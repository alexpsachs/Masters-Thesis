{
    "boennemann": "Squashed and merged, thank you \u2764 \nhttps://github.com/boennemann/semantic-release/commit/16cf9aee9b52f9539cae44d0bde256e08fc7542b\n. rebase, thanks :)\n. awesome!\n. @bcherny Thank you very much for this comment!\nFalse negatives:\nI was thinking about this stuff and what it comes down to is that whenever this method fails your test setup isn't optimal. I know that this happens a lot, but I'm not trying to fix these testing problems, but I'm trying to achieve automation for software releases that is better, or at least on par, with what the human would decide. I doubt you would recognize these breaking changes by hand, if your tests are that insufficient.\nThe way to make the automation better is to stick to best practices and that's a pretty cool thing actually.\nFalse positives:\nSame as above: in your example the tests are the problem. There are probably some scenarios where false positives would still be reported. We should add an option to pass the \"breaking change detection\" for these cases.\nI had a brief look at india, and I really like this as well. I would be more than happy if we could build both strategies, or even a combination into this.\nAlso I should probably make the breaking-change detection its own module.\n. @bcherny Thanks again for the comment. I really appreciate the discussion here :)\nI think you are raising very valid concerns.\nProbably the breaking change detection should never automatically cause a major version bump, but only raise an error that one can suppress with explicitly marking the commit as non-breaking.\nThat said I would wan't to implement this in a \"plugin\" kind of way (see #9) and I think both india and my approach would make for a great plugin for semantic-release. In the end it comes down to individual preferences and I would be happy to fulfill any of these with a modular approach :)\n. https://github.com/christophwitzko/cracks\n. @christophwitzko While I like the code I dislike the structure; there are now three libs that are almost one and the same thing (latestRelease.js (if anything this should be latest-release.js), version.js and registry.js)\nI'd prefer to have something like npm-info.js that provides the normalized info from the registry and handles all errors regarding that in this location.\nThe info is then just passed onto the type analyzer and semver.inc (or npm version see #11), which would also make the code ~~sync~~ clearer for both of these tasks.\n. Thank you so much for your patience @christophwitzko :heartbeat:\n. Either we borrow some code from npm, or just use npm version directly. We shouldn't forget to soft reset the commit that's created then, though.\n. Hey @ELLIOTTCABLE,\nthanks a lot for this issue. I'm totally up for this, but I'm super busy until mid/end next week.\nI will get back to you then.\nI hope you understand :)\nBest,\nStephan\n. Hey @ELLIOTTCABLE,\nsorry for the super long delay. I'm currently working on this and while I'm not entirely finished yet, I will give you a glance at the new API.\nYou will be able to provide a function that semantic-release will call with an array of all commits since the last version was released. This function should then return the version type, like major, minor, patch or null for no release. \njs\n[{\n  hash: '<a commit hash>',\n  message: '<the commit message>'\n}, {\u2026}]\nIs this something you could work with?\nBest,\nStephan\n. My plan is to integrate a release section into the package.json.\nYou then provide a module name or path to require, with the signature I outlined above.\nThis is what it could look like for common analyzers that could be published on npm:\njson\n\"release\": {\n  \"analyzer\": \"semantic-release-gitlabels\"\n}\nAnd this is how you would define a file that just lies around your repository.\njson\n\"release\": {\n  \"analyzer\": \"./build/release-analyzer\"\n}\nHope that makes sense ;)\n. @ELLIOTTCABLE Have fun with it: https://github.com/boennemann/semantic-release/releases/tag/v3.1.0\nWould love to get your feedback and maybe, ideally semantic-release-gitlabels-analyzer on npm :)\nNext up: custom changelog\n. I've added a hook for changelog generation now: https://github.com/boennemann/semantic-release/wiki/release-note-generation\nMaybe you could simply dump your commit messages into the log, and then go and edit them once they're published.\nI hope that's what you're looking for :)\n. Hey @bclinkinbeard,\nwhile using npm version brings shrinkwrap.json support it wouldn't bring back the version in package.json.\nThe thing is that releases happen on the CI, and as long the CI doesn't push back to your repo (which is a bad idea) the changes/commits/tags are just cleaned away.\nI'm closing this as it's a duplicate of #11 now, but I'm happy to further discuss :)\nBest,\nStephan\n. Hey Tom,\nnice catch. You're right it's 'repo/public_repo'. Do you want to send a PR?\nStephan\nOn Sat, Mar 21, 2015 at 10:42 PM, Tom Vincent notifications@github.com\nwrote:\n\nIn the CI Server set up, we need to add a GitHub OAuth token. Which scope(s) need to be selected here? I presume its just repo/public_repo, but it'd be nice to have that documented either way.\nReply to this email directly or view it on GitHub:\nhttps://github.com/boennemann/semantic-release/issues/15\n. Awesome thank you!\n. ping @christophwitzko \n. @ELLIOTTCABLE Just so I understand this correctly. Using && doesn't work on windows? If that's the case it would still be broken with the new setup/cli.\n\nHow would we work around this?\n. @johann-sonntagbauer Thanks for the clarification!\n. Hey @tlvince,\nreally cool to see you're giving semantic-release a try.\nI've looked into this and currently I have no idea where it is coming from.\nAfter the Determining new version there would need to be at least one other log message before the actual publishing (that might internally pack) happens. And even then, why would packing fail.\nCan you try clearing caches on travis and then rerun? Unfortunately that's the only starter for debugging I can give you atm. Please report back in this issue if you have found anything.\n. @tlvince \nI can reproduce this now, so it's definitely a semantic-release bug. Currently investigating where this is coming from, maybe a new npm version.\n. @tlvince Okay I think I know what's happening now.\nnpm publish starts the spinner which eats up all the log output on travis.\nBecause of this the expected 'Nothing changed. Not publishing.' simply isn't shown even though everything is fine.\nThe latest npm changed the error message a bit, so npm ERR! addLocalDirectory Could not pack is the expected output for an aborted publish. \nCan you please verify this by adding this to your travis.yml\nyml\nbefore_deploy:\n - npm config set spin false --global\n. @tlvince Thanks for checking that. This started happening only with more recent npm versions.\nI'll add a note once I'm back in my home wifi ;)\n. :+1: :sparkling_heart: \n. Fixed with: https://github.com/semantic-release/cli\n. Fixed with: https://github.com/semantic-release/cli\n. I guess this happens because you have a multi job setup. You need to use \"travis-after-all\" for this. You can copy the configuration from semantic-release itself: https://github.com/boennemann/semantic-release/blob/master/.travis.yml\n. Thanks for the issue Tom. I couldn't reproduce this yet, there are also tests for this, but there seems to indeed be a problem, as @gr2m reports the same.\nIs there anything special you're using, e.g. scoped modules? \nMaybe you can provide steps to reproduce or send me some Travis logs? :)\nSorry for the inconveniences this may have caused.\n. Thanks for checking :)\n. Also @gr2m, as noted elsewhere, you need \"travis_after_all\" for more than one node version :)\n. Thanks @stojanovic,\nthe scenario you describe doesn't make sense to me as to why it would fail, but that doesn't mean anything.\nI'll investigate this very soon.\n. I couldn't reproduce and so I think this happens when something with the setup is wrong. As the setup is super bothersome and needs a lot more thought and work I've just added a new verification that aborts the release if a version that matches /semantically-released/ is about to be published.\nSo while this shouldn't happen anymore the underlying problem still exists. The progress on this is tracked in other issues though. This is why closed again.\nThanks y'all\n. Yeah I'm sorry, this bug sneaked in when I've rewritten that part for the plugin system :/\nFixed here: https://github.com/boennemann/semantic-release/releases/tag/v3.2.2\nThanks for baring with me in this early phase :) This is really appreciated!\n. Hey @bahmutov,\nthanks for writing. You could use the verification hook, that was added in recent versions, to do this :)\nHave a look here: https://github.com/boennemann/semantic-release/wiki/verification-hook\nBest,\nStephan\n. I'd consider it a bug at this point, because If we'd use npm directly for the requests it should just work\u2122.\nThe actual problem is that testing gets even trickier, but this is high on our agenda :)\n. Sorry for the late reply, this is a very good idea and I keep thinking about how to make this right.\nMy current thinking is that it doesn't make sense to bloat semantic-release too much, so maybe a seperate cli and core would make sense, so we can build all the things\u2122 into the cli (e.g. dependencies necessary for travis and other services, argument parsers, abbrev) and have a very lean core that gets installed way more often.\nI'd like to collect ideas here, so please write down yours and feedback here.\nBest,\nStephan\n. Here we go: https://github.com/semantic-release/cli\n. @gr2m Thanks for clarifying this.\n@remy It's totally fine to skip the (<scope>) part of the commit message. Just feat: <message> etc. works.\n. @remy Sorry for the hassle here. The setup part isn't really that seamless and I'm already thinking of ways to streamline all of this.\nGenerally when there is an unwanted version I unpublish it npm unpublish whatever@1.0.10 and then manually set the latest back to the version before npm dist-tag add whatever@1.0.9 latest.\nDo you think we can close in favor of #29, or are there remaining issues that we need to sort out?\n. One thing that probably is a problem here is that the placeholder number (v0.0.0-semantically-released) must be a yet unpublished version, because npm does some checks on it that aren't too useful in our case :/\nTry changing the version inside your package.json that's checked into git to v0.0.1-semantically-released or similar. Heads up: The version inside the package.json doesn't have anything to do with what's published later on :) (well, at least that's the plan\u2026)\nI'm definitely trying to ease all of this and I'm also visiting the npm offices next month, so I have a clear idea of what makes sense for the future path.\n. With semantic-release@4 there is no more requirement for a placeholder version in the package.json, which is why these problems should ultimately go away :)\n. @remy Yeah, I enjoyed the evening a lot!\nYou can get the new version using the CLI: https://github.com/semantic-release/semantic-release#setup\nWe should chat about the bigger picture setup, once we have done that for hoodie ourselves :)\n. @remy\nnormal package: https://registry.npmjs.org/semantic-release\nscoped package: https://registry.npmjs.org/@semantic-release%2Ferror\nYou can also use the cli (which should be easiest if you want to get info about private packages)\nnpm info semantic-release --json.\nIt allows you to query individual fields:\nnpm info semantic-release versions --json\nnpm info semantic-release version --json\nnpm info semantic-release dist-tags --json\n. 0.1.0 is expected as it just uses the previously published version to determine the new one. Only if no version is present it jumps directly to 1.0.0.\nThe failed PUT looks like some problem with the npm credentials, can you double check whether they're okay? :)\n. You can now force it to 1.0.0 by adding a breaking note to a commit message. Much like async did recently: \"No known breaking changes, we are simply complying with semver from here on out.\"\nhttps://github.com/caolan/async/blob/master/CHANGELOG.md\nSimply releasing 1.0.0 for everything below it seems a bit harsh, and might come with some unintended side effects, so I'm leaving it out for now, but maybe we can do it in the future, when things are more stable and tested by more folks.\n. To be honest I haven't figured this one out yet. It's the very same request every time and sometimes GH includes the commit message, sometimes not :/\nWhat would your preferred title look like?\n. This is now set explicitly https://github.com/semantic-release/semantic-release/blob/next/src/post.js#L28\n. Thank you @janl. This will be addressed by future versions of 4.x\n. Sorry for the late reply @johann-sonntagbauer,\nI'm totally up for that and the good news is that it's already kind of pluggable, because all the post script currently does is the \"publishing to github\" part. This means writing another post hook just for gitlab is all it takes :) I'm currently running this module through a bigger rewrite, but I could reping you once that's done, so you could contribute that :)\n. @johann-sonntagbauer The rewrite is done on the next branch. Maybe you can look into it again now?\n. Thinking about this more it would probably make sense to create a \"createGitTag\" plugin for this. It has the usual plugin signature and additionally gets passed the object the github.createRelease function receives right now. That way we could implement a bitbucket, gitlab, raw git strategy, etc.\n. @ariporad I don't get what's different from your proposal and the current plan?\n\"getLastRelease\" is your proposed \"publish\" plugin, while \"createGitTag\" is \"release\".\nWe can discuss the \"createGitTag\" name though :)\n. @johann-sonntagbauer \nWhat do you mean by \"github notation\"? Can you point me to the code you're talking about?\nTotally up for relaxing the URL thing!\nWhen it comes to the NPM_TOKEN \u2013 this a security feature. npm does not automatically ignore .npmrc files, which means if it's already in there in clear text it will publish that to the registry, which I just want to restrict in any case. If you're already using the environment variable notation you might as well change the variable name to NPM_TOKEN (but we could also talk about how to make name of the env variable dynamic if that's a concern). \n. @johann-sonntagbauer \ndependencies:\nThese aren't loaded from GitHub, they're scoped packages: https://docs.npmjs.com/misc/scope\nrepository url\nI think we could make the repository url another verifyConditions plugin and just set travis and that in series as a default.\nruntime for calling plugins in sequence\nI like the idea and that's definitely where we're already headed, but I'd like to avoid making changes to this extent in one go and rather implement them one after another, as soon as the need for each individual hook arises.\n. fixed with 4.x\n. Pinging a few people that I think could be interested (also feedback would be cool :))\n@christophwitzko @janl @gr2m @othiym23 @rmehner @remy @tlvince \n. @rmehner @gr2m This sounded way to bold. Doing it on our own essentially means setting an encrypted env var with the npm token, creating an ~/.npmrc and running npm publish on after_success. (npm@^2.0.0 required)\nThe ~/.npmrc\nregistry=https://registry.npmjs.org/\n//registry.npmjs.org/:_authToken=${NPM_TOKEN}\nI want to build this for semantic-release first, so there are no blockers. I am more than happy to bring this back to Travis then. (Same goes for the npm team, as they want to get rid of the old token). The dpl tool is open source anyway: https://github.com/travis-ci/dpl/blob/master/lib/dpl/provider/npm.rb\n. At first sight this seems like a setup issue for me. If the request to the registry fails it assumes version 1.0.0, which is why it worked for the first time, but not now, for the second time. I'll try and figure out where the problem is.\n. Okay I've looked into it now and it seems like the npm credentials aren't setup correctly. Can you try doing the setup again there?\n(Sooooorrrrryyy, a solution is in sight: github.com/semantic-release/core)\n. Thanks for the report, I'm investigating this now.\n. Okay given that the npm credentials were correctly setup for releasing 1.0.0 this indeed seems to be a regression (also the same and real reason for #45).\n1.1.0 should have been released for 73032331d9fcece165e10a1816fe3de93ab9cd0e, and as you only pushed on 61fa7cf86528e04f4c556b4f06e472770dbc1123 it should've happened there.\n74a84ce4ec9351e00d40b1f0d2daef8bdd12e887 breaks it for real though, so please revert that.\nThe only recent change that messed with this logic is this 3.4.0 https://github.com/boennemann/semantic-release/releases/tag/v3.4.0 (cc @christophwitzko).\nCan you please pin the semantic-release dependency to 3.3.2 https://github.com/boennemann/semantic-release/releases/tag/v3.3.2 and tell me if it works then?\nThanks for your patience,\nStephan\n. @christophwitzko Do you think is related to the private module support? Can we add npm-registry-client as a quick fix here?\n. Alright In the meantime I've moved the latest tag on npm back to version 3.3.2 so the problematic version will no longer be installed by default. We're still looking for a fix here.\n. We won't fix this in the 3.x range. 4.x is due very soon.\n. The repo url in your package.json is malformed: https://github.com/eHealthAfrica/joffrey-bootstrap/blob/master/package.json#L13\nUse one of the supported formats by npm/the used parser: https://www.npmjs.com/package/parse-github-repo-url\nI will add a step that not only checks for presence, but the right url format to semantic-release@next\n. What npm version are you running on? They always look this for me: git+https://github.com/semantic-release/core.git\n. No noise, I could add a very helpful error message just because of this :+1: \n. @lewiscowper Thanks a lot! :tada: \n. The error is happening when extracting the commits: https://github.com/semantic-release/semantic-release/blob/next/src/lib/commits.js\nI think there are more reasons why this could fail, so it would be better to explicitly test if the hash is in the history first. git branch -a --contains ${hash}\n(I haven't fully thought this through, but maybe this also opens up the opportunity to recover from this error by checking if a git tag with the same version number, but a different hash, exists. We could try to parse again from there.)\nDo you want to send a PR for this (ignore the git tag thing for now), or should I do it once there is some time left?\n. I've now added the helpful error message: https://github.com/semantic-release/semantic-release/commit/5cc7da6035e22660848c7960c9d18e6df1b7b0eb#diff-c82ff4edea7a03060298416c6d869999R29\nI figured \"recovering\" from the error is not reliably doable.\n. Hey @ariporad, thanks for your interest in semantic-release and this issue.\nIf I understand that correctly both you're client and server are individual packages. Maybe you can try to publish them as (private) npm packages using semantic-release, and then deploy your top-level app that pulls both of them together, whenever a new version gets published.\nWe are currently experimenting with ideas on how to bring this to applications ourselves and we will share our findings as soon as we have them.\nThanks again,\nStephan\n. @ariporad Unfortunately such a thing doesn't exist yet, but I'd be very happy if you could share your thoughts so far in this issue :)\nI'll try to come up with a discussion platform and more general information soon-ish.\n. @claudiocro \nFirst of all: Because you were talking about having client and server packages. Would it be feasible to have both of these as a private npm package, or hosted on an enterprise registry, and then pull them together into your app and deploy them to your server?\n\nAre you planing to abstract this dependency to that other provider / solutions could be used?\n\nEven though this module/repo is currently called semantic-release, in my thinking this is more like semantic-release-npm, while semantic-release itself is a concept that can be applied to a lot of package managers, providers and other solutions. E.g. there are already solutions popping up for python, gitflow etc.\nTime is very limited for me right now, but I'm trying two things.\n1. Implement, document and share an architecture model to release and deploy full node apps with semantic-release\n2. Write content for semantic-release.org, where we define what the core principles of are, so that it's easy to implement this for any given ecosystem.\n. @claudiocro Awesome! Yes I can generally recommend to use the next branch, as its pretty much stable already. Here is the roadmap of things we want to add before moving it over to latest: https://github.com/semantic-release/semantic-release/issues/52\n. @ariporad is now working on an alternative git-only implementation, which should make things flexible enough to work with almost anything. If that isn't enough you can still use the about to be created \"getLastRelease\" hook to implement the logic entirely on your own. This should fully address this issue, so I'm closing. You can track the progress here: https://github.com/semantic-release/semantic-release/issues/56\n. @ariporad semantic-release already creates a git tag for you. If you would want to publish using git this is how it would work:\nIn your package.json instead of \n\"scripts\": {\n  \"semantic-release\": \"semantic-release pre && npm publish && semantic-release post\"\n}\n\"scripts\": {\n  \"semantic-release\": \"semantic-release pre && semantic-release post\"\n}\nThis way you'd always get a git tag for every relevant change. You could then use Travis's Deployment Tasks to perform certain actions once a tag was created: heroku, aws, modulus, custom script, \u2026\nIf that doesn't cover what you were asking for please let me know and I'm happy to reopen :)\n. @gr2m Doing a quick github code search gives me the impression that that's not really worth the effort. The existing migration guide is also pretty straight forward, I hope? :)\n. @ariporad Unfortunately they didn't. Always some weird issue with getting CouchDB to start.\n. I got more and more error reports, because people were installing the 3.x branch. I've now moved 4.2.1 over to latest earlier to get this problem out of the way.\nI'll further develop on next and will cherry-pick features and fixes onto master, until I'm confident to release 5.x as latest.\n. https://github.com/semantic-release/semantic-release/commit/2b284fcc9043744c85ea75b40de72e84585a4272\n. This is something I'd love to see. We could introduce another plugin hook \"getLastRelease\", leave the current implementation as default, and provide a git-tag based implementation.\nAnyone up for tackling this one?\n. @ariporad This sounds fantastic, do you want to chat about it some more on gitter first?\n. Alright, @ariporad will take a stab at implementing this :+1: \n1. [x] Add a \"getLastRelease\" plugin hook to semantic-release\n2. [x] Move lib/last-release.js to https://github.com/semantic-release/last-release-npm and make it the default\n3. [ ] Implement https://github.com/semantic-release/last-release-git-tag\n:tada: \n. Thank you @ariporad,\nthis landed as https://github.com/semantic-release/semantic-release/commit/7ceac766892b6f4c311582efcdd3a2c86ae3dad2 and got published as 4.1.0.\n. Awesome! Noticed that I forgot it and now I've got the PR in before I could fix it :sparkling_heart:\n. Sorry this was auto closed because I renamed the default branch, can you send this again please?\n. Thanks for catching this very nasty bug! I didn't realize nested stubbing isn't possible, but after reading the docs it makes a lot of sense.\nI addressed this now by wrapping the proxyquire calls into each other: https://github.com/semantic-release/semantic-release/commit/5cc7da6035e22660848c7960c9d18e6df1b7b0eb#diff-b2fc167aa2bf97d4559ff48a142cf3e4R6\n. The cli exposes itself as semantic-release-cli, to avoid confusion with the semantic-release core package, which is available as semantic-release. Unless I'm missing something the docs are correct the way they are :) But you're right, the CLI screenshot needs an update, w/o the info logs, and w/o passwords :)\n. The semantic-release core used to have a setup command in older versions. I seems like you're running this old version globally installed. We've split that out, to keep the core as small as possible.\nThe CLI definitely exposes itself as semantic-release-cli https://github.com/semantic-release/cli/blob/master/package.json#L6\nI'm confused as to why npm install -g semantic-release-cli doesn't give you that executable.\nCan you run which semantic-release, or uninstall semantic-release globally and then only install npm i -g semantic-release-cli again. Also what's npm -v?\nThanks for your help!\n. @kentcdodds Thanks for clarifying. To me this looks like the first time you didn't npm install -g semantic-release-cli, but npm install -g semantic-release. You then ended up with the \"old\" semantic-release as a global install, which also has a setup command. I say \"old\", but it's still the \"latest\" semantic-release, because I want to address some more things in the current \"next\" branch before moving them over.\nGlad it's working now :+1: \n. Just to document this here: 4.x is now on the \"latest\" dist-tag, which means this should no longer happen in the future :)\n. Using the default setup it doesn't mark the build as failed, because, the actual build passed.\nIf you desire a different behavior you could remove - npm run semantic-release from the .travis.yml's after_success section and add \nyml\nscript:\n- npm test && npm run semantic-release\nBe prepared for a lot of failed builds though, e.g. every PR or non-master build.\n. @lapanoid Thanks for reporting this. Having a look at your package.json showed that you're running semantic-release@3.x, which isn't compatible with the way the cli sets up your tokens and auth. This is why the cli automatically installs the 4.x, or \"next\" branch of semantic-release.\nUpdating semantic-release to ^4.1.1 in you package.json should immediately fix this.\nPlease report back :)\nBest,\nStephan\n. Just to document this here: 4.x is now on the \"latest\" dist-tag, which means this should no longer happen in the future :)\n. :+1: Thanks for letting us know :)\n. @bahmutov Awesome, thank you!\n. Hey @accraze, \nsorry this slipped through my notifications. Do you need any guidance? I'm happy to help you to get this going :)\nBest,\nStephan\n. Here you go: https://github.com/semantic-release/condition-nsp\nThank you!\n. Here are several open things and I'll try to address these now :)\n- I think it makes sense to run this only at release time and not during pre-commit, because this is exactly where it is relevant. Enforcing passing tests/sufficient coverage at commit time makes it impossible to push WIP things and let them run on CI, you can't push failing tests to prove they're failing, this is unfriendly for newcomers, who might get hindered from sending a PR in the first place etc.\n- Istanbul already has this built in:\n```\nAvailable commands are:\n  check-coverage\n          checks overall/per-file coverage against thresholds from coverage\n          JSON files. Exits 1 if thresholds are not met, 0 otherwise\n\n```\nhttps://github.com/gotwarlost/istanbul#the-command-line\n- At this point I'm wondering if it makes sense to only implement a  run-script plugin (#69) instead, because of how straight forward istanbul check-coverage already is\n- If the  verifyConditions callback gets an error passed as the first argument it is considered a failure\n- I'm thinking of building a mechanism where the results of the verification get attached to the commit via the GitHub status API.\nBest,\nStephan\n. @satya164 nyc uses istanbul under the hood, so this will work with coverage reports nyc has reported, too.\n. @remy Thanks for the idea, genius :+1: \n@ariporad Thanks for picking it up. Here you go, just PR it in :) https://github.com/semantic-release/condition-run-script\n. Landed as of 4.2.0 :) https://github.com/semantic-release/semantic-release/releases/tag/v4.2.0\n. @gr2m It should be easy to add the npm tarball, or any arbitrary file really, because we just need to pass it to the github.repos.createRelease method.\nI'll think about how to make that configurable.\n. Hey @quarterto,\nthis is entirely on purpose because we're still running semantic-release pre && npm publish && semantic-release post in series. If it weren't for process.exit(1) then npm publish would get executed next, which probably has some very unintended side effects. Unfortunately there is no way for us to fail an npm script without the verbose error log at the end.\nBest,\nStephan \n. Yeah, nice, looks like a good solution to get a version-preview command :+1: \n. Wow these tools are all very nice :+1: Would someone mind adding them to the readme via a PR?\n. Thank you @johann-sonntagbauer,\nI'm currently moving into a new apartment and I'll be at nodeconfeu next week, so please bare with me a bit longer until I can review and merge this. \nThank you :) :+1: \n. I've now reviewed this and I like the general direction. I made some inline comments.\n. Unfortunately we can't clean this file up before publish, because npm needs it during publish. The best solution would be to store the .npmrc file outside of the package folder, but we don't have sufficient permissions to do so on e.g. travis. The easiest workaround for this is adding .npmrc to your .npmignore file.\n. Hey @eliias,\nvery neat solution. I just want to make sure the name isn't confusing before merging this in.\nIs it obvious enough that the global \"prelease\" option only affects the GitHub Release part?\nAlso as we were thinking of making the whole github-release part a plugin anyways would it make sense to create this plugin step now and pass \"prerelease\" to that plugin instead.\nBest,\nStephan\n. Any reason this won't work for you? (I split it up for readability)\njson\n\"scripts\": {\n  \"prepublish\": \"npm run build\",\n  \"presemantic-release\": \"semantic-release pre\",\n  \"semantic-release\": \"npm publish && npm run publish:latest\",\n  \"postsemantic-release\": \"semantic-release post\"\n}\nIf you want to expose the version number into the build just read it from the package.json, but fallback to \"0.0.0-development\" (or similar) if it isn't present. That way you can just make it part of the build script and have it work as expected for builds that are about to be distributed.\n. Hey @apowers313,\nthanks for reporting this. Turns out this just revealed a bug in the way the commits were extracted.\nThe commit hash not even being in the history is a source for a lot of confusion and problems, which is why I added the git branch --contains check in the first place. The bug is that I was assuming an empty stdout in this case, while in reality this also fails the command. The error shouldn't abort the flow, but be expected here: https://github.com/semantic-release/semantic-release/blob/caribou/src/lib/commits.js#L15\nSo assuming this bug wouldn't have existed when you tried this out the output would have been this:\n\nThe commit the last release of this package was derived from is no longer\nin the direct history of the \"${branch}\" branch.\nThis means semantic-release can not extract the commits between now and then.\nThis is usually caused by force pushing or releasing from an unrelated branch.\nYou can recover from this error by publishing manually or restoring\nthe commit \"${from}\".\n\nI think this could've already been helpful, but we can easily add to the error message:\n\nThis is usually caused by force pushing, releasing from an unrelated branch, or using an already existing package name.\n\nGiven that the \"last-release\" part is now a plugin, we can no longer assume any information other than the commit-ish.\nDo you think fixing the bug and modifying the error message is a sufficient way of dealing with this?\n. The fix landed in 4.3.5 and 6.0.2 respectively :+1: \n. Thank you! Landed here: https://github.com/semantic-release/semantic-release/commit/81de8ae19b3263d70b8c09b8c78d679d47e48146\n. Adding an result/error hook is a very good idea. I think if we just add that people can develop their own small plugins that post the data somewhere in the right format.\nI'm happy to assist contributors to implement this, or I hope to get to this out sometime soon. I'll leave this issue open so people can grab it.\n. This is a limitation with travis-after-all, so I've opened an issue there: https://github.com/alrra/travis-after-all/issues/6\n. Fixed via v6.3.2\n. Thanks for reporting this, a fix landed here: https://github.com/semantic-release/cli/releases/tag/v1.1.5\nBest,\nStephan\n. Yep, it's a mistake. Thanks for catching :)\n. If by \"beta\" you mean sth. like 1.0.0-beta.1 the default analyzeCommit plugin doesn't support them out of the box. If you find some heuristics on whether to publish those you can implement this though: https://github.com/semantic-release/semantic-release#analyzecommits\nEven though this possible with your own plugin I'd strongly discourage you from using \"beta versions\". semantic-release has support for release-channels (https://github.com/semantic-release/semantic-release#how-does-it-work 3rd paragraph) by adding \"publishConfig\": {\"tag\": \"next\"} to your package.json. This is a way better mechanism to communicate stability.\nBest,\nStephan\n. I just published a new version of the condition-travis plugin that is responsible for these error messages: https://github.com/semantic-release/condition-travis/commit/be5386e3\nI think this should make things much clearer, but I'm happy to get some feedback/contributions so we can make them even better.\nBest,\nStephan\n. Hey @SteveALee,\nthis indeed coupled to npm very tightly. We were able to offer a last-release hook though, so this could potentially be solely based on git tags.\nThere is a work in progress implementation here: https://github.com/semantic-release/last-release-git-tag\nBest,\nStephan\n. @christophwitzko Can you look into this?\n. @alejandronanez Ah, nice, thanks for catching that :) I'm closing this in favor of an issue on the CLI repo:\nhttps://github.com/semantic-release/cli/issues/38\n. I agree that it should do that. If someone would like to give this a try I'm happy to accept contributions for it and help with any questions along the way.\nThis might be another relevant package: https://github.com/npm/normalize-package-data\nBest,\nStephan\n. Thanks, landed here: https://github.com/semantic-release/semantic-release/commit/de4bd7750e9d52779cde767a80f4dc91e2e41544\n. From Gitter\n\njohann-sonntagbauer Oct 08 07:53\n@olalonde Hi yes it is possible to execute semantic-release from your local machine. The internal plugin pipeline is configured and optimised for the github like setup. therefor travis preconditions are checked in default setup. You can change/influence that with configuration. That config has to be put in package.json, or can be applied through command line.\nplease try the following: add the config into your package.json\njson{\n  \"release\": {\n    \"verifyConditions\": {\n      \"path\": \"./plugin-noop\"\n    }\n}```\n. Hey @olalonde,\n\nthanks for taking the time to send a pull request and sorry for taking so long to answer.\nThe philosophy of this project is to not bother anyone with versions or types, which is why we haven't and won't expose them.\nI see that you want to reuse this with another script and don't want to use the rest of semantic-release. I'm happy to tell you that there is dedicated module that does exactly what you want: conventional-recommended-bump\nThanks a lot for your patience and time. If you have ideas for improvement in the future please reach out in the Gitter chat first, so we can avoid unnecessary work.\nBest,\nStephan\n. Hey,\nthanks for the report. It don't know much about your system, but it seems like keytar is incompatible with it somehow. Maybe there is something on how to fix this in their issue tracker?\nI think to prevent this from happening in the first place we should make keytar an optinal dependency of this CLI so people can continue using semantic-release even if there are some problems with the native extensions.\nPlease let me know if you find anything.\nBest,\nStephan\n. Hey @ds82,\nif you have development workflows that require a version number you can just put something there, e.g. \"version\": \"0.0.0-development\". During publish time the placeholder will be overridden anyway.\nBest,\nStephan\n. Hey @mdreizin,\nI couldn't find any logs like this in the Travis build you linked to. Looking at your releases it seems like it's working now.\nShould you have any more questions please join our Gitter room.\nThanks for trying semantic-release,\nStephan\n. Hey @lapanoid,\nthis is possible by implementing an alternative \"getLastRelease\" plugin. You could base it on git tags to fully decouple semantic-release from npm.\nBest,\nStephan\nhttps://github.com/semantic-release/semantic-release/issues/56\n. Since semantic-release-cli >= 2 keytar is an optionalDependency, so it still works if keytar fails to compile. That fixes this issue.\n. Hey David,\nthis error can only ever happen if you force push, or start publishing from an unrelated branch/repo. Force-pushing is something that shouldn't happen on your default branch in the first place, especially for commits you have already derived releases from.\nGitHub added a new feature called protected branches that can prevent you from doing that in the future. Unless you know 100% what you're doing with git (spoiler: no one does) I'd suggest enabling this for every project \u2013 and don't forget the \"enable for administrators too\" checkbox.\n\nYou can recover from this error by publishing manually or restoring the commit \"8445b3f61069ed9224e6704c758574a7e573ac0e\".\n\nJust as the error message suggests you either have to restore the commit in question (requires another force push), or do one manual release. \nI know that once you are in this place (been there, too \ud83d\ude4a) it's painful to recover, but I currently don't have the time to build extra recovery tooling around this \u2013 plus I don't want to introduce manual publishing mechanisms to semantic-release ever. Because of this I'm strongly recommending the prevention measures and I've added the lengthy error message.\n\nI don't quite know what's the best way to recover from this.\n\nIf I had a \"best way\" to recover I would have added it to the error message. Both ways are painful. If you come across one that's cool, or if you want to contribute a better step by step guide I'm happy to merge that.\nBest,\nStephan\n. @Starefossen There are some work in progress efforts on a git-tag based implementation https://github.com/semantic-release/last-release-git-tag\n. Hey all, \nthanks for the report. Just looking at this, it looks like Travis has some issues with their API, or changed their endpoints. This blogpost suggests something in that direction.\nWe'll investigate and see if we can fix this from our side, or if Travis needs to reenable their Endpoint.\nBest,\nStephan\n. Also summoning the semantic-release cli maintainer @christophwitzko  ;)\n. This is working again, thanks so much @bahmutov.\nhttps://github.com/semantic-release/cli/releases/tag/v1.3.3\n. Hey @bahmutov,\nexactly, this caused by multiple Travis jobs running and publishing at the same time. You can prevent this from happening by using travis_after_all like so: https://github.com/semantic-release/cli/blob/master/.travis.yml#L31-L33\nIf you chose multiple node versions with the cli it sets it up for you and with future versions of semantic-release this going to be implemented in JS and bundled with semantic-release.\nBest,\nStephan\n. Hey @matheussampaio,\nfor a setup like this you would just change the package.json to whatever you need on the respective branches. For example with semantic-release I have the current \"latest\" on the \"badger\" branch and I just set it up in the package.json, while my \"next\" channel lives on the \"caribou\" branch, where that is set up in the package.json as well.\nWhenever I want to backport non-breaking features/fixes from caribou to badger I cherry-pick them. If you want to move a version from \"next\" to \"latest\" you do that by changing the tag using npm dist-tag.\nI hope that helps. If you have any further question I'm happy to help.\nBest,\nStephan\n. Hey Gleb,\nthis is supported for verification plugins as of 4.2.0. You simply pass the plugins as an array (https://github.com/semantic-release/semantic-release/commit/700ec9d4).\nBest,\nStephan\n. Hey @bahmutov,\nbecause it's so tightly coupled to npm I just made it inherit the npm loglevel.\nThe way I do this with Travis is to set the environment variable npm_config_loglevel=verbose and let the build run again.\nLet me know how the private npm registry goes!\nBest,\nStephan\n. I would love to see support for GHE.\nI think we can remove the parse-github-repo-url check altogether, as that's also required for the GitLab PR to work #77.\nGood to know that a pathPrefix is required for the node-github library. That should be added as an option.\nHappy to accept PRs for this :)\n. Hey @tthew,\nthere is a gist that describes this: https://gist.github.com/boennemann/54042374e49c7ade8910\nLet me know if that works for you.\nBest,\nStephan\n. Awesome, thank you :)\n. Hey @hbetts,\nsorry for the outstanding review. I'm currently trying to rethink the way semantic-release could work, especially it's architecture and plugin system. See https://gist.github.com/boennemann/ac06b7f8bcf50510ffa1 for some thoughts.\nI can't find anything bad with your PR, but I'm a little hesitant to merge it, without knowing whether that's the right direction in general. Like, I don't want to introduce a new feature that I'm already thinking of deprecating.\nI'm really sorry, because I currently don't have the time this project would deserve and need, to move forward on these ideas, but I'm trying to get back to it as soon as I possibly can.\nBest,\nStephan\n. Hey @hbetts,\nI saw you opened a few issues and PRs and, even though it might not be the most satisfying answer, I'll try my best to review them after the holidays. I'm super sorry, but I currently don't have the time I'd like to have to document all of these things.\nI'm trying to find a better way to maintain semantic-release, especially by it being a group effort. I've written a few thoughts down here: https://github.com/semantic-release/project-management/issues/1 and I'll try to address them, and reach out to people, in the new year.\nAll the best and thanks so much for your contributions,\nStephan\n. The semantic-release-cli operates on existing projects. I looks like there is no package.json present in your current folder.\nShould this keep failing for you, even with a package.json please reopen this issue on the cli repo's issue tracker: https://github.com/semantic-release/cli\nThank you!\n. It looks like that there is no TravisCI account existing, but I agree that the error message isn't very helpful. Please reopen this on CLI https://github.com/semantic-release/cli so we can address it there.\nThanks for your reports.\n. @tlvince Yeah seems like it to me. When last-release runs the other versions aren't released yet.\nI'd suggest using the update branch button, or rebasing against the master branch first. That way you'll also get separate test runs for the combination of PRs, to make sure they're working together. Maybe look into GitHub's required status checks, which will enforce this.\nI'm closing this here, because I think it's not a problem semantic-release can or should solve (in core).\nI'm considering enabling protected branches/required status checks by default using the new API and making that part of the CLI.\nThanks for the report!\n. Thanks for this @bahmutov. Just to clarify, merging this would also fix #114, right?\n. Thanks @bahmutov! Landed here https://github.com/semantic-release/semantic-release/commit/66454e7e46d32b00bb597a4eeac05036cad8dda8\n. Hey @colinmeinke,\nthanks for trying semantic-release. It appears to me that this is because you're having the lib folder in your .gitignore file. Try adding an additonal .npmignore file like this: \n/src\n/test\n/node_modules\nor alternatively a \"files\" filed in your package.json:\njson\n...\n\"files\": [\n  \"lib\"\n]\nAfter this npm will pick up your built files. You can verify if this is working correctly by running npm pack, which will create the tarball that would get sent to the registry.\nBest,\nStephan\n. Thank you!\n. Thanks @hbetts,\ndo you know what exactly changed since npmconf was merged back into npm?\nI know it's not too cool that npmconf is deprecated, but the programmatic npm API is unsupported as well.\nThis means on top of requiring the entire npm client, we would have to pin it down and review every version update \u2013 and they happen about every week.\nI'm a bit puzzled, and I don't know which of theses two unsatisfying ways is the better one :/\nBest,\nStephan\n. Flaky integration tests \\o/\n. semantic-release-cli >= 2 set's it to the placeholder \"0.0.0-development\"\n. Hey @RWOverdijk,\nthe CLI only uploads the tokens if you chose the TravisCI option. It seems like you didn't do that, because they were logged to the terminal instead.\nThe Travis log also doesn't show that these variables get declared.\nPlease upload the tokens manually, or rerun the cli flow while choosing the TravisCI option.\nBest,\nStephan\n. Ahh, sorry. Now I see where this is coming from. This is a Pull Request build and encrypted environment variables aren't exposed to those by Travis.\nEverything should be fine on branches, especially on your master branch where releases will happen.\nBest,\nStephan\n. If you can see the two tokens created here https://travis-ci.org/SpoonX/aurelia-api/settings, then everything should be working fine after the merge :)\n. Hey @RWOverdijk,\nwhile this part is definitely working, GitHubs error messages aren't really helpful. My first guess is that the GitHub token is not uploaded correctly/invalid/doesn't have the right access to the repository.\nPlease verify manually that the token is working so we can at least rule that out.\nThanks,\nStephan\n. Are you sure the local branch is exactly the same as the one running on Travis?\nThis error is usually caused by force-pushing, see: https://github.com/semantic-release/semantic-release/issues/132\n. Amazing find by @finnp :+1: :100: Thanks so much.\nFixed version about to land as 6.2.1.\n. Here is a quick-solution that is probably unrelated to the underlying problem you want to fix.\nRun coverage for every build, coveralls correctly handles that :)\nThe BUILD_LEADER variable was originally set by the python script travis_after_all, while the js version that is used in \"next\" does no longer set it.\nI'll leave this open if someone wants to add it.\n. thanks :)\n. Fixed via https://github.com/semantic-release/semantic-release/releases/tag/v6.3.2\n. Thank you! Looks good.\n. Both of the problems are fixed with the latest versions of semantic-release (6.3.2) and the cli (3.0.0).\n. Thank you :)\n. Thanks for the explaining this @woshilapin. My explanation for this was buried in the 6.0.0 release notes.\nsemantic-release 6.3.2 is now on latest. It depends on travis-deploy-once instead of travis_after_all, or travis-after-all. You have to remove the python script from the travis file to get this to work.\nThe CLI now sets this up correctly, too.\n. Doesn't look right indeed.\nWhat happens if you run npm run semantic-release locally? (runs in debug mode automatically)\n. That's the expected output, because it was run locally ;)\nBut did it detect a new version before that? Maybe just send me the entire output/screenshot, so I can have a look :)\n. Okay so npm info case-converter gitHead returns 1ec9488803ff8f1845b07a949908fde13bc84e63, which is your latest commit: https://github.com/travelperk/case-converter/commit/1ec9488803ff8f1845b07a949908fde13bc84e63.\nsemantic-release uses this information from the npm registry to find the differing commits. \nYour manual release might have fixed things now, even though I'm still not sure what's been broken.\nIf you do git commit -m 'fix: dummy commit' --allow-empty on your master branch and then run npm run semantic-release right after that it should now correctly detect a new patch release.\nCan you confirm this?\nRun git reset HEAD^ to remove this test commit again.\n. Thank you!\n. Sorry missed this. Re-ran. 6.3.1 is out there.\n. Hey @cdaringe,\nthis is totally possible and here is how: https://gist.github.com/boennemann/54042374e49c7ade8910\nThanks,\nStephan\n. Fixed via https://github.com/semantic-release/semantic-release/releases/tag/v6.3.2 and https://github.com/semantic-release/cli/releases/tag/v2.0.0\n. Great catch, thank you!. Thank you \ud83c\udf89 . Hey @umireon,\nthanks for digging into this detail, I really like it \ud83d\udc4d \nI'm happy to merge this, but I don't think that first creating and then editing the release is the most elegant solution.\nWhat do you think about first using the git data API to create a tag at the specified hash and then use the release API to create a release from that tag, including the release notes?\nBest,\nStephan\n. Thank you!. Hey @thekalinga,\nthanks for opening this issue. I'm happy to tell you that this use case is entirely covered by semantic-release.\nThis gist (also linked in the README) contains the steps required to set it up: https://gist.github.com/boennemann/54042374e49c7ade8910\nBest,\nStephan\n. Sorry for neglecting semantic-release in the past and thanks @gr2m for stepping in.\nHappy to see progress in here \ud83d\udc96. @vanduynslagerp @gr2m I still conceptually like travis-deploy-once better, because it's zero config on Travis (Pro). We can however think about making it possible to use build stages for more complex setups in the future.\n@gr2m Updated the comments, thanks for the hints. I suggest we leave the comments about \"build leader\" in until we can merge a travis-deploy-once that's capable of auto choosing the leader.. Alrighty, I went ahead and added node 8 detection into travis-deploy-once https://github.com/semantic-release/travis-deploy-once/pull/7\nOnce we have that released we can add it here, and make this change even less likely to break end-users.. Sorry for this. 7.0.2 is now published as latest.\nnpm install semantic-release or npm install semantic-release@latest will work now.. Thank you @pvdlg for this very detailed write up.\nThis topic is something that I thought about before. Especially with all the concerns and security issues you're listing here I think it's a good idea/first step to think of this whole project as a collection of tools that are as loosely coupled as possible.\nFortunately the GitHub API offers a matching paradigm for this: Deployments\n(I think when building a GitHub App it's fine to build on a concept exclusive to GitHub for now)\n\nDeployments are a request for a specific ref (branch, SHA, tag) to be deployed. GitHub then dispatches deployment events that external services can listen for and act on. This enables developers and organizations to build loosely-coupled tooling around deployments, without having to worry about implementation details of delivering different types of applications (e.g., web, native).\n\nBased on this it could be a nice first step to build a GitHub App, which automatically creates a deployment event, whenever a new release is due.\nIn a second step the same app could create a GitHub release with the changelog as soon as a successful deployment_status event is triggered.\nAll of this should be possible without the need to run custom code or plugins, to clone repos etc.\nAlso it does not require any storage solution as all the state should be inside the GitHub repo (commits/messages, tags). It will probably become a lot trickier with release-channels/dist-tags though.\nOnce this is done we can think about how to get from the deployment to the deployment_status=success event.\nThere are several ways to get there (and using the deployments paradigm everyone could build their own way, independent of programming language, ecosystem or package registry/deployment target). Let me illustrate one:\n\n\nAnother (or the same) GitHub App listens to the deployments event and pushes a release commit to GitHub. This could happen in the traditional pre semantic-release way, in a sense that this commit changes the version number in the package.json, updates a CHANGELOG.md, whatever we want. This commit will be tagged with the version number.\n\n\nThe CI (e.g. Travis) is configured to perform a publish step (e.g. npm publish) whenever a tag with the semver-pattern is pushed. (Funny enough this is also the traditional pre semantic-release way). This would also enable manual release commits quite easily. I didn't think that's desirable at first, but imagine a tool that you can use locally. It checks for pending deployments and automatically creates the changes and commits them for you. Because that happens locally the git commit can be signed by the maintainer \u2013 something semantic-release currently lacks.\n\n\n3a. After the publish step the CI will create deployment_status event via the GitHub API.\n3b. An App will listen to npm (or any other) registry webhooks and create the deployment_status event as soon as a new npm package was published. (With this solution the CI env wouldn't even require a GH_TOKEN anymore)\nAnother way could be this:\n\nAnother (or the same) GitHub App listens to the deployments event and uses the CI (e.g. Travis) API to trigger a custom build, which executes the publish step and so on.\n\nAs I said before: how to get from deployment to deployment_status=success could totally be up to the user and that's a very powerful thing \u2013 circumnavigating all the security issues in the first place. This doesn't mean that there couldn't be a powerful default strategy, like pushing a tagged release commit and a CI tool to update the deployment_status.\nWhat are your thoughts on this @pvdlg?\nI think this also addresses @felixfbecker's feedback, as the GitHub App would then have the clear purpose of providing semantic deployment events and changelogs for the repository, without trying to be a CI tool. Existing CI infrastructure can easily be used to do the job it's good at.\nEssentially this GitHub App's primary purpose is to define when a release happens, and to document the changes it contains (i.e. why). The how is someone else's problem.\n. GitHub API returning returning random errors and requiring 1sec delay sounds awfully similar to the problems Greenkeeper runs into.\nReferencing the solutions for the very same problems:\nretry: https://github.com/greenkeeperio/greenkeeper/blob/e3b2ec236139c0202df840f33187d75deca9222e/lib/github.js#L6-L27\n1sec delay: https://github.com/greenkeeperio/greenkeeper/blob/e3b2ec236139c0202df840f33187d75deca9222e/lib/github-queue.js\ntl;dr require('promise-retry') / require('promise-queue')\n. @pvdlg @gr2m Thanks for your feedback!\nI removed the npm i -g semantic-release part completely, as per @pvdlg's comment.\nI added an FAQ entry \"What is npx\" and linked it up, also in the installation section where we recommend npx to install node@8.\nHope this works now :) . I'm so eager to get this out, I even added Yarn instructions \ud83d\ude48 . > It's probably because the package name you are trying to publish has already been used by someone else.\nNote that also publishes fail if the names are too similar. E.g. if bob.js exists, you can't publish bobjs. standard: Use JavaScript Standard Style (https://github.com/feross/standard)\n  /home/travis/build/boennemann/semantic-release/src/setup.js:30:70: Extra semicolon.\n;)\n. Oh nice to know thanks. I'll backport this then after I'm done with the tests.\nArgh this PR is so huge already :grimacing: \n. I'm all for it, if we have a reason. E.g. for security we could enforce sha512 hashes when publishing.\nBut this package.json entry doesn't really do much, so we'd have to write some additional code first. I'd do all of this in a separate step. . Btw, by enforcing node8 npm5 becomes the de facto min npm version \u2013 unless people explicitly downgrade.. ",
    "christophwitzko": "Thanks! :+1: \n. this sounds pretty awesome! :+1: \n. @boennemann i am on it!\n. Thank you! :ok_hand: \n. Hi @johann-sonntagbauer,\nthis should be fixed in git-refs@1.1.3.\nIt would be awesome if you could try to reproduce the problem again.\nregards\nChristoph\n. @johann-sonntagbauer cool, thank you :relaxed: :+1: \n. rebase, thanks :smile: \n. Thanks :+1:\n. :revolving_hearts:\n. Hi @dbkaplun,\nthe default analyzer handles the AngularJS commit message conventions like this:\n| commit type | version type |\n| --- | --- |\n| commit message contains BREAKING CHANGE: | major |\n| feat | minor |\n| fix | patch |\nYou can find the full description of the AngularJS commit message conventions in the wiki. There is also an explanation on how to write your own commit message analyzer.\nhave a nice day\nChristoph\n. LGTM :+1: \n. That's awesome. :+1:\nMaybe we should add the link to the travis profile? https://travis-ci.org/profile\n. Thank you very much. :relaxed: \n. Hi @apowers313,\nthere is no need to add semantic-release-cli to your devDependencies.\nThe semantic-release-cli is just used for setting up semantic-release on your repository.\nYou might install the CLI globally on your machine: npm install -g semantic-release-cli.\nhave a nice day,\nChristoph\n. @apowers313 nice :+1: :relaxed: \nRegarding keytar: Sorry for the bad documentation. It would be awesome if you could create here an issue so we can discuss the further steps.\n. Thank you @Starefossen :+1: :relaxed: \n. Since semantic-release-cli >= 2 keytar is an optionalDependency. You can use the CLI now without installing keytar.. @ahmadnassri Yes, that's correct. Maybe you can try to reinstall semantic-release-cli.\nbash\nnpm uninstall semantic-release-cli -g && npm install semantic-release-cli -g\n. Hi @coderbyheart,\nthank you for your contribution.\nHave a great day,\nChristoph\n. Thank you for your contribution! :+1: :relaxed: \n. Hi @ryan-kimber, thank you for your contribution. I have rebased the commit here: https://github.com/semantic-release/semantic-release/commit/6a172e172035432b2e063fad3d088beb46332c92. Duplicate of #334. Hi @develar, thank you for your contribution. I have rebased the commits. \ud83d\udc4c . @markdalgleish thank you \u263a\ufe0f . ",
    "bcherny": "@boennemann that's a really cool idea. Keep in mind that it will report a lot of false positives (eg. if my unit tests test a method's implementation, not interface), and will fail to report a lot of stuff (eg. if a test didn't test the right thing, or if an argument type change still makes tests pass).\ni took a very different approach with india, relying on jsdoc instead: https://github.com/bcherny/india. Your way of doing it is less fragile than my approach, I think, but may be less accurate.\n. I think it's more than the test setup being \"unoptimal\". There are different ways of unit testing stuff, and depending on what you're testing it's reasonable to use the approach that's the best fit. Some examples of this are:\n- Fully sandboxed unit testing (mocking out all dependencies, Jest-style)\n- Sometimes-sandboxed unit testing (mocking out some dependencies)\n- Never-sandboxed unit testing (driving partial-stack integration tests with unit tests)\n- Testing implementations (eg. #foo called #bar with \"bar\", example)\n- Testing state (example)\n- Testing interfaces (example)\n- Testing DOM-related stuff with a detached DOM (example)\n- etc.\nWith good test coverage, it's typical to have some mix of the above in your tests (not just interface tests). Interface tests are good for supplementing JavaScript's lack of static typing, but other types of tests are useful for other things.\nFalse negatives can potentially be an issue too. For example, say I have this code:\n``` js\n// source\nfunction multiply (a, b) {\n  return a * b\n}\n// test\nassert(multiply(2,2) === 4)\n```\nI then decide that multiply should also accept Strings, so I add some tests:\njs\nassert(multiply('2',2) === 4)\nassert(multiply('2','2') === 4)\nBecause multiply doesn't typecheck its arguments, it ends up being more permissive than it ought to be. An automated semver tool would mark this as a patch change, but really it's a minor change because you went from accepting arguments of type Number to arguments of type String|Number (as specified in the tests).\nI'm worried that there are too many edge cases like these to make an automated semver tool based on unit tests useful in large projects. On the flip side, my approach with India creates the risk that jsdoc annotations will grow out of sync with function signatures, and makes maintaining your jsdoc necessary. Though Google Closure has enforced type annotations for years (in service of compiling code more efficiently), and Facebook's Flow does as well.\nWhat do you think?\n. ",
    "wolframkriesing": "(I didn't read the discussion completely, so excuse if i have duplicate input)\nOnly updating the test folder assumes that all tests in the test folder test only public API. This means that way of detecting breaking changes strongly depends on the way testing was done in this project. Quickly the mockist vs. classisist discussion comes to my mind, or unit and BDD style testing. They all have different implications.\nMaybe a \"new\" category of tests can be defined, kinda like \"API tests\", \"public tests\" or maybe even integration tests ... not sure. And those can be used to test what you described. But still that means it depends on people doing it right in this category.\n. ",
    "ELLIOTTCABLE": "Looks like a good plan to me. How do you plan on allowing, er, plugins / etc / whatever to be integrated into the semantic-release installation and usage pattern? (i.e. if I want to release a sem-release modification to support .gitlabels, how would you want me to do so?)\n. Excited to see where it goes. I'll leave this issue subscribed; drop a note here when you push something I can play with. (=\n. Curious about your thoughts on changelogs. (I'd make a new Issue, or contact you elsewhere, except this isn't really semantic-release specific, and I don't know your other presences).\nI've been idly planning to put together some NIHey tooling to allow me to automatically generate changelogs like this one, which was primarily copy-pasted from commit logs, but manually beautified and very slightly changed (rather obviously, that particular approach is tightly coupled to gitlabeling, but you get the idea).\nAre you planning to start working on new tooling for changelog generation and maintenance, or is that actually something you want to wrap into semantic-release? In general, what're your thoughts on changelogs?\n(I'm on Freenode if you don't want to pollute this random, now-dead Issue.)\n. ",
    "johann-sonntagbauer": "Think i ran into the same problem. First invastigation showed that some lib for parsing the git refs is relying on path-object npm module. That module is not os independent. I try to get in contact with the guy and try to find a solution. First attempt would be to use https://github.com/sindresorhus/slash to convert the paths into a common representation. christophwitzko/path-object/issues/1\n. Will try in the afternoon, thx for fast response.\n. @christophwitzko works like a charm. THX a lot.\n. @boennemann only as background information:\nmy problem was related to path generation on windows. That part was fixed by @christophwitzko in path-object. \n'&&' should work on windows. echo \"test\" && echo \"tada\" works as expected.\n. Perfect, when you need any help with the rewrite let me know.\n. Thx for the reminder, I will take a look at it tomorrow! \n. Hi, sorry had no time to dig into this right away. @ariporad I like your idea. \n. Hi @boennemann \nI started to investigate that topic today, but I face some problems with the npm dependencies. The dependencies are now managed through github notation? Is that intended? \nWe use internal build infrastructure which is not allowed to access the internet which is quite common in enterprises. Would be very happy when we can bundle the plugins with semantic relase together. \n. also the repository.url verification should be a little relaxed. For now only github repos are supported here (because of parsing with parse-github-repo-url). Maybe moving the verification into the post step is sufficient. The property is only used when publishing the release.\n. another question :) NPM Token handling. I think its a litte strange why already present _auth tokens in npmrc configuration has to be respecified with environment variables. Maybe adjust the verify.js check a litte so that it checks the npm config if _auth or _authToken are given and afterwards check the env properties. When absolutly no data is available throw the error.\n. ### dependencies\nThe dependencies to semantic-release artefacts are handled in github notation. E.g.\n\"@semantic-release/commit-analyzer\": \"^2.0.0\"\nNPM fetches the dependency directly from the github releases. That causes trouble when you use semantic-release in a restricted environment (closed build server without internet connection).\nMaybe we can treat the dependencies as devDependencies and bundle the code into the release of the semantic-release npm distribution? In that way you still have the isolation, but also a complete npm package.\nrepository url\nThe repository url is only needed for publishing the release to github. So in that case I moved the verification into the post.js but don't like that approach. I like the plugin mechanism and think of extra steps to provide the validation upfront. In that way the github integration itself could be modeled as a set of plugins without any \"hardcoded\" options and properties in the core. Still need to think a little more about the additional plugin hooks. \nNPM_TOKEN\nThx for clearing that for me. Didn't know that npm stores credentials in clear text into configuration files :/ Looked into mine and saw some Hash. Never mind with that background the implementation is perfectly fine.\n. So after reading through the code i came up with following proposal for the hooks.\nThe semantic-release itself should only be a runtime for calling plugins in sequence. Out of the box it does nothing. \nThe functionality is registered with a set of plugins called bundle. For example git bundle for getting commits; travis bundle for travis support; github bundle which depends on git bundle for github support and so on.  \n- index\n  - applyDefaultConfiguration \n  - verifyConfiguration\n- pre\n  - beforePre\n  - getLastRelease\n  - getCommits\n  - getTyp\n  - verifyRelease\n  - writeRelease\n  - afterPre\n- post\n  - beforePost\n  - generateNotes\n  - createRelease\n  - afterPost  \nall hooks should support the array notation for defining more than one hook. \nPlease let me know if you are ok with that strategy before i start the work ;)\n. @boennemann \ndependencies:\nYes, the problem i am facing is that i can't resolve the scoped dependencies. I can't find them in the npm registry. Do you know how scoped dependencies are handled by the registry? Haven't found any good resource about that.\nruntime changes\n+1 for the incremental implementation. The current implementation is good, but two main problems for now: \n1. Some plugins can be defined as Sequences (e.g. verifyConditions), some don't (verifyRelease) \n2. Some checks are hardcoded outside a plugin (e.g. all checks in verify.js).\n   - To solve that I would also prefer to move the checks in a seperate verifyConditions plugin\nplanned actions\n\nmove verification code into own verifyConditions plugin\nprovide default plugin configuration that enables github and travis\nprovide configuration for gitlab as documentation. \n. @boennemann maybe when you find some time to take a look at pr https://github.com/semantic-release/semantic-release/pull/77. I fixed the test coverage issue and the current implementation is in use. \n. damn, i don't get the coverage tool working on my windows machine :/ i try my best to get that one right but dev experience on windows is worse than ever :/\n. @boennemann no problem, wish you a nice time at nodeconfeu :)\n. @boennemann thx for the review, i will rebase my changes to the new changes as well and kick out the ternary adaptions.\n. sorry for the long absence, i have trouble to find time to work on that issue any longer.\n. @hbetts feel free to do so, would be glad when someone can make use of the work so far. \n. @andrei-cacio nothing new on my side - we switched to a monorepo style and therefor have no need for semantic-release any longer. \n. The specific gitlab plugin was necessary because of the validation logic. I don't remember the details, but the git URL was parsed and validated to be a valid github based URL.  If that validation rule is relaxed now, your configuration solution is valid.. sorry we moved away from semantic release and now use a big monorepo which suites our development workflow better. Time is currently a limiting factor but I will try to setup some test repository.. \n",
    "tlvince": "Thanks for tracking that down @boennemann. I can confirm disabling the spinner gives an expected log output and this was a false alarm.\nJust adding a note to the readme giving the heads up that this is normal behaviour or to disable the spinner (if npm >= v1.4.11?) would suffice.\n. I'll prepare a reduced test case and get back to you.\n. I tried, but couldn't reproduce this (as of semantic-release v3.3.1); https://github.com/tlvince/tlvince-semantic-release-initial-version was correctly published with v1.0.0.\n. :+1: \n. No probs. Thanks!\n. <3\n. :+1: \n. I've been using a similar script for sometime now and whilst it's a little hacky, it works. I've written up my workflow in tlvince/tlvince-semantic-release-push-dist, but I'd also love to see a plugin that implements this more robustly.\n. For reference, I recently packaged up two other approaches:\n- publish-repo: pushes dist to a separate repository\n- publish-dist: commits and pushes dist to master if the last commit was not made by itself\n. @kentcdodds NIH? :sweat_smile: In all seriousness, I didn't realise publish-latest was that flexible; I thought it only concerned itself with one scenario (publishing to a branch). I guess I didn't look very hard! (I'd also been using the scripts in different projects for quite some time before and wanted to consolidate them).\n. Note, I suspect this might be happening because Travis hasn't yet finished the previous build/semantic-release pushed a release. Perhaps limiting Travis' concurrent jobs to 1 would fix this?\n. Thanks! We'll give status checks a roll.\n. ",
    "gr2m": "I'd suggest to put that in the default .travis.yml, with a comment containing the URL of this issue.\nBy the way, I got bit by this issue (I think) when I tried to do the first deploy to npm. The package did not yet exist. I expected that in that case, semantic-release would create a 1.0.0 as a default?\n. oh, also, funny version on npm right now :D \nhttps://www.npmjs.com/package/couchdb-view-tester\n. I've removed the bad version, but here's a screenshot \n\n. It also created a version on GitHub: https://github.com/gr2m/couchdb-view-tester/releases \nI can leave that for now and delete it once things are working\n. I didn't do anything special on my side, besides testing with different node versions:\nhttps://github.com/gr2m/couchdb-view-tester/blob/master/.travis.yml#L3-L5\n. :+1: \n. \n. @remy npm publish is now being run on travis for you, you don't publish yourself anymore, it's happen for you, whenever tests pass and there is a patch / minor / major change in the commits since the last one, via your travis deploy settings\nYou can still run npm publish locally, see this question:\nhttps://github.com/boennemann/semantic-release/#how-do-i-get-back-to-good-ol-npm-publish\nNote, this one applies to your project as well, because you test on multiple Node versions:\n\nNote: If you have a more sophisticated build with multiple jobs you should have a look at travis-after-all, which is also configured for this package.\n\nPing me if anything is unclear :)\n. btw it's BREAKING CHANGE:, not BREAKING CHANGES:. But maybe it works with both, I don't know :)\n. @remy the npm website has caching, the displayed versions are sometimes out of date. They are working on a smart \"invalidating cache\" script right now. Raquel is talking about it on the last episode of descriptive: http://descriptive.audio/episodes/18\n. btw, it tried to publish v0.1.0. I'd have expected v1.0.0. Was that intended?\n. will do! \nRegarding jumping to 0.1.0. As it's about semver, I'd always jump to 1.0.0 if it doesn't exist yet. Let's put all the npm packages to 1.0.0+, because below: everything can change at any time, right?\n. for the time being, how can I force it to release 1.0.0?\n. :+1: Also, async should use semantic-release! Let's do some lobbying :D\n. just v1.0.0 :) Details are in the release body\n. \ud83d\udc4b Hey everyone, I'm not a gitlab/bitbucket user myself so I can\u2019t help, but would love for it to happen.\nWhat we need though is ideally at least two people who would be willing to maintain the project for each platform once it\u2019s done. We can help with overall updates but when it comes to bugs and new features, we\u2019ll need you :) . @armand1m @hbetts I\u2019m very open to any suggestions. I\u2019m happy to make the github-specific parts pluggable. In fact, I think they already are :) semantic-release already has a plugin system.\nNext step would be to investigate where we are today and whats holds us back to use semantic-release on GitLab, for example. Would any of you be up for doing that research task?. Hmm I see that you already published https://www.npmjs.com/package/semantic-release-gitlab, maybe we can make it \"official\" and move it to the semantic-release GitHub organization, stating in the README that you are the maintainer? I don\u2019t know how it\u2019s currently implemented, but ideally it would depend directly on semantic-release but configure custom plugins for gitlab compatibility. What do you think?. > Does Not Publish To NPM Registry\nI would be open to make the currently built-in release to npm pluggable, so other folks can set other deploy / publish targets\n\nNo CI Limitation\n\nI think we have that already\n\nNode LTS Support\n\nThere is quite a simple workaround using npx which you can install on older node versions and it lets you run single commands with newer node versions.\nBesides, Node 8 becomes LTS next month :). > You would need to fetch version information from the project's repository instead of npm. Would y'all consider that?\nyes :) \n\nMy attempt in #150 to make GitHub a plugin never received much input.\n\nIt\u2019s a good time to revive that discussion\n\nAlso, our corporate policy is that developers may use any LTS version (Node 4 or 6, so long as they migrate towards newer releases)\n\nNode 4 is not LTS and Node 6 stops being LTS in April 2018, which could be a good target for us to ship first class GitLab support by then :). I can\u2019t drive it myself, if you are interested in merging the two projects, you\u2019d need to be the one driving it :) There is no rush. I had the same thought as @rmehner: any chance we could help fix travis instead? Or is it a conceptual issue?\n. oh wow, note that I did not set this property, it was the default that npm suggested on setup\n. forget what I said, that was one of 7 repos I did all at once, but this one I think I copy / pasted from an existing one and only find/replaced stuff in package.json. Thanks for the help, sorry for the noise \n. I won't have time anytime soon. First come, first PR'd :) And the problem is well described now, anyone could come in and try to fix it\n. @claudiocro what other providers / solutions would you like to see? Do you mean instead of publishing a module to npm, you'd rather deploy an app to your production server for example? \n. I wonder if we could make semantic-release-cli smart enough to migrate semantic-release@3 setups? \n. > The existing migration guide is also pretty straight forward\nIt is :) It would have been just a bonus, nevermind then\n. w00p congrats :tada: \n. discussed this quickly with @boennemann. Plan is as follows\n1. Make a lib/get-registry file\n2. If package.json name has a scope, look for conf.get('@'+scopeName+'/registry')\n3. If it returns undefined, check if pkg.publishConfig.registry is set\n4. If that returns undefined, use conf.get('registry')\n. @lapanoid did you run npm publish locally on your machine? Or is that an error log from Travis? If it's the latter, did you use semantic-release-cli setup as described here?\nhttps://github.com/semantic-release/semantic-release#setup\n. I'm happy to give this a try, whenever the time is good for it, I'd just need a little guidance :)\n. @boennemann I\u2019m still happy to work on this, but could use a little guidance on how to implement this. I didn\u2019t touch semantic-release code yet. I don\u2019t know what you mean with pass it to the github.repos.createRelease\n. @hbetts that sounds great. So I guess best would be to wait for your work to land in semantic-release, and then build a plugin based on it to allow custom uploads?\n. I use it in about 50 of my open source projects, it\u2019s most definitely not dead, it works great for what it does, but it\u2019s only as active as you are willing to contribute ;) Stephan who started the repo is pretty swamped with life right now, but if you take this and start a PR that will make it work, I\u2019m sure we can get it added\n. Yeah I agree it needs a bigger effort to refactor as it grew organically over time. I think it proofed it scope pretty good now. I already told Stephan I\u2019m willing to help maintain semantic-release and help with such an update, are you in?\n. I\u2019m working on something by chance, I might have something in a week or two, I\u2019ll post updates in the comments here. oops forgot to post the library I\u2019ve built: https://github.com/gr2m/octokit-release-asset-upload\nbut even more awesome: uploading assets will be a built-in feature soon! Thanks t @pvdlg \ud83d\ude4c . @conblem see https://github.com/gr2m/octokit-release-asset-upload/blob/master/package.json#L21 (actually have to fix this to postpublish instead of postsemantic-relaese :) )\nBut note that the new semantic-release will have asset upload options built in :). Could the build files live in a separate branch? Then you could use https://www.npmjs.com/package/gh-pages-deploy for it. We use it do push docs after a deploy, e.g. for https://github.com/hoodiehq/pouchdb-hoodie-api, see https://github.com/hoodiehq/pouchdb-hoodie-api/blob/master/.travis.yml#L24\n. Then you can achieve that with\n1. On traves in after_success, run the build task which builds into /dist or similar\n2. Copy / create bower.json file in dist/ folder\n3. Use gh-pages-deploy to push contents of /dist folder to a dist branch on GitHub\n4. Point bower to the dist branch\nThat should work, right?\n. Travis already has the github token, so we use a smal script for that:\nhttps://github.com/hoodiehq/pouchdb-hoodie-api/blob/master/bin/authorize-push.js\nand run it in predeploydocs\n. Not at all! I'll leave it to @boennemann, just to make sure there is no simpler solution for the root problem you have. Also it's his work, so honor to whom honor is due. Okay for you to copy & paste this for the time being?\n. if you changed to Node v4 after you run npm install, make sure to delete node_modules and run npm install again, as some installed binaries might break now\n. Glad to hear you got things working @hafeez-syed. Sounds like an issue not related to semantic-release. I'll close the issue, but feel free to keep commenting or reopening if you see a need :)\n. Can you try to update npm to latest version, then try again? If that's not working, try npm uninstall -g semantic-release-cli, then try again\n. @Flame2057 what versions of node, npm, semantic-release are you using?\nnode -v && npm -v && semantic-release-cli -v\nMake sure it\u2019s all updated to the latest.\nWhat operating system are you using?\n. The problem is with the install of node-gyp. There are lots of instructions for Windows. Once you get it installed on your machine, the install of semantic-release-cli and many others that rely on node-gyp should work fine\n. you need python (Error: Couldn\u2019t find executable python), please see https://github.com/nodejs/node-gyp#installation for windows.\n. Oh my, I've no idea :(\nCan you check http://www.jamessturtevant.com/posts/5-Ways-to-install-git-on-Windows/ for an alternative to the git bash? I've heard Cmder is great for older Windows versions. Sorry I can't help better than this, I don't have Windows myself.\n. glad you got it working \ud83d\udc4d \n. semantic-release does not support that, it only creates tags with the versions released on npm. \nI don\u2019t see the use case for it. Can you explain why you\u2019d want that? Would that be in addition to the version tags like v1.2.3, or as a substitute?. yes that is intended behavior :) At the end, both npm & GitHub have releases with version numbers, but only npm gets the beta/next/custom tag, that is correct. Nobody asked for that to be added to GitHub yet. I wouldn\u2019t be opposed adding it though. You\u2019d also need to reset it if it already exists. Pull requests welcome \ud83d\udc4d . Related question: can't we disable Travis builds on new git tags somehow?\n. I've worked around it by setting\nyml\nbranches:\n  except:\n    - /^v\\d+\\.\\d+\\.\\d+$/\nBut it would be still nice to make the error message more descriptive\n. Sorry for the frustration, I know, I\u2019ve been there a lot myself. You have to do a manual release once to make it work again. We are looking into new ways to determine the change history, stay tuned :). @gyoshev this is very insightful, thanks for sharing @gyoshev! We have some ideas about how we could utilize GitHub\u2019s pre-releases and a GitHub app which would set a version to @latest once a GitHub pre-release was marked as normal release. Stay tuned :). We are planning a little semantic-release hackday in which I hope we get to address that issue or at least prepare the project to onboard more maintainers. Stay tuned :)\nUpdate\nI say \"we\" but just want to clarify I\u2019m not a maintainer myself :) But I\u2019m friends with the maintainers and we are trying to make a hackday :). @jony89 no update on this particular issue, but I\u2019m working to onboard more maintainers, so there will be more momentum in future :). It\u2019s not something that anyone is looking into right now. But we are discussing about further modularizing semantic-release and introducing \"publish\" plugins (see https://github.com/semantic-release/semantic-release/issues/484). I think this could be built with the new architecture, creating similar GitHub releases/tags to https://github.com/atlassian/lerna-semantic-release. Maybe lerna-semantic-release could be migrated to it if the maintainers are interested /cc @jpnelson . hey @evocateur cool to see you around :) Just a heads up that Pierre is traveling this week so might be slower to respond :). @pvdlg it all sounds good to me. \n\nshould it be up to semantic-release to loop over the different packages directory or an external solution?\n\nI\u2019m agree that this is out of scope. The additional config complexity makes sense, a mono repo it is a more complex setup after all. \nI guess supporting a simpler setup where all packages are released with the same version like in https://github.com/pouchdb/pouchdb should be much easier to support, right? \nLet\u2019s move forward with it and once we have something we can invite folks with different monorepo setups to give it a try.\n\n\nOne thing I like about current lerna publish is that it also bumps dependents of updated packages. \nI don't think it's semantic-release responsibility to do that.\n\n\nI agree. That would be a job for @greenkeeperio :) The team is looking into monorepo support as far as I know. @ashleygwilliams ^^ this is the cause for the problem I had with the empty README files like this one, we had a few twitter conversations on it. Turns out it\u2019s not npm registry or the npm publish command, it\u2019s the normalize-package-data package that is used within semantic-release. See example here: https://tonicdev.com/gr2m/56eacb53ee0381120071d499\n. :clap: :clap: :clap: \n. @felixfbecker can you explain what you mean with \"if the package manager does not support dist tags\"? The current semantic-release is pretty much bound to npm right now. I guess that is out of scope for semantic-release at this point. I know that Pierre is looking into making the \"publish\" step pluggable so you can build a semantic-release publish plugin for Composer. I would imagine that could set any settings you want in package.json for your plugin, it will be passed through. \nBut until that is done, I don't think other package managers are within the scope of semantic-release. Hey friends \ud83d\udc4b Sorry it took so long to get back to you \ud83d\ude1e I recently joined as maintainer and would like to help you get this merged. I don\u2019t see any reason not to support to use semantic-release as package by moving out all CLI related logic \ud83d\udc4d \nCould you please update the PR on the latest master and let me know once you did? And I\u2019d also like to ask you to add a test of using require('semantic-release') as a package\nI\u2019d be happy to make a proper review then. thanks Ron, I can take it from here. I\u2019ll be travelling next week but will have time after. I\u2019m still not convinced that the version number needs to be written into package.json in the source code. All the use cases mentioned so far are covered by tooling. If someone really needs it, it can be done with a post script and we can maybe document that or even implement that plugin, but this is not going to be part of semantic-release core\n\n@GarthDB  When I'm making CLI tools I use the version field from the package.json to return a version in the command line.\n\nCan you elaborate? The package.json version number is set in packages published to the npm registry. If you npm link a local package, it will say 0.0.0-development which makes a lot of sense as it is your local version.. Thanks for putting this together @pvdlg! . Looks like an issue with travis today\n\nIdentified - We identified the database connection issue.\nJul 21, 16:02 UTC \n\nI wonder if we could make the error message more helpful though? Show the actual error that the server returns, and maybe recommend to check if there is an issue on https://www.traviscistatus.com/ right now?\n. I\u2019ve added my travis-after-all fork with some debugging logs, here is what it gives me:\nhttps://travis-ci.org/hoodiehq/ember-hoodie/jobs/147563086#L2020\nTurns out the API call to https://api.travis-ci.org/jobs/147525158 returns Forbidden. Any idea why that might happen?\n. worked today https://travis-ci.org/hoodiehq/ember-hoodie/jobs/147573175. I\u2019ll send travis support an email anyway\n. > This is a case where moving semantic-release out of the CI and into a GitHub App (as proposed by @gr2m ) may be the way to go\njust to clarify, I don't plan to replace the current semantic-release CLI tool with a GitHub app, it will just be another option, the two might even work together. Hello there @umireon! I\u2019m sorry nobody got back to for so long \ud83d\ude1e I recently joined as maintainer and would love to help get this merged and released. \nIt still need some time to familiarise myself with the code base and the respective GitHub APIs used in this PR. I\u2019ve seen you already added tests so that seems good. I\u2019m not yet sure how I can test it myself before release, if you have any ideas, let me know :)\nCould you rebase your PR on top of latest master?\nAnd in case we release it and run into any trouble, I\u2019d appreciate to know that you are around to diagnose and fix eventual problems.\nThanks for your help \ud83d\udc90 . All right, thanks you very much, I\u2019m going to rebase your PR on latest master and merge it once CI is happy \ud83d\udc4d . released as https://github.com/semantic-release/semantic-release/releases/tag/v7.0.1 (not yet on @latest on npm, install with @next). @umireon Hey is it possible that this change creates branche names with the same names as the git tags that get created? See https://github.com/semantic-release/semantic-release/issues/415 and https://github.com/semantic-release/semantic-release/tree/v7.0.1\nIs there a way to avoid that? . no worries at all, I haven\u2019t found it when I reviewed, so it\u2019s equally my fault. If you could send another PR that would be great :) No rush though. > The only solution I can think of is to modify semantic-release to do in one command\nIf we could figure that out, that\u2019d be pretty cool I think!. we are good friends with the npm CLI developers, certainly sth we can ask them about, but we should do our homework first and prepare questions :). Hey there, I\u2019ve just joined as maintainer and hope to help you get this pull request merged. Sorry it took so long to get back to you \ud83d\ude1e \nI\u2019m currently not sure how to test the change myself before merging, can you help me out? Do you think you could add a test for it?. I\u2019d need to do some research on this to understand the changes which I can\u2019t until the weekend, but I fully trust you @vanduynslagerp feel free to :shipit: . hey based on your comment at https://github.com/semantic-release/semantic-release/issues/340#issuecomment-266205026, this PR can be closed, right?. > Basically I think there should be an option to enable this... However not as a normal release but as a release candidate, do we think this is possible?\nYes that is possible :) \n\nWhat you want to do is create a branch like rc.\nIn the package.json file, add a \"publishConfig\" key, and set it to \"publishConfig\": {\"tag\": \"rc\"}. See publishConfig docs for more options\nMerge all pull requests you want to release into that branch.\n\nFor example, semantic-release itself releases with a next tag by default, and only after we tested the @next release on some repositories, we set the version to @latest: https://github.com/semantic-release/semantic-release/blob/42456a32b316c2879fc667323817c4cf11ee8e90/package.json#L73-L75\n@codekiln We don\u2019t merge locally ever, the main benefit of semantic-release is that we can just merge pull requests and the release happens automatically. Does my comment above help you? We are always happy for any help we can get to improve the documentation, you have a much better perspective on it than us who know semantic-release inside out :). thank you all for helping figuring this out \ud83d\udc4d \n@calebeby could you try to replace npx -p node@8 npm run semantic-release with just npm run semantic-release? I\u2019ve run into a different problem with npx myself the other day: https://github.com/semantic-release/semantic-release/pull/414#issuecomment-330004885 I don\u2019t know how npx works exactly and if it screws with process.env which could cause both problems. could you add this to your travis file?\nafter_install:\n  - npm ls\nso we can see what exact versions have been installed?\nAnother problem could also be the caching of node_modules. The npm folks themselves don\u2019t recommend to do that anymore, and instead cache  $HOME/.npm. I know our CLI is currently setting up .travis.yml to cache node_modules, something we should change asap :). All right thanks Caleb, we\u2019ll need to investigate this some more. Your build is using the latest version of travis-deploy-once so there must be  a bug in it. If you could help us finding the cause of the problem, that\u2019d be great \ud83d\ude4f . I\u2019ve just run into this problem myself, this is very weird, because I\u2019m quite sure it worked before :( I\u2019ll try to reproduce it on a minimal test setup\nFor others who run into this problem, you can set BUILD_LEADER_ID to the job number you want semantic-release do its release on.. I don\u2019t know, but I'm pretty sure it\u2019s a problem is related to https://github.com/semantic-release/travis-deploy-once/releases#2.0.0. I think we can drop the npm prune step now anyway from the default.travis.yml created by the CLI.. I've started a PR at https://github.com/semantic-release/cli/pull/149. Hey folks, I\u2019m looking into this now, I\u2019ll help maintain the project moving forward.. I\u2019ll keep you all posted in this issue moving forward: https://github.com/semantic-release/semantic-release/issues/411 Thanks for your patience and if you could help triaging open issues / PRs and mention me in the ones you think are most urgent, I\u2019d appreciate it <3. I\u2019ve released semantic-release@7.0.0 with the next release. You can install it with npm install --save-dev semantic-release@next or directly set the version in your projects\u2019 package.json files.\nThis should resolve the issue. Please give it a try and let me know if it works as expected, once a few folks tested it we can set the semantic-release@7.0.0 to @latest. @nanovazquez @durancristhian Would it be an option to set your custom registry in the package.json file? You can set \"registry\" in the \"publishConfig\" setting, see https://docs.npmjs.com/misc/registry#i-dont-want-my-package-published-in-the-official-registry-its-private. I\u2019m still finding my ways around semantic-release & npm details myself. I would prefer to find a way to make semantic-release work without adding another option. \nCan you tell me how your existing .npmrc file looks like and how the one created by semantic-release looks like? Maybe we can merge the two if one already exists so it would work for you?. how about we check if the .npmrc file exists. If it does, we read out its contents and add it back in after semantic-release is done overriding it. That should work and not break anything? I guess your file with have the URL of your private registry used for a specific @scope and the auth token for it?. Okay thanks for all your insights on this. I'll reach out to some friends who know much more about npm internals. I\u2019ll get back to you :) . I think it would be great if semantic release could be configured to release new versions for previous major releases. Say my last version is 3.0.0. What I would do now is to branch out v2.x with the last version in the 2x release and in that branch configure v2x to be the branch from which it should release. But when I push a feat: ... commit, semantic-release does nothing because it is looking for the last commit of the last version which is 3.0.0 instead of the last commit in the current branch.\nAnother limitation would be that I would not want to allow to do breaking changes from this. I wonder if we could another option like baseVersion which would achieve both things \u2013 forbidding breaking changes and checking for the last commit in the right place?. hey all I\u2019m having a look into this, I\u2019ll help maintain the project moving forward \ud83d\udc4b . I\u2019ll keep you all posted in this issue moving forward: https://github.com/semantic-release/semantic-release/issues/411 Thanks for your patience and if you could help triaging open issues / PRs and mention me in the ones you think are most urgent, I\u2019d appreciate it <3. I\u2019ve released semantic-release@7.0.0 with the next release. You can install it with npm install --save-dev semantic-release@next or directly set the version in your projects\u2019 package.json files.\nThis should resolve the issue. Please give it a try and let me know if it works as expected, once a few folks tested it we can set the semantic-release@7.0.0 to @latest. I run into the same problem. In my case, the repository in question was moved into a github organisation that I had to grant access first. Hey there,\nI\u2019m sorry for the late response :(\nI think that indeed the github user needs admin authentication on the org, otherwise it cannot create the webhook required for semantic-release. We should return a more helpful error in that case though. As a workaround, I would suggest to just log out the tokens and add them manually to Travis setting, does that work for you?. @yoitsro can you please test with semantic-release@8.2.1? It has been released with the @next dist-tag, so you have to set that version explicitly. npm install semantic-release will still give you 8.2.0. Hey @zetaron, I\u2019m just familiarising myself with semantic-release as I joined it as maintainer today. \nThanks a lot for putting the time into the pull-request, I\u2019ll do my best to get this merge as I understand that it\u2019s a blocking issue for you right now.\nAs this issue didn\u2019t come up before (I think), can you check with Bitrise if they maybe might want to change their setup to align with the other CI services? \nIf that is not an option, could I please ask you for two more things\n1. add tests for the change\n2. add a comment to explain the additional .replace('origin/','')\nThanks \ud83d\udc90 . The fix of the \"<a name\"x.x.x\"> in release notes\" bug is currently blocked by a problem with npm publish: https://gist.github.com/gr2m/80e7e580556c1f7eb32d7b8af55ff281\n. I\u2019ve released semantic-release@7.0.0 with the next release. You can install it with npm install --save-dev semantic-release@next or directly set the version in your projects\u2019 package.json files. \nNote that support for no longer maintained Node.js versions has been dropped as part of this release. If you use Node 4 or newer all will be fine :) I\u2019m very sorry if you still have run on Node 0.10 or Node 0.12, but we can\u2019t support these any longer while at the same time making the project easier to maintain and contribute to.\nThis should resolve the \"<a name\"x.x.x\"> in release notes\" issue. Please give it a try and let me know if it works as expected, once a few folks tested it we can set the semantic-release@7.0.0 to @latest\nUpdate\nThere seems to be a new bug introduced with the update. A fix comment like semantic-release@7.0.0 gets parsed to semantic-release[@7](https://github.com/7).0.0, see https://github.com/gr2m/semantic-release-test/releases/tag/v2.0.2 for an example. My guess is this happens somewhere in conventional-changelog, trying to link github usernames, but unfortunately not doing any checks. See https://github.com/conventional-changelog/conventional-changelog/issues/218. I have set semantic-release@7.0.1 to @latest. Happy updating :). We had a little boo boo in v7.0.1. If a new version was released using that version (past two days), please see the notes on how to recover from the ENOTINHISTORY error at https://github.com/semantic-release/semantic-release/releases/tag/v7.0.2\nSorry for that \ud83d\ude47 . We just released semantic-release@8 with the @next dist-tag. It drops support for Node < 8:\nhttps://github.com/semantic-release/semantic-release/releases/tag/v8.0.0\nInstall the latest version with npm install --save-dev semantic-release@next or update the version in your package.json file directly. We would much appreciate your help testing it before we set it to @latest \ud83d\ude4f \nWith this version we also introduced a new way to detect the Travis build leader, meaning the job on which semantic-release will be run. Before, it was run on the first job, now we look for the first job that is running on node@8 instead. If you have a build matrix that includes version 8, you are all set, if not, add node 8 to your test matrix (you should do that anyway, it is the current stable version of node).\nIn case you cannot add node 8 to your test matrix, please let us know why in a new issue (mention me please). To workaround, you can install npx and then run npx -p node@8 npm run semantic-release in after_success.\n. semantic-release got a nice shoutout on \ud83c\udf99\ufe0f JS Party #18. Thanks @mikeal \u2728 . Pierre (@vanduynslagerp) offers to donate two of his plugins he wrote to semantic-release core:\nhttps://github.com/semantic-release/semantic-release/issues/427\nLet us know what you think and if you could help us give the plugins a try to make sure they don\u2019t break existing behaviour by enabling them in your projects, that\u2019d be great :). We are moving forward with @vanduynslagerp plugins. Pierre will also join the maintainers team \ud83d\ude4c. I\u2019ve set semantic-release@8.0.0 to the @latest dist-tag on version as no problems have been reported in the past 4 weeks :) Happy updating \u2728 . We just released semantic-release@8.0.3 on @latest. release notes. We just released semantic-release@8.2.0 as @latest. Last @latest release was 8.0.3. See release notes. Thanks for giving it a try! I\u2019ll try to give it a look my self, it\u2019s on my list of things I want to work on next for semantic-release. @pvdlg sounds great! \n@zetaron wanna give this a try? . no worries :) Good luck with the project. Shall we ping you again on some specific day? . I think we can even work around the problem that the build leader on travis must be running on Node 8. When getting a build with travis-ci library using travis.builds(id).get(callback), the response includes a jobs array. Here is the same response using curl (the header is significant)\n$ curl -H'Accept: application/vnd.travis-ci.2+json, */*; q=0.01' https://api.travis-ci.org/builds/264152577\nThe response looks like this (excerpt)\njs\n{\n  \"build\": {\n    \"id\": 264152577,\n    \"repository_id\": 5110092,\n    // ...\n    \"config\": {\n      \"node_js\": [\n        6,\n        8\n      ],\n      // ...\n    },\n  },\n  \"jobs\": [\n    {\n      \"id\": 264152578,\n      \"number\": \"58.1\",\n      // ...\n      \"config\": {\n        \"node_js\": 6,\n         // ...\n      }\n    },\n    {\n      \"id\": 264152579,\n      \"number\": \"58.2\",\n      // ...\n      \"config\": {\n        \"node_js\": 8,\n         // ...\n      }\n    }\n  ]\n}\nInstead of declaring \"58.1\" the job leader just because its job number ends with \".1\" (like it is implemented today), we could find the first job with a node version >= 8 and declare this job the job leader, no matter the version.. @vanduynslagerp I tried that, but run into several problems with it. Among others, there is no way from the script being run to tell that it\u2019s run as a stage, at least not from environment variables alone. \nBut thanks for bringing it up, it\u2019s out of scope for this pull request, but we sure will give it more thought. @boennemann the npx trick didn\u2019t work:\nhttps://travis-ci.org/hoodiehq/hoodie/builds/276387784#L2843\n```\n$ npm install --global npx\n$ npx -p node@8 npm run semantic-release\n\nhoodie@0.0.0-semantically-released semantic-release /home/travis/build/hoodiehq/hoodie\nsemantic-release pre && npm publish && semantic-release post\nsemantic-release: node version >= 8 is required. Found v4.8.4.\n```\n\nAny thoughts?. npx -p node@8 node ./node_modules/.bin/semantic-release should work, I\u2019m currently testing it via https://travis-ci.org/hoodiehq/hoodie/builds/279660236\nMaybe npx -p node@8 semantic-release will work, too, I\u2019ll test it next. > npx -p node@8 node ./node_modules/.bin/semantic-release should work\n\ud83e\udd26\u200d\u2642\ufe0f no of course it does not, because the semantic-release npm task is more than just running the binary. Testing npx -p node@8 semantic-release now . okay that also didn\u2019t work, but npx -p node@8 -c \"semantic-release pre && npm publish && semantic-release post\" will I think. Not very pretty but if it works, it works :D. that worked, we can just update the error / documentation to recommend npx -p node@8 -c \"semantic-release pre && npm publish && semantic-release post\": \nhttps://travis-ci.org/hoodiehq/hoodie/builds/279667094#L2846. Creating a branch is part of the main feature of semantic-release. Based on the branch we can create a GitHub release and then put the change logs in there, example: https://github.com/semantic-release/semantic-release/releases/tag/v7.0.1\nThe branches is also not something that was added with version 7, it was there since day one, so I don't quite understand your issue to be honest :). ah sorry it's late for me, I was thinking we were talking about tags, not branches. Okay something is off here.\nIf you could investigate what\u2019s happening and send a pull request, that\u2019d be great, because I don\u2019t think neither Stephan nor I will get to this, we are working on other parts right now.\nThanks for your help!. I\u2019m pretty sure this is the change that cause it: https://github.com/semantic-release/semantic-release/pull/335. Could you send a PR to start a discussion? . Hey @sudo-suhas I\u2019m not using yarn myself, but as far as I know that should work. Please let us know if it does :) Would be great if you could send a pull request to adjust our README to mention how how to use semantic-release with yarn. doesn\u2019t yarn end up publishing to the same npm registry? Maybe you can use npm to publish while keep using yarn for dependency management?. Yeah I agree, I\u2019m just not familiar with yarn myself. I\u2019d be happy to accept a pull request if it makes things simpler. It could also be an addition to our README to inform people how to use semantic-release with yarn once someone figures it out :). if someone could add an FAQ entry to our README at https://github.com/semantic-release/semantic-release#itymfaqlt for the time being, that'd be :100: :). This is very curious indeed. Thanks for reporting this issue \ud83d\udc4d \nThe problem is that it tries to publish version 1.0.0 but the tag v1.0.0 already exists on github. Is it possibile that either commitizen or cz-conventional-changelog does create the git tag and you pushed it up togethere with your commits?. I\u2019m really sorry, I\u2019m in between jobs right now and I have to focus on that transition, things will get better soon though.\nMy next step is to create a bare bone repository that has no dependencies but semantic-release and has the npm \"test\" script just return exit 0 so it will always pass on travis, and use that as a minimal test case to reproduce the problem that you have seen. If you could set that up and invite me as collaborator to that would be helpful. . Hey @vanduynslagerp, that all sounds great, thanks for offering to contribute them back to core!\nThese are pretty massive changes, I\u2019ll need some time to review them. It\u2019s not that they aren\u2019t great, it\u2019s all about the fact that we take over responsibility and maintainership over for these, too. Would you be willing to join the maintainers team to help out with that?\nUpfront, two things:\n\nplease keep in standard. It\u2019s not that we think the rules are better, it\u2019s the fact that we discussions about coding styles is one less discussion we can have :) I haven\u2019t use prettier yet but there is prettier-standard, would that be an option?\nI\u2019m very familiar with tap myself so I would prefer to keep that. I'm always happy to be convinced about how ava is better :) I care less about features, and more about simplicity and contributor friendliness. And if we introduce ava to the default plugins, we should use it in all semantic-release packages. Would you be willing to help with that transition?. > I have no problems switching to prettier-standard.\n\nPlease lets do that.\nI agree with your critique, I just try to minimise the amount of discussions moving forward in the project, to make the project easier to maintain. \n\nIn addition I was under the impression that this transition was already underway.\n\nTotally missed that. All right, let\u2019s do it :)\n\nYes, I'd be really happy to join the maintainers team !\n\nAwesome, welcome \ud83d\udc90 Can you send me a dm on twitter? I\u2019d love to chat to say welcome in person ;). Thanks for the research, Pierre, this is great input \ud83d\udc4d I\u2019ll try to get @boennemann\u2019s thoughts on this. I\u2019m okay with either.. that would be great :) \nI really don\u2019t mind the loose rules of standard. Problems with syntax that could have been enforced with stronger eslint rules is not a problem we have. yes, I don\u2019t think that will be much of a problem, I haven\u2019t seen that become much of a problem in any other projects I\u2019m involved in that is using standard, but I have seen endless discussions about around jshint / eslint configurations :) Hence the preference to just go with standard. All right, @vanduynslagerp, let\u2019s do it :) \nI hope to find a bit of time to work on semantic-release on Friday / Saturday, that\u2019s when I can review your pull requests. If you could help us with transforming to es6 and setting up the linting (eslint + eslint-config-standard + eslint-config-prettier) that\u2019d be ace.\nI\u2019ll invite you to the team in moment. Welcome \ud83d\ude4c . npm@5 introduced notice as a new loglevel and it defaults to it. semantic-release uses the same library that npm uses for logging: https://www.npmjs.com/package/npmlog. So that\u2019s where this is coming from.\nBut where exactly semantic-release validates the current level and logs the warning, I dunno :) Would be nice if you could investigate \ud83d\ude4c . I also don\u2019t know yet, but I\u2019ll have a look. I\u2019ll be busy with work until Saturday, I'll have a look then.\nWhat you can do until then is to setup a test repository for a test npm package, set \"semantic-release\": \"Apidcloud/semantic-release#GitHubCustomTag\" in your package.json so your fork gets installed, and then see if it works, if there are any problems left you\u2019ll catch it that way. > And should this PR focus on creating a pre release in GitHub when the dist tag is next and the pre release is set to true?\nThe only problem I see with this is that when you set the @latest dist-tag on npm to the new version, you should have to manually update the release on GitHub, too, as it no longer is a pre release.\n\nIs this flag even needed? Shouldn\u2019t it happen by default as the tag is next?\n\nI\u2019m undecided. I\u2019d be okay flagging a GitHub release as \"pre-release\" if the dist tag is set to anything else than latest, but we should inform folks about that in the docs and tell them that they have to remove the flag once they set the @latest dist-tag on npm.. >  Maybe we could add the possibility to run manually semantic-release --latest  that would do npm dist-tag add @ latest and remove the pre-release flag on github at the same time.\nThat\u2019d be super nice!\nI\u2019m also thinking about the GitHub app that could do such things, but that\u2019s out of scope and would only work for GitHub. Love the idea to make it work with the CLI!. > We also have to handle situations where folks publish on a legacy dist channel in order to do bug fixes on old versions. For example one can maintain a legacy version that retain node 4 compatibility, and release only bug fixes there\nGood point ... we could also add another option the package.json publishConfig ... or be smart about it and see if the released version is higher than the currently @latest, and only then set the GitHub release to be a pre-release?. > What if you make a breaking change commit on the legacy channel ? => Fails because 2.0.0 already exists.\nWell you don\u2019t, this would be like an LTS version, you keep maintaining it, but you can\u2019t do breaking changes. We had discussion on this somewhere else. The idea is that when I release 3.0.0 I\u2019d create a branch 2.x.x and in that branch I could set a base version to \"2\" so releases from that version would release as the next version within 2.x.x, but it would not allow breaking changes at all. Not sure what the npm tag would be, we could default to v2 or we could require a dist-tag setting that isn\u2019t \"latest\".. hmm shouldn\u2019t the 4.1.2 version be installed automatically as it is inside the range of ^4.0.0?. I think it\u2019s already set to 4.1.2 in there, it looks like @semantic-release/last-release-npm\" is depending on an outdated version though, probably it\u2019s the root of the problem. Sounds like a pragmatic solution, let\u2019s do it.. have you tried setting npm_config_loglevel? semantic-release is currently using the same log library as npm itself, so you can set npm_config_loglevel=verbose to get more logs\nI\u2019ve used it myself in the past but moved over to the much simpler and more widely adapted debug package. I\u2019d be happy to transition to that and use it across all core packages as well as recommending it to be used by plugin developers. I\u2019m okay with passing a logger to the semantic-release plugins \ud83d\udc4d \nA problem I run into with npmlog is that if I set the loglevel to verbose or silly, it also affects the other npm commands like npm install and npm test. The log becomes huge and travis eventually cuts it off. Setting DEBUG=semantic-release* or DEBUG=semantic-release:plugin-name* would only affect semantic-release.\nWe could pass in a .log method to the plugins that is require('debug')('semantic-release:plugin-name'). I don\u2019t know, we could just log errors directly using console.log. I\u2019ve used different libraries in the past that support different loglevels and especially in teams (and even more so in open source projects with a higher fluctuation rate, and even more if there are plugins with 3rd-party developers) people are confused about what level to use when, so ending up with debug and simple name spaces is a good balance.\nI like chalk for logs, too :) debug gives you colorful logs by default ;). okay sounds good to me \ud83d\udc4d \nI think console.error is just an alias for console.log these days, at least in node, so you can just use console.log for both. you are right, maybe they changed it back \u00af\\_(\u30c4)_/\u00af. > remove npm prune\nYeah there are some updates due for the CLI, we can remove npm prune now. And instead of caching node_modules, we\u2019ll cache ~/.npm\nCan we close this issue?. I\u2019ve seen the core npm CLI developers themselves recommend to not cache node_modules, but ~/.npm instead, so that\u2019s what I\u2019m doing and recommend others to do, too. I must admit I\u2019m probably one of the few people who still haven\u2019t worked with Babel much :) I love the project and their maintainers though, so definitely open to it. I usually try to avoid to to limit the amount of tooling to a minimum, but you make a good case for it here.\nOne thing that I fear (maybe for no reason, I don\u2019t know): what happens when errors occur? How good are error stacks from transpiled code? \nIt\u2019s not only about making semantic-release run in versions less than Node 8, if we keep supporting them officially, there will be an overhead for us as maintainers to keep them working. We have to test in all the node versions and people will report bugs. The alternative is to make it easier for people to setup semantic-release correctly, which feels like a documentation overflow. It will also cause a support overhead for sure, I\u2019m not sure if one outweighs the other.\nTo be fair, if we say \"just use npx\" it\u2019s basically the same problem. But it feels like less overhead for us than introducing babel. But We should add it to our CI tests, because at least for me, it didn\u2019t work: https://github.com/semantic-release/semantic-release/pull/414#issuecomment-330004885\nNode 8 becomes the official LTS version next month. Node 4 remains in maintenance until April 2019. I feel like focussing on the LTS version is good practise.\nSo yeah, I\u2019m undecided. > \"use npx\" doesn't works. npx doesn't transpile or simulate node 8. This is why I made this proposal actually :) If npx was making node 8 packages works on node 4 that would be a no brainer :)\nnpx -p node@8 npm run semantic-release should install and run in node 8, at least that\u2019s how it\u2019s advertised as far as I know \u00af\\_(\u30c4)_/\u00af I guess we have to change how we check for the node version to make it work\n$ node -v\nv4.8.3\n$ npx -v\n9.6.0\n$ npx -p node@8 node -v\nv8.3.0. oh you are right, it\u2019s actually not documented, I\u2019ve just seen Kat tweet about it. I\u2019ll open an issue on the npx repository. The problem is that process.version returns the wrong version when run a an executable file instead of running it with node file.js\nHere is a test script \"funk.js\"\n```js\n!/usr/bin/env node\nconsole.log('\\nprocess.version ==============================')\nconsole.log(process.version)\n```\nAnd a test\n```\n$ npx -p node@8 node funk.js \nprocess.version ==============================\nv8.3.0\n$ npx -p node@8 ./funk.js \nprocess.version ==============================\nv4.8.3\n```\nI dunno if there is a workaround for this. > In the case of npx -p node@8 ./funk.js I wonder if it runs it on node 8 with the wrong process.version or it runs in node 4.\nIt runs in node 4, I tested it. npx -p node@8 ./funk.js works after chmod +x funk.js, but it does not use the node version that npx set, but is using the system node. Agree :). Sounds all good to me \ud83d\udc4d \nBasically if folks us yarn and they want to test in node < 8, they don\u2019t install semantic-release as devDependency, but install it globally as part of their CI? That\u2019s a decent workaround :) . @vanduynslagerp love your solution, let\u2019s add it to our docs! :) . even better :D . do you know what\u2019s up with codecov?. yeah feel free to merge it as is any time, I just don\u2019t do it myself because I\u2019m not sure if you still fine tuning it :) . \ud83d\ude4c . I tried it on my semantic-release test repo: https://travis-ci.org/gr2m/semantic-release-test/builds/282482167#L863\nI\u2019ve git push -fed to remove the commit from the 2.0.3 npm release, and I recreated the v2.0.3 git tag on GitHub for the new commit. Shouldn\u2019t that have worked? I must miss something. > Do you see a scenario that will result in this situation ?\nMy main scenario would be a simpler recovery from the ENOTINHISTORY error. Right now I need to do a manual release. With that change, I could change an existing git tag to point to the correct git hash that is in the master branch and then restart the build to recover. \nBut we should document that as well if we should support it. \nI get your point though, my use case is out of scope of this pull request, if you agree that it\u2019s a good idea, we can still make a follow up PR for that\nSo from my side, I\u2019d suggest to merge & release it, notify folks in #411 and ask them to install the newest version by updating their package.json files and comment on this PR if they run into any trouble, before setting the new version to latest?. > So in the ENOTINHISTORY message instead of suggesting to do a manual release we could suggest to tag the commit that correspond to the last release and restart the build.\nyeah that\u2019d be great. Sorry to make you wait for so long, and thanks for all your great work!\nI agree, I'd go with the 3rd solution but would work on it in a follow up pull request. We can wait to release semantic-release as @latest until we have that ready, but people who know what they are doing can already work with the pre-release.\nI'll review the changes and give it a spin on a sandbox repository of my own :). I've tested it and it works as advertised \ud83d\udc4d https://github.com/gr2m/semantic-release-cli-test/releases\nOnce we make pre-releases on GitHub a first-class citizen feature, how would we recommend to keep releases on GitHub in sync with releases on npm? E.g. ideally, the moment I'd remove the pre-release flag, the release should be set to latest on npm? Maybe we could create a GitHub app for that which also gets setup when using semantic-release-cli setup? Or we add that as a feature to semantic-release-cli, e.g. semantic-release-cli set-latest 1.2.3? . > > Maybe we could create a GitHub app for that which also gets setup when using semantic-release-cli setup?\n\nThat sounds a really good idea !\n\nI'll work on this just for fun and to explore how github apps could work against the npm registry API\nUPDATE: unfortunately blocked by missing webhook \ud83d\ude22 https://platform.github.community/t/release-webhook-not-emitted-on-update/3772. @PatrickHeneise I can\u2019t think of one. I think the only approach would be to add more features to the CLI as suggested above, e.g. semantic-release-cli set-latest 1.2.3, happy to get you going if you want to help with that. > I'd like to see all releases on develop on the dev pre-release tag, without changing the package.json manually.\nI would suggest to suggest to configure the release tag to to dev in general, so all releases will be using that tag. When you merge to master, no release will happen because there are no changes since the last release. Then once you are confident with the new version (e.g. 1.2.3), you\u2019d be able to run \nsemantic-release-cli set-latest 1.2.3. Hmm I don\u2019t see any reason not to :) . +1 on this, sounds great \ud83d\udc4d . Is this fixing an open issue that we have? I don\u2019t quite understand the use case yet :) Can you explain a bit further?. I fear that we introduce a functionality which we don\u2019t yet have use cases for and that we will have to maintain for forever. Maybe let\u2019s leave that open until we hit a blocker that this is the right solution for?. We are also discussing a GitHub app which you can install on any repository and it will do language agnostic releases to GitHub only, stay tuned :). it is published on npm, but using the @next dist-tag. You can install it with npm install semantic-release@next or set the version in your package.json directly to ^8.1.2\nYou can subscribe to this read-only thread for updates: https://github.com/semantic-release/semantic-release/issues/411#issuecomment-333698472. can you point to an example? Or tell us the steps to reproduce it with expected / actual behavior? That\u2019d be very helpful :). hey @ryansmith94, #460 has been resolved via #480, you can use the new version by setting the semantic-release version to \"^9.0.0\"  in your package.json. Can we close this issue?. out of curiosity, why would you want to release a new version if you just refactored without any behaviour changes? If it\u2019s a speed improvement worth releasing, I\u2019d use a fix prefix. Thanks @pvdlg great work \ud83d\udc4d . is the PR ready for review? You still have the WIP in the title so just want to make sure :). > Add JSDoc\ndo you have a preferred library for API docs based on JSDoc comments? I'm looking for one to update https://octokit.github.io/node-github/, too :). sorry I didn't get to review the PR today, but can't wait to get this landed :). Thanks @marcbachmann, I've added this to the release notes\n\n\nIf you depend on npm shrinkwrap, you have to run it before semantic-release now. You can set \"presemantic-release\": \"npm shrinkwrap\" in your package.json file\n\n\nDoes that sound good to you?. > Lock down dependency versions for publication\nhttps://docs.npmjs.com/cli/shrinkwrap\nnpm shrinkwrap writes a npm-shrinkwrap.json file which is published to the npm registry, unlike package-lock.json. ah I get what you mean now. Yeah makes sense to me. But either way, if someone had a use case to use npm shrinkwrap on CI before publishing, they still can do it now. looks good to me now? https://travis-ci.org/electron/electron-i18n#L1583 / https://github.com/electron/electron-i18n/releases/tag/v0.7.4 / https://www.npmjs.com/package/electron-i18n. That sounds super awesome \ud83d\udc4d . Maybe we can make additional plugins for verifyConditions and make them part of core as well, in which we check that the provided NPM_TOKEN/GH_TOKEN are valid, and if either isn't, the release will not happen with a helpful error message?. > The problem is we repeat 3 times the NPM_TOKEN check and the npmrc update.\nI don't think that is actually a problem, if the logic is all contained in one library that all plugins depend on. Another possibility is to have a state that is shared across all plugins, so verify-conditions-npm could set state.npmToken and then the others would depend on npmToken to be set.\n\nNot directly related, but we should also support shortcuts for plugins name in the config, for example we should allow to use \"verifyConditions\":[\"travis\", \"npm\"]\" instead of \"verifyConditions\":[\"@semantic-release/conditions-travis\", \"@semantic-release/npm\"]\n\nI think the long version is much clearer, I wouldn't shorten it :) At least lets start with the long form and we can discuss if we want to support the short form later?. @buehler we already have that with verifyConditions I think? Or what is there anything missing?\n@pvdlg I gave it all some more thought tonight and overall this all makes a lot of sense. I\u2019d move forward with the \"multi-plugin\" idea. It also makes sense e.g. for analyzeCommits and generateNotes, both currently depend on conventional-changelog.\nI think a default configuration like this would make a lot of sense: \n\"release\": {\n  \"verifyConditions\": [\n    \"@semantic-release/travis\", \n    \"@semantic-release/npm\",\n    \"@semantic-release/github\"\n  ],\n  \"getLastRelease\": \"@semantic-release/npm\",\n  \"analyzeCommits\": \"@semantic-release/conventional-changelog\",\n  \"verifyRelease\": [\n    \"@semantic-release/lts\"\n  ],\n  \"generateNotes\" : \"@semantic-release/conventional-changelog\",\n  \"publish\": [\n    \"@semantic-release/npm\", \n    \"@semantic-release/github\"\n  ]\n}\nanalyzeCommits, getLastRelease and generateNotes are clear, they only can have one value. But verifyConditions, verifyRelease and publish are arrays. What happens if  I set \"verifyConditions\": [\"./script/my-custom-verification-plugin\"]? Will it replace the default plugins, or add to it? I\u2019d say they replace the default values, and if I want to keep them, I have to list them explicitly. \nIn my example above I\u2019ve added verifyRelease because I think we will need a default verification to support LTS/legacy version releases.\nI\u2019m no longer sure about generateNotes. At least for our github/npm default, release notes are only relevant for GitHub. Maybe we should move the logic there? Can you think of examples where for example we would want to publish to a GitHub release and another platform which would also include the release notes? Would it want the exact same release notes or maybe different ones per target? I don\u2019t know.\n\nin case of a misconfiguration (for example the NPM token is set but not the Github one) the npm publish would happen but not the github release. Not sure if we can find a clean solution for that. That's quite a edge case though.\n\nIt's actually not an edge case at all. I run into the problem that a package got released but the GitHub release was not created quite a bit. I wish we already had a built-in verifiy plugin for both npm & github today. They plugins would not only check if the respective tokens are set, but also if the tokens include authorization to make the respective releases. \n. We can commit to the Node LTS schedule starting with Node 8 becoming LTS in 5 days (Oct 31). We will not add support for versions smaller than Node 8. To add our motivation behind it: we also have only so much time to maintain the project. Limiting support to just Node 8 has very small impact for this project specifically, but quite a big impact on code maintainability overhead. if that means it would unblock you from joining forces with gitlab support, then yes :) . yes, okay with me \ud83d\udc4d thanks!. done \ud83d\udc4d . it's currently not possible, but @pvdlg is exploring it at https://github.com/semantic-release/semantic-release/issues/484, can we take the discussion there?. The HTML you see there is GitHub's 500 response, so it might have likely be a temporary GitHub server error. But on the other side I don't see any notes at https://status.github.com/messages \ud83e\udd14 . can you install the latest version (^9.0.0) and set the environment variable DEBUG to semantic-release:* on travis? @pvdlg added some more logging and debug output that will help us narrow down the problem if it occurs again.\nI did a few test releases yesterday and did not run into it, so I guess it's not a general problem. yes @pvdlg is right, the new version of semantic-release does not expose the npm publish step any longer, basically we don't give users any choice any more. I'm sorry for that, but I fear the FAQ addition become obsolete with v9.0.0, I'm sorry I should have told you but forgot :(. I'd squash the commits to just fix: log error properties and check SemanticReleaseError by .semanticRelease property, the current commit message is no longer correct, right?. > I renamed the commit properly\nEven better, I just wanted to safe you the extra work and make sure we don't merge it with the old commit message to avoid misleading change logs :). I think all migration notes are in the v9.0.0 release notes.\nCan you run the gh-pages task after the publish? There will be more breaking changes in future, you'll be on the safe side if you add semantic-release to your devDependencies and enable greenkeeper to get notified about a new verson. I've tested the new command but got an error:\nhttps://travis-ci.org/gr2m/semantic-release-cli-test#L564\nIt looks like it cannot access NPM_TOKEN but it is set at https://travis-ci.org/gr2m/semantic-release-cli-test#L422\nI'll look more into it. I don't think it's the access to the environment variable, but the location of the .npmrc file. @pvdlg by the way the %O placeholder doesn't get replaced correctly: https://travis-ci.org/gr2m/semantic-release-cli-test#L564, I don't know why, works for me when testing locally with Node 8\n```\n\nconsole.error('test 12 %O', new Error('funky'))\ntest 12 Error: funky\n    at repl:1:29\n    at ContextifyScript.Script.runInThisContext (vm.js:50:33)\n    at REPLServer.defaultEval (repl.js:240:29)\n    at bound (domain.js:301:14)\n    at REPLServer.runBound [as eval] (domain.js:314:12)\n    at REPLServer.onLine (repl.js:441:10)\n    at emitOne (events.js:120:20)\n    at REPLServer.emit (events.js:210:7)\n    at REPLServer.Interface._onLine (readline.js:282:10)\n    at REPLServer.Interface._line (readline.js:631:8)\n```\n\nBut it doesn't when running in Node 6 or 4. Maybe the execa is messing with the npx command somehow?. I'm okay with supporting only Node >=8.9 as it became LTS today \ud83c\udf89 \n\nnpx -p node@8 -c \"node -e \\\"console.log('TEST %O', {a: 1})\\\"\"\n      => TEST %O { a: 1 }\n\nI was not able to reproduce this \u00af\\_(\u30c4)_\\/\u00af\nMy guess it had an older Node 8 version installed and because it matched the wanted node version it used the local version instead of getting the latest? Try\nnpx -p node@8.9.0 -c \"node -e \\\"console.log('TEST %O', {a: 1})\\\"\". by the way node is just an npm package: https://www.npmjs.com/package/node. So npx installs the node package and runs the command string against its binary, I guess . > I get the error: /bin/sh: semantic-release: command not found\ncan you try the --shell-auto-fallback flag? \nDocs say\n\n--shell-auto-fallback [] - Generates shell code to override your shell's \"command not found\" handler with one that calls npx. Tries to figure out your shell, or you can pass its name (either bash, fish, or zsh) as an option. See below for how to install.. That is currently out of scope.\n\nBut good news is that @pvdlg is looking into making the publish step pluggable in semantic-release via https://github.com/semantic-release/semantic-release/issues/484. Once we have that, I could imagine that you could drop the npm publish step entirely and add a custom release step which writes the current version to package.json with an extra commit.\nI'd suggest to watch #484 for now :). semantic-release calculates the version and writes it into the package.json file before running npm publish. So it is set on the package published to the npm registry, but the version is not part of your source code.\n. @lirantal can you explain your use case a bit more? semantic-release has been around for over 2 years now, and so far the only problem with a missing version on github was that people couldn't install dependencies from their forks, which we fixed by adding a 0.0.0-development placeholder. @lirantal still at https://github.com/semantic-release/semantic-release/issues/497#issuecomment-340620440, but @pvdlg is doing great progress, stay tuned. We will announce all relevant news in this issue: https://github.com/semantic-release/semantic-release/issues/411 if you haven\u2019t yet I\u2019d recommend you all to subscribe to this one. it runs yarn instead of npm install and I don\u2019t know why ... I'm not familiar with yarn but can there be a reason that it doesn't install semantic-release from the dev dependencies? \nCan you add npm ls semantic-release to before_script to see if it gets installed?. I looked for NODE_ENV=production but it doesn't look like your travis build set this environment variable. thanks for the kind words \ud83d\ude2c glad you like the project!\nI'm afraid I have no idea about Artifactory. Did you replace the actual URL with ARTIFACTORY_URL in your logs above? \ne.g. \n\nhttp semantic-release request PUT ARTIFACTORY_URL/-/user/org.couchdb.user:USER_NAME\n\nlooks as if ARTIFACTORY_URL should actually be a host name with username & password for auth.\nIf Artifactory is a drop-in replacement for npm it might lack APIs that semantic-release depends on. The best place to look what npm endopints semantic-relaese is using is @pvdlg\u2019s work-in-progress @semantic-release/npm module: https://github.com/semantic-release/npm/pull/1. It is part of his great efforts to modularise semantic-release to make it work in other environments, so it\u2019s a perfect fit to make it work with artifactory. Here is a preview of the README: https://github.com/semantic-release/npm/blob/initial-release/README.md. Thanks @olstenlarck, I have lots of thoughts on a semantic-release GitHub app, but didn't get to put it into a document yet :( hopefully soon! I'm a big fan of Probot, too. I\u2019m a contributor myself and build some tooling around it. I\u2019ll try to have a look at your app tomorrow \ud83d\udc4d . hey Charlike I didn\u2019t get to the app today I\u2019m afraid. \nCould you please add a note to the description that it\u2019s not an official app from semantic-release and maybe add a link to this issue here? I just don\u2019t want folks to be confused, because it looks somewhat official but it\u2019s not (yet) ;). Hey @olstenlarck I\u2019m glad you got your app working, I\u2019ll definitely check it out myself over the holidays :) I\u2019ll close the issue as it\u2019s not an open bug or feature request, but please feel free to keep commenting updates so that folks interested in it can subscribe to the issue and stay up-to-date :). I dunno, I\u2019ll close the issue, we can investigate it if it happens again. @coolgod I\u2019d suggest you subscribe to the #484 issue that Pierre mentioned, once it\u2019s released, try to build a custom plugin for it and create a follow up issue if you run into any trouble :). Hey @ryan-kimber, we are working towards further modularization of semantic-release. @pvdlg is doing great work on it. The best issue to subscribe to is https://github.com/semantic-release/semantic-release/issues/411, we will keep folks updated there as soon as we have something ready to try. If you could have a look at the open pull requests mentioned in https://github.com/semantic-release/semantic-release/issues/484, that\u2019d be \ud83d\udcaf It\u2019s the perfect time to get involved :) we hope to empower users like yourself to make semantic-release work with their environment and reduce hard coded dependencies as much as possible. I\u2019m wondering about the note in the 2nd breaking change:\n\nthe npm parameter is not passed to any plugin anymore. Each plugin have to read .npmrc if they needs to.\n\nis there a package you are using to read out the npm rc auth? If yes, maybe we can recommend it in the release notes? No need to update commits, we can update release notes later. are the tests working for you when run locally? \nI get tons of \"unauthorized Name or password is incorrect\" errors? Full log: https://gist.github.com/f96f23d4765530db0ad97bae9cbd2500. I\u2019ve stopped my local CouchDB before running the tests. I pulled your latest changes, I still get the same errors. \nI\u2019ve Node 8.9.1 and npm 5.5.1. I\u2019ve deleted node_modules and run npm install again. Still the same result. \nTo only run the integration tests I tried ./node_modules/.bin/ava  test/integration.test.js, same results.\nWanna pair on this?. clearing my ~/.npmrc file made the tests work again. Hey @unional thanks for the pull request and the \ud83d\udc90\ud83d\ude01 \nWe usually don\u2019t recommend to use 0.x.x at all, just like npm does. All versions before 1.0.0 can be potentially breaking so it does not make much sense for semantic-release to be used. \nBut on the other hand, this questions comes up every now and then. So I\u2019m okay with adding a question to the FAQ and I love your workaround, I\u2019m surprised how simple it is :)\nI\u2019d just change the wording a bit. I\u2019d like to make the point that we don\u2019t recommend to publish 0.x.x versions and why as a disclaimer. But if folks still want to do it, they can use your workaround. \nI\u2019ll need a bit to think about the right wording and to lookup some resources, okay if we leave your PR open until then?. Ideally people loose the fair of increasing the major (breaking) version number. These numbers are for machines, not humans. There is really no difference if a project is on version 1.2.3 or 132.2.3, not for our code anyway. At least above 1.0.0, the semantics of each number is clearly specified. . no worries, doesn\u2019t feel like ranting at all :) I\u2019ll get back to you with feedback on the wording. Thanks again for the pull request and insights into your perspective, much appreciated. Thanks for sharing your perspective on this. I\u2019m sorry that we can\u2019t make everyone happy, we have to make choices somewhere, and we cannot change it in regards of 0.x releases.\nSame holds true for \"version numbers are for machines, not humans\". We still try to keep breaking versions to a minimum and there are things we plan to do to reduce the maintenance overhead for supporting things like LTS version and scheduled releases.. I hear you, I\u2019ve been there. The only cure is too loose your hesitation about 1.0.0 and major releases in general :) It was hard but things got so much easier afterwards. You can add a clear notice in the README that the module is still experimental.\nWe also have an FAQ entry here: https://semantic-release.gitbooks.io/semantic-release/docs/support/FAQ.html#can-i-set-the-initial-release-version-of-my-package-to-001. That is a great use case for github apps :) It\u2019s fairly simple to do, e.g. check out https://probot.github.io/apps/validate-commit-msg. Thanks for reporting the issue!. ~~I\u2019ve tried to enable more debug output: https://github.com/gr2m/github-graphql-schema/commit/f5835bb48107639c63331778fe6d1d2e45dbf08e but either there are none or it didn\u2019t work~~ nevermind, forgot I have to set the DEBUG environment variable. \u00af\\_(\u30c4)_/\u00af restarted the build with DEBUG set, now it worked. maybe we can log sth like Load plugin verifyConditions from @semantic-release/npm?. Wow, you put lots of thoughts into this. I love the idea of \"Branches naming convention\"!\nHere some notes from my first review. I\u2019ll give it some more thoughts with suggestions on how to move forward :)\n\nDistribution channels to make unstable version available to early adopters. Usually named next or unstable.\n\nI\u2019ve never seen a dist tag called unstable. Maybe just leave it at \"Usually named next?\n\nA software meant to be used by final users\n\nend users\n\n\"channel\"\n\nI wonder if instead of \"channel\" we should call it \"npm-dist-tag\", to make it super clear what it is?\n\npush to 1.x.x or 2.x.x branches\n\nI think it\u2019s more common to call them 1.x and 2.x branches\n\n(Pre-releases) \"branches\": [\"master\", \"4.0.0-beta\", \"5.0.0-alpha\"]\n\nWhen I push to the 4.0.0-beta branch and it releases a 4.0.0-beta version to npm, what happens with the GitHub release notes? I think there would be a conflict with the branch 4.0.0-beta as the release would need a git tag with the same name, I think that is not possible, but I haven\u2019t checked it.\nI\u2019m also not sure if releasing these pre versions to @latest is the right approach? Because if I do npm install my-pkg I get my-pakg@4.0.0-beta if it\u2019s released to latest, I\u2019m not sure if that is the intent? Shouldn\u2019t these rathe be relesed to @beta release channel instead?. @travi when you have ongoing branches where you develop features, why do you need to publish it to npm at all? Why not install from git directly in these cases? Setting a version to \"travi/repo-name#feature-branch-name\" is simple enough? You could create \"travi/repo-name#some-feature-alpha.1 and if a breaking change comes up just create another branch and ask folks to give it a try by installing `\"travi/repo-name#some-feature-alpha.2\". I don\u2019t see the benefit of npm here, people wouldn\u2019t get new versions automatically with npm, but they would with the install from git, you\u2019d have full control.\nIf you have feedback to  semantic-release/evolution#1 I\u2019d suggest you comment directly on it, that\u2019s why we do it :). > i'd love to see greenkeeper change that if a project already depends on a pre-release :)\nI mean that if you release a fix then people won\u2019t get it automatically.  Greenkeeper might eventually be able to notify you about the changes, but just running npm install will not install the newest version because there is no semver version range that covers 2.0.0-beta.1 and 2.0.0-beta.2, they would be treated like breaking changes.. I\u2019ve published a maintenance release for @octokit/rest: https://github.com/octokit/rest.js/releases/tag/v15.18.1\nConfiguration:\njson\n[\n    \"@semantic-release/npm\",\n    {\n        \"path\": \"@semantic-release/github\",\n        \"assets\": [\n            \"dist/*\",\n            \"!dist/*.map.gz\"\n        ]\n    }\n]\nIt also had publishConfig.tag = \"deprecations-for-v16\" which I forgot. \nThe publish comment on the PR mentioned that the package was published using the @latest dist tag: https://github.com/octokit/rest.js/pull/1158#issuecomment-447060785\nThere was no publish comment on the issue which the PR closed.\nOther than that it was magical \u2728 . I just set this up for nock. I successfully released a beta pre-release https://github.com/nock/nock/releases/tag/v11.0.0-beta.1%40beta, but after I merged more pull requests into \"beta\" the publish failed with the error\n\nsemantic-release cannot push the version tag to the branch undefined on remote Git repository with URL https://[secure]@github.com/nock/nock.git.\n\nhttps://github.com/nock/nock/issues/1304. build error on travis\nI think the problem might have been that I merged multiple pull requests into quick succession, before the current build could finish. The last build was able to finish and did not have the problem. When the git push --dry-run https://[secure]@github.com/nock/nock.git HEAD:beta command fails due to (non-fast-forward) error, it creates an issues saying that the problem is \"The push permission to the Git repository is required.\"\nhttps://github.com/nock/nock/issues/1327\nnock is using 16.0.0-beta.13. I had another of the ! [rejected] HEAD -> beta (non-fast-forward) errors. We are using the latest beta of semantic-release. I\u2019m now fairly sure that it\u2019s a timing problem. I merged several pull requests in quick succession, I assume that while the release build started, I merged another pr, hence the non-fast-forward error. \nI wonder if we could add an error handler for that error to check if the last remote commit changed and if it did, log a more helpful message and then exit without an error, as we can assume that the new commit triggered another build?\nhttps://travis-ci.org/nock/nock/jobs/475937483#L505\n[10:13:48 AM] [semantic-release] \u203a \u2714  Run automated release from branch beta\n2019-01-06T10:13:48.430Z semantic-release:git Error: Command failed: git push --dry-run https://github.com/nock/nock.git HEAD:beta\nremote: Invalid username or password.\nfatal: Authentication failed for 'https://github.com/nock/nock.git/'\n    at makeError (/home/travis/build/nock/nock/node_modules/semantic-release/node_modules/execa/index.js:174:9)\n    at Promise.all.then.arr (/home/travis/build/nock/nock/node_modules/semantic-release/node_modules/execa/index.js:278:16)\n    at process._tickCallback (internal/process/next_tick.js:68:7)\n2019-01-06T10:13:48.836Z semantic-release:git Error: Command failed: git push --dry-run https://[secure]@github.com/nock/nock.git HEAD:beta\nTo https://github.com/nock/nock.git\n ! [rejected]        HEAD -> beta (non-fast-forward). I just tried to release a 7.x release for Probot. I think everything was setup created, the 7.x branch was created based on the last 7x release tag (v7.5). But instead of creating 7.5.1, it created a tag v7.0.0@7.x and I\u2019m not sure what exactly it did on npm?\nHere are the full logs: https://travis-ci.org/probot/probot/jobs/501226804\nUpdate 1\nOh it actually got rogue and after \"releasing\" 7.0.0, it continued with all the other existing tags :( https://travis-ci.org/probot/probot/jobs/501226804#L595 we canceled it eventually after it created v7.0.0@7.x, v7.1.0@7.x, and v7.1.1@7.x\nUpdate 2\nI manually create the tag v7.5.0@7.x and updated the @release-7.x npm dist tag to point to 7.5.0, then pushed another fix commit, but it continued with creating where it left off and created v7.2.0@7.x so I canceled it again: https://travis-ci.org/probot/probot/jobs/501234571#L507\nUpdate 3\nIt now worked as expected, after creating all in-between branches: https://travis-ci.org/probot/probot/jobs/501237021\nTurns out, @latest dist tag points to 7.5.0, we should have merged into master in the first place because v8 was only released on @next so far. \nBut still the above behavior looks like a bug\n. Oh it actually got rogue and after \"releasing\" 7.0.0, it continued with all the other existing tags :( https://travis-ci.org/probot/probot/jobs/501226804#L595 we canceled it eventually. Hey @felixfbecker, thanks for all your suggestions on for getting this going \ud83d\udc4d\nWould it be okay if we start a new PR to document configuration for build stages and Circle CI and then we take it from there?\nI think that will make it easier to move things forward after the discussion stalled here.\nI suggest we create the documentation for the parts we agree on and then do follow up issues for the parts that can be improved.. after_success:\n  - npm install -g travis-deploy-once\n  - travis-deploy-once \"npm run semantic-release\"\nI like the separation of semantic-release and travis-deploy-once \ud83d\udc4d \nInstalling travis-deploy-once in travis instead of as a devDependency might be problematic though in case we ever release a breaking change. Maybe change it it to\nnpm install -g travis-deploy-once@3\nAnd when we release a v4, we can log a deprecation warning for the latest v3. > Moving the verification of the branch and PR in the core\nI wonder if maybe instead of moving all the logic into core, we could replace @semantic-release/condition-travis with a generic @semantic-release/ci?. > plugins are better suited for optional things users can enable/disable and releasing from a PR (by disabling @semantic-release/ci) is not really something that would make sense. \nas long as we can assume that everyone wants to release from a CI, that works. But for example @bkeepers tried to do a release from his local machine the other day, as the automated release process is not a good setup for @probot. Would that be possible with the built-in CI detection? I agree that this is out of scope of semantic-release, automation is at its core, I just want to make sure we don\u2019t block legit use cases where people want to run semantic-release on custom environments which would not be detected by env-ci. > Which comment are you referring to?\nnevermind got lost in PR reviews :) . re: local release. I think it\u2019s too much effort for a use case we don\u2019t really want to support.\nIn Brandon\u2019s case, I see ways to allow for semi-automated releases, but it will require a GitHub app. Can\u2019t wait to finally get going on this :) . > - travis-deploy-once \"npm run semantic-release\"\nThis will not work by itself. You\u2019ll need to do ./node_modules/.bin/travis-deploy-once \"npm run semantic-release\", but that\u2019s not OS agnostic. I\u2019d stick with npm run travis-deploy-once or do npm run -s travis-deploy-once\n\nnpm run travis-deploy-once \"npm run semantic-release\"\n\nI think you need to separate arguments you want to pass to the travis-deploy-once binary using --. So the full script would be \n\nnpm run travis-deploy-once -- \"npm run semantic-release\"\n\nI wonder if we should just go ahead and create stages from the beginning instead of installing the additional travis-deploy-once dependency? . > Agreed, but maybe in a later step?\n\ud83d\udc4d . good point, as long as it\u2019s not run in Windows, ./node_modules/.bin/travis-deploy-once should work just fine.\nThe polling is a hack but it\u2019s fairly robust by now. Having to different solutions for travis-ci.org/com and Enterprise is reason enough to not go with Stages yet. We can switch once stages land in Travis Enterprise. > when all CI passes\nas an alternative, we could listen to events when pull requests get merged. @olstenlarck none of us are native English speaking. Could you please self-moderate or delete your last comment, it is unnecessary confrontational. Thanks . thanks for the testing and the PR @kbrandwijk @schickling. I reviewed the PR at #167 and code-wise it looks good. I don\u2019t have a CircleCI setup to test it out and don\u2019t have the time to do so, but I trust you that it works :) \nWould you be interested in joining the semantic-release community and help out with all things related to CircleCI? Neither Pierre nor I do have a lot of experience with it, so it would be very helpful to have you (and other folks interested) to take ownership of making sure that semantic-release works great with it.\nWe don\u2019t have a lot of processes in place yet, but I\u2019d setup a new Team and invite you both to it, so we can mention in in related issues / PRs and give you write access to all relevant repos, so you can create pull requests from branches instead of forks, among other things.\nLet me know if you are interested  :). @kbrandwijk sorry for the delay! https://github.com/semantic-release/cli/pull/167 is merged \ud83c\udf89 And I\u2019ve invited you to the newly created @semantic-release/CircleCI team :) It currently has write access to the cli repository and I\u2019ll give it access to all repos as needed\nYay, welcome to the team! Hope we can chat some time soon!\nCan we close this issue now?. sorry my fault, you should have gotten it now :) . we could take advantage of an undocumented GitHub feature: multiple issue templates. See this repository for a demonstration: https://github.com/clarkbw/team-plates/ :) We can also do it in a follow up PR?. try one of these:\n\nBugs: https://github.com/clarkbw/team-plates/issues/new?template=bug.md\nFeature Requests: https://github.com/clarkbw/team-plates/issues/new?template=feature.md\n\nThere is no UI for this feature yet, which is why it wasn\u2019t publicly launched yet.. false positive. I have seen random 404s from GitHub\u2019s API as well. They way I worked around them is to implement  a 1s delay between write requests. see https://developer.github.com/v3/guides/best-practices-for-integrators/#dealing-with-abuse-rate-limits\n\nIf you're making a large number of POST, PATCH, PUT, or DELETE requests for a single user or client ID, wait at least one second between each request.\n\nThis is something that I plan to built into @octokit/rest core (renamed for github), so these errors should go away. > Are the 404 due to go over the rate limit? Should it be another type of error like 429?\nI know, there are tons of different abuse limit mechanisms. I thought it might be related to this\n\nRequests that create content which triggers notifications, such as issues, comments and pull requests, may be further limited and will not include a Retry-After header in the response. Please create this content at a reasonable pace to avoid further limiting\n\nBut in this case, creating a tag, does not trigger notifications, so that\u2019s new to me, too. I\u2019ll investigate this with the GitHub platform team, I\u2019m curious myself. \nEither way, adding the 1s delay for write operations will fix it. \nIt might take a while until this lands in @octokit/rest, but I can create a @semantic-release/octokit-rest package that adds that for us using experimental APIs of the @octokit/rest package. I\u2019ll have time next week Tuesday to look into it. not a fork, a module that depends on and pins the version of @octokit/rest. We would use the octokit.hook API (which is available, but not yet documented, hence experimental) which might or might not break between patch releases. That way we can make our semantical versions. I\u2019m assuming here that we would use @octokit/rest in more than one of the semantic-release modules? If it\u2019s just one, we can also put the logic in there and pin the version of @octokit/rest. A wild @boennemann appears \ud83c\udf89 \ud83d\udc4b  Thanks for the links :)\n@pvdlg can you confirm that @semantic-release/github is the only one using github/@octokit/rest right now?\nEither way, I can work on this next week. See the retry link above in Stephan\u2019s comment to see how it\u2019s currently implemented in Greenkeeper using the octokit.hook API. Here is a simple usage example of the hook api: https://github.com/octokit/rest.js/tree/master/lib/plugins. It\u2019s https://github.com/gr2m/before-after-hook under the hood. > I don't think octokit.hook is the best solution though. octokit.hook allow to run something before or after\nYes it\u2019s not a very elegant solution for the retry, I\u2019m thinking about that right now and will work on it next week\n\nIt should probably be handled on the GitHub backend (by return a proper 429) or in the API client. At least it worth reporting the problem to GitHub and see what they say\n\nYes I\u2019m talking to them, I\u2019ll keep you posted.\n\nAnother thing to consider is that several times when I experienced these random errors, they would persist for a couple hours\n\nLocally, or on CI? I\u2019ve seen it on travis in a cron job that always runs at the same time. After adding the 1s delay, I haven\u2019t seen it happening again. wow I also did not know that! 0_o\nYeah let\u2019s use deploy for now. Eventually using stages will probably be the best thing to do, but for now let\u2019s make sure we replace the current recommendation\nThanks @travi \ud83d\ude47 . fyi I rephrased the title to better represent what you try to achieve, please correct me if I got it wrong. The original sounded like you just wanted to disable the publish to npm, but I think the actual challenge is the custom deploy to a branch. Thank you @newyork-anthonyng \ud83d\udc90 . This all sounds great to me! For finding PRs/issues to comment on to notify contributors about the release of their changes, see the implementation of https://github.com/release-notifier/release-notifier. yeah I think that is all within scope for the release-notifier app, too. I talked with @zeke, we can extract the logic into a reusable library that could be used by both, the release notifier and a semantic-release notifier plugin. let me know if I can help with using the GitHub API :). can you double check if this works with private repositories?. just some wage problems I run into in the past, I can recall it exactly ... but sounds like they wouldn\u2019t apply. Let me review the code :). @brettstack it\u2019s all automatically released using @next dist-tag, this one in https://github.com/semantic-release/semantic-release/releases/tag/v13.1.3. no opinions either way. I don't think that it's too complex to need a templating language, and I don't think it will change a lot, so probably we are fine without mustache?. it\u2019s published using the @next dist-tag. You can see it with\n$ npm info semantic-release@next version\n13.1.3\nyou can instal it with npm install semantic-release@next\nYou can find out more about dist-tags at https://docs.npmjs.com/cli/dist-tag. problem is that the regex resulting from this line\nhttps://github.com/semantic-release/semantic-release/blob/cbf57851fbf84502bf408a19b8008d226432edf7/lib/hide-sensitive.js#L4\nends up with a value like this /123reducted|||456reducted/g. I think that should do the trick\ndiff\n- toReplace.map(envVar => escapeRegExp(process.env[envVar])).join('|')\n+ toReplace.map(envVar => escapeRegExp(process.env[envVar])).filter(Boolean).join('|')\nDoes that look good? I can prepare a PR for it. Great. If anyone wants to help out, please go ahead :) Happy to have someone new submit this pull request. I can do it otherwise on Friday. Pull requests welcome :) Thanks for your help!. yes, I think that should be \n\nDefault: false if running in a CI environment, true otherwise\n\nBut maybe double check the code to make sure :) . I'd keep it simple and \n\nOr for simplicity sake we can just rename 13.4.0 to 14.0.0 and just remove 13.3.0 and 13.3.1.\n\nthen deprecate 13.3.0 and 13.3.1. sounds good \ud83d\udc4d . > always first deprecate a feature and add the alternative in a minor version, then remove the deprecated feature in a major\nI agree that this is best practise. From my experience it doesn\u2019t happen until there is a release process in place with different people being in charge for different parts. I'm not sure we can tackle it yet, but we sure will in future.. yeah, here: https://github.com/node-nock/nock/commit/315104d4c7390199d60fc0c062abdd4ab6a11e89\nSquash & merge adds the pull request reference by default so I usually keep it there. Did it work before? Or is this an initial setup?. No idea what could be going on here :/ . Hm I set DEBUG=semantic-release, see https://travis-ci.org/gr2m/octokit-rest-routes/jobs/352181416#L424, but output is still the same as far as I can tell? Is that an unrelated bug? I\u2019ll change the command to run with --debug. so, with the new commit and --debug it worked \u00af\\_(\u30c4)_/\u00af\nhttps://travis-ci.org/gr2m/octokit-rest-routes/builds/352421582#L1987\nbut there are some one error message in there\n[Semantic release]: Running semantic-release version 15.0.2\n2018-03-12T16:28:57.391Z semantic-release:get-version-head Error: Command failed: git push --dry-run git+https://github.com/gr2m/octokit-rest-routes.git HEAD:master\nfatal: Unable to find remote helper for 'git+https'\n    at makeError (/home/travis/build/gr2m/octokit-rest-routes/node_modules/execa/index.js:169:9)\n    at Promise.all.then.arr (/home/travis/build/gr2m/octokit-rest-routes/node_modules/execa/index.js:274:16)\n    at <anonymous>\n    at process._tickCallback (internal/process/next_tick.js:188:7)\n2018-03-12T16:28:57.396Z semantic-release:config options values: { branch: 'master',\n  repositoryUrl: 'https://[secure]@github.com/gr2m/octokit-rest-routes.git',\n  tagFormat: 'v${version}',\n  _: [],\n  debug: true,\n  '$0': 'node_modules/.bin/semantic-release' }\nDoes that ring a bell?. Thanks for the extended bug report! Could you please create a follow up issue? It will be easier to track for us. My issue was fixed so it looks like yours is slightly different.\nv15.0.3 had a change related to the URLs, maybe that\u2019s a good place to start digging: b0b4fc8. Thanks!. Could you please create a follow up issue? It will be easier for us to track. @SirWindfield I think the problem is your publishConfig https://github.com/SirWindfield/workspace-runner/blob/24b24636be707cd56c7f15fc5ca09e498965c492/package.json#L78-L80\nThe error at https://travis-ci.org/SirWindfield/workspace-runner/jobs/354582377#L525 says \n\nCan't restrict access to unscoped packages\n\nWhich means you can\u2019t restrict access for packages that don\u2019t have a scope. It would work for \"name\": \"@sirwindfield/workspace-runner\" given you have the paid plan on npm. I think I pushed an update to master while the CI build was created on Travis, probably quite an edge case.\nI wonder if we can ignore this error altogether? We just want to check if the token has write access, right? . > if the output change in a different git version it won't work.\nyeah that\u2019s fair\n\nMoreover I don't think we should consider this as a success because in this situation when we do the actual push to create the tag, it will fail as well, isn't it?\n\nwe create the tag using the API, not with the execa & git? \nThis is all probably just an edge case, I\u2019m fin with closing it. If it occurs again / more frequently we can think about how to work around it. I remember now, thanks!\n\nMaybe we can add a test to make sure the remote head and the local head are the same.\n\nYes, that sounds good\n\nAnother solution would be to force a pull but that probably not a good idea as we would run semantic-release on a different code than the one on which the CI ran the tests.\n\nAgreed. It looks to me like the verifyRelease would be the right place, the new version is calculated (but not yet set in package.json): https://semantic-release.gitbooks.io/semantic-release/content/docs/usage/plugins.html#verifyrelease-plugin. oopsiedooopsie I merged the others \ud83e\udd26As it\u2019s just a dev dependency I suggest I leave it at that unless tests start to break. good idea on adding the requirement to the docs. We could maybe also check for the git version and show a more helpful error message? \nWould you like to send a pull request for either or both?. Was that an accident?. I think you can run a custom script in the prepublishOnly script, see https://semantic-release.gitbooks.io/semantic-release/docs/support/FAQ.html#how-can-i-use-a-npm-build-script-that-requires-the-packagejsons-version- \nAt this point the version in package.json is set. Your custom script can read it and write it into your build files. you can use semantic-release without publishing to npm, you can create a prepare plugin at which point the new version will be available to your script, see for example https://github.com/GabrielDuarteM/semantic-release-chrome/blob/dd75ea42bdc6a21a138ae76fc73dd13b2570d43d/src/prepare.ts#L22\nsee also https://semantic-release.gitbooks.io/semantic-release/docs/extending/plugins-list.html. I agree with @pvdlg, we can leave the issue open for some more time to see if others have a similar workflow, but I can\u2019t recall anyone form the past. Hey I\u2019m sorry I don\u2019t yet understand what you need exactly, and why?\nIf I understand correctly, you want the release build on Travis to be triggered by the a commit to a master branch. But then in that build you want semantic-release to check out the source branch and do its release from there? \nYou can configure a custom branch for  semantic-release, e.g. set it to \"source\", but the workflow you are looking for is not. I think your best option is a more common workflow, I head about your setup for the first time. It\u2019s BREAKING CHANGE:, not BREAKING:. You can customise the conventions to your preference, see https://semantic-release.gitbooks.io/semantic-release/#commit-message-format. Is it a private repository? A 404 error from GitHub\u2019s API usually means that there is something wrong with authentication. It\u2019s a problem when it\u2019s a problem :) I\u2019d suggest if someone runs into it in a production setting then we will address it. I think that could be done using an analyzeCommit plugin: https://semantic-release.gitbooks.io/semantic-release/docs/usage/plugins.html#analyzecommits-plugin\nWe might incorporate into semantic-release core but a plugin would be the first step. > I'll raise this over here then: semantic-release/commit-analyzer. :)\nEither place works for discussion :)\nNote that semantic-release/commit-analyzer is the default plugin to analyze commits. You can replace it with your own module that also parses squash-merges. I do squash-merges all the time on GitHub to fix the commit messages so that the right version gets released :) \nI\u2019d suggest you make a fork and release it first so you get unblocked and get test it in production. Then we can start a PR against the default plugin and see if we can merge it in.. > How does a regular merge work?\nI\u2019m not sure what you mean? semantic-release only runs on your main branch\u2019s CI builds. It doesn\u2019t matter if new commits are coming from a PR or have been pushed to the main branch directly. It just goes through all new commits and calculates version & changelogs based on that. I\u2019ve seen similar odd logs before, semantic-release redacts values of private environment variables, I\u2019m certain it is related to that. But I haven\u2019t seen that one specifically yet. Can you look trough past issues and see how we resolved it in the past?. Confirmed. See also https://github.com/mikaelbr/marked-terminal/issues/40. @UziTech note that you should remove the npm@2 install here: https://travis-ci.org/UziTech/number-string/builds/381739610#L453 :)\nIt only fails in npm@2, the other npm versions only log warnings. So I\u2019d say no need for any action on our side. Node v4 is no longer supported, current LTS version is Node 6 which comes with npm 3\nBut we can leave the issue open in case others run into this. If you do, simplest fix is to stop testing in Node 4.. Thanks!. Hi @ihtiht welcome to semantic-release! @pvdlg suggested that it\u2019d be great to work on a better logo a while ago, maybe he put some thoughts into it. I\u2019m open to suggestions myself :) . Hey @ihtiht! I checked in with Pierre and we think the idea with the two colors was worth to give a try, but I don\u2019t think it works well when looking at it. I also think that the logo should work in black/white, too.\nI wonder if you could try to make the packet more the center body of the rocket. The rocket itself could be square. The wings could be directly attached to the \"package\" and the top could be more like a pyramide. You could play with the perspective a bit so that 3 wings would be visible if they are attached to the corners. Instead of having the front and back corner in one line, maybe shift the perspective so that we look a bit sideways, it might make the logo more interesting. You could also play with the perspective to make the logo less high. The current perspective of the package is 45% from top, maybe make that more like 20%. \nI\u2019m really not good at this, but I hope it helps to explain what I mean :D \n\nThese are just inputs, feel free to experiment some more with own idease. sounds good to me! I\u2019m a bit concerned about all the new packages, it would be good to find other folks take ownership over them? . okay, let\u2019s do it :). I think semantic-release requires node 8 since version 12: https://github.com/semantic-release/semantic-release/releases/tag/v12.0.0. I think the current version should still work with it?\n. > @gr2m we talked at some point to have such feature implemented directly in the Octokit client. Do you know if it is still planned?\nYes it\u2019s planned, I\u2019m not working on it yet, but hope to soon, as in over the next 2-4 weeks. @shawnbot I\u2019ve learned from @JasonEtco that he successfully pushed to a repository using this form https://x-access-token:${GITHUB_TOKEN}@github.com/${GITHUB_REPOSITORY}.git, is this something we should try? Or shall we wait until GitHub resolves it. > To release this feature I propose to:\n\n\nRename the branch caribou to master for consistency. That also allows us to use the default config.\nCreate a beta branch and merge this PR in it, so we would release v16.0.0-beta.1 for people to test. This way if we find issues that are solved by a breaking change we can do it on the beta branch and we don't have to release a v17.0.0, v18.0.0 etc... for fixes on this feature.\nCreate the branch next for working on next major release in the future.\n\n\nBig +1. NNNNNNICEEE!!!!!\n. it was fixed in https://github.com/octokit/request.js/pull/15/files, a new release is already out. I would suggest to leave out the pull-request flow and suggest to directly commit to master. If people care, they will know how to do it with pull requests.\nI would suggest something like this\n\nreplace \"0.0.0-development\" in package.json with the next patch version of your package.json file. Find the current version with npm info <package name> version\nrun npm publish\nrevert the change to package.json\ncreate a new tag with the new version, prefixed with v. So if the new version is 1.2.3, run git tag v1.2.3\ngit push --tags\nIf you like, create a new release with the latest changes, as semantic release failed for the release. But it will work again from now on. oh my, I forgot the most important thing: thank you so much for putting time into this and sorry it took so long to get back to it. I\u2019ll help to maintain semantic-release now, you can follow news at https://github.com/semantic-release/semantic-release/issues/411. can you make this a log.info please?. can you explain why this change was needed? Just want to make sure that merging this change won\u2019t break something else, also want to better understand you changes :). shall we bump to npm 5, too?. I know people will have strong opinions about. I know this is meant to sound fun & human, but it just provoke heated emotions. I would suggest the information super dry here, the argument is solid, no need to tell anyone not to fret, I\u2019d just go straight into a simple, clear explanation.. similar to my comment above, I\u2019d suggest to leave it out. . Yeah I have the same protection enabled for master on most of my repositories, too. But for the troubleshooting section, I\u2019d describe the most simple case. When people don\u2019t want or can\u2019t push to master, they will figure it out because they know what they are doing. For newbies who just work directly on master, the simplified version is easier. \n\nWe can leave the npm version x.y.z step, I thought to leave it out to avoid an extra commit, but then again, I can work around this myself, but for newbies it will be simpler this way, you are right \ud83d\udc4d . would it  be enough to check here if .npmrc file exists? And if it does, skip the code below? That way we don\u2019t need to introduce another configuration. But I\u2019m not 100% sure that this wouldn\u2019t break someone else\u2019s setup. You are replacing creating the v1.2.3 tags. We will not remove that feature. But we could additionally create a tag if a custom tag is set in publishConfig.. Don\u2019t change an existing test, please create a new on. instead of creating a single tag, we know would create 2 tags at once:\n\nthe version tag in the form of v1.2.3\nthe release tag which matches the name of the tag used to publish the package on npm\n\nDoes that make sense?. the tests should pass, they just did about 19h ago on travis:\nhttps://travis-ci.org/semantic-release/semantic-release/builds/275739048\nThe tests that currently fail are related to your changes.\nBefore the changes, what errors do you see?. try to run in node 8, we recently deprecated support for lower versions via https://github.com/semantic-release/semantic-release/pull/414\nI think you also need to setup CouchDB locally for the integration tests to work: http://couchdb.apache.org/. have you installed CouchDB? Can you run couchdb in your terminal?. The whole setup is not ideal right now, I don\u2019t even know if it\u2019s working on Windows :( \nas a workaround, can you try to adapt these lines for local testing:\nhttps://github.com/semantic-release/semantic-release/blob/88b5895f800f608eca3f1f4b435b34891d00082d/test/registry/start.sh#L22-L23\nChange the port number in L22 to to 5984 and comment out the second. Make sure you created an admin account with username \"admin\" and password \"password\" at http://localhost:5984/utils/. I\u2019m sorry for the trouble, thanks for your patience! If it doesn\u2019t work, you can still push and have travis run the integration tests. . nothing changes, if we release a new version 1.2.3 to npm, we will still create a git tag v1.2.3. But if publishConfig.tag is to set \"next\"  then we can create an _additional git tag called next. \nWhat I\u2019m not exactly sure about is what happens if a git tag next already exists from an earlier release. We would probably check if it does, if yes delete it, then create it again.. yes :) . The change looks good to me in general, but I wouldn't like to merge it without a test. Could you add one?. do we need to wrap this block into ()?. I\u2019ve seen it in a few other places, too. ah got it, it\u2019s fine, code is readable as is, I was just curious. And learned something, thanks \ud83d\udc4d . > I'm thinking of doing a bit more refactoring in other PR actually. Mostly modularize a bit and splitting thing in different function.\nThat would make the code clearer, allow us to write more docs in the form of jsdoc.\nAlso that would simplify a lot the situation like were have to reuse variable.\nyeah +1 on doing that in follow up PRs, this one is quite big already\n\nWith more modularization, each function that throws could handle it's errors (ie process the error and rethrow a SemanticRealseError) so in the parent module that calls them we could have only one try catch block.\n\nSounds good to me. they will also fail when you run npm test locally. @pvdlg @Apidcloud are you sure we need that flag? What are current use cases for it? I'm reluctant to add more configuration if we can avoid it. I wonder if is-pre-release.js would be a better name for the file?. see comment above, I would prefer\njs\nconst preRelease = isPreRelease(config);\ncamelCase for preRelease. camelCase. camelCase. camelCase. camelCase. ah got it. It's tricky though, I think I would make it explicit in the argument passed to github using prerelease: preRelease to keep our naming of the variables coherent?. > Might be useful when you release on a legacy/LTS/old version dist-tag.\nI think this is a separate use case that we should address separately. My understanding is that this PR is all about setting the pre-release flag on releases when publishing to a custom tag?\nWe don't really support LTS releases yet, do we? That is a valid use case by itself but I think it will need other features like a built-in restriction of not allowing breaking feature releases and using a major version as base, so that even if v3.0.0 is already released, it can still release v2.0.1. typo: teh. nitpick: space after %s also in other places in the code. Or is that intentional? . > Kind of feel bad that I asked @Apidcloud to add it...\nI know, I understand, but remember Open Source is free as in puppy, once we take it, we will have to maintain it until the end of time :) Better have a longer, uncomfortable discussion upfront, that's how it goes some times, time gets spent on work only to realize it won't get merged. Still better than the alternative of accepting changes and than maintaining them for forever ;). also just to make that clear, I want to make LTS releases a first-class feature of semantic-release, so we can leave it safely out of scope for this feature. If plugin developers extend the SemanticReleaseError then the name will change, see @felixfbecker's question at https://github.com/semantic-release/error/pull/71#discussion_r147571577?\nWhat was your thinking behind changing the condition to check for the name?. love it, good solution \ud83d\udc4d I reviewed & merged semantic-release/error#72. diff\n- The fit repository URL\n+ the git repository URL. What format can the git repository URL have? Maybe we could add a few examples or link to the package we use to parse the URL?. can we change the port? It\u2019s the CouchDB default port, if folks have running it locally, the tests will fail with Error starting userland proxy: Bind for 0.0.0.0:5984 failed: port is already allocated. Greenkeeper no longer needs to install any dependency, it works as a GitHub app that needs to be installed on the repo. It does require a package.json file though. But GK is only relevant for node apps. I suggest to leave out the script part altogether, I think the receipt should focus on the semantic-release, weather you have a build or lint script that you want to run next to npm test depends on the respective project. Agree. Maybe change the comment though to something like \"Use the latest Node LTS version\". agreed. I agree with Pierre. I see your point Felix, but I think you try to solve multiple things at once with these instructions. The main objective is to help folks setup semantic-release. The : branch = master AND type = push AND fork = false is an optimization ahead of where the user currently is. The less other code we show, the simpler it will be to follow instructions.. I\u2019d prefer the except, too. Keep it simple. Maybe folks haven\u2019t heard of greenkeeper and it adds to the mental overhead while learning to setup semantic-release. It\u2019s addressed via semantic-release/travis-deploy-once#30, let\u2019s leave it in. okay, I\u2019m lacking the experience with non-Node projects, I feel like we are guessing here :) let\u2019s go ahead with it and see how folks adapt it and what trouble they run in \ud83d\udc4d . To be more precise, we could say \"This run was not triggered in a known CI environment (https://git.io/vbA4g). Running in dry-run mode.\". and can opts.dryRun be already set to true at this point? In that case the condition should maybe be\njs\nif (!isCi && !opts.dryRun) {\nso folks don\u2019t see that message when running with the dryRun option explicitly . why the %s placeholder here?. Maybe add a comment referencing https://github.com/npm/read-package-json/pull/77 for explanation? . maybe differentiate between \n\nDefault plugins - used by semantic-release by default\nOfficial plugins - repo on github.com/semantic-release/*, package name with @semantic-release/ scope\nCommunity plugins - all other plugins\n\nOver time we can define requirements for plugins to be added to 3.. And the process of how a community plugin can be \"upgraded\" to 2.. . Instead of saying \"set of semantic-release plugins\" I would suggest we list the extension points separately, like so\n\n@semantic-release/github\nverifyConditions: Verify the presence and the validity of the authentication and release configuration\npublish: Create GitHub release\n\nThis would make a good overview of all plugins and their extension points.. Regarding wording: the title of this page is Semantic-release plugins, and the description of the plugins also has \"plugins\" in them. I think for clarity it would be good if we had different names for the two things. The latter could be called \"extension points\" or \"hooks\". The definition of a plugin would be a module that extends semantic-release by hooking into one or multiple extension points.. no need to link npx twice. let\u2019s lowercase semantic-release everywhere. It\u2019s our brand now :). multiple version_s_. Let\u2019s try to avoid abbreviations when possible\ndiff\n- OSs\n+ Operating Systems. why !== true instead of !opts.noCi?. we need a clear distinction between plugins that are supported by the semantic-release team and plugins that are supported by the community, to set the right expectations in terms of compatibility and support. I agree that as a user I\u2019d prefer all plugins to be working with the latest semantic-release and be well maintained and supported, but that will not happen and we have to make which plugins are core and which are not.\nOnce there are more plugins, I\u2019m sure we can build better ways for discoverability, but for starting out that is the best we can do :). I would leave out anything that is not necessary to make semantic-release work. Please leave out all the steps related to caching. I\u2019m not familiar with CircleCI so I don\u2019t know how we could reduce it further, but the simpler it is, the less error prone, the better. . I agree with @pvdlg, please leave it out, it will work without. I do similar optimizations in my travis.yml files (https://github.com/octokit/rest.js/blob/34109d614958f8e423beb94c6959920e79c14862/.travis.yml#L16) but I would not make it a default trough the CLI or document it that way.\nFor example, if I set my default branch to something else than master and then copy/paste the config which only runs the release on the master branch, it will never work. \nIt\u2019s great to give people a starting point to make semantic-release working, but it shouldn\u2019t be the goal to put in best practices. People who look into this are likely new to both, semantic-release & circeCI and they will run into problems anyway for which they will then create issues which increases the work load for the maintainers. And maintainers time is the scarces of resources, so when in doubt, I\u2019d always optimize for that. \ud83d\udc4d . forgetting a build seems like a challenge / pitfall that should be addressed somewhere else, it is not unique to any CI. \nThe current setup does not what you think it does\nscript:\n  - npm run build\n  - npm run lint\n  - npm test\nsee https://github.com/semantic-release/semantic-release/issues/609\nAnd the builds for the different stages are separated, you have to build in the same job as semantic-release. \nThe right thing to do is to put npm run build into prepublishOnly. How about we remove it for our docs, but then link to a list of more complex configurations in other projects? That would have the benefit that these would be configurations that are actually in use and hence being updated. We could add links to a list of different configurations for projects of different nature, only ask that the respective projects throughly comment their settings?. I'm not sure we need this, I think that is the default?. I'd leave out the os: setting for simplicity. Maybe we can leave out 4 already? Either way okay with me.\nOr we just set it to one node version like node_js: 8 for simplicity. good point. how did that change any behavior? Isn't it just a variable rename?. I would suggest we add the link to this PR here for easier reference in future: https://github.com/semantic-release/semantic-release/issues/699#issuecomment-373445979. I think [npmjs.org](npmjs.org) should be [npmjs.org](https://www.npmjs.com/), otherwise this is good to go, thanks :) . /s/repositoru/repository. can you please explain why you set defaults now? Could this be  problem if master is not the default branch on remote?\nAnd unrelated to this PR: should the origin argument be called remote? \"origin\" is the default remote name, or does the parameter refer to something else here?. repositoryUrl is more clear I think \ud83d\udc4d  . I wonder if the 1.x branches could be created automatically by semantic-release, each time a breaking release is published?. ",
    "stojanovic": "I managed to reproduce this 2-3 days ago - I tried to add semantic-release on module that was already v1.1.0 and it was reset to 0.0.0-semantically-released.\n. ",
    "lewiscowper": "\n~~Looks good to me! :+1:~~\n~~Relevant Travis Build~~\nEDIT: Apparently I did something silly. Consider all this moot.\n. :+1: with the same message as above\n. ",
    "remy": "Huh, that's weird. I did check the npm version (via the web site) and it still said 0.1.2 not 0.2.0 as it does today...\nSo this isn't actually a problem then... weird. \u00af(\u30c4)/\u00af\n. Do you know if the commit format allows for skipping the (something) part after the type, or should I go ahead and my own parser?\n. Erm...following up on this, I've noticed that the version in npm has actually gone a bit stale, and I'm sure I could push to npm directly and it'll update.\nTwo examples - it doesn't contain the latest readme but also doesn't have v0.2.1 (the latest version)...\nI'm not terribly confident of when it's actually being pushed to npm or not...\nChecking npm view bind.js, it seems that npm doesn't know anything about 0.2.1.\n. I dug in a little further, and can see this from npm: publish Failed PUT 500. I'm going to try to re-encode my auth details.\n. Okay, so I got to the bottom of this. I ran the commands from the README to add travis fields on the CLI and pasted them into my .travis.yml file. Because I didn't use the --add CLI arg, it all kinda messed up. I say \"kinda\", it really messed up.\nBut now I have new problems - this: https://api.travis-ci.org/jobs/64443174/log.txt?deansi=true (see \"something went wrong\")\nAny clues?\n. Note - I went ahead and tried to manually remove the duff releases. I think it might be worth either having a cli to prompt for the .travis.yml bits (I saw an issue on this already), or making it super clear that you need to include the --add...or maybe it was, but I thought it would overwrite my travis file \u00af(\u30c4)/\u00af\n. @boennemann I did unpublish the latest v0.0.0-semantic-release tags, but I have a feeling that something's still wrong. I just pushed a change to github, and travis failed the deploy again: https://travis-ci.org/remy/bind.js/builds/64635839\nI think there's two issues - one is definitely some kind of streamlined setup - and I kinda feel like there's some mistake I made early on that's causing pain now - so this would be awesome if done right. \nThe second issue is what I've got now: stuck on the v0.0.0-semantic-release version.\n. @boennemann you need to remind me where to get the version from npm again... \nAlso - good have dinner and chat with you! :)\n. Semantic CLI - I'm all over it!\nAlso - that npm url you showed me...the one that responds with JSON, can you remind me of the url?\n. Very useful, thank you!\n. How would you go about testing this if someone like me wanted to try to fix it?\n. Sorry, more specifically, I'm only getting the error in travis, when I dry-run on my local machine, it doesn't produce this error.\n. Do you get the same result on different repos or on the same single repo? I don't know the inners of semantic-release well enough to tell you off hand, but I could probably debug it...\n. ",
    "dbkaplun": "I see, looks like it uses AngularJS commit message conventions to determine what version to release. This needs to be made more clear in the README.\n. ",
    "tusharmath": "The default analyzer link is broken.\n. @boennemann If I want to execute my gh-pages script only if there is a new release then what should i do?\n. @hbetts  if semantic-release gets the latest of both the published and unpublished and then release with the same version but a different build may be?\n. Got it thanks. Small request \u2014 can this be a part of the FAQs?\n. > It does seem the call to semantic-release in your build is trying to publish a new major version, but the npm registry is rejecting it\nMajor version means 1.0.0 right? Then why is it trying to publish 0.3.0\n. Wow! I din't know this. Thanks a ton for providing that link. I got confused because when I ran npm run semantic-release locally, it gave the following result \u2014\n``` bash\n\nmt-downloader@ semantic-release /Users/tushar.mathur/Documents/Projects/Multi-threaded-downloader\nsemantic-release pre && npm publish && semantic-release post\n\nsemantic-release WARN pre semantic-release didn\u2019t run on Travis CI and therefore a new version won\u2019t be published.\nsemantic-release WARN pre You can customize this behavior using \"verifyConditions\" plugins: git.io/sr-plugins\nsemantic-release ERR! pre Determined version 1.0.0 as \"latest\". Not publishing in debug mode. { type: 'major', version: '1.0.0' }\nnpm ERR! Darwin 15.2.0\nnpm ERR! argv \"/Users/tushar.mathur/.nvm/versions/node/v5.1.0/bin/node\" \"/Users/tushar.mathur/.nvm/versions/node/v5.1.0/bin/npm\" \"run\" \"semantic-release\"\nnpm ERR! node v5.1.0\nnpm ERR! npm  v3.3.12\nnpm ERR! code ELIFECYCLE\nnpm ERR! mt-downloader@ semantic-release: semantic-release pre && npm publish && semantic-release post\nnpm ERR! Exit status 1\nnpm ERR!\nnpm ERR! Failed at the mt-downloader@ semantic-release script 'semantic-release pre && npm publish && semantic-release post'.\nnpm ERR! Make sure you have the latest version of node.js and npm installed.\nnpm ERR! If you do, this is most likely a problem with the mt-downloader package,\nnpm ERR! not with npm itself.\nnpm ERR! Tell the author that this fails on your system:\nnpm ERR!     semantic-release pre && npm publish && semantic-release post\nnpm ERR! You can get their info via:\nnpm ERR!     npm owner ls mt-downloader\nnpm ERR! There is likely additional logging output above.\nnpm ERR! Please include the following file with any support request:\nnpm ERR!     /Users/tushar.mathur/Documents/Projects/Multi-threaded-downloader/npm-debug.log\n```\nSo I have two questions \u2014\n1. Why is the result different 1.0.0 when I run it locally?\n2. How do I make this release using this module?\n. Kind of gave up on expecting a response.\n. @hbetts I had to manually make that release.\nThis module makes a great impact in the way I write git commits and makes me think about releases first rather than thinking about it later. There are still quite a few undocumented \"gotchas\" such has \u2014 greenkeeper.io integration and using npm-dist tags or proper integration with ghooks etc.\nThough I understand they are not a part of semantic-release as module but are relevant from a concept point of view.\n. Try logging in on travis and sync your repos and try again?\n. I would rather use npm dist tags, which semantic release has awesome\nsupport for.\nOn Sun, Mar 27, 2016, 1:05 AM Ryan Kimber notifications@github.com wrote:\n\nI'd like to be able to use semantic-release to automatically version and\npublish pre-releases when we merge to the develop branch, and to publish\nreleases when we merge to master.\nIt doesn't seem as though semantic-release has been built with this use\ncase in mind, which makes me wonder if this a poor idea.\nI'm looking for some feedback on this idea, and would be happy to create a\npull-request to add the feature if there's support for it.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub\nhttps://github.com/semantic-release/semantic-release/issues/207\n\nRegards,\nTushar Mathur.\nwww.tusharm.com\n. I would rather create a dist-tag next and whenever the code is merged into  master I would release it on that tag. So by default everything is released on next. Once you are comfortable with a particular release and find it stable you can add the latest dist tag on it.\n\nThe advantage I get from this setup is that I don't need to create a new release per say when something is marked as latest.\n. dist-tags are read by npm from package.json at the time of publishing so I highly doubt we can make it dynamic, unless we write a script like yours above.\nWhy does the branch option not work for you\u2014 https://github.com/semantic-release/semantic-release#options?\n. I too think these things should be documented as its not obvious to people who are just getting started with automating their releases, would love to know what the owners think about it. \n. I think then there should be a separate command to make the initial release. Its quite cumbersome other wise because semantic-release deletes the version from package.json.  Any thoughts?\n. @Raathigesh Bottom line is \u2014\n\nNEVER UNPUBLISH, use deprecate instead. \n\nSecondly, it's alright to have an invalid version of your module rather than not having it at all.\nBut since you already did, you should just delete the equivalent git tag 1.0.0 and then try again.\n. Oh yes! Sorry about that, you will also need to revert your npm dist-tag to the version just before your published 1.0.0.\n. @Moezalez which tag are you talking about here \u2014 on npm or on git? You need to delete both.\n. @Moezalez Yeah that's a nasty one. I have faced this issue too. You will have to make a FAKE feat commit to go to the next version.\n. Perf.\nOn Mon, May 16, 2016, 8:04 PM Gajus Kuizinas notifications@github.com\nwrote:\n\nI understand that the commit message footer must have the BREAKING CHANGE\nmessage. But what type ought to be used?, feat?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub\nhttps://github.com/semantic-release/semantic-release/issues/224\n\nRegards,\nTushar Mathur.\nwww.tusharm.com\n. \n",
    "hutson": "@tusharmath under the analyzeCommits section on the README, you will see a link to the default implementation.\n. @johann-sonntagbauer it seems you cannot search for scoped npm packages using the search box on npmjs.org.\nHowever, the package you provided as an example can be accessed here: https://www.npmjs.com/package/@semantic-release/commit-analyzer\nScope support was introduced in npm version 2 (Though, for those using Artifactory within corporate environments, the recommended version if 2.1.9 or higher).\nIssue related to searching scoped packages: npm/newww#929\n. Also meant to say :+1: as I would like to take advantage of semantic-release for packages on a GitLab instance.\n. > What we need though is ideally at least two people who would be willing to maintain the project for each platform\nIf you need any assistance with GitLab, please let me know.. > whats holds us back to use semantic-release on GitLab\nA non-blocker, but definitely a burden, is the fact that semantic-release is hard-coded to enforce Travis-CI.\nTravis-CI does not integrate with GitLab. \nGitLab users would need to always disable the Travis-CI plugin before they could use semantic-release.\nIs there a way we can make the default experience better for GitLab users?. > I don\u2019t know how it\u2019s currently implemented\nSo semantic-release-gitlab was a from-scratch implementation of a semantic-release like tool for GitLab. While in spirit it's similar to semantic-release, there are a few core differences that would need to be considered before it could become the official semantic-release of GitLab.\nDoes Not Publish To NPM Registry\nsemantic-release-gitlab does not publish to the npm registry, nor does it interact in any way with the npm registry - https://gitlab.com/hyper-expanse/semantic-release-gitlab/commit/f359a6c45f7181de30fcb955c05549a3eb2818da\nThat functionality was remove, leaving semantic-release-gitlab as a tool that interacts solely with GitLab for the purpose of auto-versioning.\nPrevious tag information is fetched from the local environment instead of the npm registry.\nNo CI Limitation\nAs hinted at in my comment above, semantic-release-gitlab does not depend on a specific CI environment, so it's capable of working on GitLab CI just as easily as Jenkins (The company I work for uses Jenkins, while I personally use GitLab CI. Cross CI compatibility was a core requirement)\nNode LTS Support\nsemantic-release-gitlab is written to run on all Node LTS versions.\nOur Node Support Policy - https://gitlab.com/hyper-expanse/semantic-release-gitlab#node-support-policy\nMany enterprises, including the one I work for, have a policy of only allowing Node LTS versions for production processes, including the release process for production code.. > I would be open to make the currently built-in release to npm pluggable, so other folks can set other deploy / publish targets\nYou would need to fetch version information from the project's repository instead of npm. Would y'all consider that?\n\nI\u2019m happy to make the github-specific parts pluggable. In fact, I think they already are :) semantic-release already has a plugin system.\n\nTo my knowledge the GitHub integration is not part of a plugin. My attempt in #150 to make GitHub a plugin never received much input.\n\nThe rest is more about policy and business requirements.\n\nThere is quite a simple workaround using npx which you can install on older node versions and it lets you run single commands with newer node versions.\n\nBut that technically runs semantic-release on a non-LTS version of Node.\n\nBesides, Node 8 becomes LTS next month :)\n\nAnd Node 9 becomes Current. What's to say you won't want to switch to Node 9 ( It will have native support for import/export, which is a pretty compelling feature. )\nAlso, our corporate policy is that developers may use any LTS version (Node 4 or 6, so long as they migrate towards newer releases), and upgrade as resources become available. This ensures developers have room to chosen when to upgrade, while still having access to actively supported software.. Node 4 is LTS. It's in Maintenance mode, but it's still LTS.\nPlease see the Release Plan section of the Release WG README -\nhttps://github.com/nodejs/Release/blob/master/README.md#release-plan\nAs for the GitHub plugin, should we just re-open that pull request? To be\nhonest, I won't have the time to contribute such a significant refactor any\ntime soon.\nOn Sep 26, 2017 1:43 PM, \"Gregor Martynus\" notifications@github.com wrote:\n\nYou would need to fetch version information from the project's repository\ninstead of npm. Would y'all consider that?\nyes :)\nMy attempt in #150\nhttps://github.com/semantic-release/semantic-release/pull/150 to make\nGitHub a plugin never received much input.\nIt\u2019s a good time to revive that discussion\nAlso, our corporate policy is that developers may use any LTS version\n(Node 4 or 6, so long as they migrate towards newer releases)\nNode 4 is not LTS and Node 6 stops being LTS in April 2018, which could be\na good target for us to ship first class GitLab support by then :)\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/semantic-release/semantic-release/issues/37#issuecomment-332296288,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AGY_5h-Q7_SQ2u9yHaYgvf4u2lSHan8Jks5smUXhgaJpZM4E7vvz\n.\n. @ariporad sounds like a great idea!\n\nWhat kind of features would such a yeoman generator have over say generator-node?\n. @gr2m I think @boennemann was referring to updating the release object here: https://github.com/semantic-release/semantic-release/blob/caribou/src/post.js#L28-L36\nThat object is passed to createRelease on line 47.\nHowever, I think you actually want to add a new call to uploadAsset. uploadAsset is documented in the node-github API documentation here: http://mikedeboer.github.io/node-github/#releases.prototype.uploadAsset\n@ariporad and @gr2m as part of #150 I pulled out the GitHub code into a separate plugin (though still bundled with semantic-release.\nMy hope is to support additional plugins like semantic-release-github-notifier.\nI actually just started work on pulling out the GitHub code from #150 into a separate project here.\n. I closed out my pull requests to integrate my changes into semantic-release since there was no feedback on them.\nInstead, to support my own needs I moved forward with developing my own semantic-release like tool for GitLab.\n. @gr2m the project, it's maintenance and community contributions, will only be as active as it's maintainer(s). For example, I would have liked to be more active in supporting semantic-release, but given that my merge requests (including #150 which was to help set the foundation for resolving this issue) were not reviewed, let alone accepted. That makes it difficult to be active.\nThere's actually an on-going discussion to address the plugin system, which you can read here: https://gist.github.com/boennemann/ac06b7f8bcf50510ffa1\nAlso, there's a project-management repo for discussing major refactors, ideas, re-tooling, etc.\nI would have also liked to help with semantic-release, including providing code reviews, and project management support, but now I'm a little busy with my own semantic-release like project that works with GitLab.\n. @johann-sonntagbauer I'm looking forward to reviewing your rebased work.\n. @johann-sonntagbauer would you be able to rebase your work on the latest changes made to semantic-release?\n. @johann-sonntagbauer @boennemann I wouldn't mind taking up this merge request and patching it to work against the master branch.\nJust want to see if the two of you are alright with me doing that?\n. Since I hadn't heard back from @boennemann I went ahead and just developed a side project that allows me to auto release on GitLab.\n. As noted in the previous comments, please give 'semantic-release-gitlab' a\ntry. I use that tool on a daily basis for GitLab hosted projects, built on\nGitLab CI and Jenkins, for both the public registry and a private registry.\nOn Nov 10, 2016 11:24 AM, \"Alexander Kachkaev\" notifications@github.com\nwrote:\n\nHi guys. Are there any plans to merge this? I'm currently looking for a\nsolution to publish to a private npm registry via GitLab CI. Given that\nthere has not been much activity for quite long on this, maybe there is\nsome other common solution for GitLab CI users?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/semantic-release/semantic-release/pull/77#issuecomment-259752275,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AGY_5lmLHn_czT25hH69ZhKB2QJsWfBdks5q81M4gaJpZM4F0-Ob\n.\n. :+1:\n\nInforming users, and contributors, when a merged change is consumable would save a considerable amount of time for those users, and as a package developer, my own time as well.\n. @ariporad @kentcdodds semantic-release uses the release-notes-generator plugin, which uses conventional-changelog, to generate releases notes with links to issues that are referenced in commits. We should be able to extract those same issue references from commits. Furthermore, once we have the issues, based on my understanding of the GitHub API, we should be able to get the list of Pull Requests.\nThere doesn't seem to be a plugin phase that is triggered after the release. Any ideas?\n. Just a note here, we could leverage work related to #89 to write notification plugins that will be called after a release is made.\n. @hafeez-syed could you please confirm whether @gr2m's comment applies?\n. :+1: \n@hawkrives could you rebase your branch?\n. :+1: Looks great!\n. @egoroof keytar (A dependency of semantic-release) has code that must be compiled natively. Please see the node-gyp documentation on requirements to compile native node modules.\n@afirdousi I've looked through the log file but so far haven't see the specific failure. Any hints as to the actual error that's killing the installation?\n. @rubenhazelaar are you encountering issues with installing semantic-release-cli?\n. Also, for future reference, issues with semantic-release-cli should be taken up on the semantic-release-cli repo: https://github.com/semantic-release/cli\n. There seem to be very few alternatives to keytar.\nFirst off I'll note here that the keytar developers are aware of the desire by the community for support for prebuilt binaries so that consumers of the package do not need to have compilers installed locally. You can find the issues tracking this change here: https://github.com/atom/node-keytar/issues/27\nAn alternative is xkeychain, but it's listed as in development, and it also requires compiling on Windows.\nA third option is clortho, but I'm not entirely sure that works in the same way as keytar, and I don't think it supports Linux.\n. @ocombe I actually successfully use semantic-release for my projects on snap-ci, so hopefully I can help out.\nBased on the error, I took a look at your package.json file. You don't have a version number in that file.\nNow, semantic-release doesn't actually update the version field in a repo's package.json file, but that field must at least exist for semantic-release to work.\n. @ocombe at the time I was using the latest semantic-release version available on the npm registry. (Therefore what ever version is tagged as latest).\nI must confess, I've switched from snap-ci to travis-ci, to get access to a build matrix, and to make it easier to manage all my projects.\n. @bahmutov so I ran into issues using travis_after_all as well. One issue, which is similar to the one you encountered, had two of my travis-ci jobs waiting on each other. Disabling, and re-enabling the travis build seemed to clear that up.\nThe other issue was that I wasn't using travis_after_all correctly. Though I had logs for a leader job, and minion jobs, my coverage and semantic-release scripts were called for all jobs. Turns out I needed to actually check various environmental variables to ensure that a job was actually the leader before executing post test tasks. My changes to correct this latter issue are here: https://github.com/hbetts/jenkins-coverage-badge/commit/ba6070c995ee4fedda67da4982a8aeaf9267cbcf\n. @jrwebdev I wonder if #104 would resolve the first issue.\n. I don't really understand why this is failing. The exec method takes an options object, and the transpiled code looks fine.\n. Closing out following the closing of #150 \n. I've completed the following:\n- Rebase\n- Update README\n- 100% code coverage on new code\n- Verified refactored code can correctly publish release to GitHub: https://github.com/hbetts/post-test/releases\nCould I get some feedback please, and if nothing needs changing, can this get merged?\n. @boennemann no problem. Thank you for letting me know about your architecture re-work.\nJust as a little background, I'm managing about ~35 npm projects that have contributions from several other people. I end up spending quite a bit of time using a release-it like setup to manually publish new versions, and then post back to issues and merge requests with the version number. That's why I'm working towards implementing a GitHub notifier: https://github.com/hbetts/semantic-release-github-notifier\n. As this pull request has been sitting here for a while, I'm going to go ahead and close it out.\n. :+1: \n. @therealklanni as you mention, just unpublishing the change might be problematic. If you are on version 1, and submit a breaking change, you end up with version 2 on the npm registry. You then unpublish version 2 from npm. The next time you submit a breaking change, semantic-release will try to publish version 2 again, and will fail.\n. @ArnaudRinquin you may also want to check out #77.\n. @Guria it could be done (though the release notes are in post).\nDo you anticipate this being useful for debugging, or actually releasing a new version from a local environment?\n. It looks like npmconf was just deprecated two weeks ago: https://github.com/npm/npmconf/commit/22827e4038d6eebaafeb5c13ed2b92cf97b8fb82\nThe npmconfig module is used here: https://github.com/semantic-release/semantic-release/blob/032b49369696113807563ea1d932af9e42606c4b/bin/semantic-release.js#L44\nWe will need to use npm programmatically to fetch config information: https://www.npmjs.com/package/npm#using-npm-programmatically\n. Change up for review in #177 \n. @boennemann I don't know what's changed since npm switched to handling config within their own package. There's very little documentation for npm's programmatic config interface so I don't have anything to compare against. Some of their documentation is actually incorrect (such as console logging for npm.config.get)\nI concur that requiring npm is about as bad as it goes for refactoring. It's a massive dep that, as you pointed out, changes quite often, and in my opinion, not always in a stable manner.\nThough, I'm probably not as worried about pinning npm as perhaps you are. \n. As this pull request has been sitting here for a while, I'm going to go ahead and close it out.\n. For anyone that comes across this closed pull request, you may be interested in @gr2m's comment.. @ahmadnassri I don't believe semantic-release depends on keytar.\nHowever, the CLI tool does.\nShould this merge request be opened over there?\n. :+1: \n. @tusharmath \nSo I took the contents of the merge commit you provided just to verify that conventional-commits-parser (The parser used by semantic-release), can handle the message format:\n```\n parser = require('conventional-commits-parser')\n{ [Function: conventionalCommitsParser] sync: [Function: sync] }\n\nparser.sync('Merge pull request #42 from tusharmath/develop\\nBREAKING CHANGE: public api uses promises\\nDevelop')\n{ type: null,\n  scope: null,\n  subject: null,\n  header: 'Merge pull request #42 from tusharmath/develop',\n  body: null,\n  footer: 'BREAKING CHANGE: public api uses promises\\nDevelop',\n  notes:\n   [ { title: 'BREAKING CHANGE',\n       text: 'public api uses promises\\nDevelop' } ],\n  references: [],\n  revert: null }\n```\n\nWhich is does. Next, taking a look at your Travis-CI logs, I notice this in the build logs:\n\"You cannot publish over the previously published version 0.3.0.\" : mt-downloader\nIt does seem the call to semantic-release in your build is trying to publish a new major version, but the npm registry is rejecting it. Though the npm website says the last version was 0.2.11, npm registry thinks 0.3.0 has already been published.\nTherefore I ran npm info mt-downloader, to see which versions npm knows about. In their time list I see '0.3.0': '2016-01-29T15:02:41.725Z'. So the npm registry does think it has a 0.3.0 already. Though the version list seen via npm info does not show 0.3.0.\nPerhaps you published a 0.3.0, and then unpublished it?\nHere's an npm issue related to publishing previously published versions: https://github.com/npm/npm/issues/9266\n. Major version as interpreted by npm, and the general npm community, is defined as the first non-zero number. So for your project, which is currently 0.2.11, the major version is 2. The next major version for your project would be 0.3.0.\nDocumentation here: https://github.com/npm/node-semver#caret-ranges-123-025-004\nSpecifically this line:\nMany authors treat a 0.x version as if the x were the major \"breaking-change\" indicator.\n. @tusharmath I'm sorry I wasn't able to respond sooner.\nI really can't explain the difference between semantic-release executed in travis-ci, versus executed locally. I'm still in the process of learning semantic-release myself.\nBased on your repository, it looks like you've been successfully making releases using semantic-release for several days now. Hopefully that implies that your setup is working well for you now, and my hope is that semantic-release is being helpful, and not a burden.\n. @alecxe could you please be more specific about what changes you feel should be made to the documentation?\nI do feel semantic-release could describe an ideal setup in greater detail. I had issues myself getting my first project setup with semantic-release.\n. :+1: \n. @stevemao some what ironic, I've been working on semantic-release-github-releaser, which uses conventional-github-releaser under the hood (src/index.js). semantic-release-github-releaser is meant to replace the GitHub release code pulled out into a pluggable module as part of my work in #150 \nI would also like to use conventional-recommended-bump to replace commit-analyzer which will help to solve some of the issues that have arisen with it. You may be interested in: https://github.com/semantic-release/commit-analyzer/issues/11\nAll of this, though, depends on @boennemann and @christophwitzko, the maintainers of semantic-release.\nOn a side note, @stevemao, one of my major goals is to bring GitLab support to semantic-release. Would there be a conventional-gitlab-releaser in the future (Now that GItLab has Release pages as well)?\n. Actually I think we can entirely deprecate the analyzeCommits plugin point and just use conventional-recommended-bump. It already has built-in preset, and support for custom presets. No need for anyone to create their own commit analyzer.\n. @stjohnjohnson as noted here, you can write your own analyzeCommits plugin.. Why does the README.md file need the current version of the package to be in package.json?\n. @nephridium the prefixes used by semantic-release are encoded in commit-analyzer.\nThere is already a discussion there about extending the list of available commit types: https://github.com/semantic-release/commit-analyzer/issues/12\n. @safareli you may want to look into the following issue semantic-release/commit-analyzer#3\nWhether a version is released is decided by commit-analyzer and there's an on-going discussion over there on how to support other commit types like perf.\n. @cyberhck you may want to look at bahmutov/ci-publish#2 for a possible solution.. Or encourage developers to switch to the new Build Stages feature in Travis CI where you can install semantic-release in a Node 8 stage. (Travis CI is not the only CI and most allow you to have stages with their own version of Node)\nHere's the stance on the engines property by the Yarn core team - https://github.com/yarnpkg/rfcs/pull/69#issuecomment-308567694\nMy stance is that engines should remain because technically semantic-release can not be executed successfully in any other environment other than Node 8.. This change seems odd. The whole point of engines is to say what version of Node is required for the successful operation of this package.\nHowever, you're saying it works on Node 4, only to then turn around and fail later on.. As an alternative, it may be best to just remove npm prune.\nnpm version 5 automatically creates a lockfile, and uses that lockfile when installing your project's dependencies.\nnpm prune is actually unnecessary when using npm version 5.\nnpm version 5 will always make sure your node_modules directory matches your package-lock.json file exactly.\n. >  And instead of caching node_modules, we\u2019ll cache ~/.npm\nWith npm version 5 you can still cache node_modules/.\nnpm version 5 will modify the contents of node_modules/ to ensure it matches the package-lock.json lockfile.. > It's worth noting that to get rid of the problem entirely, I had to not only remove npm prune but also the cache of node_modules. \nThat seems really strange. Maybe I'm being overly optimistic about npm's ability to update an existing node_modules directory in-place to match a package-lock.json file?\nAlso, maybe I'm making an incorrect assumption here. Do you have a package-lock.json file in your repository?\nSince you're using Travis CI you can manually clear the cache following these instructions - https://docs.travis-ci.com/user/caching/#Clearing-Caches. > I would generally recommend to only lock versions on the top-level consuming project, not the library level.The point of lockfiles is to have the same versions in development and production.\nFor the same reason, I strongly recommend library developers commit their package-lock.json file to their repository.\nThis ensures that if I pull down your library to fix a bug, or add an enhancement, that I will get the same working dependencies used by the last working build.\nWithout a package-lock.json file it's possible that I won't be able to contribute to your library because of a broken upstream dependency.. > npm-shrinkwrap.json should be published on the repo and the release process should use that file and not regenerate one, as we want to publish the npm-shrinkwrap.json from the repo not a generated one.\nI really agree with @pvdlg here. You want to be publishing the lockfile that the developer pushed to the repository that was then successfully built. You should never npm publish a lockfile that hasn't passed your CI tests and isn't part of your repository (so that future builds works the exact same).. > multiple CIs\n@pvdlg do you mean external CIs? (Such as Travis CI, etc.)\n\nAllow to have access to GITHUB_TOKEN for pull request\n\nI would assume not, but I haven't confirmed that myself.\n. In the case of a simple npm package, I did the following:\n```\nworkflow \"Default\" {\n  on = \"push\"\n  resolves = \"Deliver\"\n}\naction \"Node_6_Install\" {\n  runs = \"yarn\"\n  uses = \"docker://node:6\"\n}\naction \"Node_6_Test\" {\n  needs = \"Node_6_Install\"\n  runs = \"yarn test\"\n  uses = \"docker://node:6\"\n}\naction \"Node_8_Install\" {\n  runs = \"yarn\"\n  uses = \"docker://node:8\"\n}\naction \"Node_8_Test\" {\n  needs = \"Node_8_Install\"\n  runs = \"yarn test\"\n  uses = \"docker://node:8\"\n}\naction \"Node_10_Install\" {\n  runs = \"yarn\"\n  uses = \"docker://node:10\"\n}\naction \"Node_10_Test\" {\n  needs = \"Node_10_Install\"\n  runs = \"yarn test\"\n  uses = \"docker://node:10\"\n}\naction \"Default_Branch\" {\n  needs = [\"Node_6_Test\", \"Node_8_Test\", \"Node_10_Test\"]\n  uses = \"actions/bin/filter@master\"\n  args = \"branch master\"\n}\naction \"Deliver\" {\n  args = \"--preset $(pwd)/node_modules/@hbetts/conventional-changelog-config\"\n  needs = \"Default_Branch\"\n  secrets = [\"GITHUB_TOKEN\"]\n  uses = \"DOCKER IMAGE\"\n}\n```\nThere was no need to wait on external CI providers because GitHub Actions became my CI. My Deliver job waited on the filter job (which just checks that I only release on the master branch), and the filter job waited on my Node test matrix.\nAnyway, it's just an example of how I imagine I could hook semantic-release docker image into the Deliver action and have the confidence that it will only run on successful builds on the master branch.\n(Please ignore the --preset args, as it's just a demonstration of how I pass in a custom conventional-changelog preset into the image I actually use for generating releases in a private GitHub repo). If external CI is needed, then maybe @joshk's work would provide an Action that demonstrates how to call out to Travis-CI to trigger CI jobs on that platform.\nIn that case, I then imagine that I might have a Travis CI Action for calling out to Travis CI and running my Travis CI test matrix, and then another action that calls out to maybe AppVeyor to execute my test matrix on that platform.\nThen I would fan those back into a semantic-release Action.. I imagine this would also translate well to offering a semantic-release Docker image for GitLab where all CI is handled through their .gitlab-ci.yaml configuration file (in which you can specify an image for semantic-release, and fan-in all the CI jobs you might have, including from your custom runners that might be running on OSX, Windows, etc.). > I had to call semantic-release with --no-ci\n@shawnbot could you export CI=true in your Dockerfile, entrypoint.sh, or in the configuration for the Action?\n\nTo get around the lack of push permissions for the built-in GITHUB_TOKEN\n\nIs this for pushing a commit to the repository where the version field in package.json is updated?. I like how this code was pulled into its own module, thereby allowing GitLab developer to disable it on a per-project basis.\n. Perhaps a silly question, but why another parse library?\nJust searching Google, there are quite a few out there.\nAlso, if it's not github specific (your README mentions GItLab), why not remove the github reference from the package name?\nOn a related note, does it support github enterprise?\n. Thanks @bahmutov \n. weel => well\n. Can you this be broken out into a separate file, like src/lib/plugin-verify-npm.js.\nActually, that brings up another point. Perhaps this needs to be a very specific type of verify config plugin. One that only checks that npm is setup correctly in the environment.\n. Actually I'm not sure I understand this code at all. The verifyConditions plugin only gets called if verifyConfig passes?\nWhat if I want to ignore the npm token verification, but want to keep the GItHub verification and the verifyConditions plugin? Will I need to re-write the verifyConfig plugin, minus the npm check code?\n. Because this test block does not run multiple actions asynchronously, I would just remove the t.plan call, and call t.end() after line 15. Much less flaky (As you don't have to remember to increment the plan count each time you add a test.\n. Since verify is now a plugin, I would probably move it into the lib directory and prepend the name with plugin-.\n. Fun fact: Calling npm.get will return the config value, but it also console logs the value (which creates a lot of noise on the console). However, npm.config.get does not console log the value. \n. Another fun fact: npm.config.set, does not write the config value to disk. It only writes it into memory within the context of the npm.config instance. However, npm.set will write the value to the user's .npmrc file.\n. ",
    "ariporad": "Actually, what if we just did a release plugin? That would solve\napplications.\nOr, even better make two, a publish plugin (defaults to NPM), and a\nrelease plugin (defaults to GitHub). That would make it much more\nflexible for non npm modules.\n. Sorry, I phrased that poorly.\nWhat I'm suggesting is that in package.json, we change semantic-release from 'semantic-release pre && npm publish && semantic-release post' to 'semantic-release run'.\nThen, semantic-release run runs pre, runs the publish plugin (defaults to npm), then runs post (which runs the release plugin).\nThat would make semantic-release completely compatible with non-npm packages (ie. Apps)\n. I'll try this.\n. Should having [verification skip] in a single commit be sufficient to prevent verification of the whole release (I could see this being a problem for things like the next branch, where there are hundreds of commits).\n. I'll Do this\n. Thanks!\nIf I may ask, is there a unified place for discussing these things?\nAri\nOn Wed, Aug 5, 2015 at 11:23 AM, Stephan B\u00f6nnemann <notifications@github.com\n\nwrote:\nHey @ariporad https://github.com/ariporad, thanks for your interest in\nsemantic-release and this issue.\nIf I understand that correctly both you're client and server are\nindividual packages. Maybe you can try to publish them as (private) npm\npackages using semantic-release, and then deploy your top-level app that\npulls both of them together, whenever a new version gets published.\nWe are currently experimenting with ideas on how to bring this to\napplications ourselves and we will share our findings as soon as we have\nthem.\nThanks again,\nStephan\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/semantic-release/semantic-release/issues/51#issuecomment-128099202\n.\n. Ok.\n\nFirst of all, you could check out gitter, it's a free chat room.\nAs for my thoughts, here's what I'm thinking:\n1. First of all, my project is in the early stages, so this might change\n2. This type of application (where the server just has an API, and the client uses it), is well suited to this project, because semver is important.\n3. I'm making this all up as I go, but here's what seems like the most logical way to release such an app (the normal way):\n1. Write the code for the server and client (including any native apps, for example iOS)\n    2. Test, etc.\n    3. Deploy the server, make 110% sure it works. The server should be backwards compatable.\n    4. Once every possible server supports the new version, deploy the web client\n    5. Make sure that works\n    6. Deploy any other clients.\n    7. ???\n    8. Profit\n1. I would assume that for unit testing the client, you'd test against a known-good server, say the latest commit in master that passed it's tests.\n2. Therefore, it seems completely valid that the sign that it's A OK to deploy is when you can run the tests, with the production servers, and have them all pass. \n3. Theoretically, if some servers have updated, and other's haven't, that could be a problem. Maybe solve this with a few minute delay.\n4. The server could be deployed whenever the tests pass, because, if none of the clients use an api, and it's not in the docs, it (for all intents and purposes), doesn't exist. This might have to be modified for some things, (ie, things that would reveal themselves, but must be kept secret).\nBased off all that, it seems like the first step would be allowing for the customization of deployments, for example deploying to heroku instead of npm.\nJust my thoughts, feel free to let me know anything I missed.\nI can try to open a PR and work on this, if you're interested.\n. Actually, @boennemann, Currently I'm just working on a git-tags based system for finding the last version, not for publishing via git. (I'm not really sure how that would work anyway).\nCould we please re-open this for further discussion?\n. Did the integration tests ever start running on travis?\n. This will move to semantic-release/last-release-npm with #57, so I'm going to open an issue about it there, and close this one.\n. I'd love to try... I'm a little busy, But I'll try to get to it today or\ntomorrow.\n\u1427\n. Number 1 is fixed in #57.\n. Hey, This is semi-badly broken. I'm going to fix it in the morning. In the meantime please ignore.\n. I think that release skipping should defiantly be a part of the commit analyzer, as it could change for different (commit) styles.\n. Hey, I'm not really sure what I screwed up for this branch, so I'm just going to close it and re-open a new one\n. Apparently not: http://ariporad.link/1hCvf1H (screenshot). Can you just reopen this?\n. That sounds awesome! And if you're willing, I'd love to help.\nThanks!Ari\nOn Sun, Aug 23, 2015 at 2:17 PM, Gleb Bahmutov notifications@github.com\nwrote:\n\nwill consider if I have time. Right now I am thinking of writing a tool that would configure all project-related services: travis, semantic release, david dependencies, codacy in a single command.\nReply to this email directly or view it on GitHub:\nhttps://github.com/semantic-release/semantic-release/issues/65#issuecomment-133938778\n. Me too. I think most code coverage tools have an option to fail if they\ndon't pass a certain threshold.\n\nAri\nOn Tue, Sep 8, 2015 at 4:12 AM, Kent C. Dodds notifications@github.com\nwrote:\n\nFor what it's worth, I actually use this as part of my scripts and\npre-commit hooks so the build will break if a PR or commit doesn't have\nsufficient code coverage.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/semantic-release/semantic-release/issues/68#issuecomment-138520115\n.\n. Shouldn't be hard, I'll take it on. @boennemann, can you create a repo for it?\n. oops.\n\nAri\nOn Sun, Aug 23, 2015 at 7:45 AM, Stephan B\u00f6nnemann <notifications@github.com\n\nwrote:\nLanded as of 4.2.0 :)\nhttps://github.com/semantic-release/semantic-release/releases/tag/v4.2.0\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/semantic-release/semantic-release/issues/70#issuecomment-133852651\n.\n. @hbettes: It was a while ago, but IIRC, I wanted a test/babel setup, etc.\n. Hmm...\n\nI'm working on a PR to seperate out the publishing (npm) and releasing (github) into plugins. One that lands, this will be much easier.\nWhy don't we re-discuss this once that lands?\nThanks!Ari\nOn Mon, Aug 24, 2015 at 8:08 PM, Gregor Martynus notifications@github.com\nwrote:\n\nFor JavaScript libraries that can be used in the browser, it would be nice to have direct downloads of the different versions, ideally right from the GitHub releases page. Here is an example:\nhttps://github.com/gr2m/initials/releases\nIt would be nice to be able to not only download the source code for each version, but also the built initials.js and maybe ainitials.min.js files.\nCould that be with a plugin?\nReply to this email directly or view it on GitHub:\nhttps://github.com/semantic-release/semantic-release/issues/72\n. @boennemann: I was more thinking perhaps having the cli set it up, or adding it to the docs, etc... I just opened it here for discussion.\n. I think that the trouble would be mapping commits to PRs. We could\ndefiantly map it to contributors, but PRs would be tricky.\n\nAri\nOn Mon, Sep 7, 2015 at 5:46 AM, Kent C. Dodds notifications@github.com\nwrote:\n\n[image: :+1:] from me. Based on my limited experience, this sounds like\nthis would totally be possible as a semantic-release plugin\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/semantic-release/semantic-release/issues/79#issuecomment-138289647\n.\n. You can only comment on a specific line of the commit though...\n\nAri\nOn Mon, Sep 7, 2015 at 8:15 AM, Kent C. Dodds notifications@github.com\nwrote:\n\nHmmm... What if I commented on the commit(s) instead of the PR?\n- Kent C. Dodds\n(Sent from my mobile device, please forgive typos or brevity)\nOn Sep 7, 2015 9:02 AM, \"Ari Porad\" notifications@github.com wrote:\n\nI think that the trouble would be mapping commits to PRs. We could\ndefiantly map it to contributors, but PRs would be tricky.\nAri\nOn Mon, Sep 7, 2015 at 5:46 AM, Kent C. Dodds notifications@github.com\nwrote:\n\n[image: :+1:] from me. Based on my limited experience, this sounds like\nthis would totally be possible as a semantic-release plugin\n\u2014\nReply to this email directly or view it on GitHub\n<\n\nhttps://github.com/semantic-release/semantic-release/issues/79#issuecomment-138289647\n\n.\n\n\u2014\nReply to this email directly or view it on GitHub\n<\nhttps://github.com/semantic-release/semantic-release/issues/79#issuecomment-138319606\n.\n\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/semantic-release/semantic-release/issues/79#issuecomment-138323185\n.\n. Oops... Yeah, you're right.\n\nI think thought that this might get annoying for contributors (like\n@boennemann).\nAri\nOn Mon, Sep 7, 2015 at 8:41 AM, Kent C. Dodds notifications@github.com\nwrote:\n\n[image: screenshot_2015-09-07-09-39-55]\nhttps://cloud.githubusercontent.com/assets/1500684/9719722/77b0c8a2-5544-11e5-9553-57fd64114310.png\nI'm pretty sure you can comment on whole commits. [image: :point_up_2:]\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/semantic-release/semantic-release/issues/79#issuecomment-138327224\n.\n. \n",
    "zetxx": "+1 for resolution for those issues(@johann-sonntagbauer i see strong logic in your posts and seems reasonable), i work in corporate env too, and 80% of the developers i think.\nthis problem should be nailed down until module is still not well known..\n. ",
    "mfilotto": "+1\n. +1\n. ",
    "andreasolund": ":+1: for GitLab and Bitbucket support!\n. ",
    "jimitndiaye": "Looking forward to generic (including private) git repository support rather than just GitHub.\n. ",
    "KeithPepin": "Also looking forward to this possibility.  We're developing some new things at work right now and could really use this for our process!\n. ",
    "stalinkay": "+1 gitlab and bitbucket. ",
    "armand1m": "You guys could reuse some of the code in semantic-release-gitlab package into the next branch. I'm actually using it on gitlab and it works like a charm.. Someone willing to implement this? The ability to use other services than github seems to be the a key thing that is missing in this package :P. @gr2m What do you think about creating some kind of pluggable system? Would be fair easier to maintain this and an official github plugin. People can develop their own plugins and maintain those themselves. The most popular one's would probably be adopted by the community. . i'm getting this same issue on travis ci, this job shows it better for further details: https://travis-ci.org/armand1m/generate-random-points/jobs/198233123. Apparently it just seems like the library will wait until the master build leader resolves the CI cycle, so when it is done, it does publish the package. Probably this feature is implemented in order to avoid publishing the package more than once, when testing across different versions of Node in parallel in Travis CI, for example. Would be nice to see it in docs. (I did not searched but never have seen it there before either so, if it exists, someone post the link here please.). ",
    "andrei-cacio": "+1 gitlab. Hi, is somebody still working on this MR? It would be really great if semanti-release supported Gitlab. Or do you guys know any alternatives to this?. @johann-sonntagbauer and are you sync-ing all sub modules to a single version?. ",
    "freeman29": "+1 for Bitbucket. ",
    "vnpnlz": "+1 for Bitbucket. ",
    "ghost": "So I filed #485 to discuss a Node LTS policy.\nIt looks like y'all are already discussing removing npm from semantic-release in #465.\nLastly, I've filed #486 to discuss removing the Travis-CI plugin.\n. @pvdlg is there a guide for building a semantic-release plugin?. Thank you @pvdlg.\nI went ahead and imported the github project into GitLab - https://gitlab.com/hyper-expanse/gitlab\nI hope to try and work on it this weekend, in addition to proving that I can use it with semantic-release to release itself.\nOf course, if anyone else wants to work on it, please do, and let me know! \ud83d\ude04 . I still have this issue\n. @gr2m Node version 4.5.0, npm version 3.10.6, and no semantic-release version because I can't get it to install (that's the issue here).\nMy OS is the latest version Windows 10 Home Edition, and I'm using the Git Bash terminal.\n. @gr2m I installed that, but I'm still getting a bunch of error messages. The messages I'm getting are a little different than the OP, so I will post screenshots of them here:\n\n\n. @gr2m Thanks so much, I got it working with that.  :)\n. @gr2m I spoke too soon - now I get a bunch of ambiguous errors when I run semantic-release-cli setup in my github project directory\n\n. @gr2m I am using Windows 10 though. I just tried it on the ordinary CMD, though, and it worked. I guess Git Bash is only good for Linux machines? Anyway thanks for your help, I will use the Windows CMD from now on.\n. @bahmutov could this issue be closed out since the problem wasn't with semantic release?\n. I'd be curious how this should be done as I've made the same mistake.\nI wonder whether we could just rely on the normal git revert workflow to make a revert commit and then update commit-analyer to treat commits starting with revert as a patch.\nRelevant code: https://github.com/semantic-release/commit-analyzer/blob/master/src/index.js#L20\n@tusharmath does that seem reasonable?\n. @pensierinmusica correct me if I am wrong, but things like refactor and style do not change anything from the user's perspective and therefore shouldn't be a release.\n. @glebec AFAIK most people read the docs on github, and don't want to look at some completely unformatted markdown in their node_modules folder. \n. In my case I want to write the version to my libraries license banner to help track which version is being used when others include the minified source code. Seems like a pretty legit use case, right?\nHowever, it would be an anti-pattern for semantic release to clobber your actual source code, and it could in could in theory spawn infinite recurring builds. That said, there's going to be better solution than manually managing the version field, so my suggestion is to remove version from your package.json file entirely and figure out another way. That's what I'm planning to do, at least.\nEDIT: I'm simply going to add a timestamp to identify the exact moment a build occurred. Problem solved and nothing clever involved.. Bailed on the timestamp idea because I build several different modules concurrently and didn't want each to have a different, ahem, build indicator (what the hell was I thinking).\nAnyway, I was able to use the version number from the Semantic Release pre script as a part of my build process. Here's how I did it.. semantic-release would still need your GitHub token to push an update to your project's Releases page. \nOtherwise, it would be nice to have signed tags. Would go really well with the recent release of signature verification released by GitHub.\n. @tusharmath\nThis is not working for me. The tag is deleted, still can't republish.\n$ npm dist-tag ls @scope/package\nlatest: 2.0.1\n\"You cannot publish over the previously published version 2.1.0.\"\n. @tusharmath all tags are deleted. Git and npm. Still can't publish over previously published packages. \nI think it might be related to this: \nhttp://blog.npmjs.org/post/77758351673/no-more-npm-publish-f\n\nIf you publish foo@1.2.3, you can still un-publish foo@1.2.3. But then, you will not be able to publish something else to that same package identifier and version.\n\nI really just want sermver to figure out that this version is not available anymore and use the next version, so basically 2.2.0 instead of 2.1.0.\n. Partial dupe of #176 and #389 . Please close this and be sure to search through closed issues in repos before opening new ones, and keep the scope minimal. Thanks!. > semantic-release WARN pre semantic-release didn\u2019t run on Travis CI and therefore a new version won\u2019t be published.\n\nsemantic-release WARN pre You can customize this behavior using \"verifyConditions\" plugins: git.io/sr-plugins\nsemantic-release ERR! commits The commit the last release of this package was derived from is not in the direct history of the \"master\" branch.\nsemantic-release ERR! commits This means semantic-release can not extract the commits between now and then.\nsemantic-release ERR! commits This is usually caused by force pushing, releasing from an unrelated branch, or using an already existing package name.\nsemantic-release ERR! commits You can recover from this error by publishing manually or restoring the commit \"1ec9488803ff8f1845b07a949908fde13bc84e63\".\nsemantic-release ERR! pre Failed to determine new version.\nsemantic-release ERR! pre ENOTINHISTORY Commit not in history\n\nI guess I have to modify it to run it locally.\n. \nI might have introduced some issues now, since I manually released the last version after semantic-release failing\n. \n. Hi @MoeSattler, how did you get around this? Your last screenshot here looks like it was still failing to determine version. I have the same issue where I haven't yet gotten an initial versioning to take place. Thanks for any info you have.. @Ian-Rossi-aimtheory I dropped semantic release. @MoeSattler OK, that is actually helpful. What did you do instead? I'm interested. Thanks.. @MoeSattler Perhaps you'll consider reopening this. @boennemann Perhaps you could reopen it? Because I am just getting started with SR and I cannot get past this. I have never released my demo app with SR, so what's saying in the error message doesn't make much sense. I just need to get a first release going? How do I do that?. Thanks @MoeSattler . @boennemann I am facing the same issue as @MoeSattler.  If you can help me get over this hump, I would really appreciate it as I would love to be able to use SR to deliver my nodejs projects. This is the error I am facing. It seems like a chicken/egg scenario. I am dropping efforts to use SR at this time, due to this blocker, but would love to be unblocked and really be able to use SR. Thanks.\n```\nsemantic-release ERR! commits The commit the last release of this package was derived from is not in the direct history of the \"master\" branch.\nsemantic-release ERR! commits This means semantic-release can not extract the commits between now and then.\nsemantic-release ERR! commits This is usually caused by force pushing, releasing from an unrelated branch, or using an already existing package name.\nsemantic-release ERR! commits You can recover from this error by publishing manually or restoring the commit \"ebd22468e45c8749026458a5432abf456965183d\".\nsemantic-release ERR! commits Here is a list of branches that still contain the commit in question: \nsemantic-release ERR! commits  * * (detached from 7b10008)\nsemantic-release ERR! pre Failed to determine new version.\nsemantic-release ERR! pre ENOTINHISTORY Commit not in history\nnpm ERR! Linux 3.13.0-101-generic\nnpm ERR! argv \"/usr/bin/node\" \"/usr/bin/npm\" \"run\" \"semantic-release\"\nnpm ERR! node v0.10.48\nnpm ERR! npm  v2.15.1\nnpm ERR! code ELIFECYCLE\nnpm ERR! @cc/node-hello-world@1.0.0 semantic-release: semantic-release pre && npm publish && semantic-release post\nnpm ERR! Exit status 1\nnpm ERR! \nnpm ERR! Failed at the @cc/node-hello-world@1.0.0 semantic-release script 'semantic-release pre && npm publish && semantic-release post'.\nnpm ERR! This is most likely a problem with the @cc/node-hello-world package,\nnpm ERR! not with npm itself.\nnpm ERR! Tell the author that this fails on your system:\nnpm ERR!     semantic-release pre && npm publish && semantic-release post\nnpm ERR! You can get information on how to open an issue for this project with:\nnpm ERR!     npm bugs @cc/node-hello-world\nnpm ERR! Or if that isn't available, you can get their info via:\nnpm ERR! \nnpm ERR!     npm owner ls @cc/node-hello-world\nnpm ERR! There is likely additional logging output above.\nnpm ERR! Please include the following file with any support request:\nnpm ERR!     /var/jenkins_home/workspace/node-pipeline-feature-deploy/npm-debug.log\nBuild step 'Execute shell' marked build as failure\nFinished: FAILURE\n``. I was experiencing build failures with doc changes as well because I was running the SR pre script in thescript` step in Travis config (my build depends on the version number created by it), which was causing the build to error out.\nAs a workaround I chose to run my build twice. Once as a development dry-run to fail CI if the build doesn't work. And the second time after SR pre script so I get the version number as a part of my build.\nHere are the relevant parts of my setup for posterity:\nyaml\nbefore_script:\n  - npm prune\n  - npm run clean\nscript:\n  - npm run lint\n  - npm run build\nafter_success:\n  - npm run clean\n  - npm run semantic-release\nAnd from my package manifest:\njson\n\"semantic-release\": \"semantic-release pre && npm run build && npm publish && semantic-release post\"\nAnd here's a successful build issuing a release followed by a doc update which does not.. This is a case where moving semantic-release out of the CI and into a GitHub App (as proposed by @gr2m ) may be the way to go (Would allow semantic-release to observe all CIs, and wait until all CIs report pass on the master branch commit). > just to clarify, I don't plan to replace the current semantic-release CLI tool with a GitHub app, it will just be another option, the two might even work together\nI think it would be kind of cool to see semantic-release evolve over time into something that could be executed within a CI, or independently, such as in a cron job, or as a service for a GitHub App.\nInspiration comes from how renovate is both a CLI tool and used to power a GitHub app.. > I had some issues with the master branch and semantic-release told me to revert back to a certain commit, I tried that\nLooks like that at some point semantic-release didn't find the commit corresponding to the last release. Did you force push or roll back at some point ? \n\nso I created a new release/tag myself\n\nDid you also publish to npm? Make sure your tag has the v as in  v1.2.3 and not 1.2.3. \nUsually the only way to recover from those issues is:\n- publish once manually to npm\n- then return to semantic release\n. Closed, see https://github.com/semantic-release/semantic-release/issues/339. @sirJconny Sorry I can't help with this, I abandoned semantic_version for https://github.com/fmahnke/shell-semver. Was much easier to work with and can be used across applications of different languages.. > Maybe you can use npm to publish while keep using yarn for dependency management?\n@gr2m that's actually what I do for my projects.\nAs noted by @benjamincharity (Thank you for the issue reference because I wasn't finding that GitHub issue) yarn publish does not have feature parity with npm publish, and as you noted, yarn publish just proxies the publish process through Yarn's proxy of the npm registry.. > We are also discussing a GitHub app which you can install on any repository and it will do language agnostic releases to GitHub only, stay tuned :)\nThat's exciting to hear! Looking forward to giving that app a try.. Actually, to move this discussion forward, could npm support be removed from semantic-release, and we just encourage developers to run npm publish as part of a build job that only runs on new tags`?. > CLI ask a question whether you want to use NPM integration or not\nHow would that work from within an automated CI job?. @gr2m if semantic-release were to adopt an LTS policy, it would mean supporting an LTS for 30 months (Two and a half years). \nWould y'all be comfortable with that?\nBecause of an early OpenSSL EOL it would mean supporting Node 8 until December 2019.. > if that means it would unblock you from joining forces with gitlab support, then yes :)\nIt would be a long-term impediment to my own personal ability to contribute, yes.\nMay I submit a Pull Request for a Node LTS policy in the README file, with the caveat that it takes effect starting with Node 8 LTS?. @gr2m can you please assign the issue to me and apply any appropriate labels?. I believe this would simply require writing documentation that encourages users to use Build Stages if using Travis CI, and then remove the Travis-CI plugin from semantic-release (As part of a major version release).. > allow to support configuration with and without Build stage there I' not sure to see a reason to remove it\nIf it's no longer needed, removing it would mean less code to upgrade as new JavaScript features are released. Less code to refactor as the plugin system evolves. Less code that could break one day.\n\nWe can encourage users to use Build Stage with the condition-travis plugin by recommending this approach in the documentation.\n\nSince semantic-release uses Travis CI, this could be a fun opportunity to demonstrate the power of build stages.\nIf I can get to it this week I'll submit a pull request to update semantic-release to use Travis build stages.\n\nsupport other CI. For example https://github.com/bahmutov/condition-circle\n\nI would actually like to use Circle CI for one of my projects, but I don't see the value in using the Circle CI plugin you listed.\nIt does two things: checks that you're running on Circle CI, and that you are running on the branch configured in your semantic-release configuration in package.json.\nThe first one, the one that checks that I'm running on Circle CI, does not add value to the developer experience, or quality of the product. If I want to run my project on Circle CI, I'll run my project on Circle CI. Nothing more to it.\nAs for checking whether semantic-release is running on a given branch, I would probably just use the branches option for a deployment job - https://circleci.com/docs/2.0/configuration-reference/#job_name\nTherefore, to get semantic-release running on Circle CI I would just need to add configuration to my project's package.json to disable a Travis CI plugin, which seems a little silly if I am not even using Travis CI to begin with.\n. Just noting a similar issue has been posted against semantic-release-gitlab - https://gitlab.com/hyper-expanse/semantic-release-gitlab/issues/26\nI bring that up because I want to make sure I'm following the same best practices in semantic-release-gitlab as semantic-release.. Artifactory does not have all the same user management features as the npm registry (I work with Artifactory and Yarn on a regular basis).\n\nmight lack APIs that semantic-release depends on\n\nI've been trying to find what those APIs may be. Does semantic-release interact with npm's User endpoint? (I've been trying to search the code for that without success)\nBasic package metadata fetching is fully supported by Artifactory.\n@gergelyke what is the contents of your .npmrc file (with sensitive information redacted).. @olstenlarck is the app no longer there?\nI'd really like to see an app like this to further lower the barrier to automated releases. With an integrated app, no need for people to create release stages in their CI, or configure GitHub tokens.\nJust register the app, and done!. CC @rarkins\n@olstenlarck, cc'd Rhys, as he currently has the release app to provide a very similar service (Though I don't think it actually does anything at the moment).\nI'd love to eventually check out your project. As I noted earlier, it'd be nice if all I had to do was just add an app and be done.\nAt the moment I think the only concern I have is whether there's feature parity between new-release and semantic-release.\nIf not, it would seem like a great opportunity to share core functionality between the two for ensuring a consistent developer experience.. As a first iteration of Release as a Service, I like @bahmutov's proposal of scoping functionality to tagging a release, deferring to the project\u2019s CI for publishing their artifacts.\n(Tangent: We should probably not call it a release. release implies it has been published in a consumable way. Instead, we should be generating deliverables. A uniquely identifiable tag pointing to the build artifact(s) (the thing generated by the project\u2019s one or more CI platforms), that can be deployed to one or more environments (npm publish --tag next), and eventually, released for end-user consumption (npm dist-tag add <pkg>@<version> latest) )\nWhile it might seem the functionality of this Release as a Service app is limited, it offers the following benefits over the existing semantic-release core CLI tool:\n\nCan support projects that use multiple CI platforms.\nIs language agnostic (to the point that no one must know about Node at all).\nCan tag a deliverable on pull requests and dedicated release branches.\n\nI believe these are substantial improvements to the existing user experience.\nHowever, @pvdlg pointed out a few constraints that still need to be addressed.\nBecause semantic-release\u2019s analyzeCommits is configurable, could we migrate the community away from custom analyzeCommits plugins, and simply require customization to be handled through JSON configuration?\nThat leaves verifyConditions, which may not be necessary, since the only example I see is validation of the GitHub auth token, which doesn\u2019t apply to a GitHub App (because the app would generate its own authentication tokens).\n. > The best solution is probably to do both:\nI really like the simple workflow outlined by @pvdlg in the four bullet points he provided.\nAssuming semantic-release can be re-used for just publishing, the separation of tagging a deliverable, from the deployment/release step, empowers users to customize their deployment strategy (Such as deploying straight to latest dist-tag, utilizing a blue/green strategy, etc.)\n. I have a concern about the following feature suggestion:\n\nAdd comment to a PR with the future release info\n\nWhat is described in the release information, and what actually happens after the merge completes successfully, is not guaranteed. Between reading what could happen, and seeing the results of what actually happened, someone, including a third-party automated process, could accept a PR, or push a commit to the target branch, changing the final results. . > Set PR status if a commit message is invalid\nThis one might be difficult to fully realize, as some developers I know, do not use properly formatted commit messages until they press \"Squash and Merge\". This is considered an acceptable practice, so long as the final commit to the project's default branch is properly formatted.\nAlso, it doesn't prevent improperly formatted commit messages from being committed directly to the project's default branch. Therefore, the experience is not uniform between direct contributions, and pull request contributions.. > In most cases where such feature was requested there was a better solution to implement the desired workflow, so it hasn't been implemented so far.\nI'm not sure I completely agree with that statement. In previous versions this was sometimes hacked together using pre and post sub commands, e.g.\n\"release\": \"semantic-release pre && npm run build && npm publish && semantic-release post\"\nObviously not an ideal solution. So I'm happy to see there's FAQ now and some other approaches as mentioned in the first few responses above.\n@BenoitAverty imho if you're not using this product for NPM please consider looking for a less opinionated product, many of which have been mentioned in older issues related to version numbers.. ",
    "pvdlg": "Closing in favor of #565. Duplicate of #565. The verifyRelease step applies to the entire release and consist in verifying that the release type (patch, minor, major) corresponds to the content of the release.\nThe content of the release can be verified in many different ways: commits, changes in tests, changes in dependencies, changes in API etc...\nI don't think a [verification skip] commit message make much sense as the verifyRelease step is not executed per commit but for the entire release.\nWhat was the original goal of this feature request?\n. Closing per previous comment. Feel free to comment further if you disagree.. @bahmutov do you think you could update https://github.com/bahmutov/dont-crack to the latest semantic-release API?\nOr maybe someone in the community would like to make a PR for that?\nThe we could add it to https://github.com/semantic-release/semantic-release/blob/caribou/docs/extending/plugins-list.md#community-plugins. As mentioned in several comments in #68 running nsp is more appropriate in the test phase than in the release phase. If a dependency update is creating a security risk, the test should fails and semantic-release release shouldn't even be called. In addition the alert can be reported directly in the PR (as the build would fail due to the failed tests), before it get merged.\nAs anyone any objection regarding closing this issue?. Closing per previous comment. Please re-open if the previous comment is no accurate.. As mentioned in several comments running test coverage is more appropriate in the test phase than in the release phase. If we choose to enforce a certain percentage of coverage, and it's not met the test should fails and semantic-release release shouldn't even be called. In addition the alert can be reported directly in the PR (as the build would fail due to the failed tests), before it get merged.\nAs anyone any objection regarding closing this issue?. It's not accurate anymore and cannot be merge. Many things have changed in version 16.0.0.. @conblem, We just release semantic-release@10.0.0 on the dist-tag next that include the possibility to publish file to a Github release\nYou can find more information on that in the new github plugin: https://github.com/semantic-release/github#assets-option\nLet us know if that works for you!. Github and npm semantic-release have been moved to their own plugins: npm and github. So I imagine this PR is not necessary anymore.\n@johann-sonntagbauer or anyone else involved in this PR, would you be interested in developing a Gitlab plugin similar to github?. > @pvdlg is there a guide for building a semantic-release plugin?\nNot yet. I plan to work on that at some point.\nYou can look at existing plugin for an example, it pretty straight forward and the code is documented.. Closing in favor #565. Duplicate of #565. Currently under work as part of #627 and semantic-release/github#32. Duplicate of #627. The feature is currently under work in #627. Let's follow up over there.. Duplicate of #627. @hawkrives, I tested with last release of semantic-release and it works with every URL I tried:\n- npm/npm\n- bitbucket:example/repo\n- gitlab:another/repo\n- git@github.com:example/repo\nCould you confirm that everything works on your end?. A lot of version of semantic-release have been released since this issue was reported. Could you try again with semantic-release@8.1.0 ? This version improve the way we detect the commit related to the last release.. This should be solved by #515 which we just released in semantic-release@10.0.0 on the next dist-tag.\nThe verifications are now part of https://github.com/semantic-release/github and https://github.com/semantic-release/npm.. We could use this package https://github.com/kevva/npm-conf maybe ?. Documentation has been improved in #593\nLet us know if that helps enough. Otherwise all semantic-release projects use semantic-release and can be used as an example. The new commit-analyzer and release-notes-generator plugins both use the last version of conventional-changelog.\nThe conventional-changelog are also configurable.\nFeel free to re-open if the new plugins doesn't fulfill your requirements.. If there is no release on npm, semantic-release will analyze all the commits in your repo to figure out if a release is necessary. A new release (the initial 1.0.0) will happen only if the commit-analyzer determines there is a commit in the history that should trigger a release.\nBy default it's: perf, feat, fix or a breaking change.\nIf your repo contains only commits that doesn't trigger a release, then the initial won't happen. This is the expected behavior as we don't want to make the initial release until there is actually something to release. For example if your firsts commits are something like chore: Add license, ci: Set up Travis etc we don't want to release. Once you push a commit like feat: Initial release for example the release will happen.\nIn addition, the releases rules are now completely customizeable: see commit-analyzer#release-rules\nHere is a config that would trigger a patch release for commits that starts with docs(readme):\njson\n{\n  \"release\": {\n    \"analyzeCommits\": {\n      \"preset\": \"angular\",\n      \"releaseRules\": [\n        {\"type\": \"docs\", \"scope\": \"readme\", \"release\": \"patch\"}\n      ]\n    }\n  }\n}\nThis issue cover a lot of things but I think they should be covered by this new plugin configuration. Some other problems are mentioned but there is corresponding issue already open.\nFeel free to open a new issue if it's not the case.. semantic-release uses by default the Angular format that specify BREAKING CHANGE should be in the body.\nYou can change that by re-implementing a different analyzeCommits plugin.\n. I think that will be possible with the plugin architecture of #484.\nThat would require to:\n- Modify https://github.com/semantic-release/commit-analyzer or create a new plugin that would return a list of package names and version.\n- Modify semantic-release to hand a list of release instead of only one and call the getLastRelease and the publish steps for each release.\n- Modify the npmgetLAstRelease plugin or create a new one to return the lerna tag in addition of the gitHead and the version\n- Modify semantic-release to use the tag returned by getLastRelease instead of v${version}\n- Modify the future npm and github publish plugin or create a new ones to handle the release with lerna specifics (probably just do the release from a the sub-diretory corresponding to the lerna package?)\n. Unfortunately none of the maintainer knows monorepo solutions enough to be able to come up a comprehensive design.\nIn order to move forward we would like to have a proposal, in the the form of an issue or a PR on the evolution repo with:\n- A detailed explanation of the major monorepo solutions:\n  - File structure and naming convention\n  - Commit formats\n  - Scripts used to make a release\n  - Version number / Git tag format\n- A detailed explanation of the release process\n  - How to determine if 1 or more release(s) have to be done\n  - How to retrieve the last release(s), on npm and on git, especially in the case of multiple releases\n  - How to parse the commits and details about the mapping commits <-> releases\n  - How to make the release(s): change directory? run a script? what to do if one of the multiple release fail?\n  - How to generate the changelog: One changelog per packaged released? Or concatenate all of them in one changelog? How many releases on Github? \nThen when we have all this information we can involve the community and discuss the best approach.\nThis idea is that if we support monorepo we'll do it properly:\n- The solution has to be generic enough so the core (and possibly the default plugins) would support any monorepo solution\n- The specificities of each monorepo has to be in plugins\n- The changes in the core and the potential plugin input/output has to be defined beforehand so the community can work on plugin without constant breaking changes\n- As monorepo are very complex solutions with a lot of constraints/workaround, we would need detailed documentation regarding how to implement a workflow for each major monorepo solution\nIt doesn't mean we have to support all solutions right away. But the design as to be generic and robust enough so anyone can create plugins for other/new monorepo solutions without changing the core.\nRef #531. Each commit might impact multiple module in the monorepo. semantic-release has to figure out which module has to be release and with what type of release, then release each one with the proper version increment, passing relevant info to each publish plugin (different tag name as least, maybe version with a prefix depending on the monorepo solution).\nBasically instead of doing one release per push, semantic-release would to do up to one per module.\nI'm not sure how what you propose would work? If you filter the commits for one module (I guess this is the intention of the prefix you mentioned) and release this module, what about the other modules that might have been changed by other commits in this push? And what about the commits changing multiple module at once? How do you handle the tag creation (they must be named v- I imagine)? And do you create one release note for the push, or one per published module?\nUnless you have a script that iterate over the modules directory, and for each one change the cwd, call semantic-release passing the prefix (from a config local in the root of the module ?). Is such script exist for each type of monorepo solution? Can it be configured to call semantic-release? How configurable it is?\n. > The benefit of this solution is that it is simple and the semantic-release runs can be run in isolation as parallel jobs in CI (as it is usually done with proper monorepo CI configs - you're not testing/deploying every package serially).\nThis forces the users to find a solution to iterate over the packages and run semantic-release for each one of them, so it's not really more simple from the user perspective.\nThe CI configuration you are mentioning doesn't  seems to be the approach chosen by monorepo solution. For example lerna publish iterate over the package and makes the release for each one of them, and it doesn't seems there is a solution (at least not clearly recommended in the doc) to achieve that.\nMoreover, configuring your CI this way will have a huge impact on build time. semantic-release takes a few seconds to run, while cloning starting the CI VM, cloning the repo (especially for monorepo as the repo is bigger), installing the dependencies and running a potential build on each packages will takes a lot more time. Basically you would save a couple seconds by parallelizing the semantic-release runs and loose several minutes by duplicating the startup, npm install, repo cloning and build.\n\nNow what this doesn't work well for of course is the case like angular where you just have a bunch of packages that in reality are always kept in sync to have the exact same version number...\n\nMost monorepo seems to propose 2 mode: locked and independent that works quite differently. A semantic-release would have to handle both situation as seamlessly as possible.\nI'm not sure if semantic-release would have to do the iteration over the package or if an external script should do it and call semantic-release. There is many things at play here, including the different choices made by each monorepo solution.\nThis is why, in order to come up with a solid design, with the core being generic enough to work with any solution/mode, and allow specifics to be done via plugins, we need first to understand in great details how monorepo works. Hence all the questions I asked here.. @evocateur nice to see you here!\nAfter reading a lot about multi-package repo, here what's missing in semantic-release so far:\n- Loop over the different packages directory and do the release on each one\n- Filter the commits that are relevant to the current package\n- Create tags with a format specific to the current package\nThe main questions is: should it be up tosemantic-release to loop over the different packages directory or an external solution?\nUsing an external solution like lerna exec has several advantages:\n- less complexity for semantic-release\n- avoid duplicating existing solutions\n- allow more flexibility for users\nThe main inconvenient are:\n- a bit more configuration to do for users\n- difficult to run both tasks per package and globally (for example it won't be possible to publish each package on npm but to make only one release on GitHub) => See workaround below\nHere is the solution I propose for semantic-release:\n- [ ] Add a tagFormat option to semantic-release. By default it would be v<version> (version would be replaced by the next version determined by semantic-release). When using multi-packages users would have to define in each package.json a format like pkg-name@v<version>.\n- [ ] Move the getLastRelease and the tag creation steps into the core (it has also other advantages, see release-workflows and this comment)\n- [ ] Add a new filterCommits plugin hook that would filter the commits based on the current cwd so users can implement different solutions (based on commit format for example)\n- [ ] Create a new multi-pckages plugin that would be used as the default filterCommits. It would filter commits that create/delete/modify files under the current cwd (similar to lerna).\nThis will support transparently the independent mode.\nIn order to use the locked mode, users will only have to define the same git tag format for each package (or not define any to use the default v<version>), this way:\n- Only one tag will be created per run (whether 1 or n package is released)\n- All the packages will always have the same version (as the get last release step will be based on the unique tag created on the last run)\n- Only the packages that change will be released (as the filter will return an empty array for packages that didn't change)\nFor the specific case in which we want to execute some publish steps for each package and some for the whole repo we could recommend to:\n- In the package.json of each package configure the plugin that has to be run for each package (i.e. npm)\n- In the package.json of the repo (at the root) configure the plugins that has to be run for the whole repo (i.e github if we want one GitHub Release)\n- Run semantic-release for each package + 1 time for the repo root\nAt the cost of some simple configuration (lerna exec or similar + tagFormat in each package.json for the independent mode) we would support all the multi-package scenario/implementation with minimal changes in semantic-release.\n@evocateur would that work with the refactoring you are doing ? Basically we would need lerna exec to loop over each package sequentially and run semantic-release.\nI already have a kind of working POC locally with this solution. If everybody involved agrees on the solution I could implement it within the next few days.\n. Nice to see that the Jest team is interested in semantic-release!\n\nOne thing I like about current lerna publish is that it also bumps dependents of updated packages. While semver dictates that it shouldn't matter, I find it useful and helpful to guarantee the latest version of dependencies between published modules in a monorepo.\n\nI don't think it's semantic-release responsibility to do that. Maybe there is another lerna command that allow to do the update without publishing? This command could be run before calling semantic-release on each package?\n\nRelated, the changed version fields should be committed back to the repo to allow linking between modules to continue working (might be covered in your post, and I'm just missing it).\n\nThat can be done with the git plugin. Is it necessary for lerna to have the actual last version released in the pacakge.json on the repo? maybe @evocateur can shade some light on that?\n\nlerna publish --conventional-commits currently create a changelog in each package, useful when \"releases\" on github are full of other stuff.\n\nThat can be achieve with the git plugin and the changelog plugin. Is there something covered by lerna publish --conventional-commits that is not covered by semantic-release?\n. > I guess supporting a simpler setup where all packages are released with the same version like in https://github.com/pouchdb/pouchdb should be much easier to support, right?\nThere is no simple solution for supporting both independent and locked mode. It's a tradeoff between config and huge complexity in semantic-release. The proposal choose the config complexity.\nThat means to support the pouchdb solution you would have to do what mentioned above:\n\nIn order to use the locked mode, users will only have to define the same git tag format for each package (or not define any to use the default v)\n\nwhich is really simple. The complicated part is to have multiple npm releases but only one GitHub release. You would have to do that:\n\nFor the specific case in which we want to execute some publish steps for each package and some for the whole repo we could recommend to:\n- In the package.json of each package configure the plugin that has to be run for each package (i.e. npm)\n- In the package.json of the repo (at the root) configure the plugins that has to be run for the whole repo (i.e github if we want one GitHub Release)\nRun semantic-release for each package + 1 time for the repo root\n\n. > 'm not sure running semantic-release in n+1 packages will be sufficient, or correct, as during any given lerna publish there can be a range of actual npm publish calls, from \"all\" to \"none\" (if all extant changes were in non-managed directories or files, for instance).\nDo mean that when publishing a package there can be multiple calls to npm publish? How so?\nIn any case, it would be out of semantic-release scope to determine how many times a single package have to release. It would be up to an external solution (lerna in that case) to execute semantic-release for each release that has to be done, even if it's multiple times on the same package.\n\nThe cross-dependency bumps are vital to the lerna pattern, and they really only work with one high-level process to coordinate those bumps (which also need to happen in topological order, so you don't try to publish a package before its dependencies).\n\nDetermining the order and doing the cross-reference would be out of scope for semantic-release. I imagine that it's also dependent on the multi-package solution used.\nIs there a way for lerna to handle that part and delegate to semantic-release the tasks of determining the next version, updating the package.json version, running npm publish, generating the changelog.md and creating the GitHub release?\nBasically what we would need is a command like lerna exec semantic-release that would handle:\n- Figuring out each package directory\n- Handle the cross-dependencies\n- For each release to be done, change the current directory to the package directory and call semantic-release\nMaybe this lerna command would work as follow:\n- Link the dependencies\n- Determine the packages and the order in which to release them\n- For each package:\n  - change the current directory\n  - call semantic-release\n  - Do whatever is required to update links, cross-dependencies etc..\n  - Repeat for the next package in the list\nI though, according to comments in this thread by other lerna users that it was more or less what lerna exec was doing? Or that at least there would be a way to have this behavior with a combination of lerna exec and other lerna commands.\nWould it be possible? Would that require lerna modification? Or other tool?\n\nI don't think getLastRelease can be removed from a plugin, since it would need to be so dramatically different for the multi-package plugin. I might be wrong. I hope to re-integrate the gitHead property for lerna-published modules, which would provide a network-based (instead of tag-based) method of determining the previously published version.\n\nWhy would it be different for multi-package? The getLastRelease just find the commit sha used to make the last release. Doing so with the gitHead attribute in the npm metadata create several issues and is not compatible with package manager that doesn't have an equivalent field.\nUsing git tags would be more stable and compatible with any package manager. We just need to create a tag for each release (which semantic-release will do). There will one tag per release in locked mode and one tag per package release in independent mode.\n. We have implemented two of the features described in this comment:\n- Move the getLastRelease step to the core: #613\n- Add tagFormat option: #626\nWe implemented those features as they make sense on their own. They might also help moving toward multi-package repo support.\nHowever it seems the solution I proposed in this comment which is similar to semantic-release-monorepo doesn't work as the following is missing:\n- Defining the order in which release have to be done\n- Update the package.json for cross-dependency\nHere is an example to illustrate the problem. If we have multi-package repo with moduleA, moduleB and moduleC. moduleA depends on moduleB which depends on moduleC.\nIf we make a breaking change commit that modifies the 3 modules, then the release process should:\n1. Determine the following order: moduleC, then moduleB, then moduleA\n2. Release moduleC\n3. Update moduleB's dependencies in package.json with the new version of moduleC\n4. Release moduleB\n5. Update moduleA's dependencies in package.json with the new version of moduleB\n6. Release moduleA\nAnd it gets even more complex with multiple cross dependencies...\nThe solution I proposed in this comment doesn't handle steps 1, 3 and 5. As far as I understand semantic-release-monorepo doesn't handle those either. Handling the the steps 1, 3 and 5 from the examples above is out of the semantic-release scope.\nAs mention before, if we support multi-package repo in semantic-release the solution has to be comprehensive and works in every situations.\nIn conclusion, the design needs more work. We are still interested in supporting multi-package repo in semantic-release, but nobody in the maintainers team has time, knowledge or desire to investigate multi-package repo more to come up with a complete working design.\nThat mean we would rely on the community to do this research/design work as requested here, and we can help with questions/ideas/proposals for the parts specific to semantic-release. Once we have a thorough and detailed proposal with possibly a POC, we would consider implementing it, but until then the maintainer team won't move forward on multi-package repo.. @evocateur one other possibility we can explore is to expose different functions in the semantic-release API, so lerna could call them. For example we could expose getNextVersion and publish, so lerna would call them when appropriate. Just mentioning it, I don't know if it's something you would consider of if that would help.. > and I don't think its necessarily a required feature of a monorepo \nI'm not an expert on multi-package/mono repo but it seems that in the example mentioned above, that would release some broken packages.\nIf you make a releases in this order  moduleA, then moduleB, then moduleC you will end up the following on npm:\n- New major version ofmoduleC OK\n- New major version ofmoduleB with code depending on the new major version ofmoduleC but with a package.json depending on the previous version of moduleC => broken package\n- New major version ofmoduleA with code depending on the new major version ofmoduleB but with a package.json depending on the previous version of moduleB => broken package\nSo it seems pretty much necessary to support that. With the current implementation of semantic-release-monorepo you will release broken packages for each release of an out of range cross-dependency.. Lock files would not change that, as they are not published anyway. If you are talking about a shrinkwrap file, it would make things worst as the problem would happen for each releases instead of the only the major.\nTo make things clearer here is a more detailed version of the example above with only 2 modules.\nModule A\nThe last version published on npm is 1.0.0 and it depends on moduleB.\npackage.json\njson\n{\n  \"name\": \"moduleA\",\n  \"version\": \"1.0.0\",\n  \"dependencies\": {\n    \"moduleB\": \"^1.0.0\"\n  }\n}\nindex.js:\njs\nconst moduleB = require('moduleB');\nmodule.exports = () => {\n  const b = moduleB();\n  console.log(b);\n};\nModule B\nThe last version published on npm is 1.0.0.\npackage.json\njson\n{\n  \"name\": \"moduleB\",\n  \"version\": \"1.0.0\"\n}\nindex.js:\njs\nmodule.exports = () => {\n  return 1;\n};\nBreaking change commit\nNow you make a commit to have moduleB returning an Array instead of a single value. That's a breaking change. The changes would be like this.\nindex.js in moduleA:\njs\nconst moduleB = require('moduleB');\nmodule.exports = () => {\n  const b = moduleB();\n  console.log(b.sort()); // Now we expect an Array\n};\nindex.js in moduleB:\njs\nmodule.exports = () => {\n  return [3, 2, 1]; // Now we return an Array\n};\nThen you push the commit and semantic-release-monorepo run.\nReleases\nsemantic-release-monorepo would release the version 2.0.0 of moduleB that returns an Array, everything ok so far.\nBut then it would make a 2.0.0 release of moduleA with the following content:\npackage.json in moduleA:\njson\n{\n  \"name\": \"moduleA\",\n  \"version\": \"2.0.0\",\n  \"dependencies\": {\n    \"moduleB\": \"^1.0.0\"\n  }\n}\nindex.js in moduleA:\njs\nconst moduleB = require('moduleB');\nmodule.exports = () => {\n  const b = moduleB();\n  console.log(b.sort());\n};\nThe moduleA package is broken because it's package.json refer to moduleB@1.0.0 which returns a single value, however the code in it's index.js expects an Array. So user's of moduleA will get an error.\nThe only way to make that works is to update the cross-dependencies in moduleA after releasing moduleB and before releasing moduleB, which is not done by semantic-release-monorepo.. If you use a mono-repo with lerna, lerna publish will take care of such scenario and and would release moduleB, update moduleA's package.json and releasemoduleA. \nPer lerna's doc for lerna publish:\n\nMore specifically, this command will:\n1. Run the equivalent of lerna updated to determine which packages need to be published.\n2. If necessary, increment the version key in lerna.json.\n3. Update the package.json of all updated packages to their new versions.\n4. Update all dependencies of the updated packages with the new versions, specified with a caret (^).\n5. Create a new git commit and tag for the new version.\n6. Publish updated packages to npm.\n\nThe missing steps in semantic-release-monorepo are 1 and 4.\nThe benefit of a mono-repo is that you can modify multiple packages at once. It allow to build a feature that spans across multiple packages more easily. if you don't support this scenario there is no much point in using a mono-repo.\nWithout that, if you want to make a feature that span across multiple packages you have to update moduleA code, then commit, then release, then update moduleA's package.json, then modify moduleA's code, then commit, then release. That's the workflow used in an architecture with one module per repo.\nSo if you don't support modifications that spans across multiple packages in the mono-repo, you loose the main advantage of having a mono-repo.\n. What you are proposing has already been propose here: https://github.com/semantic-release/semantic-release/issues/193#issuecomment-359132861 (named filterCommits).\nThere is still other unresolved issues, see https://github.com/semantic-release/semantic-release/issues/193#issuecomment-364520929 and following comments.\nSolving those issues would involve:\n- Determining the order in which the releases have to be done\n- Updating the package.json of dependents in between releases\nThat is already handled by Lerna, and it's a fairly complex complex algorithm. semantic-release shouldn't re-implement/duplicate that code. The challenge here is to find the proper integration between Lerna and semantic-release.. @evocateur, just out of curiosity, why the cross-references use a specific version/range and not *?\nSo if you have moduleA having a dependency on moduleB, why not defining in moduleA package.json the following?\njson\n{\n  \"dependencies\": {\n    \"moduleB\": \"*\",\n  }\n}\nBy doing so we wouldn't have to publish in a specific order nor to update cross-dependencies in between publications.\nIt would still be problematic when using shrinkwrap, as npm-shrinkwrap.json would contain an exact version and would still need to be updated.\nMaybe there is a way to exclude the cross-dependencies from shrinkwrap?\nIs there an other case in which it would result in an undesired behavior? Maybe it's acceptable to not support the shrinkwrap case.... OK, it make sense. Thanks for the explanation.\nHowever how relative file: specifiers would solve this issue? As far as I understand we can't publish a package that refer to another one with a file: specifiers.. Fixed.\nThanks !. @RWOverdijk is this issue still happen with the last release of semantic-release ?\nIf yes can you provide an updated link to a failing CI build ?. Travis pulls only 50 commit commits from the history. So the commit that was used for the last release is more than 50 commit back, semantic-release will not find it.\nSee https://docs.travis-ci.com/user/customizing-the-build#Git-Clone-Depth. Supporting other package manager will be possible when #484 will be implemented.\nI'll have some time this weekend to work on that but probably not before.\nWith #484 you will be able to disable the NPM_TOKEN verification and the npm publish and run anything else instead.\nBut there will still be some restriction due to:\n- semantic-release getting a lot of info from the package.json (config, module name, module scope, dist-tag, repo url etc...). So supporting a package manager that doesn't rely on package.json will not be possible in the near future.\n- The next version is determined in semantic-release and follow semver. So package manager that doesn't support server won't be supported in the near future.\nAt that point the priority is #484 to support workflow that doesn't use npm and to give the possibility to create plugins for other repository type, and if possible other package manager.\nWe are also discussing how to support dist-tag in a better way with npm, in particular the scenario with a LTS/legacy/maintenance dist-tag. It's a problematic that is far from being easy as is has a lot of implications and there is almost as many workflow as there is developers.\nSupporting other package managers with their own specificities in terms of version / branch / tag / release channel is not the top priority at the moment.\nOnce we have a 100% robust and simple solution that support a LTS/legacy/maintenance + latest + next dist-tag type scenario with npm we will consider other package manager.\nThat said, if a package manager works similarly to npm that should be easy to integrate via plugin.\n. For information, here is a thread with a discussion related to dis-tag vs pre-release scenario: https://github.com/semantic-release/semantic-release/pull/431\nI don't know anything about composer. So I'm not sure what type of workflow it relies on.\nAs mentioned previously we still have a bit of work to completely support a dist-tag based workflow and that's the priority. There is a discussion around that in https://github.com/semantic-release/semantic-release/issues/371.\nIf you could formulate the changes necessary to be made in semantic-release to support the scenario you want to implement we will absolutely consider it. But at that point, I don't fully understand how this workflow would work and I don't know what modification would be required.\n. Duplicate of #563. Feedback welcome in #563. Thanks !. semantic-release will make the initial release, as soon there is at least a commit that trigger a release (by default fix, feat). This is the intended behavior.\nFor the first commit on your repo you can for example use feat: Initial release. That will trigger release 1.0.0.\nIf you have a repo with several commits and some releases already done before configuring semantic-release everything should work smoothly as soon as semantic-release is configured and you start using formatted commits.\nsemantic-release starts version at 1.0.0 and it's a design chose. The whole point of semantic-release being to remove  the connection between human emotions and version numbers by following semver.. Thinking about this a bit more...\nWhen is the version is package.json is present\n| Phase  | Description | Version set  | \n|---|---|---|\n| npm test script | Usually runs on Travis script step  | No |\n| npm prepublish | Runs in after_scuccess, trigger by npm publish  | Yes |\n|Any PR build | | No|\n| Execution  | When a user install the package from npm and use it  | Yes\nDifferent scenario and solutions\nDisplaying version in a cli tool\nThe package is published on npm with a package.json containing the published version.\nSo at runtime (i.e. when a user install your package from npm and use it) the version is available and can be used. A cli tool for example can read its package.json and display it's version.\nPublishing documentation or a website\nThe version might be required so the script can publish in a the proper subfolder (i.e. http:mysite.com/myproject/doc/vx.x.x).\nThis script can be run in the after_sucess phase, after semantic-release. For example semantic-release pre && npm publish && semantic-release post && my-doc-publish-script\nThe doc/website publish would run only when a release is done.\nBuild script that require the version\nThe solution is to run the build script during the prepare, prepublish or prepublishOnly script phase. This way semantic-release would update the version in the pre phase, and npm would call the prepare, prepublish or prepublishOnly before calling npm publish.\nUsing version from package.json during tests\nThis wouldn't work.\nBut I don't see a scenario that would require that. \n=> Do you have an example of such scenario?\nUsing version from package.json in a PR\nThe version wouldn't be present for a PR build.\nIt doesn't make sense to do a release in a PR anyway and I don't see a scenario in which a script ran in a PR would need to access the version.\n=> Do you have an example of such scenario?\n=> Is there any other scenario not covered here ?. This feature has been implemented via the plugin https://github.com/semantic-release/git. I think this should be solved by https://github.com/semantic-release/semantic-release/pull/453, which is in semantic-release@8.1.0 currently release on the next dist-tag.\nCould you give semantic-release@8.1.0 a try and let us know if that solve the issue ?. @gavriguy can you clarify what do you mean by force publish?\nIf you mean npm publish -f it's not supported anymore: http://blog.npmjs.org/post/77758351673/no-more-npm-publish-f\nI'm not sure I understand the relation between the Travis job not running and the need to force publish...Can you clarify?\nIf the release didn't happen because of an issue on Travis, I would suggest to just restart the job on Travis after your configuration is fixed. Would that solve your issue?\n. Closing as the question was answered by @nephridium.. The commit analyzer and release generator plugins allow to select the  conventional-changelog preset to use and even allow to overwrite any properties.\nSee commit-analyzer#release-rules and release-notes-generator#parser-options.\nFeel free to re-open if it doesn't fit your needs. Duplicate of #176 . Yes this is now a supported workflow with git and npm plugins.\nYou can check the doc in those repo for more details.. you do not have permission to publish \"json-transformer\". Are you logged in as the correct user? : json-transformer is an npm message. It comes from npm publish, so there is no much we can do in semantic-release.\nBut we are planning to improve log messages: #438\nsemantic-release now require Node 8. All release task will be skipped if the Travis job run on a version lower than 8. So you need to have at least one Travis job running Node 8.\nYour feedback is much appreciated. We'll keep your comment in mind to improve logs and documentation. . Yes indeed. We've open an issue for that: semantic-release/cli#126 :). A lot of semantic-release version has been released since this bug was opened.\nIs this issue still happening with the last release ?\nIf yes, could you provide a link to the CI job on which the publish failed ?. Is this issue still happen on the latest release ?\nIf yes could you provide a link to the CI job that fails to do the release ?. Since version 11.0.0 semantic-release can be used to release any type of project independently of the language.\nIt requires to create plugins.\nVersion 11.0.0 is available on the @next dist-tag.\n . The code mentioned is not part of semantic-release anymore. The Module not found is expected if the referenced plugin is not accessible.\nIs this issue still happening ? Or can we close it?. Closing due to lack of response. Please re-open if it's still an issue.. This issue should be solved with semantic-release version >=9.0.0 as we don't return an error code when there is no releases. See #480.\nPlease re-open if the issue is not solved.. Similarly to this comment wouldn't it be better to run inchjs in the test phase rather than in the release phase?\nIf the documentation threshold is not met, the test should fail, similarly to test coverage or linting errors. In that case the release wouldn't be even attempted.. Closing per previous comment. Please re-open if the previous comment is no accurate.. This feature has been implemented via https://github.com/semantic-release/git plugin. Authentication with Artifactory is support be semantic-release via the environment variables NPM_USERNAME, NPM_PASSWORD  and NPM_EMAIL.\nI'm not sure it is support by semantic-release-cli setup though. Could confirm?\n. Duplicate of semantic-release/cli#79. If you don't want to deploy to npm and still test your plugins, you could reference them as dependencies with their github url. See package.json#github-urls.\nThis way when running npm install you packages will be downloaded directly from their Github repo rather than npm.. Let's continue the discussion in #585. Closing as the problem seems to be solved. Please reopen if it's not the case. I think a workarround in the form of a more explicit error message has been added here\nI'm not sure if we can do anything more on semantic-release unfortunately.\nIs this error message solve this issue in a reasonable way?. Ok, I'm gonna go ahead and close this issue.\nFeel free to re-open if you can think of a better way for semantic-release to handle this situation.. Is it still happening with the last version of semantic-release?. Closing for now. Please re-open if the problem is still happening.. > I realize the failure exit code also directly affects travis (and others) in the deploy step: semantic-release pre && npm publish && semantic-release post, but I believe there might be a better approach... (just not one that I have figured out yet) I will update here when I do.\nYes indeed we need to exit with an error to prevent the following command to be executed.\nThe only solution I can think of is to modify semantic-release to do in one command what's currently done by semantic-release pre && npm publish && semantic-release post.\nBut that has a lot of consequences.\nDid you continued to do some research on this? Do you have an alternative proposal ? Other ideas ?. Yes. The main challenge that I see is that we want to continue to publish exactly like npm publish does. So I don't know if there is an official (like npm supported) API to publish.. This is the new config format for commitizen.\nIt's not something you can test per say as it's just an indication of the commit format we use for people using commitizen.\nYou can try by installing commitizen npm install -g commitizen and then run node_modules/.bin/git-cz. @zcei would you mind you rebase the PR? Or you can check \"Allow edits from maintainers\" and I'll do it for you. Thanks !. Thanks !. Release from a PR is not possible as it require to have access to the various authorization token (GH_TOKEN, NPM_TOKEN). Environment variable are not available for build triggered by a PR from a forked repository.\nPlease see #563 for a proposal regarding pre-release and dist-tags. Feedback welcome over there!\n. semantic-release 8.0.0 requires Node > 8 so you need to have at least 1 of your job running on node 8. The node 8 job will always be considered the build leader.\nFor example with this travis.yml:\nyaml\nnode_js:\n  - '8'\n  - '6'\n  - '4'\n- The node 8 job will be the build leader, run semantic-release, wait for the other jobs to be successful and publish on NPM\n- On the Node 4 and 6 jobs semantic-release just output the message This test run is not the build leader and therefore a new version won\u2019t be published and do nothing else.\nThis is the intended behavior as we want to publish only once.\nFor information, publishing with node 4, 6 or 8 doesn't make any difference. Your npm package is published all the same.\nsemantic-release enforce using node 8 to publish as it allows to use the latest node 8 feature in semantic-release source code without having to transpile.\n. @calebeby, I think this is because you are using old version of condition-travis and travis-deploy-once. See here in your yarn.lock.\nThis is because you updated your package.json without updating your yarn.lock.\nEither remove yarn.lock from your repo, or install/update dependencies with the yarn cli and commit the changes in yan.lock.. @calebeby, everything seems ok in your config, and I don't understand the problem yet.\nI will try to fork your repo, reproduce and add more logs to figure out.\nBefore that, could you try to run semantic-release with npm instead of yarn, just to be sure it's not a yarn specific issue.. The Travis API might have change? Or respond differently ?. It should be fixed by https://github.com/semantic-release/travis-deploy-once/pull/12\nThe issue was happening if the node version is specified as number rather than a string.\nFor example node_js: '8' and node_js: 8 was not.\nNow that the fix is published it will work no matter is the version is defined as a string or a number.\nAs FYI, the node version can also be defined like this node_js: node which indicate to Travis to use the latest stable version.\nMake sure to update your lock files if you have them in your repositories.\nCould test again and let us if everything works ?. Just tried and it seems it has been fixed.\nFeel free to re-open if you still encounter the issue.. @balibou Did that solved your issue ?. Can you try again after removing npm prune from your .travis.yml ?\nI think the problem is that you do the install with yarn (Travis does that becuause you have a yarn.lock in your repo) and then when you call npm prune that might break something.. A lot of new version of semantic-release have been released since this issue has been opened.\nCould you confirm if it's still happening with the last version of semantic-release ?. Closing due to lack of response. Please re-open if the problem is still happening. Fixed in last semantic-release version. I'm working on another PR and I will probably remove the deprecated npmconf.\nWould that work if we create the .npmrc file is it doesn't exists and append to it if it does exist ?\nYou mentioned \"the process fails because the Jenkins Multibranch Pipeline doesn't allow it\", can you explain a bit more in detail what the problem exactly is? Is it Jenkins that disallow to modify the .npmrc ?. We released semantic-release@10.0.0 on the next dist-tag that uses the plugin https://github.com/semantic-release/npm.\nWe now update the .npmrc only if it doesn't contain an authentication setting for the configured registry. Also we append to the file, therefore we don't erase any configuration that might be there already.\nFeel free to re-open if that doesn't completely solve your issue.. The releases rules are now completely customizeable: see commit-analyzer#release-rules\nIn addition the perf commit now trigger a patch release in accordance with the last angular conventions.. The scenario described in this comment currently works, with the exception that we do not enforce the type of release allowed on a given branch/dist-tag.\nHere in a configuration to support this scenario:\n- git 2x branch with code of version 2.0.0, release on 2x dist-tag\n- git master branch, with code of version 3.0.0, release on latest dist-tag\n- git next branch with code of version 4.0.0, release on next dist-tag\nThe package.json on branch 2x:\njson\n\"release\": {\n  \"branch\": \"2x\"\n},\n\"publishConfig\": {\n  \"tag\": \"2x\"\n}\nThe package.json on branch master:\njson\n\"release\": {\n  \"branch\": \"master\"\n},\n\"publishConfig\": {\n  \"tag\": \"latest\"\n}\nThe package.json on branch next:\njson\n\"release\": {\n  \"branch\": \"next\"\n},\n\"publishConfig\": {\n  \"tag\": \"next\"\n}\nWith this config:\n- A fix commit on 2x branch would trigger the release 2.0.1 on dist-tag 2x\n- A fix commit on master branch would trigger the release 3.0.1 on dist-tag latest\n- A fix commit on next branch would trigger the release 4.0.1 on dist-tag next\nThe scenario works, but there is still a few issues:\n1. A breaking change commit on 2x would trigger the release 3.0.0 on dist-tag 2x and  fails as 3.0.0 already exist (not on the 2x dist-tag but still npm would refuse the release)\n2. Making 4.x.x the new latest and 5.x.x the new next is a manual process:\n  - Create branch 3x from master\n  - Change the package.json on branch 3x to \"publishConfig\": {\"tag\": \"3x\"}\"\n  - Run npm dist-tag add <package>@<latest 3.x.x version> 3x to move the last 3.x.x to the 3x dist-tag\n  - Run npm dist-tag add <package>@<latest 4.x.x version> latest to move the last 4.x.x to the latest dist-tag\n  - Merge the next branch into master and change the package.json on branch master to \"publishConfig: {\"tag\": \"latest\"}, \"release\": {\"branch\": \"master\"}\nIn order to solve 1 we could allow a new \"branches\" configuration that would define a list of branches and the version range we allow to release from them. With the initial example it would be:\njson\n\"release\": {\n  \"branches\": {\n    \"2x\":  \"2.x.x\",\n    \"master\":  \"3.x.x\",\n    \"next\": \"x.x.x\"\n  }\n}\nIf a breaking change is pushed on the branch 2x we would not do a release (because 3.0.0 is not in range 2.x.x) and report an error to the user. We can even imagine doing that on a PR before it get merged.\nWe might even be able to do something a bit smarter for master, by allowing only releases that are inferior to the earliest version released on next not present on latest yet. That would require to configure somewhere that master < next.\nRegarding 2, it's fairly complex and I'm sure everybody has some specificities in their workflow, so it will be hard to automate. Plus this process shouldn't have to be done too frequently as we can assume that a project maintaining old major version is probably not doing too many breaking changes. So maybe some documentation would be enough?\n. Duplicate of #563. Feedback welcome in #563. Thanks !. This fix is now present in the latest dist tag. Please update to semantic-release ^8.0.0. Failed on unsupported node versions. Duplicate of semantic-release/cli#112. 2.4.0 doesn't break the build anymore apparently. semantic-release now support the BUILD_LEADER_ID environment variable, that allow you to define which build as to be considered the build leader.\nHere is an example of a travis.yml file with build stages.\nyaml\nlanguage: node_js\nnode_js:\n  - 8\n  - 6\n  - 4\nos:\n  - linux\n  - osx\nenv:\n  - BUILD_LEADER_ID=7\njobs:\n  include:\n    - stage: release\n      node_js: 8\n      os: linux\n      after_success: \n        - npm run semantic-release\nThis file configure 6 base jobs that will be ran on the default test stage: node 4, 6 and 8 each on OSX and Linux.\nThe a release stage will run 1 jon on Linux and Node 8 to execute semantic-release.\nWe set BUILD_LEADER_ID=7 because the the job that execute semantic-release will be executed after the 6 base jobs and be the 7th to run.\nAs a side note if [ \"$TRAVIS_BRANCH\" = \"master\" ] && [ \"$TRAVIS_PULL_REQUEST\" = \"false\" ]; here is not necessary as semantic-release already verify that the branch is master and the build is not triggered by a PR. See condition-travis and semantic-release#options.\n. Seems to be fixed with config from this comment\nFeel free to re-open if you still experience and issue.. The releases rules are now completely customizeable: see commit-analyzer#release-rules\nHere is a config that would trigger a patch release for commits that starts with docs(readme):\njson\n{\n  \"release\": {\n    \"analyzeCommits\": {\n      \"preset\": \"angular\",\n      \"releaseRules\": [\n        {\"type\": \"docs\", \"scope\": \"readme\", \"release\": \"patch\"}\n      ]\n    }\n  }\n}\nFeel free to re-open if you can't configure it the way you want.. Thanks for looking at this issue !\nI would have a few questions/remarks. As mentioned in npm/npm#3363 \"gitHead\" is not part of the spec so it might not be the best idea to add it in the package.json before publishing. Because it's not specified in the spec, it could change anytime and npm publish could change to store the 'gitHead' differently in the registry, overwriting it before publishing, or completely ignore it.\nFor now npm publish not publishing the gitHead seems to be a bug, as in most cases it's published. Did you manage to find more information about it or a reproduction case ?\nSo we could open a bug report with npm (or check if one exist already).\nRegarding using the tag as a fallback, by default Travis doesn't pull tags, so they won't be available on the CI. I'm not sure about the other CI. So we should probably check if the project is a github repo and call the github API or do a git fetch --tags.\nI think it's important to continue to publish package exactly the waynpm publish would in a normal case (ie having the version and name in the package.json).\nIt's probably better for us to only workaround the consequences of a potential npm publish (by finding an alternative way to get the gitHead like tags) and not workaround the bug itself as we'll encounter it anyway on version not published by semantic-release.. Actually I was proposing the opposite :)\nWe have to deal with package published on npm without a git head, because that can happen if a package is published from a non git root directory or from outside the git directory. There will always be a lot of package published without semantic-release and we have to be able to deal with those.\nAnd the best (only?) workarround seems to be to use the git tags.\nWe also have a request to allow to customize the tag in #431. We won't be able to implement both  as we would need the tag to match the version published on npm.\nRegarding npm that doesn't publish the gitHead at that point we have no evidence it's a bug in npm and it seems to be related to something specific on your environment or on Circle CI.\nYou mentioned:\n\nIn case CircleCI command starts with npm publish it doesn't write gitHead to published package.json even if it runs from proper git repo dir - maybe because CircleCI runs each command in a new shell session.\n\nTo be clear npm publish read the gitHead and include it by itself, it's not a semantic-release feature. So running semantic-release pre && npm publish or just npm publish doesn't affect the behavior of  npm publish regarding gitHead.\nSo most likely in your situation the problem is not semantic-release pre && npm publish vs npm publish but something else. For some reasons, in your configuration when Circle CI runs npm publish it doesn't have access to the git info.\n=> We should analyze that and find the root cause of the problem before trying to implement a workaround in semantic-release.\nHere is a few guesses about the potential root cause of your issue:\n- When you run npm publish the current directory is not the root of your repo\n- When you run npm publish the repo directory doesn't contains the .git directory\nCould you check that ? Or could you provide a link to your repo and the Circle CI jobs so we can analyze more in details ? \n. For information when npm publish runs is reads the package.json here and reading the package.json adds the gitHead there.\nSo we would need to figure out why in your situation that function doesn't returns the gitHead.\nMaybe your issue is related to that https://github.com/npm/read-package-json/pull/67 ?. Thanks so much for for the reproduction environment ! It's very helpful !\nI created this repo based on yours and I managed to reproduce the problem with a reduced test case.\nIt seem to be a Circle CI issue that drop the git refs informations in the deployment phase.\nSee https://circleci.com/gh/vanduynslagerp/test-circleci/33\nIn the dependencies step of the build we have a normal git repo with the head reference of the current branch:\n$ cat .git/refs/heads/master\n7e6b47bbb9c467808250a586df39996cd8e4300f\nBut in the deployment step:\n$ cat .git/refs/heads/master\ncat: .git/refs/heads/master: No such file or directory\ncat .git/refs/heads/master returned exit code 1\nFor some reason, on the deployment step CircleCI clear the .git/refs/heads directory. So when npm publish runs it cannot get the gitHead with this function.\nSo the problem is not running semantic-release pre && npm publish && semantic-release post in one command or in two. It's related to which phase of the Circle CI build it runs.\nSo if you would run semantic-release pre && npm publish && semantic-release post in the deployment the problem would be the same because files are missing in the .git directory.\nBoth semantic-release and npm publish have to run on a valid git repository.\nI did a bit of research and I couldn't figure out why Circle CI drops the content of .git/refs/heads on deployment phase... Seems to be a bug in Circle CI. I also figured out the the problem is similar during the test step.\nI opened a support ticket with CircleCI here: https://discuss.circleci.com/t/git-refs-heads-master-missing-on-test-and-deployment-step/16865\nMaybe CircleCI 2.0 solve the problem.... After more analysis I figured out why.\nIt's because condition-circle runs a special script to fix this Circle CI issue. See refs.sh.\nThe script fixes the problem by restoring the missing .git/refs/heads/master.\nApparently someone ran into this problem before....\nYou can see it being used here.\ncondition-circle is ran by semantic-release pre, this is why running it just before npm publish fix the problem.\nSo if you want to run semantic-release pre on dependencies step and npm publish && semantic-release post on deployment you should run this script just before:\nyml\nmachine:\n  node:\n    version: 8.0.0\ndependencies:\n  post:\n    - npm run semantic-pre\ndeployment:\n  master:\n    branch: master\n    commands:\n      - node_modules/condition-circle/refs.sh\n      - npm run semantic-release\n. Yes I think we should improve the error messages and the documentation regarding those things.\nUsing the git tags as a backup when gitHead is not in the npm package is still a good idea as this situation can happen for many reasons.\nI'm going to work on that soon. I'm also currently working on improving the logs to be more explicit and easier to read.\nMaybe we could open an issue with read-package-json suggesting a more robust way to get the git head. Or at least clarify if the gitHead is actually part of the package.json specification or not (if it is then we could set it in semantic-release).\nFor information we are also trying to figure out a way to have only one step for semantic-release that would handle pre, publish and post. But that's not so easy as we want to publish exactly the way npm does.. Nevermind the PR is already there: https://github.com/npm/read-package-json/pull/67. > Btw I have an input to this idea - the reason why we've split the semantic-release to two parts at some point is that it can be useful to have the package version before it's published - e.g. then we can console.log it from the JS code being run, useful for browser libs.\nAgreed. I have the same problem on some libs.\nMy thoughts so far (nothing is settle has it hasn't been discussed) would be something like:\nnpm install -g semantic-release. Then just semantic-release.\nAnd in addition:\nsemantic-release --dry-run that would print the new version and the changelog in the console\nsemantic-release --update-version that could be ran before the tests (including on a PR) to just bump the version in the package.json.\nBut there is a lot of side effect and edges case to iron out. So I can't tell what direction thing will end up going nor when.\nI joined the maintainer team recently. And what I can tell for sure is that @gr2m and myself are quite motivated to move things forward, and hopefully people have already noticed some small improvements here and there.. Closing for now has it seems the question was answered. Please re-open if you are still experiencing an issue.. tap is not used anymore. In the current version the defaultcommit-analyzer uses the default configuration of conventional-changelog.\nYou can use sr-commit-analyzer and sr-release-notes-generator that allow you to customize the parser options.\nWe are working on making those 2 plugins the default ones, but it's not completely done yet.\nCurrently you can use those 2 plugins by following the documentation in their readme (basically installing the plugins and adding the configuration in your package.json).\n. Those two plugins are now the default ones. You can now customize the parser regex.\nFeel free to re-open if that doesn't fit your needs.. Closing as it seems to be a missing token issue and/or an npm/CI install with the CI config.\nI you still experience the problem, please open a new issue, with the configuration step you went through, and a link to the cI build that failed.. Duplicate of #563. Feedback welcome in #563. Thanks !. Duplicate of semantic-release/cli#105. Could you provide a link to your package.json, travis.yml and the log of your CI that fail to publish ?. The problem happen when the next release determined by semantic-release already exists on the npm registry or has existed and has been unpublished.\nIn order to find a solution we need to figure out:\n- The next release determined by semantic-release\n- The release currently present on the npm registry\n- Find out why the next release is already present on the npm registry\nSo ideally we need:\n- The semantic-release logs for the build that failed\n- The commit history of the project\n- The metadata of the package on the npm registry (obtained with npm view <package-name>). Looking at that @semantic-release/condition-codeship works properly and throw an error in it doesn't run on codeship.\nThe problem was in semantic-release itself, due to a bug I introduced and fixed in this commit:https://github.com/semantic-release/semantic-release/commit/90417c6ffe35c6ba479121a60085f0cfd35c6d1e\nThis fix was released in 8.1.1. So with a version >= 8.1.1, if you run semantic-release locally it will fail as it should instead.\nThat said, I'm not sure it explains the problem you are facing.\nIf you had make an involuntary release on npm during a dry run, semantic-release would have detected this release as the last release, incremented this number and release a version.\nThe problem would happen if you unpublish this involuntary release.\nNPM return this error when we try to publish a version that was unpublished.\nCurrently last-release-npm doesn't detect unpublished version. We are looking at a solution to handle this edge case.\n. This case is tested here: plugins.test.js#L47. Maybe there is a problem somewhere else that cause this behavior.\nCan you share the configuration and the reproduction steps?. Indeed I can reproduce. I will push a fix tonight !. So 8.2.1 solves @yoitsro issue.\nBut I'm not sure about @dsslimshaddy issue.\n@dsslimshaddy could you provide the information requested in this comment. You can run semantic-release pre --debug. That would print the new version determined by semantic-release based on the commit since the last release on NPM.\nYou need to set NPM_TOKEN as semantic-release needs to check on NPM registry what is the last version released (and what's the commit associated with this release).\nOther environment variable are not necessary. semantic-release will display a warning if you don't have CIRCLECI and CIRCLE_BRANCH but it will still analyze your commit since last release and display the new version.\nThe message ENOCHANGE There are no relevant changes, so no new version is released. indicate that no commits you have made on your repository since last NPM release require to release a new version.\nMaybe your commit messages are not properly formatted or none of them are of type fix or feat.. @zetaron thanks for the contribution!\nChecking the remote branch might not completely work though... We check if the last release gitHead is present in the local branch in order to make sure:\n- The source code we currently have on the CI contains all the changes between the last release and the last commit we have in the repo\n- We have all the commits between the last release and now\nChecking that the last release gitHead is present on the remote branch will not guaranties it's present in the current repo on the CI, as we can't verify how far back commit history in the local clone goes or from which branch the detached head was created.\nMaybe a better solution would be to use a different command that would be able to check if the commit is present in the history of the branch or the detached head indifferently.\nI didn't test much but maybe something along those line would do: git cat-file -t <sha>^{commit} or git rev-parse --verify <sha>^{commit} ?\nI'm not really sure if that would work in every cases, or it would have some blind spot or false positive in some cases. So more test would needed.\nOr do you know another way to make that check ?. Duplicate of #431\nSee conversation over for the reasoning regarding custom tag name. See also #457 that is related.. We just released semantic-release@8.0.1 @next dist-tag. \ud83c\udf89\nIt includes 2 refactored default plugins: commit-analyzer and release-notes-generator.\nAmong the new features:\n Option to select commit message style via conventional-changelog preset or config. For example you can choose to use the eslint commit format rather than the default angular.\n Option to customize the commit analysis rules with criteria via release-rules option. For example you can configure the commits with a docs type and a readme scope to trigger a patch release. Criteria can also use regex and can be defined on any field parsed by the selected conventional-changelog preset.\n* Allow to overwrite specific conventional-changelog preset options via parserOpts and writerOpts. It's convenient if you want to use an existing preset but with a small difference, for example a more loose parser regex or using type[scope] instead of type(scope).\nThese new featuree should address several issues in the tracker requesting more flexibility regarding the commit format.\nYou can can try those new feature by installing semantic-release with npm install semantic-release@next.\nLet us know what you think ! Feedback would be very much appreciated !. We've just release semantic-release@8.1.0 on the @next tag.\nYou can test it by updating your package.json explicitly referencing the new version:\njson\n\"devDependencies\": {\n  \"semantic-release\": \"^8.1.0\"\n}\nOr by running npm install --save-dev semantic-release@next.\nThis new release ship with #453 that change the way we determine the git head of the last release which we use to determine the commits to analyze since the last version.\nWe used to rely on the gitHead filed in the package metadata on the npm registry, but under certain circumstances this field might not be published on npm, resulting in the infamous ENOTINHISTORY error on semantic-release.\nIn semantic-release@8.1.0, when the gitHead is missing from the npm registry metadata we check if there is a git tag associated with the version of the last release and if there is one we use the associated commit.\nIn addition we make sure to unshallow the git repository cloned by the CI, when necessary, to be sure to have access to all git tags and commits.\nPlease give it a try and let us know if it works as expected. You can comment on #453 if you encounter any issue or have a suggestion for improvement.. We are discussing about improving modularization and allowing to cover more workflow in the issue #484.\nIt will be a pretty important change in semantic-release and should allow to cover many feature requested.\nWe'd love to have some feedback from the community ! Feel free to check #484 and help us to find the best solution.. We just released semantic-release@11.0.0 on the next dist-tag. It comes with different optional way to set options that doesn't rely on package.json. This open the door to using semantic-release for any language / type of project via plugins.\nBe aware that plugins now have to return an async function instead of a function accepting a callback.\nThe plugin architecture shouldn't change much now. So if you'd like to develop a plugin for your favorite package manager, git repo etc...it's safe to start now!\nThe next steps I'm going to work on:\n- A plugin to release via commit (allow to release commit dist files, Changelog etc...)\n- A plugin to run shell scripts\n- A way to handle multiple branches / dist-tag / pre-release, in a fully automated way! \n. I did some cleaning/sorting/labeling on the issues/PR across the semantic-release repos.\nA lot of issues a labeled with help wanted. Feel free to check them out and add a comment if you'd like to help and tackle some. Thanks !. We just released semantic-release@11.0.2 as @latest.\nNew features\n\nSemantic-Release must now be executed with semantic-release instead of semantic-release pre && npm publish && semantic-release post\nThe CLI options --debug doesn't enable the dry-run mode anymore but activate the debug logs. The dry run mode is now set with the CLI command --dry-run or -d.\nnpm and github releases are now handled within their one plugins which can be disabled. The plugins also offer a lot of new options\nsemantic-release can now be used for non npm packages and can be configured via dotfiles as an alternative to package.json \n\nSee the release notes for more details.\nMigration guide\nIf you are using a third-party plugin, please verify its documentation and repository to make sure it has been updated to work with semantic-release version 11.0.0.\nUpdate the semantic-release in your package.json from:\njson\n\"scripts\": {\n   \"semantic-release\": \"semantic-release pre && npm publish && semantic-release post\"\n}\nTo:\njson\n\"scripts\": {\n   \"semantic-release\": \"semantic-release\"\n}. The next step will be support more complex release workflows, including multiple branches, distribution channels, Long term support branches and pre-releases.\nFeedback would be much appreciated in #563 !. semantic-release 12 has been released on the latest dist-tag!\nIt comes with changes regarding the CI configuration.\nPlease see the release notes for more details and a migration guide.. I'm closing as it's not used anymore for a while.\nThe project progress can be tracked here: https://waffle.io/semantic-release/semantic-release. We could move to https://github.com/npm/npm-docker-couchdb. That would simplify our code and it would make it work on any OS. Currently we rely on a bash script to start couchdb, so it would work only on Mac OS and Linux.\nThat would also allow us to run our test on a Windows CI, which would quite nice to verify everything work as expected there.. For information I added mock-server to the tests. And I use Docker to start it.\nSee mockserver.js.\nSo we could do something similar for npm-docker-couchdb.\nIn addition there is an authentication issue that would be great to solve:\nCurrently with https://github.com/npm/npm-registry-couchapp and the Docker version the only way to authenticate is with email / password (See this code). While with the regular npm registry we authenticate with just a Token.\nIdeally we should authenticate the same way with the local registry that it's done with the regular npm registry. I don't know how we can make npm-registry-couchapp to accept a token based authentication...So if you have an idea that would be awesome!\n. > might be a stupid question to ask but why does the code you reference care about modification of the .npmrc at all?\nBecause this is the only way to make a release from a CI environment unfortunately.\nnpm publish doesn't support passing the authentication parameters as a parameter or with an environment variable. The only way is to set entry like //<registry_url>/:_authToken=<token>\nIn order to not display the token in the config of a repo we pass it via the CI environment variable and we write //<registry_url>/:_authToken=${NPM_TOKEN} in the .npmrc.  npm will replace ${NPM_TOKEN} by the environment variable value at runtime.\n\nI'd also assume most systems either already have a .npmrc or it would be easy to set up before running semantic-release.\n\nOn a local machine yes. It's setup with npm login. On a CI no, the authentication will not be part of the .npmrc file. Having it would require to set it in the repo and therefore exposing the auth token to everyone.\n\nTherefore I'd suggest to just remove the auth setup from code and add it to the tests setup code as an implementation detail cared for before running the actual integration suite.\n\nAs mentioned above, updating or creating .npmrc with the auth information is mandatory to release from a CI environment. We want semantic-release to take care of that so a user just has to add the NPM_TOKEN environment variable to Travis (in the Settings UI). We don't want the user to have to run an additional command in the CI build to update the file.. All the integration tests runs on Docker now.\nWe should just document somewhere that contributor need install Docker on their machine to run the tests.. > I think we can even work around the problem that the build leader on travis must be running on Node 8.\nTravis released Build stages in beta a few months ago.\nUsing that would allow to greatly simplify the verification:\n- No need to verify for build leader\n- No need for travis-deploy-once. I'm not against clarify the docs at all, but please note this is not a semantic-release option but an npm one.\nAlso the dist-tag management will change quite a lot with #563 that I hope to complete in the next couple of weeks.. Thanks a lot @benjamincharity for the detailed explanation!\n@psyrendust does that solve your issue?. @kasunkv I looked a bit more at this issue and it seems the version 1.0.0 was published on npm from the commit https://github.com/kasunkv/sem-rel/commit/e35192366c0e26eaf87ed6bd2679906e0323eaa6 which is the last commit on your master branch.\nBut the github release and the git tag were created with the commit https://github.com/kasunkv/sem-rel/commit/8865499212f105ba708e12a09f0f7c7135ed4bdb which 4 commit is behind the one used for the npm release.\nIt seems that somehow the order of event was:\n- Commit https://github.com/kasunkv/sem-rel/commit/8865499212f105ba708e12a09f0f7c7135ed4bdb => release on github + tag but no release on npm\n- Commit https://github.com/kasunkv/sem-rel/commit/e35192366c0e26eaf87ed6bd2679906e0323eaa6 => release on npm but release on github failed\nThis is probably because you forgot to add npm publish in your release command in between those commits.\nThe situation should solve itself automatically on the next commit you push on your master branch.\nLet us know if that works\n. semantic-release for now rely on packages published on npm to figure out the commit that was used to make the previous release. So without publishing to npm we can't determine which commit to analyze when determining the next release.\nWe have plans to allow this type of scenario, and possibly to handle other type of platform than npm. But we're not there yet... We have a plugin to determine the last version released based on git tags here https://github.com/semantic-release/last-release-git-tag but it requires some work.. This is because you are using the ESLint format for your commits, not the angular one.\nIf you want to use semantic-release with those type of commit, I would recommend to use those 2 plugin (sorry for the shameless plug) : sr-commit-analyzer and  sr-release-notes-generator.\nBasically you would do:\nbash\nnpm install --save-dev sr-commit-analyzer sr-release-notes-generator conventional-changelog-eslint\nthen in your package.json:\njson\n{\n  \"release\": {\n    \"analyzeCommits\": {\n      \"path\": \"sr-commit-analyzer\",\n      \"preset\": \"eslint\"\n    },\n   \"generateNotes\": {\n      \"path\": \"sr-release-notes-generator\",\n      \"preset\": \"eslint\"\n  }\n}\n. Awesome! Glad I can help!. You might try the following.\nFirst delete the 1.0.0 release on Github.\nThen install conventional-github-releaser and conventional-changelog-eslint globally:\nbash\nnpm install -g conventional-github-releaser conventional-changelog-eslint\nThen trigger the releases again (in draft mode to test first):\nbash\nconventional-github-releaser -p eslint -r 0 -d\nIt should re-create 1.0.0 as a draft release. If it looks ok then you can either delete it and recreate it with the same command without the -d or simply change the release on github directly to go from pre-release to normal release.\n. Ok, then it's even easier. From the root of your project:\nbash\nnpm install -g conventional-changelog-cli conventional-changelog-eslint\nconventional-changelog -p eslint -r 0\nThat will print the mardown changelog in your console for both 1.0.0 and 1.0.1. You can just copy 1.0.0 from the console and paste it in Github.. Hello @gr2m !\n\nThese are pretty massive changes, I\u2019ll need some time to review them. It\u2019s not that they aren\u2019t great, it\u2019s all about the fact that we take over responsibility and maintainership over for these, too. Would you be willing to join the maintainers team to help out with that?\n\nYes, I'd be really happy to join the maintainers team !\n\nplease keep in standard. It\u2019s not that we think the rules are better, it\u2019s the fact that we discussions about coding styles is one less discussion we can have :) I haven\u2019t use prettier yet but there is prettier-standard, would that be an option?\n\nPrettier is an amazing tool that I would highly recommend. It solves the endless discussions about formating and really improves productivity. Prettier can take care of the formatting rules (usually opinionated) and let eslint take care of the \"potential bug\" type of rules (usually not opinionated). The problem I see with standard is that it prevent to use some very useful rules from plugins like eslint-plugin-import, eslint-plugin-node, eslint-plugin-promise or eslint-plugin-ava. \nThat said, I have no problems switching to prettier-standard.\n\nI\u2019m very familiar with tap myself so I would prefer to keep that. I'm always happy to be convinced about how ava is better :) I care less about features, and more about simplicity and contributor friendliness. And if we introduce ava to the default plugins, we should use it in all semantic-release packages. Would you be willing to help with that transition?\n\nAva syntax is exactly the same as Tap so the change would be completely transparent and shouldn't impact contributors. Ava is a lot faster, produces more informative error output, supports all the last JS syntax out of the box (including async await) and has many other advantages.\nI'm totally willing to take care of the transition to Ava for each semantic-release repository (it should be really fast and pretty transparent). In addition I was under the impression that this transition was already underway.\n. Hello,\nI did a some research/attempt to use prettier-standard. It turns out it's a formatter but not a linter. So it doesn't provide a way to actually lint (in the sense of enforcing a format during the CI).\nSo here is the options that I see so far:\n1/ Use standard just the way it's used on other semantic-release repo\nPro:\n- Simple, we don't have to change anything on other repo to harmonize\nCon:\n- We lose the auto-formatting feature of prettier (prettier is more contributor friendly I think)\n- We enforce only the \"loose\" format of standard (in the sense that the same code can be formatted multiple way and still be valid for standard. For example standard does not enforce the line length. With prettier, 1 AST = 1 output).\n- We lose the ability to enforce \"potential bug\" type of rules that are not part of standard\n2/ Use eslint + eslint-config-standard + eslint-config-prettier\nPro:\n- Nicer and stricter prettier formatting (for example, enforce a max line length, adapt the format to fit in the max length) well integrated with every IDE, less controversial formatting as the \"opinionated\" choices of prettier are based on open source code analysis to determine the most common patterns used out there\n- Non formatting rules stays are the same as the one currently set on the others semantic-release repo\n- We use directly eslint with all the latest features rather than the standard wrapper\n- Ability to, someday if we choose to, to add more \"potential bug\" type of rules\nCon:\n- We need to add one config file (.eslintrc) on each repo that contains {extends: ['standard', 'prettier'], plugins: ['standard', 'prettier']}\nSolution 2 seems to be more contributor friendly to me (try prettier for a couple days, you won't go back, I promise :-)). But that's just my opinion.\nIf we choose option 2, I can make a PR on each repo. If we choose solution 1, I can live with it :-). Another thing I'd like to do is to update the code to es6 now that we require Node 8.\nThe prettier/eslint solution would allow to mostly automate that (open file and save would autofix) and we could enforce es6 usage (force using const/let instead of var, enforce using async/await or Promise if we choose to etc...). On the other hand standard allow to use es6 features but doesn't enforce it (you can still push code using var for example).. > Problems with syntax that could have been enforced with stronger eslint rules is not a problem we have\nWhat I meant is that after migrating everything to es6, if someone opens a PR with some code that use var for example, then you'll have to check visually in the diff to make sure to not introduce inconsistencies, and ask that person to use const/let, because standard won't tell you.. Awesome ! I'll try to start that ASAP, but most likely PR will show up only this Saturday/Sunday. Thanks !. commit-analyzer and release-notes-generator are now the default plugins in semantic-release@8.0.1 . @Apidcloud thanks for the contribution!\nWe now use the git tags as a fallback to determine the commit that was used to make the last release. And we expect the tag associated with the release to be named according npm recommendation (or at to the way npm version creates it).\nIn addition, it's not possible to have a version released multiple time on different tags.\nSo if you release 2.0.0 on the @next diest-tag you won't be able to release 2.0.0 on the latest dist-tag. You would have to run npm dist-tag add <pkg>@2.0.0 latest to add the latest dist-tag to version 2.0.0. See dist-tag.\nThat means that when you release 2.0.0 with the next dist-tag and create the git tag tags/v2.0.0 (as it's done in this PR, or maybe you intended to do next/v2.0.0 ?) at some point v2.0.0 will be made available on the latest dist-tag and the git tag won't make much sense anymore. It will just reflect that originally v2.0.0 was released as a beta, even though it's now available on latest.\nNot all the versions you release on next are meant to become available on latest as some might have bugs, but some are, and they will have a inconsistent tag name.\nWhat would be the objective of your proposal? Could you describe which scenario you'd like to achieve? Thanks !. > The first idea was to mirror what happens over npm when releasing under a custom tag (say alpha).\nI might be wrong but I think npm create a tag like v2.0.0 when you do npm version <patch|minor|major> and doesn't create a tag when doing npm publish --tag next.\nSo it seems that what happen with npm is that the git tag is not related in any way to the dist-tag. \n\nBut as the GitHub behaviour is rather different, the purpose of this PR is to create a 2nd tag (when defined) that points to the same release. Doesn't have to be next.\n\nIt didn't occur to me that the code was creating a second tag, but I checked fairly quickly :)\nWhat's the point of creating a second tag that points to the same version? Can you describe your workflow or how that would be useful ?. I understand. But as I was trying to explain in this comment the notion of git tag and npm dist-tag are quite different.\nA git tag mark a commit as a milestone in the history and is not meant to be changed.\nAn npm dist-tag is a distribution channel (Arguably the term dist-channel would be a lot less confusing). It works like the Chrome dist channel:\n- Version 2.0.0 is release (it's the only version 2.0.0 that will ever be released and the commit associated with 2.0.0 will never change)\n- This version is cutting edge, has many new features and might have bugs, so it's made available only on the distribution channel next (or dist-tag in npm world). Therefore only early adopters (aka adventurous users) will use it because they opt in by setting the dependency as 'my-package@next'.\n- If everything goes well and it turns out nobody report bugs on v2.0.0 for a month or so, we decide to also make it available to regular users by doing npm dist-tag add my-package@2.0.0 latest. Version 2.0.0 will now be distributed to everyone. But 2.0.0 is still the same, point to the same commit and the same git tag.\nIn that scenario there is no version 2.0.0-beta and version 2.0.0-stable. There is only 2.0.0 distributed to a subset of users for a month then distributed to everyone.\nSo it doesn't make much sense to have a git tag, meant to represent a milestone in the evolution of the package, to be named after it's temporary distribution channel.\nThe way github handle that is with pre-release. See creating-releases, especially:\n\nIf the release is unstable, select This is a pre-release to notify users that it's not ready for production.\n\nWhat would make more sense would be to create github release flagged as pre-release at first (when your package is distributed only on next channel/dist-tag).\nAnd when/if you are ready to make that release available to everyone you would do npm dist-tag add my-package@2.0.0 latest and go to the github release and uncheck the pre-release.\nIn terms of semantic-release you would configure your package.json like this:\njson\n \"publishConfig\": {\n    \"tag\": \"next\"\n },\n\"release\": {\n  \"pre-release\": true //New option we would have to add\n}\nEach time semantic-release would make a release it would be:\n- Available only on the npm next distribution channel\n- Flagged as pre-release on Github\nIf the version is never deemed good enough for general availability, it would stay like that. But if it is deemed good enough for general availability you can move it to the npm lastest distribution channel and remove the pre-release flag on github.\nDoes that make sense? Would that work for you? . Here is a good blog post on the subject: https://blog.greenkeeper.io/one-simple-trick-for-javascript-package-maintainers-to-avoid-breaking-their-user-s-software-and-to-6edf06dc5617 . In addition, it's worth noting that npm does support the prereleases but as mentioned here semantic-release doesn't recommends to use them and recommends to use dist-tags instead, fitting the scenario I explained above.. > Would the migration to latest dist channel be done manually though?\nI think so, because semantic-release wouldn't have a way to determine which release can be moved to the latest channel nor when to do so.\n\nAnd should this PR focus on creating a pre release in GitHub when the dist tag is next and the pre release is set to true?\n\nIf that fit your need and you would like to make a PR for this feature, yes. But maybe it would be better to start a new PR (referencing this on in the comment). Also it's probably better to do that independently of the release branch configured in \"release\": {\"branch\": \"branch-to-release-from\"}.\n\nIs this flag even needed? Shouldn\u2019t it happen by default as the tag is next?\n\nSome users might name their beta/unstable/preview/notProdReadyYet branch other than next. In addition some users might want to not use the Github pre-release feature at all independently of the distribution channel they choose. So it's probably better to keep it configurable.\n@gr2m do you have some feedback / concerns on this ?. > The only problem I see with this is that when you set the @latest dist-tag on npm to the new version, you should have to manually update the release on GitHub, too, as it no longer is a pre release.\nYes indeed. I'm fiddling with what we can do regarding the refactoring of the cli (the main semantic-release not the setup one) to have only one command (instead of pre > publish > post and the reliance on 1 exit code). Maybe we could add the possibility to run manually semantic-release --latest <version> that would do npm dist-tag add <package>@<version> latest and remove the pre-release flag on github at the same time.\n\nI\u2019m undecided. I\u2019d be okay flagging a GitHub release as \"pre-release\" if the dist tag is set to anything else than latest, but we should inform folks about that in the docs and tell them that they have to remove the flag once they set the @latest dist-tag on npm.\n\nWe also have to handle situations where folks publish on a legacy dist channel in order to do bug fixes on old versions. For example one can maintain a legacy version that retain node 4 compatibility, and release only bug fixes there. So the package users could reference <package>@legacy and receive only the latest bug fixes on the node 4 compatible legacy version.\nThat's probably a very rare situation though. But maybe if we do a Github pre-release by default on any publish that is not on latest dist-tag, we should have a way to override that behavior for some specific dist-tags.\n . > I\u2019m also thinking about the GitHub app that could do such things, but that\u2019s out of scope and would only work for GitHub. Love the idea to make it work with the CLI!\nI was thinking the same :) But that would require a user action (as the decision to make a release available on the latest channel can only be made by a human). Therefore a UI. Therefore quite some work (at least for someone with no design talent like me :-)). > Good point ... we could also add another option the package.json publishConfig ... or be smart about it and see if the released version is higher than the currently @latest, and only then set the GitHub release to be a pre-release?\nYes, but we are touching a complex subject. I've been thinking about that and hoe deal with or prevent situations of \"non consistent\" release across dist-tag.\nFor example if folks have a legacy, latest and next dist-tags.\nLast release on legacy is 1.1.0, last release on latest is 2.0.0, last release on next is 2.1.0.\nWhat if you make a breaking change commit on the legacy channel ? => Fails because 2.0.0 already exists.\nWhat if you make a breaking change commit on latest? Release 3.0.0, but the last release on latest is higher than last release on next. I think npm would handle that without any issue but seems weird. Or not. I'm not sure.\nI have a few ideas on how to handle those cases but the deeper I dig the more edges case I find and the more unlikely they get. My best shot so far would be to have the last-release-npm plugin to also report the versions already released in other tags or unpublished (as npm doesn't allow to publish a version on an unpublished one) and to skip those versions when we determine the next release version number. \nAnyway that's not really the subject of this PR. But maybe it's safer to keep it configurable, and try later to improve the algorithm to automatically determine the appropriate config?. > A custom tag other than latest+ pre-release flag mark the GitHub release as pre-release.\nDoes that sound ok?\nThe idea is to mark the github release as a pre-release if the dist-tag in publishConfig is not latest by default. But to add a possibility to override that with a config that would allow to define other branches on which we want a non pre-release release.\nMaybe an option with that can accept a string or an array of string that defines the branches the branches on which we don't do a non pre-release. If this config is not present, then we consider it's ['latest'] by default.\nKeep in mind that in order to accept the PR we would ask to have unit tests that cover all the cases introduced by the change. I refactored all the unit test recently so they should be easier to understand, but feel free to ask any questions :). I'd say in release as it's semantic-release specific and publishConfig is npm specific.. > Well you don\u2019t, this would be like an LTS version, you keep maintaining it, but you can\u2019t do breaking changes.\nYep. Enforcing this kind of things is not something we do currently. But we probably should. We would need to know the precedence of dist tags though (next > latest > legacy). The verifyRelease plugin might be a good candidate for that. And a GitHub app would allow us to handle the situation better by opening an issue or even better, setting the status of the PR that would introduce a non allowed breaking change. . My mistake, I said branch but I meant dist-tag. We are checking the dist-tag not the branch to determine if we do a github pre-release or not. So the default should be ['latest'].\nOk for no-pre-release, I can't find a better name.. Thanks so much ! I'll review shortly. I think it's not installed because of package-lock.json. semantic-release will exit right away if ran on node < 8. See semantic-release.js#L8.\nSo if you configure Travis to run multiple jobs on different node versions (ie. you want to test on node4, 6 and 8), semantic-release will run only for the job running node 8.\nSo the only constraint when you have multiple node version in your travis.yml is that at least one is 8.\nso in your package.json:\njson\n\"scripts\": {\n    \"semantic-release\": \"semantic-release pre && npm publish && semantic-release post\"\n}\nand in travis.yml\nyaml\nlanguage: node_js\nnode_js:\n  - 8\n  - 6\n  - 4\nafter_success:\n  - npm run semantic-release\nOnly the node 8 job will run semantic-release. It will also wait for the node 4 and 6 jobs to complete and will do the release only if all 3 jobs are successful.\n. semantic-release require node >8 for execution. You can still list it in devDependencies and run npm install on node <8 without any problem?\nDo you have a link to your build that fail on Travis ? Maybe I can look at the logs and help you.. This is due to a specificity of yarn that check the engines field of dependencies while npm doesn't.\nAccording to the package.json specification on npm doc, the engines property in package.json is only advisory and create a warning only for dependencies not devDependencies. See package.json#engines.\nIt seems that yarn works differently and fails the install. I'm not really sure which of the yarn or the npm behavior is the right one here...\nYou have two options here.\n1/ Use npm in your CI build by removing yarn.lock or by specifying in travis.yml:\nyaml\ninstall:\n  - npm install\n2/ Pass the option --ignore-engines to yarn:\nyaml\ninstall:\n  - yarn install --ignore-engines\nWe should add this in the semantic-release documentation.. > What if semantic-release didn't require node 8 in package.json (i.e. it would install but not run)?\nThe intention in semantic-release package.json is not to require Node 8, but to inform that it's made to run on Node 8. This is what the engines property does according to npm docs. But not according to yarn apparently.\nAs a potential fix we could:\n- Support Node > 4 and provide transpiled files (but that would be going backward)\n- Recommended in the documentation to use --ignore-engines with yarn\n- Remove the engines filed in package.json (as technically semantic-release can run on any version of node, it will just exit right away if node < 8).. Thinking about that I think we should set engines to >= 4 in package.json as semantic-release can and will run on Node 4 (it will just skip everything and do nothing other than a log message but still runs).\nWhat do you think @gr2m ?. The Build stage feature in Travis is awesome and we'll write more documentation regarding how to use it.\nAnd yes we could recommend to not include semantic-release in the devDependencies and run npm install -g semantic-release && semantic-release pre && npm publish && semantic-release post. But not quite now. Because semantic-release, when installed globally, won't be able to load custom plugins as they are loaded relatively to process.cwd() .\nAs explained here semantic-release can be executed on node < 8. It report an error instead of an informational log due to current limitation is the way handle the different release steps (pre, publish, post).. I'm investigating the reason of the error.. Yes there is log on the main semantic-release but not on the plugin themselves.\nFor example we don't log details about how the build leader is determined. And we have a few issues on the tracker that could benefit from that.\ndebug is great but it's really for debug logs (like you don't want to log that systematically).\nIn most cases we have bug report with a problem that already happen (someone linking the travis build log for example). So it would be helpful to log systematically.\nnpmlog seems ok and do the job. But we can change to something else.\nMy idea was for semantic-release to create the logger, set the loglevel and pass it to each plugin. So each plugin can easily log stuff without having to import a logger and dealing with all that.\nRegarding the log level, it seems a bit confusing to me to use npm loglevel param in .npmrc (I just learn it exists actually).\nMaybe we can do info by default and debug if the --debug arg is passed to semantic-release.\nAs we run primarily on CI, I don't think having \"too much detailed\" logs is a problem as it doesn't impact the user (contrary to a cli tool you use on your terminal).\nI'll continue to work on the general \"refreshing\" of the repo and I'll make a PR for the logging (that would be easier to show what I mean and discuss it).\n. > A problem I run into with npmlog is that if I set the loglevel to verbose or silly, it also affects the other npm commands like npm install and npm test. The log becomes huge and travis eventually cuts it off. Setting DEBUG=semantic-release or DEBUG=semantic-release:plugin-name would only affect semantic-release.\nSounds nasty. Let's avoid npmlog then.\n\nWe could pass in a .log method to the plugins that is require('debug')('semantic-release:plugin-name')\nYes this is exactly what I was thinking.\n\nThe problem with debug is that it's on or off (no error, info, debug level). It monitors execution time and seems really dev oriented.\nI think we need at least:\n- Error: token missing, npm registry inaccessible etc\n- info: build leader determination, commit analyze and other info users can need to understand what's going\n- debug: Very specific things mostly for us to solve issues\nlog4js-node seems widely used. But didn't search extensively (it seems there is a lot of logging libraries).\nconsole.log, console.error, console.debug is a good option as well.\nWe can also add chalk which allow to make pretty sweet and readable logs. I like colors :)\n. I was thinking something along those lines:\n``js\n// src/utli/logger.js\nfunction getLogger(namespace){\n  return {\n    log() {\n      console.log(${chalk.magenta(namespace)} ${chalk.white(Array.prototype.slice.call(arguments).join())});\n    },\n    error() {\n      console.error(${chalk.magenta(namespace)} ${chalk.red(Array.prototype.slice.call(arguments).join())}`);\n    }\n  }\n}\n// in semantic-release\nconst logger = getLogger('condition-travis');\n// Then pass logger to condition-travis plugin\nlogger.log('This is an informative message');\nlogger.error('Something wrong, please do something about it');\n```\nThe output look like that:\n\n\nNo loglevel to deal with.\ninfo for informative logs so the user know what semantic-release is doing (like \"we are going to release make a patch release\", \"Releasing v1.0.1\", etc..).\nerror so user know something went wrong and he has to fix something (like \"Please set NPM_TOKEN. You can find more information here: \").\ninfo and error are pretty explicit, so it avoid the situation of contributors wondering what level to use.\nVery easy to mock for unit test to check that we log appropriately.\n\nThen we can use debug for actual debug log (ie for developers looking to fix a bug), that will be activated only if we pass the --debug arg or set the DEBUG environment variable. debug can be used for stuff like (\"executing function XXX, going in code branch YYY\").\nNo need to pass the debug instance to the plugin, as the DEBUG environment variable is set in semantic-release. So the plugin can import debug and use it directly.\nLooking around on different popular projects it seems this approach (console for log and error + debug for dev debugging) is quite common.. console.error logs on stderr while console.log logs on stdout.\nconsole.info is an alias of console.log (and probably pretty much every variant).\nNot sure anymore make a distinction between stdout and stderr though.... This was due to the release being published on npm during previous build, but the github release not being published due to a bug fixed since then.\nSo the There are no relevant changes message was correct.. Supporting a new CI provider is usually done via a verifyCondition plugin similar to condition-travis.\nIn order to be able to support a CI provider the plugin need to verify:\n- That semantic-release is running on CI (via environment variable for example)\n- If the current run is a PR\n- The git branch on which the build is currently running\n- The current job run last in the build (if you build on different OS or Node version for example) and all the other jobs are successful\nThe last one is the most tricky, and it's very important as we want to make a new release only if all the test are successful, on each OS it's tested on and each version of Node.\nIdeally the CI provider should also offer a Github integration that update the PR and commit status as semantic-release might rely on that in the future to detect if all build passed.\nI'm not familiar with Visual Studio Team Services and I'm not sure if it's widly use, so it probably won't be a priority for us to support it.\nThat said you are more than welcome to create a plugin :)\n. A plugin for Visual Studio Team Services shouldn't be required anymore as Semantic-release works on any CI since #578.\nIf the CI runs multiple jobs (to test multiple node version or different OSs) within a build it has to guarantee that semantic-release is executed only after all jobs are successful. Quickly going through the Visual Studio Team Services doc it seems that running multiple jobs within a build is not supported anyway.\nFeel free to re-open if there is something to support Visual Studio Team Services. Thanks for the feedback @hbetts!\nThe goal of engines is not that clear... According to npm documentation:\n\nIf you specify an \"engines\" field, then npm will require that \"node\" be somewhere on that list. If \"engines\" is omitted, then npm will just assume that it works on node.\n\nBut it seems that npm actually doesn't care much and do not \"require\" anything.\nStill in the same documentation:\n\nUnless the user has set the engine-strict config flag, this field is advisory only will produce warnings when your package is installed as a dependency.\n\nI didn't check but I don't think it produces warnings.\nAnd on the next line:\n\nengineStrict\nThis feature was removed in npm 3.0.0\n\nSo the engines config is:\n- For npm: an indication on which node version can run the package\n- For yarn: a constraint on which node version the package can be installed\nA lot of confusion come from the fact that semantic-release throw errors for situation that are actually expected and not really errors. This is because we run semantic-release pre && npm publish && semantic-release post and the only way for semantic-release pre to prevent npm publish && semantic-release post to run is to exit the process with 1 which make npm to log an error.\nWe are currently working on a solution that would allow us to run only one command and would avoid to rely on this mechanism of throwing error to interrupt the command chain. That's not necessarily as easy as it sounds so it might takes some time to be done.\nSo in conclusion when you run semantic-release on node < 8 it throws an error but it's actually meant to be an informative message to the user. And semantic-release is designed so it can run on node < 8, the same way it can run Travis job that are not the build leader or on branches that are not master. In all these situations it will not trigger a release but it can and should be run on these situations, precisely to verify those conditions.\nI think the best approach is:\n- Go with \"engines\": {\"node\": \">=4\"} right away to avoid pain for yarn users (and avoid them to turn away from semantic-release)\n- Continue to work on a better solution to avoid throwing those \"expected\" errors to interrupt the command chain, and avoid the confusion regarding those error that are actually not errors\n. I saw this problem happening a few times on Travis (independently of semantic-release). It seems to be related to the way the npm cache is handled.\nIt should be solve if you remove the purge the cache on the Travis UI and restart the build.\nI would recommend to remove the cache directive in your travis.yml.\nIn addition you can add a retry on the install step like this:\nyml\ninstall:\n  - travis_retry npm install\n. This issue doesn't seem to be related to semantic-release directly, but to npm/Travis/cache good practice.\nFeel free to re-open you want to propose/request a change in semantic-release. > To be fair, if we say \"just use npx\" it\u2019s basically the same problem. But it feels like less overhead for us than introducing babel. But We should add it to our CI tests, because at least for me, it didn\u2019t work: #414 (comment)\n\"use npx\" doesn't works. npx doesn't transpile or simulate node 8. This is why I made this proposal actually :) If npx was making node 8 packages works on node 4 that would be a no brainer :)\nthis is why you had this issue mentioned in #404\nFrom above \n\nThe workaround proposed here and there is to use npx but that doesn't solve the issue as npx is just a tool to run locally installed packages as global ones (basically allow to run npm my-local-package rather than npm node_modules/.bin/my-local-package). That doesn't allow to run Node 8 only package on an older version of node.\nSo this should be removed.\n. Ohhhhhh....my bad....I misunderstood the trick completely. npx -p node@8 actually install node 8 as an npm package and runs it. I totally missed that.\n\nSo I don't understand the problem in #414-comment then...\nI searched for more info in npx and I didn't find any example mentioning that you can install node like that. Would you mind sharing the docs mentioning that ?. \ud83d\udc4d If we manage to make it work that would be awesome.\nMaybe we'll have to remove the test on process.version in the code ? But that ok I guess.. In the case of npx -p node@8 ./funk.js I wonder if it runs it on node 8 with the wrong process.version or it runs in node 4.\nIf it's only the process.version, maybe we can just remove the test in our code.\nMaybe a better workaround is to make semantic-release to work as a global package.\nI think we almost there, we just need to revisit the way we load custom plugins when running as global.\n. Shouldn't the command be npx -p node@8 node ./funk.js instead ?. Ideally we should be able to handle all the steps in one command (something that would do pre, publish and post).\nThen we could do npx -p node@8 semantic-release.. We'll have to think about how to do that. But in the meantime I think we can close this issue once we have modified the doc :). So it seems the npx trick is a bit shaky...Also npxing Node 8 to run a command is not really documented...\nOnce #524 get merged we could recommend to run semantic-release globally.\nThat would allow to go back to {\"engines\" : \"\"node\": \">=8\"} everywhere. The >=4 trick was implemented because yarn refused to install incompatible version.\nIf we recommend to install globally then yarn users could do something like this:\nafter_success:\n  - yarn global add semantic-release && semantic-release\nThis way if the Node version is <8 the installation will fail but not stop the build as the failure occur in after_success. Or maybe better:\nafter_success:\n  - yarn global add semantic-release && semantic-release || true\nOr:\nif [[ `node -v | egrep -o '[0-9|\\.]+'` > 8* ]]; then yarn global add semantic-release -g && semantic-release; fi\nFor npm <5 users:\nafter_success:\n  - npm install semantic-release -g && semantic-release\nFor npm 5 users:\nafter_success:\n  - npx semantic-release\n. Should be good after #593\nWe just need to set the engines.node back to >=8. All orga packages have been update to require Node >=8.3. It seems to be a duplicate of https://github.com/semantic-release/semantic-release/issues/444\nCan you try to apply one the solutions proposed there ?. Thanks for the details information. It's really helpful !\nsemantic-release runs 3 steps: pre, npm config and post. This is 3 independent shell commands.\nWhen pre determines there is no release to do we need to make sure npm publish and post are not going to be executed.\nThe only way to do is to return an exit code of 1, which is an error code, that prevent the next command after the && to be executed.\nSo when there is no release to do (because you have only chore or docs commits) we return an error code...which expected and should be ignored.\nThis is why we require to run semantic-release in a CI build step that doesn't fail the build when returning 1. In Travis this the after_sucess step. When you reach this step in the build process, Travis does not care anymore if there is errors, the build will be successful.\nSo you should run semantic-release in a similar step in Circle CI. In Circle CI 1.0.0 this step was deployment. I'm not familiar with version 2.0.0 but it seems the when flag might allow to do that.\nSee https://discuss.circleci.com/t/run-all-test-steps-even-if-one-fails/11229 and https://circleci.com/docs/2.0/configuration-reference/#the-when-attribute\nWe are working on a way to avoid this type of limitation by running only 1 shell command instead of 3. So it's going to be simpler and less confusing in the future. Stay tuned!. Actually, thinking about there is an even simpler solution.\nIn your package.json:\njson\n\"scripts\": {\n  \"semantic-release\": \"semantic-release pre && npm publish && semantic-release post\",\n}\nIn your circle CI config:\n```yaml\n- run: semantic-release || true\n````\nThis way you can do the release at whichever step of the build that you prefer and it won't fail no matter if there is a release to do or not.\nNot that it's import to run semantic-release pre && npm publish && semantic-release post as one shell command with the && so when semantic-release pre return 1 it will prevent npm publish and semantic-release post to run.\nLet us know if that solve your issue.\n. Sure, let's do that. But on the other hand, that should be solved when we move to a unique command that doesn't rely exit code 1 :). Since several releases semantic-release doesn't returns with 1 when no release has to be done.\nJust upgrade to a recent version and remove the || true. > do you know what\u2019s up with codecov?\nYes, it's because codecov has nothing to compare against to figure out if the coverage reduced as it has never ran on caribou branch.\nAll other PR after this one will work as expected.\nBut let me check if I can put a config to not report statuses when there is no comparison point.. So there is a way to prevent codecov to fail on the first PR that use it: https://github.com/codecov/support/issues/173#issuecomment-216067683\nBut apparently it can also create situation in which Codecov would report success when coverage may be faulty.\nAs this would happen only on the first PR that configure Codecov, it's probably better to keep configured the way it is now.. I'm fine with it as is. I'm gonna wait a few hours while I work on the following PR locally in case anyone as additional comments.\n@luftywiranda13 Thanks for the review \ud83d\udc4d \nIf you have any more comments/review, feel free to add them :). Can you clarify which error you are referring to ?\nIn the Travis logs of the build you linked I see the release of version 2.5.0 happened without errors and the version is on npm and in the Github release.. Thanks !\nI'll close as duplicate of #337 then.\nFeel free to re-open if it's not the case.. That's expected with the current version of the code.\nIt's because you have a gitHead in the metadata of the last release's package.json. So I use that and I don't check the git tags.\nI use the git tag as a fallback only if there is no gitHead in the last release's package.json.\nHere we have a situation in which:\n- package.json from npm version 2.0.3 reference commit A\n- commit A is not in the history of the branch anymore\n- The v2.0.3 tag reference commit B\n- Commit B is in the branch history\nSo we have 2 version markers (git tag and npm last release package.json) that contradict each other. It's probably a case that is quite rare and that is an indicator of a bigger problem in the repo.\nSo I though in this situation it's better to bail out with the ENOTINHISTORY error and let the user decide if they want to make a release manually.\nIn the end it's a question of what to trust more when we have contradicting infos between a git tag and npm metadata. As the creation of the gitHead is done automatically by npm publish and a tag can be more easily created by mistake, I thought we should give priority to npm metadata.\nThat said I can change the code to handle this situation. Do you see a scenario that will result in this situation ? It would imply to make a release for a given commit, remove the commit from the history, make a new commit and tag a version on this commit. It seems very wrong to change a commit that happened before a release.. > My main scenario would be a simpler recovery from the ENOTINHISTORY error. Right now I need to do a manual release. With that change, I could change an existing git tag to point to the correct git hash that is in the master branch and then restart the build to recover.\nI didn't think about that! It's indeed a great idea for a recovery scenario, that is much convenient than doing a manual release.\nSo in the ENOTINHISTORY message instead of suggesting to do a manual release we could suggest to tag the commit that correspond to the last release and restart the build. I'd have to change the algorithm a bit to check the tag in the case a gitHead is in the npm metadata but not in the branch history.\n\nI get your point though, my use case is out of scope of this pull request, if you agree that it\u2019s a good idea, we can still make a follow up PR for that\n\nYep. Let's take a couple days to think about it and be sure we won't create side issues in some scenario. I don't see any one so far, but it's a complex problem...\n\nSo from my side, I\u2019d suggest to merge & release it, notify folks in #411 and ask them to install the newest version by updating their package.json files and comment on this PR if they run into any trouble, before setting the new version to latest?\n\nI'll do that.\n. apm is not currently supported unfortunately. But that's something we'll consider in the future. I cannot tell when though.... Once #515 will be merged and released, it will be possible to customize the release process via plugins.\nWe would need to create an apm plugin similar to https://github.com/semantic-release/npm.\nThe plugin would have to:\n- Verify the authentication to the apm registry\n- Retrieve the last version published (for a given dist-tag if apm support dist-tags)\n- Publish a given version\nWould you know by any change where to find documentation about how to do that with apm?\nWould you be interested in developing such plugin?. Looks good. Let me know if you need any help!. Work in progress in semantic-release/apm-config#1.. @semantic-release/apm-config has been release!\n@Arcanemagus that would be awesome if Atom Linter would use Semantic-release! Do not hesitate to ping me if you have any question or need help with the config!\n  . Great job! Especially on the tests !\nI added just a few change requests for minor stuff.\nThe last step would be to add the new option with a short description here\nIf you could squash your commits into 1 that would be awesome. But I can do it on my side I think.. > All there's left is to check whether the module is called correctly within post. How should I do that? I wonder if I can do it with spies. Any suggestions?\nIt's done with the tests you modified and the one you added on post.test.js. \ud83d\udc4d . Just a small change in terms of wording. Other than everything looks good ! \ud83d\udc4d \nI'll give it a try on a test repo to be sure and I'll let you know.. Alright, everything looks good to me: https://github.com/pvdlg/test-sr/releases\nThanks for the great work !. There is some edge cases scenario that doesn't work yet, but it's independent of this PR.\nFor example:\n\nPublish 1.0.0 on next\nPublish 1.1.0 on next\nMake 1.0.0 available on latest\nPublish a minor version on latest => semantic-release determines the new version should be 1.1.0 => Fails as the version already exists\n\nThat is a bigger issue we have to solve in semantic-release. I'm not sure yet what the best solution is.\nWe can either skip existing version and in step 4 release a 1.1.1 instead of 1.1.0. That avoid the error but create a situation in which the last release on latest is higher than the last version on next. It's not necessarily a problem (in the technical sense of the term) but it probably reveal a mistake in the way the release flow was handled.\nA second solution would be to determine what is the last version in a more complex way:\n- Use last version on the dist-tag if increasing this version number doesn't create a version higher or equal than a version on a higher dist-tag\n- If it does, use the last version of the higher dist-tag that create a conflict\nSo in this situation on step 4 we would determine that the last release is 1.0.0, increase it to 1.1.0, see that it's higher or equal to the last version on next, therefore consider the last version on next as the last release and increase it to obtain 1.2.0. But that can creates a lot of issues if for example the release 1.1.0 has been done from a different branch and contains code not yet merge in the current branch. We would have 1.2.0 that contains less features than 1.1.0.\nA third solution is to prevent a release that would end with a lower dist-tag having a higher last release than a higher dist-tag. So in the case of step 4 we would not do a release at all and display a message like \"Doing this release would make the last version on 'latest' higher than the last version on 'next'.\"\nThat would work if we accept to limit the type of changes we can make on each dist-tags. For example in a situation with last release on latest being 1.0.0, and last release on next being 2.0.0, we would accept only patch and minor releases on latest.\nWe don't enforce anything regarding those scenario so far and we rely on the users to make appropriate type of changes in such configuration.\n. > Maybe we could create a GitHub app for that which also gets setup when using semantic-release-cli setup?\nThat sounds a really good idea !. I completely missed your previous message...sorry. The Github release has been moved to https://github.com/semantic-release/github.\nThe Github prerelease is something we want to support, but it's probably going to be done within a larger feature to handle multiple repo and dist-channel. I'm not 100% sure how everything is going to work though. I've been working on a proposal for some weeks now and did a lot of tests to see what's possible. I think I should be able to write a proposal for the implementation in a couple weeks.\nThen we can discuss and see how and where to implement this feature. Stay tuned!\n. To be implemented in the github plugin as part of #563. Keeping open as some code might reused in the github plugin. I'm closing as the code changed so much since this PR was opened.\nThe feature will be implemented via #563.. No we don't have an open issue regarding that, but it was mentioned in several conversation that it would be nice to be able to run semantic-release globally without having to depend on it in the package.json\nWhat this change allow to do is to have in package.json:\njson\n\"release\": {\n  \"analyzeCommits\": \"my-custom-analyzer\"\n}\nand no dependencies to semantic-release or my-custom-analyzer in devDependencies and be able to run:\nbash\nnpm install -g semantic-release my-custom-analyzer\nsemantic-release pre && npm publish && semantic-release post\nOne possible benefit would be to not have the problem with yarn that refuses to install semantic-release as a devDependency on version of Node < 8 and would avoid to have to do the trick with \"engines\": {\"node\": \"4\"}.\nAnother possible advantage is the situation in which a release is triggered externally (for example when a Github app would detect via commit status that all CI pass successfully). You can trigger a job that install semantic-release globally and run. So for the user no need to include and manage semantic-release and custom plugins as a devDependency.\nIn conclusion, this is useful only when we run semantic-release globally and it's something that we don't officially recommend in the doc for now. But it might be useful in the future.\n. Ok, works for me. Irrelevant due to #524. It seems you have discrepancy between between your git tags and npm releases.\nThe last git tag in your repo is 3.8.4 but the last npm release is 3.8.2.\nSo you have two options:\n1. Delete the git tags 3.8.3 and 3.8.4 and re-run a Travis job. That would trigger a new release using 3.8.2 as the last one\n2. Do a manual release from the git tag 3.8.4 (checkout tag 3.8.4, set your package.json version to 3.8.4 and run npm publish)\n1 would work only if you use semantic-release@8.1.2 which is the latest release currently available only on the next dist-tag.. @meodai did that solve your issue? . No you are not the only one :)\nThere is quite some confusion on how semantic-release works internally and how to recover from situation like that.\n458 should improve the situation when it lands, as it would offer a recovery scenario based on tags and the error logged by semantic-release would indicate the steps to follow.\nWe also need to work on the documentation.\nAny contribution is well appreciated !\n. Currently semantic-release doesn't support a scenario without npm by default. This is something we want to support in the future.\nIf you provide the link of a CI job where you experience the problem I can look at it and try to help.. I open this issue #484 to propose a solution that would allow to use semantic-release without npm and with repositories other than Github.\nWould love to have your feedback on this proposal.. @felixfbecker Good catch! Would you mind opening a bug in the travis-deploy-once repo? . > Are there any other factors that semantic release take into account when calculating the next version that I need to alter?\nCurrently semantic-release, get the last version published on npm, look for the commit used to make this release and search for it in the git history.\nIf there is commit referenced in the gitHead property of the last release found on npm then we search for a tag.\n458 will change that a bit, allowing to search for a tag even if there is a gitHead in the npm last release when it;s not found in the git history.\n\nI Tried adding the latest version as a tag to my last commit but this didn't do any good.\nThat should work when #458 lands.\n\nIn the meantime the best you can do is a manual release:\n- locally change the version manually in your package.json\n- Run npm publish\n- Create a git tag and push it to origin\n- Create the Github release. > I'll give this a shoot.\nLet us know how it goes!. I think what happen is that after the name change,semantic-release ran and didn't found the new package on npm, then it concluded there is no releases yet. And in that case the version to release is 1.0.0. That's the expected behavior.\nIf you change your package name you'd have to manually release the last version with the new name as semantic-release has no way to know there was a previous release with a different name.\n. Could you provide a link to the Travis job in which semantic-release fails to publish a new version ? You screenshot doesn't show the semantic-release logs.. Looking at the logs, in particular this line it seems it's similar to #444\nYou should remove the cache in Travis or you can find alternative solution in #444 . This is because the commit used to do the last release is not present in your develop branch, or is too far in history (by default Travis pull only the last 50 commits of your branch).\nPlease make sure the develop branch contains the commit used for the last release. In order to solve the problem of Travis pulling only the last 50 commits, you can use semantic-release@8.2.0 that will handle this situation. It's currently released on the the next dist-tag so you would have to specify the version ^8.2.0 in your package.json.\n. Is you develop branch contains all the commit from master ? How did you created it ?\nDid you try with semantic-release version 8.2.0 ?. > I'm yet to try 8.2.0, but i'll do that now.\nOk let us know how it goes!. Both the commit parsing and the release-note generation is handled by https://github.com/conventional-changelog/conventional-changelog which handle the merge commits: mergepattern.\nThe way it should work is that the commits referenced by the merge will be analyzed and used for the release note.\nSo for example if your Merge commit message is:\nMerge Pull Request #xxx from <repo>/<branch>\nfix: This is a fix\nfeat: This is a feature\nThen semantic-release would analyze and include in the release note 2 commits:\n fix: This is a fix\n feat: This is a feature\nAs mentioned by @gr2m it would be helpful to have more information. Especially, what do you mean by \"if I create a merge commit with a Commitizen commit message\". My understanding is that merge commits are created automatically when you merge a branch.. I'm not 100% sure how Github handle Merge commit, but it seems it includes the original message from the commits you are merging in addition of what you enter in the commit description during the merge. So in that case semantic-release will use the original commit message, which is the expected behavior.\nCould you share the repo url you are using? So we can verify exactly the commit message generated by Github in your case?\n. semantic-release analyze commit on the build branch (master in your case). The commit are retrieved with git log.\nLooking at the commit history of the master branch I see the commit https://github.com/xAPI-vle/moodle-logstore_xapi/commit/3b599d4c27f195db4fbf4972105291d7af1ef79f but I don't see the commits that were part of the PR xAPI-vle/moodle-logstore_xapi#139\nSo semantic-release behave as expected:\n- It finds a fix commit and determine a patch release has to be done\n- Publish the version 2.1.5\n- Do a Github release for 2.1.5 including the fix commit\nsemantic-release has no way to know that https://github.com/xAPI-vle/moodle-logstore_xapi/commit/3b599d4c27f195db4fbf4972105291d7af1ef79f is a merge commit of several other commits.\nIt seems that what you do, when you merge the PR, erase the other commits references.\nIn effect, according to the commit history of your repo, it's like if you were doing a squash.\nI'm not extremely knowledgeable on the specificities of Github when doing a \"Merge pull request\" and modifying the message. But I can tell you that if you do a \"Merge pull request\" without editing the message, Github create a \"Merge commit\" that is recognized by semantic-release. In such case semantic-release will consider all the commits that are part of the merge commit.\nIf you want to preserve the commits messages from your contributors, I would advise to:\n- Inform contributors that you are using a commit convention (for example angular)\n- Add some tooling to enforce the commit format (for example https://github.com/marionebl/commitlint or https://gitcop.com/)\n- Merge your PR with \"Merge pull request\" or \"Rebase and merge\"\n. > I don't really understand why it creates the correct release using that commit message in xAPI-vle/moodle-logstore_xapi@3b599d4, but doesn't use the commit message for the release notes, that certainly wasn't what I had expected.\nThe commit https://github.com/xAPI-vle/moodle-logstore_xapi/commit/3b599d4, with commit message fix(AssignmentGraded): Corrects actor format. (#139 - thanks @Nicosoft) is in the release note for 2.1.5. \nI don't understand what you mean by \"but doesn't use the commit message for the release notes\" ?\n\nThat's not correct. The commits from the PR are in the master branch commit history.\n\nYes. My bad, I didn't went far enough in the master history.\nWhen you merge the PR xAPI-vle/moodle-logstore_xapi#139 and modify the message it result in pushing to master the commits:\n- Update AssignmentGraded.php => Not recognized by semantic-release as a valid commit message => ignored by semantic-release\n- Function change => Not recognized by semantic-release as a valid commit message => ignored by semantic-release\n- fix(AssignmentGraded): Corrects actor format. (#139 - thanks @Nicosoft) => Contains no reference to the other commits. => semantic-release has no way to know it's a merge of Update AssignmentGraded.php and Function change => semantic-release analyze it as a regular commit\n\nI think forcing people to use a commit convention in order to make a PR would create an unnecessary barrier for contributors to climb, some of which in our case will be using Github for the first time. Most of the pull requests would probably have to be resubmitted with correct commit messages.\n\nThere is tools like https://github.com/commitizen/cz-cli that can help with that\n\nI think the only solution here, would be pushing an empty commit with the correct format into the pull request which isn't ideal.\n\nIf you would do so, only this empty commit would be analyzed by semantic-release and included in the release note.\nsemantic-release can only use commits it can analyze. All the commits that are not formatted in a way that semantic-release can parse will be ignored. I don't see a way to workaround that. But if you have a suggestion we will certainly consider it!\nWhat you can try is to format your merge commit like this:\nfix(AssignmentGraded): Corrects actor format. (#139 - thanks @Nicosoft)\n- Update AssignmentGraded.php (link to commit)\n- Function change (link to commit)\nOnly fix(AssignmentGraded): Corrects actor format. (#139 - thanks @Nicosoft) will be included in the release note but the commit will reference to the other commits.\n. I think I finally figured it out!\nsemantic-release uses conventional-changelog to generate the changelog. And by default conventional-changelog pass the --no-merges options to the git log command used to retrieve the commits. See conventional-changelog-core/lib/merge-config.js#L228\nWhile semantic-release doesn't use --no-merges when it retrieve the commit for analysis.\nThe --no-merge option according to git documentation: Do not print commits with more than one parent. This is exactly the same as --max-parents=1.\nThe commit fix(AssignmentGraded): Corrects actor format. (#139 - thanks @Nicosoft) has multiple parents, so it's ignored by conventional-changelog and not present in the changelog.\nWe plan to generate the changelog with the commits retrieved by semantic-release during the analysis phase. See #460.\nSo when #460 is resolved the commit analysis and the changelog generation should be consistent.\nI think the best solution for us would be to not use --no-merge at all. We would keep the way we retrieve commits as it is now, and use those commits to generate the changelog as explained in #460.\nThis way fix(AssignmentGraded): Corrects actor format. (#139 - thanks @Nicosoft) would be included in the change log. But Update AssignmentGraded.php and Function change would still be completely ignored.. Sorry I missed the question the first time.\nI checked and there is no workaround at that moment, as we don't let this option to be configured at the moment.\nI'm working on the fix for #460.\n. This issue will be completely solve only after we merge https://github.com/semantic-release/release-notes-generator/pull/34 and update the release-notes-generator version in semantic-release.. You can configure that as explain in commit-analyzer#release-rules.. That's very strange indeed. Could you share the link to the CircleCi job with the problem ?. Ok.\nCan you clarify what do you mean by \"I can't even get the \"command not found\" error when I type in random things.\" ?. semantic-release is meant to be run with the root of your repository as the current working directory.\nHere you are running it from <repo_root>/node_modules/.bin/.\nsemantic-release is meant to be use as follow:\nIn package.json:\njson\n\"scripts\": {\n  \"semantic-release\": \"semantic-release pre && npm publish && semantic-release post\"\n}\nAnd your CI should run the shell script npm run semantic-release after the test are passed.\n. It seems the command return 1, but because it's ran with yarn it doesn't log anything. This is because for now we are using npmlog.\nCan you try to run npm run semantic-release instead of yarn run semantic-release ?. @kumarharsh can you try to remove npm prune ?. @DeividasK we have just release v9.0.0 with a lot of changes, including more logs.\nIt's released on the next dist-tag so you would have to specify \"semantic-release\": \"^9.0.0\" in your package.json.\nWith this new version, your npm script as to be semantic-release instead of semantic-release pre && npm publish && semantic-release post.\nCould try with this version and let us know if that solve the issue? And if not could you provide the logs?. Thanks for the feedback!. Could change your commit to confirm with Angular convention ?\nIn this case: fix: Log error messages on reject. semantic-release is meant to run on a CI environment. Each time the CI run it download the a fresh repo.\nCan you clarify in which scenario this problem happen? Why would you run npm install on the CI after the build is done and the release happened ?. > I guess the use case I was describing with npm install is only an issue if you push the version changes from CI, then pull locally.\nThe version change in package.json is not meant to be pushed on git. On the git repo it should stay 0.0.0-dev.\n\nNevertheless, shouldn't the npm published package-lock.json match the published package version when the package is installed into a dependent?\n\nNo because the package-lock.json is not part of the package published on npm.. We should also merge #457 before this one, to avoid asking #457 author to do a big rebase/merge conflict. It would be easier to handle the merge here.. The code ready for review.\nI have the WIP in the title as I still have to add some JSdoc and update the README to reflect the changes.\n. > do you have a preferred library for API docs based on JSDoc comments? I'm looking for one to update https://octokit.github.io/node-github/, too :)\nI used jsdoc-to-markdown on another project that generate markdown file, then generate the site with Jekyll: https://pvdlg.github.io/uprogress/getting-started\nThere is also the default JSdoc feature: http://usejsdoc.org/about-getting-started.html#generating-a-website but I never used it.\nreadme.io might also be a solution and it has and open source license: https://readme.readme.io/v2.0/docs/open-source. Not sure if it can generate doc based on JSDoc, but it might be able to use the markdown files generated by jsdoc-to-markdown.\nI'm not sure it makes a lot senses for semantic-release to publish a website with the doc generated from JSDoc as most of the functions are private. The only exposed function is index.js (the one in this PR, not the old one.)\n. > sorry I didn't get to review the PR today, but can't wait to get this landed :)\nNo problem. I have to finish the doc anyway :) Would you mind looking at #457 before?. The PR should be fully ready for review now.\nI didn't add JSDoc everywhere yet. That's quite a big task, so it will come in a future PR, probably after the biggest changes planned are completed.. Having 3 different command was forcing to return a 1 exit code in order to prevent the next command to run. For example if semantic-release pre determines no release is necessary, the only to prevent npm publish to be executed was to return and error.\nIn addition of being counter intuitive and giving the impression that an error happened, it forced us to run semantic-release only on a CI step that wouldn't fail the build in case of an error.\nThis was creating a lot of confusion and difficult issues to troubleshoot.\nIn addition to that it's was not really possible to use semantic-release without npm anyway for several reason:\n- We rely on the npm registry to determine the last version released\n- We were verifying at the very beginning of semantic-release pre taht a NPM token is set\nHere is a proposal to support any type of release: #484\nOnce it's implemented you would be able to configure semantic-release as follow to skip npm publish:\njson\n\"release\": {\n \"publish: [\"github-release\"]\"\n}\nAs mentioned in #484 we would also provide a plugin or another mechanist that would allow to set a command line to run, allow to do any type of release that can be done via command line.\n. > That would be great, if the plugin just had an option to specify an arbitrary command to run in package.json \ud83d\udc4d\nAbsolutely. Implementing a solution that let users bypass npm publish or run another command instead is the next priority. . If I'm not mistaken, npm shrinkwrap just create the shrinkwrap file but doesn't publish anything.\nSo what would be the purpose of semantic-release pre && npm shrinkwrap && semantic-release post ?\nI think npm shrinkwrap is meant to be used in your dev environment , and the shrinkwrap should be committed to your repo. During the release on the CI you probably don't want to re-generate your shrinkwrap file and use the one from your repo.\n. > npm shrinkwrap writes a npm-shrinkwrap.json file which is published to the npm registry, unlike package-lock.json\nnpm-shrinkwrap.json should be published on the repo and the release process should use that file and not regenerate one, as we want to publish the npm-shrinkwrap.json from the repo not a generated one.. We have implemented a new mechanism in v8.2.0 that allow you to recover more easily from the ENOTINHISTORY.\nSee #458 for more details.\nThe first log you mentioned seems to be a build that happened on the release-bump branch and your build branch is configured to be master. So it's expected that semantic-release doesn't do a release in that case.\n. We started that here: https://github.com/semantic-release/semantic-release/blob/caribou/TROUBLESHOOTING.md\nAny help would be much appreciated :-)\nJust for information we are working on some changes in this PR #480. It's part of a general effort to make semantic-release more seamless to use and easier to troubleshoot.\n. @zeke should we close this issue? Or would you like to keep it open as a reminder if you are still interested in adding more info in https://github.com/semantic-release/semantic-release/blob/caribou/TROUBLESHOOTING.md?. Should be fixed by #594. No worries. I was updating the whole documentation anyway.\nThere is a lot of issues, related to documentation or not that needs help if you are interested.. There is only one downside: We won't be able to check the NPM and Github token before calling the npm-publish and the github-release plugin.\nSo in case of a misconfiguration (for example the NPM token is set but not the Github one) the npm publish would happen but not the github release.\nNot sure if we can find a clean solution for that. That's quite a edge case though.\nIf it's a problem we could check for the NPM and Github token in semantic-release if the npm-publish or the github-release plugin are configured.. Working on the implementation, one challenge I'm facing is how to avoid/limit plugins interdependencies and limit redundancy. \nFor example with npm we would have 3 plugins:\n- verify-conditions-npm:\n  - check NPM_TOKEN\n  - Add NPM_TOKEN to npmrc if not already there\n  - Call the registry to make sure the auth works\n- last-release-npm:\n  - check NPM_TOKEN\n  - Add NPM_TOKEN to npmrc if not already there\n  - Do the stuff we currently do in last-release-npm\n- publish-npm:\n  - check NPM_TOKEN\n  - Add NPM_TOKEN to npmrc if not already there\n  - Update package.json and Call npm publish\nThe problem is we repeat 3 times the NPM_TOKEN check and the npmrc update.\nIn order to avoid that we could do it only in verify-conditions-npm. But that would make last-release-npm and publish-npm dependant on verify-conditions-npm which kind of defeat the purpose of plugins...\nA solution would be to support \"multi-plugins\".\nInstead of returning an async function, a plugin could return an object with multiple async function, each to be use for a specific plugin type. semantic-release would handle both plugins that returns an async function (as of now) and the one returning a \"multi-plugin\".\nIn the npm example we could create a new plugin @semantic-release/npm that would handle the 3 plugins mentioned above. This new would look like that:\n```js\n// File: index.js\nlet verified = false;\nmodule.exports = {\n  verifyConditions(pluginConfig, {pkg, options}, cb) {\n    // Call set-npm-auth.js\n    // Check we can authenticate to the registry\n    verified = true;\n  },\n  getLastRelease(pluginConfig, {pkg, options}, cb) {\n    if (!verified) {\n      // Call set-npm-auth.js\n    }\n    // Do the last-release-npm stuff\n  },\n  publish(pluginConfig, {pkg, options}, cb) {\n    if (!verified) {\n      // Call set-npm-auth.js\n    }\n    // Do the npm publish stuff\n  },\n};\njs\n// File: lib/set-npm-auth.js\nmodule.exports = () => {\n  // check if npmrc has auth setup for the registry\n  // If not check NPM_TOKEN and set up the auth in npmrc\n};\n```\nThe default semantic-release configuration would look like that:\njson\n\"release\": {\n  \"analyzeCommits\": \"@semantic-release/commit-analyzer\",\n  \"verifyConditions\":[\"@semantic-release/conditions-travis\", \"@semantic-release/npm\", \"@semantic-release/github\"],\n  \"getLastRelease\": \"@semantic-release/npm\",\n  \"generateNotes\" : \"@semantic-release/release-notes-generator\",\n  \"publish\": [\"@semantic-release/npm\", \"@semantic-release/github\"]\n}\nsemantic-release users could opt for different plugins like this:\njson\n\"release\": {\n  \"verifyConditions\":[\"@semantic-release/conditions-travis\", \"verify-npm-another-way\"],\n  \"getLastRelease\": \"get-last-release-another-way\",\n  \"publish\": [\"@semantic-release/npm\"]\n}\nIn this situation the publish part of our plugin would still work, even though the verifyConditions wasn't called.\nThe \"multi-plugin\" solution would be a more elegant way to handle plugin interdependencies as it would:\n- Allow to have multiple related plugins sharing some code (the lib/set-npm-auth.js)\n- Allow to have multiple related plugins sharing a state (the verified value)\n- Allow users to opt-in/out of some plugins\nThe constraint for \"multi-plugin\" is that they have to work even if not all their sub-plugins have been called. For example, the getLastRelease function of the npm multi-plugin has to work even if the verifyConditions function hasn't been called (this is why we check the verified boolean).\nSub-plugins have to work individually but can provide extra features if they are used with some their other sub-plugins (in the example above the \"extra feature\" is avoid checking and setting up npmrc multiple times).\nNot directly related, but we should also support shortcuts for plugins name in the config, for example we should allow to use \"verifyConditions\":[\"travis\", \"npm\"]\" instead of \"verifyConditions\":[\"@semantic-release/conditions-travis\", \"@semantic-release/npm\"]\nFeedback welcome !\n. > I don't think that is actually a problem, if the logic is all contained in one library that all plugins depend on.\nI agree, that was my original though. It's just that we are going to read the .npmrc 3 times. But that's really not a big deal. It's a matter a ms, so not relevant.\n\nAt least lets start with the long form and we can discuss if we want to support the short form later?\n\nOK\n\nAnother possibility is to have a state that is shared across all plugins, so verify-conditions-npm could set state.npmToken and then the others would depend on npmToken to be set.\n\nI'm not sure it's a good idea, because that would create a lot of dependencies between plugins. And with third parties plugin (not maintained by us) that can get out of control quickly. For example if another plugin that to run before didn't set a variable due to a bug, then we have a broken plugin that can't be fixed until the dependent is fixed.\nHaving a state in a \"multi-plugin\" module create also additional complexity but at least this complexity is limited within the module...\nAll the scenario of interdependent plugins that can think of are related to verifying a config/auth in a plugin then doing something that require this config/auth to be set in another plugin.\nMaybe it doesn't worth to add some complexity, and the 3 plugins using a common library is enough. So yeah I'm undecided...\n. > @pvdlg I gave it all some more thought tonight and overall this all makes a lot of sense. I\u2019d move forward with the \"multi-plugin\" idea.\nAgreed. I'm on it!\n\nIt also makes sense e.g. for analyzeCommits and generateNotes, both currently depend on conventional-changelog.\n\nI'm not sure about that. They both depends on conventional-changelog-parser, but share almost no code in common other than loading the presets and calling the parser. They also do not depends on each other in a any way (sharing a state wouldn't provide any benefit), so I'm not sure there is any benefit in merging those two.\n\nWhat happens if I set \"verifyConditions\": [\"./script/my-custom-verification-plugin\"]? Will it replace the default plugins, or add to it? I\u2019d say they replace the default values, and if I want to keep them, I have to list them explicitly.\n\nYes it will replace the default and will not concatenate the array with the default. In that situation only my-custom-verification-plugin will be executed.\n\nIn my example above I\u2019ve added verifyRelease because I think we will need a default verification to support LTS/legacy version releases.\n\nAgreed. We need to specify how that would work. Maybe lts is not the ideal name as the plugin would allow to  handle lts, latest and next.\n\nI\u2019m no longer sure about generateNotes. At least for our github/npm default, release notes are only relevant for GitHub. Maybe we should move the logic there? Can you think of examples where for example we would want to publish to a GitHub release and another platform which would also include the release notes? Would it want the exact same release notes or maybe different ones per target? I don\u2019t know.\n\nCurrently the plugin generate releases note that works for Github, Gitlab and BitBucket.\nI think we should keep generateNotes as is as it would allow folks to replace it by a custom plugin. This way they can customize the release note but still use our future Github release plugin.\nIf we remote the generateNotes plugin folks would who want a different release note would have to write a plugin that do both the release note and the release on Github/Gitlab/Bitbucket. \nIdeally, instead of a github plugin we should do a repository plugin that would do verifications and make the release on Github, Gitlab or Bitbucket based on the repository URL.\n\nIt's actually not an edge case at all. I run into the problem that a package got released but the GitHub release was not created quite a bit. I wish we already had a built-in verify plugin for both npm & github today. They plugins would not only check if the respective tokens are set, but also if the tokens include authorization to make the respective releases.\n\nYes. That will be solved by the \"multi-plugin\" design.. > The ability to customize the publish/release would be a huge plus. That means we could use it to version app docker images for instance!\nEven with the customization of the publish/release, semantic-release will still require to have a package.json to defined the dependency and the npm script and to read some configuration.\nBut the reliance on a package.json should't be too hard to eliminate.\nThe release of docker image seems to be an interesting use case to cover. Could you provide a bit more information on such workflow, so that would help us to define the next steps to support it. In particular:\n- How the release is done? If possible could you provide a link to the documentation explaining how to make the release?\n- And example of a docker project\nThanks !\n. > So I imagine that being able to configure the \"publish\" step so that instead of publishing to NPM, it would run a custom script and pass things like the new version information, which we can then use to create an environment variable so that when Codefresh is ready to create the image, it would tag the final image with the version that semantic-release created.\nThis is the type of detail I'd be interested about. I don't know anything about Codefresh or how to publish a Docker image.\nIdeally I'd like to make the plugin system flexible enough to handle such case. So that would be helpful to know which type of script would have to be run, with which param.\nSo I can make sure the plugin system will allow to create a plugin to handle such case.\nThis type of release could be done with either a dedicated plugin or a generic plugin that run script. I just want to be sure we pass enough information to the custom plugin or if we create a generic script plugin that we have a way to pass the correct information to it.. Here's an update on the progress.\nInitial PR for npm and github plugins:\n- https://github.com/semantic-release/npm/pull/1\n- https://github.com/semantic-release/github/pull/1\nModifications for semantic-release to use these new plugins will follow shortly.. We just release semantic-release@10.0.0 on the dist-tag next that include the possibility to configure the publish plugins (by default npm and github).\nI'm not sure what you mean by \"binary publishing\". If you mean the possibility to publish file in the Github release, see https://github.com/semantic-release/github#assets-option\nIf you mean publishing with something else than npm or github, that is possible with a custom publish plugin.\n. Ok, in that you can use semantic-release@10.0.0 with the configuration here: https://github.com/semantic-release/github#assets-option\nLet us know if that works for you!. That option is not supported by the setup cli.\nYou can find documentation in the following FAQ:\n- Can I skip the release to the npm registry?\n- Can I use semantic-release to publish non-JavaScript packages?. I would suggest to not comment on unrelated closed issue as your questions probably won't be addressed this way. Please see our get help section to find support.. As mentioned in #445 my personal preference would be to use babel-register and babel-polyfill as it makes life easier for both maintainers and users.\nYou can see an exemple in semantic-release/cli#146, specifically this commit.\nAs you can see it's as simple as 2 lines of code and 3 dependencies.\nThe only constraints is that we can't use Node API added after version 4, but the only one we use is promisify.\nI frankly don't have a strong opinion on that and I use Node 8 everywhere anyway.\nBut if not supporting Node 4 or 6 or anything version is a problem for folks, which is totally understandable, then it's a good solution that works for everyone.. Build stage is indeed a better solution, and if we were starting semantic-release now we would probably rely only on that. But as we have a working plugin that allow to support configuration with and without Build stage there I' not sure to see a reason to remove it...\nWe can encourage users to use Build Stage with the condition-travis plugin by recommending this approach in the documentation. Contribution are welcome !\n\nThis would make it easier for package maintainers using alternative CI providers to adopt semantic-release\n\nsemantic-release can be configured to use other plugins to support other CI. For example https://github.com/bahmutov/condition-circle or https://github.com/semantic-release/condition-codeship.\nCould you explain why removing the plugin would help? What's problematic with the plugin approach?\n. > If it's no longer needed, removing it would mean less code to upgrade as new JavaScript features are released. Less code to refactor as the plugin system evolves. Less code that could break one day.\n100s or probably 1000s of build depends on it. It might mean less code to maintain, but it also mean \nall those builds will fail or behave improperly in case a user doesn't read the release note mentioning that Build stages are now mandatory. It also means a lot of issues opened by users who do not want to or cannot use Build Stage x, y, z reasons.\nIt we realize the code doesn't work and the charge to fix it is important we might think about decommissioning it. It the code works and is used by most users, I don't see the point of removing the feature.\nIf the plugin doesn't cover a use case then we can update it.\nCan you explain which workflow the plugin prevent you to achieve ?\n\nIf I can get to it this week I'll submit a pull request to update semantic-release to use Travis build stages.\n\nPR are always welcome. But I'm not sure what modification you are proposing here. semantic-release support Build stages with the current conditions-travis. See comment.\nWe need to document it though.\nCould you elaborate a little bit on the modification you are proposing ?\n\nIt does two things: checks that you're running on Circle CI, and that you are running on the branch configured in your semantic-release configuration in package.json.\nThe first one, the one that checks that I'm running on Circle CI, does not add value to the developer experience, or quality of the product. If I want to run my project on Circle CI, I'll run my project on Circle CI. Nothing more to it.\n\nThe verify-conditions plugin is responsible for more than that:\n- Verify we are running on a CI env\n- Verify we are running on the configured branch\n- Verify we are not running on a PR build\n- Guarantee that the test of the current job and all other job are successful (that part can be insured by Build Stage if you choose to)\n\nTherefore, to get semantic-release running on Circle CI I would just need to add configuration to my project's package.json to disable a Travis CI plugin, which seems a little silly if I am not even using Travis CI to begin with.\n\nWe have a plugin system to let users customize semantic-release. We choose to have the Travis one as the default because it's the most commonly used. Using another CI environment require using another plugin at the moment.\nWe could have make a plugin that works on all CI but at the time the plugin was created, it was made specific to Travis as making Api calls to Travis was the only way to guarantee we make a release only when other jobs a successful.\nAnother thing to consider with Build Stages is that we have no way in semantic-release to verify that the configuration of Build Stages is done properly. A misconfiguration in the build stages might trigger an unwanted release.\nThe amount of safety check we should put in the code to prevent problems due to misconfiguration is arguable, but a lot of issue we have are related to a misconfiguration that have created a release or a tag and the user struggles to recover from that. In other type of software, I'd say that failures due to misconfiguration are completely acceptable and expected. In the case of semantic-release it result in an unwanted release  which can have a lot of consequences:\n- Some user might upgrade to the new release before you relaize the problem happened\n- Tools like greenkeeper will be triggered, creating update PR, that might get merge\n- Any other automated tool that listening to npm publishes will be triggered (blog posts, mails, tweet, confetis, etc...)\n- Unpublishing the version on npm prevent to reuse the version later (if you release 2.0.0 and unpublish it, you won't be able to release 2.0.0 it again, ever.You'd have to take manual step to release 2.0.1 or 3.0.0)\nAll that concerns mostly big projects. But still, it's important for semantic-release to take extra care in checking everything possible before making the release.. I create a PR to add explanation on how to use Build Stage with an example: https://github.com/semantic-release/condition-travis/pull/91\nDoes that address the concerns raised in this issue ?. Duplicate of semantic-release/condition-travis#96. Closing in favor of semantic-release/condition-travis#96\nOther CI can be supported via plugin, by configuring a different plugin in place of condition-travis.. What problem from https://travis-ci.org/buehler/node-typescript-parser/jobs/294617068 are you referring to?. I'm not sure the explanation is still relevant since we released v9.0.0.\nnpm publish is now handled directly within semantic-release.\nWe now expect the package.json to be configured like this:\njson\n\"scripts\": {\n  \"semantic-release\": \"semantic-release\"\n}\nConfiguring the CI to yarn semantic-release would work.\nsemantic-release use npm to do the publishing instead of yarn, but that's an implementation detail for the user.\nThe only requirement we have is that npm must be installed on the CI (and it's the case by default for all CI I'm aware of). . I think every feedback has been addressed now.\n@felixfbecker @gr2m could you review ?. > I'd squash the commits to just fix: log error properties and check SemanticReleaseError by .semanticRelease property, the current commit message is no longer correct, right?\nI renamed the commit properly. any reason to squash the 3 commits in one? They fix different things. So as much as possible I rather to smaller, specific commit. That create a release note with more info and make the repo history clearer.. > Agree, as long as every commit works on it's own (a build on this would succeed) I wouldn't squash them\nYes I make sure of that when I create multiple commits in a PR. If for some reasons I fix two related thing but can't make 2 commits that work by themselves, then I create 1 commit and I mention both fix in the body.\nMake me think it would be nice to include commit body in release note (maybe in segment with \u25b6 that would allow to unfold/expand the body). But that's another story.. @sudo-suhas I'd suggest a postpublish script in which you would add anything to be done after a publish to npm.\nThis script would:\n- be run only if a release is done\n- After the package.json is updated\n. You can run those scripts by putting them in the prePublishOnly or postpublish.\nThe would be run by npm before or after the publishing.\nAt that point there is no way to not use npm though. That will be handled soon in #484. Yes I noticed that as well. I'm looking at it.. On a local project if I run npx -p node@8 -c \"semantic-release\"\nI get the error: /bin/sh: semantic-release: command not found\nIf I have semantic-release installed globally it works.\nI'm really confused by what npx -p node@8 -c \"semantic-release\" actually does...\nThe problem with the NPM_TOKEN missing might be due to semantic-release not being executed from the root directory of the project.... Running on Node 8:\nnode -e \"console.log('TEST %O', {a: 1})\"\n=> TEST { a: 1 }\nnpx -p node@8 -c \"node -e \\\"console.log('TEST %O', {a: 1})\\\"\"\n=> TEST %O { a: 1 }\n\u00af_(\u30c4)_/\u00af\n. Ok the %O problem is due to https://github.com/nodejs/node/pull/14558 that has been implemented in Node 8.4.0.\nWhen running npx -p node@8 the version used is 8.3.0 as it's the latests published on npm.\nSo we can either decide to support only node >=8.4.0 or I'll have to find another way to format objects in logs. I'm sure their library that can do that. . > I was not able to reproduce this \u00af_(\u30c4)_/\u00af\nIt happens with node <= 8.4.0\nSo npx -p node@8.3.0 -c \"node -e \"console.log('TEST %O', {a: 1})\"\" would create the problem with %O.\nSince today the last of node@8 release on npm is 8.9.0, so npx -p node@8 works.\n. > can you try the --shell-auto-fallback flag?\nNow running npx -p node@8 -c \"semantic-release\" works... I don't have /bin/sh: semantic-release: command not found\nMaybe a weird bug somewhere between a specific version of node / npx / npm?. Fixed by #593. Would this answer in our FAQ address your question? \nIf it's not clear let us know and we'll try to clarify as much as possible !. To add a bit more information, this is mostly because it's unnecessary. There is just no particular reason to push the version in the repo. So it's not necessary to create a commit, that would not add any additional info in the commit history (we already have tags).\nDoing this commit from the CI would also come with additional complexity:\n- Permission\n- Handling the CI job that would be triggered by this new commmit\n- Having a cloned repo to be able to do the commit (some CI do not provide a clone but a detached head). That would be a lot of modifications and code to maintain for something that is not necessary. It might be a common thing in the ecosystem, but if it's not necessary I'm not really sure it worth investing the resources. At least not for the maintainer team in the near future.\nThat said, once #484 is implemented, it will probably be possible to create a plugin to achieve that (and maybe even pushing a CHANGELOG.md to the repo).. @thezimmee that's a different issue you are having.\nThe problem is that your build step (what put the version is in your distrib files) probably runs before semantic-release, so the version is not in the package.json yet.\nThe solution is to setup those script to be run in the npm prepublishOnly script like this:\njson\n\"scripts\": {\n  \"prepublishOnly\": \"prepare-dist-files\",\n  ...\n}\nThe script prepare-dist-files will runs after sematic-release update the version in package.json and before npm publish (so the updated dist files will be included in the package published on npm). > Just trying to think this through, so I think what you're suggesting is something like this:\n\n\nOnly npm truly needs the dist files and not source control, which means I can...\n...add dist files to .gitignore,\nand run the build in the prepublishOnly script (\"prepublishOnly\": \"npm run build\" in my case).\nDoing so will publish the dist files to npm via semantic-release/travis ci.\n\n\nYes. You would also have to add the files property in your package.json to include your dist files in the npm package (just add the path of the folder that contains the dist files.). See package.json#files.\nDoing so has also other advantages:\n- You can get rid of the .npmignore file\n- You add new files in your repo you don't have to remember to add them to .npmignore as they will be excluded due to not being present in files.\n\nSound about right? My assumption is that if I .gitignore the dist files, they will still be published to npm, so long as they are not in .npmignore, is that correct?\n\nNo, as npm also ignores what's in the .gitignore. Adding the files property to the package.json will solve that.\n\nBased on all this, it doesn't seem like there is a great way to get my dist files into github / source control (with the correct version), or am I wrong? Does/should this even matter?\n\nNo there is no easy way at the moment to push your dist files if they are built with the version number.\nIt probably doesn't matter, unless you want users to download them directly from Github instead of installing your package with npm. In order to solve this situation we plan in a future release to allow to push files to the github release (see #484). It's a much cleaner way to make your dist files available for download than pushing them to the repo as they are more easily identifiable as the final product and users can download any version they want.\n\nit makes me a little hesitant to have the dist files be so automated...\n\nIn your current workflow the dist file are built on your local machine by your build script. In the proposed scenario they are built on the CI by the same script. So in the end it's the same script that build your dist files, so it's really more automated than before, it just run at a different time.\nYou can keep your prepush hook in order to check the build work locally before pushing. But if for some reason the build fail on the CI, the package won't be published on npm registry and the semantic-release will stop right there and report the error.. A git plugin is in the work with:\n- Create a release commit (optionally gpg signed)\n- Generate/update a CHANGELOG.md\n- Commit package.json if it was updated by a previous plugin / script (like the npm plugin does)\n- Commit a configurable list of files (like a dist directory etc..)\n- Create the git tag\nMore to come in the following days/weeks\n. This feature has been implemented via the  plugin https://github.com/semantic-release/git. Yes it will be deprecated soon. It's already published in the dist-tag next. You can use with \"semantic-release\": \"^9.1.0\" in your package.json.\nBefore publishing on the latest dist-tag, I think It's probably better to implement #484 first to avoid breaking build that do not use npm.\n. We will update #411 once we release on latest. Feel free to subscribe to this issue.. Could you provide a link to your repo? Or at least your package.json and travis.yml ?. I think Travis use yarn if it finds a yarn.lock file but no package-lock.json.\nBut if I install with yarn install and run npm run semantic-release it works... Not how installing with yarn is causing the issue.. It's not an error, just warning from npm. You are using aprepublishscript [here](https://github.com/stoffern/universal-app/blob/master/package.json#L9) and that's a deprecated feature. You should replace it byprepareorprepublishOnly `.\nSee https://docs.npmjs.com/misc/scripts#prepublish-and-prepare. @gergelyke according to Artifactory documentation the authentication with a token was introduced in version 5.4.\nAs you are using version 4.16.0 you have to use the legacy authentication. It's supported by semantic-release but undocumented as it's deprecated.\nWith the current version of semantic-release you have to define the environment variables:\n- NPM_OLD_TOKEN with your Artifactory username and password (formatted username:password) encoded in Base 64\n- NPM_EMAIL with the email address associated with your Artifactory user\nOnce #515 is merged and released you will have to defined the environment variables:\n- NPM_USERNAME with your Artifactory username\n- NPM_PASSWORD with your Artifactory user password\n- NPM_EMAIL with the email address associated with your Artifactory user\nIf you can, you should upgrade to a more recent version of Artifactory and just use the NPM_TOKEN generated with npm login as it's a lot more secured.\nIn order to do that run npm login and open the file ~/.npmrc. You should see something like that in the file: //<registry_url>/:_authToken=<token>.\nSet the NPM_TOKEN on your CI with the value of <token> from ~/.npmrc.\nLet us know if that solve your issue.. It's really weird how it jumped from attempt 2 to 112....\nIt seems the job was running for a while but the logs were lost.. Should we close? Or do you still need it?. This should be the case soon :-)\nSee #484. A plugin for Shippable-CI shouldn't be required anymore as Semantic-release works on any CI since #578.\nIf the CI runs multiple jobs (to test multiple node version or different OSs) within a build it has to guarantee that semantic-release is executed only after all jobs are successful. Quickly going through the Shippable-CI doc it seems that running multiple jobs within a build is not supported anyway.\nFeel free to re-open if there is something to support Shippable-CI. You can set the access to public in your package.json:\njson\n  \"publishConfig\": {\n    \"access\": \"public\"\n  },\nIf you want to limit what's included in the published package (i.e. include only the dist directory) you can configure that in the files property of you package.json:\njson\n\"files\": [\"dist\"]. @abalad does that solve your issue?. It's not possible at the moment. But you can have a different package.json on each branch, each one having a different branch config.\nThat said doing releases from multiple branches is not fully supported yet.\nnpm allow to release a version only once, independently of the dist-tag. And when a release done on dist-tag next is considered ready for general availability, you have to make it available on the latest branch with: npm dist-tag add <pkg>@<version> latest.\nSo if you release version 2.0.0 from the next branch on the next dist-tag, when you will merge the next branch into master, semantic-release will attempt to release 2.0.0 on the dist-tag latest. That would fail because 2.0.0 has been released already.\nWhat is fully supported is what we currently do on the semantic-release repo:\n- release.branch configured to master in package.json\n- publishConfig.tag configured to next in package.json\nWith this configuration you have only one branch (master) and all releases are done from there on the dist-tag next. When a version is ready for general availability you make it available on latest with npm dist-tag add <pkg>@<version> latest.\n. There is several issues opened with more or less related questions. Feel free to search in the issue tracker.. Duplicate of #563. Feedback welcome in #563. Thanks !. Authentication is required to publish scoped packaged.\nThe authentication is set up with the NPM_TOKEN environment variable.\nCan you check that NPM_TOKEN is set on your CI environment (for example in Travis) and the token set allow you to publish?. semantic-release try to create the tag 1.2.1 on the repo formhero/fh-cors-middleware referencing the commit 8f1c9771bc4e4deb25bf3da93118dc6e2163c8e1 on branch develop\nCan you verify if the commit 8f1c9771bc4e4deb25bf3da93118dc6e2163c8e1 exists on the repo formhero/fh-cors-middleware on branch develop ?. Yes via plugins. Feel free to follow #484 for updates.. @raix did you had time to implement those 2 plugins? If yes are they compatible with the last semantic-release version (v13.0.0)?\nTo work with semantic-release@13.0.0 the plugins should:\n- not implement getLastRelease anymore (handle in the core)\n- not create the Git tag anymore (handled in the core)\nIf those plugins are developed and tested, would like to add them to \nplugins-list.md?. Ok. Do not hesitate to ping me if you have questions regarding the plugin architecture. Awesome! Feel free to open a PR to add it to plugins-list.md#community-plugins whenever you's like!. Closing as the plugins exist. Feel free to open a PR to add them to  plugins-list.md#community-plugins. > is there a package you are using to read out the npm rc auth? If yes, maybe we can recommend it in the release notes? No need to update commits, we can update release notes later\nI'm using https://github.com/kevva/npm-conf here\nI can update the commit as I have to reference https://github.com/semantic-release/github version 1.0.0 when it's released\n. npmconf is deprecated. npm-conf is not.. > Could you give an example how to use an arbitrary shell command as a publish step? E.g. docker push, vsce publish etc\nThat is not possible yet. I'm working on a plugin that would allow to do that.. I cannot tell you about https://github.com/finom/last-release-git\nBut https://github.com/semantic-release/last-release-git-tag does works with 10.0.0. > sorry for the trouble you run to. Okay with me\nNo problems :). The error you get is npm ERR! You must sign up for private packages : @at-scale/mock-react-components. See https://travis-ci.org/at-scale/mock-react-components/jobs/306197163#L547\nHave you set the NPM_TOKEN environment variable in your CI? Is the user associated with this token is allowed to publish on your npm org?. I'd suggest to add that to your package.json instead:\njson \n \"publishConfig\": {\n    \"access\": \"public\"\n  }. This is caused by https://github.com/babel/babel/pull/5487. It happened under certain circumstances based on how the dependencies ends up being installed (that depends of the npm your are using). It shouldn't happen with npm 5.\nIt's fixed in semantic-release/cli#153. The error is exactly what you mentionned here :)\nBind for 0.0.0.0:5984 failed: port is already allocated. Thanks for your interest in semantic-release and your contribution !\nAs a general rule when you want to propose an important change it's better to open an issue first to discuss the change. So if the change is refused you'll save time :)\nAfter discussing with the maintainer team, we would be open to support monorepo, but only on certain conditions:\n- It would be supported through third-party plugins\n- Only minor changes would have to be made to semantic-release core\n- The monorepo implementation would not go against the core principle of semantic-release (i.e. release-on-every-push)\nHere is some of the reasons for this:\n- There is currently multiple monorepo solutions: lerna, builder I think, yarn workspaces, zelda and many custom ones\n- All this solution are quite different and it's not really clear which one is going to become the most common one\n- It doesn't seems there is a strong agreement yet on how to manage naming convention (commits, tags, versions etc...) so it makes it difficult to determine which commit belong to which package etc...\n- Some of the features provided by monorepo are covered by semantic-release (arguably in a better way)\n  - monorepo make the release process easier as only one command has to be ran to release multiple packages => semantic-release goes further by automating the release process completely\n  - Monorepo make changes across package easier => semantic-release enforces semver and allow to make a release on each push. This is arguably a better way to handle modularization as it guarantees the dependencies are unidirectional and that changes will be displayed outside the organization properly (by releasing a major version on breaking changes)\nMy humble opinion, from what I read regarding monorepo, is that the most promising solution is zelda as it's non intrusive, provide most of the benefits of other solution, without the additional complexity/constraints of dealing with commit/tag naming convention, mixing the issue tracker, releases etc...\nRegarding your proposed change I don't think it's the right approach. semantic-release must continue to identify all the commits since the last release, monorepo or not, as plugins downstream will need that.\nMoreover your solution seems to be based on determining the files modified by a commit. It will probably be complex to handle situation in which a commit modify files across multiple sub-package. It's probably better to make the commit/package association based on naming convention, possibly reporting errors when a commit modify multiple packages (I don't know if such case is expected or not...).\nThe right way to handle monorepo might be via plugins:\n- analyzeCommit: to parse the monorepo commit format\n- publish: to do multiple releases of each sub-modules\n- generateNotes: to generate a custom release note that group together the commits related to the same package\nBut all that depends mostly on monorepo specifics:\n- Should we make one release note with different block for each package released ?\n- Should we make one tag ? Or a tag per package released ? what if a commit span across packages?\n- What happen if a new dependency is set in the root package.json? Does that mean all the sub-package have to release so they include the new dependency? Or is each sub-module has its own independent package.json?\n. Related to #193. The objective of semantic-release plugin architecture is to support various workflow, third-parties  integration and to customize some rules. In order to keep a sane eco-system:\n- the core has to do the decision making and the orchestration\n- the plugins have to be limited to simple, well-defined tasks\n- the plugins cannot be interdependents\nOtherwise it will create a crazy amount of issue like \"When I have plugin X, Y, Z this weird thing happen\".\nThe goal is to allow extension and customization not to transform the core into an empty shell that run plugins sequentially.\nThe fundamentals of the semantic-release plugin architecture are:\n- The core is in control, determine the logic and orchestrate\n- The plugins (as in the exported function of a plugin module: verifyConditions, getLastRelease etc..) do one tasks\n- The plugins have well-defined, simple input and outputs => Plugins know only the minimum they have to know to perform their simple task\n- The core validate the output of each plugin\n- The plugins cannot be interdependent: a plugin cannot call another plugin, and should perform its task with the input passed by the core, no matter what other plugin is used\nMoving the commits retrieval to a commit would go against that, by creating plugin inter dependencies. In your implementation for example the publish would be dependent on the getCommit.\nMoreover it doesn't make sense to exclude some commits. In git the commits (on the release branch) are sequential, and a release is the state at a moment of the commit history. In other terms a release is defined by a commit range, including everything from A (last release commit) to B (new release commit). Some commits within that range might not be written to the changelog, or not be considered to determine the version increase, but they are part of the release.\nFinally, the commit retrieval part will evolve quite a lot in the near future, in order to handle workflow with multiple branches, dist-tags and pre-release. It will be in charge, among other things to detect merge/rebase commits, to determine if a new release has to be done or if an existing release has to be made available on a lower dist-tag.\nFor these reasons the commit retrieval part should stay in the core.\n\nThey are complementary to semantic-release, allowing it to scale across a monorepo. In fact, I use lerna and yarn workspaces in the semantic-release-monorepo workflow.\n\nTo a certain extend yes. semantic-release and monorepo do very different things. But they both offer solutions to problems that overlap. As mentioned they both provide a way to make the release process easier for the developer, monorepo by doing multiple releases with one command, semantic-release by fully automating the process.\n\nI could filter the commits passed to analyzeCommits, but I'd have to do the exact same filtering again to generateNotes since both plugins are passed the same commits coming from getCommits\n\nWe have implemented the concept of \"multi-plugin\" so a given plugin package can expose multiple plugin functions and share some code. For example in the npm plugin the verifyConditions, getLastRelease and publish are exposed. They all use some shared code: verifyNpm and getPkg.\nKeep in mind that they still have to be non interdependent. the npm publish can be used with a different implementation of the getLastRelease.\nSo if you need commit filtering function shared by analyzeCommits and generateNotes you can do that pretty easily.\nI think what you want to achieve is possible with the current architecture and the plugin hooks available.\n\nsemantic-release must continue to identify all the commits since the last release, monorepo or not, as plugins downstream will need that.\n\nThis PR does not interfere with this. The default behavior is still exactly what it was. Only through a third party plugin could this behavior be overridden.\n\n\nWhat I mean is that it does change it because it allows to replace the commit retrieval by a different implementation\nSorry for the long message...It's a complex subject. Hopefully my explanations clarify a bit and provide reasonable points :) \n. Thanks for the update!\nAs mentioned we would be open to minor changes in the core to support monorepo. But the commitFilter you are proposing seems to be specific to your implementation of monorepo. For example (as far as I understand) lerna works differently and analyze all the commits and make multiple releases at once.\nUnfortunately none of the maintainer knows monorepo solutions enough to be able to come up a comprehensive design.\nIn order to move forward we would like to have a proposal, in the the form of an issue with:\n- A detailed explanation of the major monorepo solutions:\n  - File structure and naming convention\n  - Commit formats\n  - Scripts used to make a release\n  - Version number / Git tag format\n- A detailed explanation of the release process\n  - How to determine if a 1 or more release(s) have to be done\n  - How to retrieve the last release(s), on npm and on git, especially in the case of multiple releases\n  - How to parse the commits and details about the mapping commits <-> releases\n  - How to make the release(s): change directory? run a script? what to do if one of the multiple release fail?\n  - How to generate the changelog: One changelog per packaged released? Or concatenate all of them in one changelog? How many releases on Github? \nThen when we have all this information we can involve the community and discuss the best approach.\nThis idea is that if we support monorepo we do it properly:\n- The solution has to generic enough so the core (and possibly the default plugins) would support any monorepo solution\n- The specificities of each monorepo has to stay in plugin\n- The changes in the core and the potential plugin input/output has to be defined beforehand so the community can work on plugin without constant breaking changes\n- As monorepo are very complex solutions with a lot of constraints/worarround, we would need detailed documentation regarding how to implement a workflow for each major monorepo solution\nIt doesn't mean we have to support all solutions right away. But the design as to be generic and robust enough so anyone can create plugins for other/new monorepo solutions without changing the core.\nI know it's a lot, but would you want to work that?. Just to clarify a bit regarding the problem of having too frequent breaking change releases. Using 0.x.x version will not change anything vs having a 1.x.x version. \nIf you configure your dependency in the package.json with ^0.1.0 for example than each release that change the second number will be consider a breaking by npm and the user will to update manually the version.\nIn other terms for npm, 0.1.0 => 0.2.0 and 1.0.0 => 2.0.0 are both considered a breaking change release.\nIf you are concerned about \"spamming\" your users with too frequent major release, you could use dist-tag. From the README.md:\n\nIf you fear the loss of control over timing and marketing implications of software releases you should know that semantic-release supports release channels using npm\u2019s dist-tags. This way you can keep control over what your users end up using by default, you can decide when to promote an automatically released version to the stable channel, and you can choose which versions to write blogposts and tweets about. You can use the same mechanism to support older versions of your software, for example with important security fixes.\n\nYou could configure semantic-release like this:\njson\n\"plublishConfig\": {\n  \"tag\": \"next\"\n}\nThis way all releases will be done on the next dist-tag. That means only the user that explicitly choose to use the next dist-tag will get the breaking change.\nWhen you want to make a release available for everyone then you can add it to the default latest dist-tag.\nThat would solve the problem of having too frequent breaking changes for your users (the 0.x.x version wouldn't solve that).\nSee this article for more details: https://blog.greenkeeper.io/one-simple-trick-for-javascript-package-maintainers-to-avoid-breaking-their-user-s-software-and-to-6edf06dc5617\nIf the problem is the \"emotional\" part attached to high version numbers then you could create a next branch and release frommaster only when you decide.\nYou would have to set next as your default branch on Github and push your code there.\nWhen you are ready to make a release, you would merge next into master. That would trigger a release process and semantic-release would release based on the commits since the last release.\nIn the early stage of your project, when you break the API very often, you would do a release less frequently. Once your project is stable you can start making releases more often, maybe even committing directly on master and make commit on each push.\n. Here more details about the reason we favor starting at 1.0.0: Introduction to SemVer\nClosing in favor of #566. I see in the Circle logs that it uses yarn. That should work, but you still need to have npm in the path. Do you know if Circle still install npm when you are using yarn?\nCan you start another run with version 11.0.0 and setting the environment variable DEBUG to semantic-release:* ?. In 11.0.0 we changed the plugin API.\nIf you use custom plugin, make sure they have been updated for the new API.\n. Not much more info unfortunately.... Do you have to connect with ssh to check what's in the .npmrc ?. Can you check if you have another .npmrc in the home directory ?\nIf it's the case it might have a different value there. And the .npmrc in the home will take precedence over the one in the project I think.. With //registry.npmjs.org/:_authToken = ${NPM_TOKEN} in the .npmrc, what happen when you run npm whoami ?. Is it possible that somehow NPM_TOKEN is available when you debug with ssh but it's not when semantic-release runs?. There is no differences between 10 and 11 I can think of that would explain a different behavior regarding the npm auth... So I don't really understand yet what cause the problem.... The debug log is still there but we don't use the name config anymore. So it's normal.. In the Circle step in which you run semantic-release, can you try to run that:\necho \"//registry.npmjs.org/:_authToken=${NPM_TOKEN}\" > .npmrc && npm whoami ?. condition-circle will break things if it doesn't adapt to the new plugin API of 11.\nSo if you remove condition-circle out of the equation, does it works ?. In your custom plugin condition-circle.js can you check if NPM_TOKEN is properly set ?\nHere is an example of code that would avoid revealing your token:\njs\nconsole.log('Check NPM_TOKEN ' + process.env.NPM.substring(0, 4) === '<the first 4 characters of your token>')\n. If the npm verifyConditions runs first and fail, your custom plugin won't even be called. Maybe that's why?\nBy the way the custom script to fix packed repo is not required anymore. semantic-release handle that now.. I might have an idea... I pushed so changes on https://github.com/semantic-release/npm/tree/userconfig.\nCould you try to configure in your package.json:\njson\n\"devDependencies\": {\n  \"@semantic-release/npm\": \"semantic-release/npm#userconfig\"\n}\nAnd see if that solve the issue ?\n. :( When you shh to the box, do you the expected token with echo $NPM_TOKEN ?. I also added some debug log in the branch https://github.com/semantic-release/npm/tree/userconfig.\nCan you restart the build that uses the userconfig branch with the environment variable DEBUG=semantic-release:* ?\nJust to make sure what is the error reported by npm whoami. One more thing. can you set the npm loglevel to verbose here ?\n. It should be solved by semantic-release/npm#9\nFor informations it comes from this issue: npm/npm#18426. Can you confirm it works with yarn now?. False positive due to Travis taking to startup Docker. Yes that would be great. Not sure which form it would take though. Ideally it has to run on PRs.\nIn the meantimes you have a few options:\n- https://github.com/marionebl/commitlint\n- https://gitcop.com/. Yep. But for info this app uses validate-commit-msg which is deprecated..... Feedback on this subject welcomed in #585. False positive. The tests passed on a retry: https://travis-ci.org/semantic-release/semantic-release/jobs/309316414. This is happening because that project uses version 12: https://github.com/okonet/lint-staged/blob/fcb774b1ff46bf072e77b757a6b1133bb72b596c/.travis.yml#L24\nAfter upgrading to the latest version 15 it will works. . Version is really old (we are version 15) and many fixes/features have been added since then. We might consider delivering fixes for the previous major release (e.g. version 15 when we release 16) but we won't maintain a version that is so old as 12..... The error come from the Travis API...which doesn't give very detailed errors...\nCan you make sure you added your Github repo to Travis?. You have to enable your Github repo on Travis. See https://docs.travis-ci.com/user/getting-started/#To-get-started-with-Travis-CI. Is the GITHUB_TOKEN you are using is the associated with the Github user who is an owner of the repo?. Are you using Travis Pro or Travis Enterprise (with a custom URL) ?\nIf you are using Travis Enterprise we are not supporting yet.\nPlease open an issue on https://github.com/semantic-release/condition-travis for that.\nWe would like to support Travis Enterprise, but we do not have an instance to test so it would be quite difficult for us to add this feature.\nWould like to help us and contribute with a PR? We would would give you guidance and help regarding the specifics of semantic-release.. Does your user have write access to the repo?. Do you have more details about the error ? Could you copy and paste the output of the CLI.\nCould you also provide a link to your package.json ?. What is the error you get from the CLI ?\nLike the exact error, and the stackstrace.. Duplicate of #380. > The issue (I think) is that the url is commit_s_/ instead of just commit/ (singular). I tried finding where in the code the URL is made, but couldn't find it\nI can reproduce. I'll check that out.\n\nOn a related note, would it be possible to write a CHANGELOG.md to the root of the package before publish, so it's included in the npm package? I don't need it in my source code, but would be sweet if it was included so people working offline could still see the changelog\n\nyes => https://github.com/semantic-release/git. False positive. Thanks for the proposal!\nA shareable config might be a solution but the problem is that many (most?) parameters are repository/branch specifics:\n- branch might have a different value on each permanent branches of your repo (in order to release on latest dist-tag from master and on next dist-tag from another branch)\n- assets will most likely be different on each repo\n- repositoryUrl will by definition be different on each repo\n- The list of plugins to use will in most case be the default one (no config at all) and when it's not it will in most case quite specific to a given repo\nIn addition some other configuration that semantic-release uses are independent from its configuration, such as .npmrc or the publishConfig in the package.json.\nWith a shareable config you would still have to configure most of the options manually on each repo.\nThat mean a shareable configuration would have to be extendable, which comes with a lot of problems: See the 2.5 year old, 110 comments issue on the subject.\nMaybe a better solution to share a config across repo would be https://github.com/sapegin/mrm. They event offer a semantic-release task.\nFor information, what parameters are looking to put in a shareable config?\nI'm currently looking at a way to simplify the configuration, but I'm not sure what the right solution is yet... Ideally I'd like a way to configure the plugin params globally (instead of limiting the config within the plugin definition). Maybe that would alleviate the problem.. Here is a first proposal to implement such feature, so we can discuss what the best approach is.\nThis first step would be to allow plugin configuration to be set directly under the release property. Those config would be passed to each plugins. For example:\njson\n\"release\": {\n  \"publish\": [\"@sematic-release/github\", \"@sematic-release/git\"],\n  \"assets\": [\"dist/**/*.js\"]\n}\nThe assets option would be passed to both the git and github plugins. It would still be possible to define options inside each plugin, that would take precedence for this specific plugin over the one defined under release.\n=> #553\nThe second step would be to allow the new parameter extends that could be set either via config file or CLI. It would be a list of path (either file on the FS or npm modules) to extends from.\njson\n\"release\": {\n  \"extends\": [\"config-1\", \"config-2\"],\n  \"branch\": \"caribou\",\n  \"assets\": [\"dist/**/*.js\"]\n}\nSo semantic-release would determine its options by merging in that order of priority:\n- Options passed via CLI\n- Options set in the package.json or dotfile config\n- Options set in the scripts/modules defined in extends\n- Default options\nIn order to keep things simple the shareable config would not be allowed to extends other shareable configs.\nThis way a shareable config could:\n- Defined which plugin to use\n- Defined a new set of default options\nAnd the user could override any options specific to the current repo/branch.\nWould that be an acceptable solution?\n. Thanks for the feedback!\n\nanalyzeCommits: i've stuck with the the default for simplicity, but there are times where we've wanted to tweek it a bit based on our team conventions. we use commitlint to ensure our commits align to what semantic-release is looking for. i'd want the shareable config to enable us to align any tweaks we've made to our commitlint config with semantic-release behavior. \n\nYou can already do that with the releaseRules that accept a module or a path and config that accept a custom conventional-changelog preset module. commitlint is based on conventional-changelog preset I think. So it should work for your use case.\n\nprereleases: i have thoughts around a strategy for prereleases that would work for our team that i think would need to be coordinated across several plugins. since this would be a team strategy, we'd want to make sure each package is codified to follow the same strategy. i'd love to run my thoughts about this strategy by you all, but thats a separate conversation (would another issue be a good place for that type of conversation, or is there a better way?)\n\nI have something in preparation for that, including multiple branches, multiple dist-tag and pre-releases, all that fully automated based git merge detection. It's a pretty complex thing so I've been experimenting on that for several weeks :) I'll open a (very long) issue for a proposal soon. Feedback welcome once I got that published :)\n\ni do think there would be significant value in enabling shareable configs to extend other shareable configs, but i can certainly understand avoiding that complexity at first at least.\n\nAs mentioned through the Eslint issue it's quite complicated and potentially not even solvable properly, mostly due to plugin dependencies. Ideally, when you create a shareable config that use a custom plugin, you'd want to include this plugin as a dependency of your config package. The case with a chain of several configuration using different version of the same plugin is either impossible or extremely difficult to solve.\nIn addition that would create a lot of complexity regarding how to merge the different config (deep merge or not ?). Doing a deep merge is probably error prone as plugin could define option that are inter-dependent, and doing a deep merge would create more often than not inconsistencies and very difficult issue to debug.\nChainable extends make sense for something like Eslint that defines a lot of things in a config. Not sure sure that the complexity and maintenance load would justify the gain in the case of semantic-release.\n\ndoes this give some more context for what i was thinking? what other information would be helpful?\n\nYes, it helps a lot!. I'm currently looking at a way to simplify the configuration, but I'm not sure what the right solution is yet.\nSome plugin parameters (and future core parameters) are complex objects (like github#assets) that couldn't be passed via CLI. It would be confusing to have some parameters accepted in the CLI and some other that are not.\nAlso I don't think wrapping the CLI is the right approach. You should instead call semantic-release via API:\n```js\nconst semanticRelease = require('semantic-release');\nconst options = {branch: 'master'};\nawait semanticRelease(options);\n```\nOn a side note, what you do insemantic-release-github-pr is something we are thinking to implement. But that will not work for PR that are made from a forked repo, as the environment variables will not be available on the CI.\n\nEncrypted environment variables are not available to pull requests from forks due to the security risk of exposing such information to unknown code.\n\nIf you'd make the environment variables available for PR coming from forked repo, anyone could make a fork and open a PR that does console.log(process.env.GH_TOKEN) and obtain access to your Github account by looking at the CI logs.. I was trying to propose a solution to your use case and I'm sorry that my choice of word appeared non constructive. That wasn't the intention.\nThe objective of the CLI is to be used by users and on the CI, while the objective of the API is to allow integrations. API is usually a more convenient choice as it allows to do some pre-processing and to pass a complex object as the options. In addition it avoid having to spawn a sub-process and it makes it easier to handle errors, as the API throws typed exceptions with messages, while the CLI just return 0 or 1 with some logs on stdout and stderr.\nYou can use the API and still pass any parameter (such as --dry-run). This can be achieved by parsing the arguments passed to your CLI and pass them to the API along with some other pre-determined parameters. This is basically what the semantic-release CLI is doing in cli.js.\nYou can use libraries like https://github.com/tj/commander.js or https://github.com/yargs/yargs to parse process.argv. This way you can allow your users to set any options via CLI.\nThis could be something along those lines:\n```js\nconst semanticRelease = require('semantic-release');\nconst program = require('commander');\nconst {merge} = require('lodash');\nconst predefinedOptions = {...};\nprogram\n// Optionally defined the set options that are allowed, or let the user set any parameters, display a custom, a custom help etc...\n.parse(process.argv);\ntry {\n  await semanticRelease(merge(program.opts(), predefinedOptions));\n} catch(err) {\n  // Handle errors\n}\n```\nThis way you can, if you choose to, limit the options the users can set, or add new ones, or display different help message, or do any pre-processing/validation on the options passed by the user,  etc...\nWith the API semantic-release will create the options object by merging the following in that order of priority:\n- options passed to the API\n- option sets in the first configuration file found (package.json or a dotfile at the root of the repo)\n- default options\n. I'm not sure I understand what you are proposing. Can you provide an example with the command you want to execute, the package.json config and the expected result? . > Having to re-implement/copy the CLI when creating a binary has some serious drawbacks.\nYou can call the API, passing any CI arguments with 1 line of code:\njs\nawait require('semantic-release')(require('minimist')(process.argv.slice(2)));\n\nIt's duplicated code with a brittle coupling to the version of semantic-release from which it was lifted.\n\nIt's not really a duplication of code. The coupling is no more brittle with one solution or the other, as a change in the API will come with a change in the CLI and vice-versa. It would be a breaking change in both case.\nIn addition this solution allow to customize more if you choose to:\n- You can restrict some options\n- You can parse options passed to your CLI in any custom way in order to make some validations\n- You can display a custom help message\n\nIf passing --analyze-commits=\"alternative-analyze-commits\" instead was mapped into { path: \"alternative-analyze-commits\" }, any additional plugin options defined in package.json would be merged into that object.\n\nI imagine that would be a problem for plugin that can be defined as an Array? Or at least it would incur a lot of complexity to handle those cases.\nIn addition that would allow to create inconsistencies. If the configuration set analyzer-1 as the analyzeCommits plugin and sets options specific to this plugin. If you call the CLI with --analyze-commits=\"analyzer-2\" you will end up passing to analyzer-2 an option that is meant to analyzer-1, which probably not what a user want to do.\nOverriding the entire value of analyzeCommits when using --analyze-commits=\"analyzer-2\" is the expected behavior. This is because the intent of the CLI options is to enable/disable plugins, and that mean overriding the entire value so it works for plugins defined as Array.\npublish: [\"publish-1\", \"publish-2\", \"publish-3\"] has to become publish: [\"publish-1\", \"publish-2\"] when we pass the options --publish=publish-1,publish-2.\nIf you want to use semantic-release with a predefined set of plugins and options you have 2 choices:\n1. Use the API with the one liner I provided\n2. Use a shareable config module once a good solution is found for #549 and it's implemented\nThe CLI options to choose the plugin are there mostly for historical reasons. When those options where introduced there was only a limited number of plugins and none of them had options.\nWe kept those options as a convenience to only enable/disable plugins.\nThe JS API has been added in v9.0.0 to allow the integration use case, as the number of plugin and option grew.\n. > Looking forward to this then! \ud83d\ude04\nShould wee close this issue and follow up in #549? Feedback welcome regarding the proposal I made over in #549.. An error occurred while running semantic-release: 'Forbidden\\n' means that one of the plugin threw an error with 'Forbidden\\n' as a message.\nLooking at the logs, it seems it's the npm plugin during the verifyConditions phase. When a problem happen while running the npm CLI the plugin throw an error and set the message with the stdout of the npm CLI.\nSo something happen when we ran npm whoami and the only thing the npm CLI wrote in stderr is 'Forbidden\\n'...\n. > It also logs that it loads the same plugins multiple times? I guess that is unrelated?\nYes it's unrelated. The log appear for each time we load a plugin. IF we use the npm plugin for verifyConditions and for publish it will appear twice in the logs.\nNot sure if we should consider that the normal behavior or not. For now all plugins (verifyConditions, publish, generateNotes etc..) are independent and semantic-release doesn't know that some might be implemented in the same npm package.. Yep!. Here is an example to what could be done with shareable configs: https://github.com/shroudedcode/semantic-release-apm/issues/4#issuecomment-353409057\nIdeally when that is merge we could create an apm-config that would serve as an example. It would include:\n- the config itself\n- unit test of the config (using the verifyConditions) of each plugin\n- integration tests with a release end to end\nWe might also consider making public the semantic-release API to load the config and run the verifyConditions pipeline. That would make shareable config unit test a lot easier.. I had to do some more changes since your reviewed, in order to support loading plugins defined in a shareable config from that context.\nThat will allow to have shareable config, defining the plugin they depends on in dependencies so they don't have to be added to the package.json of the user using the shareable config.. This doesn't seem related to semantic-release at all. You should ask within your organization, on an Artifactory forum or on Stack Overflow.. After doing some test the --merge option has been added in git 2.7.0, which is a quite old version. The last one is 2.15.1.\nAccording to Circle CI docs the git version installed is 2.14.2.\nCan you check which version of git is running on your Circle CI build with git --version?. On regular Circle CI builds it seems git 2.14.2 is installed: https://circleci.com/gh/pvdlg/test-circleci/42\nI'm re-opening as it's important to find a solution that works on all CI, including the one with very old git CLI. CircleCI should update their images to march their docs, but it's possible other CIs out there provide only an old version of git. git 2.7.0 is \"only\" 2 years old after all.\n. The problem happens with Circle CI 2.0 and their docker images as it comes with a very old git. Surprisingly with Circle CI 1.0, the git version installed is recent (2.14.2).\nIt would be a good idea to open an issue/PR with circleci-images to update git to the version they mention in their docs. Would you take care of that?\nI found a good workaround in semantic-release/git#6 to avoid using the --merge option of git tag so we might want to use so we won't have the problem anymore, whether CircleCi update their image or not.. > Alright they're not going to update it circleci/circleci-images#128 (comment)\n: ( It was worth trying!\nI released semantic-release/git#6 so it should work with git 2.1.4 now. Thanks for the heads up. It's fixed now and a new version has been released . Thanks for the proposal!\nA migration guide is generally a good idea, however in this case the migration will be very in easy in most cases:\nFor users using the default settings (the very large majority):\n- semantic-release pre && npm shrinkwrap && semantic-release post => semantic-release in package.json scripts\nFor users using custom plugins:\n- Make sure the plugins are updated\nFor users with a non officially supported configuration or workaround (i.e stuff that rely on exit code, semantic-release running in the non expected Travis step, wrapping scripts etc...):\n- All the breaking change entries in the release notes are relevant and it's not really possible to identify all the possible cases. Plus they are not supported in the first place....\nDo you think it would be sufficient to add a Migration section to each release note with something like that \ud83d\udc47?\n\nIf you are using semantic-release with the default configuration created by semantic-release-cli setup, please update your package.json scripts from semantic-release pre && npm shrinkwrap && semantic-release post => semantic-release\nIf you are using a custom plugin, please make sure with the its author that its updated for the new semantic-release version\n\n. I added a short Migration guide to the  v9.0.0 and v11.0.0 releases.\nPlease re-open if you'd like a to add something to the releases description or a more detail documentation. PR welcome for a documentation!. Ooops...Thanks for catching that up!\nIt's fixed now!. > I\u2019ve never seen a dist tag called unstable. Maybe just leave it at \"Usually named next?\nI think unstable is kind of the naming convention in the Linux world, mostly because Debian name future releases like that. But mentioning only next probably make more sense.\n\nI wonder if instead of \"channel\" we should call it \"npm-dist-tag\", to make it super clear what it is?\n\nThe objective was to use a generic name that is not attached to a specific package manager like npm, as we want to support any type of release target, not only npm. Channel is the generic term used by Google for this type of distribution: https://support.google.com/chromebook/answer/1086915?hl=en\n\nI think it\u2019s more common to call them 1.x and 2.x branches\n\nBoth works, as long it's a valid semver range it will be detected as a LTS branch. I'll make it more clear in the doc.\n\nWhen I push to the 4.0.0-beta branch and it releases a 4.0.0-beta version to npm, what happens with the GitHub release notes? I think there would be a conflict with the branch 4.0.0-beta as the release would need a git tag with the same name, I think that is not possible, but I haven\u2019t checked it.\n\nThe tag will be 4.0.0-beta.X where X is the iteration: 4.0.0-beta.0, 4.0.0-beta.1, 4.0.0-beta.2 etc... But that's a good feedback, I'll make sure we'll never end up with tag/branch conflict.\n\nI\u2019m also not sure if releasing these pre versions to @latest is the right approach? Because if I do npm install my-pkg I get my-pakg@4.0.0-beta if it\u2019s released to latest, I\u2019m not sure if that is the intent? Shouldn\u2019t these rathe be relesed to @beta release channel instead?\n\nAs far as I understand if you do npm install my-pkg you will not get my-pakg@4.0.0-beta, you will get the highest non pre-release version available on @latest. I'll test to make sure.\n. @schickling thanks for the feedback!\nActually I don't really understand how to workflow you are describing could currently works. Let's say you have a version 1.0.0 released on npm which correspond to the sate of the master branch. The 1.0.0 has been made available on the @latest dist-tag.\nThen you create a dev branch (step 1), set the config (step 2) and push a feature commit on it. That will trigger a 1.1.0 release that will be available only on the @next dist-tag. Then you change the config and merge to master (step 3). That will trigger a release process from master that will attempt to release 1.1.0 and make it available on @latest, but that would fail as 1.1.0 already exists.\nCan you clarify how you make that works? Is what you are trying to achieve is to make the code that only on dev available to only early adopters?\n. Ah ok, I think I understand better now. The workflow is:\n- push on dev => release a beta version available only @next\n- push on master (by merging from dev) => release a normal version available on @latest dist-tag\nThat's not currently possible as we don't have a way to make pre-release (i.e. 1.1.0-beta.1) in semantic-release currently. The new feature would allow to do that with a pre-release branch.\nWhat you can do now is something similar to what we do in the semantic-release repo:\n- Only one branch master (named caribou for this particular repo) \n- Push to master => release a normal version available on @next dist-tag\n- When we want to promote a release (make it available for everyone) we make it available on @latest with npm dist-tag add semantic-release@<version to promote> latest\n. In your example the order of the 2 breaking changes would dependents on what you merge and when and how you configure your branches.\nIf you have a master and a 4.0.0-beta branches and the last release done from master is 3.1.1:\n- Pushing a breaking change on 4.0.0-beta would release 4.0.0-beta.1 on the beta dist-tag\n- Pushing another breaking change on 4.0.0-beta would release 4.0.0-beta.2 on the beta dist-tag\n- Merging 4.0.0-beta would release 4.0.0 including the 2 breaking change on the latest dist-tag\nIf you have a master and 4.0.0-beta branches and the last release done from master is 3.1.1:\n- Pushing a breaking change on 4.0.0-beta would release 4.0.0-beta.1 on the beta dist-tag\n- Merging 4.0.0-beta would release 4.0.0 including the breaking change  on the latest dist-tag\n- Pushing another breaking change on 4.0.0-beta would be invalid as each branch need to have non overlapping range (so you can't have master and 4.0.0-beta having the same range)\nThe idea of pre-release is that it doesn't respect semver, per semver specification :)\nWhatever you push on the pre-release branch only the last digit increase (4.0.0-beta.1, 4.0.0-beta.2, 4.0.0-beta.3 etc).\nThat allow to \"group\" breaking changes without making a major release. Once you merge to master, the not semver rules applies: breaking change => major release and as it is the case currently multiple breaking released at once create only one major increase.\nThat also mean that a pre-release branch has a lifetime limited to the development cycle of a new version (in that case 4.0.0).\nAs a side note the \"future branch\" works differently as they defined for a release type and not a release version. So for example a branch defined as:\n{\n  \"branch\": \"next\",\n  \"type\": \"major\n}\nWill accept release range that depends on the releases existing on the previous branch in the config.\nIf the previous branch is master and the last release there is 3.1.1 then next will accept only commits that trigger a release in the range 4.x.x. If the type was minor then it would accept only commits that trigger a release in the range 3.x.x. If the type was minor then it would accept only commits that trigger a release in the range 3.1.x.\n\"Future branches\" are long-lived in the sense their configuration will never have to be changed.\nThe type property indicated what type of changes are allowed there.\nThe \"pre-release branches\", as mentioned before, live from the beginning to the end of the dev cycle for a given version.\n. The format 4.0.0-beta is only for pre-release branch. That's the format defined by semver.\nWhat I called \"Future branch\" is what is described in semantic-release/evolution#1.\nI'm not sure I understand your example especially regarding feature branches. A feature (like a branch on whci your develop a feature and open a PR) will never trigger a release. The release will happens when you merge your PR to a release branch.\nBasically if you push to master or if you merge a PR into master it's the same thing for semantic-release.\n\ni'm not sure i fully understand the limitation based on type. is that an upper bound or a strict limit? even for branches that would end up in a major bump, i would still want to allow some commits that dont include breaking changes. would those be prevented?\n\nThe type defines the type of release allowed on this branch. That allow to do something like:\n- master => only fix and feat\n- next => fix, feat and breaking change\nThat allow to do a workflow like that: https://github.com/sass/sass/blob/stable/CONTRIBUTING.md#branches\nYou have a lot more details an example there: https://github.com/semantic-release/evolution/blob/release-workflows/_drafts/release-workflows.md#future-branches-configuration\n. Just to be sure we are using the same vocabulary:\n- pre-release: release version formatted as specified by SemVer (x.y.z-preid.N, for example 4.0.0-beta.1)\n- Future release: Release done on a dist-tag. Follow the normal SemVer (x.y.z)\n\ni would want the alpha/beta/etc style release to be opt-in and not for every branch.\n\nEverything is always opt-in. semantic-release runs only on branches that are part of the config.\n\nmost of my feature branches have a short life and dont need a pre-release before being merged into master and getting released as latest\n\nIf you don't add them to the semantic-release config this is exactly what's going to happen.\n\nbut there are times where these branches are more complex and live long enough or are disruptive enough to benefit from a pre-release.\n\nFor those ones you will have to add them to the config as a \"Pre-release branch\"\nRegarding the two example you gave, I think they are fairly common and they should be support. If you want to create a branch from which you want to do pre-releases you will have to add to the semantic-release config (as semantic-release needs to know you want to make releases from there).\nIf you want to make pre-releases you have to give semantic-release the version from which to start (like 4.0.0) because I don't see a way to determine that automatically. Also in a SemVer pre-release the version part is mandatory (4.0.0-beta.1 is valid while beta.1 is not).\nSo in order to do what you mention in your examples:\n1. Create a branch side-project from master\n2. Update the semantic-release config to add the side-project branch and set the prerelease property 4.0.0-side-project\n3. Every fix, feat, perf or BREAKING CHANGE on side-project will trigger a pre-release (4.0.0-side-project.1, then 4.0.0-side-project.2, then 4.0.0-side-project.3 etc... )\n4. Once you merge to master the normal process will happen, each commit is evaluated and a release is done based on the last release (if the last release is 1.0.0 then we'll increase it based on the commit added, so it might be 1.1.0 or 2.0.0)\nAs you can see in that example, the fact the pre-release branch specifies 4.0.0 is irrelevant and appear to be useless. But it's required by the SemVer spec, and you be able to publish on npm if the version number isn't valid. Unfortunately I don't think there is a way for semantic-release to guess or make up a version number. It also has the advantage to communicate intent to your users, for example 4.0.0-beta.1 should contains all the code released in 3.x.x (semantic-release will check that btw).\n. > sorry if it created a bunch of noise to get here\nI don't think it's noise at all. It really helps to figure out the in and outs of this feature and all the scenario to test. This is exactly what this issue is made for. So no worries.\n\nso with all of that said, if a project does manage to be disciplined enough to stay focused on limiting to intentional breaking changes that would bump from 3,x.x to 4.0.0 to a single pre-release branch, what happens if 4.0.0-beta.1 and 4.0.0-beta.2 have already been released in that branch but a breaking change slips through to master before that pre-release is ready for promotion to latest?\n\nThe breaking change on master will trigger a 4.0.0 release.\nThe fact that master now have commits ahead of side-project will prevent you to merge side-project into master (that's git doing that). You will have to merge master into side-project.\nThen on side-project each commit will continue to trigger versions like 4.0.0-beta.3, 4.0.0-beta.4 etc... Here semantic-release could errors out and tell you that side-project is behind master, but I'm not really sure it's a good, as you might legitimate case in which you want to do that.\nWhat's tricky here is that pre-release version live in their own \"continuity\", they don't respect the semver rules of regular version. Basically in pre-releases the version part is purely indicative and no rules (by semver or semantic-release) are applied on it.\nTo put in other terms, with regular releases, the version 3.1.1 guarantees the it contains all the code from all the release with a version number inferior. Btw, even when you revert a commit, the versioning move forward not backward, so in terms of releasing a revert is considered like a regular commit and it appears in the commit history log (it just happens to make the exact opposite change of another commit).\nWith pre-release version, nothing of that true. Or to be more precise nothing of that is enforced. You can release any version with any type of commit inside. They are made unique by using the last digit but that's it. It might be clever to release pre-releases with a number higher that the last stable release but it's not enforced because 4.0.0-beta.1 => major release => 4.0.0-beta.2 (and not 5.0.0-beta.1).\nBasically pre-release branches are used in that situation:\n- I want to make a release on every push (so a non-release branch is not an option)\n- But I don't want to increment versions normally because I'm going to do a bunch of breaking change and I don't want to end up with version 9999999999.0.0 (so a \"Future branch\" which increment versions normally and  releases on a dist-tag is not an options)\n. > this is the part that i keep coming back to. i agree that they should live on their own until merged to master, but the requirement to decide the #.#.# when starting the series of pre-releases limits that ability in my mind. still a shortcoming of semver itself, not of this proposal\nThis is why with this proposal you have two way to handle release that you don't want to be available to everyone:\n- Future branch, that have normal semver and release to a dist-tag. Version number is increased normally.\n- Pre-release branches that use a pre-release semver and also release to a dist-tag. Version number is not increased normally (only the last digit).\nIf you want to increase the x in x.y.z when you push a breaking change, then you should use a \"Future branch\" not a \"Pre-release\" one.\n\nthe idea of including the version number but ignoring it is at least a way around the limitation so that the feature name could be treated as the meaningful part. i suppose alpha or beta could still be included as well to communicate the stability.\n\nTo be valid a pre-release semver be formatted like <version-<preid>.N>. All the 3 parts are mandatory. In your example the preid is beta or alpha and it's mandatory.\nThe version is completely ignored. It doesn't participate in any semantic-release rule, but it's still there as its the one published (and for which a git tag is created)\n\nyou mention that a future release is done on a dist-tag. would a pre-release be published to the latest channel? i would not have expected that if thats the case. i would only expect it to hit latest after it is no longer a pre-release.\n\nBoth are done in a dist-tag. In case of a pre-release, if the dist-tag is not specified the preid (i.e. beta in 4.0.0-beta) will be used.\n. > if i have a pre-release of 4.0.0-some-feature-alpha.7 and want to promote it to 4.0.0-some-feature-beta.1 what steps would i use? since semantic release ignores the version and preid, i realize there wouldnt be provided process, but what would the manual steps be? is it as simple as renaming the branch?\nTo support this workflow you would have the branches 4.0.0-some-feature-alpha and 4.0.0-some-feature-beta. Once you merge 4.0.0-some-feature-alpha into 4.0.0-some-feature-beta, semantic-release will run on 4.0.0-some-feature-beta and make the release `4.0.0-some-feature-beta.<last_release + 1>.\n\nif i have two future branches in addition to master with activity, do publishes on each impact the others since the version is incremented normally for each? i see that stalled branches are expected to be updated with changes from master, but the reverse can't be true if the changes aren't ready for promotion. is this type of a scenario simply a reason not to use future branches when these things are possible?\n\nWith \"Future branches\" you have a lot more rules that are verified, especially each one need to:\n- Each one has to define a type, which defined the release gap allowed with  the previous branch\n- The version range allowed on Future branches cannot overlap\nFor example you can define something like:\n- master => only patch release on dist-tag latest\n- features => only patch and minor releases on dist-tag latest\n- major => patch, minor, major releases on dist-tag next\nPushing a commit on one branch doesn't have a direct impact other than what git already does: for merging features into master, features must have all the master commits.\nSo if you push a fix to master and you already have a few feats on features, in order to merge features into master you need to update features with the fix commit.\nNormally that should avoid inconsistent situations (by verifying the releases are consistent with the git history).\n. The code is 99% completed and can be found in the multi-branches branch. You should be able to start experimenting with it.\nI have to finish writing the doc though which takes quite some time... . The branch is badly outdated and I have to rebase it.\nA PR will be opened and the code published to dist-tag when it's ready enough to test. I don't know when that will be.. Fixed by #991 . This feature as been implemented in version 16.0.0-beta.X and released on the @beta dist-tag.\nSo far we didn't had any bug reports on 16.0.0-beta.X. Before moving it to the @next dist-tag, and later @latest, that would be great to have some feedback from real-life usage.\nIf you have tested or used 16.0.0-beta.X and made successful releases, please add a comment to this thread so we can get an idea of how much it was tested and feel confident moving forward with the general release. Please add any details you see fit (plugins used, type of releases, link to the repo etc...).\nIf you experienced an issue, please open an issue on the GitHub tracker, so we can fix it while we are still in beta.\nIf you have questions or other feedback, please start a thread  on https://spectrum.chat/semantic-release.\nThanks!. @appsolutegeek I think the problem is the branch 1.16.x doesn't exists on your remote repo.\nFor several reasons we have to get the list of branches in your repo from origin. So this is expected.\nIf you still encounter the issue while having the branch on origin, please open a new issue.. @gr2m the issue with the @latest in the comment has been fixed in v16.0.0-beta.4.\nThe issue didn't received a comment because it was opened when semantic-release ran: https://travis-ci.org/octokit/rest.js/jobs/467622755#L765.\nThis is something on GitHub side. When a PR has a fix #xx in the description and get merged it should close the referenced issue. I noticed recently that often GitHub does not close the issue.. @gr2m, re https://github.com/semantic-release/semantic-release/issues/563#issuecomment-447679389\nIt turns out GitHub does not close issues solved by a PR unless this PR is merged to the default branch. With https://github.com/semantic-release/github/pull/146 we will now comment in this case.\nI think GitHub should close the issue when the PR get merged to any protected branch, rather than just the default one. Worst case a GitHub app can do that.. The undefined in the message should be solved in https://github.com/semantic-release/semantic-release/pull/1043.\nHowever you should have had the message The local branch beta is behind the remote one, therefore a new version won't be published. and the build should have not failed. I don't understand why it didn't work...\nThat would be helpful to have debug messages. I think that would be a great idea to always enable --debug or DEBUG=semantic-release:* for anyone testing the beta.. It's the same issue as https://github.com/semantic-release/semantic-release/issues/563#issuecomment-448403202. When this error occurs we call isBranchUpToDate to check if it's due the local branch being behind or to another problem.\nThe error ! [rejected]        HEAD -> beta (non-fast-forward) indicate the local branch is behind the remote one, so isBranchUpToDate should return false and semantic-release should exit with false. However it seems isBranchUpToDate returns true in that case but I don't know why.\nHaving the debug logs would be helpful.. Yes that's the intended behavior. That allows you when working on a pre-release to make as many fix, feature or breaking change without incrementing the version.\nOnce you merge the pre-release branch to a regular branch then normal version will be released.. Looking at the Gitlab doc for release it seems Gitlab doesn't have something similar to Github releases. Instead it seems the recommended way is to create a git tag with the release note as the body of the commit associated with the tag. This is exactly what the git plugin does.\nTherefore, is there really a need for a specific Gitlab plugin ? Or should we just write a recipe explaining how to configure the git plugin for Gitlab?\nThe configuration could be something like that:\njson\n{\n  \"release\": {\n    \"verifyConditions\": [ \"@semantic-release/changelog\",  \"@semantic-release/git\"],\n    \"getLastRelease\": \"@semantic-release/git\",\n    \"publish\": [\"@semantic-release/changelog\", \"@semantic-release/git\"]\n  }\n}\nOr with npm:\njson\n{\n  \"release\": {\n    \"verifyConditions\": [ \"@semantic-release/changelog\", \"@semantic-release/npm\", \"@semantic-release/git\"],\n    \"getLastRelease\": \"@semantic-release/git\",\n    \"publish\": [\"@semantic-release/changelog\", \"@semantic-release/npm\", \"@semantic-release/git\"]\n  }\n}\nWith the environment variable GIT_CREDENTIALS set with a Gitlab personal token value.\nAs Travis is not compatible with Gitlab, that would be possible once #578 lands.\n@destroyerofbuilds, @johann-sonntagbauer as you know Gitlab better, would that works?. The repository URL is retrieve here, and its used Git plugin and in Release note generator plugin. Both plugins accept Gitlab URLs (and include unit tests verifying that).\nSo it should work then.\nDo you have by any chance a repo handy on which you could test that config after #578 lands?\nDo not hesitate to ping me for help with the semantic-release and plugin config.\nIf it works as expected, we can change this issue to \"Write a recipe for Gitlab\" and link your test repo here to help write the doc.\n. After some tests it turns out the GitLab release description is not the same as the tag message.\nThe release message can be set only by API for now. See https://gitlab.com/gitlab-org/gitlab-ce/issues/20587\nI when ahead and created a GitLab plugin and shareable config.\nI also add a GilLab CI recipe in #583\n. Would a GitLab user could try out the plugin and shareable config?\nNo one is really experience with GitLab in the team, so that would be great if we could get feedback from an experienced user.\nThanks!. Awesome! Let us know how it goes.\nDo you need to have the plugin available on npm? OR can you just reference it in your package.json with \"semantic-release/gitlab#initial-release\" ?. We now have:\n- GitLab plugin\n- GitLab shareable config\n- GitLab CI recipe\nSo semantic-release should officially support GitLab!\nAs usual, feedback always welcome!\n  . Fixed by #593. That's the intended behavior. \"Expected\" errors reported with SemanticReleaseError are logged and exit the process with 0. Unexpected errors reported with Error are logged and exit the process with 1.\nUnexpected errors are code issues, network problems or errors in the underlying dependencies.\nExpected errors cover configuration issues and various situation in which no release has to be performed.\nIdeally (in a future version) those expected errors should be reported to the users in a more direct way such has opening an issue or sending a notification of some sort, in addition of being logged.\nThe reason for this behavior is to not fail the build when a release cannot be performed. In such case the user should be made aware but not releasing is not a reason to break a build (like failing test would).\nWe recommend to use semantic-release in the after_success step in Travis whether we return 0 or 1 doesn't matter in that case. But not all CI have an after_success step.\n. This actually a much broader subject than that, which involve future user reporting, potential Github application, management of multiple branches and dist-tag with reporting/prevention of some inconstant cases.\nA lot of the current implementation has historic roots (such as using SemanticReleaseError).\nThis is the exception/error situation we/we'll have to handle:\n1. Coding error in a plugin or wrong output\n2. Unexpected Error in a dependency\n3. Exceptional case for which the user doesn't need to be alerted (like no release to be done)\n4. Exceptional cases for which the user has to be alerted (i.e. the commit xyz create an incoherent state of your branching/release system or a misconfiguration)\nThe current implementation doesn't handle that level or granularity very well. It works for now as we don't need to distinguish 3 and 4 and just log. Once we have a better reporting system we'll have to figure out a better implementation to handle 3 and 4.\nIn addition of that there is the question of what should (if anything) break the build.\nA case like a misconfiguration for example is really debatable. Should we fail the build or should we let the build succeed and open an issue to alert the user?\nIf you have a very active project and a maintainer decide to try out semantic-release and make a misconfiguration, it's probably better to alert via an issue or some other means rather than breaking all the builds for everyone.\nIf your private npm is down, should we report that to users via an issue or a notification or should we fail every builds, prevent PR to be merged, trigger the same alerts that are triggered when a unit test fail and basically indicate \"your code is broken\" while it's not?\nThose type of questions are related to the bigger question of the relationship between CI and release management. Some might want the release to be part of the CI: if the release fails then the CI build fails, similarly to when a unit test fails. Some might see it as something that comes after the CI: if the release fails it doesn't mean my code is broken like a failed unit test would.\nYour strong disagreement is understandable, but there is also some reasons for the current implementation, mainly to be less disruptive in order to, among other things, encourage adoption.\nSo the current approach is: \"If we have what we need to make a release and we are sure one has to be made, we'll do it for you. If not we'll let you know (via log for now) and don't break anything in your workflow\".\nIt's a fait point though that the user can (in some cases that depends on the CI platform) use test or after_sucess step to decide if a failed release should fail the build. Still remains the question of what qualify as a failed release.\nLong story short: yes error management has to be improved, but it's complex and the solution has to encompass future semantic-release features.\nOn a side note allow_failures would allow failures on the whole CI job, not only on the semantic-release call. And after_success is available on Travis but not necessary on every CI solutions (especially private/corporate ones).\n. The big problem for now is that the travis plugin throw errors that shouldn't fail the build (like if we are on a PR or we are not running on the build leader).\nSome of the changes in #563 will make that easier, so I'll tackle the error management just after that.\nThe objective is to have any actual error to throw 1 as requested in this issue.\n. I'd rather not for 2 reasons:\n1. In a future feature I'd like to report SemanticReleaseError to the user via opening issues. While Error will just fail the build as they do now.\n2. That would involve changing all the plugins, including third-parties ones. And change them again once we want to report functional errors to the users via issues\nAfter #563 the only thing that should be left in the conditions-travis should be to check that we run on the last job. We'll be able to move that somewhere else or to make a few changes to report the fact that we are not on the build leader via another mean than SemanticReleaseError. > Why would it require changing all the plugins?\nBecause currently all the plugins return SemanticReleaseError for config error, invalid tokens etc.\n\nMaybe give it a boolean property like expected then?\n\nThe idea would be instead to have the travis plugin to return false instead of throwing a SemanticReleaseError. Or maybe to handle that outside of semantic-releasse by running on Travis (for cases without Build Stages) something like $ travis-deploy-once && semantic-release.\nBut I'd rather tackle that just after #563. #563 is well on its way with changes on every plugins. Doing what you are proposing in this issue (basically all failures return 1) would be much easier then.\n. Every plugin currently returns SemanticReleaseError when a config/authorization error happen. Basically all errors for which the user is responsible. All this errors will be reported to the user at some point in the future (\"Please fix the config\", \"Please setup the auth\", etc..).\nThere is one exception: condition-travis which returns SemanticReleaseError when we run on a PR build or on a job which is not the build leader. Those errors should not fail the build nor bother the user.\nIn this specific situation it's fine to return false because it's not an error and there is nothing more to report. That's part of it works. We can log in order to help debugging but there is nothing else to report. Returning false means modifying the way the verifyingCondition plugin works though.\nIn conclusion, this is the condition-travis plugin that prevent to modify the core to just return 1 on SemanticReleaseError.\nAs mentioned before after #563 is done, that would be much easier to solve the real root cause of the problem the condition-travis plugin.\n. > There is also the ENOCHANGE error, right?\nThat's part of the core so it's easier. It will be handled as part of #563. No analyzeCommits was done in a \"smarter\" way and allow to return a falsy value when no release has to be done. this is the code that get the falsy value and throw  ENOCHANGE.. In your config it seems your are trying to publish with the git, github and npm plugin. You are configuring assets in the npm plugin which is not an option that exists for this plugin.\nCan you clarify what you are trying to publish where ?\nAre you trying to commit the content the of dist ? Or only build the tarball with dist as the root?\nI didn't check but running semantic-release from dist should work: cd dist && npm run semantic-release\n. In your  circle configconfig.yml just call cd dist && npm run semantic-release. If you want to install semantic-release globally do npm i -g semantic-release and not npm i -g semantic-release-cli. semantic-release-cli is used to set up the configuration.. > cd dist && npm run semantic-release doesn't work @pvdlg.\nI just tried locally and it works for me. Can add more details? What do you meant exactly by \"doesn't work\"? Can you provide the error message or a link or your build?. In your package.json:\njson\n\"devDependencies\": {\n  \"semantic-release\": \"^11.0.0\"\n},\n\"script\": {\n  \"semantic-release\": \"semantic-release\"\n}\nIn your Circle config:\nyaml\n- run:\n  command: cd dist && npm run semantic-release\nMake sure the dist directory exists before cd dist && npm run semantic-release is executed.\nAlso make sure, that if there is a package.json in the dist directory it contains the depency to semantic-release and the script definition.\n. > Seems like you would need to run cd dist && ../node_modules/.bin/semantic-release pre && ....\nI don't see why. npm or yarn can run scripts defined in a package.json from a parent directory.. @blakedietz\nNo it's installed locally.\nI'm running exactly the config from https://github.com/semantic-release/semantic-release/issues/570#issuecomment-352621488\nIf you use yarn I remember there was an issue with older version of semantic-release. You should use^11.0.0 in your package.json as mentioned above.\n. @blakedietz,\na few unrelated problems in your config:\n- You are setting some plugins in verifyConditions but not for publish and getLastRelease so it doesn't make sense as those plugin won't be used. verifyConditions just verify that everything is ok for this plugins to be used in publish and getLastRelease\n- run: echo \"//registry.npmjs.org/:_authToken=$NPM_TOKEN\" >> ~/.npmrc is unnecessary as it's already done by the npm plugin\n- You might want to configure you devDependencies to \"semantic-release\": \"^11.0.2\" instead of \"semantic-release\": \"11.0.2\" so you will get semantic-release fixes and non breaking features automatically\n- \"@semantic-release/npm\": \"2.3.1\" and \"@semantic-release/github\": \"2.2.3\" are unnecessary as they are already dependencies of semantic-release \n- run: cd build && ../node_modules/.bin/semantic-release can be replaced by run: cd build && npm run semantic-release so the package.json in your build directory (the one published) will be used. > due to the same reasons that I had mentioned earlier.\nOk, good to know. Somehow locally for me, npm is capable of running the script has expected from a sub-directory. Don't know what the different is. Anyway if it works, all good!. Have you check the documentation in the README.md of each plugin? Everything should be there.\nIf the doc is not clear let us know.\nThe error you have is because you use the changelog plugin to create/update a CHANGELOG.md file and the git plugin to commit it. But you create it in a directory that is in the .gitignore so when doing the commit, there is an error because there is nothing to commit.. > I'm assuming that this is because semantic-release is still trying to create a release commit in this ignored directory? So it seems that the Git part of SR needs to be run in my root, but the NPM part of SR needs to run inside my dist which is ignored.\nYes. If you don't need to push a commit then, just don't use the git plugin.\nIf you use the github plugin it will create a Github Release with the changelog.\n\nIs tracking my dist the most simple solution?\n\nProbably not. The simple solution is to not package from a subdirectory. Doing create a lot of complexity (besides semantic-release). It forces you to copy your package.json, README.md, CHANGELOG.md etc... in the dist directory. In addition I imagine it forces to to take in account the different paths when you require in your JS files.\nThe more common way to handle that is to specify in your package.json what you want to include in the release with the files property.\nYou can find more details in this blog post: log.npmjs.org/post/165769683050/publishing-what-you-mean-to-publish\n. Thanks for the positive attitude :) Much appreciated!\nI'm going to spend a bit more time to figure out if it's possible to add a new option to the npm plugin to do the packaging from a sub-directory.\nI'm not really sure how npm works in such case (does it use the package.json at the repo root, or the one on the sub-directory? What about npm-shrinkwrap.json? Does it includes the CHANGELOG.md and README.md at the root? Does it interpret the .npmignore and files property relative to the repo root or to the sub-directory? etc... ).\n. @benjamincharity is semantic-release/npm#23 helps to solve your use case better?. Can you update to semantic-release version 11.0.2 ? That should give you more detailed logs.\nYou can use 2FA for your npm account, but you have to make sure to use a deploy token: https://npme.npmjs.com/docs/workflow/travis.html.. If you use v11.0.0, your should do semantic-release instead of semantic-release pre && npm publish && semantic-release post. This has changed recently.\nYou need to create a token with the npm CLI:npm token create, and add it to Travis environment variable with the name NPM_TOKEN.\nAlso I'm not sure if npm install --no-save semantic-release-tamia has an impact....\n. @sapegin Should we close this issue in favor semantic-release/npm#11?\nI also created semantic-release/npm#30 in order to improve the npm plugin doc regarding 2FA.. Thanks very much. That's a great idea!. There is a lot of comment on this PR, many (from me) that are not relevant anymore. Unfortunately Github doesn't allow to remove a single change request in a review.... \nSo I dismissed my review and created a new one with only the actual changes requested. There should be 7. All other comments can be ignored. Hopefully that helps.... @felixfbecker would you like to update this PR with the changes requested and adapt it to fit in the new doc?  I can also cherry pick your commit and make the changes (that you can review).\nLet me know.. Thanks for updating the PR!\nI added some comments, mostly related to consistency with other docs and to the scope of what semantic-release recipes are (focused on the semantic-release config, not on the CI best practices, advices or opinions).\nRegarding the PHP / Composer the Travis and semantic-release configuration doesn't seems different than the one in the Build Stage recipe. It seems to be really more about PHP / Composer than specific to semantic-release. I would prefer to write a more generic section in the Build Stage recipe for Non Javascript project similar to travis.md#non-javascript-projects-configuration. This section can re-use the PHP / Composer example the same way travis.md#non-javascript-projects-configuration uses Go examples. \n. Per this comment I opened #659.\n@felixfbecker you have a lot of knowledge regarding CI workflows and that can be really beneficial for the overall developer community. We think the best way to share it is outside the semantic-release documentation though. \nWe try to keep the semantic-release official documentation focused on semantic-release only and stay away from general recommendations, best practices and opinionated configs.\nCI workflows and semantic-release are intrinsically related but we don't want to be responsible for hosting and maintaining recommendations or best practices and becoming a forum about pros/cons of specifics CI config/practices.\nIf you'd like to provide advices, best practices, opinionated config and more specific scenario,  feel free to create blog posts or articles and we'll happily add them to resources and promote them on Twitter or other channels.\n. Thanks for the feedback and suggestion. Could you just clarify if what you are trying to achieve works and if you are suggesting to add more examples to the doc, or if you are asking for help to make it work?\nMore generally, the parserOpts in analyzeCommits and generateNotes is there for convenience to allow you to make minor changes to a conventional-changelog preset.\nIf you want to achieve something more advanced the best option is to implement your own conventional-changelog preset. Here is an example I did a while ago (It's not really up to date but can be of some help): https://github.com/pvdlg/conventional-changelog-metahub.\nIf you name your preset module conventional-changelog-my-preset, then you can configure semantic-release as follow:\njson\n\"release\": {\n    \"analyzeCommits\": {\n      \"preset\": \"my-preset\",\n      \"releaseRules\": \"./config/release-rules.js\"\n    },\n    \"generateNotes\": {\n      \"preset\": \"my-preset\"\n    }\n  }\nTechnically you could do all of that in a release.config.js file, but it's probably easier to create a preset. In addition it makes it easier to re-use.\nThat said, we can add a Note in the README of both plugins, linking to the semantic-release README part mentioning the different config file type, explaining that it can allow to set regex or function property if necessary. But in most cases, creating a preset is the recommended way.\nPR welcomes for the doc additions!. Ah ok, thanks for clarification.\nJust a FYI, you can create your own preset by \"extending\" an existing one, this way you don't have to rewrite everything.\nIf you want to set a regexp option in a semantic-release config you have two options:\n- Use release.config.js instead of the release property inpackage.json\n- Create a shareable config (implemented in #553)\nrelease.config.js is not mentioned in most docs as it's a feature that has been implemented recently, after most docs were written.\nI'm not really sure where the problem is. Does that works the way you want when you use release.config.js? \n. The npm plugin was never intended to be used to retrieve the last release on a package manager other than the npm registry.\nYou can use the git plugin to retrieve the last release based on git tag.. The workaround changed by this PR is related to the npm plugin using the gitHead from the package metadata that is sometimes not present. If you want to implement a getLastRelease plugin you must return a version and a gitHead. If the package manager you are using doesn't provide a gitHead then you should use the git plugin.\nRelying on the workaround removed in this PR is effectively the same thing as using the git plugin: it uses the git tags to retrieve the last version.. No, in the sense that is what not intended not documented to work that way. Plugins are supposed to handle the specificities of the system they integrate with (like having a gitHead or not or other ways to retrieve the commit associated with the last release).. If your registry doesn't have a gitHead you have to use git tag.\nThe proper way to do that is to use the git plugin for the getLastRelease step and to make sure you have at least one publish plugin that creates the tag (with the git or github plugin for example).\nNo need for your plugin to use the git plugin as a dependency. Just use it for the getLastRelease step.\n. As most registry do not provide a way to get the commit sha associated with the last release, using a git tag is necessary. Git tags are a quite convenient to get the last release sha especially when you have multiple branches and distribution channels as the tag follow the commit (contrary to the gitHead in the registry that is not affected by branch merging on the git side).\nSo I don see much benefits to use anything else than the git tags to get the last release. The only constraint is the tag has to be created during the release process, but I don't see any scenario in which you don't want to create a tag.\nThis is why I propose here to always use create the git tag and to use it to retrieve the last release.. > The only benefit I could see is have multiple getLastRelease map to the publish plugins, so that if for example the npm publish succeeded, but the github publish failed, the github publish will be retried because its getLastRelease is lagging behind. That would make the system a bit more error tolerant. But that is not what is currently implemented anyway and would also add complexity.\nI don't think having multiple getLastRelease would solve that. The getLastRelease is called once before any publish. The code already allow any publish task to make a commit, as any subsequent publish will be called with the new gitHead (corresponding to the last commit made on the branch).\nAny retry mechanism can be implemented at the plugin level. There is actually retry mechanism already implemented an most API client. In this case it's not really something that we can identify a situation that require a retry. Basically if it's a network issue, the API client will take care of retrying, but getting a 404 indicate a functional error (like the commit doesn't exist on the remote).\n\nWouldn't you still want the tag creation to live in the git plugin though?\n\nAs proposed here it would be moved to the core.\n\nWhat if I want to make semantic-release work with Mercurial for example?\n\nThat would be quite complex because as of now, semantic-release is really tied to git. There is a lot code that runs the git command. The solution probably to implement all that in the core with a mechanism to detect if we are on a git or mercurial repo, and have all the function in git.js ported to Mercurial.\n\nOr use tag prefixes in a multi-package repo?\n\nThe multi-package is still in discussion. The solution will probably be to add a new option to the core that allow to define the git tag format. So you could define it like <package>@v<version> for monorepo or v<version> for regular repo, or pretty much any format that you like.\nMoving the getLastRelease step and the tag creation to the core would make that a lot easier as all the tag stuff will be handled in the same place. It would also simplify plugins and let them focus on the specific platform they integrate with (no need to deal with git stuff in plugins).\n. This is because we publish new version on the next dist-tag, and once a version has been tested enough we make it available on the latest dist-tag.\nSee https://docs.npmjs.com/cli/dist-tag\nThe current version on latest is 11.0.2. If you want to use the version from next you can specify in your package.json \"semantic-release\" : \"^11.1.0\".\n. Actually it should be travis-deploy-once@4 because the cli will be supported only in version >=4.\nGood idea. Maybe I can add https://github.com/yeoman/update-notifier to travis-deploy-once instead? And still mention travis-deploy-once@4 in the doc.. > I wonder if maybe instead of moving all the logic into core, we could replace @semantic-release/condition-travis with a generic @semantic-release/ci?\nDetecting the current branch will be required for #563 as we need to know on which branch we are to determine what to do (do a release, error out or move a release to a different dist-tag).\nRegarding the PR detection it doesn't have to be in the core for now, but putting it there has the advantage of allowing in the future to do specific things for PRs like log/inform the user of the version that would be released.\nIn addition plugins are better suited for optional things users can enable/disable and releasing from a PR (by disabling @semantic-release/ci) is not really something that would make sense. \n. Currently releasing from a local machine is not really supported. There might be a way to achieve currently but that would be very hacky.\nI think we should support local release in a better way (even if we mention it's not the recommended way).\nWe could do something like that when running outside a CI:\n```bash\n$ semantic-release\n=> Run a dry-run\n$ semantic-release --no-dry-run or $ semantic-release --local\n=> Do a release, ignoring the CI/PR checks\nOr something even better:bash\n$ semantic-release\n? This run was not triggered in a known CI environment. Do you want to run a dry-run or make a release?\n- dry-run (default)\n- release\n? We will release version x.y.z\n- Ok\n- Abort\n? The release note will be .....\n- Ok\n- Abort\n=> Do the release\n```\n. > let me know what you think about my other comments\nWhich comment are you referring to?. Good point.\nWhat if we recommend the following instead?\njson\n{\n  \"devDependencies\": {\n    \"semantic-release\": \"^12.0.0\",\n    \"travis-deploy-once\": \"^4.0.0\"\n  },\n  \"scripts\": {\n    \"semantic-release\": \"semantic-release\",\n    \"travis-deploy-once\": \"travis-deploy-once\"\n  }\n}\nyaml\nafter_success:\n  - npm run travis-deploy-once \"npm run semantic-release\"\n. Do you mean that the following should work?\njson\n{\n  \"devDependencies\": {\n    \"semantic-release\": \"^12.0.0\",\n    \"travis-deploy-once\": \"^4.0.0\"\n  },\n  \"scripts\": {\n    \"semantic-release\": \"semantic-release\"\n  }\n}\nyaml\nafter_success:\n  - travis-deploy-once \"npm run semantic-release\"\nEven if the case, some users might use this doc and adapt it to another CI that doesn't add ./node_modules/.bin to the path. I think it's not the standard behavior, [npx] was created among other thing to do that: npx#running-a-project-local-bin.. > I think it would be just as fine to just tell the user to add it to their devDeps with npm install --save-dev travis-deploy-once locally.\nYes but we still have to mention how to run it: either npm run travis-deploy-once \"npm run semantic-release\" or travis-deploy-once \"npm run semantic-release\".\nI think I'll go with the first option (npm run travis-deploy-once \"npm run semantic-release\" + \"travis-deploy-once\": \"travis-deploy-once\") as ./node_modules/.bin being in the PATH is not documented in the Travis doc, therefore it might not be guaranteed to work in the future.\n. > I think you need to separate arguments you want to pass to the travis-deploy-once binary using --. So the full script would be npm run travis-deploy-once -- \"npm run semantic-release\"\nI though so as well but after testing it works without the -- (at least on my local machine and on Travis).\n\nI wonder if we should just go ahead and create stages from the beginning instead of installing the additional travis-deploy-once dependency?\n\nAgreed, but maybe in a later step?\n- That would make the migration more complex\n- Build Stages are still in beta\n- I don't think Build Stages are supported on Travis pro and Enterprise\n. I agree that Build stages are the future and offer a lot of advantages and taht travis-deploy-once is somewhat \"hacky\". But at that point I think we've really made a lot of effort to remove dependencies to travis-deploy-once, give users more flexibility in their CI config and  promote Build Stages.\nWith version 12.0.0 you can use Build Stages freely, without any constraints, without travis-deploy-once, without any environment variable and build stages can be promoted via docs like in #573.\nBut I don't see any reasons to go on a crusade against users who do not use Build Stages yet as:\n- Build stages are still in beta and can change anytime\n- Build stages are not supported on Travis Pro and Enterprise (AFAIK)\n- A large part of the semantic-release user do not use Build Stage and is not familiar with it yet\n- Offering the possibility to use travis-deploy-once doesn't prevent to recommend Build Stages and to use them\nFo all those reasons, I would favor a smooth, step by step migration toward Build Stages, that doesn't break any current workflow in the short to mid-term:\n- Use travis-deploy-once locally installed with npm run in the 12.0.0 migration guide in the CLI  for now\n- Update docs with both travis-deploy-once and Build Stages, recommending Build stages, See #583\n- Release seamntic-release@12.0.0 on the @latest dist-tag in a few weeks and see how the migration goes for users\n- In a few weeks, update the CLI to use Build Stages if the users select Travis CI option and travis-deploy-once if they select Travis Pro or Travis Enterprise option\n- Remove travis-deploy-once from docs and CLI once it is out of beta and available on Travis Pro and Enterprise\n. Duplicate of #577. See https://github.com/semantic-release/semantic-release/issues/577#issuecomment-354334044. It seems the problem happen when we check for the existence of the tag on GitHub. If the tag doesn't exists the GitHub API is supposed to return a 404 status and not a 422.\nCan you enable the debug logs with the environment variable DEBUG set to semantic-release:* and re-run your build?. > Thanks, I'll manually recover by adding the tag to Git.\nThe is an error different than the 422 Unprocessable Entity you add previously.\nIt seems everything works now: https://travis-ci.org/graphcool/graphql-config-extension-graphcool/jobs/323763719#L547 so I imagine the 422 Unprocessable Entity was a temporary error on the GitHub API side.\nCan you confirm everything works as expected now?. Fixed by #593. I mentioned a possible solution in this comment.\nBasically we would allow (but not recommend) to run Semantic-release outside of a CI. It could takes different form: a --no-dry-run, --no-ci or --local options for example.\nSetting this option would by pass the isCi and isPr checks.\nWould that works?\n. @marionebl, there is two issues with have here:\n- running untrusted code\n- running code that uses secure environment variables (like tokens etc)\nCIs do not allow access to environment variables when running on a PR from a downstream repo. This is to avoid a security breach in which someone would for the repo and open a PR with console.log(process.env.NPM_TOKEN). If the environment variables were available it would allow anyone to export the secured environment variable.\nI'm not sure I fully understand your solution but it seems it would allow someone to create a fork, and open a PR that would ultimately run on the main repo, therefore having access to the environment variables.. @boennemann, I didn't know about GitHub Deployments. It seems a great idea to use them.\nConceptually the solution you are proposing is similar to Solution 3: Trigger a custom CI job: the GitHub app determines if a release has to be done and delegates the rest to the CI (that would run semantic-release for example).\nIt comes with the same limitations though. In order to determine the if a release has to be done we currently execute the analyzeCommits which can be custom, untrusted code. So in both solution we would need to limit the commit analysis to our default plugin (which is customizable enough I think).\nWe might also have to execute the verifyConditions step that might require various authentication tokens (NPM_TOKEN for example). Those will not be available to the GitHub app.\nSo for the when we can use GitHub Deployment + tag creation, and have the CI to do the release when a tag is created.\nFor the how (i.e. publishing), I don't think it's someone else problem. We currently have the semantic-release command that. It's modular, well test and used in production. So we should keep using that, rather than recreating \"plugins\" or \"modules\" that would react to a GitHub Deployment or a tag being created.\nThe best solution is probably to do both:\n- The GitHub app reuse the current semantic-release code to determine the type of release, the last release, the next release and create the GitTag + a GitHub deployment\n- We run the current semantic-release on the CI (triggered by the tag creation) or not if the user doesn't choose to\n- We allow folks to run whatever else they'd like, triggered by the tag creation or the GitHub deployment\n- We add a step in the current semantic-release to add the status success to the deployment\nSince #613 is implement that would make that solution easier to implement. We just need to reuse part of the current semantic-release code in the GitHub app (by exposing API): basically what index.js is doing but we skip the publish step. This is basically: build config, verify conditions, get last release, get commits, analyze commits, get next version, create tag.\nOnce the tag is created it trigger a CI job that runs the current semantic-release command.\nRegarding your proposal about listening to the npm registry to figure out when to set the status to deployment_status=success, keep in mind that npm is optional now and we support multiple (basically any) package manager or other release method. In addition multiple methods can be used together. The current implementation verifies that each publishing works (if it doesn't an error is thrown). So we should probably have the semantic-release command to update deployment_status=success once all the publish have run.\nA few other comments:\n\nThis would also enable manual release commits quite easily. I didn't think that's desirable at first, but imagine a tool that you can use locally\n\nThis is currently possible with the --no-ci CLI option\n\nBecause that happens locally the git commit can be signed by the maintainer \u2013 something semantic-release currently lacks.\n\nIt can currently be done with the git plugin: https://github.com/semantic-release/git#gpg-signature\n\nand using the deployments paradigm everyone could build their own way, independent of programming language, ecosystem or package registry/deployment target\n\nsemantic-release is already language and CI agnostic. A package.json is not required anymore, publishing on npm and github is now done via a plugin and is optional, the exec plugin allow to publish anything with a command line and the publish plugin architecture allow to create a plugin for any language/project type that cannot be achieved via the exec plugin.\nOverall I see the GitHub app more as way to trigger a CI build that runs the semantic-release command. And we can integrate the GitHub Deployment feature in the mix to allow extensibility outside the semantic-release ecosystem.\n. Just got an idea, that is really simple (maybe too naive?) to be able to run semantic-release only after all the CIs test pass.\nWe could create a GitHub app that listen to commits on the branch configured in semantic-release and when all CI passes it would create the branch release/<name_of_the_branch> that would trigger a CI job. The CI would be configured to run semantic-release only on branches like release/**.\nThis is similar to the way GreenKeeper triggers CI jobs to test new version of dependencies.\nThat would be a very simple solution with the following benefits:\n- We keep the semantic-release as is, which is tested, used in prod and offer modularization with plugins\n- We don't rely on Build Stages or travis-deploy-once and therefore can really support any CI (even the one that doesn't offer a Build Stages equivalent)\n- We don't have to call the CI API (as in Solution 3: Trigger a custom CI job)\n- We don't have to split the release process between the GitHub App and the semantic-release command\n. Thanks for your feedback, and your interest in semantic-release!\nI looked at the code in new-release-app and it seems create a tag/GitHub release, based on static (non configurable) commit parsing.\nIt doesn't seems to address the challenges or implement any of the features listed above, namely:\n- Providing the same features as the current version semantic-release such as:\n  - Release of multiple commits at once (it seems your app take only one commit in account to determine the next release)\n  - Plugins system (problematic has the GitHub app can't and shouldn't load third party modules)\n  - All the different options\n  - Customization of the commit parser preset\n  - Customization of the release rules\n  - Customization of the release note\n- Release after all CI are successful\n- Release on npm, Atom or any other package management registry (as the Github app doesn't have access to the cloned repo)\n- Run project's custom command to compile/build before releasing (e.g prePublishOnly script)\n- Add comments to PRs opened from a fork (there is no env variable available on build triggered by such PRs, hence the challenge)\n- Set PR status to failed if a commit message doesn't respect the convention\n- Notifications\nWhat you implemented in new-release-app surely fulfill your needs but what we try to achieve with a GitHub app is to keep all (or most of) current semantic-release features, extend them and add new ones; preferably reusing the current code, or least having a large part of the code base in common between a GitHub app solution and CI+CLI solution (to support non GitHub projects).\nIf you manage to find a solution and implement a POC for any of the features and challenges listed above, please let us know! That would be very helpful! . The purpose of this issue is to discuss possible solutions for the proposed features above and we'd like to avoid going off track. This issue is not the right place to discuss the direction of semantic-release project, the benefits of current features or promoting your project.\nIf you have solutions to propose for the challenges and features mentioned above, feel free to expose them here.\nIf you want to see some features implemented in semantic-release and think those are more important than what we are working on, feel free to open and issue describing your proposed feature and its benefits.\nIf you would like to see semantic-release evolving in a different direction, feel free to open an issue and expose your points in a constructive manner.\nIf you think semantic-release is not the right tool for you and prefer to develop and use and alternative one, that's great! Open source is about diversity, creativity and empowering new ideas. But remember this is not a competition and kindness id the most important part of the Open Source experience. For example, you don't see yarn developers going on the npm issue tracker to explain yarn is better than npm.\nIn any case, this issue and this issue tracker in general is not the appropriate place to promote you project or argue about its superiority to semantic-release. We don't have any problem being challenged, but we'd prefer that to be done in an appropriate place (blog posts, forum, chat etc...) and in a kind and constructive way. Thanks for your understanding.. Per the documentation semantic-release uses the the Angular convention.\nThe types that trigger a release are feat, fix or perf. fest is not a valid commit type.. A recipe for Circle CI will be added in #573. But indeed it would be great to have the cli offering the Circle CI choice and generating the config file. PR welcome !. Can you do something to what we do with GitHub and NPM in the CLI? And ask the users for their CircleCI user/password and authenticate with that?. That's quite unfortunate the API is sot flexible. It seems that what you propose is the only solution...\n@gr2m any thoughts?. I added a FAQ with explanation about [skip release]/[release skip]. Oops I referenced the wrong PR...It should not be closed. For information, due to the ^ in the version definition, the latest version in the 3.x.x range will always be used.\nIs it about a XSS vulnerability? Doesn't it affect only web browsers? We use marked to log colorized marked down in the console.. > @pvdlg This is no longer true with package-log.json in later node version - whatever is written in the package-log.json is being installed and the file only changes when the dependencies change.\nPer the npm documentation:\n\nOne key detail about package-lock.json is that it cannot be published, and it will be ignored if found in any place other than the toplevel package.\n\nThe package-lock.json file will be used only in development when you do npm install at the root of your project. When users of your project install it (with npm install simlu-project or by adding it to their package.json dependencies) the package-lock.json of your project will not be used as it's not published in your package.\nEven if we merge this PR and release and updated version of semantic-release it will not be used by your project in dev, due to the package-lock.json. However the last version of marked will currently be used by the users of your package when they install it as a dependency, without having to change anything in semantic-release.\n\nIn that case this vulnerability might not concern you. However it still came up in my project - so better to fix it and prevent other people running into it.\n\nUpdating the dependency version in semantic-release will not change that. You'll have to update your package-lock.json no matter what, either to update the version of semantic-release and marked if this PR is merged, or to update only marked otherwise.\nIn your project, just regenerate your package-lock.json so you will get all the last fixes of all your dependency. Also, you might have security vulnerabilities other than marked for which there is a fix, but you don't get them in development because the package-lock.json makes you use outdated versions.\nI know it's a simple modification with no impact and I could just merge it and move on. But this change  doesn't solve the actual problem, and I don't want to give folks the false idea that it does. The actual problem is that using a package-lock.json make you have outdated dependencies in development, and the only solution is to not use a package-lock.json or to update it frequently.\nWe had several PRs of this type recently and they come from a misunderstanding about how SemVer and package-lock.json works. Mostly because it's frankly really confusing and also because pacakge-lock.json is the default behavior, so folks just use it without having to read the doc in details. Basically as a npm or yarn user, you will never get a warning telling you \"Using a lockfile, which is the default behavior, will prevent you to get any fixes while in development, although those fixes will automatically be used in production\".\nAs SemVer is at the core of semantic-release it's important for us to explain how it works and to avoid misconceptions such as the one around package-lock.json\n. Thanks for the feedback! That's a very interesting discussion to have (at least for me ^^).\n\nWith the semver range defined by this package, the version with the vulnerability is an acceptable version that satisfies the defined range. All we are proposing is to update the acceptable range to a minimum that does not include the version that has the vulnerability.\n\nI understand that, but the whole point of using npm and SemVer is to not have to do that. If we update this, then every time a project release a fix, we'll have to update all the projects that depends on it directly or indirectly. This is really going back to the days without npm (that was maven for me :)) where version range where not available (no ^ or ~) and you had to contently update everything and live with bugs because you dependencies were not updating their own dependencies.\nBasically I we update the marked version in semantic-release why not updating all the patch and minor versions of all dependencies every time one is released? If the npm ecosystem can evolve so fast this is because we don't have to do that.\n\nWith the semver range defined by this package, the version with the vulnerability is an acceptable version that satisfies the defined range. All we are proposing is to update the acceptable range to a minimum that does not include the version that has the vulnerability.\n\nUnderstood, but my point is that it won't change anything for anyone:\n- Project that include semantic-release as a new dependency (with npm install semantic-release) will get the last version of marked whether or not we update the marked range in semantic-release.\n- Project that currently use semantic-release with a package-lock.json will not get the updated version of marked until they update their package-lock.json whether or not we update the marked range in semantic-release.\n- Project that currently use semantic-release without a package-lock.json will get the updated version of marked when they do npm install whether or not we update the marked range in semantic-release.\n\nThe other benefit of updating the minimum of the range if you were to decide that the problematic version were not acceptable is that npm would then take care of updating to a newer version, both in cases with lockfiles (w/o hand editing the lockfile) and when installs happen into a dirty workspace.\n\nThat's true only if you update semantic-release manually. Otherwise the current version (with marked ^0.3.6) will still be the one installed due to your package-lock.json. No matter what with a package-lock.json you will need a manual action.\n\nFair?\nI'm ok merging this PR if it makes people feels better. I just want to point out that it's a false feeling of security, as this would not solve the problem. If folks use a package-lock.json they implicitly (unknowingly?) make the choice of using a consistent but outdated dependency tree. Not matter what we do in semantic-release they will have to update their package-lock.json if they want to prevent security vulnerabilities.\n. > Here is my point of view on this: We pin every dependency and don't use version ranges.\n\nPinning dependencies is contrary to the npm logic, and would kill it's main benefit: version ranges that allows to automatically uses non breaking changes (namely patches and new features).\n\nWhen a new dependency is released we use greekeeper + travis + octoscript + semantic-release to test and immediately publish a new version of the module (everything fully automated). If the dependency update causes a test failure, no new version is release and we are notified about it and can fix it manually.\n\nWith the current setting (range for dependencies) when a new dependency (in range or not) is released, Greenkeeper run the tests automatically to make sure nothing breaks. It currently doesn't work if you use a package-lock.json due to greenkeeperio/greenkeeper#506. But we are not using a package-lock.json for semantic-release as we prefer to have up to date dependencies in dev rather consistents but outdated ones.\nIf a patch or minor release of a dependency break something we are already notified immediately by Greenkeeper.\nBasically it's already working like what you propose, but with version range, without having to merge a Greenkeeper PR every time a dependency releases a patch or feature, and without having to release a semantic-release version every time it happens.\n. To @simlu \n\nAssume a dependency X of module A get's a minor version update with a critical fix for your module A. No new version of module A get's released. Hence there is a no way for a module B that uses module A to know that something critical has changed (since module A still has the same version). We simply prefer to make changes transparent to all the modules that use our modules.\n\nThat's not correct. If you define your module A with a version range and the fix is within this range, then Module B that uses Module will get the update automatically, as long as they don't explicitly refuse to get it by using a package-lock.json. Also they will get the update automatically in prod as the package-lock.json is not used there.\nThe notion of transparency is handled with Semver: If it's a fix update only the last number of the version.\n\nExactly the reasoning why we want this PR to be merged and a new version of semantic-release to be released. This prevents some users from having the current semantic release version with an old install and other users using the same semantic release version with a new install. The version are the same, but the functionality is different.\n\nAs explained in this thread this is not correct. Updating semantic-release will not solve that issue.\nUsers who do not update their dependencies won't get the update. Users who do update their dependencies will get the update, no matter is semantic-release is updated or not, because the marked version with the fix is in the range defined by semantic-release.\n\nThe main argument against this is \"release overhead\", but if that is all automated it mainly goes away. But this is opinion based. I don't think that part of npm is \"great\" - this was simply a fix for problems people had \"release wars\", but it's not necessarily the best solution.\n\nThis choice has been made by npm and it allowed to create a striving ecosystem evolving faster than any other before. The benefit of SemVer might be an opinion, but it's the choice made by npm. The entire objective of semantic-release is to enforce it, so you can imagine we love this SemVer :)\nTo @travi \n\nHowever, I do think there are special cases like this when I think it is appropriate for a project to limit the semver range further than they normally might. The other case is a breakage that didnt bump semver appropriately. If the project knows that there is a version within their specified range that breaks the functionality of their package, I think it is helpful for them to exclude that version from their range.\n\nYep, if someone release a breaking in a path or minor release that blows up everything. This is why everyone should use semantic-release and Greenkeeper :) semantic-release will avoid folks to do such thing and Greenkeeper prevent us to be affected by it.\n\nSecurity vulnerabilities are a special case in my book (but it is also influenced by the fact that github sent a notification for all of my projects that have this in their dep tree).\n\nFair point. But GitHub didn't reported the problem to the semantic-release repo. I imagine it's because the fix for it is in the range we declared?\n\nThis is true except for the manual editing of the lockfile. I may have to \"manually\" install the new semantic-release version, but by doing so, npm takes care of updating the lockfile for me.\n\nFair point in that particular case. But keep in mind that updating semantic-release with this PR will solve your specific case for remark. But I'm pretty sure that you have in your dependency tree dozen or hundreds of sub-dependencies outdated due to your package-lock.json. Many of them might have security issues for which a fix exists and you won't get that fix until all the projects you depends on update to a range that doesn't allow the bug. But by the time they do that you'll have many bug that would have appeared.\nNo matter in which side we put the problem, using a package-lock.json will have for consequence an outdated dependency tree. This is the whole concept of the package-lock.json: guaranteeing a consistent dependency tree by creating a snapshot of it at a given moment. By definition it makes your dependency tree outdated. If you use a package-lock.json you give up the ability to get an up to date dependency tree.\n\nRegardless of opinions on whether or not a lockfile should be used, we should be able to agree that no human should manually edit that file.\n\nIdeally npm should provide a way to update a sub-dependency via CLI. But it's not the case....\n. I'll go ahead an merge the PR as it seems to be a friction point and it's the specific case of a security issue.\nBut all the points made in this thread remain and it's illusory to think it is required to prevent to an outdate marked.\nIf other PRs of this type happen we'll update the documentation to explain why they are unnecessary and won't be merged.\n. > Leaving out the lock file entirely, the problem I have with version ranging is that you no longer differentiate between dependency versions, but between install times. Basically you would have to constantly re-install all your dependencies, because a sub-dependency could have updated - even if non of your direct dependencies updated. And yes, that's how it was designed for npm - it doesn't mean we have to like it.\nIndependently of npm, you have to choose between an automatically up to date but changing dependency tree or a consistent but outdated one. You can't get both.\nnpm chose the former to be the default and allow to use the later with npm-shrinkwrap.json for prod and package-lock.json for dev.\nIf you want a npm install to produce a consistent dependency tree, then use a package-lock.json but you loose the ability to be always up to date. If you also want to be up to date you have to frequently delete your pacakge-lock.json and regenerate it.\nYou can decide to not use npm with the default ^ and pin your dependencies or to have a pacakge-lock.json that you don't fully regenerate frequently, but you can't expect all the projects in the eco-system to all update all their dependencies every time and in-range dependency is released (like I did by merging this PR).\nUnfortunately this is a situation in which a choice has to be made:\n1. Either you use version range, no package-lock.json and Greenkeeper to test in range dependencies releases\n2. Or you use a package-lock.json to freeze your dependencies (in dev only) and you regenerate it frequently to stay up to date\n3. Or you ask all the developers in the world who publish on npm, to always and immediately update all the dependencies of all their packages every time a release is done\nObviously the 3rd choice is not reasonable. That was my point in this thread.\nIn conclusion, if you want to use a package-lock.json regenerate it frequently to stay up to date.. > Unfortunately, this doesn't seem to be an action that is enabled very well through the CLI. Do you know of a way to do this effectively? No worries if not since I'm aware you're avoiding their use.\nSadly no. I'm thinking about building a GitHub app that would run every day, fully update the yarn.lock and package-lock.json and opens a PR with it. But I didn't had much time to work on that and I'm not really satisfied with opening a PR everyday. The other option would be to push to master directly but that has some constraints as well.\n\nEven if we landed on the answer being no in the end, I think the conversation is worthwhile in special cases like this. Sometimes it is worth exceptions to event defined common practices so its doesnt hurt to at least ask :)\n\nAbsolutely! This is type of conversation is always beneficial. It can be also used or future reference.\n\nI think this is the key point to all of this. Everything is about tradeoffs. Different maintainers will make different decisions about which are most important. For me, predictable but slightly out of date outweighs unpredictably/inconsistently up to date.\n\nAbsolutely it's a tradeoff. My problem is that both yarn and npm, use a lockfile by default and do a terrible job at explaining users what tradeoff they are doing. Most users do not realize the tradeoff they are making.\nActually a lot of users also think that a yarn.lock or a package-lock.json protect them from experiencing a different tree between their dev environment and their users' execution environment. That's something provided by npm-shrinkwrap.json but not by yarn.lock and package-lock.json. It's so confusing that even the Greenkeeper team, who know a lot about dependency management and npm got confused and introduced greenkeeperio/greenkeeper#506.\nLockfiles are not necessarily a bad idea , but because the concept is complex and their were introduced without much documentation, no warning in the CLI and they are used by default, that create a lot of confusion. The result is that many many projects use them and have dependencies in their dev environment that didn't received any fix/feature for months or years. The more time passes the more their dev environment diverge from the execution environment of their users (as the dev env is frozen but not the exec env) and the more likely it is to have bugs related to that.\nI think it's to yarn and npm to:\n- make sure the community understand that with lockfiles you need to upgrade them often\n- provide tools to do so (better than rm -rf node_modules && rm -f package-lock.json && npm install)\n- make sure the community understand that lockfile do not impact the exec environment\nThere is also the notion of speed behind all that. Using a lockfile speed up the installation. Yarn introduced the lockfile first, and their main selling point was speed. They put a lot of emphasis on \"we are faster than npm\" but not so much on the \"at the expense of not having an automatically up to date dependency tree\". Then npm had to catch up and introduced package-lock.json\n\nThe fact that we are even this deep into this conversation means we are far further in understanding and considering the tradeoffs in this space than most. I really appreciate thinking through a problem like this with you. Projects like semantic-release, greenkeeper, etc have the potential to make these problems far better than vanilla npm for teams that might never get this deep into considering what we're talking about. Thank you for the work you're putting into this space!\n\nAppreciation is shared :-)\n. > What else can we do to encourage educated decisions in this area?\nI've been working on a Medium post for a while, but did't go time to finish it. I guess that can be a good solution. Based on that maybe try to engage with Yarn / npm people to get their feedback.. > It would be a good idea to add this example for release.config.js , no ?\nThat would be a better fit for the commit-analyzer and note generator plugin.. > How is the website deployed?\nWith GitBook. > we could take advantage of an undocumented GitHub feature: multiple issue templates. See this repository for a demonstration: https://github.com/clarkbw/team-plates/ :)\nIs it really a feature? When I open an issue on this repo I just see the link in the template.\nAm I missing something?\n. Never mind I get it now.. We have:\n- GitLab plugin\n- GitLab shareable config\n- GitLab CI recipe\nThere is 2 things here, GitLab the Git hosted repository (supported with the plugin and shareable config) and the GitLab CI.\nThe plugin make the release on GitLab (the Git hosted repo) similarly to what we do with GitHub.\nRegarding CI support, there is nothing we have to do in semantic-release to support additional CI.\nThe only CI related stuff we do is:\n- Check we are running on a CI\n- Check it's not a PR build\n- Check if we are on the proper branch\nAll that is done with env-ci.\n. Do you mean support for the CLI?\nNothing is the roadmap. There is no much roadmap other than:\n- Issue with the design label will be implemented once we agreed on the design\n- Issues with help wanted are considered valid on ok to fix/implement\nBut that would be great if the CLI could generate something similar to what's in the GitLab CI recipe. Since semantic-release/cli#172 is open should we close this issue?. This issue is related to the setup CLI (https://github.com/semantic-release/cli) and is already closed.\nThe @semantic-release/gitlab-config shareable config is also mentioned here: https://github.com/semantic-release/semantic-release/blob/caribou/docs/extending/shareable-configurations-list.md and in a FAQ: https://github.com/semantic-release/semantic-release/blob/caribou/docs/support/FAQ.md#can-i-use-semantic-release-with-gitlab.\nThe documentation of @semantic-release/gitlab-config contains the info related to its usage and configuration.. It seems the Object spread properties feature require a version slightly higher than 8.0.x.\nIt should work if you install a more recent Node 8 version (like 8.6.0).\nWe should update the documentation to mention we require that version.\n. Yes but it is a choice to support only certain version of Node. You can find the reasons and solutions there: https://semantic-release.gitbooks.io/semantic-release/content/docs/support/node-version.html. I tested on Travis and locally, nvm install 8 does install and use it. Do you see a different behavior?. If you are using the npm plugin there is no change in behavior regarding the gitHead. The code just has been moved to the plugin.\nThe error happened when the github plugin create the new tag with await github.gitdata.createReference({owner, repo, ref, sha: gitHead});\nThe gitHead passed here is the sha of the last commit in the branch obtained with await execa('git', ['rev-parse', 'HEAD']);\nIt's probably a temporary problem with the GitHub API. Or it might be that the last commit sha in the local repo is not present in the remote (on GitHub).\nYou can obtain more info if you run semantic-release in debug mode with the DEBUG environment variable set to sematic-release:*.\n. We had several issue related to temporary errors with the GitHub API. Maybe it's on of this situation.\nI really don't why GitHub would return a 404 when we create a tag that reference the last commit sha in the repo. . Are the 404 due to go over the rate limit? Should it be another type of error like 429?. > But in this case, creating a tag, does not trigger notifications, so that\u2019s new to me, too\nI think creating a tag make a notification in the News feed of people who watch the repo (Or maybe it's on the actual release?). I don't know if that count as a notification per the API definition.. I can confirm that @octokit/rest is used only in @semantic-release/github.\nIt seems the issue is related to the GitHub backend that for some reasons returns random errors. I'm not sure the solution should be implemented in semantic-release. It should probably be handled on the GitHub backend (by returning a proper 429) or in the API client. At least it worth reporting the problem to GitHub and see what they say. If the issue is urgent we can implement a retry based workaround in @semantic-release/github.\nI don't think octokit.hook is the best solution though. octokit.hook allow to run something before or after. What we want to do here is to retry on error for a certain number of time, so we should implement a solution based on something like promise-retry as suggested by @boennemann. \nActually we already have something similar done with p-retry in test/helpers/npm-registry.js and travis-deploy-once/lib/wait-for-other-jobs.js. The advantage of p-retry is that we can use exponential backoff.\nWe could implement a similar solutions for the calls we expect to not fail (like creating a tag or a release). We could do something like:\n- retries: 3\n- factor: 2\n- minTimeout: 1000\nSo if the first call fails we would wait 1s and retry, if it still fails wait 2s and retry, and if it still fails wait 4s and retry.\nAnother thing to consider is that several times when I experienced these random errors, they would persist for a couple hours. I was retrying the calls but still obtained the same error. After waiting a couple hours it would work right away. For those type of situation doing a retry in the code would not work.\n. > Yes it\u2019s not a very elegant solution for the retry, I\u2019m thinking about that right now and will work on it next week\n\ud83d\udc4dI guess it worth having the GitHub feedback, to decide if it's better done in semantic-release as a temporary workaround or permanently in @octokit/rest.\nFor info it's implemented in the npm registry client: https://github.com/npm/npm-registry-client/blob/80870c565700699111a56bb1b76f28202442aba5/lib/request.js#L67. It's a common thing for API to implement such feature.\nThe tough part is to determine when to retry and when to consider the error and actual error that doesn't need a retry.\n\nLocally, or on CI?\n\nBoth. In order to debug a problem that happened on the CI on one of my repo I was trying to make the call locally with Postman. Couldn't figure out why I was having the error (a 404 as well if I remember well) so I gave up. I went back to it a few hours later, same request worked right away.. Whaow I'm shocked to see that! I was convinced that in the script phase any failure would prevent other step to run. That really sounds like a bug in Travis to me...Most CI work that way.\nWe indeed need to change the documentation (and the config of semantic-release repos!).\nWe could run semantic-release in the after_success but if semantic-release fails the build doesn't fail, so users are not aware of the problem.\nUsing deploy seems to be the best solution, however when doing so I have the message !!! Script support is experimental !!!. So if it's a beta thing maybe it's not that great for now.\nAn other solution is to keep it in script but do npm run test && semantic-release. But it's not really elegant and can be complex for users having multiple scripts in the script phase.\nNot sure what the best solution is, but I'm leaning toward the deploy step as suggested by @travi \n. We should probably change the ASAP to avoid user to end up in the same situation.\nI'm definitely interested to get feedback from you regarding the deploy step.\n@gr2m what do you think about changing the doc to recommend using the deploy step as proposed by @travi ?. > Anything in particular that you're interested in beyond the fact that it's been working well for us for other tasks?\nI'm just concern about the fact Travis says it's experimental.. The reason we started to recommend to script instead of after_success was to fail builds when the release fail so the user will be aware of the problem. It was requested in #569.\nWe had several releases that didn't happen in the semantic-release repos and we weren't aware of it because the build didn't fail. So it turns out it's quite useful to have the build failing.\nThe PR #610 specifies:\n\nIt's recommended to run the semantic-release command in the Travis deploy step so if an error occurs the build will fail and Travis will send a notification.\n\nEven with the experimental warning there is more benefits to use deploy (or other solution that fails the build on error). Not sure if it worth mentioning after_success. I'd rather keep the documentation simple and less confusing for new comers. Advanced users can customize.\n\nA big part of the previous recommendation to use after_success was because semantic-release used to exit with non-zero for non-failure scenarios. Since after_ steps don't fail the build, it was important to run from there. That problem has been fixed, so it seems less valuable to recommend an approach that wouldn't notify on failure as the only recommendation that doesn't require the added complexity of stages.\n\nYes exactly.. Would the answer to this FAQ would help?. Do you have by any change a link to your repo and your build scripts? I'm curious to know more about non Javascript project and in which circumstances they might need the version in their build script.\nGetting to know more would allow us to come up with the best solution for this type of scenario.. What is your semantic-release configuration? What plugin do you use to publish?\nDo you also need the version to run your tests? Or can you do build and pack with version 0.0.0-development like we do with npm packges and then run your tests?\nThen for publishing the binaries created with the proper version, maybe you could use the exec plugin to run dotnet build /p:AssemblyVersion=1.2.3.4 and dotnet pack /p:AssemblyVersion=1.2.3.4 in the publish step before other plugins.\nThe exec plugin allow to run custom command and give you the possibility to pass the value in the semantic-release context, such as version.. The best would be what you mentioned at the end of the last comment. The exec plugin is probably a more simple solution than creating a plugin if you have to just execute one or 2 shell commands.\nYou might want to run Build and Package before the GitHub plugin, so you can upload your packaged assets to the GitHub release with github#assets.\nYou can also create a shareable configuration similar to apm-config if you'd like to, so you and others can reuse it across different projects.\nRunning the build twice (once for test and once for release) might seems inefficient, but here is a few things to consider:\n- Most build scripts will take a few seconds or a few dozen of seconds, so the general impact on the total CI runtime will not be that big. Plus the extra build will happen only when a release is actually required.\n- Everything in PR will not trigger a release not an extra build.\n- If you test in multiple environments (for example Windows 64 bit + Windows 32 bits + Linux + different versions of .Net) you will need to configure multiple CI jobs. That mean you will probably use something like Travis Build Stages and configure one job per environment/version + 1 job to make the release. In such situation will have to make a build specifically for the release step anyway, as the release job will have to run after all other are successful.. Awesome! Let us know how it goes. You can ping me if you need help.. Yep we can test on the @next branch.\nWe should also need to merge #618 before this one.. What you try to achieve with a master branch and a release branch cannot be achieve as of now. semantic-release analyze the commit present on the current branch to make the release.\nSo you need both the code to release and the commits that created it, to be on the same branch.\nWhat you can do is use semantic-release to make releases on master, and use the exec plugin as an additional publish step to use whatever solution to push to another branch.\nFor example here I use gh-pages to publish the generated docs to the gh-pages branch.\nRegarding the EGITNOPERMISSION error the GH_TOKEN environment variable should be a GitHub personal token. You should probably not use cross-env GH_TOKEN=__TOKEN__ semantic-release as you would have your token in clear in your package.json. Even if your project is private, it doesn't seems really secure.\nDid you make sure the token has push access to your repo? As it's a probably a private repo, you will need to check \"Full control of private repositories\".\n. In order to check the permission to the repo we are using git push --dry-run https://<GH_TOKEN>@github.com/<owner>/<repo>.git HEAD:master.\nCan you try to run that on your CI to see if you get an error? You have to replace ,  and  in the command?\nAlso what is the Git URL configured in your package.json in the repository property?. If git push --dry-run https://<GH_TOKEN>@github.com//.git HEAD:master works when you run it directly in the CI there is no reason it doesn't work when it's ran by semantic-release. So there must be a difference in the configuration you reported in this issue and your actual configuration.\nYou can try with semantic-release version 12.4.1 or 13.1.0 that would give more informations in the logs. . @huchenme The command that is executed is git push --dry-run https://<GH_TOKEN>@github.com//.git HEAD:master, not git push --dry-run origin HEAD:master.\nIt's most likely a problem with your token/credentials or the configuration of the repositoryUrl.\nAlso I don't know why you have ssh-agent -k in the middle of the logs.. It seems the problem happens when you have multiple sub-path in the repository URL.\nFor example https://gitlab.com/owner/repo.git works while https://gitlab.com/group/owner/repo.git doesn't.\nThis will be solved once IonicaBizau/git-url-parse#53 get released.. @huchenme can you confirm what is your repository URL? To be sure it will be solved by IonicaBizau/git-url-parse#53.\n@abhishek199-dhn as you are using a GitHub repo I don't think it's related to IonicaBizau/git-url-parse#53. Can you confirm if your problem is solved? Did you try with the latest 13.x.x?\nThanks. That should be fixed in v13.1.4. @huchenme, @abhishek199-dhn can you confirm that works for you?\nThanks. @abhishek199-dhn I read your comments in this issue several times and I fail to understand what you are trying to achieve and what's the purpose.\nsemantic-release runs on your CI which trigger a job when a commit is pushed on a branch. semantic-release needs to be run by the job triggered on that branch because it needs to analyze the commits made there since the last release.\nYou can use the @semantic-release/git plugin to push artifacts to your repo on the branch that triggered the CI job. This is what I would recommend to do. \nYou can also use the @semantic-release/exec plugin to run a command that do whatever you'd like.\nIf you'd like to propose a new feature you can use the feature request template.\nIf you'd like to propose a new plugin you can use the plugin request template.\nIn both case you would have to explain in details what the feature/plugin is and why it would be beneficial. In both case it would have to provide benefits for for commonly adopted patterns or release workflow.. @abhishek199-dhn I'm going to go ahead and close this issue as it seems stale.\nFeel free to reopen a new feature request including and explanation of the benefits it would bring.\nKeep in mind that semantic-release needs to analyze the commits done since the last release to determine the next version and make the release, so it has to run on a branch that include those commits.. It seems you have a build script in your package.json. I guess you have to run it in the CI to produce the files you want to publish?\nIt seems this script is not run. You can run script in the prePublish hook, so it will always be run before publishing.. Thanks! I think it's a great change!\nWe just need to make sure that npx is available where we recommend to use it. On Travis it's always available independently of the Node version that the job runs. But on CI it might not be the case.\nOn all the modifications in this PR, npx should be available, so we're good to go!\nI just have one remark in the Global install (see inline comment).\n. We just need to change the commit message.. > This all sounds great to me! For finding PRs/issues to comment on to notify contributors about the release of their changes, see the implementation of https://github.com/release-notifier/release-notifier\nYep I checked it out! Actually I have something a bit more complete in mind:\n- Do a GitHub issue search for each commit in the release to retrieve each associated PR\n- Parse each PR found to find issues references (like Fix #XX or Close #XX)\n- Add a comment to each issues closed by one of the PR found\nI would also parse the commit message content to find issues closed by the commit directly.\nThe idea is similar though, it would rely on context.github.search.issues({q: commit.sha}), just dig a bit deeper.\nThat would be useful as a lot of folks open an issue or follow one, but don't necessarly follow the associated PR.. Ok. I have the code for parsing issues (that detect Fix #XX) ready to be released soon.\nThat would work with GitHub, GitLab and BitBucket and would recognize all the different Fix patterns (Fix, Fixes, Closes etc..) plus the referenced without a keyword, plus the users mentions.\nI found several library doing that but they are either unmaintained or cannot implement features mentioned above.\nWhat would be left to do would be to make the calls to the logic of GitHub API call => Parse => GitHub API call etc...\n. semantic-release runs only on one job by design, so we can guarantee that a release is done only when all tests pass (those tests can be run by different CI jobs).\nI'm not familiar with electron apps, but what I gather is that you have an OSX job that produces the OSX binaries and a Linux job that produces the linux binaries. Is that correct?\nIs there a way to have the same job producing all the binaries? For example, could a Linux job produces both the OSX and Linux?\nIf not a solution could be to use Travis build stages to make the binaries available on other jobs.\nThis way you could have:\n- A Linux job in the default test stage that would test and create the Linux binaries\n- An OSX job in the default test stage that would test and create the OSX binaries\n- A job in the release stage that would have access to both binaries and that would run semantic-release, allowing to publish both.\n. Let us know if it works! We could write a recipe in order to help other users.. In order to update the package.json you can use the @semantic-release/npm plugin. If you don't want to publish to npm you can set the npmPublish option to false.\nAlso you don't have to run the post-build.sh script. There is no need to revert to 0.0.0-development as the modified package.json is only present on the CI.\nYour config would be something like that:\n{\n  \"publish\": [\n    \"@semantic-release/npm\",\n    {\"path\": \"@semantic-release/exec\", \"cmd\": \"yarn build --linux --win --mac -p never\"},\n    \"@semantic-release/github\"\n  ],\n  \"assets\": \"dist/*\",\n  \"npmPublish\": false\n}\n. Thanks for reporting! Would you like to open a PR to fix it?. In your package.json you set semantic-release pre && npm publish && semantic-release post which is the old way of running semantic-release. As mention in the doc you have to just run semantic-release.\nIf you want to use a custom registry, you can configure it in a .npmrc file at the root of your project or in under publishConfig property in your package.json.\nThe semantic-release-cli setup should save the custom registry URL. There is an issue opened for that: semantic-release/cli#177 \n. Duplicate of semantic-release/cli#177. Thanks!. Yes this is one of the numerous problems we had trying to integrate with various npm registries. As there is no specifications, all \"npm compatible\" registries have different behavior.\nFor this reason and others we don't use the npm registry anymore to retrieve the last release. We now rely on Git tags. See semantic-release/semantic-release#613.\nThis PR has been released in the @next dist-tag. You can use it with semantic-release 13.0.0.. I'm going to go ahead and close this issue as the getLastRelease plugin doesn't exist anymore in semantic-release@13.0.0 so the problematic code is not there anymore.\nI recommend to upgrade to semantic-release@13.0.0 which available on the @next dist-tag.\n. The commit you are referencing has been released in semantic-release 13.0.0 on the next dist-tag.\nAs you use semantic-release with npx semantic-release you are using the last version on the lastest dist-tag which is 12.x.x.\nThat meant the last release is determined based on the npm registry. You can see that in the logs:\n\n[Semantic release]: No version found of package pathephone-desktop found on https://registry.npmjs.org/\n[Semantic release]: No previous release found, retrieving all commits\n\nSo when this CI job ran, you were using the default npm plugin for the getLastRelease plugin. As there is no version of your module on npm, semantic-release determined it the very first release and included all commits and released version 1.0.0.\nIf you don't want to release on the npm registry, you can look at this FAQ.\nIf you want to use Git tags for retrieving the last version (you should if you don't publish on npm), you need to configure the @sematnic-release/git plugin for getLastRelease. Or you can use semantic-release@13 that will do that automatically.\n. Don't hesitate to ping me on the Gitter chat if you need help to setup your project, or if you have questions.. Do you mean private GitHub repository? What would be the difference between public and private repo regarding?\nThe problem is related to the git CLI not handling the git+https type of URL when specified in a git push command.. Regarding the error details message defined in lib/definitions/errors.js an alternative would be to use handlebars.js to generate them.\nThis way we would have a directory that would contain markdown files with handlebars.js variable. The benefit would be a better experience when editing the detailed error message as the IDE would help formatting proper markdown.\nBut as the message as fairly simple it might be overkill to use handlebars.js.\n@gr2m do you have thoughts on that?\n. Ok. Let's go. Hopefully #627 should receive a comment after the merge and release.. This is because you using the version 2.0.0 of the GitLab plugin which is only compatible with semantic-release 13.0.0.\nYou can either continue to use semantic-release 12.x.x with the GitLab plugin 1.x.x or you can upgrade to semantic-release 13.x.x\nFeel free to re-open if that doesn't solve your issue. I changed it to a PUT as I though it would be considered an update of the tag as GitLab doesn't really have to notion of release but only \"tag comment\".\nTest more it seems it's wrong and it should be a POST.\nWould like to make a PR to fix it?. Following up in semantic-release/gitlab#11. Duplicate of semantic-release/gitlab#11. I'm not really familiar with the cli setup code. Is it the same issue as semantic-release/cli#147 ?. Yes it something weird with the Travis API. I think we workaround it in travis-deploy-once here:\nhttps://github.com/semantic-release/travis-deploy-once/blob/5e29e9d1d5bf0ae5f77ed6fabfc7a9cd36c6928a/lib/get-jobs.js#L28-L32\nI'm closing this issue as a duplicate of semantic-release/cli#147. Feel free to add analysis and insight over there.. Duplicate of semantic-release/cli#147. > The other issue makes it sound like it can be fixed by manually going to travis.com and syncing repos. The issue still occurs even after both of these steps\nOk, maybe it's the same as semantic-release/cli/issues/123 or semantic-release/cli/issues/112 ?. Duplicate of semantic-release/cli#112. Is your repository publicly accessible? Do you have a link? That would help with the troubleshooting.\nCan you provide the following in from your package.json:\n- The release  property content\n- The repository property content. Also can you try to manually run the following command in your ci: git push --dry-run https://gitlab-ci-token:$GITLAB_TOKEN@<server>/<owner>/release-test.git HEAD:master.\nYou have to replace <server> and <owner> with the value of your repo URL. For some reason in your logs its replaced by **.. It seems the problem happens when you have multiple sub-path in the repository URL.\nFor example https://gitlab.com/owner/repo.git works while https://gitlab.com/group/owner/repo.git doesn't.\nThis will be solved once IonicaBizau/git-url-parse#53 get released.. You can also see on the README which version is available on which dist-tag:\n\n. After the analysis we did together on Gitter it's due to the way you call npx.\nYou were installing this way:\nbash\nnpm install -g semantic-release/semantic-release#git-debug\nnpm install -g @semantic-release/git @semantic-release/changelog\nnpm install -g @semantic-release/git @semantic-release/git\nand then calling npx with npx semantic-release/semantic-release#git-debug --dry-run.\nDoing so make npx reinstall semantic-release rather than using the global install. And when doing so npx was installing semantic-release in its own node_modules which is different than the global one.\nIf you do npx semantic-release --dry-run then npx will run the globally installed version as expected.\nI'm closing this PR as everything works as expected. Do not hesitate to ping here or on Gitter if you have any other issue.\n. I had the same issue and I remember I fixed it by adding .filter(Boolean) as well. No idea why it's not there.\nSo yeah looks to be the right fix!\n. I'm not really sure I understand the issue. Can you edit your issue to add the information in the bug report template. Thanks. Ok, but it works in our tests and other repo, so it must be due to something specific in your configuration or environment. This is why we request some information in the bug report template.\nIf you refuse to take a couple minutes to provide those informations we can't help you.. In the logs you linked no release is created and the tag-format is not used. It doesn't seems to be even related.\nAs a side note you have several other misconfigurations:\n- \"gitlabUrl\": \"https://gitlab.com/naerion/\" is not configured properly. The naerion/ part should not be included. In addition this config is useless as you use the default one (https://gitlab.com)\n- \"createGitTag\": \"@semantic-release/git\" is not an option that exists\n- You use the @semantic-release/npm plugin but it's configured in verifyConditions\nBut I'm not even sure it's relevant as it might not be the configuration you are using since you report a problem regarding tagFormat but don't use it in the configuration you linked.\nI'd like to invite you to read out contributing guidelines especially the part about bug reports. semantic-release is an open source project and all the maintainers are volunteer with limited time. All the time we spend chasing for accurate information to troubleshoot is time that we don't spend improving the project. So please try to take the time to write proper and detailed bug reports.\n. Once again you don't provide the information requested in the bug report template, namely:\n- semantic-release version\n- Plugins used\n- semantic-release configuration\n- CI logs\nThis is 4 simple information that can be copied and pasted in the issue report, even if you are using a private repo and a private CI.\nI feel like there is some misunderstanding somewhere and maybe you think we are asking this for the sake of it. But it's not the case, I really need those info to analyze what happen in your env as I can't reproduce what you are describing.\nWe are trying to make the process of reporting issues and troubleshooting as seamless as possible, which is why we wrote a contributing guideline and and bug report template. We are at the 8th message on this issue and you didn't provide your configuration nor the semantic-release logs, so I imagine there is something that is not clear or confusing in what we are asking. How can we improve our docs/guideline/template in a way that would have prompted you to provide those information? \n. @R0oma1n do you still experience this issue? We'd really like to solve it if still the case.\nIf it still happening and you have access to your config and logs could you provide them?\nThanks!. Thanks for letting us know! Feel free to open an other issue if you see the problem happening again.. semantic-release create the tag before calling the publish plugins and update the tag reference if a publish adds a commit.\nWe do that because certain publish plugin require to have the tag created on the remote repository before running. This is the case for Atom packages as apm publish require to have the tag created on the remote repo.\nUnfortunately, if you use the @sematnic-release/git to create a commit that result in 2 tag creation events.\nI don't know how both requirements can be achieved unfortunately. Do you have any suggestions?\nIn you case you could use something like Travis auto cancellation as a workaround. This way the job triggered by the first even would be canceled by the second one.. Well, that's the architecture we moved away from recently: #613. There is several benefits to handling the git tag in the core, mostly that the creation is mandatory in order to identify the last release, so we can analyze commits between then and now.\nAlso we can't presume that a user will use a plugin or not. So all other plugin were creating or re-creating their own tags, just in case a previous plugin didn't do it already.\nBasically plugins are meant to be independents and optional. What you suggest would make @semantic-release/git mandatory and would make every other plugin depending on it (for example you would need to run @semantic-release/git first so @semantic-release/github could create a release on the tag created by @semantic-release/git).\nThe current architecture (with the core creating the tag) is much more simple, and make plugin creation a lot easier as they don't have to worry about checking if a tag exist, creating it, re-create it if the added a commit or all the authentication issue that come with it.\nSo that's a tradeoff. And to be honest we didn't think they would be any inconvenient moving the tag creation to the core as we didn't think about the double tag creation event.\nMay I ask what you are doing in the CI job triggered by the tag event?\nMaybe you could do that as part of semantic-release with the exec plugin. You could add a last publish step that runs whatever you are currently running in the job triggered by the tag event.\nThat would also have the advantage of doing everything in the same job, avoiding to wait for a new one to start on the tag event.\n. > Is it possible to make it conditional as to whether or not the tag created in core is actually pushed to github?\nUnfortunately apm requires to have the tag on the remote. When calling apm publish it will make a call to the Atom registry, that will in turn make a call to GitHub API to retrieve the code flagged by the tag.\n\nIf that isn't possible, what if you were to add a pipeline of plugins that would execute before the tag gets pushed?\n\nI think that would be possible. Wouldn't the steps be as follow instead?\n1. verify\n2. pre-publish or prepare\n3. create tag (local and remote)\n4. publish\nIn pre-push you can have plugins that created commits, while in publish they couldn't.\n. Here is a proposal to add a prepare plugin hook.\nsemantic-release changes\n\nAdd the plugin prepare hook that would work similarly to the current publish\nCreate the tag after prepare and before publish\nRemove the now unnecessary logic to update the tag if a plugin had created a commit\nAdd @semantic-release/npm to the default prepare hook\n\n@semantic-release/npm changes\n\nMove the pacakge.json version update and npm pack to a new prepare hook\nRemove the npmPublish option as it would be useless now (user can just disable the publish part to not release on npm)\n\n@semantic-release/changelog changes\n\nChange the publish step to prepare\n\n@semantic-release/git changes\n\nChange the publish hook to prepare\n\n@semantic-release/exec changes\n\nAdd the prepare hook\n\n@semantic-release/apm-config changes\n\nMove @semantic-release/git from publish to prepare\n\n@effervescentia, @gr2m what do you think? Would that work? . Thanks for suggesting it! I was not really happy with the trick that consisted in updating the tag when a plugin was making a commit anyway.\nSplitting the prepare and publish would also open more opportunities in the future such splitting the release in multiple independent steps (e.g ones could execute semantic-release with some plugins in prepare but none in publish, and would do their own publish stuff in a job triggered by the tag creation).. Contributions are always welcome! In that case I don't think it's the most trivial change, especially for the core, and because it involve changes across multi-repo.\nI'd invite to look around in the code and see which of the changes mentioned you'd like to work on (it can be plugin for example or the whole thing if you feel confident). Then we can split the work if you'd like.\nBut before making any change on this we need to have everybody in the maintainers team on board with it :)\nMore generally we flag all the issues ready to worked on with the help wanted tag. So we need plenty of help for those!\n. Fixed by #663.. @EfstathiadisDimitris yes, I think the documentation can always be improved. I wrote most of the doc and I'm not a native English speaker not a good documentation writer in general.\nSo help would be greatly appreciated. A lot of doc has been added recently on the beta branch, so you might want to look at that as it's probably what needs the most improvements.. Thanks a lot! \ud83d\udc4d . It seems you are using the @semantic-release/condition-travis plugin which is deprecated. You should remove it from your configuration.. Can you provide you semantic-release configuration?. It would be a release property in your package.json or in a releaserc file. If you just set up semantic-release with semantic-release-cli then there is no configuration set and the default one is used.\nThe ENOTRAVIS comes from the  @semantic-release/condition-travis which used to be used by default. It's used anymore since version 12.0.0.\nSo I guess you are using an older version. I see from your package.json that you are using version 11.0.2.\nI was confused because you mention version 12.4.1 in this issue.\nYou should upgrade to version 12.4.1\n. As mentioned in our contributing guidelines:\n\nThe issue tracker is the channel for bug reports, features requests and submitting pull requests only. Please use the Support and Get help sections for support, troubleshooting and questions.\n\nThose two FAQ seems to answer your question:\n- Why is the package.json\u2019s version not updated in my repository?\n- Can I manually trigger the release of a specific version?\nI'm closing the issue as it's a support question. If the 2 FAQs linked above doesn't help, I invite you to use the proper support channels for further support questions.\n. > Would I confuse semantic-release if I update it to something else?\nYou can do release manually as long as a tag is created. semantic-release determine the last version released with Git tags to analyze commits between then and now. \nIf you do a manual release, just create the git tag with a proper semver version as a name.. I wonder if it's one of these cases in which the GitHub API respond with random error code described in #607.\nIs this issue happens systematically? Or is it just once in a while?\nThe error happens when the GitHub plugin try to create the Git tag. This has been removed in semantic-release 13.0.0 which is published in the @next dist-tag. The git tag is now created with the git CLI.\nMoving to ^13.0.0 would improve the situation I think. > The CI pipeline triggered after applying the tag on code produce the following debug log which is showing failing of github plugin.\nThe logs you provides don't include any failure. It just says that semantic-release has nothing to do on a job triggered by a tag, which is expected. It exit before running any plugin.\nYou should configure your CI to run on tag creation. Or at least skip semantic-release in such case.\nAlso how I can generate the release notes of my previous releases?\nYou can try running https://github.com/conventional-changelog/conventional-changelog/tree/master/packages/conventional-changelog locally.\n. > Code changes look good! Just to be clear, this is not committing the version to package.json in the main branch on GitHub, right?\nNo. Nothing change in that regards.\nWe just split publish into publish and prepare so it makes it easier to use the git plugin to push the updated package.json. But it's still optional and has to be set up by using the git plugin.. Yes you're right, I didn't think about this situation. We should change the last few releases to be major.\nWe need to make the following changes:\n- 13.3.0 => 14.0.0\n- 13.3.1 => 14.0.1\n- 13.4.0 => 14.1.0\nWe would have to do the following step for each release to rename:\n- Checkout the tag with git checkout tags/v<old_version>\n- Push the new tag with git tag <old_version> <new_version> and git push origin --tags\n- Set the version in package.json\n- Publish on npm with npm publish\n- Deprecate the wrong release on npm with npm deprecate semantic-release@<old_version> \"Replaced by release <new_version>\"\n- Modify the GitHub release to reference the new tag\n- Delete the old tag with git push --delete origin <old_version>\nThen we need to add the breaking change description and migration guide to the 14.0.0 release, and update the plugins peerDependencies.\nOr for simplicity sake we can just rename 13.4.0 to 14.0.0 and just remove 13.3.0 and 13.3.1.\n@gr2m does that sounds good to you?. Or maybe even better, we could:\n- make a fix commit that set false to the default fail and success plugins => release 13.4.1\n- Deprecate on npm the version 13.3.0, 13.3.1 and 13.4.0\n- make a breaking change that re-enable @semantic-release/github as the default for success and fail => release a clean 14.0.0\nThat seems a lot simpler to do so.\n. Doing what I mentioned in my second comment seems even more simple as we don't have to change any tag or release notes. So if we go for simplicity maybe that's a better choice?. Yes it was implemented and it's included in 15.1.3.\nWhat is your semantic-release configuration? Are you using https://github.com/semantic-release/gitlab-config ?. Awesome! Thanks for the feedback!. This is because your OS expand whats inside${} as if it was an environment variable. As the version environment variable is probably not set, semantic-release receive test- from your OS.\nYou have to escape the $ like that semantic-release --tag-format test-\\${version}. This error doesn't seems related. It happens when we execute npm config get tag to retrieve the npm dist-tag configured.\nWhat happen if you run npm config get tag manually in your project?\nCan you provide the configuration in your .npmrc and publishConfig in your package.json?. It seems npm is trying to do something with ${version} but I can't figure out how what you pass in --tag-format ends up meddling with npm.. I think I found out. It seems you have tag=test-${version} in your .npmrc.\ntag in .npmrc is for npm dist-tag, it has nothing to do with the Git tag format.\nYou should remove that from .npmrc.\nPlease let us know if that solve the issue.. @naerion89 did the suggestions above solved your issue?. I'm going to close this issue, feel free to re-open if the problem persist.. Yes we didn't plan for scenario. If one the environment variable within GIT_CREDENTIALS, GH_TOKEN, GITHUB_TOKEN, GL_TOKEN or GITLAB_TOKEN is set then we convert the repository url to https and we use the token.\nAs you notice if you set your repository url with http, we use it and don't convert to https.\nI'm not really sure how to solve that on our side as we need a way to figure out that the GL_TOKEN is set for API purpose only and not for accessing the repo.\nMaybe we could try git push --dry-run with the actual url configured and if it works use it. If it doesn't we try to convert to http/https and use the GL_TOKEN as of now. I'd to experiment a bit to see if that could work.\nWhy not using https for your repository? Is it a common situation to not have https enabled?. Ok all done!. Those question are better asked via our different support channels.\nYes it's possible to semantic-release without a CI. See this FAQ. As mentioned there it's not the recommended approach, but it's possible\nRegarding GitHub Enterprise, several CI can be used with it I think (Travis Enterprise for example).\nsemantic-release supports GHE, see githubUrl \n and githubApiPathPrefix options.\nsemantic-release should also work with any CI supported by env-ci.\nIf a particular CI is not supported we can add it as long as we have the documentation regarding the environment variables available.. Usually Gitter/Stackoverflow is the best option (or at least I spend more time there than on Twitter). Thanks !. That's the expected behavior, the updated package.json is published on npm but not pushed to the Git repository by default.\nSee this FAQ for explanations and solutions to push the package.json to the Git repository.\n. @bjavaid does that address your question/concerns ?. I'm going to close this issue, feel free to re-open if the problem persist.. Maybe implementing #563 could help here. We could have the last major release on @next and the previous one on @latest and plugin could do the same. Just a though.\nI tried to maintain backward compatibility as much as I could but it's not always easy and in some cases it could have been done in a better way.\nBut unfortunately in some cases it's not really possible or it creates a lot of extra work.\nFor example in the cases of 9.0.0 it's really difficult to maintain the ability to call semantic-release with both semantic-release and semantic-release pre && npm publish && semantic-release post because internally a lot has changed.\nMaintaining backward compatibility (with deprecation) from one major to the other takes time. And this is time that would not be invested in developing new features, so it's a trade-off.\nSo far, developing new features was prioritized over maintaining backward compatibility, which create some hurdles. Hopefully the pace of breaking changes should slow down, or be less impactful. But as the number of users is growing it's probably time for us to move the cursor a bit more toward focus on backward compatibility.\n. We also try to release on @latest less often, and keep breaking changes on @next only for a longer time. This way we can release on @latest multiple breaking changes at once.\nOne easy thing we can start doing is to give advance notice when a version will be made available on @latest, so plugin creator have more visibility.. I'm not really sure what the feature you are proposing would do exactly.\nCan you add more clarifications?\nAlso, would it be covered by #563?. Can you clarify what you mean by \"the published artifact's version's prefix\"?\nnpm and other package management registry doesn't have any version prefixes. Your version has to be a valid semver like 1.0.0 not xyz-1.0.0.\nnpm support dist-tag, which allow you to make a given version available only to certain users. Releasing on different dist-tag based on the release branch is what is currently developed as part of #563.. I'm not even sure how that works as fdp-tool-cli-1.1.0-feature14 is not a valid semver, so I'm surprised npm even accepts it.\njs\nconst semver = require('semver');\nsemver.valid('fdp-tool-cli-1.1.0-feature14');\n//=> null\nIn order to define the version published npm reads the package.json you send in the published package (the .tgz), but you mention you don't update it. So I'm not really what you are publishing exactly...If you don't update it you would publish the version 0.0.0-dev over and over, which npm would refuse as a version can be published only once.\nMaybe you can provide a link to your repo?\nAnyway in any case, semantic-release will not implement a feature to publish invalid semver.. 42.6.7.9.3-alpha is a valid pre-release version indeed, but for info fdp-tool-cli-1.1.0-feature14 is not.. That's going to be handled within #563 via the branches option. Do you know if this PR was referenced somewhere else? Like in a commit message or in a PR associated with a commit?. In the case of 1070 and 1071 it doesn't seems they are referenced by another commit or PR.\nI think it happen when we split the search request in multiple. If there is multiple request that return the same PR they will be commented twice.\n. semantic-release-cli setup sets up the npm and GitHub token on your CI, not on your local machine.\nIf seems you are running npm run semantic-release locally. You probably don't have the GH_TOKEN environment variable set locally as indicated by the error No github token specified.\nIf you want to run semantic-release locally you have to set the NPM_TOKEN and GH_TOKEN environment variable on your local machine as indicated in this FAQ.\n. It seems I can't access your repo or the CI logs. I have a 404 error.\nDoing npm -g install @semantic-release/git semantic-release && semantic-release should work.. In your package.json I see \"pkgRoot\": \"dist\" but in the CI logs Wrote version 2.19.1 to package.json. It should be Wrote version 2.19.1 to dist/package.json.\nI cloned your repo and tried, and semantic-release properly logs Wrote version 2.19.1 to dist/package.json.\nAre you sure the current configuration in package.json is the one that was used in the CI job for which you provided logs?\n. The problem happens in travis-deploy-once not in semantic-release.\nIs you repo added to Travis? Did you change your repo name recently?. It seems it's the Travis API that returns a 403 times to times for the auth/github endpoint.\nOn my local test it seems to happen quite rarely. I get only every 20 or 30 calls when call the API repeatedly and really fast.\nI'll implement a retry mechanism in travis-deploy-once as it seems it's the only workaround possible.. Thanks. > It appears that semantic-release only analyzed the commits since the last tag, rather than the last release to the latest npm channel.\nThat's right we retrieve the last release with git tags now instead of using the npm registry.\nHowever if you release some version from another branch and merge it later on the branch managed by semantic-release, it should work as long as you create tags on your other branch.\nThis would work because the tags would \"follow\" the commits when you merge.\nFor example if you have the branch master with the last release being 1.0.0 and you create a new branch next. Then you do some work on next, releasing 1.1.0 and 1.2.0 by creating the tags v1.1.0 and v1.2.0 and releasing on @next dist-tag.\nThen you merge next into master and semantic-release runs. The last release will be determined as 1.2.0, because the v1.2.0 is in the master history since the merge.\nIf you are making prerelease that's a different story as they are outside the normal semver rules.\nFrom the above example, if you release 2.0.0-beta.1 and 2.0.0-beta.2, then after the merge will find the last release as 1.0.0, which is intended, and release 2.0.0.\nLong story short, it should work as you expect as long as:\n- You create tags for each release\n- You don't rewrite the git history in a way that would disassociate the tags created during the release from their commits\n. Ah! I didn't read properly, sorry.\nYes v2.0.0-beta.5 should be excluded from the tags we consider. . Yes, with the tagFormat option. This issue was just reported on Gitter :) And I'm working on a fix :)\nFor reference: https://gitter.im/semantic-release/semantic-release?at=5aa3165c8f1c77ef3aa24ca0. So the problem is that we parse by mistake the issues referenced in Greekeeper Pull Request.\nFor example https://github.com/eventualbuddha/add-variable-declarations/pull/83\nWe end up parsing #3128 as a closed issue because it contains replace phantomjs with puppeteer for browser tests; closes #3128.. Fixed in https://github.com/pvdlg/issue-parser/pull/6.\nJust make sure to update the issue-parser dependency if you are using a lockfile.. Can you re-run with debug enabled?. If you use the environment variable you have to set it to DEBUG=semantic-release:*. It seems to required by debug.\nI noticed the problem with Unable to find remote helper for 'git+https' and I'm working on a fix.\nThe problem is that when we retrieve the package.json here it goes through normalize-package-data which transform the URL to git+https format for some reason.\nWe check if the bare URL from package.json allow us to push here and it it doesn't we transform the URL to add the auth part.\nBecause of this issue verifyAuth(options.repositoryUrl, options.branch) always return false so we always go into getGitAuthUrl(options.repositoryUrl) which transform the git+https URL into https.\nSo this problem is not the cause of The push permission to the Git repository is required. The only explanation I see for The push permission to the Git repository is required is a temporary issue on GitHub or Travis.\n. I'm not really sure what is happening...But it seems that the problem is intermittent.\nMaybe it's an issue that happen on very specific cases and we can solve it. But we would need more data to figure out what's going on.\nSomething that would be help is to configure semantic-release in debug mode (with --debug) and see exactly what the error is when it happens.\n. That happens here: https://github.com/semantic-release/github/blob/7b6bc952e03e5215f6d2862b983431f71f457ccd/lib/verify.js#L77-L92\nThe owner/repo is determined from the repositoryUrl (which come from either the repositoryUrl, your package.json's repository value or the origin remote of the cloned repo).\nIt's parsed there: https://github.com/semantic-release/github/blob/master/lib/verify.js#L71\nI don't really see how the G could be truncated...\n. What is the value of the repository key in your package.json?\nAs mentioned in the doc the shorthand version is not supported. . I guess we could support the shorthand but only for one provider (probably GitHub) as there is no way to know if owner/repo should be expanded to https://github.com/owner/repo, https://gitlab.com/owner/repo or https://custom.com/owner/repo.\nAlso when the shorthand is used we would always communicate with https and never with ssh.. > Ah, okay, that's the problem then. We have ours as shown in #695 (comment). We had a major version bump recently and this must've been supported on our previous version as we've got a number of projects setup this way that have been working. Appreciate the help!\nAh sorry I missed than in the previous comment. Several version ago the Git tag were created via the GitHub API and are now created via the git CLI. Maybe that explain the problem appearing after an upgrade.\n. I think this FAQ should answer your exact question.\nAlso you shouldn't use condition-circle as CI related verify plugins are not required since several version of semantic-release.\n. The npm plugin is used for the publish, the verifyConditons and the prepare step.\nYou need to set npmPublish in the 3 of them. Or for more simplicity you can set npmPublish directly in  the release object.\nEven if you don't publish on npm, you still need to configure GH_TOKEN to publish on GitHub. This is why you get an error message.\n. This because your .releaserc.json is not formatted properly. It should be:\njson\n{\n  \"verifyConditions\": [...],\n  \"prepare\": [...],\n  \"publish\": [...]\n}. The GH_TOKEN must belong to a user with push access to your repo. Maybe that's the problem.. I don't know there must be a difference between the 2 repo in the way you create or set the GitHub token.\nThe check for the GitHub token permission is done here: https://github.com/semantic-release/github/blob/7b6bc952e03e5215f6d2862b983431f71f457ccd/lib/verify.js#L77-L92. No you can't disable it, and even if you could it wouldn't solve the problem as the permission is required to make the GitHub release. So it would fail later in the process but still fail.\nYou can run this code to check what is the permission associated with your token:\n```js\nconst Octokit = require('@octokit/rest');\nconst token = '...';\nconst owner = '...';\nconst repo = '...';\nconst client = new Octokit();\nclient.authenticate({type: 'token', token});\nclient.repos.get({repo, owner}).then(result => console.log(result.data.permissions));\n// => { admin: true, push: true, pull: true }\n``\nIf your token is configured properly you should havepush: true` in the logged object.. @ts-npm did you manage to find the problem regarding the permissions? Is semantic-release working on your repo?. Thanks for the feedback! Glad everything works now.\n\nIt's unclear that if you want to set a configuration to override all aspects you have to set that at the top level of the configuration object (e.g. \"npmPublish: false) or setting it for every single plugin config.\n\nI think this is mentioned in the plugin configuration doc.\n\nThe semantic-release-cli does not take a private github url into account when creating a gh token\n\nYes the CLI needs several improvement in that regard. I think there is some issue opened for that. If not feel free to open one.\n\nThe required configurations for the github token are not super clear, they're defined in the semantic-release-cli as\n\nYes indeed. However it's mentioned in the github plugin doc.. We check if the repositoryUrl configured in the via option or package.json allow to push to repo with transformation. Then if it doesn't we transform it and test again.\nThis has been implemented in #667 and implemented in #671.\nWhat would be the point of removing this feature? In which way does it creates a problem?. > The problem at the moment is that it creates ugly error messages.\nThe message appears only with --debug.\n\nIn my mind errors should not be ignored as the above one.\n\nWe use the git to determine if we have push access. If we don't have push access the cli return an error (as a non 0 return code). In such case the error means that we don't have push access. So it's not an error in the sense that it's an expected possible outcome.\n\nI think it duplicates the functionality of the verifyConditions step.\nIf I use github or plain git the corresponding module should take care of the connectivity and not the main program.\n\nNo because the core needs push access to create the Git tag. The core cannot rely on plugins to make this verification, as plugin are optional (that's the concept of plugins after all). The core has to verify what it requires, and the plugin verify what they require.\n\nI did not test it but if would add repositoryUrl like\n\nIt seems this sentence is incomplete.. Once again, the process works as follow:\n1. Check if the URL configured in repositoryUrl, or package.json or in the origin remote of the repo allows to push\n2. If it does allow to push, use this one\n3. If it doesn't allow to push, transform it to https or http and add the credentials\n4. Test if get push access\n5. If allows to push use it, if it doesn't throw an error\nThis is implemented this way as there is use cases in which users want to use the URL they configure without adding the credential. This is useful for example when they configure GH_TOKEN to access the API but want to use ssh keys for the git command line.\nI really don't see the point of removing the ability to use a non transformed URL if it provides the proper push permission. We are not going to remove a feature that was requested, implemented and useful for some users, especially if having this feature doesn't create any issue and everything work as expected.\nI understand the current implementation might not provide value for your specific use case, but that's not a reason to remove it, especially as it doesn't prevent your use case to work. Other users rely on that behavior.\n. @AVVS this is not the same as what's reported in this issue, however it's a good point.\nGit ask for user/password in the following conditions:\n- The repo config credential.helper is set with a store that can ask for user/password\n- The GIT_TERMINAL_PROMPT environment variable is not set to 0\n- The authentication fail\nAs far as I know most CI environment do not set credential.helper so the credential will not be asked when running on a CI. They would be asked when running locally, which is expected, so users can type them in the prompt.\nI never encountered this issue, and we didn't had report that it happened to someone in the CI environment. Does it happened to you? Did that happen on the CI environment?\nWe could set a timeout for execa as you suggested and set GIT_TERMINAL_PROMPT to 0 to make sure the problem won't happens. However when running locally (for a dry-run or a local release) users would have to configure GIT_CREDENTIALS, GH_TOKEN or GL_TOKEN as they won't be prompted for user/password in case those are not set. It's not necessary a big issue as in most cases GH_TOKEN is required anyway, even for dry-runs.\nIf we make such fix, I'd like to have a way to reproduce the issue on a CI environment, so we can test we actually fix it.. Did you experience this issue on Semaphore? Do you have the semantic-release config and the CI logs when the problem happened?\nIs what you describe is actually a problem you experienced or just a concern?. It seems I can't access the semaphore links you provided. I get a 404 page.\nCan provide the semantic-release logs via a Gist or in this issue?. Ok I'm looking at it. For information if you want to use ssh rather than https you have to configure repositoryUrl as a git url (like git@github.com:owner/repo.git). This way the first call to git --dry-run will works if your ssh keys are properly set up, and semantic-release will use that URL.. After further investigations, Travis never prompt the user because it sets GIT_ASKPASS=echo.\nSemaphore doesn't set this variable and prompt for the user/password.\nOn Semaphore, if GIT_TERMINAL_PROMPT is set to 0 or if GIT_ASKPASS is set to echo there is no prompt and the git command errors out as expected.\nIt seems GIT_TERMINAL_PROMPT is a good solution but it was added in Git 2.3.0. The current version of Git is 2.16.1 but some CIs (especially CircleCI) use really old version of git.\nSo in order to be sure it won't happen on any CI I would propose to do the following, only when semantic-release runs on a CI:\n- Set GIT_TERMINAL_PROMPT to 0\n- Set GIT_ASKPASS to echo\n- Set a timeout when calling execa\n. @AVVS the change has been released in 15.1.2.\n@escalate I'm going to close this issue as it doesn't seems you are reporting an actual problem. If you experience a problem, please re-open this ticket or a new one. . Yes indeed. See https://semantic-release.gitbooks.io/semantic-release/content/docs/usage/ci-configuration.html#authentication . @travi, @richardson-trevor the support for shorthand URL was released in 15.1.0 (on @next dist-tag). Would you mind testing and let us know if it works as expected? So we can release the feature on @latest once we are sure it works as expected.\nThanks!. Good catch! Thanks!. Thanks for the report. I found the problem, I set the environment variables after checking for the auth...which doesn't make any sense. I was working on another PR which change a few things regarding where the auth check is done and I got mixed up. My bad.\nI'll push a fix shortly.\nIn addition it seems the execa timeout doesn't work when the shell is prompting the user.\nNot sure if it's a bug of if it's expected. I'll investigate more.\n. @AVVS can you test with version 15.1.3 that is released on @next?\nIf everything works fine I'll release it on @latest.\nThanks. Oops I was a bit too fast to post this coment. The release will be done in a few minutes.. IT seems Travis has an issue to download a Docker image we use for the test so it prevent the release to be done. It's probably going to take a few hours to be resolved..... Ok it's released now!. I just tested in 15.1.2. https://github.com/upfrontIO/microschema, //github.com/upfrontIO/microschema and upfrontIO/microschema are all converted to https://github.com/upfrontIO/microschema.\nThen we run git push --dry-run https://github.com/upfrontIO/microschema HEAD:ci-integration, if it works we use the URL https://github.com/upfrontIO/microschema. If it doesn't we convert the URL to https://<GH_TOKEN>@github.com/upfrontIO/microschema HEAD:ci-integration and run git push --dry-run https://<GH_TOKEN>@github.com/upfrontIO/microschema HEAD:ci-integration.\nIf it still doesn't work we return the The push permission to the Git repository is required. error.\ngithub.com/upfrontIO/microschema is not a supported format and is an invalid URL as far as I know.\nWhat do you get when you run in terminal the following:\n- git push --dry-run https://<GH_TOKEN>@github.com/upfrontIO/microschema HEAD:ci-integration\n- git push --dry-run https://github.com/upfrontIO/microschema HEAD:ci-integration\nCan you also run semantic-release with the --debug option and post the logs here?\n. So in the case of https://github.com/upfrontIO/microschema it seems the user/password you are typing in the prompt are wrong as shown by the error remote: Invalid username or password.\nThis error happens only when the password is wrong. If it was a permission issue you would get the error remote: Permission to upfrontIO/microschema.git denied to<username>.\nWith //github.com/upfrontIO/microschema the first attempt fails as it's a invalid URL. Although semantic-release manage to convert it to https://<GH_TOKEN>@github.com/upfrontIO/microschema.git and it works.\nAs far as I can tell everything works as expected:\n- semantic-relrease test the permission with the URL provided, and if it fails and do not on CI you get the username/password prompt. If you enter a wrong password it fails\n- If testing the original URL errors out semantic-release attempt with the GH_TOKEN as https basic auth\nIt seems your token is correct but the password you are entering is not.\n. When you get the prompt it's a prompt from git not semantic-release. As far as I know you can't use the GitHub token as a password. You can use it as user and password with https basic auth.\nIf you run git push and you get the prompt for your username password and use the token as the password it would fail as well.\nsemantic-release behave differently because:\n- In the first case you pass a correct URL, and your OS/git CLI is not set to save the password. semantic-release try to use the URL you provide first and as your not in a CI environment it lets git to ask you for your credentials. If you were in a CI environment it would directly try to convert the URL to use the GH_TOKEN\n- In the second case you pass an invalid URL (as far as the git CLI is concerned) so the first try fails and semantic-release tries to format the URL with GH_TOKEN. This is a quite edgy case and semantic-release expect you to provide a valid git URL. And there is no good way for semantic-release to figure if the first call to git push --dry-run fails because the auth is wrong (and there fore try to add the GH_TOKEN as basic auth) of if it's because you provide a URL that is valid for node url.parse parser but not valid for git\nThe problem is that in the first case you try to use a GitHub token as a password which is not supported and in the second one use //github.com/upfrontIO/microschema as a Git URL which is not supported by the git command line.\nI'm afraid there is no much we can do in semantic-release. Testing all the possible cases of valid URL for node url.parse that happens to not be valid for the git command line seems really out of scope.\n. It seems I was mistaken and the token can be used in the git CLI as the password.\nThe prompt for username/password is from the git command line, not from semantic-release.\nSo it seems that for some reason the git CLI refuses your token as password and errors out with remote: Invalid username or password.\nI don't know why, but it seems unrelated to semantic-release. If you do git push --dry-run https://github.com/upfrontIO/microschema HEAD:ci-integration you would have the same prompt and if you enter the same username/password you will have the same error.\n. Do you currently have this behavior when you test the different version? As if you explicitly install semantic-release@15.0.2 and test?\nCan it be due to something that changed in your environment?\n. I'm not sure I understand your test. Did you explicitly test with 15.0.2 by installing with npm install semantic-release@15.0.2?. > So it seems that depending on how you test if the connection works you get different results from the same token. As the permissions on the token are be good enough in both cases (for a public repository that is).\nI'm totally lost as that point. I still don't know if you are currently experiencing a different behavior when doing:\n- rm -rf node_modules && npm install semantic-release@15.0.2 => Test\n- rm -rf node_modules && npm install semantic-release => Test\nRegarding the verification semantic-release verify the push access the same way in 15.0.2 and 15.1.2 with git push --dry-run https://github.com/upfrontIO/microschema HEAD:ci-integration so I don't understand what do you mean by \"depending on how you test if the connection works you get different results from the same token\".. I tester the 3 version you mention and in all cases I get the prompt for the user password.\nI set the repository url to https://wrong_user@github.com/semantic-release/semantic-release.git in order to force a prompt, otherwise git would use the user/password in my keychain.\nVersion 15.0.2:\n```bash\nnpm install semantic-release@15.0.2\nsemantic-release --debug --repository-url https://wrong_user@github.com/semantic-release/semantic-release.git --dry-run\n[Semantic release]: Running semantic-release version 15.0.2\nPassword for 'https://wrong_user@github.com': \n```\nVersion 15.0.3:\n```bash\nnpm install semantic-release@15.0.3\nsemantic-release --debug --repository-url https://wrong_user@github.com/semantic-release/semantic-release.git --dry-run\n[Semantic release]: Running semantic-release version 15.0.3\nPassword for 'https://wrong_user@github.com': \n```\nVersion 15.1.2:\n```bash\nnpm install semantic-release\nsemantic-release --debug --repository-url https://wrong_user@github.com/semantic-release/semantic-release.git --dry-run\n[Semantic release]: Running semantic-release version 15.1.2\nPassword for 'https://wrong_user@github.com': \n```\nSo as far as I can tell all 3 versions behave the same, at least on my machine.\nDo you have a reproduction scenario that I can use to debug?. I tried remove everything git related in my keychain and remove the GitHub ssl key I have installed.\nI still have the same behavior in all 3 versions, and everything work as expected when I enter my username and password.\nThe only change that was made between those version is that we expand the shorthand URLs (semantic-release/semantic-release => https://github.com/semantic-release/semantic-release/issues/708#issuecomment-374558363).\nAs far as I can tell semantic-release behave as expected. So I guess we can close this issue?\nIf you'd like to investigate why you have a different behavior between different versions feel free to do so, but you would have to troubleshoot and debug on your own as it seems it happens only with your environment. I can help but without detailed steps to reproduce I can't do much. If this investigation leads to finding an actual bug, then you can open a new issue with the relevant information.\n. That's the way if was working before (in 13.x.x or 12.x.x I think) but we changed that as in some case you want to have different method of authentication between the git CLI and the various API client. For example to use SSL keys for git CLI and GH_TOKEN only for the GitHub API.\nThere is many many uses cases around that, and they are really difficult to test as they involve proprietary Git repo, private GitHub/GitLab/Bitbucket instance, private CI, private authentication mechanism etc...\nThe implementation decision have mostly been made for running in a CI environment as it's the most common and the recommended way to use semantic-release.\nAlso we assume that in most cases when running locally authentication will not be necessary as the vast majority of users would have their credentials stored in some sort of keychain, or would have installed ssh keys, because you don't want to type your password every time you push...\n. > 15.1.3 fixes the issues!\nI really don't understand how...But great news anyway!\nFor information 15.1.3 just prevent the git CLI to prompt for a username password when you are running on a CI. It doesn't change anything when you run locally (unless you use --no-ci).. Do you know how we can test the push permission on a specific branch that wouldn't create this problem?\nIn such situation would creating a tag on the head commit and pushing it would work?\nIt seems this situation happens in the local branch on the CI is behind the remote branch. How can this happen?. I don't know how to properly ignore this error other than parsing the output which is not great as if the output change in a different git version it won't work.\nMoreover I don't think we should consider this as a success because in this situation when we do the actual push to create the tag, it will fail as well, isn't it?. No, we use git push with execa. The GitHub API is used only in the GitHub plugin to create the release.\nUsing git push has several advantages over using the GitHub API:\n- Doesn't require to use the GitHub plugin\n- Independent of the type of repo (GitLab, BitBucket, custom Git repo etc...)\n- It allows us to create the tag in the core and control when the tag is created (after the prepare step and before the publish step)\nThat said even if we using the API that would create an other issue as we would create the tag on the wrong commit due to the discrepancy between the local and remote head.\nI think we should still fail in such situation, but that would be great if we could display a more helpful error message in such situation.\nMaybe we can add a test to make sure the remote head and the local head are the same.\nAnother solution would be to force a pull but that probably not a good idea as we would run semantic-release on a different code than the one on which the CI ran the tests.\n. I tested there: https://semaphoreci.com/vanduynslagerp/test-semaphore/branches/master/builds/45\nIt seems to work ok now and the git auth check doesn't ask for the password and fail as expected.\nTesting unreleased version on Semaphore is a pain as when installing a package from a branch, Semaphore just ignores it and install from master. So I had to make a release in @pvdlg/semantic-release. Also it seems there is some sort of cache on Semaphore so even if the last release is 1.0.3 on semaphore the version 1.0.0 is installed, so I had to specify npm install -g @pvdlg/semantic-release@1.0.2.\n. If you are using npm you can find a solution in this FAQ: How can I use a npm build script that requires the package.json\u2019s version.\nIn any case you probably want to run different jobs on your CI for your test and for the release. You can have for example a few jobs running the test only (you app will be built with version 0.0.0-dev but it shouldn't be an issue for the tests) then a job to release. On the release job you can skip the tests (as it should run only if the test jobs are successful) and you can configure semantic-release to use the exec to run your build script on the prepare step, after the npm plugin.. @abalad did you manage to configure semantic-release the way you want?. I'm going to close this issue as its a support question and the additional information requested 3 weeks ago were not provided.\nI you have questions regarding semantic-release usage and configuration please take a look at the documentation and use one of our support channels: https://github.com/semantic-release/semantic-release#get-help\nIf you find an actual bug or want to propose a new feature, please open a new issue following our contribution guideline.. It seems sinon 5.0.0 was released unintentionally. It's not in the release of the repo and a few minutes after 5.0.0-next3 was released on the @next dist-tag. So we should probably wait to merge those PRs and possibly close them.. Good catch! Thanks for reporting!. No version is released because you are using semantic-release in dry-run mode (with the -d option) so it determine the next version and log the changelog but doesn't release anything. That's the intended behavior of the dry-run mode.\n\nIs the first release supposed to be done manually without semantic release?\nNo, 1.0.0 will be released as soon as you push a commit associated with a release type.\nIf so, does semantic release expect the first release supposed to be 1.0.0?\nSee Can I set the initial release version of my package to 0.0.1?\nSo what, then, is the recommended/best way to publish a package but keep it in \"pre 1.0.0\" so users do not download until it is ready and stable?\n\nIf you don't want users to download your package then don't release it. Work on a dev branch that you will merge to master once its stable. Or just don't run the semantic-release command until you are ready to release.\n. The error you have seems to be because the token you set doesn't allow to publish on your organization. The \"You may not perform that action with these credentials\" comes from npm, not semantic-release.\nRegarding your other questions, take a look at #563.\nThat would allow to release \"prereleases\" (such as 1.0.0-beta.1, 1.0.0-beta.2 etc...).\n. What you suggested will be clarified as part of #563.\nShould we close this issue as it seems your initial problem is solved?. It seems the user associated with the token you configured doesn't have push access to your repo.\nCan your run semantic-release with the --debug option (or the DEBUG environment variable set to semantic-release:*) and post the logs?\nAlso what is the repository URL you configured in your package.json?. According to the logs you provided, the verification error happens way before semantic-release push the tag or the release. Unless you provided the wrong logs, it's not semantic-release that create this release.\nCan you provide the information requested?. All the logs you provided show different errors. It seems they were not generated with the same configuration...\nFirst, you shouldn't have multiple pipeline running semantic-release. You should have only one that runs after all the test pipeline are successful as explain here: https://semantic-release.gitbooks.io/semantic-release/content/docs/usage/ci-configuration.html#run-semantic-release-only-after-all-tests-succeeded\nIn one of the log you provided you have the error ERROR: The key you are authenticating with has been marked as read only. so it seems your token (or ssh key if you are using one) doesn't allow you to write to your repo.\nIn an other logs you have an error when semantic-release call the search issue API: The listed users and repositories cannot be searched either because the resources do not exist or you do not have permission to view them.\nThe permission of the Token are correct, but probably the user associated with the token doesn't have the permission to push or search issues.\nAs requested before what is the repository URL configured in your package.json?\nIs it https://github.com/riqra/riqra-graphql? Is this repo exists?\n. You have some logs that reference https://github.com/riqra/riqra-saas-api and other that reference https://github.com/riqra/riqra-graphql so it's really confusing.\nEither mixup the logs you provided in this issue or you mixed up the repository urls in your package.json.. Related to #559\nDo you know what is the minimal Git version that we can support based on the git command we run in lib/git.js ?. Maybe we could also check the git bin is in the PATH with something like https://github.com/springernature/hasbin or similar.. I would like to invite you to read our contribution guidelines, in particular the section about the issue tracker:\n\nThe issue tracker is the channel for bug reports, features requests and submitting pull requests only. Please use the Support and Get help sections for support, troubleshooting and questions.\n\nIf you currently run npm publish from the root folder there is nothing special to do. Just configure semantic-release normally as indicated in the doc.\nIf you run npm publish from the lib folder then just set the pkgRoot option to lib.\n. How is the package.json inside lib generated and when? Is the file exists when semantic-release?\nIf you look at the npm plugin doc:\n\nNote: The pkgRoot directory must contains a package.json. The version will be updated only in the package.json and npm-shrinkwrap.json within the pkgRoot directory.. Have you tried with pkgRoot set to lib as I suggested before?\nAs mentioned before and in the doc:\nThe version will be updated only in the package.json and npm-shrinkwrap.json within the pkgRoot directory.\n\nIsn't the version in lib/package.json updated?. Also according to your screenshot you have a package.json in the root and another in src/lib. But you don't have a lib at the root of your project.\nAlso, the package.json used to deliver is typically generated by the build step (based on the root package.json) and is not checked in the repository. . Then just set pkgRoot to whatever directory you want npm publish to be run from.. Thanks. Please let us know if it works.\nFeel free to close the issue whenever everything works as you expect.. As mentioned in my first comment please use the proper support channels.\nThanks.\nSee #731. You have to configure pkgRoot for both prepare and publish steps.. The dry-run mode indeed skip publishing and print next version to be released.\nThe error you have is because you don't have push access to the remote repository.\nThe Dry-run mode verify the repository push permission, even though nothing will be pushed. The verification is done to help user figuring out potential config issue.\nYou should make sure the branch you running on exists on the remote repo and that you are allowed to push to it.. You should also make sure to use the last version (15.1.4) as it contains several improvements regarding the push permission verification.. @benjamincharity did that solve your issue?. As mentioned in the doc and the CLI help message the --dry-run option just skip publishing, print next version and release notes. I don't think there is anywhere in the doc we suggest if would work the way you describe.\nThe dry-run mode isn't meant to run on a feature branch to test what would happen if you would merge it to the release branch. Running semantic-release on a PR (or on a feature branch) is currently not supported. This is something we might consider implementing in a GitHub app but there is a lot of unresolved challenges so far.\nThe objective of the dry-run mode is:\n- Preview the first release for folks setting up semantic-release for the first time\n- Preview the result for folks using releasing from their local machine instead of a CI\nIf you still want to do what you describe, locally, you can run semantic-release --dry-run --branch <release-branch>. That will work only if the <release-branch> exists on the remote repo (i.e. the PR was already opened). The result will be consistent only if the feature branch is not behind the release branch (i.e all the commits in master are present in the feature branch).. semantic-release uses tags to determine the new commits between the last release and now.\nsemantic-release created the v1.0.1 tag on the first run and failed to publish to npm due to the wrong token.\nThen on the second run semantic-release tried to determine the new commits between the last tag (v1.0.1) and now and found none.\nsemantic-release tries to make as many checks as possible before creating the tag to avoid this situation, but it seems in your first run the checks passed even the token was invalid for publishing. It's because npm doesn't offer a way to check the permission of a npm token. We can only check that a token is set and valid but we cannot check if it allows to publish on a given orga.\nTo solve the problem you should delete the v1.0.1 tag and run the CI job again.. See https://github.com/npm/npm/issues/7932\nIt seems it's related to the permission of the npm user for the scope.\nIs your package is public? If yes make sure to include the following in your package.json:\n\"publishConfig\": {\n  \"access\": \"public\"\n}. What is the error you got in your example? I'm trying to figure out when git merge-base --is-ancestor could returns an error with a code different than 1.\nCould you provide the logs of git merge-base --is-ancestor v4.4.1 HEAD?. It seems it a GitHub search issue.\nIn the example you provided, semantic-release found the commit 101226db977d8fa85c50bcef78f18e39735f1081 and make a GitHub issue search.\nThe search is equivalent to: https://github.com/renovateapp/renovate/issues?utf8=%E2%9C%93&q=101226db977d8fa85c50bcef78f18e39735f1081\nAs you see it returns #1774 and #1761. #1761 make sense, however #1774 is returned by GitHub even if it's unrelated. semantic-release has no way to know the PR #1774 is unrelated and just trust GitHub search.\nThen #1080 is also commented because #1774 references it.\nIt seems this is due to this comment https://github.com/renovateapp/renovate/pull/1774#discussion_r178764564 from #1774 that references some code from the commit 101226db977d8fa85c50bcef78f18e39735f1081.\n~~Unfortunately I don't think there is anything we can do in semantic-release as there is no way to tell the GitHub search to return only the PRs that are associated with the commits and not the PR that contains a comment referencing the unrelated commit.~~ See following comment. Maybe we could use this endpoint to make sure the PRs returned by the search actually contains one of the release commits.. Yep. I'm going to implement that shortly. Thanks for the detailed report!. @rarkins I opened the PR semantic-release/github#59 that should solve the problem.\nFeel free to review it!. semantic-release doesn't handle the config file priority itself but relies on cosmiconfig which search for the config file in the following order: package.json, json rc file, yaml rc file, js rc file.\nIt's also important to note that the config are not merged. The first config file found is used. The CLI options are a bit different as they are merged with the config file content and take precedence.\nI don't think it make sense to change this order of priority or that it's relevant to care about the order in any way. Only one file is used and projects are not supposed to have multiple file (or package.json entry) doing the same thing.\nIf you want to have a generic config for all your projects and override some properties on each project then you should use a shareable config: https://semantic-release.gitbooks.io/semantic-release/content/docs/usage/configuration.html#extends\n. Thanks for the PR!\nIn order to be consistent with the rest of the docs, the change should be the other way around: github => @semantic-release/github, npm => @semantic-release/npm, etc...\nAs plugins are npm packages it make more sense to reference them by their npm name (which include the scope). In addition it allows to differentiate npm (as in https://github.com/npm/npm) from @semantic-release/npm.\nCould you make the change to your PR?\n. @bertho-zero would you like to modify this PR according to my previous comment? . Thanks!. This is because the update of the package.json version is done in the prepare step and you configured pkgRoot only in the publish step.\nTo solve that issue you should configure pkgRoot directly under release in your configuration so it would applied to both prepare and publish.. It should be necessary as it's used only in the publish step. But it doesn't hurt to put it directly under release and would simplify the config a bit.. What I meant is you could configure like this:\njson\n\"release\": {\n    \"pkgRoot\": \"dist\",\n     \"assets\": [\n          \"dist/*.zip\",\n          \"dist/*.tar.gz\"\n     ]\n  }. That's explained here in the doc: https://github.com/semantic-release/semantic-release/blob/caribou/docs/usage/plugins.md#configuration\nBut maybe it's not clear enough. Feel free to propose improvements via issue/PR, it's always much appreciated!. It seems to be an exact duplicate of semantic-release/cli#190 so I'm going to close this one.\nFeel free to re-open if you disagree.. Duplicate of semantic-release/cli#190. The error seems to happen when we check the Travis job on which you are running. It's something on Travis side that happens sometimes.\nsemantic-release 8 is ancient and I'm not sure we can help much with it. I would recommend to install the last version (15.1.5 as of now). We now recommend to use Travis Build Stage (See recipe). That will avoid all the issues related to call the Travis API.\nAll the information you see in the docs are related to the current version of semantic-release. So most of it is irrelevant of inaccurate if you are using version 8, as it's 7 major release behind.\nRegarding your question about GIT_CREDENTIALS, as mentioned in the doc The Git authentication can be set with one of the following environment variables. So you can choose which authentication method you prefer. If you are using GitHub the most simple is to use GH_TOKEN. Just configure the token as before.\nBut if you use GitLab you should use GL_TOKEN and if you use neither (Bitbucket or a custom Git server) then use GIT_CREDENTIALS.\nThey have different name as they are used slightly differently:\n- GH_TOKEN is used for Git (i.e. the git CLI) as basic auth and GitHub API authentication\n- GL_TOKEN is used for Git (i.e. the git CLI) as basic auth prefixed with gitlab-ci-token: and GitLab API authentication\n- GIT_CREDENTIALS is used for Git Authentication as basic auth\n. Looking at the commit on your master branch the 1.0.0 release none of that have a valid angular format:\n- Merge pull request #3 from neekey/release\n- update dummyjs2\n- Merge pull request #2 from neekey/release\n- Merge pull request #1 from neekeyni/master\n- test feature\nNone of your commits since the 1.0.0 release contain fix() or feat() in their subject.\nIf you want semantic-release to analyze those commit you have to format them according to Angular convention.\nIf you look at the convention you will see that fix(), feat(), etc... have to be in the subject not the body.\nFeel free to comment further or re-open if you disagree.. That shouldn't be a problem.\nThe code that build the regexp in get-last-release.js should be something like that:\njs\nconst tagRegexp = `^${escapeRegExp(template(tagFormat)({version: ' '})).replace(' ', '(.+)')}`;\nCan you also add a test that verify the use case you mentioned?\nI would also like to mention that semantic-release does not support monorepo at this point. See #193.\nThere is solution out there be as explain in #193 they don't cover every case of a monorepo.\nSo the semantic-release maintainer team will not offer support for monorepo beside what's outlined in #193, which is mainly working with the community to find the right design that would fully support monorepo.. Plugins were implemented in semantic-release to allow a separation of concern (the plugin do stuff specific to a platform, the core do generic things) and to allow to support specific package managers.\nContrary to project like Gulp or Grunt, that are task runners which can do virtually anything, semantic-release has a much more limited scope: releasing packages. There is a finite number of Git hosted platform, package manager registry, commit conventions and release note format to support.\nEven the verifyRelease step has a finite number of application as it's useful only for verifications related to a release. It's useful when you want to check the release version/type is correct, but if you make verification unrelated to the release version then they should be done as part of your test suite (before running semantic-release).\nFor example in your plugin semantic-release-verify-deps I would have recommended you to do that as part of your tests suite, so the build of PRs that contains local dependencies would fail, and that would avoid to merge it.\nI'm totally ok to list the plugin though. I'm just mentioning it's not necessary always the best approach.\nAs a general rules, the earlier you catch a problem the better.\nProblems that can be caught in the test phase should be handled there. A few example of things that should be done in test:\n- Verify if dependencies have security vulnerabilities\n- Verify that certain type of dependencies are not used\n- Verify code format (linting)\nA few example of things that make sense to do as a verifyRelease step:\n- Verify that if the code break dependents, the release is a major\n- Verify that if the public API changed the release is at least a minor\n- Verify that if the integration tests changed, the release is a major\nIn any case, I don't think the list of plugin for semantic-release is meant to grow to more than a handful or a dozen plugins. Especially because the \"Official\" ones already cover a lot of use cases.\nIn addition, most scenario can be implemented with the @semantic-release/exec.\nTherefore I don't think having an autogenerated list based on an npm keyword would be necessary.\nRegarding the plugin we include in the list, it's a lot more important to have well maintained plugins rather than having a long list. Here is a  few reasons:\n- If a plugin has bugs or is not compatible with a certain semantic-release version or use case, users will most likely open issue on the semantic-release and add to the maintenance burden\n- If we list a plugin, even on the \"Community\" list, we kind of endorse it and user will have certain expectation\n- Having a long list of plugin for the sake of it doesn't bring much value and would confuse users more than anything else\nLong story-short, in the case of semantic-release, the most helpful for the community is to have a curated list of good quality, well documented, well maintained plugins. Basically quality over quantity.. No it's not only for Node.\nCould you provide the information requested in the issue report template? Otherwise there is nothing we can do to help with an error code.. As indicated in the plugin configuration doc by default semantic-release use the @semantic-release/npm plugin for verifyConditions, prepare and publish steps, which update the package.json and publish on the npm registry. This plugin require a package.json.\nIf you don't have a package.json you should disable the npm plugin and replace it by another plugin to make the releases.\nDepending on the project type you have several options:\n- Use the @semantic-release/git plugin to commit compiled assets to your git repo\n- Use the @semantic-release/exec plugin to run a custom shell command in the publish step in order to publish to your package registry\n- Create your own plugin to publish to your package registry if the capabilities of the @semantic-release/exec plugin are not sufficient\n. I updated the FAQ for non-Node project in #743. Hopefully that helps clarifying the steps to follow.. It seems the problem happens with uglifyjs-webpack-plugin postinstall that can't run node lib/post_install.js.\nDid you mean to open this issue to another repo? This is not related to semantic-release in any way apparently.\nIf it's actually related to semantic-release, please reopen the issue and explain where semantic-release is involve.. This is because your repository URL in your package.json is configured to https:git@github.com:mdn/bob.git which is an invalid URL.\nA URL cannot be both https and git.\nYou should configure ~https://github.com:mdn/bob.git~ https://github.com/mdn/bob.git or git@github.com:mdn/bob.git.\nEdit: fixed the http URL in my comment.. Your repository URL is still incorrect. https://github.com:mdn/bob.git is not a valid URL.\nIt should be https://github.com/mdn/bob.git.\nJust copy/paste the URL in your browser when you are on your repo GitHub page to avoid mistakes.. Can this issue be closed then?. Can you clarify what is the URL that semantic-release generate and the one that is expected by VSTS?\nIs it due to .git at the end? Do you know why it's not supported by VSTS, is a pretty standard git thing.. In https://[secure]@conpanyname.visualstudio.com/DefaultCollection/_git/MyRepo is the _git before MyReponecessary?\nIt's not really if that is supposed to be there or not from your example.\nWhat do you get if you do git push --dry-run https://<TOKEN>@companyname.visualstudio.com/DefaultCollection/MyRepo HEAD:BUILD (without .git)? I understand you are not asked the password but what is the return code of the command?\n. Regarding the .git the proper fix is to fix IonicaBizau/git-url-parse#69, update git-url-parse, then remove the .git concatenated by semantic-release. This way the .git will be added at the end of the converted URL only if it was present in the original URL.\nRegarding the _git it seems you already opened IonicaBizau/git-url-parse#67.. Hardcoding a specific behavior based on the presence of a specific string of character in the URL is not the proper fix. This is too brittle (what if CSTS offer different or private domaine names?). In addition it would open the door to fixes for each specific case with more hardcoded conditions that make the maintenance a lot harder.\nSee https://github.com/semantic-release/semantic-release/issues/741#issuecomment-380355402 for a better solution.\nIn addition, when opening a PR, please:\n- Do not modifying the formatting of unrelated code\n- Format the code you change according to the project formatting\n- Add unit tests for the case you add\nI would invite you to read our contribution guidelines in particular the lint and tests sections.. No worries. We wrote the contributing guidelines to help new contributor. . You can find all the explanations, configuration and examples in the GitHub plugin doc: https://github.com/semantic-release/github#assets\nIs there something not clear in the doc that we can improve?. > Honestly I thought the npm build artifact should be uploaded to github by default. Ideally there would be an option for that.\nPlugins are independents, so the github plugin doesn't know if you are releasing on npm or somewhere else. semantic-release support a lot of workflow, project type, package manager registry etc... Every users have a different workflow, produces assets with different name in different folder, some want to upload to GitHub, some don't. At that point there is no point to maintain a state shared by different plugins, so there is no way for the github plugin (or semantic-release core) to know if an npm tar.gz was create and where it was created.\n\nIf I understand correctly we need to create and define artifacts manually for now?\n\nsemantic-release is a release tool not a build tool. It has never been and I don't think it will ever be in the scope of semantic-release to be a build tool, to compile code or generate artifact.\nThere is dozen of tools doing way better than we could: npm, gulp, grunt among many other.\n\nDoes that sound about right?\n\nI guess but I didn't look in detail. As mentioned in the Contribution guideline the issue tracker is not for support.\nYou can find various ways to get support here.. This is not a semantic-release issue. It's related to npm. See https://github.com/npm/npm/issues/8561.\nIt's probably because the package name you are trying to publish has already been used by someone else.\nThe npm error message is not really explicit though... It would be a good idea to add that in troubleshooting. Thanks!. Can you provide the information requested in the issue template? Such as you configuration and the CI logs?\nI'm not familiar with VSTS and with your config there is no much help that can be provided.\n\nThe git plugin for semantic release is not suitable to use in the publish step\n\nAs explained in the documentation of the plugin, it's mean to be used in the prepare step no the publish one.\n\nHow do I get the publish to simply push the changes to git?\n\nBy configuring the plugin in the prepare step as explained in the documentation.. The problem is the GitHub plugin is used by default for the steps verifyConditions, publish, success and fail.\nYou should disable it by overwriting those steps in your config.. The npm plugin documentation mention it update the package.json during the prepare step.\nI don't understand where the problem is. Just configure your prepare step to run the npm plugin then the git plugin and make sure to not use the github plugin by overriding the steps that uses it. Something like that:\njson\n{\n  \"release\": {\n    \"verifyConditions\": [\"@semantic-release/npm\", \"@semantic-release/git\"],\n    \"prepare\": [\"@semantic-release/npm\", \"@semantic-release/git\"],\n    \"publish\": [\"@semantic-release/npm\"],\n    \"success\": false,\n    \"fail\": false,\n  }\n}\nAm I missing something?\n. Ah I see where the confusion come from. When you don't use the npm plugin for the prepare step, the publish step will automatically run it as it's mandatory to update the package.json in order to publish. This is why you see in the logs the package.json is done during the publish step.. semantic-release use git tags to determine the last version present in the repo.\nIf you migrate from BitBucket to GitHub the proper solution is to migrate the complete repo, including all commits and tags. Loosing your git history will cause you several issues down the line and make maintenance of your project harder.\nIf you don't to do that for some reason then you have to create a tag with the last version released to the corresponding commit. semantic-release will use this tag to figure out the commit made between the last released (marked by the tag) and now.. Thanks!. You can also use the @semantic-release/exec to run a script at any step you'd like that can be passed the new version number. Something like that:\njson\n{\n  \"release\": {\n    \"prepare\": [\n      \"@semantic-release/npm\",\n      {\n        \"path\": \"@semantic-release/exec\",\n        \"cmd\": \"my-script ${nextRelease.version}\",\n      },\n    ],\n  }\n}\nWith this config the npm plugin is going to update your package.json first, then my-script will be called with the new version as first argument.. > The problem with all these solutions is that I need to have two configurations : One that outputs the version or sets it somewhere, and one for the actual release in gitlab (tag, etc.) which doesn't seem to be possible easily.\nDo you mean two semantic-release config? Can you clarify why would you need two configs?. Thanks for the clarification.\nsemantic-release is build around the following ideas:\n- A release consist in running test, defining the version then releasing\n- A given release happens only once\nIt seems your steps 1 and 2 are actually tests, but handled like a release. In semantic-release, it has to be either a test step or a release step. If it's a test, there is no version determined, if it's a release there is one.\nIf you need the version number for step 1 and 2 then it's a release. Your workflow could be viewed as doing two different release:\n- One \"pre-release\" or \"release candidate\" that will go through integration testing\n- One final release if the integration test are successful\nWe usually handle this case via npm dist-tag. Until #563 get implemented the support of dist-tag is fairly simple unfortunately as we support one dist-tag config in the package.json and pre-releases are not supported.\nOnce #563 is implemented you could do the following workflow:\n- Set up the branches master and rc\n- Configure master to release on the @latest dist-tag\n- Configure rc to release on the @rc dist-tag\n- Configure semantic-release to do the whole release (build, version bump, changelog, gitlab release, deploy on kubernetes, run e2e tests, etc...) \n- Push your new code (i.e. merge your PRs) into the rc branch\n- Once a release released on @rc passes all the integration tests, merge the rc branch into master, semantic-release will make the @rc release available on @latest\nThis way:\n- Every time you run your CI and there is new relevant commits you make a release\n- Each release candidate is actually a real release (with git tag, gitlab release, changelog etc...)\n- All your releases go through the integration test process\n- Only the satisfying releases are made available on @latest and used by the final users\nWith the current implementation you can do something that involve some manual steps:\n- Configure the dist-tag @rc in your package.json's publishConfig.tag property\n- Configure semantic-release to do the whole release (build, version bump, changelog, gitlab release, deploy on kubernetes, run e2e tests, etc...)\n- Push your new code (i.e. merge your PRs) into the master branch as your currently do\n- When a @rc release passes the test and is considered ready to be made available to users, make it available on @latest with the npm dist-tag add command\n. In most cases where such feature was requested there was a better solution to implement the desired workflow, so it hasn't been implemented so far.\nIt seems the workflow explained here is very specific and uncommon. However we might consider adding such feature if there is other workflow that would require it.\nSo if anyone using a workflow that would benefit from that feature, please add a comment to this issue to explain your workflow with as much detail as possible.. @andresmijares could you explain your workflow and why such feature would be useful to you?. Can you clarify what \"I havent had any luck with it\" means?\nIs it not working? What's the problem?. btw, as indicated in semantic-release/exec#usage the proper syntax is ${nextRelease.version} not ${version}.\nSo your config should be:\njs\n\"release\": {\n   \"prepare\": [{\n       \"path\": \"@semantic-release/exec\",\n       \"cmd\": \"./build.sh --release -v ${nextRelease.version}\"\n   }]\n}. To implement this workflow I'd recommend to look at #991.\nYou could work on a rc branch and configure it as a pre-release branch. This way it would be release as x.y.x-rc.n and you can test that version. Once the test pass you can merge the rc branch into master and release the regular version.\nHere is an example workflow that includes what you try to achieve: https://github.com/semantic-release/semantic-release/blob/beta/docs/recipes/pre-releases.md. @simlu as indicated in the issue https://github.com/semantic-release/github/issues/152 that you open this is supported in v16.0.0-beta.\nYou have an example similar in this doc: https://github.com/semantic-release/semantic-release/blob/beta/docs/recipes/pre-releases.md. You mentioned in your previous comment that you want to release version like 1.2.3-rc1. In semantic versioning this format is called a pre-release: https://semver.org/#spec-item-9.. Again, if what you want to do is to releases like 1.2.3-rc1, 1.2.3-rc2 from dev and releases like 1.2.3 from master the workflow you are looking for is https://github.com/semantic-release/semantic-release/blob/beta/docs/recipes/pre-releases.md.\nOutputting the version without publishing a release is at best a convoluted and brittle way to achieve the implementation you describe. Unless you actually want to do something else...But it's hard to say as the only explanation you provided is https://github.com/semantic-release/semantic-release/issues/753#issuecomment-455273645.\nAs requested in https://github.com/semantic-release/semantic-release/issues/753#issuecomment-455241656 please explain what is your objective (as in your overall goal for managing releases, not the implementation you try to make) otherwise your requests will continue to be ignored.. This is a duplicate of #709.\nThe problem happens if the Head commit on the local clone is behind the head on the remote, due to git push failing.\nThis is normal that we fail in this condition as we have to create a tag and push it and git won't allow to push if the local clone is behind the remote. We could force push but that's a bad idea as we would just erase some commits on the remote.\nWe need to improve the error message to:\n- Log the git output\n- Mention in can be due to authentication or due to the local repo being behind the remote\nI think configuring Travis to cancel builds when a new commit is pushed on the branch should prevent this issue to happen. See https://blog.travis-ci.com/2017-03-22-introducing-auto-cancellation.\n. One of the goal of using commit convention is that it allow you to have a clean and informative git history. I'm not sure I understand your workflow, nor what problem you try to solve but it seems you end up with a master branch that doesn't contains the conventional commits.\nIn addition, usually the master branch reflect the last version of the software released.\nI don't really understand why you do this complex workflow and there must be reasons that I am missing. But I would propose the following workflow instead:\n- Write conventional commits for your PRs/feature branches\n- Merge your PRs/feature branches to master\n- Run a Travis job on master and run semantic-release\n- Use a prePublishOnly npm script to run your script that compile/optimize\n- Use @semantic-release/git to push to compiled code code to the repo (in a dist folder for example)\n. It seems that GitHub requires to use and URL ending with .git when using the git CLI.\nIn your package.json you should configure your repository URL to https://github.com/DJTB/hatsuon.git instead of https://github.com/DJTB/hatsuon.. Can you try to run the following on the CI?\n- git push --dry-run https://${GH_TOKEN}@github.com/DJTB/hatsuon HEAD:master\n- git push --dry-run https://${GH_TOKEN}@github.com/DJTB/hatsuon.git HEAD:master. That's really weird.... The logs clearly show that git push --dry-run https://${GH_TOKEN}@github.com/DJTB/hatsuon HEAD:master fails. But now it seems to work.\nMaybe the problem was related to a temporary issue with GitHub..... @acgritt you have to make sure you have all the latest version of dependencies on your CI.. Can you fix the test?\nI think you have to pass the remote URL to unshallow() in the test.\nYou might have to change some tests in index.test.js to make sure they use a cloned repo.. Are you sure the problem is with unshallow() ?\nIf your CI managed to clone the repo, then git fetch --unshallow -- --tags should work without any additional authentication mechanism than what's provided by the CI.\nWhat CI are you using? \nWhat do you get if you run git fetch --unshallow -- --tags on your CI?\n. > I am using Jenkins with pipeline scripts's module checkout scm. Based on your response I presume you expect Jenkins to store credentials in 'origin' of .git/config??\nNot particularly. I don't use Jenkins and I'm not really sure how it works regarding credentials. I know there is other people using Jenkins and they don't experience this issue.\nWe can add the credentials to the unshallow command though.. Regarding people using Jenkins you can ask on the Gitter channel.\nWe use unshallow because we need both the tags and the commit messages as semantic-release analyze those.\ngit ls-remote would give us only refs (commit sha and tags).\n. Fixed in #766. Thanks!. Fix #764. Currently if you are using a token for authentication you should set GIT_CREDENTIALS to x-token-auth:<token>.\nTesting for : is probably not reliable because a token could contains a :. So such token would be misinterpreted as user/pass.\nWhat we could do is to add a BB_TOKEN environment variable that would work similarly to GL_TOKEN:\n- If GIT_CREDENTIALS is set assume it's in user:pass format\n- If BB_TOKEN is set assume it's a Bitbucket token and add x-token-auth: in front of it.\n. Thanks for the clarification. I'd prefer to add a dedicated Bitbucket environment variable for consistency with GitHub and GitLab.\nI'll take of it in a different PR.. I looked in detail but I couldn't figure out what happened...\nI don't think it could be related to #709 as I don't see the message The local branch %s is behind the remote one, therefore a new version won't be published in the logs.\nI opened #772 that logs the output of the git push --dry-run. That would help debugging hopefully.\nWhat happen if you set the DEBUG environment variable to semantic-release:* in Travis and restart the hob https://travis-ci.org/AtomLinter/linter-htmllint/jobs/373647402 ? . That's weird, the URL seems correct. But it seems the git CLI doesn't like it.... I think we had cases where adding .git at the end of the URL solved this type of issue.\nIt might be related to the git version. On my local machine with version 2.17.0, it works with and without the trailing .git. It seems that on Travis it might make a difference.. I'm really curious to know why the trailing .git makes a difference in some cases.\nI tested there https://travis-ci.org/pvdlg/test-sr/jobs/374590162#L443 and it seems both works.\nMaybe an obscure thing with slightly different version of git running on different Travis images..... Indeed. Can't figure out what's causing this \"not found\" error when omitting the .git.... Great news!\nI'd like to figure out when exactly the .git is required as some people have encounter this issue as well... If anyone reading this thread has any idea.... Closing in favor of #774. semantic-release look at all the environment variable containing the keywords token, password, credential, secret or private and replace their values in stdout and stderr.\nSo if you have an environment variable named 'SOME_CREDENTIAL' that contains the value do then do will be replaced in the log output.\nI also noticed that Travis is replacing some keywords by [secure] as well. I don't know what the Travis algorithm is, but I noticed some weird cases in which a totally random string was replaced. So it's possible the case you mentioned is done by Travis and not by semantic-release.\nDo you have any environment variable that would contains the value do?\n. Here is similar example where do is not replaced: https://travis-ci.org/mdn/bob/builds/364609477#L3816\nMaybe you have an environment variable set to the value do by something else (a script)?. For info here is the code doing the replacement: https://github.com/semantic-release/semantic-release/blob/caribou/lib/hide-sensitive.js. Only full match of the variable value is replaced.\nUnless there is a bug in https://github.com/semantic-release/semantic-release/blob/caribou/lib/hide-sensitive.js. If someone encounter the same issue, please provide:\n- The semantic-release logs (or a link to the logs)\n- The output of the env command. After further analysis  that happens because Travis set the environment variable nvm_token to the value do. This happens only in the deploy step for some reasons.\nsemantic-release considers that the content of the variable nvm_token is sensitive as the variable name contains token and then hide any instance of the value (do) from the output.\nI'm not really sure what the proper fix is here.\nWhen we detect the environment variables that might contains sensitive values we could exclude nvm_token. However the same problem might happens with other environment variables named *token*, *credential* etc...\nAnother solution would be to identify variable value as sensitive only if it has a minimum number of characters. I don't think any sensitive info (token, key, credential etc...) would be less than 5 characters.\nAny though on that?. The problem is that plugins can use any environment variables, so there is no pre-defined whitelist.\nThe point of this feature was to prevent plugin to accidentally leak the user's credentials/tokens.\nIt can happens really easily without the plugin author noticing. For example if a plugin call a cli like that some-cli --token <process.env.MY_TOKEN>, and for some reasons the calls fails, it's likely the exception thrown will contains something like The command some-cli --token value_of_the_token will be logged.\nThe same can happens when you pass the token/credential to an API client that end up doing an http request with the token in a header. If an error happens it will likely contains information about the failed request, possibly including headers.. Yes this is meant for any CI. It seems Travis does indeed hide that value contained in secured environment variables. I think it also hide other stuff but I don't know what are the rules.\nAnd yes we support a lot more than Travis. I don't know which other CIs also hide value of environment variable in the log output, but I'm sure there is some that doesn't. And better be safe than sorry....\nI think such feature is really important because we ask users to trust us with their tokens/credentials, and we don't want to \"transfer\" that trust to a third-party like the CI or a plugin author. Ideally, the semantic-release users should decide if they trust their CI and the plugins they are using, but I don't think it's reasonable to expect that.\nJust a slightly related FYI point: In all CI the environment variables are available only for builds that runs on the repository itself, and not on forked ones.\nSo it means:\n- Forking a repo and opening a PR that contains sendToMyServer(process.env.NPM_TOKEN) will not expose the token. process.env.NPM_TOKEN will be undefined.\n- As a repo maintainer you have to make sure such code doesn't end up on your own repo, otherwise the token will be leaked. Basically, you have to make sure to not merge PRs that introduces malicious code, but that's not specific to using semantic-release.. Closing as the problem doesn't seems to happen anymore. semantic-release comes with the github and npm plugin as they are the default ones.\nFor any other one you have to install them.\nYou can either add them as a devDependency if you have a package.json or globally with npm install -g <plugin name>.. Can you check which version of env-ci you are using? There was some releases recently that addressed similar issues, namely https://github.com/pvdlg/env-ci/releases/tag/v2.1.0. This recipes is part of CI recipes that covers the CI configuration only, not specifics related to a particular Git host. Note it's named GitLab CI and not GitLab.\nSo information related to GitLab itself (the Git host) shouldn't be in that recipe.\nAll the information you added are already in the documentation of the GitLab shareable config: https://github.com/semantic-release/gitlab-config. If something is unclear or missing it should be added over there.\nThe shareable config is also mentioned here: https://github.com/semantic-release/semantic-release/blob/caribou/docs/extending/shareable-configurations-list.md and even more specifically in a FAQ: https://github.com/semantic-release/semantic-release/blob/caribou/docs/support/FAQ.md#can-i-use-semantic-release-with-gitlab\n. Closing per previous comment and due to no response.\nPlease re-open if you disagree or want to discuss/refine a possible doc improvement.. Fixed in #783. The note added is not accurate, as the SSH keys are sufficient for the base functionalities of semantic-release core. An API is required only when using a plugin that requires it and would be mentioned in the plugin doc.\nCould you replace the note with:\nmd\n**Note:** SSH keys allow to push the [Git release tag](https://git-scm.com/book/en/v2/Git-Basics-Tagging) associated to the released version. Some plugins might also require an API token. See each plugin documentation for additional information.. Can you remove the italics to be consistent with the rest of the docs?. Thanks. On my local machine and on Travis there is no upstream remote configure (only origin) and git rev-parse master@{u} works...\nI'm not sure what the difference is.\nWhat do you get is you run git rev-parse master@{push} on Jenkins?. We need to push a tag during the release process. So we need a remote to push to.\nIf it was working for you before I assume at some the push remote is set.\nMaybe when we unshallow the repo it solve the problem.\nCan you try the following on Jenkins:\n\ngit fetch --unshallow --tags\ngit rev-parse \"master@{push}\n. Also what do you get with git ls-remote --heads <repositoryUrl> <branch> ?. Ok so I'll replace git rev-parse \"master@{u}\" by git ls-remote --heads <repositoryUrl> <branch> then.. Checking explicitly if the local head is up to date was meant to distinguish an outdated local branch from an authentication errors, because git push --dry-run returns and error for both cases.\n\nI just realized git ls-remote --heads <repositoryUrl> <branch> require authentication. So that doesn't allow to distinguish the 2 different cases, so we can't use that command...\nCan you check if git rev-parse origin/master works in your scenario?\nYou can also use the semantic-release version from the branch git-verif-uptodate to test.. The commit message that will trigger a release depends on the configuration of:\n- The commit convention used with preset\n- The release rules configured with releaseRules\nThis is why we use the somewhat vague term of \"relevant change\". The commits that will trigger a release depends on your config.\nIf you have a proposition for a better term or for clarification feel free to propose it here and open a PR.. @ricardograca do you have a proposition to make to improve the language in the documentation? Or should we close this issue?. We can't answer that question. It depends if this particular registry is compatible with npm and implements it's API the same way.\nsemantic-release use the npm CLI to interact with the registry. If the registry you use is compatible with npm it should work, if not you should open an issue with the registry provider.. It seems you are passing wrong arguments to the semantic-release CLI.\nCould you provide the content of your semantic-release script from your package.json?. This is not the correct way to call semantic-release since version 6 or 7. You should just call semantic-release now.\nPlease see the documentation: https://semantic-release.gitbooks.io/semantic-release/content/#highlights. semantic-release-cli setup should setup the authentication on your CI. But it depends on which GIT host and CI you are using.. I just tested the same config and it works as expected. I don't know why the URL is parsed as https://[secure]@/ttps:git@github.com:AirPageInc/icons.git.\nEither you have the repository url configured somewhere else, or you are using outdated version of the dependencies modules that semantic-release uses to parse the URL. The Travis build that you linked has been triggered by a tag creation. semantic-release make a release only for builds on the branch configured (by default master).\nSo this is the expected behavior.\nThere is no reason to trigger builds on Travis when a tag is created, so it's something you can disable.\nThe release actually happened during the last master build: https://travis-ci.org/kopax/deleteme/jobs/380159426. However it failed because your build script failed.. > I don't thing it was triggered by a tag creating, I did created it with a git push from my host directly to branch master. What make you thing It was triggered automatically after a git push?\nBecause it says so on the build. See \n\n\nHow can I disable this? What is your recommendation I do not get it.\n\nSee Travis documentation: https://docs.travis-ci.com/user/customizing-the-build#Building-Specific-Branches\n\nAter a release, the package.json appear to be modified with the new version in it.\nBefore I started to play with semantic-release, I was doing the npm version followed by the git push of the package.json to the HEAD:dev.\n\nWhat is your recommendation regarding that?\nI don't really understand your question. Our recommendation is to use semantic-release the way it's describe in the documentation.\nThe problem is that you probably didn't configure the NPM_TOKEN properly, as mentioned in the logs: https://travis-ci.org/kopax/deleteme/jobs/380159426#L5854. Is what you are trying to do is to push the updated package.json to the repo?\nHave you looked at the FAQ: Why is the package.json\u2019s version not updated in my repository??. Closing as it seems everything works as intended. If you need support please use appropriate channels: https://github.com/semantic-release/semantic-release#get-help. The test with git push --dry-run has been implemented a while ago and seems to work so far.\nCan you clarify what you mean by \"this fails because there would be a conflict with the new master that has been pushed\"? What is the \"new master that has been pushed\"? The test with git push --dry-run happen before pushing anything so I'm confused. How can there be a conflict between the remote branch and the local one on the cloned repo?\nIf you refer to a situation in which the local cloned branch happens to be behind the remote branch (i.e. you push a commit to the remote repo after the CI build started but semantic-release runs) then it should have been handled in https://github.com/semantic-release/semantic-release/pull/759.\nCould you provide the full logs with the --debug option?\n. Are you sure you are using 15.4.1? This case should have been handled in #759 which was released in 15.1.10.\nNow if the local repo is behind the remote we log a message and exit without error.\nUsing git push --dry-run --force is not a good idea because later on in the process we'll have to push a tag. If we push the tag without --force it will fails as well (so we prefer to fails earlier before any release is attempted) and if we push it with --force we will erase the commits on remote that are not present in the local branch.. Can you provide some logs or some context to analyze exactly what cause the issue?. The How does semantic-release handle merges? is really generic and unrelated to semantic-release.\nsemantic-release simply analyze the commits present on the release branch when it runs. It doesn't matter if those commits have been push, rebased or merged from another branch. When you merge and a Merge commit is created, semantic-release just analyze the merged (note the d in merged) and ignore the Merge commit.\nSo all merge consideration are not relevant for how semantic-release works so I would remove this section entirely.\nThe How does semantic-release handle squash merges? section is not completely accurate and is not clear due to explanation about breaking change. The fact that breaking change are parsed is just a side-effect of an invalid commit message. See https://github.com/semantic-release/commit-analyzer/issues/65#issuecomment-390505020\nI would replace this entire section by this paragraph in the Troubleshooting doc instead:\n```md\nSquashed commits are ignored by semantic-release\nsemantic-release parses commits according to a commit message convention to figure out how they affect the codebase. Commits that doesn't follow the project's commit message convention are simply ignored.\nWhen squashing commits most Git tools will by default generate a new commit message with a summary of the squashed commits. This commit message will most likely not be compliant with the project's commit message convention and therefore will be ignored by semantic-release.\nWhen squashing commits make sure to rewrite resulting commit message to be compliant with the project's commit message convention.\nNote: if the resulting squashed commit would encompasses multiple changes (for example multiple unrelated features or fixes) then it's probably not a good idea to squash those commits together. A commit should contain exactly one self-contained functional change and a functional change should be contained in exactly one commit. See atomic commits.\n``.github.com/benbria/secret-project` is not a valid git URL, this is why it errors out.\nWe have to support multiple format of valid Git URL, including some shorthand, so unfortunately there is no great way to handle every possible mistakes that can be made while configuring the URL.\nIt's expected from the users to configure a repository URL that works with the git command line.\nI'm not sure it's worthwhile to spend time trying to figure out every possible mistake to report better errors. The git CLI doesn't do it, and just fails when the URL is improperly formatted and it doesn't seems to be a big issue.\nIn addition the error message report the URL that is used, so users can figure out there is an issue with the repository URL.. > This project has been hosted on git for three years. It's worked fine with the git command line tools all this time. The git command line tool doesn't read package.json.\nI never said the git command read the package.json. The package.json defines a property for repository URL used as a metadata of the project. semantic-release uses that to know what is the repository URL and it assume it's correct.\nSo yes sure you can have an incorrect URL in your package.json and it won't create any issue if you don't use it, but that doesn't means semantic-release should handle incorrect URL.\n\nThe error did not report the URL that was used in package.json, it printed \"ithub.com/benbria doesn't exist.\" This is not the URL from package.json, nor is it the url from git remote -v. At the very least, you should print the literal URL you tried to use (rather than the mangled version) and where it came from (because TBH I expected it to come from git remote -v).\n\nsemantic-release uses the URL in your package.json and transforms it:\n- to expand shorthand URL\n- to transform git URL into https\n- to add the authentication part\nIn certain case a wrong URL fails right away as it's not readable. In cases like your where the URL is a correct generic URL but a wrong Git URL (as per what the git CLI considers correct) the transformations can still occur but ends up generating a still wrong URL.\nSo there is a grey area where the URL seems correct (according what a generic URL should be) but still doesn't work with git CLI. There is no way to way (at least not a simple one) for us to figure out if the URL is invalid, not authorized, point an offline location etc...\nWe just see that it's parseable but the git CLI report an error. If we start reporting configuration error (such as \"The URL  is not configure properly\") as you suggest, it would be accurate in your specific situation. But someone with a permission issue will obtain an inaccurate error.. That should be solved with the 15.4.4 release. Could you confirm?. We don't really use those branches anymore. Once #563 lands will probably move toward something more usual: master and next and maybe some branches for older versions that we still want to maintain (15.x, 16.x, etc...). Thanks for the proposal! I really like the idea of the rocket with the package!\nWe'd like to use the logo as an avatar image for the Twitter account, the GitHub orga etc... so it would have to be square and recognizable on small size.\nWould it be possible to have a bit more colors? Maybe 2 colors so that would help to distinguish the rocket from the rocket itself? Here a few example, that can help maybe:\n- https://www.flaticon.com/free-icon/rocket-launch_762658#term=rocket&page=2&position=64\n- https://www.flaticon.com/free-icon/rocket_599193#term=rocket&page=1&position=78\n- https://www.flaticon.com/free-icon/rocket_178158#term=rocket&page=1&position=23\nAlso maybe it would be better to add a window/porthole on the rocket, this way it would be clearer it's a rocket and not a bomb or a torpedo. Something like this: http://www.iconarchive.com/show/captiva-icons-by-bokehlicia/rocket-icon.html\nLet me know what you think!\n. @ihtiht are you still interested to work on a logo, and make changes based on @gr2m comments?. Yes. The quotes seems a good idea. Do you want to make a PR?. See https://github.com/sindresorhus/hook-std/issues/16. Does it happens when you run npm install? Or when you run semantic-release?\nHave you tried to delete your node_modules folder and your lockfile and re-install?. It should be fixed when https://github.com/peerigon/parse-domain/pull/39 lands.. An alternative and probably better solution here: https://github.com/IonicaBizau/git-url-parse/pull/80. Fixed by #860. This is discussed here: #193.\nPlease search the issue tracker before opening a new one. Thanks.. Duplicate of #193. Can you add a test to keep 100% coverage? Thanks.. Thanks for the proposal.\nWe decided a while ago to keep the badges on the readme to the minimum, so we are not going to add a new one as suggested in this PR.\nI checked quickly the page associated with this badge. I might have missed something, but it's not clear for me what \"semver compatibility\" means. Does it check the released version are named with a semver tag? If it's the case it's not really useful as npm forces that anyway.. This sentence doesn't make much sense to me. How 2.1.0 -> 2.2.0 is valid and 2.2.0 -> 3.0.0 not? \nIt's perfectly ok to release a version 3.0.0 if the last release is 2.2.0 and the new change is a breaking change.\nI really don't understand what you are measuring.\n. Ok it's clearer now.\nI'm not sure you'll a reliable number though, because you are going to get a lot of false positive in cases where the CI just fail for unrelated reason, the user tests are flaky, the user tests fails for unrelated reason etc...\nSo someone maintaining a library and displaying your badge might end up showing something that is not 100% even though their releases perfectly respect semver.\nAnd the score will actually depends on the quality of tests written by dependents libraries that also use  Dependabot. So if I'm unlucky and the few libraries using mine and having Dependabot configured have flaky tests then I'll get a bad score even though I fully respect semver.. Ah ok that make sense.\nI think that's an interesting feature indeed! I imagine the more people use Dependabot the more accurate the results will be.. Thanks!. //cc @gr2m . It's always good to get more people taking ownership. However it's really simple packages as they contains only a few lines of JSON.. And hopefully that would encourage folks to create more shareable configs, especially ones that doesn't use our plugins or ones that are quite specifics.. You just have to add to the prepare the other plugins you want to use in this step.\nBy default it's only the @semantic-release/npm one.\nYou can see the default plugins in the doc: https://github.com/semantic-release/semantic-release/blob/caribou/docs/usage/configuration.md#prepare. > If I add the prepare rule into my package.json do I have to precise the npm plugin too or it still took into account 'cause it's the default one ?\nYes you have to add the npm plugin in that step.\n\nin the doc I see semantic-release/commit-analyzer is the default commit analyzer used. So Do I have to redefine it if I just want to change the prepare step ? If yes where can I find the default options it's called with ?\n\nNo you don't have to redefine it in that case.. There is no option set by default for plugin by semantic-release core. You can read each plugin documentation to find out what the default are.. The yaml that you provided produce that JSON:\njson\n{\n  \"verifyConditions\": [\n    \"@semantic-release/git\",\n    \"@semantic-release/npm\"\n  ],\n  \"prepare\": [\n    \"@semantic-release/git\",\n    \"@semantic-release/npm\"\n  ],\n  \"publish\": [\n    \"@semantic-release/npm\"\n  ],\n  \"success\": null,\n  \"fail\": null\n}\nAs you can see success and fail are null and not an empty Array.\nIf you want to disable the default you set them to an empty Array or to false.\nThe documentation is indeed not clear about that. This problematic will disappear once #827 is implemented (basically there won't be any default plugin anymore) but I will try to clarify that a prop set to null or undefined is ignored and won't override anything.\nThe rational behind that is to handle multiple level of inheritance, for example if you extends a shareable config, but if you want to use the default for a given plugin rather than what's in the shareable config you can defined that plugin to null in your config. So basically:\n- false or []=> disable\n- undefined or null => use default\n- \"Nothing\" => use whatever is defined in the parent config. I'm closing this issue as it related to yaml specific handling of undefined arrays properties.. Your remark make sense. We had a bit a floating period in which we were not sure how to handle the relationship between plugins and the core.\nIn the case you mention, @semantic-release/commit-analyzer@5.0.x was not really meant to work with older version of semantic-release.\nWe now have a more stable system in place and each (or at least most) plugins require a specific version of semantic-release via peerDependencies.\nCurrently we do not maintain older versions of semantic-release. That means versions 12.x.x, to 14.x.x probably have bugs and plugin incompatibilities that have been addressed in later releases, but won't be fixed in those versions.\nOnce #563 lands we might adopt a different policy and backport some of the fixes to previous version. The feature should be completed soon (all the code for the core, minus the doc, is in multi-branches but I have to modify some plugins). However, we are currently in version 15.x.x and you are using 12.x.x, and it's unlikely that we would support 3 major releases back. So I would recommend to upgrade to the latest version, it comes with a ton of fixes and new features.. I'm going to close this issue then. You should really upgrade to the last version.. What is the point of having different ssh private keys on the same host?. Even if we support running locally, semantic-release is mainly intended to run on a CI and the problem you describe wouldn't exist in a CI environment. I don't think it's a feature we would implement as it would only solve a very specific case (your work/home laptop setup) for a very limited number of users (I imagine only you).\nI would suggest in your case to investigate other solutions, for example:\n- Using a token instead of ssh keys\n- Using the same GitHub account when you work on that specific project rather than having a specific one for different laptop\n- Find tools that allow to manage your ssh keys with more flexibility. > I do use a token (with GH_TOKEN), but when trying to connect to the server, semantic-release uses the repositoryUrl provided, instead of the one defined at .git/config.\nThen you should configure the repository URL in your package.json as an http URL rather than a git (ssh) one, so semantic-release would use the token to authenticate instead of the ssh key.\n\nIt would be great if you could give more priority to the remote at .git/config for connecting, and use the one defined at package.json for appearance (writing CHANGELOG.md).\n\nIt's not always possible to control the remote URL set by the CI environment in .git/config. However it is possible for users to configure the URL they want to use in their package.json or via CLI option. Therefore we choose to use the one set by the user first, and the one set by the CI during the repo cloning second.\n\nHow do you suggest I use a CI in my setup? Can you quickly describe a high overview of the process?\n\nThe high overview of the semantic-release process is the README.md.. semantic-release look only for tags that reference a commit in the history of the current branch. Maybe those tags were created on a different branch?\nWhat is the output of git tag --merged master?\nCan you run semantic-release with the --debug option? Or set the environment variable DEBUG to semantic-release:*?. What do you get with git merge-base --is-ancestor v1.1.0 HEAD? I would the console output if there is one and the exit code? You can get the exit code of the last command with echo $?.. Can you provide the beginning of the logs? That's the useful part to troubleshoot this issue.. From the logs:\n\nsemantic-release:get-last-release found tags: [ { gitTag: 'v1.0.0', version: '1.0.0' } ]\n\nThis is the result of the git tag command.\nThat means the tag v1.1.0 is not present in your local clone on your CI.. For info semantic-release runs git fetch --unshallow --tags before running git tag.\nSo it seems a fetch is not enough and the problem is somewhere else.. It's part of the Semantic Versioning Specification so I guess we should support it.\nIt could be implemented with a new buildMetata plugin hook that would receive {options, logger, lastRelease, commits, nextRelease} and returns a String that would be set in the metadata part of the version \nAs the metadata part of the semantic version is something rarely used (as far as I can tell) and it's not used by npm (the metadata is just ignored on publish) I imagine you are mostly interested in having it in the Git tag.\nIf it's indeed the case you can use the tagFormat option option like this: v${version}+${process.env.JENKINS_BUILD_NUMBER}.\nWould such workaround works for you?. Yeah I just tried to publish version 2.1.0-beta.1+exp.sha.5114f85 and I get that on npm: https://www.npmjs.com/package/@pvdlg/test-release/v/2.1.0-beta.1.\nThe only differences I see between using the tagFormat workaround and having a proper implementation via plugin are:\n- The version passed to publish, prepare and success plugins will be without the metadata (the gitTag prop will have it though)\n- Therefore the version name in the GitHub release and the changelog will not have the metadata, but I'm not sure it's really valuable info anyway\nDo you need that info anywhere else than in the Git tag?\n. That wouldn't work as it wouldn't follow semantic versioning. The concept is to increase version numbers by one on each new release (1.0.0 then 1.0.1 etc...).\nThe entire concept of semantic-release is to determine the next version for you, based on the changes made since last release. We achieve that by analyzing the commit messages in the analyzeCommit plugin.\nIn addition plugins cannot modify the version by design as the core concept is to define the version based on semantic versioning rules.\n. The last version and next version are determined by the core, not by a plugin.\nAnd yes the entire Git repo with the complete history is required.. Thanks for the PR!\nThere is some changes going on as part of #563 regarding the plugins.\nAlso I was working on a version of the guide locally that is partially generated from JSDoc.\nI'll include some part of your PR if you don't mind.. Please see this FAQ Can I set the initial release version of my package to 0.0.1? explaining why semantic-release start the releases at 1.0.0.\nPlease also see #532 with an similar request and several explanations.\nIn addition #563 will allow to use pre-release version that would fulfill the need of publishing beta versions.. Duplicate of #532. That's where we do the check: https://github.com/semantic-release/semantic-release/blob/d4f68a5680ebcd8c9adf1d1fee26507a079aac62/index.js#L59-L71\nBasically we check if the auth is valid, which can throw either if the user doesn't have the permission or if the local branch is behind the remote one. So to know in which case we are we test if the local branch is behind, if it id than that's the problem if not then it's an auth problem.\nThe trick is that to verify if the local branch is behind we need to have read access to the repo. But we assume we do as the repo was cloned on the CI so if the read access were missing we wouldn't even have a repo at all.\nThe problem might be that we check if the local branch is behind by using the authenticated URL (containing the GH_TOKEN) so maybe the CI has read access but the user associated with the GH_TOKEN does not.\nI tried to reproduce this situation, however, I have the expected error: EGITNOPERMISSION.\n@jwalton is your repo private? What is the exact permission setup on GitHub?\n@portenez What is your issue exactly? What is the error message you get? Can you provide logs wit the --debug option?\nWith a missing token I have the EGITNOPERMISSION error as expected.. As explained in the previous comment, if verifyAuth() fails there is no way to know exactly why.\nverifyAuth() runs git push --dry-run to verify the permissions. This command can fails if the authentication fails, or if the authorization fails, or the local branch is behind.\nCall isBranchUpToDate() in the catch allows to determine why verifyAuth() threw and throw the proper error.. @jwalton I pushed a fix on the branch https://github.com/semantic-release/semantic-release/tree/fix-838. Would you mind testing the same scenario and confirm that with this fix you get the proper EGITNOPERMISSION error?. @wejendorp it seems you are in a very particular case where you have a wrong authentication, a private repo and use a URL to clone the repo in the CI (the ssh one) but configured another one in your package.json (the https one).\nI updated the branch fix-838 in order for isBranchUpToDate to use origin rather than the URL configured. This way it will always use the URL used by the CI clone the repo which should be allowed to read, otherwise the CI wouldn't be able to clone in the first place.\nCould you test again and let me know if that solve the issue?. @jwalton could you confirm if that fix the issue?. @portenez are you using the branch fix-838?. @portenez do you still experience the issue with branch fix-838?\n@jwalton did you had a chance to test with branch fix-838?\n@kopax can you try to reproduce with the branch fix-838? Can you provide more info about your environment (private or public repo? Repo URL configured in your package.json? etc...). @portenez: npm install username/repo#branchName --save-dev. GitHub limit API calls to 5000 per hour for each users: https://developer.github.com/v3/rate_limit/\nWe already have a throttling mechanism in the @semantic-release/github that limits 1 call every 720ms (which result in 5000 calls per hour maximum).\nThe problem happens when you have other things using the API with the same user, as the 5000 per hour limit is shared across all the API calls for the same user.\nCurrently the throttling mechanism in @semantic-release/github is relatively basic. In order to prevent this problem we would have to implement the throttle with a bucket of tokens that we would consume/refill based on the X-RateLimit-Remaining and X-RateLimit-Reset headers.\n@gr2m we talked at some point to have such feature implemented directly in the Octokit client. Do you know if it is still planned?\n@bodinsamuel do you have a repo that I could fork and use to try to reproduce the problem?\nHow many commit, issues, PRs do you have in the repo?. Ok, so I'll wait for that then. It's pretty complex issue to solve...and test....\nFor info see https://github.com/SGrondin/bottleneck/issues/51, especially https://github.com/SGrondin/bottleneck/issues/51#issuecomment-370641192 which should allow to implement the feature.. Your case seems different as it was detected as an abuse, which happens when your account make more than 1 write query per second.\nThis shouldn't happens as we throttle to 1 call per second...So either their is a bug and the throttling doesn't work either you have other stuff (maybe other semantic-release instance) running at the same time. From the date of failed errors it seems the throttling works.\nDid you had other stuff running using the GitHub API at the same time?\nIn any case I think we can catch this specific 403 errors and block the execution for the time indicated in Retry-After.. The API doc is not super specific about what's considered rate abuse: https://developer.github.com/v3/guides/best-practices-for-integrators/#dealing-with-abuse-rate-limits\nThey mention wait at least one second between each request. We do wait 1 second between each requests.  I just tested and I can confirm it works as expected.\nMaybe GitHub detect an abuse as we do a lot of similar calls and even if we wait 1 second in between they consider that suspicious...I don't know how to figure out what is the appropriate rate though.... I guess this part from the API doc is interesting:\n\nRequests that create content which triggers notifications, such as issues, comments and pull requests, may be further limited and will not include a Retry-After header in the response. Please create this content at a reasonable pace to avoid further limiting.\n\nCreating comments does generate a notification. So It's limited to less than 1 per second. But it's not clear when GitHub consider it an abuse. In addition they don't return the Retry-After header so there is no to know for how long to wait to continue.. I can set a different throttler for the command that create notifications. But not sure what the proper interval should between requests...I'll try to test a bit more to figure out when does GitHub consider it an abuse.. I'm guessing you are using execa to run the semantic-release command? Something similar to the examples shown in https://github.com/SamVerschueren/listr?\nIf yes, just the stdio option of execa or it's pipe function to pipe the stdout and stderr to whatever you stream your like.\nIf you want to write logs to a file then just pipe the execa stderr or stdout to a file writer.\nThat's not an issue with semantic-release. All the examples on https://github.com/SamVerschueren/listr also use command that write to the console. It's up to you to decide what you do with stdout and stderr.. Ah ok. You mentioned the option --silent which look like a CLI option so I assumed you were calling the CLI with execa.\nI'm thinking about using signale for logging. I could add a parameter (or an option to opts) in the main JS function that would allow to define the signale config. If it's not set I would use the default one.\nThis way you could pass the signale config with the disabled option or the stream option to collect the logs on whatever stream you'd like.. I'm doing a lot of refactoring to simplify the code. I'll look at this feature after. I don't yet how it's going to be implemented in details.. @Aghassi please see #865.\nI implemented slightly differently then what I proposed above. Basically I allow to pass a writable stream to be used as stdout and stderr rather than the full signale options.\nAllow to customize the logger options doesn't seems to provide much value and it would have created a lot of extra complexity.\nI also added a JS API documentation with some examples.\nWould that work for your use case?. Older version of semantic-release didn't supported version < 2.0.0 either. It's that we were not checking for the git version. Not all the git command we do require 2.0.0 so depending on what semantic-release is doing it might or might not use a command that require 2.0.0.\nI'm not 100% sure what git version is required and what command require what, because there is no good way to know what version of Git support which options/command. The only way is too look at the the Git doc and use the version dropdown at the top of each page to select an older version and see if the needed option/command was available in said version. However the oldest version available in the doc is 2.0.0.\nThe version 2.0.0 has been released on May 28, 2014, more than 4 years ago, so I think it's more than reasonable to require that version. In addition semantic-release is a development support tool, not a production dependency, so we think it's ok to require updated tools. This is why we require Node 8.3 for example.\nUpdating to a new version is fairly easy and a good thing to do anyway. In any case it's a lot easier than accepting older version in semantic-release and find out what is supported or not in an undocumented 4 years+ old version. Going through the commit history of git and analyze the code in each version to figure out what is supported or not is extremely painful and time consuming. This time is way better invested in fixing bugs and developing features.. If I understand correctly you want to have a latest branch with a commit that contains your built assets and to tag this commit with the version number?\nIf it's the case I don't think it's even possible. semantic-release will tag the last commit of the a release on master and use it later on to figure out the last release.\nEven if it wasn't a semantic-release requirement it's still a recommended practice to tag your commits in master with the version. Among other things it allow you to checkout a particular version tag and get the code as it was on that release. For example you can do git checkout tags/v1.0.0 to test if v1.0.0 has a particular bug.\nThat also allow you to create hotfixes on old versions. For example if your last version is 2.0.0 and a user experience a bug on version 1.1.0 and cannot upgrade to 2.0.0 for certain reasons, then you can do git checkout tags/v1.1.0 -b 1.1.x and fix the bug on the branch 1.1.x and make a 1.1.1 release from there.\nI imagine your previous workflow was tagging on latest but not on master?\nThe problem is that tags name have to be unique in Git and point to one commit. So you cannot have a v1.0.0 tag that point to the last commit included in the release on master and another v1.0.0 tag that point to a release tag on latest.\nSo I don't think we can do anything to support that workflow in semantic-release for several reasons:\n- We do not want to support a workflow that allow to not tag on master for reason explains above\n- You situation is specific to bower which is not supported anymore\n- An alternative solution is to push your assets to the master branch, which seems to be an acceptable compromise as long as you have to publish on bower \n. If you find a solution that works you can still implement it with custom plugins or with @semantic-release/exec. The goal of having plugins has always been to allow implementing specific workflow that are not common enough to be part of the plugins we maintain.. Thanks for the PR!\nLooking at the code I see that you are using a a bash script. Because of that any CI based on windows will not be able to run your plugin.\nDo you think you can change that to make sure your plugin would work for everyone?\nThanks. For info, Appveyor offer free Windows CI environment for OSS.. Fix #816. I think it's a duplicate of #563?. I still have some work to do before releasing this feature. I did a lot of fixes and new feature that I need to merge into that branch.\nI shared the branch for transparency purpose, but there is no guarantee for it to work completely.\nOnce I'll be ready enough I'll open a PR and then I'll look at the feedback there regarding the code and the design.\nI imagine we will release this feature as a beta pre-release. Then you would be able to open issues to solve specific issues.\nIn the meantime I'm going to close this issue as it's a duplicate of #563 and it's a bit early in the process to start reporting issues on this feature.. Duplicate of #563. Isn't it a duplicate of semantic-release/npm#4?. The changelog is generated by conventional-changelog-writer and the date is determined here with dateFormat(new Date(), 'yyyy-mm-dd', true).\nSo I imagine the date on your CI is off because new Date() in JAvaScript return the current date of the OS.\nThere is nothing we can do about that in semantic-release.\n. The analyzeCommits as always been a single plugin.\nCurrently the error message is generic for all plugins, which might be confusing. I guess it can be improved to be clearer.\nAlso I guess we can accept Arrays of 1 as valid for analyzeCommits.. I don't think that can be solved because semantic-release needs to run from a Git repository to:\n- Find the last release by reading the Git tags\n- Retrieve the commits since the last release\n- Create and push a tag\nSo if you don't have the .git directory in your project semantic-release cannot do any of that.. I'm going to close this as there is nothing we can without the .git directory.. Please see https://semantic-release.gitbook.io/semantic-release/support/faq#why-is-the-package-jsons-version-not-updated-in-my-repository\nAlso in your .travis.yml you try to deploy twice. Once with provider: npm and once with semantic-release.\nPlease follow the documentation to configure Travis: https://semantic-release.gitbook.io/semantic-release/recipes/recipes/travis-build-stages#multiple-node-jobs-configuration. You can't republish a version on npm after unpublishing it.\nAgain, your problem is that in your .travis.yml you try to deploy twice, once with provider: npm and once with semantic-release.. Just recreate your 1.0.0 tag on the commit that was used to create that release.\nSee https://semantic-release.gitbook.io/semantic-release/support/faq#how-can-i-revert-a-release. Can you try to configure your repository in your package.json as https://github.com/juresotosek/ink-divider.git instead of https://www.github.com/juresotosek/ink-divider.git?. Yes, GitHub doesn't expose Git repos on https://www.github.com.. This is done like that on purpose.\nIn that code, we parse the URL, add the basic auth part and format it. git-url-parse can achieve that but it also does a bunch of other stuff that we don't necessary control. For example, when reformatting the URL from the parsed object, it used to always remove .git at the end of the URL.\nIn other terms gitUrlParse(repositoryUrl).toString() === repositoryUrl doesn't always return true.\nUsing url.parse and url.format guarantees that not transformation will be done in the process or parsing/formatting. So the resulting URL will be identical to the original one, with the basic auth added.\nAlso the url package is part of Node (it's not a package.json dependency) so using it doesn't have any impact.. This happens because you already have a v1.3.2 tag bu it's not in the master history.\nbash\n$ git tag\n// => v1.2.0\n// => v1.3.0\n// => v1.3.1\n// => v1.3.2\nbash\n$ git merge-base --is-ancestor v1.3.2 master\n// => exit with 1\nIt seems you have rewritten your git history at some point, and now you have this v1.3.2 that is referencing a commit that doesn't exist in any branch history.\nSo when looking at the history of master semantic-release find the last tag v1.3.1, increment the version and fails to create v1.3.2 because it exists in the repo.\nYou should not create version like tags on branches other than your release branch. . According to the logs semantic-release properly update the package.json and calls npm publish.\nAnd I don't see any indication in the logs nor any reason for semantic-release to try to publish twice.\nWas the version 0.4.0 already published before you ran semantic-release?\nOr did you publish it before then unpublished it?. The error is reported by npm which is ran by semantic-release.\nEither it's a bug in npm or there was actually a 0.4.0 and 0.3.0 version already published before.. So it seems it's an issue on the registry side...\nThere is no much we can do here.\nMaybe it's similar to #804 ?. Closing as it seems to be a bug on npm registry. I invite you to open an issue over there.. I'm reverting the change that I made in #889 as it's not the proper fix.\nsemantic-release does try to do a push --dry-run with your unmodified URL and if it works then it uses it. It rewrite to a https URL only if the exact URL you configured fails.\nThis test fails in your case:\n\nsemantic-release:git Error: Command failed: git push --dry-run ssh://git@gitlabserver:10022/myGroup/myProject.git HEAD:semantic-release\n  semantic-release:git error: cannot spawn .git/hooks/pre-push: No such file or directory\n  semantic-release:git error: waitpid for .git/hooks/pre-push failed: No child processes\n\nYou mentioned running git push --dry-run ssh://git@gitlabserver:10022/myGroup/myProject.git HEAD:semantic-release works. However you must have run in a different situation (maybe locally? Maybe you run semantic-release not from the root of your repo? Maybe your CI doesn't clone the Git hooks so the command fails?).\nSo you should investigate the errors cannot spawn .git/hooks/pre-push: No such file or directory and waitpid for .git/hooks/pre-push failed: No child processes.. That's because none of those commit follow the Angular convention.\nPer the convention a breaking change has to be indicated by a BREAKING CHANGE note in the footer of the commit.\nYour first commit is not formatted like a breaking change commit. It just happens to contains the works \"major\" in the subject...but is formatted like a perf commit.\nYour second commit just has BREAKING CHANGE in the subject but doesn't have a body or a footer and therefore doesn't contains BREAKING CHANGE in the footer.. The tag is pushed to the remote between the prepare and publish steps because some plugins, such as apm require to have the tag on the remote.\nFor example, when running apm publish` it will:\n- Check if the tag exist on the remote repo\n- Publish the package referencing the URL of that tag\nI though about deleting the remote tag in case the publish step fails, but that might create other issues in case some publish fails but other succeed. For example is the apm plugin create the release but the github plugin fails, if we delete the tag then the apm release will probably be broken.\nIf we re-run semantic-release and try to publish the apm release it will probably fails.\nSimilarly if the npm publish works but the github fails, if we delete the tag, then on next run npm will try to release the same version again and fails as it's not allowed by the registry.\nOne solution I thought about would be to maintain a \"state\" of which plugin was successful, so when semantic-release re-run it would call only the plugin that previously failed. But the only way for semantic-release to maintain a \"state\" between execution is via tags.\nSo we would have to do something like that:\n- After prepare and before publish, create a tag like v${version}#{pluginName} for each publish plugin configured, in addition of the regular one\n- Call each publish plugin (passing the regular tag as of now)\n- For each publish successful remove the corresponding v${version}#{pluginName} tag\n- For each semantic-release run, check if there is a v${version}#{pluginName}, and in such case re-re-run the corresponding publish plugin and delete the tag if successful\nI din't think too much about all the edge cases though, and I'm sure there would be a lot. Also, it kind of feel like abuse the tag system and it might be problematic and confusing for some users (if one trigger something based on tag creation for example) to have all those tags lingering.. That wouldn't solve the problem as some platform might not provide a good way to figure out what was the last version released. In addition that would create a huge complexity to handle cases where two plugins return different versions for the last release.\nIt would also force every plugin with a publish step to implement a get-last-release one.\nThis is why we choose to use Git tags only:\n- One source of truth for versionning: the tag which is attached to the codebase\n- Works independently of the features provided by package manager (it doesn't matter if the provider doesn't allow to search previous releases)\n- Make plugin development more simple. Another solution to explore would be to offer users the possibility to run locally semantic-release recover <tag> which would be interactive and allow them to choose each publish plugin if they want to run it.\nWhen a publish plugin fails we could add something to the error message mentioning to use this command to re-run the failed plugin.\nIt's not the most automated way possible to recover, but it would give more flexibility as I don't think we can automatically handle all recovery cases in an automated way, or at least not without a huge added complexity.. @mike-north see https://github.com/semantic-release/npm/issues/11 and https://github.com/semantic-release/npm/issues/93.\nI'm also working on a solution that would allow to publish npm package with 2FA enable for publish. The solution would to publish to a temporary server and send an email to the package owner. The package owner would then login to a UI and enter their one-time password to do the actual publish to the real npm registry.. I think you have the right approach.\nAs to whether you should create a plugin or use @semantic-release/exec here a few general rules I would suggest. Create a plugin if one of those situation applies:\n- You need to run something more complex than a few shell command (e.g. you need custom logic, conditional execution, parse options, specific error handling, etc...)\n- You need to provide multiple plugin steps that share some code\n- You want to make your plugin available to other (note that you could also provide a shareable configuration that uses @semantic-release/exec). Thanks for the feedback.\nCan this issue be closed then?. Closing as it seems you implemented the solution discussed. The semantic-release-cli setup creates a token on npmjs.com and add it to Travis but doesn't set it locally. Once created on npmjs.com a token cannot be displayed anymore, so I guess what you configured in your local NPM_TOKEN environment variable is not that one.\nJust create a token with npm token create and then export the value with export NPM_TOKEN=<the_token_return_by_npm_command>.. Could you provide the semantic-release logs?. Nevermind, I think it\u2019s because you need to set the git plugin after the npm one in the prepare step.\nSee https://github.com/semantic-release/git/blob/master/README.md#usage. As you can see in the logs the @semantic-release/github and @semantic-release/npm are used but not @semantic-release/git, which is the default configuration.\nSo your config file is not read, either because it's not properly named or it's not in the root of your repo.. Semantic-release needs to be able to execute git commands to the remote repo you configured in the repository fields of your package.json.\nIt seems that with the URL and authentication you configured your GitHub instance returns a redirect.\n```\nThe command \"git push --dry-run https://[secure]@github.ibm.com/path/to/repo HEAD:master\" failed with the error message fatal: unable to update url base from redirection:\nasked for: https://[secure]@github.ibm.com/github.ibm.com/path/to/repo/info/refs?service=git-receive-pack\nredirect: https://w3id.sso.ibm.com/auth/sps/samlidp/saml20/logininitial?RequestBinding=HTTPPost&PartnerId=https://github.ibm.com&NameIdFormat=email\n```\nIt seems it's related to your SSO configuration. There is nothing we can do here, you have to configure your environment to allow git commands.. The Travis stage in which you run semantic-release doesn't affect the authentication.\nSo it might be some interaction between your SSO and the Travis stage.. Closing it's an issue related to your specific SSO config.. This is because you probably have a lockfile that forces an outdated version of marked-terminal.. Semantic-release defines its dependency to marked-terminal as ^3.0.0 so if you don\u2019t have a lock file it should install 3.1.0. How is that a problem with semantic-release?\nThe error logs show that semantic-release-plugin-decorators/src/index.js:18:18 calls import-from passing an object instead of a string in the second argument.. Closing as it's not related to semantic-release and no answer was provided in almost 10 days.. It's probably because you already have the tag v3.4.1 somewhere, but semantic-release doesn't find it because it's not in the history of the release branch.\nYou should delete this tag if it doesn't correspond to a release.. > Also, if they already existed before the release started, I think the release would fail when first pushing to GitHub. It doesn't. It creates the release just fine, with change-log and all. And the time of creation for the release and the tag seems to match as well.\nNot according to the logs you provided. In those logs semantic-release fails on creating the tag, which happens before anything is published. No release is created by semantic-release here.\n\nIt seems to me like it's just trying to push the tag twice\u2026?\n\nThere is no indication of that in the logs you provided. And the problem doesn't seems to happen for anyone else.\nHave you run git tag to verify v3.4.1 doesn't exists?\nWhat do you get from git rev-list -1 v3.4.1?. semantic-release does not support monorepos at the moment. See #193.\nSome of the core concept of semantic-release are:\n- Everything that makes it to master should be released\n- Every commit describe the change it makes to the code base, not the steps the developer took to implement those. That mean your commits must be atomic (1 fix or feature == 1 commit and 1 commit == only 1 fix or feature)\nThis is a \"good\" example of commit to merge to master:\nfeat: support themes\nThis a \"bad\" example of commit to merge to master:\nfix: fix another mistake I made while implementing the feature\nstyle: fix the linting errors\nfix: handle empty `theme` option\nfeat: load the theme\nfeat: add the `theme` option\nWith the fist solution you have several advantages:\n- When doing git blame you know exactly why some code was changed. With solution 2, you have no idea what is the context and the reason for the commit \"style: fix the linting errors\"\n- You have an git history that describe the changes made to your code base, and avoid the noise of all the details the developer when through locally while developing\n- You can do git checkout -b old-state <commit sha> and you will always a consistent codebase: all tests pass, no linting error, no half-done feature, no work in progress etc...\nsemantic-release only cares about the commits that makes it to master. You can do anything you like before that. Personally I tend to do many commits on my feature branch, without using the commit convention, so locally I can rollback a small change made in one of those commit for example.\nWhen the feature is done, the tests and linter pass, and the PR is approved, I squash the commit into one using the commit convention and describing the change. GitHub Squash and Merge feature is really convenient for that.\nIf the PR contains multiple features, it's a bit more tricky and I would use a Git IDE (like Sourcetree) to create one commit per feature, making each commit is atomic and contains only the relevant code.\n. I clarified the doc in #917.\nIt's quite common for any CLI to allow to negate options with a --no prefix, so --foo false is equivalent to --no-foo.. That's because you set npmPublish to false in verifyConditions and you forgot @semantic-release/npm in the prepare step.\nIf you don't want to publish on npm, but still want to update the package.json then set npmPublish to false directly under the release property. If you want to publish then do not set it anywhere.. That's the expected behavior. See Can I set the initial release version of my package to 0.0.1?.. Your config should be:\njson\n{\n\"release\": {\n    \"analyzeCommits\": \"@semantic-release/commit-analyzer\",\n    \"verifyConditions\": \"@semantic-release/npm\",\n    \"prepare\": \"@semantic-release/npm\",\n    \"generateNotes\" : \"@semantic-release/release-notes-generator\",\n    \"publish\": \"@semantic-release/npm\",\n    \"success\": false,\n    \"fail\": false,\n    \"branch\": \"master\",\n    \"npmPublish\": true,\n    \"tarballDir\": \"dist\",\n    \"assets\": \"dist/*.tgz\"\n  }\n}\nThis is not really intuitive and should change soon: #827. Closing as a solution was provided.. The subject chore(release): 1.0.1 [skip ci] should work as it's valid per the spec:\n\nA description MUST immediately follow the type/scope prefix. The description is a short description of the code changes, e.g., fix: array parsing issue when multiple spaces were contained in string.\n\nThe spec also doesn't enforce any particular casing:\n\nAre the types in the commit title uppercase or lowercase?\nAny casing may be used, but it\u2019s best to be consistent.\n\nAnyway, it seems it's a bug in commitlint that fails to detect the case when the subject starts with a version number.\nI would suggest to open a bug there.. Closing this one as it seems it's going to be addressed in marionebl/commitlint#438. The dependency is defined as ^12.0.0 so this range includes 12.0.2. The latest version in that will always be installed.\nIf you have a lockfile (package-lock.json or yarn.lock) it forces an outdated version of yarn and you should update it.\n. Closing per previous comment.. The problem is that if we limit the depth we might not be able to properly determine the last version released.\nFor example is configure a depth of 10 and you push 10 commits since the last release semantic-release will not fing the commit used for that last release and will consider there is no previous one, so it will release 1.0.0.\nUnshallowing will also be very important for #563 as we would need to check the tags on multiple branch, some of them potentially really old. For example if your last release is 3.2.1 and for some reasons you need to deliver a fix for a client that can't upgrade to 3.x.x. So you create a new branch from the last 2.x.x tag, let's say 2.3.4, apply your fix there and release 2.3.5.\nIf 2.3.4 was release 1 year ago, you probably have 100s of new commit in your repo since the commit tagged as 2.3.4. semantic-release would need to unshallow with a huge depth value to be sure to have it included.\nIn addition, and without going into too much technical details here, in #563 we have to do a lot verification for consistency across your branches (i.e. if you have a 2.x.x branch and a master you don't want to release a version from 2.x.x that is higher than the last version release from master).\nDoing those checks require to have a long history of commits in the local repo, as we need to have the last version tagged commit on each branch.\nWe used to unshallow with a depth of 50 before (maybe a year ago) and we changed to a full unshallow as it was creating to many issues for a lot of users. Those issues were pretty bad as they would end up releasing a wrong version.\nEven if what you propose is only an option, I think it opens the door to many bigger problems and there is probably better solutions.\nMaybe there is a way to configure your CI to cache the local repo, so on new builds instead of cloning the repo it would get it from the cache and fetch/pull the new commits.\n. Also 1.5G is pretty extreme, and you will probably encounter other issues (like limitation on the Git Hosting platform) so you might want to look at why it's so big and maybe see if you can reduce the size.\nSee https://confluence.atlassian.com/bitbucket/reduce-repository-size-321848262.html for some suggestions.. > Is there a way semantic-release can leave a \"trail\" of when the last time it was run, and use that as the shallow clone depth?\nThe only state shared between multiple semantic-release runs are the Git tags. In any case there is no way store that information when semantic-release runs, because the info we need comes from the remote repo (e.g. new commits, new branches, new tags etc...)\n\nSo parse the git log backwards till you find the last release?\n\nThat is not possible because depending on the merge strategy you use the commits will not be ordered by their actual merge time.\nIf you create a PR with a commit from Sept 23 and another one with a commit from Sept 24, merge that second PR which release 1.0.0 and then merge the first PR which release 1.0.1, then if you list the tags chronologically you will get 1.0.1 happening before 1.0.0. That's because the tags do not have a date, only the commit do.\n. Yes the tag have a date, but fetch with --depth is based on the commit, not the tags. Because the problem explain the commits might not be ordered the same as the tag.\nSo if you'd be fetching commit 10 by 10, and check if you find a tag in the newly fetched ones, there is no guarantee the first tag you'll find is the last one created.\nAlso, even if that was possible, once #563 is implemented, suffice. In #563 we check on each branch configured to release if there is a tag that was created from another branch but not the current one.\nFor example if you have a master and a next branch we go through all the tags on master to see if one was created on next and not on master (tags created on master are named vx.y.z, the one created on next are named vx.y.z@next). If we find one of those we make the corresponding version available on the dist-tag associated with master.\nSo if you release 1.1.0 from next (on the dist-tag @next) we create the tag v1.1.0@next. When you merge next in to master, we go through all the tags on master and we find that v1.1.0@next is in master history (because of the merge) so we search for v1.1.0 in master history. We don't find it and therefore conclude that 1.1.0 was release from next but not from master, so we add that release to @latest and create the tag v1.1.0 on the commit where v1.1.0@next is.\nAs you can see, in that process, we need all the commits in the repo in order to:\n- finding all the vx.y.x@next tags in master history\n- test if v1.1.0 exist on master\nBasically we need to keep a state in between run, with the info of what was released from where. Using tags is much more robust than any other solution because it's embedded in Git. Using a DB or a file, would create a lot more complexity and potential for error (like if you loose that state, you can't reliably release anything new with semantic-release).. @Aghassi did you find an alternative solution that wouldn't cause the problem mentioned?\nOn my side I've been thinking about that for a couple week and I don't see any other solution that write the state outside of the git repository, which is not a good solution, so we wouldn't implement it.. That's still supported. This change is fully backward compatible with existing configurations.\nBy the way for the cases you mention you also have the following options:\n- Set the npmPublish option to false to disable publishing\n- Set successComment/successTitle and/or failTitle to false (See semantic-release/github#111). As it's a pretty big feature that involve some plugins changes, we are going to keep this feature (and the associated plugin PR) on @next dist-tag for a couple weeks. I would rather avoid to keep it there longer as we have a discrepancy between the docs and what's on @latest.\nThat'd be great if users could test that new version on their projects, in particular:\n- Making sure existing configurations still works\n- Making sure the new plugins option works as expected. Thanks for the PR! However your addition is not really correct. If you look at the entry just above in the troubleshooting.md it describes the same error, in a context that is way more common.\nInstead I think we should add a paragraph in the configuration doc mentioning that for repo with existing releases the tagFormat must be set accordingly to the existing release tags. Or alternatively the tags should all be renamed to the format configured in tagFormat.. I made some changes in the docs in #936. I can add a \"migrating existing repo\" section (or something along those lines) after #936 gets merged.. GIT_CREDENTIALS is a semantic-release specific environment variable, Git itself doesn't do anything.\nThe only other variable we set are GIT_AUTHOR_NAME, GIT_AUTHOR_EMAIL, GIT_COMMITTER_NAME, GIT_COMMITTER_EMAIL, GIT_ASKPASS and GIT_TERMINAL_PROMPT.\nGIT_ASKPASS and GIT_TERMINAL_PROMPT are set to prevent the git command to prompt the user. As it runs on a CI it would block the build.\nUsing $HOME/.config/git/credentials is not something we have tested and is not mentioned in our doc. It present an important security as you would have a file on the CI containing your credential. Anyone can open a PR with code reading and printing the content of that file. The PR would trigger the job and your credential are compromised.\nSo I don't know if the problem you are reporting is specifically related to semantic-release or not, but in any case I don't see much reasons for us to investigate and potentially make changes to support an unsecure workflow.\nThe only recommended approach for authentication are the GIT_CREDENTIALS environment variable and ssh keys.\n. > I thought that because git cli was used, then we could use any git authentication flow.\nTheoretically yes. In the sense that we don't do anything on purpose to prevent any authentication type. Now if a specific authentication type that provide value doesn't we will try to support it. In the present case, I'm not sure that authenticating with $HOME/.config/git/credentials present much value as it comes with a big security flow when running on a CI.\n\nI was and I am still confused with GL_TOKEN, if the recommended approach is GIT_CREDENTIALS.\n\nGIT_CREDENTIALS, GL_TOKEN, BB_TOKEN and GH_TOKEN are effectively the same when it comes to the authentication for the git CLI. When I was referring to GIT_CREDENTIALS I was implying GIT_CREDENTIALS or GL_TOKEN or BB_TOKEN or GH_TOKEN.\nGL_TOKEN will be used for git CLI auth and GitLab API auth, same forGH_TOKEN.GIT_CREDENTIALSwill be used only forgitCLI auth. There is also some minor differences in the way the authenticated URL is built based on the platform (e.g. for GitLab the format ishttps://gitlab-ci-token:@gitlab.com/owner/repo.git`).\n\nI used to run semantic release with GL_TOKEN=$token npx semantic-release and having git-credentials configured at the same time without hassle.\n\nThat's because semantic-release use GL_TOKEN for git CLI authentication in that case. What you set in git-credentials is probably just ignored.\n. See the log message:\n\nThe command \"git push --dry-run https://github.com/oleg-koval/koa-verto.git HEAD:master\" failed with the error message remote: Invalid username or password.\n\nAlso the CI logs link you provided doesn't contain the same logs you included in the issue. The logs on the CI says:\n\nError: GitHub authentication missing\n\nSee https://travis-ci.com/oleg-koval/koa-verto/jobs/149680141#L2878\nSo I think the problem is you didn't configure the authentication on your CI. Please see the doc: https://github.com/semantic-release/semantic-release/blob/caribou/docs/usage/ci-configuration.md#authentication. I don't think your GitHub token is set. See https://github.com/semantic-release/travis-deploy-once/blob/master/lib/validate.js#L12\nAnd you have this error in your CI logs https://travis-ci.com/oleg-koval/koa-verto/jobs/149680141#L2878. Also now that Travis Build Stage are out of beta it's recommended to use them instead of travis-deploy-once. See https://github.com/semantic-release/semantic-release/blob/caribou/docs/recipes/travis-build-stages.md. Please make sure the GH_TOKEN environment variable is set properly in Travis and let us know if that solve the issue. If not please provide the Travis log with after the variable is set.. semantic-release cannot work without pushing tags because on each run it will check the previous tags to figure out what is the last release and what are the new commits.\nSo it cannot be optional.. Plugins can push tags. But if the tags are pushed only by plugins and not by the core then it becomes optional (i.e. one can configure semantic-release without the plugin that pushes tags).\nIn such situation semantic-release wouldn't work an always release 1.0.0.\nSo the tag created by semantic-release is mandatory. But you can create a plugin that push other tags if you want.. btw, what is the use case? Why would you not want to create a tag?. > In my case runners doesn't have access to git repository, and only way to push tags is using gitlab api\nIt the runner doesn't have access to the git repo, how the repo was cloned on the CI in the first place? How semantic-release was able to read and analyze the commits?\nAnd how is it possible to have access via API but not with git? As far as I can tell Gitlab expose the API and the git interface on the same host/port and the permissions are the same for both.. Closing as no answer was provided. If you want to propose a feature please use the corresponding issue template and explain the in which circumstances the feature would be useful.\nIn that case include the answers to the questions asked in https://github.com/semantic-release/semantic-release/pull/944#issuecomment-427886267. The form semantic-release pre && npm publish && semantic-release post is not supported for more than a year. \nPlease read the documentation: https://github.com/semantic-release/semantic-release/blob/caribou/docs/usage/README.md. As mentioned in README, semantic-release parse your commit according to a commit convention to determine the type of release to make and the default one is Angular. However it seems your commits do not follow that convention.\nIt also seems that you do not have any version tagged in your staging branch so far, so semantic-release analyze all your commits (744 of them) and it seems that at least one is formatted according to the angular convention so a version 1.0.0 is released.\nFinally you are running in dry-run mode. I'm guessing one the first line of logs which you didn't include in your issue report is This run was not triggered in a known CI environment, running in dry-run mode. This is explained in the FAQ.\n. Thanks!. The setup CLI does not support Bitbucket. You should follow the documentation instead of using the setup CLI: https://github.com/semantic-release/semantic-release/blob/caribou/docs/usage/README.md.\nBeware that the current doc correspond to the version of semantic-release on the @next dist-tag.. There is no @semantic-release/bitbucket because Bitbucket doesn't offer an API to make releases.\nYou should use the @semantic-release/git and @semantic-release/changelog plugins to generate a CHANGELOG.md file and push it to the repo.\nAs mention earlier you should use the version of semantic-release and each plugins from the @next dist-tag, as the doc correspond to those versions.. Can you run semantic-release with the --debug option and provide the logs?. So it seems you configured your repositoryUrl as a git or ssh URL, therefore the git command line tries to uses ssh. And it seems you have some ssh keys in your environment and those doesn't give you permission to access your repo.\n\nPermission denied (publickey).\nfatal: Could not read from remote repository.\nPlease make sure you have the correct access rights and the repository exists.. I don't think providing types for everything in semantic-release would make much sense as it it mostly used as a CLI and I don't want to maintain type definitions. However types can be useful for plugin author.\n\nIs there a way to only provide an interface that plugin authors would have to implement?\nNot sure in that case if that would have to be added to package.json.\n. @mattyclarkson, @byCedric  If we were to add the type definition for plugins in this repo, would you help maintaining them in the future?\nIf yes we can add them in the semantic-release repo, otherwise I would prefer to add them to DefinitelyTyped.. You can the changes for this feature in https://github.com/semantic-release/semantic-release/tree/multi-branches\nI have to find the motivation and time to finish the doc and test. So things might still change a bit.. Thanks!. semantic-release just run npm publish which will includes files that you defined in package.json#files if they exists.\nIt seems you configured a prepublishOnly step that runs your build script. However npm cannot run this script on your CI:\n\nprepublishOnly: cannot run in wd @taktikal/my-test-project@1.0.7 npm run build (wd=/builds/taktikal/test/my-test-project-client)\n\nThat's probably because you are using the root in your CI. See https://github.com/npm/npm/issues/3497\nThe solution is probably to not use root or sudo.. On a side note, when npm cannot run prepublishOnly it should errors out rather than just displaying a warning, because it can leads to this type of situation where you publish a broken package.\nI think it worth opening a bug report with npm.. For info I opened and issue with npm to properly fail the publication in that case, rather than publishing a broken package: https://npm.community/t/failure-to-run-prepublishonly-should-trow-an-error-rather-than-just-a-warning/2779. semantic-release used to allow to retrieve the last release commit via a plugin, and the npm plugin used to implement the tag retrieval by reading the gitHead property from the package.json published on npm. However we moved away from that mechanism for several reason:\n- There is many cases where the gitHead was not present in the package.json on the registry\n- It creates additional complexity\n- If you don't use npm, or choose to not publish your package to the registry then you can't get the commit corresponding to the last release\nFor all those reasons we moved to a solution where we retrieve the last release from Git tags. Which means we have to push a tag during a release so we can read it in the next run.\nIn addition the feature #563 uses tags to figure out what version was published on various distribution channel. For example it allows us to determine if a given version was published on @next but not on @latest. If the master branch contains the tag v2.0.0@next but not the tag v2.0.0 we know that 2.0.0 was published on @next and the corresponding commits were merged to master so we can add the release 2.0.0 to the @latest branch and create the tag v2.0.0.\nSo in the end it's a trade off. Using tags prevent to use semantic-release in cases where you don't have write access to the remote repo, but it makes thing more simple, allow to support more workflow (i.e. it doesn't require to publish to npm registry) and it allow to support multiple branches and distribution channels.\nConsidering that situation where you don't have write access to your repo are fairly uncommon we chose the solution that allow us to implement an often request feature and to support workflow that doesn't publish to the npm registry.\nRegarding the problem you are facing. If the Git credentials (I'm guessing the BITBUCKET_TOKEN environment variable) is not available on your CI when running  semantic-release, that probably means NPM_TOKEN will not be available either so you won't be able to publish on the registry and retrieve the gitHead later.\nMaybe using ssh keys for authentication would solve your problem: https://github.com/semantic-release/semantic-release/blob/caribou/docs/recipes/git-auth-ssh-keys.md. You would still need to make NPM_TOKEN available to semantic-release though.. Just out of curiosity, why are the credential removed?\nCan you confirmed that the NPM_TOKEN is also removed? If yes how would you publish to npm from the CI?. Returning the release notes in the JS API makes sense, so I'll merge the PR!\nHowever what you try to implement is not gonna work. See #585 for the details.\nTo summarize:\n- semantic-release is currently coded to not run on PRs\n- semantic-release requires access to a local repo clone which you won't have in a GitHub app\n- secured environment variables (like NPM_TOKEN) will not be available in the GitHub app so many verifyConditions will fail\nAs you can see in #585 we plan to support commenting on PRs, but it's really not simple and we need to find the right solution first.. Thanks! See https://github.com/semantic-release/semantic-release/issues/959#issuecomment-431596890 regarding your use case.. That error happened when we call the GitHub API to search for issues associated with the release commits. My guess is that it's related to yesterday's outage.. Unfortunately no because the releases happened and worked properly. It's the final success step that failed and there is no simple way at the moment to re-run only that step.. Actually I think it's related to https://github.com/octokit/octokit.net/issues/1381\nThis is because your repository url in your package.json is configured to github:zeke/get-svg-colors but it should be https://github.com/colorjs/get-svg-colors.\nI guess you migrated your repo to an organization and didn't update the package.json.. Most of the API calls follow redirects, but not the search API. I think it's because the repo and owner are part of the q parameter and are not part of the URL itself like other endpoints.. This is caused by https://github.com/IonicaBizau/git-up/issues/17.. @martinmosegaard, @Alorel the problem is in git-up which is a dependency git-url-parse. The specific version of git-up is in range of the definition in git-url-parse so there is nothing that can be done in semantic-release. Change our dependency definition of git-url-parse would not change anything.. See #944 and #957 for explanation of why not pushing a tag is not possible.\nIn your case you should use the @semantic-release/exec plugin to run the script that update your files with the version. You'll have to configure it to run on the prepare step before the @semantic-release/git plugin. Alternatively you can create your own plugin to do that, instead of using @semantic-release/exec.\nThen configure the assets option @semantic-release/git to includes your modified files in the commit.. Duplicate of #944. Duplicate of #957. > I'm aware that tags themselves are mandatory, but it is not mandatory for semantic-commit to push tags itself, it can be done by something else as long as tags are there in the end.\nI don't know what semantic-commit is. If you meant semantic-release I think https://github.com/semantic-release/semantic-release/issues/957#issuecomment-431133011 does explain why it has to be done by semantic-release and not by something else.\nAlso the statement \"as long as tags are there in the end\" is incorrect as some publish plugins require to have an existing tag on the remote repository (Atom packages or GitHub releases for example).\n\nMoving update script to shell file and using exec would needlessly complicate things as all our build process is inside Jenkins pipeline which uses groovy code. Rewriting all that in shell file (or javascript) would cause quite a lot of complications and loose jenkins integration.\n\nI understand. However moving out the tag creation logic into something else (which is quite complex with #563) will cause a lot more complications for every other semantic-release users as they would have to handle it themselves. . Once #563 is released, tags are created:\n- before the prepare step for each version that was merged into the current branch and needs to be added to a distribution channel\n- After the prepare step and before the publish step\nThe correct determination of the last release for the publish step requires the tags created after adding to a channel. So it can't be simply done by the user after semantic-release ran. \nImplement what you are requesting would:\n- Require to develop the code to handle errors in case the user didn't create the tags properly\n- Require to maintain that code\n- Require to write the documentation explaining users how to create tags themselves\n- Find a way to limit situation where incorrect or partial releases could be published: for example a release without a tag, or vice-versa, or a wrong last release determination\n- Complexity and limit future developments as any new feature would have to handle the case of tags not being available after the prepare step\n- Create a longer and more confusing documentation for users (users getting confused or not reading the doc completely is by far the majority of tickets and time spend on this project)\n- Handle support tickets of users getting themselves in a non recoverable situation, with releases partially done or done incorrectly, due to misconfiguration when using that option\n- Handle support tickets of users asking for help about how to create the tag themselves when using that option\nAnd I'm sure I could go on and on... So no, it's not as simple as making that optional even if you write the word optional in capital letters.\nAnd no it's not obvious for users that certain plugins/workflow would not be usable with that option. The plugin concept is that they do not depend on other plugins nor on specific core config.\nYour workflow is very specific and I'm pretty sure the very large majority of current or future semantic-release users are not using it. In addition there is a more simple solution, as mentioned before, that consist in wrapping your code that update your project files in something callable via command line and call it with @semantic-release/exec. This can be done with any language and would take less time than implementing what I mentioned above.\nSo it's a trade-off and I don't think it's worthwhile to try to implement such feature. And I still think it's not even possible without scarifying a lot of current and future more useful features.\nIf you disagree, I suggest you to fork the project and modify it for your specific needs.  . This is due to https://github.com/IonicaBizau/git-up/issues/17. It should be resolved when https://github.com/IonicaBizau/git-up/pull/19 get merged.\nIn the meantime, changing your repository URL to https://github.com/Typeform/forms.git (remove the git+ part) should solve the problem.. Caused by #963. This PR remove the dependency to git-url-parse and replaces it by custom code, I don't see how it's related. The internal of the plugins mechanism can change anytime without a breaking change as long as it doesn't impact the plugins API or the configuration. If you monkey patch something you take the risk to see it breaking without notice.\n. This bug is already fixed in release-notes-generator@7.1.3.. Duplicate of #969. What would be the point of breaking down semantic-release into multiple pieces that could run individually?\nsemantic-release is already modular thanks to plugins: https://github.com/semantic-release/semantic-release/blob/multi-branches/docs/usage/plugins.md\nInstead a GitHub action could be one that runs when all CI pass (is that possible by the way?) and that just run npx semantic-release.\nThe workflow you describe is already possible via the config plugins: ['@semantic-release/commit-analyzer', '@semantic-release/release-notes-generator', '@semantic-release/npm']. To generate a CHANGELOG.md file and include it in the npm package, add @semantic-release/changelog to the plugins list. To commit the CHANGELOG.md to your repo, add @semantic-release/git to the plugins list. To create a release on GitHub and comment on included issues/PRs add @semantic-release/github to the plugins list.\nBreaking down semantic-release into multiple piece as you suggest would be quite complex to do and make us loose a lot of features. Currently the each plugins are orchestrated and called by the core and there is some dependencies, for example:\n- If the publish step of a plugin fails we call the fail step with the corresponding Error, that allow to open an issue on GitHub for example\n- For each successful publish we call the success plugins with information related to each release (URL, name, plugin that made the release, commits, etc...), that allow for example to add comments on issue and PR included in a release\n- The generateNotes plugins (the default one can use conventional commits or other presets) are called and the resulting notes are passed to all publish plugins\n- There is a prepare plugin step that allow to generate or modify files, that can be published by the publish plugins\nThe problem with having all those steps running in different processes is that we cannot pass much information between them other than the version released (via the tag itself). The current plugin system allow a lot more flexibility and advanced features. In addition, I don't see how configuring several actions is beneficial versus configuring a list of plugins. Finally the current plugin system allow to work and be modular with any Git host (GitLab, Bitbucket, custom server) and to deploy to any package manager.\nThat said, if you provide compelling reasons to go that direction we'll certainly consider it!. > I instead wanted to publish the npm module using actions/npm, I could just setup the following config:\nYes you can exclude the @semantic-release/npm plugin to opt out of publishing to npm, and then run your action to do that.\nBut by doing so you loose the following semantic-release features:\n- Includes a link to the npm registry in the comments added to issue and PR included (if you were to use the @semantic-release/github plugin)\n- Warn the user of the npm publish error (for example by opening an issue on GitHub with the @semantic-release/github plugin)\nSo again, what would be the point?\n\nI think a compelling GitHub action would potentially just be a container with semantic-release installed, reasonable defaults, and the ability to modify behavior somewhat with environment variables.\n\nThat's already the case. By running npx semantic-release you have by default ['@semantic-release/commit-analyzer', '@semantic-release/release-notes-generator', '@semantic-release/npm', '@semantic-release/github']. You cannot customize that by environment variable but you can via configuration file or CLI args.\nThis is why I suggested that a semantic-release action would just run npm semantic-release. It could also allow to pass parameters as CLI args.\n\nShould I attempt to see https://github.com/conventional-commits/conventional-commits-action over the finish line, and we could potentially reference it as one of the recipes? Or would you rather create your own action, and I'd happily contribute?\n\nconventional-commits-action seems more limited than what semantic-release do now (multiple commit convention, multiple plugins etc...). We won't reference it as a recipe in the semantic-release repo as it's a different tool even though it's doing something similar. It might be of use for folks who want a simpler/lighter solution though.\nWe will most likely create a GitHub action that runs npx semantic-release $* in the future. Probably when my request to access the beta is approved :-) Contributions are always welcome :-)\nThe code should be extremely simple though:\n```\nFROM node:10-slim\nLABEL....\nCOPY \"entrypoint.sh\" \"/entrypoint.sh\"\nENTRYPOINT [\"/entrypoint.sh\"]\nbash\n!/bin/sh\nset -e\nsh -c \"npx semantic-release $*\"\n``\n. GitHub actions would be really beneficial for semantic-release if they would allow to:\n- run semantic-release only after multiple CIs repost a success status\n- Allow to have access toGITHUB_TOKEN` for pull request originating from a forked repo, so we could add comments on PR with info regarding the version that would be released when the PR is merged\nI don't know if that's possible though. Without those two things, running semantic-release in any CI or a GitHub action is pretty much he same thing.. > do you mean external CIs? (Such as Travis CI, etc.)\nYes\n\nI would assume not, but I haven't confirmed that myself.\n\nSame. I'd be curious to know. Currently the only solution is a GitHub app, which come with limitation (no file system, can't run user code)\n. All that doesn't provide additional value versus any CI as most CI offer a mechanism to orchestrate jobs.\nOne benefit that GitHub actions could bring would be to run something when all check status on the HEAD are successful. So it would allow for example to run semantic-release only after Travis CI and Appveyor and Codecov are successful for example.. > I agree, I think GitHub actions are made much more valuable once there's a clear story regarding how you can wire them together with a variety of external services. Travis CI, or AppVeyor, etc., have the benefit of running on a large matrix of platforms, providing information about past failures, etc.\nBasically I'd like a trigger like check_all that would run the action when all Check API status are successful. It doesn't seems that exist: events-supported-in-workflow-files\n@bcoe do you think there is some workaround or a solution to achieve a similar workflow?\nThe solution I planned to implement is a GitHub app that list for Check API events, and when all are successful create a branch, that would in turn trigger the a CI job that runs semantic-release.\n\nwhat is cool about GitHub actions is they do magically populate the GITHUB_TOKEN for the repo they're installed on, and the code is already cloned into the working directory by the time your action runs.\n\nYes that's the cool part, however is it guaranteed? What happen when you run the action on pull_request events and you open a PR from a forked repo?\nDoes it just run with an empty GITHUB_TOKEN? Doest it run at all? Or does it run it with the GITHUB_TOKEN somehow?\nBasically, do you have to handle that case when you develop an action?. @shawnbot great to know that you are looking to use semantic-release with Primer!\nWe'll definitely provide a GitHub action at some point. But there was no urgency on our side as long as actions are in beta.\n\nI had to create a new action that installs the git binary from the same node:10-slim image as actions/npm.\nYes git is required and there is no easy way around that as we want to preserve compatibility with non-GitHub repos. But when we provide our own semantic-release action that shouldn't be a problem.\nTo maintain parity with the actions/npm environment, I copied that action's entrypoint.sh and \"aliased\" NPM_TOKEN (which semantic-release expects) to NPM_AUTH_TOKEN.\nYes semantic-release require the variable to be named NPM_TOKEN. I'm not sure what's the point of maintaining parity with actions/npm. Once we provide our own semantic-release action the variable will have to be named NPM_TOKEN.\nI had to call semantic-release with --no-ci because it doesn't seem to recognize the Actions environment as CI (maybe because it doesn't set a CI environment variable?).\nThe CI we support are listed here: https://github.com/pvdlg/env-ci#supported-ci. We'll add support to GitHub actions.\nTo get around the lack of push permissions for the built-in GITHUB_TOKEN, I created a personal access token with full repo permissions and added it as a GH_TOKEN secret. (Just to be safe, I also disabled the automatic GITHUB_TOKEN in this task.)\n\nThat's kind a problem...I though the GH_TOKEN provided by the action would have sufficient permissions.... semantic-release needs at a minimum to push tags to your repo. And depending on the plugins you are using, it might also need to push commits.\nDo you know what are the permission of the GH_TOKEN provided by the action?\nIs GitHub plan to have that configurable (in a better way than by setting your personal token?).. I can't reproduce. For me with the URL https://github.com/benbria/loop-contact-prompt.git, https is used.\nCan you provide the log output with --debug? . Closing as this problem doesn't seems to affect anyone else (so not likely to be a bug) and no answer was provided here.. Maybe you add an older version due to a lockfile?\nAnyway feel free to re-open if the problem happens again.. Thanks for the PR. Instead I opened #983 which allow multiple definitions for analyzeCommits plugins. That will make things clearer and more consistent across plugins.. Thanks. env-ci is used to determine the branch on which your CI is running.\nIn the case of team city it reads a property file which is referenced by the environment variable TEAMCITY_BUILD_PROPERTIES_FILE. According to the Teamcity doc that's the proper way to access system properties.\nI would suggest to review the Teamcity doc and try to figure out if TEAMCITY_BUILD_PROPERTIES_FILE is properly set and if the file it points to contain the teamcity.build.branch variable.. What do you mean by \"I printed the teamcity.build.branch\"? What command did you run to print it?\nIs it in the file referenced by TEAMCITY_BUILD_PROPERTIES_FILE?. > Therefore for my understanding the needed variable that https://github.com/pvdlg/env-ci/blob/master/services/teamcity.js is calling is available.\nAgain, env-ci reads that from the file referenced by TEAMCITY_BUILD_PROPERTIES_FILE because this is what the Team City docs mention to do. It seems in your case, this is set as an environment variable of its own... So either the docs is wrong/misleading or there is something special about your environment.\nWhat is the value of the TEAMCITY_BUILD_PROPERTIES_FILE environment variable? Does it point to a file? What's in that file?. I released a new version of env-ci that reads teamcity.build.branch from environment variables if it can't finds it in the properties file. That should solve your issue.\nThe Teamcity docs is really unclear...It seems there is multiple scope for variable and they can be set in multiple places depending on the scope...But nothing explain what those scope are or what variable will be where based on those scopes... It's also quit difficult to have a lot of test and feedback on Teamcity as it's not really a popular CI...\nAnyway please try again with the new env-ci version (it's a patch release so it should be installed automatically unless you have a lockfile) and let me know if that fixes it.\n. As long as you don't have a package-lock.json or a yarn.lock the updated dependency will be automatically installed.. Can you provide:\n- The value of the teamcity.build.branch environment variable\n- The value of the TEAMCITY_BUILD_PROPERTIES_FILE environment variable\n- The full content of the file referenced by TEAMCITY_BUILD_PROPERTIES_FILE. I'm confused, according to this comment the teamcity.build.branch variable was set to development. And now it's set to /opt/buildagent/temp/buildTmp/teamcity.config6472602540593814375.properties:teamcity.build.branch=development\n/opt/buildagent/temp/buildTmp/teamcity.config6472602540593814375.properties:teamcity.build.branch.is_default=true ??. Also, what is the value of the TEAMCITY_VERSION environment variable?. Ok...but I asked \"The value of the teamcity.build.branch environment variable\"...so I don't understand what's the connection with a grep on a file...\nYou can obtain the value of this environement variable with echo $teamcity.build.branch on Linux or echo $teamcity.build.branch on Windows.. So I tested locally with the environment variables and file you gave me and it works as expected.\nI tried to test on Teamcity directly but after more than an hour I can't make it set teamcity.build.branch anywhere. I did set a branch specification as mentioned in the Stackoverflow post you linked. But the environment variable teamcity.build.branch is never set.\nSo I don't know how you manage to have it set...\nHow do you print this environment variable exactly? With echo $teamcity.build.branch in a command line step?\nA you sure this is actually the command being executed on the OS? Or is TeamCity replaces the variable before executing the script and actually ends up running echo \"development\"?\n. Yes, you can pass the --no-ci option.. > It is listed under Predefined Parameters\nOk but I don't know what that mean...That's a team city jargon.\nWhat I need to know is how can I get the branch name at runtime?\nIt seems reading the content of the file in TEAMCITY_BUILD_PROPERTIES_FILE doesn't work (or at least not all the time).\nReading the environment variable teamcity.build.branch doesn't work as it's not set as an environment variable.\nSo if there is no way to determine the branch on which the build is running for Team City then we'll just drop support for it. We try to make every effort possible to support as many CI as we can, but at some point, if a CI doesn't have such a basic feature as determining the current branch, there is no much we can do. For every other CI supported by env-ci determining the current branch consist in just reading the value of one environment variable.\n. Yes, please ask them what is the proper way to obtain the branch that triggered the build.. This should be fixed in env-ci@3.1.2. Please re-open if it's not the case.\nPlease also open an issue with TeamCity and share the link here as it would be nice to have an answer from them about a consistent way to obtain the branch on which the build is running on.. It's actually a bit more complex than that due to shareable configuration.\nYou can have the following project structure:\nmy-project\n\u251c\u2500\u2500 package.json\n\u251c\u2500\u2500 node_modules\n\u2502   \u251c\u2500\u2500 my-shareable-config\n\u2502   \u2502   \u251c\u2500\u2500 index.js\n\u2502   \u2502   \u251c\u2500\u2500 my-template.hbs\nIn that case the template is embedded in the my-shareable-config package, so you won't be able to load it by just knowing the path of the semantic-release config.\nAnd that can also happens with the dependency of a dependency and so on. So I'm not there is a good way to define which path is the right one to load dependencies from.\nMaybe an easier way is to configure semantic-release with a release.config.js file so you can import your template file there.\nSimilarly if you create a shareable config you can import your template from there as a shareable config is a JS module.\nIn that situation your plugin would receive a string for the template with the content of the template rather than the path.\n. Unfortunately, as far as I know there is no good solution for this kind of problems. Passing the main semantic-release config path might solve your issue in one specific case, but it will open the door to many situations that are even more broken.\nPassing the path of the config implicitly makes that it's a \"supported feature\". And it won't work in case of a shareable config, because there is no way to know if the file would have to be loaded relatively to the main config or relatively to the shareable config.\nSo we won't implement this at this point.\nYou have different solutions though:\n- Mention in your docs that in order to customize the template a release.config.js must be use and load the template. In that case your option expect the content of the template.\n- Or mention that the path to the template must be relative to the root of the project (which is where semantic-release should run from). In that case your option expect a path to the template.. https://github.com/semantic-release/evolution/blob/release-workflows/_drafts/release-workflows.md is not up to date. It was a specification draft and details changed during implementation.\nPlease use the documentation on the beta branch.\nThe correct property is name and not branch.\nchannel is mentioned in the doc: https://github.com/semantic-release/semantic-release/blob/beta/docs/usage/workflow-configuration.md#branches-properties. Is your version.js or @iteratec/semantic-release-docker commit something to the remote Git repo?\nWas there something committing to the remote repo while semantic-release was running?\nsemantic-release verify that the local branch is up to date with the remote at the beginning of the process and will exit if it's not the case. If you have something updating the remote in between this check and the tag creation there is no much we can do.\nI guess we could check if the remote is up to date when the push fails so we can print a slightly more useful message, but it's a case that is so rare that I'm not sure it worth it.\nWe choose to skip the release when the remote is ahead because:\n- we don't want to inadvertently erase a commit you might have done in your CI before running semantic-release\n- there is no guarantee that doing a pull would work because the local and remote might have a merge conflict (e.g. if you rebased your head commit on the remote)\n- You might have run build scripts before running semantic-release, and those would have used an outdated version of the code, therefore the published code would be wrong\n- It can creates several unexpected issues because your CI would have started with a certain head and we would modify it (e.g. the CI dashboard will display a head commit that is not the one actually used)\nIn any case it doesn't really matter that we skip the release on an outdated local branch, because if the remote has been updated it would trigger another build and semantic-release would run without errors for this one.. > The first problem now is, that there was no version published for this commit.\nHow would you push a tag from an outdated local repo? How could you handle any type of discrepancy between local and remote (including new commit pushed, remote branch reset to an older commit, rebase of the head commit on remote) when pushing that tag?\n\nThe second problem is that semantic release did not finish in a pristine state as the tag was pushed to the remote and then exited with failure.\n\nAccording to your logs the tag was not pushed to the remote. See \"error: failed to push some refs to 'https://remote.gitrepo.com/path/to/project'\"\nAlso semantic-release doesn't have control on external events. We can't prevent external things to happen between when we make the check and when we push.\n\nI would expect semantic release to run without error, once it verified in the beginning, if the branch is up to date.\n\nAgain there is no way to achieve that, as there is no way to prevent things to happen outside of semantic-release. The verification happens at a point in time, and the push at another point in time and we can't prevent things to happen in the outside word between two point in time. As far as I know there is no way to put a lock on the remote between those two point in time, so there will always be a race condition there.\n. I didn't realized the tag was created but pushing the head failed.\nShould be fixed in #994 .\nRegarding https://github.com/semantic-release/semantic-release/issues/993#issuecomment-440708053 it's not completely correct. Pushing to Docker should be done in the publish step which happens after the tag is pushed. You should not publish things in a step before publish.. /cc @gr2m . Ok after more research the problem is due to an outdated version of node-fetch.\n@rolandjitsu this is because you are forcing this outdated version with your yarn.lock file: https://github.com/thesoftwarecompany/colormaps-client/blob/master/yarn.lock#L3817\n@gr2m, @octokit/request.js uses node-fetch here but doesn't defined it in its package.json. If it was properly set in dependencies the problem wouldn't have happen as Yarn or npm would have guaranteed the version requested.\nFor info there is ESlint rules to check those type of things: import/no-extraneous-dependencies.. As explained above the problem is in @octokit/request.js. Adding a dependency to node-fetch will not solve the problem. Actually @octokit/rest.js which is a parent of @octokit/request.js already defines the dependency to node-fetch.\nThe problem is that you have something in your project that defines a dependency to node-fetch@^1.0.0 and @octokit/rest.js has one to node-fetch@^2.0.0, but the way Yarn/npm resolves that is by providing node-fetch@^2.0.0 to @octokit/rest.js and node-fetch@^1.0.0 to everything else. I don't know exactly what the rules are in Yarn/npm, but in any case you can't expect Yarn/npm to provide you systematically the right version if you don't specifies it.. I have one almost ready. Thanks though.. Closing as it was already fixed in https://github.com/octokit/request.js/pull/15.\nJust update your yarn.lock or package-lock.json to use up to date dependencies.. I can't reproduce the issue. I'm very confused about what happen there...\nThe function gitTags called here does exists there. I don't know how could not find it...\nIs it something systematic? Can you reproduce it?. @Hyperkid123 did you had a change to test that again? I see you have successful build on your repo now: https://travis-ci.org/Hyperkid123/data-driven-forms/builds/459063120. I think you have a corrupt cache on Travis. You should delete that cache and restart your build.\nAlso you should not cache node_module but $HOME/.npm instead: https://twitter.com/maybekatz/status/905213355748720640. Can you remove the \"warning\" section from there? That should be in the Readme of your plugin.\nAlso it's not accurate as now the preferred configuration methods is to use the plugins option.\nI quickly checked your plugin code and there is several issues I found:\n- Hardcoded dependency to GitHub there. Use the option repositoryUrl instead, which is an authenticated URL that semantic-release passed to you\n- Hardcoded dependency to Travis there. Use the branch option that semantic-release passed to you\n- Instead of creating and pushing your commit, you should just update the pom.xml and let users use https://github.com/semantic-release/git to commit it\n- What your are doing in verifyRelease should be done in verifyConditions. The point of verifyRelease is to determine if the release type determined based on commits is correct (e.g. if based on the commits semantic-release determine a patch verifies that there is no breaking change by running previous version test or checking the public API didn't change, etc...)\n- It's quite surprising to change the pom.xml to a snapshot version in publish.js#L18. You should not need to do that with automated version releases.\n- You should not set user.email and user.name, semantic-release does that already\n- You should not verify the current CI branch, semantic-release does that already\n- You should not checkout a branch as it can creates many issues on CIs for code that can run after semantic-release\n- You should not define semantic-release as a dependency but as a peerDependency. See example.\n- Your doc Step 5 and Step 6 are not necessry as that's already part of semantic-release doc\nWould you mind solving those issues before we add it to the list? Feel free to ask questions on on the Gitter chat.. I was just wondering about those 2 commits. I think the one done in prepare can be done with @semantic-release/git. For the one done after publish that can be done in your plugin. If it's really specific to your workflow it can be behind an option. It's it's a general practice that any user would use it can be the default behavior without option.\nTo clarify, it's perfectly fine to create a plugin very specific to your workflow. But in such case it doesn't make much sense to add it to the list of plugins in this repo. The goal of this list is to provide plugins that can be used by other. This is why it's important to not restrict those to one CI for example.\n. @kopax you already asked this question here and someone else already told you that you won't be able to get help if you don't provide any details.\nI'm mentioning it because it became a recurring problem where you ask a question with no details, context or error messages, forcing other to chase you for informations. That's actually something mention in you guidelines.\nYou won't get any answer to such vague question because no one can just guess the answer without information to analyze. Then when you see that you open an issue to force an answer from the maintenance team. \nPeople maintaining this project and helping out on the chat/issue tracker are not paid and have no obligation to provide support, they are all volunteer doing so on their free time as a hobby. Try to put your self in the shoes of someone susceptible to help you. Would you take on your free time to help someone who doesn't even bother including the problematic commit message, or the link to the repo, or the CI logs?\nSo please provide those information on this issue and for future questions. You might not figure out what to provide right away, but at least try to provide some common sense things: commit message, repo link, semantic-release logs.. I would assume you are using the Angular commit convention...So please read: https://github.com/angular/angular.js/blob/master/DEVELOPERS.md#footer.\nThe BREAKING CHANGE part as to be in the footer. A oneliner commit is not a valid breaking change commit per the convention.. How is semantic-release installed? Globally or locally? Do you have the semantic-release devDependency in your package.json?\nHow is installed your shareable configuration? Do you have is as a devDependency in your package.json?\nWhat is the content of your shareable config? I'm not sure if what you provided under \"semantic-release configuration\" is the config in your project or if it is the shareable config itself.\nWhat are the dependencies in the package.json of your shareable config?\nCan you provide a link to your repo?. > Hi! Are you familiar with npx?\n\nnpx installs them locally in temporal folder to run the command.\nNo, that's the beauty of npx, I don't need to install them in the app itself.\n\nYes I am familiar with npx and no npx doesn't necessarily install package in a temp folder or execute them globally. If you define a dependency or devDependency in your package.json and run npx from there is will execute the locally installed package, therefore package resolution will be done from there.\nCan you please confirm if you have either semantic-release or semantic-release-apps-config in dependencies or devDependencies in your project's package.json?\n\nThe ones listed in the repo\n\nJust to be sure, that means in your shareable config semantic-release-apps-config module you have a package.json and @semantic-release/release-notes-generator, @semantic-release/npm, @semantic-release/github and @semantic-release/git are defined as dependencies and not devDependencies there?. Thanks!. Actually semantic-release (at least since version 15.0.0) was never really compatible with Git < 2.0.0. But before 15.4.4 we were not explicitly checking the Git version.\nOnly a few Git commands we are using are not compatible with Git < 2.0.0, So it could give the \"impression\" that it was working but in reality it was working only under certain circumstances where those incompatible command were not called.. I don't remember exactly which command is not compatible with Git < 2.0.0, but I remember that the general case works.\nI can't guarantee there is any version fully compatible with Git < 2.0.0.\nThe problem is that there is no way to know command is supported in which version of Git below 2.0.0.\nIn the git documentation you can select the version on the top of the page to figure which command/option are available in which versions. But it never goes beyond 2.0.0.\nYou are probably better off upgrading to a more recent version as it's really and safe easy to do.\nUsing an old version semantic-release is not recommended as you will experience bugs for sure.. I don't think you have to define a specific image on Travis. We are using the default one and the git version is > 2.0.0.. I'll close this issue as it seems it's resolved.. There is a section in the README of the project: Get Help. We use Greenkeeper to keep our dependencies up to date. So we always use the latest version for each of our dependencies. GitHub also monitor vulnerabilities in dependencies. So I don't see any reason to add something on top of that.\nThe 3 vulnerabilities you are mentioning are all in npm (as we have a dependency to npm through the @semantic-release/npm plugin). I guess there is some kind of irony in the fact that the only vulnerabilities found by npm audit are its own... \nAnyway there is nothing more we can do here. I'd suggest you to open an issue with npm so they would update their vulnerable dependencies.. Yes it does. That's indicated in the first paragraph of the README:\n\nBy default semantic-release uses Angular Commit Message Conventions. The commit message format can be changed with the preset or config options of the @semantic-release/commit-analyzer and @semantic-release/release-notes-generator plugins.\n\nAny existing  conventional-commits preset can be used or you can create your own.. What do you think is missing?. I'm sorry, I read your message multiple times, but I do not understand what you are saying.\nAre you asking a question about the inner functionning of the plugin?\nOr are you reporting a problem? Is yes what do you think the doc should be then?. According to the logs you provided your commit is Merged PR 18632: fix(package.json): added publish script and fixed script name and not fix(package.json): added publish script and fixed script name therefore it's not a valid Angular convention commit and it's ignored.. It seems easier to find a way to tell Azure Devops to not do that. That seems a very strange behavior.\nIn any we won't make change to accommodate that as it's a problem with Azure Devops.\nIf it's the route you want to take anyway you'll have to implement your own conventional-changelog preset.. Again, it's probably way easier to fix the Azure thing that changes the commit message. It's probably one checkbox to uncheck somewhere.\nOtherwise you would have to develop your own version of a conventional-changelog preset. Something like conventional-changelog-angular but with your own implementation to parse the commit what your format.\nBut honestly it make no sense to do that. You should look the Azure thing documentation and figure out why it changes your commits.. env-ci is used to determine the current branch even with --no-ci. It shouldn't fails.\nPlease provide more details to figure out why it's failing: logs, details about your environment, why the property file is missing?, in which file the JSON is invalid? etc.... @fwal do you think you can provide those informations?\nIt seems the problem is specific to your environment. Without those information we can't fix anything and we'll have to close this issue.. Closing as no answer was provided. The @semantic-release/npm plugin runs npm version to increase the version in the package.json but you have overwritten that script here. So this is what ends up running instead of the actual npm version and it fails apparently.\nDon't override default npm scripts.\nIt seems you want to generate a changelog file and push it to Git? Then use the plugins @semantic-release/git and @semantic-release/changelog.\n. semantic-release embed conventional-changelog to parse the commits and generate the changelog. I guess their recommendation applies when you the conventional-changelog CLI in standalone.\nYou should just remove that version script and use the 2 plugins I mentioned.. As @bddckr mentioned this workflow is supported in the version 16.0.0-beta.\nYou can refer to the documentation on the beta branch: https://github.com/semantic-release/semantic-release/blob/beta/docs/usage/workflow-configuration.md\nFeel free to try it out and give us feedback in #563 or open another issue if you encounter a problem.. How did you create your 1.19.x branch?\nIt seems it includes all the commits made after the last 1.19.x release. You should create a maintenance branch from the tag corresponding to the lasted version of the range you want to maintain.\nFor example if you have made the releases 1.19.1, 1.19.2 and 2.0.0, you should create your 1.19.x branch from the tag 1.19.2.. It should be fixed in 16.0.0-beta.10. Let us know if that fixed it.\nPlease re-open this issue if not.. Yes the contradicting messages are a problem indeed. The No git tag version found on branch 1.19.x should not be displayed here.\nEarlier it found the v1.9.1 and v1.9.0 tags on the branch 1.9.x but not anymore. Any idea why?\nCan you run the commands git merge-base --is-ancestor v1.9.1 1.19.x and provide the exit code of this command? You can display the last command exit code with echo $?.. > i always get the erors..\nWhich one? The one where v1.9.1 and v1.9.0 are not found or the one or EINVALIDMAINTENANCEMERGE The release 1.0.0 on branch 1.19.x? . Also as you testing, can you run semantic-release with the --debug option? That'd be useful to get more info.. Can you try again with 16.0.0-beta.11? . > I create a branch and if i leave the version at 1.21.0 in package.json then no bump happens... in fact it errors out as above... Even with the conventional commit.\nSo if you look closely at the logs the message is Adding version 1.21.0 to npm registry on dist-tag release-1.21.x. So semantic-release doesn't try to publish a the new release 1.21.0, it just makes the existing release 1.21.0 available on the 1.21.x dist-tag with the command npm dist-tag add <your_package@1.21.0> @release-1.21.x.\nThat's the expected behavior because we make the existing version on that branch available on the corresponding dist-tag. The registry should accept that.\nSo I'm wondering if that's an issue with your registry that somehow doesn't accept the command npm dist-tag add <your_package@1.21.0> @release-1.21.x.\nWhat registry do you use (Artifactory? something else?). Which version?\nCan provide the full error message from the registry from https://github.com/semantic-release/semantic-release/issues/1038#issuecomment-448052485? It seems it was truncated.\nCan you try to manually run npm dist-tag add <your_package@1.21.0> @release-1.21.x?\n. I'm guessing that's the problem: https://issues.sonatype.org/browse/NEXUS-9862. Because creating a new version will trigger npm publish --tag <tag_name> that will work with nexus, even though the tag will be ignored.\nWhat's fails is making an existing version available on a different dist-tag with npm dist-tag add .... which is not supported by Nexus according to https://issues.sonatype.org/browse/NEXUS-9862.\nThe fact your registry doesn't support make this workflow impossible unfortunately. It's entirely based on dist-tag, so when you release a new version from 1.21.x you want it to be available only on a specific dist-tag so only your users specifying this dist-tag will get that version, and not the ones using the default dist-tag.\nSo I'm afraid there is nothing that can be done until Nexus supports dist-tags other than moving to a better registry. Artifactory is a common solution for private registry, but I never really used it myself.. The problem doesn't happens when the dist-tag is created but when an existing version is added to a dist tag (that already exists or not).\nAdding to a dist-tag happens when a version was released on a branch associated with a distribution channel (generic term for dist-tag) and the associated code gets merged into another branch configured with another distribution channel.\nThis is an important feature because without it your releases are stuck on the channel on which they were released in the first place.\nYou can read about an example that uses dist-tag here: https://github.com/semantic-release/semantic-release/blob/beta/docs/recipes/distribution-channels.md.\nIf you disable the addChannel step, and release a version from next on the dist-tag @next your user installing with npm install my-package@next will get i, but not the one installing with npm install my-package which is the whole point.\nHowever when you decide you code on next is well tested and ready to be distributed to everyone and you merge next into master, you want semantic-release to call addChannel so this version released on @next will now be available to users installing with npm install my-package.\nIf you disable addChannel or if your registry doesn't support dist-tag, then the versions released on @next will never be made available to your global user base. Users installing with npm install my-package will never get it.\nThat would defeat the main purpose of the features in semantic-release@16.0.0 which is to support the workflow described in https://github.com/semantic-release/semantic-release/blob/beta/docs/recipes/distribution-channels.md. So we would not accept a PR making that optional.\nNow, you can disable addChannel, at your own risk, by simply setting the property addChannel to false in the semantic-release config. But I would advice against that as you will end up releasing versions that you will never manage to make available to all users. I would instead recommends to move to a registry that support dist-tags.. Do you have a publishConfig property in your package.json?\n@semantic-release/npm calls npm publish specifying the --tag argument, however it seems npm give priority to what's configured in publishConfig rather than in the --tag argument.. Was there an npm output after the line Publishing version 2.1.0-rc.4 to npm registry in the logs?\nI'm trying to figure out what option were passed to the npm publish command.\nIf you do npm view <your_package_name> dist-tags.beta what do you get?. So you can call semantic-release with --debug that would give you more info.\nI just added the dist-tag passed to the npm CLI to the logs in the latest beta: https://github.com/semantic-release/npm/pull/129/files\n\nI am able to publish manually to the @beta tag on our registry via the npm cli without issue - although currently nothing is published with that tag.\n\nCan you confirm that you are using npm publish --tag beta in this test?\nAlso, how do you check if that was publish on the @beta tag or not?\nI wonder if it's related to your registry, because we published a bunch of beta version on @beta recently (https://github.com/semantic-release/semantic-release/releases, https://github.com/semantic-release/npm/releases, https://github.com/semantic-release/github/releases).. Thanks for letting us know!\nBtw, now that we support the plugins option the gitlab-config is not that useful anymore.\nIt just contains that:\njs\n{\n  plugins: [\n    '@semantic-release/commit-analyzer',\n    '@semantic-release/release-notes-generator',\n    '@semantic-release/npm',\n    '@semantic-release/gitlab'\n  ]\n}\nSo you can drop it and just configure that in your semantic-release config if you prefer.. The only explanation I can think of it that your environment variable are not set.\nWhen is the error happening? Can provide your CI logs?. That is supported in the version 16.0.0-beta. You can install it with npm install semantic-release@16.0.0-beta and you can find the corresponding doc on the beta.. @meebix please see the documentation I linked in my previous comment. It's an (purposely) undocumented option for configuring plugins. The recommended way to configure plugins is to use the plugins option as described in the plugins documentation.\nHowever you can override each plugin step individually.\nFor example the following config will use all the steps of @semantic-release/commit-analyzer, @semantic-release/commit-analyzer, @semantic-release/release-notes-generator and @semantic-release/npm but skip the addChannel step:\njson\n{\n  \"plugins\": [\n    \"@semantic-release/commit-analyzer\",\n    \"@semantic-release/release-notes-generator\",\n    \"@semantic-release/npm\"\n  ],\n  \"addChannel\": false\n}\n. It seems the user associated with the token you are using is not allowed to push to your remote repository. Easier you simply didn't allow that user to push or it might be related to the GitLab limitation described in https://github.com/semantic-release/gitlab/issues/19.\nRegarding Git LFS, it seems related to your CI. semantic-release needs to run git commands such as git push. If those command doesn't work on your CI, semantic-release will error out.\nI don't know the specifics of your CI and your repo, so I can't help much... According to the error message you have a Git hook that require Git LFS and its not installed on your CI.\n. Closing due to lack of follow up.. See https://github.com/semantic-release/semantic-release/blob/master/docs/usage/configuration.md#existing-version-tags. When you want to ask questions or ask for help please use the Spectrum community as mentioned in Using the issue tracker.\nPlease also read take a look at the documentation as well as the plugins documentation.\nYou can find the answer to your question reagarding the package.json not being committed to GitHub in the first example of the @semantic-release/git example.\nYour compiled file are not included in the published package simply because you are not running your build script on your CI, so those file do not exist when semantic-release publishes your package.. Please the note in https://github.com/semantic-release/semantic-release/blob/master/docs/usage/configuration.md#debug. Duplicate of #1019. Closing a per @travi answer.\nWe won't change that behavior as we now support pre-releases(in version 16.0.0-beta).. semantic-release determines the current branch based on environment variables provided by the CI we support. If it's running on an unsupported CI we try to determine the current branch with git rev-parse --abbrev-ref HEAD.\nIt seems in the case of you CI (which is not one we officially support) this Git command fails.\nUnfortunately, there is nothing we can do if your CI doesn't allow us to determine the current branch on which the build is running.\nIf you can provide some Netlify that explain which environment variables are available in order to determine the branch being built we can look at supporting it.\n. We might support Netlify CI at some point but It's not really a priority.\nI would recommend to use a real CI and to customize the message option to include skip travis or skip circleci instead of skip ci.. Let's wait for marked-terminal peerDependency to be updated.. In which file do you set the semantic-release configuration?\nCan you provide the semantic-release logs?\nIf you use package.json then all the config should be under the key release. If you a releaserc file it should not be under the key release but directly at the root of the JSON file.\nMay I ask what is the point appending the new version number to a VERSION.txt file? What are you trying to achieve? Don't you prefer to have a proper CHANGELOG.md with an entry for each version along with the list of commits?. Thanks for the clarification. I would configure the following in .releaserc then:\n{\n    \"plugins\": [\n        \"@semantic-release/commit-analyzer\",\n        \"@semantic-release/release-notes-generator\",\n        [\"@semantic-release/exec\", {\n           \"prepareCmd\": \"echo ${nextRelease.version} > VERSION.txt ${nextRelease.version}\"\n         }],\n        \"@semantic-release/git\",\n        \"@semantic-release/github\",\n    ]\n}\n. Closing as solution was provided by @bddckr . Closing as answer was provided by @bddckrv !. @Berkmann18 what do you mean?. I'm guessing it's because the tag v1.0.0-alpha.1@alpha is not in the history of the branch alpha. I don't know how it happened, you might have rebased the commit associated with that tag.\nYou can verify if the commit associated with that tag is in the history of a branch with git merge-base --is-ancestor v1.0.0-alpha.1@alpha alpha.\nThis is the exit code of this command that will tell if the commit in the branch history or not. You can display the exit code of the last command with echo $?. If it's different than 0 it means the commit referenced by the tag v1.0.0-alpha.1@alpha is not in alpha history. Probably the commit referenced by the tag doesn't exist anymore if it was rewritten with a rebase or cherry-pick.. What CI are you using?\nCan you provide the logs from the run where the undefined branch was pushed?. I need the full from when the undefined branch was created. The release tag_name: undefined is a problem in the debug message only. The value passed to GitHub is not undefined. Fixed in https://github.com/semantic-release/github/pull/149.\nFrom the logs you provided, everything seems to work as expected and semantic-release properly see the branch as alpha and not undefined.\nIn order to create the tag semantic-release do the following:\n- git rev-parse HEAD to determine the sha of the head commit on the current local branch\n- git tag 1.0.0-alpha.1@alpha <sha_of_head_commit>\n- git push --tags <repository_url>\nEither for some mysterious reasons those commands on TeamCity ends up creating an undefined branch on the remote repo. Or this undefined branch is not related to semantic-release.\nEverything is those logs indicate the notes generated have contents. So maybe your undefined branch with empty CHANGELOG is not related to semantic-release, or at least not to the run for which you provided logs.\n. Unfortunately that's no so simple as we can't assume the current configuration in the .travis.yml. Many jobs could already exists for example.\nIn the large majority of cases you can just replace your .travis.yml by what's in the documentation linked. But if we provide a step by step doc that will create problems for some users with a different configuration.\nGenerally, speaking you have to understand how your CI configuration work and how to split and orchestrate your jobs, because each project is different. You might want to run 2 test jobs each running half of your tests to speed up the build, or you might want to run a different test command based on the Node version or the platform etc... We could add docs in this project explaining all that, but it will never be as good and as complete as the docs of each CI provider. \nWe used to have a more detailed and opinionated CI configuration documentation in the past. It only generated a lot of noise on the issue tracker with people either giving their opinion about CI best practices or having issues due to something specific in their project. \nSo we provide examples and we clearly state that semantic-release should run after all your tests. But that's up to you to figure out what's the best solution for your project. At some point we might rework the setup CLI to be smarter and try to guess the best configuration, but I don't know if the effort is worth the benefits.\n. Thanks. This feature has been discussed in length in #585 and cannot be currently implemented without several drawbacks.\nThe TL;DR is that CIs do not provide secret environment variables for PRs originating from a forked repo for security reasons. So with those PRs we don't have the GitHub token to add comments or do anything. And we can't run any plugin that require a token.\nThe solution would be to use a GitHub app, but on a GitHub app you cannot run custom code for security reasons so you can't allow plugins.. Duplicate of  #585. That's because you are using the eslint for @semantic-release/commit-analyzer but the default one for @semantic-release/release-notes-generator.\nYou should use the same preset for both.. It seems works sometime because the angular release note generator can sometime parse the eslint formatted commits and make something out of it.. As mentioned in the docs gitlabTargetBranch require the gitlab-plugin.\nAccording to the Jenkins documentation the variable GIT_BRANCH should be set. I don't know why it's not set in your case. Likely an issue with your version/environment/configuration.\nI would recommend to use gitlab-plugin so semantic-release can detect PR builds.. What is the API endpoint on your instance? Did you configure the GL_PREFIX variable accordingly?. What does curl --header \"X-Private-Token: ${GH_TOKEN}\" https://gitlab.mycompany.com/api/v4/projects/mygroup/myrepo returns?\nThe plugin does exactly that and that returns a 404 saying mygroup/myrepo doesn't exists.. What does trigger the CircleCI build, pushing to the PR branch or merging to master? On which branch CircleCI is running?\nIf the job was triggered by the merge to master and the build actually run on master branch then CIRCLE_PULL_REQUEST and CIRCLE_PR_NUMBER should not be set. If they are that's an issue with CircleCI that you should report over there.. Last time I tried CircleCI those variable were set only on the merge build triggered by opening/updating the PR. After merging the PR in GitHub a regular build was triggered on master.\nCan you provide a link to the problematic CircleCI job?. I just tried to reproduce that on CircleCI and everything works as expected.\nI opened the PR https://github.com/pvdlg/playground/pull/38 which triggered the build https://circleci.com/gh/pvdlg/playground/57 where CIRCLE_PULL_REQUEST is set as expected.\nThen I merged the PR to master which triggered the build https://circleci.com/gh/pvdlg/playground/59 in which CIRCLE_PULL_REQUEST is not as expected.\nSo as far as I can tell CircleCI works as expected, and semantic-release will make a release during the build triggered on master.. Just tried the PR https://github.com/pvdlg/playground/pull/39 from a fork.\nThe job triggered by the PR is https://circleci.com/gh/pvdlg/playground/61 and the variable CIRCLE_PULL_REQUEST is set.\nMerging the PR triggered the job https://circleci.com/gh/pvdlg/playground/64 where CIRCLE_PULL_REQUEST is not set.\nSo even with a PR from a forked repo CircleCI works as expected and semantic-release would make a release from the job triggered by the merge to master.. If you do that the PR will not be built, only the merge to master will.\nTested again with \"Build forked pull requests\" set to \"off\" with PR https://github.com/pvdlg/playground/pull/40.\nSame result, the merge triggers the job https://circleci.com/gh/pvdlg/playground/67 on master and CIRCLE_PULL_REQUEST is not set.. Per our Contributing guildline please use the appropriate channels for requesting supporting.\nYou can use the plugins and just not use the @semantic-release/npm or @semantic-release/github.. > I guess I should have formulated it as a feature request. Thanks for getting back to me. I'll try to figure it out I guess.\nThe objective of having different channels to handle bugs/features and support request is to:\n- encourage other users to answers support questions\n- make the issue tracker clearer and less busy\n- make support answers easier to be found by search engines\n- encourage users to read the documentation, the FAQ and other support answers before opening an issues\n- have a clear view of what development is in progress (issue tracker + Waffle), without cluttering the issue tracker with support request\nThe objective is evidently not to force people to \"formulate\" or disguise support questions as feature request.\n. Before you spend more time on the PR, this is not something we will implement.\nAs mentioned in #753, outputting the version to be released without making a release is a feature that we are still evaluating.\nSo far the only use cases mentioned there that  are commons enough and explained in detail are supported via the pre-release feature in version 16.0.0-beta. This use case is to publish release for integration tests purpose only then once the test are successful to publish on the main release channel. This use case is detailed there: https://github.com/semantic-release/semantic-release/blob/beta/docs/recipes/pre-releases.md.\nOther comments in #753 are either:\n- of the type \"I want it because that's my workflow\" without explanation justifying why that workflow is better than the proposed alternative\n- or are not common enough to justify the implementation of the feature\nRegarding skipping the PR check this is not something we will implement as we do not want to make releases from a PRs for obvious reasons. If we fail to detect properly that a CI job has been triggered by PR, then will fix the detection. \n. Then just use the @semantic-release/exec plugin and configure the publishCmd with something like ./publish-artefact.sh ${nextRelease.version}.\nIn the puplish-artefact.sh script the first argument will be the version being published by semantic-release.\nIn that script, build your stuff, name it the way you want using the version and whatever environment variable CircleCI provide and copy it in the directory where CircleCI pick the artifacts. \n. Please see the CI configuration documentation that explicitly specify the following:\n\nThe semantic-release command must be executed only after all the tests in the CI build pass. If the build runs multiple jobs (for example to test on multiple Operating Systems or Node versions) the CI has to be configured to guarantee that the semantic-release command is executed only after all jobs are successful. This can be achieved with Travis Build Stages, CircleCI Workflows, Codeship Deployment Pipelines, GitLab Pipelines, Codefresh Pipelines, Wercker Workflows or GoCD Pipelines.\n\nA release must be unique, that's a basic requirement of semver, as a release with a given version must always be the same no matter when and where you download it. So a published version has to be built once and released once. This is why most package managers prevent to re-publish or unpublish a release with the same verssion. We are not going to change this behavior.. semantic-release is designed as a release tool not as a build one. It is meant to be used independently of your build tool, as a final step for releasing. This is why we determine the version only when we release, and we don't determine \"would be version\". This is by design. \nIf you want to creates multiple builds that contains the version, semantic-release is not the right tool and you should using something to manage your versioning.. We can't help you with so few details.\nI'm sure you noticed there is 3 different templates when opening an issue on this repo, and one of them is Bug Report which ask all the information we need to help.\nMay I ask if somehow you didn't see that template (maybe you opened the issue with a third-party client?)? Or if you choose to ignore it? If yes, why?\nWe have a lot of support requests and it's very time consuming to handle, especially when going back and forth, requesting additional informations. So we try to improve with issue templates and contributing guidelines. But obviously that failed in this instance...\nWe would greatly appreciate if you could give us any feedback regarding improvements to our repo such that you would have provided those information right away when you opened this issue. . Please see the @semantic-release/github options. It doesn't support the repositoryUrl option.\nrepositoryUrl is a global option as described in semantic-release options documentation and should be your repository URL.\nIf you are using a GitHub enterprise instance you have to set githubUrl.. What is your configuration now?\nWhat is the URL on which you access the GH instance?\nOn which URL is the API deployed?\nDid you test that URL to make sure the API is available?. What is the value you set for  the GITHUB_PREFIX environment variable?. GITHUB_PREFIX is just the prefix not the URL. it should be set to /api/v3. > The only current workaround for this, without stripping out repository.url, is to use a scripts entry like \"semantic-release\": \"semantic-release --repository-url ${BITBUCKET_GIT_HTTP_ORIGIN}\" to explicitly invoke the magic value for the git origin, which is obviously pretty fragile.\nWhy is it fragile? Sure, it relies on a BitBucket specific environment variable, but having this repositoryUrlFromGitOrigin option would also relies on a BitBucket specific feature (to set the local repo remote URL as the authenticated one). So I don't really see why one is more fragile than the other.\nAdding an option would also mean adding more confusion for users...and considering the number of support tickets we have, people are already pretty confused about repository URLs and authentication.. Closing has no answer was provided.. > The obvious problem here is that the deployables depend on the libraries and the libraries were not released until master so DEVELOP wasn't deploying the correct deployables because the libraries were not released.\nI don't understand what you mean there...\nIf you have a dependency between two modules you need to release the one depended upon first. But that's not related to semantic-release. So I'm guessing there is something I'm missing there...\nYou are talking about deployable and publishable but that doesn't help to understand much (other than you deploy one and publish the other I guess).\nMaybe you can give an example (maybe with a simple schema?) where you actually name things?\nMaybe something like this:\n - Project A is a private node module with a dependency to B\n - Project B is a public node module \n - I commit to branch X on project A => semantic-release do XXX\n - I commit to branch X on project B => semantic-release do XXX => The problem is XXX. The plugins option has been added in version 15.10.0. You are using version 15.0.0. This is the code used to determine the branch on which the build is running: https://github.com/pvdlg/env-ci/blob/master/services/jenkins.js\nAccording to the Jenkins doc the environment variable GIT_BRANCH should be set with the branch that triggered the build.\nAs you can see from the code we also check GIT_LOCAL_BRANCH, gitlabBranch and BRANCH_NAME as a backup solution. GIT_BRANCH is supposed to be set but with some version of Jenkins one of the other variable is used instead.\nSo I would suggest you to investigate why none of those variables are set. It's probably an issue specific to your environment.\nI would also suggest to ask the Jenkins team if the GIT_BRANCH variable not being set is a bug or an error in the documentation. If it turns out there is yet another variable that can contain the current branch, please let us know so we can add it.\n. Adding information to a PR about what semantic-release would release if that PR were merged is something we would like to implement. However, so far there is no good solution to do so. See #585.\nAs you mentioned the problem is that you have very limited access when running in PR build, in order to prevent someone to open a PR from a forked repo and leak sensitive info.\nThat mean you will have access to the GitHub token, so you won't be able to add a comment to the PR. So it seems what you are trying to achieve will not works.\nAt best it will be limited to PR opened from the same repo (as CI would provide the token via environment variable in that case) or for public repo only (adding a comment to the PR without a token). At that point, we don't make changes to support such feature with so many limitations. If we support it we would like to have no limitation (it should work for private repo and for PR coming from a fork). The solution that comes with the least compromises seems to be a GitHub app.\n . Having PRs coming from forked repo is extremely common. This is the large majority of PRs on many open source projects.\nWe won't make changes to support commenting on PRs if we can can't do it for all PRs, including ones that come from a forked repo. That would be extremely confusing for users to have a feature that \"sometimes\" works.\nI'm gonna close this and invite you to comment further on #585 if you have a solution that would work for every cases we want to support.\n. I just tried you exact configuration and both command you mentioned works for me and the plugins load properly. So I don't know why it doesn't works for you....Maybe the npx version?\nI'm using 6.5.0. This is expected. If you semantic-release is installed globally you have to install the plugins globally as well.. The only authentication required by semantic-release core is for the git CLI as we have to push a git tag. git already support a lot of authentication method including ssh keys, keychain or password files. So what you are requesting is already possible.\nThe other authentication configuration are related to the GitHub, GitLab and npm plugins. Each one has its own specificities. For example with @semantic-release/npm you could have a .npmrc file in your home folder with the credentials.\nAs semantic-release is meant to run on a CI, I'm not sure there is really a better way than environment variables. Having a file containing your credentials on the CI is effectively the same as having environment variable. Keychain is probably not available on the CI (or at least it would be empty).\nCan you provide a detailed use case that is not currently possible and explain why it would be better than environment variables?\n. > Assuming a single token is very much the model of Travis (and maybe Circle, etc), however I'm currently working on implementing this in Jenkins, with a rather custom setup. We already have the credentials available in ~/.config/hub that we use for other purposes, and there's restrictions on what we can put in env vars. From the access perspective, a publicly accessible file is in effect the same as an env var, but on the other hand, you can't accidentally leak the token by running env or console.log(process.env) while debugging something unrelated.\nInability of setting an environment variable and using a file to store credentials seems to be a very specific use case and it doesn't seems it would benefit any other user. So I would suggest to implement your own fork of @semantic-release/github or to run a script that read the file and set the environment variable.\nLeaking the credentials with env or console.log(process.env) is generally not an issue because most CIs do not provide the environment variable when building a PR coming from a fork repo. So if someone fork your repo, add console.log(process.env) to the code and open a PR, the credential won't leak ass the won't be available.\nAlso debugging things is usually done locally not on the CI.\n\nThe other example I gave is vault. While at run time, as part of a CI job, the token is easily accessible, it generally rests in a controlled, encrypted environment. In certain environments this is important.\n\nI'm not familiar with what vault is. It seems a quite specific use case, so again I'd suggest to run your own fork of @semantic-release/github for that.\n\nWhile keychain is debatable (as this is meant for CI), it would be extremely handy when you're trying to debug or try out things locally (--dry-run, etc). This would be primarily a usability feature. I work daily with public GitHub and with GitHub Enterprise. They naturally have a different token, therefore a single GH_TOKEN env var does not suit me - I'd have to switch it every time I change repos.\n\nThere is several issues with such approach. First, how do add the token to the keychain in the first place? That would require semantic-release to ask the user for the token if not found in the keychain. Which is a problem when running on a CI. There is certainly way to workaround that, but that's a lot of complexity added to semantic-release for few benefits.\nSecond, the keychain (at least on OSX and Windows) allow access based on process name. So if you add a token to the keychain with any Node app, any other Node app can access it, which is a big security issue. See https://github.com/atom/node-keytar/issues/88\nIf you want to test locally with different tokens I would suggest to either:\n- Use https://direnv.net/ so you can have a different token for each directory automatically set\n- Just run the command GH_TOKEN=XXXX semantic-release --dry-run. > I would expect that if the git url doesn't match the package.json repo url, then either:\n\n\nWe surface an error that is clearly saying \"EURLMISMATCH\" or something\nWe assume the git url is correct from git and use that one, then create an issue on the repo saying \"package.json url doesn't match git url, please update\"\n\n\nThere is valid scenario where the remote URL of the local repo on the CI and the repository URL in the package.json. For example if the CI set the URL with http but you want to use a https or ssh URL.\nIn addition, each CI do they own stuff regarding the remote they set in the cloned repo, so we can't rely on that. This is why we favor the repository URL configured by the user over the one set by the CI.\nManually configuring the repository URL is by far a more common use case than moving the repo and forgetting to change the URL in the package.json. So we'll keep things as is and continue to allow user to configure the repository URL and override the one set by the CI.\n. semantic-release need to push tags to your git repo and uses the git CLI for that (git tag vx.y.z then git push --tags). Those command need to works for semantic-release being able to make the release.\nI don't know why you get this error on CircleCI but there is not much we can do on semantic-release side. You can run semantic-release with --debug to have more detail about the git command that is ran.\nIt's probably related to the container you are using to run your CI job that somehow can't verify the authenticity of the github.com certificate.. Closing as answered in https://github.com/semantic-release/semantic-release/issues/1096#issuecomment-462103512. Already implemented in v16.0.0\n. > The problem here is that if master has no other release in yet then the only version that can be deployed from the maintenance 1.8 is between 1.8 and 1.8. This is due to no other release being available in master - master latest is 1.8.\nIs there some way of changing this behaviour?\nThis is by design. Why would create a 1.8.x branch such case? If the last version released from master is 1.8.0 and you want to apply a fix on 1.8.0 then push that fix to master.\n\nLet's assume that master has 1.9 now, so technically the release allows me to apply fixes on top of the 1.8.x branch now.... up until 1.9.0 - so hence I have a possibility of 8 fixes in the maintenance branch (from 1.8.1 to 1.8.9).\nI was wondering what other peoples strategy is here ?\n\nThat's not accurate. Semantic version are not limited to a single digit. If you would push 500 fixes sequentially you would end up with version 1.8.500.\n\nIf we plan on releasing version tag 1.8 to production then QA needs to test this version in the QA environment but they might find issues so my understanding is that if they do then i must release maintenance fixes (updating the patch) on top of 1.8.\n\nOnly if you released version 1.9 in the meantime. If not apply your fix on master.\nAlso if you are making non-production ready releases for QA purpose you should use pre-releases: https://github.com/semantic-release/semantic-release/blob/beta/docs/recipes/pre-releases.md. This is by design. If you were to allow to release from different branches with the same prerelease id you could en up with conflict:\n- Create a rc-5 and a rc-6 branch from master (the last release is 1.0.0)\n- Push a feat to rc-5 => release 1.1.0-rc.1\n- Push a feat to rc-6 => release 1.1.0-rc.1 => npm error as you try to release the same version twice\n. If we don't enforce that I don't think there is a scenario that doesn't create conflict or inconsistencies.\nThe name conflict is just an example of one problem that can happens.\nA situation were you release 1.1.0-rc.1 then 2.0.0-rc.1 but 2.0.0-rc.1 doesn't contains all the commit included in 1.1.0-rc.1 is problematic.\n. I don't really any use case common enough to allow releasing from multiple branches on the same prerelease id.\nI think I explained with a lot of details why it would be either impossible or at best extremely complex to implement.\nSo we'll keep the restriction in place for the reasons I explained above.. Tags are the only state semantic-release can maintain between releases.\nAn important feature for us is to be able to move releases from a channel to another when the corresponding code is merged from one branch to another. For example if 2.0.0 is released on @next when the corresponding code is merged to master we want to automatically add 2.0.0 to @latest.\nIn order to do that semantic-release need to know on which channel a given release has been made available. This is why we have to add the @channel to the tag name. So if v2.0.0@next exist but v2.0.0 doesn't, then it means 2.0.0 is available on @next, it has been merged to master but has not yet been made available on @latest.\nWithout adding the @channel this feature could be only be possible with an external database maintaining a state of all the release for all repos. That would be obviously way more constraining.\nRegarding the proposed options.\n\n\nWhen tagging vX.Y.Z-rc.N@channel, also add a tag at the same place for vX.Y.Z-rc.N (in fact, this is what I think I'll do as a stopgap). Possibly even make the channel-less version the release (i.e. keep the tag@channel for reference)\n\n\nThat is not possible because we wouldn't be able to determine if the code associated with vX.Y.Z-rc.N was merged to master or not\n\n\nAllow an explicit channel: \"\" / channel: false. This would mean that when filtering tags in get-last-release.js, the branch.channel === tag.channel needs to account for branch.channel === '' && isNil(tag.channel). This is a little ugly - I do think that allowing channel-less pre-releases by default is probably better. Alternatively, the \"\" or false could be normalized into undefined.\n\n\nThat is not possible because the absence of a channel is used for the default one (master branch / @latest dist-tag)\n\n\nAllow a custom extension point for plugins to categorize tags into channels or to override the last/next release version/tag.\n\n\nExternalizing that to a plugin would not change the fact that you need to maintain a state between releases and the only reasonable way to do that is tag naming.\n. The scenario we want to support is:\n1. Push a commit to master => release version 1.0.0 on @latest\n2. Create branch next from master\n3. Push a commit to next => release version 1.1.0 on @next\n4. Merge next into master => add release 1.1.0 to the @latest channel\nHow would you do the step 4 if you don't have the channel in the tag name?\nPlease describe the algorithm and the git command to run. As far as I can tell it's not possible.. Pre-release or not doesn't change the problem. We want to use that workflow between any branches.\nWe can't use npm view to figure out what's released were because we support any projects, including non Javascript ones and ones that doesn't release on npm.\nThis is why we support npm via plugin, as it's optional.. The goal is to support any release target via plugins. Some might support channel, some other don't. Some might provide a way to find the channels on which a version is available. We can't assume anything regarding the target as we want to be generic enough to support anything.. I tried this recently on Travis and it worked as expected. Also the nvm documentation indicate this is a valid command: https://github.com/creationix/nvm#long-term-support\nMaybe this error happened for another reason? Can you try again? . The parsing of the commit is done with conventional-changelog which follows the Angular convention closely and require a BREAKING CHANGE to have a descriptions explained by @Nargonath.. The documentation is incorrect. The skipped steps are prepare, publish, success and fail.\nPR updating the doc are welcomed.. The prepare step can make persistent modification such as pushing a commit with the modified package.json.\nThis use case is actually the main reason for the prepare step to exist. Some package managers such as APM require to have an updated version of the package.json in the repo and a tag created before publishing to the Atom registry.\nWe have to exclude the prepare step in dry-run because we do not want to commit to the remote repo in a dry-run.. That seems to be a quite rare edge case. It would happens only if you merge two commit rapidly and the second one skip the CI.\nThe problem is that the commit where you skip the CI, might still warrant a release. You commit could be feat: something [skip CI].\nHandling 100% of those edge cases would be extremely complex and I don't think it would bring much value.\nIn your case you have multiple solution:\n- Run a job from the last commit on master\n- Wait for pushing another commit which will trigger a new CI run so semantic-release can make the release\n- Do not use [skip CI] in the first place\n. You can use a GPG key to sign your commits. If you use the @semantic-release/git plugin to push a release commit you can https://github.com/semantic-release/git#gpg-signature.\nWhat value does signing the tag itself (in addition of the commits) would provide?\nIs there a use for it?\nI quite reluctant adding yet another option...That create more complexity, more maintenance and more confusion for users.... If you want to sign your commit locally it's even more simple. A simple Google search will give you a lot of results. For example: https://git-scm.com/book/en/v2/Git-Tools-Signing-Your-Work\nI understand the \"additional layer of authenticity\" argument. However if you don't even sign your commit, I don't really understand the need to sign the tags. Start by configuring your environment to sign your commits.\nI don't think signing tags is a feature important enough to justify the addition of a new option. Especially considering you can already sign commits.\nMaybe you can find a way to configure Git to always sign tags: https://stackoverflow.com/a/50647394/2238351\n. The changelog is generated by conventional-changelog so I would suggest to open an issue over there.. Yes I'll close it as there is nothing we can do here unfortunately.. Thanks!. In you reproduction steps you say the release works fine then you get Receive error Error: Failed to replace env in config: ${NPM_TOKEN}.\nWhat command gave you the error? What's the problem exactly if the release works?\nsemantic-release is primarily meant to be used on a CI and adds the NPM_TOKEN from an environment variable to the .npmrc to be able to make releases. There is no other way to authenticate with npm, we can't change that.\n. Closing in favor of https://github.com/semantic-release/npm/issues/145. It's a ReferenceError meaning that you refer to a JavaScript variable named mode that doesn't exists. It's not related to any semantic-release option.\nIt seems it comes from your .releaserc.js.. Can you run semantic-release with the --debug option and provide the logs?\nCan you also provide the output of git branch -a?. The command that fails is git ls-remote --heads origin. This command shouldn't require any authentication as it's just reading from your repo...\nI don't understand how Azure was able to clone your repo at the beginning of the build process, but it's not able to read it later on....\nThat seems to be a problem specific to Azure. If you investigate a bit more and figure out why Azure loose read access to your repo, maybe we can find a workaround.. The @semantic-release/github interact with the GitHub via API. The GitHub API is a REST API accessible over https. The plugin uses the URL configured via githubUrl and githubApiPathPrefix.\nIf your server is not accessible via https then you can't use the API and therefore can't use @semantic-release/github. There is no way around that, you need to able to access the API to use it.\n. What is SM?\nsemantic-release uses the git CLI because not everyone uses GitHub. The git CLI is the most common way to access a git repo, including ones that doesn't provide an alternative API.\nThe releases on this GitHub repo are publish with semantic-release, so you can see that GitHub repositories are accessible via the git CLI.\nAccording to the error message you have, it seems you have explicitly disabled remote operation authenticated via password. So obviously semantic-release won't work.. Closing as we won't make this change for the reasons explained above.\nThe workflow discussed here will be supported with version 16.. Duplicate of #1107. This is an issue with conventional-changelog which is one of our dependency. It will have to be fixed there.\nThere is nothing we can do here other than replacing/rewriting conventional-changelog which we won't do at this point.. Should you test that the custom tag has been created ?\nBecause defaultReleasetag_name is: 'v1.0.0' which is not the custom tag. So if the code works and actuallt create a custom tag, this test would fail.. What is the purpose of this section of code?\nIt seems outside of the scope of this PR (which is to customize git tag based on release tag)?\nIt might be a good candidate for another PR. Even though we would have to think about the consequences of deleting tags. Maybe the user has other tags, maybe there is other things relying on this tag etc...So it's probably safer to log the error and explain the user what to do rather than taking the risk of deleting something the user might care about.. Yes in order to reuse the stdout variable.\nSee https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Assignment_without_declaration\nI could also use different variables.. What do you mean 'they're just invisible' ?\nIf they are not committed to the repo, they are not in the repo.. Also I added npmrc and .yarnrc to not regenerate them.. The point of removing the lockfiles is to do the development with latest versions of dependencies. Your solution (unless I'm missing something) just remove the lockfiles before commit even though they wouldn't be committed anyway due to gitignore.\nThat doesn't solve the problem as the lockfile will be present on the local machine until the contributor do a commit. So a contributor would do all the development and run the test locally with potentially outdated libraries. Therefore what worked on their local machines might not work on the CI.\nAlso adding 2 extra dependency + a commit hook seem more overkill to me than two one line dotfiles.. We had this discussion about commit hook previously among maintainer and we've decided to not use commit hook for simplicity. Also that could create confusion for contributors to see their code automatically changed on commit.\nThe chosen solution is to enforce the formating with eslint (with eslint-plugin-prettier).\nAll the code format pushed is validated in CI with eslint to be sure it's formatted with prettier.\nThis comment is not really about style but more about a not well know javascript feature allowing to reassign let variables with destructuring.. No because prettier config is read by editor tools and by the prettier command itself.\nActually it work the other way around, it's eslint-plugin-prettier that read the prettier config. See prettier/eslint-plugin-prettier#55. I'm thinking of doing a bit more refactoring in other PR actually. Mostly modularize a bit and splitting thing in different function.\nThat would make the code clearer, allow us to write more docs in the form of jsdoc.\nAlso that would simplify a lot the situation like were have to reuse variable.\nMost of the case I do that is due to try / catch to avoid having all the code depending the throwing function be part of the try block.\nWith more modularization, each function that throws could handle it's errors (ie process the error and rethrow a SemanticRealseError) so in the parent module that calls them we could have only one try catch block.\n. Not really because eslint will run on npm run test. So a contributor would figure that out before committing.\nSure we could run npm run test on each commit or something like that but:\n- Most contributor would know they have to at least run unit test before commiting\n- For some less experienced contributors, we prefer answer them in the PR and help them as we believe guidance from a human would be more pleasant and helpful than an error message on commit\nAnd there wouldn't be any style discussion, the style is enforced by eslint + prettier. There would be just explanation on how to read the eslint error, how to format properly, and maybe suggestion to use tools etc...Anything helpful for the contributor.. Prettier config in prettier property, Eslint config in eslintConfig property seems more clear to me. Not sure what would be the point of moving it around.\nBut thanks for the feedback :). Isn't the github API would already throw an error when you create a tag that already exist?. What I mean is:\n- We probably don't want to delete tags. We have no way to check if the original tag is intentional or not. We don't want to take any destructive action without user consent.\n- If the objective is to test if the tag exist before creating it, the \"create tag\" API call is already doing that.. release.prerelease is redefined several time which complexify the code. It's probably better to do the computation to determine githubPreRelease before crating release.. There is no reasons to change release from const to let as it's not reassigned.. You could use Shorhand Property Names here to simplify and stay consistent.. The tests in post.test.js are fairly complex (use nock, call a bunch of submodules etc), so it would probably better to externalize the determination of the prerelease value to a sub-module in src/lib. You have seral example there.\nThis way you could create a test file dedicated to this sub-module that would be simpler and more focused. This way you would test there all the details regarding the determination of prerelease (default parameters, parameter with a value, dist-tag with value x, y, z etc) and in post.test.js you would just need one test that will only validate that whatever value returned by the sub-module is properly sent to gihub and that post.js pass the correct parameter to the sub-module.. The tag can also be in the .npmrc config.\nIt actually already determined in src/index.js#L54 and passed to post.js in config.npm.tag so you should reuse that.. As determined in src/index.js#L54 config.npm.tag cannot be null;. You could use Object destructuring to get the value of pkg.release in src/post.js#L8 like it's done for other input params.. You can use includes() here.. Yes :) I think made a review comment in that direction.. Maybe I'm missing, but what difference does it make if the user explicitly set the dist-tag as latest in publishConfig or in the code in index.js set it as it's default value of latest ?\nIf it's latest then no Github pre-release, independently of how it was set isn't it?. I might have express myself in a confusing way, sorry.\nThe algorithm I think should be something along those line:\n- if dist-tag (default or not) is latest or in no-prerelease property => no pre-release\n- Otherwise => pre-release. I was thinking something like: const {pkg: {release} = {}, options: {branch, debug, githubUrl, githubToken, githubApiPathPrefix}, plugins} = config;\nBut actually, I just realized pkg is used somewhere else so nevermind. . console.log would print to the console when you run the tests.\nYou can run ava -v --watch so each test of source file you modify will immediately run so that make it easier.\nYou can also temporarily add only to your test (for example test.only('test title' ... ) or test.serial.only('test title' ... )), so only this test will run.\nYou can find more info on Ava here https://github.com/avajs/ava. You forgot to remove the only here.. You could do directly:\njs\nmodule.exports =({pkg: {release = {}}, npm: {tag}}) => {\nAnd remove const {pkg: {release = {}}, npm: {tag}} = config;. It's a small detail, but for readability and consistency, could you format the objects with few properties on one line? In other places as well?. Can you rename expectPreRelease into prerelease ?\nIt's an expected value there but it's the \"obtain\" value here, in the sense it's what the github API client sent. So better to call it just prerelease.. I'm afraid that a pre-release won't happen might give the idea that the release will not be done.\nMaybe something as follow instead ?\nno-pre-release: By default, releases on an npm dist-tag other than latest will produce a Github release with the pre-release tag. You can add any dist-tag in the no-pre-release array in order to produce a regular (non pre-release) on Github for those dist-tag.\n. The use case is to force a regular release on Github, even if the release is done on a dist-tag other than latest.\nBasically when you release on v2 but you still want the release on Github to not be tagged pre-release.\nMight be useful when you release on a legacy/LTS/old version dist-tag.\n. I think the prerelease is not on camel case so the variable can be used as a short and in const release.\nrelease is passed to the Github API which expect prerelease not preRelease. See https://developer.github.com/v3/repos/releases/#create-a-release. > We don't really support LTS releases yet, do we?\nKind of. You can have a branch configured to release on the dist-tag lts for example. In that case you might not want the prerelease tag.\nBut yes in order to support it properly  we would need a to implement a verification to make sure we don't release something out of bound.\nSo I guess when we do that, we would have everything necessary to figure out it a LTS branch therefore the prerelease tag should be false.\nIn that case yes it makes the no-pre-release param useless.\nKind of feel bad that I asked @Apidcloud to add it.... Ok make sense \ud83d\udc4d. Done!. It wasn't intentional. It's fixed.. It is logged here: https://github.com/semantic-release/semantic-release/blob/caribou/src/cli.js#L56\nIn addition it's tested there: https://github.com/semantic-release/semantic-release/blob/caribou/test/integration.test.js#L618. Could you clarify what do you mean by \"a different version of @semantic-release/error\" ?\nThe idea here is that throwing a @semantic-release/error will stop the process and exit gracefully without an error.\nWhile throwing any other error is considered and actual problem that prevent semantic-release to work and will result in logging the error with a stack trace and exiting with 1.. I checked that arg.stack logs the error type and the stacktrace. Can you confirm it won't log any other parameters?\nThis log is useful for debugging purpose. Is there a scenario in which the stacktrace is not enough to find where the problem happen and reproduce?\nFor example is the case of child_process.exec() with the stacktrace you could find the line in the source that caused the error and see the command executed there.\nOn a side note a plugin can also catch its own errors and log them before re-throwing them to semantic-release.. Yes indeed. I didn't think about this case.\nI realize there is a problem in the definition of @semantic-release/error as the name is not set properly.\n```js\nconst SemanticReleaseError = require('@semantic-release/error');\nconst err = new SemanticReleaseError('message', 'CODE');\nconsole.log(err.name);\n// Error\n``\nIdeally we need to fix that and useerr.name` in this test.. Ok make sense. I'll fix it shortly. Thanks for the feedback !. The error itself will be printed with https://github.com/semantic-release/semantic-release/blob/include-eror-props/src/lib/logger.js#L15\nThe output will be:\n[Semantic release]: An error occurred while running semantic-release: Error: error message\n{ Error: error message\n    at module.exports (/Users/vanduynslager/git/semantic-release/test/fixtures/plugin-error-a.js:2:17)\n    at bound  (internal/util.js:227:26)\n    at /Users/vanduynslager/git/semantic-release/src/lib/plugins.js:22:58\n    at <anonymous> errorProperty: 'errorProperty' }\nThe %s is used to print [Semantic release]: An error occurred while running semantic-release: Error: error message. The function logger.error can be used to print anything, not only Error objects. So it has to work with string formatting and handled multiple parameters.\nThe function format the the parameters and print them in red, and in addition if there is errors among the parameters it will print them completely.\nSo the error message will appear in the formatted string and the complete error (with message, stacktrace and properties) will be logged after.. I made the change, the message shouldn't be logged twice anymore\n. I made some changes. The Object will now be logged properly.\nBoth log and error support the following now:\n- logger.log(obj)\n- logger.log('Something %O something else', obj)\n- logger.log('Something %s something else','some string')\n- logger.log('Something %s something else %O','some string', obj)\n. That's expected I think.\nconsole.log('an error occured: ', err) will log err as an object (with stacktrace etc)\nconsole.log('an error occured: %s', err) will log only the equivalent of err.toString()\nIf a user use %s in their format it means they want to be logged a string.\nCan you give me an example that won't work as expected ?. js\nlogger.log('this is an object', {a: 'a'});\n// [Semantic release]: this is an object { a: 'a' }\n```js\nconst error = new Error('err message');\nerror.property = 'propValue';\nlogger.error('this is an error', error);\n//[Semantic release]: this is an error { Error: err message\n//    at module.exports (/Users/vanduynslager/git/semantic-release/src/cli.js:57:21)\n//    at  property: 'propValue' }\n```\nIsn't it the expected output?. > also here's one idea: why not simply wrap all format sequences with chalk? I.e.\nThat seems a good idea. Let me investigate a bit more (tomorrow though).. Yes that's a problem indeed. Maybe the safe side solution is if (err.name === 'SemanticReleaseError' || err instanceof SemanticReleaseError) {.\n@felixfbecker what do you think?. Thinking about it best solution might be to set a property in the SemanticReleaseError that indicate it's a semantic-release error. This way it would work with inheritance and wouldn't have the issue of multiple version of the error being different instances (and failing the err instanceof SemanticReleaseError test).. Yes. See https://github.com/semantic-release/error/pull/72\nOnce that is merge I can do if (err.semanticRelease) {.\nI choose to name the property semanticRelease instead of expected or exitCode to avoid conflicts.  . Ok. Once we merge semantic-release/error#72 it would be a good idea to deprecate older versions, to make sure third-party plugins use the last version that include the property.. Modification done. I implemented the format.replace(/%[^%]/g, seq => chalk.magenta(seq)). Thanks @felixfbecker !. I fixed the typo and added a note regarding the supported format.\nWe do not support the shorthand format (for example npm/npm) because release-notes-generator needs to determine the hostname to create links in the release notes. With the shorthand format we don't have a way to figure out if the hostname is github.com, gitlab.com or any custom GHE domain.\nI will check if we can generate release notes with relative URLs. If it's the case I will create a PR on release-notes-generator to handle that and remove the restriction in the semantic-release doc.\n. I made the change.. Maybe it would be better to use heading in the readme?\nSomething like this:\n```\nCI configuration\nTravis CI build stages\n```\n. runnin => running. In order to make this recipe simpler and more focused on Composer maybe it be better to not mix Travis Build Stage and keep the conditions-travis plugin.\nNot sure if it's possible though. I think node and npm are installed by default on each travis images, so you might be able to do something like that:\n```yaml\nphp:\n  - '7.0'\n  - '7.2'\ninstall:\n  - composer install --prefer-dist\nscript:\n  - vendor/bin/phpunit\nafter_success:\n  - npx semantic-release\n. Here you can configure with `node_js: node` so the last Node stable will be used and conditions-travis will always pick this job as the build leader, without having to add `BUILD_LEADER`.. `semantic-release` now support various config files. As php project typically do not use `package.json` maybe it would be better to make the `semantic-release` config in `releaserc.yml` or `releaserc.json` ?. Can you instead recommend to build in a `pretest` and in a `prepublishOnly` script?\nThis way that avoid forgetting the build step, both on the CI and for contributor who fork the repo.. Can you instead recommend to lint in a `pretest` script?\nThis way contributors are less likely to push commits without linting?. Same as above. The build step would be run automatically if set in a `prepublishOnly` script.. No need for this filter as it's handled by the `conditions-travis` plugin.. Same comment as above:yaml\nbranches:\n  only:\n    - master\n    - /^greenkeeper.*$/\n``. No need to disablecondition-travisas it supports Travis Build stages. Isn't it the default? I don't think it's necessary. The release Build Stage will use the same as its the default. . Here instead you can mentioned that usingnode_js: nodewill guarantee that the release will happen on that job.. Can Travis runsnpx semantic-releaseon a non Node image? If yes this comment is irrelevant.. That's a good occasion to mention that other type of config files can be used.semantic-releasecould be used withnpx semantic-release, which avoid having to go through thenpm installstep.\nGreenkeeper can also be used withnpx` I think. I don't know about renovate.\nThat also avoid to configure all the mandatory fields in package.json.\n. ok, works for me. As a side note there is something that is quire related to semantic-release and that has been ask several time on the issue tracker: Having the version set in package.json before running the build script.\nThis is because some build script need the version to be set to do something with it.\nIn such situation the best way to solve it is to have the build script being triggered in prepublishOnly.\nThat might a good candidate for another recipe though. Ok. Ok, let's forget about npx. Ok for putting that in another recipe. Ok. The build defined in the release Stage will be determined as the build leader automatically due semantic-release/travis-deploy-once#30. No need to specify node_js: node. Ok, let's keep what the CLI generates. Change still needed. Maybe we should remove this sentence? I'm not sure the internal mechanics of the \"non build stage\" is relevant for the reader?. Let's remove for simplification, it as it's the default then.. Per @gr2m comment. Similar to https://github.com/semantic-release/semantic-release/pull/573/files#r158536677. Per @gr2m comment. Per @gr2m comment. I made both changes. It's to highlight verify-conditions with color. See logger.js#L11.\nIn retrospective it's maybe unnecessary fancyness. But it's not related to this PR.. It's not related to npm/read-package-json#77. The workaround for npm/read-package-json#77  has been moved to the npm plugin.\nThis is related to the ENOTINHISTORY error. That allow users to create a tag for a given commit in case they have rewritten their master history and the last release commit is missing.. No reason, it was a mistake. I changed it.. Done. Done. Done. Done. I made the change. I wonder if it makes the page a bit too long and redundant with the plugins docs?. > Did you mean to add -g here?\nYes I meant -g. Fixed in #594. Thanks.\n\nWhy would we want to recommend this approach given it's disadvantages (no Greenkeeper support etc)?\n\nBecause not all projects use a package.json.\n\nShould in any case have a version requirement so it's not breaking folks on a major release\n\nI added a recommendation in #594. Thanks.. We are guaranteeing the support of Node LTS whatever version it is. See Node Support Policy.. This is what we suggested when the problem was reported, but for some reason it wasn't working due to a bug in yarn that was somehow ignoring --ignore-engines.\nIf it's fixed the doc can be changed. By \"non-JavaScript package\" I implied a project without a package.json. I added some clarification in #594 . The doc clearly mention is a simplified example.\nAn example cannot plan for every possible interaction in every situation otherwise it ends up being confusing with a lot of \"If this do that\".\nThe person configuring the .travis.yml file expected to have a minimum understanding of Travis. The objective of this doc is explain how to use semantic-release, not to explain how to use Travis, or to choose which Node version is best for your project or your company.\nThe users who configure the .travis.yml should be able to analyze by themselve the fact they specifically pin a very old version of semantic-release.. I'd rather remove this entire paragraph, as the the objective of a recipe is to explain how to do a configuration and not to argue about CI best practices or opinions.\nBuild Stages are the best solution and as soon as they are out of beta they will be the only one we recommend. There is already multiple places in the documentation in which we say it's the preferred solution.\nI'd prefer to keep recipe focused on the configuration part that is directly related to semantic-release. Blog post are a better place to evangelize about best practices. And a recipe can reference such blog post.. Can you add a section about authentication configuration? Similar to travis.md#environment-variables:\n```md\nEnvironment variables\nThe Authentication environment variables can be configured in Travis Repository Settings or with the travis env set CLI.\nAlternatively, the default NPM_TOKEN and GH_TOKEN can be easily setup with semantic-release-cli.\n```\nBuild Stages are not supported by the setup cli yet but they should be soon, and the cli can still be used to set up the environment variables.\n. Can you simplify the config example to the minimum required by semantic-release, similarly to travis.md and mention something similar to:\nmd\nThis example is a minimal configuration for semantic-release with a build running Node version 6 and 8 on Linux. See [Travis - Customizing the Build](https://docs.travis-ci.com/user/customizing-the-build) for additional configuration options.\nBasically we would keep only the following entries: language,  node_js, jobs.\n. Can you use lts/* instead of 8 to be consistent with the rest of the doc?. This can be removed as semantic-release core already check for that.. Can you remove npm run build in order to be consistent with other docs and to keep it focused on what's required to run semantic-release?\nAlso can you mention both global and local install?\n```yml\nscript:\n  # Only for a local semantic-release installation\n  - npm run semantic-release\n# Only for a global semantic-release installation\n  - npm install -g semantic-release\n  - semantic-release\n```. Similarly to travis.md can you add a note about Global/Local installs:\nmd\n**Note**: The`semantic-release` execution command varies depending if you are using a [local](../usage/installation.md#local-installation) or [global](../usage/installation.md#global-installation) semantic-release installation.. Can you add a section about package.json configuration mentioning it's required only for local installs similarly to travis.md:\n```md\npackage.json configuration\nA package.json is required only for local semantic-release installation.\n{\n  \"devDependencies\": {\n    \"semantic-release\": \"^11.0.0\"\n  },\n  \"scripts\": {\n    \"semantic-release\": \"semantic-release\"\n  }\n}\n```. Can you add these plugins in plugins-list.md#community-plugins instead?. Can you reference the CircleCi documentation to do that? Similarly to travis.md#environment-variables.. Can this configuration be simplified to keep only what's required by semantic-release, similarly to travis.md?\nYou can mention it's a minimal configuration for the semantic-release part only and provide a link to the Circle CI doc for users can refer to it for the non semantic-release related parts.. There is no need to filter on branch as it's done by semantic-release. It's also something that is configurable so it shouldn't be hardcoded.. This is a section to list all plugins available, from @semantic-release org and community.\nThere no such thing as \"blessed\" plugins. There is the plugins maintained by the semantic-release team (for which bug report have to be opened in the semantic-release orga for example) and the community plugins that are not maintained by the semantic-release team.\nAnyone can make a PR to add their plugin to the list.\nI don't know what you mean by \"hide\". This page is clearly visible, linked in the README and in the sidemenu of the doc website. This is meant to be a registry of plugins.. Thanks!. It seems there is a problem with option 2 as we would install semantic-release globally and run it twice (once with semantic-release and once with npx semantic-release).\nOverall we probably don't need two options but just npx semantic-release as npx would take care of the install.. Indeed it's the default and we don't need it. I added it for more clarity.\nBut we can remove it.\nDo you think it's more confusing to keep it or to remove it?. I removed them in both Travis and Travis build stage. I removed Node 4. But we should keep 6 and 8 as the point of the recipe is to show how to test on multiple Node versions. I removed it. I was passing an object with pluginType to the error function but I was using pluginName instead. I resulted in a message with undefined.. The parameter is passed as {pluginName, pluginConf} which is one Object parameter with pluginName and pluginConf properties.. Oops that was for dev debugging and I forgot to remove it. Good catch!. Shouldn't the comment and GitHub git blame be enough?\nPersonally I use Git blame really often, but not sure if it's a well known feature.\nI'm not sure if in general it's better to reference PR/issues as comment versus using GitHub/Git feature. Or at least I don't know in which cases it worst it to reference an PR/issue in a comment. Any suggestion?\n. The dont-crack plugin seems to not be updated to work with the last version of semantic-release so I'd rather not add it until it's updated.. It doesn't seems condition-run-script is maintained and there is no link to the repo.\nAlso I prefer to recommend using semantic-release/exec which is more generic and maintained.. Can you format like the Official plugins with a list of the plugin function (e.g. verifyConditions, prepare, publish, etc..)?. cracks should be part of the Official plugins. Also it's not updated to work with the last version of semantic-release so I'd rather not add it for now.. Can you format like the Official plugins with a list of the plugin function (e.g. verifyConditions, prepare, publish, etc..)?\nCould you also make sure the plugin is updated to work with the last version of semantic-release and that its author is ok with having it in the list?. Could you replace that with:\nmd\n[Open a Pull Request](https://github.com/semantic-release/semantic-release/blob/caribou/CONTRIBUTING.md#submitting-a-pull-request) to add your plugin to the list.. Ok we can keep the link then.. Can remove this change of syntax that is unrelated to this PR?. Maybe use package-name in the error message instead of package? That would be clearer.. I wouldn't be that categorical here. There is situation in which this error message is actually correct and caused by a permission. So I would soften the language here.. No need to reference to https://github.com/npm/registry/issues/240 here.\nJust explain the error might be due to the package name (or a very similar one) is already used.. No need for the note here. Also it's difficult to know what npm actually consider similar or not.\nJust mention in the previous verbiage something like \"the package name, or a very similar one, is already taken\".. I don't understand what you mean... Please remove your modification so - stays -.. Sorry to nitpick, but can you also remove this additional new line as it's not related to your addition?. This code is not used in semantic-release. It's just code used in the test.\nI set the defaults out of convenience.\nYes I can change the arg name to remote. Well actually in each other function on this util file, similar args are named origin. Should I change it to remote everywhere? Or maybe repositoryUrl would be clearer?. Can you rename the origin parameter to repositoryUrl and add the JSDoc?. Thanks. See https://github.com/semantic-release/semantic-release/pull/798. If this command fail the error will be propagated and logged upstream.. That branch would not be used until one would decide to make a commit there. So that would create potentially a lot of branches that doesn't bring any value (they would functionally to the version tag).\nAlso creating branches might trigger a bunch of stuff on repos (CI etc...).\nFinally those branches being permanent should be created as protected branches, which we cannot do from the core with only the git command. Maybe I should add that in the recipe.\nSo it might be better to users do that when they need it.. ",
    "rmehner": "Good point, done in 1ddb090fec98a3ab0ff0302f64a308f60b3866e4\n. > The Travis deploy integration with npm is so bad, that we need to do it ourselves anyways. Namely auth, where it still uses the old base64 encoded username and password, but also one can't pass arguments to the publish command itself.\nI'm a bit undecided on that. My first thought about this was: Why not fix the npm integration of Travis so that all other unrelated projects can benefit from that? I know that Travis is essentially a product that we'd improve there, but they're good citizens and so is npm inc. You know better than I do what's wrong with the integration, but happy to discuss that and help out with some of my Ruby skills if needed.\n. FYI: In my recent Babel project I got back to use the regular require again, since module loading was recently kicked out of the spec (https://github.com/lukehoban/es6features/issues/75#issuecomment-97763850) and I wanted to keep the code as standard compatible as possible.\n. ",
    "janl": "I\u2019m generally +1 on all of this :)\n. fixed in latest\n. ",
    "arlac77": "going back to:\nversion: 0.0.0-semantically-released\nsemantic-release: 3.3.2\nproduced v1.1.0\n. ",
    "trusktr": "@boennemann  Or, this output:\n```\nok   Installed jss-nested as npm:jss-nested@^0.1.4 (0.1.7)\n     Clearing configuration for npm:commander@2.5.1\n     Removing package files for npm:commander@2.5.1\n The following existing package versions were altered by install deduping:\n\n   commander 2.5.1 -> 2.5.0\n\n To keep existing dependencies locked during install, use the --lock option.\n\n The following new package versions were substituted by install deduping:\n\n   css 2.2.1 -> 2.1.0\n\n Installed Forks\n\n                                   npm:commander 2.5.0 2.8.1\n                                  npm:esprima-fb 8001.1001.0-dev-harmony-fb 13001.1.0-dev-harmony-fb 14001.1.0-dev-harmony-fb\n                                         npm:jss 0.10.2 1.0.8\n                                   npm:minimatch 1.0.0 2.0.8\n                                    npm:minimist 0.0.8 1.1.1\n                                     npm:process 0.10.1 0.11.1\n                                  npm:source-map 0.1.32 0.1.43 0.4.2\n\n To inspect individual package constraints, use jspm inspect registry:name.\n\nok   Installed npm:commander@~2.5.0 (2.5.0)\nok   Install complete.\n```\nIt gives super good insight to the dependencies.\n. ",
    "claudiocro": "I'm also thinking about using semantic-release for my server/client. semantic-release looks very tight couple to npm. Are you planing to abstract this dependency to that other provider / solutions could be used? \n. @gr2m one possibility I think of is to store my archived client to a Amazon S3 bucket like: myapp-v0.0.1.tar.gz. So i would use my S3 bucket instead of the npm archive.\nI just started with this awesome library so maybe I miss something. \n. @boennemann for my current project i'm using the public npm registry, so, no problem.\nI just wanted to know if there where future plans towards an abstraction of the npm layer. But thinking of this module as semantic-release-npm makes sense.\nIf I start a new project (not enterprise) should I use the next branch already?\n. ",
    "juristr": ":+1: \n. I have the exact same problem with semantic release & bower. Used to have the dist folder in master and to compile it just before creating a new release (really tedious work..).\n@kentcdodds Ok, so if I got you correctly, Travis is listening for changes on master, builds etc, uses semantic-release and your script to publish the dist files to latest which you then tag. You cannot push the dist to master 'cause that would end in an infinite loop :smile:. Did I get that correctly?\n. @kentcdodds Hmm..ok. Set it up. Publishing to npm etc works. Tried to hook in your publish-latest plugin, but it failed. Any idea why: https://travis-ci.org/Swimlane/angular-model-factory/builds/82403298\n```\n...\n\nangular-model-factory@1.0.1 postpublish .\npublish-latest\nstderr: fatal: 'travis/temp' does not appear to be a git repository\nfatal: Could not read from remote repository.\nPlease make sure you have the correct access rights\nand the repository exists.\nfatal: Cannot update paths and switch to branch 'dist' at the same time.\nDid you intend to checkout 'package.json' which can not be resolved as commit?\nstdout: > PL >> setting global git config: latest,\nPL >> running git config --global user.email\nPL >> running git config --global user.name \"latest\"\nPL >> setting remote\nPL >> running git remote set-url origin travis/temp\nPL >> checking for dist package.json branch\nPL >> dist package.json does not exist on remote... creating it...\nPL >> running git checkout -b dist package.json\n...\n```\n\nI don't get why it says this: Please make sure you have the correct access rights. 'Cause the push of the semantic-release created tag and GitHub release works just fine.\nAnd it also seems to do a weird thing:\n\nAny idea?\nThx!\n. > Oh, also, I recommend you do this also, to prevent building the latest branch.\n@kentcdodds :+1: thx for the hint.\n. @gr2m Maybe you're able to do with the branches property of the .travis.yml file:\n...\nbranches:\n  only:\n    - master\n...\nThis way it only builds master and nothing else. I did not yet check whether this also prevents from building tags, but I guess so.\n. ",
    "kentcdodds": "When I npm install -g semantic-release-cli the command I then execute is semantic-release setup not semantic-release-cli setup. semantic-release-cli command is not found.\n. Huh, that was odd. It's working now:\n\n. For what it's worth, I actually use this as part of my scripts and pre-commit hooks so the build will break if a PR or commit doesn't have sufficient code coverage.\n. If I need a WIP commit, I simply commit with --no-verify and it skips the commit hooks. I actually prefer the build to break if the thresholds aren't met.\nSounds to me like this would be a fine micro-plugin. I personally wouldn't use it.\n. Hi @gr2m. I want the built files to live in the tagged version because that's how bower works. It doesn't make a difference what branch it's in.\n. Seems like it should. How do I authorize travis to commit to my repo?\n. That looks awesome! Mind open sourcing that so I (and others) can just npm install?\n. no problem. I'll let you know how it goes :-)\n. Alright, so I've gotten something that works really well. Here's my semantic-release process: https://github.com/formly-js/angular-formly/blob/master/package.json#L32\nsemantic-release pre && npm run build && npm publish && semantic-release post && npm run publish:latest\nNote: I need to run the build after pre because my build depends on the package.json version because I publish the version as part of my library (similar to what angular or react do).\nThen the publish:latest is this script which essentially:\n1. checks out the latest branch\n2. merges master\n3. adds the dist directory (the generated files needed for bower)\n4. commits it with the version as the message\n5. Moves the tag that semantic-release just created\n6. Force pushes (so the tag gets moved to the commit with the dist directory).\nHowever, I think this is causing some odd behavior. If you look at my releases you'll see that the changelog is getting stacked. Each release has the changes from the previous releases as well as its own. If you look at the output from the travis build you'll see that semantic-release is: \"Generating changelog from v6.24.21 to HEAD...\" every single release.\nAny tips on how I could accomplish what I'm trying to do, but fix the changelog issue are appreciated!\n. So I've changed a few things and now we no longer need to move the release tag (which is great). Here's how things look now:\nsemantic-release pre && npm run build && npm publish && npm run publish:latest && semantic-release post\nSo publish:latest has moved in front of semantic-release post and here's what it's doing now:\n1. checks out the latest branch\n2. merges master\n3. adds the dist directory (the generated files needed for bower)\n4. commits it with the version as the message\n5. Force pushes latest (in case there is some kind of divergence for some reason).\nAll that's changed is I'm no longer moving the tag because it doesn't exist yet. This seems to work great. The only problem is that it's still generating the changelog from 6.24.21 so every release the changelog gets bigger and bigger filled with stuff that's been released before.\n. I think I've found the problem. When I run git describe --tags --abbrev=0 in my repo, I get back v6.24.21. I'm not sure why it's not showing me the actual latest. Any tips appreciated!\n. I figured out that because I'm actually committing my tags on the latest branch, I need to change the branch to latest before conventional-changelog runs git describe --tags --abbrev=0. Still working out a few kinks. Hopefully I'll be able to create a plugin to suit this use case better in the future when I'm done :-)\n. Alrighty! I've got it. It's kinda crazy, but it totally works. I'm all set!\n. Sure, if you look at my comments, I describe exactly what my code does and where it is. You need to alter the semantic-release script slightly and you'll need to have a script which commits built files and pushes them to a branch (I use latest). In addition, you'll need to either re-use your GH_TOKEN on this line or do what I did and have a BOT_GH_TOKEN which is a token for a bot account.\nI'm hoping to make this a plugin eventually. Good luck!\n. That is quite similar. I'm working on something right now. Hopefully I'll\nhave it before too long.\n-Kent C. Dodds\nOn Tue, Sep 15, 2015 at 12:56 PM, Tom Vincent notifications@github.com\nwrote:\n\nI've been using a similar script for sometime now and whilst it's a little\nhacky, it works. I've written up my workflow in\ntlvince/tlvince-semantic-release-push-dist\nhttps://github.com/tlvince/tlvince-semantic-release-push-dist, but I'd\nalso love to see a plugin that implements this more robustly.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/semantic-release/semantic-release/issues/75#issuecomment-140499990\n.\n. Alrighty, I've open sourced my script. It seems to work great :-) http://npm.im/publish-latest\n. @juristr, you'd be fine to have a dist in master. Travis just runs the build as normal and it simply commits your built files and pushes them to latest. It explicitly adds dist and package.json (with -f so it works even if they're .gitignored) (the files it adds is configurable). Glad you got it working!\n\nOh, also, I recommend you do this also, to prevent building the latest branch.\n. Huh... @tlvince is there a reason you didn't just use publish-latest? You know you can publish to a separate repository, to master, OR to the latest branch with it right?\n. That's my bad for not calling that out in the documentation well enough.\n. :+1: from me. Based on my limited experience, this sounds like this would totally be possible as a semantic-release plugin\n. Hmmm... What if I commented on the commit(s) instead of the PR?\n- Kent C. Dodds\n(Sent from my mobile device, please forgive typos or brevity)\nOn Sep 7, 2015 9:02 AM, \"Ari Porad\" notifications@github.com wrote:\n\nI think that the trouble would be mapping commits to PRs. We could\ndefiantly map it to contributors, but PRs would be tricky.\nAri\nOn Mon, Sep 7, 2015 at 5:46 AM, Kent C. Dodds notifications@github.com\nwrote:\n\n[image: :+1:] from me. Based on my limited experience, this sounds like\nthis would totally be possible as a semantic-release plugin\n\u2014\nReply to this email directly or view it on GitHub\n<\nhttps://github.com/semantic-release/semantic-release/issues/79#issuecomment-138289647\n.\n\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/semantic-release/semantic-release/issues/79#issuecomment-138319606\n.\n. \n\nI'm pretty sure you can comment on whole commits. :point_up_2: \n. If it's annoying, then the project maintained doesn't have to use the\nplugin.\n- Kent C. Dodds\n(Sent from my mobile device, please forgive typos or brevity)\nOn Sep 7, 2015 10:05 AM, \"Ari Porad\" notifications@github.com wrote:\n\nOops... Yeah, you're right.\nI think thought that this might get annoying for contributors (like\n@boennemann).\nAri\nOn Mon, Sep 7, 2015 at 8:41 AM, Kent C. Dodds notifications@github.com\nwrote:\n\n[image: screenshot_2015-09-07-09-39-55]\n<\nhttps://cloud.githubusercontent.com/assets/1500684/9719722/77b0c8a2-5544-11e5-9553-57fd64114310.png\nI'm pretty sure you can comment on whole commits. [image: :point_up_2:]\n\u2014\nReply to this email directly or view it on GitHub\n<\nhttps://github.com/semantic-release/semantic-release/issues/79#issuecomment-138327224\n.\n\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/semantic-release/semantic-release/issues/79#issuecomment-138332642\n.\n. I never got it to work. I just went with a non-scoped package... I wonder if it'd work if I update to the latest version of semantic-release. In any case, it's not currently a problem for me, so I'll go ahead and close this.. This was closed because it's not directly affecting me and I'm not going to work on fixing it. If you want to fix the issue, feel free. I'll go ahead and re-open it.. I don't think this is an issue any longer.. Thanks! It looks like things were resolved when I actually installed semantic-release-cli globally rather than using npx.. I upgraded and things and it's working great! I love the new automatic comment feature. Wahoo! Thanks :). \n",
    "lapanoid": "This is travis https://travis-ci.org/lapanoid/presentation, I did semantic-release-cli setup without any errors\n. @boennemann Everything works great, thanks!\n. If it is complicated, I can workaround it by publishing something lightweight (just package.json) and then do my graddle-android publishing stuff. But I don't now how to hook when semantic release successfully finished. @boennemann can you guide me here?\n. ",
    "bahmutov": "will consider if I have time. Right now I am thinking of writing a tool that would configure all project-related services: travis, semantic release, david dependencies, codacy in a single command.\n. I believe my plugin https://github.com/bahmutov/dont-crack already does that. @hbetts - great project, trying it on our gitlab projects right now!\n. Same problem, the repo in package.json\n\"repository\": {\n     \"type\": \"git\",\n     \"url\": \"git@github.com:bahmutov/obind.git\"\n}\n. checked the info - seems the ghrepo property is missing completely\njs\n// in semantic-release-cli/dist/lib/travis.js\nfunction setUpTravis(pkg, info, cb) {\n  var log = info.log;\n  var travis = info.travis;\n  syncTravis(travis, function () {\n    console.log('gh repo', info.ghrepo);\n    console.log('info', info);\n    travis.repos(info.ghrepo.slug[0], info.ghrepo.slug[1]).get(function (err, res) {\nprints for info\ngiturl: \"https:git@github.com:bahmutov/obind.git\",\ngithub: { valid object }\nmaybe it is not parsing the git repo url correctly?\n. Seems the git url parsing code is really old using https://www.npmjs.com/package/parse-github-repo-url\nwhich does not handle most of the newer formats. For example it chokes on https:git@github.com:bahmutov/lazy-ass.git parsing, even when the package.json contains\n\"repository\": {\n      \"type\": \"git\",\n      \"url\": \"git@github.com:bahmutov/lazy-ass.git\"\n}\n. Same problem with a little different message\nERR! semantic-release Could not login to Travis CI.\nERR! semantic-release you are currently not allowed to perform this request. please contact support@travis-ci.com.\n. Seems for my issue the reason is because of DDOS, Travis now needs a user agent in the header, see https://github.com/semantic-release/cli/issues/69\n. As a work around I am using CircleCI to do semantic-release. Here is step by step guide https://github.com/bahmutov/condition-circle/blob/master/HOW.md and I wrote a verify conditions plugin https://github.com/bahmutov/condition-circle to be used instead of the default condition-travis - seems to work pretty nicely\n. Ok, seems single tested Node version on Travis fixed the problem. Is there something about multiple Node versions I can fix? Is there a way to only publish for a specific node version?\n. For now as a work around I am publishing to NPM only if running tests on a specific Node version using plugin https://github.com/bahmutov/condition-node-version\n. sure, close it. I am always using condition-node-version in these cases.\n. For example I implemented Node version check in https://github.com/bahmutov/condition-node-version but had to check for travis env too because I cannot combine the default plugin with this one\n. :cool: \n. Yes forgot about that open issue, should fix it \nSent from my iPhone\n\nOn Jan 9, 2016, at 13:13, Stephan B\u00f6nnemann notifications@github.com wrote:\nThanks for this @bahmutov. Just to clarify, merging this would also fix #114, right?\n\u2014\nReply to this email directly or view it on GitHub.\n. @motiz88 will do, opened https://github.com/bahmutov/condition-circle/issues/3\n. @motiz88 I have updated condition-circle to run the script as part of the condition, seems to work - now my modules on CircleCI are actually bumped correctly.\n. Can people here try using github-post-release please?\n\n\nsingle dev dependency that automatically inserts itself as generateNotes plugin\nuses latest conventional-changelog to format release markdown text without weird link\nupdates every resolved github issue with a note: \"version ... published to npm ...\"\n\nSee doc: https://github.com/bahmutov/github-post-release#github-post-release. Hi! for changelog, I am just calling conventional changelog and have no idea why this version just posts the commits list\nSee https://github.com/bahmutov/github-post-release/blob/8e7cb4adcb12fd6e19d7c3440fa51123517f7476/src/index.js#L136\njs\n  const generateChangeLog = () => {\n    debug('generate changelog')\n    return streamToPromise(\n      changelog({\n        version: pkg.version,\n        repository: parsedRepo,\n        fail: false\n      })\n    ).then(buffer => buffer.toString())\n  }\nI do want to fix this, so there is an issue bahmutov/github-post-release#9. @dfbaskin i have no idea, this project is really on very low maintenance right now, seems to me . ok, updated the changlog and factored it into https://github.com/bahmutov/simple-changelog and examples of release notes can be found in https://github.com/bahmutov/github-post-release/releases\nNote, I am using https://github.com/bahmutov/simple-commit-message convention which is simpler than conventional one. The easiest way to control this is to use plugin https://github.com/bahmutov/condition-node-version. +1 on moving this into separate module.\nAlso, I have forked the parse-github-repo-url some time ago, because they would not merge the pull request.\nI added robust github parsing and some simple inhouse gitlab url parsing (hit same problem trying to set this up against gitlab at work). It is literally single dependency drop-in replacement from parse-github-repo-url to @bahmutov/parse-github-repo-url\n. The idea was that library was already used, just not maintained, so it was missing a few cases. I just kept adding use cases, so it is pretty simple replacement.\n. ",
    "gajus": "I don't understand. https://github.com/semantic-release/semantic-release is advertising this as a feature.\n\nDetect breaking changes using your dependents\u2019 test suites: Help out! Implement the dont-break plugin\n\nOh, no it doesn't. Reading a second time \u2013\u00a0\"Help out!\" is supposed to indicate it is an upcoming feature. Thats a bit misleading.\nNevertheless, this would be a deal breaker.\n. What is the logic?\nIt has nothing to do with performance. We are removing one feature because it duplicates with lodash functionality (as an example).\n. @vrtxf The quote is from FAQ section of http://semver.org. You will need to be more specific.\nRegardless, this was a suggestion to improve docs.\n. @boennemann any guidelines regarding this?\n. ",
    "felixfbecker": "My question would be how to do this before an accidental breaking change is merged into master, i.e. on a PR? Using plain dont-break works, but will not consider whether the commit messages include BREAKING CHANGE. As I see it all that is needed is for analyzeCommits to accept a prefix option and pass that to git log, so that only the history of a subdirectory with the package ist analyzed. Am I missing something?. Well in my head, just like you have a package.json for every package, you run semantic-release for each package, which the specific directory prefix. Then if a commit affected multiple packages, it will simply show up for each package that it affected, because it will have affected the respective directories and therefor show up in the filtered git log. The benefit of this solution is that it is simple and the semantic-release runs can be run in isolation as parallel jobs in CI (as it is usually done with proper monorepo CI configs - you're not testing/deploying every package serially).\nNow what this doesn't work well for of course is the case like angular where you just have a bunch of packages that in reality are always kept in sync to have the exact same version number. Essentially the version number doesn't say anything individually about each package, you're just splitting up a big package into chunks to reduce download size for folks who don't need all of it. That means you more often than not are releasing a version of a package even if nothing in that package changed, or nothing in that package changed that would warrant the respective semver bump (personal opinion on the side: for angular's packages imo it's a bad idea and against semver, but we can still support it).\nFor that workflow, you would always want to analyze the whole repo history, but then update all of the package.jsons with the same version and publish all of them.\nI think that should already be possible with current semantic-release - getLastRelease would use @semantic-release/git to determine the last release for all packages, then publish would list @semantic-release/npm multiple times with different pkgRoot settings for each package.\nDisclaimer: I am not working myself on any monorepos with multiple packages, so would love to hear thoughts on these ideas from someone who does. > This forces the users to find a solution to iterate over the packages and run semantic-release for each one of them, so it's not really more simple from the user perspective.\nI think you are making that sound a bit harder then it really is. It's just a bunch of cds into folders. Now where these folders are declared is up to the user, if you are using lerna, you can let lerna do it - lerna run semantic-release will run the semantic-release npm script in every package.\n\nMoreover, configuring your CI this way will have a huge impact on build time. semantic-release takes a few seconds to run, while cloning starting the CI VM, cloning the repo (especially for monorepo as the repo is bigger), installing the dependencies and running a potential build on each packages will takes a lot more time. Basically you would save a couple seconds by parallelizing the semantic-release runs and loose several minutes by duplicating the startup, npm install, repo cloning and build.\n\nThe reason to configure the CI that way is to improve build time. You don't just want to publish all these packages, you want to build them in any case and run tests. Doing that for all packages in series is slow, you want to parallise that anyway, and then you can also do the publishing in parallel. Bootstraping a container should not take more than a few seconds if you are utilising caching properly and/or prebuilt containers and it also doesn't matter since it's parallel (the time needs to be spent equally for one or for many containers).\nBut that's not really my point, if you want to do it serially noone will stop you - I just think that this configuration should be possible/supported, because it a really big monorepo (enterprise size) you will not get around it. Running all tasks in a single big container in series is just not an option. So it's better to not make that semantic-release's responsibility.\nI agree that semantic-release should just be as generic as possible to allow monorepos through plugins and config without making assumptions, and that people who are actually releasing packages from monorepos know best what workflows should be supported (I work daily with a monorepo but we don't release any packages from it).\nMaybe a good approach would be to check what needs to happen so that lerna-semantic-release can become a plugin instead of a fork. For example, https://github.com/atlassian/cz-lerna-changelog uses affects: annotations in commit messages to mark what packages are affected by commits.. > While semver dictates that it shouldn't matter, I find it useful and helpful to guarantee the latest version of dependencies between published modules in a monorepo.\n@SimenB I'm curious about why you find it useful/helpful?. > For the general case of mono-repo to work (as lerna, babel, etc do it), any change in a dependent (local) package must result in a new release of the depending package.\nWhy is this? If the depending package has a caret semver range dependency, and the depended-upon package made a bug fix that didn't touch the depending package in any way, why would the depending package need a new release?. Empty/noop versions are cheap for the publisher, but annoying for the consumer:\n- when using Renovate/Greenkeeper/... you get countless PRs that effectively change nothing\n- when using Sibbel, you get countless notification emails for new releases that have no changes\n- when scrolling through GitHub releases, there are countless entries that have no changes\nI don't know what you mean with \"silent transitive regressions\" as it's not clear to me how releasing noop versions solve that problem in any way (vs unit tests etc). I looked through the linked PR and issues but am not familiar enough with lerna to understand what flags are being talked about. If it is possible to avoid empty versions then I believe semantic-release should do it, independent of what lerna does.. It wouldn't even need the subtree config option, it could use the location of the package.json/.releaserc to mark the package root.. What's the recommended approach if the package manager does not support dist tags / release channels but only prereleases?. I am using it successfully with Composer, which does not support dist tags, but prereleases.. Why is that out of scope? The current version works by running semantic-release pre && npm publish && semantic-release post. You can put any arbitrary command instead of npm publish in there, so that is already as pluggable as it can get really. Instead of last-release-npm, you can already configure to use a different plugin like last-release-git. NPM_TOKEN can be set to a dummy value. It works well - some rough edges shouldn't block us on brainstorming how semantic-release could support a prerelease workflow.\nFor example, one could imagine different branches like alpha, beta, stable that commits go through. I imagine it should already be possible with the plugin API to make the new release on the beta branch always the \"next\" beta release or the previous beta release + 1. Then a release could be first merged into the beta branch if desired before being merged into stable.. @pvdlg what do you think about the idea I outlined above?. Just had the same error again, in a project that doesn't publish to npm:\n```\n$ npm run semantic-release\n\nphp-intellisense@0.0.0-development semantic-release /home/travis/build/felixfbecker/vscode-php-intellisense\nsemantic-release pre && vsce publish -p $VSCE_TOKEN && semantic-release post\nsemantic-release WARN invalid config loglevel=\"notice\"\nsemantic-release ERR! pre undefined\nnpm ERR! code ELIFECYCLE\nnpm ERR! errno 1\nnpm ERR! php-intellisense@0.0.0-development semantic-release: semantic-release pre && vsce publish -p $VSCE_TOKEN && semantic-release post\nnpm ERR! Exit status 1\nnpm ERR! \nnpm ERR! Failed at the php-intellisense@0.0.0-development semantic-release script.\nnpm ERR! This is probably not a problem with npm. There is likely additional logging output above.\nnpm ERR! A complete log of this run can be found in:\nnpm ERR!     /home/travis/.npm/_logs/2017-10-29T20_50_25_073Z-debug.log\n```\n\nhttps://travis-ci.org/felixfbecker/vscode-php-intellisense/builds/294574982?utm_source=github_status&utm_medium=notification\nI see this issue was closed, but were there any improvements done to error handling?. Since with build stages condition-travis is redundant (previous stages must pass, I already configure it to only run on master, ...) I tried setting \"verifyCondition\": [] in .travis.yml.\nThat caused a version 0.0.0-development to be released. I tried reproducing locally with \"debug\": true but I don't get any log output.. I re-ran semantic-release-cli setup and restartet the build, which suceeded. Seems like a token issue maybe? I would propose to improve the error message, seems similar to https://github.com/semantic-release/semantic-release/issues/337. I'd like to use semantic-release with PHP projects that use Composer. Composer doesn't publish tarballs of new versions, it just uses git tags in the repository. So I only need the functionality of semantic-release to tag new releases, i.e. instead of\nsh\nsemantic-release pre && npm publish && semantic-release post\njust do\nsh\nsemantic-release pre && semantic-release post\nwithout an NPM_TOKEN, just a GH_TOKEN.. Seems like this should work: https://www.npmjs.com/package/last-release-git. That sounds great, as long as it's still flexible enough to configure with custom scripts etc.\nGot it to work btw: https://github.com/felixfbecker/php-semantic-release-test/releases/tag/v2.1.0. I don't think it should be removed from the default configuration, because it's the biggest use case and the plugin architecture makes it easy enough to run on tags (but it requires to workaround some Travis annoyances).\nBut what I'd like to see is the requirement for NPM_TOKEN to be dropped and  have the CLI ask a question whether you want to use NPM integration or not. Atm the CLI adds an NPM token to Travis even when I want to set it up for a PHP project. The token is not used in the end because I use the git tag plugin, but if it is not set, semantic-release will bail early with an error. I have to set it to a fake token like 0000-0000-0000-0000 to make it work.. I mean the semantic-release-cli setup command. Met another problem:\ntravis-deploy-once seems to check the Node version. If none of the jobs are using the node_js language, then there will be no build leader detected, even if node 8 is installed with nvm.\nhttps://travis-ci.org/felixfbecker/php-language-server/jobs/291359846#L912-L915. https://github.com/semantic-release/travis-deploy-once/issues/22. > Semantic-Release must now be executed with semantic-release instead of semantic-release pre && npm publish && semantic-release post.\nWhat is the benefit from this change? Imo this makes it unnecessarily hard to publish to things other than npm. It is nice to be able to publish e.g. a VS Code extension without having to write any custom plugins for publishing that [1], or using semantic-release to publish a docker image on Docker hub [2]. In a non-JS project you don't want to maintain related JS code, a CLI command is very easy to understand for everyone. Am I missing some better alternative here?\n[1] https://github.com/felixfbecker/vscode-php-intellisense/blob/d293ba3323f705404dcae84959f95dc1dce128f0/package.json#L46\n[2] https://github.com/felixfbecker/php-language-server/blob/1db6b7bbb3af458feffe356427fae6f85f8a025c/package.json#L7\n. @pvdlg ah, that makes sense.\n\nIn addition to that it's was not really possible to use semantic-release without npm anyway\n\nThe examples I posted work ;)\n\nWe rely on the npm registry to determine the last version released\n\nThat is just the default, it can be overridden. https://www.npmjs.com/package/last-release-git makes it possible to determine the last release from git tags.\n\nWe were verifying at the very beginning of semantic-release pre taht a NPM token is set\n\nYeah, that was annoying. It can be worked around by setting NPM_TOKEN to a dummy value.\nSee https://github.com/semantic-release/semantic-release/issues/465#issuecomment-339809654\n\nAs mentioned in #484 we would also provide a plugin or another mechanist that would allow to set a command line to run, allow to do any type of release that can be done via command line.\n\nThat would be great, if the plugin just had an option to specify an arbitrary command to run in package.json \ud83d\udc4d \n. @marcbachmann if you want to lock versions in a project and not a library, you should use package-lock.json. npm 5 updates the file automatically. I would generally recommend to only lock versions on the top-level consuming project, not the library level.The point of lockfiles is to have the same versions in development and production. Greenkeeper has support for updating lockfiles.. > For the same reason, I strongly recommend library developers commit their package-lock.json file to their repository.\n\nThis ensures that if I pull down your library to fix a bug, or add an enhancement, that I will get the same working dependencies used by the last working build.\nWithout a package-lock.json file it's possible that I won't be able to contribute to your library because of a broken upstream dependency.\n\nImo that gives a false sense of security, because consumers of the library would still get the broken package. So I would rather have the build be broken than to pretend everything's fine and then pin the dependency if needed - for contributors and consumers. After all, the package.json specifies the versions that are guaranteed to work. This is the primary reason I run nightly builds for OS libraries, so that a green build status actually indicates that the package is 100% functional for consumers and a red status indicates it's broken for consumers. But I know this is a very controversial topic.. Is it possible to already try out the GitHub release binary publishing? Currently using semantic-release v8 with vsce for vscode extensions.. Yes, I mean \"assets\". GitHub calls that \"binaries\":\n\n. I'll definitely try it out!. @raix very interested in sematic-release-vsce! Is it usable already?. If anyone is interested, I published https://github.com/felixfbecker/semantic-release-docker to release docker images to Docker Hub. Agree, as long as every commit works on it's own (a build on this would succeed) I wouldn't squash them. One point I would like to comment on:\n\nThing is, maintaining a project's version in package.json is a common thing for the ecosystem (even for projects that don't ship to npmjs).\n\nComposer is an example of a package manager that has a version field in composer.json, but it is optional and actively discouraged from being used, because git tags should be the source of truth for this, which I agree with.\n\nOptional if the package repository can infer the version from somewhere, such as the VCS tag name in the VCS repository. In that case it is also recommended to omit it.\nNote: Packagist uses VCS repositories, so the statement above is very much true for Packagist as well. Specifying the version yourself will most likely end up creating problems at some point due to human error.\n\nhttps://getcomposer.org/doc/04-schema.md#version\n. @lirantal maybe I'm missing something, but for what use case do git tags not work?. @pvdlg should semantic-release/last-release-git-tag be deprecated? Seems like the git plugin provides a superset of the functionality. Instead of a GitHub app, wouldn't it make more sense to have a Travis deploy provider?. > most users, sadly use Travis\n@olstenlarck curious why you think it's sad most users use travis?. I work with both intensively and from my experience they are roughly the same.\nBut Circle has some really annoying aspects especially in the context of semantic release. They don't build PR merge commits, but only the branch tips, and share the builds between different PRs from the same head commit. That prevents you from using something like commitlint to lint the commit messages included in a PR to make sure they conform to conventional commit style before merging, which is essential to semantic-release. There is no way to figure out what commits are part of this PR build because there is not a 1:1 mapping between builds and PRs.. Of course, commitlinting should be done before committing, code linting should be done before linting (best in the editor), tests should be run before committing, etc etc. But people can always circumvent it (and sometimes it's just not worth the time). Commit with --no-verify and no git hooks are run. Make a commit in GitHub's online editor and nothing will be checked. Every check you may have locally in a git hook must be replicated in CI to prevent bad things from ever getting into master. That's why CI is used to run tests - otherwise we could just say \"remember to run everything locally\". Remembering doesn't scale. Client-side validation is great, but cannot replace server-side validation.. It's hard to support both v12 and v13 so I plan to update semantic-release-vsce to v13 when v13 gets moved from next to latest. Isn't npm-conf deprecated?. Could you give an example how to use an arbitrary shell command as a publish step? E.g. docker push, vsce publish etc. Do existing plugins like https://github.com/finom/last-release-git sill work with 10.0.0?\nBtw, thank you for all the work @pvdlg! These updates are very exciting.. Even better!. > As far as I understand if you do npm install my-pkg you will not get my-pakg@4.0.0-beta, you will get the highest non pre-release version available on @latest. I'll test to make sure.\nAfaik npm install my-pkg will always get you latest, and if that was set to a prerelease, then you will get a prerelease. I already opened many issues because package maintainers forgot to publish with --dist-tag=next and accidentally tagged latest to a prerelease. But maybe npm changed it?. \noff topic\n@priley86 documentation of breaking changes belong to the release notes, not the readme. They were documented in the release notes of 9.0.0 with a migration guide. But a smart way to detect the pre argument may have been nice.\nLet's not get this issue thread off topic though please.\n. I agree that it's unintuitive - if we know that the next non-pre release will have a breaking change, shouldn't the prerelease be for the next major version? I.e. if at least one breaking change is detected on a prerelease branch, the major should be bumped (once). More breaking changes would then only bump the prerelease number.. Strongly disagree. Why would this not be a reason to break the build? It\u2019s a fatal CI misconfiguration. If deploys are not happening even though I\u2019d expect them to that\u2019s as close as it gets to the definition of a build failure.\nOne of the major advantages of semantic-release v11 is that it doesn\u2019t have to be run in after_success anymore because it doesn\u2019t use exit codes to signal ENOCHANGE. Meaning it can be executed in script / in a Travis build step and not get silent failures.\nIf someone really wants to ignore failed releases they can use e.g. Travis allow_failures, but the failed release should still be visible somehow, not hidden in a lig while everything is green. @pvdlg thanks for your reply, let me respond to each point individually (tldr at the end):\n\nwhich involve future user reporting, potential Github application\n\nImo this isn't coupled to the GitHub application, which can always have a different reporting mechanism. This is as low-level as \"if there was a configuration error, make the process return a non-zero exit code\". Complex projects and companies will always want to have their release process go through their CI system, through a deploy bot or whatever, and they might not even use GitHub. The CI workflow should always be a first-class citizen in semantic-release.\n\nThis is the exception/error situation we/we'll have to handle:\n\nCoding error in a plugin or wrong output\nUnexpected Error in a dependency\nExceptional case for which the user doesn't need to be alerted (like no release to be done)\nExceptional cases for which the user has to be alerted (i.e. the commit xyz create an incoherent state of your branching/release system or a misconfiguration)\n\n\nThe 4 error types you mentioned can be reduced to just two: Non-failure cases (ENOCHANGE etc) and failure cases (everything else). Looks like it could be achieved atm by simply using Error for the ENONPMTOKEN error.\n\nA case like a misconfiguration for example is really debatable. Should we fail the build or should we let the build succeed and open an issue to alert the user?\n\nWhat would be the benefit of opening an issue if I am not using the GitHub app? CI systems already have methods to notify about broken builds, where it's easy to configure that for example only I get notified as the one who broke the build.\n\nIf you have a very active project and a maintainer decide to try out semantic-release and make a misconfiguration, it's probably better to alert via an issue or some other means rather than breaking all the builds for everyone.\n\nIf you use CI for deployment (aka Continuous Deployment) then your builds are broken for everyone, because they don't do anymore what they are supposed to do (deploy). You could make the same argument for anything that could break the build, e.g. \"should a lint failure turn the build status red or just create a GitHub issue\". But in reality I see no benefit from that. Multiple commits could be pushed to try to fix the config. If the build fails, it's directly tied to the commit and easy to see what commit works / which one is wrong and who is responsible. A GitHub issue would be much harder to link to the failing builds+commits and to make sure the responsible people are notified (and others not). And most importantly: The GitHub issue reporting doesn't exist yet.\n\nIf your private npm is down, should we report that to users via an issue or a notification or should we fail every builds, prevent PR to be merged, trigger the same alerts that are triggered when a unit test fail and basically indicate \"your code is broken\" while it's not?\n\nCI is more than just unit test, it is what you as a user use it for. If you use it for unit tests, it's for unit tests. If you also use it for linting, it is also for linting (and fails the build if linting fails, unless you configure it to ignore that failure). If you use it for deployment/releases, it is also for deployment/releases, and should fail the build if that part fails (unless you configured CI to ignore that failure).\n\nprevent PR to be merged\n\nThat is up to you to configure. If you configure CI to only run semantic-release on master, then this will not prevent PRs to be merged.\n\nThose type of questions are related to the bigger question of the relationship between CI and release management. Some might want the release to be part of the CI: if the release fails then the CI build fails, similarly to when a unit test fails. Some might see it as something that comes after the CI: if the release fails it doesn't mean my code is broken like a failed unit test would.\n\nYes, and if semantic-release exits with a non-zero exit code, everyone can configure CI to ignore that error. They can use allow_failures, or make it as simple as appending || true to the command to ignore the exit code. But if semantic-release always exits always with 0, it's impossible to opt-in into non-silent errors. And I believe that should be the default, because it is a huge foot gun.\n\nYour strong disagreement is understandable, but there is also some reasons for the current implementation, mainly to be less disruptive in order to, among other things, encourage adoption.\n\nImo foot guns are not good for adoption, they cause frustration.\n\n\"If we have what we need to make a release and we are sure one has to be made, we'll do it for you. If not we'll let you know (via log for now) and don't break anything in your workflow\".\n\nIf I set up my workflow to do my releases in CI, but something is wrong (token expired etc), then my workflow is broken. I would not want it to pretend everything is fine.\n\nIt's a fait point though that the user can (in some cases that depends on the CI platform) use test or after_sucess step to decide if a failed release should fail the build.\nOn a side note allow_failures would allow failures on the whole CI job, not only on the semantic-release call. And after_success is available on Travis but not necessary on every CI solutions (especially private/corporate ones).\n\nTo use allow_failures you have to separate the release into a separate job/build stage of course, which is supported by Travis (build stages), CircleCI (workflows), and Buildkite (pipelines). If not, every CI provider can run a shell script and a shell script can ignore an exit code - if you really want the release to not impact your build status, that is what you want anyway so bugs don't affect it either.\n\nStill remains the question of what qualify as a failed release.\n\nI think that is easy to answer: If the build ran, should have done a release or was unable to find out, but has not, that's a failed release. I.e.:\n- ENOCHANGE is not a failure\n- A config error like ENONPMTOKEN is a failure\n- npm registry down is a failure\n- git exec error is a failure\n- Any other uncaught exception is a failure\nTL;DR:\n\nI believe the current behaviour is a foot gun for new users and should not be the default.\nIt would be easy enough to opt-in to it if desired.. To give some graphic examples:\n\nCircle:\n\nTravis:\n\nBuildkite:\n\nIf the release was actually not possible e.g. because my npm token was not set or expired, as a user I would expect to see \u274c  Release, not \u2705 Release.. @pvdlg wouldn't it be enough to always use SemanticReleaseError for non-breaking errors and Error for breaking errors?. Why would it require changing all the plugins? As I understand it the current behaviour is that SemanticReleaseError does not fail the build, so that behaviour would be maintained, and normal Errors should never be thrown unless because of a bug.\nMaybe give it a boolean property like expected then?. I mean, yeah, it would require updating all plugins to achieve the proposed behaviour. Otherwise this would be a breaking change.\nA bit confused why you are talking about the Travis plugin, just to be clear I am talking about @semantic-release/npm.\n\nThe idea would be instead to have the travis plugin to return false instead of throwing a SemanticReleaseError.\n\nI don't think that is a good idea because false does not contain any information anymore what exactly happened, no message, no error code etc. Yes, the plugin could log itself, but if used programmatically (I've seen this) the caller would have no way to catch and handle specific errors manually.. There is also the ENOCHANGE error, right?. Not sure I follow. Why is that part of the core and condition-travis not? Doesn't every third-party analyzeCommits plugin also use such an error?. I just had another case of this. The only reason I found out was because a user tweeted at me whether we could get another release. Which made me think, weird, that should have already been auto-released - and the build had passed.\nTurns out the release was not working because Docker was updated in Travis:\n```\n$ npm run semantic-release\n\nphp-language-server@0.0.0-development semantic-release /home/travis/build/[secure]/php-language-server\nsemantic-release\n[Semantic release]: Load plugin verifyConditions from @semantic-release/github\n[Semantic release]: Load plugin verifyConditions from semantic-release-docker\n[Semantic release]: Load plugin getLastRelease from @semantic-release/last-release-git-tag\n[Semantic release]: Load plugin analyzeCommits from @semantic-release/commit-analyzer\n[Semantic release]: Load plugin generateNotes from @semantic-release/release-notes-generator\n[Semantic release]: Load plugin publish from @semantic-release/github\n[Semantic release]: Load plugin publish from semantic-release-docker\n[Semantic release]: Run automated release from branch master\n[Semantic release]: Call plugin verify-conditions\n[Semantic release]: Verify Github authentication\nunknown shorthand flag: 'e' in -e=[secure]\nSee 'docker login --help'.\n[Semantic release]: undefined docker login failed\nThe command \"npm run semantic-release\" exited with 0.\n```\nI would have never found out if I didn't get tweeted at.\n\nAnd to be clear, I would not want a GitHub issue for this. I don't subscribe to all opened GitHub issues, it's just way to many. I check them every once in a while. But if my build/release is failing, I want to get an email for that and fix it asap.. @sapegin do you have your 2FA set to auth-only or auth-and-writes? auth-and-writes doesn't work because it would prompt for a code on every automatic publish. Then the description is misleading though. It does work with 2fa, just not if you configure it to prompt for OTPs during publishing (that would be impossible). Better error reporting is tracked here: https://github.com/semantic-release/npm/issues/11. Updated the PR, should be good like this. Let me know if you have more feedback. I think this was a breaking change. The VS Code marketplace (and I assume lots of other registries) does not provide a gitHead field. This was working fine before but now it breaks with this error:\n[Semantic release]: An error occurred while running semantic-release: Error: The \"getLastRelease\" plugin output if defined, must be an object with a valid semver version in the \"version\" property and the corresponding git reference in \"gitHead\" property. Received: { version: '1.12.1' }\n    at Object.getLastRelease (/home/travis/build/felixfbecker/vscode-php-debug/node_modules/semantic-release/lib/plugins/normalize.js:44:13)\n    at <anonymous>\n    at process._tickCallback (internal/process/next_tick.js:188:7). Not talking about the npm plugin, but the vsce plugin: https://github.com/raix/semantic-release-vsce. Well as I understand it with this workaround the last release version would be determined from the marketplace, and then only the matching tag would be determined from git. Whereas the git plugin would do it all through git (not saying that is a big problem for me).\nBut it's still a breaking change, right?. @pvdlg what is the proper thing to do for plugins that work with registries that can get you the latest version, but not the gitHead? Should they take a dependency on @semantic-release/git and call that under the hood to resolve the commit ID that matches the version?\nI am assuming it is beneficial to resolve the version from the registry, otherwise we could just always use @semantic-release/git for all registries including npm. Which means we would have to split the process into two steps and in the best case not have to copy the code for resolving the commit ID.\nI would guess the vast majority of registries do not expose a gitHead field so this is an important issue to solve and communicate.. Let me ask the question then what the benefit is at all to get the last release from the registry? Why not always use the git plugin?. The only benefit I could see is have multiple getLastRelease map to the publish plugins, so that if for example the npm publish succeeded, but the github publish failed, the github publish will be retried because its getLastRelease is lagging behind. That would make the system a bit more error tolerant. But that is not what is currently implemented anyway and would also add complexity.\nWouldn't you still want the tag creation to live in the git plugin though? What if I want to make semantic-release work with Mercurial for example? Or use tag prefixes in a multi-package repo?. I really like the idea of this PR!\nOnly point I have is to not recommend imperatively installing dependencies in CI, because that prevents you from using tools like Greenkeeper and possibly many other tools/IDEs/... that read package.json. There really is no reason to not do it declaratively with a package.json.. I think in Travis you don't even need to define the script because Travis adds ./node_modules/.bin to the PATH.. Yeah I think so.\nThis guide is specifically targetting Travis, so I don't think adaption for another CI is a concern here.\nAnyway I just think that no deps should be installed imperatively in CI. I think it would be just as fine to just tell the user to add it to their devDeps with npm install --save-dev travis-deploy-once locally.. > You\u2019ll need to do ./node_modules/.bin/travis-deploy-once \"npm run semantic-release\", but that\u2019s not OS agnostic\nI don't see how that is not OS agnostic, especially in the context of Travis?\n\nI wonder if we should just go ahead and create stages from the beginning instead of installing the additional travis-deploy-once dependency?\n\nMy opinion on this is that build stages are the future, you can see every CI provider moving in that direction. And it's a great way to plug-in a release step that has its own environmental requirements (Node 8 etc) without touching the rest of the config at all.\nPolling the Travis API and keeping one arbitrary job alive indefinitely always felt hacky to me.. If CI is still involved (triggering a custom build etc) then what is even the advantage of the GitHub app vs. having a release step in CI as today? It sounds to me like it just makes things more complicated (the release build and the test builds are not connected in the CI UI, there are more points of failure, no UI to retry builds, no easy way to specify tokens, etc).\n\nThe goal of Semantic-release GitHub should not be to re-create a CI service.\n\nI agree, but what is the goal then? Deployment/Release/Continuous Delivery is a big part of what a CI service does. @boennemann I like your thinking in decoupling things, but what value does the GitHub app have over the current flow if it just triggers a CI build that needs to run semantic-release? What is better about it then just running that logic as part of CI as it works atm?. @travi these things are already possible with tools independent of semantic-release, like commitlint and cracks.\n\nWrite programs that do one thing and do it well.\n\nhttps://en.wikipedia.org/wiki/Unix_philosophy. This was running in CI so the commit must have existed. I cannot reproduce anymore because now the version was already published to npm. I also think a retry logic would be good here, given how annoying it is if you ever get into the state were it's released to npm but not to github. \ud83d\udc4e  on a @semantic-release/octokit-rest fork - timeouts should be easy enough to add in semantic-release and if there is experimental API to try out, that should not be semantic-release specific.. I don't know why it would be used in more than @semantic-release/github. All other modules should not be coupled to GitHub. Therefor imo another module sounds overly complicated.. In a system that involves network requests it's always a good idea to do retries with backoff.. The reason Travis works like that is so that you can still see the result of tests even if e.g. linting failed. Imo the docs should just use after_success again or build stages.. > We also try to release on @latest less often, and keep breaking changes on @next only for a longer time. This way we can release on @latest multiple breaking changes at once.\nWell I assume the goal of having an unstable (next) release channel is to have users try it out and report bugs before it gets promoted to stable (latest). But to have users try it out, plugins need to support it. That is hard when a plugin cannot be compatible with both versions at the same time. Plugins could of course also move to a next/latest release flow, but imo plugins shouldn't be required to have a release process as complicated as core, and plugins may want to use the next channel to test their own unstable features, not just to support the next unstable version of core.. I agree with @Arcanemagus. Even if you configure Travis to auto-cancel builds, I noticed it sometimes doesn't work. And you should always be able to rebuild an older build that failed without the release system tripping and therefor that build being broken forever. If the build is outdated, the best option would be if semantic-release noticed it and exited (not errors) to not override a newer release.. I have the same problem, this commit consistently fails: https://travis-ci.org/felixfbecker/vscode-php-intellisense/jobs/371814953\nThe next commit always passes.. What if origin is not the upstream remote (or there is no remote named origin)?. Ah, forgot to look in that repo.. Ah, that makes sense.\nThe only way I see to make this reliable is to reintroduce get-last-release plugins, and have semantic-release ask each publish step individually what its last release was, so some publish step might have to retry a previously failed publish while the other had succeeded and does nothing.. That would be amazing. I've needed to \"correct\" so many half-done releases in my time of using semantic-release.. I just met this again, the Chrome extension release failed because of a 503 Service Unavailable, leaving the Firefox extension released, but not Chrome, and not GitHub or npm (because the plugins happen to be specified in that order) and no easy way to retry only the missing releases.\n[8:08:53 PM] [semantic-release] \u203a \u2139  Start step \"publish\" of plugin \"semantic-release-chrome\"\n[8:09:18 PM] [semantic-release] \u203a \u2716  Failed step \"publish\" of plugin \"semantic-release-chrome\"\n[8:09:18 PM] [semantic-release] \u203a \u2716  An error occurred while running semantic-release: { HTTPError: Response code 503 (Service Unavailable)\n    at stream.catch.then.data (/home/travis/build/sourcegraph/browser-extensions/node_modules/got/index.js:123:13)\n    at process._tickCallback (internal/process/next_tick.js:68:7)\n  message: 'Response code 503 (Service Unavailable)',\n  host: 'www.googleapis.com',\n  hostname: 'www.googleapis.com',\n  method: 'POST',\n  path:\n   '/chromewebstore/v1.1/items/dgjhfomjieaadpoljlnidmbgkdffpack/publish?publishTarget=default',\n  statusCode: 503,\n  statusMessage: 'Service Unavailable',\n  pluginName: 'semantic-release-chrome' }\n{ HTTPError: Response code 503 (Service Unavailable)\n    at stream.catch.then.data (/home/travis/build/sourcegraph/browser-extensions/node_modules/got/index.js:123:13)\n    at process._tickCallback (internal/process/next_tick.js:68:7)\n  message: 'Response code 503 (Service Unavailable)',\n  host: 'www.googleapis.com',\n  hostname: 'www.googleapis.com',\n  method: 'POST',\n  path:\n   '/chromewebstore/v1.1/items/dgjhfomjieaadpoljlnidmbgkdffpack/publish?publishTarget=default',\n  statusCode: 503,\n  statusMessage: 'Service Unavailable',\n  pluginName: 'semantic-release-chrome' }\nhttps://travis-ci.org/sourcegraph/browser-extensions/jobs/418391161#L737. Thanks!. Sometimes I like to compose plugins for different steps in config, e.g. run only @semantic-release/npm for prepare to update a package.json, but then publish the package in a different way with @semantic-release/exec. Or not run the fail and success plugins of @semantic-release/github. How would that be supported in a world with the plugins option?. Oh, that makes sense. Why is this error not logged anymore?. Could a plugin have a different version of @semantic-release/error that makes this check fail? Would checking err.name work too?. why only log arg.stack? Afaik console.error() should log the stack of errors, but if the error has more metadata it will log that too. For example, child_process.exec() errors have an stderr property that gives you the actual error output of the command that failed, without this the error is often times useless. If a plugin has a dependency on @semantic-releae/error ^1.0.0 and this module has a dependency on @semantic-release/error ^2.0.0 the instanceof expression will always be false because it will be different classes, so this logic depends on the npm deduplication logic.. This is what a logged child process err.stack looks like:\nError: Command failed: git status\n    at checkExecSyncError (child_process.js:591:13)\n    at Object.execSync (child_process.js:631:13)\n    at repl:1:32\n    at ContextifyScript.Script.runInThisContext (vm.js:44:33)\n    at REPLServer.defaultEval (repl.js:239:29)\n    at bound (domain.js:301:14)\n    at REPLServer.runBound [as eval] (domain.js:314:12)\n    at REPLServer.onLine (repl.js:440:10)\n    at emitOne (events.js:120:20)\n    at REPLServer.emit (events.js:210:7)\nThis is what console.error(err) looks like:\n```\n{ Error: Command failed: git status\nfatal: Not a git repository (or any of the parent directories): .git\nat checkExecSyncError (child_process.js:591:13)\nat Object.execSync (child_process.js:631:13)\nat repl:1:32\nat ContextifyScript.Script.runInThisContext (vm.js:44:33)\nat REPLServer.defaultEval (repl.js:239:29)\nat bound (domain.js:301:14)\nat REPLServer.runBound [as eval] (domain.js:314:12)\nat REPLServer.onLine (repl.js:440:10)\nat emitOne (events.js:120:20)\nat REPLServer.emit (events.js:210:7)\n\nerror: null,\n  cmd: 'git status',\n  file: '/bin/sh',\n  args: [Array],\n  options: [Object],\n  envPairs: [Array],\n  stderr: 'fatal: Not a git repository (or any of the parent directories): .git\\n',\n  stdout: '',\n  pid: 1492,\n  output: [Array],\n  signal: null,\n  status: 128 }\n``\nThe former log doesn't help, the latter does because the important metadata (stderr`) is included.\nThis was an actual real life situation: https://github.com/semantic-release/semantic-release/issues/477\nTook me forever to find out what went wrong\nThis is just an example, it's quite common to attach more metadata to properties, e.g. when wrapping (an)other error(s)\njs\nthrow Object.assign(new Error('Multiple other operations failed'), { errors }). what is %s expanding to for an Error instance? error.toString()? As mentioned in another thread, it should include error properties. since you use %s, would this not print the error twice? Instead of this handling, why not simply log like this:\njs\nlogger.error('An error occurred while running semantic-release: ', err)\n(no %s). Yeah, realised that later down. Seems redundant though to log the message twice?. console.log/console.error support format strings and arbitrary structures which result in being util.inspect()ed. It behaves differently depending on whether the first argument is a format string or not, which changes the semantic of the rest arguments.\nThis logger seems to only support the format string mode, and I assume chalk.yellow() implicitly converts the argument to a string ala toString(), so for arbitrary structures it would just print [object Object].\nI would make it behave like the native console as in not add custom handling of errors, but of format strings if that is needed.. console.log() will check if the first arg contains any format sequences, not just if it's a string. I.e. these two act different:\njs\nconsole.log('an error occured: ', err)\nconsole.log('an error occured: %s', err). also here's one idea: why not simply wrap all format sequences with chalk? I.e.\nts\nif (typeof format === 'string') {\n  format.replace(/%[^%]/g, seq => chalk.magenta(seq))\n}. > console.log('an error occured: ', err) will log err as an object (with stacktrace etc)\nAre you sure? As I understand the code this will wrap err in chalk.magenta() because the first argument is a string and it doesn't check whether it actually contains a format sequence like console does.. What we need here is a common interface to be implemented by all errors that should not cause the build to not fail / are \"expected\". This could be\n- common name that is always SemanticReleaseError, even for subclasses\n- a property like expected: true\n- a property exitCode: 0 (this is non ideal because ChildProcess errors have an exitCode property)\n- .... I think it should also be mentioned that if you're using Travis build stages, you have the freedom to specify a separate node version for that stage anyway. Not sure what the advantage of that would be. You still need to install semantic-release, so you need to declare the dependency. You could just install it imperatively in CI of course but then you can't use Greenkeeper/dependencies.io/Renovate to update your deps. And given PHP is primarily used for web applications I think PHP people are familiar with npm/package.json for frontend frameworks.. Yeah you're right. Imo that is not really feasible for any medium-sized project and not the convention at least from what I've seen in build setups (TS, webpack, Babel, ...). When developing, you want to use the watch mode of your build pipeline. Running another build before every test run is just wasted time (it could be anywhere between a few seconds to over a minute). Travis also collapses each command separately so it's easier to see what command actually failed. I think it would also make the example a bit more complex because I would have to highlight that in package.json.\nIn general, this is just a recipe and as such you are of course always free to not follow it 100%. All of these are mostly directly copied from real projects.. I think tools like lint-staged and husky are great for catching lint errors before pushing but CI always needs to repeat the steps and it's kinda out of scope for this example. This is just copied from a real project where linting takes a significant amount of time that you don't want to spend on every test run.. That would make the build irreproducible and prone to breakage. What if semantic-release doesn't work with the next major Node version? I would rather recommend to use the LTS version. Then after all test jobs succeeded on a PR, Travis would spin up a container for the release stage, install the correct Node version, install dependencies, just so condition-travis notices it is on master and doesn't need to run - wasting build time. Seems pointless?. Yeah wasn't sure about this one. I prefer it too but some people may be confused if their branches don't build. The CLI generates the except config so I chose that. Not Node 8 though, you'd have to run nvm install 8; nvm use 8 first, and then npm install. I think using build stages lowers the barrier especially for any non-JS project because you can just \"drop in\" that totally isolated release stage that is completely independent of the rest of your build config.. Yeah it's a good idea to mention it.\nHow would Greenkeeper+npx work? Do you have an example?. Not afaik because npx was introduced in npm 5. Also are you sure that every image has Node preinstalled?. I don't think that would look better, because the headings would have no indentation when rendered. This is intended to be a ToC. Not really till https://github.com/semantic-release/condition-travis/issues/96 is resolved, right?. Yeah, that's what I meant. Just using npx in .travis.yml without package.json won't work with updates.\nI disagree that it is only relevant for Node apps. Any user who uses semantic-release may want to auto-update semantic-release. There are also tools like dependencies.io or dependabot that work for both Node/npm and PHP/Composer, so there would be no reason not to use it for both in a project.\nSo imo using a package.json is a better practice to recommend.. I wanted to highlight that you must not forget to run build again in the release step if you have a build process. I've forgot to do that a couple of times and ended up releasing uncompiled packages. Yeah, that would be a valid use case that could fit into a recipe.. Did you mean to add -g here?\nWhy would we want to recommend this approach given it's disadvantages (no Greenkeeper support etc)?\nShould in any case have a version requirement so it's not breaking folks on a major release\n  . I would always pin this to a specific major version, e.g. 8. Otherwise if a new major version becomes lts this would break the build.. I think it makes sense to mention that you can just install it globally in CI if you don't want a package.json, but stating the user needs to is misinformation.. Wouldn't it be much easier to just use --ignore-engines? That makes it behave like npm (only print warnings). Sure, the latest version of semantic-release guarantees that. But if a project is on an older pinned major version of semantic-release (which it should be for reproducable builds) then a new LTS release can break the build.. I think it does matter because the Travis UI will show better what is going on, vs having the first job pending until all jobs completed. And it is more reliable than polling for sure.. Keeping this now that condition-travis is not run by default anymore. So this section is reserved for \"blessed\" plugins? Why hide community plugins away on a different page?. That would trigger a release build on every branch or PR build, spin up the container, checkout code, npm install, block the build queue, report a GitHub status check for that specific build etc, just to have semantic-release figure out that it shouldn't do anything. Why not include these 3 lines in the example that users will copy+paste?. I am not sure what you would want it to look like - only have a release step? Imo in opposite to documentation, recipes should be examples that can be copy+pasted and then modified if needed. They should examples show how the general documentation can be adapted for specific projects, more as inspiration than a guarantee to work for every project.. So to be clear, you would want the PHP/Composer link to stay here but the VSCE and Docker links to be moved? Imo that is not very user-oriented, because as a user I just want a single place where I can find out how to get semantic-release working with my package manager . We seem to disagree on this but imo if you don't use the benefits of build stages (separate stages that can be filtered by Travis) then you might as well not use build stages at all. So if the recipe doesn't show a good example of how build stage features can be utilised, I don't really see a point in having this recipe at all. This is exactly the things that took me hours of tinkering, digging docs and failed attempts to figure out that I would like to share with others so they don't have to go through that (for example, who knew all PR builds have branch set to master?).. > Can you remove npm run build in order to be consistent with other docs and to keep it focused on what's required to run semantic-release?\nPartly repeating what I mentioned in other comments, I see the value of recipes in showing off examples of end-to-end solutions that can often be copy+pasted and would rather have a bit to much than not enough (removing is always easy). Forgetting to run the build script before releasing specifically is one of the biggest pitfalls when migrating to build stages, that has tripped me multiple times (resulting in empty broken releases to users), that I would like others to be aware of.\n(Note that I added the prepublishOnly script approach too)\n\nAlso can you mention both global and local install?\n\nWill do. How about adding \"(community plugin)\" after the community plugins in this list?\nFWIW gulp highlights almost exclusively community plugins in their recipes. . if this command fails too, could you log the output?. ",
    "accraze": "Hi, I'm interested in giving this a shot...\n. no worries @boennemann! can you make a repo for it?\n. ",
    "apowers313": "Seeing as it's automated, I don't see any harm in doing it in semantic-release too.\nIstanbul has a json-summary reporter that kicks out a report in the following format:\njson\n{\n  \"total\": {\n    \"lines\": {\n      \"total\": 3,\n      \"covered\": 3,\n      \"skipped\": 0,\n      \"pct\": 100\n    },\n    \"statements\": {\n      \"total\": 3,\n      \"covered\": 3,\n      \"skipped\": 0,\n      \"pct\": 100\n    },\n    \"functions\": {\n      \"total\": 1,\n      \"covered\": 1,\n      \"skipped\": 0,\n      \"pct\": 100\n    },\n    \"branches\": {\n      \"total\": 0,\n      \"covered\": 0,\n      \"skipped\": 0,\n      \"pct\": 100\n    },\n    \"linesCovered\": {\n      \"7\": 3,\n      \"8\": 3,\n      \"9\": 3\n    }\n  },\n  \"/private/tmp/open-element-template/test.js\": {\n    \"lines\": {\n      \"total\": 3,\n      \"covered\": 3,\n      \"skipped\": 0,\n      \"pct\": 100\n    },\n    \"statements\": {\n      \"total\": 3,\n      \"covered\": 3,\n      \"skipped\": 0,\n      \"pct\": 100\n    },\n    \"functions\": {\n      \"total\": 1,\n      \"covered\": 1,\n      \"skipped\": 0,\n      \"pct\": 100\n    },\n    \"branches\": {\n      \"total\": 0,\n      \"covered\": 0,\n      \"skipped\": 0,\n      \"pct\": 100\n    },\n    \"linesCovered\": {\n      \"7\": 3,\n      \"8\": 3,\n      \"9\": 3\n    }\n  }\n}\nMaking this work would require:\n1. Using Istanbul for code coverage\n2. Ensuring that json-reporter was enabled as a reporter\n3. Having a configuration option for the plugin that points to the coverage directory\n4. Having a configuration option for the passing threshold \nThe semantic-report plugin would read in {{coverage}}/coverage-summary.json, compare {{threshold}} to the total coverage for lines, statements, functions and branches and return true if the coverage is greater than or equal to the threshold.\nOne question -- is there a way for a plugin to send a failure notification (email, slack, etc.) so that a minimal amount of time is spent trying to understand why a release didn't go out? Doesn't seem like every plugin should write their own notification mechanisms...\n. Is the assumption for verifyConditions that if the callback has an error the condition fails; otherwise, the condition succeeds?\n. If you were to implement Istanbul as a verifyConditions script, wouldn't that mean that you would have to run the test suite twice -- once during Travis's npm test and once during semantic-release's verifyConditiions? If that's the case, it might be too much overhead for large test suites...\nI like checking Istanbul coverage during semantic-release because 1) it won't mark the build as failing if coverage thresholds aren't met; 2) all of the release requirements are managed by a single decisioning engine, rather than trying to figure what is breaking and where; 3) it simply stops a release if coverage is insufficient, which seems like the most appropriate (and semantically correct) action.\n. hi @kentcdodds -- I was just trying to figure out how to get semantic-release to push to Bower when I came across this post. Do you have some code you can share?\n. @christophwitzko Ah, now it makes sense why nobody else was running into this issue. Thanks for the help.\nI'm actually using it as part of a template where I would expect others to run semantic-release-cli as part of the npm post-install process. I'll fix up the .travis.yml as part of my install process -- you can close out this issue.\nOn an unrelated topic, I found the undocumented use of keytar extremely disturbing when I realized that semantic-release-cli had saved my passwords without mentioning that was going to do so in the README or mentioning it as part of install script. The README doesn't even mention the command-line option for --no-keychain. I would advocate for defaulting keychain to false and updating the README. Happy to submit a PR if you guys are open minded to that.\n. Looks good to me, thanks for the consideration.\n. ",
    "satya164": "nyc will be a better choice as it also supports test runner which run tests in subprocesses.\n. @remy Tried several repos, and same result. I've 2 factor authentication enabled, if that helps.\n. @boennemann Any idea? I'll really love to use this.\n. @tusharmath I'm stuck at initial set up in any repo. Travis doesn't come into picture.\n. I've not been able to repro this for quite some time. Closing.\n. ",
    "saiichihashimoto": "I'm really confused as to the value of this (or #67, for that matter). From what I gather, semantic-release is about automating package publishing. And in continuous integration, it makes sense for the build to fail before we reach this point if our tests fail. Don't we want the tests (and ultimately, the build) to fail if the coverage is too low?\nPerhaps the purpose of semantic-release isn't defined well enough. From what I understand, semantic release:\n- Examines the package, determining if it's the right situation to release and, if it is, determining the version to release.\n- Doing the actual release\n- Creating documentation and git tags\nIt doesn't look like semantic-release should reinvent running tests. That can (and currently should be) run before semantic-release and fail the build if they don't pass. The exceptions to this would be running cracks or #65 but even those are running tests to determine what the next version should be: a job of semantic-release.\nTLDR If coverage should abort the release, isn't the best way to fail the build, just as failing tests would?\n. Let's close it. ",
    "phra": "@saiichihashimoto i'm exactly doing that. in an agile environment, every commit should be able to be promoted to master without disasters, so if the coverage is not correct, the commit itself should fail.. ",
    "Aghassi": "@pvdlg If #836 is still accurate and can be merged, I can probably take a pass at writing a generator that scaffolds based off of generator-node above and then adds life cycle files for semantic release plugins, as well as a basic context or something. This is probably easiest once there is a straight forward doc on how plugins are meant to be built.. @jhnns Any update as to when https://github.com/peerigon/parse-domain/pull/39 will be merged?. I'm actually not \ud83d\ude05 . I could use execa, but I was trying to be a little more native than that since you already return a Promise and I didn't want to Promise chain if I didn't have to. My code is just this:\njavascript\n      {\n        title: 'Releasing via semantic-release...',\n        skip: () => program.manual,\n        task: () => {\n          // Use observable to get pretty spinner while Semantic Release Runs\n          from(semanticRelease({ dryRun: program.dry, noCi: !process.env.CI, isCi: process.env.CI }));\n        }\n      },\nAnd at the top I just do\njavascript\nimport { from } from 'rxjs';\nimport semanticRelease from 'semantic-release';. To add to this, it looks like this also writes the results directly to the stdout stream\nhttps://github.com/semantic-release/semantic-release/blob/45eee4acdd2a213672466369bcf0a04cd39ee0e1/index.js#L106\nThat means that if there is a --silent option, this would have to be handled too since it doesn't go through the normal logger.. Looks cool! What would it take to get this going? Anything I can do to help?. Just as a note, until this is fix, I wanted to post my work around for now. For now, I used https://www.npmjs.com/package/intercept-stdout to hijack the console output temporarily and then log it later when I wanted to use it. Anyway, thanks again! Looking forward to when there is an official logger \ud83d\ude04 . @pvdlg Yeah that looks like it will work. That allows me to at least modify the stream before presening \ud83d\ude04 . @pvdlg Don't disagree. Just looking at ways to avoid rewriting history to trim the size of the repo. Would mean all our contributors would need to force reset their masters etc and cherry pick their features. It's just a bit of a massive headache which is why I posed this question. Is there a way semantic-release can leave a \"trail\" of when the last time it was run, and use that as the shallow clone depth? So parse the git log backwards till you find the last release?. I understand there may be issues on multiple branches, I'm just trying to see if there is a flexible medium (I am by means no expert in the area).. I'm surprised. It seems tagging supports dates according to this https://git-scm.com/docs/git-tag#_on_backdating_tags to some extent. Also, tags are associated with commits right? Could we not infer the date from the time of the commit?\nUnfortunately, dates make everything difficult. \ud83d\ude1e \nPardon my questions, I still have a lot to learn in this area and wanted to best understand the problem before fully conceding this isn't possible \ud83d\ude05 . Nope. I can't really think of anything either... Thanks anyway \ud83d\ude04 . Yeah I was waiting on v16 to be able to do the pre-releasing, because that would solve my issue. I'm hesitant to take it in because I don't want to be caught in the middle of breaking changes. Also, there are no docs on how to use that yet are there? I need to learn more to understand how one can do pre and regular releases without issue.. ",
    "rodneyrehm": "+1\n. ",
    "finom": "Any news about this issue?\n. @hbetts this was awesome idea. Unfortunately semantic-release looks dead :(\n. @gr2m I didn't say it is dead I said it looks dead. This is the great project as MVP but it needs to be rewritten from scratch or at least make big refactoring, dependencies update, issues review. I guess you like it because you use it as described at tutorials but I'm trying to customize it for my needs (for example I'm that guy who use plugins). I'm going to use it in some open source projects too but only because I have no alternatives.\n. @gr2m I can't say I'm in because mostly I'm busy with my own projects but I'm going to look on how is going and maybe provide something useful for the project. \n. To keep a bundle up to date somewhere I have created a little script that deploys it to given branch. It's more useful for me than custom uploads because I can use bundled files directly with gh-pages. This also allows to modify generateNotes script to mention that branch in release description. I'm not sure does README describe the tool nicely, let me know if you have suggestions.\nP. S. I have spent really long hours on a research of how to deploy a bundle of a library and I found deploying to a branch of the same repo as the most useful and universal (considering that I don't like branches with different commit history).\n. The same bullshit there.  Have no idea why does it appear. I even tried to publish a package manually but this gives no progress.\n. I just made a plugin for it.\n. @justmoon the error means that somewhere semantic-release code requires non-existent module.\n. Another issue is there. Closing this one.\n. A solution looks similar to this:\n``` js\nconst { gitHead } = data.versions[version];\nif(!gitHead) {\n  return cb(new SemanticReleaseError(\n\nNPM registry does not contain \"gitHead\" in latest package version data.\nIt's probably because somebody is made publish outside of repository folder.,\n      'ENOGITHEAD'))\n    }\ncb(null, {\n  version,\n  gitHead,\n  get tag () {\n    npmlog.warn('deprecated', 'tag will be removed with the next major release')\n    return npm.tag\n  }\n})\n\n```\n(not doing pull req because have no time to make tests)\n. Not sure.\n. Nice to see the project to be maintained.. ",
    "conblem": "Any News on this?. @gr2m Cool stuff! would love to see a example in conjunction with semantic-release :blush:. ",
    "quarterto": "Ok, thanks. I've added another script that runs semantic-release pre || true.\n. ",
    "JamieMason": "I could really use this for the project I'm working on. If there's anything I can @johann-sonntagbauer @boennemann to help, please let me know.\nThanks.\n. ",
    "kachkaev": "Hi guys. Are there any plans to merge this? I'm currently looking for a solution to publish to a private npm registry via GitLab CI. Given that there has not been much activity for quite long on this, maybe there is some other stable solution for GitLab CI users? \nUPD: I've seen semantic-release-gitlab, but still wondering if its a common way to go.\n. ",
    "relekang": "Commenting on issues would also be pretty nice.\n. ",
    "eliias": "Yep. A plugin does make total (more) sense than adding arbitrary options for an unspecified repository host. I was not ware of any github-release plugin plans. Beside that, it would allow to add all the other release options to the plugin too. Ping me if you need a hand.\n. ",
    "hafeez-syed": "@gr2m no, I had to re-install my windows and re-install python and MS Visual Studio 2013 to make it work\n. ",
    "shairez": "+1\n. Thanks for the quick reply @gr2m !\nHere is my experience:\ntried uninstalling and reinstalling - didn't work\ntried upgrading to latest npm - didn't work\nI'm on Windows and I get the same error for node-gyp\nFirst it complained about missing \"python\", I installed it, now it is complaining about .NET 2.0 SDK\nI see this error with other projects, but usually it doesn't stop the install.\nIs there a way to maybe npm install the pre-release version (0.6.x) of this project? just to test it out to see if it solves it?\n. Well, after reading here - \nhttps://github.com/nodejs/node-gyp, \nI've installed the express version of .net tools -\n(http://www.microsoft.com/en-gb/download/details.aspx?id=44914 \nand it solved the install issue.\n. ",
    "cakarci": "+1\n. finally, this solved the problem. Thanks\nOn Wed, Sep 23, 2015 at 1:14 PM, Shai Reznik notifications@github.com\nwrote:\n\nWell, after reading [here[(https://github.com/nodejs/node-gyp), I\ninstalled the express version of .net tools\nhttp://www.microsoft.com/en-gb/download/details.aspx?id=44914 and it\nsolved the install issue.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/semantic-release/semantic-release/issues/92#issuecomment-142555973\n.\n. \n",
    "oneezy": "My related issue #344 , just seeing this... ",
    "ericdouglas": "Great, @boennemann ! Many thanks :smile: \n. ",
    "Apidcloud": "Is there any way to release on GitHub under the same dist-tag? as mentioned in https://github.com/kentcdodds/ama/issues/318\nThanks!. At least as a substitute just like what happens over npm. Despite using a dist tag (publishConfig field) such as beta, GitHub keeps using a number as the version (tag).. Please check the changes \ud83d\udc4d I'm still not sure how to test it thoroughly though.. After some struggle, I think I got it. It's deleting and creating a new one when it already exists.\nYou can check the builds here: https://github.com/Apidcloud/node-fusionchart-demo\nOr just https://travis-ci.org/Apidcloud/node-fusionchart-demo\nPlease also give it a try and let me know what you think.. The first idea was to mirror what happens over npm when releasing under a custom tag (say alpha).\nBut as the GitHub behaviour is rather different, the purpose of this PR is to create a 2nd tag (when defined) that points to the same release. Doesn't have to be next.\nLet me know your thoughts!\nThanks!. TLDR:\nI guess what I wanted was the ability to do the release under an alpha or beta tag (dist-tag) just like what happens over npm.\nOk. I'll try to explain it based on what I wanted (and still want) to accomplish.\nI'm developing some packages that aren't ready for production use. With the current semantic-release version, when it comes to npm releases, I'm able to do it under a beta or alpha tag. \nIn GitHub the behaviour is different. There's just a numerical version (e.g., v0.4.0) as explained in the issue https://github.com/semantic-release/semantic-release/issues/97 by @gr2m:\n\nbut only npm gets the beta/next/custom tag\n\nWhat I originally wanted was to mirror what happens in npm, so I suggested  mixing the GitHub tag with the custom tag (e.g., v1.0.0-alpha) and make the release with that. But I think that's not acceptable for you, is it?\nThen the idea was to create a 2nd tag (custom tag, only when defined) reference that points to the same numerical release.\nDoes that make sense? I'm not sure myself anymore.. Thank you for the wonderful explanation and link. I think I understand it better now.\nWould the migration to latest dist channel be done manually though? And should this PR focus on creating a pre release in GitHub when the dist tag is next and the pre release is set to true? (Is this flag even needed? Shouldn\u2019t it happen by default as the tag is next?)\nThanks again! I\u2019ll try to take a look tomorrow.. It might be better to create another PR then. And just to make sure, it would address the following:\n* A custom tag other than latest+ pre-release flag mark the GitHub release as pre-release.\nDoes that sound ok?. Ok. Where would that branch config be placed? Inside publishConfig?. > Maybe an option with that can accept a string or an array of string that defines the branches the branches on which we don't do a non pre-release. If this config is not present, then we consider it's ['latest'] by default.\nShouldn't it be ['master'] by default? I mean, shouldn't we compare it to the branch name instead of the dist tag? Not sure since you mentioned 'branch'.\nAlso, what do you think of naming the flag no-pre-release instead?. I've just created another PR. I believe this one might be closed.. I think it should be much cleaner now \ud83d\udc4d\nAll there's left is to check whether the module is called correctly within post. How should I do that? I wonder if I can do it with spies. Any suggestions?. I have addressed (all of?) the minor formatting issues you mentioned, added a description of this new option to the documentation and squashed everything into 1 commit.\nWere you able to test this on a real repository? I believe it works, but Travis starting caching my fork project dependency (??) and was unable to test further.\nLet me know if everything's ok \ud83d\udc4d . Alright \ud83d\udc4d . Can you test going out of pre-release again? That's the one thing I wasn't able to. \nAlso, for now, we'd need to run the following command in order to go back to latest, right? Otherwise, it will raise an error saying there's already a published version.\n\nnpm dist-tag add my-package@2.0.0 latest\n\nThanks for the opportunity and advice \ud83d\udc4d . Makes sense. The third solution might be easier/better (at least for now) as it gives that responsibility to the users to change from other dist tags to latest before publishing a new version on npm. . Sorry for the delay guys. I'll try to do the changes on the weekend \ud83d\ude04 . Finally made the changes \ud83d\ude05. Let me know if I can squash the commits and/or rebase caribou branch.. No problem \ud83d\ude04 Let me know how it goes!. Thanks a lot \ud83d\ude04 I'll be sure to use twitter or something next time!. Not sure I understand the first part. Shouldn't it match with release.tag_name and release.name?. I was about to, but it raises the error I mentioned even without the changes. What do you recommend to fix that? . ah, so this line would be kept in v1.2.3 format and only the release one changes if publishConfig is present?. Hmmm that's weird. I forked and just ran npm install and npm test. Do I need anything else?. Log: https://pastebin.com/HARMnXg5. Alright, just updated to node 8.5 and npm to 5.3 and it seems to be the cause. It still raises the following error though: https://pastebin.com/PPDfSnz3\nCould that one be related with couchdb?. I've installed it, and it's running in http://localhost:5984/_utils/ but I'm not sure what else I need to set it up for the tests. couchdb doesn't work in the terminal despite being added (manually) to the path environment variable (windows).. Still doesn't seem to work. I will try with a different couchdb version tomorrow, as running couchdb is producing some weird output (kernel-poll not supported).  Probably some windows black magic going on here \ud83d\udc83 . It seems to be a problem with privileges in Windows... Still trying to figure out a solution.\nEither way please check my other comment, related to the tags \ud83d\udc4d . So I just need to create an additional reference (github.gitdata.createReference) when publishConfig.tag is present, and the release (github.repos.createRelease) shouldn't be changed, right?. This part makes sure the reference (tag) doesn't exist when we create it, otherwise, it throws an error. But on a first glance, I believe I forgot to check whether the custom tag was defined in the first place.. Exactly, and thus deleting it when that's the case. There might be better ways to do so, though.. Yeah, I wasn't sure how to test it. Can give it another try though.. I agree with you. Originally I thought the same tag could have multiple versions within, but I believe that's not possible and thus the need of replacing it.\nWould next/v2.0.0 as you mentioned earlier make more sense?. maybe this should come after deciding whether it's a pre-release or not. since we are still deciding the value of a release property (prerelease). How do I check whether it was manually set or not in this case?. Thought you mentioned that it shouldn't pre-release when set to 'latest' by default.. Not sure how to do it here. Can you help?. I'm trying that at the moment. Is there any good way of debugging these tests? Or at least a way of printing something to the console.. ",
    "SteveALee": "OK, thanks. I guess it's not masses of work making it a NPM package as well :)\n. ",
    "alejandronanez": "``` shell\nusr/local/lib/node_modules/semantic-release-cli/dist/lib/travis.js:42\n    if (res.user.is_syncing) {\n           ^\nTypeError: Cannot read property 'user' of undefined\n    at /usr/local/lib/node_modules/semantic-release-cli/dist/lib/travis.js:42:12\n    at /usr/local/lib/node_modules/semantic-release-cli/node_modules/travis-ci/lib/travis-ci.js:51:21\n    at Request._callback (/usr/local/lib/node_modules/semantic-release-cli/node_modules/travis-ci/lib/travis-http.js:49:13)\n    at Request.self.callback (/usr/local/lib/node_modules/semantic-release-cli/node_modules/travis-ci/node_modules/request/index.js:148:22)\n    at emitTwo (events.js:87:13)\n    at Request.emit (events.js:172:7)\n    at Request. (/usr/local/lib/node_modules/semantic-release-cli/node_modules/travis-ci/node_modules/request/index.js:886:14)\n    at emitOne (events.js:82:20)\n    at Request.emit (events.js:169:7)\n    at IncomingMessage. (/usr/local/lib/node_modules/semantic-release-cli/node_modules/travis-ci/node_modules/request/index.js:837:12)\n```\nThis is what I'm getting on my console after waiting for a long time.\n. @boennemann @christophwitzko I haven't signed up for Travis and that was causing the problem. We still need to handle that scenario though.\n. ",
    "joshmanders": ":+1: Had a bunch of trouble getting semantic-release working until I realized \"repository\": \"npm/npm\" was the problem.\n. ",
    "hawkrives": "I suppose that now that #119 has been merged, I should take another look at this and see what else needs to happen to do it.\n. I don't think I use semantic-release for any projects currently, sorry! If you say it works for those shorthands, that's good enough for me! I believe that my original request is satisfied. . I think I've just rebased. Fingers crossed that the tests still pass.\n. Thanks!\n. ",
    "olalonde": "Tried this in package.json:\n\"release\": {\n    \"debug\": false,\n    \"verifyConditions\": \"semantic-release/dist/lib/plugin-noop\"\n  },\nBut now getting an error at the semantic-release post step:\n``` bash\n$ npm run semantic-release                               master\n\nbitstore@1.1.0 semantic-release /abc/bitstore-client\nsemantic-release pre && npm publish && semantic-release post\nbitstore@1.2.0 prepublish /abc/bitstore-client\nbabel ./src --out-dir ./lib --copy-files\n\nsrc/cli.js -> lib/cli.js\nsrc/index.js -> lib/index.js\n+ bitstore@1.2.0\nGenerating changelog from v1.1.0 to HEAD...\nParsed 1 commits.\nsemantic-release ERR! post Failed to publish release notes. { [Error: {\"message\":\"Validation Failed\",\"errors\":[{\"resource\":\"Release\",\"code\":\"custom\",\"field\":\"tag_name\",\"message\":\"tag_name is not a valid tag\"},{\"resource\":\"Release\",\"code\":\"custom\",\"message\":\"Published releases must have a valid tag\"},{\"resource\":\"Release\",\"code\":\"invalid\",\"field\":\"target_commitish\"}],\"documentation_url\":\"https://developer.github.com/v3/repos/releases/#create-a-release\"}]\nsemantic-release ERR! post   message: '{\"message\":\"Validation Failed\",\"errors\":[{\"resource\":\"Release\",\"code\":\"custom\",\"field\":\"tag_name\",\"message\":\"tag_name is not a valid tag\"},{\"resource\":\"Release\",\"code\":\"custom\",\"message\":\"Published releases must have a valid tag\"},{\"resource\":\"Release\",\"code\":\"invalid\",\"field\":\"target_commitish\"}],\"documentation_url\":\"https://developer.github.com/v3/repos/releases/#create-a-release\"}',\nsemantic-release ERR! post   code: 422 }\n```\nand now getting a new error...\n. Any chance to get feedback on this PR?\n. The reason I need this is I only want to use the part of semantic-release which guesses what should be the next package version as part of a different publish flow (without all the other stuff).\n. Oh great, thanks. Wish I had found out about this earlier!\n. ",
    "jimthedev": "As it turns out, you actually need something more like this since the path used is relative to the cwd (which typically in CI is your project root):\n\"release\": {\n    \"debug\": false,\n    \"verifyConditions\": {\n      \"path\": \"./node_modules/semantic-release/dist/lib/plugin-noop.js\"\n  }\n}\n. We use it on Commitizen. Just a heads up that semantic-release-monorepo (unrelated to semantic-release, despite the name) is broken due to this change in the plugins structure since it monkey patches the plugin ecosystem. I know there's been a lot of conversation on the tradeoffs of having monorepos and semantic release but figured I would submit for visibility https://github.com/Updater/semantic-release-monorepo/issues/65 . ",
    "mrself": "My github repo was git+git@github.com:mrself/ instead of git+https://github.com/mrself/. I think I did not notice it when run npm init\n. ",
    "dustinws": "Hello, I haven't been able to get to the bottom of it, but I've narrowed it down to a system issue. It's safe to close this out, thanks!\n. Unfortunately that still didn't fix mine. It can't find the \"gnome-keyring-1\" package. I'm running Debian Jesse, so maybe I need a slightly different package? Will look in to it later tonight. Thanks!\n. ",
    "joefitzgerald": "@dustinws can you elaborate on what the system issue was? /cc @thomasjo\n. Ahh, yes, thanks @thomasjo.\n. ",
    "thomasjo": "@joefitzgerald His system didn't have the gnome-keyring library installed;\n\n[..] Package gnome-keyring-1 was not found in the pkg-config search path [..]\n. \n",
    "heydemo": "Had to apt-get install libgnome-keyring-dev on ubuntu 14.04 to fix this\n. ",
    "afirdousi": "What do Windows users do for a similar situation ? \"gnome-keyring\" is Linux based.\nI have opened a similar issue 131\n. For anyone who is stuck with the same issue in a similar environment, I haven't found the solution yet but if you try to install a specific older version of semantic-release, it might work. Following worked in my scenario\n\nnpm install semantic-release@1.0.3 -g\n\nThis is not a solution so please do not close this issue until we find a proper way out of this.\n. ",
    "Guria": "apt-get install libgnome-keyring-dev does not helps me as well.\n. It is in secured travis environment variables. ",
    "davincho": "In my case it helped. I am running Ubuntu 15.10 with Gnome 3.\n. ",
    "zkochan": "Would be nice to have a note about this issue in the Setup section until its fixed. I had the same issue, Ubuntu 15.10\n. It would be terrific if it would be possible to use semantic-release together with lerna\n. Some tools need the version in the package.json. For instance, this tool (update-notifier) checks whether the package has a newer version and notifies the user if there is one. It is very useful for CLI tools. I myself would love to use it in my package (mos) but cannot because I use semantic-release, which removes the version from the package.json\n. oh, I just realized, the tool will actually work when installed. The version is added before publish. The problem is just when running the package from a local repo\n. ",
    "Rambou": "a solution is to install \nfor Debian/Ubuntu\n\nsudo apt-get install libsecret-1-dev\n\nin order to work. at least worked for me. Its a keytar problem so look this too https://github.com/atom/atom/issues/1948#issuecomment-42344415. ",
    "ds82": "Thanks for clearing that up! That should work for us.\n. ",
    "mdreizin": "@boennemann Thanks a lot for your help. I migrated to https://github.com/alrra/travis-after-all. Not it works fine. Thanks again for semantic-release.\n. @boennemann Did you have a chance to look at this PR?\n. ",
    "egoroof": "It is so sad :disappointed_relieved: \n```\nE:\\Dropbox\\repo\\browser-id3-writer>npm install semantic-release-cli -g\nC:\\Users\\\u0410\u0440\u0442\u0451\u043c\\AppData\\Roaming\\npm\\semantic-release-cli -> C:\\Users\\\u0410\u0440\u0442\u0451\u043c\\AppData\\Roaming\\npm\\node_modules\\semantic-release-cli\\bin\\semantic-release.js\n\nkeytar@3.0.0 install C:\\Users\\\u0410\u0440\u0442\u0451\u043c\\AppData\\Roaming\\npm\\node_modules\\semantic-release-cli\\node_modules\\keytar\nnode-gyp rebuild\n\nC:\\Users\\\u0410\u0440\u0442\u0451\u043c\\AppData\\Roaming\\npm\\node_modules\\semantic-release-cli\\node_modules\\keytar>if not defined npm_config_node_gyp (node \"C:\\Program Files\\nodejs\\node_modules\\npm\\bin\\node-gyp-bin\\....\\node_modules\\node-gyp\\bin\\node-gyp.js\" rebuild )  else (node  reb\nuild )\ngyp ERR! configure error\ngyp ERR! stack Error: Can't find Python executable \"python\", you can set the PYTHON env variable.\ngyp ERR! stack     at failNoPython (C:\\Program Files\\nodejs\\node_modules\\npm\\node_modules\\node-gyp\\lib\\configure.js:116:14)\ngyp ERR! stack     at C:\\Program Files\\nodejs\\node_modules\\npm\\node_modules\\node-gyp\\lib\\configure.js:71:11\ngyp ERR! stack     at FSReqWrap.oncomplete (fs.js:82:15)\ngyp ERR! System Windows_NT 10.0.10586\ngyp ERR! command \"C:\\Program Files\\nodejs\\node.exe\" \"C:\\Program Files\\nodejs\\node_modules\\npm\\node_modules\\node-gyp\\bin\\node-gyp.js\" \"rebuild\"\ngyp ERR! cwd C:\\Users\\\u0410\u0440\u0442\u0451\u043c\\AppData\\Roaming\\npm\\node_modules\\semantic-release-cli\\node_modules\\keytar\ngyp ERR! node -v v5.1.0\ngyp ERR! node-gyp -v v3.0.3\ngyp ERR! not ok\nnpm WARN install:keytar@3.0.0 keytar@3.0.0 install: node-gyp rebuild\nnpm WARN install:keytar@3.0.0 Exit status 1\nC:\\Users\\\u0410\u0440\u0442\u0451\u043c\\AppData\\Roaming\\npm\n\u2514\u2500\u2500 (empty)\nnpm ERR! code 1\n``\n. @hbetts yeah, I know. But it is lots of steps to do it (install python, visual studio and other). Is it not possible to replacekeytar` to something else which works without extra steps?\n. ",
    "rubenhazelaar": "Would be great if it worked on Windows :+1: \n. @hbetts Yes, indeed the same as egoroof, however on better inspection I see now it's python that's missing for me (just as with egoroof I believe). I will let you know if it works out, thank you for the quick response.\n. That would be great\nOn Jan 21, 2016 2:17 AM, \"Tema\" notifications@github.com wrote:\n\n@hbetts https://github.com/hbetts yeah, I know. But it is lots of steps\nto do it (install python, visual studio and other). It is not possible to\nreplace keytar to something which works without extra steps?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/semantic-release/semantic-release/issues/131#issuecomment-173456488\n.\n. \n",
    "BioPhoton": "Any updates for the python installing process? Would be great to have a rough explanation of the steps needed to get it running on Windows. thx!\n. If somebody is looking for alternatives here are some interesting repo: \nconventional-changelog\n. ",
    "Ahmed-Badawy": "still not working on windows till 9/2016 ... \nwhere's the bug fix ??? \n. ",
    "davidpfahler": "@boennemann Thanks for this great response. I will, of course, turn on that protection.\n. ",
    "Starefossen": "Just my two cents but it should be very feasible to recover by reading the git refs to generate a change log since the last git tag.\n. +1 for support for Artifactory!. ",
    "amatiasq": "Isn't there a way to reset semantic-release state? I've been trying to make this work for a week now and I did a push force because I amended a chore commit to make it look like a breaking change so semantic-release finally allow me to do a release.\nThe whole experience has been very frustrating, I want to ensure semantic-releases are working before I start working on new features so I don't have to change context again but I can't test it without adding a feature. And now it's broken...\nI don't like the idea of having stuff like this to test it. And since I'm not able to push force it will stay in history.. The thing is I can deploy locally but I'm configuring travis so it can do it with my account that's why I have to push every time.. ",
    "ghaiklor": "+1, also couldn't login to Travis CI.\n. Summoning @boennemann to help with this critical issue.\n. @bahmutov great, hope it will be merged soon :+1: \n. @boennemann any thoughts ?\n. @boennemann yeah, I'm sure. All what I do with master branch is merging with dev.\n. @boennemann so what the procedure for restoring the commit ? Can I do this without losing my changes ?\n. ",
    "trodrigues": "Ah damn, I also got caught by this. Wondering if it would be a good idea to also add a note on the readme, as people integrating it with existing projects probably won't let semantic-release generate a travis file for them.\n. ",
    "PatrickHeneise": "Is there another way? I think it's pretty awful to maintain two different package.json files, having to add it to .gitignore so it's not in pull-requests from branch a to branch b etc.. What does this do?. Any hints where to start debugging this?\n. I am currently publishing manually, which is a PITA. I removed all releases and tags from GitHub, but it seems npm is holding some information about the releases in the cache as well.\nAnd yes, I did roll back / force push at some point, but don't remember where.\n. I wish it would just be a wrong repository attribute in package.json, but it's not that. I managed to resolve this error based on this hint.. No, having this issue for a while already, no idea how to resolve / debug.. I have the issue in 5 repos now. It's caused by manual tagging, but there has to be a way to get this back up and running.\n@boennemann any insight on where to start with debugging?. @travi did you continue on this issue?. @travi can you check if the tokens are all still valid? After some digging, I traced the PRE undefined error back to travis-deploy-once/index.js and resolved it with new keys. But I had a problem with my local branch and after a git reset to the GitHub origin, I'm back to the original issue of a broken history.\nAs far as I remember, this PRE: undefined comes after the broken history issue, so I think it can be resolved with git. Here's a snippet I used to get semantic-release to run locally with a little bit of debug info (clone the repo to ../semantic-release):\nDEBUG=* \\\nTRAVIS_REPO_SLUG=[me/myrepo]\nTRAVIS_BUILD_ID=[valid travis build id] \\\nTRAVIS_TEST_RESULT=0 \\\nTRAVIS_JOB_NUMBER=1.1 \\\nNPM_TOKEN=[fresg npm token] \\\nGH_TOKEN=[fresh github token] \\\nTRAVIS_BRANCH=master \\\nTRAVIS=true \\\nnode ../semantic-release/bin/semantic-release pre --no-debug. Wow, that might indeed be a problem for some of our repos as well (same case with the bot), I'll look into it, thanks!\nSo far, I still don't know how to resolve the git issue without reverting back to the commit.. @gr2m sorry this took so long. Moved it to a separate file and added the PR workflow comments. I'm sure beginners and experts alike will be able to fix the ENOTINHISTORY issue with this guide.. Is there a possible workaround to get the gh-app running without the update endpoint?. Not sure, we run semantic-release on travis, the CLI doesn't help much there. There's just a conflict between master and develop, I'd like to see all releases on develop on the dev pre-release tag, without changing the package.json manually.. If there's a way to not set the version number, that could work for us.\nie. semantic-release deploy-latest. Thanks for taking this over! In most of our projects we have the master branch protected, direct commits/pushes are not accepted, therefore the pull-request workflow.\nI find npm version x.y.z easier than replacing the version tag in package.json and running git tag (also as this isn't updated by semantic-release, we don't usually have a version tag in our package.json). . Ok, I\u2019ll work on it tomorrow. I\u2019d like to have both versions for the commit then, it really took me a little while to get this right (it really only worked in that order), the more there\u2019s documented the easier it is for everyone (not just beginners) to figure things out without wasting time. Can also add a new file TROUBLESHOOTING.md instead of putting this in the readme if you\u2019re concerned about the simplicity of the README?. ",
    "gyoshev": "We had a similar idea at work, and developed a set of semantic-release plug-ins that enable this. See the semantic-prerelease project and the accompanying blog post. We use prerelease tags for our next branch (we name it develop), but that should still work in this case.\n. ",
    "ocombe": "Well I had one, and it told me that this version already existed in the npm registry (since it took the existing number instead of generating a new one) :(\nWhat version of semantic release do you use on snap ci @hbetts ? Maybe the problem is that I use 6.x which is a pre release ?\n. Same thing here, the new version are not visible on npm by default, I think this has something to do with marking the versions as \"beta\" or something, which is why they are available with @next but not with @latest.\nI find it funny that a lib that helps you publish packages with correct semver on npm has a problem with releasing a new version :P\n. Closing this since it is an error with npm! https://github.com/npm/npm/issues/19222. ",
    "tthew": "@boennemann awesome. Exactly what I was looking for :) thanks!\n. ",
    "christiansakai": "me too +1\n. @knowbody I figured out the issue. I need to setup my Travis CI account first. After I set it up to be synced with the related github repo, it works\n. ",
    "knowbody": "@christiansakai what do you mean by:\n\nI need to setup my Travis CI account first\n\nI have the Travis CI set up and all the repos are synced...\n@boennemann thanks! I'll reopen it on the CLI issues\n. ",
    "sotojuan": "After pushing and inspecting on other modules, it seems as if the error is normal and happens when no changes worthy of a release are done. Closing for now, but reopen if I am wrong!\n. ",
    "colinmeinke": "You are totally right, that was the issue. Thanks so much :+1: \n. ",
    "therealklanni": "@tusharmath @destroyerofbuilds you will have to unpublish the version on npm:\nnpm unpublish <pkg>@<semver>\nThen from there, I'm not 100% sure how to handle the semantic-release aspect. Maybe try @destroyerofbuilds 's suggestion, but it might be better to just rewrite the commit.\n. Semantic Release uses your commit messages to decide how to release. If you do not want your package released as a major version (i.e. \"breaking\"), then don't write \"BREAKING CHANGE\" in your commit, since in your case it was never released before it was broken.\nYou can amend your commit to remove the \"BREAKING CHANGE\" note.\n\nSide note: you should always/only say \"BREAKING CHANGE\" when the change breaks something that was actually published\n. Feel free to submit a PR to update the docs.\n. \n",
    "semantic-release-bot": ":tada: This issue has been resolved in version 15.6.6 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This issue has been resolved in version 13.3.0 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 13.3.0 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This issue has been resolved in version 14.0.4 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 13.3.0 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 13.3.0 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 13.3.0 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 13.4.0 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 13.4.0 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.0.0 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This issue has been resolved in version 14.0.1 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 14.0.0 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 14.0.1 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 14.0.3 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 14.0.2 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 14.0.3 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 14.0.4 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.0.1 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.0.1 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.0.1 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.0.1 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This issue has been resolved in version 15.0.2 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.0.2 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This issue has been resolved in version 15.0.3 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.0.3 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.0.3 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.0.4 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.1.0 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.1.2 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.1.1 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.1.3 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This issue has been resolved in version 15.1.3 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This issue has been resolved in version 15.1.10 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.1.3 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This issue has been resolved in version 15.1.4 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.1.5 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.1.4 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This issue has been resolved in version 15.5.0 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This issue has been resolved in version 15.3.2 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This issue has been resolved in version 15.1.5 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.1.5 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This issue has been resolved in version 15.1.6 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This issue has been resolved in version 15.3.1 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This issue has been resolved in version 15.1.7 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.1.6 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.1.6 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.1.7 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.1.8 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.1.8 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.1.8 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.1.10 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.1.8 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This issue has been resolved in version 15.1.11 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.1.9 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.1.9 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.1.11 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.2.0 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.3.0 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.3.0 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This issue has been resolved in version 15.9.3 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.3.1 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.3.1 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.3.1 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.3.1 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.4.0 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.3.2 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This issue has been resolved in version 15.4.1 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This issue has been resolved in version 15.4.3 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.4.1 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This issue has been resolved in version 15.5.4 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This issue has been resolved in version 15.5.3 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This issue has been resolved in version 15.4.2 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.4.2 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.4.3 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.4.3 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.4.3 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.4.4 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.5.0 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.5.1 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.5.1 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.5.1 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.5.1 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This issue has been resolved in version 15.5.1 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.5.1 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.5.2 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.5.3 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.5.3 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.5.3 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.5.4 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This issue has been resolved in version 15.6.5 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.5.5 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.5.5 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.6.0 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This issue has been resolved in version 15.10.0 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.6.1 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This issue has been resolved in version 15.6.6 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.6.2 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.6.2 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This issue has been resolved in version 15.6.3 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.6.3 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This issue has been resolved in version 15.7.0 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.6.4 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.7.0 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.6.6 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.6.5 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.6.6 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.6.5 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This issue has been resolved in version 15.9.0 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.7.1 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.7.2 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.7.2 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.9.0 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.7.2 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.8.0 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.8.0 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.8.1 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.9.0 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This issue has been resolved in version 15.9.1 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.9.0 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.9.1 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.9.3 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.9.2 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.9.4 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This issue has been resolved in version 15.9.4 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.9.4 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.9.5 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.9.6 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.9.6 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This issue has been resolved in version 15.9.6 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.9.6 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.9.8 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.9.9 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.9.9 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.9.10 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.9.11 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.9.12 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.9.13 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.9.13 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This issue has been resolved in version 15.9.13 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.9.13 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.9.13 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This issue has been resolved in version 15.9.13 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This issue has been resolved in version 15.9.13 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.9.13 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.9.13 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.9.14 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.9.15 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.9.16 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.9.16 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.9.17 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.10.0 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.9.17 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.9.17 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This issue has been resolved in version 15.10.3 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This issue has been resolved in version 15.10.3 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.9.17 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.10.1 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.10.1 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.10.2 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.10.3 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.10.3 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.10.4 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.10.4 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This issue has been resolved in version 15.10.5 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.10.5 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This issue has been resolved in version 15.10.6 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This issue has been resolved in version 15.10.6 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.10.6 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.10.7 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.10.8 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.11.0 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.11.0 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This issue has been resolved in version 15.11.0 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.11.0 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.12.0 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.12.1 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This issue has been resolved in version 15.12.1 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.12.1 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 16.0.0-beta.1 :tada:\nThe release is available on:\n- npm package (@beta dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.12.1 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This issue has been resolved in version 15.12.1 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.12.1 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This issue has been resolved in version 15.12.5 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This issue has been resolved in version 15.12.2 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.12.2 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.12.3 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.12.3 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 16.0.0-beta.1 :tada:\nThe release is available on:\n- npm package (@beta dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.12.4 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 16.0.0-beta.2 :tada:\nThe release is available on:\n- npm package (@beta dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.12.5 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.12.5 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.12.5 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.12.5 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This issue has been resolved in version 15.12.5 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.12.5 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 16.0.0-beta.3 :tada:\nThe release is available on:\n- npm package (@beta dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 16.0.0-beta.3 :tada:\nThe release is available on:\n- npm package (@beta dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.13.0 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 16.0.0-beta.4 :tada:\nThe release is available on:\n- npm package (@beta dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 16.0.0-beta.4 :tada:\nThe release is available on:\n- npm package (@beta dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.13.0 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.13.0 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 16.0.0-beta.6 :tada:\nThe release is available on:\n- npm package (@beta dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 16.0.0-beta.7 :tada:\nThe release is available on:\n- npm package (@beta dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 16.0.0-beta.8 :tada:\nThe release is available on:\n- npm package (@beta dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 16.0.0-beta.9 :tada:\nThe release is available on:\n- npm package (@beta dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.13.3 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 16.0.0-beta.9 :tada:\nThe release is available on:\n- npm package (@beta dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.13.1 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This issue has been resolved in version 16.0.0-beta.11 :tada:\nThe release is available on:\n- npm package (@beta dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 16.0.0-beta.10 :tada:\nThe release is available on:\n- npm package (@beta dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 16.0.0-beta.11 :tada:\nThe release is available on:\n- npm package (@beta dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 16.0.0-beta.12 :tada:\nThe release is available on:\n- npm package (@beta dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 16.0.0-beta.13 :tada:\nThe release is available on:\n- npm package (@beta dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.13.2 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 16.0.0-beta.14 :tada:\nThe release is available on:\n- npm package (@beta dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 16.0.0-beta.15 :tada:\nThe release is available on:\n- npm package (@beta dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 16.0.0-beta.16 :tada:\nThe release is available on:\n- npm package (@beta dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.13.3 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This issue has been resolved in version 16.0.0-beta.16 :tada:\nThe release is available on:\n- npm package (@beta dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 16.0.0-beta.16 :tada:\nThe release is available on:\n- npm package (@beta dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.13.4 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.13.4 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This issue has been resolved in version 16.0.0-beta.17 :tada:\nThe release is available on:\n- npm package (@beta dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 16.0.0-beta.17 :tada:\nThe release is available on:\n- npm package (@beta dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.13.4 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.13.4 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 16.0.0-beta.18 :tada:\nThe release is available on:\n- npm package (@beta dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.13.4 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.13.5 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This issue has been resolved in version 15.13.5 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.13.5 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This issue has been resolved in version 15.13.5 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.13.5 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.13.7 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.13.6 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.13.7 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. :tada: This PR is included in version 15.13.5 :tada:\nThe release is available on:\n- npm package (@next dist-tag)\n- GitHub release\nYour semantic-release bot :package::rocket:. ",
    "ArnaudRinquin": "@mdreizin I'm not working on it anymore really.\n. ",
    "Snugug": "For me, useful for debugging\n. ",
    "ahmadnassri": "@hbetts you're correct, however this section of the README, directly references installing and setting up semantic-release-cli and since this is the entry point for majority of people discovering this project, I would suggest this note be more appropriate here.\ncan make the same / similar PR on the CLI repo as well ...\n. excellent.. @christophwitzko except now I'm seeing this warning and its not saving any passwords?\n. @christophwitzko yep, that worked! thx. same issue here? how to resolve this?. created a proof of concept PR to better demonstrate a solution: #342 \ndepends on:\n- https://github.com/semantic-release/condition-travis/pull/56\n- https://github.com/semantic-release/error/pull/63 (there could be cleaner approach to the error class, but kept it simple to keep backward and cross compatibility)\nIf I get a thumbs up to continue this approach, happy to make appropriate changes and PRs to the rest of the repositories where applicable :+1: . I realize the failure exit code also directly affects travis (and others) in the deploy step: semantic-release pre && npm publish && semantic-release post, but I believe there might be a better approach... (just not one that I have figured out yet) I will update here when I do.. @pvdlg sorry for the delayed follow up, yes, I continued on and off looking into modifying / improving the functionality, but ultimately semantic-release pre && npm publish && semantic-release post || true was the simplest and most elegant solution given the current state of the many components within the semantic-release ecosystem, making any change will likely require a big refactor on many fronts and making it backward compatible is also a challenge . yes, can close this now.. seeing the same issue here: https://travis-ci.org/ahmadnassri/nightwatch-accessibility/jobs/277788548#L517. I'm starting to see the same error, CI log here: https://travis-ci.org/ahmadnassri/glob-promise/jobs/352165164\nI ran locally with --no-ci --debug to see if I can get the debug for you, but that seemed to actually work ...\nI verified the GH_TOKEN values on travis are correct, nothing changed in my CI configuration either. also, I use npx to install and run semantic-release so it's always getting the latest on node v9\n```\n\nnpx semantic-release --debug --no-ci\n  semantic-release:config options values: [ 'branch', 'repositoryUrl', 'ci', 'debug', 'noCi' ] +0ms\n  semantic-release:config name: undefined +2ms  semantic-release:config branch: 'master' +0ms\n  semantic-release:config repositoryUrl: 'git+https://github.com/ahmadnassri/glob-promise.git' +0ms\n  semantic-release:config analyzeCommits: undefined +0ms  semantic-release:config generateNotes: undefined +0ms\n  semantic-release:config verifyConditions: undefined +0ms\n  semantic-release:config verifyRelease: undefined +0ms\n  semantic-release:config publish: undefined +0ms\n[Semantic release]: Load plugin verifyConditions from @semantic-release/npm\n[Semantic release]: Load plugin verifyConditions from @semantic-release/github\n[Semantic release]: Load plugin getLastRelease from @semantic-release/npm\n[Semantic release]: Load plugin analyzeCommits from @semantic-release/commit-analyzer\n[Semantic release]: Load plugin generateNotes from @semantic-release/release-notes-generator\n[Semantic release]: Load plugin publish from @semantic-release/npm\n[Semantic release]: Load plugin publish from @semantic-release/github\n  semantic-release:get-version-head Check if the current working directory is a git repository +0ms\n  semantic-release:get-version-head cmd: 'git rev-parse --git-dir' +0ms\n  semantic-release:get-version-head stdout: '.git' +1ms\n  semantic-release:get-version-head stderr: '' +0ms\n  semantic-release:get-version-head code: 0 +0ms\n[Semantic release]: Run automated release from branch master\n[Semantic release]: Call plugin verify-conditions\n[Semantic release]: Verify authentication for registry https://registry.npmjs.org/\n[Semantic release]: Verify GitHub authentication\n[Semantic release]: Call plugin get-last-release\ninfo attempt registry request try #1 at 08:23:56\nhttp request GET https://registry.npmjs.org/glob-promise\nhttp 200 https://registry.npmjs.org/glob-promise\n[Semantic release]: Found version 3.3.0 of package glob-promise with dist-tag latest\n  semantic-release:get-version-head Check if commit is in history +1s  semantic-release:get-version-head cmd: 'git merge-base --is-ancestor 93a7d4568de54dbcfc74f313dad7ab99ce0e6949 HEAD' +0ms\n  semantic-release:get-version-head stdout: '' +0ms  semantic-release:get-version-head stderr: '' +0ms\n  semantic-release:get-version-head code: 0 +0ms\n  semantic-release:get-version-head Check if commit is in history +3ms\n  semantic-release:get-version-head cmd: 'git merge-base --is-ancestor 93a7d4568de54dbcfc74f313dad7ab99ce0e6949 HEAD' +0ms\n  semantic-release:get-version-head stdout: '' +0ms\n  semantic-release:get-version-head stderr: '' +0ms\n  semantic-release:get-version-head code: 0 +0ms\n  semantic-release:get-commits Use gitHead: 93a7d4568de54dbcfc74f313dad7ab99ce0e6949 +0ms\n[Semantic release]: Found 4 commits since last release\n  semantic-release:get-commits Parsed commits: [ { commit: { long: '3b44f0ed6245cd07854ca1b2beecbda245fe54cf', short: '3b44f0e' }, tree: { long: '0d82467ee091287aad38949ef1484f18342d56e9', short: '0d82467' }, author: { name: 'Ahmad Nassri', email: 'ahmad@ahma\ndnassri.com', date: 2018-03-12T03:50:23.000Z }, committer: { name: 'Ahmad Nassri', email: 'ahmad@ahmadnassri.com', date: 2018-03-12T03:50:48.000Z }, subject: 'docs(readme): use --production instead of --only', body: '[skip ci]\\n', hash: '3b44f0ed6245cd07854ca\n1b2beecbda245fe54cf', message: 'docs(readme): use --production instead of --only\\n\\n[skip ci]', gitTags: '(HEAD -> master, origin/master, origin/HEAD)', committerDate: 2018-03-12T03:50:48.000Z }, { commit: { long: '734117dc18a69432ffd620b980edc06b18d209ce', s\nhort: '734117d' }, tree: { long: 'e194d64cf1aea316beaafc005d3ec79985cda653', short: 'e194d64' }, author: { name: 'Aluan Haddad', email: 'aluanh@gmail.com', date: 2018-03-12T03:44:38.000Z }, committer: { name: 'Ahmad Nassri', email: 'ahmad@ahmadnassri.com', da\nte: 2018-03-12T03:44:38.000Z }, subject: 'feat(typescript): add TypeScript typings', body: ' Add TypeScript typings\\r\\n\\r\\n  fix white space\\r\\n', hash: '734117dc18a69432ffd620b980edc06b18d209ce', message: 'feat(typescript): add TypeScript typings\\n\\n Add\nTypeScript typings\\r\\n\\r\\n  fix white space', gitTags: '', committerDate: 2018-03-12T03:44:38.000Z }, { commit: { long: 'f4da92e7910c6662bde2f0ef5587190da24e8471', short: 'f4da92e' }, tree: { long: 'fdcc95a9bb771e1f3c1e4f6836791c903ed9bb8f', short: 'fdcc95a'\n }, author: { name: 'Ahmad Nassri', email: 'ahmad@ahmadnassri.com', date: 2018-03-12T03:42:28.000Z }, committer: { name: 'Ahmad Nassri', email: 'ahmad@ahmadnassri.com', date: 2018-03-12T03:42:28.000Z }, subject: 'docs(readme): improve readme', body: '', hash:\n 'f4da92e7910c6662bde2f0ef5587190da24e8471', message: 'docs(readme): improve readme', gitTags: '', committerDate: 2018-03-12T03:42:28.000Z }, { commit: { long: '5c183106ec3895e2574aa00549030c7e7b948625', short: '5c18310' }, tree: { long: '4bfbc4ea6c41ad10139f\nd71a6f1c1b3b9a086d3c', short: '4bfbc4e' }, author: { name: 'Ahmad Nassri', email: 'ahmad@ahmadnassri.com', date: 2018-03-12T03:39:11.000Z }, committer: { name: 'Ahmad Nassri', email: 'ahmad@ahmadnassri.com', date: 2018-03-12T03:39:11.000Z }, subject: 'feat(pa\nckage): update dependencies and improve repo meta and build process', body: '', hash: '5c183106ec3895e2574aa00549030c7e7b948625', message: 'feat(package): update dependencies and improve repo meta and build process', gitTags: '', committerDate: 2018-03-12T03:\n39:11.000Z } ] +7ms\n  semantic-release:get-version-head Get git commit tag +11ms\n  semantic-release:get-version-head cmd: 'git describe --tags --exact-match 93a7d4568de54dbcfc74f313dad7ab99ce0e6949' +0ms\n  semantic-release:get-version-head stdout: 'v3.3.0' +0ms\n  semantic-release:get-version-head stderr: '' +0ms\n  semantic-release:get-version-head code: 0 +0ms\n[Semantic release]: Call plugin analyze-commits\n[Semantic release]: Analyzing commit: docs(readme): use --production instead of --only\n\n[skip ci]\n  semantic-release:commit-analyzer Analyzing with default rules +0ms\n[Semantic release]: The commit should not trigger a release\n[Semantic release]: Analyzing commit: feat(typescript): add TypeScript typings\n\n\nAdd TypeScript typings\n\n\nfix white space\n  semantic-release:commit-analyzer Analyzing with default rules +0ms\n  semantic-release:commit-analyzer The rule { type: 'feat', release: 'minor' } match commit with release type 'minor' +0ms\n[Semantic release]: The release type for the commit is minor\n[Semantic release]: Analyzing commit: docs(readme): improve readme\n  semantic-release:commit-analyzer Analyzing with default rules +1ms\n[Semantic release]: The commit should not trigger a release\n[Semantic release]: Analyzing commit: feat(package): update dependencies and improve repo meta and build process\n  semantic-release:commit-analyzer Analyzing with default rules +0ms\n  semantic-release:commit-analyzer The rule { type: 'feat', release: 'minor' } match commit with release type 'minor' +0ms\n[Semantic release]: The release type for the commit is minor\n[Semantic release]: Analysis of 4 commits complete: minor release\n[Semantic release]: The next release version is 3.4.0\n  semantic-release:get-version-head Get git head +9ms\n  semantic-release:get-version-head cmd: 'git rev-parse HEAD' +0ms\n  semantic-release:get-version-head stdout: '3b44f0ed6245cd07854ca1b2beecbda245fe54cf' +0ms\n  semantic-release:get-version-head stderr: '' +0ms\n  semantic-release:get-version-head code: 0 +0ms\n[Semantic release]: Call plugin verify-release\n[Semantic release]: Call plugin generateNotes\n  semantic-release:release-notes-generator version: '3.4.0' +0ms\n  semantic-release:release-notes-generator host: 'github.com' +0ms\n  semantic-release:release-notes-generator owner: 'ahmadnassri' +0ms\n  semantic-release:release-notes-generator repository: 'glob-promise' +0ms\n  semantic-release:release-notes-generator previousTag: 'v3.3.0' +0ms\n  semantic-release:release-notes-generator currentTag: 'v3.4.0' +0ms\n[Semantic release]: Call plugin publish\n[Semantic release]: Wrote version 3.4.0 to package.json\n[Semantic release]: Wrote version 3.4.0 to package-lock.json\n[Semantic release]: Publishing version 3.4.0 to npm registry\n\nglob-promise@3.4.0  semantic-release:get-version-head Get git head +4s\n  semantic-release:get-version-head cmd: 'git rev-parse HEAD' +0ms\n  semantic-release:get-version-head stdout: '3b44f0ed6245cd07854ca1b2beecbda245fe54cf' +0ms\n  semantic-release:get-version-head stderr: '' +0ms\n  semantic-release:get-version-head code: 0 +0ms\n  semantic-release:github release owner: 'ahmadnassri' +0ms\n  semantic-release:github release repo: 'glob-promise' +0ms\n  semantic-release:github release name: 'v3.4.0' +0ms\n  semantic-release:github release branch: 'master' +0ms\n  semantic-release:github Create git tag 'v3.4.0' with commit '3b44f0ed6245cd07854ca1b2beecbda245fe54cf' +242ms\n[Semantic release]: Published GitHub release: https://github.com/ahmadnassri/glob-promise/releases/tag/v3.4.0\n  semantic-release:get-version-head Get git head +1s\n  semantic-release:get-version-head cmd: 'git rev-parse HEAD' +0ms\n  semantic-release:get-version-head stdout: '3b44f0ed6245cd07854ca1b2beecbda245fe54cf' +0ms\n  semantic-release:get-version-head stderr: '' +0ms\n  semantic-release:get-version-head code: 0 +0ms\n[Semantic release]: Published release: 3.4.0\n```. \n",
    "thelambdaparty": "I also had this problem, would have found out if it was in the readme :smile: Seems like the merge didn't go to caribou branch\n. I just saw there is a pull request for this, seems like it wasn't merged to caribou branch\n. ",
    "alecxe": "@hbetts sure, sorry for not providing details. \nI just mean would be nice to link the projects that are already set to use semantic-releasing. For example this project really helped me to set up the release for this project. Actual working example seriously helped to get things started..\nHope it makes sense. Thanks.\n. ",
    "DavidWells": "This project is another good example: https://github.com/kentcdodds/starwars-names\n. ",
    "luftywiranda13": "generator-bunny \ud83d\udc30 . \nit'll make it look like that in http://npmjs.com\n. just fixed!\ni solved it by pushing another patch commit, i dont know why . @jhabdas hmmm do you mean an issue posted more than 1 year ago?\nclosed issue? has it been closed?. I'm sorry that's because I saw so many long open issues here \ud83d\ude09 \nyes it doesn't matter but why didn't semantic-release delete the branch after releasing? Do I have to manually delete the branch?\nSo I think someday I'll have 50+ branches created by semantic-release in my repo \ud83d\ude22 . oh okay, I'll try to\nthanks Gregor!. yeah it looks suspicious, i'm still digging a bit. @vanduynslagerp it's currently not tagged as latest but next.\nif you want to have v7.0.2 now, you can install it by running npm install semantic-release@7.0.2 --save-dev or npm install semantic-release@next --save-dev. @frank-long yes it is. Clearly inconsistency in the docs.\nPeople write BREAKING CHANGE in the body/description of commit to trigger releasing a major version, not in the title.. EDITED: ignoring lockfiles like this is harmful, because lockfiles are still in your local machine (they're just invisible)\nSee https://github.com/luftywiranda13/remove-lockfiles#why. i updated my comment, sorry \ud83d\ude06 . > Also I added npmrc and .yarnrc to not regenerate them.\n2 dotfiles to prevent lockfiles to be generated? I think it's overkill. Isn't it better to integrate prettier + eslint in pre-commit hook? \nSo we can make sure prettier + eslint reformat any changes before committing. IMO it's better to put prettier config directly inside eslint config. we're using eslint-plugin-prettier, right?. Also this approach will reduce the possibility of us having code style discussion in code review\nhttps://github.com/semantic-release/semantic-release/pull/451#discussion_r141981878\nEdited: if i got it right \u270c\ufe0f . > The point of removing the lockfiles is to do the development with latest versions of dependencies.\nyes, I know. that's the main reason why I decide to never commit lockfiles in my projects\n\nAlso adding 2 extra dependency + a commit hook seem more overkill to me than two one line dotfiles.\n\nhmmm I think https://github.com/semantic-release/semantic-release/pull/451#discussion_r141984300 is a relevant answer. > We had this discussion about commit hook previously among maintainer...\ncool, I respect that \ud83d\udc4d \n\nThe chosen solution is to enforce the formating with eslint (with eslint-plugin-prettier).\nAll the code format pushed is validated in CI with eslint to be sure it's formatted with prettier.\n\nyeah, the changes will fail on CI if they're not following our prettier config but then we still have to discuss about the code style things in the PR, right? isn't it not so good in terms of productivity?. > Actually it work the other way around, it's eslint-plugin-prettier that read the prettier config. See prettier/eslint-plugin-prettier#55\nyeah, it's added in v2.3.0. but it still can read the config directly if we put the config in rules field. ",
    "stevemao": "Also conventional-changelog is broken down into smaller modules. Some related tools such as conventional-recommended-bump and conventional-commits-detector is using the internal module of conventional-changelog. I believe these can greatly improve semantic-release.\n. @hbetts Yes.\n. conventional-changelog really needs to be bumped. The old version is very buggy and causes a lot of problems.  @boennemann @christophwitzko if you guys are too busy I'm very happy to maintain this module. Thanks.\n. https://github.com/semantic-release/semantic-release#why-is-the-packagejsons-version-not-updated-in-my-repository\n\nWhy is the package.json\u2019s version not updated in my repository?\nThe npm docs even state:\nThe most important things in your package.json are the name and version fields. Those are actually required, and your package won\u2019t install without them. \u2013 npm docs\nWhile this entirely true the version number doesn\u2019t have to be checked into source control. semantic-release takes care of the version field right before npm publish uses it \u2013 and this is the only point where it really is required.\n. I agree it's not so clear.... And the project looks unmaintained. I don't know if they still accept PRs.\n\nSent from my iPhone\n\nOn 10 Mar 2016, at 12:34 PM, Alessandro Zanardi notifications@github.com wrote:\nThanks, I actually read that. It wasn't entirely clear to me though that it deletes the version field when it exists. I thought it would simply ignore it. Maybe this point could be clarified in the readme...\nCheers!\n\u2014\nReply to this email directly or view it on GitHub.\n. \n",
    "stjohnjohnson": "@hbetts @stevemao is there anything users can do to swap out to use conventional-recommended-bump?. ",
    "pensierinmusica": "+1 I have the exact same problem!\nIn case it's useful, this is the npm package: https://www.npmjs.com/package/firstline\n@greenkeeperio-bot and @boennemann, any idea what could be causing this?\n. @thiagofelix no it's a different case. The problem is that commit analyzer will consider a new version only if there are commits of type feat or fix. I already sent a pull request to fix this: https://github.com/semantic-release/commit-analyzer/pull/13\nIf you'd like more details please check the conversation here: https://github.com/semantic-release/commit-analyzer/issues/12#issuecomment-203166512\nThanks, cheers!\n. Thanks, I actually read that. It wasn't entirely clear to me though that it deletes the version field when it exists. I thought it would simply ignore it. Maybe this point could be clarified in the readme...\nCheers!\n. Mmm, looks like there have been commits up until last month, so I'd say hope is not lost ;)\n. Hi @boennemann, is this mentioned in the docs?\n. @safareli take a look here: https://www.npmjs.com/package/cz-changelog\n. ",
    "thiagofelix": "Is it not the same case as #208? \nPlease refer to my comment there.\n. The reason why it raises ENOCHANGE is not because there have been no previous publishes.\nIt is actually because there isn't any relevant commit on your history.\nThe default implementation uses conventional-changelog style of commits.\nSo it makes sense to refuse to publish when it is not possible to tell the next release version or generate proper changelog document.\nLastly, dealing with the special condition of \"never published before\" would add unnecessary complexity IMO =)\n. Well, it is a bit cumberstome yes.\nBut you need to start using conventional-changelog since the beggining, and make sure you have feat/fix commits by the time you release you package.\nBecause if you don't have feat/fix to release, what are u release them ? =p\n. ",
    "glebec": "Some of them may be debatable, but docs definitely changes the user experience.\n. True, most don't. Some do. I have several times in the past. I guess it depends somewhat on whether you consider documentation to be part of the code source or a separate project. If the former, updated docs means a changed product means a new version.\nI can see the argument against it\u2026\u00a0just providing food for thought.\n. ",
    "GarthDB": "@MoeSattler the README.md does change what is shown on npmjs.com. So I guess I have to change it to a fix type for now.\n. When I'm making CLI tools I use the version field from the package.json to return a version in the command line.\n. ",
    "cdaringe": "i'm unclear on how the intent is supposed to work.  why would \"no change\" be a non-zero exit code?  what's the convention such that i can merge things into master that arent supposed to cut new releases?  i dont want CI failing because it discovered \"hey, there's nothing new.\"  in fact, yes, i'm aware there's nothing new, and that's ok--no reason to exit 1!  just askin' what i'm missing, here\n. @terales, whenENOCHANGE happens for me, the cli exits with code 1, and on codeship, a non-zero exit code == fail.  are you suggesting that your CI is configured to allow it to fail? \n. IMHO (respectfully) ENOCHANGE possibly shouldn't be a thing.  \"no change\" is a valid and expected state, not an error condition.  using ENOCHANGE as a mean of control flow seems like misuse of the Error construct.\nGrateful for this project, keep up the good work :)\n. @kentcdodds, did you ever resolve this?. oh... that's weird. i just tagged on another commit that made it work.  maybe is was that i was not in the proper directory?  go figure.. even if's unofficial, does anyone else in the community have a strategy for this?\n. Hey folks:\nI want to add support to using the \"Deployments\" strategy.  I was redirected here from #319.  Of the many ideas listed, deployments seems like it could offer the lowest cognitive overhead workflow, whilst maintaining deep capability, especially for those projects where artifacts are created from multiple CI providers.  I assume releasing with multiple CI providers may not be? a 1st class support citizen for this project, but gyp, neon, electron, nexe, and other-js-projects-with-native-concerns have a lot to gain if it was supported.\nHypothetical workflow:\n\ncommit lands in GitHub\nCI providers race on build/tests steps only.  no publish occurrs\nGH app waits for CI GREENness\nGH app computes if next version required, and generates tags when necessary\nevent sent to CI providers, instructing to build/publish artifacts only\none provider elected to be \"master\"\nmaster does npm publish, generates release notes, etc\n\n\neach provider publishes artifacts\nGH app waits for all artifacts and done signal from master\nGH finalizes the semantic-release\n\nI know that this may not be exactly what was envisioned with the GH application, but it's food for thought. thx!\n  . @pvdlg, thx!  the recipe link doesn't specify the minimal set of configuration required in package.json.  im not 100% sure what it should be either.  any tips?. ah, i dev installed @semantic-release/gitlab-config then added:\njson\n  \"release\": {\n    \"extends\": \"@semantic-release/gitlab-config\"\n  }\nto my package.json and blamo!  in business.  the issue is probably worth closing too, as aforementioned by @pvdlg . ",
    "terales": "@cdaringe semantic-release should run after successful build and this error won't trigger Travis CI build fail.\n. Nope. This is just default Travis CI behavior.\nFirst it runs all tests. A non-zero exit here will fail build.\nIf there was no error with tests, Travis will mark build as passing and run after success scripts.\nResult of after success scripts won't affect build state.\nI think semantic-release should throw warn instead of error for such case.\n. @boennemann Would it be okay for you if I create PR with this changes in https://github.com/semantic-release/semantic-release/blob/a5cb9ea7f7a66657f95f0d913126e812adb6d9f8/bin/semantic-release.js#L116-L123\n``` javascript\nif (err) {\n  var errMessage = (err.code ? err.code + ' ' : '') + err.message\nif (err.code && err.code === 'ENOCHANGE') {\n     log.warn(errMessage )\n     process.exit(1)\n  }\nlog.error('pre', 'Failed to determine new version.')\nvar args = ['pre', errMessage]\n  if (err.stack) args.push(err.stack)\n  log.error.apply(log, args)\n  process.exit(1)\n}\n```\nWhich will exit with:\nsemantic-release Warn pre ENOCHANGE There are no relevant changes, so no new version is released.\n. Don't know real solution, but you can init semantic-release cli with selecting Other CI option, so it will print GH_TOKEN and NPM_TOKEN which you should add to the Travis CI \u2192 Settings \u2192 Environment Variables.\nAfter the first push it should work as expected.\n. @ByteDefault file a new issue with logs from Travis. This issue is about automatic setup.\n. @DavidWells, @davemachado, @marvindanig  \nIssue with a buffer size was fixed in PR #15 and released in 6.3.1.\nBut npm installs 4.3.5 from @lastest channel (see #223), to get the last version you need to install from @next channel:\nsh\nnpm i -S semantic-release@next\n. You can check GitHub statuses of commits and run release on the last build if all other checks are already passed.\n. Thanks for creating separate issue.\nRoot problem is travis-after-all module, which is used in condition-travis\nThere is a pull request from 7th January :no_mouth: which hasn't merged yet: alrra/travis-after-all#15\nEven if this PR will be merged somehow, then some modifications would be needed in the condition-travis call of the travis-after-all module and in the list of known options. So it won't be implemented in the next days, as I can see from current repository pulse.\n. You can make changes yourself \ud83d\ude08, use it in production from yours repo and create PR. \nAlso, try https://github.com/Netflix/unleash . It hasn't automatic builds, but it can do one-line manual releases like semantic-release does.\n. ",
    "mrfelton": "You can work around this using https://github.com/fullcube/customizable-commit-analyzer. ",
    "filipvh": "i seem not able to find how i can make it so a breaking change commit will trigger a build?. its that if i do this i get:\n[Semantic release]: Analyzing commit: BREAKING CHANGE: Testing breaking change\n[Semantic release]: The commit should not trigger a release\n. when i debug, the commit object that is given to analyze-commit.js \n```\n{ type: null,\n  scope: null,\n  subject: null,\n  merge: null,\n  header: 'BREAKING CHANGE: Testing breaking change',\n  body: null,\n  footer: null,\n  notes: [],\n  references: [],\n  mentions: [],\n  revert: null }\n```. is there a way to change this? using config?. ",
    "benjamincharity": "Check out: https://github.com/semantic-release/semantic-release#commit-message-format\nIn short, if you add BREAKING CHANGE: your message here to a commit message, it should trigger a breaking change release. Hmm.. I think the breaking change message needs to be in the body rather than the header. (not 100% on that..) So your commit would need a line break before the breaking change message.\n```bash\nfix: I did a thing!\nBREAKING CHANGE: I broke a thing!\n```. I don't believe so.\nI think they are trying to follow Github's native functionality somewhat. Github seems to only parse the body of PRs etc for functionality rather than the title (ie closes #12 will auto close an issue - but only when in the body of the PR)\nI definitely don't know all the ins and outs of semantic release, so you may want to open a new issue asking if that is possible.. I have successfully used https://github.com/leonardoanalista/cz-customizable to define custom scopes. It also has the ability to set custom scopes and override which scopes trigger version number changes. An example config:\n```javascript\n'use strict';\nmodule.exports = {\ntypes: [\n    {value: 'feat',     name: 'feat:     A new feature'},\n    {value: 'fix',      name: 'fix:      A bug fix'},\n    {value: 'docs',     name: 'docs:     Documentation only changes'},\n    {value: 'style',    name: 'style:    Changes that do not affect the meaning of the code\\n            (white-space, formatting, missing semi-colons, etc)'},\n    {value: 'refactor', name: 'refactor: A code change that neither fixes a bug nor adds a feature'},\n    {value: 'perf',     name: 'perf:     A code change that improves performance'},\n    {value: 'test',     name: 'test:     Adding missing tests'},\n    {value: 'chore',    name: 'chore:    Changes to the build process or auxiliary tools\\n            and libraries such as documentation generation'},\n    {value: 'revert',   name: 'revert:   Revert to a commit'},\n    {value: 'WIP',      name: 'WIP:      Work in progress'}\n  ],\nscopes: [\n    {name: 'Button'},\n    {name: 'Input'},\n    {name: 'InputMessages'},\n    {name: 'Search'},\n    {name: 'SCSS'},\n    {name: 'CI'},\n    {name: 'Dependencies'},\n    {name: 'Demo'},\n  ],\n// it needs to match the value for field type. Eg.: 'fix'\n  /\n  scopeOverrides: {\n    fix: [\n      {name: 'merge'},\n      {name: 'style'},\n      {name: 'e2eTest'},\n      {name: 'unitTest'}\n    ]\n  },\n  /\nallowCustomScopes: true,\n  allowBreakingChanges: ['feat', 'fix']\n};\n```. Add your build steps and publish command between the pre/post steps:\nbash\nyarn run semantic-release-pre # This way sematic-release is still managing your versions\nyarn run build # This is where you build/copy/package/etc so all files are together\nyarn publish dist/\nyarn run semantic-release-post\nSo the only real changes to your flow are:\n\nStep 2 no longer needs to happen\nStep 6 isn't needed. You can pass a directory to the publish command so you don't need to cd in. (yarn publish dist/)\nReorganize your steps a bit to match the above pattern. Hmm I'm not entirely sure... Our builds look pretty similar. Bump the package, run a rollup build, copy package.json over and run publish.\n\nHere are my publish steps if it helps. Maybe something will jump out to you that I'm missing..\n\nCircleCI publish script\nBuild script\n. afaict at this point we are just waiting for the Yarn team to implement a more complete publish command: https://github.com/yarnpkg/yarn/issues/610\n\nUntil then, if you want to use yarn publish you will need to retrieve your last git tag and use that value as the version in the publish command.\nPersonally, I have just opted to use npm publish until Yarn is a drop-in replacement.. I even tried to fork @semantic-release/npm to add my own dist/ option but the npm command just fails now An error occurred while running semantic-release: { Error: Command failed: npm publish dist/ so no go :/. Sorry, yeah I'd gotten to just trying random things..\nI just need to publish the contents of dist/ to NPM.\nPreviously my release was handled like so:\n```bash\nyarn run semantic-release-pre\n// My build step packages all files etc (including the package.json) into the dist/ directory.\nyarn run build\nnpm publish dist/\nyarn run semantic-release-post\n```\nMy release object now looks like this:\n\"release\": {\n    \"verifyConditions\": [\n      \"condition-circle\",\n      \"@semantic-release/changelog\",\n      \"@semantic-release/npm\",\n      \"@semantic-release/git\"\n    ],\n    \"getLastRelease\": \"semantic-release-npm\",\n    \"publish\": [\n      \"@semantic-release/changelog\",\n      \"@semantic-release/npm\",\n      \"@semantic-release/git\"\n    ]\n  },\nTrying to run semantic release from dist/ throws this error: semantic-release: command not found and trying to install it globally really seems to make CircleCI go nuts (over 400,000 lines of output). Hmm still not having any luck.  I needed sudo for the semantic-release install: sudo npm i -g semantic-release. But I still get the 'command not found' error. I've tried running `npm run semantic-release from dist and from my root and from my circle ci config file.\nI created an NPM script \"semantic-release\": \"semantic-release\" and tried cd dist && yarn run semantic-release in my circle ci config. But that gives me error Command failed with exit code 1.\n. Thanks for the crazy fast responses guys! \ud83d\ude4f \nOk, it feels like I'm getting very close.. I'm failing now on the changelog generation but I'm not completely sure why. It almost seems as if the generated changelog file isn't being tracked before the commit is tried. I can survive with the changelogs simply living in the Github releases if needed.  But looking at @blakedietz's config, it seems like this should work:\n\nEDIT: I noticed an error in my config, so I've updated it and the error output:\n\nMy config at this point:\n```yml\n.circleci/config.yml\n  - run:\n      name: Release\n      command: cd dist && ../node_modules/.bin/semantic-release\n\n```\njson\n// package.json\n  \"release\": {\n    \"verifyConditions\": [\n      \"condition-circle\",\n      \"@semantic-release/changelog\",\n      \"@semantic-release/npm\",\n      \"@semantic-release/git\"\n    ],\n    \"getLastRelease\": \"@semantic-release/npm\",\n    \"publish\": [\n      \"@semantic-release/changelog\",\n      \"@semantic-release/npm\",\n      \"@semantic-release/git\"\n    ]\n  },\nCI error:\n```bash\n[Semantic release]: Call plugin publish\n[Semantic release]: Create CHANGELOG.md\n[Semantic release]: Wrote version 1.2.0 to package.json\n[Semantic release]: Publishing version 1.2.0 to npm registry\n+ @terminus/ui@1.2.0[Semantic release]: Add CHANGELOG.md to the release commit\n[Semantic release]: Add package.json to the release commit\n[Semantic release]: Found 2 file(s) to commit\n[Semantic release]: An error occurred while running semantic-release: { Error: Command failed: git commit -m chore(release): 1.2.0 [skip ci]\n\n1.2.0 (2017-12-19)\nFeatures\n\nCI: add changelog plugin back (c0ee235)\n\nOn branch master\nYour branch is up-to-date with 'origin/master'.\nUntracked files:\n    ../coverage/\nnothing added to commit but untracked files present\nat Promise.all.then.arr (/home/circleci/ci-build/node_modules/execa/index.js:236:11)\nat <anonymous>\nat process._tickCallback (internal/process/next_tick.js:160:7)\n\ncode: 1,\n  killed: false,\n  stdout: 'On branch master\\nYour branch is up-to-date with \\'origin/master\\'.\\nUntracked files:\\n\\t../coverage/\\n\\nnothing added to commit but untracked files present\\n',\n  stderr: '',\n  failed: true,\n  signal: null,\n  cmd: 'git commit -m chore(release): 1.2.0 [skip ci]\\n\\n\\n# 1.2.0 (2017-12-19)\\n\\n\\n### Features\\n\\n* CI: add changelog plugin back (c0ee235)\\n\\n\\n\\n',\n  timedOut: false }\nExited with code 1\n```\nBuild if it helps: https://circleci.com/gh/GetTerminus/terminus-ui/1103. I'm also not entirely sure what the difference is between the git and github plugins. I noticed both in the shared config above so I tried adding both to mine with the same error as above\nIn case it matters, I also see the same error without the changelog plugin.. I have. I've spent much more time configuring semantic-release (old version and new version) than any other resource or tool. The benefit of semantic-release, when working, is great enough for me to spend this time so far. The docs are pretty good if you are setting it up for the first time and want to use it as-is. But as soon as a specific need arises, like wanting to release a specific directory, things seem to get a bit hairy. Please don't take this as negatives, I'm very grateful for the work that has been done on this tool \ud83d\ude4f \n\nHmm ok, yeah that definitely sounds like an issue..\nEven without the changelog plugin, I see the same error. I'm assuming that this is because semantic-release is still trying to create a release commit in this ignored directory? So it seems that the Git part of SR needs to be run in my root, but the NPM part of SR needs to run inside my dist which is ignored.\nIs tracking my dist the most simple solution?. I originally was using the standard way of defining which files to publish. I just ran into a lot of issues trying to build my project into my src dir, cleaning up files, organizing my npm package files etc. It just ended up being way easier to build everything into a specific dir. Copying a few files is a one-liner and paths aren't an issue (the build is generated from src and just simply specifies an output dir).\nNPM makes it easy to include files in your release, but afaict we have no control over the organization. I've even seen other library maintainers resorting to listing out every individual file in their files array\n\nEither way, removing the changelog and git plugins got me back to releasing so I will close this issue. \nI am very grateful for your help here!. Of course! I'm grateful to not have the ability to screw up my version numbers now ;)\n\nYep, once my package.json, README.md etc is moved into my dist dir I can run npm publish dist/ from the root directory.\nI haven't directly used an .npmignore or npm-shrinkwrap.json, but I would assume those would need to be manually moved also.\nAlso, I believe publishing a directory is something done instead of the files array rather than using both.. I possibly don't really understand how the dry-run should be used.. Here is what I am hoping for:\n\ncreate new branch\nmerge a bunch of work into this branch\nrun dry-run to verify what would be published on a merge to master\n\nBut this is where I'm blocked since semantic release just says this branch is not configured to publish. If I add \"branch\": \"my-branch\", under the release key I then get the 'push permission is required' error.\nI am on my local machine and definitely have permission to push to the repo/branch.. The same issue crops up really anytime I make any changes to semantic-release. Currently I'm trying to add the ability to generate a changelog.md. But there is no way to verify this will actually work until I merge and release. \nSo I merge something, let the publish run and see that something was configured incorrectly. So now I need to push another hotfix release out to hopefully fix it.\nI know I could set it up so that NPM doesn't publish to latest automatically but that doesn't solve the noisy commits/builds/tags. Plus it requires me to manually publish to NPM which happens ~7-10/week.. Thank you for the very clear response. I understand the purpose much better.\n\nSorry for the noise.. just really trying to figure out how to be more confident in my releases. Having some way to say 'if this branch is merged into the current state of the release branch, here is what would happen' would be very helpful (especially as junior team members or new engineers begin helping out).\nThanks again for the explanation and the great tool!. ",
    "travi": "you might consider https://github.com/bahmutov/simple-commit-message#as-plugin-for-semantic-release if you don't want to implement your own. after getting past a travis-pro permissions issue for our \"bot\" account, as described in #337, i'm now seeing this issue in one of my private repos. as mentioned above, it does successfully publish the package to our private registry (nexus in this case) but fails to publish the release notes to github.\ni'm fairly sure that this is not a permissions issue because another of our private packages with the same config is publishing to the registry and posting release notes to github successfully. plus, the process of determining that the builds are all complete requires interacting with the travis api after logging in through github using the same token as would be used here. the problem appears to be limited to this particular project so far.\nI have tried to publish a version manually, hoping that it would give a more appropriate previous version to go back to, but that did not appear to have any impact.\nalso worth noting, this appears to be the same error as seen in #328 and #257, neither of which appear to have found a resolution.. i figured out my problem by adding a log statement so i could see the information that was being used to create the release through the github api. in my case, the repository field in the package.json pointed to a wrong, but real repo (probably a copy paste issue when the project was created). fixing this enabled the next release to be created successfully.\nwhile this might not be the same problem for others, definitely look at the data for creating the release and confirm the sanity of that data.. i ended up seeing this error in one of my repos, but was able to resolve it. see more detail in #199 . digging into the specific issue that @jcjones1515 mentioned, I ensured that\n we have publishConfig.registry defined in the package.json to simplify registry resolution\n the publishConfig.registry has a trailing / so that the request to get info would be built correctly\n making a request to the url built by the default last-release plugin successfully provides the expected info about the package\n $NPM_TOKEN is available in the build\nwith loglevel=debug set in the .npmrc i was able to get a bit more log information. it doesn't provide an obvious answer yet, but it does narrow where the failure happens to somewhere in this range\nsemantic-release verb init options: { argv: { remain: [ 'pre' ], cooked: [ 'pre' ], original: [ 'pre' ] },\nsemantic-release verb init   branch: 'master',\nsemantic-release verb init   fallbackTags: { next: 'latest' },\nsemantic-release verb init   debug: false,\nsemantic-release verb init   githubToken: '***',\nsemantic-release verb init   githubUrl: undefined }\nsemantic-release verb init Verifying config.\nsemantic-release verb pre Running pre-script.\nsemantic-release verb pre Veriying conditions.\nsemantic-release ERR! pre undefined. after forking semantic-release and adding a fallback to log err if err.message was undefined, i'm now seeing:\nsemantic-release ERR! pre { file: 'not found' }\ni was hoping for something more revealing, but that still isn't obvious to me.. sorry, i haven't had a chance to trace this any further. i know i had tried updating the $GH_TOKEN and $NPM_TOKEN during my tests, but it's always possible that i pasted an incorrect value. \nfrom my investigation though, it seemed like the issue was from node-travis-ci rather than directly from travis-deploy-once. This suggested to me that the problem was in communicating with travis pro, so it seems unlikely that $NPM_TOKEN or $GH_TOKEN would have an impact. by \"new keys\", did you mean one of these, or something else?\nthank you for providing the details of running it locally. that was one of my next steps when i had been looking at this, but tracking down the right way to get it going was a big enough hurdle that i didnt get that far. this should be very helpful.. thank you for the nudge to dig into this again. i did end up solving our problem. it was related to our $GH_TOKEN, but i did not end up needing to replace it with a different one.\nwe use a bot account for our semantic-release process. since no-one uses this account directly, it had never been used to log into the travis-pro webapp, so OAuth access had never been granted for travis-pro. even without this, authenticating against the travis-pro api does not fail (i've logged an issue about this). Instead, it still attempts to get data about the build jobs, resulting in the {file: 'not found'} errors because of the lack of permissions.\ni have not yet seen the broken history issues you mentioned, but our issue was definitely a permissions issue in the end. i just wish the errors would have been reported in a way that would have simplified resolution a bit more.. i think that error message would have been enough when i ran into this issue. it really came down to having no reason to think that was the issue and burning a ton of time investigating other things that seemed more likely. seeing that message would have cut down the time significantly for me.. i've resorted to using pre-releases for new packages that i consider to still be in \"beta\". i try to keep that period short, but having the very rough initial iterations come before releasing v1.0.0 has still been valuable for me.\nlike you, @jwalton, i've become very spoiled by semantic-release, so i'm very much looking forward to when semantic-release might be able to help me with my pre-releases . > The main issue with the current workflow is that it assumes \"deliverables are releasable\".\nBut the fact is this is just not true.\nI'm interested in what is meant by this statement. \nthe continuous delivery philosophy is essentially that master is always releasable, but not necessarily deployed/published. semantic-release enables going the step beyond continuous delivery to continuous deployment, where you might as well deploy/publish the value that has been delivered to master automatically.\nare you referring to something else?. i think that fully depends on your definition of \"releasable\" and the definition that i use above is core to the ideas behind both continuous delivery and continuous deployment. releasable in that sense is simply \"able to be released\", not necessarily \"delivers value\" to a user. if it can be released to a user without making anything worse, it is \"releasable\". \n\nmaster is always releasable, but not necessarily deployed/published\n\ni suppose i should have expanded on this statement a bit further. while not necessarily deployed/published, it could be at any time. there should never be anything in master that would cause a problem if someone made the decision to release now.\n\nCompleting a feature \"login\" makes it deliverable (as all tests pass), but not releasable because it does not support an use case that is valuable to the user.\n\ni think this piece gets into yet another related topic: continuous integration (the practice, not the server/service that automatically tests/builds/deploys). through continuous integration an engineer should be trying to get as much of their progress into master as possible, but that is limited by what is releasable to an end user. the core of the business logic should be possible to integrate into master in a way that stays dark while holding back the (hopefully thin) sliver of the implementation that actually exposes the functionality to the user. in this case you would not integrate the piece that exposes the \"login\" feature to a user until the important, unsupported use case is completed. techniques like feature flags can even be used to make that sliver that is held back from integration into master even smaller.\nso, my point is that anything that is in master should be at least deployable/publishable. if it is not, it should not make it to master. if you are not following a practice like this, i can understand how you would fight the assumptions of a tool like semantic-release.\nnote: maybe we are touching on the distinction between deployable/publishable and releasable, which can be a valuable distinction, but the same mentality should apply. releasable in that case has nothing to do with semantic-release. it has everything to do with deployable/publishable. if what is integrated into master exposes something to an end user that is premature, that is not a problem with semantic-release, but a problem with the fact that that functionality was integrated into master\ndoes that help to clarify the intent some?. > is being published to the wild\ncorrect, which is why it is important for all commits in master to be safe for being published. keep in mind that not all commits trigger semantic-release to publish. in my case i use a type of wip (as opposed to feat or fix) in commits that are forward progress, but incomplete, that i want to get merged into master. you do need to make sure it is \"safe\" to publish because another commit could trigger a publish, but not everything has to trigger the publish immediately after a merge to master\n\nSo with no human involved, this difference (\"while not necessarily deployed/published, it could be at any time\") is muted.\n\nright, my point above is that the primary purpose of using semantic-release is to enable continuous deployment, not just continuous delivery. if that is not your goal, semantic-release might not be a good fit\n\nYour comment basically suggesting all PRs on github should not merge to master, because having one PR merged does not mean the code is \"publishable\" in your term.\n\nthis depends on what is considered mergeable. i am suggesting that it a contribution would result in something that would be problem if published, it shouldn't be merged to master. \n\nOr, you will have to keep each PR around to collect many more changes until it is in a \"feature-completed\" state\n\nthis is one technique for keeping partial implementations that shouldn't be published out of master. however, just because it is not \"complete\" doesn't mean that it can't be published without causing a problem. incomplete and \"dark\" may not be a valuable publish, but it could be published without being noticed by a consumer. again, the practice of continuous integration is very much about the careful integration of as much of an (even incomplete) implementation into master, while carefully ensuring that the bit that would make the feature noticeable to a consumer is not included.\nit's completely up to you to decide what workflow is the best fit for your project and team, but semantic-release is pretty clearly targeted at continuous-deployment and is very good at it. if continuous deployment is not the desired workflow, i'm not sure what value would be expected from using semantic-release. I've found this bot very helpful when using the default convention.. thanks a lot for the quick response. i apologize for being so slow to follow up.\nyou've made some good points about how much of the config is specific to each project. admittedly, there are a number of config options that i have not explored very deeply due to concern around keeping things consistent after diverging from defaults. therefore, there are some of these implications that i have not explored enough to understand fully yet.\nthank you for pointing out mrm i have searched for tools like that in the past, and it seems worth taking a close look at, even beyond semantic-release config.\nthe things that i had in mind that would be helpful in a shareable config are:\n analyzeCommits: i've stuck with the the default for simplicity, but there are times where we've wanted to tweek it a bit based on our team conventions. we use commitlint to ensure our commits align to what semantic-release is looking for. i'd want the shareable config to enable us to align any tweaks we've made to our commitlint config with semantic-release behavior. however, as you mention for other details, there might be a better place than a shareable config for this. if semantic-release could reference the commitlint config directly, maybe a shareable config wouldnt be needed for this detail\n prereleases: i have thoughts around a strategy for prereleases that would work for our team that i think would need to be coordinated across several plugins. since this would be a team strategy, we'd want to make sure each package is codified to follow the same strategy. i'd love to run my thoughts about this strategy by you all, but thats a separate conversation (would another issue be a good place for that type of conversation, or is there a better way?)\ni do think there would be significant value in enabling shareable configs to extend other shareable configs, but i can certainly understand avoiding that complexity at first at least.\ndoes this give some more context for what i was thinking?  what other information would be helpful?. a thought that has been on my mind around this type of flow for a while is how to support multiple pre-releases at the same time. i think npm itself is limited in this regard, but rapid releases when using semantic-release highlight my question even further. i'm happy to take this to another issue if it is too off-topic, but i'm curious around your thoughts about how this would work with this proposal.\nscenario:\n\ni have a feature branch with breaking changes that i expect to bump the major version once merged to master. the changes have a big impact, so i want to publish and test a few -alpha.# or -beta.# releases and test them to ensure there are no surprises.\na team member is working on a separate feature that also includes breaking changes that would bump the major version\n\nhow do i handle the unknown around the order of those breaking changes landing? truthfully, i dont know the actual version until the point of publishing (which is a big part of the point of semantic-release). so, i dont want my feature branch that was branched from 4.x.x to result in 5.x.x-beta.1 because it might end up being a pre-release for 6.0.0 or even 7.0.0, etc by the time it gets published as latest.\nideally, id like the pre-release to be more along the lines of featureName-beta.1, but i don't think that would be supported by npm, correct? what recommendations do you have and how do you think semantic-release can help with this?. i think what i'm understanding from your clarification is that my scenario would follow the idea of a \"future branch\" rather than a \"pre-release branch\", which is a good distinction. as you mentioned, \"pre-release\" seems to be more for grouping changes into a single version bump.\nif we focus on the idea of future branches in my scenario above, i wouldnt really have long lived branches like next, but more feature specific branches. if both features branched from master and the last release there is 3.1.1:\n if a breaking change was introduced to the first branch, what would the first part of the version be? (-beta.1)\n if a breaking change was then introduced to the second branch, same question...-beta.1? \nin both cases, i hope there is an option other than 4.0.0, but im not clear on if that part still needs to be semver compatible or not. ideally, id like that to simply be a string, possibly matching the branch name.\ni'm not sure i fully understand the limitation based on type. is that an upper bound or a strict limit? even for branches that would end up in a major bump, i would still want to allow some commits that dont include breaking changes. would those be prevented?\n  . > I'm not sure I understand your example especially regarding feature branches. A feature (like a branch on whci your develop a feature and open a PR) will never trigger a release. The release will happens when you merge your PR to a release branch.\nmaybe a little more context would help. what i'm referring to as a feature branch in this case would be a branch in the primary repo, not from a fork. i would want the alpha/beta/etc style release to be opt-in and not for every branch. most of my feature branches have a short life and dont need a pre-release before being merged into master and getting released as latest, but there are times where these branches are more complex and live long enough or are disruptive enough to benefit from a pre-release. \ntwo cases come to mind where this could happen at the same time as another feature branch and without disciplined planning to know which will be merged first. \n the first is on my team when multiple team members are working on independent features. this case is a bit more random and less predictable because there are multiple people making changes without impacting each other. \n the second is for side-projects that i dont find enough time to focus on getting features released that involve more complex changes. these often make a little bit of progress here and there when i can sit down and get a partial thought out of my head and into code. admittedly, pre-releases being difficult ends up further demotivating progress because the level of effort ends up being so much higher than typical auto-publishes from master\ndoes that help clarify? these may not be as common as some of the other use cases, but i find them useful. if there is a way to support this approach, i think it could be pretty valuable to some users like me.. thanks. i think we've clarified what i was after. sorry if it created a bunch of noise to get here, but it helps me to have a more solid understanding around what can be possible. \nto restate what we've clarified around this:\n npm requires a version to be included when a package is published\n npm only supports valid semver formatted versions, which does allow for pre-releases like 4.0.0-beta.1, etc\n feature-beta.1 and similar do not fall into this category because feature does not follow the #.#.# format\n what i would ideally like for supporting the scenarios that i described is not possible\n* since npm does not support it, semantic-release cannot either\nso with all of that said, if a project does manage to be disciplined enough to stay focused on limiting to intentional breaking changes that would bump from 3,x.x to 4.0.0 to a single pre-release branch, what happens if 4.0.0-beta.1 and 4.0.0-beta.2 have already been released in that branch but a breaking change slips through to master before that pre-release is ready for promotion to latest? is the next pre-release then 5.0.0-beta.1? is that limited by the branch name or other config? these are the confusion points i've always had about semver prereleases because you dont truly know what the version number will be until it gets fully released.... > With pre-release version, nothing of that true. Or to be more precise nothing of that is enforced. You can release any version with any type of commit inside.\ni guess that makes sense, but is a bit unfortunate. it definitely leaves the opportunity for the version to confuse a consumer rather than inform them of the risk of updating. i understand its a bit different in the case of pre-releases but it just feels like there should be a more clear way. i dont know what could be though when npm doesnt allow deferring the version choice. as you mentioned, there might be some valid cases for this, so maybe its not actually a bad thing\n\nWhat's tricky here is that pre-release version live in their own \"continuity\"\n\nthis is the part that i keep coming back to. i agree that they should live on their own until merged to master, but the requirement to decide the #.#.# when starting the series of pre-releases limits that ability in my mind. still a shortcoming of semver itself, not of this proposal\n\nthe fact the pre-release branch specifies 4.0.0 is irrelevant and appear to be useless. But it's required by the SemVer spec\n\nthe idea of including the version number but ignoring it is at least a way around the limitation so that the feature name could be treated as the meaningful part. i suppose alpha or beta could still be included as well to communicate the stability.\n\n\npre-release: release version formatted as specified by SemVer (x.y.z-preid.N, for example 4.0.0-beta.1)\nFuture release: Release done on a dist-tag. Follow the normal SemVer (x.y.z)\n\n\nthis conversation has been very helpful in getting my head around semantic-release/evolution#1. the point above maybe points out something i've been overlooking. you mention that a future release is done on a dist-tag. would a pre-release be published to the latest channel? i would not have expected that if thats the case. i would only expect it to hit latest after it is no longer a pre-release.\n. thanks again for working through this. while still limited by npm from getting to where i'd hoped, i think you've given some very workable solutions. \n\nBoth are done in a dist-tag. In case of a pre-release, if the dist-tag is not specified the preid (i.e. beta in 4.0.0-beta) will be used.\n\nthis might be worth clarifying in https://github.com/semantic-release/evolution/pull/1. only latest is listed for channel under the pre-release section.\nso, a couple follow up questions:\n if i have a pre-release of 4.0.0-some-feature-alpha.7 and want to promote it to 4.0.0-some-feature-beta.1 what steps would i use? since semantic release ignores the version and preid, i realize there wouldnt be provided process, but what would the manual steps be? is it as simple as renaming the branch?\n if i have two future branches in addition to master with activity, do publishes on each impact the others since the version is incremented normally for each? i see that stalled branches are expected to be updated with changes from master, but the reverse can't be true if the changes aren't ready for promotion. is this type of a scenario simply a reason not to use future branches when these things are possible?. > why do you need to publish it to npm at all? Why not install from git directly in these cases?\ni used to do that type of thing quite a bit. once i started adding a build step to distribute common-js and es-module bundles, that isn't realistic anymore. main and module are defined so the bundles are loaded from lib/, which is ignored from git because that is the output directory of the build step. i dont know of a way to make this work when depending directly from git w/o adding pretty significant complexity to enabling the build process after installation.\nin reality, we currently avoid dist-tags altogether at this point. this mostly works well because we are very disciplined to follow true continuous integration. there are exceptions where a pre-release would be very helpful for a risky change, so if semantic-release made the process easy to publish and iterate on pre-releases, we'd be far more likely to do it. we would still need to manually specify the version in the consumer, but it would give us simpler ability to test a version in a real environment before promoting it to latest.\nsemantic-release was transformative for our willingness to pull code out of applications to separate packages, so making this process easy has the potential to have a big impact as well.\n\npeople wouldn\u2019t get new versions automatically with npm\n\ni'd love to see greenkeeper change that if a project already depends on a pre-release :)  \n\nIf you have feedback to semantic-release/evolution#1 I\u2019d suggest you comment directly on it, that\u2019s why we do it :)\n\nwill do :). > just running npm install will not install the newest version because there is no semver version range that covers 2.0.0-beta.1 and 2.0.0-beta.2\ni see your point, but that doesnt really impact me or my team, we dont really rely on semver ranges but instead use lockfiles and depend on greenkeeper to keep us up to date. because of https://github.com/greenkeeperio/greenkeeper/issues/506, we also have to pin exact versions of our direct dependencies, which has worked well for us so far. the only reason i am very interested in defining ranges would be to let greenkeeper know the upper bound of my desired range, to prevent PRs for versions that I know my project isn't ready for yet.\neither way, i'm still not sure how to handle the loss of the published artifacts that arent versioned with the source code. i just finished up a prerelease where i created an alpha branch, (alpha this time, but beta is typically be more common for my flow. i expect that it would behave the same, though), pushed changes as normal and semantic-release worked very nicely to publish multiple ...-alpha.1, ...-alpha.2, etc versions to the alpha dist tag. once i merged the branch, the new version was published to the latest dist tag as expected.\nthis project just uses the default config with no config file and i publish from travis using npx semantic-release@beta\nwell done @pvdlg!. also, i really like how the github release notes for the full release after the prereleases rolls all of the changes up from the prereleases. i think that'll be really handy for consumers that don't subscribe to non-latest channels. i just published a couple of beta versions. first a fix, then a BREAKING CHANGE. the first published a patch pre-release, as expected. for the second, i expected the pre-release to be bumped to a major, but a second pre-release of the patch was published.\nis this the expected incrementing behavior? from the log, it appears that it was correctly detected as a major change.. gotcha. im familiar with the behavior once things get merged, but i guess i had an incorrect assumption about the pre-release versioning. i assumed it would increment the patch pre-release until a more impactful (minor/major) change was added and then would publish a minor/major pre-release instead. fair enough if thats not the expectation. i've been thinking about this some more and thought it could be helpful to at least share a bit more about where my assumptions/hopes came from. Not necessarily trying to convince anyone about a change, but at least maybe adding a few more thoughts around the topic:\n\na pre-release always seems to advance by just updating the pre-release number, the \"actual version\" number always stays the same\n\ni mostly agree with this and have followed that mentality when manually publishing pre-releases. however, i see two problems that i've either run into in that approach that i think could be different when using semantic-release. \nmanually, i could think through the changes that i expect to make and do the semantic math myself to set the initial \"version\" to match the most impactful change i expect to make. if i know i'll be making a breaking change, ill make the inital pre-release suggest that. with semantic-release, it depends on which change is made first. in my case above, i made a commit that triggered only a patch before making a commit that would normally trigger a major. admittedly, this time that order was to test out what semantic-release would do, but i've followed that approach legitimately many times in the past (and was why i was curious).\nthe second piece is that i could simply be wrong. i may not realize that a series of pre-releases that i expected to only add new functionality would end up forcing me to break a public api. in normal use of semantic-release, i purposely dont fret about these types of things because i know it will handle translation of my changes into the proper semantic version.\nin addition, theres always the possibility that master releases an independent change that increments the version published to latest beyond what the pre-release is referencing. that ends up being downright confusing for the next pre-release, so the ideal behavior, in my mind, would be that the pre-release version would account for that as well after merging master into the pre-release branch.\nwhile i agree that the version part of the pre-release tends to be somewhat meaningless, i think semantic-release has enough information available to potentially make it more meaningful. as a consumer, it is certainly helpful to understand, from the semantic version, what the impact of the change is. when pulling in a pre-release, that information is a bit different, since it is the impact relative to what has been deployed as latest. however, without the updates that i'm referring to, its more relative to what was deployed as latest when the first pre-release was cut and only suggests the impact of the first change(s) that resulted in the publish of that first pre-release.\nas i said, i can see both sides and am not necessarily trying to convince that there should be a change, but hopefully these details help articulate what my assumptions were since i think there is a potential opportunity for semantic-release to provide further semantic value for pre-releases.. was the token created while your account was configured for auth-and-writes and then your account was switched to auth-only? i think it matters when the token was created\nfwiw, i have been successfully publishing with semantic-release with my account using 2fa for auth-only for quite some time, so i can at least confirm it does work. my bet would be that it is related to the token you are trying to use.. to capture discussion from gitter, another scenario that could be very helpful as a commit check for PRs would be to run verifyRelease plugins and fail the commit check if the plugins return failure. \nthis would enable the maintainer to choose between a few options before the PR is merged to master:\n modify the PR so that the breaking change is removed if it was an unexpected breakage\n modify the commit message so that it is properly marked as a breaking change\n* mark the branch as a pre-release to trigger publishing versions that are not tagged as latest, with the help of the functionality from #563 . @felixbecker I'm not quite sure what you mean. \nI am a commitlint user, but commitlint only verifies that the message format matches the defined pattern. It does not ensure that a breaking change would not resolve to a patch based on the types from the commits. \nIf this is the cracks you are referring to, that is exactly the type of plugin I'm referring to for verifyRelease, but also dont-crack, which i think could be a better fit for projects like an ESLint config that would make less sense to have it's own test suite. \nThe problem with current state is that sensitive release only runs the verifyRelease plugins while preparing to publish from master, where it is too late to amend a message to mark the change as breaking or amend the change to remove the breakages cleanly, etc. \nIf the bot proposed by this issue acts as a commit check for a PR, as described above, it has the potential to handle these checks before merging to master and enable more appropriate handling. . this has impacted a number of my projects as well due to lockfiles pinning an older version. since there is a vulnerability, i think that it does make sense to move the minimum of the range defined by semantic-release to a version beyond the fix of the vulnerability. even though it probably isnt realistically impactful based on the usage, this would satisfy warnings for a lot of users with minimal impact to semantic-release . It is correct that the lockfile of the semantic-release project would have no impact on consumers, so I don't think that is what is being proposed here. \nAs you mentioned, the lockfile of the consuming projects is the issue, to an extent. npm only updates a local dependency from a lower in-range version to a higher in-range version in a clean install, even without a lockfile because it already has a version that satisfies the range.\nWith the semver range defined by this package, the version with the vulnerability is an acceptable version that satisfies the defined range. All we are proposing is to update the acceptable range to a minimum that does not include the version that has the vulnerability. As you mentioned, the use by this project probably doesn't really run into the case that the vulnerability impacts, so it could still be reasonable to say that the version with the vulnerability is still acceptable for this particular project. Fair?\nThe other benefit of updating the minimum of the range if you were to decide that the problematic version were not acceptable is that npm would then take care of updating to a newer version, both in cases with lockfiles (w/o hand editing the lockfile) and when installs happen into a dirty workspace.\nIts not a misunderstanding of semver that raises the request, so I wanted to clarify at least my intent. It won't upset me if you still decline since the vulnerability shouldnt really impact semantic-release.. I'm certainly not proposing needing to increase the minimum of the range every time any package updates. Security vulnerabilities are a special case in my book (but it is also influenced by the fact that github sent a notification for all of my projects that have this in their dep tree). Since this vulnerability doesnt actually impact sematic-release's use, I'd still say its probably not worth extra effort. This is why I only spoke up on an existing issue rather than opening my own :) The rest of this is mostly to talk through the theoretical aspects as long as we are still interested :)\nHowever, I do think there are special cases like this when I think it is appropriate for a project to limit the semver range further than they normally might. The other case is a breakage that didnt bump semver appropriately. If the project knows that there is a version within their specified range that breaks the functionality of their package, I think it is helpful for them to exclude that version from their range.\n\nProject that currently use semantic-release with a package-lock.json will not get the updated version of marked until they update their package-lock.json whether or not we update the marked range in semantic-release.\n\nThis is true except for the manual editing of the lockfile. I may have to \"manually\" install the new semantic-release version, but by doing so, npm takes care of updating the lockfile for me. Regardless of opinions on whether or not a lockfile should be used, we should be able to agree that no human should manually edit that file. that is npm's responsibility. like @simlu, I pin versions in my package.json (mostly due to https://github.com/greenkeeperio/greenkeeper/issues/434), but compensate for that by letting the combination of greenkeeper and greenkeeper-keeper keep them up to date for me automatically.\n\nProject that currently use semantic-release without a package-lock.json will get the updated version of marked when they do npm install whether or not we update the marked range in semantic-release.\n\nThis is only true for clean workspaces or when node_modules/ has been cleared or maybe for a npm rebuild, etc.\n. @simlu as far as greenkeeper updating your lockfile, i've had good luck so far with greenkeeper-lockfile outside of the fact that it has to make an additional commit for the lockfile updates. have you had trouble with that?. > Ideally npm should provide a way to update a sub-dependency via CLI. But it's not the case....\nThis! We're in the early days of using lockfiles with npm, but I hope things continue in a positive direction to handle things like this.\n\nIn conclusion, if you want to use a package-lock.json regenerate it frequently to stay up to date.\n\nUnfortunately, this doesn't seem to be an action that is enabled very well through the CLI. Do you know of a way to do this effectively? No worries if not since I'm aware you're avoiding their use.\n\nBut GitHub didn't reported the problem to the semantic-release repo. I imagine it's because the fix for it is in the range we declared?\n\nAlso a fair point. We're also very early with tools like the vulnerability reporting from tools like github, snyk, nsp, etc. Until tools like that start automatically sending PRs to projects, similar to what greenkeeper does, I think the best we can hope for is for package consumers that get the notifications to open issues to start conversations like this. Thank you for having the patience to work through the conversation with us.\n\nObviously the 3rd choice is not reasonable. That was my point in this thread.\n\nI hope its clear that we don't want to suggest that we'd want semantic-release to be responsible to keeping its dependency in our project. This particular dependency simply deserved special consideration around whether the allowed range should be tightened up. Even if we landed on the answer being no in the end, I think the conversation is worthwhile in special cases like this. Sometimes it is worth exceptions to event defined common practices so its doesnt hurt to at least ask :)\n\nIf you use a package-lock.json you give up the ability to get an up to date dependency tree.\n\nI think this is the key point to all of this. Everything is about tradeoffs. Different maintainers will make different decisions about which are most important. For me, predictable but slightly out of date outweighs unpredictably/inconsistently up to date. My use of greenkeeper/greenkeeper-keeper shortens the time that my non-direct dependencies are out of date even further, especially for the direct dependencies that update often. There is no perfect solutions. Dependency management is hard. We've all got to find workable solutions that work for us and our teams.\nThe fact that we are even this deep into this conversation means we are far further in understanding and considering the tradeoffs in this space than most. I really appreciate thinking through a problem like this with you. Projects like semantic-release, greenkeeper, etc have the potential to make these problems far better than vanilla npm for teams that might never get this deep into considering what we're talking about. Thank you for the work you're putting into this space!. Very well said. All very valid points. I still stand by preferring a lockfile over not for my projects, but that is absolutely because of careful consideration of the tradeoffs that are not well known to many. \nThe lack of emphasis on educating the community about the tradeoffs has absolutely caused a ton of problems throughout the community. Unfortunately, it is starting to seem like many conversations, unlike this one, simply land on \"lockfiles are hard; give up on them\" rather than trying to drive decisions to be educated about the tradeoffs. \nSince communication from npm and yarn falls so short of properly educating, do tools like semantic-release stand in a strong enough position to help fill in the gaps (as if you don't already have enough on your plate)? If nothing else, it seems like the audience of tools in this space is likely to be the most interested in better understanding reality. Educated users of these tools are likely to share knowledge along with the information of the success they've had with these tools.\nWhat else can we do to encourage educated decisions in this area?. >  I was convinced that in the script phase any failure would prevent other step to run. That really sounds like a bug in Travis to me...Most CI work that way.\nsame here until my team member noticed a failure that still continued on to publish today. he found the issue thread that i linked above and it seems like most would agree that it is unexpected, but they dont seem very interested in changing it. I expected it to work as if the steps were separated by &&, but instead appears to behave like ;\nmy team has been using the script deploy provider successfully for several tasks for quite a while, but i only thought to go that route for semantic-release as part of our conversation today after running into this issue. \ni used to to the after_success stage, but we definitely had cases where we would be unaware of failed publishes.\ni just went through the process of moving a bunch of projects over to use the script stage instead of after_success, but it looks like ill be needing to go back and give the deploy stage a try now. i think that one should at least accomplish the the desired goal.. > I'm definitely interested to get feedback from you regarding the deploy step.\nAnything in particular that you're interested in beyond the fact that it's been working well for us for other tasks?. it is unfortunate that it still prints that message in the output, but its been available as a provider for quite a while. i don't understand why they would still consider it experimental. theres not much to it and hasnt been touched since Apr 21, 2016.\nit is an option to submit another provider to travis if a semantic-release provider would be preferred longer term. . Any reason not to document both deploy and after_success and highlight the trade-offs (no notification of failure for after_success or an experimental warning printed in the build output for deploy)?. A big part of the previous recommendation to use after_success was because semantic-release used to exit with non-zero for non-failure scenarios. Since after_ steps don't fail the build, it was important to run from there. That problem has been fixed, so it seems less valuable to recommend an approach that wouldn't notify on failure as the only recommendation that doesn't require the added complexity of stages. . also, in case you are running semantic-release from the publish step on travis, make sure you set skip_cleanup: true or travis will cleanup the files that you built before publishing.. nice work! this is a big win. really excited for this, both in my own projects and those i'm a consumer of or try to find time to contribute to :). @jourdain looks like a case what i reported in https://github.com/semantic-release/npm/issues/54 rather than a github issue. i've only noticed it happen once, so i'm keeping my eye out for more cases but havent pursued very far yet.. > If you are making prerelease that's a different story as they are outside the normal semver rules.\nFrom the above example, if you release 2.0.0-beta.1 and 2.0.0-beta.2, then after the merge will find the last release as 1.0.0, which is intended, and release 2.0.0.\nthis is what i expected to happen, but as you can see from the logs, it found the 2.0.0-beta.5 tag and only considered commits from there. . that took care of it. thanks for the quick resolution!. Oh, ouch. That's unfortunate. \nI use the shorthand in almost all of my packages. Looks like I've got some updates ahead of me. \nAny chance supporting the shorthand is on the roadmap?. > I guess we could support the shorthand but only for one provider (probably GitHub)\nI think that is completely reasonable. As far as I know the shorthand is only supported for github on the npm side of things as well.. so, i did forget some of the detail around the shorthand. it looks like each can be supported (not necessarily saying they should be for semantic-release) with a prefix. the current docs dont seem to make it clear that the non-prefixed shorthand is only for github, which was my previous understanding.. the npm install docs do seem to further suggest that the non-prefixed shorthand is limited to github though:\n\nNote: if you do not include the @-symbol on your scope name, npm will interpret this as a GitHub repository instead, see below. Scopes names must also be followed by a slash.\n\nalso:\n\nnpm install \\<githubname>/\\<githubrepo>[#\\<commit-ish>]. @pvdlg thank you so much. you continue to impress me by the great work you do for this project and your willingness to run with thoughts from consumers.\n\ni just tested the @next release on a public project and it did resolve the issue. here is the output from the previous build where it was still broken.\nthanks again!. the only commits that is see in the logs that you link to that follow the commit convention are of type chore(), which does not trigger a release. which commits did you expect to trigger a release?. feat: does not follow the default commit convention. please review the details linked to above to ensure the expected syntax is followed. @simlu could you expand on some details of your use case? i'm sure it would be helpful to understand what it is that you are trying to accomplish that other plugins, especially exec, can't already help you with.. ive noticed similar in some of my builds. are partial matches replaced, or only full matches? i've noticed that do or maybe doc has been getting replaced. i definitely haven't set any secure variables that would be a full match to that, but could maybe see a partial match of a randomly generated secret. . the 5 character minimum seems reasonable. i wonder though, is there a need to be quite so generic? is there already a list of variables used by semantic-release that could be used as a whitelist, or is it important to go beyond those used for semantic-release?. > The problem is that plugins can use any environment variables, so there is no pre-defined whitelist.\nok, that makes sense.\nremind me, i assume this filtering is intended for non-travis ci services, correct? i'm fairly certain travis expanded it's own filtering of values that are stored in encrypted environment variables. thats my normal use case, so this isn't really an issue in that context, but i know semantic-release needs to support more than travis.. > And yes we support a lot more than Travis. I don't know which other CIs also hide value of environment variable in the log output, but I'm sure there is some that doesn't. And better be safe than sorry....\nagreed in those cases. the part is was wondering about though was whether that opened any possibilities in this specific case since this is limited to travis.\n\nJust a slightly related FYI point: In all CI the environment variables are available only for builds that runs on the repository itself, and not on forked ones.\n\nthis is actually one of the reasons that i'm such a fan of travis. it is intentionally built for workflows involving PRs from internal branches as well as third-party contributions. configuring other CIs to follow even close to the same behavior is a pita. however, many users are unaware of some of the benefits like this one, so this is definitely a detail worth calling out for awareness.. the readme includes details about the commit message format and the result of each type. only those will trigger publishes and would be considered the \"relevant code changes\". all other commit messages would not trigger a publish.. @pvdlg seems like this has tripped people up a few times. i wonder if double-quoting the plugin names, or something similar, would be enough to clarify this for users.. sure, i could put something together tonight. . while updating npm tokens, i found a package that i missed updating to a recent version of semantic-release, so it had lots of commits since the last publish, similar to what is described above. it hit rate limits as described above as well.\nsince this is public, here is a link to the failed build in case it is helpful. the plan to wait for octokit handling of this seems totally reasonable. i have no reason to add any time pressure, just providing some additional detail.. hmm, no i shouldnt have had any other activity at the same time as this from what i've looked into. a lot of my activity is still backed up behind getting new tokens in place.. plus this is a bot account that has a pretty small list of repos that it interacts with.. yeah, hard to say. this is the first time i've ever seen it and it was only because of a backup due to a misconfiguration. i'm happy to provide more examples if i end up seeing more, but it seems unlikely that this will cause me enough trouble to worry too much about.. i think you need to remove the release layer in your file above. that layer should only be needed if your config is in a package.json if i remember correctly. to clarify, by \"works fine\", do you mean it successfully published, or didn't fail the build? i ask because a non-zero exit code in deploy will cause the build to fail, but will not in after_success. would defining assets within the github plugin config cover your need?. major bumps have been working fine for us with the default convention. \nit's hard to tell from what you show above, but are you putting the BREAKING CHANGE: in the subject or the body? it must be in the body and be exact (notice the : that i included that you did not above). \ni also tend to typo things like that, so i prefer to use commitizen to format the message rather than type it manually, only to learn that i had a typo after it published differently than i intended.. this capability is currently in pre-release status itself. take a look at this summary and the rest of that thread for more detail. see the FAQ for the reasoning behind the current approach. \npublishing a pre-release to the alpha or beta channel is even easier by using the beta channel of semantic-release. You can install it with npm install semantic-release@16.0.0-beta and you can find the corresponding doc on the beta branch.. i'm a bit confused why you would want to publish packages from the netlify continuous-deployment infrastructure. from what i understand (and use it for), it is intended for deployment of netlify sites to the the netlify infrastructure more than as a general purpose continuous integration platform. \nwhat is your use-case that caused you to attempt to publish from there?. please take some time to read through the documentation. all of this is covered there, including why the version is not updated in version control.. its never a great idea to disable verification. it would be a much better idea to reach out to your ci service and have them investigate why the failure is happening.. have you seen the support for pre-releases that is available in the beta version of semantic-release? what you describe sounds like it would largely be satisfied by that support: https://github.com/semantic-release/semantic-release/blob/beta/docs/recipes/pre-releases.md. > Why force the pre-releases into channels?\nI think its important to remember that a channel is always involved, but not specifying one means that the default one (latest) is used. latest does come with several conventions attached to it. You mentioned the fact that npm install <package-name> would install a pre-release rather than a stable version, but there are others as well. \nOne that would be a big impact for users of tools like greenkeeper is that it sends PRs for new versions published to latest, but not to other channels. Personally, I automatically merge any greenkeeper PRs that pass all verification, so going automatically from a stable version to a new pre-release would not be desirable.\nOne of the many things that I find valuable about semantic-release is that it makes it harder to accidentally abuse conventions that would result in upset consumers while also making it easier to do the right thing, even for some of the complex areas like channels. The newest semantic-release versions have made pre-releases to channels so simple that I can't imagine it being valuable enough to simplify for an edge case that then makes it possible for users of semantic-release to opt-out of the protections that are currently in place.. also, keep in mind that you would have to make your GPG key available on your CI server in order to do the signing. you at minimum would want a separate key from your normal one so that you dont put your personal key at more risk of exposure. at that point, things start to get a little confusing around who actually signed it since its not your normal trusted key. \npersonally, if i were to ever consider this, i would create a key that is associated with a bot account rather than me and use it only for this. would the signature of a key for a bot be as trusted as a maintainer, though? the risk of accidentally exposing the key somehow from CI would probably outweigh the value in my mind. plus, in order to use the key, you would either need to create a key with no passphrase (which has no protection if exposed), or also expose the passphrase to the CI (which would then also be possible to steal if anyone gained enough access to steal the key).. i can confirm that GH_TOKEN is working properly for my many packages that i publish from Travis. I would start by making extra sure that the token that you think is available as the GH_TOKEN environment variable on travis is actually the one that is there and that it has the appropriate permissions.. > I'm having exactly the same issue\nsince the original problem here was concluded to be related to azure pipelines, i don't think the cause of your issue is exactly similar as you suggest. i would recommend opening a new issue rather than adding to an issue that has already been closed. \nalso be sure to sure previous issues to see if any others are helpful that are more specifically related to jenkins. similar problems have been reported in the past that might have solutions described that could be helpful. if not, a new issue would be the best bet. From the logs that you posted above: \n\nIf you are using GitHub Enterprise (https://enterprise.github.com) please make sure to configure the githubUrl and githubApiPathPrefix options (https://github.com/semantic-release/github/blob/master/README.md#options).. ah, sorry. your details about your semantic-release config file blended in with the log output when i thought i could be helpful quickly. i saw your package.json details, but not the other.\n\ni'm not confident about this, but i think the trailing slash on the prefix needs to be removed. \nbeyond that, my suspicion is that the problem is related to the use of the ssh url in the package.json repository field. while you may be pulling the code from your repo over ssh, semantic-release interacts with github through its api, so i believe it needs the https version, which is also the recommended version by npm.. > In that article it is explicitly mentioned that SSH as well is supported.\nthis is true for interactions with git, like pushing tags, but i do not believe the same is true for interactions with the github api, like publishing release notes. \nsince i'm not a maintainer, i'm not fully familiar with the internals, but this part of the log suggests to me that the github plugin is attempting to ensure (over https) that it will be able to perform the interactions with the api that it is configured to perform:\n```\n[2:36:14 PM] [semantic-release] [@semantic-release/github] \u203a \u2139  Verify GitHub authentication (https://github.xxx.com/api/v3/)\n[2:36:23 PM] [semantic-release] \u203a \u2716  Failed step \"verifyConditions\" of plugin \"@semantic-release/github\"\n```\nif the server is not accessible over https, i would expect that is the reason it is failing to be found at that step.. this is configured this way very intentionally, and i expect that it would be very unlikely to change. see https://semantic-release.gitbook.io/semantic-release/support/faq#can-i-set-the-initial-release-version-of-my-package-to-0-0-1\nthat said, the recommended way to defer publishing a v1.0.0 is to publish pre-releases until you are ready to publish a \"stable\" or \"functional\" release (i mention both because \"stable\" implies more maturity than is encouraged). the beta version of semantic-release supports publishing pre-releases with basically no additional configuration, and i have found that approach to a be very effective alternative to v0.x.x. documentation is on the beta branch, with the features: https://github.com/semantic-release/semantic-release/blob/beta/docs/recipes/README.md#release-workflow. fwiw, i've been using the beta successfully with a bunch of my projects and haven't had to add any special config other than naming my branches alpha or beta. the only other config i've changed is making sure that travis runs semantic-release on all branches instead of only master (because i use the deploy step).. have you configured semantic-release beyond the defaults? see https://semantic-release.gitbook.io/semantic-release/support/faq#why-is-the-package-jsons-version-not-updated-in-my-repository. typo: \"strats\" => \"starts\". ",
    "sobolevn": "This would be an amazing feature. Do you have any plans on it?\nJust saying, that there's a fork for that already: https://github.com/atlassian/lerna-semantic-release. I haven't tried it actually.. https://github.com/atlassian/lerna-semantic-release works!. ",
    "jan-molak": "@sobolevn - Do you know if the atlassian fork is a good substitute of semantic-release? I'm using semantic-release right now and loving it, but am planning to migrate to a mono repo which this project doesn't (yet?) support.. ",
    "jony89": "Are there any plans for this? \nLerna has become a gr8 tool and the fork is not updated at all.\nThis could be extremely useful! . @sobolevn, regard lerna-semantic-release :\n\nit's not up to date. a merge with semantic-release need to be done.\nI am not sure, but it forces me to use commitizen\n. \n",
    "FezVrasta": "Is this still being taken in consideration?. Any chance to perform the work suggested by @paulkenney?\nAre PRs accepted for this?. Do you know if there's a Lerna integration for it?. Is there any progress on this front?. Having the same problem with JFrog, is there a solution?. ",
    "PostCrafter": "I just wanted to point out that there is a plugin that already handles the splitting of commit history and separate releases by running semantic-release for each package separately.\nIt would be nice however to have another solution that somehow synchronizes the steps so we could also update cross-dependencies and/or have release commits for multiple packages.. ",
    "pmowrer": "Glad to see there's an active discussion on the subject!\nOur company has only recently moved our component library to a monorepo approach (with individually versioned packages). Having a tool like semantic-release has proved invaluable as it greatly reduces the time and tedium spent manually versioning and publishing, and reduces the risk for mistakes!\nSince semantic-release doesn't (yet) support monorepos, we've been developing a set of plugins called semantic-release-monorepo (as noted by @PostCrafter above). We don't claim in any way to be experts on monorepos, but so far it's been working out great for us!\nTo chime in on the conversation, I agree with the points @felixfbecker is making. It seems unnecessary and out of scope for semantic-release to worry about catering to every part of the build/release/ci process. Great tools do one thing well and that's right where semantic-release is right now. We have lerna (and others) to manage running semantic-release across multiple packages. We have yarn workspaces to optimize installation of dependencies across multiple packages. \nBy this standard, I think lerna is a good example of a tool that's doing too many things (probably due to the lack of options in managing a monorepo). I was initially looking at lerna publish for automated releases but found semantic-release to be a much better tool for this task. Along these lines, it seems to me that lerna bootstrap has been yielded to yarn's workspaces, which makes sense since yarn is all about managing dependencies. In the way we've been using it, lerna's purpose has entirely been running tasks across multiple packages and none of the other functionality.. Thanks for implementing these features, @pvdlg! I'm going to release a compatible version of semantic-release-monorepo soon.\n\nHowever it seems the solution I proposed in this comment which is similar to semantic-release-monorepo doesn't work as the following is missing:\n\nDefining the order in which release have to be done\nUpdate the package.json for cross-dependency\n\n\nI understand the complexity here, but to be clear, this is not a scenario semantic-release-monorepo supports, or even attempts to. I agree that updating package dependencies is out of scope for semantic-release and I don't think its necessarily a required feature of a monorepo (or multi-package \ud83d\ude0e ). . I don't think the scenario you describe is possible in a monorepo where each package manages its dependencies through npm, including cross dependencies, using a lock file. That's the assumption semantic-release-monorepo is making. \nYour scenario breaks because moduleB can't depend on a new moduleC version unless it explicitly installs it (updating its lock file). In order to install the new moduleC version, it must have already been published.. Why would moduleA expect moduleB to return an array? It's explicitly depending on moduleB version ^1.0.0, which returns a single value. It has to wait until after moduleB version 2.0.0 is published to use the new version.. > If you use a mono-repo with lerna, lerna publish will take care of such scenario and and would release moduleB, update moduleA's package.json and releasemoduleA\nSure, but semantic-release-monorepo doesn't aim to support this behavior.\n\nThe benefit of a mono-repo is that you can modify multiple packages at once.\n\nYou still can. You just can't depend on an unpublished version of a package. Personally, I haven't found this to be a problem.\n\nSo if you don't support modifications that spans across multiple packages in the mono-repo, you loose the main advantage of having a mono-repo.\n\nI disagree. When you have many similar packages (e.g. a component library), having separate repositories for each individual package is much more difficult to manage.. > For the general case of mono-repo to work (as lerna, babel, etc do it), any change in a dependent (local) package must result in a new release of the depending package.\nIs this mainly about using linked packages in a lerna repo?. Hi @pvdlg! Thanks for your review and very thorough comments!\nI don't think we're at odds here. Addressing the three criteria you listed:\n\n\nThe proposed semantic-release-monorepo plugins are entirely third party and are not intended to be coerced onto semantic-release (I'd be happy to change the name if you feel it implies a relation to semantic-release). \n\n\nThe proposed change to semantic-release (this PR) doesn't change (or propose to change) its functionality at all. It simply allows customizing semantic-release further, getCommits being one of the few functions that isn't already extracted into a plugin. \n\n\nThe proposed workflow of semantic-release-monorepo is, as far as I can gather, entirely in-line with semantic-release's core principles. The proposed workflow is simply scaling the semantic-release workflow/core principles across multiple packages.\n\n\nTo address your other points:\n\nThere is currently multiple monorepo solutions: lerna, builder I think, yarn workspaces, zelda and many custom ones\n\nI'm familiar with lerna, builder, yarn workspaces and zelda. I believe they're essential tools to making a monorepo work, but they handle dependency/task management across many packages, not automatic releases. They are complementary to semantic-release, allowing it to scale across a monorepo. In fact, I use lerna and yarn workspaces in the semantic-release-monorepo workflow.\n\nMoreover your solution seems to be based on determining the files modified by a commit. It will probably be complex to handle situation in which a commit modify files across multiple sub-package. \n\nIn the proposed workflow, a commit can belong to multiple packages all at once (if the commit touched files across multiple packages). Personally, I don't see a problem with this. That said, this is intended as a third party plugin and not a workflow to be imposed on anyone. Simply use it if it fits your workflow.\n\nThe right way to handle monorepo might be via plugins\n\nThis workflow could be achieved using the existing plugins, but it would require extra complexity and duplication. I could filter the commits passed to analyzeCommits, but I'd have to do the exact same filtering again to generateNotes since both plugins are passed the same commits coming from getCommits. If getCommits would be allowed to be customized the complexity would be reduced.\n\nsemantic-release must continue to identify all the commits since the last release, monorepo or not, as plugins downstream will need that.\n\nThis PR does not interfere with this. The default behavior is still exactly what it was. Only through a third party plugin could this behavior be overridden.\n\nBut all that depends mostly on monorepo specifics\n\nI'd suggest leaving this to plugin implementors. semantic-release-monorepo is just a plugin to represent one approach. . Thanks again for taking the time to write such in-depth replies. Very helpful! \ud83d\ude04 \n\nThe fundamentals of the semantic-release plugin architecture are:\n\nThe core is in control, determine the logic and orchestrate\nThe plugins (as in the exported function of a plugin module: verifyConditions, getLastRelease etc..) do one tasks\nThe plugins have well-defined, simple input and outputs => Plugins know only the minimum they have to know to perform their simple task\nThe core validate the output of each plugin\nThe plugins cannot be interdependent: a plugin cannot call another plugin, and should perform its task with the input passed by the core, no matter what other plugin is used\n\nMoving the commits retrieval to a commit would go against that, by creating plugin inter dependencies. In your implementation for example the publish would be dependent on the getCommit.\n\nGood point! It felt icky extracting getCommits. \nAs an alternative, filterCommits could be a plugin after getLastRelease, a function that takes a predicate (commits -> Boolean) and returns a list of commits. It would enforce the options structure passed to the following plugins and avoid the interdependency. However, it'd be a much more specific plugin and I understand if you wouldn't want to pollute the plugin API.\n\nMoreover it doesn't make sense to exclude some commits. In git the commits (on the release branch) are sequential, and a release is the state at a moment of the commit history. In other terms a release is defined by a commit range, including everything from A (last release commit) to B (new release commit). Some commits within that range might not be written to the changelog, or not be considered to determine the version increase, but they are part of the release.\n\nIn the context of a monorepo, I think excluding commits from a release is fine. If the commit didn't touch files within a package, the commit isn't relevant to that package's release. The commits remain sequential, only some are \"hidden\" because they are irrelevant. I'm not sure I follow what your objection is. \n\nSo if you need commit filtering function shared by analyzeCommits and generateNotes you can do that pretty easily. I think what you want to achieve is possible with the current architecture and the plugin hooks available.\n\nI've refactored the implementation according to your suggestion and it's fine. There are some drawbacks to it:\n\nThe added complexity, as noted above.\nThe need for optimization. The filtering must now be done twice, though that could be optimized away using some (somewhat icky) global state, as in the npm plugin example you referenced.\n\nGiven that my current implementation solves the problem just fine, I agree that it's not worth messing with the core architecture. Perhaps commit filtering is something to consider as the project evolves. For now, I am only experimenting with this workflow anyway. Thanks again for walking me through some of the project!. Thanks again for the thorough write-up! \nFor now, I'm going to continue experimenting with applying semantic-release to a monorepo using the plugin I wrote: https://github.com/Updater/semantic-release-monorepo. As it evolves, I'll think about what, if anything, can be added to the semantic-release core to better support the workflow.. I've encountered the same problem and I think it has to do with running semantic-release via yarn. It works fine running it as npx semantic-release.. > Also I don't think wrapping the CLI is the right approach. \nWrapping the CLI is an approach that most closely achieves what we're trying to achieve in the aforementioned examples and given the current state of semantic-release. In that sense, it's \"right\" for us, but we try to avoid using such language as it typically isn't very constructive. I think it'd be more constructive discussing the relative merits (pros/cons) of each approach and determine when appropriate.\nWhat do you think are the pros (if any) and cons of the proposed approaches?\n\nYou should instead call semantic-release via API\n\nWith the aforementioned tools wrapping semantic-release, we're trying to achieve the following:\n\n\nSame interface as semantic-release CLI (such that you can pass --dry-run and other options).\n\nWrapping CLI: \u2705 \nUsing API: \u274c\n\n\n\nPicking up configurations options from package.json.\n\nWrapping CLI: \u274c\nUsing API: \u2705 \n\n\n\nFor our current use-case, the first requirement is slightly more important and is why we went with the wrapped CLI approach. But, it's not perfect which is why I've opened this ticket.\n. > You can use the API and still pass any parameter (such as --dry-run). This can be achieved by parsing the arguments passed to your CLI and pass them to the API along with some other pre-determined parameters. This is basically what the semantic-release CLI is doing in cli.js.\nHaving to re-implement/copy the CLI when creating a binary has some serious drawbacks. It's duplicated code with a brittle coupling to the version of semantic-release from which it was lifted.\nIt becomes more difficult to maintain such a binary because any changes to semantic-release's CLI implementation must be copied/adapted for each binary.. > 2. When passing a plugin via the CLI, only set the config object's path property and don't throw away the rest of the config set for that plugin (from package.json).\n@pvdlg Is there a particular reason it currently works like this? \u261d\ufe0f \nE.g.:\nbash\nsemantic-release --publish=\"moduleA\"\nThe above command sets the plugin config for the publish command to the string \"moduleA\". What if it instead set the plugin config for publish to { path: \"moduleA\" }? Things would work exactly the same, only it would allow any plugin configuration from package.json to be merged using defaults here. It would make using plugins from the CLI much more useful as you'd at least have a means to be able to configure them.\n. Sure! \nA plugin can be set two different ways in package.json:\n\nString: The module name to use as the plugin. Does not allow passing plugin configuration options.\nObject: The path property is the module name. Allows passing plugin configuration options.\n\nWhen using the CLI, only the first way of configuring a plugin is currently supported.\nLet's say we have this package.json:\njson\n{\n  \"release\": {\n    \"analyzeCommits\": {\n      \"preset\": \"angular\"\n    }\n  }\n}\nAnd we invoke semantic-release via the CLI in the following way:\nbash\nsemantic-release --analyze-commits=\"alternative-analyze-commits\"\nBecause analyzeCommits is set to a string, the configuration in package.json will have no effect. semantic-release will effectively be run with the following config:\njson\n{\n  \"release\": {\n    \"analyzeCommits\": \"alternative-analyze-commits\"\n  }\n}\nProposal\nIf passing --analyze-commits=\"alternative-analyze-commits\" instead was mapped into { path: \"alternative-analyze-commits\" }, any additional plugin options defined in package.json would be merged into that object.\njson\n{\n  \"release\": {\n    \"analyzeCommits\": {\n      \"path\": \"alternative-analyze-commits\",\n      \"preset\": \"angular\"\n    }\n  }\n}\n. > You can call the API, passing any CI arguments with 1 line of code:\n\nawait require('semantic-release')(require('minimist')(process.argv.slice(2)));\n\nThis isn't an equivalent solution. Unless everything in cli.js is copied, the binary won't behave the same (no help output, debug probably won't work the same, exit codes need to be configured). The desired behavior is for a binary like semantic-release-github-pr to work exactly the same as semantic-release, only with a different set of pre-defined plugins. That's the crux of this entire issue.\n\nI imagine that would be a problem for plugin that can be defined as an Array? Or at least it would incur a lot of complexity to handle those cases.\n\nFair point, its a scenario I didn't consider. But, easily addressed by allowing the path property to accept an array.\n\nOverriding the entire value of analyzeCommits when using --analyze-commits=\"analyzer-2\" is the expected behavior. This is because the intent of the CLI options is to enable/disable plugins, and that mean overriding the entire value so it works for plugins defined as Array.\npublish: [\"publish-1\", \"publish-2\", \"publish-3\"] has to become publish: [\"publish-1\", \"publish-2\"] when we pass the options --publish=publish-1,publish-2.\n\nThis would be solved by above suggestion.\n\nIn addition that would allow to create inconsistencies. If the configuration set analyzer-1 as the analyzeCommits plugin and sets options specific to this plugin. If you call the CLI with --analyze-commits=\"analyzer-2\" you will end up passing to analyzer-2 an option that is meant to analyzer-1, which probably not what a user want to do.\n\nThis is basically what I was looking for when asking \"Is there a particular reason it currently works like this?\". I agree changing it could be confusing, but in my opinion it's equally confusing the way it works now. I don't see a strong reason why it should work this way, but \"historical reasons\" makes sense.\n\nUse a shareable config module once a good solution is found for #549 and it's implemented\n\nLooking forward to this then! \ud83d\ude04 . Sure! The first suggestion in the first post of this thread is a variation on the \"CLI extends\" feature that you propose in #549.\n\n\nA \"config path\" option, allowing for passing a path to a file that returns the JSON format used in package.json (perhaps with package.json as the option's default).\n . I think being able to do a --dry-run w/o the CI restrictions is\nvaluable. I'd vote for --no-ci! Thanks for sharing the discussion!\n\n\nOn Sun, Dec 31, 2017 at 6:47 PM Pierre Vanduynslager \nnotifications@github.com wrote:\n\nI mentioned a possible solution in this comment\nhttps://github.com/semantic-release/semantic-release/pull/578#issuecomment-354579928\n.\nBasically we would allow (but not recommend) to run Semantic-release\noutside of a CI. It could takes different form: a --no-dry-run, --no-ci\nor --local options for example.\nSetting this option would by pass the isCi and isPr checks.\nWould that works?\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/semantic-release/semantic-release/issues/584#issuecomment-354628488,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAVv4OG1vICAeQeJUOEEfCJjpBxIa0etks5tGB0qgaJpZM4RP84B\n.\n. \n",
    "evocateur": "\nBy this standard, I think lerna is a good example of a tool that's doing too many things\n\nI agree! (I'm the currently-active maintainer of lerna)\nI'd love nothing more than to be completely replaced by package managers and robust plugin ecosystems like semantic-release. I've been really impressed by the quality and frequency of @pvdlg's contributions since taking over the project. I am open to collaborating on a multi-package (I kinda hate the term \"monorepo\") semantic-release plugin, and I'll definitely be checking out the progress made in semantic-release-monorepo.\n\nit seems to me that lerna bootstrap has been yielded to yarn's workspaces\n\nNot quiiiite yet, as not everyone uses yarn (nor intends to). npm support for multi-package repositories is forthcoming, as far as I can tell from reading the tea leaves (aka tweets/comments from npm core CLI devs).. @gr2m Thanks for the heads-up! I'm neck-deep in a massive refactoring of lerna right now, so it's probably for the best. :D. @pvdlg: My apologies for the delay in response. Turns out infants make focused free-time a thing of the past.\nBriefly:\n- I'm not sure running semantic-release in n+1 packages will be sufficient, or correct, as during any given lerna publish there can be a range of actual npm publish calls, from \"all\" to \"none\" (if all extant changes were in non-managed directories or files, for instance).\n- The cross-dependency bumps are vital to the lerna pattern, and they really only work with one high-level process to coordinate those bumps (which also need to happen in topological order, so you don't try to publish a package before its dependencies).\n- I don't think getLastRelease can be removed from a plugin, since it would need to be so dramatically different for the multi-package plugin. I might be wrong. I hope to re-integrate the gitHead property for lerna-published modules, which would provide a network-based (instead of tag-based) method of determining the previously published version.\nThere's a lot of detail in this thread that I haven't had time to properly parse. Let me know if you have other questions about lerna's internals.. I appreciate the progress. I\u2019ve been doing a lot of refactoring in lerna recently; one of my goals is to split lerna publish into lerna version and lerna publish, much like npm\u2019s API.\n\nOn Feb 8, 2018, at 17:49, Pierre Vanduynslager notifications@github.com wrote:\nWe have implemented two of the features described in this comment:\nMove the getLastRelease step to the core: #613\nAdd tagFormat option: #626\nWe implemented those features as they make sense on their own. They might also help moving toward multi-package repo support.\nHowever it seems the solution I proposed in this comment which is similar to semantic-release-monorepo doesn't work as the following is missing:\nDefining the order in which release have to be done\nUpdate the package.json for cross-dependency\nHere is an example to illustrate the problem. If we have multi-package repo with moduleA, moduleB and moduleC. moduleA depends on moduleB which depends on moduleC.\nIf we make a breaking change commit that modifies the 3 modules, then the release process should:\nDetermine the following order: moduleC, then moduleB, then moduleA\nRelease moduleC\nUpdate moduleB's dependencies in package.json with the new version of moduleC\nRelease moduleB\nUpdate moduleA's dependencies in package.json with the new version of moduleB\nRelease moduleA\nAnd it gets even more complex with multiple cross dependencies...\nThe solution I proposed in this comment doesn't handle steps 1, 3 and 5. As far as I understand semantic-release-monorepo doesn't handle those either. Handling the the steps 1, 3 and 5 from the examples above is out of the semantic-release scope.\nAs mention before, if we support multi-package repo in semantic-release the solution has to be comprehensive and works in every situations.\nIn conclusion, the design needs more work. We are still interested in supporting multi-package repo in semantic-release, but nobody in the maintainers team has time, knowledge or desire to investigate multi-package repo more to come up with a complete working design.\nThat mean we would rely on the community to do this research/design work as requested here, and we can help with questions/ideas/proposals for the parts specific to semantic-release. Once we have a thorough and detailed proposal with possibly a POC, we would consider implementing it, but until then the maintainer team won't move forward on multi-package repo.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub, or mute the thread.\n. > I'm really not sure how either tool can determine what bump to make though.\n\nIn lerna's case, the dependent bump is dependent (heh) on what was decided elsewhere during the publish process.\nIn the default \"fixed\" versioning scheme, it just takes the same bump as everything else. It gets more complicated in the \"independent\" versioning scheme, but generally it's a semver patch, unless I'm mistaken (I don't use \"independent\" very often, myself). The generated commit message is just a version (or a list of versions when independent).\nWhen using --conventional-commits, in either versioning scheme, lerna currently weasels out with a \"Version bump only\" message for dependent changelog messages. I'd like to improve that, perhaps bubbling up at least some notice of what dependencies changed, but it's kinda far down on my priority list right now.. @felixfbecker https://github.com/lerna/lerna/pull/707 and many issues linked to that PR explains the reasoning in-depth. TL;DR: Versions are cheap, silent transitive regressions aren't, and lerna will always err in favor of safety.. > Is this mainly about using linked packages in a lerna repo?\nNo, this has nothing to do with that.. > semantic-release should NOT update any dependencies, devDependencies. This should be done by developer manually\nNo, that is done by lerna. This is the fundamental blocker to integrating lerna-like features into semantic-release.\nWhat happens when a breaking change occurs in a sibling dependent when versioning independently? The range should be updated to the new breaking version, but it won\u2019t be in the scenario you\u2019ve described.. It\u2019s also not the case that every release of fixed version packages always touches every package in the monorepo.\n\nOn Jul 15, 2018, at 03:39, Sergii Stotskyi notifications@github.com wrote:\nSo, the resulting action items:\nadd packages (or similar) option to existing npm plugin (plugin will interate over each package and call npm publish)\n find or create cross-dep-order package\n allow to filter commits by some criteria (add additional option to semantic-release core)\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Originally the semver matching was to enable users to depend on conflicting majors of a sibling package. That is, opt-in to not symlinking a local sibling if a given package specified a non-satisfying (usually different major) semver range for the \"local\" dependency.\n\nIt's extremely confusing, both in explanation and why one would even want to do this in the context of a monorepo.\nThe other reason is that semver ranges (^-prefixed, by default) are the conventional way of specifying dependencies. Most design decisions in lerna were motivated by existing npm conventions and best practices.\nAs for *, I'm of the opinion, based on several years of npm-based development, that the * range is almost always a bug waiting to happen, and not worth any convenience it offers. In terms of lerna, the problem occurs on the consumer side: once published, now we have no way of specifying changes that should trigger updates.\n\nMaybe there is a way to exclude the cross-dependencies from shrinkwrap?\n\nI would just use relative file: specifiers like lerna's source does, it's way better in my experience than lerna bootstrap hackery.. Well, yeah, Lerna temporarily mutates the file: specifiers back to the current semver range of the package in the directory the file: path points to before publishing. The file: specifiers are useful during development as they allow npm to install the entire tree, letting lerna focus on versioning and publishing.. ",
    "SimenB": "I'm really excited about where this is going! I'd be happy to help testing this out (we really want it in Jest (https://github.com/facebook/jest/issues/5079)).\nThrowing a couple of thoughts out there, in case it triggers anything:\n\nOne thing I like about current lerna publish is that it also bumps dependents of updated packages. While semver dictates that it shouldn't matter, I find it useful and helpful to guarantee the latest version of dependencies between published modules in a monorepo.\nRelated, the changed version fields should be committed back to the repo to allow linking between modules to continue working (might be covered in your post, and I'm just missing it).\nlerna publish --conventional-commits currently create a changelog in each package, useful when \"releases\" on github are full of other stuff.. >I don't think it's semantic-release responsibility to do that. Maybe there is another lerna command that allow to do the update without publishing? This command could be run before calling semantic-release on each package?\n\nRight now it's part of the publish command - bumping a package bumps its dependents, meaning they get a patch release as well (which bubbles up). Without knowing the internals of lerna, I'm sure that logic could be isolated enough to make it possible to run on its own.\n\nIs it necessary for lerna to have the actual last version released in the pacakge.json on the repo?\n\nI don't know lerna well enough to answer that. I can try, though! \ud83d\ude00 I guess 0.0.0-development would work fine, as it would be within semver range, meaning all modules would use the symlinked versions. That means on publish you would have to look up all of the {dev,peer}Dependencies to see if they exist within the monorepo, and insert their correct published version.\n\nIs there something covered by lerna publish --conventional-commits that is not covered by semantic-release?\n\nJust the changelog part, I think.\n\n@SimenB I'm curious about why you find it useful/helpful?\n\nMostly because upgrading nested dependencies is a pain (neither npm nor yarn has a command for it). I end up doing this: yarn add some-updated-dep && yarn-dedupe && git checkout package.json && yarn --force (yarn-dedupe being a custom command as yarn has no dedupe). Having the bump be as high up in the dependency tree as possible makes it so that I often just need to bump an actual dependency in package.json without resorting to hacky workarounds. >I agree. That would be a job for @greenkeeperio :) The team is looking into monorepo support as far as I know\nRenovate supports monorepos, fwiw. I don't think that's optimal though - an external tool shouldn't be needed to detect changes within the same repo. You potentially end up with n - 1 (n being number of packages in the repo) PRs one after another.\nThis is not something I feel strongly for, though.\nEDIT: Also, when we bump outside of semver range, I think that should be reflected within the repo.. >Can you make sure you added your Github repo to Travis?\nHow so? The output here is from Travis. Should I specify the travis api url in some environment variable?. I have the build running on travis already, Travis is building on every commit, and Travis CI is in the repo's settings.\n\n. Yes, with the following permissions: read:org, read:user, repo, user:email. (repo includes all of repo:status, repo_deployment and public_repo).\nToken added to .travis.yml by doing travis encrypt GH_TOKEN=mytoken --add. >If you are using Travis Enterprise we are not supporting yet.\nAh, that's it! Much sadness.\n\nWould like to help us and contribute with a PR?\n\nSure!. https://github.com/semantic-release/condition-travis/issues/100. ",
    "jquense": "I'd like to just reiterate:\n\nThe cross-dependency bumps are vital to the lerna pattern, and they really only work with one high-level process to coordinate those bumps (which also need to happen in topological order, so you don't try to publish a package before its dependencies).\n\nFor the general case of mono-repo to work (as lerna, babel, etc do it), any change in a dependent (local) package must result in a new release of the depending package. I'm really not sure how either tool can determine what bump to make though. In most of these cases the only commit would be the dep bump in the depending package. I'm guessing tools like lerna would need to make a choice about what bump to make and format the commit message appropriately?. @felixfbecker it's not intuitive on the face of it (and bless @evocateur he has talked to so many folks about this), but not publishing a new version can lead to bugs in a way that isn't determinable from the start. It's easy to say SR shouldn't have this behavior but it's really required for these tools to work generally, otherwise the repo's get into bad states. If SR can be unopionated such that lerna can implement this behavior on top of it great, but I'd consider a required use-case for SR to allow.. how would you do it manually? I think the point is that tools like Lerna need to have input in what packages are bumped. In the case of mono-repos, bumps of local dependent packages is semantically relevant to whether others should be also bumped. IT's not enough to just look at commits by subtree. Another tool may make a different (dubious :p) choice in that regard, but for Lerna (and other tools) it's required for integration, its a messy sort of interplay\n. @stalniy if your interested in why it's required I'd encourage you to read the long long long history of said issue in Lerna. The tldr is if you don't you get bugs eventually.. ",
    "bartlangelaan": "Semantic release is a very useful tool that I've been using for quite a lot of releases now.\nA week ago, I merged two repositories into one new monorepo. A lot of things went smoothly, but semantic-release doesn't have monorepo support out-of-the-box yet.\nI'm using semantic-release-monorepo right now, and it covers most of the functionalities needed. I think it would be very helpful to have the basics into the core of semantic-release. I've read this thread and seen a lot of use-cases and ways of them to be handled.\nThis is a proposal of it's behaviour that handles most use-cases. Sure, probably not all of them, but I'm sure the functionality can be extended over time.\nModes\nThere are two modes: locked and independent. They have the same principles as lerna, and behave almost the same.\nLocked mode means that if there is a commit that should trigger a new release (fix / feat), it releases all packages. Independent mode means that if there is a commit that should trigger a new release, it releases only the packages affected.\nBasic configuration\njson\n{\n  \"monorepo\": {\n     \"mode\": \"locked\",\n     \"packages\": [\"packages/pkg-core\", \"packages/pkg-ext-1\", \"packages/pkg-ext-2\"]\n  },\n}\njson\n{\n  \"monorepo\": {\n     \"mode\": \"independent\",\n     \"packages\": [\"packages/*\"]\n  },\n}\nExample structure\n\n/package.json\n\n```json\n{\n  \"private\": true,\n  \"devDependencies\": {\n    \"semantic-release\": \"^15.1.6\"\n  },\n  \"scripts\": {\n    \"release\": \"semantic-release\"\n  },\n  \"release\": {\n    \"monorepo\": {\n       \"_\": \"See config above\"\n    }\n  }\n}\n```\n\n\n\n/packages/pkg-core/package.json\n\n```json\n{\n  \"name\": \"pkg-core\",\n  \"version\": \"0.0.0-development\",\n  \"main\": \"index.js\"\n}\n```\n\n\n\n/packages/pkg-core/index.js\n\n```js\nmodule.exports = \"Package core!\";\n```\n\n\n\n/packages/pkg-ext-1/package.json\n\n```json\n{\n  \"name\": \"pkg-ext-1\",\n  \"version\": \"0.0.0-development\",\n  \"main\": \"index.js\",\n  \"dependencies\": {\n    \"pkg-core\": \"0.0.0-development\"\n  }\n}\n```\n\n\n\n/packages/pkg-ext-1/index.js\n\n```js\nmodule.exports = require('pkg-core').replace('core', 'extension 1');\n```\n\n\n\n/packages/pkg-ext-2/package.json\n\n```json\n{\n  \"name\": \"pkg-ext-2\",\n  \"version\": \"0.0.0-development\",\n  \"main\": \"index.js\",\n  \"dependencies\": {\n    \"pkg-ext-1\": \"0.0.0-development\"\n  }\n}\n```\n\n\n\n/packages/pkg-ext-2/index.js\n\n```js\nmodule.exports = require('pkg-ext-1').replace('1', '2');\n```\n\n\n\n/packages/pkg-ext-3/package.json\n\n```json\n{\n  \"name\": \"pkg-ext-3\",\n  \"version\": \"0.0.0-development\",\n  \"main\": \"index.js\",\n  \"peerDependencies\": {\n    \"pkg-ext-1\": \"0.0.0-development\",\n    \"pkg-ext-2\": \"0.0.0-development\"\n  }\n}\n```\n\n\n\n/packages/pkg-ext-3/index.js\n\n```js\nmodule.exports = require('pkg-ext-1') + require('pkg-ext-2');\n```\n\n\nUse cases\nFor all of these examples, I assume all packages have a latest release of 1.0.0.\nLocked mode\nThe locked mode is pretty straightforward. A change of any kind publishes new versions of all packages.\n\nDeveloper: commits fix: change something in pkg-core.\nSemantic-release: publishes 1.0.1 for all packages. The version of packages in the 'dependencies' section are published as ^1.0.1. The commit gets tag v1.0.1 and a release is made on Github.\nDeveloper: commits feat: pkg-core now returns an array with BREAKING CHANGE. The other packages are updated to implement the change in pkg-core.\nSemantic-release: publishes 2.0.0 for all packages. The version of packages in the 'dependencies' section are published as ^2.0.0. The commit gets tag v2.0.0 and a release is made on Github.\n\nThere is no intelligent check of which packages should be updated, or what the new version should be. That is the same functionality of what's currently in semantic-release.\nIndependent mode\nCommits that only affect one package, should only publish one package.\n\nDeveloper: commits feat: add feature to pkg-core.\nSemantic-release: detects that only the package/pkg-core folder was changed and publishes 1.1.0 for pkg-core. The commit gets tag pkg-core-v1.1.0 and a release is made on Github. Because all other packages reference to the package as ^1.0.0, all packages are automatically compatible with the new version and don't require a new release.\nDeveloper: commits feat: use new feature from core in pkg-ext-1.\nSemantic-release: detects that only the package/pkg-ext-1 folder was changed and publishes 1.1.0 for pkg-ext-1. The commit gets tag pkg-ext-1-v1.1.0 and a release is made on Github. Every time a package is published, it's dependencies to other modules are updated to the latest version. So, pkg-ext-1 will have a dependency to pkg-core@^1.1.0.\nDeveloper: commits feat: return array in pkg-ext-3 with BREAKING CHANGE.\nSemantic-release: detects that only the package/pkg-ext-3 folder was changed and publishes 2.0.0 for pkg-ext-3. The commit gets tag pkg-ext-3-v2.0.0 and a release is made on Github. Its dependencies are pkg-ext-1@1.1.0 and pkg-ext-2@1.0.0.\n\nThese examples would cover most commits, but of course it becomes more complicated when there are commits or PRs covering multiple packages.\n\nDeveloper: commits feat: add feature to all packages.\nSemantic-release: detects that all packages were updated, and releases pkg-core@1.2.0, pkg-ext-1@1.2.0, pkg-ext-2@1.1.0 and pkg-ext-3@2.1.0. They all reference the new versions in the 'dependencies' part. \nThe commit gets all of the appropriate tags, and ideally publishes one Github release (bound to one tag). Also it should respond to all fixed commits / PR's once (and not for every package that was released). \nThe bundeling of the release and issue comments is also something that can be implemented later on, if that's hard to implement for all plugins.\nDeveloper: commits feat: add feature to pkg-core and pkg-ext-1.\nSemantic-release: detects that pkg-core and pkg-ext-1 were updated, and publishes pkg-core@1.3.0 and pkg-ext-1@1.3.0.\nDeveloper: commits feat: add feature pkg-core and fix: change something in pkg-ext-1 in a new branch, creates PR and merges.\nSemantic-release: detects that pkg-core needs a minor release and pkg-ext-1 needs a patch release, and publishes pkg-core@1.4.0 and pkg-ext-1@1.3.1.\n\nSo far, so good. As long as semantic-release checks the commits for each package individually and determines the new version individually, it's clear what packages will be released. And you don't need to update packages that aren't updated, because it's dependencies can be updated within it's semver reach.\nBut the hard part is: what happens when a breaking change happens in a package that other packages depend on?\n\nDeveloper: commits feat: change in pkg-core with BREAKING CHANGE and commits feat: update ext-1 to use new version of pkg-core in a new branch, creates PR and merges.\nSemantic-release: detects that pkg-core needs a major release and pkg-ext-1 a minor release, and publishes pkg-core@2.0.0 and  pkg-ext-1@1.4.0. \nDeveloper: commits feat: change in pkg-core with BREAKING CHANGE.\nSemantic-release: detects that pkg-core needs a major release and publishes pkg-core@3.0.0. \n\nEven though the release didn't break the pkg-ext-1, maybe a new release with an updated dependency for that package is desired. The semver range of pkg-ext-1 now doesn't cover the newest release of pkg-core, so npm or yarn won't install the latest version.\nTo fix this, it would be nice to automatically create a new release for all packages that have a dependency on pkg-core. This should be configurable, some would like a patch release (pkg-ext-1@1.4.1), some would like minor release (pkg-ext-1@1.5.0) and others would maybe like a major release (which would result in all packages releasing a new major version).\nThis would mean that (if you make this configurable) this would be a third option in the monorepo config.\njson\n{\n  \"monorepo\": {\n     \"mode\": \"independent\",\n     \"packages\": [\"packages/*\"],\n     \"onBreakingRelease\": \"minor\",\n  },\n}\n\nDid I miss some widely used use-cases here? I think this would make most monorepos workable with semantic-release.. ",
    "ryaninvents": "From my point of view, the only thing preventing the existing monorepo managers from using semantic-release is that the log is pulled from the entire repo. Would it be possible to introduce a subtree config option? Admittedly, this would only enable monorepos using \"independent\" versioning, but from my point of view using independent versioning is more in line with the philosophy of semantic-release.\nThis would mean in the release config for each package in the monorepo, you'd have a line \"subtree\": \"packages/project-N\", and you could use your existing monorepo solution to trigger it (e.g. lerna run semantic-release).\nI'll have a PR up shortly for this; the implementation turned out to be more straightforward than I'd thought.. @felixfbecker that sounds like a nice usability improvement. It's possible (though unlikely) that this could break someone's workflow however, since it would change how existing deployments work. It would be cool if it picked up on the subtree based on package.json/.releaserc location, but better for now to make it an explicit opt-in.. @pvdlg ah, thank you for the pointer! I thought I'd read the entire thread closely enough \ud83d\ude05. I won't make the PR here, since it moves a direction that's perhaps not suited for the project, but I've pushed the code change to a branch.. Thanks for the feedback! I figured it was a niche problem, and don't want to add complexity for such a rare edge case. I'll close this issue, since this seems like it would be better solved on my end.\nLet me know if there's anything else I can help with towards #563 as well.. ",
    "stalniy": "I don't think that it's all such complicated as everybody thinks :) \nThe support for monorepos should be done by using ONLY plugins. In that way it will be much easier to proceed step by step. The core should have minor changes.\nI had experience working with Lerna, so will try to answer on questions which @pvdlg asked:\nFirst of all, the best use case for lerna is fixed/locked mode. For independent mode lerna is almost not usable. \nSome details about Lerna\n\nfile structure usually is this:\nsh\nmonorepo/\n--packages/\n----packageA/\n----packageB/\n--package.json\nthere are no any restrictions on commit formats as far as I know but most of the people uses commitizen style (e.g., with angular preset). Also if there is a need to support other formats devs can implement own plugins for generateNotes and analyzeCommits\nlerna has 2 commands which allows to run scripts inside packages: lerna run (runs npm script in package.json of every package or specified package) and lerna exec (runs sh script in the folder of specified package or all packages)\nlerna uses $NAME@$VERSION format for git tags (semantic-release supports this)\n\nRelease process:\n lerna uses convential changelog to generate release notes (not sure have it determines section for each package but very likely by file path)\n it's possible to retrieve the last release as usually, just find the last tag in git which corresponds to the specified tagFormat. The last version of the package can be also found in package.json. So, this can be used during release process to determine the last version\n release <-> commits can be found by taking all commits from the last version and filter them by affected files\n how much releases depends on the mode:\n  * for independent mode: 1 release per package because all of the have different versions and different tags\n  * for fixed mode: 1 release for all, because they use single tag\n changelog needs to be generated based on mode\n  * independent: 1 changelog per package in corresponding directory\n  * fixed: 1 changelog  per repo\n make a release:\n  * independent mode: multiple changelogs, multiple git tags, multiple github releases, multiple npm publish (works almost the same as 1 repo per package, the only difference is that we need to understand which packages are affected by commit)\n  * fixed mode: 1 changelog, 1 github release, 1 git tag, multiple npm publish (almost like working with a single package, the only difference that we need to publish multiple ones on npm)\n semantic-release should NOT update any dependencies, devDependencies. This should be done by developer manually\n. It's much easier to start supporting fixed/locked mode of monorepo (the same version for every package) and this is what needs to be done:\n separate semantic-release npm plugin  which supports monorepo or add option to existing one\nThe rest plugins can be reused without changes\nFor independent mode:\n* ability to filter commits by some criteria (so, we can understand relationship between commits and packages). It can be whatever user wants, the built-in functionality can contain 2 variations: filter by affected files path or by tags specified in commit messages\nThe rest of plugins can be reused for each package as if every package is in a separate repo.\nNow, this complicated cross-dependency release order can be done via plugin. So, people who cares about this can add it. This can be done even as a separate tool. \nSo, for fixed/locked mode it can be used like this:\njs\n// .releaserc.js\n// returns an array of packages\nconst resolveCrossDependencyOrder = require('cross-dep-order')\nmodule.exports = {\n  publish: [\n    { path: '@semantic-release/npm', packages: resolveCrossDependencyOrder('./packages') }\n  ]\n}\nFor independent mode:\n``sh\npackages=node -p -e 'require(\"cross-dep-order\")(process.argv[1])' './packages'`\nfor package in $packages; do\n  cd $package\n  semantic-release ....\ndone\n``. So, the resulting action items:\n- [ ] addpackages(or similar) option to existingnpmplugin (plugin will interate over each package and callnpm publish)\n- [ ] find or createcross-dep-orderpackage\n- [ ] allow to filter commits by some criteria (add additional option tosemantic-release` core). > I don't agree with this at all. It's way easier to manage independent packages in one repo with lerna than it is to manage them in separate repos.\n@psirenny I didn't say that it's better to manage packages in separate repos. What I said is that lerna has a lot of issues if you want to run it in independent mode, especially with releases.. > No, that is done by lerna. This is the fundamental blocker to integrating lerna-like features into semantic-release.\n\nWhat happens when a breaking change occurs in a sibling dependent when versioning independently? The range should be updated to the new breaking version, but it won\u2019t be in the scenario you\u2019ve described.\n\nWhy can't you update it manually? What if you don't want to update sibling package to support dependency with breaking changes? \nSo, the good point to start is just to do this manually. > It\u2019s also not the case that every release of fixed version packages always touches every package in the monorepo.\n@evocateur good point, lets think how we can handle this. i can\u2019t inderstand why dependent packages should bump:\n\nIn a semantically correct solution, packages in the monorepo need to automatically bump if they depend upon another local package that has bumped.\n\nIf you use seamver inside your packages then new minor and patch versions will be automatically picked up by npm install. No need to bump dependent packages version in this case\nIn case of major update, there is no reason to bump dependent packages because very likely that they must be changed before version bump. So, no need to bump. \nI use semantic-release and semantic-release-monorepo plugins together. This is not ideal as the latest plugin also proxies core packages with little changes and can\u2019t proxy github plugin (because of internals of semantic-release, there was even a PR to integrate this in core but it was rejected). \nSo, in the end, yarn workspaces semantic-release is very close to what I do with my monorepo and it works pretty good  . @jquense but if you do, you will also have bugs, won\u2019t you?\nThere may be situation when you want to do breaking change in base/core package but integrate that into dependent packages later. \nI don\u2019t think this is something what can be automated. \nI\u2019ll look at the learns issue. Thanks. ",
    "psirenny": "\nFirst of all, the best use case for lerna is fixed/locked mode. For independent mode lerna is almost not usable.\n\nI don't agree with this at all. It's way easier to manage independent packages in one repo with lerna than it is to manage them in separate repos.. Fair enough, I just don't want to see independent mode miss out on semantic releases since that happens to be the mode that I use the most \ud83d\ude04 . ",
    "kopax": "Hi!, what's the status of this? Does anybody here use https://github.com/Updater/semantic-release-monorepo? How is it compare to this official plugin? Is there a chance to see monorepo supported in 2019? Hi and happy new year of the pig!  \nThis project is awesome, thanks!. I agree with the bumping by default. I'll be happier if I would not have to do it every upgrade manually. That could be easily disabled. Thanks for offering to work on it @dhoulb, this feature is really missing. We use normal repo because of our attachement to semantic-release but I see many cases where I would have prefered to use a mono repo for maintenances and less CIs (run in band).. Somebody asked me by email so I wanted to clarify that verdaccio work super well with semantic-release.. > The Travis build that you linked has been triggered by a tag creation.\nI don't thing it was triggered by a tag creating, I did created it with a git push from my host directly to branch master. What make you thing It was triggered automatically after a git push?\n\nThere is no reason to trigger builds on Travis when a tag is created, so it's something you can disable.\n\nHow can I disable this? What is your recommendation I do not get it.\nAter a release, the package.json appear to be modified with the new version in it.\nBefore I started to play with semantic-release, I was doing the npm version followed by the git push of the package.json to the HEAD:dev. \nWhat is your recommendation regarding that?\n. >  Because it says so on the buid.\nWeird, thanks for pointing this out.\nThis is my job and I have already said that it should do the release job only on master branch:\n```yml\n    # Job: Release\n    - stage: release\n      node_js:\n        - lts/*\n      skip_cleanup: true\n      script:\n- echo -e \"Host *\\n\\tStrictHostKeyChecking no\\n\\n\" > ~/.ssh/config\n    - npx semantic-release\n\n# Will push package.json next version if semantic-release do release\n- '[ -z \"$(git status --porcelain)\" ] || git add package.json package-lock.json'\n- '[ -z \"$(git status --porcelain)\" ] || git commit -m \"[ci skip] Version $(node -p \"require(\\\"./package.json\\\").version\") updated by release branch\"'\n- 'git push origin HEAD:dev || echo Nothing to release.'\n  branches:\n    only:\n    - master\n\n````\n\nThe problem is that you probably didn't configure the NPM_TOKEN properly, as mentioned in the logs: https://travis-ci.org/kopax/deleteme/jobs/380159426#L5854\n\nThis was a old build, I was setting a private registry in the package.json and I since corrected the issue. We already use the NPM_TOKEN and have removed the publish configuration from our package.json.\n\nI don't really understand your question. Our recommendation is to use semantic-release the way it's describe in the documentation\n\nIn the documentation, after the release have been made, you don't recommend to do anything. So a human (that should have been killed since we installed your module) must manually update the version in the development branch. What to do? Should we push for them the package.json ? This is my current approach.\n. @pvdlg yes, I was able with the FAQ link to understand and make it work. I was not familiar with the all the plugin. Thanks . I am having the same error when using npx semantic-release --no-ci. \nI am still trying to know why but obviously the error is wrong.. We found that it was the GH_TOKEN missing.\n@pvdlg regarding testing, we cant do it right now but I'll try to get into it when it's possible.. What a shame when I realized the group was not containing the proper user that own the token. Sorry for opening this.. @pvldg thanks for the explanation. I thought that because git cli was used, then we could use any git authentication flow. \nI was and I am still confused with GL_TOKEN, if the recommended approach is GIT_CREDENTIALS.\nI used to run semantic release with GL_TOKEN=$token npx semantic-release and having git-credentials configured at the same time without hassle.. Thanks a lot, it appears thanks to your replies that semantic-release does not work with git-credentials so I am closing this, thank you.. @travi, I've been trying a few times with the following commit message:\n\nperf(babel): babel 7 BREAKING CHANGE\\nUse version 0.18.1\nperf(cli): BREAKING CHANGE cli now use @babel/node during test\n\nYou are right to say it does not include the :. Is this really a requirement ? What about the fact of having perf shouldn't that be enough for major?\nI really like commitizen but found it convenient to also write short message in one line.. Dear @pvldg, sorry for the confusion. I did ask twice in 30 minutes interval. I am using a IRC client and I must admit that I forgot Gitter was also a website and support platform. For some reason my IRC client did not blink on your replies, I wish I would have seen them earlier to prevent that. \nThat doesn't excuse the absence of details here, I sincerely apologize.\n\nsemantic-release: 15.12.1.\n\nI do use angular commit convention (which are default for commitzen), thanks for pointing that link, I will always remember to be more specific. Thanks for the awesome work and supporting some users.\nBest regards,. ",
    "dhoulb": "Hey everyone!\nMonorepos and semantic release are both growing in popularity (they're both massive for developer productivity and convenience). So the demand for this functionality will probably grow 100x over the next few years. I think it\u2019s really important that we try and unblock this thread and move forward.\nI\u2019ve done a lot of thinking and playing around the issue and I think I\u2019ve got an approach that\u2019ll move us forward. (Skip to my summary if you don\u2019t want the background/thought process.)\nBackground\nFirst a quick summary/clarification of the thread:\n\nIn a semantically correct solution, packages in the monorepo need to automatically bump if they depend upon another local package that has bumped.\nThis means that the correct next version of all packages in the monorepo must be established first\nThis means that the solution cannot just iterate into folders and run semantic-release independently\nThis means that something must coordinate the release and hold that information about package versions throughout the release process\n\nThis requirement for coordinating the release is the kicker. It means that (unfortunately) Lerna or Yarn Workspaces won't ever be able to semantically release a monorepo (a shame because yarn workspaces run semantic-release etc would be so much simpler \ud83d\ude25). \nI had a go at building an independent package that would support the above without needing to modify semantic release: multi-semantic-release. It works correctly and I\u2019ve tested publishing with it BUT has a lot of ickyness due to its integration with semantic release (via an inline plugin that proxies all the other configured plugins \ud83e\udd2e \u2014 I\u2019ve written implementation notes in the README that will be interesting if you know semantic release\u2019s internals). \nBut I think there's too much jank for my approach to be production viable. I now believe the best way to provide monorepo semantic release support is to modify the semantic release core to work with an array of releases rather than just a single release.\nApproach\nThis is my approach and thinking for what would be required in modifying semantic release to add support for monorepos:\n1. Yarn workspaces / NPM workspaces\nAs @evocateur alluded to above, Lerna is on a road to becoming unnecessary. It\u2019s currently the main tool for monorepos but it's clear it won't be in the long run. Yarn already have monorepo support baked in (they call it \u201cworkspaces\u201d) and NPM are rumoured to be working on it too.\nAt that point the only functionality Lerna will be needed for is publishing. If semantic release adds this functionality then most projects could remove Lerna today.\nThe configuration for Yarn workspaces is really simple \u2014 you just list one or more paths/globs in package.json and it\u2019s a safe bet when NPM add their functionality they'll copy this config (or something similar).\njson\n\"workspaces\": [\n    \"packages/*\",\n    \"morepackages/*\"\n]\nI think adding support for the above package.json syntax out of the box would be the most intuitive and forward looking approach.\n2. Modifying semantic release to work with an array of packages\nThis is the main task: We need to modify the core of semantic release to work with an array of packages (rather than just a single package). \nThe API would be 100% backwards compatible with how semantic release works currently (i.e. semantic-release would continue to release the package in the CWD as it does currently).\nThen, we'd add a new configuration option --workspaces (or -w) which would allow an array of package subpaths to be passed in (in the same format as Yarn workspaces):\nsh\nsemantic-release -w packages/* -w morepackages/*\nInternally this would become options.workspaces. If undefined it would default to the value of the \"workspaces\" key from package.json. This would make it compatible (out of the box) with Yarn workspace (and presumably NPM workspaces too).\nThird-party monorepo tools like Lerna could add support for semantic release by calling require(\"semantic-release\")() with options.workspaces to an array of packages (@evocateur personally I'd favour adding semantic as a new release type alongside fixed and independent \u2014 as I think it's such a different paradigm than the other two! \ud83d\ude04\nThis would probably be a breaking change in semantic release, but the work is actually quite contained! Most of the modifications are in index.js/run() with some minor tweaks to other functions. My summary below lists the changes.\n3. Managing versions of local deps\nThe best thing about semantic-release is not thinking about version numbers! In monorepos you (traditionally) still manually update version numbers in dependencies and devDependencies (when publishing via CI).\nMy proposed solution for this is: \n\nAlways use * as the dependency version in package.json for local deps\nBefore semantic release publishes: swap out the asterisk for the fixed version of that dep at time of publishing (similar to how @evocateur said it's done in Lerna)\n\nThis way packages in NPM are fixed into an always-correct network of versions (even if they have circular dependencies etc). This is consistent with how semantic release already works with the version field in package.json, so is intuitive.\nSummary\nHere\u2019s my proposed action list for supporting monorepos in semantic-release:\n\n[ ] Add a --workspaces / -w option that accepts an array of workspace globs\nDefaults to the value of workspaces  in package.json\n\n\n[ ] Modify run() in index.js to iterate through an array of packages\nConvert options.workspaces into an array of named packages to work on (see multiSemanticRelease.js) \nArray of packages defaults to [cwd] (so semantic release is backwards compatible)\nFor each package establish the correct semantic release options\ni.e. merging ./.releaserc and ./packages/a/.releaserc and the CLI options to generate the final config and plugins for each package \nExtracting getPlugins() from getConfig() would make this easier!\n\n\nSome plugin steps only need to be called once for each plugin (e.g. verify) while some obviously need to be called for each package context (e.g. analyzeCommits, prepare, publish, success)\nAfter plugins.analyzeCommits() has been called for every package (so we know all the next version based on Git commits) loop through the dependencies of every package again to see if any local dependencies (or deps of deps recursively) have bumped\nIf a dep has bumped do a bump on the package too (similar to hasChangedDeep.js \u2014 I can\u2019t decide currently if it should always be a patch bump OR should match the nump of the dependency?\n\n\nAppend a section to the release notes for each package that lists any local dep bumps\ne.g. ## Dependencies\\n\\n- my-package-a: bumped to 1.2.3\nCould be done by making @semantic-release/release-notes-generator smarter instead!\nSee generateNotes() in createInlinePluginCreator.js\n\n\nMake sure unique Git tags are only created once\nOtherwise Git will error if two packages share a tagFormat (which would cause the tag to be created twice)\nThis will happen in @semantic-release/github too \u2014 for this we should prepend the package name to context.gitTag (e.g. my-super-package@v123) so each release has a unique name\n\n\nClean up logger messages so they make sense\ne.g. Releasing 6 packages Released package my-package-name at version 1.2.3 \nmultiSemanticRelease.test.js shows some examples of what I went with!\n\n\n\n\n[ ] Modify getCommits() to filter the commits by the current package\u2019s directory (see getCommitsFiltered.js for an example)\nBasically you add -- package/a/ to the gitLogParser() call\n\n\n[ ] Change calls to execa() to exec.sync() to prevent Git state issues \ud83d\ude0a\n[ ] Update tests\nI've got some tests already that might speed things up (in particular the helper functions)\n\n\n[ ] Update docs\n\nApologies for the long message. I\u2019m happy to help with the work (I\u2019ll have some availability maybe in a few weeks). But obviously some discussion on the above would be great before I do. @pvdlg please me know your thoughts! . @stalniy You're right that devs wouldn't be able to individually manage dep versions in their monorepos \u2014 but I'd argue individually managing package versions is what semantic-release exists to eliminate\nThe bumping is needed to eliminate the worst kind of bugs: edge-case bugs based on how and when a user does npm install. That particular type of bug would be a total nightmare for package maintainers. This is the major reason this thread has been stuck for a while.\nDoing it as you described (effectively Lerna independent mode) is a totally acceptable way to treat a monorepo \u2014 but to many people a monorepo repository semantically describes a set of interconnected packages that is correct at the time of a commit/release. So it is correct for semantic-release to bump/synchronise the version numbers appropriately.\nAs you mentioned though if someone doesn't care about that then yarn workspaces semantic-release works pretty well! (this is basically what semantic-release-monorepo does). The only change that's needed for that to work out of the box is filtering commits to only be relevant to the current directory (a small change in getCommits()). With my spec above you'd get that too so you could probably drop semantic-release-monorepo and just use plain semantic-release with Lerna or Yarn etc.. @pvdlg I\u2019d love to hear your feedback on the above.. ",
    "khankuan": "@pensierinmusica im on v3.0.0. It seems like package.json got updated correctly after the release. Unfortunately that creates a change in package.json and the file needs to be pushed again.. ",
    "RWOverdijk": "@boennemann I did select that option, they weren't logged to the terminal.\n? Is the GitHub repository private? No\n? What is your npm registry? https://registry.npmjs.org/\n? What is your npm username? rwoverdijk\n? What is your npm email? r.w.overdijk@gmail.com\n? What CI are you using? Travis CI\n? What kind of `.travis.yml` do you want? Create no `.travis.yml`\nIn the options above I chose \"Create no .travis.yml\" because I already created it last time I run the command.\n. Update... Even if I specify the token in travis, it still says I didn't.\n. @boennemann So, as soon as I merge you mean? (which makes sense, I don't think I want to publish on PRs)\n. It did publish to npm, so that's something. :) But still not to github\n. Could you perhaps give me a pointer as to how I can debug this without actually releasing? I want to know what is causing the 404 because I want to use this module. The concept sounds really cool! If it works :p \n. @boennemann Hm yeah. It created a personal access token, does that matter though? Because I have full access to the repo and org, so shouldn't it just work? If not, where should I create the key?\n. I'm not using this anymore.. ",
    "crobinson42": "@boennemann Hey there - I have a project that's public but under an organization name - It seems the cli isn't able to find the project on Travis due to the different username/organization name prefix (my theory). Anyways - I looked at the travis logs and it's showing the missing github/npm token so semantic-release doesn't proceed. Any quick pointer on how to manually recreate what semantic-release does with these tokens? Thanks!\nIs the GitHub repository private? No\n? What is your npm registry? https://registry.npmjs.org/\n? What is your npm username? coryrobinson42\n? What is your npm email? coryrobinson42@gmail.com\n? What is your GitHub username? crobinson42\n? What CI are you using? Travis CI\nERR! semantic-release Could not get repository on Travis CI.\nERR! semantic-release { file: 'not found' }\nhttps://travis-ci.org/pizza-rolls/node-api-server/builds/160954581\nsemantic-release ERR! init No github token specified. ENOGHTOKEN\nsemantic-release ERR! init No npm token specified. ENONPMTOKEN\nEDIT: I've figured this out - thx! Select the 'print tokens' option in the cli setup and use those in your CI environment configs.\n. @cameronroe Is this still an 'open' issue?\nA major release is triggered when a commit message contains the string \"BREAKING CHANGES\".\n. +1 I noticed in standard-version (https://www.npmjs.com/package/standard-version) In the FAQ it says this package, semantic-release generates changelogs...:\n\nFAQ\nHow is standard-version different from semantic-release?\nsemantic-release is a fully automated library/system for versioning, changelog generation, git tagging, and publishing to the npm registry.\n. And how? I have been using this module on several packages and gone through several versions of automation and yet to see a CHANGELOG.md created.\n. Ahh. My misunderstanding! Thanks for clarifying.. \nOn Sep 19, 2016, at 2:47 PM, Christopher Hiller notifications@github.com wrote:\n@crobinson42 https://github.com/crobinson42 No, it doesn't make a CHANGELOG.md. It puts the changelog in the GitHub release description.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub https://github.com/semantic-release/semantic-release/issues/289#issuecomment-248137444, or mute the thread https://github.com/notifications/unsubscribe-auth/AFsmS2eETTRFNZgt6Y7aLHBSrJBEWEVzks5qrwLfgaJpZM4JyPNf.\n. This is because when running through the semantic-release-cli setup command, it asks \"single\" or \"multiple\" versions of Node. Regardless, it assigns Node LTS (v4) which uses npm v2.x \n\nRequires a manual override if you're expecting or change to Node v6 in the .travis.yml file for node_js config\n. @nanovazquez Thank you, that helps a lot!. ",
    "blacksonic": "It is connected to access rights, can be a good addition to the error message.. ",
    "sgimeno": "You can solve it by manually publishing a version and then re-building on Travis or restore the commit meaning you need to push force again :/. ",
    "finnp": "/cc @gr2m @boennemann \n. Awesome, LGTM :+1: \n. Yep the problem is that the CI build is behind the remote:\n[Semantic release]: The command \"git push --dry-run https://[secure]@github.com/[secure].git HEAD:master\" failed with the error message To https://github.com/[secure].git\n ! [rejected]        HEAD -> master (fetch first)\nerror: failed to push some refs to 'https://[secure]@github.com/[secure].git'\nhint: Updates were rejected because the remote contains work that you do\nhint: not have locally. This is usually caused by another repository pushing\nhint: to the same ref. You may want to first integrate the remote changes\nhint: (e.g., 'git pull ...') before pushing again.\nhint: See the 'Note about fast-forwards' in 'git push --help' for details.\nTo make sure it is not failing in this case you could do git push --dry-run --force.. Might be that that was using a version before 15.4.1. Closing this for now.. This is still happening as of 15.5.1.. Sure!\n[Semantic release]: Running semantic-release version 15.5.1\n[Semantic release]: Load plugin \"verifyConditions\" from @semantic-release/github\n[Semantic release]: Load plugin \"analyzeCommits\" from @semantic-release/commit-analyzer\n[Semantic release]: Load plugin \"generateNotes\" from @semantic-release/release-notes-generator\n[Semantic release]: Load plugin \"prepare\" from @semantic-release/npm\n[Semantic release]: Load plugin \"publish\" from @semantic-release/github\n[Semantic release]: Load plugin \"publish\" from @semantic-release/npm\n[Semantic release]: Load plugin \"publish\" from @semantic-release/exec\n[Semantic release]: Load plugin \"success\" from @semantic-release/github\n[Semantic release]: Load plugin \"fail\" from @semantic-release/github\n[Semantic release]: The command \"git push --dry-run https://[secure]@github.com/[redacted].git HEAD:master\" failed with the error message To https://github.com/[redacted].git\n ! [rejected]        HEAD -> master (fetch first)\nerror: failed to push some refs to 'https://[secure]@github.com/[redacted].git'\nhint: Updates were rejected because the remote contains work that you do\nhint: not have locally. This is usually caused by another repository pushing\nhint: to the same ref. You may want to first integrate the remote changes\nhint: (e.g., 'git pull ...') before pushing again.\nhint: See the 'Note about fast-forwards' in 'git push --help' for details.\n.\n[Semantic release]: Verify GitHub authentication\n[Semantic release]: Found existing semantic-release issue #556.\n[Semantic release]: Added comment to issue #556: https://github.com/[redacted]/issues/556#issuecomment-396850387.\n[Semantic release]: EGITNOPERMISSION The push permission to the Git repository is required.\nsemantic-release cannot push the version tag to the branch master on remote Git repository with URL git+ssh://git@github.com/[redacted].git.\nPlease refer to the authentication configuration documentation (https://github.com/semantic-release/semantic-release/blob/caribou/docs/usage/ci-configuration.md#authentication) to configure the Git credentials on your CI environment and make sure the repositoryUrl (https://github.com/semantic-release/semantic-release/blob/caribou/docs/usage/configuration.md#repositoryurl) is configured with a valid Git URL (https://git-scm.com/book/en/v2/Git-on-the-Server-The-Protocols).\nAnd as I said this happens if you merge multiple pull requests quickly after each other.. ",
    "ryan-kimber": "Is there a way to use dist tags without manually editing the package.json?\nWe'd like to have our versioning tied to the branch and not have developers\nmaking manual changes to package.json.\nOn Sat, Mar 26, 2016 at 11:54 PM, Tushar Mathur notifications@github.com\nwrote:\n\nI would rather use npm dist tags, which semantic release has awesome\nsupport for.\nOn Sun, Mar 27, 2016, 1:05 AM Ryan Kimber notifications@github.com\nwrote:\n\nI'd like to be able to use semantic-release to automatically version and\npublish pre-releases when we merge to the develop branch, and to publish\nreleases when we merge to master.\nIt doesn't seem as though semantic-release has been built with this use\ncase in mind, which makes me wonder if this a poor idea.\nI'm looking for some feedback on this idea, and would be happy to create\na\npull-request to add the feature if there's support for it.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub\nhttps://github.com/semantic-release/semantic-release/issues/207\n\nRegards,\nTushar Mathur.\nwww.tusharm.com\n\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly or view it on GitHub\nhttps://github.com/semantic-release/semantic-release/issues/207#issuecomment-201981943\n. I understand what you're saying, but that would mean we're manually managing those tags when we'd like it to all be handled by virtue of what branch the build takes place on (i.e. it IS a release if it's on master, so we want to automatically tag it as latest).\n\nI hope I'm not coming across as critical of the tool - it's a great tool, I'm just not clear on how to best manage this use case.\nFor now, we're executing these commands after a successful build:\n\nif [ \"$PULL_REQUEST\" == \"false\" ]; \n  then (npm run semantic-release && set NPM_PUBLISHED=1) \n    || (echo Unable to publish version && set NPM_PUBLISHED=0);\nfi\nexport PACKAGE_VERSION='cat package.json | jq .version -r'\nexport PACKAGE_NAME='cat package.json | jq .name -r'\nif [ \"NPM_PUBLISHED\" == \"1\"]; \n then npm dist-tag add $PACKAGE_NAME@$PACKAGE_VERSION $BRANCH; \nfi\nif [ \"NPM_PUBLISHED\" == \"1\" && \"$BRANCH\" == \"master\" ]; \n  then npm dist-tag add $PACKAGE_NAME@$PACKAGE_VERSION latest;\nfi\n\nThis is kind of working, but it doesn't feel quite right.\n. The branch option is working well. \nWhere I ended up wasting a lot of time is trying to figure out how to use pre-release tags, and I guess what we're saying is that pre-release tags aren't supported (at least as it currently stands) and aren't recommended practice.\nHow about working that into the landing README.md? (I'll be happy to do it)\n. For an initial release, it can be a bit of a pain - the change log isn't\nreally appropriate. That is, we're releasing a new library, it's supposed\nto be v1.0 - I probably don't want every commit tracked in a change log and\nI probably don't want to have to list a 'breaking change' or list of\nindividual features - I just want it to become 1.0.0.\nThis should be default behaviour (not even a separate switch on the command\nline) so that it doesn't require separate handling in a CI process. The\nfirst time I merge code to master, I should be able to run\nsemantic-release, it should see that there's no previous version, and it\nshould create a 1.0.\nOnce a 1.0.0 is out there, the change-log and auto-versioning makes sense.\nOn Tue, Apr 5, 2016 at 10:57 AM, Thiago Felix notifications@github.com\nwrote:\n\nWell, it is a bit cumberstome yes.\nBut you need to start using conventional-changelog since the beggining,\nand make sure you have feat/fix commits by the time you release you package.\nBecause if you don't have feat/fix to release, what are u release them ? =p\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly or view it on GitHub\nhttps://github.com/semantic-release/semantic-release/issues/208#issuecomment-205845163\n. In my use-case, I renamed my modules. That will work, but it's a\nfrustrating solution.\n\nAnother option you could explore (but I haven't tried this), is to push a\nnew version of your module to NPM (and make it your 'latest' or custom\nequivalent) and use a semantic-formatted version name that doesn't conflict\nwith your existing naming. Once you've done that, semantic-release might\nbehave.\nOn Fri, May 20, 2016 at 6:28 PM, Alexandru Badiu notifications@github.com\nwrote:\n\nI'm in the same situation, I haven't used conventional-changelog from the\nbeginning and now semantic-release won't do the first release, even with a\nnew feat. What would be the solution in this case (ignoring removing the\nrepo and doing a one time big import of all the code as a feature)?\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly or view it on GitHub\nhttps://github.com/semantic-release/semantic-release/issues/208#issuecomment-220733323\n. My apologies, but we've deleted the repository and renamed the project to get around this issue. \n\nIf we have it happen again on another repo, I'll add another ticket.. ",
    "voidberg": "I'm in the same situation, I haven't used conventional-changelog from the beginning and now semantic-release won't do the first release, even with a new feat. What would be the solution in this case (ignoring removing the repo and doing a one time big import of all the code as a feature)?\n. ",
    "camwest": "@boennemann mind taking a look at this one?\n. ",
    "meldiner": "we use semantic release by requiring it as a module and not using its cli. this PR is for allowing this type of usage.. ",
    "dbartholomae": "The current version should be part of the documentation files to make it easy to look up documentation for different versions.\nFurthermore it's needed to create a changelog-file. And if the version isn't in the package.json, it's hard to automate :)\n. Yes, that's why it would be easy to add an option that just adds the upcoming version.\n. ",
    "timotgl": "I currently have the problem that two repos A and B use semantic-release and have no version in their respective package.json. For testing purposes, I'd like to include A as a dependency of B by specifiying the github branch. This however breaks npm install, because repo A is cloned and no version is found in package.json.\nI resorted to putting a fake version number in each repo's package.json that is included in that way (the dependency graph is actually bigger than B->A).\nIs there a better way to deal with this? I think doing  npm publish just to test a branch is too much overhead. I'm aware that I can use npm link locally.\n. ",
    "ifyio": "Is there any word on this? I'm making a cli tool and it would be useful able to be able to grab the version number from the package.json.\n. ",
    "mucsi96": "+1. ",
    "bluecamel": "+1. ",
    "robophil": "Updating package.json... Very necessary.. Hi,\nI was previously using master with semantic release but i changed it to develop\njson\n{\n  \"branch\": \"develop\"\n}\nand that's when the issue started. As stated above, i even tried pushing a tag manually but that didn't help as it kept asking for a specific commit as shown in the log file above.\nsemantic-release ERR! commits You can recover from this error by publishing manually or restoring the commit \"623866dc2f616b3883165ad92b15a30dafa8ebc4\".. Develop was branched off master, and that's where I push to\nBy default, semantic-release was tracking master so I merged into master and a release was made.\nI want a release to be made every time I merge into develop, that's why I changed my default branch to develop. I haven't been able to get semantic release to work after that.\nI'm yet to try 8.2.0, but i'll do that now.. Yh, I did and faced the same issue.\nHere's what I did that helped.\nbash\ngit checkout develop\ngit merge v1.0.1\nAfter merging that tag into develop, it worked fine ;-) \ngit tag --merged develop now shows v1.0.1.\nThanks for all the help @pvdlg . ",
    "jbcpollak": "@thiagofelix I also ran into issue #300 with Artifactory - do you have a workaround for that?\n. I solved this problem by switching to go-semantic-release and letting npm\nhandle the deployment step\nOn Fri, Jun 16, 2017, 12:12 PM Federico Zivolo notifications@github.com\nwrote:\n\nAny chance to perform the work suggested by @paulkenney\nhttps://github.com/paulkenney?\nAre PRs accepted for this?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/semantic-release/semantic-release/issues/213#issuecomment-309068217,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AALgjjWuOP6bcG-40LROuyBwVnI6bAZpks5sEql5gaJpZM4IBaRz\n.\n. I haven't done it yet, but I looked into that a little bit. My solution was going to be something like this:\n\n```\n!/bin/bash\n~/semantic-release -vf\nexport VERSION=$(cat .version)\nlerna publish --repo-version ${VERSION} --skip-git --yes\n```\nThere are a lot of useful command line switches on the lerna publish command: https://github.com/lerna/lerna#commands\nHope that helps.. @janppires I have tried as you suggested, but I get the following error. It is a bit different because I am also using a scoped package, but I did setup my .npmrc to use the correct scoped configuration, and we have been deploying with that config directly via `npm publish without trouble.\nsemantic-release verb pre Wrote authToken to .npmrc.\nverb request uri https://mycompany.jfrog.io/mycompany/api/npm/npm-local/auth/mycompany/@scope%2Fmyproject\nverb request no auth needed\ninfo attempt registry request try #1 at 1:11:03 AM\nverb request id 1aaf69ee06c4c83a\nhttp request GET https://mycompany.jfrog.io/mycompany/api/npm/npm-local/auth/mycompany/@scope%2Fmyproject\nhttp 401 https://mycompany.jfrog.io/mycompany/api/npm/npm-local/auth/mycompany/@scope%2Fmyproject\nverb headers { date: 'Thu, 27 Apr 2017 05:11:03 GMT',\nverb headers   'content-type': 'application/json;charset=ISO-8859-1',\nverb headers   'content-length': '91',\nverb headers   connection: 'keep-alive',\nverb headers   server: 'Artifactory/5.2.1',\nverb headers   'x-artifactory-id': 'aolshared2b-mycompany',\nverb headers   'www-authenticate': 'Basic realm=\"Artifactory Realm\"',\nverb headers   'x-node': 'nginx-shared2b' }\nsemantic-release ERR! pre Failed to determine new version.\nsemantic-release ERR! pre E401 Registry returned 401 for GET on https://mycompany.jfrog.io/mycompany/api/npm/npm-local/auth/mycompany/@scope%2Fmyproject \nError: Registry returned 401 for GET on https://mycompany.jfrog.io/mycompany/api/npm/npm-local/auth/mycompany/@scope%2Fmyproject\nsemantic-release ERR! pre     at makeError (/Users/me/src/myproject/node_modules/npm-registry-client/lib/request.js:304:12)\nsemantic-release ERR! pre     at RegClient.<anonymous> (/Users/me/src/myproject/node_modules/npm-registry-client/lib/request.js:282:14)\nsemantic-release ERR! pre     at Request._callback (/Users/me/src/myproject/node_modules/npm-registry-client/lib/request.js:212:14)\nsemantic-release ERR! pre     at Request.self.callback (/Users/me/src/myproject/node_modules/request/request.js:187:22)\nsemantic-release ERR! pre     at emitTwo (events.js:106:13)\nsemantic-release ERR! pre     at Request.emit (events.js:192:7)\nsemantic-release ERR! pre     at Request.<anonymous> (/Users/me/src/myproject/node_modules/request/request.js:1048:10)\nsemantic-release ERR! pre     at emitOne (events.js:96:13)\nsemantic-release ERR! pre     at Request.emit (events.js:189:7)\nsemantic-release ERR! pre     at IncomingMessage.<anonymous> (/Users/me/src/myproject/node_modules/request/request.js:969:12). This might be related, I noticed that get-registry.js seems to look up the scoped registry incorrectly:\nhttps://github.com/semantic-release/semantic-release/blob/caribou/src/lib/get-registry.js#L7\nI believe this:\nvar scopedRegistry = conf.get(scope + '/registry')\nshould be:\nvar scopedRegistry = conf.get(scope + ':registry')\nAccording to the npm scope documentation (https://docs.npmjs.com/misc/scope), at the bottom of the page it says:\nnpm config set @myco:registry http://reg.example.com. You mean setting only NPM_OLD_TOKEN, correct? or only NPM_TOKEN?\nI don't have $NPM_TOKEN set, but I do have an _authToken set in ~/.npmrc, however its scoped only to npmjs.org:\n$ less ~/.npmrc\n//registry.npmjs.org/:_authToken=..... how do you do this without having to modify package.json each time you merge from develop to master? Is there a way to specify the release and publishConfig parameters from the commandline?. We found go-semantic-release a better option for us. We now use a somewhat customized fork that theoretically) handles calculating feature-branch versions automatically:\nhttps://github.com/6RiverSystems/go-semantic-release. ",
    "vampolo": "Ran on the same problem and verified that npm view mypackage@latest --registry=JFROG | grep gitHead returns empty. Any workaround?. For what it is worth i tried to contact Artifactory support to let them know about this problem. They seemed unresponsive.. ",
    "paulkenney": "It seems that https://github.com/semantic-release/semantic-release/pull/10 broke this library for use Artifactory users. Has anyone looked into reverting that refactoring or at least making is so that if gitHead is not provided (as is the case with Artifactory) then the less efficient method is used which queries git for tags?\nOther related issues:\n https://github.com/semantic-release/semantic-release/issues/256: Bump minor version when not needed\n https://github.com/semantic-release/semantic-release/issues/229: Fetching latest release from npm is error prone\n* https://github.com/npm/read-package-json/pull/67: Fall back to .git/packed-refs if .git/ does not exist. ",
    "Conaclos": "@destroyerofbuilds Thanks for your relevant reply ;)\n. ",
    "marcusnielsen": "I think lots of people don't want to publish to npm for apps, but still want the semver for tracking releases internally. \nI'm glad I found this question and its hot-fix solution! \ud83d\udc4d\n. ",
    "jwright04": "Just ran across this which works nicely: https://github.com/finom/last-release-git \nDescription: semantic-release plugin for projects that must not be published at NPM\n. ",
    "gavriguy": "Sorry It's been I while so I don't remember exactly the issue I had. Your suggestion sounds like a good solution.\nClosing this issue as I'm not sure how to reproduce it anymore. ",
    "sarbbottam": "Fixed, please see https://github.com/sarbbottam/watch-and-exec/issues/4\n. ",
    "Raathigesh": "\nBut since you already did, you should just delete the equivalent git tag 1.0.0 and then try again.\n\nBut the issue would be semantic-release will again determine the version as 1.0.0 but npm would not allow to publish again with the same version.\n\nEven if a package version is unpublished, that specific name and version combination can never be reused. - Npm Docs\n\nIs there a workaround to this issue? May be publish the next version (v1.0.1) manually and then use semantic-release after that so it would determine the version correctly going forward ?\n. Thanks for the info. Closing the issue. \n. ",
    "Tzaphkiel": "I'm also curious why it suddenly went from v4.3.5 to v6.x.y with the latest release v6.3.0 not released on npmjs.\nCould you please give us some more information ?\n. ",
    "goodmind": "Is there anything about this?\n. ",
    "0-vortex": "taken from my package.json:\n\"semantic-release\": \"^6.3.0\",\nYou are probably running the semantic-release-cli v4 and then fail to update with ncu.\nBottom line is that all versions are on npmjs.com. \nThis issue needs to be closed\n. read http://semver.org \"faq\" section\n. the solution is to restart the failing build (the stuck one)\ntravis_after_all.py is natively included in travis now afaik (it's still bugged anyway will work in 50% of the cases as intended)\n. Could this be related to your issue ?\nhttps://github.com/semantic-release/last-release-npm/pull/87\n. read the documentation for \"breaking changes\"\n. check out https://www.npmjs.com/package/semantic-release#is-it-really-a-good-idea-to-release-on-every-push\n. I think SR was built for Travis with the actual semantic-release cli running on travis_after_all. It's basically a configuration issue, you are running npm run semantic-release inside your build when you should run it after everything is 'done'\n. @marvindanig OP said he is running it on Codeship CI, you show me Travis CI configuration for an entirely unrelated problem. As a side note, you have a different problem, did you read the documentation ? \nI can't find your package on NPM so it's unlikely I can be of any assistance\n. @marvindanig are you sure you read the documentation for semantic-release ? I ask this because the problems you are experiencing are the result of not reading the main page ... I don't want to be critical but it's explained clearly that SR is doing automated releases, in order to do this you need to have the package available and published already - at least, that's my understanding after using SR on 3 packages. My only issue with it was with last-release calculator that did not account for unpublished versions (for which I created a pull request and never got merged)\nFrom the looks of it you might benefit from doing manual bumps, for example netflix unleash (still new technology and buggy in my opinion but might be less hassle for you)\n. Yes, at the moment of writing I actually encountered that issue as well, found it as a quirk in the documentation, lead to a bug in last-release-npm that I fixed but never got accepted. \nI don't know what happened to that project as I only used it on 2 repos, some fixes which I found crucial never got accepted and I ended up being challenged due to the strict usage of SR.\nI don't rate the project very highly based on my experience with it so if you want my advice I'd say use standard-version or unleash.\nCheers !. ",
    "uglow": "Is there any explanation for this? The 6.x releases have been going for almost a year. Surely there is a good reason to switch this to @latest or advise why it must remain on the @next channel. Should we be using 6.x?\n. https://github.com/leonardoanalista/corp-semantic-release generates changelogs and works for non-GitHub repositories.\n. @bahmutov Was the grouping behaviour (by type(feature/fix/breaking) & scope) removed?. ",
    "nephridium": "It depends on what kind of version bump the change warrants. Have a look at https://github.com/conventional-changelog/conventional-changelog-angular/blob/master/convention.md#type - BREAKING CHANGES (with any prefix), feat, fix or perf will be shown in the changelog and will bump major, minor, patch or no version number, respectively. (Or you can get the straight dope on what is handled from the source: https://github.com/semantic-release/commit-analyzer/blob/master/src/index.js)\nIf you're replacing an app function with a lodash function you could prefix refactor (or anything else you prefer) if it's not significant for the changelog or fix/feat if you want a version bump.\n. ",
    "elliotttf": "In case anyone else needs to support additional prefixes, I've written a module that duplicates the behavior of the commit analyzer that ships with semantic release but also allows configuring release behavior more granularly.\nFor the maintainers: I'm happy to work with you on including this functionality in commit-analyzer if there's interest \u2013 given semantic-release/commit-analyzer#11 and semantic-release/commit-analyzer#12 though it's not clear to me that this is actually desired for the project.. ",
    "davemachado": "Clean install of sementic-release throws deprecated errors, could be similar to this issue. Thoughts?\n. Could be similar to issue #229 \n. This might be tied back to the Travis CI API bug from a few weeks ago.\n. I went through the closed issues list and didn't see anything that referenced this being fixed. If someone else would like to look through the issues and look for duplications, that would be great.\n. ",
    "motiz88": "Related issue: #256. There's another workaround in https://github.com/semantic-release/semantic-release/issues/256#issuecomment-239678516, plus a reference to the npm bug that's causing this.\n. Seeing the same behavior here: motiz88/astring-flow. I'm also using CircleCI, maybe that's a factor? I have several other modules building on Travis with semantic-release, and that has always worked fine.\n. tl;dr: try running the attached git/bash one-liner prior to npm publish\nGot it! semantic-release is not the culprit (though it could possibly help - see 1 below). This happens when the \"latest\" version on npm is missing the gitHead field of package.json. In this case, semantic-release analyzes the entire commit history each time, generating spurious version bumps.\nThis arises from npm publish's ~~brittle~~ broken way of getting at that Git hash in the first place (PR here): It silently fails on perfectly valid Git repos if they use packed refs a certain way.\nCuriously, that somehow happens on CircleCI and not on, say, Travis (last time I checked). Haven't looked into why that is, since again, the situation is perfectly valid from a git standpoint - It's npm that's depending on an internal detail and thus breaking.\nNow, the workaround: I added the following Bash command to circle.yml right before npm run semantic-release. It reconstructs the \"unpacked refs\" for all the branch heads that exist only as packed refs, so npm can read them where it expects them. Thus npm publish will include the correct gitHead reference and thus the next semantic-release run will see the correct, truncated change list.\nbash\ngit show-ref --head --heads | while IFS=' ' read -r hash name; do test ! -e \"${GIT_DIR:-.git}/$name\" && echo $hash > \"${GIT_DIR:-.git}/$name\"; done\ncc @peteyy @krishna-koushik re: #258 - maybe this applies to your cases too?\nOther thoughts:\n1. Two things semantic-release can (should?) do about this mess: emit a warning in case of a missing gitHead; infer the correct hash from the local repo by looking for the vx.y.z git tag auto-created by npm publish.\n2. @bahmutov, do you feel like including the workaround in condition-circle? Seems like an easy enough fix. semantic-release is effectively broken on CircleCI right now, and there's no telling if/when the npm fix will ship.\n. @krishna-koushik I think you did it right. The fix takes effect from the next publish. To verify this without pushing another version right now, you can look at the output of npm info @meltwater/output-manager-api and see that it has a non-empty ~~gitHash~~ gitHead field.\n@bahmutov Fantastic :smile:\n. @krishna-koushik I meant gitHead, so you're fine. (Edited my previous comment accordingly)\n. ",
    "krysalead": "Hi,\ngot the same running on Ubuntu 14.04.\n. ",
    "metasean": "Related to #234 & #215 & #51\n. ",
    "aberonni": "+1 I see there is a hotfix in #215 but I haven't looked into it\n. ",
    "marvindanig": "Did any of you get it working finally? On my rather new/empty nodejs project travis-ci showsbuild:success but no releases are published on Github or on npm. Any help would be great! \n. @vrtxf  My .travis.yml file looks like this:\n```\nsudo: false\nlanguage: node_js\ncache:\n  directories:\n    - node_modules\nnotifications:\n  email: false\nnode_js:\n  - '6'\n  - '6.1'\n  - '6.2'\n  - '6.3'\nbefore_install:\n  - \"npm i -g npm@latest\"\nbefore_script:\n  - npm prune\nscript:\n  - npm run test:once\nafter_success:\n  - npm run semantic-release\nbranches:\n  except:\n    - /^v\\d+.\\d+.\\d+$\n```\nAnd the build fails exactly with the same error log as reported above. So what do you mean by \"running npm run semantic-release inside your build when you should run it after everything is 'done'\"?\nThe logs are here:\n```\n\nflippy@0.0.0-semantically-released test:once /home/travis/build/marvindanig/flippy.JS\n mocha ./tests/start.tests.js\n  Flippy.JS\n    First\n      \u2713 Should work\n    new\n      \u2713 Is it installed correctly?\n  2 passing (10ms)\nThe command \"npm run test:once\" exited with 0.\ncache.2\nstore build cache\n0.00s\n1.89snothing changed, not updating cache\nafter_success\n1.74s$ npm run semantic-release\nflippy@0.0.0-semantically-released semantic-release /home/travis/build/marvindanig/flippy.JS\nsemantic-release pre && npm publish && semantic-release post\nsemantic-release ERR! pre Failed to determine new version.\nsemantic-release ERR! pre ENOCHANGE There are no relevant changes, so no new version is released.\nnpm ERR! Linux 3.13.0-40-generic\nnpm ERR! argv \"/home/travis/.nvm/versions/node/v6.5.0/bin/node\" \"/home/travis/.nvm/versions/node/v6.5.0/bin/npm\" \"run\" \"semantic-release\"\nnpm ERR! node v6.5.0\nnpm ERR! npm  v3.10.6\nnpm ERR! code ELIFECYCLE\nnpm ERR! flippy@0.0.0-semantically-released semantic-release: semantic-release pre && npm publish && semantic-release post\nnpm ERR! Exit status 1\nnpm ERR! \nnpm ERR! Failed at the flippy@0.0.0-semantically-released semantic-release script 'semantic-release pre && npm publish && semantic-release post'.\nnpm ERR! Make sure you have the latest version of node.js and npm installed.\nnpm ERR! If you do, this is most likely a problem with the flippy package,\nnpm ERR! not with npm itself.\nnpm ERR! Tell the author that this fails on your system:\nnpm ERR!     semantic-release pre && npm publish && semantic-release post\nnpm ERR! You can get information on how to open an issue for this project with:\nnpm ERR!     npm bugs flippy\nnpm ERR! Or if that isn't available, you can get their info via:\nnpm ERR!     npm owner ls flippy\nnpm ERR! There is likely additional logging output above.\nnpm ERR! Please include the following file with any support request:\nnpm ERR!     /home/travis/build/marvindanig/flippy.JS/npm-debug.log\nDone. Your build exited with 0.\n\n```\n. hmm, I missed reading the Codeship CI part in my rush \u2026  :( I got the fix thanks @vrtxf but I apologize for littering this thread for an unrelated issue that earlier seemed the same to me. \nAnother reason why it'd be appropriate to wrap three commands semantic-release pre && npm publish && semantic-release post in a way so that errors are logged out for each step separately.\n. ",
    "ByteDefault": "I'm in the same situation, I've tried with a fresh install but no luck. Any link to the Travis CI bug to track the progress?\n. @terales I've tried manual configuration and it doesn't work for private repos because semantic-release tries to connect with travis-ci.org instead of travis-ci.com (which is the server for private repos).\nIs there any way to set travis-ci.com as default server?\n. Ok, thank you for the info \ud83d\ude04 \nAny possible workarounds?\n. ",
    "ColinEberhardt": "Aaarrghh ... so the name I was publishing to was already taken. The Are you logged in as the correct user? message is really misleading.\n. ",
    "DianaSuvorova": "I am glad I found this. The error message is a bit confusing indeed. Although I understand that correctly detecting the cause might be a bit challenging. But adding it as a suggestion  Are you logged in as the correct user or are you the owner of the npm package would have saved me a bit time.\nIn addition to that I was only able to see this error msg if running Travis on node v8. Any version below 8 gives no readable error but rather ELIFECYCLE code. This might be completely different issue.  . @vanduynslagerp , that makes sense.\nAs for node version 8 requirements - this makes sense as well. The problem I see with that is that .travis.yml generated by semantic-release-cli setup the default list of node version does not include 8. So it took me sometime to figure out what's going on. \nlanguage: node_js\ncache:\n  directories:\n    - node_modules\nnotifications:\n  email: false\nnode_js:\n  - '7'\n  - '6'\n  - '4'\nbefore_script:\n  - npm prune\nafter_success:\n  - npm run semantic-release\nbranches:\n  except:\n    - /^v\\d+\\.\\d+\\.\\d+$/. OK, what is a correct way of deleting a plugin? and do I need to install anything instead?. I wish I knew where to find them. It was generated by semnatic-release-cli. npm run semantic-release seems to magically know what to do. . the repo is https://github.com/DianaSuvorova/eslint-plugin-react-redux. Got it, yes, thanks for the explanation. removing ./node_modules/@semantic-release + npm install fixed the issue.\nThanks a bunch!. ",
    "develar": "If you don't have time to maintain project, maybe you can add someone to contributors to help?\n. This feature request contradicts the idea of semantic release. To apply changed CHANGELOG.md additional commit is required. So, imagine \u2014  on each your fix or feat commit will  be created yet another synthetic commit. And your log will be littered with it.\nIt is exactly why version not presented in the package.json.\nAlso, sometimes you will change GitHub release notes to add contributors/some additional notes.\nSo, it is bad idea :) You or use semantic release (release often) or not (sporadic releases and angry users (if your project is active).\n. ",
    "krishna-koushik": "Not sure if i did this right but it did not work for me.\n\nMy Circle.yml looks like this at the end.\n\n. I ran the command but i did not see a gitHash field.\ngitHead: 'b355667a2a2a83b8ae7dd1c4f30fbb03d9c66643',\n  dist: \n   { shasum: '7959dd9490983e39777e9873932611d394d9b234',\n     tarball: '' },\n  directories: {} }\n. Awesome thank you @motiz88 :)\n. I have a similar problem but for me lately my fix(): messages are generating minor version instead of fix version.\nMy Commit message: fix(npm shrinkwrap): Update npm shrinkwrap (#43)\n\nnpm run semantic-release\n@meltwater/output-manager-api@0.0.0-semantic-release semantic-release /home/ubuntu/output-manager-api\nsemantic-release pre && npm publish && semantic-release post\n@meltwater/output-manager-api@1.19.0\nGenerating changelog from v1.18.0 to HEAD...\nParsed 1 commits.\n\nI am using version 4.3.5\n. ",
    "tleunen": "Glad you found a way to fix it @motiz88!\n. ",
    "peteyycz": "I added the following to the circle.yaml:\nyaml\ndeployment:\n  master:\n    branch: master\n    commands:\n      - git show-ref --head --heads | while IFS=' ' read -r hash name; do test ! -e \"${GIT_DIR:-.git}/$name\" && echo $hash > \"${GIT_DIR:-.git}/$name\"; done\n      - npm run semantic-release\nBut I still got a major release out of a feat() tag without a BREAKING line.\nEDIT: after the second commit it has been resolved, thanks! \ud83d\udc9b \n. ",
    "gund": "I have somewhat similar problem, it publishes new version to NPM but fails to publish release notes to Github (despite token is fine) with next error:\nsemantic-release ERR! post Failed to publish release notes. { [Error: {\"message\":\"Validation Failed\",\"errors\":[{\"resource\":\"Release\",\"code\":\"already_exists\",\"field\":\"tag_name\"}],\"documentation_url\":\"https://developer.github.com/v3/repos/releases/#create-a-release\"}]\nsemantic-release ERR! post   message: '{\"message\":\"Validation Failed\",\"errors\":[{\"resource\":\"Release\",\"code\":\"already_exists\",\"field\":\"tag_name\"}],\"documentation_url\":\"https://developer.github.com/v3/repos/releases/#create-a-release\"}',\nsemantic-release ERR! post   code: 422 }\nI can see that the message is Release + already_exists + tag_name so seems like it tries to release with same version however NPM version was updated with new one.\nIs there any option to enable verbose/debug mode to see which version it is trying to push to Github?\nThanks\nUPD: Also forgot to mention, the very first release (which was determined as v1.0.0) was released successfully to NPM and Github. But all releases after that failed with error above.\n. It is still written in the release notes... Does anyone know when this can be fixed?. ",
    "kelkes": "I've got the same problem. Trying to publish release notes for a private scoped packages\n```\nGenerating changelog from  to HEAD...\nParsed 5 commits.\nsemantic-release ERR! post Failed to publish release notes. { [Error: {\"message\":\"Validation Failed\",\"errors\":[{\"resource\":\"Release\",\"code\":\"custom\",\"field\":\"tag_name\",\"message\":\"tag_name is not a valid tag\"},{\"resource\":\"Release\",\"code\":\"custom\",\"message\":\"Published releases must have a valid tag\"},{\"resource\":\"Release\",\"code\":\"invalid\",\"field\":\"target_commitish\"}],\"documentation_url\":\"https://developer.github.com/v3/repos/releases/#create-a-release\"}]\nsemantic-release ERR! post   message: '{\"message\":\"Validation Failed\",\"errors\":[{\"resource\":\"Release\",\"code\":\"custom\",\"field\":\"tag_name\",\"message\":\"tag_name is not a valid tag\"},{\"resource\":\"Release\",\"code\":\"custom\",\"message\":\"Published releases must have a valid tag\"},{\"resource\":\"Release\",\"code\":\"invalid\",\"field\":\"target_commitish\"}],\"documentation_url\":\"https://developer.github.com/v3/repos/releases/#create-a-release\"}',\nsemantic-release ERR! post   code: 422,\nsemantic-release ERR! post   status: 'Unprocessable Entity',\nsemantic-release ERR! post   headers:\nsemantic-release ERR! post    { server: 'GitHub.com',\nsemantic-release ERR! post      date: 'Mon, 13 Feb 2017 13:33:55 GMT',\nsemantic-release ERR! post      'content-type': 'application/json; charset=utf-8',\nsemantic-release ERR! post      'content-length': '386',\nsemantic-release ERR! post      connection: 'close',\nsemantic-release ERR! post      status: '422 Unprocessable Entity',\nsemantic-release ERR! post      'x-ratelimit-limit': '5000',\nsemantic-release ERR! post      'x-ratelimit-remaining': '4918',\nsemantic-release ERR! post      'x-ratelimit-reset': '1486993406',\nsemantic-release ERR! post      'x-oauth-scopes': 'repo, read:org, user:email, repo_deployment, repo:status, write:repo_hook',\nsemantic-release ERR! post      'x-accepted-oauth-scopes': '',\nsemantic-release ERR! post      'x-github-media-type': 'github.v3; format=json',\nsemantic-release ERR! post      'access-control-expose-headers': 'ETag, Link, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval',\nsemantic-release ERR! post      'access-control-allow-origin': '*',\nsemantic-release ERR! post      'content-security-policy': 'default-src \\'none\\'',\nsemantic-release ERR! post      'strict-transport-security': 'max-age=31536000; includeSubdomains; preload',\nsemantic-release ERR! post      'x-content-type-options': 'nosniff',\nsemantic-release ERR! post      'x-frame-options': 'deny',\nsemantic-release ERR! post      'x-xss-protection': '1; mode=block',\nsemantic-release ERR! post      'x-github-request-id': 'xxx' }\n````. ",
    "felixcrive": "Same for me\nsemantic-release ERR! post Failed to publish release notes. { [Error: {\"message\":\"Not Found\",\"documentation_url\":\"https://developer.github.com/enterprise/2.8/v3\"}]\nsemantic-release ERR! post   message: '{\"message\":\"Not Found\",\"documentation_url\":\"https://developer.github.com/enterprise/2.8/v3\"}',\nsemantic-release ERR! post   code: 404 }. ",
    "toverux": "Why this issue has been closed? :) I'm having this problem for a while, and I'm tagging manually for now.\n@kentcdodds . Thanks, I'll see if I can help on this, I like this tool and I'd be happy to see it generating the changelogs.. Oh, strange, I've just published the 1.0 version of mitmadness/UnityInvoker and... that worked, the changelog has been generated. This is a scoped package too so... Are we certain that this bug is tied to scoped names?\nWill comment again if I encounter the bug on the next release.. ",
    "vaidik": "Experiencing the same issue. I have a private repo and I didn't want to publish my package on npm. So I have removed the npm publish command from the semantic-release script. Could that be causing any issue?. I also tried committing the version to package.json.. ",
    "maxcnunes": "I had that error {\"resource\":\"Release\",\"code\":\"already_exists\",\"field\":\"tag_name\"} as well. In my case the package.json-repository.url was pointing to the wrong project.. ",
    "zeidlos": "Still is an issue. :(. ",
    "safareli": "Thanks\n. This solved my issue\n\npackage.json\njson\n{\n  \"release\": {\n    \"analyzeCommits\": \"./misc/releaseAnalyzeCommits\n  }\n}\nmisc/releaseAnalyzeCommits\n``` js\nconst conventionalRecommendedBump = require('conventional-recommended-bump')\nmodule.exports = (options, parserOpts, cb) => conventionalRecommendedBump(\n  Object.assign({}, options, { preset: 'angular' }),\n  parserOpts,\n  (err, res) => cb(err, res != null ? res.releaseAs : res)\n)\n```\n. ",
    "kumarharsh": "The snippet is a bit outdated. In conventional-recommended-bump, the res.releaseAs property is apparently renamed to res.releaseType now.. I think the devs have mentioned something regarding that here: https://github.com/semantic-release/semantic-release#can-i-run-this-on-my-own-machine-rather-than-on-a-ci-server. When I ran this:\nnpm dist-tag ls react-ui-debugger\nand I got a response:\nnpm http request GET https://registry.npmjs.org/-/package/react-ui-debugger/dist-tags\nnpm http 200 https://registry.npmjs.org/-/package/react-ui-debugger/dist-tags\nlatest: 0.0.4\nedit: Looking at the log output in your case, NPM is giving a 403 response, which means that maybe your npm is not correctly setup?. Upgrading from 6.x to latest 8.2.2 is giving me this error:\nhttps://travis-ci.org/kumarharsh/graphql-for-vscode/jobs/292268485\n\nI am running node 8.7.0\n\n. @felixfbecker there is https://github.com/kumarharsh/semantic-release-visualstudio-marketplace-version which you might be interested in.. ",
    "bfred-it": "semantic-release is node.js and that won't change unless somebody really wants to write a version in their own language. \nIf you're asking for a semantic-release that publishes something to a place different from npm, then that is slightly more likely.\nI myself would be interested in using semantic-release to update and publish extensions to the Chrome Web Store; it'd have to \n1. update the version in manifest.json instead of package.json\n2. use chrome-webstore-uploadpublish instead of npm publish\n. ",
    "dalelotts": "I would like to use this to publish (java and node projects) to a private binary repository, not npm. (S3 in one case, artifactory in the other) but it does not look like that is supported...yet. \ud83d\ude04 \n. It's not clear that the scoped URL code 100% wrong. I can set the scoped registry using / without error, but maybe npm does not validate the input. In any case, that's not the issue I am having. \nI discovered that the 401 error happens when setting NPM_TOKEN, NPM_OLD_TOKEN and NPM_EMAIL. Setting only NPM_OLD_TOKEN and NPM_EMAIL got @alexw10  and me past the 401 error.  . I corrected my comment. Sorry, brain doesn't work on Friday. \ud83d\ude2d   \nSemantic release writes a new .npmrc file in the project directory during the pre step. You can inspect that file and see what it looks like before the npm publish step. . Getting past the 401 error isn't the end. \ud83d\udc4e \nArtifactory does not expose gitHead so sem-rel includes all commits in the release and the version bump is major every time if you have a breaking change in your commit history. Search past issues with gitHead for details. We got past the 401 by writing a .npmrc with the registry only and then setting NPM_OLD_TOKEN and NPM_EMAIL environment variable. \nThen I needed to figure out how to determine gitHead for the last release (it's not exposed by artifactory) - that's was a bit of code but not bad.\nNow I am stuck with detached head mode and semantic-release thinking that the current SHA is not in the master branch when it is - but the git repo on the Jenkins box is a detached head branch so...yeah. I hope to work through that issue soon.  LMK if anyone knows how to fix the issue with the detached head mode. \ud83d\udc4d . Thanks. Do I also need to update the assets for gitHub? Or does GitHub ignore pkgRoot?. I'm a bit confused by that comment...sorry, I'm slow today.\nIs this the correct configuration:\n\"release\": {\n    \"pkgRoot\": \"dist\",\n    \"publish\": [\n      {\n        \"path\": \"@semantic-release/npm\"\n      },\n      {\n        \"path\": \"@semantic-release/github\",\n        \"assets\": [\n          \"dist/*.zip\",\n          \"dist/*.tar.gz\"\n        ]\n      }\n    ]\n  }\nor this?\n\"release\": {\n    \"pkgRoot\": \"dist\",\n    \"publish\": [\n      {\n        \"path\": \"@semantic-release/npm\"\n      },\n      {\n        \"path\": \"@semantic-release/github\",\n        \"assets\": [\n          \"*.zip\",   <------ Change here - removed dist\n          \"*.tar.gz\" <------ and here\n        ]\n      }\n    ]  \n}\nI also removed success and fail since they are enabled by default.. Ah, I see. That is much simpler!\nI didn't get that at all from the current documentation. I'll take a stab at a PR for the documentation if you like. . ",
    "cybertk": "Cool, will have a try!. ",
    "honzajavorek": "It turns out some Travis CI environments have outdated npm installation by default, which is unable to deal with prefixed/scoped packages \ud83d\ude29 Solution is to make sure there's npm install -g npm@latest in your .travis.yml. Hope this helps to someone.\n. My project uses Sem Rel and follows the practice of having the changelog in GitHub Releases. However, I'd like to have a way to dynamically generate also a file with the changelog to attach it to my dynamically generated docs. Sometimes it's easier to scan, search and follow a single page then to interact with click-heavy UI, such as GitHub Releases. What would be the best approach to do this? Should I write my own tool and take the contents from GitHub Releases, or can I leverage Sem Rel for this somehow?. It was super annoying to go down the dependency chain and track this down, but it looks like the package which generates the actual text is conventional-changelog/conventional-changelog-writer and the template is here. But in the template it's correct. It looks like it has been fixed and Sem Rel needs to update dependencies (https://github.com/conventional-changelog/conventional-changelog-writer/commit/9942863d93d609899c23481798fd9a649138f4d6). Not sure how though, it's like 5th dependency down the chain \ud83d\ude10. So if you go for the workaround, make sure not to have the Semantic Release command in stage:\nyaml\njobs:\n  include:\n    - stage: \"code/docs/commits quality checks\"\n      node_js: \"6\"\n      script: \"npm run lint\"\n    - stage: \"tests & code coverage\"\n      node_js: \"4\"\n      script: \"npm run test:coverage && npm run coveralls\"\n    - node_js: \"6\"\n      script: \"npm run test:coverage && npm run coveralls\"\n    - stage: \"semantic release\"\n      node_js: \"6\"\n      # https://github.com/semantic-release/semantic-release/issues/390\n      script: \"TRAVIS_JOB_NUMBER=WORKAROUND.1 npm run semantic-release || true\"\nThis results in another error: Not running in Travis after_success hook \ud83e\udd26\u200d\u2642\ufe0f Solution is to set both\nTRAVIS_JOB_NUMBER=\"WORKAROUND.1\"\nTRAVIS_TEST_RESULT=\"0\"\n\nrelevant line of code\nrelevant issue on Travis CI - https://github.com/travis-ci/travis-ci/issues/8239. Just for the record, Travis now exposes TRAVIS_BUILD_STAGE_NAME env var: https://github.com/travis-ci/travis-ci/issues/8239#issuecomment-373729248. I see, makes sense. Thanks!. \n",
    "woshilapin": "@gajus I reached the same problem and found a solution.\nTL;DR; remove the Python script travis-after-all.py from your .travis.yml because it's redundant.\nI didn't have the problem until I updated semantic-release from 4.3.5 to version 6.3.1. And it seems that this new version is including a functionality similar to travis_after_all.py.  The dependency is  travis-after-all in semantic-release (see dependency @semantic-release/condition-travis which itself has the dependency travis-after-all).\nWhat was happening was that the Python script got called on all the jobs but only the first job was proclaimed leader (which is what is intended). The other jobs are launching the other commands and are reaching semantic-release pre. And the first job that called semantic-release pre will launch the travis-after-all javascript script and will also be proclaimed leader.  Second one will endlessly wait for the first one, and first one will endlessly wait for the second: the Python script and the Javascript dependency are fighting to do the exact same thing.\nThe Python script is now redundant with the semantic-release dependency travis-after-all.  You can check in your build this information.  First of all, the format of the messages are different (Leader waits for minions [u'92.2']... vs [travis-after-all] Waiting for 92.1 to be done...). Second, in your build #92.1, line 1403, it's the Python build which is waiting.  However, in #92.2, line 1501, the Python script has identified the job as a minion and line 1509, semantic-release is launched, waiting for other jobs to finish.  Hope this helps.\n. ",
    "Bigous": "Does anybody has any hint?. ",
    "justmoon": "Had the same issue. For me it was the fact that condition-circle wasn't installed.\nRecommended solution: Only put a require.resolve('../dist') statement inside of the try {} block. Right now, if there is a \"module not found\" error anywhere in semantic-release, it'll give this cryptic error message. If you put only require.resolve in the try-catch block, then it will only trigger if ../dist itself is not found, not any of its dependencies.\nSomething like:\n``` js\nfunction checkModule (path) {\n  let distAvailable = false\n  try {\n    require.resolve('../dist')\n    return true\n  } catch (err) {\n    if (err.code === 'MODULE_NOT_FOUND') {\n      return false\n    } else {\n      throw new Error('Unexpected error while resolving ../dist:' + err)\n    }\n  }\n}\nif (checkModule('../dist')) {\n  require('../dist')\n} else {\n  require('babel/register')\n  require('../src')\n}\n```\n. ",
    "Ridermansb": "Same error for me.. and I don`t set analyzeCommits path..\nI use circle-ci ...\nhttps://circleci.com/gh/Ridermansb/vue-gmaps/8\n\"release\": {\n    \"verifyConditions\": \"condition-circle\"\n  },\n  \"config\": {\n    \"commitizen\": {\n      \"path\": \"./node_modules/cz-conventional-changelog\"\n    }\n  }\n. ",
    "okonet": "I use TravisCI with npx travis-deploy-once \"semantic-release\" and just hit this as well. \nhttps://travis-ci.org/okonet/react-simple-focus-within/jobs/422469781. Probably this one is a wrong one for me after all. See https://github.com/semantic-release/travis-deploy-once/issues/87. We had a reason to pin the version although I can not remember what it was. That\u2019s understandable. I\u2019m going to upgrade to latest and see if it still works for us. . ",
    "coderbyheart": "This could be fixed by fetch the commit id from GitHub for the tag detected by last-release-npm. See https://github.com/semantic-release/release-notes-generator/issues/4. ",
    "cameronroe": "Okay, thanks. Closing now.\n. ",
    "theninthnode": "My question is more around the CI build failing due to the error exception ENOCHANGE  when in fact it's just not being released. My tests are passing but SR aborts the build\n. ",
    "bengummer": "I've raised a PR to solve this using child_process.spawn() as we're hitting the maxBuffer error again even with the limit set to 1MB.\nCan this issue be re-opened @boennemann ?. ",
    "Xiphe": "<3\n. ",
    "joscha": "@boennemann any chance to get this in?\n. Ah, great @boennemann - seems as if Node 5 on stable went red though: https://travis-ci.org/semantic-release/semantic-release/jobs/156795912\n. Just ran it locally with 5.12.0 again - green like in the PR tests:\n``` console\n\u279c  semantic-release git:(caribou) \u2717 npm test\n\nsemantic-release@0.0.0-placeholder pretest /Users/joscha/Development/semantic-release\nstandard\nsemantic-release@0.0.0-placeholder test /Users/joscha/Development/semantic-release\nnpm run test:unit && npm run test:integration\nsemantic-release@0.0.0-placeholder test:unit /Users/joscha/Development/semantic-release\nnyc tap --no-cov test/specs/*.js\n\ntest/specs/commits.js ............................... 10/10\ntest/specs/get-registry.js ............................ 6/6\ntest/specs/plugins.js ............................... 13/13\ntest/specs/post.js .................................... 9/9\ntest/specs/pre.js ..................................... 6/6\ntest/specs/type.js .................................... 5/5\ntest/specs/verify.js ....[]\ntest/specs/verify.js ................................ 11/11\ntotal ............................................... 60/60\n60 passing (7s)\nok\n------------------|----------|----------|----------|----------|----------------|\nFile              |  % Stmts | % Branch |  % Funcs |  % Lines |Uncovered Lines |\n------------------|----------|----------|----------|----------|----------------|\nAll files         |    94.66 |    87.06 |      100 |      100 |                |\n src              |     88.1 |       75 |      100 |      100 |                |\n  post.js         |       88 |    77.78 |      100 |      100 |                |\n  pre.js          |    88.24 |    66.67 |      100 |      100 |                |\n src/lib          |    97.75 |     91.8 |      100 |      100 |                |\n  commits.js      |    96.77 |    83.33 |      100 |      100 |                |\n  get-registry.js |      100 |      100 |      100 |      100 |                |\n  plugin-noop.js  |      100 |      100 |      100 |      100 |                |\n  plugins.js      |      100 |      100 |      100 |      100 |                |\n  type.js         |    91.67 |    83.33 |      100 |      100 |                |\n  verify.js       |      100 |    93.33 |      100 |      100 |                |\n------------------|----------|----------|----------|----------|----------------|\n\nsemantic-release@0.0.0-placeholder test:integration /Users/joscha/Development/semantic-release\ntap --no-cov test/scenarios/*.js\n\ntest/scenarios/pre.js ................................. 7/7 12s\ntotal ................................................. 7/7\n7 passing (12s)\nok\n```\n. @xicombd no it hasn't, the release failed because the travis build failed. I think it needs a re-run, but I don't have access.\n. ",
    "fbaiodias": "@boennemann I'm running into the same issue, did this change get published yet?\n. ",
    "boneskull": "@crobinson42 It does--in a GitHub release.\n. @crobinson42 No, it doesn't make a CHANGELOG.md.  It puts the changelog in the GitHub release description.\n. (I responded to the \"semantic-release generates changelogs\" quote)\n. Thanks @gr2m, I ran in to this as well.  . @hbetts It's worth noting that to get rid of the problem entirely, I had to not only remove npm prune but also the cache of node_modules.  Maybe I can put the cache back; there doesn't seem to be a way to reset it manually?. iarna writes:\n\n@boneskull I would have always cached ~./npm as well, but yeah npm@5 is fast enough that skipping node_modules is ok now.\n\nThis seems to imply that if you aren't using npm@5, then keep caching node_modules.. ",
    "levithomason": "You can generate a changelog from your issues and PRs with a curl call using https://github.com/levithomason/github-changelog-api. Human curated changelogs are always best but this can be an alright stop-gap. . ",
    "KarstenBuckstegge": "FYI:fix commits don't seem to trigger major version bumps even with a BREAKING CHANGE text in the commit body.. ",
    "janppires": "I was facing the same issue.\nAfter digging semantic-release code I saw two magic words: NPM_OLD_TOKEN and NPM_EMAIL.\nBecause semantic-release stills support the old way to authenticate with npm, people using Artifactory can use it. Simply export those two environment variables before running semantic-release command and add/create .npmrc file in your project, like this:\n_auth=${NPM_OLD_TOKEN}\nalways-auth=true\nemail=${NPM_EMAIL}\nAlso export GH_TOKEN environment variable (personal access token on github settings menu). Or use the release.githubToken field on your package.json file.\nI also configured publishConfig and release elements on package.json file:\n\"publishConfig\": {\n    \"registry\": \"http://ENTERPRISE_ARTIFACTORY/api/npm/NPM_REPO_NAME/\"\n  },\n\"release\": {\n    \"githubUrl\": \"https://ENTERPRISE_GH_URL\",\n    \"githubApiPathPrefix\": \"api/v3\",\n    \"verifyConditions\": []\n  }\nI have done verifyConditions:[] just to skip the default travis behaviour. Later you can use condition-jenkins.\nThe official jfrog website also provide good information about the npm registry process. Like how to get NPM Registry credentials, for NPM_OLD_TOKEN and NPM_EMAIL variables:\n$ curl -uadmin:password \"http://localhost:8081/artifactory/api/npm/auth\"\nI hope this helps other developers to take advantage of semantic-release tool!\nCheers. @yamikuronue Can it be because your package is not published on npm? \nThis plugin works fine and is configured in a similar way: https://www.npmjs.com/package/@krux/condition-jenkins. @yamikuronue, I mean, yamikuronue/commit-analyzer and yamikuronue/release-notes-generator packages! You can use npm publish on each package to publish, and then you can use  them as dependencies for the release. analyzeCommits and release. generateNotes fields.\nCheers,\n=). Hi @kreck! Could you share your semantic-release configuration integrated with jenkins? I do not find enough information about that. Many thanks. Thanks @kreck ! That seems easy! \nAnother problem I have is the fact that I do not want to use the default npm repo. I need to figure out how to setup artifactory instead.. ",
    "alexw10": "We are getting the same error Failed to determine new version.\n401 Registry returned 401 for get... when trying to use semantic release with artifactory\nAnyone have a solution?. Hmmm, well we aren't using scoped at all and still hitting this same issue.\n. ",
    "weishang": "I tried using NPM_OLD_TOKEN and NPM_EMAIL instead, https://github.com/semantic-release/semantic-release/blob/a4951b7c3004793ef658f344e7875f4accc7e637/src/lib/publish-npm.js#L21, the generate .npmrc file looks promising, which should satisfy npm publish, but I am still getting 401 error. \nAnyone knows what to try next? At least to get rid of the 401. \nThanks.. ",
    "paralin": "Fixed by fixing permissions of dir and not using root.\n. Also make sure your package.json is in the same directory as .git\n. ",
    "yamikuronue": "So... is this project abandoned or what? There's all this information on the front page about how it's got a plugin architecture, but all the promoted plugins are listed as \"please implement\", and I can't get help with installing my own basic plugins?. Probably? But how am I supposed to test it before I publish?\nAlso I probably did scoped packages wrong, I've learned more about them in the three months since my last comment. But I don't want to put anything in npm unless I know it works. And I can't test that it works if, as you say, I can't load it until it's in npm. . ",
    "Almenon": "I ran into the exact same issue - arepl-backend has two CI's: travis and appveyor (travis for python and appveyor for node)\nFor now I'll just try enabling it on travis.. ",
    "zakhenry": "@kreck the issue arises from the fact that jenkins checks out the head commit directly and the tree is in a \"detatched HEAD state\". You can resolve this in jenkins by just running git checkout master or whatever your branch is. Ideally semantic-release would be able to handle detached HEADs however, so this should not resolve this issue, just add clarity\n. ",
    "kreck": "@zakhenry you saved my Friday evening. It is working. Thank you very much!\n. @janppires Sure, first you add the relevant tokens (GiHub/npm) to the credentials keychain in Jenkins. Then you simply set up a build task (in my case triggered via GitHub Webhooks). Make sure node is available in your PATH and simply run a \"Shell\" build script:\nsh\ngit checkout master\nset +x\nexport NPM_TOKEN=${NPM_TOKEN}\nexport GH_TOKEN=${GH_TOKEN}\nset -x\nnpm prune\nnpm install\nnpm run cover\nnpm run check-coverage\nnpm run build\nnpm run semantic-release\nHope that helps..... ",
    "zot24": "Hi guys! what about the verifyConditions? I'm getting the following:\nsemantic-release WARN pre semantic-release didn't run on Travis CI and therefore a new version won't be published.\nsemantic-release WARN pre You can customize this behavior using \"verifyConditions\" plugins: git.io/sr-plugins\nAnd can make it work on Jenkins I have found this https://github.com/krux/condition-jenkins but not sure if it will be needed/required\nThanks,. We kind of fix part of the problem using the project mention before and adding this to our package.json\n\"release\": {\n   \"branch\": \"master\",\n   \"verifyConditions\": {\n     \"path\": \"./node_modules/@krux/condition-jenkins\"\n   }\n }\nAnd our Jenkins command that will run the semantic-release pre looks like:\nsh \"docker run -v \\$(pwd):/data -w /data -e GIT_BRANCH=\\\"origin/master\\\" -e JENKINS_URL=${env.JENKINS_URL} -e GH_TOKEN=$GH_TOKEN -e CI=true -e NPM_TOKEN=\\\"$NPM_TOKEN\\\" zot24/semantic-release semantic-release pre\"\nHowever still getting an error this time a different one\nsemantic-release ERR! pre The header content contains invalid characters TypeError: The header content contains invalid characters\nAny ideas?\nThanks,. It's have to be something related with how Jenkisfile process the commands, some kind of encoding error I think because the command it self works perfectly if you run it manually from the shell either local or from the Jenkins server host. Problem solve it behaved different because the way I was getting the token on the Jenkinsfile was different that when I execute the command from the host, check for more info https://github.com/npm/npm-registry-client/issues/159 ta\nIf it does helps someone this is how our Jenkinsfile looks like https://github.com/moltin/js-sdk/blob/master/Jenkinsfile. Try adding NPM_TOKEN as an env var instead that on your package.json as it's npm what will use it no semantic-release\nI just hope those are not your real tokens \ud83d\udc47 \n\"githubToken\": \"32558a13585b92da451b3d55f1623f36513586ea\",\n\"NPM_TOKEN\": \"063bdee0-66dc-4a7f-afbe-9e957d61c223\". I have fix my problem the resolution in here https://github.com/npm/npm-registry-client/issues/159 ta\n. ",
    "umireon": "According to API doc, target_commitish is described to be usually master (or the default branch) and that is almost always true.\nThis can be confirmed by this command: curl -fsSL https://api.github.com/repos/github/hub/releases | grep '\"target_commitish\"'\n$ curl -u umireon:$GH_TOKEN -fsSL https://api.github.com/repos/github/hub/releases | grep '\"target_commitish\"'\n    \"target_commitish\": \"master\",\n    \"target_commitish\": \"master\",\n    \"target_commitish\": \"master\",\n    \"target_commitish\": \"master\",\n    \"target_commitish\": \"master\",\n    \"target_commitish\": \"master\",\n    \"target_commitish\": \"master\",\n    \"target_commitish\": \"master\",\n    \"target_commitish\": \"master\",\n    \"target_commitish\": \"master\",\n    \"target_commitish\": \"2.2-stable\",\n    \"target_commitish\": \"master\",\n    \"target_commitish\": \"master\",\n    \"target_commitish\": \"2.2-stable\",\n    \"target_commitish\": \"master\",\n    \"target_commitish\": \"master\",\n    \"target_commitish\": \"master\",\n    \"target_commitish\": \"master\",\n    \"target_commitish\": \"master\",\n    \"target_commitish\": \"master\",\n    \"target_commitish\": \"master\",\n    \"target_commitish\": \"master\",\n    \"target_commitish\": \"master\",\n    \"target_commitish\": \"master\",\n    \"target_commitish\": \"master\",\nBut semantic-releaseed repos has weired target_commitishes...\n$ curl -fsSL https://api.github.com/repos/semantic-release/semantic-release/releases | grep '\"target_commitish\"'\n    \"target_commitish\": \"73138f8a8f15b207d6553864c17917433be38800\",\n    \"target_commitish\": \"f239f2f402551bb210c3ae0475e0349906829b46\",\n    \"target_commitish\": \"2be6e5d34a4c89a74a8a0bd40a6706d3705be448\",\n    \"target_commitish\": \"a5cb9ea7f7a66657f95f0d913126e812adb6d9f8\",\n    \"target_commitish\": \"0a89265ae76b5672465f04caae0676104bd28894\",\n    \"target_commitish\": \"d9b95940dbfbbb321810cbcb35886d5eff330acd\",\n    \"target_commitish\": \"4b64afefe4321bdf4c70cdfe81e00cbee2d2efd8\",\n    \"target_commitish\": \"adc65e4950f6218345e73be9c959a209ead8d871\",\n    \"target_commitish\": \"64926934894fb8ae69892638df522d5e31deed0d\",\n    \"target_commitish\": \"e19b1952d174e3c7b41a87025686f2508551a126\",\n    \"target_commitish\": \"676d2d6210f2bfc17a376c7eeb59bbf5dd02dd98\",\n    \"target_commitish\": \"df5f8337e89de14bb1025847245ffe4a07e6b152\",\n    \"target_commitish\": \"527c45fbf5c7a47ef30cd689208843b892f54033\",\n    \"target_commitish\": \"a7270bb84c13e803ca851e9426c2cef5071a583b\",\n    \"target_commitish\": \"ef1623210ba2b5b97edb4d76c497513ef729b3e9\",\n    \"target_commitish\": \"5711e95c790a269a97d705b8b89d6292d0e093c0\",\n    \"target_commitish\": \"03534e51bcc57c6a3379e885d1541efa777c965d\",\n    \"target_commitish\": \"451378117df6d7015f5db1dacc99d9ade4ebc123\",\n    \"target_commitish\": \"85b35aaed363a616d9144cae2c0e88ed9590511d\",\n    \"target_commitish\": \"23221cc044c1498ee63f5b05d17b7ff527358b03\",\n    \"target_commitish\": \"a16c36ed4d9fb1a10b84069f9239e63bb4605d7a\",\n    \"target_commitish\": \"a2d6db2ce5511f99ffa7efed1cf3f8427464693a\",\n    \"target_commitish\": \"b47311d5653065a67a59ea3869d5e93ed5ccc5b7\",\n    \"target_commitish\": \"7ceac766892b6f4c311582efcdd3a2c86ae3dad2\",\n    \"target_commitish\": \"55364ded401dbabbb867fde0cf2be01b4d2f7790\",\n    \"target_commitish\": \"fb1aa80f263881c29ea84d5896b8a66ee95b390a\",\n    \"target_commitish\": \"05490fe2290144fbc60ae3171184e4e05719898a\",\n    \"target_commitish\": \"caribou\",\n    \"target_commitish\": \"2690d30aa07958ed7e109cb6536046b3af391f68\",\n    \"target_commitish\": \"1db531b51180a3d032024bbb5a0cf4e1bed1147e\",. Broken target_commitishes can be fixed by this script.\nIt's working since my repo was fixed by this.\nENDPOINT=https://api.github.com/repos/username/reponame/releases\nGH_AUTH=\"username:password_or_token\"\nfor id in $(curl -u \"$GH_AUTH\" -fsSL \"$ENDPOINT\" | jq '.[].id')\ndo\n  curl -v \\\n    -u \"$GH_AUTH\" \\\n    -X  PATCH \\\n    -d '{\"target_commitish\": \"master\"}' \\\n    \"$ENDPOINT/$id\"\ndone. Thank you, @boennemann !\nI have changed the PR to use Git Refs API to make a lightweight tag (the same as the current implementation does).\nNote that the suggested API is not needed to call for creating a lighweight tag.. Thank you for picking this up, @gr2m \nI have rebased the branch and confirmed my tests passed on Travis CI.\nIn addition, I have created a sandbox repository for testing.\nhttps://github.com/umireon/semantic-release-sandbox-target-committish\nBest regards,\nKaito. I'm sorry but it's my mistake.\nhttps://github.com/semantic-release/semantic-release/pull/335/files#diff-012dd2b56a863a41776f3a519e6aaa56R30\nref: 'refs/heads/v' + pkg.version,\nshould be\nref: 'refs/tags/v' + pkg.version,\n. Will be fixed by #416 . This PR added the usage of options.branch in src/post.js, and its default value is master.\nhttps://github.com/semantic-release/semantic-release#options\nThis change just provides the default value of options.branch for the test code.. ",
    "jcjones1515": "I'm hitting something similar @PatrickHeneise, did you have any luck?. ",
    "ianrossi": "I'm closing this, since I was able to get past the 401 error by just just activating the NPM Bearer Token realm in Nexus.. ",
    "jonmajorc": "Hey @ianrossi , I am running into some trouble setting up my deployment pipeline too. It seems like I am relatively close to your error. I do have n initial question: what do you do with the GH_TOKEN and NPM_TOKEN generated from the cli setup? Thanks.. ",
    "zcei": "Sorry, literally had the item in my activity feed begging for my attention.\n(I thought \"Update Branch\" does the job, let me get rid of this merge commit real quick)\nEdit: there we go \u2b07\ufe0f . ",
    "greenkeeper[bot]": "Version 4.0.1 just got published.\nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits .\n\n2492118 doc: update changelog for 4.0.1\n3f70720 4.0.1\nfb9b1ce doc: fix syntax fencing\n\nSee the full diff.\n\n. ## Version 9.0.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits .\n\nc82c752 v9.0.1\ne354064 Keep my home dir out of test fixtures\n\nSee the full diff.\n\n. ## Version 9.0.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits .\n\n05b9d9c v9.0.2\nda59c8e refactoring and code organization\n642fada Don't end before implicit bailout from bufferend child bailout\n\nSee the full diff.\n\n. ## Version 9.0.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits .\n\n1a603cd v9.0.3\ncddf1db Avoid slashes in output tests\n5c820a8 Make tests pass on 0.10\n\nSee the full diff.\n\n. ## Version 10.0.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits .\n\n2003990 v10.0.2\neb08505 Remove line breaks from subtest names\n\nSee the full diff.\n\n. ## Version 2.12.0 just got published. \nYour tests are passing again with this version. Explicitly upgrade to this version \ud83d\ude80 \n\nRelease Notes\nBranch coverage support\nAdds branch coverage data to Coveralls API post.\n\n\nCommits\nThe new version differs by 2 commits .\n\nd571dac merge, version bump\n1575050 branching WIP\n\nSee the full diff.\n\n. ## Version 9.1.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits .\n\n46b8648 update apidoc.js\nceaf8c5 bump to 9.1.0\n8413595 add user blocking preview api\n\nSee the full diff.\n\n. ## Version 9.2.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 14 commits .\n\na124756 update changelog\n6fbd0ce add netrc example\n169e7df fix get release asset example\nd43425e fix getNextPage example\n997306a fix getStarred example\n25da4e0 Merge pull request #521 from jeffwilcox/direct-collaborators\n6297160 Merge pull request #514 from PabloZaiden/master\na3e794e Merge pull request #517 from williamkapke/accept-pagination\n33031c3 Merge pull request #516 from williamkapke/org-blocks\ned3500c Collaborators preview API \"direct\" affiliation\n9e4bb5a set accept header on pagination\nbfb6bf5 9.2.0\nc38fe38 add org blocking preview api\nee1c003 Support for operations with empty parameters\n\nSee the full diff.\n\n. ## Version 9.3.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 53 commits.\n\n90d3a14 bump to 9.3.0\nbeb8f46 update params for edit repo endpoint\nf03b4c0 rearrange some repo endpoints\nb566dd9 update params for create repo\nd6d4173 add Review Requests preview stuff for team reviewers\n8a4a61b update params for create pull request review endpoint\n5e07f91 update params for update pull request endpoint\n2f6f096 use global state param for pullrequests getAll\n003f223 add state param to some project endpoints\nc267104 added superfluous endpoints to preview section\nb4e08c8 add two missing endpoints for project preview accept header\n8eb1e8b change endpoint order under user blocking preview\nc0dd41f match ordering of acceptTree in routes with README\n7cbd06a Merge pull request #561 from LukeJosten/master\n420cced add filter param to outside collaborators endpoint\n\nThere are 53 commits in total.\nSee the full diff\n\n. ## Version 9.3.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 6 commits.\n\n71cc8ae bump to 9.3.1\n8899461 Add example that tests instantiating multiple instances.\nf1da560 Merge pull request #574 from mikedeboer/revert-545-master\nd27c0c7 Revert \"Require routes.json\"\nb4eb3cc add missing config options to README\n6dc5728 include missing contributions in CHANGELOG\n\nSee the full diff\n\n. ## Version 10.0.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 20 commits.\n\n9f81c89 Update apidoc.\n9b04215 bump to 10.0.0\ne4d3090 fix removeAssigneesFromIssue endpoint\nae1c184 fix params for addLabelsToIssue example\n464cf69 Add get-gpg-keys-for-user endpoint.\nf681098 Add endpoint to toggle user primary email visibility.\n647c076 Add endpoint to get user's public emails.\n4ff37a9 Make get-combined-status-for-ref clearer.\n7811d2c Some small edits.\n65602aa Specify deploy key in library method.\n6fb6f36 Add author param to file-related endpoints.\nb4a20ad Allow to do commit signature verification.\n4be678d Merge pull request #577 from dominique-mueller/bugfix/missing-typescript-interface-generics\ne4eb240 Update typings generator\n965c1cd fix(types): Fix missing TypeScript interface generics\n\nThere are 20 commits in total.\nSee the full diff\n\n. ## Version 10.1.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 11 commits.\n\nfa03fa5 add 10.1.0 to apidoc\n4ddbd33 bump to 10.1.0\n356c20a add some user related endpoints\n971b68a add missing options to type/flow templates\n4ad6d2c add marketplace endpoints\n0a25728 Merge branch 'pull-request-568'\n902e7a6 some updates to match latest doc\n37c954d Add support for deprecation warnings\n1d532e7 Keep old integration methods\nb0db181 node lib/generate.js\n65b7f18 Rename 'integrations' to 'apps'\n\nSee the full diff\n\n. ## Version 11.0.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 8 commits.\n\nf06dd9f bump to 11.0.0\n79619e8 Merge branch 'master' of https://github.com/mikedeboer/node-github\ne859767 Protected branches API now official.\n1eefe5f Merge pull request #584 from mikedeboer/remove-npmignore\n61c6278 fixup! chore(package): whitelist files for publish\nd41d278 chore(package): whitelist files for publish\n50720c8 chore: remove obsolete .npmignore\n586a4df add Nested Teams API changes\n\nSee the full diff\n\n. ## Version 10.0.0-beta.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 10 commits .\n\n2a8aeba 10.0.0-beta.0\nfa5fcf7 eslint-config-standard@8.0.0-beta.0\na15d8ea changelog\n759d2d1 eslint-plugin-promise@3.5\n21c4e41 eslint-plugin-react@6.10\nda0fb51 eslint-plugin-standard@2.1\n21e6231 v10: depend on eslint-plugin-node@4.1\n04baf9e v10: depend on eslint-plugin-import@2.2\nd14e646 eslint@3.16\na5e3e85 changelog\n\nSee the full diff.\n\n. ## Version 10.0.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 12 commits .\n\nd37028e authors\n6b48c9f 10.0.1\n332e0ff changelog\n9f63f6b eslint-plugin-standard@~3.0.1\n1b08ba2 eslint-config-standard-jsx@4.0.1\n9cb1097 eslint-config-standard@10.2.0\n4c888b0 Merge pull request #839 from feross/watson-patch-1\n8fd2b37 Update README.md\n59e8048 Add the word IRC to README.md\nf107095 changelog\n9223ed2 changelog\nce20f3c changelog\n\nSee the full diff.\n\n. ## Version 10.0.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 19 commits .\n\n8b43d45 authors\nb002f41 10.0.2\nf1f772a changelog\n9994f1d eslint-config-standard@10.2.1\n8aa90ea Merge pull request #858 from feross/feross/flow\n1e66bdf Merge pull request #851 from feross/readme-vim-ale\ne0bdcdc Update README.md\n3c64877 readme: Add more specific Flow instructions\n5126e74 Merge pull request #855 from pablopunk/patch-1\n99b9e76 Fix list indentation\n1366340 Merge pull request #854 from wayou/improve-translation\nf737f22 \ud83d\udcd6 Spanish docs fixes\n4b9ad60 improve readme translation for simplified chinese, fix typos\nc7500e2 Readme: add mentions of neomake and syntastic\nd60d2de Update README.md\n\nThere are 19 commits in total. See the full diff.\n\n. ## Version 10.0.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv10.0.3\n\nInternal changes (incremented dependency versions)\n\n\n\nCommits\nThe new version differs by 99 commits.\n\n91e80a1 10.0.3\n82a0d5c changelog\nd22676e Merge pull request #963 from daper/patch-1\ncfb84fe Remove tilde to lock down eslint-config-standard-jsx version\n4a6e0d0 Update dependecy of eslint-config-standard-jsx\nac9e09e Merge pull request #961 from igorsantos07/patch-1\n873bc9b Adding valid example for no-unsafe-negation\nf00b169 more feross/standard -> standard/standard\n9770303 Merge pull request #954 from standard/security\n8cc2285 Add a security policy\n2fa8b0f change more feross/standard -> standard/standard\ne79a692 Merge branch 'devjin0617-translation-kr'\n34490f7 Merge branch 'translation-kr' of https://github.com/devjin0617/standard into devjin0617-translation-kr\n6d59566 Merge pull request #953 from standard/translations\n3895bc6 move english readme/rules to docs/ folder\n\nThere are 99 commits in total.\nSee the full diff\n\n. ## Version 9.0.14 just got published. \nYour tests are still failing with this version. Compare the changes \ud83d\udea8 \n\nCommits\nThe new version differs by 14 commits.\n\n8da9ee0 Fixes for Node 8\n612388e Merge pull request #948 from martinkuba/master\na2f170f www.amazon.com does not return any data\n35c76e3 Merge pull request #929 from martinkuba/node8\n39c7e32 Merge pull request #942 from michaelnisi/browserify\n0c0aaca Skip browserify test because zombie fails @7.10\naac5c34 wrap http.get on Node 8 only\n5db4fa0 workaround for socket hang up\nf984668 fix recorder when calling res.end(data)\nf6369d0 use req.setHeader()\n119fa65 override http.get\nc2d605a added Node 8 to Travis\n17d7c25 Merge pull request #667 from ksmith97/master\nbcdf886 Updated debug namespace to match file.\n\nSee the full diff\n\n. ## Version 2.3.8 just got published. \nYour tests are passing again with this version. Explicitly upgrade to this version \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits .\n\n6ba4949 2.3.8\nebc9544 Package .json files toooo!\n\nSee the full diff.\n\n. ## Version 2.4.0 just got published. \nYour tests are still failing with this version. Compare the changes \ud83d\udea8 \n. ## Version 11.0.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits.\n\ne9fad9f docs:  add note about tap-nyc to README (#614)\nf86b0b1 chore(release): 11.0.3\n923b062 fix: upgrade to spawn-wrap version that works with babel-register (#617)\nb1eb4d6 fix: update help link to list of reporters (#601)\n\nSee the full diff\n\n. ## Version 11.1.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 5 commits.\n\na3f033f chore(release): 11.1.0\na076951 chore: upgrade to latest version of istanbul-lib-instrument\n8768afe feat: upgrade to version of spawn-wrap that supports .EXE (#626)\n2d92501 chore: attempt to fix appveyor (#623)\nbbadc1f feat: add support for per file coverage checking (#591)\n\nSee the full diff\n\n. ## Version 11.2.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 7 commits.\n\nb2ff72d chore(release): 11.2.0\n97b962e chore: explicit update of istanbul-lib-instrument (#662)\n0dcceda feat: allow cwd to be configured see #620\n0fc6d8f chore: add support for --cwd (#542) (#620)\n658dba4 fix: remove excluded files from coverage before writing (#649)\ndd40dc5 feat: add possibility to filter coverage-maps (#637)\nfb3ab92 docs: add link to community slack (#639)\n\nSee the full diff\n\n. ## Version 11.2.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n87281f9 chore(release): 11.2.1\n3bd1527 fix: create temp directory when --no-clean flag is set #663 (#664)\na10d478 fix: apply exclude logic before remapping coverage (#667)\n\nSee the full diff\n\n. After pinning to 10.3.3 your tests are still failing. The reported issue might not affect your project. These imprecisions are caused by inconsistent test results.. ## Version 10.4.0 just got published. \nYour tests are still failing with this version. Compare the changes \ud83d\udea8 \n\nCommits\nThe new version differs by 7 commits.\n\n9b78624 v10.4.0\nc2c72f5 update tap-mocha-reporter to 3.0.5\n1892366 t.type(fn, Function) should pass\n8aa0d52 Add t.rejects() assertion\n37ec7a4 update deps\n8843d29 remove debug test.  times out, removed in node 8\nd635535 update travis\n\nSee the full diff\n\n. ## Version 10.5.0 just got published. \nYour tests are still failing with this version. Compare the changes \ud83d\udea8 \n\nCommits\nThe new version differs by 2 commits.\n\n2de6ad9 v10.5.0\n5cad167 t.same, t.match: Add Map/Set support\n\nSee the full diff\n\n. ## Version 10.5.1 just got published. \nYour tests are passing again with this version. Explicitly upgrade to this version \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\n37bbd48 v10.5.1\nb99df68 update tsame so NaN matches NaN\n\nSee the full diff\n\n. ## Version 10.5.2 just got published. \nYour tests are still failing with this version. Compare the changes \ud83d\udea8 \n\nCommits\nThe new version differs by 5 commits.\n\ne3c17e4 v10.5.2\n1330d90 update deps\nb898023 update readable-stream\n37bbd48 v10.5.1\nb99df68 update tsame so NaN matches NaN\n\nSee the full diff\n\n. ## Version 10.6.0 just got published. \nYour tests are still failing with this version. Compare the changes \ud83d\udea8 \n\nCommits\nThe new version differs by 7 commits.\n\n090a8ee v10.6.0\nf60b003 fix rcfile test for grep and grepInvert fields\n0e36c2a doc TAP_GREP and TAP_GREP_INVERT environs in cli usage\n780f14a inherit grepInvert as well as greps\nb4a6c8f update tests for grepInvert fix\n3c62917 grepInvert defaults to false, not []\n7e94cfc add --grep option\n\nSee the full diff\n\n. ## Version 10.7.0 just got published. \nYour tests are still failing with this version. Compare the changes \ud83d\udea8 \n\nCommits\nThe new version differs by 10 commits.\n\nc417424 v10.7.0\n802cf70 update 'only' output test\ndc67c58 add t.only()\n0f474d9 filter out --only and --grep skip messages\nefd024d consolidate --only tests\nf60b060 Further refining --only\n0d0ac05 runner test for --only\n7550694 update usage, add -O alias for --only\n8438249 add test for --only flag\n7e42a08 WIP TAP_ONLY, --only, {only: true} and warning to stderr if {only: true} but tap\u2019s only option is not true\n\nSee the full diff\n\n. ## Version 10.7.1 just got published. \nYour tests are passing again with this version. Explicitly upgrade to this version \ud83d\ude80 \n\nCommits\nThe new version differs by 5 commits.\n\n716414a v10.7.1\n4a3945f update all the things\nfa9410e update to latest release of nyc\nd385f01 update nyc to 11.0.3\n087912f remove output tests for bail cases that don't bail\n\nSee the full diff\n\n. ## Version 10.7.2 just got published. \nYour tests are passing again with this version. Explicitly upgrade to this version \ud83d\ude80 \n\nCommits\nThe new version differs by 7 commits.\n\n9e51611 v10.7.2\n52d5983 t.rejects: handle getting expected error but not options\n716414a v10.7.1\n4a3945f update all the things\nfa9410e update to latest release of nyc\nd385f01 update nyc to 11.0.3\n087912f remove output tests for bail cases that don't bail\n\nSee the full diff\n\n. After pinning to 4.1.0 your tests are passing again. Downgrade this dependency \ud83d\udccc.. ## Version 4.1.2 just got published. \nYour tests are still failing with this version. Compare the changes \ud83d\udea8 \n\nCommits\nThe new version differs by 2 commits.\n\nf7f9516 4.1.2\n938be5b When stringifying stack, keep previously mutable property\n\nSee the full diff\n\n. ## Version 3.0.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv3.0.1\n<a name\"3.0.1\">\n3.0.1 (2017-08-13)\nBug Fixes\n\nadapt for new conventional-changelog (ff28bb5e)\n\n\n\nCommits\nThe new version differs by 5 commits.\n\na80b68b chore(package): scenarios,specs -> integration,unit\nff28bb5 fix: adapt for new conventional-changelog\n2c52076 test: adapt for new conventional-changelog\n0d2803f chore(package): add Gregor to authors\nf4cf92f docs(README): usage\n\nSee the full diff\n\n. After pinning to 3.0.4 your tests are passing again. Downgrade this dependency \ud83d\udccc.. ## Version 3.0.6 just got published. \nYour tests are passing again with this version. Explicitly upgrade to this version \ud83d\ude80 \n\nRelease Notes\nv3.0.6\n\n3.0.6 (2017-10-01)\nBug Fixes\n\nLoad preset/config if semantic-release run as global install (34d964b)\n\n\n\nCommits\nThe new version differs by 1 commits.\n\n34d964b fix: Load preset/config if semantic-release run as global install\n\nSee the full diff\n\n. After pinning to 1.7.4 your tests are passing again. Downgrade this dependency \ud83d\udccc.. After pinning to 6.1.1 your tests are passing again. Downgrade this dependency \ud83d\udccc.. ## Version 6.2.1 just got published. \nYour tests are passing again with this version. Explicitly upgrade to this version \ud83d\ude80 \n\nRelease Notes\nv6.2.1\n\n6.2.1 (2017-11-21)\nBug Fixes\n\nInclude lib in release (29e574c)\n\n\n\nCommits\nThe new version differs by 1 commits.\n\n29e574c fix: Include lib in release\n\nSee the full diff\n\n. After pinning to 2.12.1 your tests are passing again. Downgrade this dependency \ud83d\udccc.. After pinning to 2.1.0 your tests are passing again. Downgrade this dependency \ud83d\udccc.. After pinning to 4.0.2 your tests are passing again. Downgrade this dependency \ud83d\udccc.. After pinning to 5.1.1 your tests are passing again. Downgrade this dependency \ud83d\udccc.. After pinning to 7.1.0 your tests are passing again. Downgrade this dependency \ud83d\udccc.. After pinning to 1.9.1 your tests are passing again. Downgrade this dependency \ud83d\udccc.. After pinning to 7.1.1 your tests are still failing. The reported issue might not affect your project. These imprecisions are caused by inconsistent test results.. After pinning to 2.2.1 your tests are passing again. Downgrade this dependency \ud83d\udccc.. ## Version 2.2.3 just got published. \nYour tests are passing again with this version. Explicitly upgrade to this version \ud83d\ude80 \n\nRelease Notes\nv2.2.3\n\n2.2.3 (2017-12-17)\nBug Fixes\n\nhandle custom url without prefix (2bad805)\n\n\n\nCommits\nThe new version differs by 1 commits.\n\n2bad805 fix: handle custom url without prefix\n\nSee the full diff\n\n. After pinning to 3.0.0 your tests are still failing. The reported issue might not affect your project. These imprecisions are caused by inconsistent test results.. ## Version 1.10.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 1.10.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n. After pinning to 5.4.1 your tests are still failing. The reported issue might not affect your project. These imprecisions are caused by inconsistent test results.. After pinning to 6.0.3 your tests are passing again. Downgrade this dependency \ud83d\udccc.. After pinning to 4.0.0 your tests are passing again. Downgrade this dependency \ud83d\udccc.. ## Version 4.0.2 just got published. \nYour tests are passing again with this version. Explicitly upgrade to this version \ud83d\ude80 \n\nCommits\nThe new version differs by 1 commits.\n\n27d7828 fix: handle undefined GitHub prefix\n\nSee the full diff\n\n. ## Version 0.20.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\nbf29ed8 0.20.1\n71036d1 Disable parsing of prettier CLI option (#298)\n\nSee the full diff\n\n. ## Version 0.20.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\n3094538 0.20.2\n5a55cee Do not add indent rule when prettier option is true (#300)\n\nSee the full diff\n\n. After pinning to 0.3.14 your tests are still failing. The reported issue might not affect your project. These imprecisions are caused by inconsistent test results.. After pinning to 8.2.0 your tests are passing again. Downgrade this dependency \ud83d\udccc.. ## Version 8.3.1 just got published. \nYour tests are passing again with this version. Explicitly upgrade to this version \ud83d\ude80 \n\nRelease Notes\n8.3.1\nFix #65. Check if the parsed resource is not null.\n\n\nCommits\nThe new version differs by 3 commits.\n\nb09336e Updated docs\nd21bab3 :arrow_up: 8.3.1 :tada:\nf10ded0 Fix #65. Check if the parsed resource is not null.\n\nSee the full diff\n\n. After pinning to 9.3.1 your tests are passing again. Downgrade this dependency \ud83d\udccc.. ## Version 1.0.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\n6942796 1.0.1\n86f4209 Add a check to ensure the encoding argument is a string (#17)\n\nSee the full diff\n\n. After pinning to 3.3.2 your tests are passing again. Downgrade this dependency \ud83d\udccc.. After pinning to 2.6.1 your tests are passing again. Downgrade this dependency \ud83d\udccc.. ## Version 2.7.1 just got published. \nYour tests are passing again with this version. Explicitly upgrade to this version \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\nab35a90 chore(release): 2.7.1\n5bc580d fix(index): Guard against non-string types\nc931482 fix(parse): Crash on strings that parse to having no host\n\nSee the full diff\n\n. After pinning to 3.3.4 your tests are passing again. Downgrade this dependency \ud83d\udccc.. ## Version 5.0.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv5.0.1\n5.0.1 (2018-08-04)\nBug Fixes\n\ndo not use execa.stdout.pipe as it closes the stream (544d4c7)\n\n\n\nCommits\nThe new version differs by 1 commits.\n\n544d4c7 fix: do not use execa.stdout.pipe as it closes the stream\n\nSee the full diff\n\n. After pinning to 2.1.1 your tests are still failing. The reported issue might not affect your project. These imprecisions are caused by inconsistent test results.. After pinning to 2.1.2 your tests are passing again. Downgrade this dependency \ud83d\udccc.. After pinning to 4.0.0 your tests are passing again. Downgrade this dependency \ud83d\udccc.. - The devDependency commitizen was updated from 2.10.1 to 3.0.1.\nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes for v3.0.1\n<a name\"3.0.1\">\n3.0.1 (2018-10-01)\nBug Fixes\n\ndeps: update dependency inquirer to v6 (#541) (ef760efd)\n\n\n\nCommits\nThe new version differs by 1 commits.\n\nef760ef fix(deps): update dependency inquirer to v6 (#541)\n\nSee the full diff\n\n. After pinning to 5.1.0 your tests are passing again. Downgrade this dependency \ud83d\udccc.. After pinning to 5.2.0 your tests are still failing. The reported issue might not affect your project. These imprecisions are caused by inconsistent test results.. After pinning to 9.3.0 your tests are still failing. The reported issue might not affect your project. These imprecisions are caused by inconsistent test results.. After pinning to 5.3.0 your tests are passing again. Downgrade this dependency \ud83d\udccc.. After pinning to 5.0.5 your tests are still failing. The reported issue might not affect your project. These imprecisions are caused by inconsistent test results.. After pinning to 7.0.0 your tests are still failing. The reported issue might not affect your project. These imprecisions are caused by inconsistent test results.. After pinning to 5.0.6 your tests are passing again. Downgrade this dependency \ud83d\udccc.. - The dependency @semantic-release/npm was updated from 5.1.0 to 5.1.1.\nYour tests are passing again with this update. Explicitly upgrade to this version \ud83d\ude80\n\nRelease Notes for v5.1.1\n5.1.1 (2018-11-09)\nBug Fixes\n\nalways attempt to set the legacy token env var (2432eb0)\n\n\n\nCommits\nThe new version differs by 1 commits.\n\n2432eb0 fix: always attempt to set the legacy token env var\n\nSee the full diff\n\n. After pinning to 1.1.0 your tests are passing again. Downgrade this dependency \ud83d\udccc.. - The dependency yargs was updated from 12.0.5 to 13.2.0.\nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n48249a2 chore(release): 13.2.0\n51876e6 chore: update deps (#1296)\n16c5d25 feat: zsh auto completion (#1292)\n\nSee the full diff\n\n. After pinning to 7.2.6 your tests are passing again. Downgrade this dependency \ud83d\udccc.. After pinning to 1.2.1 your tests are passing again. Downgrade this dependency \ud83d\udccc.. - The devDependency ava was updated from 1.3.0 to 1.3.1.\nYour tests are passing again with this update. Explicitly upgrade to this version \ud83d\ude80\n\nRelease Notes for 1.3.1\nBug fixes\n\nWe've fixed a rather embarrasing bug with t.throws() and t.throwsAsync(). If you'd set a code expectation to a number we never actually checked that the thrown error had such a code! Thanks to @qlonik for both spotting and fixing this. 82daa5e\n1.2.0 contained a regression which meant that if you faked clearTimeout(), you'd break AVA. That's now been fixed. 40f331c\nSnapshot files are now recognized as source files, so if you're using watch mode and you delete one, AVA won't rerun all your test files. d066f6f\n\nNew features\nYou can now use require() in ava.config.js files to load non-ES modules. 334e15b\nAll changes\nv1.2.1...v1.3.1\nThanks\nThank you @itaisteinherz, @jdalton, @kagawagao, @KompKK, @SleeplessByte, @Chrisyee22 and @qlonik for helping us with this release. We couldn't have done this without you!\nGet involved\nWe welcome new contributors. AVA is a friendly place to get started in open source. We have a great article on getting started contributing and a comprehensive contributing guide.\n\n\nCommits\nThe new version differs by 2 commits.\n\n960f4cd 1.3.1\n9beb600 Check whether the code expectation was given\n\nSee the full diff\n\n. ",
    "morten-kirstein": "I'm getting the same error. So I'm interested in this as well :). ",
    "codekiln": "The docs could be a lot clearer on this point. I'm new to semantic-release and from everything I've read I'm getting the sense that people who are using it are manually merging pull requests locally into master on their own computer and then using a push to master to do the release via the cli. \nThere must be something I'm missing, but I can't find contrary evidence to that so far. \n\nhttps://github.com/semantic-release/semantic-release/issues/207\nhttps://github.com/semantic-release/semantic-release/issues/390. \n",
    "Khaledgarbaya": "I am having the same issue. I did publish the package manually but still failing in the next pushes . Yeah, that was the issue thanks a lot. But what if I want to release a specific version that is not the leader like currently I am testing using node 6 and 7 and I want to release only in v6 because it is.. ",
    "jy95": "Still the case .. Any news about this ?\nI am using semantic-release 7.0.2 and Travis CI.\nmy .travis.yml\nyml\nlanguage: node_js\ncache:\n  directories:\n    - node_modules\nnotifications:\n  slack:\n      on_success: change\n      on_failure: always\nnode_js:\n  - '7'\n  - '6'\n  - '4'\nbefore_script:\n  - npm prune\nafter_success:\n  - npm run coverage\n  - cat coverage/lcov.info | node_modules/.bin/coveralls\n  - npm run semantic-release\nbranches:\n  except:\n    - /^v\\d+\\.\\d+\\.\\d+$/. @calebeby Check my .travis.yml on my repository https://github.com/jy95/torrent-files-library\nMaybe do a npm i -g npm@latest ?. thanks ... it seems the changelog generator doesn't handle this extended angular format.\nCan someone modify the original module that handles this : https://github.com/conventional-changelog/conventional-changelog/tree/c146f2a67ac8127423fe24cc0cbe304cfa637fe3/packages/conventional-changelog-angular to handle this ? . Great thank for your help, it works XD https://github.com/jy95/torrent-files-library/releases/tag/v1.0.1.. Any ideas how to generate changelog for 1.0.0 ?. I was talking about regenerate locally, doesn't want to mess up semantic-release with this temp release. thanks for your big help \ud83d\udc4d . To clarify I just want my first build to trigger the release like the second build but the preset cannot handle the little change added by sgc (refered in the readme)\nRecreate a preset that looks like 99% of the conventional-changelog-eslint package looks like a quick fix but not the best solution (think about updates that fix parts of the code I didn't touch ) ....\nI think it is strange that release.config.js is never used anywhere ^^ (but I saw the shareable.json in the tests )\n. Thanks for the detailed answer.\nI think It could be useful to have a example with release.config.js since it is new XD\nI would like to test it  (using it in local with debug) but I didn't know how to use it ^^\nFrom what I have understand, : \nrelease.config.js\njs\n/* eslint-disable no-useless-escape */\nmodule.exports = {\n  analyzeCommits: {\n    preset: 'eslint',\n    releaseRules: './config/release-rules.js',\n    parserOpts: {\n      headerPattern: /^(?:\\:(\\w*)\\:)?\\s(\\w*)\\:\\s(.*?)(?:\\((.*)\\))?$/,\n      headerCorrespondence: [\n        'emoji',\n        'tag',\n        'message',\n      ],\n    },\n  },\n  generateNotes: {\n    preset: 'eslint',\n    parserOpts: {\n      headerPattern: /^(?:\\:(\\w*)\\:)?\\s(\\w*)\\:\\s(.*?)(?:\\((.*)\\))?$/,\n      headerCorrespondence: [\n        'emoji',\n        'tag',\n        'message',\n      ],\n    },\n  },\n};\nand to set up inside semantic-release, the only option seems to be\n```\nUsage: semantic-release [options]\nOptions:\n  -e, --extends     Comma separated list of shareable config paths or packages name\n```\nSo\nbash\nsemantic-release -e ./config/release.config.js --debug\ngives : \nbash\n  semantic-release:get-version-head Check if the current working directory is a git repository +0ms\n  semantic-release:get-version-head cmd: 'git rev-parse --git-dir' +1ms\n  semantic-release:get-version-head stdout: '.git' +2ms\n  semantic-release:get-version-head stderr: '' +0ms\n  semantic-release:get-version-head code: 0 +0ms\n  semantic-release:config options values: [ 'branch',\n  semantic-release:config   'repositoryUrl',\n  semantic-release:config   'analyzeCommits',\n  semantic-release:config   'generateNotes',\n  semantic-release:config   'debug' ] +0ms\n  semantic-release:config name: undefined +2ms\n  semantic-release:config branch: 'master' +0ms\n  semantic-release:config repositoryUrl: 'git+https://github.com/jy95/torrent-files-library-cli.git' +0ms\n  semantic-release:config analyzeCommits: { preset: 'eslint',\n  semantic-release:config   releaseRules: './config/release-rules.js',\n  semantic-release:config   parserOpts:\n  semantic-release:config    { headerPattern: /^(?:\\:(\\w*)\\:)?\\s(\\w*)\\:\\s(.*?)(?:\\((.*)\\))?$/,\n  semantic-release:config      headerCorrespondence: [ 'emoji', 'tag', 'message' ] } } +0ms\n  semantic-release:config generateNotes: { preset: 'eslint',\n  semantic-release:config   parserOpts:\n  semantic-release:config    { headerPattern: /^(?:\\:(\\w*)\\:)?\\s(\\w*)\\:\\s(.*?)(?:\\((.*)\\))?$/,\n  semantic-release:config      headerCorrespondence: [ 'emoji', 'tag', 'message' ] } } +1ms\n  semantic-release:config verifyConditions: undefined +0ms\n  semantic-release:config verifyRelease: undefined +1ms\n  semantic-release:config publish: undefined +0ms\n[Semantic release]: Load plugin verifyConditions from @semantic-release/npm\n[Semantic release]: Load plugin verifyConditions from @semantic-release/github\n[Semantic release]: Load plugin verifyConditions from @semantic-release/condition-travis\n[Semantic release]: Load plugin getLastRelease from @semantic-release/npm\n[Semantic release]: Load plugin analyzeCommits from @semantic-release/commit-analyzer\n[Semantic release]: Load plugin generateNotes from @semantic-release/release-notes-generator\n[Semantic release]: Load plugin publish from @semantic-release/npm\n[Semantic release]: Load plugin publish from @semantic-release/github\nI will test it on my cli project to see if it works (but It looks like good)\nEDIT: It works  - https://travis-ci.org/jy95/torrent-files-library-cli/jobs/322179281. It would be a good idea to add this example for release.config.js , no ?\nhttps://github.com/semantic-release/semantic-release/issues/575#issuecomment-354110425\n  . ",
    "calebeby": "My node 8 build was not set as build leader: https://travis-ci.org/calebeby/transform-pkg/jobs/276423918. I regenerated the yarn.lock and the problem persists: https://travis-ci.org/calebeby/transform-pkg/jobs/276549917. Hm. None of them are being set as build leader: https://travis-ci.org/calebeby/transform-pkg/builds/276554973. https://travis-ci.org/calebeby/transform-pkg/builds/276596249. https://travis-ci.org/calebeby/transform-pkg/jobs/276604452. I switched to using build stages, and that worked. I think I'll stick to that.. https://travis-ci.org/calebeby/transform-pkg\nThanks, this worked for me! Good work!. Right, the issue that I have is that it is listed in devDependencies and it stops the whole travis install on node <8. https://travis-ci.org/calebeby/transform-pkg/builds/276373481?utm_source=github_status&utm_medium=notification. I didn't have the node 8 test running in that case, but it would've probably passed.. OK, thanks for that feedback. I think I will choose the 2nd option for now. But what if semantic-release didn't require node 8 in package.json (i.e. it would install but not run)?. OK, makes sense.. ",
    "jeongsd": "how can i use https://github.com/semantic-release/semantic-release#can-i-run-this-on-my-own-machine-rather-than-on-a-ci-server ?\npackage.json\njson\n\"scripts\": {\n  \"semantic-release\": \"semantic-release pre&& npm publish && semantic-release post\"\n},\n\"devDependencies\": {\n  \"semantic-release\": \"^6.3.2\"\n},\n\"release\": {\n  \"debug\": false\n}\nresult\nsh\nsemantic-release ERR! pre semantic-release didn\u2019t run on Travis CI and therefore a new version won\u2019t be published.\nsemantic-release ERR! pre You can customize this behavior using \"verifyConditions\" plugins: git.io/sr-plugins\n. ",
    "ankur-birdeye": "Hey team, I am also facing the same issue. Can anyone help here\n. ",
    "matiascarranza": "Hi @balibou, try running npm install after semantic-release-cli setup. ",
    "dwiyatci": "I've got a similar issue on the latest version (9.1.0) on Travis CI here. Not sure where I did it wrong. \n\"scripts\": { \"semantic-release\": \"semantic-release\" }\nAny clue?\n\n. @pvdlg Thanks a lot for the valuable clue! I think that's it!! \ud83c\udf89 \ud83c\udf89 \ud83c\udf89 I simply screwed yarn and fallback using npm instead (by overriding the install option). Here is my .travis.yml looks like in the end:\n```yaml\nlanguage: node_js\ncache:\n  directories:\n  - node_modules\nnode_js:\n- '8'\ninstall:\n- npm isntall\nbefore_script:\n- npm prune\nafter_success:\n- npm run semantic-release\nbranches:\n  except:\n  - /^v\\d+.\\d+.\\d+$/\n```. Ahh. Sorry, my bad. Got it now! \ud83d\udc4c \nFeel free to close this once the latest dist-tag is published.. ",
    "meszaros-lajos-gyorgy": "I have the same for my repo here: https://github.com/meszaros-lajos-gyorgy/workspace\nInterestingly it works fine on my other branches, for example: https://github.com/meszaros-lajos-gyorgy/split-article\nI have tried re-creating the repo 3 times now with no success.\nI have semantic-release-cli and commitizen installed globally and I first run this:\nsemantic-release-cli setup\nwhich produced no errors. Then I run:\ncommitizen init cz-conventional-changelog --save-dev --save-exact\nalso without any issues. But travis is not creating a release, nor any tags.\nHave I missed to setup something?. Is it possible, that a package with the same name (workspace) was once owned by someone else?\nhttps://registry.npmjs.org/workspace\nAccording to the received json, the package has been unpublished, so npm says, I'm good to go with claiming: https://www.npmjs.com/package/workspace\nCan you guys confirm @Sly777's solution at https://stackoverflow.com/a/41700557/1806628 ?\nNote: on my other components I didn't have to do that to make the code work.. I created a new repo and double checked the availability against npm registry. I also didn't enable the repo in travis, I simply let the semantic-release-cli to set it up. My repo contained the same code, that I linked in my previous comment and it worked without any problem, even when using commitizen from the start.. ",
    "marcbachmann": "semantic-release pre --debug=true shows information about the setup and the version\n$ semantic-release pre --debug=true\nsemantic-release WARN pre semantic-release didn\u2019t run on Travis CI and therefore a new version won\u2019t be published.\nsemantic-release WARN pre You can customize this behavior using \"verifyConditions\" plugins: git.io/sr-plugins\nsemantic-release ERR! pre Determined version 12.2.0 as \"latest\". Not publishing in debug mode.\nMaybe we can do a small change to that script so the version gets logged to stdout.\n$  semantic-release pre --debug 2> /dev/null\n{\"type\": \"minor\", \"version\": \"12.2.0\"}\nWarnings should go to stderr and the json to stdout.\nAn additional command which is more explicit would be even better.. Nice update \ud83d\udc4f \nOne change you didn't mention anywhere is how to handle the shrinkwrap.\nPreviously we had to use\nsemantic-release pre && npm shrinkwrap && semantic-release post\nAccording to the changes in this pr that changed to\nnpm shrinkwrap && semantic-release.. > I think npm shrinkwrap is meant to be used in your dev environment , and the shrinkwrap should be committed to your repo. During the release on the CI you probably don't want to re-generate your shrinkwrap file and use the one from your repo.\nIf you write it in development, the shrinkwrap doesn\u2019t contain the actual version. There were also issues in earlier versions where we had to ececute npm prune \u2014production to prepare the modules for the shrinkwrap command. \nGenerating the file in development is more error-prone. It introduces more steps for developers and also doesn\u2019t work in combination with bots like greenkeeper. And then there are the merge conflicts on github. Your suggested workflow might work for libraries but not on projects that have too many prs.. ",
    "thekalinga": "@boennemann What you mentioned assumes that there is no version conflict.\nBut in my case both ng2-cool-plugin & ng4-cool-plugin can have their own version 1.0.0. @boennemann Is this still an issue that's already addressed/should this issue be re-opened?. @boennemann Would you mind answering the query plz. ",
    "Nargonath": "@thekalinga I don't think that your current use case work with the aforementioned gist example. It seems to allow only minor and fix semver bumps.. For anyone coming from Google I had the same problem with GitLab. If you go in your CI/CD settings of your repository you can switch to using git clone from git fetch for cloning the repo in your pipelines and it just fixed the problem for us.. Looking at your repository and the CI log, it detected 15 commits which seems correct based on your history. There were:\n\n2 ci\n5 chore\n1 fix\n4 refactor\n1 feat\n1 style\n1 test\n\nOnly the feat and fix commits should trigger a release. There is a BREAKING CHANGE for the feat commit: https://github.com/sourcegraph/lsp-client/commit/23c653d999458a6c3ec133f4bb12ff77efcca0fe but without the colon and the explanation. I'm not sure this format works for semantic-release hence that may be the reason it didn't trigger the major release and just the minor release.. As a matter of example when using https://github.com/commitizen/cz-cli if you don't provide an explanation for your breaking change, the label is not added to the commit.. ",
    "enriquecaballero": "+1. ",
    "dfbaskin": "I submitted a PR to the release-notes-generator repo.  All it does it update the version of conventional-changelog.\nhttps://github.com/semantic-release/release-notes-generator/pull/5\nThe build succeeded and the tests passed.  If that can get merged, then I can submit a PR here.. @bahmutov That works nicely.  So is release-notes-generator deprecated now?. ",
    "buehler": "@dfbaskin Awesome.. now some guy should merge it :). @dfbaskin @bahmutov \nI tried it :-) It works quite well, but the generation of the release notes are a little bit off:\n\nThe \"old\" generator does group the notes by title and scope, which is a pretty nice feature.. What if...\nThe plugins can export a list of prerequisites? So actually a list of predicate-functions that return a boolean. So the first step of the core would be: Gather all those predicates and run them. If all return true, do the rest of the stuff. If a predicate fails, throw an error with the name of the plugin (and maybe with a description of the error?). I know, as I analised it I thought the same, but it happend on two different releases that were 3 days apart. So maybe there's something wrong with the format that is submitted to github over the api.. It's kinda strange \ud83d\ude09. Ofc, will do as soon as I do the next release!. Ok so v9.0.0 fixed the publish. It works for the typescript parser, but sadly, I've to use v8 for my other project that I mentioned in https://github.com/semantic-release/semantic-release/issues/492#issuecomment-340309088 since I'm using vsce publish there :-) Any chance to analyse the problem from: https://travis-ci.org/buehler/node-typescript-parser/jobs/294617068 ?. Actually the problem in the opening post of this issue. @gr2m suggested to add debug output, but well kinda hard when it works :-). I just read the v9 release notes, and I'm asking myself the following: since the new version does everything in one command, is it possible to do the \"old\" path?\nI'm asking because of a project of mine that actually relies on that part of semantic release:\nhttps://github.com/buehler/typescript-hero/blob/develop/package.json#L91\nI actually use semantic release pre to set the correct version, than generate changelog entries, and afterwards, do the actual release via vsce publish instead of npm publish.\nIs this still possible?\nCheers. ",
    "durancristhian": "I'd love this option for the same use case \ud83d\udcaa . ",
    "nanovazquez": "\n_ @gr2m said:_ @nanovazquez @durancristhian Would it be an option to set your custom registry in the package.json file? You can set \"registry\" in the \"publishConfig\" setting.\n\nWe are currently using it, and that's why we need an .npmrc in place. The problem is that we are already creating one before running semantic-release, and that's the one we need to use (not the one semantic-release tries to create by default).. > Can you tell me how your existing .npmrc file looks like and how the one created by semantic-release looks like? Maybe we can merge the two if one already exists so it would work for you?\n.npmrc file\n@<scope>:registry=<registry-url>\n//<registry-url>/:_authToken=<registry-token>\n@gr2m: The biggest problem is that semantic-release uses the deprecated npmconf library. And, when this tool tries to save the .npmrc at the project's level (not sure why, because we already have one inside the user's folder), the process fails because the Jenkins Multibranch Pipeline doesn't allow it.\nFrom my point of view, the problem is that semantic-release always tries to create an .npmrc file, which is not required in some cases (this one, for instance). I can try to refactor the code to avoid creating this file when is not needed. But that might the replacement of the npmconf tool and/or big structural changes. With this PR, we are avoiding the refactor and we maintain backwards compatibility. Thoughts?. It will be enough, but as you said, we can't guarantee that we are introducing a breaking change in someone else's setup. \nThat's why I suggested the use of a configuration value. But, if you agree, I can update the code, introduce a breaking change and then release it as a major.. @gr2m: I'm not sure if that will work because semantic release always tries to save the .npmrc file at the project level, and in this case the .npmrc is stored in the user's folder. \nEven if we change this, the user performing the action might not have access to create a file inside the project's folder (this particular case). And (more probably), it won't have access to create a file inside the user's folder.. Hey @crobinson42. In each branch, you need to configure:\n\nThe tag you want to use in the publishConfig field.\nThe branch target in the release field (otherwise semantic-release won't publish in the branch)\nThe npm publish script with the tag you set in the publishConfig field.\n\nIn your case:\nmaster branch\npackage.json\njs\n{\n  ...\n  \"scripts\": {\n    ...\n    \"semantic-release\": \"semantic-release pre && npm publish --tag=stable && semantic-release post\"\n  },\n  \"release\": {\n    \"branch\": \"master\"\n  },\n  \"publishConfig\": {\n    \"tag\": \"stable\"\n  },\n  ...\n}\ndevelop branch\npackage.json\njs\n{\n  ...\n  \"scripts\": {\n    ...\n    \"semantic-release\": \"semantic-release pre && npm publish --tag=next && semantic-release post\"\n  },\n  \"release\": {\n    \"branch\": \"develop\"\n  },\n  \"publishConfig\": {\n    \"tag\": \"next\"\n  },\n  ...\n}\nHope it helps.\n. Sure. I'll make the change.. ",
    "faceyspacey": "This package itself seems to do this here:\nhttps://github.com/semantic-release/semantic-release/releases?after=v6.2.0\nwhere it goes back and forth from releases for the 4.0 track and the 6.0 track. How was that done?. It seems I was correct about manually having to perform the publishes in these cases:\nhttp://stackoverflow.com/questions/24691314/npm-publish-patch-for-earlier-major-version\nBut, taking, the next example, what happens when you eventually merge back into master? The next branch may have already bumped several patches and minor versions ahead when it registers as a breaking change--will semantic-release know to create its version major version incremented from, e.g., 2.3.7 rather than, e.g., 2.0.0?. or perhaps just an option called bump that lets you force re-publishing whenever you need.. ",
    "jedwards1211": "To fix this semantic-release would just need to git fetch and then find last version tag in the history of the current branch, instead of using the version of the last release published to npm, right?. I think in addition to this, semantic-release should publish on the vX (where X is a past major version) branches by default as well.  Maybe even the vX.Y branches (in case one wants to backport bugfixes to multiple minor releases).  Basically the branch option should accept a regex that defaults to master|v\\d+(\\.\\d+)?. whoops, need to open this in the cli project.. Sorry, I was confused by reading the code on here because I didn't realize it's up to version 11 and I'm on 8.\nPart of the reason I didn't realize this is that for some reason yarn upgrade --latest semantic-release wasn't doing a darn thing.. Guys...you have released version 11, yet it's not tagged as latest...only tagged as next.\n@boennemann Das ist mal eine neue Art von Hauptversionsnummernerh\u00f6hungsangst...\n. At least I got my @jcoreio/condition-solano working with semantic-release 11.  No idea how to do it with version 8.. Nevermind, yarn seems to have messed up and put the browserify-aes package in the folder for builtin-modules.. Cool, that makes more sense!. Understood, it's kind of a dumb situtation, and Circle CI should provide a way to force a build of a skipped commit.. ",
    "dalisoft": "Thanks. I try. I am not worry about token and even password. Github is home of open source and peoples doesnt uses other code (always good peoples more than bads).  Thanks a lot for reply. ",
    "aviadatsnyk": "I'd be happy to fix this and create a pr, but would be great if someone can point to the relevant area in the code.. ",
    "LeonardoGentile": "I'm new to this and also for my first release I could see the changelog added an <a name\"1.0.0\">.\nI'm not sure what should be the real and correct value of this? Should be a link pointing somewhere (.i.e npm)? Do we have to manually change this link or can it be configured?. This seems a duplicate of #363 . ",
    "CapitanRedBeard": "@Snugug, I'm facing the same problem. Have you found a work around or should I start looking into working on a PR? Thanks!. ",
    "jlengstorf": "For semantic-release-cli, I found an option in the source code (--ghepurl) that lets you specify the GHE URL:\nsh\nsemantic-release-cli setup --gh-token=<GH_TOKEN> --npm-token=<NPM_TOKEN> --ghepurl=<GHE_API_URL>\nNot sure about the package.json part, unfortunately.. @Snugug @CapitanRedBeard I chased this down further and isolated the condition-travis repo as the culprit: public Travis and GitHub endpoints are hard-coded.\nI created an enterprise-friendly version here: https://github.com/jlengstorf/condition-travis-enterprise\nCaveat: this only works for single-run Travis builds. If you're running in a matrix, this will most likely cause issues for you.. ",
    "Adam-Burke": "I have the same issue on ubuntu . ",
    "HHogg": "I've also just started getting this, I can't seem to find a workaround. Exactly the same error, also on Sierra.\n\nERR! semantic-release Error: Could not get repo id\nERR! semantic-release     at /Users/harry/.config/yarn/global/node_modules/semantic-release-cli/dist/lib/travis.js:92:31\nERR! semantic-release     at next (native)\nERR! semantic-release     at step (/Users/harry/.config/yarn/global/node_modules/semantic-release-cli/dist/lib/travis.js:114:191)\nERR! semantic-release     at /Users/harry/.config/yarn/global/node_modules/semantic-release-cli/dist/lib/travis.js:114:361\nERR! semantic-release     at process._tickCallback (internal/process/next_tick.js:103:7)\nERR! semantic-release  Error: Could not get repo id\nERR! semantic-release     at /Users/harry/.config/yarn/global/node_modules/semantic-release-cli/dist/lib/travis.js:92:31\nERR! semantic-release     at next (native)\nERR! semantic-release     at step (/Users/harry/.config/yarn/global/node_modules/semantic-release-cli/dist/lib/travis.js:114:191)\nERR! semantic-release     at /Users/harry/.config/yarn/global/node_modules/semantic-release-cli/dist/lib/travis.js:114:361\nERR! semantic-release     at process._tickCallback (internal/process/next_tick.js:103:7). There was a major Travis API update on 6th April, though it says nothing in v2 has been deprecated. . @adrukh That was the issue for me too. This was my config ...\n\n\"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/hhogg/remarkable-react.git\"\n  },\nHowever my username is HHogg so changing it to ...\n\"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/HHogg/remarkable-react.git\"\n  },\n... fixed it. I can't imagine this is intentional? . ",
    "adrukh": "I am 99% certain that was having this specific error when my package.json was referencing an incorrect git repo. Even a case-sensitivity mismatch was triggering this. Make sure you are pointing to the proper URL like so:\n...\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/snyk/snyk.git\"\n  },\n...\n. \ud83e\udd26\u200d\u2642\ufe0f \ncould it be that all we need to do is https://github.com/semantic-release/exec#prepare ?. Thanks @pvdlg , we seem to have this going for us with two additions:\n https://github.com/snyk/snyk/blob/master/.releaserc#L4-L7\n https://github.com/snyk/snyk/blob/master/.travis.yml#L30\nLeaving this here in hopes it'll help someone else!. Thanks @pvdlg !\nThis is the commit that made it work for us - https://github.com/snyk/snyk/commit/2eeab79eccc7fe8bb14948538f0697a441938433\nCould not have semantic-release as a devDependency of the project due to our internal constraints (cannot have npm as a dependency), so had to overcome with npm i -g.. ",
    "k1r0s": "+1 facing the same problem\nEdit (missconfigurations in travis)\nSolved. ",
    "tibuurcio": "I'm having this issue as well in macOS Sierra :/\nEdit: My problem was that I hadn't set up a Travis CI account... :grimacing:. ",
    "WebDevMichael": "@jbcpollak it seems that you can add parameters in the CLI https://semantic-release.gitbooks.io/semantic-release/content/docs/usage/configuration.html#configuration. ",
    "mvpspl619": "@SpikeO @jbcpollak Unfortunately, the docs says that the plugin options cannot be passed via CLI. So I'm not sure if it's possible to pass publishConfig args to CLI\n\nNote: Plugin options cannot be defined via CLI arguments and must be defined in the configuration file.\n\nhttps://semantic-release.gitbooks.io/semantic-release/content/docs/usage/configuration.html#configuration. ",
    "Thatkookooguy": "I created an npm library to update semantic-release package.json fields before semantic-release runs on travis.\nIf anyone wants to use it, it should solve this problem: https://www.npmjs.com/package/@kibibit/branch-it. ",
    "cyberhck": "Looks like we don't need any of those after all, semantic release already uses deploy_once and it waits for all the builds to pass before releasing a version. We can just use as it is, everything will work fine.\nI think it's best to close this issue now.. oh, wow, I should have went there before searching in semantic-release core repo, my bad, that's exactly what I'm looking for. Thanks.. ",
    "rarkins": "So npmconf is mentioned in #176 but the other two are not.. @gr2m I think that the default decision to leave refactoring out of releases goes against the higher level semantic-release philosophy of \"remove the immediate connection between human emotions and version numbers\", probably because we all don't want it to \"look like another bug fix\". Instead, I think semver's biggest value to the downstream user is to indicate risk, not characteristic, as represented here:\n| type  | characteristic | breakage               | risk   |\n|-------|----------------|------------------------|--------|\n| major | breaking       | definitely broke       | high   |\n| minor | feature        | maybe broke            | medium |\n| patch | fix            | hopefully didn't break | low    |\nBut refactoring is usually a risk too, sometimes even a medium risk. If I've done a big refactor then I even prefer to even release it as a minor version bump to indicate medium risk. Hence:\nmajor = backwards-incompatible change\nminor = code with risk of breakage, you may want to check it\npatch = should only ever improve stability\ntldr; I prefer an approach of breaking/medium risk/low risk instead of breaking/feature/fix, because that's what the end user is ultimately trying to judge anyway when they look at versions or read release notes. . Thank you! I kept searching for tag and prefix - did not notice that option, sorry.. Thanks for looking at it so quickly. It would be great if you can verify that the PRs contain the release commits. Otherwise, it would also suit my situation if I could disable comments for open issues. i.e. only comment if the issue is in state closed, because issues and PRs that are resolved by a commit to master should always be closed immediately - prior to semantic release - anyway.. ",
    "darscan": "I just ran into this myself. Here's an awful/fun hack:\nyaml\nafter_success:\n  - TRAVIS_JOB_NUMBER=WORKAROUND.1 npm run semantic-release. Hi @lespinalrivera . I'm not quite sure what you mean by \"legal\".. it's certainly a dirty hack, but was enough to get semantic release past this conditional: https://github.com/semantic-release/travis-deploy-once/blob/master/src.js#L10\nThe hack will certainly cause problems if you're not using build stages or your publish step is not in its own stage.. Ah, I just took a look at https://github.com/lespinalrivera/lame-excuses/blob/ee0b6ad8c61bf1e1d270297121756fd09d5c75da/.travis.yml\nYou definitely don't want to use this hack there! It will run after every job, and the hack will cause semantic release to run each time.\nThe hack is needed when using build stages where the release job is in a separate stage from all other jobs (and therefore can never be the so-called \"build leader\"), like this:\nhttps://github.com/nordnet/grid/blob/45e05405e8ebd9aa040279386470994030de74b6/.travis.yml\nIn the example above the auto-expanded-build-matrix (node_js: -7 -6 -4) is run in one (implicit) \"test\" stage, while the \"release\" stage runs after and only has a single job. As the \"release\" stage will only be reached if all jobs in the \"Test\" stage succeed, and there is only one job in the \"release\" stage, we need to trick semantic-release into thinking that the single job in that stage is the build leader.\nBut in your case every job in the build matrix is in the same stage, and after_success hook will run for all of them. Which means you need the default behaviour where semantic-release bails out for any job that is not the \"build leader\" (the first job).. ",
    "iamstarkov": "nice, @darscan thank you. ",
    "lespinalrivera": "Is this even legal @darscan I am running into the same problem with my library for lame excuses (don't ask).\nUPDATE: This command actually had Travis running around chasing its own tail \ud83d\udc15 until half an hour later, it ended catching it and finishing. Sadly I went from V1.7.2 to V0.0.1 guess I will update a tag for github and push it.. ",
    "artemv": "@vanduynslagerp yeah the gitHead concerns make sense. Looks like the best thing is to make semantic-release pre write some semantic-release specific property to package.json instead to make it independent of this undocumented npm thing? E.g. \n\"release\": {\n    \"verifyConditions\": \"condition-circle\",\n    \"gitHead\": \"bfc1d5eadb48039c038bc02a88a5c48fda1d28ab\"\n  },\nand then fallback to looking at tags can be just removed.. > Or could you provide a link to your repo and the Circle CI jobs so we can analyze more in details ?\nHere I've set up a demo: https://github.com/artemv/semantic-test. The only thing needed to showcase the issue in CircleCI env is to split semantic-release into 2 parts: semantic-release pre runs after dependencies are installed, and then npm publish && npm show && semantic-release post publishes to NPM, shows the published version of package.json and publishes git tag. Looks like the key thing is that npm publish is a first command in the step there, and no command before it populates gitHead to env vars somehow.\nThe commits history has BREAKING CHANGE so because of the gitHead issue it always publishes new major: https://circleci.com/gh/artemv/semantic-test/25 publishes version 6.0.0 and then https://circleci.com/gh/artemv/semantic-test/26 publishes 7.0.0, though the difference between them should be patch increment.\nI also showcased the use of this PR's version of semantic release: when I switch to it it \n warns that gitHead was missing in semantic-release pre - see npm run semantic-pre step in https://circleci.com/gh/artemv/semantic-test/22\n figures correct starting point for commit analyzer from git tag (luckily it was published) - so it's an immediate cure\n* writes gitHead to package.json semantic-release pre for use in next CI build - it's then seen inside the output of npm show inside npm run semantic-release step of https://circleci.com/gh/artemv/semantic-test/22\nSo when https://circleci.com/gh/artemv/semantic-test/23 runs the gitHead is in place and all works as usual (except semantic-release pre writes gitHead to package.json again to make sure it's published).. > So the problem is not running semantic-release pre && npm publish && semantic-release post in one command or in two. It's related to which phase of the Circle CI build it runs.\nThat's interesting because I remember we started to have this issue on one of my projects exactly when I split the command into two. So I tested your idea here - no, joined version does publish gitHead: https://circleci.com/gh/artemv/semantic-test/27\n\nThough, it's probably semantic-release pre then who is helping npm here. Anyway, the logic behind this PR is this - \n NPM doesn't promise to publish gitHead\n but it usually does, and when it does it's equal to git head hash indeed\n semantic-release relies on gitHead property - obviously it needs it more than npm itself\n semantic-release pre is confident at getting the git head hash - note btw that it got it inside deployment step without problem in https://circleci.com/gh/artemv/semantic-test/27\nSo why not just let semantic-release pre write it by itself... Yeah, the mystery unveils, thank you! Found more context behind condition-circle's workaround here: \n\nThis arises from npm publish's brittle broken way of getting at that Git hash in the first place (PR here): It silently fails on perfectly valid Git repos if they use packed refs a certain way.\n\nSo, an NPM issue yeah, the one you've mentioned already. Well, at least semantic-release could do better at identifying the issue on semantic-release pre stage - it says nothing about missing gitHead at e.g. https://circleci.com/gh/artemv/semantic-test/27. I think I'll make another PR ). Here: https://github.com/semantic-release/semantic-release/pull/447 - I kept the using tags thing there.. > For information we are also trying to figure out a way to have only one step for semantic-release that would handle pre, publish and post. But that's not so easy as we want to publish exactly the way npm does.\nBtw I have an input to this idea - the reason why we've split the semantic-release to two parts at some point is that it can be useful to have the package version before it's published - e.g. then we can console.log it from the JS code being run, useful for browser libs. So would be good to keep an option to split them.. > And what I can tell for sure is that @gr2m and myself are quite motivated to move things forward, and hopefully people have already noticed some small improvements here and there.\nSure, nice to see that the project is alive again, thank you guys!. Yeah I'll try.. ",
    "tunnckoCore": "The whole point that i may consider return back to using Travis is if really semantic-release do that thing automatically, otherwise i'll stay with CircleCI. But i don't want to do such manual things - hate that shit, that's one of the reasons why i switched from Coveralls to Codecov, too.. Manually added, seems to work, but fails again with .pluck is not a function.\n\nOn Node 8.1, fails with .pluck is not a function\n\nOn Node 6.11, fails with Cannot find module 'validate-npm-package-license'\n\n. Seems that v4.3.5 works, but only on node 4. On node 6 it fails to load validate-npm-package-license (which seems to exist in normalize-package-data which is used here). Oh, probably issue is in the wrong repo, but... is it a problem?. Hm. Actually, good point. Okey, clarified, now not sounds so strange.\nThanks! :) . Great! It seems to work fantastic https://github.com/olstenlarck/probot-test/releases! :tada: :taco: \nIt's already pretty well organized and is good to read :)\nOptionally configurable through .github/semantic-release.yml file which allows customizing the release template and the npm registry, also the separate type of headings.\nTests are welcome, cuz it's my first time Probot and don't think i can do it very well. Also one note: currently it only supports getting most latest commit, which is pretty enough if you already is using semantic-release.. Anyone can try it https://github.com/apps/semantic-release-app - it's live now :) Feedback welcome and we'll continue work.. O yea yea, sorry.. Not so. GitHub is most widely used and CIs are more different per project and self preferences. If we have such app, then we only need to handle the npm part in the semantic-release package. Which also means lower dependencies and codebase.. Actually yea, it's up but is called new-release currently (damn, should change it's description too, just forgot that). Because to not confusions with the Semantic Release team and etc stuff. Also it is good works perfectly currently with new-release npm package :) Few packages are autoreleased with both of them :)\nThat's it https://github.com/apps/new-release. As about https://www.npmjs.com/package/new-release - it needs only $NPM_TOKEN to exist as global ENV in the CI, which is pretty enough. You can see some example CircleCI config in triage-new-issues app. Most important is to set context: org-global for the job that executes new-release package. \nTravis in anyway isn't good. Or i'm just not aware of some way to set global env (as like it is possible in CircleCi), you always should add it per project which is too much for me.. Yup, core behind both are almost the same. And yes, they currently works well together and works brilliant with CircleCI 2.0 and only requires to add NPM_TOKEN env. I'm trying to get some more little time to finish all the things.\n\ncc'd Rhys, as he currently has the release app to provide a very similar service (Though I don't think it actually does anything at the moment).\n\nHa! Cool, didn't noticed that, because i'm not active last week.. Just to share how cool is everything and that the Github app and new-release works great together.\nIt's just fantastic to woke up that way in the morning :hear_no_evil: Check out last few releases of https://github.com/tunnckoCore/hela-config-tunnckocore/releases which are totally automated ;]\n\n\n. Great to hear that :) Yea, no problem. When it is really ready we can discuss more things (missing things, etc) about it and eventually adjust both things - most users, sadly use Travis, so we must do something for this (i totally don't have welling to mess with Travis; at least until their package is good). It would be great if this community can use the app, so i'm also open to rename it once everything is clear.. Cuz, definitely, CircleCI has enormous speed and advantages (i didn't believe until i just started using it).\nOr at least, i feeling it and seeing it that way.. Agree. But I more think that such things like commitlint must be done before commiting phase, so it's totally impossible to even commit if you don't follow community rules - read the READMEs, docs, contributing guides and then consider everything other, otherwise you are just not welcome. :laughing: \nSorry, but i can't do much if you can't read :D \nIt's just my mindset. And actually this model works great to me for last years.\nSo, in short, that aspect of CircleCI is not a problem for me.. Agree. But the CI still runs all of my jobs that I run locally so... I don't need github apps for this.. @pvdlg, some previous work https://github.com/tunnckoCore/new-release-app and new-release npm package (quick and simple replacement, just because Semantic Release burnt out me around october). Btw, fully working, covering only Github releasing automation. Npm and such things just should be bundled as package.\nI'm seeing a lot of work in last 2 months and even so big v13 version, i'll try. I'll read the whole thread later.. Of course. Once upon a time Semantic Release wasn't so general tool and didn't (?) have such purpose. And yes, the whole point is that javascript needs easy and small tools. Generalized ones are good too. But why i (and not only me) should use Semantic Release and waste time in installing, when we only need nodejs releaser? Also it just make sense to separate the two things - Bot & cli that runs from CI. Why is the other overhead? \n\nRelease of multiple commits at once (it seems your app take only one commit in account to determine the next release)\n\nYup, in the roadmap, of course.\n\nCustomization of the commit parser preset\n\nIn the roadmap, it just temporary works with most simple commit parsing, for now. Even in future, it not make sense to support too much. In reality such tool just needs 3 kind of things from the message - fix, feat and /BREAKING( CHANGES?)?/g, no matter of what preset.\nNot to mention that https://github.com/tunnckoCore/parse-commit-message has plugins support. Currently just works for the default expectations of Conventional Commits v1 spec.\n\nSet PR status to failed if a commit message doesn't respect the convention\n\nAgain think that it is too much to listen on every commit of the pr. Don't make it hard for less experienced users to contribute. You in anyway then merge with squash option and you can set the correct commit message. But okey, little change can be done in the cli to support it.\nAs about the failing, CI fails if tests are not passing and if the new-release cli fails. It is CI's thing, not tool's.\n\nRun project's custom command to compile/build before releasing\n\nNeedless to be handled by tool. Everyone can simply add it to CI or just pass whatever he want to the prerelease npm script, whenever he want.\n\nCustomization of the release note\n\nIt depends on template of course. Would be possible to configure it through Probot config file convention. Currently it just aligns to the default Semantic Release style.\n\nI'm not against Semantic Release or anything. I used it for a year or more, and after hitting my Github account's rate limits (https://github.com/semantic-release/cli/issues/143) i was just totally blocked to do any developer work and needed, really fast, to come with solution and write something  that just works as was working with semantic release 1:1.. It's not competition and i'm not trying to compete. My kindness is totally okey too. I didn't hopped here to promote or anything. Just gave some previous work and you commented points that partly are not correct about it, so i just responded that it is possible. \n \nLet's clear something. I'm not native English and hate when people saying that i'm promoting something or i'm not enough polite or whatever - that's damn ridiculous, sorry, but that is my maximum kindness. Tired of defensing my words, just because we should kind and polite to pain - sorry that's not my thing. :D \n \nI didn't get here just because i don't have what to do and as i said i'll review the whole thread and give response.. Exactlty, @destroyerofbuilds. It's some kind of confusing for the newcomers. I was wanting to force people to follow that \"spec\" for every commit they made, but realized that it is uneccessary when we can just format it correctly following the convention spec, when merge the PR.. ",
    "rtizzy": "Any update on getting this working with Travis @charlike ? I'd like to implement this in a client's environment on a private repo. \nAlso if I'm not mistaken, shouldn't the token be implemented in Travis with secure environment variables? It's an option under settings. \nDoes this package somehow handle that differently? \n@charlike \n. ",
    "gurpreetatwal": "Check out this gist: https://gist.github.com/boennemann/54042374e49c7ade8910\n. Just wanted to drop my vote for this feature as well. I have a couple of restrictions on my workflow that prevent me from using semantic-release fully without this feature. \n- my \"package\" is a web server, so it is not pushed to npm\n- for security / compliance no code is allowed to be deployed unless it has gone through a review process meaning a bot can't edit files before merging to master and deploying\n- I need to have the version number in the package.json for my service for things like error tracking, logging, etc.\nThe workflow I was thinking is as follows:\n1. add a git post-commit hook that runs on every commit created, it runs semantic-release and amends the previous commit to have the updated package.json file\n2. when a commit lands on master, semantic-release runs in CI and creates the github release with release notes\nI've run into two problems with this:\n1. The need to maintain two different semantic-release configs, one for local use and one for CI use.\n2. semantic-release will not execute if my branch is behind my remote \nThis is the setup I have thus far:\n```js\n'use strict';\nmodule.exports = {\n  verifyConditions: [],\n  analyzeCommits: ['@semantic-release/commit-analyzer'],\n  verifyRelease: [\n    {\n      path: '@semantic-release/exec',\n      cmd: 'echo  ${nextRelease.version} > .version',\n    },\n  ],\n  generateNotes: [],\n  prepare: [],\n  publish: [],\n  success: [],\n  fail: [],\n};\n```\n```bash\ncompute the version from the commit message\nnpx semantic-release --dry-run --branch \"$( git rev-parse --abbrev-ref HEAD )\" --no ci\nupdate package.json & package-lock.json\nnote: the subshell is needed because you can't read and write to the same file\necho \"$(jq \".version = \\\"$( cat .version )\\\"\" package.json )\" > package.json\necho \"$(jq \".version = \\\"$( cat .version )\\\"\" package-lock.json )\" > package-lock.json\ngit add package.json package-lock.json\ndisable post-commit hook temporarily, otherwise ammending the commit will execute this again\n[ -x \"$hook\" ] && chmod -x \"$hook\"\ngit commit --amend --allow-empty\nchmod +x \"$hook\"\n```\nI could get around the limitation by using standard-version, but then the tool publishing the tag would different from the one bumping the versions. \nIdeally I would run semantic-release -d --quiet --show-version and semantic-release would analyze the commits between the last tag on GitHub and HEAD and then just print the recommended version.\nI will say that this breaks most of the assumptions that semantic-release is built upon, meaning it runs in a CI environment, but maybe introducing a local flag would make the abstraction cleaner? \nAnother idea would be to implement this via a plugin of some sort, but the checking of various git states is actually in the main semantic-release code rather than a plugin which can be disabled. . ",
    "yoitsro": "I'm also getting this, but using Codeship. I also get the same even when running locally. Here's my setup:\npackage.json\n{\n  \"name\": \"hops\",\n  \"description\": \"Hops\",\n  \"main\": \"index.js\",\n  \"dependencies\": {\n    \"google-protobuf\": \"^3.4.0\"\n  },\n  \"scripts\": {\n    \"test\": \"exit 0\",\n    \"semantic-release\": \"semantic-release pre && npm publish && semantic-release post\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/private-org/hops.git\"\n  },\n  \"author\": \"Ro Ramtohul\",\n  \"license\": \"ISC\",\n  \"bugs\": {\n    \"url\": \"https://github.com/private-org/hops/issues\"\n  },\n  \"homepage\": \"https://github.com/private-org/hops#readme\",\n  \"publishConfig\": {\n    \"access\": \"restricted\"\n  },\n  \"engines\": {\n    \"node\": \"> 8.4.0\"\n  },\n  \"version\": \"0.0.1\",\n  \"devDependencies\": {\n    \"@semantic-release/condition-codeship\": \"^1.1.0\",\n    \"semantic-release\": \"^8.2.0\"\n  },\n  \"release\": {\n    \"verifyConditions\": [\n      \"@semantic-release/condition-codeship\"\n    ]\n  }\n}\nI have the following Codeship environment variables set: CI=true, GH_TOKEN and NPM_TOKEN.\nIn the custom deployment script:\nnpm run semantic-release. So I'm doing some more digging and it looks like the @semantic-release/condition-codeship isn't working properly. Rather than bailing out like @semantic-release/condition-travis does, I get this warning:\n(node:10647) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 2): Error: semantic-release didn\u2019t run on Codeship and therefore a new version won\u2019t be published.\nYou can customize this behavior using \"verifyConditions\" plugins: git.io/sr-plugins\n(node:10647) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.\nI think this could have happened during a dry run when I ran it locally, but rather than bailing, it published the version in the package.json without bumping the version number.. More digging:\nWhen release.verifyConditions in package.json is an array, rejected promises aren't caught properly...\nWhen it's just a string, the error is caught and the rest of the flow happens as expected.\n. Try this using the default condition-travis plugin, but explicitly placed inside an array:\n{\n  \"name\": \"hops\",\n  \"description\": \"Hops\",\n  \"main\": \"index.js\",\n  \"dependencies\": {\n    \"google-protobuf\": \"^3.4.0\"\n  },\n  \"scripts\": {\n    \"test\": \"exit 0\",\n    \"semantic-release\": \"semantic-release pre && npm publish && semantic-release post\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/private-org/hops.git\"\n  },\n  \"author\": \"Ro Ramtohul\",\n  \"license\": \"ISC\",\n  \"bugs\": {\n    \"url\": \"https://github.com/private-org/hops/issues\"\n  },\n  \"homepage\": \"https://github.com/private-org/hops#readme\",\n  \"publishConfig\": {\n    \"access\": \"restricted\"\n  },\n  \"engines\": {\n    \"node\": \"> 8.4.0\"\n  },\n  \"version\": \"0.0.1\",\n  \"devDependencies\": {\n    \"@semantic-release/condition-codeship\": \"^1.1.0\",\n    \"semantic-release\": \"^8.2.0\"\n  },\n  \"release\": {\n    \"verifyConditions\": [\n      \"@semantic-release/condition-travis\"\n    ]\n  }\n}\nNow, try the same without it being placed inside an array:\n{\n  \"name\": \"hops\",\n  \"description\": \"Hops\",\n  \"main\": \"index.js\",\n  \"dependencies\": {\n    \"google-protobuf\": \"^3.4.0\"\n  },\n  \"scripts\": {\n    \"test\": \"exit 0\",\n    \"semantic-release\": \"semantic-release pre && npm publish && semantic-release post\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/private-org/hops.git\"\n  },\n  \"author\": \"Ro Ramtohul\",\n  \"license\": \"ISC\",\n  \"bugs\": {\n    \"url\": \"https://github.com/private-org/hops/issues\"\n  },\n  \"homepage\": \"https://github.com/private-org/hops#readme\",\n  \"publishConfig\": {\n    \"access\": \"restricted\"\n  },\n  \"engines\": {\n    \"node\": \"> 8.4.0\"\n  },\n  \"version\": \"0.0.1\",\n  \"devDependencies\": {\n    \"@semantic-release/condition-codeship\": \"^1.1.0\",\n    \"semantic-release\": \"^8.2.0\"\n  },\n  \"release\": {\n    \"verifyConditions\": \"@semantic-release/condition-travis\"\n  }\n}. Good work \ud83d\udcaa Thank you!. @gr2m This works \ud83d\udc4c Nice one!. ",
    "zetaron": "Hey @gr2m, that's great news :) \nI'll try to reach out to Bitrise and see if I can get some feedback on changing the way git initializes its repositories on their platform. \nFor 1 and 2 I'd wait until I've talked to Bitrise but in case they're not willing to change their setup I'll take these on. \nJust a small request: Cloud you point me to how to setup the test environment locally? Unit tests are not the problem but there seem to be integration tests with a dependency on some sort of fake registry that requires a database? . I'll see if I can get around to the requested changes 1 and 2 on the coming weekend.. @gr2m I'm actually having trouble finding the spec file where I'd extend the test suite in respect to the change this PR provides.\nMaybe you could describe a little bit how the suites are structured and eg. on which directories they operate, for example I initially thought to extend the test/specs/commits.js suite but then was unable to understand how the current tests work and how I'd add my own.. According to the docker hubs page on couchdb the default port is 5984 but can be bound to any host port using dockers -p cli option.\nI'll see to test this on the coming weekend.. Currently the registry start script either expects to either be run on Travis (if) or to have the couchdb binary installed on the host (else).\nhttps://github.com/semantic-release/semantic-release/blob/12b35396d88d37de8000d7838b41de9f2b276f80/test/registry/start.sh#L10-L26\nThe stop.sh script also assumes that it is able to kill the started couchdb instance.\nhttps://github.com/semantic-release/semantic-release/blob/12b35396d88d37de8000d7838b41de9f2b276f80/test/registry/stop.sh#L4-L11\nIt would be required to modify these two scripts to allow the use of docker for running couchdb.\nMaybe it's an option to check for docker and if it's available use it to run the couchdb instance.\nWhile trying to test the setup with docker, I was able to use the official couchdb image from the docker hub but then ran into timeout issues with the scenario tests.\nI feel that I lack the knowledge to configure couchdb or to modify the current scenario setup, maybe someone who's a little more involved could take a look.. Will certainly do! Unfortunately we are so close to a deadline, that it'll take me some time to get to it.\nOn October 15, 2017 10:42:27 PM GMT+02:00, Gregor Martynus notifications@github.com wrote:\n\n@pvdlg sounds great! \n@zetaron wanna give this a try? \n-- \nYou are receiving this because you were mentioned.\nReply to this email directly or view it on GitHub:\nhttps://github.com/semantic-release/semantic-release/issues/413#issuecomment-336740058\n\n-- \nSent from my Android device with K-9 Mail. Please excuse my brevity.. When I don't get to it within the next 14 days, it would be great if you could ping me :)\nThanks for the patience and pushing the project forward! I really appreciate it. \nOn October 16, 2017 9:53:38 PM GMT+02:00, Gregor Martynus notifications@github.com wrote:\n\nno worries :) Good luck with the project. Shall we ping you again on\nsome specific day? \n-- \nYou are receiving this because you were mentioned.\nReply to this email directly or view it on GitHub:\nhttps://github.com/semantic-release/semantic-release/issues/413#issuecomment-337017072\n\n-- \nSent from my Android device with K-9 Mail. Please excuse my brevity.. @pvdlg might be a stupid question to ask but why does the code you reference care about modification of the .npmrc at all?\nThe important bit is the modification of the package.json and related files to use the new package version. \nI'd also assume most systems either already have a .npmrc or it would be easy to set up before running semantic-release.\nTherefore I'd suggest to just remove the auth setup from code and add it to the tests setup code as an implementation detail cared for before running the actual integration suite. \nIf there are compatibility concerns for current users I'd mark the feature as deprecated and still move the test specific email auth setup while leaving the NPM_TOKEN code. This should not change the current coverage (for this piece of code) as the production code is skipped in favor or the email auth setup which only gets run while testing and the actual production code stays untested. \n. ",
    "rockchalkwushock": "I see now that in the package.json the version has never been updated. I imagine that npm & yarn both when installing globally are reading package.version so that is why I see:\nsh\nsemantic-release-cli@3.0.3. @vanduynslagerp \nThanks for the quick response and information I will give that a try. I'm new to CircleCi in general and got started with v2 so I'm still learning my way around it. Thanks so much for the advice. I will let your team know if the solution works. \ud83d\udc4d . Worked! Thanks so much for the assistance @vanduynslagerp\n\n. ",
    "godber": "Ok, adding the tag to package.json and using the default semantic-release task works as desired.\nThe snippet added would look something like this:\n...\n    \"publishConfig\": {\n      \"tag\": \"dev\"\n    }\n...\nI suppose the docs could be a little more explicit on this topic, I didn't put two and two together until I re-read it a few times.. ",
    "blakedietz": "I agree this could be better documented.. cd dist && npm run semantic-release doesn't work @pvdlg.. Seems like you would need to run cd dist && ../node_modules/.bin/semantic-release pre && ..... @pvdlg Are you installing semantic-release globally?\nHere's the output for the deploy when I'm doing that from the CircleCi box.\n```\ncircleci@a17ba19938b9:~/repo/build$ npm run semantic-release\n\nblake-dietz-ts-ui-2@1.0.0 semantic-release /home/circleci/repo/build\nsemantic-release pre && npm publish && semantic-release post\n\nsh: 1: semantic-release: not found\nnpm ERR! file sh\nnpm ERR! code ELIFECYCLE\nnpm ERR! errno ENOENT\nnpm ERR! syscall spawn\nnpm ERR! blake-dietz-ts-ui-2@1.0.0 semantic-release: semantic-release pre && npm publish && semantic-release post\nnpm ERR! spawn ENOENT\nnpm ERR!\nnpm ERR! Failed at the blake-dietz-ts-ui-2@1.0.0 semantic-release script.\nnpm ERR! This is probably not a problem with npm. There is likely additional logging output above.\nnpm WARN Local package.json exists, but node_modules missing, did you mean to install?\nnpm ERR! A complete log of this run can be found in:\nnpm ERR!     /home/circleci/.npm/_logs/2017-12-19T02_35_02_632Z-debug.log\n``. @pvdlg not using yarn, but I was using an older version before reading this thread. That command was hydrated from earlier. I'll try your configs out with the latest version ofsemantic-release.. @pvdlg Thanks for the heads up, that helped. I'm using npm 5.5.1 with node 9.3.0 andsemantic-release@11.0.2and these are the configs based upon yours that I used that worked for deploying with  CircleCI with a directory that is built to (/build`) in this scenario. \nAre those other verifyCondition plugins even required other than the condition-circle plugin?\nHere's the .circleci/config.yml as well. I did have to refer to the node modules manually using relative paths.\n```\nJavascript Node CircleCI 2.0 configuration file\n\nCheck https://circleci.com/docs/2.0/language-javascript/ for more details\n\nversion: 2\njobs:\n  build:\n    docker:\n      # specify the version you desire here\n      - image: circleci/node:9.3.0\nworking_directory: ~/repo\n# TODO: (bdietz) - add a caching step to speed up the download speeds for deps\n\nsteps:\n  - checkout\n  - run: echo \"//registry.npmjs.org/:_authToken=$NPM_TOKEN\" >> ~/.npmrc\n  - run: npm install\n  - run: npm run lint\n  - run: npm run build\n  - run: npm run deploy:storybook\n  - run: cd build && ../node_modules/.bin/semantic-release\n\ngeneral:\n  branches:\n    only:\n      - master\n```\n\"name\": \"blake-dietz-test\",\n  \"version\": \"0.0.0-development\",\n  \"description\": \"A ui-library for creating applications consistent with the TSheets style guidelines.\",\n  \"main\": \"./src/index.js\",\n  \"scripts\": {\n    \"build\": \"npm run build:es2015 && npm run build:es2015modules && npm run build:copy-files\",\n    \"build:copy-files\": \"babel-node ./scripts/copy-files.js\",\n    \"build:es2015\": \"NODE_ENV=production BABEL_ENV=es babel ./src --out-dir ./build\",\n    \"build:es2015modules\": \"NODE_ENV=production BABEL_ENV=modules babel ./src/index.js --out-file ./build/index.es.js\",\n    \"build:storybook\": \"build-storybook -c .storybook -o .out\",\n    \"commit\": \"git-cz\",\n    \"deploy:storybook\": \"storybook-to-ghpages\",\n    \"ci-deploy:storybook\": \"git config --global user.email $GH_EMAIL && git config --global user.name $GH_NAME && storybook-to-ghpages\",\n    \"lint\": \"eslint . --cache && echo \\\"eslint: no lint errors\\\"\",\n    \"postrelease\": \"npm publish build --tag next\",\n    \"prebuild\": \"rimraf build\",\n    \"prettier\": \"find . -name \\\"*.js\\\" | grep -v -f .eslintignore | xargs prettier --write\",\n    \"storybook\": \"start-storybook -p 9001 -c .storybook\",\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n    \"semantic-release\": \"semantic-release\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/blakedietz/blake-dietz-tsheets-ui-test.git\"\n  },\n  \"keywords\": [\n    \"material design\",\n    \"material-ui\",\n    \"react\",\n    \"react-component\",\n    \"theme\",\n    \"tsheets\"\n  ],\n  \"author\": \"\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/blakedietz/blake-dietz-tsheets-ui-test/issues\"\n  },\n  \"homepage\": \"https://github.com/blakedietz/blake-dietz-tsheets-ui-test\",\n  \"devDependencies\": {\n    \"@semantic-release/changelog\": \"1.0.0\",\n    \"@semantic-release/git\": \"2.0.0\",\n    \"@semantic-release/github\": \"2.2.3\",\n    \"@semantic-release/npm\": \"2.3.1\",\n    \"@storybook/react\": \"^3.2.17\",\n    \"@storybook/storybook-deployer\": \"^2.2.0\",\n    \"babel-cli\": \"^6.26.0\",\n    \"babel-core\": \"^6.26.0\",\n    \"babel-eslint\": \"^8.0.3\",\n    \"babel-plugin-transform-dev-warning\": \"^0.1.0\",\n    \"babel-plugin-transform-object-assign\": \"^6.22.0\",\n    \"babel-plugin-transform-runtime\": \"^6.23.0\",\n    \"babel-preset-env\": \"^1.6.1\",\n    \"babel-preset-react\": \"^6.24.1\",\n    \"babel-preset-stage-1\": \"^6.24.1\",\n    \"commitizen\": \"^2.9.6\",\n    \"condition-circle\": \"^2.0.1\",\n    \"cz-conventional-changelog\": \"^2.1.0\",\n    \"eslint\": \"^4.12.1\",\n    \"eslint-config-airbnb\": \"^16.1.0\",\n    \"eslint-config-prettier\": \"^2.9.0\",\n    \"eslint-plugin-babel\": \"^4.1.2\",\n    \"eslint-plugin-import\": \"^2.8.0\",\n    \"eslint-plugin-jsx-a11y\": \"^6.0.2\",\n    \"eslint-plugin-prettier\": \"^2.3.1\",\n    \"eslint-plugin-react\": \"^7.5.1\",\n    \"fs-extra\": \"^5.0.0\",\n    \"jest\": \"^21.2.1\",\n    \"prettier\": \"^1.9.1\",\n    \"rimraf\": \"^2.6.2\",\n    \"semantic-release\": \"11.0.2\"\n  },\n  \"dependencies\": {\n    \"material-ui\": \"^1.0.0-beta.22\",\n    \"react\": \"^16.2.0\",\n    \"react-dom\": \"^16.2.0\"\n  },\n  \"config\": {\n    \"loglevel\": \"verbose\",\n    \"commitizen\": {\n      \"path\": \"node_modules/cz-conventional-changelog\"\n    }\n  },\n  \"release\": {\n    \"verifyConditions\": [\n      \"condition-circle\",\n      \"@semantic-release/changelog\",\n      \"@semantic-release/npm\",\n      \"@semantic-release/git\",\n      \"@semantic-release/github\"\n    ]\n  }\n}. @benjamincharity does my config help?. @pvdlg thanks for your recommendations! Seriously, you were super fast! A lot of that previous cruft was from other tutorials about the older version of semantic-release, glad to clean it all up! Everything worked except for\n\nrun: cd build && ../node_modules/.bin/semantic-release can be replaced by run: cd build && npm run semantic-release so the package.json in your build directory (the one published) will be used\n\ndue to the same reasons that I had mentioned earlier.. @pvdlg I think it's all just based upon the directory you give to publish. It's up to you to copy the necessary files over into the directory that you're publishing. See https://github.com/mui-org/material-ui/blob/v1-beta/scripts/copy-files.js for an example of a package publishes a built directory and the associated scripts.. ",
    "psyrendust": "@benjamincharity @vanduynslagerp that'll work, thanks!. ",
    "jrgcubano": "I'm facing the same issue... The version does not increase: \n\nnpm run semantic-release-pre\nnpm run build (create dist)\nnpm run publish-npm (npm publish ./dist)\nnpm run semantic-release-post\n\nhttps://github.com/MallorcaJS/mallorca-ng/blob/master/.travis.yml\nSome advice @benjamincharity?. Nice @benjamincharity. Thanks a lot!\ncode\n...\nscript:\n  - npm test\n  - npm run semantic-release-pre\n  - npm run build  \nafter_success:\n  - npm run publish-npm\n  - npm run semantic-release-post**\n.... ",
    "abalad": "@jrgcubano In your current Travis configuration, is not it generating this error below for you?\nsemantic-release ERR! pre Not running in Travis after_success hook\nBecause I have the following settings in my travis.yml and when it generates wheel this error is returned to me\nbefore_script:\n  - npm prune\n  - npm run lint\n  - npm run test\nscript:\n  - npm run semantic-release-pre\n  - npm run compile\nafter_success:\n  - npm run publish\n  - npm run semantic-release-post\n  - npm run build:showcase. @pvdlg Thanks, I did not know these package.json keys. I'll use them right now ;). @pvdlg Solved yes you can close it ;) Thx.. Sorry @pvdlg  really was that, I was passing the wrong package.json into the ci. . Thanks guys, I'll try to do it this way.\n. Not yet. Because I'm finishing other tasks, because I need to update the Node of my environment. But as soon as I can finish here,. ",
    "sudo-suhas": "@gr2m I tried this out by creating a POC repo but it does not work \ud83d\ude1e. yarn publish does not publish the current version but instead tries to prompt for the new version. Which errors out on travis:\nconsole\n$ semantic-release pre && yarn publish && semantic-release post\nyarn publish v0.27.5\n[1/4] Bumping version...\ninfo Current version: 1.0.0\nerror An unexpected error occurred: \"Can't answer a question unless a user TTY\".\ninfo If you think this is a bug, please open a bug report with the information provided in \"/home/travis/build/sudo-suhas/yarn-semantic-release-poc/yarn-error.log\".\ninfo Visit https://yarnpkg.com/en/docs/cli/publish for documentation about this command.\nI also tried yarn publish --non-interactive but that didn't work either.\nAs suggested in this issue, https://github.com/yarnpkg/yarn/issues/3011, one alternative is to pass the new version yarn publish --new-version <version> but I can't quite figure out a simple and clean way to do this.. True. Wanted to use yarn just for the sake of consistency. I slightly dislike having to use both yarn and npm in the travis file.. @gr2m I'd be glad to help with that. However, I am not entirely sure what the solution would be. At this point, I feel trying to use yarn is more trouble than it is worth.. Ok, I'll do that. \nBTW, I got one step further but no cigar. I used the following script to pass the version to yarn publish:\njs\n// package.json\n{\n  //...\n  \"scripts\": {\n    \"print-version\": \"cross-env-shell echo $npm_package_version\"\n  },\n}\n```yml\ntravis.yml\n...\nafter_success:\n  - yarn global add semantic-release\n  - 'semantic-release pre &&\n    yarn publish --new-version yarn run -s print-version &&\n    semantic-release post'\n```\nBut this resulted in an error - An unexpected error occurred: \"https://registry.yarnpkg.com/yarn-semantic-release-poc: You must be logged in to publish packages.\". Yarn does not use the environment variable NPM_TOKEN which semantic-release sets up in travis.. Closing as the question is no longer relevant with the changes in v9 release of semantic-release.. I wasn't aware of that. Perhaps @gr2m can clarify why he felt we could add a section to the FAQ.. No problem @gr2m, wanted to be sure before closing the PR.. Alright, thanks @gr2m, @pvdlg. I think that answers my question. prepublishOnly hook is good for running the build and postpublish can be used for generating docs. . I see that normalize-package-data is taking care of this. Closing,. ",
    "JPeer264": "A custom commitAnalyzer was written to detect those changes. This should close this issue.. ",
    "kasunkv": "Yes the tag v1.0.0 already exists. And that release was pushed  by travis using semantic-release when i ran the build for the first time. But if you look at the sample repository, there are 2 more commits which are features, that should increment the version number to v1.2.0 but that is not happening. semantic-release tries to push v1.0.0 to github repository and therefore throwing this error. It seems semantic-release does not pickup the commit properly right? if so the version should have been updated to v1.2.0. @gr2m I would really appreciate if i can get some assistance on this issue. I tried everything i could think of and still no luck. . @pvdlg No, v1.0.0 was published with the kasunkv/sem-rel@6dce8ed68c64cbfe79c88079de8c04b000b2a7c7 commit according to the Travis Build. Having said that, does semantic-release must have a npm publish step included in it to work properly.? Because, the first time i faced this issue was on a different project that i am working on kasunkv/owasp-zap-vsts-task . This is not a npm package. The releases to VSTS happens on a different build system. I only wanted to have semantic releases on GitHub with release notes. That's why in the sample project i created, i did not include npm publish in the semantic release step. When that didn't work, i tried adding npm publish to check if that had something to do with the changes. But if you check the commit history, if everything works as expected it should have incremented the version number since i have pushed another commit with a feature commit tag  to trigger a version increment. So the order in that case is (first commit on the top)\n\nCommit kasunkv/sem-rel@ecf820f6a1757be94e6a5d83e27d529a3538a0bc => Initial Commit - No Build\nCommit kasunkv/sem-rel@7fb10643df902c168dde9118ab92a09515394432 => feat(hello): - Build Failed\nCommit kasunkv/sem-rel@6dce8ed68c64cbfe79c88079de8c04b000b2a7c7 => chore(build): - v1.0.0 was released. No npm publish\nCommit kasunkv/sem-rel@8865499212f105ba708e12a09f0f7c7135ed4bdb  => feat(method) - Version Increment Failed (Version should have been v1.1.0). No npm publish\nCommit kasunkv/sem-rel@f698f4fd54b869081f5304618c5c5234a702d618  => feat(method) - Version Increment Failed (Version should have been v1.2.0). No npm publish\nCommit kasunkv/sem-rel@b853ce1f2d606d35b96da2cfaf5506d43c994ee5 => chore(build) - Version Increment Failed (Version should have been v1.2.0). No npm publish\nCommit kasunkv/sem-rel@e35192366c0e26eaf87ed6bd2679906e0323eaa6 =>chore(config) - Version Increment Failed (Version should have been v1.2.0). npm publish included.\n\nIf my understanding is correct and assuming npm publish is not required for semantic releases. at the commit kasunkv/sem-rel@8865499212f105ba708e12a09f0f7c7135ed4bdb the v1.1.0 should have been released to GitHub and at the commit kasunkv/sem-rel@f698f4fd54b869081f5304618c5c5234a702d618 the v1.2.0 should have been released.\nAm i right on this assumption?. ",
    "sukazavr": "@vanduynslagerp i'm on my way. @vanduynslagerp yeah! It helped! Thank you so much for the help and blazing fast reaction \ud83d\udc4d. ",
    "scamden": "isn't the || true kind of a hammer? what if something legitimately fails during deploy like a network connection error to npm? now my deploy appears to have succeeded when really it failed? definitely interested in a more nuanced solution. thank you :)\nOn Wed, 24 Jan 2018 at 11:14 Pierre Vanduynslager notifications@github.com\nwrote:\n\nSince several releases semantic-release doesn't returns with 1 when no\nrelease has to be done.\nJust upfate to a recent version and remove the || true\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/semantic-release/semantic-release/issues/449#issuecomment-360242035,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABE5mLqq6lvJFh9Lnh7JrxjWZr4mXDRyks5tN4EAgaJpZM4PmqAT\n.\n. \n",
    "codecov-io": "Codecov Report\n\nMerging #453 into caribou will decrease coverage by 2.98%.\nThe diff coverage is 97.82%.\n\n\n```diff\n@@             Coverage Diff             @@\ncaribou     #453      +/-\n===========================================\n- Coverage    90.19%   87.21%   -2.99%   \n===========================================\n  Files            9       10       +1   \n  Lines          204      219      +15   \n  Branches        42       47       +5   \n===========================================\n+ Hits           184      191       +7   \n+ Misses          20       18       -2   \n- Partials         0       10      +10\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| src/lib/get-version-head.js | 100% <100%> (\u00f8) | |\n| src/lib/get-commits.js | 96.42% <96%> (-3.58%) | :arrow_down: |\n| src/index.js | 66.25% <0%> (-10.5%) | :arrow_down: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update cbb51a4...ee6d047. Read the comment docs.\n. # Codecov Report\nMerging #504 into caribou will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@          Coverage Diff           @@\ncaribou   #504   +/-\n======================================\n  Coverage      100%   100%         \n======================================\n  Files           15     15         \n  Lines          276    278    +2   \n  Branches        45     46    +1   \n======================================\n+ Hits           276    278    +2\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| src/lib/get-commits.js | 100% <0%> (\u00f8) | :arrow_up: |\n| src/lib/logger.js | 100% <0%> (\u00f8) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 018835f...384f192. Read the comment docs.\n. # Codecov Report\nMerging #515 into caribou will not change coverage.\nThe diff coverage is 100%.\n\n\n```diff\n@@          Coverage Diff           @@\ncaribou   #515   +/-\n======================================\n  Coverage      100%   100%         \n======================================\n  Files           15     13    -2   \n  Lines          276    248   -28   \n  Branches        45     47    +2   \n======================================\n- Hits           276    248   -28\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| lib/debug.js | 100% <\u00f8> (\u00f8) | |\n| lib/logger.js | 100% <\u00f8> (\u00f8) | |\n| lib/get-version-head.js | 100% <100%> (\u00f8) | |\n| lib/plugins/definitions.js | 100% <100%> (\u00f8) | |\n| lib/get-next-version.js | 100% <100%> (\u00f8) | |\n| lib/plugins/index.js | 100% <100%> (\u00f8) | |\n| index.js | 100% <100%> (\u00f8) | |\n| cli.js | 100% <100%> (\u00f8) | |\n| lib/git.js | 100% <100%> (\u00f8) | |\n| lib/get-commits.js | 100% <100%> (\u00f8) | |\n| ... and 10 more | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 3326083...30ad3cf. Read the comment docs.\n. \n",
    "shroudedcode": "@pvdlg\n\nWould you know by any change where to find documentation about how to do that with apm?\n\nYes, here (on apm's REST API) and by running apm help.\n\nWould you be interested in developing such plugin?\n\nI'll try. I've already cloned your npm plugin and started adapting it. I will push it to GitHub soon.. @pvdlg Here it is.. @pvdlg @gr2m Could you please take a look at this issue? I need some feedback and help.\n(I already tagged you on the issue but don't know whether you were notified.). > I'm very interested in rolling this out to many of the AtomLinter packages.\n@keplersj I'm really excited to see interest from one of the most popular Atom package organizations on this. It would be great if we could make automated deployment the standard in the Atom community.. ",
    "keplersj": "With #553 merged in and published what is needed to have a shareable APM config published as discussed here https://github.com/shroudedcode/semantic-release-apm/issues/4#issuecomment-353410272? I'm very interested in rolling this out to many of the AtomLinter packages.\nref: https://github.com/AtomLinter/Meta/issues/18\ncc: @Arcanemagus. I should be able to test out the plugin soon. My startup does CD on GitLab for a few of our projects. The preset isn't super helpful for me at this point.. I should be able to reference by branch.\n  . ",
    "Arcanemagus": "Oooo, this is going to be amazing if we can use that as full protection can finally be enabled on the master branch while still letting collaborators publish releases!. I'm seeing this as well, the only change from the last build being https://github.com/AtomLinter/atom-linter-pug/pull/37 which updates to semantic-release@15.0.1/@semantic-release/apm-config@2.0.0.. > I think I pushed an update to master while the CI build was created on Travis, probably quite an edge case.\nThis isn't too edge of a case, it's pretty easy to hit if you are working on multiple PRs, don't require the PR to be up to date with master, and merge two close enough together that the CI build of the first to be merged hasn't hit the deploy stage before the second one is merged. (The cause of #754). Ah, definitely a dupe of #709, sorry!\nHopefully future people searching for what I did will find this and be directed there \ud83d\ude09.. Ah ha! It looks like the repository definition wasn't quite correct, leading it to not recognize the repository!. Yea, I've had to add .git on the end of all the repos so far. This is one of the 2 that I haven't done personally and I forgot to check it myself.. Your test job is running on the node_js image just like these builds, so it's not the image itself at least.. Confirming that adding it at least fixed the build.. The only environment variables that I've specified are ATOM_ACCESS_TOKEN and GITHUB_TOKEN, so that would have to be something from Travis itself.\nNote that I see this on all the builds I've done so far, this just happened to be a recent example.. Interesting, it must be something on Travis's part then, as this script is the only thing running there and it doesn't set any variable that would match that.. ",
    "codecov[bot]": "Codecov Report\n\nMerging #458 into caribou will increase coverage by 0.22%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff             @@\ncaribou     #458      +/-\n===========================================\n+ Coverage    87.21%   87.44%   +0.22%   \n===========================================\n  Files           10       10            \n  Lines          219      215       -4   \n  Branches        48       48            \n===========================================\n- Hits           191      188       -3   \n  Misses          18       18            \n+ Partials        10        9       -1\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| src/lib/get-version-head.js | 100% <100%> (\u00f8) | :arrow_up: |\n| src/lib/get-commits.js | 100% <100%> (+3.57%) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 8e9d9f7...e7f74f1. Read the comment docs.\n. # Codecov Report\nMerging #461 into caribou will not change coverage.\nThe diff coverage is 100%.\n\n\n```diff\n@@           Coverage Diff            @@\ncaribou     #461   +/-\n========================================\n  Coverage    87.21%   87.21%         \n========================================\n  Files           10       10         \n  Lines          219      219         \n  Branches        47       48    +1   \n========================================\n  Hits           191      191         \n  Misses          18       18         \n  Partials        10       10\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| src/lib/plugins.js | 100% <100%> (\u00f8) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 90417c6...ac53607. Read the comment docs.\n. # Codecov Report\nMerging #491 into caribou will not change coverage.\nThe diff coverage is 100%.\n\n\n```diff\n@@          Coverage Diff           @@\ncaribou   #491   +/-\n======================================\n  Coverage      100%   100%         \n======================================\n  Files           15     15         \n  Lines          278    280    +2   \n  Branches        43     46    +3   \n======================================\n+ Hits           278    280    +2\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| src/lib/logger.js | 100% <100%> (\u00f8) | :arrow_up: |\n| src/cli.js | 100% <100%> (\u00f8) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 8a1dd7b...feb11b2. Read the comment docs.\n. # Codecov Report\nMerging #494 into caribou will not change coverage.\nThe diff coverage is 100%.\n\n\n```diff\n@@          Coverage Diff           @@\ncaribou   #494   +/-\n======================================\n  Coverage      100%   100%         \n======================================\n  Files           15     15         \n  Lines          280    278    -2   \n  Branches        46     46         \n======================================\n- Hits           280    278    -2\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| src/lib/get-commits.js | 100% <100%> (\u00f8) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 186950a...5da9b45. Read the comment docs.\n. # Codecov Report\nMerging #506 into caribou will not change coverage.\nThe diff coverage is 100%.\n\n\n```diff\n@@          Coverage Diff           @@\ncaribou   #506   +/-\n======================================\n  Coverage      100%   100%         \n======================================\n  Files           15     15         \n  Lines          278    276    -2   \n  Branches        46     45    -1   \n======================================\n- Hits           278    276    -2\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| src/lib/get-version-head.js | 100% <\u00f8> (\u00f8) | :arrow_up: |\n| src/lib/logger.js | 100% <100%> (\u00f8) | :arrow_up: |\n| src/lib/get-commits.js | 100% <100%> (\u00f8) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 94b00e2...d87b3f5. Read the comment docs.\n. # Codecov Report\nMerging #519 into caribou will not change coverage.\nThe diff coverage is 100%.\n\n\n```diff\n@@          Coverage Diff           @@\ncaribou   #519   +/-\n======================================\n  Coverage      100%   100%         \n======================================\n  Files           13     13         \n  Lines          248    248         \n  Branches        47     47         \n======================================\n  Hits           248    248\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| lib/get-next-version.js | 100% <100%> (\u00f8) | :arrow_up: |\n| lib/plugins/definitions.js | 100% <100%> (\u00f8) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update d548edc...2e3a3b5. Read the comment docs.\n. # Codecov Report\nMerging #520 into caribou will not change coverage.\nThe diff coverage is 100%.\n\n\n```diff\n@@          Coverage Diff           @@\ncaribou   #520   +/-\n======================================\n  Coverage      100%   100%         \n======================================\n  Files           13     13         \n  Lines          248    245    -3   \n  Branches        47     48    +1   \n======================================\n- Hits           248    245    -3\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| lib/plugins/definitions.js | 100% <\u00f8> (\u00f8) | :arrow_up: |\n| lib/plugins/index.js | 100% <100%> (\u00f8) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update facdada...deee205. Read the comment docs.\n. \n",
    "meodai": "@pvdlg I did thanks you. Am I the only one with this issue? If not a entry in the readme could be cool. ",
    "nazreen": "So the subsequent release is dependent on it being published on NPM? Is it right that semantic release would push a release on github on every commit? Or how does it calculate when to release? . ",
    "johnnyBira": "Thank you for clarifying @pvdlg. I'll give this a shoot.. ",
    "mamboer": "@pvdlg hi, this's the latest builds https://travis-ci.org/mamboer/hexo-renderer-scss/builds/285981654. @pvdlg Thanks so much, i disable the cache and it works.. ",
    "ryansmith94": "Hey guys, thanks for the quick replies, sorry that I've been so slow to reply here.\nRe @gr2m reply:\nSteps to reproduce the error\n\nCreate a pull request in a repository with Semantic Release and Travis.\nClick \"Merge pull request\" to \"Create a merge commit\".\nChange the short commit description to \"fix(scope): Message\". This is what I mean by \"a merge commit with a Commitizen commit message\".\nDelete the long commit description.\nClick \"Confirm merge\".\nWait for the Travis CI build to finish on the master branch.\nView the releases for the Github repository.\n\nExpected Behaviour\nA new patch release is created with release notes that contain details of the fix based on the short commit description above.\nActual Behaviour\nA new patch release is created without details of the fix in the release notes.\nRe @pvdlg reply:\nThanks for the links and explanation of how it should work, I'm going to have a look at the links now.. To be clear I'm creating the merge commit instead of squashing because I want the author to retain credit for their code. I'm using a Commitizen (conventional) commit message so that Semantic Release is able to make a new release of the correct type (patch/minor/major), because the commits within the PR don't use Commitizen (conventional) commit messages, hence they would not enable Semantic Release to make a new release.. I just tried using the default short commit description that Github provides, then tried setting the long commit description to \"fix(scope): Message\", but that didn't actually make a release.. Yeah the repo URL is https://github.com/xAPI-vle/moodle-logstore_xapi.\n\nAn example of a PR that I merged would be xAPI-vle/moodle-logstore_xapi#139.\nThe merge commit for that PR is 3b599d4.\nThe release was v2.1.5.\n\nThe release notes for that release were originally generated to be the following.\n\n\n2.1.5 (2017-10-11). #### Re \"So semantic-release behave as expected\"\nI don't really understand why it creates the correct release using that commit message in xAPI-vle/moodle-logstore_xapi@3b599d4, but doesn't use the commit message for the release notes, that certainly wasn't what I had expected.\n\nRe: according to the commit history of your repo, it's like if you were doing a squash\nThat's not correct. The commits from the PR are in the master branch commit history.\nRe: Advise\nI think forcing people to use a commit convention in order to make a PR would create an unnecessary barrier for contributors to climb, some of which in our case will be using Github for the first time. Most of the pull requests would probably have to be resubmitted with correct commit messages.\nI think the only solution here, would be pushing an empty commit with the correct format into the pull request which isn't ideal.. > The commit xAPI-vle/moodle-logstore_xapi@3b599d4, with commit message fix(AssignmentGraded): Corrects actor format. (#139 - thanks @Nicosoft) is in the release note for 2.1.5.\nI don't understand what you mean by \"but doesn't use the commit message for the release notes\" ?\nIt's only there because I edited the release notes to contain that, notice that it doesn't have the commit link that it would have had if Semantic Release had included it. I posted the original release notes before my edit above.\n\nThere is tools like https://github.com/commitizen/cz-cli that can help with that\n\nThanks, we actually use that elsewhere, but we only expect our internal engineers to use it.\n\nIf you would do so, only this empty commit would be analyzed by semantic-release and included in the release note.\n\nYeah like I said, it's not ideal, but it does workaround the issue.\n. Nice! Good digging @pvdlg! \ud83d\udc4d Thanks for taking your time to figure that out.\nThat's awesome, I'll subscribe to #460. Yeah it would seem that not using that --no-merge would be the only way to keep the two things consistent. \nAwesome, thanks @pvdlg!\nIs there a workaround right now that would allow me to turn off the no-merge flag until #460 is resolved?. Hey guys, any thoughts on whether there is a workaround right now to pass the no-merge flag down?. No worries \ud83d\ude04 Ok. That's awesome, thanks \ud83d\udc4d . Hey @gr2m, awesome nice work guys! \ud83d\udc4d  yeah I already upgraded this morning (Renovate is awesome - I would recommend it). Yeah I think this issue can be closed, I've not tested it, but looking at the code in #480 (src/index and lib/github-release) it appears to be resolved :smile: I'll reopen if I noticed the problem persists.. Okay thanks @pvdlg. I'll reopen this issue until that is merged then.. Haha sorry, I just saw that PR got merged, closing again :smile:. This sounds awesome guys. The plugin mechanism you've made is pretty great and it seems perfect to reuse it here \ud83d\udc4d . In the case of the token issues, is it possible for plugins to throw a common error (like the SemanticReleaseError) that can be caught safely here and then continue to run the other plugins?. Ah sorry I misunderstood the issue. Sounds like the plugin idea would be best. Something like publishConditions where they all have to be met in order to run the \"publish\" plugins.. Yeah sure thanks @gr2m \ud83d\udc4d . Config in package.json\njs\n  \"release\": {\n    \"verifyConditions\": [\n      \"@semantic-release/github\",\n      \"@semantic-release/npm\" // Also fails without this.\n    ]\n  }\nDev Deps\n\"@semantic-release/github\": \"2.0.0\",\n\"@semantic-release/npm\": \"2.0.0\",\n\"semantic-release\": \"11.0.0\". Reverted back to Semantic Release 10 and I'm still seeing the issue \ud83d\ude22 \nhttps://circleci.com/gh/LearningLocker/xapi-service/241. Yeah npm is installed, we're just using the Node 8.8.0 Docker Image, that hasn't changed since our upgrade to Semantic Release 11. I have a build with Semantic Release 10 working fine in CircleCI.\nYeah sure, two minutes.. Yeah, that's fine, I took out the custom plugin we were using.. https://circleci.com/gh/LearningLocker/xapi-service/245. Okay, connected with SSH, the .npmrc file is being created incorrectly as\n```\n//registry.npmjs.org/:_authToken = ${NPM_TOKEN}\n``. There's no .npmrc in the home directory. I can confirm that correcting the .npmrc works. Seems to me that there is something trying to pipe//registry.npmjs.org/:_authToken = ${NPM_TOKEN}that into the .npmrc file and maybe the${...}syntax isn't supported in CircleCI.. Hmmm having said thatecho \"//registry.npmjs.org/:_authToken=${NPM_TOKEN}\" > .npmrcworks fine.. Okay runningnpm whoamiwith//registry.npmjs.org/:_authToken=${NPM_TOKEN}in the .npmrc correctly returns my username. Maybe, this works when I used Semantic Release 10 though..await execa('npm', ['whoami']);` is successful when running the following in Node.\njs\nconst execa = require('execa');\nexeca('npm', ['whoami']).then(() => console.log('success')).catch((err) => console.error('error', err)). Interesting that name is undefined here.\nsemantic-release:config name: undefined +0ms\n  semantic-release:config branch: 'master' +0ms\n  semantic-release:config repositoryUrl: 'git+https://github.com/LearningLocker/xapi-service.git' +0ms\n  semantic-release:config analyzeCommits: undefined +0ms\n  semantic-release:config generateNotes: undefined +0ms\n  semantic-release:config verifyConditions: [ '@semantic-release/github', '@semantic-release/npm' ] +0ms\n  semantic-release:config verifyRelease: undefined +1ms\n  semantic-release:config publish: undefined +0ms. https://circleci.com/gh/LearningLocker/xapi-service/248. I wonder if condition-circle was somehow loading the env and giving node access to it? https://github.com/bahmutov/condition-circle/blob/master/src/condition-circle.js. So taking that out has caused issues perhaps. I'm going to see why condition-circle is breaking things, try to fix that and see what happens.. Still broken \ud83d\ude1e https://circleci.com/gh/LearningLocker/xapi-service/251. Interestingly I don't see anything logged by the function I wrote.\n./condition-circle.js\n```js\n'use strict'\nconst log = require('debug')('condition');\nconst spawn = require('cross-spawn');\nconst { join } = require('path');\nconst safeEnv = require('safe-env');\nconst SemanticReleaseError = require('@semantic-release/error');\nmodule.exports = async (pluginConfig, { options: { branch } }) => {\n  const script = join(__dirname, 'condition-circle-refs.sh');\n  spawn.sync(script, [], { stdio: 'inherit' });\nif (process.env.CIRCLECI !== 'true') {\n    throw new SemanticReleaseError('Not running on Circle CI');\n  }\nif (branch !== process.env.CIRCLE_BRANCH) {\n    throw new SemanticReleaseError(\n      Running on '${process.env.CIRCLE_BRANCH}' not '${branch}'\n    );\n  }\n};\n```\n./condition-circle-refs.sh\n```sh\n!/usr/bin/env bash\nset e+x\necho \"Getting git refs\"\ngit show-ref --head --heads | while IFS=' ' read -r hash name;\ndo\n  echo \"ref $name hash $hash\"\n  test ! -e \"${GIT_DIR:-.git}/$name\" && echo $hash > \"${GIT_DIR:-.git}/$name\";\ndone\necho \"//registry.npmjs.org/:_authToken=${NPM_TOKEN}\" > .npmrc && npm whoami\necho \"All done\"\n``. Sure \ud83d\udc4d . Same result https://circleci.com/gh/LearningLocker/xapi-service/260. Hey guys, sorry for the late reply, I was on holiday today. I can confirm that running it withnpminstead ofyarn` solves the issue. https://circleci.com/gh/LearningLocker/xapi-service/266. Wow awesome!!! Thanks guys, amazing work as usual, really appreciate it! \ud83d\udc4d\nI'll create a PR for the condition-circle plugin later today for other Circle users, if it's not merged in the next day or so I'll fork their repo and publish it to npm. In the meantime, I'm using the snippet below.\n- deploy:\n          name: Semantic Release\n          command: |\n            if [ \"${CIRCLE_BRANCH}\" == \"master\" ]; then\n               yarn semantic-release || true;\n            fi. Here is the PR for condition-circle https://github.com/bahmutov/condition-circle/pull/5.\nYeah @pvdlg, it works great! \ud83d\udc4d . Interesting, yeah sure.. So CircleCI is using 2.1.4 apparently https://circleci.com/gh/HT2-Labs/semantic-release/10. Going to try using Circle's pre-built Node image instead, I'm sure that'll have a newer version of Git.. I was wrong, still using 2.1.4 \ud83d\ude1e . Just made my own plugin instead https://github.com/HT2-Labs/semantic-release/blob/master/plugins/getLastRelease.js. Oh okay @pvdlg, I wasn't going to worry you guys with it, I thought it was just an issue with my particular setup.. Hey @pvdlg, wow that's interesting. Yeah sure, I'll raise an issue over there, thanks for digging into this, really appreciate it.\nBrilliant, yeah might be a good idea to avoid the merge in the meantime. When I create the issue I'll link back here \ud83d\udc4d . Alright they're not going to update it https://github.com/circleci/circleci-images/issues/128#issuecomment-351780040. Yeah definitely worth trying.\nAwesome, thanks @pvdlg, I'll give that a go \ud83d\udc4d  I'll try to test it later today, but I'll reply in here when I've tried it.. Hey @pvdlg, the last commit in the semantic-release/git repo didn't create a new release because of an invalid NPM token on Travis. https://travis-ci.org/semantic-release/git/jobs/316572537#L630. No worries. Yeah it's all working great thanks @pvdlg \ud83d\udc4d . ",
    "DeividasK": "Unfortunately, can't do this, because it is a private repo \ud83d\ude41 . You can find my attempts to run the command below:\n\nTo be more clear about what I meant when I said the above - I've tried running semantic-release ss above, and that didn't give me any errors.. Hmm, that may be it (because I did this with semantic-release command locally), thanks! Will double check this on circle.\nDo you know the reason why it can't run from <repo_root>?. I've checked this in circle, but this didn't change the situation.\n\nLet me know if there's something else you can think of for me to try (I've also opened a support ticket with circle).\n. Here's the output of running npm run semantic-release (semantic-release pre && npm publish && semantic-release post):\n\n. @pvdlg thanks for the update!\nI've changed my circle CI build to do semantic-release instead of yarn semantic-release (which runs the predefined script) and it works fine.\nSo it seems that semantic-release script does not seem to be necessary (?), because when I run that semantic-release pre part of the script just outputs help commands and finishes.\nPersonally I consider this issue to be closed.. ",
    "wejendorp": "Yes no problem.. I'm seeing this error as well, and despite running the fix-838 branch, I still get the local branch x is behind the remote one.\nMy git remote is set to SSH url, but the ls-remote check is using an https url, and so the auth fails both with and without auth afaict.\ngit ls-remote https://[secure]@github.com/org/repo.git master # fails because bad token\ngit ls-remote https://github.com/org/repo.git master # fails because private repo\ngit ls-remote git@github.com:org/repo.git master # works but is not used\nI hope this is helpful. Let me know if I can provide more details.\n\ud83e\udde1 I just updated from using semantic-release@8 to 15.x on a project, and I love the new verbosity and execa(npm) based plugins. It really feels much more transparent and nice. With invoking npm I'm no longer hitting new config issues with certs etc. \ud83e\udde1. Thanks for the quick fix. Now I'm getting the EGITNOPERMISSION error when I mess up my token, thank you!. ",
    "aliatsis": "I guess the use case I was describing with npm install is only an issue if you push the version changes from CI, then pull locally.\nNevertheless, shouldn't the npm published package-lock.json match the published package version when the package is installed into a dependent?. ah ok thanks for the help. no issue here then.. ",
    "zeke": "\nThe first log you mentioned seems to be a build that happened on the release-bump branch \n\nYou're right. I have edited the original post to remove that tangential detail. Thanks!. Yeah looks like we're back on track. Thanks for the quick responses.\nWhere would be a good place to document the process for debugging release failures? I can take a shot at that.. Yeah let's keep it open. I will try to get to it! :). Thanks @pvdlg! Sorry for my poor opensourcepersonship here. \ud83d\ude05 . Thanks for the reply @pvdlg. \ud83d\udc4d \nIs there a way to \"retry\" a Travis build so it will re-trigger semantic-release, or is it necessary to create a new \"fake\" PR to try again?. Ok I will give it another go and report back.. Ahhh. So that API call doesn't follow redirects?. ",
    "FuzzOli87": "The ability to customize the publish/release would be a huge plus. That means we could use it to version app docker images for instance!. @pvdlg I don't have much in the way of documentation since it's pretty theoretical. However, the huge benefit in my opinion is the automation of release-notes creation and tagging on GitHub. If I'm creating an Node webserver for example, those can be crucial and makes it easier for developers to keep track of their work.\nIn that sense, I don't think the dependence on a package.json file is a big deal, at least since I'm imagining just Node applications at the moment.\nAs far as releasing docker images, I imagine this is CI/CD dependent so I'm going to talk about using Codefresh.\nIt works like most other CI/CDs, it watches a repo, does things when changes happen. It also allows us to dynamically create environment variables that it can then use when creating the final image before pushing it to a image repository.\nSo I imagine that being able to configure the \"publish\" step so that instead of publishing to NPM, it would run a custom script and pass things like the new version information, which we can then use to create an environment variable so that when Codefresh is ready to create the image, it would tag the final image with the version that semantic-release created.\nBeing able to handle the metadata in some way(maybe the publish step instead writes a file) after doing everything else like updating github etc would open the door to many types of uses.\nI'll try and emulate this through a Dockerfile to use as an example soon. . @pvdlg \nTo create a Docker image to be released to a Docker repository, it's a simple matter of running a command docker build -t <imagename>:<tag> . So, for example docker build -t test-app:1.2.4 . Then to publish it it's just a matter of running docker publish test-app:1.24 and thats it! That is the process Codefresh goes through.\nSo, the plugin can be many things. It can be dedicated to execute these commands, or just a generic plugin that passes in meta data like the new version semantic-release came up with and any other relevant information and I can use that information to create a file that then Codefresh could use to extract tag information from, or heck I can even create new environment variables that Codefresh can use when tagging the image.\nThe most important information for the publishing of docker images would be the version number. Then we can do with the information whatever we want as a generic plugin or it opens the door for developers to write custom plugins for certain CI/CDs etc.\n. ",
    "raix": "I'm currently trying to follow along adding support for vs code extensions and meteor packages:\n semantic-release-meteor\n semantic-release-vsce\nQuestion would it be possible to load a release config from the cli?\n@pvdlg Looking forward to the mods :). @felixfbecker I haven't tested it yet - but will work on it in 2 hours - I need to make sure semantic-release and the getLatestsVersion works correctly. (ref: vsce show command). thanks @pvdlg I'll have a look at it and try to align code for adapters for meteor and vs code extensions. @pvdlg both are implemented and in use - we didn\u2019t have the time to update to the v13 plugin api yet.\n(I also had some concerns re the plugin architecture, but havent had the time to dig deeper) . @pvdlg https://github.com/raix/semantic-release-vsce have been upgraded to v12 by @felixfbecker so that might be ready to add in documentation,\nI still need to upgrade https://github.com/raix/semantic-release-meteor. ",
    "simlu": "I can't find where any documentation on how to use this to only publish to github (and not npm). Ideally this would be a cli option to disable npm release. How do I achieve this?\nBasically I want to run semantic-release-cli setup, but not publish to npm.. @pvdlg This is no longer true with package-log.json in later node version - whatever is written in the package-log.json is being installed and the file only changes when the dependencies change.\nIn that case this vulnerability might not concern you. However it still came up in my project - so better to fix it and prevent other people running into it.. Very interesting discussion in deed!\nHere is my point of view on this: We pin every dependency and don't use version ranges. When a new dependency is released we use greekeeper + travis + octoscript + semantic-release to test and immediately publish a new version of the module (everything fully automated). If the dependency update causes a test failure, no new version is release and we are notified about it and can fix it manually.\ntldr; I don't trust people. They releases minor version updates with breaking changes all the time. Great way to get bitten in the behind.. @pvdlg I understand your reasoning. This all circles back nicely to this PR. Let me explain our side.\nAssume a dependency X of module A get's a minor version update with a critical fix for your module A. No new version of module A get's released. Hence there is a no way for a module B that uses module A to know that something critical has changed (since module A still has the same version). We simply prefer to make changes transparent to all the modules that use our modules.\nExactly the reasoning why we want this PR to be merged and a new version of semantic-release to be released. This prevents some users from having the current semantic release version with an old install and other users using the same semantic release version with a new install. The version are the same, but the functionality is different.\nThe main argument against this is \"release overhead\", but if that is all automated it mainly goes away. But this is opinion based. I don't think that part of npm is \"great\" - this was simply a fix for problems people had \"release wars\", but it's not necessarily the best solution.\nYou have a great point there wrt to package-lock.json and we might just abandon it until greenkeeper also updates and fully supports it.. @pvdlg I think you misunderstood my point. Leaving out the lock file entirely, the problem I have with version ranging is that you no longer differentiate between dependency versions, but between install times. Basically you would have to constantly re-install all your dependencies, because a sub-dependency could have updated - even if non of your direct dependencies updated. And yes, that's how it was designed for npm - it doesn't mean we have to like it.\nAnyways, thanks for merging :). > Obviously the 3rd choice is not reasonable. That was my point in this thread.\nAh, I'm finally getting it.\nConversely downstream in this example: Even though you updated the marked dependency in semantic-release there is no reason why a project using semantic-release would update semantic-release (and dependencies) unless you do a major version update as well (as they might be using ^).\nLots of food for thought here... Thank you for this discussion!. We just ran into the same issue. Hard one to debug :) Since we do heavy enforcement through js-gardener we'll update that there... https://github.com/blackflux/js-gardener/issues/249. Honestly I thought the npm build artifact should be uploaded to github by default. Ideally there would be an option for that.\nIf I understand correctly we need to create and define artifacts manually for now?\nSo how about the following config:\njson\n{\n  \"npmPublish\": false,\n  \"publish\": [\n    {\n      \"path\": \"@semantic-release/github\",\n      \"assets\": [\n        {\n          \"path\": \"release.tar.gz\",\n          \"label\": \"Release Artifact\"\n        }\n      ]\n    }\n  ]\n} \nand then build the artifacts as \njson\n{\n  \"scripts\": {\n      \"clean-build\": \"...\",\n      \"build-artifact\": \"npm run clean-build && tar -zxvf $(npm pack) && rm *-0.0.0-development.tgz && tar -zcvf release.tar.gz package/* && rm -rf package\",\n      \"semantic-release\": \"npm run build-artifact && npm run clean-build && npx semantic-release\"\n  }\n}\nDoes that sound about right?. @pvdlg Thank you very much for your detailed reply! This cleared up a lot for me!\nFor anyone looking at this in the future, the above works as expected (you might want to get rid of the top level package folder though in the tar.gz).\nClosing this since resolved. Cheers!. I would very much like to see this feature as well if that is still on the table: semantic-release --print-next-version\nI can probably hack around it, but it would make my life a lot easier!. @travi Oh I'm sure I can do it using exec. However that will require me to juggle with multiple .releaserc.json files. The use case it: On dev branch do a release as circleci artifact with the release number as eg 1.2.3-rc1, 1.2.3-rc2, etc and on master branch do a release as github artifact as 1.2.3.. @pvdlg Uhm what? How is that now related? Sorry I don't understand how pre release is related to this conversation... Edit: Thanks for trying to help though!. @pvdlg Ah, I see where the confusion comes from then. I can not use semantic release to release as circle ci artifacts since that can't be done as a terminal command. It's configured in the circle ci config directly. So the rc postfix format was just an example for naming.\nHence unfortunately that will not solve my use case.. @travi I've put a PR up here: https://github.com/semantic-release/semantic-release/pull/1076\nIt seems the skipTag is necessary unfortunately, unless I'm missing something. . There is a \"hacky\" workaround here. Basically create a folder e.g. release with a .releaserc.json and the content\n{\n  \"plugins\": [\"@semantic-release/commit-analyzer\"],\n  \"verifyConditions\": false,\n  \"prepare\": [{\n    \"path\": \"@semantic-release/exec\",\n    \"cmd\": \"echo -n \\\"${nextRelease.version}\\\" > version.txt && exit 1\"\n  }],\n  \"npmPublish\": false,\n  \"publish\": false,\n  \"fail\": false,\n  \"success\": false\n}\nThen run (cd release && semantic-release --branch=$BRANCH_NAME) || true where $BRANCH_NAME is the environment variable containing your branch name.\nThis will work on any branch. The downside is that you don't get immediately notified / debug information when / if something goes wrong. So you might want to check for the presence of version.txt after.. @pvdlg As described it comes down to the fact that we can not use semantic-release to store CircleCi artifacts, since this is not done via a terminal command.\nThe requirements are:\n1. We want to build an artifact that internally includes the release version, so when it's run by a user it's immediately clear (1) what release version this was going towards, i.e. it's clear when something is outdated and (2) what CircleCi build number is associated, i.e. it's easy to debug where the artifact came from exactly\n2. Store the artifact in CircleCi\n3. Use a version number that includes the CircleCi build number as well as the upcoming release number for above reasons.\nPlease let me know if you have any further questions about this use case!\nI'm ok with the \"hack\" that I have in place. It is a hack, but should continue to work going forward unless something fundamentally changes with plugin handling.. @jhabdas Possibly. That depends if @pvdlg thinks it belongs into one.. @thekiwi We still use our approach that I've outlined above and it works great. Should work well for your use case as well. Just uncollapse some replies!. The build is triggered by merging into master. I'll try circle ci and see what they have to say and get back here. Cheers!. Got a response when describing the above behavior to them:\n[...] The merge is part of the PR so these variables are expected to be set. The CIRCLE_PULL_REQUEST is specific to a forked PR and CIRCLE_PR_NUMBER references the specific PR or one chosen at random if there are multiples associated. More on this can be found in the built-in environment variables documentation. - Support CircleCI\nSo these are expected to be set. Do we need a flag --allow-on-pr? How should this best be solved?\nCheers, L~. Unfortunately the repo is private atm. I can probably set up a test case. But this might have to do with (2)?. @pvdlg I've put a pr up for now: https://github.com/semantic-release/semantic-release/pull/1076\nAs mentioned, using skipPrCheck solves my use case nicely. If you prefer to see a real world example of why this is necessary I might be able to set something up. If you are currently using circle it might be very easy for you to try it out though (the setup is very simple).. @pvdlg It appears that you didn't use a fork, which is crucial.. @pvdlg You need to set the option \"Build forked pull requests\" to \"off\" as I mentioned above.. @pvdlg Yes, that part is expected (does not build when you open the PR). But I'm really curious as to why the PR variables are not set for you... This is certainly not what I am seeing. Maybe it has something to do with private repos?\nI will do some digging tomorrow (it's really late here) and get back with some details!. And thank you very much for trying to reproduce this. I swear this is not a user (me) error. I'll proof it tomorrow.. For reference, these are my settings.\n\n. I tried to reproduce the behaviour with a separate public / private repo and tried a bunch of different things. I was not able to reproduce the behaviour that I'm seeing on my repo. \nHowever I can reliably reproduce the behaviour on my existing repo. Hence I'm considering this a CircleCi bug again. I will go back at their support.... #timesink #ffs. Their support got back to me:\n\nWe do have one known issue where the pull request variable can be set inadvertently. This happens when someone submits a pull request from a fork in this manner:\n\nFork the project\nWait for a change to the upstream to be made\nCreate a pull request on the fork requesting to merge the upstream's default branch into the fork\n\nFuture builds on the upstream project will have the CIRCLE_PULL_REQUEST variable set to the fork's new PR details. Is it possible someone could have created a pull request in this way on that project?\n\nThis doesn't appear to be my exact use case, but it indicates that they're not confident they figured all the cases out. The flow described doesn't seem to be that uncommon and is similar to what I was doing.\nI'm closing this issue. Hopefully it'll save someone else some time :(\n. I've finally figured out what is going on and can reproduce. The problem was / is that my circleci workflow creates a new pr in the first job. This then messes up subsequent jobs.\nI'll update this issue when I get more information from CirlceCI. I guess I should have formulated it as a feature request. Thanks for getting back to me. I'll try to figure it out I guess.. Haha, I get that and I was mostly kidding. No I was even considering filing it as a bug initially, but then changed my mind.\nIt just feels weird that you can set\n\"publish\": []\nbut then it still publishes. There might be something in the docs about it, but I haven't found it yet.\nI'll try to investigate the other channels you mentioned. Which one should I prefer?. @pvdlg Sure. I've mostly spend time on this since I'm now deploying using my fork. That works great for now.. @pvdlg No, that doesn't work. We might have multiple builds for the same \"upcoming\" semantic-release release (same version number with different build number). With your approach the repo would get tagged and the next time semantic-release runs no upcoming version would be returned. That's why I need the kill switch exit 1 as mentioned in the other thread..... @pvdlg I'm not arguing with that at all. However this is the equivalent of compiling your program. The prime example here is a mobile app:\n\nYou are not going to increase the version every time you compile, however the build number will\nYou might juggle a lot of different version and builds on your device. It's really, really handy to know the version of the app, plus the build number and the branch when you look at it.\n\nI'm not saying this needs to be supported (it works good enough for me now) and for npm packages your probably right to not care, but this is a real use case.. @pvdlg Fair enough. I guess aspirational versioning isn't for everyone :) Seriously though, I should maybe just look at the highest tag on the branch and use that instead. Something like this should work: https://stackoverflow.com/questions/1404796/how-to-get-the-latest-tag-name-in-current-branch-in-git#answer-5261470. ",
    "lirantal": "yeah I saw that issue and the work discussed there, but is there really a connection between the npm publish and the saving the new version in package.json?. Sure, I understand that. Although what is the reason for not updating package.json and commiting the change?. The FAQ doesn't convey the \"why\", it just states what is happening.\nI agree with the use of tags, but I think the \"complexity\" part of the CI is a technical gap, not really a reason not do it. Thing is, maintaining a project's version in package.json is a common thing for the ecosystem (even for projects that don't ship to npmjs).\nIf you are somewhat leaning towards my idea here, then I can suggest that instead of commiting directly, instead we can create a PR with the relevant changes (i.e: update the package.json with the new version, update a changelog file for example), etc. It will require a manual step of approve and merge which will effectively tag a new version.\nOr does it throw you off because it's not automatic anymore? :-)\n. If the npm client is any model to look up to, then if you do npm version patch it will:\n1. update package.json to a new patch version\n2. commit the change on the repo\n3. create the tag\nRegardless though, updating the version in package.json is even more important for Node.js projects which aren't pushed to a repository. Consider the following - a project could be a framework, which doesn't get pushed to npm as a library, but rather maintain on github as a source. If you don't maintain versioning in package.json then if a user wants to report a bug, how does he find which version they're on? maybe they can specify the commit hash, or check the tag they fetched originally - but none of this is a straightforward solution.\nMy own personal use case is that I read the currently deployed version of a Node.js API service from the packge.json file.\nMaybe this is out of scope for semantic-release.. right, so where do we stand on bumping the version in package.json? :-)\n. Cool, thanks!. You keep citing examples of why to avoid versioning in package.json, but I didn't see even one recommended way of solving the use-case I'm referring to :-)\n. ",
    "thezimmee": "I am just starting to use semantic-release, but the use case that @lirantal explained pretty closely describes the issue I am running into. I am creating a framework and use the version field of package.json to put into my distributed files. I just added semantic-release to the workflow, and now all of the distributed files have v0.0.0-development in them.\nI would certainly like my distributed files to show the version that a user is using. Does anybody have any suggestions for how to handle this? Using semantic-release, how do I get the version for a build to put into my distributed files?. @pvdlg Thank you for your help, much appreciated! You are correct that my build step (npm run build) currently runs before semantic-release. I have a prepush githook that runs the build locally in order to make sure tests pass and the build completes successfully before pushing anything to github.\nJust trying to think this through, so I think what you're suggesting is something like this:\n\nOnly npm truly needs the dist files and not source control, which means I can...\n...add dist files to .gitignore,\nand run the build in the prepublishOnly script (\"prepublishOnly\": \"npm run build\" in my case).\nDoing so will publish the dist files to npm via semantic-release/travis ci.\n\nSound about right? My assumption is that if I .gitignore the dist files, they will still be published to npm, so long as they are not in .npmignore, is that correct?\nBased on all this, it doesn't seem like there is a great way to get my dist files into github / source control (with the correct version), or am I wrong? Does/should this even matter? I can't think of a great reason why it does matter, though it makes me a little hesitant to have the dist files be so automated... I appreciate any thoughts you or anybody might have.. > My assumption is that if I .gitignore the dist files, they will still be published to npm, so long as they are not in .npmignore, is that correct?\nPer npm docs:\n\nIf there is a .gitignore file, and .npmignore is missing, .gitignore's contents will be used instead... Files included with the \"package.json#files\" field cannot be excluded through .npmignore or .gitignore.\n\nSo it looks if I .gitignore the dist folder I would need to make sure to have either 1) an .npmignore file, or 2) a files property in package.json to ensure the dist files get published to npm.\nAny suggestions on the rest of my questions/comments are much appreciated.. @pvdlg Thank you for helping me think it through!. Thank you for your help! I knew it had to be something stupid I was doing. It looks like that worked... I'm just getting a different error now. Here's the new log\nIt's a scoped package, and I have my NPM token set up in Travis, which is a correct token. So not sure what this is about... any ideas?\n\nRegarding 0.x releases...\n\nSee Can I set the initial release version of my package to 0.0.1... If you don't want users to download your package then don't release it.\n\nI had read the docs you linked to, which is what confused me in the first place. In addition to your suggestion (work on dev branch, merge to master when stable) Semantic Release suggests:\n\n\"In early development phase when your package is not ready for production yet we recommend to publish releases on a distribution channel (for example npm\u2019s dist-tags)\"\n\nThat would be nice, but NPM apparently requires the latest dist-tag to exist first; which would mean the package would have to be production ready the first time you publish.\nI think it's useful to sometimes publish in a \"pre 1.0.0\" state to be able to support initial development until it's stable. Yet Semantic Release says starting releases at 0.x is \"not supported... as it's not considered a good practice\". However, that is contrary to Semantic Versioning docs, which recommends using version 0.x for initial development:\n\n\"Major version zero (0.y.z) is for initial development. Anything may change at any time. The public API should not be considered stable.\"\n\nAlso:\n\n\"How should I deal with revisions in the 0.y.z initial development phase?\n\"The simplest thing to do is start your initial development release at 0.1.0 and then increment the minor version for each subsequent release.\"\n\nBased on this it seems to me 0.x initial development releases should be supported by Semantic Release. It seems Semantic Release wouldn't have to treat 0.x releases any differently if they left it up to the user to follow Semantic Versioning's suggestions and release everything as a \"minor\" release during initial development.\nUnfortunately for now, unless somebody has a better idea, I guess we're left with not using Semantic Release for the 0.x initial development phase, which is a bummer.\n\nAgain, thanks for your help, @pvdlg! I would love any ideas on the remaining issue.... K, prereleases is an option once available, though even that seems to make this much more difficult than this really is (I'm using a dist-tag channel already). At bare minimum the documentation needs to change to make the following clarifications:\n\n\nChange this line:\n\n\"This is not supported by semantic-release as it's not considered a good practice, mostly because Semantic Versioning rules applies differently to major version zero.\"\n\nto something like:\n\nSemantic Release considers this bad practice and will not support releasing to 0.x.\n\nIt simply is not correct to infer that Semantic Versioning considers publishing to 0.x a bad practice; their docs clearly recommend doing so. This should be clear.\n\n\nRemove the line that says:\n\n\"when your package is not ready for production yet we recommend to publish releases on a distribution channel (for example npm\u2019s dist-tags)\";\n\nHaving this line as a direct response to releasing to 0.x is very misleading. At least clarify that releasing to dist-tags can only be done after initial release to the latest dist-tag (making the resolution to the question being asked useless).\n\n\nHaving these simple clarifications would have saved me hours of searching through issues and documentation.\n\nRegarding the original issue, I updated my NPM_TOKEN and it published successfully. Thank you, again, for your help @pvdlg! Much appreciated!. Yes, sorry. Closed.. ",
    "fenduru": "Ultimately the contents of package.json are used to describe the information that is needed for the package manager to deal with that package, and tooling around package.json should be able to safely rely on that.\n@felixfbecker An example of this is Yarn's workspaces feature, whose behavior differs based on the version listed in package.json.\nThis project is already manipulating SCM by adding/pushing a tag, so it seems like there shouldn't be an issue pushing a commit from CI.\nHistorically my release workflow (and I'm sure this is true for most other projects) has been to manually bump package.json, commit, tag, push, npm publish. I think creating tooling to automate processes like this is great for reducing efforts and human error, but I don't think doing so should require going against longstanding conventions.. ",
    "stoffern": "https://github.com/stoffern/universal-app. I think the answer may be here: https://github.com/yarnpkg/yarn/issues/2739\nTrying to set it into development mode on Travis... removing yarn.lock and generating package-lock.json seems to fix it..\nYet there is a new error:\nWARN invalid config loglevel=\"notice\"\n[Travis Deploy Once]: There is only one job for this build.\nnpm WARN prepublish-on-install As of npm@5, `prepublish` scripts are deprecated.\nnpm WARN prepublish-on-install Use `prepare` for build steps and `prepublishOnly` for upload-only.\nnpm WARN prepublish-on-install See the deprecation note in `npm help scripts` for more information.. thanks \ud83d\ude09 \nYet there seems to be a problem using yarn. I will close this for now but it may be reopened if more people get this error in the future... ",
    "jeffijoe": "@pvdlg thank you! That makes perfect sense! \ud83d\udc4d \nHow about supporting pre-releases, such as 1.0.0-alpha.4? Is there a pending proposal for this?. ",
    "drazik": "There was already a NPM_TOKEN environment variable in the configuration on my repository in Travis CI. I tried to remove it, create a new token using npm token create, according to npm documentation and adding it again, but the problem was still the same.\nI found that the npm documentation says that I need to set the --access=public option in the npm publish command to be able to publish the package. I updated my npm semantic-release script to the following : \n\"semantic-release\": \"semantic-release pre && npm publish --access=public && semantic-release post\"\nAfter that, I got another issue :\nsemantic-release ERR! pre This test run is not the build leader and therefore a new version won\u2019t be published.\nThis seems to be related to https://github.com/semantic-release/semantic-release/issues/390. The error message says that \"a new version won't be published\" but a new version has been released.\nTo sum up, my issue was not about NPM_TOKEN, because semantic-release adds it to the Tracis CI repository settings, but about --access=public in the npm publish command, because I want to publish a scoped package.\nThanks for your help @pvdlg.. ",
    "priestine": "In case you have this problem, what helped me out was that I added\n\"publishConfig\": {\n    \"access\": \"public\"\n  }\nto my package.json. As for semantic_release script, I used\n...\n\"semantic-release\": \"semantic-release\"\nWorks like a charm now.. ",
    "paulocoghi": "For public packages under organizations, a simpler solutions is to use:\nnpm publish --access public.\n",
    "rodoabad": "Yes, I do have access to that org. I was just reading this right now.\n\nTo publish a public scoped package, you must specify --access public with the initial publication.\n\nDoes this mean I have to edit my script first and modify it to...\n\"semantic-release\": \"semantic-release pre && npm publish --access public && semantic-release post\". Good suggestion. Thanks. I've been meaning to use public scoped packages for awhile now.. ",
    "lakshyaranganath": "Awesome! Thanks for the quick turnaround \ud83d\udc4d \ud83d\udcaf . ",
    "unional": "Sure, no problem. \ud83c\udf37 \n. I think using 0.x.x has its place and not necessarily a bad thing, especially for open source projects.\nOpen Source projects can easily introduce breaking changes, partly because the consumer is more remote compared to an internal project that is used within an organization. You get the heat from your colleagues breathing through your neck when you introduce a breaking change.\nThe other half is the author tends to experiment things for his own use cases and just want to share the work to the world so other people MAY benefit from it. But as more use cases are identified, it is very likely the design and architecture of the project will change multiple times before the \"final\" design emerge.\nThat's why we see (IMO) many open source projects uses the 0.x.x scheme until it is stable.\nIMO, it is a nice way to state that the projects are still in \"initial development\" phase and breaking change can be more frequent than more matured projects.\nAnother reason I think open source projects use more of 0.x.x scheme because many of them are created in the spare-time. There are probably many features the author wants to add in but just doesn't have the time to do so.\nIf we move too soon to version 1.0.0, we will either see the major version craze (e.g. jest and react), or the innovation slows down because we want to keep the project more stable.\nMy two cents. \ud83c\udf37 \n. Definitely. \ud83d\udc4d \nI agree that for engineering (or, as engineers), we should un-tie our emotion from the version number.\nBut coming from business and company perspective, the stability of versions and the perception of \"stable major\" does have some value, even thou the value can be artificial or even \"harmful\" (as it slows down innovation). \ud83d\ude06 \nWhen a business sees a version 45.0.0, and the version follows SemVer, one response would be: \"this library introduces breaking changes 45 times in its lifespan. That means it breaks its consumers at least 45 times in the past. Should I let my team investing time in using this library? How likely would it introduce another breaking change that would cost both time and money for my business (to upgrade and keep code current)?\"\n\nAt least above 1.0.0, the semantics of each number is clearly specified.\n\nIf there is a SemVer 2.1 that improves the clarity of 0.x.y ... \ud83d\ude04 \nAgain, I'm in sync with you on promoting proper versioning, using SemVer, and let the machine deal with versioning. Just adding my two cents on the value of having better clarity and support of 0.x.y. \ud83c\udf37 \nSome mumbling:\nUncle Bob mentioned that the maturity of a library can be measured by how many libraries it depends on, vs how many libraries it is depended upon. But for open source projects, this is less true because the author can introduce breaking changes and bump the major version anytime.\nAt the end, the chance of introducing breaking changes is correlated to the complexity of the library. Mitigate strategies include: separation of concern, cohesion, coupling, dependency management.... i.e. better architecture and design at the component level.\nIn other words, for well designed, cohesive, and compact library with a single purpose, it is completely fine to do some brief initial development and starts its version from 1.0.0 \ud83c\udf89 . > author can introduce breaking changes and bump the major version anytime.\nI'm saying this not because of ranting. It is because I do that many times myself on my open source projects to figure out better naming and better API.\nThat's why I keep many of my open source projects under 0.x.y scheme.\nIn my own experience, it takes 0.8 to 0.20 to get things stable, on average. \ud83d\ude1b . Having used semantic-release for more than 6 months and on multiple packages, IMO the currently recommended workflow is not optimal.\nI'm planning to write up an article on it, but don't know when I'll have the time to.\nThe main issue with the current workflow is that it assumes \"deliverables are releasable\".\nBut the fact is this is just not true.\nOther issues include the workflow on dist-tag is not established, and the modification described in this PR is needed for it.\nI understand the stand of the team on \"version numbers are for machines, not humans\", but I disagree.\nThe word \"semantic\" itself means \"meaning\" and it directly implies those meaning carried in the \"semantic versioning\" should be meaningful to both human and machines.\n. One way to explain this is in Scrum, at the end of a sprint you have a deliverable product. But that does not mean you will release it.\nIt's similar to your wording that master is releasable but not released/deployed/published.\nBut the term releasable is confusing as it suggests the code is at a stage that can be released, but not necessarily true.\nFor example, you are writing a web app. Completing a feature \"login\" makes it deliverable (as all tests pass), but not releasable because it does not support an use case that is valuable to the user.\nThe same is true for libraries. You may complete a story of an epic, but until all stories in that epic are completed, it cannot be released.\n. I think we are basically on the same page.\nThe only difference is we are looking at two different products: app vs library,\nand we are talking about \"-able\" vs \"-ed\".\nFor app, you can have an additional step to do CD, but for libraries, you don't. Publish = Deploy.\nsemantic-release automates the publishing step, so for libraries, the \"publishable\" master branch is being published to the wild.\nAnd here are some comments to address other points:\n\ni suppose i should have expanded on this statement a bit further. while not necessarily deployed/published, it could be at any time. there should never be anything in master that would cause a problem if someone made the decision to release now.\n\nBut that someone, when using semantic-release, is the machine and it will always released the releasble. So with no human involved, this difference (\"while not necessarily deployed/published, it could be at any time\") is muted.\n\nif what is integrated into master exposes something to an end user that is premature, that is not a problem with semantic-release, but a problem with the fact that that functionality was integrated into master\n\nYour comment basically suggesting all PRs on github should not merge to master, because having one PR merged does not mean the code is \"publishable\" in your term.\nOr, you will have to keep each PR around to collect many more changes until it is in a \"feature-completed\" state, i.e. making every PR branch a feature branch.\nWith active projects, that means you have to deal with merging/rebasing between different branches.\n. duh... \ud83d\ude0a . Yes, it worked before. Released 1.0.0 and 1.0.1 . ",
    "jwalton": "I would ask you to reconsider merging this.  Major version of 0 has special meaning for SemVer.  From the semver docs:\n\nMajor version zero (0.y.z) is for initial development. Anything may change at any time. The public API should not be considered stable.\n\nA major version of 0 is an indicator to a human that this library is effectively in \"beta\".\n\nThese numbers are for machines, not humans. There is really no difference if a project is on version 1.2.3 or 132.2.3...\n\nI beg to differ, @gr2m; a major version of 132 tells me that the author of this package can't make up their mind about their public API, and relying on this library is going to be a maintenance nightmare for me.  I expect lots of breaking changes in a 0.x project, and I'm using it at my own risk.  I expect a 1.x or greater to be more stable, and while major revisions may come along, they should be rare.. That's ok.  We can still be friends.  ;)  I mean, the reason I'd like to see something like this in the FAQ is only because I'm in the middle of writing a big library that's not at all ready for public consumption, but I'm publishing it to npm because I'm using it in another project in parallel with developing it (which is finding lots of friction points in the API), and while I've only just started using semantic-release, it's completely ruined me and it makes me angry that I now have to waste time typing npm version patch && git push --follow-tags && npm publish on this project over and over again.  You've completely ruined me.  :). I'll raise this over here then: https://github.com/semantic-release/commit-analyzer.  :). Yup.  It's something that should be handled though; from the command line, you can't accidentally create a squash-merge, but from github it's quite easy to squash merge, and then github remembers your previous merge-type and will automatically pick squash merge for you on subsequent merges.  I'm introducing my team to semantic-release, but quite a few people prefer squash merge.  Even if they know that squash merges won't be handled correctly, I suspect we'll get more than one accidental squash merge from people merging via github.\nI'm happy to take a stab at a PR.. How does a regular merge work?  Like, where do we go fetch all the commits associated with a non-squash merge?. No, you're right, what I just asked makes no sense.  I've been spending too\nmuch time in sourcetree, where it splits out the \"merged\" branch into a\ndifferent line that joins in at the merge commit.  :P\nOn Thu, May 17, 2018, 18:42 Gregor Martynus notifications@github.com\nwrote:\n\nHow does a regular merge work?\nI\u2019m not sure what you mean? semantic-release only runs on your main\nbranch\u2019s CI builds. It doesn\u2019t matter if new commits are coming from a PR\nor have been pushed to the main branch directly. It just goes through all\nnew commits and calculates version & changelogs based on that\n\u2014\nYou are receiving this because you modified the open/close state.\nReply to this email directly, view it on GitHub\nhttps://github.com/semantic-release/semantic-release/issues/792#issuecomment-390036423,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABsF-1z6dpz17Q3F7Yrcnk7I7SPex7LIks5tzfzIgaJpZM4UDSs_\n.\n. Before we call here, options.repositoryUrl is \"github.com/benbria/secret-project\".  Afterwards, it is \"https://[secure]@/ithub.com/benbria/secret-project\".\n\nWe end up here with the error:\n{ Error: Command failed: git push --dry-run github.com/benbria/secret-project HEAD:master\nfatal: 'github.com/benbria/secret-project' does not appear to be a git repository\nfatal: Could not read from remote repository.\nOh!  I can reproduce this locally, if I set GH_TOKEN and NPM_TOKEN.  That makes this easier to figure out.... Aha.  The error is on this line.  When we get here, parsed.toString() returns 'github.com/benbria/secret-project', but parsed.toString('https') (which is the value ofprotocol) returns \"https:///ithub.com/benbria/secret-project\".  With theuser`, this ends up as \"https://[GH_TOKEN]@/ithub.com/benbria/secret-project\".\nNote the extra \"/\" after the \"@\".  This is completely broken.  :P\nBut, likely this is being caused by some kind of permissions problem.  Although github says my user has write access to the repo.  :/\n. If I curl https://api.github.com/repos/benbria/secret-project?access_token=$GH_TOKEN, I get back a big document that includes (amongst a lot of other things):\n\"permissions\": {\n    \"admin\": false,\n    \"push\": true,\n    \"pull\": true\n  },\nSo github, at least, thinks I have write access to this repo.. Oooh.  Since I have all these successful projects, I tried putting breakpoints in one of them.  In the success case, before we get to here, the url is \"https://github.com/benbria/other-project\".  Note the \"https://\" which is missing in the failure case.. readPkgUp is returning an \"https://\" URL in one case, and a bare URL in the other case.. Fixed by changing:\njson\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"github.com/benbria/secret-project\"\n  },\nto\njson\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/benbria/secret-project.git\"\n  },\nBut yeah, you guys need a better error message for this.  :)\n(BTW; as I've been digging into semantic-release, I feel like all I ever do is post horrible issues here.  Just wanted to take a moment to say thanks for building all of this.  Something I know open source maintainers don't hear enough.  :) ). > It's expected from the users to configure a repository URL that works with the git command line.\nThis project has been hosted on git for three years.  It's worked fine with the git command line tools all this time.  The git command line tool doesn't read package.json.\n\nIn addition the error message report the URL that is used, so users can figure out there is an issue with the repository URL.\n\nThe error did not report the URL that was used in package.json, it printed \"ithub.com/benbria doesn't exist.\"  This is not the URL from package.json, nor is it the url from git remote -v.  At the very least, you should print the literal URL you tried to use (rather than the mangled version) and where it came from (because TBH I expected it to come from git remote -v).\nIt took me almost two hours to track this down.. It doesn't have to be \"This is not a valid git url\", it could be simply \"We\nare unable to contact the git repo at the URL xxxx, taken from\npackage.json\".  But at leastlist the actual url  you're trying to use.  I\nsearched my project all over for ithub.com, with no success.\nYou've to at least give people a chance of figuring out where the url is\ncoming from, without having to use a debugger.\nEven @gr2m didn't spot the problem right away, even though I had the line\nfrom my package.json right there in my initial issue report.  So it's not\nlike this is just me.\nOn Sun, May 20, 2018, 14:43 Pierre Vanduynslager notifications@github.com\nwrote:\n\nThis project has been hosted on git for three years. It's worked fine with\nthe git command line tools all this time. The git command line tool doesn't\nread package.json.\nI never said the git command read the package.json. The package.json\ndefines a property for repository URL used as a metadata of the project.\nsemantic-release uses that to know what is the repository URL and it assume\nit's correct.\nSo yes sure you can have an incorrect URL in your package.json and it\nwon't create any issue if you don't use it, but that doesn't means\nsemantic-release should handle incorrect URL.\nThe error did not report the URL that was used in package.json, it printed\n\"ithub.com/benbria doesn't exist.\" This is not the URL from package.json,\nnor is it the url from git remote -v. At the very least, you should print\nthe literal URL you tried to use (rather than the mangled version) and\nwhere it came from (because TBH I expected it to come from git remote -v).\nsemantic-release uses the URL in your package.json and transforms it:\n\nto expand shorthand URL\nto transform git URL into https\nto add the authentication part\n\nIn certain case a wrong URL fails right away as it's not readable. In\ncases like your where the URL is a correct generic URL but a wrong Git URL\n(as per what the git CLI considers correct) the transformations can still\noccur but ends up generating a still wrong URL.\nSo there is a grey area where the URL seems correct (according what a\ngeneric URL should be) but still doesn't work with git CLI. There is no\nway to way (at least not a simple one) for us to figure out if the URL is\ninvalid, not authorized, point an offline location etc...\nWe just see that it's parseable but the git CLI report an error. If we\nstart reporting configuration error (such as \"The URL\n is not configure properly\") as you suggest, it\nwould be accurate in your specific situation. But someone with a permission\nissue will obtain an inaccurate error.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/semantic-release/semantic-release/issues/795#issuecomment-390502383,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABsF-81XRg_xTWNWn9J4k1YxyTJmm5Xbks5t0blegaJpZM4UFfCg\n.\n. @pvdlg Mine is, indeed, a private organization repo.  The private repo had \"read/write\" for the \"developers\" team from our org (of which our \"deploy user\" is not a member... although now that we're using semantic-release, it probably should be, since \"deploy user\" needs write permissions everywhere these days.  :P), and on most projects we have a second \"team\" called \"deploy\" which only contains our deploy user.  This project did not have the deploy user or team at all, so the deploy user would have been completely unable to see the project.. Why is there a isBranchUpToDate() check inside the \"Failed verifyAuth()\" case?  That seems weird.. I'll give it a try tomorrow - I'm in Canada, so it's a long weekend here.\n:)\n\nOn Jul 2, 2018 10:30, \"Pierre Vanduynslager\" notifications@github.com\nwrote:\n@jwalton https://github.com/jwalton could you confirm if that fix the\nissue?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/semantic-release/semantic-release/issues/838#issuecomment-401824725,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABsF-7RrbzrWVDHWCupQborE2VN5cH1Kks5uCi5wgaJpZM4U7yK3\n.\n. @pvdlg Sorry for being so slow to get back to you.  I gave your branch a try locally with a dry run, and it worked:\n15.6.3 said:\n[Semantic release]: The local branch master is behind the remote one, therefore a new version won't be published.\nAnd your branch said:\n[Semantic release]: The command \"git push --dry-run https://[secure]@github.com/benbria/XXX.git HEAD:master\" failed with the error message remote: Repository not found.\nfatal: repository 'https://[secure]@github.com/benbria/XXX.git/' not found\n.\n[Semantic release]: EGITNOPERMISSION The push permission to the Git repository is required.. Oops.  Just realized semantic-release/changelog needs semantic-release >= 15.8.0.  That's probably the issue.. Yup, I'm dumb.  :). Sorry, it magically started working.  I was hoping to spend some time\ndebugging it, but I've been busy.  Closing is fine.  :)\nOn Sat, Nov 17, 2018, 14:52 Pierre Vanduynslager <notifications@github.com\nwrote:\n\nClosing as this problem doesn't seems to affect anyone else (so not likely\nto be a bug) and no answer was provided here.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/semantic-release/semantic-release/issues/979#issuecomment-439643127,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABsF-1N3V15UVJaLxxYMJdBsroCa1mBNks5uwGj_gaJpZM4YT6LA\n.\n. \n",
    "myii": "Our method for dealing with this using Travis CI is to have 3 stages defined, where the release stage only runs when merging the PR.  commitlint runs for PRs as well, so that we can ensure that the commit messages will pass through to the release stage appropriately.\n. @travi Thanks for that link.  I did find another bot previously but it is no longer a GitHub app.  Can't recall its name right now.. @pvdlg Thanks for the response.  This is how we're doing it now:\n``yaml\n    # Define the release stage that runs semantic-release\n    - stage: release\n      language: node_js\n      node_js: lts/*\n      before_install: skip\n      script:\n        # UpdateAUTHORS.md`\n        - export MAINTAINER_TOKEN=${GH_TOKEN}\n        - go get github.com/myii/maintainer\n        - maintainer contributor\n    # Update Tables of Content in the relevant `.md` files\n    - npm install markdown-toc -D\n    - markdown-toc -i CONTRIBUTING.md\n    # - markdown-toc -i README.md\n    - markdown-toc -i TOFS_pattern.md\n\n    # Install all dependencies required for `semantic-release`\n    - npm install @semantic-release/changelog@3 -D\n    - npm install @semantic-release/exec@3 -D\n    - npm install @semantic-release/git@7 -D\n  deploy:\n    provider: script\n    skip_cleanup: true\n    script:\n      # Run `semantic-release`\n      - npx semantic-release@15\n\n```\nThere's a couple of feature ideas there for semantic-release as well:\n\nUpdate AUTHORS.md\nUpdate Tables of Content in the relevant .md files. @pvdlg Thanks, I've copied across the issue over there, as shown linked above.  Would you prefer this issue is closed?. \n",
    "rodrigobdz": "This issue is still happening in https://github.com/okonet/lint-staged/releases as described in https://github.com/okonet/lint-staged/issues/546. @gr2m Could you reopen this issue?. ",
    "IniZio": "Yes, I am the creator of the organizaion.. My package.json. . Resolved by revoking and granting access github oauth for Travis. Thanks for the help :pray: . ",
    "micha149": "@pvdlg How to deal with the plugin order? I would like to create a sharable config for our company. But not all projects are javascript. So, I need to add @semantic-release/npm in the project specific config, but it need to be executed before @semantic-release/git.. I am not sure if the auto-branch option is to tightly coupled to a specific workflow. You assume, that there is a branch for pre releases, but this might not be true. For example on a new project one would like to create alpha, beta, or whatever releases on the master branch until the project reaches a state where it makes sense to be released on a stable version.\nWhat about simply adding an option to force the level which will be increased. semver also provides an --preid option which is used to control what goes after the dash. So I could put simply control the release names from my CI system.\nExample:\n```yaml\nrelease-alpha-beta:\n    stage: release\n    script:\n        - semantic-release --force-level prerelease --preid $CI_COMMIT_REF_NAME # this variable contains the branch name on gitlab\n    only:\n        - alpha\n        - beta\nrelease-dev:\n    stage: release\n    script:\n        - semantic-release --force-level prerelease --preid pre\n    only:\n        - develop\nrelease-master:\n    stage: release\n    script:\n        - semantic-release\n    only:\n        - master\n```. ",
    "phukcingprivacy": "microsoft.com/Acct\nOn Dec 9, 2017 11:24 PM, \"Patrick Mowrer\" notifications@github.com wrote:\n\nIt's possible to pass plugins via the CLI, only the plugins cannot have\nany configuration which isn't terribly useful. This could be resolved with\neither:\n1.\nA \"config path\" option, allowing for passing a path to a file that\n   returns the JSON format used in package.json (perhaps with package.json\n   as the option's default).\n   2.\nWhen passing a plugin via the CLI, only set the config object's path\n   property and don't throw away the rest of the config set for that plugin\n   (from package.json).\nI think the ability to pass plugin options to the CLI would relatively\neasily allow sharing plugin configs (#49\nhttps://github.com/semantic-release/semantic-release/pull/49). The\nproblem is, since there are so many plugins, any custom configuration gets\nverbose and tedious to share across projects. For example, to use the\nsemantic-release-monorepo \"multi-plugin\"\nhttps://github.com/Updater/semantic-release-monorepo#usage:\n{\n  \"release\": {\n    \"analyzeCommits\": \"semantic-release-monorepo\",\n    \"generateNotes\": \"semantic-release-monorepo\",\n    \"getLastRelease\": \"semantic-release-monorepo\",\n    \"publish\": [\"semantic-release-monorepo/npm\", \"semantic-release-monorepo/github\"]\n  }\n}\nIf this configuration could be passed via the CLI, we can create a wrapper\nbinary over semantic-release, e.g. semantic-release-monorepo, encoding\nthe plugin's default configuration. As an example, the binary for\nsemantic-release-github-pr\nhttps://github.com/Updater/semantic-release-github-pr/blob/master/bin/semantic-release-github-pr.js,\nanother \"multi-plugin\" (with custom \"verifyConditions\" and \"publish\"\nplugins):\nconst args = argv\n  .slice(2)\n  .concat([\n    '--verify-conditions=@semantic-release/github',\n    --publish=${resolve(__dirname, '../index.js')},\n]);\nThe only problem with it is now you can't configure either of\n\"verifyConditions\" or \"publish\" via package.json.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/semantic-release/semantic-release/issues/550, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AdKm8iRqB0xv2BVIDbbVzgdkB35zFbG4ks5s-2r4gaJpZM4Q8YOn\n.\n. \n",
    "vamsi248": "once i removed that 3 lines from my docker file its running fine.. why any idea??  @semantic-release-bot @PatrickHeneise . ",
    "jcane86": "@pvdlg hiya, thanks for the guides, I was looking for that too.\nJust a quick heads up, the one for 9.0 looks wrong, it says to keep the npm script unchanged, when it should be \"release\" : \"semantic-release\",? \nThanks! . ",
    "schickling": "This is highly appreciated. Our current workflow is:\n\n\nCreate a new branch (e.g. dev)\n\n\nAssuming you're on the dev branch, you need to add the following to your package.json to publish using the next NPM tag:\n\n\njson\n  \"release\": {\n    \"branch\": \"dev\"\n  },\n  \"publishConfig\": {\n    \"tag\": \"next\"\n  }\n\nBefore merging back to master (typically via PR) remove everything from (2) again.\n\n@pvdlg do you (or someone else) have suggestions on how to improve this workflow until this issue has been implemented and released?. Ideally we'd be able to \"promote\" released versions by assigning the latest (or another) tag.\nSo far we've been releasing versions like 1.1.0-beta.1, 1.1.0-beta.2 etc. How would we do something like this using semantic-release?. Thanks, I'll manually recover by adding the tag to Git.\nHere is a build using the DEBUG env var set: https://travis-ci.org/graphcool/graphql-config-extension-graphcool/builds/323760453. Yes, after manually adding and pushing the missing git tag, everything worked!. ",
    "priley86": "\noff topic\nguys... please do a better job of announcing these breaking changes in a README or something... i love this tool and i rarely complain about other's open source work, but this is quickly becoming a mysterious library that I'm somewhat afraid of upgrading. Please do your best to ensure error messages are helpful for the end user.\n\nFor anyone else upgrading from an earlier version and searching these github issues, you may receive an error like this:\n\n```\n> semantic-release pre && npm publish && semantic-release post\n  Usage: semantic-release [options]\n  Run automated package publishing\n  Options:\n    -b, --branch                 Branch to release from\n    -r, --repositoryUrl   Git repository URL\n    --verify-conditions           Comma separated list of paths or packages name for the verifyConditions plugin(s)\n    --get-last-release             Path or package name for the getLastRelease plugin\n    --analyze-commits              Path or package name for the analyzeCommits plugin\n    --verify-release              Comma separated list of paths or packages name for the verifyRelease plugin(s)\n    --generate-notes               Path or package name for the generateNotes plugin\n    --publish                     Comma separated list of paths or packages name for the publish plugin(s)\n    --debug                              Output debugging information\n    -d, --dry-run                        Dry-run mode, skipping verifyConditions, publishing and release, printing next version and release notes\n    -h, --help                           output usage information\nnpm ERR! code ELIFECYCLE\nnpm ERR! errno 1\nnpm ERR! patternfly-react@0.0.0-semantically-released semantic-release: `semantic-release pre && npm publish && semantic-release post`\nnpm ERR! Exit status 1\nnpm ERR! \nnpm ERR! Failed at the patternfly-react@0.0.0-semantically-released semantic-release script.\nnpm ERR! This is probably not a problem with npm. There is likely additional logging output above.\nnpm ERR! A complete log of this run can be found in:\nnpm ERR!     /home/travis/.npm/_logs/2018-01-08T19_59_14_238Z-debug.log\n```\n\nThis likely means you missed @pvdlg 's comment here with the suggested fix:\nhttps://github.com/semantic-release/semantic-release/issues/411#issuecomment-353233730\n\nWith no errors/readme updates, i'm just really hoping someone else finds this issue since the original is now locked!\n\n. \noff topic\nSure, thanks for the prompt response and I\u2019ll be sure to check your release notes going forward.  I\u2019m a big fan of this library and just hope upgrades continue to be fluid. \n. ",
    "n1ru4l": "Pretty excited about this \ud83d\ude0a This allows powerful workflows!. ",
    "domwashburn": "Hi there, I hate to post a non-productive comment, but I'm wondering when we might be able start working with this new tagging system. I'm reaching a point in my process where I can either work out a temporary solution until this is ready or wait on this and prioritize some other work.\nI'm so glad I found this thread, I'm eagerly awaiting this update \ud83e\udd17 . @pvdlg Is there any work the community can do to help get this solved, even if it's only a step towards the final version... This has answered a very real need for the project that I'm working on (one lead and one other dev rapidly building and releasing a beta package for hoards of developers) so if I can help to get it up and running again I can allocate some time to that.. possibly related to #720 . Got it, I guess I'm still a little confused as to why I've been able to successfully build in a Travis environment before. I haven't had any major hiccups until the issue with the build until the url parse issue discussed in #963\nIs there a version I can use that is compatible with Git < 2.0.0?. Thanks @pvdlg\nAfter a little investigation, a colleague recommended that I add dist: xenial to .travis.yml... seems like an esoteric solution considering that Git v2.0.0 was released over 4 years ago (2014-05-28)\nFor anyone else that encounters this issue, here's a link to the doc that helped me out.\nhttps://docs.travis-ci.com/user/reference/xenial/. ",
    "lzzparis": "Is this multi-branches code published to NPM via any of the future channels yet? We're really eager to give it a shot! . ",
    "axe312ger": "Actually, we'd love to use this at Contentful, too :). I know we should use the subscribe feature for +1 and similar. Just wanted to point out that a release to any npm tag besides latest would be great. That way we can test the new code :). ",
    "Martaver": "Ditto over here\nOn Fri, Jul 27, 2018 at 12:06 PM Benedikt R\u00f6tsch notifications@github.com\nwrote:\n\nActually, we'd love to use this at Contentful\nhttps://github.com/contentful, too :)\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/semantic-release/semantic-release/issues/563#issuecomment-408359677,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AF1wMuHJ6XfrBK94ukH7-C_nqc7WZu7jks5uKtgpgaJpZM4RDyXn\n.\n. Facepalm. So - in case anyone else is in this situation, turns out that environment variables sourced in your command line don't get automatically loaded into node. For dev purposes, I used the node-env-run package to run semantic-release with local environment variables defined in a .env:\n\nnpx node-env-run --exec \"semantic-release --ci false\". ",
    "Esya": "Hey @pvdlg first of all thanks for this, this seems to be perfectly what we need. We're trying to implement it to have a simple workflow where we have master as our release branch, and beta as a pre-release branch, plugged with our CI pipeline.\nWe've tried the following simple configuration - with the proper add-channel branches of all the plugins and the multi-branches branch for semantic-release : \njson\n{\n  \"branches\": [\n    \"master\",\n    {\n      \"name\": \"beta\",\n      \"prerelease\": true\n    }\n  ],\n  \"tagFormat\": \"${version}\",\n  \"publish\": [\n    \"@semantic-release/npm\"\n  ],\n  \"npmPublish\": true\n}\nBut we get the following error : \n[Semantic release]: Running semantic-release version 0.0.0-development\n[Semantic release]: Load plugin \"verifyConditions\" from @semantic-release/npm\n[Semantic release]: Load plugin \"verifyConditions\" from @semantic-release/github\n[Semantic release]: Load plugin \"analyzeCommits\" from @semantic-release/commit-analyzer\n[Semantic release]: Load plugin \"generateNotes\" from @semantic-release/release-notes-generator\n[Semantic release]: Load plugin \"prepare\" from @semantic-release/npm\n[Semantic release]: Load plugin \"publish\" from @semantic-release/npm\n[Semantic release]: Load plugin \"addChannel\" from @semantic-release/npm\n[Semantic release]: Load plugin \"addChannel\" from @semantic-release/github\n[Semantic release]: Load plugin \"success\" from @semantic-release/github\n[Semantic release]: Load plugin \"fail\" from @semantic-release/github\n[Semantic release]: Run automated release from branch beta\n[Semantic release]: Call plugin \"verifyConditions\"\n[Semantic release]: Call plugin \"verifyConditions\"\n[Semantic release]: An error occurred while running semantic-release: { TypeError [ERR_INVALID_ARG_TYPE]: The \"path\" argument must be of type string\n    at assertPath (path.js:28:11)\n    at Object.resolve (path.js:1179:7)\n    at module.exports (/tmp/testrepo1/node_modules/semantic-release/node_modules/@semantic-release/npm/lib/get-pkg.js:11:46)\n    at verifyConditions (/tmp/testrepo1/node_modules/semantic-release/node_modules/@semantic-release/npm/index.js:28:23)\n    at validator (/tmp/testrepo1/node_modules/semantic-release/lib/plugins/normalize.js:46:28)\n    at pReduce (/tmp/testrepo1/node_modules/semantic-release/lib/plugins/pipeline.js:37:40)\n    at Promise.all.then.value (/tmp/testrepo1/node_modules/p-reduce/index.js:16:10)\n    at <anonymous>\n    at process._tickCallback (internal/process/next_tick.js:160:7) pluginName: '@semantic-release/npm' }\n[Semantic release]: An error occurred while running semantic-release: { TypeError: Cannot read property 'GH_TOKEN' of undefined\n    at module.exports (/tmp/testrepo1/node_modules/@semantic-release/github/lib/resolve-config.js:7:20)\n    at module.exports (/tmp/testrepo1/node_modules/@semantic-release/github/lib/verify.js:31:76)\n    at verifyConditions (/tmp/testrepo1/node_modules/@semantic-release/github/index.js:25:9)\n    at validator (/tmp/testrepo1/node_modules/semantic-release/lib/plugins/normalize.js:46:28)\n    at pReduce (/tmp/testrepo1/node_modules/semantic-release/lib/plugins/pipeline.js:37:40)\n    at Promise.all.then.value (/tmp/testrepo1/node_modules/p-reduce/index.js:16:10)\n    at <anonymous>\n    at process._tickCallback (internal/process/next_tick.js:160:7) pluginName: '@semantic-release/github' }\nenv seems to be undefined  in @semantic-release/github - and we're not too sure about the path error in @semantic-release/npm, we've tried manually specifying pkgRoot in .releaserc but that does not change a thing. Any thoughts?\n. ",
    "SimonFinney": "@pvdlg Same thought as the above - I can dedicate time to help get this brought into the mainline. I can confirm this is working for me with the following configuration -\njs\n{\n  branches: [\n    'master',\n    {\n      name: 'dev',\n      prerelease: 'prerelease',\n      channel: 'next',\n    },\n  ]\n}\nThanks @pvdlg!. ",
    "mattyclarkson": "@pvdlg happy to help out also. @pvdlg as @byCedric said, we only need the type definitions for certain things that are useful for the plugin authors. The index.d.ts can contain as much or as little as you like. I would suggest that we just put the type definitions in there for the plugin interfaces.\nThe way TypeScript finds the typings is either from a typings key in the package.json or it pulls it from @types/semantic-release.\nIt's really up to you if you want the typings maintained in here or we put them up to @DefinitelyTyped? The benefit of having them in here is that the typings stay in sync with the releases of the project. Submitting bug fixes to @DefinitelyTyped will result in the versions getting out of sync which is very confusing. Totally up to you though.\nI need the typings at some point as I have written a semantic release plugin for both React Native and App Center codepush in TypeScript that use local typings and @byCedric has an Expo plugin that is written in TypeScript. It would be silly for all three plugins to maintain typings for the core plugin interfaces.\nHappy to contribute if you think it would be helpful to plugin authors.. The thing I haven't quite figured out with the typings it how to correctly represent the context when different plugins are configured. Depending on the plugin the context has different properties. I guess the best thing to do it make the properties optional and people have to check. Or we have narrowing functions to determine what type of context it is.. That's fine but you end up with unsafe types by using any. unknown would be a better type to use. I was thinking we could provide narrowing functions and extended interfaces:\n```ts\ninterface Context {\n  nextRelease: Release;\n}\ninterface ContextNotes extends Context {\n  notes: string;\n}\nfunction isContextNotes(context: unknown): ContextNotes {\n  return isObject(context) && typeof context.notes === 'string';\n}\nfunction prepare(pluginConfig: Config, context: Context): void {\n  if (!isContextNotes(context)) {\n    throw new SemanticReleaseError(/ must add release notes generator plugin /);\n  }\n// notes guaranteed to exist now at compile time and runtime time\n  const { notes } = context;\n}\n```\nHowever that needs extra JavaScript code for the narrowing functions, which obviously wouldn't be ideal.. Put up the first set of typings at semantic-release/error#91 as having typings for that is pretty useful for plugins.. I'm currently investigating the typings for this project.. ### config\nI think the config should come in as an unknown type because there is no way for the typings to know what shape the configuration for a plugin would be. Users should write a narrowing function or parser for their config that confirms the shape of the configuration passed in.. ### context\nThe context is built up during the run function, so the typings for the different plugin stages can be strongly typed.. ### exports\nThe type of the functions that are exported are the interface that semantic-release uses to determine how to run the plugin. We need someway to make sure that plugins conform to the correct interface. There is no way to type a modules exports though. The following would be ideal:\n```ts\nconst { IPlugin } from 'semantic-release';\nimport publish from './publish';\nimport verifyConditions from './verifyConditions';\nconst plugin: IPlugin = { verifyConditions, publish };\nexport { ...plugin };\n```\nBut that syntax is invalid. Seems like Microsoft/TypeScript#13231 -> Microsoft/TypeScript#420 is needed there.\nThe other possibility is that the functions are typed:\n```ts\nimport { VerifyConditions, IVerifyConditionsContext } from 'semantic-release';\nimport Configuration from './Configuration';\nexport const verifyConditions: VerifyConditions = async (config: unknown, context: IVerifyConditionsContext): void => {\n  const configuration = new Configuration(config);\n  await configuration.verify(context);\n}\nexport default verifyConditions;\n```\nThat will make sure that any changes in here for the typings will propagate to users. Syntax is a little ugly though.\n. ",
    "bddckr": "Besides https://github.com/semantic-release/github/issues/139 I have no issue with the latest betas and that may just be a result of me accidentally not using the latest beta versions. This issue isn't really a deal-breaker anyway.\nVersions used (Click to expand)\n\n```\n        \"semantic-release\": \"^16.0.0-beta.8\",\n        \"@semantic-release/commit-analyzer\": \"^7.0.0-beta.1\",\n        \"@semantic-release/release-notes-generator\": \"^7.1.4\",\n        \"@semantic-release/changelog\": \"^3.0.1\",\n        \"@semantic-release/git\": \"^7.1.0-beta.1\",\n        \"@semantic-release/npm\": \"^5.2.0-beta.3\",\n        \"@semantic-release/github\": \"^5.3.0-beta.3\"\n```\n\n\nConfiguration (Click to expand)\n\n```\n    \"release\": {\n        \"branches\": [\n            \"+([1-9])?(.{+([1-9]),x}).x\",\n            \"latest\",\n            \"master\",\n            \"next\",\n            \"next-major\",\n            {\n                \"name\": \"prerelease\",\n                \"prerelease\": \"prerelease\"\n            },\n            {\n                \"name\": \"beta\",\n                \"prerelease\": \"beta\"\n            },\n            {\n                \"name\": \"alpha\",\n                \"prerelease\": \"alpha\"\n            }\n        ],\n        \"plugins\": [\n            [\n                \"@semantic-release/commit-analyzer\",\n                {\n                    \"parserOpts\": {\n                        \"revertPattern\": \"/^(?:Revert|revert:)\\\\s\\\"?([\\\\s\\\\S]+?)\\\"?\\\\s*This reverts commit (\\\\w*)\\\\./\"\n                    },\n                    \"releaseRules\": \"./release-rules.js\"\n                }\n            ],\n            [\n                \"@semantic-release/release-notes-generator\",\n                {\n                    \"parserOpts\": {\n                        \"revertPattern\": \"/^(?:Revert|revert:)\\\\s\\\"?([\\\\s\\\\S]+?)\\\"?\\\\s*This reverts commit (\\\\w*)\\\\./\"\n                    }\n                }\n            ],\n            [\n                \"@semantic-release/changelog\",\n                {\n                    \"changelogFile\": \"./CHANGELOG.md\"\n                }\n            ],\n            [\n                \"@semantic-release/npm\",\n                {\n                    \"tarballDir\": \"./npm\"\n                }\n            ],\n            [\n                \"@semantic-release/git\",\n                {\n                    \"message\": \"chore(release): set version to ${nextRelease.version}\\n\\n${nextRelease.notes}\",\n                    \"assets\": [\n                        \"../../../CHANGELOG.md\",\n                        \"../../Package/package.json\"\n                    ]\n                }\n            ],\n            [\n                \"@semantic-release/github\",\n                {\n                    \"assets\": [\n                        {\n                            \"path\": \"./npm\",\n                            \"label\": \"Unity Package\"\n                        }\n                    ]\n                }\n            ]\n        ]\n    }\n```\n\n\n\nI have yet to test the maintenance and pre-release support, though!. I can confirm pre-release as well as regular releases work without issues now. I'm using the npm plugin without publishing and then release a new GitHub release with that tarball using the GitHub plugin.. AFAIK this is expected - a pre-release always seems to advance by just updating the pre-release number, the \"actual version\" number always stays the same.\nI tried finding an explanation of this in the documentation but I don't think it clearly states this behavior. In case it really doesn't (I may have missed it) it should not just explicitly note the behavior for breaking changes, but instead note that this is true for any form of commit that would normally change the version.. Indeed they can!. It sounds like you're trying to release a \"maintenace\" release which is properly supported by the beta via https://github.com/semantic-release/semantic-release/issues/563. The documentation (that also links to more specific details) can be found here.. Your repo's releases page isn't actually listing any releases, it is currently only listing git tags.\nAFAIK for semantic-release to create a proper release on GitHub you need to use the github plugin. According to the docs of it you don't have to configure its assets setting as that is empty by default. This should create a GitHub release.. All you need to do is ensure the git repo has the matching tag (with the tag format you configured, by default vX.Y.Z). More info can be found here in the semantic-release configuration documentation.. ",
    "bniedermeyer": "I've had some issues with publishing to channels with a private registry, but haven't tried with the latest betas yet. I'll try again with those this week and open something up if I'm still running into problems. . After running with the latest betas I was unable to fix my issues. I've opened up #1040. . @pvdlg I don't - currently I only have dependency info, and other metadata about the library. . There was no npm output after that line unfortunately. The only thing I've changed from that log dump is removing identifying info in regards to the library or our environment (unfortunately the library is for internal use only at my company or else I'd point you to the job itself that ran). \nWhen I run npm view <your_package_name> dist-tags.beta nothing is returned. We only used the beta tags for testing a poc workflow earlier and they were unpublished before we added in semantic-release.\nIs there a verbose mode for logging I could turn on that might give more information?. I believe I solved my problem. My project was using https://github.com/semantic-release/gitlab-config which uses \"@semantic-release/npm\": \"^5.1.1\". Since two versions of @semantic-release/npm were being installed the stable version was the one actually executing when the release was created. I removed @semantic-release/gitlab-config and setup the plugins manually and it publishes to the correct channel!\nThis was tricky - I only figured it out after investigating my package-lock.json file trying to find why it wasn't logging the updated message you added in @semantic-release/npm. \nThanks for helping out!. ",
    "appsolutegeek": "Hi, I have tried testing it, but I get a problem saying\n[10:00:56 AM] [semantic-release] \u203a \u2139  This test run was triggered on the branch 1.16.x, while semantic-release is configured to only publish from master, therefore a new version won\u2019t be published.\nI have .releaserc.json file created like so - I added the .json extension so it was easier to manged in my IDE which according to the docs - is fine.\n{\n  \"branches\": [\n    \"+([1-9])?(.{+([1-9]),x}).x\",\n    \"master\",\n    \"next\",\n    \"next-major\",\n    {\n      \"name\": \"beta\",\n      \"prerelease\": true\n    },\n    {\n      \"name\": \"alpha\",\n      \"prerelease\": true\n    }\n  ],\n  \"plugins\": [\n    \"@semantic-release/commit-analyzer\",\n    \"@semantic-release/release-notes-generator\",\n    \"@semantic-release/changelog\",\n    [\n      \"@semantic-release/npm\",\n      {\n      }\n    ],\n    \"@semantic-release/git\"\n  ]\n}\nAnd I have just created a branch from version 1.16 tag and branch is called 1.16.x but it doesn't seem to recognise it.\n\u279c  semantec-release-poc git:(1.16.x) npx semantic-release --no-ci\n[10:09:23 AM] [semantic-release] \u203a \u2139  Running semantic-release version 16.0.0-beta.8\n[10:09:23 AM] [semantic-release] \u203a \u2714  Loaded plugin \"verifyConditions\" from \"@semantic-release/changelog\"\n[10:09:23 AM] [semantic-release] \u203a \u2714  Loaded plugin \"verifyConditions\" from \"@semantic-release/npm\"\n[10:09:23 AM] [semantic-release] \u203a \u2714  Loaded plugin \"verifyConditions\" from \"@semantic-release/git\"\n[10:09:23 AM] [semantic-release] \u203a \u2714  Loaded plugin \"analyzeCommits\" from \"@semantic-release/commit-analyzer\"\n[10:09:23 AM] [semantic-release] \u203a \u2714  Loaded plugin \"generateNotes\" from \"@semantic-release/release-notes-generator\"\n[10:09:23 AM] [semantic-release] \u203a \u2714  Loaded plugin \"prepare\" from \"@semantic-release/changelog\"\n[10:09:23 AM] [semantic-release] \u203a \u2714  Loaded plugin \"prepare\" from \"@semantic-release/npm\"\n[10:09:23 AM] [semantic-release] \u203a \u2714  Loaded plugin \"prepare\" from \"@semantic-release/git\"\n[10:09:23 AM] [semantic-release] \u203a \u2714  Loaded plugin \"publish\" from \"@semantic-release/npm\"\n[10:09:23 AM] [semantic-release] \u203a \u2714  Loaded plugin \"addChannel\" from \"@semantic-release/npm\"\n[10:09:30 AM] [semantic-release] \u203a \u2139  This test run was triggered on the branch 1.16.x, while semantic-release is configured to only publish from master, therefore a new version won\u2019t be published.\n. my dev dependencies are \n\"devDependencies\": {\n    \"semantic-release\": \"^16.0.0-beta.8\",\n    \"@semantic-release/commit-analyzer\": \"^7.0.0-beta.1\",\n    \"@semantic-release/release-notes-generator\": \"^7.1.4\",\n    \"@semantic-release/changelog\": \"^3.0.1\",\n    \"@semantic-release/git\": \"^7.1.0-beta.1\",\n    \"@semantic-release/npm\": \"^5.2.0-beta.3\",\n    \"@semantic-release/github\": \"^5.3.0-beta.3\"\n  }. > @appsolutegeek I think the problem is the branch 1.16.x doesn't exists on your remote repo.\n\nFor several reasons we have to get the list of branches in your repo from origin. So this is expected.\nIf you still encounter the issue while having the branch on origin, please open a new issue.\n\nThanks, yes that was it! Thanks\nI have a small issue remaining but I will open a new issue as suggested\nThanks. Yes, great. Thanks, both. I am going to try it this weekend.. Yes, this is what i did\n```\n\u279c  semantic-release-poc git:(master) \u2717 git checkout -b 1.19.x v1.19.0\nSwitched to a new branch '1.19.x'\n\u279c  semantic-release-poc git:(1.19.x) git add .\n\u279c  semantic-release-poc git:(1.19.x) \u2717 nr -i\n? Which script do you want to execute? commit\nrunning command with prefix \"commit\"\n\n@reltester/semantec-release-poc@1.19.0 commit /Users/ian/Development/Scratch/POC/semantic-release-poc\ngit-cz\n\ncz-cli@3.0.5, cz-conventional-changelog@2.1.0\nLine 1 will be cropped at 100 characters. All other lines will be wrapped after 100 characters.\n? Select the type of change that you're committing: fix:      A bug fix\n? What is the scope of this change (e.g. component or file name)? (press enter to skip)\n a fix\n? Write a short, imperative tense description of the change:\n fix\n? Provide a longer description of the change: (press enter to skip)\n fix\n? Are there any breaking changes? No\n? Does this change affect any open issues? No\n[1.19.x d5446ca] fix(a fix): fix\n 2 files changed, 25 insertions(+), 41 deletions(-)\n\u279c  semantic-release-poc git:(1.19.x) git push -u origin 1.19.x\nCounting objects: 6, done.\nDelta compression using up to 8 threads.\nCompressing objects: 100% (5/5), done.\nWriting objects: 100% (6/6), 755 bytes | 755.00 KiB/s, done.\nTotal 6 (delta 4), reused 0 (delta 0)\n\n[new branch]      1.19.x -> 1.19.x\nBranch '1.19.x' set up to track remote branch '1.19.x' from 'origin'.\n```\n\nand then I just do the following but it gives the above errors\n\u279c  semantic-release-poc git:(1.19.x) npx semantic-release --no-ci\n. \n. Maybe I am doing something wrong ?\nAlthough I am not quite sure what :-). Thanks, just tried it and it did work but I added a conventional commit (fix) and it just tried to create the tag 1.19.0 and didn't try to increase it\nI am doing more tests and i will open another issue - that way - its easily tracked . Here are the logs, maybe i have to increase the version manually inside package.json -\nOther strange thing is that it states \"No git tag version found on branch 1.19.x\" and then it states it found a lot\nMaybe this is not a problem.\n[2:09:20 AM] [semantic-release] \u203a \u2714  Completed step \"verifyConditions\" of plugin \"@semantic-release/git\"\n[2:09:20 AM] [semantic-release] \u203a \u2139  No git tag version found on branch 1.19.x\n[2:09:20 AM] [semantic-release] \u203a \u2139  Found git tag v1.0.0 associated with version 1.0.0 on branch 1.19.x\n[2:09:20 AM] [semantic-release] \u203a \u2139  Found git tag v1.1.0 associated with version 1.1.0 on branch 1.19.x\n[2:09:20 AM] [semantic-release] \u203a \u2139  Found git tag v1.2.0 associated with version 1.2.0 on branch 1.19.x\n[2:09:20 AM] [semantic-release] \u203a \u2139  Found git tag v1.3.0 associated with version 1.3.0 on branch 1.19.x\n[2:09:20 AM] [semantic-release] \u203a \u2139  Found git tag v1.4.0 associated with version 1.4.0 on branch 1.19.x\n[2:09:20 AM] [semantic-release] \u203a \u2139  Found git tag v1.5.0 associated with version 1.5.0 on branch 1.19.x\n[2:09:20 AM] [semantic-release] \u203a \u2139  Found git tag v1.6.0 associated with version 1.6.0 on branch 1.19.x\n[2:09:20 AM] [semantic-release] \u203a \u2139  Found git tag v1.6.1 associated with version 1.6.1 on branch 1.19.x\n[2:09:20 AM] [semantic-release] \u203a \u2139  Found git tag v1.7.0 associated with version 1.7.0 on branch 1.19.x\n[2:09:20 AM] [semantic-release] \u203a \u2139  Found git tag v1.8.0 associated with version 1.8.0 on branch 1.19.x\n[2:09:20 AM] [semantic-release] \u203a \u2139  Found git tag v1.8.1 associated with version 1.8.1 on branch 1.19.x\n[2:09:20 AM] [semantic-release] \u203a \u2139  Found git tag v1.9.0 associated with version 1.9.0 on branch 1.19.x\n[2:09:20 AM] [semantic-release] \u203a \u2139  Found git tag v1.9.1 associated with version 1.9.1 on branch 1.19.x\n[2:09:20 AM] [semantic-release] \u203a \u2139  Found git tag v1.10.0 associated with version 1.10.0 on branch 1.19.x\n[2:09:20 AM] [semantic-release] \u203a \u2139  Found git tag v1.10.1 associated with version 1.10.1 on branch 1.19.x\n[2:09:20 AM] [semantic-release] \u203a \u2139  Found git tag v1.10.2 associated with version 1.10.2 on branch 1.19.x\n[2:09:20 AM] [semantic-release] \u203a \u2139  Found git tag v1.11.0 associated with version 1.11.0 on branch 1.19.x\n[2:09:20 AM] [semantic-release] \u203a \u2139  Found git tag v1.12.0 associated with version 1.12.0 on branch 1.19.x\n[2:09:20 AM] [semantic-release] \u203a \u2139  Found git tag v1.13.0 associated with version 1.13.0 on branch 1.19.x\n[2:09:20 AM] [semantic-release] \u203a \u2139  Found git tag v1.14.0 associated with version 1.14.0 on branch 1.19.x\n[2:09:20 AM] [semantic-release] \u203a \u2139  Found git tag v1.15.0 associated with version 1.15.0 on branch 1.19.x\n[2:09:20 AM] [semantic-release] \u203a \u2139  Found git tag v1.16.0 associated with version 1.16.0 on branch 1.19.x\n[2:09:20 AM] [semantic-release] \u203a \u2139  Found git tag v1.17.0 associated with version 1.17.0 on branch 1.19.x\n[2:09:20 AM] [semantic-release] \u203a \u2139  Found git tag v1.18.0 associated with version 1.18.0 on branch 1.19.x\n[2:09:20 AM] [semantic-release] \u203a \u2139  Found 2 commits since last release\n[2:09:20 AM] [semantic-release] \u203a \u2139  Start step \"generateNotes\" of plugin \"@semantic-release/release-notes-generator\"\n[2:09:20 AM] [semantic-release] \u203a \u2714  Completed step \"generateNotes\" of plugin \"@semantic-release/release-notes-generator\"\n[2:09:20 AM] [semantic-release] \u203a \u2139  Create tag v1.19.0@1.19.x\n[2:09:24 AM] [semantic-release] \u203a \u2139  Start step \"addChannel\" of plugin \"@semantic-release/npm\"\n[2:09:24 AM] [semantic-release] [@semantic-release/npm] \u203a \u2139  Adding version 1.19.0 to npm registry on dist-tag release-1.19.x\nnpm ERR! registry error parsing json\nnpm ERR! Unexpected token < in JSON at position 1\nnpm ERR!\nnpm ERR! <!DOCTYPE html>\nnpm ERR! <html>\nnpm ERR! <head>\nnpm ERR!   <title>400 - Nexus Repository Manager</title>. now, out of interest, I just run it again - same branch etc and now I got all the other errors again.\nI will remove the branch and start again\n``\n[2:15:46 AM] [semantic-release] \u203a \u2139  Running semantic-release version 16.0.0-beta.10\n[2:15:47 AM] [semantic-release] \u203a \u2714  Loaded plugin \"verifyConditions\" from \"@semantic-release/changelog\"\n[2:15:47 AM] [semantic-release] \u203a \u2714  Loaded plugin \"verifyConditions\" from \"@semantic-release/npm\"\n[2:15:47 AM] [semantic-release] \u203a \u2714  Loaded plugin \"verifyConditions\" from \"@semantic-release/git\"\n[2:15:47 AM] [semantic-release] \u203a \u2714  Loaded plugin \"analyzeCommits\" from \"@semantic-release/commit-analyzer\"\n[2:15:47 AM] [semantic-release] \u203a \u2714  Loaded plugin \"generateNotes\" from \"@semantic-release/release-notes-generator\"\n[2:15:47 AM] [semantic-release] \u203a \u2714  Loaded plugin \"prepare\" from \"@semantic-release/changelog\"\n[2:15:47 AM] [semantic-release] \u203a \u2714  Loaded plugin \"prepare\" from \"@semantic-release/npm\"\n[2:15:47 AM] [semantic-release] \u203a \u2714  Loaded plugin \"prepare\" from \"@semantic-release/git\"\n[2:15:47 AM] [semantic-release] \u203a \u2714  Loaded plugin \"publish\" from \"@semantic-release/npm\"\n[2:15:47 AM] [semantic-release] \u203a \u2714  Loaded plugin \"addChannel\" from \"@semantic-release/npm\"\n[2:15:58 AM] [semantic-release] \u203a \u2714  Run automated release from branch 1.19.x\n[2:16:04 AM] [semantic-release] \u203a \u2714  Allowed to push to the Git repository\n[2:16:04 AM] [semantic-release] \u203a \u2139  Start step \"verifyConditions\" of plugin \"@semantic-release/changelog\"\n[2:16:04 AM] [semantic-release] \u203a \u2714  Completed step \"verifyConditions\" of plugin \"@semantic-release/changelog\"\n[2:16:04 AM] [semantic-release] \u203a \u2139  Start step \"verifyConditions\" of plugin \"@semantic-release/npm\"\n[2:16:04 AM] [semantic-release] [@semantic-release/npm] \u203a \u2139  Verify authentication for registry http://nexus.site.int/repository/npm-private/\n[2:16:04 AM] [semantic-release] \u203a \u2714  Completed step \"verifyConditions\" of plugin \"@semantic-release/npm\"\n[2:16:04 AM] [semantic-release] \u203a \u2139  Start step \"verifyConditions\" of plugin \"@semantic-release/git\"\n[2:16:04 AM] [semantic-release] \u203a \u2714  Completed step \"verifyConditions\" of plugin \"@semantic-release/git\"\n[2:16:04 AM] [semantic-release] \u203a \u2139  No git tag version found on branch 1.19.x\n[2:16:04 AM] [semantic-release] \u203a \u2139  Found git tag v1.0.0 associated with version 1.0.0 on branch 1.19.x\n[2:16:04 AM] [semantic-release] \u203a \u2139  Found git tag v1.1.0 associated with version 1.1.0 on branch 1.19.x\n[2:16:04 AM] [semantic-release] \u203a \u2139  Found git tag v1.2.0 associated with version 1.2.0 on branch 1.19.x\n[2:16:04 AM] [semantic-release] \u203a \u2139  Found git tag v1.3.0 associated with version 1.3.0 on branch 1.19.x\n[2:16:04 AM] [semantic-release] \u203a \u2139  Found git tag v1.4.0 associated with version 1.4.0 on branch 1.19.x\n[2:16:04 AM] [semantic-release] \u203a \u2139  Found git tag v1.5.0 associated with version 1.5.0 on branch 1.19.x\n[2:16:04 AM] [semantic-release] \u203a \u2139  Found git tag v1.6.0 associated with version 1.6.0 on branch 1.19.x\n[2:16:04 AM] [semantic-release] \u203a \u2139  Found git tag v1.6.1 associated with version 1.6.1 on branch 1.19.x\n[2:16:04 AM] [semantic-release] \u203a \u2139  Found git tag v1.7.0 associated with version 1.7.0 on branch 1.19.x\n[2:16:04 AM] [semantic-release] \u203a \u2139  Found git tag v1.8.0 associated with version 1.8.0 on branch 1.19.x\n[2:16:04 AM] [semantic-release] \u203a \u2139  Found git tag v1.8.1 associated with version 1.8.1 on branch 1.19.x\n[2:16:04 AM] [semantic-release] \u203a \u2139  Found git tag v1.9.0 associated with version 1.9.0 on branch 1.19.x\n[2:16:04 AM] [semantic-release] \u203a \u2139  Found git tag v1.9.1 associated with version 1.9.1 on branch 1.19.x\n[2:16:04 AM] [semantic-release] \u203a \u2139  Found git tag v1.10.0 associated with version 1.10.0 on branch 1.19.x\n[2:16:04 AM] [semantic-release] \u203a \u2139  Found git tag v1.10.1 associated with version 1.10.1 on branch 1.19.x\n[2:16:04 AM] [semantic-release] \u203a \u2139  Found git tag v1.10.2 associated with version 1.10.2 on branch 1.19.x\n[2:16:04 AM] [semantic-release] \u203a \u2139  Found git tag v1.11.0 associated with version 1.11.0 on branch 1.19.x\n[2:16:04 AM] [semantic-release] \u203a \u2139  Found git tag v1.12.0 associated with version 1.12.0 on branch 1.19.x\n[2:16:04 AM] [semantic-release] \u203a \u2139  Found git tag v1.13.0 associated with version 1.13.0 on branch 1.19.x\n[2:16:04 AM] [semantic-release] \u203a \u2139  Found git tag v1.14.0 associated with version 1.14.0 on branch 1.19.x\n[2:16:04 AM] [semantic-release] \u203a \u2139  Found git tag v1.15.0 associated with version 1.15.0 on branch 1.19.x\n[2:16:04 AM] [semantic-release] \u203a \u2139  Found git tag v1.16.0 associated with version 1.16.0 on branch 1.19.x\n[2:16:04 AM] [semantic-release] \u203a \u2139  Found git tag v1.17.0 associated with version 1.17.0 on branch 1.19.x\n[2:16:04 AM] [semantic-release] \u203a \u2716  EINVALIDMAINTENANCEMERGE The release1.0.0on branch1.19.x` cannot be published as it is out of range.\nOnly releases within the range >=1.19.0 <1.20.0 can be merged into the maintenance branch 1.19.x and published to the 1.19.x distribution channel.\nThe branch 1.19.x head should be reset (https://git-scm.com/docs/git-reset) to a previous commit so the commit with tag v1.0.0@1.19.x is removed from the branch history.\nSee the workflow configuration documentation (https://github.com/semantic-release/semantic-release/blob/master/docs/usage/workflow-configuration.md) for more details.\n. Sure,I will do that now... I deleted the branch and created it again - and now - i always get the erors..\n.\n\u279c  semantic-release-poc git:(1.19.x) git merge-base --is-ancestor v1.9.1 1.19.x\n\u279c  semantic-release-poc git:(1.19.x) echo $?\n0\n```. This is my status right now\n\nAnd the error i get after creating a new branch (deleting the old one etc) is\n``\n\u279c  semantic-release-poc git:(1.19.x) npx semantic-release --no-ci\n[2:25:48 AM] [semantic-release] \u203a \u2139  Running semantic-release version 16.0.0-beta.10\n[2:25:48 AM] [semantic-release] \u203a \u2714  Loaded plugin \"verifyConditions\" from \"@semantic-release/changelog\"\n[2:25:48 AM] [semantic-release] \u203a \u2714  Loaded plugin \"verifyConditions\" from \"@semantic-release/npm\"\n[2:25:48 AM] [semantic-release] \u203a \u2714  Loaded plugin \"verifyConditions\" from \"@semantic-release/git\"\n[2:25:48 AM] [semantic-release] \u203a \u2714  Loaded plugin \"analyzeCommits\" from \"@semantic-release/commit-analyzer\"\n[2:25:48 AM] [semantic-release] \u203a \u2714  Loaded plugin \"generateNotes\" from \"@semantic-release/release-notes-generator\"\n[2:25:48 AM] [semantic-release] \u203a \u2714  Loaded plugin \"prepare\" from \"@semantic-release/changelog\"\n[2:25:48 AM] [semantic-release] \u203a \u2714  Loaded plugin \"prepare\" from \"@semantic-release/npm\"\n[2:25:48 AM] [semantic-release] \u203a \u2714  Loaded plugin \"prepare\" from \"@semantic-release/git\"\n[2:25:48 AM] [semantic-release] \u203a \u2714  Loaded plugin \"publish\" from \"@semantic-release/npm\"\n[2:25:48 AM] [semantic-release] \u203a \u2714  Loaded plugin \"addChannel\" from \"@semantic-release/npm\"\n[2:25:59 AM] [semantic-release] \u203a \u2714  Run automated release from branch 1.19.x\n[2:26:04 AM] [semantic-release] \u203a \u2714  Allowed to push to the Git repository\n[2:26:04 AM] [semantic-release] \u203a \u2139  Start step \"verifyConditions\" of plugin \"@semantic-release/changelog\"\n[2:26:04 AM] [semantic-release] \u203a \u2714  Completed step \"verifyConditions\" of plugin \"@semantic-release/changelog\"\n[2:26:04 AM] [semantic-release] \u203a \u2139  Start step \"verifyConditions\" of plugin \"@semantic-release/npm\"\n[2:26:05 AM] [semantic-release] [@semantic-release/npm] \u203a \u2139  Verify authentication for registry http://nexus.site.int/repository/npm-private/\n[2:26:05 AM] [semantic-release] \u203a \u2714  Completed step \"verifyConditions\" of plugin \"@semantic-release/npm\"\n[2:26:05 AM] [semantic-release] \u203a \u2139  Start step \"verifyConditions\" of plugin \"@semantic-release/git\"\n[2:26:05 AM] [semantic-release] \u203a \u2714  Completed step \"verifyConditions\" of plugin \"@semantic-release/git\"\n[2:26:05 AM] [semantic-release] \u203a \u2139  No git tag version found on branch 1.19.x\n[2:26:05 AM] [semantic-release] \u203a \u2139  Found git tag v1.0.0 associated with version 1.0.0 on branch 1.19.x\n[2:26:05 AM] [semantic-release] \u203a \u2139  Found git tag v1.1.0 associated with version 1.1.0 on branch 1.19.x\n[2:26:05 AM] [semantic-release] \u203a \u2139  Found git tag v1.2.0 associated with version 1.2.0 on branch 1.19.x\n[2:26:05 AM] [semantic-release] \u203a \u2139  Found git tag v1.3.0 associated with version 1.3.0 on branch 1.19.x\n[2:26:05 AM] [semantic-release] \u203a \u2139  Found git tag v1.4.0 associated with version 1.4.0 on branch 1.19.x\n[2:26:05 AM] [semantic-release] \u203a \u2139  Found git tag v1.5.0 associated with version 1.5.0 on branch 1.19.x\n[2:26:05 AM] [semantic-release] \u203a \u2139  Found git tag v1.6.0 associated with version 1.6.0 on branch 1.19.x\n[2:26:05 AM] [semantic-release] \u203a \u2139  Found git tag v1.6.1 associated with version 1.6.1 on branch 1.19.x\n[2:26:05 AM] [semantic-release] \u203a \u2139  Found git tag v1.7.0 associated with version 1.7.0 on branch 1.19.x\n[2:26:05 AM] [semantic-release] \u203a \u2139  Found git tag v1.8.0 associated with version 1.8.0 on branch 1.19.x\n[2:26:05 AM] [semantic-release] \u203a \u2139  Found git tag v1.8.1 associated with version 1.8.1 on branch 1.19.x\n[2:26:05 AM] [semantic-release] \u203a \u2139  Found git tag v1.9.0 associated with version 1.9.0 on branch 1.19.x\n[2:26:05 AM] [semantic-release] \u203a \u2139  Found git tag v1.9.1 associated with version 1.9.1 on branch 1.19.x\n[2:26:05 AM] [semantic-release] \u203a \u2139  Found git tag v1.10.0 associated with version 1.10.0 on branch 1.19.x\n[2:26:05 AM] [semantic-release] \u203a \u2139  Found git tag v1.10.1 associated with version 1.10.1 on branch 1.19.x\n[2:26:05 AM] [semantic-release] \u203a \u2139  Found git tag v1.10.2 associated with version 1.10.2 on branch 1.19.x\n[2:26:05 AM] [semantic-release] \u203a \u2139  Found git tag v1.11.0 associated with version 1.11.0 on branch 1.19.x\n[2:26:05 AM] [semantic-release] \u203a \u2139  Found git tag v1.12.0 associated with version 1.12.0 on branch 1.19.x\n[2:26:05 AM] [semantic-release] \u203a \u2139  Found git tag v1.13.0 associated with version 1.13.0 on branch 1.19.x\n[2:26:05 AM] [semantic-release] \u203a \u2139  Found git tag v1.14.0 associated with version 1.14.0 on branch 1.19.x\n[2:26:05 AM] [semantic-release] \u203a \u2139  Found git tag v1.15.0 associated with version 1.15.0 on branch 1.19.x\n[2:26:05 AM] [semantic-release] \u203a \u2139  Found git tag v1.16.0 associated with version 1.16.0 on branch 1.19.x\n[2:26:05 AM] [semantic-release] \u203a \u2139  Found git tag v1.17.0 associated with version 1.17.0 on branch 1.19.x\n[2:26:05 AM] [semantic-release] \u203a \u2716  EINVALIDMAINTENANCEMERGE The release1.0.0on branch1.19.x` cannot be published as it is out of range.\nOnly releases within the range >=1.19.0 <1.20.0 can be merged into the maintenance branch 1.19.x and published to the 1.19.x distribution channel.\nThe branch 1.19.x head should be reset (https://git-scm.com/docs/git-reset) to a previous commit so the commit with tag v1.0.0@1.19.x is removed from the branch history.\nSee the workflow configuration documentation (https://github.com/semantic-release/semantic-release/blob/master/docs/usage/workflow-configuration.md) for more details.\n[2:26:05 AM] [semantic-release] \u203a \u2716  EINVALIDMAINTENANCEMERGE The release 1.7.0 on branch 1.19.x cannot be published as it is out of range.\nOnly releases within the range >=1.19.0 <1.20.0 can be merged into the maintenance branch 1.19.x and published to the 1.19.x distribution channel.\nThe branch 1.19.x head should be reset (https://git-scm.com/docs/git-reset) to a previous commit so the commit with tag v1.7.0@1.19.x is removed from the branch history.\nSee the workflow configuration documentation (https://github.com/semantic-release/semantic-release/blob/master/docs/usage/workflow-configuration.md) for more details.\n[2:26:05 AM] [semantic-release] \u203a \u2716  EINVALIDMAINTENANCEMERGE The release 1.8.0 on branch 1.19.x cannot be published as it is out of range.\nOnly releases within the range >=1.19.0 <1.20.0 can be merged into the maintenance branch 1.19.x and published to the 1.19.x distribution channel.\nThe branch 1.19.x head should be reset (https://git-scm.com/docs/git-reset) to a previous commit so the commit with tag v1.8.0@1.19.x is removed from the branch history.\nSee the workflow configuration documentation (https://github.com/semantic-release/semantic-release/blob/master/docs/usage/workflow-configuration.md) for more details.\n[2:26:05 AM] [semantic-release] \u203a \u2716  EINVALIDMAINTENANCEMERGE The release 1.8.1 on branch 1.19.x cannot be published as it is out of range.\nOnly releases within the range >=1.19.0 <1.20.0 can be merged into the maintenance branch 1.19.x and published to the 1.19.x distribution channel.\nThe branch 1.19.x head should be reset (https://git-scm.com/docs/git-reset) to a previous commit so the commit with tag v1.8.1@1.19.x is removed from the branch history.\nSee the workflow configuration documentation (https://github.com/semantic-release/semantic-release/blob/master/docs/usage/workflow-configuration.md) for more details.\n[2:26:05 AM] [semantic-release] \u203a \u2716  EINVALIDMAINTENANCEMERGE The release 1.9.0 on branch 1.19.x cannot be published as it is out of range.\nOnly releases within the range >=1.19.0 <1.20.0 can be merged into the maintenance branch 1.19.x and published to the 1.19.x distribution channel.\n```. sure - let me remove the branch again and i will run with --debug\n. Actually just before deleting it - i ran it again with the --debug, thought it might be useful, i will of course now - do it again \n``\n\u279c  semantic-release-poc git:(1.19.x) npx semantic-release --no-ci --debug\n[2:36:22 AM] [semantic-release] \u203a \u2139  Running semantic-release version 16.0.0-beta.10\n  semantic-release:config load config from: /Users/ian/Development/Scratch/POC/semantic-release-poc/.releaserc +0ms\n  semantic-release:config options values: { branches:\n  semantic-release:config    [ '+([1-9])?(.{+([1-9]),x}).x',\n  semantic-release:config      'master',\n  semantic-release:config      'next',\n  semantic-release:config      'next-major',\n  semantic-release:config      { name: 'beta', prerelease: true },\n  semantic-release:config      { name: 'alpha', prerelease: true } ],\n  semantic-release:config   repositoryUrl:\n  semantic-release:config    'git@lab.sitte.int:fe/poc/semantic-release-poc.git',\n  semantic-release:config   tagFormat: 'v${version}',\n  semantic-release:config   plugins:\n  semantic-release:config    [ '@semantic-release/commit-analyzer',\n  semantic-release:config      '@semantic-release/release-notes-generator',\n  semantic-release:config      '@semantic-release/changelog',\n  semantic-release:config      [ '@semantic-release/npm', {} ],\n  semantic-release:config      '@semantic-release/git' ],\n  semantic-release:config   _: [],\n  semantic-release:config   ci: false,\n  semantic-release:config   debug: true,\n  semantic-release:config   '$0': 'node_modules/.bin/semantic-release',\n  semantic-release:config   noCi: true } +4ms\n  semantic-release:plugins options for @semantic-release/changelog/verifyConditions: {} +0ms\n[2:36:22 AM] [semantic-release] \u203a \u2714  Loaded plugin \"verifyConditions\" from \"@semantic-release/changelog\"\n  semantic-release:plugins options for @semantic-release/npm/verifyConditions: {} +1ms\n[2:36:22 AM] [semantic-release] \u203a \u2714  Loaded plugin \"verifyConditions\" from \"@semantic-release/npm\"\n  semantic-release:plugins options for @semantic-release/git/verifyConditions: {} +0ms\n[2:36:22 AM] [semantic-release] \u203a \u2714  Loaded plugin \"verifyConditions\" from \"@semantic-release/git\"\n  semantic-release:plugins options for @semantic-release/commit-analyzer/analyzeCommits: {} +0ms\n[2:36:22 AM] [semantic-release] \u203a \u2714  Loaded plugin \"analyzeCommits\" from \"@semantic-release/commit-analyzer\"\n  semantic-release:plugins options for @semantic-release/release-notes-generator/generateNotes: {} +1ms\n[2:36:22 AM] [semantic-release] \u203a \u2714  Loaded plugin \"generateNotes\" from \"@semantic-release/release-notes-generator\"\n  semantic-release:plugins options for @semantic-release/changelog/prepare: {} +0ms\n[2:36:22 AM] [semantic-release] \u203a \u2714  Loaded plugin \"prepare\" from \"@semantic-release/changelog\"\n  semantic-release:plugins options for @semantic-release/npm/prepare: {} +0ms\n[2:36:22 AM] [semantic-release] \u203a \u2714  Loaded plugin \"prepare\" from \"@semantic-release/npm\"\n  semantic-release:plugins options for @semantic-release/git/prepare: {} +1ms\n[2:36:22 AM] [semantic-release] \u203a \u2714  Loaded plugin \"prepare\" from \"@semantic-release/git\"\n  semantic-release:plugins options for @semantic-release/npm/publish: {} +0ms\n[2:36:22 AM] [semantic-release] \u203a \u2714  Loaded plugin \"publish\" from \"@semantic-release/npm\"\n  semantic-release:plugins options for @semantic-release/npm/addChannel: {} +0ms\n[2:36:22 AM] [semantic-release] \u203a \u2714  Loaded plugin \"addChannel\" from \"@semantic-release/npm\"\n  semantic-release:get-tags found tags: [ { gitTag: 'v1.0.0', version: '1.0.0', channel: undefined }, { gitTag: 'v1.1.0', version: '1.1.0', channel: undefined }, { gitTag: 'v1.10.0', version: '1.10.0', channel: undefined }, { gitTag: 'v1.10.1', version: '1.10.1', channel: undefined }, { gitTag: 'v1.10.2', version: '1.10.2', channel: undefined }, { gitTag: 'v1.11.0', version: '1.11.0', channel: undefined }, { gitTag: 'v1.12.0', version: '1.12.0', channel: undefined }, { gitTag: 'v1.13.0', version: '1.13.0', channel: undefined }, { gitTag: 'v1.14.0', version: '1.14.0', channel: undefined }, { gitTag: 'v1.15.0', version: '1.15.0', channel: undefined }, { gitTag: 'v1.16.0', version: '1.16.0', channel: undefined }, { gitTag: 'v1.17.0', version: '1.17.0', channel: undefined }, { gitTag: 'v1.18.0', version: '1.18.0', channel: undefined }, { gitTag: 'v1.19.0', version: '1.19.0', channel: undefined }, { gitTag: 'v1.19.0@1.19.x', version: '1.19.0', channel: '1.19.x' }, { gitTag: 'v1.2.0', version: '1.2.0', channel: undefined }, { gitTag: 'v1.20.0', version: '1.20.0', channel: undefined }, { gitTag: 'v1.3.0', version: '1.3.0', channel: undefined }, { gitTag: 'v1.4.0', version: '1.4.0', channel: undefined }, { gitTag: 'v1.5.0', version: '1.5.0', channel: undefined }, { gitTag: 'v1.6.0', version: '1.6.0', channel: undefined }, { gitTag: 'v1.6.1', version: '1.6.1', channel: undefined }, { gitTag: 'v1.7.0', version: '1.7.0', channel: undefined }, { gitTag: 'v1.7.1', version: '1.7.1', channel: undefined }, { gitTag: 'v1.8.0', version: '1.8.0', channel: undefined }, { gitTag: 'v1.8.1', version: '1.8.1', channel: undefined }, { gitTag: 'v1.9.0', version: '1.9.0', channel: undefined }, { gitTag: 'v1.9.1', version: '1.9.1', channel: undefined } ] +0ms\n  semantic-release:get-tags found tags for branch 1.19.x: [ { version: '1.0.0', channel: undefined, gitTag: 'v1.0.0', gitHead: '710bf7059301bc5abccac81392cdbdd56bc101e4' }, { version: '1.1.0', channel: undefined, gitTag: 'v1.1.0', gitHead: '3ca9698074c23b49e98f7c8171d9ed16627c2c75' }, { version: '1.10.0', channel: undefined, gitTag: 'v1.10.0', gitHead: 'c763d75e6c876f9e9e3e058c34b37b7805f971e5' }, { version: '1.10.1', channel: undefined, gitTag: 'v1.10.1', gitHead: 'ff3ecb9730d28a3b539c6f5412618adc1ebef8c3' }, { version: '1.10.2', channel: undefined, gitTag: 'v1.10.2', gitHead: '507f63f573fb80cdf2ec1bdbe048a6fd090cd928' }, { version: '1.11.0', channel: undefined, gitTag: 'v1.11.0', gitHead: 'd841840cf2bfc64d96ec2031fb132529fa976e64' }, { version: '1.12.0', channel: undefined, gitTag: 'v1.12.0', gitHead: '358ba8817772067a6e87fe948d7e443631fed7ba' }, { version: '1.13.0', channel: undefined, gitTag: 'v1.13.0', gitHead: '5942254e0f157aece6e44ebc5c8b7fcf2b6de29c' }, { version: '1.14.0', channel: undefined, gitTag: 'v1.14.0', gitHead: '0e6558ff63e67c307973186b833393da0b6f8b51' }, { version: '1.15.0', channel: undefined, gitTag: 'v1.15.0', gitHead: '25de7869c9962dc1d9fc9fcf9e8336f5256d2747' }, { version: '1.16.0', channel: undefined, gitTag: 'v1.16.0', gitHead: '6e8687a2b37c818626933acc3a0a42924e18c537' }, { version: '1.17.0', channel: undefined, gitTag: 'v1.17.0', gitHead: 'd5c86e943362c97bcea543202082b6b3df781e53' }, { version: '1.18.0', channel: undefined, gitTag: 'v1.18.0', gitHead: '0cb9270059bd68b2a29da6ca23cb923979820b8e' }, { version: '1.19.0', channel: undefined, gitTag: 'v1.19.0', gitHead: 'e41f59a2162dc4ab6b235b399e4a0c33138e2963' }, { version: '1.19.0', channel: '1.19.x', gitTag: 'v1.19.0@1.19.x', gitHead: 'e41f59a2162dc4ab6b235b399e4a0c33138e2963' }, { version: '1.2.0', channel: undefined, gitTag: 'v1.2.0', gitHead: '96eb77b16cfa37d22de1e20263fab3ec3dc4fa10' }, { version: '1.3.0', channel: undefined, gitTag: 'v1.3.0', gitHead: 'bc189023f4d11550d1d1dc32d493ab6d110f7e2d' }, { version: '1.4.0', channel: undefined, gitTag: 'v1.4.0', gitHead: '12f80ff4a2a5c1c587e6d6d6eb2f3619b9cd1e33' }, { version: '1.5.0', channel: undefined, gitTag: 'v1.5.0', gitHead: '121baa9f74cbcbaf53d753a3bc8402fee841b32f' }, { version: '1.6.0', channel: undefined, gitTag: 'v1.6.0', gitHead: '4514887b95b357637e2b7b6948e2bedb1b2a0547' }, { version: '1.6.1', channel: undefined, gitTag: 'v1.6.1', gitHead: '5f50575a3fe327d8d54751126519ee456ff69c95' }, { version: '1.7.0', channel: undefined, gitTag: 'v1.7.0', gitHead: 'cde7d7676d325056534c46649d1ed2c3459d071b' }, { version: '1.8.0', channel: undefined, gitTag: 'v1.8.0', gitHead: 'f053541c1bb277f414c9e0f0dbc4d19e7e06db05' }, { version: '1.8.1', channel: undefined, gitTag: 'v1.8.1', gitHead: '1413b49f5677f51520f34528943fdbe48645032d' }, { version: '1.9.0', channel: undefined, gitTag: 'v1.9.0', gitHead: 'd12e4bdf618741145883317f029b9150ee41a1e5' }, { version: '1.9.1', channel: undefined, gitTag: 'v1.9.1', gitHead: '975ead63ad0b5b1863b8966af43d253e0fa80155' } ] +1s\n  semantic-release:get-tags found tags for branch master: [ { version: '1.0.0', channel: undefined, gitTag: 'v1.0.0', gitHead: '710bf7059301bc5abccac81392cdbdd56bc101e4' }, { version: '1.1.0', channel: undefined, gitTag: 'v1.1.0', gitHead: '3ca9698074c23b49e98f7c8171d9ed16627c2c75' }, { version: '1.10.0', channel: undefined, gitTag: 'v1.10.0', gitHead: 'c763d75e6c876f9e9e3e058c34b37b7805f971e5' }, { version: '1.10.1', channel: undefined, gitTag: 'v1.10.1', gitHead: 'ff3ecb9730d28a3b539c6f5412618adc1ebef8c3' }, { version: '1.10.2', channel: undefined, gitTag: 'v1.10.2', gitHead: '507f63f573fb80cdf2ec1bdbe048a6fd090cd928' }, { version: '1.11.0', channel: undefined, gitTag: 'v1.11.0', gitHead: 'd841840cf2bfc64d96ec2031fb132529fa976e64' }, { version: '1.12.0', channel: undefined, gitTag: 'v1.12.0', gitHead: '358ba8817772067a6e87fe948d7e443631fed7ba' }, { version: '1.13.0', channel: undefined, gitTag: 'v1.13.0', gitHead: '5942254e0f157aece6e44ebc5c8b7fcf2b6de29c' }, { version: '1.14.0', channel: undefined, gitTag: 'v1.14.0', gitHead: '0e6558ff63e67c307973186b833393da0b6f8b51' }, { version: '1.15.0', channel: undefined, gitTag: 'v1.15.0', gitHead: '25de7869c9962dc1d9fc9fcf9e8336f5256d2747' }, { version: '1.16.0', channel: undefined, gitTag: 'v1.16.0', gitHead: '6e8687a2b37c818626933acc3a0a42924e18c537' }, { version: '1.17.0', channel: undefined, gitTag: 'v1.17.0', gitHead: 'd5c86e943362c97bcea543202082b6b3df781e53' }, { version: '1.18.0', channel: undefined, gitTag: 'v1.18.0', gitHead: '0cb9270059bd68b2a29da6ca23cb923979820b8e' }, { version: '1.19.0', channel: undefined, gitTag: 'v1.19.0', gitHead: 'e41f59a2162dc4ab6b235b399e4a0c33138e2963' }, { version: '1.19.0', channel: '1.19.x', gitTag: 'v1.19.0@1.19.x', gitHead: 'e41f59a2162dc4ab6b235b399e4a0c33138e2963' }, { version: '1.2.0', channel: undefined, gitTag: 'v1.2.0', gitHead: '96eb77b16cfa37d22de1e20263fab3ec3dc4fa10' }, { version: '1.20.0', channel: undefined, gitTag: 'v1.20.0', gitHead: '2dcec5f578178d726e67a428a15c1140c0743a1e' }, { version: '1.3.0', channel: undefined, gitTag: 'v1.3.0', gitHead: 'bc189023f4d11550d1d1dc32d493ab6d110f7e2d' }, { version: '1.4.0', channel: undefined, gitTag: 'v1.4.0', gitHead: '12f80ff4a2a5c1c587e6d6d6eb2f3619b9cd1e33' }, { version: '1.5.0', channel: undefined, gitTag: 'v1.5.0', gitHead: '121baa9f74cbcbaf53d753a3bc8402fee841b32f' }, { version: '1.6.0', channel: undefined, gitTag: 'v1.6.0', gitHead: '4514887b95b357637e2b7b6948e2bedb1b2a0547' }, { version: '1.6.1', channel: undefined, gitTag: 'v1.6.1', gitHead: '5f50575a3fe327d8d54751126519ee456ff69c95' }, { version: '1.7.0', channel: undefined, gitTag: 'v1.7.0', gitHead: 'cde7d7676d325056534c46649d1ed2c3459d071b' }, { version: '1.8.0', channel: undefined, gitTag: 'v1.8.0', gitHead: 'f053541c1bb277f414c9e0f0dbc4d19e7e06db05' }, { version: '1.8.1', channel: undefined, gitTag: 'v1.8.1', gitHead: '1413b49f5677f51520f34528943fdbe48645032d' }, { version: '1.9.0', channel: undefined, gitTag: 'v1.9.0', gitHead: 'd12e4bdf618741145883317f029b9150ee41a1e5' }, { version: '1.9.1', channel: undefined, gitTag: 'v1.9.1', gitHead: '975ead63ad0b5b1863b8966af43d253e0fa80155' } ] +1s\n[2:36:35 AM] [semantic-release] \u203a \u2714  Run automated release from branch 1.19.x\n[2:36:42 AM] [semantic-release] \u203a \u2714  Allowed to push to the Git repository\n[2:36:42 AM] [semantic-release] \u203a \u2139  Start step \"verifyConditions\" of plugin \"@semantic-release/changelog\"\n[2:36:42 AM] [semantic-release] \u203a \u2714  Completed step \"verifyConditions\" of plugin \"@semantic-release/changelog\"\n[2:36:42 AM] [semantic-release] \u203a \u2139  Start step \"verifyConditions\" of plugin \"@semantic-release/npm\"\n[2:36:42 AM] [semantic-release] [@semantic-release/npm] \u203a \u2139  Verify authentication for registry http://nexus.site.int/repository/npm-private/\n[2:36:42 AM] [semantic-release] \u203a \u2714  Completed step \"verifyConditions\" of plugin \"@semantic-release/npm\"\n[2:36:42 AM] [semantic-release] \u203a \u2139  Start step \"verifyConditions\" of plugin \"@semantic-release/git\"\n[2:36:42 AM] [semantic-release] \u203a \u2714  Completed step \"verifyConditions\" of plugin \"@semantic-release/git\"\n[2:36:42 AM] [semantic-release] \u203a \u2139  No git tag version found on branch 1.19.x\n[2:36:42 AM] [semantic-release] \u203a \u2139  Found git tag v1.0.0 associated with version 1.0.0 on branch 1.19.x\n[2:36:42 AM] [semantic-release] \u203a \u2139  Found git tag v1.1.0 associated with version 1.1.0 on branch 1.19.x\n[2:36:42 AM] [semantic-release] \u203a \u2139  Found git tag v1.2.0 associated with version 1.2.0 on branch 1.19.x\n[2:36:42 AM] [semantic-release] \u203a \u2139  Found git tag v1.3.0 associated with version 1.3.0 on branch 1.19.x\n[2:36:42 AM] [semantic-release] \u203a \u2139  Found git tag v1.4.0 associated with version 1.4.0 on branch 1.19.x\n[2:36:42 AM] [semantic-release] \u203a \u2139  Found git tag v1.5.0 associated with version 1.5.0 on branch 1.19.x\n[2:36:42 AM] [semantic-release] \u203a \u2139  Found git tag v1.6.0 associated with version 1.6.0 on branch 1.19.x\n[2:36:42 AM] [semantic-release] \u203a \u2139  Found git tag v1.6.1 associated with version 1.6.1 on branch 1.19.x\n[2:36:42 AM] [semantic-release] \u203a \u2139  Found git tag v1.7.0 associated with version 1.7.0 on branch 1.19.x\n[2:36:42 AM] [semantic-release] \u203a \u2139  Found git tag v1.8.0 associated with version 1.8.0 on branch 1.19.x\n[2:36:42 AM] [semantic-release] \u203a \u2139  Found git tag v1.8.1 associated with version 1.8.1 on branch 1.19.x\n[2:36:42 AM] [semantic-release] \u203a \u2139  Found git tag v1.9.0 associated with version 1.9.0 on branch 1.19.x\n[2:36:42 AM] [semantic-release] \u203a \u2139  Found git tag v1.9.1 associated with version 1.9.1 on branch 1.19.x\n[2:36:42 AM] [semantic-release] \u203a \u2139  Found git tag v1.10.0 associated with version 1.10.0 on branch 1.19.x\n[2:36:42 AM] [semantic-release] \u203a \u2139  Found git tag v1.10.1 associated with version 1.10.1 on branch 1.19.x\n[2:36:42 AM] [semantic-release] \u203a \u2139  Found git tag v1.10.2 associated with version 1.10.2 on branch 1.19.x\n[2:36:42 AM] [semantic-release] \u203a \u2139  Found git tag v1.11.0 associated with version 1.11.0 on branch 1.19.x\n[2:36:42 AM] [semantic-release] \u203a \u2139  Found git tag v1.12.0 associated with version 1.12.0 on branch 1.19.x\n[2:36:42 AM] [semantic-release] \u203a \u2139  Found git tag v1.13.0 associated with version 1.13.0 on branch 1.19.x\n[2:36:42 AM] [semantic-release] \u203a \u2139  Found git tag v1.14.0 associated with version 1.14.0 on branch 1.19.x\n[2:36:42 AM] [semantic-release] \u203a \u2139  Found git tag v1.15.0 associated with version 1.15.0 on branch 1.19.x\n[2:36:42 AM] [semantic-release] \u203a \u2139  Found git tag v1.16.0 associated with version 1.16.0 on branch 1.19.x\n[2:36:42 AM] [semantic-release] \u203a \u2139  Found git tag v1.17.0 associated with version 1.17.0 on branch 1.19.x\n[2:36:42 AM] [semantic-release] \u203a \u2716  EINVALIDMAINTENANCEMERGE The release1.0.0on branch1.19.x` cannot be published as it is out of range.\nOnly releases within the range >=1.19.0 <1.20.0 can be merged into the maintenance branch 1.19.x and published to the 1.19.x distribution channel.\nThe branch 1.19.x head should be reset (https://git-scm.com/docs/git-reset) to a previous commit so the commit with tag v1.0.0@1.19.x is removed from the branch history.\nSee the workflow configuration documentation (https://github.com/semantic-release/semantic-release/blob/master/docs/usage/workflow-configuration.md) for more details.\n[2:36:42 AM] [semantic-release] \u203a \u2716  EINVALIDMAINTENANCEMERGE The release 1.7.0 on branch 1.19.x cannot be published as it is out of range.\nOnly releases within the range >=1.19.0 <1.20.0 can be merged into the maintenance branch 1.19.x and published to the 1.19.x distribution channel.\nThe branch 1.19.x head should be reset (https://git-scm.com/docs/git-reset) to a previous commit so the commit with tag v1.7.0@1.19.x is removed from the branch history.\nSee the workflow configuration documentation (https://github.com/semantic-release/semantic-release/blob/master/docs/usage/workflow-configuration.md) for more details.\n[2:36:42 AM] [semantic-release] \u203a \u2716  EINVALIDMAINTENANCEMERGE The release 1.8.0 on branch 1.19.x cannot be published as it is out of range.\nOnly releases within the range >=1.19.0 <1.20.0 can be merged into the maintenance branch 1.19.x and published to the 1.19.x distribution channel.\nThe branch 1.19.x head should be reset (https://git-scm.com/docs/git-reset) to a previous commit so the commit with tag v1.8.0@1.19.x is removed from the branch history.\nSee the workflow configuration documentation (https://github.com/semantic-release/semantic-release/blob/master/docs/usage/workflow-configuration.md) for more details.\n[2:36:42 AM] [semantic-release] \u203a \u2716  EINVALIDMAINTENANCEMERGE The release 1.8.1 on branch 1.19.x cannot be published as it is out of range.\nOnly releases within the range >=1.19.0 <1.20.0 can be merged into the maintenance branch 1.19.x and published to the 1.19.x distribution channel.\nThe branch 1.19.x head should be reset (https://git-scm.com/docs/git-reset) to a previous commit so the commit with tag v1.8.1@1.19.x is removed from the branch history.\nSee the workflow configuration documentation (https://github.com/semantic-release/semantic-release/blob/master/docs/usage/workflow-configuration.md) for more details.\n[2:36:42 AM] [semantic-release] \u203a \u2716  EINVALIDMAINTENANCEMERGE The release 1.9.0 on branch 1.19.x cannot be published as it is out of range.\nOnly releases within the range >=1.19.0 <1.20.0 can be merged into the maintenance branch 1.19.x and published to the 1.19.x distribution channel.\nThe branch 1.19.x head should be reset (https://git-scm.com/docs/git-reset) to a previous commit so the commit with tag v1.9.0@1.19.x is removed from the branch history.\nSee the workflow configuration documentation (https://github.com/semantic-release/semantic-release/blob/master/docs/usage/workflow-configuration.md) for more details.\n[2:36:42 AM] [semantic-release] \u203a \u2716  EINVALIDMAINTENANCEMERGE The release 1.6.1 on branch 1.19.x cannot be published as it is out of range.\nOnly releases within the range >=1.19.0 <1.20.0 can be merged into the maintenance branch 1.19.x and published to the 1.19.x distribution channel.\nThe branch 1.19.x head should be reset (https://git-scm.com/docs/git-reset) to a previous commit so the commit with tag v1.6.1@1.19.x is removed from the branch history.\nSee the workflow configuration documentation (https://github.com/semantic-release/semantic-release/blob/master/docs/usage/workflow-configuration.md) for more details.\n[2:36:42 AM] [semantic-release] \u203a \u2716  EINVALIDMAINTENANCEMERGE The release 1.10.0 on branch 1.19.x cannot be published as it is out of range.\nOnly releases within the range >=1.19.0 <1.20.0 can be merged into the maintenance branch 1.19.x and published to the 1.19.x distribution channel.\nThe branch 1.19.x head should be reset (https://git-scm.com/docs/git-reset) to a previous commit so the commit with tag v1.10.0@1.19.x is removed from the branch history.\nSee the workflow configuration documentation (https://github.com/semantic-release/semantic-release/blob/master/docs/usage/workflow-configuration.md) for more details.\n[2:36:42 AM] [semantic-release] \u203a \u2716  EINVALIDMAINTENANCEMERGE The release 1.10.1 on branch 1.19.x cannot be published as it is out of range.\nOnly releases within the range >=1.19.0 <1.20.0 can be merged into the maintenance branch 1.19.x and published to the 1.19.x distribution channel.\nThe branch 1.19.x head should be reset (https://git-scm.com/docs/git-reset) to a previous commit so the commit with tag v1.10.1@1.19.x is removed from the branch history.\nSee the workflow configuration documentation (https://github.com/semantic-release/semantic-release/blob/master/docs/usage/workflow-configuration.md) for more details.\n[2:36:42 AM] [semantic-release] \u203a \u2716  EINVALIDMAINTENANCEMERGE The release 1.10.2 on branch 1.19.x cannot be published as it is out of range.\nOnly releases within the range >=1.19.0 <1.20.0 can be merged into the maintenance branch 1.19.x and published to the 1.19.x distribution channel.\nThe branch 1.19.x head should be reset (https://git-scm.com/docs/git-reset) to a previous commit so the commit with tag v1.10.2@1.19.x is removed from the branch history.\nSee the workflow configuration documentation (https://github.com/semantic-release/semantic-release/blob/master/docs/usage/workflow-configuration.md) for more details.\n[2:36:42 AM] [semantic-release] \u203a \u2716  EINVALIDMAINTENANCEMERGE The release 1.11.0 on branch 1.19.x cannot be published as it is out of range.\nOnly releases within the range >=1.19.0 <1.20.0 can be merged into the maintenance branch 1.19.x and published to the 1.19.x distribution channel.\nThe branch 1.19.x head should be reset (https://git-scm.com/docs/git-reset) to a previous commit so the commit with tag v1.11.0@1.19.x is removed from the branch history.\nSee the workflow configuration documentation (https://github.com/semantic-release/semantic-release/blob/master/docs/usage/workflow-configuration.md) for more details.\n[2:36:42 AM] [semantic-release] \u203a \u2716  EINVALIDMAINTENANCEMERGE The release 1.12.0 on branch 1.19.x cannot be published as it is out of range.\nOnly releases within the range >=1.19.0 <1.20.0 can be merged into the maintenance branch 1.19.x and published to the 1.19.x distribution channel.\nThe branch 1.19.x head should be reset (https://git-scm.com/docs/git-reset) to a previous commit so the commit with tag v1.12.0@1.19.x is removed from the branch history.\nSee the workflow configuration documentation (https://github.com/semantic-release/semantic-release/blob/master/docs/usage/workflow-configuration.md) for more details.\n[2:36:42 AM] [semantic-release] \u203a \u2716  EINVALIDMAINTENANCEMERGE The release 1.6.0 on branch 1.19.x cannot be published as it is out of range.\nOnly releases within the range >=1.19.0 <1.20.0 can be merged into the maintenance branch 1.19.x and published to the 1.19.x distribution channel.\nThe branch 1.19.x head should be reset (https://git-scm.com/docs/git-reset) to a previous commit so the commit with tag v1.6.0@1.19.x is removed from the branch history.\nSee the workflow configuration documentation (https://github.com/semantic-release/semantic-release/blob/master/docs/usage/workflow-configuration.md) for more details.\n[2:36:42 AM] [semantic-release] \u203a \u2716  EINVALIDMAINTENANCEMERGE The release 1.13.0 on branch 1.19.x cannot be published as it is out of range.\nOnly releases within the range >=1.19.0 <1.20.0 can be merged into the maintenance branch 1.19.x and published to the 1.19.x distribution channel.\nThe branch 1.19.x head should be reset (https://git-scm.com/docs/git-reset) to a previous commit so the commit with tag v1.13.0@1.19.x is removed from the branch history.\nSee the workflow configuration documentation (https://github.com/semantic-release/semantic-release/blob/master/docs/usage/workflow-configuration.md) for more details.\n[2:36:42 AM] [semantic-release] \u203a \u2716  EINVALIDMAINTENANCEMERGE The release 1.5.0 on branch 1.19.x cannot be published as it is out of range.\nOnly releases within the range >=1.19.0 <1.20.0 can be merged into the maintenance branch 1.19.x and published to the 1.19.x distribution channel.\nThe branch 1.19.x head should be reset (https://git-scm.com/docs/git-reset) to a previous commit so the commit with tag v1.5.0@1.19.x is removed from the branch history.\nSee the workflow configuration documentation (https://github.com/semantic-release/semantic-release/blob/master/docs/usage/workflow-configuration.md) for more details.\n[2:36:42 AM] [semantic-release] \u203a \u2716  EINVALIDMAINTENANCEMERGE The release 1.14.0 on branch 1.19.x cannot be published as it is out of range.\nOnly releases within the range >=1.19.0 <1.20.0 can be merged into the maintenance branch 1.19.x and published to the 1.19.x distribution channel.\nThe branch 1.19.x head should be reset (https://git-scm.com/docs/git-reset) to a previous commit so the commit with tag v1.14.0@1.19.x is removed from the branch history.\nSee the workflow configuration documentation (https://github.com/semantic-release/semantic-release/blob/master/docs/usage/workflow-configuration.md) for more details.\n[2:36:42 AM] [semantic-release] \u203a \u2716  EINVALIDMAINTENANCEMERGE The release 1.4.0 on branch 1.19.x cannot be published as it is out of range.\nOnly releases within the range >=1.19.0 <1.20.0 can be merged into the maintenance branch 1.19.x and published to the 1.19.x distribution channel.\nThe branch 1.19.x head should be reset (https://git-scm.com/docs/git-reset) to a previous commit so the commit with tag v1.4.0@1.19.x is removed from the branch history.\nSee the workflow configuration documentation (https://github.com/semantic-release/semantic-release/blob/master/docs/usage/workflow-configuration.md) for more details.\n[2:36:42 AM] [semantic-release] \u203a \u2716  EINVALIDMAINTENANCEMERGE The release 1.15.0 on branch 1.19.x cannot be published as it is out of range.\nOnly releases within the range >=1.19.0 <1.20.0 can be merged into the maintenance branch 1.19.x and published to the 1.19.x distribution channel.\nThe branch 1.19.x head should be reset (https://git-scm.com/docs/git-reset) to a previous commit so the commit with tag v1.15.0@1.19.x is removed from the branch history.\nSee the workflow configuration documentation (https://github.com/semantic-release/semantic-release/blob/master/docs/usage/workflow-configuration.md) for more details.\n[2:36:42 AM] [semantic-release] \u203a \u2716  EINVALIDMAINTENANCEMERGE The release 1.3.0 on branch 1.19.x cannot be published as it is out of range.\nOnly releases within the range >=1.19.0 <1.20.0 can be merged into the maintenance branch 1.19.x and published to the 1.19.x distribution channel.\nThe branch 1.19.x head should be reset (https://git-scm.com/docs/git-reset) to a previous commit so the commit with tag v1.3.0@1.19.x is removed from the branch history.\nSee the workflow configuration documentation (https://github.com/semantic-release/semantic-release/blob/master/docs/usage/workflow-configuration.md) for more details.\n[2:36:42 AM] [semantic-release] \u203a \u2716  EINVALIDMAINTENANCEMERGE The release 1.16.0 on branch 1.19.x cannot be published as it is out of range.\nOnly releases within the range >=1.19.0 <1.20.0 can be merged into the maintenance branch 1.19.x and published to the 1.19.x distribution channel.\nThe branch 1.19.x head should be reset (https://git-scm.com/docs/git-reset) to a previous commit so the commit with tag v1.16.0@1.19.x is removed from the branch history.\nSee the workflow configuration documentation (https://github.com/semantic-release/semantic-release/blob/master/docs/usage/workflow-configuration.md) for more details.\n[2:36:42 AM] [semantic-release] \u203a \u2716  EINVALIDMAINTENANCEMERGE The release 1.2.0 on branch 1.19.x cannot be published as it is out of range.\nOnly releases within the range >=1.19.0 <1.20.0 can be merged into the maintenance branch 1.19.x and published to the 1.19.x distribution channel.\nThe branch 1.19.x head should be reset (https://git-scm.com/docs/git-reset) to a previous commit so the commit with tag v1.2.0@1.19.x is removed from the branch history.\n```. hi, i destroyed the branch locally and orgin and did everything again - and the same result\ni won't paste the error here, its the same as before\n. When i create a branch from the tag, the package.json has 1.19.0 version in there. I should leave that as is - correct? The conventional commits should take care of incrementing the version ?\n. sure, i am on it now.. i still have problems, see the logs below BUT - I didn't update the version number, it was set at 1.21.0 in the package.json - i did a conventional commit of fix() so i assume it should bump it to 1.21.1 - but it didn't\n```\nTo lab.site.int:fe/poc/semantic-release-poc.git\n * [new branch]      1.21.x -> 1.21.x\nBranch '1.21.x' set up to track remote branch '1.21.x' from 'origin'.\n\u279c  semantic-release-poc git:(1.21.x) npx semantic-release --no-ci\n[1:34:26 AM] [semantic-release] \u203a \u2139  Running semantic-release version 16.0.0-beta.11\n[1:34:26 AM] [semantic-release] \u203a \u2714  Loaded plugin \"verifyConditions\" from \"@semantic-release/changelog\"\n[1:34:26 AM] [semantic-release] \u203a \u2714  Loaded plugin \"verifyConditions\" from \"@semantic-release/npm\"\n[1:34:26 AM] [semantic-release] \u203a \u2714  Loaded plugin \"verifyConditions\" from \"@semantic-release/git\"\n[1:34:26 AM] [semantic-release] \u203a \u2714  Loaded plugin \"analyzeCommits\" from \"@semantic-release/commit-analyzer\"\n[1:34:26 AM] [semantic-release] \u203a \u2714  Loaded plugin \"generateNotes\" from \"@semantic-release/release-notes-generator\"\n[1:34:26 AM] [semantic-release] \u203a \u2714  Loaded plugin \"prepare\" from \"@semantic-release/changelog\"\n[1:34:26 AM] [semantic-release] \u203a \u2714  Loaded plugin \"prepare\" from \"@semantic-release/npm\"\n[1:34:26 AM] [semantic-release] \u203a \u2714  Loaded plugin \"prepare\" from \"@semantic-release/git\"\n[1:34:26 AM] [semantic-release] \u203a \u2714  Loaded plugin \"publish\" from \"@semantic-release/npm\"\n[1:34:26 AM] [semantic-release] \u203a \u2714  Loaded plugin \"addChannel\" from \"@semantic-release/npm\"\n[1:34:36 AM] [semantic-release] \u203a \u2714  Run automated release from branch 1.21.x\n[1:34:42 AM] [semantic-release] \u203a \u2714  Allowed to push to the Git repository\n[1:34:42 AM] [semantic-release] \u203a \u2139  Start step \"verifyConditions\" of plugin \"@semantic-release/changelog\"\n[1:34:42 AM] [semantic-release] \u203a \u2714  Completed step \"verifyConditions\" of plugin \"@semantic-release/changelog\"\n[1:34:42 AM] [semantic-release] \u203a \u2139  Start step \"verifyConditions\" of plugin \"@semantic-release/npm\"\n[1:34:42 AM] [semantic-release] [@semantic-release/npm] \u203a \u2139  Verify authentication for registry http://nexus.siter.int/repository/npm-private/\n[1:34:42 AM] [semantic-release] \u203a \u2714  Completed step \"verifyConditions\" of plugin \"@semantic-release/npm\"\n[1:34:42 AM] [semantic-release] \u203a \u2139  Start step \"verifyConditions\" of plugin \"@semantic-release/git\"\n[1:34:42 AM] [semantic-release] \u203a \u2714  Completed step \"verifyConditions\" of plugin \"@semantic-release/git\"\n[1:34:42 AM] [semantic-release] \u203a \u2139  Found 5 commits since last release\n[1:34:42 AM] [semantic-release] \u203a \u2139  Start step \"generateNotes\" of plugin \"@semantic-release/release-notes-generator\"\n[1:34:42 AM] [semantic-release] \u203a \u2714  Completed step \"generateNotes\" of plugin \"@semantic-release/release-notes-generator\"\n[1:34:42 AM] [semantic-release] \u203a \u2139  Create tag v1.21.0@1.21.x\n[1:34:46 AM] [semantic-release] \u203a \u2139  Start step \"addChannel\" of plugin \"@semantic-release/npm\"\n[1:34:46 AM] [semantic-release] [@semantic-release/npm] \u203a \u2139  Adding version 1.21.0 to npm registry on dist-tag release-1.21.x\nnpm ERR! registry error parsing json\nnpm ERR! Unexpected token < in JSON at position 1\nnpm ERR!\nnpm ERR! <!DOCTYPE html>\nnpm ERR! \nnpm ERR! \nnpm ERR!   400 - Nexus Repository Manager\nnpm ERR!   \nnpm ERR!\n```. basically, it seems to want to tag it with 1.21.0 - which technically already exists AND then it tries to publish it on my private npm server as 1.21.0 - which technically already exists.\n. ok - so i think i have it working now - but maybe it shouldn't be like that ? Let me explain.\nI create a branch and if i leave the version at 1.21.0 in package.json then no bump happens... in fact it errors out as above... Even with the conventional commit.\nI had to manually bump the version to 1.21.1 - now the tag is created and version is released..\nnow if i make another conventional commit (fix) .. it is now automatically bumped to 1.21.2\nnow i make another conventional commit (fix) - it is now automatically bumped to 1.21.3\n. Now - i tried to simulate the merge back from the 1.21.x branch into master and then re-release from master...\nmaster now gets a bump of (fix) .... take a look - this is right - correct ?\n\nSo it appears the merging back seems to work correctly ??\nBut the initial maintenance branch creation and release - is an issue - see above explanation.\nLet me know if I can help further.. Sure, let me try the manually adding now...\nYes I am running nexus.. Actually, still got the error msg from before in my iterm history.. placing it below\n```\n\u279c  semantic-release-poc git:(1.21.x) npx semantic-release --no-ci\n[1:34:26 AM] [semantic-release] \u203a \u2139  Running semantic-release version 16.0.0-beta.11\n[1:34:26 AM] [semantic-release] \u203a \u2714  Loaded plugin \"verifyConditions\" from \"@semantic-release/changelog\"\n[1:34:26 AM] [semantic-release] \u203a \u2714  Loaded plugin \"verifyConditions\" from \"@semantic-release/npm\"\n[1:34:26 AM] [semantic-release] \u203a \u2714  Loaded plugin \"verifyConditions\" from \"@semantic-release/git\"\n[1:34:26 AM] [semantic-release] \u203a \u2714  Loaded plugin \"analyzeCommits\" from \"@semantic-release/commit-analyzer\"\n[1:34:26 AM] [semantic-release] \u203a \u2714  Loaded plugin \"generateNotes\" from \"@semantic-release/release-notes-generator\"\n[1:34:26 AM] [semantic-release] \u203a \u2714  Loaded plugin \"prepare\" from \"@semantic-release/changelog\"\n[1:34:26 AM] [semantic-release] \u203a \u2714  Loaded plugin \"prepare\" from \"@semantic-release/npm\"\n[1:34:26 AM] [semantic-release] \u203a \u2714  Loaded plugin \"prepare\" from \"@semantic-release/git\"\n[1:34:26 AM] [semantic-release] \u203a \u2714  Loaded plugin \"publish\" from \"@semantic-release/npm\"\n[1:34:26 AM] [semantic-release] \u203a \u2714  Loaded plugin \"addChannel\" from \"@semantic-release/npm\"\n[1:34:36 AM] [semantic-release] \u203a \u2714  Run automated release from branch 1.21.x\n[1:34:42 AM] [semantic-release] \u203a \u2714  Allowed to push to the Git repository\n[1:34:42 AM] [semantic-release] \u203a \u2139  Start step \"verifyConditions\" of plugin \"@semantic-release/changelog\"\n[1:34:42 AM] [semantic-release] \u203a \u2714  Completed step \"verifyConditions\" of plugin \"@semantic-release/changelog\"\n[1:34:42 AM] [semantic-release] \u203a \u2139  Start step \"verifyConditions\" of plugin \"@semantic-release/npm\"\n[1:34:42 AM] [semantic-release] [@semantic-release/npm] \u203a \u2139  Verify authentication for registry http://nexus.site.int/repository/npm-private/\n[1:34:42 AM] [semantic-release] \u203a \u2714  Completed step \"verifyConditions\" of plugin \"@semantic-release/npm\"\n[1:34:42 AM] [semantic-release] \u203a \u2139  Start step \"verifyConditions\" of plugin \"@semantic-release/git\"\n[1:34:42 AM] [semantic-release] \u203a \u2714  Completed step \"verifyConditions\" of plugin \"@semantic-release/git\"\n[1:34:42 AM] [semantic-release] \u203a \u2139  Found 5 commits since last release\n[1:34:42 AM] [semantic-release] \u203a \u2139  Start step \"generateNotes\" of plugin \"@semantic-release/release-notes-generator\"\n[1:34:42 AM] [semantic-release] \u203a \u2714  Completed step \"generateNotes\" of plugin \"@semantic-release/release-notes-generator\"\n[1:34:42 AM] [semantic-release] \u203a \u2139  Create tag v1.21.0@1.21.x\n[1:34:46 AM] [semantic-release] \u203a \u2139  Start step \"addChannel\" of plugin \"@semantic-release/npm\"\n[1:34:46 AM] [semantic-release] [@semantic-release/npm] \u203a \u2139  Adding version 1.21.0 to npm registry on dist-tag release-1.21.x\nnpm ERR! registry error parsing json\nnpm ERR! Unexpected token < in JSON at position 1\nnpm ERR!\nnpm ERR! <!DOCTYPE html>\nnpm ERR! \nnpm ERR! \nnpm ERR!   400 - Nexus Repository Manager\nnpm ERR!   \nnpm ERR!\nnpm ERR!\nnpm ERR!   [if lt IE 9]>\nnpm ERR!   <script>(new Image).src=\"http://nexus.site.int/favicon.ico?3.12.1-01\"</script>\nnpm ERR!   <![endif]\nnpm ERR!   \nnpm ERR!   \nnpm ERR!   \nnpm ERR!   \nnpm ERR!   \nnpm ERR!   \nnpm ERR!\nnpm ERR!   \nnpm ERR! \nnpm ERR! \nnpm ERR! \nnpm ERR!   \nnpm ERR!     \nnpm ERR!       \nnpm ERR!     \nnpm ERR!     \nnpm ERR!       \nnpm ERR!         Nexus Repository Manager\nnpm ERR!       \nnpm ERR!       \nnpm ERR!         OSS 3.12.1-01\nnpm ERR!       \nnpm ERR!     \nnpm ERR!   \nnpm ERR! \nnpm ERR!\nnpm ERR! \nnpm ERR!   \nnpm ERR!     \nnpm ERR!     Error 400\nnpm ERR!     Bad Request\nnpm ERR!   \nnpm ERR!   \nnpm ERR!     \nnpm ERR!       Bad Request\nnpm ERR!     \nnpm ERR!       \nnpm ERR! \nnpm ERR! \nnpm ERR! \nnpm ERR!\nnpm ERR!\nnpm ERR! A complete log of this run can be found in:\nnpm ERR!     /Users/ian/.npm/_logs/2018-12-18T00_34_47_003Z-debug.log\n[1:34:47 AM] [semantic-release] \u203a \u2716  Failed step \"addChannel\" of plugin \"@semantic-release/npm\"\n[1:34:47 AM] [semantic-release] \u203a \u2716  An error occurred while running semantic-release: { Error: Command failed: npm dist-tag add @reltester/semantec-release-poc@1.21.0 release-1.21.x --registry http://nexus.site.int/repository/npm-private/\nnpm ERR! registry error parsing json\nnpm ERR! Unexpected token < in JSON at position 1\nnpm ERR!\nnpm ERR! <!DOCTYPE html>\nnpm ERR! \nnpm ERR! \nnpm ERR!   400 - Nexus Repository Manager\nnpm ERR!   \nnpm ERR!\nnpm ERR!\nnpm ERR!   [if lt IE 9]>\nnpm ERR!   <script>(new Image).src=\"http://nexus.site.int/favicon.ico?3.12.1-01\"</script>\nnpm ERR!   <![endif]\nnpm ERR!   \nnpm ERR!   \nnpm ERR!   \nnpm ERR!   \nnpm ERR!   \nnpm ERR!   \nnpm ERR!\nnpm ERR!   \nnpm ERR! \nnpm ERR! \nnpm ERR! \nnpm ERR!   \nnpm ERR!     \nnpm ERR!       \nnpm ERR!     \nnpm ERR!     \nnpm ERR!       \nnpm ERR!         Nexus Repository Manager\nnpm ERR!       \nnpm ERR!       \nnpm ERR!         OSS 3.12.1-01\nnpm ERR!       \nnpm ERR!     \nnpm ERR!   \nnpm ERR! \nnpm ERR!\nnpm ERR! \nnpm ERR!   \nnpm ERR!     \nnpm ERR!     Error 400\nnpm ERR!     Bad Request\nnpm ERR!   \nnpm ERR!   \nnpm ERR!     \nnpm ERR!       Bad Request\nnpm ERR!     \nnpm ERR!       \nnpm ERR! \nnpm ERR! \nnpm ERR! \nnpm ERR!\nnpm ERR!\nnpm ERR! A complete log of this run can be found in:\nnpm ERR!     /Users/ian/.npm/_logs/2018-12-18T00_34_47_003Z-debug.log\nat makeError (/Users/ian/Development/Scratch/POC/semantic-release-poc/node_modules/execa/index.js:174:9)\nat Promise.all.then.arr (/Users/ian/Development/Scratch/POC/semantic-release-poc/node_modules/execa/index.js:278:16)\nat process._tickCallback (internal/process/next_tick.js:68:7)\n\ncode: 1,\n  stdout: '',\n  stderr:\n   'npm ERR! registry error parsing json\\nnpm ERR! Unexpected token < in JSON at position 1\\nnpm ERR! \\nnpm ERR! <!DOCTYPE html>\\nnpm ERR! \\nnpm ERR! \\nnpm ERR!   400 - Nexus Repository Manager\\nnpm ERR!   \\nnpm ERR! \\nnpm ERR! \\nnpm ERR!   [if lt IE 9]>\\nnpm ERR!   <script>(new Image).src=\"http://nexus.site.int/favicon.ico?3.12.1-01\"</script>\\nnpm ERR!   <![endif]\\nnpm ERR!   \\nnpm ERR!   \\nnpm ERR!   \\nnpm ERR!   \\nnpm ERR!   \\nnpm ERR!   \\nnpm ERR! \\nnpm ERR!   \\nnpm ERR! \\nnpm ERR! \\nnpm ERR! \\nnpm ERR!   \\nnpm ERR!     \\nnpm ERR!       \\nnpm ERR!     \\nnpm ERR!     \\nnpm ERR!       \\nnpm ERR!         Nexus Repository Manager\\nnpm ERR!       \\nnpm ERR!       \\nnpm ERR!         OSS 3.12.1-01\\nnpm ERR!       \\nnpm ERR!     \\nnpm ERR!   \\nnpm ERR! \\nnpm ERR! \\nnpm ERR! \\nnpm ERR!   \\nnpm ERR!     \\nnpm ERR!     Error 400\\nnpm ERR!     Bad Request\\nnpm ERR!   \\nnpm ERR!   \\nnpm ERR!     \\nnpm ERR!       Bad Request\\nnpm ERR!     \\nnpm ERR!       \\nnpm ERR! \\nnpm ERR! \\nnpm ERR! \\nnpm ERR! \\nnpm ERR! \\n\\nnpm ERR! A complete log of this run can be found in:\\nnpm ERR!     /Users/ian/.npm/_logs/2018-12-18T00_34_47_003Z-debug.log\\n',\n  failed: true,\n  signal: null,\n  cmd:\n   'npm dist-tag add @reltester/semantec-release-poc@1.21.0 release-1.21.x --registry http://nexus.site.int/repository/npm-private/',\n  timedOut: false,\n  killed: false,\n  pluginName: '@semantic-release/npm' }\n{ Error: Command failed: npm dist-tag add @reltester/semantec-release-poc@1.21.0 release-1.21.x --registry http://nexus.site.int/repository/npm-private/\nnpm ERR! registry error parsing json\nnpm ERR! Unexpected token < in JSON at position 1\nnpm ERR!\nnpm ERR! <!DOCTYPE html>\nnpm ERR! \nnpm ERR! \nnpm ERR!   400 - Nexus Repository Manager\nnpm ERR!   \nnpm ERR!\nnpm ERR!\nnpm ERR!   [if lt IE 9]>\nnpm ERR!   <script>(new Image).src=\"http://nexus.site.int/favicon.ico?3.12.1-01\"</script>\nnpm ERR!   <![endif]\nnpm ERR!   \nnpm ERR!   \nnpm ERR!   \nnpm ERR!   \nnpm ERR!   \nnpm ERR!   \nnpm ERR!\nnpm ERR!   \nnpm ERR! \nnpm ERR! \nnpm ERR! \nnpm ERR!   \nnpm ERR!     \nnpm ERR!       \nnpm ERR!     \nnpm ERR!     \nnpm ERR!       \nnpm ERR!         Nexus Repository Manager\nnpm ERR!       \nnpm ERR!       \nnpm ERR!         OSS 3.12.1-01\nnpm ERR!       \nnpm ERR!     \nnpm ERR!   \nnpm ERR! \nnpm ERR!\nnpm ERR! \nnpm ERR!   \nnpm ERR!     \nnpm ERR!     Error 400\nnpm ERR!     Bad Request\nnpm ERR!   \nnpm ERR!   \nnpm ERR!     \nnpm ERR!       Bad Request\nnpm ERR!     \nnpm ERR!       \nnpm ERR! \nnpm ERR! \nnpm ERR! \nnpm ERR!\nnpm ERR!\nnpm ERR! A complete log of this run can be found in:\nnpm ERR!     /Users/ian/.npm/_logs/2018-12-18T00_34_47_003Z-debug.log\nat makeError (/Users/ian/Development/Scratch/POC/semantic-release-poc/node_modules/execa/index.js:174:9)\nat Promise.all.then.arr (/Users/ian/Development/Scratch/POC/semantic-release-poc/node_modules/execa/index.js:278:16)\nat process._tickCallback (internal/process/next_tick.js:68:7)\n\ncode: 1,\n  stdout: '',\n  stderr:\n   'npm ERR! registry error parsing json\\nnpm ERR! Unexpected token < in JSON at position 1\\nnpm ERR! \\nnpm ERR! <!DOCTYPE html>\\nnpm ERR! \\nnpm ERR! \\nnpm ERR!   400 - Nexus Repository Manager\\nnpm ERR!   \\nnpm ERR! \\nnpm ERR! \\nnpm ERR!   [if lt IE 9]>\\nnpm ERR!   <script>(new Image).src=\"http://nexus.site.int/favicon.ico?3.12.1-01\"</script>\\nnpm ERR!   <![endif]\\nnpm ERR!   \\nnpm ERR!   \\nnpm ERR!   \\nnpm ERR!   \\nnpm ERR!   \\nnpm ERR!   \\nnpm ERR! \\nnpm ERR!   \\nnpm ERR! \\nnpm ERR! \\nnpm ERR! \\nnpm ERR!   \\nnpm ERR!     \\nnpm ERR!       \\nnpm ERR!     \\nnpm ERR!     \\nnpm ERR!       \\nnpm ERR!         Nexus Repository Manager\\nnpm ERR!       \\nnpm ERR!       \\nnpm ERR!         OSS 3.12.1-01\\nnpm ERR!       \\nnpm ERR!     \\nnpm ERR!   \\nnpm ERR! \\nnpm ERR! \\nnpm ERR! \\nnpm ERR!   \\nnpm ERR!     \\nnpm ERR!     Error 400\\nnpm ERR!     Bad Request\\nnpm ERR!   \\nnpm ERR!   \\nnpm ERR!     \\nnpm ERR!       Bad Request\\nnpm ERR!     \\nnpm ERR!       \\nnpm ERR! \\nnpm ERR! \\nnpm ERR! \\nnpm ERR! \\nnpm ERR! \\n\\nnpm ERR! A complete log of this run can be found in:\\nnpm ERR!     /Users/ian/.npm/_logs/2018-12-18T00_34_47_003Z-debug.log\\n',\n  failed: true,\n  signal: null,\n  cmd:\n   'npm dist-tag add @reltester/semantec-release-poc@1.21.0 release-1.21.x --registry http://nexus.site.int/repository/npm-private/',\n  timedOut: false,\n  killed: false,\n  pluginName: '@semantic-release/npm' }%\n```. its strange because bumping the version manually then succeeds\n[1:51:02 AM] [semantic-release] \u203a \u2714  Created tag v1.22.1\n[1:51:02 AM] [semantic-release] \u203a \u2139  Start step \"publish\" of plugin \"@semantic-release/npm\"\n[1:51:02 AM] [semantic-release] [@semantic-release/npm] \u203a \u2139  Publishing version 1.22.1 to npm registry on dist-tag latest\nnpm notice\nnpm notice \ud83d\udce6  @reltester/semantec-release-poc@1.22.1\nnpm notice === Tarball Contents ===\nnpm notice 871B  package.json\nnpm notice 6.9kB CHANGELOG.md\nnpm notice 0     README\nnpm notice 268B  README.md\nnpm notice 716B  dist/backme\nnpm notice 0     dist/index.js\nnpm notice 21B   dist/test.js\nnpm notice === Tarball Details ===\nnpm notice name:          @reltester/semantec-release-poc\nnpm notice version:       1.22.1\nnpm notice package size:  1.8 kB\nnpm notice unpacked size: 8.8 kB\nnpm notice shasum:        b2324210df6c942c977168c4b994855982abd11e\nnpm notice integrity:     sha512-COZl8RuUdjSa3[...]fuR6fTuG41TCA==\nnpm notice total files:   7\nnpm notice\n+ @reltester/semantec-release-poc@1.22.1\n[1:51:04 AM] [semantic-release] [@semantic-release/npm] \u203a \u2139  Published @reltester/semantec-release-poc@1.22.1 to http://nexus.site.int/repository/npm-private/\n[1:51:04 AM] [semantic-release] \u203a \u2714  Completed step \"publish\" of plugin \"@semantic-release/npm\"\n[1:51:04 AM] [semantic-release] \u203a \u2714  Published release 1.22.1. Hi, yep, if you issue the command manually, it fails also. Looking into it further it seems that nexus has a problem with distags.. But we publish all the time - so it does work. It seems the issue is with adding a new dist tag ... If I inspect the private npm repo - you can see the distag is created but i suppose its the first initial call to create the dist-tag that fails... After, it automatically creates it when publishing..\nCan we do some kind of work around? Maybe an option to NOT call the create dist-tag..\nIf you see here, you can see the dist-tag is there \n```\n\u279c  semantic-release-poc git:(1.22.x) npm view @reltester/semantec-release-poc\n@reltester/semantec-release-poc@1.22.1 | ISC | deps: none | versions: 20\ndist\n.tarball http://nexus.site.int/repository/npm-private/@reltester/semantec-release-poc/-/semantec-release-poc-1.22.1.tgz\n.shasum: b2324210df6c942c977168c4b994855982abd11e\n.integrity: sha512-COZl8RuUdjSa37nwYfLNN45U0Nf3JNg81SRnvleFUAfjr03ZpzBEU3aCLkvFfTngLbejJl/ebfuR6fTuG41TCA==\ndist-tags:\nlatest: 1.22.1          release-1.21.x: 1.21.3\n```\nSo it seems the dist-tags is ok - its just calling explicitly to create it - fails... but subsequent publishing works...\nAny ideas ?. And it appears the tag is not ignored as its there in the npm view. And sure enough the tag is there\n```\n\u279c  testinstall npm init -y\nWrote to /Users/ian/Development/Scratch/POC/testinstall/package.json:\n{\n  \"name\": \"testinstall\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\"\n}\n\u279c  testinstall npm install @reltester/semantec-release-poc@release-1.21.x\nnpm WARN testinstall@1.0.0 No description\nnpm WARN testinstall@1.0.0 No repository field.\n\n@reltester/semantec-release-poc@1.21.3\nadded 1 package and audited 1 package in 1.072s\nfound 0 vulnerabilities\n\n\u279c  testinstall\n```. So working on that assumption, it appears that npm publish tag ... automatically creates the tag if its not there.. Yep - it appears that is correct, it automatically creates it - see below\n```\n\u279c  semantic-release-poc git:(1.22.x) \u2717 npm publish --tag my-new-tag\nnpm notice\nnpm notice \ud83d\udce6  @reltester/semantec-release-poc@1.22.1\nnpm notice === Tarball Contents ===\nnpm notice 871B  package.json\nnpm notice 6.9kB CHANGELOG.md\nnpm notice 0     README\nnpm notice 268B  README.md\nnpm notice 716B  dist/backme\nnpm notice 0     dist/index.js\nnpm notice 21B   dist/test.js\nnpm notice === Tarball Details ===\nnpm notice name:          @reltester/semantec-release-poc\nnpm notice version:       1.22.1\nnpm notice package size:  1.8 kB\nnpm notice unpacked size: 8.8 kB\nnpm notice shasum:        b2324210df6c942c977168c4b994855982abd11e\nnpm notice integrity:     sha512-COZl8RuUdjSa3[...]fuR6fTuG41TCA==\nnpm notice total files:   7\nnpm notice\n+ @reltester/semantec-release-poc@1.22.1\n\u279c  semantic-release-poc git:(1.22.x) \u2717 npm view @reltester/semantec-release-poc\n@reltester/semantec-release-poc@1.22.1 | ISC | deps: none | versions: 20\nexport NPM_TOKEN=c628672a-ec41-32a4-afed-cd843a0b4155\ndist\n.tarball http://nexus.site.int/repository/npm-private/@reltester/semantec-release-poc/-/semantec-release-poc-1.22.1.tgz\n.shasum: b2324210df6c942c977168c4b994855982abd11e\n.integrity: sha512-COZl8RuUdjSa37nwYfLNN45U0Nf3JNg81SRnvleFUAfjr03ZpzBEU3aCLkvFfTngLbejJl/ebfuR6fTuG41TCA==\ndist-tags:\nlatest: 1.22.1          my-new-tag: 1.22.1      release-1.21.x: 1.21.3\n```. if this is the case - would it not be possible to add an option when configuring semantic-release - something like \"explicitly-create-dist-tags: yes/no\"\nThis seems a real pitty, as it does technically seem to publish to the correct dist tag but doesn't allow a call to create it... but behind the scenes it automatically creates it.\nI doubt we can move away from nexus as we use it for other things.. ahhh it appears the guys over at lerna had a similar issue - https://github.com/lerna/lerna/issues/293\nThey added a feature to pass into the command line - to not create the tag.\nIs this a viable option ? This would keep the config file clean\n. After taking a closer look, it appears that its the job of this plugin to create the tags ? is this correct ?\nhttps://github.com/semantic-release/npm\n. Hi, I was actually looking at the code - I notice the addChannel from the npm plugin is responsible for creating the dist-tag. Although I also noticed that the main semantic-release is calling the addChannel, it does it via the  \nconst releasesToAdd = getReleasesToAdd(context);\nI was going to create a pull request but I was unsure where to override it, I initially thought in the npm plugin but from testing, I think its only job is to create the dist-tag and is only called from semantic-release from the method outlined above.\nRegards. Thanks, yes this is something I prefer to do, moving to a more robust npm repository.\nThanks again.. wait\n. My bad! I think i have a commit created before i had the ENV variable set .. so even though now i have it set, its trying to push a commit that was created previously.\nSorry. Thank you. > Your repo's releases page isn't actually listing any releases, it is currently only listing git tags.\n\nAFAIK for semantic-release to create a proper release on GitHub you need to use the github plugin. According to the docs of it you don't have to configure its assets setting as that is empty by default. This should create a GitHub release.\n\nOoopps, I missed adding the github plugin :-) Thanks... great thats what i needed. cheers. Thanks @travi , I missed that. Thanks for the link. Thanks @pvdlg , yes after reading the FAQ, I know now that releasing often is the correct way of working. So basically i removed the DEVELOP branch - and I am only releasing from MASTER. So obviously release dependent packages first.\nSo it's all good, I can close this. I think I was missing some context that made me understand the flow better and I found everything in the FAQ.\nThanks. I installed the latest beta which supports multiple branching, I am trying to test the maintenance branching. Hence I created 1.2.x from master... master has released 1.2 and a number of other versions.. Here are my branches\n* 1.2.x\n  master. no worries, i forgot to push :-). This is the current status of the git tree, so I have pushed it\n\n. Thanks @dominykas, yes very strange but it is very.. Here is me on the branch and as you can see the .releaserc seems to be correct\n\u279c  sem-release-library git:(1.0.x) git pull\nAlready up to date.\n\u279c  sem-release-library git:(1.0.x) cat .releaserc.json\n{\n  \"branches\": [\n    \"+([1-9])?(.{+([1-9]),x}).x\",\n    \"master\",\n    \"next\",\n    {\n      \"name\": \"alpha\",\n      \"prerelease\": true\n    },\n    {\n      \"name\": \"beta\",\n      \"prerelease\": true\n    }\n  ],\n  \"plugins\": [\n    \"@semantic-release/commit-analyzer\",\n    \"@semantic-release/release-notes-generator\",\n    \"@semantic-release/changelog\",\n    \"@semantic-release/git\",\n    \"@semantic-release/npm\"\n  ]\n}. This is also a list of the branches locally and remotely\n* 1.0.x\n  alpha\n  master\n  remotes/origin/1.0.x\n  remotes/origin/1.x\n  remotes/origin/HEAD -> origin/master\n  remotes/origin/alpha\n  remotes/origin/master\n  remotes/origin/next. For sure I am doing something wrong but right now i am having problems seeing the issue. My .releaserc file from the docs (beta). I believe i have the correct version of the packages installed. They are the beta versions.\nIt is strange that its saying \nThis test run was triggered on the branch 1.0.x, while semantic-release is configured to only publish from master, alpha, therefore a new version won\u2019t be published.\nwhen my releaserc file has the regex in there for the branch naming but also the beta.\n. @pvdlg Can you see anything strange that I am overlooking ? Is my regex correct ?\nThe only thing I can see is the following\n[1:14:14 PM] [semantic-release] \u203a \u2714  Loaded plugin \"addChannel\" from \"@semantic-release/npm\"\n  semantic-release:get-tags found tags: [ { gitTag: 'v1.0.0', version: '1.0.0', channel: undefined }, { gitTag: 'v1.0.1', version: '1.0.1', channel: undefined }, { gitTag: 'v1.0.2', version: '1.0.2', channel: undefined }, { gitTag: 'v1.0.3', version: '1.0.3', channel: undefined }, { gitTag: 'v1.0.4', version: '1.0.4', channel: undefined }, { gitTag: 'v1.0.5', version: '1.0.5', channel: undefined }, { gitTag: 'v1.0.6', version: '1.0.6', channel: undefined }, { gitTag: 'v1.1.0', version: '1.1.0', channel: undefined }, { gitTag: 'v1.1.0-alpha.1@alpha', version: '1.1.0-alpha.1', channel: 'alpha' }, { gitTag: 'v1.1.0-alpha.2@alpha', version: '1.1.0-alpha.2', channel: 'alpha' }, { gitTag: 'v1.1.0-alpha.3@alpha', version: '1.1.0-alpha.3', channel: 'alpha' }, { gitTag: 'v1.1.1', version: '1.1.1', channel: undefined }, { gitTag: 'v1.2.0', version: '1.2.0', channel: undefined }, { gitTag: 'v1.2.1', version: '1.2.1', channel: undefined }, { gitTag: 'v1.2.2', version: '1.2.2', channel: undefined }, { gitTag: 'v1.2.2-alpha.1@alpha', version: '1.2.2-alpha.1', channel: 'alpha' }, { gitTag: 'v1.2.3-alpha.1@alpha', version: '1.2.3-alpha.1', channel: 'alpha' }, { gitTag: 'v1.2.3-alpha.2@alpha', version: '1.2.3-alpha.2', channel: 'alpha' }, { gitTag: 'v1.2.3-alpha.3@alpha', version: '1.2.3-alpha.3', channel: 'alpha' }, { gitTag: 'v1.3.0', version: '1.3.0', channel: undefined } ] +0ms\n  semantic-release:get-tags found tags for branch master: [ { version: '1.0.0', channel: undefined, gitTag: 'v1.0.0', gitHead: 'b7769512591a43d642a51c9eb433fc4f43247acf' }, { version: '1.0.1', channel: undefined, gitTag: 'v1.0.1', gitHead: 'd55acea894a55e22bbab88525c2bfb8374237093' }, { version: '1.0.2', channel: undefined, gitTag: 'v1.0.2', gitHead: 'edc161a78718c8c4eac2c14e800aa18ce9ab24ca' }, { version: '1.0.3', channel: undefined, gitTag: 'v1.0.3', gitHead: '45b56a9251f11f727a0cf99a206d5e15bfa848f9' }, { version: '1.0.4', channel: undefined, gitTag: 'v1.0.4', gitHead: '5b2fae4217bb26d811fc3049f96098832c6cfb30' }, { version: '1.0.5', channel: undefined, gitTag: 'v1.0.5', gitHead: '18e575446793aa0d708e6714c2d7d59c5205a4af' }, { version: '1.0.6', channel: undefined, gitTag: 'v1.0.6', gitHead: '62737873766f116ea4d7f76c12ebfcfbf0073850' }, { version: '1.1.0', channel: undefined, gitTag: 'v1.1.0', gitHead: 'c539c6a6a41f3ff1cfbf9b097b6736ce5b32d305' }, { version: '1.1.0-alpha.1', channel: 'alpha', gitTag: 'v1.1.0-alpha.1@alpha', gitHead: '267381b910bd8caba9b87befeff83d93c9160f00' }, { version: '1.1.0-alpha.2', channel: 'alpha', gitTag: 'v1.1.0-alpha.2@alpha', gitHead: 'fc01e1f6d26771efd45f17221b91098e03b2e1a8' }, { version: '1.1.0-alpha.3', channel: 'alpha', gitTag: 'v1.1.0-alpha.3@alpha', gitHead: 'a407ef8372f6dc082eef0a0f05dd04a5cccbbe51' }, { version: '1.1.1', channel: undefined, gitTag: 'v1.1.1', gitHead: '5f0e9aaf2e8cf69c2f0306c26cec17a98efd9fb0' }, { version: '1.2.0', channel: undefined, gitTag: 'v1.2.0', gitHead: 'a161e653913d8f2f18e0126b60801ac2f0602da0' }, { version: '1.2.1', channel: undefined, gitTag: 'v1.2.1', gitHead: '561897c810e3d8e0975f686fe2426dfae361f8d4' }, { version: '1.2.2', channel: undefined, gitTag: 'v1.2.2', gitHead: '479198f1602ec34d1c3d0c7ecd278739582fffaf' }, { version: '1.2.2-alpha.1', channel: 'alpha', gitTag: 'v1.2.2-alpha.1@alpha', gitHead: '3a3f8eceb2e35b0b27e24793b2f41a6bbe5a4ba6' }, { version: '1.2.3-alpha.1', channel: 'alpha', gitTag: 'v1.2.3-alpha.1@alpha', gitHead: 'ddda97c5b8f2b8f79e1ac6fee8771102e052f0f1' }, { version: '1.2.3-alpha.2', channel: 'alpha', gitTag: 'v1.2.3-alpha.2@alpha', gitHead: '8fc18313a4f3f46627475edf556759611b148054' }, { version: '1.2.3-alpha.3', channel: 'alpha', gitTag: 'v1.2.3-alpha.3@alpha', gitHead: '8117073e210a06333d3041521e453f7c3bec3cac' }, { version: '1.3.0', channel: undefined, gitTag: 'v1.3.0', gitHead: '189e9e2c18d0c2a19f3b5bca969322b2b0cae05b' } ] +783ms\n  semantic-release:get-tags found tags for branch alpha: [ { version: '1.0.0', channel: undefined, gitTag: 'v1.0.0', gitHead: 'b7769512591a43d642a51c9eb433fc4f43247acf' }, { version: '1.0.1', channel: undefined, gitTag: 'v1.0.1', gitHead: 'd55acea894a55e22bbab88525c2bfb8374237093' }, { version: '1.0.2', channel: undefined, gitTag: 'v1.0.2', gitHead: 'edc161a78718c8c4eac2c14e800aa18ce9ab24ca' }, { version: '1.0.3', channel: undefined, gitTag: 'v1.0.3', gitHead: '45b56a9251f11f727a0cf99a206d5e15bfa848f9' }, { version: '1.0.4', channel: undefined, gitTag: 'v1.0.4', gitHead: '5b2fae4217bb26d811fc3049f96098832c6cfb30' }, { version: '1.0.5', channel: undefined, gitTag: 'v1.0.5', gitHead: '18e575446793aa0d708e6714c2d7d59c5205a4af' }, { version: '1.0.6', channel: undefined, gitTag: 'v1.0.6', gitHead: '62737873766f116ea4d7f76c12ebfcfbf0073850' }, { version: '1.1.0', channel: undefined, gitTag: 'v1.1.0', gitHead: 'c539c6a6a41f3ff1cfbf9b097b6736ce5b32d305' }, { version: '1.1.0-alpha.1', channel: 'alpha', gitTag: 'v1.1.0-alpha.1@alpha', gitHead: '267381b910bd8caba9b87befeff83d93c9160f00' }, { version: '1.1.0-alpha.2', channel: 'alpha', gitTag: 'v1.1.0-alpha.2@alpha', gitHead: 'fc01e1f6d26771efd45f17221b91098e03b2e1a8' }, { version: '1.1.0-alpha.3', channel: 'alpha', gitTag: 'v1.1.0-alpha.3@alpha', gitHead: 'a407ef8372f6dc082eef0a0f05dd04a5cccbbe51' }, { version: '1.1.1', channel: undefined, gitTag: 'v1.1.1', gitHead: '5f0e9aaf2e8cf69c2f0306c26cec17a98efd9fb0' }, { version: '1.2.0', channel: undefined, gitTag: 'v1.2.0', gitHead: 'a161e653913d8f2f18e0126b60801ac2f0602da0' }, { version: '1.2.1', channel: undefined, gitTag: 'v1.2.1', gitHead: '561897c810e3d8e0975f686fe2426dfae361f8d4' }, { version: '1.2.2', channel: undefined, gitTag: 'v1.2.2', gitHead: '479198f1602ec34d1c3d0c7ecd278739582fffaf' }, { version: '1.2.2-alpha.1', channel: 'alpha', gitTag: 'v1.2.2-alpha.1@alpha', gitHead: '3a3f8eceb2e35b0b27e24793b2f41a6bbe5a4ba6' }, { version: '1.2.3-alpha.1', channel: 'alpha', gitTag: 'v1.2.3-alpha.1@alpha', gitHead: 'ddda97c5b8f2b8f79e1ac6fee8771102e052f0f1' }, { version: '1.2.3-alpha.2', channel: 'alpha', gitTag: 'v1.2.3-alpha.2@alpha', gitHead: '8fc18313a4f3f46627475edf556759611b148054' }, { version: '1.2.3-alpha.3', channel: 'alpha', gitTag: 'v1.2.3-alpha.3@alpha', gitHead: '8117073e210a06333d3041521e453f7c3bec3cac' } ] +776ms\n[1:14:23 PM] [semantic-release] \u203a \u2139  This test run was triggered on the branch 1.0.x, while semantic-release is configured to only publish from master, alpha, therefore a new version won\u2019t be published.\nSo no tags found on the branch - but this is correct as I haven't released, correct ?\nI know it must be me.. I also just added a new conventional commit and pushed and tried releasing but the same again\n```\n\u279c  sem-release-library git:(1.0.x) \u2717 git status\nOn branch 1.0.x\nYour branch is up to date with 'origin/1.0.x'.\nChanges to be committed:\n  (use \"git reset HEAD ...\" to unstage)\nmodified:   onalpha.txt\n\n\u279c  sem-release-library git:(1.0.x) \u2717 nr cm\nrunning command with prefix \"cm\"\n\n@camspoc/sem-release-library@1.1.0-alpha.1 cm /Users/ian/Development/Work/poc/sem-poc-release/sem-release-library\ngit-cz\n\ncz-cli@3.0.7, cz-conventional-changelog@2.1.0\nLine 1 will be cropped at 100 characters. All other lines will be wrapped after 100 characters.\n? Select the type of change that you're committing: feat:     A new feature\n? What is the scope of this change (e.g. component or file name)? (press enter t\no skip)\n? Write a short, imperative tense description of the change:\n This a new release on branch 1.0.x\n? Provide a longer description of the change: (press enter to skip)\n? Are there any breaking changes? No\n? Does this change affect any open issues? No\n[1.0.x 41ef53e] feat: This a new release on branch 1.0.x\n 1 file changed, 2 insertions(+)\n\u279c  sem-release-library git:(1.0.x) git push\nEnumerating objects: 5, done.\nCounting objects: 100% (5/5), done.\nDelta compression using up to 8 threads\nCompressing objects: 100% (3/3), done.\nWriting objects: 100% (3/3), 314 bytes | 314.00 KiB/s, done.\nTotal 3 (delta 2), reused 0 (delta 0)\nremote:\nremote: To create a merge request for 1.0.x, visit:\nremote:   http://lab.poc.int/poc/poc/sem-release-library/merge_requests/new?merge_request%5Bsource_branch%5D=1.0.x\nremote:\nTo lab.poc.int:poc/poc/sem-release-library.git\n   fcbbd8a..41ef53e  1.0.x -> 1.0.x\n```\nand the release\nsem-release-library git:(1.0.x) npx semantic-release --no-ci\n[12:20:31 PM] [semantic-release] \u203a \u2139  Running semantic-release version 16.0.0-beta.18\n[12:20:31 PM] [semantic-release] \u203a \u2714  Loaded plugin \"verifyConditions\" from \"@semantic-release/changelog\"\n[12:20:31 PM] [semantic-release] \u203a \u2714  Loaded plugin \"verifyConditions\" from \"@semantic-release/git\"\n[12:20:31 PM] [semantic-release] \u203a \u2714  Loaded plugin \"verifyConditions\" from \"@semantic-release/npm\"\n[12:20:31 PM] [semantic-release] \u203a \u2714  Loaded plugin \"analyzeCommits\" from \"@semantic-release/commit-analyzer\"\n[12:20:31 PM] [semantic-release] \u203a \u2714  Loaded plugin \"generateNotes\" from \"@semantic-release/release-notes-generator\"\n[12:20:31 PM] [semantic-release] \u203a \u2714  Loaded plugin \"prepare\" from \"@semantic-release/changelog\"\n[12:20:31 PM] [semantic-release] \u203a \u2714  Loaded plugin \"prepare\" from \"@semantic-release/git\"\n[12:20:31 PM] [semantic-release] \u203a \u2714  Loaded plugin \"prepare\" from \"@semantic-release/npm\"\n[12:20:31 PM] [semantic-release] \u203a \u2714  Loaded plugin \"publish\" from \"@semantic-release/npm\"\n[12:20:31 PM] [semantic-release] \u203a \u2714  Loaded plugin \"addChannel\" from \"@semantic-release/npm\"\n[12:20:37 PM] [semantic-release] \u203a \u2139  This test run was triggered on the branch 1.0.x, while semantic-release is configured to only publish from master, alpha, therefore a new version won\u2019t be published.. Ok - it appears that the tag i was creating the branch from had the .releaserc as an old version. I have created a tag from a newer version and it appears to be now working.. ",
    "renemr86": "First of all, awesome tool! We've been using semantic-release for some time on Java projects with Gradle and CircleCI and it has been great!\nNow we decided to move on to the beta version and publish releases on multiple branches. Until now, everything is working like a charm.\nThanks. Hello\nI'm trying to replicate the example Working on a third future release, however when I commit on alpha branch the semantic-release set the next release version with the next beta version (2.0.0-beta.3) instead of the next alpha version (3.0.0-alpha.1).\nExample repository:\nhttps://github.com/renemr86/semantic-release-test\n.releaserc:\n```\ntagFormat: ${version}\nbranches:\n  - master\n  - name: next\n    prerelease: 'rc'\n  - name: beta\n    prerelease: 'beta'\n  - name: alpha\n    prerelease: 'alpha'\nverifyConditions:\n  - \"@semantic-release/git\"\ngenerateNotes: []\nprepare: []\npublish: []\nsuccess: []\nfail: []\n```\n```\n$ npx semantic-release --no-ci\n[12:55:00 PM] [semantic-release] \u203a \u2139  Running semantic-release version 16.0.0-beta.15\n[12:55:00 PM] [semantic-release] \u203a \u2714  Loaded plugin \"verifyConditions\" from \"@semantic-release/git\"\n[12:55:00 PM] [semantic-release] \u203a \u2714  Loaded plugin \"analyzeCommits\" from \"@semantic-release/commit-analyzer\"\n[12:55:00 PM] [semantic-release] \u203a \u2714  Loaded plugin \"addChannel\" from \"@semantic-release/npm\"\n[12:55:00 PM] [semantic-release] \u203a \u2714  Loaded plugin \"addChannel\" from \"@semantic-release/github\"\n[12:55:15 PM] [semantic-release] \u203a \u2714  Run automated release from branch alpha\n[12:55:21 PM] [semantic-release] \u203a \u2714  Allowed to push to the Git repository\n[12:55:21 PM] [semantic-release] \u203a \u2139  Start step \"verifyConditions\" of plugin \"@semantic-release/git\"\n[12:55:21 PM] [semantic-release] \u203a \u2714  Completed step \"verifyConditions\" of plugin \"@semantic-release/git\"\n[12:55:21 PM] [semantic-release] \u203a \u2139  Found git tag 2.0.0-beta.2@beta associated with version 2.0.0-beta.2 on branch alpha\n[12:55:21 PM] [semantic-release] \u203a \u2139  Found 1 commits since last release\n[12:55:21 PM] [semantic-release] \u203a \u2139  Start step \"analyzeCommits\" of plugin \"@semantic-release/commit-analyzer\"\n[12:55:21 PM] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: feat: first feature of other release\nBREAKING CHANGE: it breaks something\n[12:55:21 PM] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The release type for the commit is major\n[12:55:21 PM] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analysis of 1 commits complete: major release\n[12:55:21 PM] [semantic-release] \u203a \u2714  Completed step \"analyzeCommits\" of plugin \"@semantic-release/commit-analyzer\"\n[12:55:21 PM] [semantic-release] \u203a \u2139  The next release version is 2.0.0-beta.3\n[12:55:24 PM] [semantic-release] \u203a \u2714  Created tag 2.0.0-beta.3@alpha\n[12:55:24 PM] [semantic-release] \u203a \u2714  Published release 2.0.0-beta.3\n```\n```\n$ git log --graph --oneline --all --decorate --date-order\n 461efd6 (HEAD -> alpha, tag: 2.0.0-beta.3@alpha, origin/alpha, bitbucket/alpha) feat: first feature of other release\n| * 6bca0e4 (tag: 1.0.1, origin/master, bitbucket/master, master) fix: a fix\n | bbbaf5f (tag: 2.0.0-beta.2@beta, origin/beta, bitbucket/beta, beta) feat: second feature\n | 4409cd5 (tag: 2.0.0-beta.1@beta) feat: first feature\n|/\n cc1021a (tag: 1.0.0) feat: initial commit\n```\n. I'm using semantic-release on a pre-release branch (beta). When I commit a break change, the semantic-release correctly indicates that a new major version will be generated, however instead of increasing the major version (4.0.0-beta.1), it keeps the current version (3.38.0) and only increases the pre-release version (3.38.0-beta.15 to  3.38.0-beta.16).\n```\nnpx semantic-release\n[3:27:51 PM] [semantic-release] \u203a \u2139  Running semantic-release version 16.0.0-beta.18\n[3:27:51 PM] [semantic-release] \u203a \u2714  Loaded plugin \"verifyConditions\" from \"@semantic-release/git\"\n[3:27:51 PM] [semantic-release] \u203a \u2714  Loaded plugin \"analyzeCommits\" from \"@semantic-release/commit-analyzer\"\n[3:27:51 PM] [semantic-release] \u203a \u2714  Loaded plugin \"prepare\" from \"@semantic-release/exec\"\n[3:27:51 PM] [semantic-release] \u203a \u2714  Loaded plugin \"publish\" from \"@semantic-release/exec\"\n[3:27:51 PM] [semantic-release] \u203a \u2714  Loaded plugin \"publish\" from \"@semantic-release/exec\"\n[3:27:51 PM] [semantic-release] \u203a \u2714  Loaded plugin \"addChannel\" from \"@semantic-release/npm\"\n[3:27:51 PM] [semantic-release] \u203a \u2714  Loaded plugin \"addChannel\" from \"@semantic-release/github\"\n[3:27:51 PM] [semantic-release] \u203a \u26a0  This run was not triggered in a known CI environment, running in dry-run mode.\n[3:28:11 PM] [semantic-release] \u203a \u26a0  Run automated release from branch beta in dry-run mode\n[3:28:16 PM] [semantic-release] \u203a \u2714  Allowed to push to the Git repository\n[3:28:16 PM] [semantic-release] \u203a \u2139  Start step \"verifyConditions\" of plugin \"@semantic-release/git\"\n[3:28:16 PM] [semantic-release] \u203a \u2714  Completed step \"verifyConditions\" of plugin \"@semantic-release/git\"\n[3:28:16 PM] [semantic-release] \u203a \u2139  Found git tag 3.38.0-beta.15@beta associated with version 3.38.0-beta.15 on branch beta\n[3:28:16 PM] [semantic-release] \u203a \u2139  Found 2 commits since last release\n[3:28:16 PM] [semantic-release] \u203a \u2139  Start step \"analyzeCommits\" of plugin \"@semantic-release/commit-analyzer\"\n[3:28:16 PM] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: ci(circle/semantic-release): upgrade semantic-release\n[3:28:16 PM] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The commit should not trigger a release\n[3:28:16 PM] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: feat(something): description\nBREAKING CHANGE: description\n[3:28:16 PM] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The release type for the commit is major\n[3:28:16 PM] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analysis of 2 commits complete: major release\n[3:28:16 PM] [semantic-release] \u203a \u2714  Completed step \"analyzeCommits\" of plugin \"@semantic-release/commit-analyzer\"\n[3:28:16 PM] [semantic-release] \u203a \u2139  The next release version is 3.38.0-beta.16\n[3:28:16 PM] [semantic-release] \u203a \u26a0  Skip step \"prepare\" of plugin \"@semantic-release/exec\" in dry-run mode\n[3:28:16 PM] [semantic-release] \u203a \u26a0  Skip 3.38.0-beta.16@beta tag creation in dry-run mode\n[3:28:16 PM] [semantic-release] \u203a \u26a0  Skip step \"publish\" of plugin \"@semantic-release/exec\" in dry-run mode\n[3:28:16 PM] [semantic-release] \u203a \u26a0  Skip step \"publish\" of plugin \"@semantic-release/exec\" in dry-run mode\n[3:28:16 PM] [semantic-release] \u203a \u2714  Published release 3.38.0-beta.16\n[3:28:16 PM] [semantic-release] \u203a \u2139  Release note for version 3.38.0-beta.16:\n```. ",
    "gempain": "Any update on this ?. @pvdlg Yes, I should've closed this yesterday, so sorry, I found that the issue was indeed coming from a typo in my config, which had mode.exports = instead of module.exports. Greatest apologies !. @pvdlg Sure, here you go:\n``\n$ git branch -a\n* (HEAD detached at 85e7274)\n  dev\n  remotes/origin/HEAD -> origin/dev\n  remotes/origin/dev\n$ npx semantic-release@16.0.0-beta.18 --debug\nnpx: installed 797 in 26.618s\n[6:17:17 PM] [semantic-release] \u203a \u2139  Running semantic-release version 16.0.0-beta.18\n2019-03-04T18:17:17.831Z semantic-release:config load config from: /builds/internal/my-project/my-project-repo/.releaserc.js\n2019-03-04T18:17:17.854Z semantic-release:config options values: { branches:\n   [ '+([1-9])?(.{+([1-9]),x}).x',\n     'master',\n     'next',\n     'next-major',\n     { name: 'beta', prerelease: true },\n     { name: 'alpha', prerelease: true } ],\n  repositoryUrl:\n   'https://gitlab-ci-token:[secure]@gitlab.my-site.com/internal/my-project/my-project-repo.git',\n  tagFormat: 'v${version}',\n  plugins:\n   [ [ '@semantic-release/commit-analyzer', [Object] ],\n     [ '@semantic-release/release-notes-generator', [Object] ],\n     [ '@semantic-release/changelog', [Object] ],\n     [ '@semantic-release/npm', [Object] ],\n     [ '@semantic-release/git', [Object] ] ],\n  _: [],\n  debug: true,\n  '$0': '/root/.npm/_npx/25/bin/semantic-release' }\n2019-03-04T18:17:18.392Z semantic-release:plugins options for @semantic-release/changelog/verifyConditions: { changelogFile: 'CHANGELOG.md' }\n[6:17:18 PM] [semantic-release] \u203a \u2714  Loaded plugin \"verifyConditions\" from \"@semantic-release/changelog\"\n2019-03-04T18:17:18.394Z semantic-release:plugins options for @semantic-release/npm/verifyConditions: { npmPublish: false }\n[6:17:18 PM] [semantic-release] \u203a \u2714  Loaded plugin \"verifyConditions\" from \"@semantic-release/npm\"\n2019-03-04T18:17:18.395Z semantic-release:plugins options for @semantic-release/git/verifyConditions: { message: 'chore(release): ${nextRelease.version} [ci skip]' }\n[6:17:18 PM] [semantic-release] \u203a \u2714  Loaded plugin \"verifyConditions\" from \"@semantic-release/git\"\n2019-03-04T18:17:18.396Z semantic-release:plugins options for @semantic-release/commit-analyzer/analyzeCommits: { preset: 'angular' }\n[6:17:18 PM] [semantic-release] \u203a \u2714  Loaded plugin \"analyzeCommits\" from \"@semantic-release/commit-analyzer\"\n2019-03-04T18:17:18.397Z semantic-release:plugins options for @semantic-release/release-notes-generator/generateNotes: { preset: 'angular' }\n[6:17:18 PM] [semantic-release] \u203a \u2714  Loaded plugin \"generateNotes\" from \"@semantic-release/release-notes-generator\"\n2019-03-04T18:17:18.398Z semantic-release:plugins options for @semantic-release/changelog/prepare: { changelogFile: 'CHANGELOG.md' }\n[6:17:18 PM] [semantic-release] \u203a \u2714  Loaded plugin \"prepare\" from \"@semantic-release/changelog\"\n2019-03-04T18:17:18.398Z semantic-release:plugins options for @semantic-release/npm/prepare: { npmPublish: false }\n[6:17:18 PM] [semantic-release] \u203a \u2714  Loaded plugin \"prepare\" from \"@semantic-release/npm\"\n2019-03-04T18:17:18.399Z semantic-release:plugins options for @semantic-release/git/prepare: { message: 'chore(release): ${nextRelease.version} [ci skip]' }\n[6:17:18 PM] [semantic-release] \u203a \u2714  Loaded plugin \"prepare\" from \"@semantic-release/git\"\n2019-03-04T18:17:18.400Z semantic-release:plugins options for @semantic-release/npm/publish: { npmPublish: false }\n[6:17:18 PM] [semantic-release] \u203a \u2714  Loaded plugin \"publish\" from \"@semantic-release/npm\"\n2019-03-04T18:17:18.401Z semantic-release:plugins options for @semantic-release/npm/addChannel: { npmPublish: false }\n[6:17:18 PM] [semantic-release] \u203a \u2714  Loaded plugin \"addChannel\" from \"@semantic-release/npm\"\n2019-03-04T18:17:18.658Z semantic-release:get-tags found tags: []\n[6:17:18 PM] [semantic-release] \u203a \u2716  ERELEASEBRANCHES The release branches are invalid in thebranches` configuration.\nA minimum of 1 and a maximum of 3 release branches are required in the branches configuration (https://github.com/semantic-release/semantic-release/blob/master/docs/usage/configuration.md#branches).\nYour configuration for the problematic branches is [].\n{ AggregateError:\n    SemanticReleaseError: The release branches are invalid in the branches configuration.\n        at module.exports (/root/.npm/_npx/25/lib/node_modules/semantic-release/lib/get-error.js:6:10)\n        at Object.entries.reduce (/root/.npm/_npx/25/lib/node_modules/semantic-release/lib/branches/index.js:41:19)\n        at Array.reduce ()\n        at module.exports (/root/.npm/_npx/25/lib/node_modules/semantic-release/lib/branches/index.js:31:46)\n    at module.exports (/root/.npm/_npx/25/lib/node_modules/semantic-release/lib/branches/index.js:63:11)\n    at process._tickCallback (internal/process/next_tick.js:68:7) name: 'AggregateError' }Git git version 2.18.1\nNode v10.15.2a\nNpm 6.4.1\nDocker Docker version 18.06.1-ce, build d72f525745\nERROR: Job failed: exit code 1\n```\nThe weird things is it does not crash on all of my projects. I haven't been able to figure out what the difference between those projects is because I copy-pasted the setup for each of them, so it couldn't come from this I guess.. @priyajeet so far I have it working on only one project in my GitlabCI runner. It's failing on pretty much every other project. Note that some of those projects are configured to run in DroneCI as well, and they work fine in Drone, so it seems to be varying between CI setups and I can't figure out the difference between those setups as I usually copy-paste most config.\nHere is the log on a repo that's failing:\n$ git remote -v\norigin  https://gitlab-ci-token:xxxxxxxxxxxxxxxxxxxx@gitlab.my-site.com/internal/my-project/my-repo.git (fetch)\norigin  https://gitlab-ci-token:xxxxxxxxxxxxxxxxxxxx@gitlab.my-site.com/internal/my-project/my-repo.git (push)\n$ git branch -a\n* (HEAD detached at 3de7bd6)\n  dev\n  remotes/origin/HEAD -> origin/dev\n  remotes/origin/dev\n  remotes/origin/feat/road-list\nand now on the repo that is succeeding:\n$ git remote -v\norigin  https://gitlab-ci-token:xxxxxxxxxxxxxxxxxxxx@gitlab.my-site.com/internal/my-project/my-repo.git (fetch)\norigin  https://gitlab-ci-token:xxxxxxxxxxxxxxxxxxxx@gitlab.my-site.com/internal/my-project/my-repo.git (push)\n$ git branch -a\n* (HEAD detached at 0526aef)\n  master\n  remotes/origin/HEAD -> origin/master\n  remotes/origin/dev\n  remotes/origin/feat/feat1\n  remotes/origin/feat/feat2\n  remotes/origin/master\n$ npx semantic-release@16.0.0-beta.18 --debug\nnpx: installed 797 in 23.96s\n[9:17:48 PM] [semantic-release] \u203a \u2139  Running semantic-release version 16.0.0-beta.18\n2019-03-05T21:17:48.416Z semantic-release:config load config from: /builds/internal/my-project/my-repo/.releaserc.js\n2019-03-05T21:17:48.430Z semantic-release:config options values: { branches:\n   [ '+([1-9])?(.{+([1-9]),x}).x',\n     'master',\n     'next',\n     'next-major',\n     { name: 'beta', prerelease: true },\n     { name: 'alpha', prerelease: true } ],\n  repositoryUrl:\n   'https://gitlab-ci-token:[secure]@gitlab.my-site.com/internal/my-project/my-repo.git',\n  tagFormat: 'v${version}',\n  plugins:\n   [ [ '@semantic-release/commit-analyzer', [Object] ],\n     [ '@semantic-release/release-notes-generator', [Object] ],\n     [ '@semantic-release/changelog', [Object] ],\n     [ '@semantic-release/npm', [Object] ],\n     [ '@semantic-release/git', [Object] ] ],\n  _: [],\n  debug: true,\n  '$0': '/root/.npm/_npx/26/bin/semantic-release' }\n2019-03-05T21:17:48.900Z semantic-release:plugins options for @semantic-release/changelog/verifyConditions: { changelogFile: 'CHANGELOG.md' }\n[9:17:48 PM] [semantic-release] \u203a \u2714  Loaded plugin \"verifyConditions\" from \"@semantic-release/changelog\"\n2019-03-05T21:17:48.902Z semantic-release:plugins options for @semantic-release/npm/verifyConditions: { npmPublish: false }\n[9:17:48 PM] [semantic-release] \u203a \u2714  Loaded plugin \"verifyConditions\" from \"@semantic-release/npm\"\n2019-03-05T21:17:48.903Z semantic-release:plugins options for @semantic-release/git/verifyConditions: { message: 'chore(release): ${nextRelease.version} [ci skip]' }\n[9:17:48 PM] [semantic-release] \u203a \u2714  Loaded plugin \"verifyConditions\" from \"@semantic-release/git\"\n2019-03-05T21:17:48.904Z semantic-release:plugins options for @semantic-release/commit-analyzer/analyzeCommits: { preset: 'angular' }\n[9:17:48 PM] [semantic-release] \u203a \u2714  Loaded plugin \"analyzeCommits\" from \"@semantic-release/commit-analyzer\"\n2019-03-05T21:17:48.905Z semantic-release:plugins options for @semantic-release/release-notes-generator/generateNotes: { preset: 'angular' }\n[9:17:48 PM] [semantic-release] \u203a \u2714  Loaded plugin \"generateNotes\" from \"@semantic-release/release-notes-generator\"\n2019-03-05T21:17:48.905Z semantic-release:plugins options for @semantic-release/changelog/prepare: { changelogFile: 'CHANGELOG.md' }\n[9:17:48 PM] [semantic-release] \u203a \u2714  Loaded plugin \"prepare\" from \"@semantic-release/changelog\"\n2019-03-05T21:17:48.906Z semantic-release:plugins options for @semantic-release/npm/prepare: { npmPublish: false }\n[9:17:48 PM] [semantic-release] \u203a \u2714  Loaded plugin \"prepare\" from \"@semantic-release/npm\"\n2019-03-05T21:17:48.907Z semantic-release:plugins options for @semantic-release/git/prepare: { message: 'chore(release): ${nextRelease.version} [ci skip]' }\n[9:17:48 PM] [semantic-release] \u203a \u2714  Loaded plugin \"prepare\" from \"@semantic-release/git\"\n2019-03-05T21:17:48.907Z semantic-release:plugins options for @semantic-release/npm/publish: { npmPublish: false }\n[9:17:48 PM] [semantic-release] \u203a \u2714  Loaded plugin \"publish\" from \"@semantic-release/npm\"\n2019-03-05T21:17:48.908Z semantic-release:plugins options for @semantic-release/npm/addChannel: { npmPublish: false }\n[9:17:48 PM] [semantic-release] \u203a \u2714  Loaded plugin \"addChannel\" from \"@semantic-release/npm\"\n2019-03-05T21:17:49.316Z semantic-release:get-tags found tags: []\n2019-03-05T21:17:49.316Z semantic-release:get-tags found tags for branch master: []\n[9:17:49 PM] [semantic-release] \u203a \u2139  This test run was triggered on the branch feat/road-list, while semantic-release is configured to only publish from master, therefore a new version won\u2019t be published.\nGit git version 2.18.1\nNode v10.15.2a\nNpm 6.4.1\nDocker Docker version 18.06.1-ce, build d72f525745\nCreating cache default...\nnode_modules/: found 10192 matching files\nNo URL provided, cache will be not uploaded to shared cache server. Cache will be stored only locally.\nCreated cache\nJob succeeded. @priyajeet good one ! Found the issue: the common thing between all the projects that were failing is that they did not have a master branch, only dev. Just doing the following fixed it:\ngit checkout -b master\ngit push --set-upstream origin master\nLooking back at it, the message makes sense, but I guess it could be clearer by saying something like semantic-release could not find a release branch. May be you don't have a master branch ?. Providing a list of expected release branches would be great as well, since you probably have them as branches.filter(b => typeof b === 'string ' || !b.prerelease) ?\nBy the way, I looked through the code trying to find where the error message was originally coming from, but couldn't find the words \"maximum\", \"minimum\", \"required\" or \"release branches configuration\" anywhere in the repositories semantic-release/semantic-release, semantic-release/git, semantic-release/npm (I gave up after those three). Can you point me to where the error was thrown ?\nThanks a lot for the help, really appreciated ! I'm closing this issue as it is resolved, but would suggest adding a hint to the error message.. ",
    "kbrandwijk": "If so, so should the CLI.... Sorry... missed that one.... I have just tested this with semantic-release 12.0.0 (the first CI agnostic version), and everything seems to run smoothly without needing the condition-circle plugin.\nHowever, I think this issue is still relevant to provide better support for Circle CI on the semantic-release-cli.. I already have this working locally, so I'll submit a PR to the cli for this. The only issue is the fact that you need to create an API token on Circle CI. Two forum issues on CircleCI about using GH tokens for authentication have been dead for over a year now.. Unfortunately, the only way to authenticate against the CircleCI API is using an API token that the user has to created on CircleCI. No GH token or username/password authentication possible.... @pvdlg I think the only thing I can do for now is use keytar like for Github password to store the API token after asking it once. Would that be a good idea?. @gr2m Sounds great, I'm interested! I'm looking to improve on the workflow some more by making it possible to add the semantic-release step to an existing configuration as well, for example. And I want to add some tests as well to improve quality and coverage.\nI will also be using it myself on all my repos, that all use CircleCI, so count me in.. Great! I haven't seen the invite yet though. It normally shows up right away. And yes, as far as I'm concerned, this can be closed now. Do you have a Slack channel?. Yep, thanks!. @pvdlg Regarding the nvm solution in the docs, from the nvm docs it seems that you need to run nvm use after nvm install to actually use that version.. ",
    "chasingmaxwell": "This is problematic for me as well. I'd prefer my builds to fail loudly if no release is performed. Using Travis build stages, the release job isn't run unless it is fully expected to release. All conditions are verified in travis config. I use the condition-noop plugin to prevent the verifyConditions step from preventing a release. For this reason, I'm going to have to stick with ^8.0.0 for now. It'd be great if this behavior was configurable with a cli flag. Something like: --fail-without-release.. ",
    "sapegin": "It was 11.0.2:\n$ npm install -g semantic-release\n/home/travis/.nvm/versions/node/v6.12.2/bin/semantic-release -> /home/travis/.nvm/versions/node/v6.12.2/lib/node_modules/semantic-release/bin/semantic-release.js\n/home/travis/.nvm/versions/node/v6.12.2/lib\n\u2514\u2500\u252c semantic-release@11.0.2\nAnd looks like this guide is for npm Enterprise. I can\u2019t find anything about deployment tokens for normal npm.. Yes, it works with auth-only.\n\nauth-and-writes doesn't work because it would prompt for a code on every automatic publish\n\nThat\u2019s why I\u2019ve created this issue.\n. > It does work with 2fa, just not if you configure it to prompt for OTPs during publishing\nThis isn\u2019t 100% correct, because it\u2019s a default mode, so you have to configure it not to prompt for OTP :-)\n\nShould we close this issue in favor\n\nYeah, I guess we can\u2019t really fix that on semantic-release side.. Found it: I need to throw an error instead of returning it.. ",
    "markusguenther": "I tried that and with 2fa npm publish is not working. Even when it is configured to auth only.\nAlways get the error that I need to provide a OTP.. Ah so you mean the Token knows that I have configured 2FA with\nauth-and-write no matter what I configure later. So with a new token it\nshould work out.\nBy the way I tested it before with a test package and that worked with 2FA\nauth only but the package had no scope. Maybe the scope is the problem.\nMatt Travi notifications@github.com schrieb am Mi. 15. Aug. 2018 um 03:57:\n\nwas the token created while your account was configured for\nauth-and-writes and then your account was switched to auth-only? i think\nit matters when the token was created\nfwiw, i have been successfully publishing with semantic-release with my\naccount using 2fa for auth-only for quite some time, so i can at least\nconfirm it does work. my bet would be that it is related to the token you\nare trying to use.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/semantic-release/semantic-release/issues/572#issuecomment-413070889,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AA95bpbpe3hIrXTwn9zlj_7RnF2xAxJTks5uQ4AigaJpZM4RJjTp\n.\n-- \nVon Gmail Mobile gesendet mit dem iPad gesendet - ich bitte Tippfehler zu\nentschuldigen.\n. I tried it now with a new token that I have created after auth-only was active and I still have the problem with the OTP message.\n\nTravis has the NPM_TOKEN in the settings and I have no clue what really goes wrong.\nI tested before on a extra package for testing and the only thing that is different now is the case that this package is from an organisation.\nWould be great if someone has a hint. Will test the extra package now with the organisation and may this is then the issue.. Ok found the issue ... before I used semantic release I required 2fa on npm for the package and that setting seems to break the whole behaviour with the tokens.\nThank you anyway.\nYou all created a great package or better ecosystem of packages :). ",
    "nareshbhatia": "@pvdlg, thanks for clarifying. Makes perfect sense now!. ",
    "marionebl": "Hey there, if I understand this correctly you face the same difficulties as commitlint with having to run untrusted code on a full git clone somewhere to make an useful GitHub app.\nI have not implemented this yet, but the basic idea I came up with is having a \"task queue repo\", where based on events you receive from user repos commits (with \"task payloads\") are generated. \nThe \"task queue repo\" is configured on TravisCI, where for each new commit a job executes that uses the \"task payload\" to check out the user repo, install dependencies and execute whatever you need it to execute. You'd submit the results to your GitHub app in an appropriate format.\nThe simplified flow for commitlint looks like this\n. ",
    "hoodwink73": "Thanks Pierre \nThis is awesome work. I appreciate the effort that went into this project to combine the scattered ideas into an end to end semantic release workflow.\n. There are frameworks which are yet to adopt newer versions of node. Can we transpile the dist code with babel to help older versions of node run semantic-release?. ",
    "frank-long": "I'm using 12.2.2 of sematic-release. I think this is the default behaviour for angular config.... closing. ",
    "kimsagro1": "Thanks for your response, @pvdlg however I am publishing a non-javascript package so I do not have a package.json, I'm invoking semantic-release via an npx call.. I cannot link to my repository as it is private, but basically in the .net world, we build out libraries via the following command\n\ndotnet build /p:AssemblyVersion=1.2.3.4\n\nWe pass the version number as part of the build process. The produced assets (in this case *.dll files) will them have the version number stamped into them.\nWe then need the version number again when packaging the assets for release\n\ndotnet pack /p:AssemblyVersion=1.2.3.4\n\nThis will then produce a release package MyProject.1.2.3.4.nuget which then gets deployed to github / nuget.\nSo contrary to the JavaScript world where the version number doesn't appear to be needed during the build phase only the release, we need it during both.. So the current configuration is\n{\n  \"release\": {\n    \"verifyConditions\": \"@semantic-release/github\",\n    \"getLastRelease\": \"@semantic-release/git\",\n    \"analyzeCommits\" : \"@semantic-release/commit-analyze\",\n    \"generateNotes\": \"@semantic-release/release-notes-generator\",\n    \"publish\": \"@semantic-release/github\"\n}\nbut my plan is to write a new semantic-release plugin for nuget (the .NET equivalent of npm) so that ultimately the configuration would be\n{\n  \"release\": {\n    \"verifyConditions\": [\"@semantic-release/github\", \"semantic-release-nuget\"]\n    \"getLastRelease\": \"semantic-release-nuget\",\n    \"analyzeCommits\" : \"@semantic-release/commit-analyze\",\n    \"generateNotes\": \"@semantic-release/release-notes-generator\",\n    \"publish\": [\"@semantic-release/github\", \"semantic-release-nuget\"]\n}\nThe plan was\n\nRun semantic-release in dry-run mode and extract the version\nBuild  v1.2.3\nTest\nPackage  v1.2.3\nRun semantic-release to publish to github and nuget\n\nI could as you mentioned do\n\nBuild v0.0.0-development\nTest\nRun semantic-release to publish to github and nuget but use exec to\nBuild  v1.2.3\nPackage  v1.2.3\n\n\n\nHowever this would result in the build running twice which is expensive. Thanks for your patience and response, I will go down the path you suggested. Feel free to close this proposal out.. @pvdlg this is also affecting https://github.com/semantic-release/release-notes-generator. ",
    "abhishek199-dhn": "@pvdlg \n\nWhat you can do is use semantic-release to make releases on master, and use the exec plugin as an additional publish step to use whatever solution to push to another branch.\n\nWill try this approach meanwhile. Thanks!\n\nRegarding the EGITNOPERMISSION error the GH_TOKEN environment variable should be a GitHub personal token. You should probably not use cross-env GH_TOKEN=TOKEN semantic-release as you would have your token in clear in your package.json. Even if your project is private, it doesn't seems really secure.\n\nNoted!\n\nDid you make sure the token has push access to your repo? As it's a probably a private repo, you will need to check \"Full control of private repositories\".\n\nyeah, it has the required access(Full control of private repositories) and I have tried setting up SSH keys too.\nMagically the same token worked with the semantic release once(it didn't ask any password at that time) and I was able to see the change logs and commits but after that, I was not able to make it work. \nAnd that password which it asks during authentication is also not consistent.\nsometimes it asks for it \n\nPassword for 'https://TOKEN@github.com': \n\nand sometimes it directly shows \n\n[Semantic release]: EGITNOPERMISSION The git credentials doesn't allow to push on the branch master of git+https://github.com/DeepIntent/di-component-lib.git.\n\n. @pvdlg \n\nIn order to check the permission to the repo we are using git push --dry-run https://@github.com//.git HEAD:master.\nCan you try to run that on your CI to see if you get an error? You have to replace , and in the command?\n\nThe push command works as expected and gives no error.\n\nAlso what is the Git URL configured in your package.json in the repository property?\n\"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/DeepIntent/di-component-lib.git\"\n  }\n. okay, I will try with a new version and verify it.. @pvdlg \nv13.1.4. works for me finally, Thanks.\nBut I still stuck to make a release from master branch to release branch with the changelogs.\nI'm using release branch as npm registry to pull the npm package from git using tags. So Basically I'm pushing all the build code to release branch such that if someone pulls the lib package they get the build code instead of the source code.\nWhat you can do is use semantic-release to make releases on the master, and use the exec plugin as an additional publish step to use whatever solution to push to another branch.\n\nIn this case, I have to make a git release from the master branch and then again make a git release from release branch.\n. ",
    "huchenme": "same here\n+ git push --dry-run origin HEAD:master\nEverything up-to-date\n[Pipeline] sh\n[BUILD] Running shell script\n+ npx semantic-release\n[Semantic release]: Load plugin verifyConditions from @semantic-release/changelog\n[Semantic release]: Load plugin verifyConditions from @semantic-release/git\n[Semantic release]: Load plugin analyzeCommits from @semantic-release/commit-analyzer\n[Semantic release]: Load plugin generateNotes from @semantic-release/release-notes-generator\n[Semantic release]: Load plugin publish from @semantic-release/changelog\n[Semantic release]: Load plugin publish from @semantic-release/npm\n[Semantic release]: Load plugin publish from @semantic-release/git\n$ ssh-agent -k\nunset SSH_AUTH_SOCK;\nunset SSH_AGENT_PID;\necho Agent pid 32731 killed;\n[ssh-agent] Stopped.\n[Semantic release]: EGITNOPERMISSION The git credentials doesn't allow to push on the branch master.\nIs it related to execa?. ",
    "rigobauer": "OMG! You're totally right... I adding the 'npm run build' in the after_success solve it (and makes total sense).\nJust as a desperate try to justify myself and doesn't look so dumb, I thought that Travis was doing that build automatically, because I have another component project made using the exactly same process, and that package was ok (and that's what was driving me crazy and make me focus in the wrong places).\nAfter reading @pvdlg answer, I re-check everything and then realize that I made the first publish of that package manually, and after that I incorporate semantic-release. The thing is that the next commits weren't related to new features or fixes, so obviously semantic-release didn't generate a new release, and the original package was still there.\nI had already tried the skip_cleanup parameter (thanks @travi), but without success. Obviously, without building the package there were nothing to skip!\nTotally my fault! Sorry and thank you, guys!. ",
    "negamaxi": "You are correct. Thanks for your advice, I'll try this out.. @pvdlg well, seems to me there is no native way to share artifacts between jobs or stages. There is solutions like aws proposed, but in my case it's much simpler to move build process entirely on Mac as it's possible to package app for all three platforms. \n```yaml\njobs:\n  include:\n    - if: branch = master\n      os: osx\n      osx_image: xcode9.0\n      language: node_js\n      node_js: \"8\"\ncache:\n  yarn: true\n  directories:\n    - node_modules\nbefore_install: git pull\nbefore_install: \n  - brew install rpm\n  - brew install dpkg\n  - brew install jq\nscript:\n  - yarn test\ndeploy:\n  provider: script\n  skip_cleanup: true\n  script:\n    - npx travis-deploy-once \"npx semantic-release\"\nBuild script moved inside semantic-release process because there is another issue appeared with semantic-release specific versioning. Assets names come with `0.0.0-development` version part and the only way I managed to make it normal was using `exec` plugin with this config:json\n{\n  \"verifyConditions\": \"@semantic-release/github\",\n  \"publish\": [\n    {\n      \"path\": \"@semantic-release/exec\",\n      \"cmd\": \"sh pre-build.sh ${nextRelease.version} && yarn build --linux --win --mac -p never && sh post-build.sh\"\n    },\n    {\n      \"path\": \"@semantic-release/github\",\n      \"assets\": \"dist/*\"\n    }\n  ]\n}\n...where pre-build.sh changes package.json version to normal with `jq`:sh\n!/bin/bash\ntmp=$(mktemp)\nVERSION='\"'$1'\"'\njq \".version = $VERSION\" package.json > \"$tmp\" && mv \"$tmp\" package.json\n...and post-build.sh brings back semantic's variant:sh\n!/bin/bash\ntmp=$(mktemp)\njq '.version = \"v0.0.0-development\"' package.json > \"$tmp\" && mv \"$tmp\" package.json\n```. @pvdlg Nice! Thanks!. ",
    "crash7": "I changed the line shell = await execa('git', ['push', '-d', origin, tagName], {reject: false}); to shell = await execa('git', ['push', '--delete', origin, tagName], {reject: false}); and everything solved!. @pvdlg sure! \ud83d\ude04 . @pvdlg here https://github.com/semantic-release/semantic-release/pull/631 let me know if you need changes!. Hi! Are you familiar with npx?\nhttps://www.npmjs.com/package/npx - https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b\nThe command we use is:\nnpx -p semantic-release-apps-config -p semantic-release semantic-release -e semantic-release-apps-config\n\nHow is semantic-release installed? Globally or locally? \n\nnpx installs them locally in temporal folder to run the command.\n\nDo you have the semantic-release devDependency in your package.json?\n\nNo, that's the beauty of npx, I don't need to install them in the app itself.\n\nHow is installed your shareable configuration? Do you have is as a devDependency in your package.json?\n\nSame as before\n\nWhat is the content of your shareable config? I'm not sure if what you provided under \"semantic-release configuration\" is the config in your project or if it is the shareable config itself.\n\nThe shareable config it's the one I provided earlier, yes.\n\nWhat are the dependencies in the package.json of your shareable config?\n\nThe ones listed in the repo\n\nCan you provide a link to your repo?\n\nIt's a private one in our org, if this is necessary I can try to create a public one with a public shareable config package.\n. Neither semantic-release or semantic-release-apps-config are in the package.json of the main app repo. We use npx as a step in the CI and avoid adding the release config in all the repos (it makes everything more portable, specially when adding new projects to the release party).\nRegarding the last part: Yes, this is the package.json of the shareable config module (semantic-release-apps-config):\n\"dependencies\": {\n    \"@semantic-release/commit-analyzer\": \"6.1.0\",\n    \"@semantic-release/git\": \"7.0.5\",\n    \"@semantic-release/github\": \"5.2.5\",\n    \"@semantic-release/npm\": \"5.1.1\",\n    \"@semantic-release/release-notes-generator\": \"7.1.4\"\n  },\n  \"peerDependencies\": {\n    \"semantic-release\": \"15.12.1\"\n  }\nOn the other hand, the same config works fine if:\n- I don't use a shareable config and I install everything in the main project \n- I use the same setup without configuring a plugin manually (that points the way array plugin configuration is treated)\nLet me know if I can provide more information, I didn't have the time to check the code yet. . @pvdlg just tested the new version and it works perfect. Kudos for fixing this so quickly!! Thank you so much \ud83d\ude04 . ",
    "mattmazzola": "The semantic-release setup fixed the package.json and corrected the script to be:\n\"semantic-release\": \"semantic-release\",  I thought I had those changes pushed when I submitted the issue, but maybe not.  See:\nhttps://github.com/mattmazzola/library-starter-test/blob/master/package.json#L32\nThe typescript-library-starter repo does have the old script though. They could update their default.\nhttps://github.com/alexjoverm/typescript-library-starter/blob/master/package.json#L32\nI will try using the .npmrc file to control registry. Thanks!\n. Adding the .npmrc works although now i'm facing other issue:\nhttps://github.com/semantic-release/semantic-release/issues/632\nI suppose this can be closed as duplicate of the other issue you referenced.. Hmm, I re-ran with debugging: (semantic-release-cli setup --debug) but it did not output any extra information.\nIt seems like the error is coming from here:\n```\n  travis.repoid = _.get(\n    await promisify(travis.repos(info.ghrepo.slug[0], info.ghrepo.slug[1]).get.bind(travis))(),\n    'repo.id'\n  );\nif (!travis.repoid) throw new Error('Could not get repo id');\n```\nhttps://github.com/semantic-release/cli/blob/3955e0494a6645a8e22a09cfbac9ee1bdd0203b7/src/lib/travis.js#L102-L107\nI turned on the node http proxy and it looks like the API call to Travis is incorrect.\nRequest to get the repository:\nGET https://api.travis-ci.com/repos/Microsoft/blis-models HTTP/1.1\nUser-Agent: Travis\nAccept: application/vnd.travis-ci.2+json, */*; q=0.01\nAuthorization: token <removed>\nhost: api.travis-ci.com\nConnection: close\nResponse:\nNotice Content-Type is image/png where as all the other responses are JSON.\n```\nHTTP/1.1 200 OK\nConnection: close\nServer: nginx\nDate: Mon, 05 Feb 2018 23:46:31 GMT\nContent-Type: image/png\nContent-Length: 1261\nAccess-Control-Allow-Origin: *\nAccess-Control-Allow-Credentials: true\nAccess-Control-Expose-Headers: Content-Type, Cache-Control, Expires, Etag, Last-Modified, X-Request-ID\nStrict-Transport-Security: max-age=31536000\nX-Endpoint: Travis::Pro::Api::Endpoint::Repos\nX-Pattern: /:owner_name/:name\nX-Oauth-Scopes: public,private\nX-Accepted-Oauth-Scopes: private\nVary: Accept,Authorization,Accept-Encoding\nCache-Control: no-cache\nPragma: no-cache\nExpires: Mon, 05 Feb 2018 23:46:31 GMT\nContent-Disposition: inline; filename=\"unknown.png\"\nLast-Modified: Mon, 05 Feb 2018 14:31:13 GMT\nX-Request-Id: 4e7be806-0ce5-4006-87a4-fcd777eeac46\nVia: 1.1 vegur\n\n```\nThe image returned is the build uknonwn badge:\n\nIt's strange because there are other requests to fetch users with same Accept header and they return JSON\nGET https://api.travis-ci.com/users HTTP/1.1\nUser-Agent: Travis\nAccept: application/vnd.travis-ci.2+json, */*; q=0.01\nAuthorization: token <removed>\nhost: api.travis-ci.com\nConnection: close\nResponse:\n{\"user\":{\"id\":173417,\"name\":\" .... \"}\n. I feel like Travis.com has bug in their API.\nFrom looking at their API docs:\nhttps://docs.travis-ci.com/api/#repositories\nThey have other endpoints that still allow using the {repository.slug} to get data and when I try those with the same headers it does return JSON.\nE.g.\nGET /repos/x/y          -> **Incorrectly returns image/png**\nGET /repos/x/y/branches -> application/json;charset=utf-8\nGet /repos/x/y/builds   -> application/json;charset=utf-8\nAnd yes, that looks like the same error.. The other issue makes it sound like it can be fixed by manually going to travis.com and syncing repos.  The issue still occurs even after both of these steps. It is similar to #112 however, that issue looks to be using Travis CI (Not Pro)\nThis means it's using:\napi.travis-ci.org instead of api.travis-ci.com which does not appear to have the same bug.. I noticed Travis CI has a v3 api available although I'm not quite sure how to use it at the moment.  I thought I could just update the Accept header to use 3 instead of 2 such as:\nAccept: application/vnd.travis-ci.3+json, */*; q=0.01\nHowever, it seems the V3 api still has problems.\nI wonder if there is some other API we can use to get the repository ID that doesn't have this error, and then continue on. \nFor now my work around is to try to manually put the environment variables into Travis and see if the script will run successfully.\n. Ah never mind... See fail is just the name of the plugin... \ud83d\ude05 . ",
    "brettstack": "Thanks, I'm running into this. Any ETA on next NPM release?. ",
    "naerion89": "i use node v8.9.4 and yarn. Thanks for the answer.\nI manage to create git tag but i always have a error 400 Bad request with gitlab. gitlab plugin  try a put request for creating release\nthe gitlab API require a post request (https://docs.gitlab.com/ce/api/tags.html#create-a-new-release)\nIn history, the post request has been replaced with put request.\ngitlab.com is only compatible with semantic-release/gitlab 1.02. yes i already did it but now i have the following error \nstderr: 'Error: Failed to replace env in config: ${version}\\n at /usr/local/lib/node_modules/npm/lib/config/core.js:417:13\\n at String.replace ()\\n at envReplace (/usr/local/lib/node_modules/npm/lib/config/core.js:413:12)\\n at parseField (/usr/local/lib/node_modules/npm/lib/config/core.js:391:7)\\n at /usr/local/lib/node_modules/npm/lib/config/core.js:334:17\\n at Array.forEach ()\\n at Conf.add (/usr/local/lib/node_modules/npm/lib/config/core.js:333:23)\\n at ConfigChain.addEnv (/usr/local/lib/node_modules/npm/node_modules/config-chain/index.js:207:15)\\n at Conf.addEnv (/usr/local/lib/node_modules/npm/lib/config/core.js:358:30)\\n at load_ (/usr/local/lib/node_modules/npm/lib/config/core.js:107:8)\\n at Conf. (/usr/local/lib/node_modules/npm/lib/config/core.js:96:5)\\n at emitOne (events.js:116:13)\\n at Conf.emit (events.js:211:7)\\n at ConfigChain._resolve (/usr/local/lib/node_modules/npm/node_modules/config-chain/index.js:281:34)\\n at ConfigChain.add (/usr/local/lib/node_modules/npm/node_modules/config-chain/index.js:259:10)\\n at Conf.add (/usr/local/lib/node_modules/npm/lib/config/core.js:340:27)\\n/usr/local/lib/node_modules/npm/lib/npm.js:61\\n throw new Error('npm.load() required')\\n ^\\n\\nError: npm.load() required\\n at Object.get (/usr/local/lib/node_modules/npm/lib/npm.js:61:13)\\n at process.errorHandler (/usr/local/lib/node_modules/npm/lib/utils/error-handler.js:205:18)\\n at emitOne (events.js:116:13)\\n at process.emit (events.js:211:7)\\n at process._fatalException (bootstrap_node.js:374:26)\\n',\nfailed: true,\nsignal: null,\ncmd: 'npm config get tag',\ntimedOut: false,\nkilled: false,\npluginName: '@semantic-release/npm' }. ",
    "trollr": "Have the same issue for https://:@... authentication with bitbucket server. git push --dry-run https://<user>:<password>@<server>/<owner>/x.git HEAD:master works fine. ",
    "R0oma1n": "git push --dry-run https://gitlab-ci-token:$GITLAB_TOKEN@//release-test.git HEAD:master works ! \nThe system worked after using the command, I do not have the problem anymore and I don't know why\nThanks for your help. The version remains at v1.0.0 and it never increases, for each commit, my version remains at v1.0.0.\nI don't have a bug in my console when I use --debug.. # Bug report\nCurrent behavior\n Describe how the issue manifests. \nWhen I use semantic-release option tagFormat, the version of my code stay at v1.0.0.\nExpected behavior\n Describe what the desired behavior would be. \nI want to have the normal operation, when I push a fix, I want to have v1.0.1 and not v1.0.0\nEnvironment\n\nsemantic-release version:  Version set in package.json devDpendencies \n\n\"devDependencies\": {\n    \"@semantic-release/git\": \"^3.0.0\",\n    \"@semantic-release/gitlab\": \"^1.0.2\",\n    \"@semantic-release/npm\": \"^3.0.0\",\n    \"semantic-release\": \"^13.1.3\",\n    \"@semantic-release/changelog\": \"^1.0.0\"\n  }\n\nCI environment:  CI service name \n\nI use Gitlab-ci\n link to your repository or relevant part of the semantic-release config \n\nCI logs:  link to your CI logs or semantic-release logs \n\nhttps://gitlab.com/naerion/release-test. I use another configuration that is very close to this one but the solution is on a local gitlab directory.\nThe command I use is : \nyarn release --branch ${CI_COMMIT_REF_NAME} --tag-format \"${CI_COMMIT_REF_NAME}-\"'${version}' \nInstead of :\nyarn release --debug in the project I gave you\nHere are the steps : \n- I modify my code \n- I commit my code \n- I use my yarn command : yarn release --branch ${CI_COMMIT_REF_NAME} --tag-format \"${CI_COMMIT_REF_NAME}-\"'${version}' \n- Normally, for each change, I should have a version that changes, but there, the version remains there even after each commit and each command executed.\nWhen I use yarn release without the Format tag, semantic-release uses the version in package.json, but there it does not get the version of the package.json file. In the documentation, it says to use $ {version} but this command does not work when I use the tag-format option. I always get the same version when I use --tag-format \nI hope I have made you understand my problem\nI'm sorry but I have no more explanation to give.\nThank you for your time. I thought the informations given was sufficient. I give you the configurations as soon as possible.\nAnd I thought you did not understand my problem at first.\nI do not have the files on hand, I'll answer you tomorrow.. Hello, \nAfter a few tries, I managed to make the version system work the way I wanted it and I can't give more information about the system.\nThank you for your help and your work ! . ",
    "effervescentia": "What if instead of creating it before publish it becomes one of the plugins that runs in the publish pipeline?\nThat way if someone is doing a custom release to apm then they would just need to include the @semantic-release/git-tag plugin in their publish array before their apm publish script\nIt could even become part of the functionality of @semantic-release/git for simplicity and a configuration flag could be added to indicate whether or not @semantic-release/git should do commit in order to avoid the case when it would error on committing no changes. Alternatively it could fail silently on a \"no changes to commit\" error.\nUnfortunately my CI doesn't have auto-cancellation currently \ud83d\ude1e . The tag event triggers a pipeline of other jobs that culminate in pushing a finalized docker container, and ultimately will be hooked up to our deployment process, all of which unfortunately is more complicated than I would like for the exec plugin to be responsible for.\nI understand the benefits of having the tag creation happen in the core, and given the insight you've just shared I agree it shouldn't move. Is it possible to make it conditional as to whether or not the tag created in core is actually pushed to github? I think you should be able to do the same commit analysis using the local repository. So otherwise I believe the functionality would remain the same.\nIf that isn't possible, what if you were to add a pipeline of plugins that would execute before the tag gets pushed?\nSo the lifecycle would change from:\n- verify (etc.)\n- create tag & push tag\n- publish\n- done\nto \n\nverify (etc.)\ncreate tag\npre-push <- this is where I could add plugins that add any new commits, as long as a tag by the same name as the one created in create tag exists before push tag\npush tag\npublish\ndone. @pvdlg I think that looks awesome!\nI believe had only suggested my initial flow in case there were any requirements on the tag already being created for the commit analysis. Basically doesn't matter as long as all of the parameters that are used by the current publish plugins are available in prepare then it does everything I could ask ever for \ud83d\udc4d \ud83d\udcaf \nThanks for being so expedient \ud83d\ude04 . I was thinking the same thing, makes it even more flexible to use.\n\nPS I wanted to say I'm really grateful for all of the work that went into the rewrite. I've been using semantic-release for over a year now and I couldn't imagine development without it. The new configuration makes it a lot more customize-able, while I know the old version often confused my coworkers as being a bit of a black box. I actually wrote a plugin (start-release) for a tiny build framework start and it was a little prickly to pick through the source code and wrap the package itself.\nI'm not sure how you are for contributors, but I'd be happy to help implement this change if you'd be interested.\nThanks again for taking this feature request \ud83d\ude04 . @pvdlg wanted to let you know I set this up today and it works perfectly \ud83d\ude04  thanks again. ",
    "ts-npm": "I could help with this.. Thank you for your help, but this doesn't fully answer my question. How do I deploy without the need \nfor an npm token?\nAs for the constraints listed in your FAQ I am doing the following:\n- [x] Running a globally installed semantic release\n- [x] Set semantic-release options via CLI arguments or rc file\n- [x] Make sure your CI job executing the semantic-release command has access to Node >= 8 to execute the semantic-release command\nI've updated my configurations based upon your recommendations, here's what I have so far:\n.releaserc.json\n{\n  \"release\": {\n    \"verifyConditions\": [\"@semantic-release/git\", \"@semantic-release/github\"],\n    \"publish\": [\n      {\n        \"path\": \"@semantic-release/npm\",\n        \"npmPublish\": false,\n        \"tarballDir\": \"dist\"\n      },\n      {\n        \"path\": \"@semantic-release/github\",\n        \"assets\": \"dist/*.tgz\"\n      }\n    ]\n  }\n}\npackage.json\n...\n  \"devDependencies\": {\n    \"@semantic-release/exec\": \"^2.2.3\",\n    \"@semantic-release/github\": \"^4.2.8\",\n    \"@semantic-release/git\": \"^4.0.1\",\n...\nIn my CircleCI config I have the following for testing it out with your recommended configurations\n```\nJavascript Node CircleCI 2.0 configuration file\n\nCheck https://circleci.com/docs/2.0/language-javascript/ for more details\nversion: 2\njobs:\n  build:\n    docker:\n      - image: circleci/node:8.9.4\n    working_directory: ~/repo\nsteps:\n  - checkout\n  - restore_cache:\n      key: project-name-{{ .Branch }}-{{ checksum \"package.json\" }}\n  - run:\n      name: Run semantic-release\n      command: sudo npm i -g semantic-release@15.0.2\n  - run:\n      name: Install Dependencies\n      command: yarn\n  - run:\n      name: Run semantic-release\n      command: semantic-release\n  - save_cache:\n      key: project-name-{{ .Branch }}-{{ checksum \"package.json\" }}\n      paths:\n        - ~/.cache/yarn\n        - node_modules\n\nworkflows:\n  version: 2\n  build-and-lint:\n    jobs:\n      - build:\n          filters:\n            branches:\n              only:\n                - master\n```\nBuild output\n```\n!/bin/bash -eo pipefail\nsemantic-release\n[Semantic release]: Running semantic-release version 15.0.2\n[Semantic release]: Load plugin verifyConditions from @semantic-release/npm\n[Semantic release]: Load plugin verifyConditions from @semantic-release/github\n[Semantic release]: Load plugin analyzeCommits from @semantic-release/commit-analyzer\n[Semantic release]: Load plugin generateNotes from @semantic-release/release-notes-generator\n[Semantic release]: Load plugin prepare from @semantic-release/npm\n[Semantic release]: Load plugin publish from @semantic-release/npm\n[Semantic release]: Load plugin publish from @semantic-release/github\n[Semantic release]: Load plugin success from @semantic-release/github\n[Semantic release]: Load plugin fail from @semantic-release/github\n[Semantic release]: Run automated release from branch master\n[Semantic release]: Call plugin verify-conditions\n[Semantic release]: Verify authentication for registry https://registry.npmjs.org/\n[Semantic release]: Wrote NPM_TOKEN to .npmrc.\n[Semantic release]: Verify GitHub authentication\n[Semantic release]: Verify GitHub authentication\n[Semantic release]: EINVALIDGHTOKEN Invalid GitHub token.\nThe GitHub token (https://github.com/semantic-release/github/blob/master/README.md#github-authentication) configured in the GH_TOKEN or GITHUB_TOKEN environment variable must be a valid personnal token (https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line) allowing to push to the repository timecapture/tsheets-frontend-app-ci-example.\nPlease make sure to set the GH_TOKEN or GITHUB_TOKEN environment variable in your CI with the exact value of the GitHub personnal token.\n[Semantic release]: EINVALIDNPMTOKEN Invalid npm token.\nThe npm token (https://github.com/semantic-release/npm/blob/master/README.md#npm-registry-authentication) configured in the NPM_TOKEN environment variable must be a valid token (https://docs.npmjs.com/getting-started/working_with_tokens) allowing to publish to the registry https://registry.npmjs.org/.\nIf you are using Two-Factor Authentication, make configure the auth-only level (https://docs.npmjs.com/getting-started/using-two-factor-authentication#levels-of-authentication) is supported. semantic-release cannot publish with the default auth-and-writes level.\nPlease make sure to set the NPM_TOKEN environment variable in your CI with the exact value of the npm token.\n[Semantic release]: EINVALIDGHTOKEN Invalid GitHub token.\nThe GitHub token (https://github.com/semantic-release/github/blob/master/README.md#github-authentication) configured in the GH_TOKEN or GITHUB_TOKEN environment variable must be a valid personnal token (https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line) allowing to push to the repository timecapture/tsheets-frontend-app-ci-example.\nPlease make sure to set the GH_TOKEN or GITHUB_TOKEN environment variable in your CI with the exact value of the GitHub personnal token.\n{ AggregateError: \n    SemanticReleaseError: Invalid npm token.\n        at module.exports (/usr/local/lib/node_modules/semantic-release/node_modules/@semantic-release/npm/lib/get-error.js:6:10)\n        at module.exports (/usr/local/lib/node_modules/semantic-release/node_modules/@semantic-release/npm/lib/verify-auth.js:23:33)\n        at \n    SemanticReleaseError: Invalid GitHub token.\n        at module.exports (/usr/local/lib/node_modules/semantic-release/node_modules/@semantic-release/github/lib/get-error.js:6:10)\n        at module.exports (/usr/local/lib/node_modules/semantic-release/node_modules/@semantic-release/github/lib/verify.js:86:21)\n        at \n    at Object.verifyConditions (/usr/local/lib/node_modules/semantic-release/lib/plugins/pipeline.js:52:45)\n    at  name: 'AggregateError' }\nExited with code 1\n```. Furthermore, if I do define a valid NPM_TOKEN and GH_TOKEN I recieve the following when running semantic release:\n```\n!/bin/bash -eo pipefail\nsemantic-release\n[Semantic release]: Running semantic-release version 15.0.2\n[Semantic release]: Load plugin verifyConditions from @semantic-release/npm\n[Semantic release]: Load plugin verifyConditions from @semantic-release/github\n[Semantic release]: Load plugin analyzeCommits from @semantic-release/commit-analyzer\n[Semantic release]: Load plugin generateNotes from @semantic-release/release-notes-generator\n[Semantic release]: Load plugin prepare from @semantic-release/npm\n[Semantic release]: Load plugin publish from @semantic-release/npm\n[Semantic release]: Load plugin publish from @semantic-release/github\n[Semantic release]: Load plugin success from @semantic-release/github\n[Semantic release]: Load plugin fail from @semantic-release/github\n[Semantic release]: Run automated release from branch master\n[Semantic release]: Call plugin verify-conditions\n[Semantic release]: Verify authentication for registry https://registry.npmjs.org/\n[Semantic release]: Wrote NPM_TOKEN to .npmrc.\n[Semantic release]: Verify GitHub authentication\n[Semantic release]: Verify GitHub authentication\n[Semantic release]: EINVALIDGHTOKEN Invalid GitHub token.\nThe GitHub token (https://github.com/semantic-release/github/blob/master/README.md#github-authentication) configured in the GH_TOKEN or GITHUB_TOKEN environment variable must be a valid personnal token (https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line) allowing to push to the repository timecapture/tsheets-frontend-app-ci-example.\nPlease make sure to set the GH_TOKEN or GITHUB_TOKEN environment variable in your CI with the exact value of the GitHub personnal token.\n[Semantic release]: EINVALIDGHTOKEN Invalid GitHub token.\nThe GitHub token (https://github.com/semantic-release/github/blob/master/README.md#github-authentication) configured in the GH_TOKEN or GITHUB_TOKEN environment variable must be a valid personnal token (https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line) allowing to push to the repository timecapture/tsheets-frontend-app-ci-example.\nPlease make sure to set the GH_TOKEN or GITHUB_TOKEN environment variable in your CI with the exact value of the GitHub personnal token.\n{ SemanticReleaseError: Invalid GitHub token.\n    at module.exports (/usr/local/lib/node_modules/semantic-release/node_modules/@semantic-release/github/lib/get-error.js:6:10)\n    at module.exports (/usr/local/lib/node_modules/semantic-release/node_modules/@semantic-release/github/lib/verify.js:86:21)\n    at \n  name: 'SemanticReleaseError',\n  code: 'EINVALIDGHTOKEN',\n  details: 'The GitHub token configured in the GH_TOKEN or GITHUB_TOKEN environment variable must be a valid personnal token allowing to push to the repository timecapture/tsheets-frontend-app-ci-example.\\n\\nPlease make sure to set the GH_TOKEN or GITHUB_TOKEN environment variable in your CI with the exact value of the GitHub personnal token.',\n  semanticRelease: true,\n  pluginName: '@semantic-release/github' }\nExited with code 1```. After updating the .releaserc.json file based upon your feedback I am still receiving errors relating to not having an NPM token defined.\nI am setting a GH_TOKEN and am no longer setting an NPM_TOKEN in circle.\nI am setting the personal access token as a variable in CircleCI under the name of GH_TOKEN. I've verified that I can use the token to push and pull to and from the repo locally and yet for some reason the gh token isn't being registered.\nIt should be noted that I'm using github enterprise for all of this.\nUpdated .releaserc.json file based upon your feedback\n{\n  \"release\": {\n    \"prepare\": [\n      {\n        \"path\": \"@semantic-release/npm\",\n        \"npmPublish\": false,\n        \"tarballDir\": \"dist\"\n      }\n    ],\n    \"verifyConditions\": [\n      {\n        \"path\": \"@semantic-release/npm\",\n        \"npmPublish\": false,\n        \"tarballDir\": \"dist\"\n      }\n    ],\n    \"publish\": [\n      {\n        \"path\": \"@semantic-release/npm\",\n        \"npmPublish\": false,\n        \"tarballDir\": \"dist\"\n      }\n    ]\n  }\n}\nCommand output\n```\n!/bin/bash -eo pipefail\nsemantic-release\n[Semantic release]: Running semantic-release version 15.0.2\n[Semantic release]: Load plugin verifyConditions from @semantic-release/npm\n[Semantic release]: Load plugin verifyConditions from @semantic-release/github\n[Semantic release]: Load plugin analyzeCommits from @semantic-release/commit-analyzer\n[Semantic release]: Load plugin generateNotes from @semantic-release/release-notes-generator\n[Semantic release]: Load plugin prepare from @semantic-release/npm\n[Semantic release]: Load plugin publish from @semantic-release/npm\n[Semantic release]: Load plugin publish from @semantic-release/github\n[Semantic release]: Load plugin success from @semantic-release/github\n[Semantic release]: Load plugin fail from @semantic-release/github\n[Semantic release]: Run automated release from branch master\n[Semantic release]: Call plugin verify-conditions\n[Semantic release]: Verify authentication for registry https://registry.npmjs.org/\n[Semantic release]: Verify GitHub authentication\n[Semantic release]: Verify GitHub authentication\n[Semantic release]: EINVALIDGHTOKEN Invalid GitHub token.\nThe GitHub token (https://github.com/semantic-release/github/blob/master/README.md#github-authentication) configured in the GH_TOKEN or GITHUB_TOKEN environment variable must be a valid personnal token (https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line) allowing to push to the repository timecapture/tsheets-frontend-app-ci-example.\nPlease make sure to set the GH_TOKEN or GITHUB_TOKEN environment variable in your CI with the exact value of the GitHub personnal token.\n[Semantic release]: ENONPMTOKEN No npm token specified.\nAn npm token (https://github.com/semantic-release/npm/blob/master/README.md#npm-registry-authentication) must be created and set in the NPM_TOKEN environment variable on your CI environment.\nPlease make sure to create an npm token (https://docs.npmjs.com/getting-started/working_with_tokens#how-to-create-new-tokens) and to set it in the NPM_TOKEN environment variable on your CI environment. The token must allow to publish to the registry https://registry.npmjs.org/.\n[Semantic release]: EINVALIDGHTOKEN Invalid GitHub token.\nThe GitHub token (https://github.com/semantic-release/github/blob/master/README.md#github-authentication) configured in the GH_TOKEN or GITHUB_TOKEN environment variable must be a valid personnal token (https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line) allowing to push to the repository timecapture/tsheets-frontend-app-ci-example.\nPlease make sure to set the GH_TOKEN or GITHUB_TOKEN environment variable in your CI with the exact value of the GitHub personnal token.\n{ AggregateError: \n    SemanticReleaseError: No npm token specified.\n        at module.exports (/usr/local/lib/node_modules/semantic-release/node_modules/@semantic-release/npm/lib/get-error.js:6:10)\n        at module.exports (/usr/local/lib/node_modules/semantic-release/node_modules/@semantic-release/npm/lib/set-npmrc-auth.js:21:31)\n        at module.exports (/usr/local/lib/node_modules/semantic-release/node_modules/@semantic-release/npm/lib/verify-auth.js:17:9)\n        at \n    SemanticReleaseError: Invalid GitHub token.\n        at module.exports (/usr/local/lib/node_modules/semantic-release/node_modules/@semantic-release/github/lib/get-error.js:6:10)\n        at module.exports (/usr/local/lib/node_modules/semantic-release/node_modules/@semantic-release/github/lib/verify.js:86:21)\n        at \n    at Object.verifyConditions (/usr/local/lib/node_modules/semantic-release/lib/plugins/pipeline.js:52:45)\n    at  name: 'AggregateError' }\nExited with code 1\n```. Doh.... Ok, thanks for that, sorry for bothering you with the dumb mistake. That fixed the npm problems.\nInterestingly I'm still getting problems with the github token being labeled as invalid. That breadcrumb may give me more information for debugging the rest of this.. Whoo! Getting closer @pvdlg.\nI've run into something that's kind of weird. I'm still getting the Invalid GitHub token error, but running semantic-release against a test repo generates the new tags and pushes them to the GitHub repo just fine.\nAny thoughts?\n.releaserc.json\n{\n  \"prepare\": [\n    {\n      \"path\": \"@semantic-release/npm\",\n      \"npmPublish\": false,\n      \"tarballDir\": \"dist\"\n    }\n  ],\n  \"verifyConditions\": [\n    {\n      \"path\": \"@semantic-release/npm\",\n      \"npmPublish\": false,\n      \"tarballDir\": \"dist\"\n    }\n  ],\n  \"publish\": [\n    {\n      \"path\": \"@semantic-release/npm\",\n      \"npmPublish\": false,\n      \"tarballDir\": \"dist\"\n    },\n    {\n      \"path\": \"@semantic-release/exec\",\n      \"cmd\": \"echo ${nextRelease.version}.min.js\"\n    }\n  ],\n  \"analyzeCommits\": {\n    \"preset\": \"angular\",\n    \"releaseRules\": [\n      {\n        \"type\": \"docs\",\n        \"scope\": \"README\",\n        \"release\": \"patch\"\n      },\n      {\n        \"type\": \"refactor\",\n        \"release\": \"patch\"\n      },\n      {\n        \"type\": \"style\",\n        \"release\": \"patch\"\n      }\n    ],\n    \"parserOpts\": {\n      \"noteKeywords\": [\n        \"BREAKING CHANGE\",\n        \"BREAKING CHANGES\",\n        \"BREAKING\"\n      ]\n    }\n  }\n}\nSemantic release output:\n```\n!/bin/bash -eo pipefail\nsemantic-release\n[Semantic release]: Running semantic-release version 15.0.2\n[Semantic release]: Load plugin verifyConditions from @semantic-release/npm\n[Semantic release]: Load plugin analyzeCommits from @semantic-release/commit-analyzer\n[Semantic release]: Load plugin generateNotes from @semantic-release/release-notes-generator\n[Semantic release]: Load plugin prepare from @semantic-release/npm\n[Semantic release]: Load plugin publish from @semantic-release/npm\n[Semantic release]: Load plugin publish from @semantic-release/exec\n[Semantic release]: Load plugin success from @semantic-release/github\n[Semantic release]: Load plugin fail from @semantic-release/github\n[Semantic release]: Run automated release from branch master\n[Semantic release]: Call plugin verify-conditions\n[Semantic release]: Found git tag v1.1.0 associated with version 1.1.0\n[Semantic release]: Found 1 commits since last release\n[Semantic release]: Call plugin analyze-commits\n[Semantic release]: Analyzing commit: feat(foo): has a baz\nBREAKING CHANGE: breaks everything\n[Semantic release]: The release type for the commit is major\n[Semantic release]: Analysis of 1 commits complete: major release\n[Semantic release]: The next release version is 2.0.0\n[Semantic release]: Call plugin verify-release\n[Semantic release]: Call plugin generateNotes\n[Semantic release]: Call plugin prepare\n[Semantic release]: Wrote version 2.0.0 to package.json\n[Semantic release]: Creating npm package version 2.0.0\n[Semantic release]: Create tag v2.0.0\n[Semantic release]: Call plugin publish\n[Semantic release]: Call script echo 2.0.0.min.js\n2.0.0.min.js\n[Semantic release]: The command echo ${nextRelease.version}.min.js wrote invalid JSON to stdout. The stdout content will be ignored.\n[Semantic release]: Verify GitHub authentication\n[Semantic release]: Verify GitHub authentication\n[Semantic release]: EINVALIDGHTOKEN Invalid GitHub token.\nThe GitHub token (https://github.com/semantic-release/github/blob/master/README.md#github-authentication) configured in the GH_TOKEN or GITHUB_TOKEN environment variable must be a valid personnal token (https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line) allowing to push to the repository timecapture/tsheets-frontend-app-ci-example.\nPlease make sure to set the GH_TOKEN or GITHUB_TOKEN environment variable in your CI with the exact value of the GitHub personnal token.\n[Semantic release]: EINVALIDGHTOKEN Invalid GitHub token.\nThe GitHub token (https://github.com/semantic-release/github/blob/master/README.md#github-authentication) configured in the GH_TOKEN or GITHUB_TOKEN environment variable must be a valid personnal token (https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line) allowing to push to the repository timecapture/tsheets-frontend-app-ci-example.\nPlease make sure to set the GH_TOKEN or GITHUB_TOKEN environment variable in your CI with the exact value of the GitHub personnal token.\n{ SemanticReleaseError: Invalid GitHub token.\n    at module.exports (/usr/local/lib/node_modules/semantic-release/node_modules/@semantic-release/github/lib/get-error.js:6:10)\n    at module.exports (/usr/local/lib/node_modules/semantic-release/node_modules/@semantic-release/github/lib/verify.js:86:21)\n    at \n  name: 'SemanticReleaseError',\n  code: 'EINVALIDGHTOKEN',\n  details: 'The GitHub token configured in the GH_TOKEN or GITHUB_TOKEN environment variable must be a valid personnal token allowing to push to the repository timecapture/tsheets-frontend-app-ci-example.\\n\\nPlease make sure to set the GH_TOKEN or GITHUB_TOKEN environment variable in your CI with the exact value of the GitHub personnal token.',\n  semanticRelease: true,\n  pluginName: '@semantic-release/github' }\nExited with code 1\n```. Is there a way to just disable this verification then? I'm confused how one repo would work and the other doesn't. I'm just setting the GH_TOKEN as an environment variable. This is exactly what the docs say is required by the plugin. The only thing that I can think would impact this would be something in regards to my repo being on a github enterprise account.\n. Just want to say thank you for your help. At the end of the day, it came down to to major roadblocks:\n- npmPublish: false at top level in your release configuration\n- configuring the semantic-release/github plugin correctly\n  - specifically githubUrl and githubApiPathPrefix\nAt the end of the day it was in regards to my previous comment:\n\nThe only thing that I can think would impact this would be something in regards to my repo being on a github enterprise account.\n\nHere's the .releaserc.json configuration that I used:\n{\n  \"npmPublish\": false,\n  \"githubUrl\": \"https://github.intuit.com\",\n  \"githubApiPathPrefix\": \"/api/v3\",\n  \"publish\": [\n    {\n      \"path\": \"@semantic-release/github\"\n    },\n    {\n      \"path\": \"@semantic-release/exec\",\n      \"cmd\": \"yarn version-assets -d ./dist -r ${nextRelease.version}\"\n    }\n  ],\n  \"analyzeCommits\": {\n    \"preset\": \"angular\",\n    \"releaseRules\": [\n      {\n        \"type\": \"docs\",\n        \"scope\": \"README\",\n        \"release\": \"patch\"\n      },\n      {\n        \"type\": \"refactor\",\n        \"release\": \"patch\"\n      },\n      {\n        \"type\": \"style\",\n        \"release\": \"patch\"\n      }\n    ],\n    \"parserOpts\": {\n      \"noteKeywords\": [\n        \"BREAKING CHANGE\",\n        \"BREAKING CHANGES\",\n        \"BREAKING\"\n      ]\n    }\n  }\n}\nFeedback\nI found a few things that I may end up sending a pull request for:\n- It's unclear that if you want to set a configuration to override all aspects you have to set that at the top level of the configuration object (e.g. \"npmPublish: false) or setting it for every single plugin config.\n- The semantic-release-cli does not take a private github url into account when creating a gh token\n- The required configurations for the github token are not super clear, they're defined in the semantic-release-cli as:\n\nCreates (and saves for later use) a GitHub Personal Access Token with the following permissions: repo, read:org, repo:status, repo_deployment, user:email, write:repo_hook\n\nHowever, I find that this is pretty buried and should probably be surfaced somewhere else outside of just the semanti-release-cli. I'll submit some pull requests per each repo vs trying to delineate what can be improved further. Thanks again! Love the tooling.. ",
    "whosford": "I have a question about the dryRun configuration documentation. It states the following for the default value.\nDefault: false if running in a CI environment, false otherwise\nThis makes it sound as though the default is always false, is this correct?. ",
    "EfstathiadisDimitris": "Do you guys still need help. I can jump on this in the weekend... ",
    "ray1981jacob": "Is anything else know if I need to do. What's the next step. ",
    "bjavaid": "This may be due the number of APIs requests per second. Somehow this is working only one of our repositories on github and failing for all remaining repositories.\nPreviously I was getting this issue with version 8.0.0 so I upgraded the version to 12.4.1 but issue still exist (as you mentioned in the plugin:github).\nI tried with the next release 13.3.0 and git code tagging and publishing release notes worked perfectly :). The CI pipeline triggered after applying the tag on code produce the following debug log which is showing failing of github plugin.\n`\n$ npx semantic-release\n[Semantic release]: Load plugin verifyConditions from @semantic-release/npm\n[Semantic release]: Load plugin verifyConditions from @semantic-release/github\n[Semantic release]: Load plugin analyzeCommits from @semantic-release/commit-analyzer\n[Semantic release]: Load plugin generateNotes from @semantic-release/release-notes-generator\n[Semantic release]: Load plugin publish from @semantic-release/npm\n[Semantic release]: Load plugin publish from @semantic-release/github\n[Semantic release]: Load plugin success from @semantic-release/github\n[Semantic release]: Load plugin fail from @semantic-release/github\n[Semantic release]: This test run was triggered on the branch v3.1.1, while semantic-release is configured to only publish from master, therefore a new version won\u2019t be published.\n`\nAlso how I can generate the release notes of my previous releases?. ",
    "jourdain": "I am running into a similar issue from time to time. But on my end, it is npm who timeout but still produce the release. And then, because npm supposedly failed, semantic-release does not finish its job on github. I there anyway to generate the tag/change-log after the fact? Even manually?\nNPM release 6.3.8\nGithub releases (missing 6.3.8 and a couple others)\nThanks for such a great tool!\n[Semantic release]: The release type for the commit is patch\n[Semantic release]: Analysis of 10 commits complete: patch release\n[Semantic release]: The next release version is 6.3.8\n[Semantic release]: Call plugin verify-release\n[Semantic release]: Call plugin generateNotes\n[Semantic release]: Call plugin publish\n[Semantic release]: Wrote version 6.3.8 to package.json\n[Semantic release]: Publishing version 6.3.8 to npm registry\n[Semantic release]: An error occurred while running semantic-release: { Error: Command failed: npm publish ./. --registry https://registry.npmjs.org/\nnpm ERR! registry error parsing json\nnpm ERR! registry error parsing json\nnpm ERR! registry error parsing json\nnpm ERR! publish Failed PUT 504\nnpm ERR! Unexpected token < in JSON at position 0\nnpm ERR! <html><body><h1>504 Gateway Time-out</h1>\nnpm ERR! The server didn't respond in time.\nnpm ERR! </body></html>\nnpm ERR! \nnpm ERR! \nnpm ERR! A complete log of this run can be found in:\nnpm ERR!     /home/travis/.npm/_logs/2018-03-07T00_29_15_789Z-debug.log\n    at Promise.all.then.arr (/home/travis/build/Kitware/vtk-js/node_modules/execa/index.js:236:11)\n    at <anonymous>\n    at process._tickCallback (internal/process/next_tick.js:188:7)\n  code: 1,\n  killed: false,\n  stdout: '',\n  stderr: 'npm ERR! registry error parsing json\\nnpm ERR! registry error parsing json\\nnpm ERR! registry error parsing json\\nnpm ERR! publish Failed PUT 504\\nnpm ERR! Unexpected token < in JSON at position 0\\nnpm ERR! <html><body><h1>504 Gateway Time-out</h1>\\nnpm ERR! The server didn\\'t respond in time.\\nnpm ERR! </body></html>\\nnpm ERR! \\nnpm ERR! \\n\\nnpm ERR! A complete log of this run can be found in:\\nnpm ERR!     /home/travis/.npm/_logs/2018-03-07T00_29_15_789Z-debug.log\\n',\n  failed: true,\n  signal: null,\n  cmd: 'npm publish ./. --registry https://registry.npmjs.org/',\n  timedOut: false }\nnpm ERR! code ELIFECYCLE\nnpm ERR! errno 1\nnpm ERR! vtk.js@0.0.0-semantically-release semantic-release: `semantic-release`\nnpm ERR! Exit status 1\nnpm ERR! \nnpm ERR! Failed at the vtk.js@0.0.0-semantically-release semantic-release script.\nnpm ERR! This is probably not a problem with npm. There is likely additional logging output above.\nnpm ERR! A complete log of this run can be found in:\nnpm ERR!     /home/travis/.npm/_logs/2018-03-07T00_29_15_827Z-debug.log. ",
    "cyntss": "was this implemented? im using version 15.1.3 in GitlabCI and it keeps breaking asking for a Github token, that seems to be because of the Success/Fail notifications. @pvdlg it is working now after reading: https://github.com/semantic-release/semantic-release/pull/668\nI had to set to false the success and fail options:\nverifyConditions:\n  - '@semantic-release/npm'\n  - '@semantic-release/gitlab'\npublish:\n  - '@semantic-release/npm'\n  - '@semantic-release/gitlab'\nsuccess: false\nfail: false\nThank you. ",
    "brokenmass": "\nMaybe we could try git push --dry-run with the actual url configured and if it works use it. If it doesn't we try to convert to http/https and use the GL_TOKEN as of now. I'd to experiment a bit to see if that could work.  \n\n\u261d\ufe0f This for me would be the best solution.In this way the process clearly follow the 'user' setup unless it find an error and only at that point 'gets smart' and tries to automatically recover the error any other provided credential.\nAnother scenario where this issue arises is if the user that owns the access token is different from the user owning the ssh key. this will commit code to the repository with the 'wrong' user.. I tested in my environment and now it's working correctly so all good for me, you can merge.. do you want this console.log ? shouldn't be a debug() ?. ",
    "protoEvangelion": "Current FAQ location: https://semantic-release.gitbook.io/semantic-release/support/faq#why-is-the-package-jsons-version-not-updated-in-my-repository. ",
    "tarazansafak": "I have updated my description and I was wondering should I try to write a prepare plugin and do my trick there? So that I can update the package.json with desired formatted version and publish. I got it working just today by using semantic-release/exec plugin and today I am publish in this format:\npackageName-semver-customPostfix ie:\nfdp-tool-cli-1.1.0-feature14\nYou are saying its not valid semver format but npm version command allows it, that is the tiny bit I am holding on to:)\nThe reason that I am doing this to be able to release from multiple branches. Here how it goes:\nIn each branch, including feature branches, I am running semantic-release with custom exec commands and publishing the artifact with packageName-semver-customPostfix  format and adding a dist tag with branch name to point my newly published component. By this way, I can always get the latest pakcage of my component from registry. During this process, I am not even bumping the version to package.json.\nI just wanted to do this from CLI instead of needing to run exec commands to customize it. Did I make myself more clear and how is your opinion on this approach? Currently, it seems to work for us.   . I am using private registry on artifactory. I think npm accepts it because its pre-release format isn't it?:\nsemver.valid(semver.coerce('42.6.7.9.3-alpha')) // '42.6.7'.\nHere is an example from my private registry and all the version info is kept in all.json on artifactory automagically.\nfdp-tool-cli-1.1.3-CICD-282-semver-pilot.tgz\nAnyways, you can close this issue. I will be also watching 563. Thanks for your time.. yes you are right, I just copied the whole string including the package name. Anyhow, it would be nice if we can support this pre-release with semantic-version plugin. By passing the pre-release part via cli as we are doing it with tag-format command. . ",
    "MadsRCEnerginet": "@pvdlg I had forgotten to publicize the repo, should be fixed now.\nnpm -g install @semantic-release/git semantic-release && semantic-release seemed to work, however I'm having issues with it trying to publish to npm (and failing due to no `package.json\u00b4 file... I'll keep working on it to try and get it to work.. ",
    "richardson-trevor": "We're on v15.0.3 and we've had the same The push permission to the Git repository is required issue come up multiple times today. Sounds like you're thinking this might be a blip with either Travis or Github, but thought I'd chime in with that for an additional data point.. Something else we noticed was the following: \n[Semantic release]: EMISSINGREPO The repository ainCompliance/react-components [secure]esn't exist.\nwhereas the real repository base should be GainCompliance. Our package.json is listed as follows:\n\"repository\": \"GainCompliance/react-components\". Alright, another update on this one. I added the --debug flag as recommended and get the following:\n2018-03-14T13:34:41.492Z semantic-release:git Error: Command failed: git push --dry-run https:///ainCompliance/react-components.git HEAD:master\nfatal: unable to access 'https:///ainCompliance/react-components.git/': Could not resolve host: https\nAgain the G appears missing for some reason. The piece I find interesting is that a few lines above that I get: \n2018-03-14T13:34:40.595Z semantic-release:git Error: Command failed: git push --dry-run GainCompliance/react-components HEAD:master\nfatal: 'GainCompliance/react-components' [secure]es not appear to be a git repository\nwhich clearly has the entire owner name, but without the --debug flag was the output that did not contain the owner name as mentioned in previous comments.. Ah, okay, that's the problem then. We have ours as shown in https://github.com/semantic-release/semantic-release/issues/695#issuecomment-372810602. We had a major version bump recently and this must've been supported on our previous version as we've got a number of projects setup this way that have been working. Appreciate the help!. \ud83d\udc4dthat would work from our end.. \ud83d\udc4d thanks for the quick turnaround!. ",
    "peyerluk": "I ran into this issue as well.\nTrying out some older versions I noticed that starting with version 15.03 npx semantic-release -d asked me for my github login (prompt: 'Username for 'https://github.com':') even though GH_TOKEN was set. Previous versions did not do this.\nNote: As password I provided an accessToken.\nBut this only happened if my repository url in the package.json started with https:.\nSo I tested a bit and tried different values for repository.url in the package.json. \nThese are the results for version 15.0.3:\n\nhttps://github.com/upfrontIO/microschema -> asks for username and password twice, but works.\n//github.com/upfrontIO/microschema -> works as expected\ngithub.com/upfrontIO/microschema -> I get 'The push permission to the Git repository is required.'\nupfrontIO/microschema -> I get 'The push permission to the Git repository is required.' (as expected from the previous comments)\n\nSame tests with 15.1.2:\n\nhttps://github.com/upfrontIO/microschema -> asks for username and password once, then 'The push permission to the Git repository is required.'.\n//github.com/upfrontIO/microschema -> works as expected\ngithub.com/upfrontIO/microschema -> 'The push permission to the Git repository is required.'\nupfrontIO/microschema -> asks for username and password once, then 'The push permission to the Git repository is required.'.\n\n\u00af\\(\u30c4)/\u00af. I created an issue:\nThe push permission to the Git repository is required v2 #708. > What do you get when you run in terminal the following:\nBoth work (but I have to enter the username and password for git push --dry-run https://github.com/upfrontIO/microschema HEAD:ci-integration as I haven't set any other environment variables in my terminal session).\nTo https://2bc307b681e4d4e8fe72825c53b525c3a4e3fa35@github.com/upfrontIO/microschema\n   d6e1351..f99fb10  HEAD -> ci-integration\nDebug Runs\nWith https://github.com/upfrontIO/microschema\n[Semantic release]: Running semantic-release version 15.1.2\nUsername for 'https://github.com': livingdocs-automation\nPassword for 'https://livingdocs-automation@github.com':\n  semantic-release:config options values: { branch: 'ci-integration',\n  semantic-release:config   repositoryUrl: 'https://github.com/upfrontIO/microschema',\n  semantic-release:config   tagFormat: 'v${version}',\n  semantic-release:config   _: [],\n  semantic-release:config   debug: true,\n  semantic-release:config   d: true,\n  semantic-release:config   'dry-run': true,\n  semantic-release:config   dryRun: true,\n  semantic-release:config   '$0': 'node_modules/.bin/semantic-release' } +0ms\n[Semantic release]: Load plugin verifyConditions from @semantic-release/npm\n[Semantic release]: Load plugin verifyConditions from @semantic-release/github\n[Semantic release]: Load plugin analyzeCommits from @semantic-release/commit-analyzer\n[Semantic release]: Load plugin generateNotes from @semantic-release/release-notes-generator\n[Semantic release]: Load plugin prepare from @semantic-release/npm\n[Semantic release]: Load plugin publish from @semantic-release/npm\n[Semantic release]: Load plugin publish from @semantic-release/github\n[Semantic release]: Load plugin success from @semantic-release/github\n[Semantic release]: Load plugin fail from @semantic-release/github\n  semantic-release:git Error: Command failed: git push --dry-run https://github.com/upfrontIO/microschema HEAD:ci-integration\n  semantic-release:git remote: Invalid username or password.\n  semantic-release:git fatal: Authentication failed for 'https://github.com/upfrontIO/microschema/'\n  semantic-release:git\n  semantic-release:git\n  semantic-release:git     at makeError (/Users/Lukas/git/microschema/node_modules/semantic-release/node_modules/execa/index.js:172:9)\n  semantic-release:git     at Promise.all.then.arr (/Users/Lukas/git/microschema/node_modules/semantic-release/node_modules/execa/index.js:277:16)\n  semantic-release:git     at <anonymous>\n  semantic-release:git     at process._tickCallback (internal/process/next_tick.js:188:7) +0ms\n[Semantic release]: EGITNOPERMISSION The push permission to the Git repository is required.\nsemantic-release cannot push the version tag to the branch ci-integration on remote Git repository.\nWith //github.com/upfrontIO/microschema\n```\n[Semantic release]: Running semantic-release version 15.1.2\n  semantic-release:git Error: Command failed: git push --dry-run //github.com/upfrontIO/microschema HEAD:ci-integration\n  semantic-release:git fatal: '//github.com/upfrontIO/microschema' does not appear to be a git repository\n  semantic-release:git fatal: Could not read from remote repository.\n  semantic-release:git\n  semantic-release:git Please make sure you have the correct access rights\n  semantic-release:git and the repository exists.\n  semantic-release:git\n  semantic-release:git\n  semantic-release:git     at makeError (/Users/Lukas/git/microschema/node_modules/semantic-release/node_modules/execa/index.js:172:9)\n  semantic-release:git     at Promise.all.then.arr (/Users/Lukas/git/microschema/node_modules/semantic-release/node_modules/execa/index.js:277:16)\n  semantic-release:git     at \n  semantic-release:git     at process.tickCallback (internal/process/next_tick.js:188:7) +0ms\n  semantic-release:config options values: { branch: 'ci-integration',\n  semantic-release:config   repositoryUrl: 'https://[secure]@github.com/upfrontIO/microschema.git',\n  semantic-release:config   tagFormat: 'v${version}',\n  semantic-release:config   : [],\n  semantic-release:config   debug: true,\n  semantic-release:config   d: true,\n  semantic-release:config   'dry-run': true,\n  semantic-release:config   dryRun: true,\n  semantic-release:config   '$0': 'node_modules/.bin/semantic-release' } +0ms\n[Semantic release]: Load plugin verifyConditions from @semantic-release/npm\n[Semantic release]: Load plugin verifyConditions from @semantic-release/github\n[Semantic release]: Load plugin analyzeCommits from @semantic-release/commit-analyzer\n[Semantic release]: Load plugin generateNotes from @semantic-release/release-notes-generator\n[Semantic release]: Load plugin prepare from @semantic-release/npm\n[Semantic release]: Load plugin publish from @semantic-release/npm\n[Semantic release]: Load plugin publish from @semantic-release/github\n[Semantic release]: Load plugin success from @semantic-release/github\n[Semantic release]: Load plugin fail from @semantic-release/github\n[Semantic release]: Run automated release from branch ci-integration\n[Semantic release]: Call plugin verify-conditions\n[Semantic release]: Verify authentication for registry https://registry.npmjs.org/\n[Semantic release]: Verify GitHub authentication\n... the rest seems all honkey-dory\n```\nIt seems like the dry runs are happening at different times in the two cases. And in the //github.com case the conversion to https://github.com/upfrontIO/microschema doesn't seem to work.\nIn the https: case it doesn't seem to try to push with the GH_TOKEN or it is not logged. To be fair the dry run with the GH_TOKEN is also not logged in the //github.com case. There it just works in the end.. I use a token as a password and it is the same I used for all the other tests. I didn't type it manually. The same token is also already in use in many other of our repos (although they use older versions of semantic release). And in all cases the GH_TOKEN is set as an environment variable. This token in GH_TOKEN is the same token I input manually if prompted. It's also the same token that worked in 15.0.3 an prior.\nFor me it doesn't make sense that it behaves differently depending on how the url is specified. Furthermore if the GH_TOKEN is provided I would expect semantic-release to use it.\nBut I don't mind much. I just observed this behaviour and thought you might find it interesting.. Regarding github so there is no confusion, I'm talking about the personal access tokens: https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/. I understand this is a weird bug. And it might only occur in some scenarios or locally. But at least in some indirect way (dependencies?) it is connected, because:\nWith a valid https://github.com/organization/repo url\nIn 15.0.2 when providing the GH_TOKEN it just worked. no prompting of anything.\nIn 15.0.3 when providing the GH_TOKEN it prompted for username/password and it worked.\nIn 15.1.2 when providing the GH_TOKEN it prompted for username/password and didn't work anymore.\nBy now, I'm just curious what is going on :)\n. And the token as a password thingy is super useful if you use two-factor authentication.... > Can it be due to something that changed in your environment?\nI'm setting semantic-release up in a repo and I also removed the node_modules and reinstalled. Other than that I didn't change anything else today. At least on my machine it looks consistent. But at this point it probably makes sense if it can be reproduced by someone else (or just wait if others have similar issues).. I just saw than wen creating a personal access token it works if the token does not get any additional permissions.\nIf the token gets the repo permission it does not work anymore.\n\nSo it seems that depending on how you test if the connection works you get different results from the same token. As the permissions on the token are good enough in both cases (for a public repository that is).. The removal of the node modules doesn't change anything. It's consistent on my machine:\nIn 15.0.2 when providing the GH_TOKEN it just worked. no prompting of anything.\nIn 15.1.2 when providing the GH_TOKEN it prompted for username/password and didn't work anymore.. When passing --repository-url https://wrong_user@github.com/semantic-release/semantic-release.git --dry-run it also prompts for the user in all the cases you mentioned.\nI guess the differences in the execution path depending on how the --repository-url is formatted cause the issues I see.\nMaybe it is enough to reproduce the issue if you remove your user/password from the keychain (I myself don't have them in my keychain). I can't add the user/password to my keychain to test as I use two-factor authentication.. Thanks for looking into it! And feel free to close.\nAs an input you may consider that if the GH_TOKEN is provided that semantic-release tries to push with the https url and the token first: https://<GH_TOKEN>@github.com/org/repo. In my opinion this would simplify testing locally if it tries environment variables that are used in the CI environment first. If semantic release tries with my username and password from the keychain first I can't really test locally if the token is correct. If it would be possible to pass the token as an argument to force a strategy that would also help.\nIn my usecase when testing locally before pushing the semantic-release setup to my repo the fallbacks are actually not really desirable.\nThanks again!. release 15.1.3 fixes the issues! \ud83e\udd47 \nNow I can close it myself :). We have an organisation setup with a bot-account that has the necessary permissions for CI integrations and publishing to npm. And we force all users to activate two-factor authentication. And I mostly want semantic-release to work exactly the same as it would on the CI for testing and as an emergency fallback when the CI is down but using the same tokens locally as we would on the CI.\nBut I completely understand if you optimise for the use cases the majority of your users care about.\nKeep up the good work!. ",
    "escalate": "I have to add more details to this bug report first.\nThe error message only occurs if I'm using the \"--debug\" toggle.\nThis is the output without the toggle.\n```\n  py36: commands succeeded\n  flake8: commands succeeded\n  congratulations :)\ntravis_time:end:00ebb0e9:start=1520927634655338421,finish=1520927659946117329,duration=25290778908\n\u001b[0K\n\u001b[32;1mThe command \"tox\" exited with 0.\u001b[0m\ntravis_fold:start:after_success.1\n\u001b[0Ktravis_time:start:2cb31d24\n\u001b[0K$ nvm install lts/*\nDownloading and installing node v8.10.0...\nDownloading https://nodejs.org/dist/v8.10.0/node-v8.10.0-linux-x64.tar.xz...\nComputing checksum with sha256sum\nChecksums matched!\nNow using node v8.10.0 (npm v5.6.0)\ntravis_time:end:2cb31d24:start=1520927659954592288,finish=1520927662930050654,duration=2975458366\n\u001b[0Ktravis_fold:end:after_success.1\n\u001b[0Ktravis_fold:start:after_success.2\n\u001b[0Ktravis_time:start:1c0934e5\n\u001b[0K$ npx travis-deploy-once \"npx semantic-release\"\nnpx: installed 246 in 9.772s\n[Travis Deploy Once]: There is only one job for this build.\nnpx: installed 387 in 12.623s\n[Semantic release]: Running semantic-release version 15.0.3\n[Semantic release]: Load plugin verifyConditions from @semantic-release/github\n[Semantic release]: Load plugin analyzeCommits from @semantic-release/commit-analyzer\n[Semantic release]: Load plugin generateNotes from @semantic-release/release-notes-generator\n[Semantic release]: Load plugin publish from @semantic-release/github\n[Semantic release]: Load plugin success from @semantic-release/github\n[Semantic release]: Load plugin fail from @semantic-release/github\n[Semantic release]: Run automated release from branch master\n[Semantic release]: Call plugin verify-conditions\n[Semantic release]: Verify GitHub authentication\n[Semantic release]: Found git tag v1.0.0 associated with version 1.0.0\n[Semantic release]: Found 1 commits since last release\n[Semantic release]: Call plugin analyze-commits\n[Semantic release]: Analyzing commit: ci: remove debug option for semantic-release\n[Semantic release]: The commit should not trigger a release\n[Semantic release]: Analysis of 1 commits complete: no release\n[Semantic release]: There are no relevant changes, so no new version is released.\ntravis_time:end:1c0934e5:start=1520927662937964847,finish=1520927690524800785,duration=27586835938\n\u001b[0Ktravis_fold:end:after_success.2\n\u001b[0K\n```. Sorry this was my fault. I added my a comment draft too quick. I deleted the comment immediately.\nIn my previous comment I mentioned that the error only appears with debug mode enabled. \nThat makes this bug very small for me.\nI read the solution for issue #667. At this point I don't understand how the core should really work now.\n\nUse the unmodified configured repositoryUrl (without adding the credentials) if it works, otherwise do as of now and convert the URL to http/https and add the credentials. This allow users to push tags and commits via ssh while still using the GitHub/GitLab API.\n\nThe part \"convert the URL to http/https and add the credentials\" should not create the mentioned error.\nAm I right?\nFor testing purpose I added the property repositoryUrl to .releaserc file. The error still occures in debug mode.\nrepositoryUrl: \"https://github.com/escalate/loxone-ha-bridge-importer.git\"\nMy expectation is that the core uses the GH_TOKEN if its present to test the push funtionality.\nBut it uses username and password which are not present.\nOr is the usage of username and password only one part of the whole push tests?\nAnyway the stack trace is not really nice. I think the smallest change could be to catch the error and print a nicer and more clearer message.. ",
    "AVVS": "@pvdlg I might sound a bit frustrated, but how do people not run into issues with the following:\n/**\n * Verify the write access authorization to remote repository with push dry-run.\n *\n * @param {String} origin The remote repository URL.\n * @param {String} branch The repositoru branch for which to verify write access.\n *\n * @return {Boolean} `true` is authorized to push, falsy otherwise.\n */\nasync function verifyAuth(origin, branch) {\n  try {\n    return (await execa('git', ['push', '--dry-run', origin, `HEAD:${branch}`])).code === 0;\n  } catch (err) {\n    debug(err);\n  }\n}\nThis simply asks the user to input \"username\" and \"password\" when pushing to https:// based URLs - and thats often the case for OSS projects.\nI dont see any way to remove prompt for username/password from git when its not supplied, but at least set timeout option for execa to fail after 2-3 seconds or so - that should be enough to verify authentication via ssh. I run this on semaphore CI - you can test it there I suppose, they are free for OSS\n\nOn Mar 15, 2018, at 8:08 AM, Pierre Vanduynslager notifications@github.com wrote:\nGIT_TERMINAL_PROMPT\n\n. I do experience the issue, CI has GH_TOKEN & NPM_TOKEN set\nyarn run v1.3.2\n$ semantic-release\n[Semantic release]: Running semantic-release version 15.0.3\nUsername for 'https://github.com': execution expired\nidk if it will show or not since its a deploy log - https://semaphoreci.com/makeomatic/deploy/servers/git-ssh/deploys/28 \nThese are the settings it fails with - https://github.com/makeomatic/deploy/blob/master/.releaserc.json (tried to upgrade SR from 12.x to 15.x)\n\nOn Mar 15, 2018, at 8:43 AM, Pierre Vanduynslager notifications@github.com wrote:\nDid you experience this issue on Semaphore? Do you have the semantic-release config and the CI logs when the problem happened?\nIs what you describe is actually a problem you experienced or just a concern?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub https://github.com/semantic-release/semantic-release/issues/699#issuecomment-373422238, or mute the thread https://github.com/notifications/unsubscribe-auth/ABol0T1aXUin-OQ-F8g5Q5e7e3GyrFHmks5teowcgaJpZM4SoN8C.\n\n\n. I've actually included them earlier, since I suspected it would be the case:\n$ semantic-release\n[Semantic release]: Running semantic-release version 15.0.3\nUsername for 'https://github.com': execution expired\nThis is after the build timed out in 60 minutes :). I did debug the issue first before filing it here, it does happen during the aforementioned execa call (locally as well during the dry-run since I only have ssh credentials, and when its an https schema it would ask for username/password, which is probably not something I want to do anyway). Yeah I understand, thats the case for the private repos and I have no problem with them, but for the public/OSS ones its preferable to set the repo URL to https\nThanks\n\nOn Mar 15, 2018, at 9:02 AM, Pierre Vanduynslager notifications@github.com wrote:\nOk I'm looking at it. For information if you want to use ssh rather than https you have to configure repositoryUrl as a git url (like git@github.com:owner/repo.git). This way the first call to git --dry-run will works if your ssh keys are properly set up, and semantic-release will use that URL.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub https://github.com/semantic-release/semantic-release/issues/699#issuecomment-373429275, or mute the thread https://github.com/notifications/unsubscribe-auth/ABol0THGJwwFIHk9yf5vECLJIU9DyCMqks5tepCwgaJpZM4SoN8C.\n\n\n. Seems reasonable to me. @pvdlg @gr2m It doesnt seem to solve the issue\nI'm not sure if its some sort of weirdness with env not being passed down with execa, but thats what I get when manually testing, notice that when I pass env variables manually, its all good, but process.env thats been modified inside the nodejs process is actually not being treated by execa anyhow. Also the timeout option itself doesnt trigger for some reason\n\n. @gr2m done :). @pvdlg I can, though I cant still see it on the @next, nor @15.1.3 - has it been released yet?. can confirm it works. ",
    "ArielGueta": "Thanks!. Thanks for the quick response.\nThe problem is that if I run semantic-release setup in my root project, it does the magic (  \"version\": \"0.0.0-development\" ) inside the root package.json. When I run the release I need semantic release to bump the package.json that inside the lib folder and not the one that at the project root. \n. It always there. \n\n. After running npm run build:lib you will have a dist folder that should be published to npm. The build folder will contain the package.json that inside the lib folder.. \n. OK, I am sorry, I know it's confusing, I will try it and let you know. I really appreciate your help. Thanks. . So I successfully published the package, but the problem is that it's not updated the correct package.json file. \nIt is running the npm publish from the dist folder, but it's updating the root package.json and not the one in the dist folder. Any idea why? . ",
    "SirWindfield": "Wow, I didn't see that I added that line of code. My fault, sorry.\nThank you for your help though @gr2m!. ",
    "lastmjs": "Hey I'm running into this issue on this repository: https://github.com/lastmjs/guesswork\nI don't know what's wrong, I'm using CirclecCI, my token is updated and put in correctly, I'm using a version of semantic-release above 15.1.3, and my url starts with https://...any suggestions?. ",
    "juliocanares": "@pvdlg it actually pushes the release to my github repo, but I don't know why it shows that error.. yeah, I got back to circle ci and seen that there is actually 2 pipelines failing. \nOne with the error I sent first, and another one with the following.\n```bash\n!/bin/bash -eo pipefail\nyarn semantic-release\nyarn run v1.3.2\n$ semantic-release\n[Semantic release]: Running semantic-release version 15.1.3\n[Semantic release]: Load plugin verifyConditions from @semantic-release/npm\n[Semantic release]: Load plugin verifyConditions from @semantic-release/github\n[Semantic release]: Load plugin analyzeCommits from @semantic-release/commit-analyzer\n[Semantic release]: Load plugin generateNotes from @semantic-release/release-notes-generator\n[Semantic release]: Load plugin prepare from @semantic-release/npm\n[Semantic release]: Load plugin publish from @semantic-release/npm\n[Semantic release]: Load plugin publish from @semantic-release/github\n[Semantic release]: Load plugin success from @semantic-release/github\n[Semantic release]: Load plugin fail from @semantic-release/github\n[Semantic release]: Run automated release from branch master\n[Semantic release]: Call plugin verify-conditions\n[Semantic release]: Verify GitHub authentication\n[Semantic release]: Found git tag v1.1.1 associated with version 1.1.1\n[Semantic release]: Found 10 commits since last release\n[Semantic release]: Call plugin analyze-commits\n[Semantic release]: Analyzing commit: Merge pull request #191 from riqra/initial-structure-for-roles-and-permissions\nInitial database structure for roles and permissions\n[Semantic release]: The commit should not trigger a release\n[Semantic release]: Analyzing commit: Merge pull request #181 from riqra/180-order-statuses-customized-by-distributor\nOrder statuses customized by distributor\n[Semantic release]: The commit should not trigger a release\n[Semantic release]: Analyzing commit: Merge branch 'master' into 180-order-statuses-customized-by-distributor\n[Semantic release]: The commit should not trigger a release\n[Semantic release]: Analyzing commit: refactor: changes filename for add-distributor-id and add-is-default-column in order statuses table\n[Semantic release]: The commit should not trigger a release\n[Semantic release]: Analyzing commit: feat: adds initial database structure for roles and permissions\n[Semantic release]: The release type for the commit is minor\n[Semantic release]: Analyzing commit: Merge pull request #189 from riqra/upgrade-semantic-release-to-v15.1.3\nUpdates semantic-release to v15.1.3\n[Semantic release]: The commit should not trigger a release\n[Semantic release]: Analyzing commit: chore(package.json): updates semantic-release to v15.1.3\n[Semantic release]: The commit should not trigger a release\n[Semantic release]: Analyzing commit: test(order-statuses.js): fixes orderStatuses root query\n[Semantic release]: The commit should not trigger a release\n[Semantic release]: Analyzing commit: test: adds tests for custom distributor order statuses\n[Semantic release]: The commit should not trigger a release\n[Semantic release]: Analyzing commit: feat: adds database structure to have customized order statuses by distributor\n[Semantic release]: The release type for the commit is minor\n[Semantic release]: Analysis of 10 commits complete: minor release\n[Semantic release]: The next release version is 1.2.0\n[Semantic release]: Call plugin verify-release\n[Semantic release]: Call plugin generateNotes\n[Semantic release]: Call plugin prepare\n[Semantic release]: Wrote version 1.2.0 to package.json\n[Semantic release]: Create tag v1.2.0\n[Semantic release]: Call plugin publish\n[Semantic release]: Published GitHub release: https://github.com/riqra/riqra-saas-api/releases/tag/v1.2.0\n[Semantic release]: An error occurred while running semantic-release: { HttpError: {\"message\":\"Validation Failed\",\"errors\":[{\"message\":\"The listed users and repositories cannot be searched either because the resources do not exist or you do not have permission to view them.\",\"resource\":\"Search\",\"field\":\"q\",\"code\":\"invalid\"}],\"documentation_url\":\"https://developer.github.com/v3/search/\"}\n    at response.text.then.message (/home/circleci/app/node_modules/@octokit/rest/lib/request/request.js:56:19)\n    at \n    at process._tickCallback (internal/process/next_tick.js:188:7)\n  name: 'HttpError',\n  code: 422,\n  status: undefined,\n  headers: \n   { 'access-control-allow-origin': '',\n     'access-control-expose-headers': 'ETag, Link, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval',\n     'cache-control': 'no-cache',\n     connection: 'close',\n     'content-length': '306',\n     'content-security-policy': 'default-src \\'none\\'',\n     'content-type': 'application/json; charset=utf-8',\n     date: 'Thu, 22 Mar 2018 23:24:13 GMT',\n     'referrer-policy': 'origin-when-cross-origin, strict-origin-when-cross-origin',\n     server: 'GitHub.com',\n     status: '422 Unprocessable Entity',\n     'strict-transport-security': 'max-age=31536000; includeSubdomains; preload',\n     'x-accepted-oauth-scopes': '',\n     'x-content-type-options': 'nosniff',\n     'x-frame-options': 'deny',\n     'x-github-media-type': 'github.v3; format=json',\n     'x-github-request-id': 'E8FE:5F56:29F6AFF:5AC1A0B:5AB43B1D',\n     'x-oauth-scopes': 'admin:repo_hook, read:org, read:user, repo, user:email',\n     'x-ratelimit-limit': '30',\n     'x-ratelimit-remaining': '23',\n     'x-ratelimit-reset': '1521761101',\n     'x-runtime-rack': '0.035382',\n     'x-xss-protection': '1; mode=block' },\n  pluginName: '@semantic-release/github' }\n{ HttpError: {\"message\":\"Validation Failed\",\"errors\":[{\"message\":\"The listed users and repositories cannot be searched either because the resources do not exist or you do not have permission to view them.\",\"resource\":\"Search\",\"field\":\"q\",\"code\":\"invalid\"}],\"documentation_url\":\"https://developer.github.com/v3/search/\"}\n    at response.text.then.message (/home/circleci/app/node_modules/@octokit/rest/lib/request/request.js:56:19)\n    at \n    at process._tickCallback (internal/process/next_tick.js:188:7)\n  name: 'HttpError',\n  code: 422,\n  status: undefined,\n  headers: \n   { 'access-control-allow-origin': '',\n     'access-control-expose-headers': 'ETag, Link, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval',\n     'cache-control': 'no-cache',\n     connection: 'close',\n     'content-length': '306',\n     'content-security-policy': 'default-src \\'none\\'',\n     'content-type': 'application/json; charset=utf-8',\n     date: 'Thu, 22 Mar 2018 23:24:13 GMT',\n     'referrer-policy': 'origin-when-cross-origin, strict-origin-when-cross-origin',\n     server: 'GitHub.com',\n     status: '422 Unprocessable Entity',\n     'strict-transport-security': 'max-age=31536000; includeSubdomains; preload',\n     'x-accepted-oauth-scopes': '',\n     'x-content-type-options': 'nosniff',\n     'x-frame-options': 'deny',\n     'x-github-media-type': 'github.v3; format=json',\n     'x-github-request-id': 'E8FE:5F56:29F6AFF:5AC1A0B:5AB43B1D',\n     'x-oauth-scopes': 'admin:repo_hook, read:org, read:user, repo, user:email',\n     'x-ratelimit-limit': '30',\n     'x-ratelimit-remaining': '23',\n     'x-ratelimit-reset': '1521761101',\n     'x-runtime-rack': '0.035382',\n     'x-xss-protection': '1; mode=block' },\n  pluginName: '@semantic-release/github' }\nerror Command failed with exit code 1.\ninfo Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command.\nExited with code 1\n```\nthis is the pipeline that is pushing the release without saying anything about the GITHUB_TOKEN. I am also running the pipeline again with the DEBUG enabled.. @pvdlg \nthis is what I got\n```bash\n!/bin/bash -eo pipefail\nyarn semantic-release\nyarn run v1.3.2\n$ semantic-release\n[Semantic release]: Running semantic-release version 15.1.3\n  semantic-release:config options values: { branch: 'master',\n  semantic-release:config   repositoryUrl: 'https://github.com/riqra/riqra-graphql',\n  semantic-release:config   tagFormat: 'v${version}',\n  semantic-release:config   publish: \n  semantic-release:config    [ { path: '@semantic-release/npm', npmPublish: false },\n  semantic-release:config      { path: '@semantic-release/github' } ],\n  semantic-release:config   _: [],\n  semantic-release:config   '$0': 'node_modules/.bin/semantic-release' } +0ms\n[Semantic release]: Load plugin verifyConditions from @semantic-release/npm\n[Semantic release]: Load plugin verifyConditions from @semantic-release/github\n[Semantic release]: Load plugin analyzeCommits from @semantic-release/commit-analyzer\n[Semantic release]: Load plugin generateNotes from @semantic-release/release-notes-generator\n[Semantic release]: Load plugin prepare from @semantic-release/npm\n[Semantic release]: Load plugin publish from @semantic-release/npm\n[Semantic release]: Load plugin publish from @semantic-release/github\n[Semantic release]: Load plugin success from @semantic-release/github\n[Semantic release]: Load plugin fail from @semantic-release/github\n  semantic-release:git Error: Command failed: git push --dry-run https://github.com/riqra/riqra-graphql HEAD:master\n  semantic-release:git ERROR: The key you are authenticating with has been marked as read only.\n  semantic-release:git fatal: Could not read from remote repository.\n  semantic-release:git \n  semantic-release:git Please make sure you have the correct access rights\n  semantic-release:git and the repository exists.\n  semantic-release:git \n  semantic-release:git \n  semantic-release:git     at makeError (/home/circleci/app/node_modules/execa/index.js:172:9)\n  semantic-release:git     at Promise.all.then.arr (/home/circleci/app/node_modules/execa/index.js:277:16)\n  semantic-release:git     at \n  semantic-release:git     at process._tickCallback (internal/process/next_tick.js:188:7) +0ms\n[Semantic release]: Run automated release from branch master\n[Semantic release]: Call plugin verify-conditions\n[Semantic release]: Verify GitHub authentication\n  semantic-release:get-last-release found tags: [ { gitTag: 'v1.2.0', version: '1.2.0' }, { gitTag: 'v1.1.1', version: '1.1.1' }, { gitTag: 'v1.1.0', version: '1.1.0' }, { gitTag: 'v1.0.0', version: '1.0.0' } ] +0ms\n[Semantic release]: Found git tag v1.2.0 associated with version 1.2.0\n  semantic-release:get-commits Use gitHead: de4271c7d9cd78f40d7799a66642797319a8db5a +0ms\n[Semantic release]: Found 0 commits since last release\n  semantic-release:get-commits Parsed commits: [] +18ms\n[Semantic release]: Call plugin analyze-commits\n[Semantic release]: Analysis of 0 commits complete: no release\n[Semantic release]: There are no relevant changes, so no new version is released.\nDone in 2.08s.\n```. this is the token scope\n\n. it does not exist, it was renamed to riqra-saas-api. in the package.json we still keep the riqra-graphql. I guess I must change it, but when I enter to riqra-graphql via github it redirects to riqra-saas-api. will try again with that change.. @pvdlg seems like it works now. thank you \ud83d\ude4c \ud83c\udf89 . ",
    "ethanneff": "missing name field within package.json.. I was referencing parserOpts from https://github.com/semantic-release/commit-analyzer#options. I'll try BREAKING CHANGE next time to see what happens.. ",
    "Drapegnik": "what I found:\n git merge-base --is-ancestor: --is-ancestor only from git@1.8\n git fetch --unshallow --tags: --unshallow only from git@1.8.4\n* git remote get-url origin: get-url only from git@2.7. @pvdlg, I tell you about this issue in https://github.com/pvdlg/env-ci/issues/11#issuecomment-359964228. ",
    "slkennedy": "Thanks @pvdlg - \nI deleted the tag (git tag -d v1.0.1 and git push origin :refs/tags/v1.0.1) and re-ran the build in Travis.  This resolved the issue of no commits being found but still did not publish b/c of an npm 404 error. current log\nI think this has something to do with our npm account changes, and isn't caused by semantic-release but wanted to share so you knew your support was helpful.\n. I added the publishConfig setting with a previous push but that still didn't work. Started reviewing the docs on npm organizations and found that our team had not been given read/write access to this repo in our new npm setup. So after adding that I am able to publish again.  \nThanks for your help @pvdlg . ",
    "dannychot": "Its reel\nEnvoy\u00e9 depuis mon t\u00e9l\u00e9phone intelligent Samsung Galaxy.\n-------- Message d'origine --------\nDe : Gregor Martynus notifications@github.com\nDate : 18-03-31 16 h 37 (GMT-05:00)\n\u00c0 : semantic-release/semantic-release semantic-release@noreply.github.com\nCc : dannychot dannychot@hotmail.com, Author author@noreply.github.com\nObjet : Re: [semantic-release/semantic-release] 3421 (#724)\nClosed #724https://github.com/semantic-release/semantic-release/issues/724.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHubhttps://github.com/semantic-release/semantic-release/issues/724#event-1550869113, or mute the threadhttps://github.com/notifications/unsubscribe-auth/Ae8VIKFelJzyzH6R_pf1LsIN2jQVVS7yks5tj-kOgaJpZM4TCmY4.\n. ",
    "swashcap": "\nCould you provide the logs of git merge-base --is-ancestor v4.4.1 HEAD?\n\nHey, sorry I must have missed this comment. Thanks for the pick and merge!. ",
    "tylerjgarland": "@pvdlg , if you search in your link posted above, there's no reference to pkgRoot. ",
    "neekey": "the CI build : https://travis-ci.org/neekey/semantic-release-test-repo/jobs/363661634. ",
    "jdalrymple": "Sorta the same problem. Are the merge commit messages not included in the commit analysis? Example: https://travis-ci.org/jdalrymple/node-gitlab/jobs/502889768. The line surrounded by ** is a merge commit message\n[02:59:13] [semantic-release] \u203a \u2139  Start step \"analyzeCommits\" of plugin \"@semantic-release/commit-analyzer\"\n[02:59:13] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: Merge pull request #284 from carlzogheib/feature/283\n**feat: Add support for DELETE /projects/:id/fork**\n[02:59:13] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The commit should not trigger a release\n[02:59:13] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: 283: Add support for DELETE /projects/:id/fork\n[02:59:13] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The commit should not trigger a release. Ah, i understand now! must include the (). I was sure I was missing something, thank you!. Just as another note from the OP. Their console shows:\n[Semantic release]: Analyzing commit: Merge pull request #3 from neekey/release\nfix(test): fix test \nfeat(text): feat test\nperf(pencil): remove graphiteWidth option\n[Semantic release]: The commit should not trigger a release\n[Semantic release]: Analyzing commit: update dummyjs2\nWhere:\nfix(test): fix test \nfeat(text): feat test\nperf(pencil): remove graphiteWidth option\nIs part of the body of the commit message. Just to clarify, the bodies of commit messages are not looked at by the commit analyzer?. ",
    "piercus": "Hello @pvdlg, \nThank you for your complete review.\nI'd like to suggest another thing :-)\nExtended plugin doc could promote a community npm keyword (like semantic-release-plugin) and just link to semantic-release-plugin on npm with this keyword. \nSo no maintenance needed in the documentation, and no responsability on semantic-release's team about non-compatible plugins.\nWhat do you think ?. @pvdlg I'm feeling confused, there is only mine remaining, i did really want to do it for the community :-(. I have contacted @felixfbecker to get his approval about adding him in the list. I've contacted the author, he can only guarantee that it is working for ^11.0.0, but he would be happy to be listed.. Ok done. ",
    "estahn": "I wanted to test if I made a mistake and created a fresh directory with the following outcome:\n\u2026/p/hipages \ue0b0 mkdir test-semantic-release                                                                                                                                                                            \u2026/p/hipages \ue0b0 cd test-semantic-release                                                                                                                                                                               \u2026/hipages/test-semantic-release \ue0b0 git init                                                                                                                                                                          Initialized empty Git repository in /Users/estahn/p/hipages/test-semantic-release/.git/\n \u2026/hipages/test-semantic-release \ue0b0  \ue0a0 master \ue0b0 semantic-release --dry-run                                                                                                                                            [Semantic release]: Running semantic-release version 15.1.5\n[Semantic release]: Load plugin verifyConditions from @semantic-release/npm\n[Semantic release]: Load plugin verifyConditions from @semantic-release/github\n[Semantic release]: Load plugin analyzeCommits from @semantic-release/commit-analyzer\n[Semantic release]: Load plugin generateNotes from @semantic-release/release-notes-generator\n[Semantic release]: Load plugin prepare from @semantic-release/npm\n[Semantic release]: Load plugin publish from @semantic-release/npm\n[Semantic release]: Load plugin publish from @semantic-release/github\n[Semantic release]: Load plugin success from @semantic-release/github\n[Semantic release]: Load plugin fail from @semantic-release/github\n[Semantic release]: This test run was triggered on the branch undefined, while semantic-release is configured to only publish from master, therefore a new version won\u2019t be published.\n \u2026/hipages/test-semantic-release \ue0b0  \ue0a0 master \ue0b0 semantic-release --version                                                                                                                                            \ue0b2 \u2714 \ue0b2 luke-admin/default \u2388 \ue0b2 3602 \ue0b2 16:47:40\n15.1.5\n \u2026/hipages/test-semantic-release \ue0b0  \ue0a0 master \ue0b0                                                                                                                                                                       \ue0b2 \u2714 \ue0b2 luke-admin/default \u2388 \ue0b2 3603 \ue0b2 16:47:53\nNext, running it on a repository:\n``\ngit clone https://github.com/hipages/php-fpm_exporter\ncd php-fpm_exporter\nsemantic-release --dry-run                                                                                                                                \ue0b2 \u2714 \ue0b2 luke-admin/default \u2388 \ue0b2 3609 \ue0b2 16:50:37\n[Semantic release]: Running semantic-release version 15.1.5\n[Semantic release]: Load plugin verifyConditions from @semantic-release/npm\n[Semantic release]: Load plugin verifyConditions from @semantic-release/github\n[Semantic release]: Load plugin analyzeCommits from @semantic-release/commit-analyzer\n[Semantic release]: Load plugin generateNotes from @semantic-release/release-notes-generator\n[Semantic release]: Load plugin prepare from @semantic-release/npm\n[Semantic release]: Load plugin publish from @semantic-release/npm\n[Semantic release]: Load plugin publish from @semantic-release/github\n[Semantic release]: Load plugin success from @semantic-release/github\n[Semantic release]: Load plugin fail from @semantic-release/github\n[Semantic release]: Run automated release from branch master\n[Semantic release]: Call plugin verify-conditions\n[Semantic release]: Verify GitHub authentication\n[Semantic release]: ENOPKG Missingpackage.json` file.\nA package.json file (https://docs.npmjs.com/files/package.json) at the root of your project is required to release on npm.\nPlease follow the npm guideline (https://docs.npmjs.com/getting-started/creating-node-modules) to create a valid package.json file.\n{ SemanticReleaseError: Missing package.json file.\n    at module.exports (/usr/local/lib/node_modules/semantic-release/node_modules/@semantic-release/npm/lib/get-error.js:6:10)\n    at module.exports (/usr/local/lib/node_modules/semantic-release/node_modules/@semantic-release/npm/lib/get-pkg.js:17:19)\n    at \n  name: 'SemanticReleaseError',\n  code: 'ENOPKG',\n  details: 'A package.json file at the root of your project is required to release on npm.\\n\\nPlease follow the npm guideline to create a valid package.json file.',\n  semanticRelease: true,\n  pluginName: '@semantic-release/npm' }\n```\n@pvdlg Do you need more information?. Works like a charm! Thanks for your help @pvdlg . ",
    "schalkneethling": "Hah, how odd. I completely overlooked that. Thanks so much for the help @pvdlg \ud83c\udf89 \u2615\ufe0f . @pvdlg - Ok so the EMISSINGREPO is resolved but, I am still getting EGITNOPERMISSION The push permission to the Git repository is required\nThe token was created by the CLI on Github and also added to Travis-CI, here is how the rights for the token is configured:\n\nAlso, my user has admin rights to the repo in question so, not sure what else needs changing to enable semantic-release to push to the repo on Github.. Here is the issue that was created by semantic-release:\nhttps://github.com/mdn/bob/issues/16. Just checked the job on Travis-CI and it is exporting the credentials so, they should be available to semantic-release:\nSetting environment variables from repository settings\n$ export GH_TOKEN=[secure]\n$ export NPM_TOKEN=[secure]. \ud83e\udd26\u200d\u2642\ufe0f Oh my word! Man, I should be more attentive. Thanks again @pvdlg \ud83c\udf70 \u2615\ufe0f . @pvdlg Yup, it looks like this is all good now. Thanks so much for your assistance.. Thanks so much for the feedback. Change the name I must ;) Well slightly, but not to slightly.. And it works! Thanks so much for the awesome tool and the exceptional support! https://www.npmjs.com/package/mdn-bob. @pvdlg Updated, thanks for the review.. Thanks for the reviews everyone. This has been updated.. Oh, looks like my editor made a formatting change i.e. changed - to * So, the copy is not actually removed.. I will revert. More specifically, I believe it might be prettier-atom that did the reformatting. . ",
    "roger199585": "In /lib/get-git-auth-url.js line 51.\nreturn gitCredentials\n      ? format({...parse(`${gitUrlParse(repositoryUrl).toString(protocol)}.git`), ...{auth: gitCredentials}})\n      : repositoryUrl;\nThe repositoryUrl we get from current version of semantic-release is like the URL below\nhttps://[secure]@conpanyname.visualstudio.com/DefaultCollection/MyRepo.git.\nHowever, I think the RepositoryUrl that VSTS expected is https://[secure]@conpanyname.visualstudio.com/DefaultCollection/_git/MyRepo\nIn my testing, if the repositoryURL have .git at the end VSTS will ask for another password to verify the repositoryURL. Though, I don't know the details of how VSTS work on it.\nIf you run the command with the repositoryURL that end with .git you will have the password request below that was from VSTS\nCorn-MacBook-Pro:MessengerBot corn$ git push --dry-run https://ve6e6dpewx4tp35txh2bcgd2gnvcs3jhfhkizywnpczo5vfiy3lq@companyname.visualstudio.com/DefaultCollection/MyRepo.git HEAD:BUILD\nPassword for 'https://ve6e6dpewx4tp35txh2bcgd2gnvcs3jhfhkizywnpczo5vfiy3lq@companyname.visualstudio.com':. This is the error log while running with .git\n```\nsemantic-release:git Error: Command failed: git push --dry-run https://name.visualstudio.com/Collection/_git/Repo HEAD:BUILD\n  semantic-release:git fatal: Authentication failed for 'https://name.visualstudio.com/Collection/_git/Repo/'\n  semantic-release:git \n  semantic-release:git \n  semantic-release:git     at makeError (/transcode/node_modules/semantic-release/node_modules/execa/index.js:172:9)\n  semantic-release:git     at Promise.all.then.arr (/transcode/node_modules/semantic-release/node_modules/execa/index.js:277:16)\n  semantic-release:git     at \n  semantic-release:git     at process._tickCallback (internal/process/next_tick.js:188:7) +0ms\nsemantic-release:git Error: Command failed: git push --dry-run https://[secure]@name.visualstudio.com/Collection/Repo.git HEAD:BUILD\n  semantic-release:git fatal: Authentication failed for 'https://[secure]@name.visualstudio.com/Collection/Repo.git/'\n  semantic-release:git \n  semantic-release:git \n  semantic-release:git     at makeError (/transcode/node_modules/semantic-release/node_modules/execa/index.js:172:9)\n  semantic-release:git     at Promise.all.then.arr (/transcode/node_modules/semantic-release/node_modules/execa/index.js:277:16)\n  semantic-release:git     at \n  semantic-release:git     at process._tickCallback (internal/process/next_tick.js:188:7) +1s\n[Semantic release]: EGITNOPERMISSION The push permission to the Git repository is required.\nsemantic-release cannot push the version tag to the branch BUILD on remote Git repository.\n```\nAnd this is the error the is running without .git\nsemantic-release:git Error: Command failed: git push --dry-run https://name.visualstudio.com/Collection/_git/Repo HEAD:BUILD\n  semantic-release:git fatal: Authentication failed for 'https://name.visualstudio.com/Collection/_git/Reop/'\n  semantic-release:git \n  semantic-release:git \n  semantic-release:git     at makeError (/transcode/node_modules/semantic-release/node_modules/execa/index.js:172:9)\n  semantic-release:git     at Promise.all.then.arr (/transcode/node_modules/semantic-release/node_modules/execa/index.js:277:16)\n  semantic-release:git     at <anonymous>\n  semantic-release:git     at process._tickCallback (internal/process/next_tick.js:188:7) +0ms\nhttps://joueapp.visualstudio.com/Joue/_git/NgxSidebar\nURL: https://[secure]@joueapp.visualstudio.com/Joue/NgxSidebar.git\n  semantic-release:git Error: Command failed: git push --dry-run https://[secure]@name.visualstudio.com/Collection/Repo HEAD:BUILD\n  semantic-release:git fatal: Authentication failed for 'https://[secure]@name.visualstudio.com/Collection/Repo/'\n  semantic-release:git \n  semantic-release:git \n  semantic-release:git     at makeError (/transcode/node_modules/semantic-release/node_modules/execa/index.js:172:9)\n  semantic-release:git     at Promise.all.then.arr (/transcode/node_modules/semantic-release/node_modules/execa/index.js:277:16)\n  semantic-release:git     at <anonymous>\n  semantic-release:git     at process._tickCallback (internal/process/next_tick.js:188:7) +1s\n[Semantic release]: EGITNOPERMISSION The push permission to the Git repository is required.\nsemantic-release cannot push the version tag to the branch BUILD on remote Git repository.\nNo matter we have .git in the URL or not. They both Authentication failed, so I think /_git/ before Repo might be necessary. But I'm not really sure if the error just happened on my machine.\nThe format that work on my machine is https://[secure]@conpanyname.visualstudio.com/DefaultCollection/_git/MyRepo.\n. I am sorry for my breach of the rules.\nI'm new in programming, just wanna to provide my opinion. Thanks for your response.. ",
    "koertvankleef": "Current behavior\nThe publish section throws an error when attempting to use semantic-release/github to push changes to a git repo in VSTS (visualstudio.com).\nAlternatively: The prepare section could push to the git repo with semantic-release/git plugin but this section does not contain the updated package.json to push.\nExpected behavior\nOne of two options, either:\n- the semantic-release/git plugin can push changes in the publish section, or\n- the semantic-release/github plugin can push changes to Git as well as Github\nI was not sure wether to see this as a bug or feature request or just support. \nEnvironment\nsemantic-release configuration:\n\"release\": {\n    \"npmPublish\": false,\n    \"githubUrl\": \"https://<host>.visualstudio.com\",\n    \"verifyConditions\": [\n        \"@semantic-release/git\"\n    ],\n    \"prepare\": [\n        {\n            \"path\": \"@semantic-release/git\",\n            \"assets\": [\n                \"package.json\"\n            ],\n            \"message\": \"chore(release): ${nextRelease.version} [skip ci]\\n\\n${nextRelease.notes}\"\n        }\n    ]\n},\nThe token is passed as parameter in the build step in VSTS. \nCI logs: \n$ semantic-release --branch master --no-ci --debug --gh-token <token>\n [Semantic release]: Running semantic-release version 15.1.7\n 2018-04-19T14:23:25.246Z semantic-release:config options values: { branch: 'master',\n   repositoryUrl: 'https://<host>.visualstudio.com/<organisation>/_git/<repo>',\n   tagFormat: 'v${version}',\n   npmPublish: false,\n   githubUrl: 'https://<host>.visualstudio.com',\n   verifyConditions: [ '@semantic-release/git' ],\n   prepare: \n    [ { path: '@semantic-release/git',\n        assets: [Array],\n        message: 'chore(release): ${nextRelease.version} [skip ci]\\n\\n${nextRelease.notes}' } ],\n   _: [],\n   ci: false,\n   debug: [secure],\n   b: 'master',\n   'gh-token': '[secure]',\n   ghToken: '[secure]',\n   '$0': 'node_modules\\\\semantic-release\\\\bin\\\\semantic-release.js',\n   noCi: [secure] }\n [Semantic release]: Load plugin verifyConditions from @semantic-release/git\n [Semantic release]: Load plugin analyzeCommits from @semantic-release/commit-analyzer\n [Semantic release]: Load plugin generateNotes from @semantic-release/release-notes-generator\n [Semantic release]: Load plugin prepare from @semantic-release/git\n [Semantic release]: Load plugin publish from @semantic-release/npm\n [Semantic release]: Load plugin publish from @semantic-release/github\n [Semantic release]: Load plugin success from @semantic-release/github\n [Semantic release]: Load plugin fail from @semantic-release/github\n [Semantic release]: Run automated release from branch master\n [Semantic release]: Call plugin verify-conditions\n 2018-04-19T14:23:26.606Z semantic-release:get-last-release found tags: [ { gitTag: 'v2.3.6', version: '2.3.6' }, { gitTag: 'v2.3.5', version: '2.3.5' }, { gitTag: 'v2.3.4', version: '2.3.4' }, { gitTag: 'v2.3.3', version: '2.3.3' }, { gitTag: 'v2.3.2', version: '2.3.2' }, { gitTag: 'v2.3.1', version: '2.3.1' }, { gitTag: 'v2.3.0', version: '2.3.0' }, { gitTag: 'v2.2.0', version: '2.2.0' }, { gitTag: 'v2.1.0', version: '2.1.0' }, { gitTag: 'v1.5.1', version: '1.5.1' } ]\n [Semantic release]: Found git tag v2.3.6 associated with version 2.3.6\n 2018-04-19T14:23:26.684Z semantic-release:get-commits Use gitHead: b32dbee1e51d6c241535c8fe8679a6cd3c670fde\n [Semantic release]: Found 8 commits since last release\n 2018-04-19T14:23:26.715Z semantic-release:get-commits Parsed commits: [ { <commit list> } ]\n [Semantic release]: Call plugin analyze-commits\n [Semantic release]: Analyzing commit: Merged PR 743: fix: publish section of semantic release\n fix: publish section of semantic release\n 2018-04-19T14:23:26.715Z semantic-release:commit-analyzer Analyzing with default rules\n [Semantic release]: The commit should not trigger a release\n [Semantic release]: Analyzing commit: fix: publish section of semantic release\n 2018-04-19T14:23:26.715Z semantic-release:commit-analyzer Analyzing with default rules\n 2018-04-19T14:23:26.715Z semantic-release:commit-analyzer The rule { type: 'fix', release: 'patch' } match commit with release type 'patch'\n [Semantic release]: The release type for the commit is patch\n [Semantic release]: Analyzing commit: Merged PR 742: Merge non-content changes\n 2018-04-19T14:23:26.731Z semantic-release:commit-analyzer Analyzing with default rules\n [Semantic release]: The commit should not trigger a release\n [Semantic release]: Analyzing commit: Merge branch 'develop' of https://<host>.visualstudio.com/<organisation>/_git/<repo> into develop\n 2018-04-19T14:23:26.731Z semantic-release:commit-analyzer Analyzing with default rules\n [Semantic release]: The commit should not trigger a release\n [Semantic release]: Analyzing commit: fix: set fixed version in manifest.json, created changelog.md\n 2018-04-19T14:23:26.731Z semantic-release:commit-analyzer Analyzing with default rules\n...\n 2018-04-19T14:23:26.731Z semantic-release:commit-analyzer The rule { type: 'feat', release: 'minor' } match commit with release type 'minor'\n [Semantic release]: The release type for the commit is minor\n [Semantic release]: Analysis of 8 commits complete: minor release\n [Semantic release]: The next release version is 2.4.0\n [Semantic release]: Call plugin verify-release\n [Semantic release]: Call plugin generateNotes\n 2018-04-19T14:23:26.762Z semantic-release:release-notes-generator version: '2.4.0'\n 2018-04-19T14:23:26.762Z semantic-release:release-notes-generator host: '<host>.visualstudio.com'\n 2018-04-19T14:23:26.762Z semantic-release:release-notes-generator owner: '<organisation>'\n 2018-04-19T14:23:26.762Z semantic-release:release-notes-generator repository: '<repo>'\n 2018-04-19T14:23:26.762Z semantic-release:release-notes-generator previousTag: 'v2.3.6'\n 2018-04-19T14:23:26.762Z semantic-release:release-notes-generator currentTag: 'v2.4.0'\n [Semantic release]: Call plugin prepare\n [Semantic release]: Creating tag v2.4.0\n [Semantic release]: Prepared Git release: v2.4.0\n [Semantic release]: Create tag v2.4.0\n [Semantic release]: Call plugin publish\n [Semantic release]: Wrote version 2.4.0 to package.json\n [Semantic release]: Wrote version 2.4.0 to package-lock.json\n [Semantic release]: Verify GitHub authentication (https://<host>.visualstudio.com)\n [Semantic release]: An error occurred while running semantic-release: { TypeError: Cannot destructure property `push` of 'undefined' or 'null'.\n     at module.exports (B:\\<agent>\\<organisation>1-Work\\94\\s\\node_modules\\@semantic-release\\github\\lib\\verify.js:80:21)\n     at <anonymous> pluginName: '@semantic-release/github' }\n { TypeError: Cannot destructure property `push` of 'undefined' or 'null'.\n     at module.exports (B:\\<agent>\\<organisation>1-Work\\94\\s\\node_modules\\@semantic-release\\github\\lib\\verify.js:80:21)\n     at <anonymous> pluginName: '@semantic-release/github' }\n error Command failed with exit code 1.\n info Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command.\nAnything else missing? \ud83d\ude04 \nOh, and as far as automated versioning is concerned, this library rocks! \ud83e\udd18. I understand that I can disable it by skipping the publish stage. However, my goal: \"The prepare stage could push to the git repo with semantic-release/git plugin but this stage does not contain the updated package.json to push.\"\nSo the point is I need to push the change in the package.json (that is updated in the publish stage) back to git.\nI cannot use the git plugin since it doesn't work for the publish stage and I cannot do it in the prepare stage because then the package.json has not yet been updated.\nThe question then remains how do I push the package.json with the updated version back to git? \nIf the answer is \"You can't; you'd have to roll your own git plugin.\" that's okay, then I know how to proceed from here.. I see. That's strange, the logs indicate that the publish step is started and then that the package.json is updated.\n[Semantic release]: Call plugin publish\n [Semantic release]: Wrote version 2.4.0 to package.json\nBut I guess I missed that in the npm plugin docs. Pardon the bother, and thanks! \ud83d\udc4d. ",
    "zlithgow": "Ok I see ! Thanks a lot !. ",
    "BenoitAverty": "I would but unfortunately I don't publish with npm. My build script is executed way before the semantic release.. The problem with all these solutions is that I need to have two configurations : One that outputs the version or sets it somewhere, and one for the actual release in gitlab (tag, etc.) which doesn't seem to be possible easily.\nFor now I think i'll parse the output of a dry-run, but this is really brittle if the output changes.. I will try to be more detailed about my workflow.\nI have a Gitlab-CI pipeline that does this jobs in order : \n1) Build my application (npm run build && docker build)\n2) Deploy a review environment in kubernetes\n3) Run e2e tests against this review environment\n4) If the tests are OK && the branch is master, release with semantic-release\nThe problem is that the customer wants to see the version number inside the application (and maybe the changelog later). Wich means I need the version number during step 1, but I don't want to release yet (the tests could still fail).\nThe two semantic-release configurations would allow me to use @semantic-release/exec\nConfig one : only exec during prepare that does npm version ${nextRelease.version}\nConfig two : the real configuration that does changelog, version bump, gitlab release, etc.\nBut the preferred method would just be to have a command that outputs the next version. I would use that during step one.\nI hope it's more clear, don't hesitate to ask for more details.. I can't use this workflow unfortunately. My project is not a NPM library and it's not released on any NPM registry. My real artifact is a docker image.\nMoreover, the entire release process can't be executed in one go because of infrastructure constraints: some steps (deploying the review app for example) must be executed in a particular context to be able to deploy to kubernetes, the deploy part must be in a single gitlab job so I can re-deploy or rollback with gitlab's features, etc.\nI understand this may not really be the use case this library is intending to solve, so if you think it's outside the scope, I would understand and you can feel free to close this issue (I'll be able to hack something and solve my problem).\nI still think it could be useful to have some way to configure the script's output to make it easier to parse when doing a dry run (Doing a dry run is the way to solve my use case as mentionned in the faq by the way).\nfor example \n$ semantic-release -d --quiet --show-version\nnext version: 0.2.0\n or something like that (my example is ugly, only to illustrate) . @jhabdas I tried other libs but semantic-release is the only one that is this high-level. I thought it would be less work to implement the compte workflow (parse commits, determine version bump, generate changelog, release) by configuring semantic-release that by redoing the same work with, for example, conventional-changelog.\nI still think it was easier, but maybe it's less elegant because it's a lot of configuration.. ",
    "andresmijares": "the feature would be extremely useful for me as well. I need the next version printed in several places and run scripts with this value.. Sure thing, I'm using the package to manage release for another project in a different language, this is going to build the proyect and publish in our artifact repository name as the version, which mean that in order to build the distribution I need to pass the version number. I've tried to create a script that takes this version number and make something like:\njavascript\n\"release\": {\n   \"prepare\": [{\n       \"path\": \"@semantic-release/exec\",\n       \"cmd\": \"./build.sh --release -v ${version}\"\n   }]\n}\nwhich I thought it would work but I havent had any luck with it.. my bad, I just figured I had 1 issue not related to the package, it worked like charm, I decided to use ${version} since it is the one marked for tag-format sample.\nThank you for the comment! . ",
    "deyceg": "@BenoitAverty I do something like you, and end up just using a bit of sed/awk magic to cat the next version (if there is one) to a VERSION file.\nWe have an npm library, that is consumed by some app, which is deployed to a review environment if on a feature branch. This allows us to publish the npm package under package_name@next when developing against a feature. ",
    "brad-jones": "Similar to @BenoitAverty I also work with a similar gitlab workflow, where by a release is first deployed to an environment for automated & manual testing before it proceeds on to get promoted to a production release and deployed.\nRight now the solution is 100% custom, in this pipeline there is a job called calc-next-version which runs well before a potential release is made.\nI have been using semantic release for some of my other side projects. It works well in the open source space, where generally you are not deploying anything but just releasing a new version to the public.\nTo be useful in a commercial / internal environment this feature would be helpful.. ",
    "thekiwi": "I'm having a similar challenge with semantic release, where the output is also a docker image. @pvdlg you mentioned in another thread that semantic release was very much a 'release' tool not a 'build' tool but in our case, we need the version number at build time to package into our docker file, so that the application is able to report version information with exceptions to Sentry at runtime. \nHere's the config we're currently looking at:\nJavaScript\n{\n  branch: 'master',\n  plugins: [\n    '@semantic-release/commit-analyzer',\n    '@semantic-release/release-notes-generator',\n    ['@semantic-release/npm', { npmPublish: false }], // set package.json version\n    ['@semantic-release/exec', {\n      verifyConditionsCmd: 'docker login -u $DOCKER_USER -p $DOCKER_PASS',\n      prepareCmd: 'docker build -t myorg/$CIRCLE_PROJECT_REPONAME:${nextRelease.version} .',\n      publishCmd: 'docker push myorg/$CIRCLE_PROJECT_REPONAME'\n    }],\n    '@semantic-release/github'\n  ]\n}\nAs you can see, we need to do the 'determine which version' step to update our package, then run our docker build (which is multi-stage and includes things such as unit tests) and then the output of the docker build is published before finally publishing release notes to GitHub. The docker build may also fail some tests, which will currently appear as 'release failed'\nBeing able to run semantic-release just to determine the next version (or run it in a two-step mode) would allow us to decouple our build pipeline from the semantic-release config/process. \nHaving said that, if there is a better/recommended way to handle this use case, I'm all ears :) . ",
    "BartvdWaerden": "Hi thank you for your fast reply, really appreciate it!\nCurrently I'm committing/merging to my source branch using Commitizen using the cz-conventional-changelog method. When I merge a feature into the source branch Travis runs a build and commits and pushes compiled/optimized code to the master branch.  These commits by Travis are not following the cz-conventional-changelog, so no release gets triggered. \nWhat I would like is Semantic release to release every-time a merge into my source branch. And create a release (Zip) based on the files in my source branch.\nMaybe I'm using it totally wrong, and I should change my workflow. Please feel free to close this issue if you think this is the case.. Thank you very much for your help guys! I've solved my problem using:\n\"release\": {\n    \"branch\": \"source\"\n  } in my package.json\nLearned a bunch and I will adjust my workflow in the near future!. ",
    "DJTB": "Completely public.. Travis after_success hook:\n```\n$ git push --dry-run https://${GH_TOKEN}@github.com/DJTB/hatsuon HEAD:master\nEverything up-to-date \n$ git push --dry-run https://${GH_TOKEN}@github.com/DJTB/hatsuon.git HEAD:master\nEverything up-to-date\n```\nI've amended the package.json repository url to end with .git and everything worked as expected though in the deploy hook. Thanks for the help :+1: \n. ",
    "acgritt": "I was running into this same error as well the last few days and it turns out that mine is related to this issue that has been fixed in envCi where the branch name was not being parsed correctly and could have a trailing \")\".  It works fine locally but on the build server it was having issues because the branch name had the \")\".. @botcheddevil I wasn't sure, I just thought I would mention it as I was having issues with the same error message until it was fixed yesterday with the update to envCi.. ",
    "botcheddevil": "@acgritt I don't think these two are related. I deep dived into both sem-rel and git-url-parse code and couldnt find a logic to handle this pattern.. Hi @pvdlg ,\nThank you for your response. \n\nAre you sure the problem is with unshallow() ?\n\nYes! check my pull-request it solves my problem. \n763 (all unit tests pass except unshallow one as its expecting a parameter now)\n\nWhat CI are you using?\n\nI am using Jenkins with pipeline scripts's module checkout scm. Based on your response I presume you expect Jenkins to store credentials in 'origin' of .git/config??\n\nWhat do you get if you run git fetch --unshallow -- --tags on your CI?\n\nOn the bash I get prompted for the username & password.. #766 PR seems to be passing all tests now.\n\nI know there is other people using Jenkins and they don't experience this issue.\n\nCould you refer me to someone who uses Jenkins with s-r, not sure what am I missing? Most people like using ssh where such use cases will automatically pass.\nOn an unrelated note, why do we need to unshallow? Could we use \ngit ls-remote --tags /url/to/upstream/repo\nunshallow completely defeats the purpose of having a shallow repo, now that I think of it, if I configured Jenkins for a full depth clone I wouldn't have got into this mess in the first place.\n. OAuth 2.0 tokens are base64 encoded, so there will never be a case they contain a colon ( : ).\nBut explicit is always better, so having BB_TOKEN makes sense but then again a URL having a token with a colon wouldn't be parseable like below ...\n<protocol>://x-token-auth:xxxx:yyyyy@<server>:<port>/path/to/repo.git\n. Thanks! Will wait for that PR to be released so that I can update the dependency in my project and remove the currently used hacked version.\nAlso \ud83d\udc4dfor BB support!. done. ",
    "marceloavf": "I was getting this error in VSTS so I changed to ssh authentication and it stops.\nOld url:\njson\n\"url\": \"https://xxxxxx.visualstudio.com/xxxxx/_git/xxxx\"\nNew one:\njson\n\"url\": \"ssh://xxxx@vs-ssh.visualstudio.com:22/_ssh/xxxxx\". ",
    "texel-sensei": "Thank you, that fixed it. Maybe add that to the docs somewhere, for me it was not clear that only two plugins are shipped per default.\nEspecially the documentation for non javascript projects makes it look like you just have to do a npm install -g semantic-release.. ",
    "mattrenaud": "I was on 2.0.1. I cleared my package-lock.json and node_modules and did a npm i and everything worked. Now on 2.1.0. Thanks!. ",
    "evenstensberg": "gotcha, updated now. There we go \ud83d\udc4d . ",
    "kai670": "Same result:\ngit rev-parse \"master@{push}\"\nfatal: no upstream configured for branch 'master'\nThis is the content of the .git/config in Jenkins:\n[core]\n        repositoryformatversion = 0\n        filemode = true\n        bare = false\n        logallrefupdates = true\n[remote \"origin\"]\n        url = https://bitbucket.org/quobisdevteam/webphone-angular.git\n        fetch = +refs/heads/master:refs/remotes/origin/master\nAnd the only way I see it works is when I add:\n[branch \"master\"]\n        remote = origin\n        merge = refs/heads/master\ngit version is 2.11.0 but I tested now in my local machine (git 2.17.0) that command with a branch without upstream and I get the same error.... I confirm it is working using semantic-release@15.1.9 and stops working with that change.\nChecking semantic-release code, the push is done in lib/git.js:124:\nawait execa('git', ['push', '--tags', repositoryUrl, `HEAD:${branch}`]);\nSo afaik it works without the remote because it is specified in the command itself.\n```\ngit fetch --unshallow --tags\nfatal: --unshallow on a complete repository does not make sense\ngit rev-parse \"master@{push}\"\nfatal: no upstream configured for branch 'master'\n```\n$ git ls-remote --heads <repositoryUrl> <branch>\n9316be6efbc96ca3a48ed6cfaca351e8b7b26139    refs/heads/master. git rev-parse origin/master works. It returns the latest commit in the master branch of origin.. ",
    "ricardograca": "Great, thanks for the explanation, but it would be better if that was also in the Readme file. Even a simple\n\nOnly these message types will trigger a release.\n\nwould help, since it says right there in the table that it's an \"example\", so there could be other message types that trigger releases for all I know.. How about:\n\nNote that only some message types will trigger a release. These message triggers depend on the configuration of the commit convention used with preset and the release rules configured with releaseRules, but by using the default config the table above lists all message types that would trigger a release and what kind of release it would be.\n\nThis is the best I can do without being too familiar with the project.. Typo: \"...that that affect...\". ",
    "lifeiscontent": "@pvdlg okay, thank you for the quick feedback!. @pvdlg now I'm getting an auth issue, does semantic-release-cli setup not setup authentication automatically?. using github and travis pro.. @pvdlg my repo is set as the following:\n\"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/AirPageInc/icons.git\"\n  },\nand this is the relevant information on where it fails.\n[Semantic release]: Load plugin fail from @semantic-release/github\n(node:5194) ExperimentalWarning: The fs.promises API is experimental\n[Semantic release]: The command \"git push --dry-run https://[secure]@/ttps:git@github.com:AirPageInc/icons.git HEAD:master\" failed with the error message fatal: unable to access 'https://[secure]@/ttps:git@github.com:AirPageInc/icons.git/': Could not resolve host: \n.\n[Semantic release]: Verify GitHub authentication\n[Semantic release]: EMISSINGREPO The repository git@github.com:AirPageInc/icons doesn't exist.\nThe semantic-release repositoryUrl option must refer to your GitHub repository. The repository must be accessible with the GitHub API (https://developer.github.com/v3).\nBy default the repositoryUrl option is retrieved from the repository property of your package.json or the git origin url (https://git-scm.com/book/en/v2/Git-Basics-Working-with-Remotes) of the repository cloned by your CI environment.. @pvdlg figured it out. turns out vscode was keeping around a stale package.json. Sorry for the confusion.. ",
    "UziTech": "looks good \ud83d\udc4d Thanks for the quick response.. ",
    "unlight": "It happens while runnig semantic-release.\n\nHave you tried to delete your node_modules folder and your lockfile and re-install?\n\nI do not have lockfile.\nI cannot remove node_modules on CI side (codeship) (reset cache did not help). \nI can try to do it locally, but it makes no much sense. I need working it on CI.. https://github.com/peerigon/parse-domain/issues/35. ",
    "jhnns": "This was introduced by change made in our module parse-domain (which is apparently a transitive dependency of semantic-release). You can probably close it here as it is not related to semantic-release itself.. ",
    "nkristoffersen": "I wanted to try semantic-release but now find I cannot run it in CI due to this issue with parse-domain. Ironic since this is the exact situation semantic versioning is trying to solve :-). ",
    "IonicaBizau": "Sorry for the delay\u2014I merged the @pvdlg's pull request. :). ",
    "sirlantis": "I hope my use-case of disabling changelog generation is not esoteric.\nShould I test for == null instead?. ",
    "greysteil": "\ud83d\udc4d - if you're not keen on badges then that makes perfect sense.\nOn the confusion on the page, I'd love to get to the bottom of that and change it to be clearer. Was it this line that was confusing?\n\nDependabot has performed 245 updates of semantic-release between SemVer compatible versions, and 100% of those updates passed CI.\n\nBy SemVer compatible versions I'm trying to refer to changes like 2.1.0 -> 2.2.0, rather than incompatible version updates like 2.2.0 -> 3.0.0. Was it that text that confused you or something else?. Ah, OK - so it's measuring the percentage of users' test runs that pass when upgrading between versions that, according to SemVer, shouldn't break anything. So that would include 2.1.0 -> 2.2.0 but not necessarily 2.2.0 -> 3.0.0 (because a major version can include breaking changes, and hence may (allowably) break users' tests unless they take some action). Does that make sense now? I'll try to make it clearer on the page.. There's certainly a problem with flaky tests, but from my experience it's not that big a one. I'm filtering out all of the projects whose tests were initially failing, and in future it would be relatively straightforward for me to filter out flaky tests, too (since Dependabot does updates across lots of dependencies for a given user we can identify whether their tests are flaky).\nEven without that optimisation we see really high scores for most packages that use SemVer well - they're not 100% but I think that's fine. Check out:\n- jest\n- eslint\nFor others, where a breaking change or bug was accidentally introduced in a minor version, the scores are lower:\n- prettier (click \"see more\" to see the score for 1.12.1 -> 1.13.0)\nAnyway, thanks for your feedback!. ",
    "Wikiki": "If I add the prepare rule into my package.json do I have to precise the npm plugin too or it still be taken into account 'cause it's the default one ?. Other question: in the doc I see semantic-release/commit-analyzer\n is the default commit analyzer used. So Do I have to redefine it if I just want to change the prepare step ? If yes where can I find the default options it's called with ?. Clear now.\nBut where can I find the default options passed to the default plugins if I have to redefine them ?. Perfect. Thank you. ",
    "Nysosis": "According to https://github.com/semantic-release/semantic-release/issues/827#issue-333826530 I should be able to set success: false, and have it ignore the settings. I'm not able to verify that currently as not on my development machine.\nIf this is the case then this issue can probably be closed down - especially considering #827 is regarding removal of the defaults in general.\nHowever I can't see in the documentation where this behaviour is explicitly specified, so it might be worth adding it into the docs?\n. ",
    "halfzebra": "@gr2m Node 8 was introduced only in v12.2.0\nAt the same time, @semantic-release/commit-analyzer got an engine version bump in a minor version(5.0.1->5.0.2), which did break the build for me.\nI'm not sure if anything could be done about my issue with semantic-release, I wanted to raise awareness that engine version bumps are introducing breaking changes.\nI think that engine upgrade should be reflected as a new major version. I hope that makes sense \ud83e\udd14 \nPS: I guess this issue can be closed in case if this does not require further discussion.\n. Thanks for the feedback! :+1: \nI do understand that it would be too much of a pain to include backward compatibility for addressing my issue.\nI've thought it would be healthy to share, so so this issue could be avoided in the future.\n. ",
    "jormot": "I have a pem generated with my work laptop, which I use for a specific Github account (different from my personal one).\nI can't use the works laptop at home, so when I have to take work to home, I use my personal computer, which already has a pem, which is also associated with a different Github account and other accounts as well.\nCopying pasting my personal pem to works laptop wouldn't be very wise, so what I can do is to copy the work pem to my personal computer and add a different host in the .ssh config.\nRight not the host that it's changed (githubcustom) is the one I'm trying to use with semantic-release. I do use a token (with GH_TOKEN), but when trying to connect to the server, semantic-release uses the repositoryUrl provided, instead of the one defined at .git/config.\nIt would be great if you could give more priority to the remote at .git/config for connecting, and use the one defined at package.json for appearance (writing CHANGELOG.md).. How do you suggest I use a CI in my setup? Can you quickly describe a high overview of the process?. I have created a PR at https://github.com/semantic-release/release-notes-generator/pull/89 that will fix my issue, by adding a custom repositoryUrl option for this plugin.. Didn't catch the issues, searched for first version but nothing appeared. Thanks for the links.. ",
    "adrianschmidt": "~~The CI log above doesn't match the description of expected behaviour perfectly, since the only new commit since v1.1.0 is actually a chore. But I'm adding a dummy feat commit now, and will be updating with the new output.~~\nFixed. $ git tag --merged master\nv1.0.0\nv1.1.0\nI had set the debug flag in package.json, but perhaps that didn't work. I'll add it as a command line flag instead.\nCould the issue be caused by doing rebase-commits in GitHub? I can't see how, since it doesn't change what's on the master branch, but I thought I'd ask\u2026. That doesn't seem to output anything\u2026\n```\n\u256d16:40:28 ~/src/lime-elements [master]\n\u2570$ git tag\nv1.0.0\nv1.1.0\n\u256d16:40:30 ~/src/lime-elements [master]\n\u2570$ git merge-base --is-ancestor v1.1.0 HEAD\n\u256d16:40:34 ~/src/lime-elements [master]\n\u2570$ echo $?\n0\n\u256d16:40:37 ~/src/lime-elements [master]\n\u2570$ git merge-base --is-ancestor v1.0.0 HEAD\n\u256d16:40:44 ~/src/lime-elements [master]\n\u2570$ echo $?\n0\n```\nI'll get you the debug-log soon. I just need to double-check that there are no access tokens or any other accidents in it :). Debug log:\n```\n[lime_lime-elements_master-BNNHCDJPBPTMZM3URF6ONQSA4FS6PQOTS4D4CWAKBMXFMHC7YKNA] Running shell script\n+ make release\ndocker run --rm -e CI -e GH_TOKEN -e NPM_TOKEN -w /lime lime-elements npx semantic-release --debug\n[Semantic release]: Running semantic-release version 15.6.1\n2018-06-27T14:40:03.793Z semantic-release:config options values: { branch: 'master',\n  repositoryUrl: 'https://github.com/Lundalogik/lime-elements.git',\n  tagFormat: 'v${version}',\n  _: [],\n  debug: true,\n  '$0': 'node_modules/.bin/semantic-release' }\n[Semantic release]: Load plugin \"verifyConditions\" from @semantic-release/npm\n[Semantic release]: Load plugin \"verifyConditions\" from @semantic-release/github\n[Semantic release]: Load plugin \"analyzeCommits\" from @semantic-release/commit-analyzer\n[Semantic release]: Load plugin \"generateNotes\" from @semantic-release/release-notes-generator\n[Semantic release]: Load plugin \"prepare\" from @semantic-release/npm\n[Semantic release]: Load plugin \"publish\" from @semantic-release/npm\n[Semantic release]: Load plugin \"publish\" from @semantic-release/github\n[Semantic release]: Load plugin \"success\" from @semantic-release/github\n[Semantic release]: Load plugin \"fail\" from @semantic-release/github\n2018-06-27T14:40:07.597Z semantic-release:git Error: Command failed: git push --dry-run https://github.com/Lundalogik/lime-elements.git HEAD:master\nremote: Invalid username or password.\nfatal: Authentication failed for 'https://github.com/Lundalogik/lime-elements.git/'\nat makeError (/lime/node_modules/semantic-release/node_modules/execa/index.js:172:9)\nat Promise.all.then.arr (/lime/node_modules/semantic-release/node_modules/execa/index.js:277:16)\nat <anonymous>\nat process._tickCallback (internal/process/next_tick.js:188:7)\n\n[Semantic release]: Run automated release from branch master\n[Semantic release]: Call plugin verify-conditions\n[Semantic release]: Verify authentication for registry http://npm.lundalogik.com:4873/\n[Semantic release]: Wrote NPM_TOKEN to .npmrc.\n[Semantic release]: Verify GitHub authentication\n2018-06-27T14:40:12.631Z semantic-release:get-last-release found tags: [ { gitTag: 'v1.0.0', version: '1.0.0' } ]\n[Semantic release]: Found git tag v1.0.0 associated with version 1.0.0\n2018-06-27T14:40:12.638Z semantic-release:get-commits Use gitHead: 83e6fb490b33ffc689c4aedf08c3bc5833308b53\n[Semantic release]: Found 16 commits since last release\n2018-06-27T14:40:12.648Z semantic-release:get-commits Parsed commits: [ { commit: { long: '250116b09b954dcc664f891d26628a072ee6ff75', short: '250116b' }, tree: { long: 'ae570f5b3cc834f88dbda665ee6affc4a9db1774', short: 'ae570f5' }, author: { name: 'Adrian Schmidt', email: 'adrian.schmidt@lime.tech', date: 2018-06-27T14:34:10.000Z }, committer: { name: 'Adrian Schmidt', email: 'github.com@stealmycode.se', date: 2018-06-27T14:34:33.000Z }, subject: 'feat(CI): dummy minor bump plus debug flag', body: '', hash: '250116b09b954dcc664f891d26628a072ee6ff75', message: 'feat(CI): dummy minor bump plus debug flag', gitTags: '(HEAD, origin/master, master)', committerDate: 2018-06-27T14:34:33.000Z }, { commit: { long: '65d1b9bb20e30b39662cbe906f4b3065a2195ca3', short: '65d1b9b' }, tree: { long: 'afbebaea23a088048066773575bff3651deddb00', short: 'afbebae' }, author: { name: 'Adrian Schmidt', email: 'adrian.schmidt@lime.tech', date: 2018-06-27T14:03:17.000Z }, committer: { name: 'Adrian Schmidt', email: 'github.com@stealmycode.se', date: 2018-06-27T14:05:11.000Z }, subject: 'feat(CI): dummy minor bump', body: '', hash: '65d1b9bb20e30b39662cbe906f4b3065a2195ca3', message: 'feat(CI): dummy minor bump', gitTags: '', committerDate: 2018-06-27T14:05:11.000Z }, { commit: { long: '18aeb705c14ab3a615762a1562054ef5f10861ca', short: '18aeb70' }, tree: { long: '74e56035725c3ca67c1fa1ac0fdea67f0fed6239', short: '74e5603' }, author: { name: 'Adrian Schmidt', email: 'adrian.schmidt@lime.tech', date: 2018-06-27T13:38:39.000Z }, committer: { name: 'Adrian Schmidt', email: 'github.com@stealmycode.se', date: 2018-06-27T13:48:55.000Z }, subject: 'chore(CI): try to get semantic-release to work correctly', body: '', hash: '18aeb705c14ab3a615762a1562054ef5f10861ca', message: 'chore(CI): try to get semantic-release to work correctly', gitTags: '', committerDate: 2018-06-27T13:48:55.000Z }, { commit: { long: 'bf3f32d2130592822147c710446e3c2a7463fc16', short: 'bf3f32d' }, tree: { long: 'e7657868c5a72ecb12c13bce061181b245375552', short: 'e765786' }, author: { name: 'Adrian Schmidt', email: 'adrian.schmidt@lime.tech', date: 2018-06-27T12:59:05.000Z }, committer: { name: 'Adrian Schmidt', email: 'github.com@stealmycode.se', date: 2018-06-27T13:01:08.000Z }, subject: 'chore(CI): update access token used', body: '', hash: 'bf3f32d2130592822147c710446e3c2a7463fc16', message: 'chore(CI): update access token used', gitTags: '', committerDate: 2018-06-27T13:01:08.000Z }, { commit: { long: '8477222d2a766df39ea9bd27a8d6657608860f01', short: '8477222' }, tree: { long: '15f1c0456b27cc5862d023d7d1e2d039633be4e6', short: '15f1c04' }, author: { name: 'Adrian Schmidt', email: 'adrian.schmidt@lime.tech', date: 2018-06-27T12:12:05.000Z }, committer: { name: 'Adrian Schmidt', email: 'github.com@stealmycode.se', date: 2018-06-27T12:29:58.000Z }, subject: 'chore(CI): update Dockerfile', body: '', hash: '8477222d2a766df39ea9bd27a8d6657608860f01', message: 'chore(CI): update Dockerfile', gitTags: '', committerDate: 2018-06-27T12:29:58.000Z }, { commit: { long: '5715ee90457e24bc56fba6898a04773a8bde3d4d', short: '5715ee9' }, tree: { long: '75cc015cc30ec4f9927436df31a7ec17314a8f62', short: '75cc015' }, author: { name: 'Adrian Schmidt', email: 'adrian.schmidt@lime.tech', date: 2018-06-27T12:11:11.000Z }, committer: { name: 'Adrian Schmidt', email: 'github.com@stealmycode.se', date: 2018-06-27T12:29:58.000Z }, subject: 'chore(CI): update semantic-release', body: '', hash: '5715ee90457e24bc56fba6898a04773a8bde3d4d', message: 'chore(CI): update semantic-release', gitTags: '', committerDate: 2018-06-27T12:29:58.000Z }, { commit: { long: 'b27ccb8b4c2b928c35682d5b4fb59028e939b4dd', short: 'b27ccb8' }, tree: { long: '35d3f73f1692ff1065ad6facb41c3ce938f68982', short: '35d3f73' }, author: { name: 'Adrian Schmidt', email: 'adrian.schmidt@lime.tech', date: 2018-06-27T11:15:03.000Z }, committer: { name: 'Adrian Schmidt', email: 'github.com@stealmycode.se', date: 2018-06-27T11:16:06.000Z }, subject: 'docs(README): Fix bad link formatting', body: '', hash: 'b27ccb8b4c2b928c35682d5b4fb59028e939b4dd', message: 'docs(README): Fix bad link formatting', gitTags: '', committerDate: 2018-06-27T11:16:06.000Z }, { commit: { long: '7aced71ead5876fa8734402ebd18b11aa4e03e6b', short: '7aced71' }, tree: { long: 'b00484fefefe86f03e3afbe874e11c24771307e3', short: 'b00484f' }, author: { name: 'Adrian Schmidt', email: 'adrian.schmidt@lime.tech', date: 2018-06-27T09:28:32.000Z }, committer: { name: 'Adrian Schmidt', email: 'github.com@stealmycode.se', date: 2018-06-27T09:31:59.000Z }, subject: 'feat(README): Improve readme', body: 'Also use the feat type to bump the minor version, to fix an\\nissue with semantic-release, probably caused by force-pushing to\\nmaster.\\n', hash: '7aced71ead5876fa8734402ebd18b11aa4e03e6b', message: 'feat(README): Improve readme\\n\\nAlso use the feat type to bump the minor version, to fix an\\nissue with semantic-release, probably caused by force-pushing to\\nmaster.', gitTags: '', committerDate: 2018-06-27T09:31:59.000Z }, { commit: { long: '3d278a8b2575b4f0f3262ce5766663689b47077e', short: '3d278a8' }, tree: { long: '19819eb98e0a9c2385499d2a844aeb57fefc2b17', short: '19819eb' }, author: { name: 'Adrian Schmidt', email: 'adrian.schmidt@lime.tech', date: 2018-06-27T09:14:50.000Z }, committer: { name: 'Adrian Schmidt', email: 'github.com@stealmycode.se', date: 2018-06-27T09:16:10.000Z }, subject: 'docs(README): Add commit message guidelines', body: '', hash: '3d278a8b2575b4f0f3262ce5766663689b47077e', message: 'docs(README): Add commit message guidelines', gitTags: '', committerDate: 2018-06-27T09:16:10.000Z }, { commit: { long: 'bc4e8dea97a84618181629d51f7b25ae244037a1', short: 'bc4e8de' }, tree: { long: 'ae21ae901233717086e62cd12630538b7526e86b', short: 'ae21ae9' }, author: { name: 'Adrian Schmidt', email: 'adrian.schmidt@lime.tech', date: 2018-06-27T09:12:59.000Z }, committer: { name: 'Adrian Schmidt', email: 'github.com@stealmycode.se', date: 2018-06-27T09:16:10.000Z }, subject: 'chore: Uppercase readme file', body: '', hash: 'bc4e8dea97a84618181629d51f7b25ae244037a1', message: 'chore: Uppercase readme file', gitTags: '', committerDate: 2018-06-27T09:16:10.000Z }, { commit: { long: 'd8185b1a6a59f0da2427bed248b527defea8fbce', short: 'd8185b1' }, tree: { long: 'f1dddcbc6287bfb02be52064014ac929f2680698', short: 'f1dddcb' }, author: { name: 'Adrian Schmidt', email: 'adrian.schmidt@lime.tech', date: 2018-06-27T08:48:17.000Z }, committer: { name: 'Adrian Schmidt', email: 'github.com@stealmycode.se', date: 2018-06-27T08:49:29.000Z }, subject: 'fix(CI): Debug flag removed', body: '', hash: 'd8185b1a6a59f0da2427bed248b527defea8fbce', message: 'fix(CI): Debug flag removed', gitTags: '', committerDate: 2018-06-27T08:49:29.000Z }, { commit: { long: '832bace2b1f9017b363ccb6385b2d7d61b616e4d', short: '832bace' }, tree: { long: '86f98108a748448bed44d86e8a4979144848bfa5', short: '86f9810' }, author: { name: 'Adrian Schmidt', email: 'adrian.schmidt@lime.tech', date: 2018-06-27T08:27:24.000Z }, committer: { name: 'Adrian Schmidt', email: 'adrian.schmidt@lime.tech', date: 2018-06-27T08:27:24.000Z }, subject: 'CHANGELOG.md no longer needed', body: 'Changelog is now found on each release in Github.\\n', hash: '832bace2b1f9017b363ccb6385b2d7d61b616e4d', message: 'CHANGELOG.md no longer needed\\n\\nChangelog is now found on each release in Github.', gitTags: '', committerDate: 2018-06-27T08:27:24.000Z }, { commit: { long: '318202ac318ab113a2fc833522addcf039e3e22c', short: '318202a' }, tree: { long: '58ab6856c2cc007859e4cd41e0e987bd1834a31a', short: '58ab685' }, author: { name: 'Adrian Schmidt', email: 'adrian.schmidt@lime.tech', date: 2018-06-27T08:24:38.000Z }, committer: { name: 'Adrian Schmidt', email: 'adrian.schmidt@lime.tech', date: 2018-06-27T08:24:38.000Z }, subject: 'The docker build no longer runs the npm build', body: '', hash: '318202ac318ab113a2fc833522addcf039e3e22c', message: 'The docker build no longer runs the npm build', gitTags: '', committerDate: 2018-06-27T08:24:38.000Z }, { commit: { long: '9343c360d160b4b457e7c1074206a1d84a51a161', short: '9343c36' }, tree: { long: '37227e18decabe4eb5f85c1e97e4ccae677c52eb', short: '37227e1' }, author: { name: 'Adrian Schmidt', email: 'adrian.schmidt@lime.tech', date: 2018-06-27T08:03:36.000Z }, committer: { name: 'Adrian Schmidt', email: 'adrian.schmidt@lime.tech', date: 2018-06-27T08:18:29.000Z }, subject: 'fix(semantic-release): Pass env-vars to container', body: '', hash: '9343c360d160b4b457e7c1074206a1d84a51a161', message: 'fix(semantic-release): Pass env-vars to container', gitTags: '', committerDate: 2018-06-27T08:18:29.000Z }, { commit: { long: '4faf38a139ad82042d659a4c5be52ec547599558', short: '4faf38a' }, tree: { long: '7dfac8bcaf5174335f80289a3d1d6c67f559b97e', short: '7dfac8b' }, author: { name: 'Adrian Schmidt', email: 'adrian.schmidt@lime.tech', date: 2018-06-27T07:44:04.000Z }, committer: { name: 'Adrian Schmidt', email: 'adrian.schmidt@lime.tech', date: 2018-06-27T07:44:04.000Z }, subject: 'fix(semantic-release): Fixes bug in Makefile', body: '', hash: '4faf38a139ad82042d659a4c5be52ec547599558', message: 'fix(semantic-release): Fixes bug in Makefile', gitTags: '', committerDate: 2018-06-27T07:44:04.000Z }, { commit: { long: 'feaca628147a40bde2bade552d3dee01467b678e', short: 'feaca62' }, tree: { long: 'a192174daaa8e1fa51b67fc13cc778314af6df4e', short: 'a192174' }, author: { name: 'Adrian Schmidt', email: 'adrian.schmidt@lime.tech', date: 2018-06-27T07:36:56.000Z }, committer: { name: 'Adrian Schmidt', email: 'adrian.schmidt@lime.tech', date: 2018-06-27T07:41:17.000Z }, subject: 'fix(semantic-release): Fixes for npm publish', body: 'Run npm publish in the correct environment when releasing.\\n', hash: 'feaca628147a40bde2bade552d3dee01467b678e', message: 'fix(semantic-release): Fixes for npm publish\\n\\nRun npm publish in the correct environment when releasing.', gitTags: '', committerDate: 2018-06-27T07:41:17.000Z } ]\n[Semantic release]: Call plugin analyze-commits\n[Semantic release]: Analyzing commit: feat(CI): dummy minor bump plus debug flag\n2018-06-27T14:40:12.653Z semantic-release:commit-analyzer Analyzing with default rules\n2018-06-27T14:40:12.654Z semantic-release:commit-analyzer The rule { type: 'feat', release: 'minor' } match commit with release type 'minor'\n[Semantic release]: The release type for the commit is minor\n[Semantic release]: Analyzing commit: feat(CI): dummy minor bump\n2018-06-27T14:40:12.654Z semantic-release:commit-analyzer Analyzing with default rules\n2018-06-27T14:40:12.656Z semantic-release:commit-analyzer The rule { type: 'feat', release: 'minor' } match commit with release type 'minor'\n[Semantic release]: The release type for the commit is minor\n[Semantic release]: Analyzing commit: chore(CI): try to get semantic-release to work correctly\n2018-06-27T14:40:12.657Z semantic-release:commit-analyzer Analyzing with default rules\n[Semantic release]: The commit should not trigger a release\n[Semantic release]: Analyzing commit: chore(CI): update access token used\n2018-06-27T14:40:12.657Z semantic-release:commit-analyzer Analyzing with default rules\n[Semantic release]: The commit should not trigger a release\n[Semantic release]: Analyzing commit: chore(CI): update Dockerfile\n2018-06-27T14:40:12.657Z semantic-release:commit-analyzer Analyzing with default rules\n[Semantic release]: The commit should not trigger a release\n[Semantic release]: Analyzing commit: chore(CI): update semantic-release\n2018-06-27T14:40:12.658Z semantic-release:commit-analyzer Analyzing with default rules\n[Semantic release]: The commit should not trigger a release\n[Semantic release]: Analyzing commit: docs(README): Fix bad link formatting\n2018-06-27T14:40:12.658Z semantic-release:commit-analyzer Analyzing with default rules\n[Semantic release]: The commit should not trigger a release\n[Semantic release]: Analyzing commit: feat(README): Improve readme\nAlso use the feat type to bump the minor version, to fix an\nissue with semantic-release, probably caused by force-pushing to\nmaster.\n2018-06-27T14:40:12.659Z semantic-release:commit-analyzer Analyzing with default rules\n2018-06-27T14:40:12.659Z semantic-release:commit-analyzer The rule { type: 'feat', release: 'minor' } match commit with release type 'minor'\n[Semantic release]: The release type for the commit is minor\n[Semantic release]: Analyzing commit: docs(README): Add commit message guidelines\n2018-06-27T14:40:12.660Z semantic-release:commit-analyzer Analyzing with default rules\n[Semantic release]: The commit should not trigger a release\n[Semantic release]: Analyzing commit: chore: Uppercase readme file\n2018-06-27T14:40:12.660Z semantic-release:commit-analyzer Analyzing with default rules\n[Semantic release]: The commit should not trigger a release\n[Semantic release]: Analyzing commit: fix(CI): Debug flag removed\n2018-06-27T14:40:12.661Z semantic-release:commit-analyzer Analyzing with default rules\n2018-06-27T14:40:12.661Z semantic-release:commit-analyzer The rule { type: 'fix', release: 'patch' } match commit with release type 'patch'\n[Semantic release]: The release type for the commit is patch\n[Semantic release]: Analyzing commit: CHANGELOG.md no longer needed\nChangelog is now found on each release in Github.\n2018-06-27T14:40:12.661Z semantic-release:commit-analyzer Analyzing with default rules\n[Semantic release]: The commit should not trigger a release\n[Semantic release]: Analyzing commit: The docker build no longer runs the npm build\n2018-06-27T14:40:12.662Z semantic-release:commit-analyzer Analyzing with default rules\n[Semantic release]: The commit should not trigger a release\n[Semantic release]: Analyzing commit: fix(semantic-release): Pass env-vars to container\n2018-06-27T14:40:12.662Z semantic-release:commit-analyzer Analyzing with default rules\n2018-06-27T14:40:12.662Z semantic-release:commit-analyzer The rule { type: 'fix', release: 'patch' } match commit with release type 'patch'\n[Semantic release]: The release type for the commit is patch\n[Semantic release]: Analyzing commit: fix(semantic-release): Fixes bug in Makefile\n2018-06-27T14:40:12.662Z semantic-release:commit-analyzer Analyzing with default rules\n2018-06-27T14:40:12.663Z semantic-release:commit-analyzer The rule { type: 'fix', release: 'patch' } match commit with release type 'patch'\n[Semantic release]: The release type for the commit is patch\n[Semantic release]: Analyzing commit: fix(semantic-release): Fixes for npm publish\nRun npm publish in the correct environment when releasing.\n2018-06-27T14:40:12.663Z semantic-release:commit-analyzer Analyzing with default rules\n2018-06-27T14:40:12.663Z semantic-release:commit-analyzer The rule { type: 'fix', release: 'patch' } match commit with release type 'patch'\n[Semantic release]: The release type for the commit is patch\n[Semantic release]: Analysis of 16 commits complete: minor release\n[Semantic release]: The next release version is 1.1.0\n[Semantic release]: Call plugin verify-release\n[Semantic release]: Call plugin generateNotes\n2018-06-27T14:40:12.673Z semantic-release:release-notes-generator version: '1.1.0'\n2018-06-27T14:40:12.673Z semantic-release:release-notes-generator host: 'github.com'\n2018-06-27T14:40:12.673Z semantic-release:release-notes-generator owner: 'Lundalogik'\n2018-06-27T14:40:12.673Z semantic-release:release-notes-generator repository: 'lime-elements'\n2018-06-27T14:40:12.673Z semantic-release:release-notes-generator previousTag: 'v1.0.0'\n2018-06-27T14:40:12.673Z semantic-release:release-notes-generator currentTag: 'v1.1.0'\n[Semantic release]: Call plugin prepare\n[Semantic release]: Wrote version 1.1.0 to package.json\n[Semantic release]: Wrote version 1.1.0 to package-lock.json\n[Semantic release]: Create tag v1.1.0\n[Semantic release]: An error occurred while running semantic-release: { Error: Command failed: git push --tags https://[secure]@github.com/Lundalogik/lime-elements.git HEAD:master\nTo https://[secure]@github.com/Lundalogik/lime-elements.git\n ! [rejected]        v1.1.0 -> v1.1.0 (already exists)\nerror: failed to push some refs to 'https://[secure]@github.com/Lundalogik/lime-elements.git'\nhint: Updates were rejected because the tag already exists in the remote.\nat makeError (/lime/node_modules/semantic-release/node_modules/execa/index.js:172:9)\nat Promise.all.then.arr (/lime/node_modules/semantic-release/node_modules/execa/index.js:277:16)\nat <anonymous>\nat process._tickCallback (internal/process/next_tick.js:188:7)\n\ncode: 1,\n  stdout: '',\n  stderr: 'To https://[secure]@github.com/Lundalogik/lime-elements.git\\n ! [rejected]        v1.1.0 -> v1.1.0 (already exists)\\nerror: failed to push some refs to \\'https://[secure]@github.com/Lundalogik/lime-elements.git\\'\\nhint: Updates were rejected because the tag already exists in the remote.\\n',\n  failed: true,\n  signal: null,\n  cmd: 'git push --tags https://[secure]@github.com/Lundalogik/lime-elements.git HEAD:master',\n  timedOut: false,\n  killed: false }\n{ Error: Command failed: git push --tags https://*@github.com/Lundalogik/lime-elements.git HEAD:master\nTo https://@github.com/Lundalogik/lime-elements.git\n ! [rejected]        v1.1.0 -> v1.1.0 (already exists)\nerror: failed to push some refs to 'https://***@github.com/Lundalogik/lime-elements.git'\nhint: Updates were rejected because the tag already exists in the remote.\nat makeError (/lime/node_modules/semantic-release/node_modules/execa/index.js:172:9)\nat Promise.all.then.arr (/lime/node_modules/semantic-release/node_modules/execa/index.js:277:16)\nat <anonymous>\nat process._tickCallback (internal/process/next_tick.js:188:7)\n\ncode: 1,\n  stdout: '',\n  stderr: 'To https://*@github.com/Lundalogik/lime-elements.git\\n ! [rejected]        v1.1.0 -> v1.1.0 (already exists)\\nerror: failed to push some refs to \\'https://*@github.com/Lundalogik/lime-elements.git\\'\\nhint: Updates were rejected because the tag already exists in the remote.\\n',\n  failed: true,\n  signal: null,\n  cmd: 'git push --tags https://*@github.com/Lundalogik/lime-elements.git HEAD:master',\n  timedOut: false,\n  killed: false }\nMakefile:15: recipe for target 'release' failed\nmake:  [release] Error 1\n[Pipeline] }\n[Pipeline] // script\n[Pipeline] }\n[Pipeline] // withEnv\n[Pipeline] }\n[Pipeline] // withCredentials\n[Pipeline] }\n[Pipeline] // stage\n[Pipeline] }\n[Pipeline] // withEnv\n[Pipeline] }\n[Pipeline] // node\n[Pipeline] End of Pipeline\nGitHub has been notified of this commit\u2019s build result\nERROR: script returned exit code 2\nFinished: FAILURE\n```. Here's a screenshot of the releases in Github, in case that is of any help:\n. Updated the debug-log in my comment above. Apparently Jenkins had cut a part when I checked the logs for just the relevant build step. I found the rest when I looked at the complete console output.. Ah, ok! I think that might have something to do with us running this in docker. I'm sure the image is being cached or something. I'll try adding a fetch somewhere in the pipe. Thanks!. Ah, ok. In any case, even if only a fetch doesn't solve it, it seems the problem is that the clone is not completely up to date, so at least I know what to look at. Big thanks for all the help so far! I'll be back in some fashion, either with more questions or with a report on how we solved it.. Ah. I found out Jenkins doesn't check out tags by default.\nTo fix the issue, I had to add an \"Advanced Clone Behaviours\" entry in the \"Behaviours\" in the Project Configuration, and have the \"Fetch tags\" option checked.\nNow releases work just fine! Thanks for creating this awesome tool!. Well, that's the first thing I checked, and it's happened with three consecutive builds now, so I'm fairly sure the tag doesn't already exist.\nAlso, if they already existed before the release started, I think the release would fail when first pushing to GitHub. It doesn't. It creates the release just fine, with change-log and all. And the time of creation for the release and the tag seems to match as well.\nIt seems to me like it's just trying to push the tag twice\u2026?\nWhen I get back to work on Monday I'll take a closer look and see if I can garner anything more on the tags.. Argh!\nI made this super-long post with log outputs and screenshots and everything, and just before I posted it, I thought I should just double check one thing\u2026 \ud83d\ude04\nMy colleagues had reset the build-process for some other projects, and accidentally included this one in a different pipeline. So it was indeed built twice.\nThanks for your help and sorry for wasting your time on a Friday night!. ",
    "jamsea": "Ah shoot, didn't realize npm didn't support the metadata. The tagFormat option solves the problem for the git tag side of things though, thanks for the info!. Yeah I think I might just have to write my own custom function for prepare to fit our workflow. Analyzing the commits doesn't really work because the team isn't used to formatting commit messages yet, so the least friction way to introduce this tool is to leverage the Jenkins build number for the minor version number (e.g. v0.0.95100002 would be fine)\nSomething like this should work:\njs\nconst {prepare: npmPrepare} = require('@semantic-release/npm');\nfunction customPrepare(pluginConfig, {nextRelease: {version}, logger}) {\n    const jenkinsBuildNumber = process.env.BUILD_NUMBER;\n    const customVersion = someCustomLogicHere(jenkinsBuildNumber);\n    return npmPrepare(pluginConfig, {nextRelease: {version: customVersion}, logger});\n}\n. I see what you mean. I think I've been thinking about this wrong, this might be the wrong tool for the job I have (even though it'd be great to use for a new, or smaller project). Now that I'm thinking more about it, it's going to be tricky to get the git history too, because I'll be running this from inside a docker container that won't have the entire repo (just a sub folder), so I won't have access to the .git folder to read the tags. Do you know if the npm plugin determines the next version by checking the npm server? Or does it rely on git tags and the package.json?\n. Thanks for your help! I'll close the issue. ",
    "jasononeil": "See #653 . Sounds good, if the information I've included is about to change and no longer be correct it makes sense to wait.\nIf it is still correct I think it's worth merging for people interested in the mean time - I had to learn what I've documented here by reading source code of both semantic-release and some of the default packages. Up to you though - happy for you to close or merge or give feedback as you see fit :) . ",
    "portenez": "Same on missing GL_TOKEN. The verifyConditions didn't catch this issue.. @pvdlg Hi, sorry. I'm seeing the same behavior as @jwalton. I forgot to declare GL_TOKEN, and then the error I get is:\n[Semantic release]: The local branch master is behind the remote one, therefore a new version won't be published.\nthe command and output\n$ npx semantic-release\n[Semantic release]: Running semantic-release version 15.6.0\n[Semantic release]: Load plugin \"verifyConditions\" from @semantic-release/changelog\n[Semantic release]: Load plugin \"verifyConditions\" from @semantic-release/npm\n[Semantic release]: Load plugin \"verifyConditions\" from @semantic-release/git\n[Semantic release]: Load plugin \"verifyConditions\" from @semantic-release/gitlab\n[Semantic release]: Load plugin \"analyzeCommits\" from @semantic-release/commit-analyzer\n[Semantic release]: Load plugin \"generateNotes\" from @semantic-release/release-notes-generator\n[Semantic release]: Load plugin \"prepare\" from @semantic-release/changelog\n[Semantic release]: Load plugin \"prepare\" from @semantic-release/npm\n[Semantic release]: Load plugin \"prepare\" from @semantic-release/git\n[Semantic release]: Load plugin \"publish\" from @semantic-release/npm\n[Semantic release]: Load plugin \"publish\" from @semantic-release/gitlab\n[Semantic release]: The local branch master is behind the remote one, therefore a new version won't b\nI'll get the debug logs.\n. Oh, no. I'm not using that branch. I was clarifying my initial comment.\nToday is a holiday in the US, but I'll try the branch asap.. @pvdlg I guess to try the branch, I need to clone the repo and link it locally?. ",
    "bodinsamuel": "hi @pvdlg \ngreat to here there is already something in place \ud83d\udc4d \nI'm sorry this is a private repo, but I'v provided the redacted log, there was 1065 commits most of them related to one PR and at least one or more issues ! So you can imagine how huge it could be.\nI don't know if it's really worth investigating for you, I'm probably the only having this kind of issue because it was a really old repo. \nI think the only way to reproduce would be to create a big repo with thousand of commit and launching the cli :D . ",
    "adyz": "Using an older version of semantic-release works, but what would be the safest version to use that dose not require git version greater than 1.8.5?\nAny thoughts?\nThank you!. Thank you for your answer @pvdlg !\nYou're right, we should update our git version.\n\nI've installed the semantic-release 15.0.0 and looks like this message doesn't show up.\n\n. ",
    "nick-woodward": "@pvdlg \nThanks for taking the time to provide some well articulated feedback!\nI'm actually bringing my source code with me when I checkout the latest branch. So the source code exists on both latest and master, but only latest has the built artifact. So technically hot fixes should be possible, but could create some weird situations given the branch split.\nMigrating my code from latest back to master was my first option (and likely the one I'll move forward with), however I figured it was worth a shot to see how something like this would be received over here. I totally don't blame you for not wanting to take on any debt related to bower.\nAgain, thanks for your time!. ",
    "carlos-cubas": "I roughly have an idea of how to change it, but I don't have a windows machine to test it on.  in the meantime i'll update the readme to explain support only for *nix. Hi Pierre, \nI ended up updating the docs with a no windows support disclaimer.  I unfortunately don't have the time to do this now. \nSo i have created an issue on the repo to track it: https://github.com/carlos-cubas/semantic-release-gcr/issues/2\nIn general I believe there's some value, for a large portion of the community, to use the plugin in its current state. So i would encourage a merge of the PR and addition to the docs.\nBut it is your call. . ",
    "egucciar": "@pvdlg I am interested in trying this out because it's currently a blocker in our Dev workflow to not have this sort of capability. We currently have this setup:\nmaster branch is pre-existing and running semantic-release in circleCI and contains the latest gitTag of 4.x\nstaging branch is pre-existing and was branched from master at some point in time. the last git tag on the branch is 3.x\nWe want to use staging to create a pre-release which can be installed explicitly by consuming apps with the --beta tag. Then, when staging is merged into master, we want there to be an actual release. Ideally, the same --beta release could have its dist-tag updated to --latest but it could also be an issue to do this considering the source code could theoretically be different after a merge.\nI tried your branch - Thanks so much for this by the way, incredible work! and I am running into the folowing:\n```\n[Semantic release]: The release type for the commit is major\n[Semantic release]: Analysis of 473 commits complete: major release\n[Semantic release]: The next release version is 3.0.0\n[Semantic release]: EINVALIDNEXTVERSION TODO\nTODO\n{ SemanticReleaseError: TODO\n    at module.exports (/Users/ericagucciardo/git/moveiq-app/node_modules/semantic-release/lib/get-error.js:6:10)\n    at run (/Users/ericagucciardo/git/moveiq-app/node_modules/semantic-release/index.js:129:11)\n    at \n    at process._tickCallback (internal/process/next_tick.js:188:7)\n  name: 'SemanticReleaseError',\n  code: 'EINVALIDNEXTVERSION',\n  details: 'TODO',\n  semanticRelease: true }\n```\nAny ideas on what I need to do next-steps wise to get this working for our needs? It would be lovely. Our use case currently is that our master branch is used to create Releases for our app for consumers, but it's also how we release our app to our site (since our App is consumed both by another consuming app, as well as deployed directly to a host from CI/CD). This means in order for us to QA the app in our consuming app, we have to create a production release, which can create delays when trying to move quickly since we need to completely QA things to push to Prod before we can consider QAing the staging on the consumer application. So, though there's multiple ways to solve this problem (i.e. having to merge to 2 different branches rather than having master serve the purpose of both), I think an even better solution would be to leverage Semantic Release to create beta releases for staging and latest releases for master. This would be the ideal workflow.. ",
    "dadamssg": "Dang. I figured that was it. Was hoping someone has ran into this on circleci and solved it. You can close this issue. . ",
    "sbekrin": "@pvdlg thanks for clarification! Indeed we've used just a single plugin, but it an array \ud83d\ude42. ",
    "leocwlam": "Hi Pierre,\nThank for your help.  I think I am getting closer to success.  After all the change, I can see semantic-release, which create the release (on V1.0.0)\nhttps://github.com/leocwlam/system-logger/releases\n\nbut it still fails to publish on npm https://travis-ci.org/leocwlam/system-logger/jobs/408790147\n\nFYI:\nOn Sunday, when I tried to release, I change the version to 1.0.0 and published on npm.  When I keep on modify code and release.  It failed to publish the 1.0.1.  Therefore, I ran npm unpublish system-logger@1.0.0 to remove from npm on Monday morning.  (No one download yet)\nI am not sure.  Does it cause the current issue?  \nDo I still missing anything?. Thanks for your quick reply.  \nI already fixed .travis.yml.  I changed from provider: npm to provider: script\nhttps://github.com/leocwlam/system-logger/blob/master/.travis.yml\nNow, we are at \n\nIf we can't republish a version on npm after unpublishing it.  (v1.0.0)\nNow, what should we do?  Can we config semantic-release to start version 1.0.1 instead 1.0.0.? \n. Thanks very much.  I tag the release v1.0.0 generated from semantic-release, as you mention above.  Now, I tested from my next fix, npm is showing up to 1.0.1.. Thanks. ",
    "JureSotosek": "That did the trick, seams odd. Any explanation on why that happening?. ",
    "mrchief": "\nThis happens because you already have a v1.3.2 tag bu it's not in the master history.\n\n@pvdlg Is there a way to recover from this? . I was able to apply the workaround listed here. But say one cannot apply the listed workarounds for some reason - does that mean he/she cannot use SR anymore?. ",
    "ciccio86": "@pvdlg the version 0.4.0 was a completely new version which was never published before. The fact is that even though semantic-release failed, the npm package has been successfully published on npm registry.\nThe problem actually occurred with version 0.3.0: this is the log.\nAnyway the problem did not occur earlier that day with release 0.2.1: here the log.. Just found this NPM related issue.. ",
    "mike-north": "I have hit this a few times in cases where my npm credentials for publish are valid, but publish is set up to require 2FA. Somehow I get through the verifyConditions phase (i.e., my npm user has rights to write to the registry for this package) and then fail at the publish step.\nIn my case, I'm left with github releases going through, but the npm package is left behind. Maybe some subset of these problems can be handled by more robust verifyConditions steps?. ",
    "ryexley": "That did it. Thanks so much.. I updated my release config to now look like this:\njson\n{\n  \"noCi\": true,\n  \"analyzeCommits\": {\n    \"preset\": \"eslint\"\n  },\n  \"generateNotes\": {\n    \"preset\": \"eslint\"\n  },\n  \"release\": {\n    \"verifyConditions\": [\n      \"@semantic-release/changelog\",\n      \"@semantic-release/npm\",\n      \"@semantic-release/git\"\n    ],\n    \"prepare\": [\n      \"@semantic-release/changelog\",\n      \"@semantic-release/npm\",\n      {\n        \"path\": \"@semantic-release/git\",\n        \"assets\": [ \"package.json\" ],\n        \"message\": \"Release: ${nextRelease.version}\"\n      }\n    ],\n    \"publish\": [\n      \"@semantic-release/npm\",\n      \"@semantic-release/github\"\n    ]\n  }\n}\nI ran a release, and I still have an uncommitted, modified package.json file. This is what the CLI output of the run looked like (hoping this is what you meant by \"log\", as I am not seeing any kind of output log file, if that was what you were asking for):\n[22:03:30] [semantic-release] \u203a \u2139  Running semantic-release version 15.9.8\n[22:03:30] [semantic-release] \u203a \u2714  Loaded plugin \"verifyConditions\" from \"@semantic-release/npm\"\n[22:03:30] [semantic-release] \u203a \u2714  Loaded plugin \"verifyConditions\" from \"@semantic-release/github\"\n[22:03:30] [semantic-release] \u203a \u2714  Loaded plugin \"analyzeCommits\" from \"@semantic-release/commit-analyzer\"\n[22:03:30] [semantic-release] \u203a \u2714  Loaded plugin \"generateNotes\" from \"@semantic-release/release-notes-generator\"\n[22:03:30] [semantic-release] \u203a \u2714  Loaded plugin \"prepare\" from \"@semantic-release/npm\"\n[22:03:30] [semantic-release] \u203a \u2714  Loaded plugin \"publish\" from \"@semantic-release/npm\"\n[22:03:30] [semantic-release] \u203a \u2714  Loaded plugin \"publish\" from \"@semantic-release/github\"\n[22:03:30] [semantic-release] \u203a \u2714  Loaded plugin \"success\" from \"@semantic-release/github\"\n[22:03:30] [semantic-release] \u203a \u2714  Loaded plugin \"fail\" from \"@semantic-release/github\"\n[22:03:30] [semantic-release] \u203a \u2714  Run automated release from branch master\n[22:03:31] [semantic-release] \u203a \u2714  Allowed to push to the Git repository\n[22:03:31] [semantic-release] \u203a \u2139  Start step \"verifyConditions\" of plugin \"@semantic-release/npm\"\n[22:03:31] [semantic-release] [@semantic-release/npm] \u203a \u2139  Verify authentication for registry https://registry.npmjs.org/\n[22:03:32] [semantic-release] \u203a \u2714  Completed step \"verifyConditions\" of plugin \"@semantic-release/npm\"\n[22:03:32] [semantic-release] \u203a \u2139  Start step \"verifyConditions\" of plugin \"@semantic-release/github\"\n[22:03:32] [semantic-release] [@semantic-release/github] \u203a \u2139  Verify GitHub authentication\n[22:03:32] [semantic-release] \u203a \u2714  Completed step \"verifyConditions\" of plugin \"@semantic-release/github\"\n[22:03:32] [semantic-release] \u203a \u2139  Found git tag v1.2.0 associated with version 1.2.0\n[22:03:33] [semantic-release] \u203a \u2139  Found 1 commits since last release\n[22:03:33] [semantic-release] \u203a \u2139  Start step \"analyzeCommits\" of plugin \"@semantic-release/commit-analyzer\"\n[22:03:33] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: New: Added webpack build for generating compiled, distributable artifacts\n[22:03:33] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The release type for the commit is minor\n[22:03:33] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analysis of 1 commits complete: minor release\n[22:03:33] [semantic-release] \u203a \u2714  Completed step \"analyzeCommits\" of plugin \"@semantic-release/commit-analyzer\"\n[22:03:33] [semantic-release] \u203a \u2139  The next release version is 1.3.0\n[22:03:33] [semantic-release] \u203a \u2139  Start step \"generateNotes\" of plugin \"@semantic-release/release-notes-generator\"\n[22:03:33] [semantic-release] \u203a \u2714  Completed step \"generateNotes\" of plugin \"@semantic-release/release-notes-generator\"\n[22:03:33] [semantic-release] \u203a \u2139  Start step \"prepare\" of plugin \"@semantic-release/npm\"\n[22:03:33] [semantic-release] [@semantic-release/npm] \u203a \u2139  Wrote version 1.3.0 to /Users/me/my/fancy/project/package.json\n[22:03:33] [semantic-release] [@semantic-release/npm] \u203a \u2139  Wrote version 1.3.0 to /Users/me/my/fancy/project/package-lock.json\n[22:03:33] [semantic-release] \u203a \u2714  Completed step \"prepare\" of plugin \"@semantic-release/npm\"\n[22:03:35] [semantic-release] \u203a \u2714  Created tag v1.3.0\n[22:03:35] [semantic-release] \u203a \u2139  Start step \"publish\" of plugin \"@semantic-release/npm\"\n[22:03:35] [semantic-release] [@semantic-release/npm] \u203a \u2139  Publishing version 1.3.0 to npm registry\n[22:03:41] [semantic-release] [@semantic-release/npm] \u203a \u2139  Published my-fancy-project@1.3.0 on https://registry.npmjs.org/\n[22:03:41] [semantic-release] \u203a \u2714  Completed step \"publish\" of plugin \"@semantic-release/npm\"\n[22:03:41] [semantic-release] \u203a \u2139  Start step \"publish\" of plugin \"@semantic-release/github\"\n[22:03:41] [semantic-release] [@semantic-release/github] \u203a \u2139  Published GitHub release: https://github.com/ryexley/my-fancy-project/releases/tag/v1.3.0\n[22:03:41] [semantic-release] \u203a \u2714  Completed step \"publish\" of plugin \"@semantic-release/github\"\n[22:03:41] [semantic-release] \u203a \u2139  Start step \"success\" of plugin \"@semantic-release/github\"\n[22:03:44] [semantic-release] \u203a \u2714  Completed step \"success\" of plugin \"@semantic-release/github\"\n[22:03:44] [semantic-release] \u203a \u2714  Published release 1.3.0\nHope that helps.. My config file is called .releaserc.json and it is in the root of my repository. According to the documentation that I'm reading, that should be what is expected. Additionally, it seems like it's using the config file, because it's skipping CI and doing the release locally. I guess I'm still missing something?. OK, I wondered if that might be the case. I will give that a shot and see if it helps. Thanks for the idea @travi! I will update on whether or not that works.. OK, yeah that was it. I had created my config file based on some examples I had seen, and hadn't realized that the release node was only expected when using the config from package.json. I missed that in the README. Thanks for clearing me up.. ",
    "XiaZhang0414": "@pvdlg But there is still something I don't understand. I run the command npm run semantic-release in travis enterprise. I got above when I run the semantic-release in travis deploy stage:\ndeploy:\n   skip_cleanup: true\n   provider: script\n   script: npm run semantic-release\n   on:\n     tags: false\n     branch: master\nnode: 10.6.0\nBut if I run the semantic-release in after-success stage, it works fine.\nafter_success:\n  - echo \".travis.yml\" >> ./.npmignore\n  - echo \"coverage\" >> ./.npmignore\n  - npm run prepublishOnly\n  - npm run upload-coverage\n- npm run semantic-release. @travi When I said works fine, I mean the semantic-release can successfully publish the package to GitHub and npm registry (when I run semantic-release in the travis after_success stage). I get the GitHub authentication issue when I ran semantic-release in deploy stage.. ",
    "thibaudcolas": "@pvdlg this happens on an install of semantic-release without any existing dependencies or lockfiles. For example in a fresh, empty directory:\n```\n17:27:41 :Dev/playground\n$ mkdir test\n17:27:44 :Dev/playground\n$ cd test\n./  ../ \n17:27:46 :playground/test\n$ npm install semantic-release@latest\nnpm WARN saveError ENOENT: no such file or directory, open '[...]/test/package.json'\nnpm WARN enoent ENOENT: no such file or directory, open '[...]/test/package.json'\nnpm WARN marked-terminal@3.0.0 requires a peer of marked@^0.4.0 but none is installed. You must install peer dependencies yourself.\nnpm WARN test No description\nnpm WARN test No repository field.\nnpm WARN test No README data\nnpm WARN test No license field.\n\nsemantic-release@15.9.9\nadded 790 packages in 14.554s\n```\n\nThis is because marked-terminal@3.0.0's peer dependency is set to marked ^0.4.0, so doesn't cover 0.5.0 (npm only allows patch updates for caret ranges of 0.x.y version numbers).\nSince then, I see that marked-terminal has made a v3.1.0 release which adds support for marked@0.5.0.. Yes, this is now fixed as of 2018-08-24T16:39:51.957Z when marked-terminal got released to npm. \nPeople who had installed semantic-release@15.9.9 between its release and that of marked-terminal just need to reinstall semantic-release so its dependency is updated.\n@pvdlg  so I understand if this happens again \u2013\u00a0semantic-release isn't supposed to update dependencies outside of their peer dependencies' range, right? You marked this as support, I would expect npm warnings on install to be considered bugs.. ",
    "smirnowld": "Thanks @pvdlg, this makes sense. The linked thread is certainly an interesting read, although our monorepo is just a set of standalone components, which are currently released as one package (although that is likely to change at some point), so perhaps the use case is simpler than the ones debated in that thread.\nIn any case, it looks like squashing before merging is the way to go for us after all. With regards to PRs containing several features, I would say that's a bad practice and means that the PR is too large. I should be able to enforce correct squashing through git hooks, which would hopefully ensure that only compatible commits end up in master.\nThanks a lot for the detailed response!. ",
    "MartinMuzatko": "Is the --no-ci flag now also documented in the in-CLI help (semantic-release -h) ?. ",
    "Ninerian": "Thank you very much. . Thank you for the info.. ",
    "aleclarson": "It's questionable whether breaking changes should bump 0.1.0 to 1.0.0 instead of 0.2.0. Are you aware that a dependency on ^0.1.0 is equivalent to >=0.1.0 <0.2.0? Going by that logic, the 1 in 0.1.0 is considered the major version. It should be a conscious decision on the developer's part to bump to 1.0.0 when they're ready. I imagine the best way to do that would be for the developer to manually create the 1.0.0 tag.\nIf you disagree, I guess I'll have to find another tool. Maybe auto-release supports it... ",
    "limonte": "Nevermind, related to the project internals.\nThanks for the GREAT TOOL which will improve my workflow \ud83d\ude80 . ",
    "damassi": "I think adding a \"migrating existing repo\" section would be really useful. Regarding the need for proper tags before the library will work properly, reading over the entries above the one added by this PR seem unrelated in the sense that the error is different which might confuse those migrating. (All irrelevant if a migration section were added!). ",
    "oleg-koval": "@pvdlg \nThat's actually is strange, as I did configuration with CLI tool, as the output of this I had a couple of versions released with the semantic-release, but that's was done with an older version of semantic-release.\nWill keep debugging, but don't know in which way, as I said I have all tokens setup. @pvdlg All good now, the problem was that I was looking into the travis-pro page for my repo and travis-org, so sem-release was working on travis-org, but it was never set up for travis-pro. A bit of confusion will close this, \nthanks for learnings. ",
    "anru": "\nsemantic-release cannot work without pushing tags\n\nright, but where is restriction that forbids third-party plugins to push tags ?. In my case runners doesn't have access to git repository, and only way to push tags is using gitlab api. ",
    "Diokuz": "Probably, the better solution would be an option: how to push a tag \u2013 via git push or via api. But no-push-access-for-runners is definitely the case.. ",
    "konsalex": "Thank you very much @pvdlg for your blazing fast support. The dry-run and the no-ci flag was indeed my mistake! \ud83d\ude43\n. ",
    "khaledosman": "using the default semantic-release command errors out because it asks for a github token environment variable..\nso I ended up adding this to my package.json to configure semantic-release to not use github\n\"release\": {\n    \"repositoryUrl\": \"<RepoURL>\",\n    \"plugins\": [\"@semantic-release/commit-analyzer\", \"@semantic-release/release-notes-generator\", \"@semantic-release/npm\", \"@semantic-release/bitbucket\"]\n  }\nHowever I wasn't able to find @semantic-release/bitbucket plugins, are there any?\nAn example on how to do this would be helpful..  Using \nnpm i -D semantic-release@next @semantic-release/git@next @semantic-release/commit-analyzer@next @semantic-release/release-notes-generator@next @semantic-release/npm@next @semantic-release/changelog@next\nthen running it using npx worked for me.. it just printed the Changelog as it was running in drymode..\nI tried manually setting --dry-run=false while running the command as well as adding  \"dryRun\": false, to the package json config for the sake of testing it, but it was still running in dry mode regardless. I guess I have to try it with one of the supported CIs setup.\nEDIT: the --no-ci flag did the trick. \nThis is awesome, thanks!. So I'm working with a Private NPM registry and Bitbucket Pipelines as a CI..\nI followed https://npme.npmjs.com/docs/tutorials/pipelines.html to set my NPM_TOKEN and NPM_REGISTRY variables from pipelines settings and copy them into an .npmrc file\nSo my pipelines build file looks as follows:\n```\nThis is a sample build configuration for JavaScript.\nCheck our guides at https://confluence.atlassian.com/x/14UWN for more examples.\nOnly use spaces to indent your .yml configuration.\n-----\nYou can specify a custom docker image from Docker Hub as your build environment.\nimage: node:latest\npipelines:\n  default:\n    - step:\n        caches:\n          - node\n        script: # Modify the commands below to build your repository.\n          # Generates a .npmrc file configured for installing private modules:\n          #\n          # NPM_REGISTRY_URL: the full URL of your private registry\n          #                   defaults to registry.npmjs.org.\n          # NPM_TOKEN: secret token for installing private modules. This\n          #            this token can be found in your .npmrc, after logging in.\n          - printf \"//node -p \\\"require('url').parse(process.env.NPM_REGISTRY_URL || 'https://registry.npmjs.org').host\\\"/:_authToken=${NPM_TOKEN}\\nregistry=${NPM_REGISTRY_URL:-https://registry.npmjs.org}\\n\" >> ~/.npmrc\n          - npm install\n          - npm test\n          - npx semantic-release --no-ci\n```\nHowever when running semantic-release I get an error saying \"The local branch master is behind the remote one, therefore a new version won't be published.\"\n+ npx semantic-release --no-ci\n[10:19:31 AM] [semantic-release] \u203a \u2139  Running semantic-release version 15.10.2\n[10:19:32 AM] [semantic-release] \u203a \u2714  Loaded plugin \"verifyConditions\" from \"@semantic-release/npm\"\n[10:19:32 AM] [semantic-release] \u203a \u2714  Loaded plugin \"verifyConditions\" from \"@semantic-release/changelog\"\n[10:19:32 AM] [semantic-release] \u203a \u2714  Loaded plugin \"verifyConditions\" from \"@semantic-release/git\"\n[10:19:32 AM] [semantic-release] \u203a \u2714  Loaded plugin \"analyzeCommits\" from \"@semantic-release/commit-analyzer\"\n[10:19:32 AM] [semantic-release] \u203a \u2714  Loaded plugin \"generateNotes\" from \"@semantic-release/release-notes-generator\"\n[10:19:32 AM] [semantic-release] \u203a \u2714  Loaded plugin \"prepare\" from \"@semantic-release/npm\"\n[10:19:32 AM] [semantic-release] \u203a \u2714  Loaded plugin \"prepare\" from \"@semantic-release/changelog\"\n[10:19:32 AM] [semantic-release] \u203a \u2714  Loaded plugin \"prepare\" from \"@semantic-release/git\"\n[10:19:32 AM] [semantic-release] \u203a \u2714  Loaded plugin \"publish\" from \"@semantic-release/npm\"\n[10:19:32 AM] [semantic-release] \u203a \u2714  Run automated release from branch master\n[10:19:32 AM] [semantic-release] \u203a \u2139  The local branch master is behind the remote one, therefore a new version won't be published.\nI know there's no official CI integration for pipelines, but I was hoping this would work similar to how it would when I run it locally since pipelines already has access to the repository and runs everything in a docker container with preset repository related environment variables as stated here https://confluence.atlassian.com/bitbucket/environment-variables-794502608.html\nReading through similar issues I figured this has to do with a github token based authentication check.. is there some way to disable this check or get around this?\nAfter reading through the pipelines Build Step I see that its doing the following to clone the repository:\n+ umask 000\n+ GIT_LFS_SKIP_SMUDGE=1 git clone --branch=\"master\" --depth 50 https://x-token-auth:$REPOSITORY_OAUTH_ACCESS_TOKEN@<BITBUCKET_REPO>.git $BUILD_DIR ; git reset --hard <LAST_COMMIT_ID> ; git remote set-url origin git@<BITBUCKET_REPO>\nCloning into '/opt/atlassian/pipelines/agent/build'...\nHEAD is now at <LAST_COMMIT_ID> Initial Bitbucket Pipelines configuration\n+ chmod 777 $BUILD_DIR\nperhaps this Is because pipelines is explicitly resetting to a specific commit id rather than HEAD?. + npx semantic-release --no-ci --debug\n[4:01:16 PM] [semantic-release] \u203a \u2139  Running semantic-release version 15.10.2\n2018-10-17T16:01:17.274Z semantic-release:config options values: { branch: 'master',\n  repositoryUrl: 'git@<BITBUCKET_REPO_URL>',\n  tagFormat: 'v${version}',\n  plugins:\n   [ '@semantic-release/commit-analyzer',\n     '@semantic-release/release-notes-generator',\n     '@semantic-release/npm',\n     '@semantic-release/changelog',\n     '@semantic-release/git' ],\n  _: [],\n  ci: false,\n  debug: true,\n  '$0': 'node_modules/.bin/semantic-release',\n  noCi: true }\n[4:01:17 PM] [semantic-release] \u203a \u2714  Loaded plugin \"verifyConditions\" from \"@semantic-release/npm\"\n[4:01:17 PM] [semantic-release] \u203a \u2714  Loaded plugin \"verifyConditions\" from \"@semantic-release/changelog\"\n[4:01:17 PM] [semantic-release] \u203a \u2714  Loaded plugin \"verifyConditions\" from \"@semantic-release/git\"\n[4:01:17 PM] [semantic-release] \u203a \u2714  Loaded plugin \"analyzeCommits\" from \"@semantic-release/commit-analyzer\"\n[4:01:17 PM] [semantic-release] \u203a \u2714  Loaded plugin \"generateNotes\" from \"@semantic-release/release-notes-generator\"\n[4:01:17 PM] [semantic-release] \u203a \u2714  Loaded plugin \"prepare\" from \"@semantic-release/npm\"\n[4:01:17 PM] [semantic-release] \u203a \u2714  Loaded plugin \"prepare\" from \"@semantic-release/changelog\"\n[4:01:17 PM] [semantic-release] \u203a \u2714  Loaded plugin \"prepare\" from \"@semantic-release/git\"\n[4:01:17 PM] [semantic-release] \u203a \u2714  Loaded plugin \"publish\" from \"@semantic-release/npm\"\n[4:01:17 PM] [semantic-release] \u203a \u2714  Run automated release from branch master\n2018-10-17T16:01:17.729Z semantic-release:git Error: Command failed: git push --dry-run git@<BITBUCKET_REPO_URL> HEAD:master\nWarning: Permanently added the RSA host key for IP address '18.205.93.1' to the list of known hosts.\nPermission denied (publickey).\nfatal: Could not read from remote repository.\nPlease make sure you have the correct access rights\nand the repository exists.\n    at makeError (/opt/atlassian/pipelines/agent/build/node_modules/execa/index.js:174:9)\n    at Promise.all.then.arr (/opt/atlassian/pipelines/agent/build/node_modules/execa/index.js:278:16)\n    at process._tickCallback (internal/process/next_tick.js:68:7)\n2018-10-17T16:01:17.844Z semantic-release:git Error: Command failed: git push --dry-run git@<BITBUCKET_REPO_URL> HEAD:master\nPermission denied (publickey).\nfatal: Could not read from remote repository.\nPlease make sure you have the correct access rights\nand the repository exists.\n    at makeError (/opt/atlassian/pipelines/agent/build/node_modules/execa/index.js:174:9)\n    at Promise.all.then.arr (/opt/atlassian/pipelines/agent/build/node_modules/execa/index.js:278:16)\n    at process._tickCallback (internal/process/next_tick.js:68:7)\n2018-10-17T16:01:17.955Z semantic-release:git Error: Command failed: git ls-remote --heads origin master\nWarning: Permanently added the RSA host key for IP address '18.205.93.0' to the list of known hosts.\nPermission denied (publickey).\nfatal: Could not read from remote repository.\nPlease make sure you have the correct access rights\nand the repository exists.\n    at makeError (/opt/atlassian/pipelines/agent/build/node_modules/execa/index.js:174:9)\n    at Promise.all.then.arr (/opt/atlassian/pipelines/agent/build/node_modules/execa/index.js:278:16)\n    at process._tickCallback (internal/process/next_tick.js:68:7)\n[4:01:17 PM] [semantic-release] \u203a \u2139  The local branch master is behind the remote one, therefore a new version won't be published.. I guess that makes sense, I fixed it by adding an SSH Key to the repository's pipelines' settings. Thanks!. ",
    "byCedric": "I think that's possible! Even if semantic release creates types/interfaces for these plugins or methods it would be helpful I guess.\nYou can either create an index.d.ts which contains some typing or as @mattyclarkson said, use definitely typed. If you want to create the index.d.ts in this repo, you can add it like Redux package file.\nI can pitch in to help if you guys want.. I would be happy to! I think we (me and the company I work for) owe you guys that. It's been an absolute delight since we switched over to Semantic Release, especially for the projects with complex version-sensitive files. We've reduced maintainability, and well, time is money \ud83d\ude2c \nMatt first told me about the upcoming release channels feature. This change probably has some impact on the plugins right? Is it a good idea to wait for that feature before creating the types? What do you think Matt?. @mattyclarkson I guess we can type the \"core context\"; all properties which are included when no plugin is invoked. In this type/interface we can add an index signature.\nTake this code for example:\n```typescript\ninterface Context {\n    // core\n    some: string;\n    variable: number;\n    other: string[];\n// allow unknown properties\n[key: string]: any;\n\n}\nconst abc: Context = {\n    // core\n    some: 'value',\n    variable: 123,\n    other: ['asd', 'asd'],\n// plugin-specific extra\nspecial: 'vars',\nlib: 123,\n\n};\n```\nI found it here too, https://github.com/Microsoft/TypeScript/issues/7803#issuecomment-205279410.. ",
    "bjarki": "Thank you @pvdlg I removed the prepublishOnly from package.json and update my .gitlab-ci.yaml to first run npm run build before running npx semantic-release. That solved the issue.. ",
    "tsirlucas": "Got some setup errors locally and decided to close, fix and open another PR later.. ",
    "hiradimir": "I have same issue on circleci\nsh\n$ npx semantic-release\nnpx: installed 780 in 15.47s\n[11:34:35 PM] [semantic-release] \u203a \u2139  Running semantic-release version 15.10.5\n[11:34:35 PM] [semantic-release] \u203a \u2714  Loaded plugin \"verifyConditions\" from \"@semantic-release/npm\"\n[11:34:35 PM] [semantic-release] \u203a \u2714  Loaded plugin \"verifyConditions\" from \"@semantic-release/github\"\n[11:34:35 PM] [semantic-release] \u203a \u2714  Loaded plugin \"analyzeCommits\" from \"@semantic-release/commit-analyzer\"\n[11:34:35 PM] [semantic-release] \u203a \u2714  Loaded plugin \"generateNotes\" from \"@semantic-release/release-notes-generator\"\n[11:34:35 PM] [semantic-release] \u203a \u2714  Loaded plugin \"prepare\" from \"@semantic-release/npm\"\n[11:34:35 PM] [semantic-release] \u203a \u2714  Loaded plugin \"publish\" from \"@semantic-release/npm\"\n[11:34:35 PM] [semantic-release] \u203a \u2714  Loaded plugin \"publish\" from \"@semantic-release/github\"\n[11:34:35 PM] [semantic-release] \u203a \u2714  Loaded plugin \"success\" from \"@semantic-release/github\"\n[11:34:35 PM] [semantic-release] \u203a \u2714  Loaded plugin \"fail\" from \"@semantic-release/github\"\n[11:34:35 PM] [semantic-release] \u203a \u2714  Run automated release from branch production\n[11:34:35 PM] [semantic-release] \u203a \u2716  An error occurred while running semantic-release: Error: You provided a local path.\n    at parseUrl (/home/circleci/.npm/_npx/53/lib/node_modules/semantic-release/node_modules/parse-url/lib/index.js:48:15)\n    at gitUp (/home/circleci/.npm/_npx/53/lib/node_modules/semantic-release/node_modules/git-up/lib/index.js:29:18)\n    at gitUrlParse (/home/circleci/.npm/_npx/53/lib/node_modules/semantic-release/node_modules/git-url-parse/lib/index.js:42:19)\n    at module.exports (/home/circleci/.npm/_npx/53/lib/node_modules/semantic-release/lib/get-git-auth-url.js:49:36)\n    at process._tickCallback (internal/process/next_tick.js:68:7)\nError: You provided a local path.\n    at parseUrl (/home/circleci/.npm/_npx/53/lib/node_modules/semantic-release/node_modules/parse-url/lib/index.js:48:15)\n    at gitUp (/home/circleci/.npm/_npx/53/lib/node_modules/semantic-release/node_modules/git-up/lib/index.js:29:18)\n    at gitUrlParse (/home/circleci/.npm/_npx/53/lib/node_modules/semantic-release/node_modules/git-url-parse/lib/index.js:42:19)\n    at module.exports (/home/circleci/.npm/_npx/53/lib/node_modules/semantic-release/lib/get-git-auth-url.js:49:36)\n    at process._tickCallback (internal/process/next_tick.js:68:7)Exited with code 1\n. ",
    "tuckbick": "I was able to fix this issue by changing the repository url in the package.json from git format to https format.. ",
    "zanona": "@tuckbick Yes, however, if you have read/write GitHub deploy keys installed by the CI, it seems that its server is only able to access the repo through git@github.com:username/repo.git while https://github.com/username/repo.git always asks for a username and password. I personally believe repo-specific deploy keys are much safer than an account personal token.\nI have trouble understanding as well why this message is showing up.. ",
    "Alorel": "@tuckbick An auth error shows up if I change the git repo URL to its http version.\n\nShow\n\n[2:03:04 PM] [semantic-release] \u203a \u2139  Running semantic-release version 15.10.5\n[2:03:04 PM] [semantic-release] \u203a \u2714  Loaded plugin \"verifyConditions\" from \"@semantic-release/npm\"\n[2:03:04 PM] [semantic-release] \u203a \u2714  Loaded plugin \"verifyConditions\" from \"@semantic-release/github\"\n[2:03:04 PM] [semantic-release] \u203a \u2714  Loaded plugin \"analyzeCommits\" from \"@semantic-release/commit-analyzer\"\n[2:03:04 PM] [semantic-release] \u203a \u2714  Loaded plugin \"generateNotes\" from \"@semantic-release/release-notes-generator\"\n[2:03:04 PM] [semantic-release] \u203a \u2714  Loaded plugin \"prepare\" from \"@semantic-release/changelog\"\n[2:03:04 PM] [semantic-release] \u203a \u2714  Loaded plugin \"prepare\" from \"@alorel-personal/semantic-release\"\n[2:03:04 PM] [semantic-release] \u203a \u2714  Loaded plugin \"prepare\" from \"@semantic-release/npm\"\n[2:03:04 PM] [semantic-release] \u203a \u2714  Loaded plugin \"prepare\" from \"@semantic-release/exec\"\n[2:03:04 PM] [semantic-release] \u203a \u2714  Loaded plugin \"prepare\" from \"@semantic-release/exec\"\n[2:03:04 PM] [semantic-release] \u203a \u2714  Loaded plugin \"prepare\" from \"@semantic-release/exec\"\n[2:03:04 PM] [semantic-release] \u203a \u2714  Loaded plugin \"prepare\" from \"@semantic-release/git\"\n[2:03:04 PM] [semantic-release] \u203a \u2714  Loaded plugin \"publish\" from \"@semantic-release/npm\"\n[2:03:04 PM] [semantic-release] \u203a \u2714  Loaded plugin \"publish\" from \"@semantic-release/github\"\n[2:03:04 PM] [semantic-release] \u203a \u2714  Loaded plugin \"success\" from \"@semantic-release/github\"\n[2:03:04 PM] [semantic-release] \u203a \u2714  Loaded plugin \"fail\" from \"@semantic-release/github\"\n[2:03:04 PM] [semantic-release] \u203a \u2714  Run automated release from branch master\n[2:03:07 PM] [semantic-release] \u203a \u2716  The command \"git push --dry-run http://[secure]@github.com/Alorel/personal-build-tools.git HEAD:master\" failed with the error message remote: Invalid username or password.\nfatal: Authentication failed for 'https://github.com/Alorel/personal-build-tools.git/'\n.\n[2:03:07 PM] [semantic-release] \u203a \u2139  Start step \"fail\" of plugin \"@semantic-release/github\"\n[2:03:07 PM] [semantic-release] [@semantic-release/github] \u203a \u2139  Verify GitHub authentication\n[2:03:11 PM] [semantic-release] [@semantic-release/github] \u203a \u2139  Created issue #34: https://github.com/Alorel/personal-build-tools/issues/34.\n[2:03:11 PM] [semantic-release] \u203a \u2714  Completed step \"fail\" of plugin \"@semantic-release/github\"\n[2:03:11 PM] [semantic-release] \u203a \u2716  EGITNOPERMISSION The push permission to the Git repository is required.\nsemantic-release cannot push the version tag to the branch master on remote Git repository with URL http://[secure]@github.com/Alorel/personal-build-tools.git.\nPlease refer to the authentication configuration documentation (https://github.com/semantic-release/semantic-release/blob/caribou/docs/usage/ci-configuration.md#authentication) to configure the Git credentials on your CI environment and make sure the repositoryUrl (https://github.com/semantic-release/semantic-release/blob/caribou/docs/usage/configuration.md#repositoryurl) is configured with a valid Git URL (https://git-scm.com/book/en/v2/Git-on-the-Server-The-Protocols).\n{ SemanticReleaseError: The push permission to the Git repository is required.\n    at module.exports (/home/travis/build/Alorel/personal-build-tools/node_modules/semantic-release/lib/get-error.js:6:10)\n    at run (/home/travis/build/Alorel/personal-build-tools/node_modules/semantic-release/index.js:75:11)\n    at process.internalTickCallback (internal/process/next_tick.js:77:7)\n  name: 'SemanticReleaseError',\n  code: 'EGITNOPERMISSION',\n  details:\n   '**semantic-release** cannot push the version tag to the branch `master` on remote Git repository with URL `http://[secure]@github.com/Alorel/personal-build-tools.git`.\\n\\nPlease refer to the [authentication configuration documentation](https://github.com/semantic-release/semantic-release/blob/caribou/docs/usage/ci-configuration.md#authentication) to configure the Git credentials on your CI environment and make sure the [repositoryUrl](https://github.com/semantic-release/semantic-release/blob/caribou/docs/usage/configuration.md#repositoryurl) is configured with a [valid Git URL](https://git-scm.com/book/en/v2/Git-on-the-Server-The-Protocols).',\n  semanticRelease: true }\nThe command \"semantic-release\" exited with 1.\n\n\n\nEither way this error shows there's some sort of regression going on. The auth tokens/environment variables haven't changed\n\nUpdate I: I just regenerated my access token and updated the GH_TOKEN environment variable. The token is 100% valid.\n\nUpdate II:\n\nDowngrading to semantic-release ~15.9 fixes nothing.\nDowngrading semantic-release/git fixes nothing. \n\nThis is really odd.. This is a temporary workaround idea that will only be suitable for a small portion of us, but you can try to \"force-lock\" git-up to a specific version by:\n\nusing yarn as the package manager\nadding a specific version of git-up to your project dependencies\nusing flat mode - this should prompt you to select the version you want to end up with, similar to how bower works.\n\nJust something off the top of my head until a proper fix is pushed. There is a high probability of this breaking your other dependencies, but might just pass as a temp fix.. @pvdlg I'm aware, which is why I didn't suggest you make a change, this is more for projects that depend on semantic-release to lock down on a git-up version until a fix is pushed. And I only just noticed that I posted the wrong dependency name in the comment, I'll update it.\nAlternatively, people can manually modify their lockfiles as a temp fix. I successfully published a release from this repo just a few hours ago; copy over the semantic-release version range from package.json and the lockfile data for the relevant dependencies from yarn.lock. Not exactly ideal, but it's something :slightly_smiling_face: . ",
    "ivandov": "We're hitting this now too in our production build cycle, with no viable workaround found. \nShouldn't semantic-release specify a specific version of git-up in its package.json? \nEDIT: Nevermind, see that it's nested under git-url-parse and can't be directly fixed this way.. ",
    "martinmosegaard": "Hi @pvdlg. May I ask if this could be an opportunity to revisit the caret range dependency on git-url-parse? I am not an expert on npm dependencies and it seems there are different best practices. But using a tilde or pinned dependency might help the stability of semantic-release? Seems this mishap had a real impact on CI/CD environments. Thanks.\n. ",
    "ersel": "We pinned git-up v2.0.10 as a devDependency in package.json for now.\n\"git-up\": \"2.0.10\",. ",
    "matejdro": "I'm aware that tags themselves are mandatory, but it is not mandatory for semantic-commit to push tags itself, it can be done by something else as long as tags are there in the end.\nMoving update script to shell file and using exec would needlessly complicate things as all our build process is inside Jenkins pipeline which uses groovy code. Rewriting all that in shell file (or javascript) would cause quite a lot of complications and loose jenkins integration.\nI would argue that this is not direct duplicate. #944 was closed due to lack of answers and I did exactly what you asked when closing #944  - create new feature request with those questions answered (I provided reason for disabling git push).. Yes, I meant semantic-release, sorry for that.\n\nI think #957 (comment) does explain why it has to be done by semantic-release and not by something else.\n\nIn that comment you only explain that semantic-relase requires tags to get latest version which I understand. I just don't see a difference if v2.0.0@next tag is pushed via semantic-release or via any other means that uses same exact git command anyway.\n\nsome publish plugins require to \nwill cause a lot more complications for every other semantic-release users\n\nThat is why I request for this to be OPTIONAL option flag. Obviously people that have plugins that require this would not turn this option on. \nThis feature would only require simple if statement in index.js to disable all git-related functionality. I can add pull request for that if you want.. ",
    "bcoe": "@pvdlg I think the plugin system pretty much works the way I was envisioning, it sounds like if (as an example) I instead wanted to publish the npm module using actions/npm, I could just setup the following config:\n['@semantic-release/commit-analyzer', '@semantic-release/release-notes-generator'].\nAnd opt out of the npm step -- I think a compelling GitHub action would potentially just be a container with semantic-release installed, reasonable defaults, and the ability to modify behavior somewhat with environment variables.\n\nInstead a GitHub action could be one that runs when all CI pass (is that possible by the way?) and that just run npx semantic-release.\n\n@joshk is working on a proof of concept that would provide a full-featured Travis CI test run, in the form of an action.\n\nShould I attempt to see https://github.com/conventional-commits/conventional-commits-action over the finish line, and we could potentially reference it as one of the recipes? Or would you rather create your own action, and I'd happily contribute? \n. @pvdlg most of the complexity in the container I shared is adding support for the hub CLI, so that you can easily git push using just the GITHUB_TOKEN that is populated in github actions; I believe that semantic-release invokes the git bin as well, so would want something similar.\nIt seems like semantic-release would be an incredible use-case for actions, did you see this tweet; also perhaps you can reach out to @nickvanw or @zeke.\n. > One benefit that GitHub actions could bring would be to run something when all check status on the HEAD are successful. So it would allow for example to run semantic-release only after Travis CI and Appveyor and Codecov are successful for example.\nI agree, I think GitHub actions are made much more valuable once there's a clear story regarding how you can wire them together with a variety of external services. Travis CI, or AppVeyor, etc., have the benefit of running on a large matrix of platforms, providing information about past failures, etc.\nSimilarly services like Codecov or Coveralls.io provide useful historical information about the quality of a codebase over time.\n\nAllow to have access to GITHUB_TOKEN for pull request originating from a forked repo, so we could add comments on PR with info regarding the version that would be released when the PR is merged\n\nYeah, can't imagine how this wouldn't be a security nightmare ... what is cool about GitHub actions is they do magically populate the GITHUB_TOKEN for the repo they're installed on, and the code is already cloned into the working directory by the time your action runs.. ",
    "gudmundur": "@hbetts I'm not sure that the Node_*_Install actions have the effect that you intend. Since all of the actions in a workflow share a workspace, won't they all be installing to the same node_modules folder, quite potentially at the same time?\nIf that's the case, what would your semantic expectation be for what happens?. > > Allow to have access to GITHUB_TOKEN for pull request\n\nI would assume not, but I haven't confirmed that myself.\n\nThe GitHub token you get is an installation token scoped to the repository which the workflow runs on. What this means is that you can't post anything to the forked repo, but you can have workflows run on the forked repo (given they are flagged in to the beta as well).. ",
    "shawnbot": "FYI, I put a bit of thinking into this last week as we're (the GitHub Primer team) interested in using semantic-release within an Actions workflow. (Different teams and individuals obviously have different needs, but I was curious to see if we could ween ourselves off Travis entirely and do everything on GitHub.) The setup is pretty simple:\n\nThe workflow breaks each of the npm commands up into a different sequential task using actions/npm: install (or ci, which is a bit faster), run lint, then test.\nThe final, sequential release task should just run npx semantic-release (or npm run semantic-release). The CLI know when it's not on the release branch(es), so it won't publish from any others.\n\nTL;DR: it's basically doable, but not without custom actions and some environment variable tweaks. Here's what I ran into:\n\nI had to create a new action that installs the git binary from the same node:10-slim image as actions/npm.\nTo maintain parity with the actions/npm environment, I copied that action's entrypoint.sh and \"aliased\" NPM_TOKEN (which semantic-release expects) to NPM_AUTH_TOKEN.\nI had to call semantic-release with --no-ci because it doesn't seem to recognize the Actions environment as CI (maybe because it doesn't set a CI environment variable?).\n\nTo get around the lack of push permissions for the built-in GITHUB_TOKEN, I created a personal access token with full repo permissions and added it as a GH_TOKEN secret. (Just to be safe, I also disabled the automatic GITHUB_TOKEN in this task.)\nThis is a bummer because it makes everything on GitHub happen on my behalf rather than the actions bot account. (Of course, anyone running semantic-release on Travis has already run into this and probably uses a dummy \"bot\" account's access token, so...)\n\n\nI was able to make this action work after all of this, but it was more of a headache than I'd expected; and I'm not entirely happy with everything using my personal access token (IMO, the built-in access token is one of the reasons to use Actions over Travis in the first place). In its current state, it's definitely not ready for prime-time.\nIf anyone is looking to run tests on Travis and then semantic-release in an action, I would suggest looking into a command that waits for Travis's commit status (or check) to pass before running. The ideal would be to have the semantic-release action only run on the check_run event and if the check was a successful Travis run, but \u2014\u00a0and @gudmundur, please correct me on this \u2014 I believe we only run actions on push events for public repos right now.\n. > @shawnbot could you export CI=true in your Dockerfile, entrypoint.sh, or in the configuration for the Action?\nYes, I think that would work too. I mostly noted that for my colleagues working on Actions, though, who may be interested in exporting that environment variable by default, e.g. as CI=github.\n\n\nTo get around the lack of push permissions for the built-in GITHUB_TOKEN\n\nIs this for pushing a commit to the repository where the version field in package.json is updated?\n\nYep! semantic-release plugins could theoretically commit other files too, though, right?. @pvdlg You're absolutely right about the token permissions being a problem. The bug, however, is actually on our end: it's that the permissions.push field of the API response is wrong, not that the token actually lacks permissions. @ptoomey3 tracked this down and we're working on a fix. \ud83c\udf7b . @joakimhellum-in I ran into the same issue working on some non-semantic-release actions this week, and have confirmed with the team that this is a known bug.. ",
    "mcolyer": "\nI believe we only run actions on push events for public repos right now.\n\nThat's correct.. ",
    "joakimhellum-in": "Hi, thanks for sharing thoughts and experiences about GitHub Action for semantic-release. \nWe experienced the same. However we also tried to skip the verifyConditions steps hoping the special GITHUB_TOKEN actually did have the push permission anyway, and then we got the following error when trying to push git tag: \nrefusing to allow an integration to create .github/main.workflow\nBut when looking further this seems to be a general problem in GitHub Actions and not only related to the special GITHUB_TOKEN, for example the same seem to happen when using deploy keys. \nI don't understand if this restriction is intentional and only during beta, or if this is the bug @shawnbot is referring to.\n[11:15:41 PM] [semantic-release] \u203a \u2716  An error occurred while running semantic-release: { Error: Command failed: git push --tags https://github.com/some-organization/some-repo.git\nTo https://github.com/some-organization/some-repo.git\n ! [remote rejected] v1.9.0 -> v1.9.0 (refusing to allow an integration to create .github/main.workflow)\nerror: failed to push some refs to 'https://github.com/some-organization/some-repo.git'\n...\nUpdate: Found a twitter message that suggests this is a bug. Thanks,. ",
    "JasonEtco": "@gr2m to be clear - that solution will let you push no problem, but will still be blocked from pushing main.workflow files.. ",
    "mdluo": "@pvdlg Great work \ud83d\udc4d . ",
    "xetra11": "@pvdlg \nHey there! Thanks for the advice! I fixed my issue with the teamcity.build.branch variable through this https://stackoverflow.com/questions/22314229/why-did-my-teamcity-build-stop-working\nUnfortunatly this did not fix the problem. In my build log I printed the teamcity.build.branch. As you can see it is development and semantic-release is set to b: 'development'. So everything should be fine?\n[16:51:02][Step 9/9] teamcity.build.branch\n[16:51:02][Step 9/9] development\n[16:51:02][Step 9/9] git tag\n[16:51:02][Step 9/9] v0.0.1\n[16:51:02][Step 9/9] commits since v0.0.1:\n[16:51:02][Step 9/9] 44752cf0481da6032d00b559f873676f354e5c6e docs(readme): update build status\n[16:51:02][Step 9/9] ae908dca476e44d8ad8a3db37ca527031cf7c08b Merge remote-tracking branch 'origin/development' into development\n[16:51:02][Step 9/9] 11c6329901dcb0176a0b1efdb5e791080882ed5a docs(readme): update badge\n[16:51:02][Step 9/9] 8ae6eff6b6a2e7e020a15e20707617519dac4cd9 Merge pull request #15 from CoopR-Mod/feature/refactor_api_endpoints\n[16:51:02][Step 9/9] dc0e3a375eaf45845f0933040700c6048ed47063 feat(api): change api\n[16:51:02][Step 9/9] ef5d3922c56788f4af5abf8f983f49d1b4cfcee1 refactor(port): change webapp port\n[16:51:02][Step 9/9] installing & executing semantic-release@15\n[16:51:38][Step 9/9] npx: installed 771 in 35.838s\n[16:51:38][Step 9/9] [4:51:38 PM] [semantic-release] \u203a \u2139  Running semantic-release version 15.12.0\n[16:51:38][Step 9/9] 2018-11-18T16:51:38.843Z semantic-release:config load config from: undefined\n[16:51:38][Step 9/9] 2018-11-18T16:51:38.860Z semantic-release:config options values: { branch: 'development',\n[16:51:38][Step 9/9]   repositoryUrl: 'https://github.com/CoopR-Mod/CoopR-HQ.git',\n[16:51:38][Step 9/9]   tagFormat: 'v${version}',\n[16:51:38][Step 9/9]   plugins:\n[16:51:38][Step 9/9]    [ '@semantic-release/commit-analyzer',\n[16:51:38][Step 9/9]      '@semantic-release/release-notes-generator',\n[16:51:38][Step 9/9]      '@semantic-release/npm',\n[16:51:38][Step 9/9]      '@semantic-release/github' ],\n[16:51:38][Step 9/9]   _: [],\n[16:51:38][Step 9/9]   debug: true,\n[16:51:38][Step 9/9]   b: 'development',\n[16:51:38][Step 9/9]   '$0': '/root/.npm/_npx/7494/bin/semantic-release' }\n[16:51:39][Step 9/9] 2018-11-18T16:51:39.461Z semantic-release:plugins options for @semantic-release/npm/verifyConditions: {}\n[16:51:39][Step 9/9] [4:51:39 PM] [semantic-release] \u203a \u2714  Loaded plugin \"verifyConditions\" from \"@semantic-release/npm\"\n[16:51:39][Step 9/9] 2018-11-18T16:51:39.463Z semantic-release:plugins options for @semantic-release/github/verifyConditions: {}\n[16:51:39][Step 9/9] 2018-11-18T16:51:39.463Z semantic-release:plugins options for @semantic-release/commit-analyzer/analyzeCommits: {}\n[16:51:39][Step 9/9] [4:51:39 PM] [semantic-release] \u203a \u2714  Loaded plugin \"verifyConditions\" from \"@semantic-release/github\"\n[16:51:39][Step 9/9] [4:51:39 PM] [semantic-release] \u203a \u2714  Loaded plugin \"analyzeCommits\" from \"@semantic-release/commit-analyzer\"\n[16:51:39][Step 9/9] 2018-11-18T16:51:39.464Z semantic-release:plugins options for @semantic-release/release-notes-generator/generateNotes: {}\n[16:51:39][Step 9/9] 2018-11-18T16:51:39.465Z semantic-release:plugins options for @semantic-release/npm/prepare: {}\n[16:51:39][Step 9/9] [4:51:39 PM] [semantic-release] \u203a \u2714  Loaded plugin \"generateNotes\" from \"@semantic-release/release-notes-generator\"\n[16:51:39][Step 9/9] [4:51:39 PM] [semantic-release] \u203a \u2714  Loaded plugin \"prepare\" from \"@semantic-release/npm\"\n[16:51:39][Step 9/9] [4:51:39 PM] [semantic-release] \u203a \u2714  Loaded plugin \"publish\" from \"@semantic-release/npm\"\n[16:51:39][Step 9/9] [4:51:39 PM] [semantic-release] \u203a \u2714  Loaded plugin \"publish\" from \"@semantic-release/github\"\n[16:51:39][Step 9/9] [4:51:39 PM] [semantic-release] \u203a \u2714  Loaded plugin \"success\" from \"@semantic-release/github\"\n[16:51:39][Step 9/9] [4:51:39 PM] [semantic-release] \u203a \u2714  Loaded plugin \"fail\" from \"@semantic-release/github\"\n[16:51:39][Step 9/9] 2018-11-18T16:51:39.465Z semantic-release:plugins options for @semantic-release/npm/publish: {}\n[16:51:39][Step 9/9] 2018-11-18T16:51:39.466Z semantic-release:plugins options for @semantic-release/github/publish: {}\n[16:51:39][Step 9/9] 2018-11-18T16:51:39.466Z semantic-release:plugins options for @semantic-release/github/success: {}\n[16:51:39][Step 9/9] 2018-11-18T16:51:39.467Z semantic-release:plugins options for @semantic-release/github/fail: {}\n[16:51:39][Step 9/9] [4:51:39 PM] [semantic-release] \u203a \u2139  This test run was triggered on the branch undefined, while semantic-release is configured to only publish from development, therefore a new version won\u2019t be published.. Sorry for not being clear enough in TeamCity you can refer to config variables with %config.name% syntax. In the log above I have the following shell command added:\necho \"teamcity.build.branch\"\necho \"%teamcity.build.branch%\"\nThat is the first statements of the posted log:\n[16:51:02][Step 9/9] teamcity.build.branch\n[16:51:02][Step 9/9] development\nTherefore for my understanding the needed variable that https://github.com/pvdlg/env-ci/blob/master/services/teamcity.js is calling is available.. Ok I investigated a little bit. TeamCity runs their builds via build agents.\nThis is what my build logs tells me where the TEAMCITY_BUILD_PROPERTIES_FILE file is located.\n[17:06:49][Step 9/9] TEAMCITY_BUILD_PROPERTIES_FILE\n[17:06:49][Step 9/9] /opt/buildagent/temp/buildTmp/teamcity.build1247874379229852118.properties\nSo I went in there and checked out what is to find there via ls -alt:\n```\nroot@ee1b6eaff148:/# ls /opt/buildagent/temp/buildTmp/ -alt\ntotal 124\ndrwxr-xr-x 2 root root  4096 Nov 18 22:41 npm-9474-c1607218\ndrwxr-xr-x 5 root root  4096 Nov 18 22:40 .\ndrwxr-xr-x 2 root root  4096 Nov 18 22:40 npm-9431-3e253e66\n-rw-r--r-- 1 root root  1620 Nov 18 22:40 teamcity.build1247874379229852118.properties\n-rw-r--r-- 1 root root  2328 Nov 18 22:40 teamcity.build1247874379229852118.properties.xml\n-rw-r--r-- 1 root root  6463 Nov 18 22:40 teamcity.config5401792480086582224.properties\n-rw-r--r-- 1 root root  9026 Nov 18 22:40 teamcity.config5401792480086582224.properties.xml\n-rw-r--r-- 1 root root  1218 Nov 18 22:40 teamcity.runner7126906933636614725.properties.xml\n-rw-r--r-- 1 root root     0 Nov 18 22:40 changedFiles3729922649597608790.txt\n-rw-r--r-- 1 root root   887 Nov 18 22:40 teamcity.runner7126906933636614725.properties\ndrwxr-xr-x 2 root root  4096 Nov 18 22:40 .tc-maven-bi\n-rw-r--r-- 1 root root 61565 Nov 18 22:40 maven-build-info.xml\n-rw-r--r-- 1 root root   226 Nov 18 22:40 teamcity.m2.conf\ndrwxr-xr-x 6 root root  4096 Nov 18 22:40 ..\n```\nThen I grepped for teamcity.build.branch and found these results:\nroot@ee1b6eaff148:/# grep -r \"teamcity.build.branch\" /opt/buildagent/temp/buildTmp/\n/opt/buildagent/temp/buildTmp/teamcity.config5401792480086582224.properties:teamcity.build.branch=development\n/opt/buildagent/temp/buildTmp/teamcity.config5401792480086582224.properties:teamcity.build.branch.is_default=true\nThe odd thing is that TEAMCITY_BUILD_PROPERTIES_FILE is pointing to a teamcity.build<hash>.properties file while the property teamcity.build.branch seems to reside within a\nteamcity.config<hash>.properties  file.\nNow to make things a wrap I checked if there is a TEAMCITY_BUILD_PROPERTIES_FILE env variable existing that points to the - in this case - right file. I could not find anything. There was a variable called CONFIG_FILE but this pointed to the user defined configuration of the agent - so out of context.\n@pvdlg \nFor me it looks like that TeamCity moved the property to another properties file. Something that env-ci was not yet aware of and therefore could not fix.\nShould I open an issue in that repo or will you investigate this?\nGreetings!\n. @pvdlg \nHey buddy,\nThanks for the quick fix.\nI am installing semantic-release in my Command-Line build step like this:\necho \"installing npx\"\nnpm install -g npx;\necho \"installing & executing semantic-release@15\"\nnpx semantic-release@15 --debug -b development\nI am not sure  your mentioned patch will be in there? Since I could not find it in the latest release of semantic-release\n. I don't have any of these but rebuilding everything from scratch does not seem to help. I will later check the node_modules directory and see what version on env-ci I can find in there. @pvdlg \nI checked the package.json of env-ci from within semantic-release node_modules directory.\nThis is the result: https://pastebin.com/Vw1wF69f\n\"_from\": \"env-ci@^3.0.0\",\n  \"_id\": \"env-ci@3.1.1\",\nAs mentioned I am not aware of NPM/NodeJS and there I don't know if it is right or wrong since it looks like it has the right version pulled: env-ci@^3.0.0 == 3.0.0 or greater.\nFor me it looks like it grabbed you fix release but still I get the same error \ud83d\ude22 . > The value of the teamcity.build.branch environment variable\n/opt/buildagent/temp/buildTmp/teamcity.config6472602540593814375.properties:teamcity.build.branch=development\n/opt/buildagent/temp/buildTmp/teamcity.config6472602540593814375.properties:teamcity.build.branch.is_default=true\n\nThe value of the TEAMCITY_BUILD_PROPERTIES_FILE environment variable\n\n/opt/buildagent/temp/buildTmp/teamcity.build3186240320888402473.properties\n\nThe full content of the file referenced by TEAMCITY_BUILD_PROPERTIES_FILE\n\n```\nroot@ee1b6eaff148:/# cat /opt/buildagent/temp/buildTmp/teamcity.build6322174704090798415.properties\nTeamCity build properties without 'system.' prefix\nTue Nov 20 16:38:17 UTC 2018\nagent.home.dir=/opt/buildagent\nagent.name=coopr_hq_dev_agent\nagent.ownPort=9090\nagent.work.dir=/opt/buildagent/work\nbuild.number=43\nbuild.vcs.number=7d414b3020b6a68d6979a0c0bfb120d5e988ae37\nbuild.vcs.number.1=7d414b3020b6a68d6979a0c0bfb120d5e988ae37\nbuild.vcs.number.coopr_hq_vcs_development=7d414b3020b6a68d6979a0c0bfb120d5e988ae37\njava.io.tmpdir=/opt/buildagent/temp/buildTmp\nteamcity.agent.cpuBenchmark=533\nteamcity.agent.dotnet.agent_url=http\\://localhost\\:9090/RPC2\nteamcity.agent.dotnet.build_id=187\nteamcity.auth.userId=TeamCityBuildId\\=187\nteamcity.build.changedFiles.file=/opt/buildagent/temp/buildTmp/changedFiles2936488582986504927.txt\nteamcity.build.checkoutDir=/opt/buildagent/work/b67f9480ebfe9c96\nteamcity.build.id=187\nteamcity.build.properties.file=/opt/buildagent/temp/buildTmp/teamcity.build6322174704090798415.properties\nteamcity.build.tempDir=/opt/buildagent/temp/buildTmp\nteamcity.build.workingDir=/opt/buildagent/work/b67f9480ebfe9c96\nteamcity.buildConfName=CoopR HQ Dev Build & Deployment\nteamcity.buildType.id=coopr_hq_dev_build_and_deployment\nteamcity.configuration.properties.file=/opt/buildagent/temp/buildTmp/teamcity.config6191218026832138439.properties\nteamcity.projectName=CoopR HQ Development\nteamcity.runner.properties.file=/opt/buildagent/temp/buildTmp/teamcity.runner9046867176783897020.properties\nteamcity.tests.recentlyFailedTests.file=/opt/buildagent/temp/buildTmp/testsToRunFirst3087314258389584197.txt\nteamcity.version=2018.1.3 (build 58658)\nroot@ee1b6eaff148:/#\n``\n. > I'm confused, according to [this comment](https://github.com/semantic-release/semantic-release/issues/987#issuecomment-439722724) theteamcity.build.branchvariable was set todevelopment. And now it's set to/opt/buildagent/temp/buildTmp/teamcity.config6472602540593814375.properties:teamcity.build.branch=development /opt/buildagent/temp/buildTmp/teamcity.config6472602540593814375.properties:teamcity.build.branch.is_default=true` ??\nSorry this is a grep command:\n grep -r \"teamcity.build.branch\" <path>\nIt's result is:\n/opt/buildagent/temp/buildTmp/teamcity.config6472602540593814375.properties:teamcity.build.branch=development \n/opt/buildagent/temp/buildTmp/teamcity.config6472602540593814375.properties:teamcity.build.branch.is_default=true ??\nPure values:\nteamcity.build.branch=development \nteamcity.build.branch.is_default=true // which is out of context but was grepped as well\nthe /opt/buildagent/temp/buildTmp/teamcity.config6472602540593814375.properties: is just telling me what file this entry is in. Typical grep behaviour.\n. @pvdlg \nI had a hard time understanding what you meant. Since the teamcity.build.branch value is coming from that mentioned *.properties file I thought that would be enough for you. Anyways I called it from the build step by %teamcity.build.branch% and the result was development as expected. PS: According to this https://unix.stackexchange.com/questions/93532/exporting-a-variable-with-dot-in-it you are not allowed to define environment variables in linux via dot notation. Therefore teamcity.build.branch has to be a teamcity internal system variable.. @pvdlg \nAs I assumed in https://github.com/semantic-release/semantic-release/issues/987#issuecomment-440360739 this looks like a teamcity system environment variable. I think it will be replaced as you mentioned.\nIf you want I can provide you access to by teamcity server and test it by yourself.\nAbout not having a solution for now. Doesn't semantic-release have any kind of fallbacklogic besides using env-cli? Like just asking git what branch it is currently in? If not - what about env-cli having a fallback to a user defined environment variable? In my build configuration I always can provide a custom environment variable. ENV_CLI_BRANCH for instance? This way we had a workaround for the teamcity issue?. \nIt is listed under Predefined Parameters. Real environment variables are prefixed with env. in TeamCity build config syntax. Hm ok I see. Thanks for your investigations anyways!\nStill... --no-ci doesn't helped either. I tried that at the beginning of the problem already and it yields the same problem having the branch being undefined. \nTherefore I ask if there is any way to explicitly tell semantic-release on which branch it is by an option maybe? env-ci does not work because of TeamCity's environment setup. git kinda does not work as well since I am executing git branch in the same script as I run semantic-release (see my initial question https://github.com/semantic-release/semantic-release/issues/987#issue-381817159) and it shows me the correct branch. \nBut to get around all of these pitfalls I would like to have an option to explicitly tell what branch I am on. I am upset that I cannot tell the tool to just start creating a release version because everything is fine with the branch it is executed on. . @fjaapar \nAre you asking me a question? Because I do not understand the email quote?. @pvdlg \nShould I open an issue at TeamCity? Or did you already?. It works! Thanks buddy I love you <3. ",
    "fjaapar": "Pada Sel, 20 Nov 2018 4:46 PM xetra11 <notifications@github.com menulis:\n\nI don't have any of these but rebuilding everything from scratch does not\nseem to help. I will later check the node_modules directory and see what\nversion on env-ci I can find in there\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/semantic-release/semantic-release/issues/987#issuecomment-440190726,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ApUGb8aLW0z7wUIDuRCm-BultLcjL0olks5uw8F0gaJpZM4YnOPh\n.\n. Pada 29/11/2018 6:32 AM, \"Pierre Vanduynslager\" notifications@github.com\nmenulis:\n\nMerged #1004\nhttps://github.com/semantic-release/semantic-release/pull/1004 into\nmaster.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/semantic-release/semantic-release/pull/1004#event-1993768940,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ApUGb1-eufFORUvdplyLyUkEox2OHKAOks5uzw7rgaJpZM4Y4hT1\n.\n. ",
    "momocow": "Thanks for the feedback.\nOops, I just missed to think about shareable configurations. I'll keep that in mind.\nUsually, I would like to make my configuration files a bit \"less logical\" as possible, that is, keep them static files instead of scripts. But it seems a release.config.js file is the best choice now to simplify path resolution due to the deep and complicated structure of Nodejs package system.\nAlso, I found that the configuration is merged into an object that makes it impossible to trace back where a certain path in the value of config came from.. That's all right, it's kind of virtualization that semantic-release brings to plugins, and plugins should avoid trying to resolve the actual project structure to maintain the flexibility.\nIn this case, delegating those works to users seems the best choice.\nThanks for your support!. ",
    "PawelWesolowski": "Question:\nI like this new feature and want to give it a try but I am not sure how is the dist-channel mapping going to work after beta.\nAt https://github.com/semantic-release/evolution/blob/release-workflows/_drafts/release-workflows.md I've found\n{\n  \"release\": {\n    \"branches\": [\n      {\"branch\": \"1.x.x\", \"range\": \"1.x.x\", \"channel\": \"latest\"},\n      {\"branch\": \"master\", \"channel\": \"latest\"},\n      {\"branch\": \"next\", \"channel\": \"next\"},\n      {\"branch\": \"alpha\", \"channel\": \"alpha\", \"preid\": \"alpha\", \"prerelease\": true}\n    ]\n  }\n}\nAfter I changed \"branch\" to \"name\" the \"channel\" mapping worked correctly in v16.0.0-beta.2. with the following test config\n{\n    \"branches\": [\n        {\"name\": \"release\", \"channel\": \"latest\"},\n        {\"name\": \"develop\", \"channel\": \"next\", \"prerelese\": true},\n        {\"name\": \"beta\", \"channel\": \"beta\", \"prerelese\": true}\n    ]\n}\nSo it works but I couldn't find any mentions of \"channel\" in docs for branch configs other than the one above about  addChannel in plugins. \nIs it just that the docs need update or am I failing to find it?. Thanks a lot @pvdlg !\nBtw: I did not find the this doc page because I have just followed the \"configuration\" link from here\nCheers!. ",
    "DanielHabenicht": "It has to do with this line, explitcitly referencing the branch: \nhttps://github.com/semantic-release/semantic-release/blob/f2ede5bdded568ee1e2d52af608f3c92123030dc/test/helpers/git-utils.js#L226\nGit pushes the tag but errors as the branch is behind origin.. No, I just stumbled upon this issue as we were working normally and another PR was merged into master while the release for the previous merged PR was running. Therefore we (the Team Foundation server) committed to the remote while semantic release was running.\nThe first problem now is, that there was no version published for this commit.\nThe second problem is that semantic release did not finish in a pristine state as the tag was pushed to the remote and then exited with failure.\nI would expect semantic release to run without error, once it verified in the beginning, if the branch is up to date. \n. > How would you push a tag from an outdated local repo? How could you handle any type of discrepancy between local and remote (including new commit pushed, remote branch reset to an older commit, rebase of the head commit on remote) when pushing that tag?\nWell, in this case, there is no discrepancy between local and remote apart from the remote being one commit ahead, so it shouldn't be a problem to tag the previous commit. \nI do understand that this is a problem in the situations you described. \nHowever in my way of thinking I am triggering the semantic release in order to create a release for a specific commit. If the commit is outdated before even starting the release it is fine to skip it and redo it at a later time, just as you stated. \nBut as the release is started semantic release should go on with every other task following, including tagging the commit, because it just executed all the commands for this version and e.g. already pushed the docker image or released the npm package. \nMaybe this could be hidden behind a force option if it is not favourable by the majority, as there are the drawbacks you just described. \n\nAccording to your logs the tag was not pushed to the remote. See \"error: failed to push some refs to 'https://remote.gitrepo.com/path/to/project'\"\n\nUnfortunately, it was. I can see it in the TFS and the gitlog is also saying it: \nAn error occurred while running semantic-release: { Error: Command failed: git push --tags https://remote.gitrepo.com/path/to/project HEAD:master\n2018-11-20T14:01:33.8823860Z To https://remote.gitrepo.com/path/to/project\n2018-11-20T14:01:33.8844900Z  * [new tag]         v1.1.8 -> v1.1.8\n2018-11-20T14:01:33.9350000Z  ! [rejected]        HEAD -> master (fetch first)\nIt did Error on the second task Git was doing. \nIn order to reproduce the error I tried executing the command only using git (always with the same configuration: remote repo beeing one commit ahead): \ngit push --tags is working fine\ngit push <tag name> origin is working fine\ngit push --tags origin HEAD:master is erroring with the same error message:\nTo https://remote.gitrepo.com/path/to/project\n * [new tag]         test6 -> test6\n ! [rejected]        HEAD -> master (non-fast-forward)\nerror: failed to push some refs to 'https://remote.gitrepo.com/path/to/project'\nhint: Updates were rejected because the tip of your current branch is behind\nhint: its remote counterpart. Integrate the remote changes (e.g.\nhint: 'git pull ...') before pushing again.\nhint: See the 'Note about fast-forwards' in 'git push --help' for details.\nI don't know the specifics of Git but specifying HEAD:master seems to trigger some sort of push apart from pushing the tags. \n\nAgain there is no way to achieve that, as there is no way to prevent things to happen outside of semantic-release. The verification happens at a point in time, and the push at another point in time and we can't prevent things to happen in the outside word between two point in time. As far as I know there is no way to put a lock on the remote between those two point in time, so there will always be a race condition there.\n\nI understand that handling external events should be taken care of by the build scheduler, e.g. by building only once an hour and thus circumvent this issue. \nBut my main point is that it is possible to tag the build but semantic release fails nontheless. \n. I think the command git push --tags origin HEAD:master is wrongly used. \nAt the end of the release, only the tag should be pushed to the remote repo. But by specifying origin HEAD:master the branch is also pushed, but can't because origin is already one commit ahead. Furthermore why should semantic release push the branch - it shouldn't alter the source code? \nIt should be git push --tags or even more specific git push <tag name> origin. > I didn't realized the tag was created but pushing the head failed.\n\nShould be fixed in #994 .\nRegarding #993 (comment) it's not completely correct. Pushing to Docker should be done in the publish step which happens after the tag is pushed. You should not publish things in a step before publish.\n\nYep, I wasn't sure in the beginning as well. Thanks for the quick fix and keep up the great work. I really like this tool. \ud83d\udc4d \nYou are right, I confused it with building the images. The plugin I am using takes care of publishing during the publish step. . ",
    "elevatebart": "Do you think https://github.com/vue-styleguidist/vue-styleguidist has the same issue ? I am having the same issue but use npm. I will check the package-lock when I get back\nHappy Thanksgiving . It was !! Thank you @pvdlg, could we make sure that this plugin requires a recent enough version of node-fetch? Just for safety.. so a PR to octokit/request adding the dependency would make sense. Should I do it ?. ",
    "Hyperkid123": "@pvdlg i will try it again and let you know.\n. @pvdlg no sorry i did not. I'm using older version (15.12.0).  I will go ahead and try it today.. @pvdlg so i've used the version 15.12.1 again and it again the travis build is failing. I tried it on a different repo with the same result: https://travis-ci.org/data-driven-forms/react-starter/builds/460661446#L650, with the same error (tried multiple configurations, with same results). \nThe only \"weird\" thing i've noticed is that the version of the semantic on Travis release does not match the one specified in package.json\nin travis\n[08:48:22] [semantic-release] \u203a \u2139  Running semantic-release version 15.12.0 \nin console on my PC\n[10:26:06] [semantic-release] \u203a \u2139  Running semantic-release version 15.12.2\nin package JSON\n\"semantic-release\": \"^15.12.2\",\nhttps://github.com/data-driven-forms/react-starter/commit/a39fa38e5e175f621f2812116cfdf43e31f7bd79\nWhen in run the release from terminal it will publish the new version without any issues.\nIts a bit of a head scratcher... But since i am the only one with this issue, it is most likely something wrong on my side. . @pvdlg Deleting cache helped (could have tried that first \ud83e\udd26\u200d\u2642\ufe0f ). Thanks for the tips!. ",
    "evansiroky": "Thanks for the tips.  I believe we will be able to address most of these comments.  However, the part about making commits and pushing them is an important part of our internal workflow.  These commits fulfill 2 purposes.  First, we need to make a commit with the release so that when the code is tarred up for a github release, the correct version number is included in the pom.xml and also the commit listed in the release contains these changes.  Second, we need to update to a snapshot version because we create these intermediate versions that we don't want to create a github release and maven central release for, but do use for internal development by uploading jar files to s3 that we can then use elsewhere.  Furthermore, we're about to add more code that would merge these commits back into our own development branch.  Perhaps we could make these extra commits an optional thing that could be enabled by setting a cli flag or something.  Would that suffice?. I think it may be best to add in an option to make the commits optional so that this can still be listed as a community plugin so we can get more community feedback and collaboration.. I have made a bunch of updates in the last few days.  Thanks for the tips!\n\nCan you remove the \"warning\" section from there? That should be in the Readme of your plugin.\nAlso it's not accurate as now the preferred configuration methods is to use the plugins option.\n\nDone\n\n\nHardcoded dependency to GitHub there. Use the option repositoryUrl instead, which is an authenticated URL that semantic-release passed to you\n\n\nNow using repositoryUrl throughout code.\n\n\nHardcoded dependency to Travis there. Use the branch option that semantic-release passed to you\n\n\nNow using branch throughout code.\n\n\nInstead of creating and pushing your commit, you should just update the pom.xml and let users use https://github.com/semantic-release/git to commit it\n\n\nMade this the default behavior, but with the option to still do our custom workflow by enabling a flag during runtime.\n\n\nWhat your are doing in verifyRelease should be done in verifyConditions. The point of verifyRelease is to determine if the release type determined based on commits is correct (e.g. if based on the commits semantic-release determine a patch verifies that there is no breaking change by running previous version test or checking the public API didn't change, etc...)\n\n\nI moved most things into verifyConditions, but still do a few things related to checking the next release in verifyRelease.\n\n\nIt's quite surprising to change the pom.xml to a snapshot version in publish.js#L18. You should not need to do that with automated version releases.\n\n\nMade this not the default behavior, but with the option to still do our custom workflow by enabling a flag during runtime.\n\n\nYou should not set user.email and user.name, semantic-release does that already\n\n\nDone\n\n\nYou should not verify the current CI branch, semantic-release does that already\n\n\nDone\n\n\nYou should not checkout a branch as it can creates many issues on CIs for code that can run after semantic-release\n\n\nDone\n\n\nYou should not define semantic-release as a dependency but as a peerDependency. See example.\n\n\nDone\n\n\nYour doc Step 5 and Step 6 are not necessry as that's already part of semantic-release doc\n\n\nI think these sections should be kept since they are important parts of the process.  Step 5 has many more maven-specific settings that are needed in order for the plugin to work.  Step 6 technically is covered by semantic-release, but I'd like to include it in the repo for the maven-semantic-release project too.\n. ",
    "landonreed": "Sorry, wrong project!. ",
    "Berkmann18": "@pvdlg Ah okay, I missed that bit (apologies).\nI've noticed in this and was wondering both lines were meant to be there or if there's just some missing content in one of them.\n\n\nCommits with tag 'New' will be associated with a patch release.\n...\nCommits with tag 'New' will be associated with a minor release (per default release rules).. @pvdlg Well, judging by the example above that unordered list:\n{\n \"plugins\": [\n   [\"semantic-release/commit-analyzer\", {\n     \"preset\": \"eslint\",\n     \"releaseRules\": [\n       {\"tag\": \"Docs\", \"message\":\"/README/\", \"release\": \"patch\"},\n       {\"type\": \"New\", \"release\": \"patch\"}\n     ]\n   }],\n   \"@semantic-release/release-notes-generator\"\n ]\n}\n\n\nI thought the one about patch releases would be when the releaseRules would look out for commits that would follow one like this:\n{\"type\": \"New\", \"message\": \"...\", \"release\": \"patch\"}\nWhere message would describe a new feature that would be treated as a patch or something not worthy of a minor bump (can't think of any keywords to concisely describe this in a commit message).. @pvdlg \n\n\nCommits with tag 'New' will be associated with a patch release.\n...\nCommits with tag 'New' will be associated with a minor release (per [default release rules]\nThose lines seem to contradict each other and confusing and unless both lines are there on purpose, I feel like some info is missing.. @pvdlg The reason why I was overwriting it is to automate the changelog generation as recommended by the developers of conventional-changelog.\nAnd yes, I want to generate a changelog file which is pushed to git.. So why did it worked from time to time with the same config?. @pvdlg Basically, having the same configuration, @semantic-release-bot sometimes did write the changes but not always which is a bit strange.\nEDIT: No idea how my comment above ended up here instead of #1068 (maybe a FastHub bug that made me comment on the wrong issue).. Oh, that's interesting!\n\n\nAnyway, thank you for your help.. ",
    "Ismothers": "Thank you for helping identify that. It looks like Azure Devops is adding that to the commit when it merges to master via PR.\nI'm currently looking at editing commit-analyzer to ignore that message at the beginning, any ideas would be very appreciated.\nThank you again!. Do you have a rough idea of how that could be accomplished @pvdlg? Would I need to copy their package locally, make the changes (I found something called mergePattern that can modify the expected pattern for merge in commit), then include that in semantic-release?\nI apologize, I am very new to this.. It is a known issue with Azure Devops and people have been requesting to have it removed / changed into optional. You can manually clear it out every time you do a PR, but that is very manual. I'll take a look at doing that, thanks!\n. I ended up putting mergePattern into ParserOpts in the package.json! This allowed me to specify my own custom merge syntax for that package. It seems like it is working perfectly now.\n\"release\": {\n        \"plugins\": [\n            \"@semantic-release/commit-analyzer\",\n            \"@semantic-release/release-notes-generator\",\n            \"@semantic-release/npm\"\n        ],\n        \"parserOpts\": {\n            \"mergePattern\": \"Merged PR .*:\"\n        }\n    },. ",
    "fwal": "Thanks @pvdlg \ud83d\ude4c . ",
    "mg901": "Incredibly grateful. ",
    "meebix": "@pvdlg - This is an awesome update. Can I assume that on each version (and release) of the \"beta\" branch, for instance, semantic-release is going to bump the corresponding number accordingly?\nbeta.0\nbeta.1\nbeta.2\netc.\nsemantic-release is taking care of this?\nThanks.. ",
    "kamontat": "You will found here the build variable called BRANCH which it is a branch of current build.\nref: https://www.netlify.com/docs/continuous-deployment/#build-environment-variables. My workflow is getting version from package.json and attach it to html, which generate via vue (which is a static website). and since it's only a content website, so I don't want to write any testing.\nSo first I have to release newest version. and then build website, and then deploy them to Netlify.\nThe problem is if I deploy it in other CI services when it commit the latest version it will include [skip ci]which also use to skip build in Netlify as well. so I cannot do on that way.\nP.S. Assume if I need to use external CI, i will use Circle CI as CI services\nScenario 1\n\nRelease new version on CI (when in master)\nsemantic update version and commit (with [skip ci])\nbuild will not build the latest version\n\nScenario 2\n\nRelease new version on CI (when in master)\nsemantic update version and commit (without [skip ci])\nbuild the deployment and trigger release again\nit will try to build at least 2 times\n\nScenario 3\n\nUse netlify as CI\nrun semantic-release first to update new version\ngenerate html for deployment\ndeployed.. Thank you.. \n",
    "achillesrasquinha": "Sorry to keep you dangling with queries. I'm attempting to perform automated releases for a Python (non-NodeJS based) project. (https://git.io/pipupgrade)\nHere's the corresponding .releaserc as defined. (https://github.com/achillesrasquinha/pipupgrade/blob/develop/.releaserc)\nHere's the corresponding .travis.yml as defined.\n(https://github.com/achillesrasquinha/pipupgrade/blob/develop/.travis.yml)\nOn release, there's a version change (using ${nextRelease.version}) to be made for VERSION file (https://github.com/achillesrasquinha/pipupgrade/blob/develop/src/pipupgrade/VERSION) and committed along with that release (I'm guessing this is where @semantic-release/git would help me).\nThe VERSION file is used by the project to display [command] --version outputs. I'm keen to help this work it out for any non-NodeJS project and assure to have this documented out. Can't seem to find any direction though. Any documentation lead would be appreciated but I don't seem to find any yet.\n. A slight change to the .releaserc you've mentioned:\n{\n    \"plugins\": [\n        \"@semantic-release/commit-analyzer\",\n        \"@semantic-release/release-notes-generator\",\n        [\"@semantic-release/exec\", {\n            \"prepareCmd\": \"echo ${nextRelease.version} > src/pipupgrade/VERSION\"\n        }],\n        [\"@semantic-release/git\", {\n            \"assets\": \"src/pipupgrade/VERSION\"\n        }],\n        \"@semantic-release/github\"\n    ]\n}\nI can confirm that this works! Thank you.. ",
    "paulblyth": "Hey @pvdlg thanks for the reply!\nI haven't rebased or cherry-picked and that tag is not in the history. However I have noticed semantic-release-bot is pushing a branch named 'undefined' to my repo which does have the commit! So perhaps when it's pushing up at the first release it's struggling to find the correct branch name to push to. Does that make sense?\nEdit: here is the publish logs for GitHub from the CI box (replaced owner/repo names)\n[15:46:34][Step 8/8] [15:46:34] [semantic-release] \u203a \u2139  Start step \"publish\" of plugin \"@semantic-release/github\"\n[15:46:34][Step 8/8] 2019-01-09T15:46:34.873Z semantic-release:github release owner: 'owner'\n[15:46:34][Step 8/8] 2019-01-09T15:46:34.874Z semantic-release:github release repo: 'repo'\n[15:46:34][Step 8/8] 2019-01-09T15:46:34.874Z semantic-release:github release tag_name: undefined\n[15:46:34][Step 8/8] 2019-01-09T15:46:34.874Z semantic-release:github release name: 'v1.0.0-alpha.1'\n[15:46:34][Step 8/8] 2019-01-09T15:46:34.874Z semantic-release:github release prerelease: true\n[15:46:35][Step 8/8] [15:46:35] [semantic-release] [@semantic-release/github] \u203a \u2139  Published GitHub release: https://github.com/owner/repo/releases/tag/v1.0.0-alpha.1%40alpha\n[15:46:35][Step 8/8] [15:46:35] [semantic-release] \u203a \u2714  Completed step \"publish\" of plugin \"@semantic-release/github\"\nThe only undefined I can see is from the tag_name. I'm using TeamCity.\nThose were the logs from the run. I can get the full logs if you want them but if there's a specific log you're looking for let me know - I'm a little conscious about filtering out some data that we might class as sensitive.. This should do it:\n[15:46:18][Step 8/8] Starting: /home/centos/buildAgent/work/agentTmp/custom_script6901059480333355715\n[15:46:18][Step 8/8] in directory: /home/centos/buildAgent/work/df162c7dd0c21ff7\n[15:46:18][Step 8/8] On branch alpha\n[15:46:18][Step 8/8] Your branch is up to date with 'origin/alpha'.\n[15:46:18][Step 8/8] \n[15:46:18][Step 8/8] nothing to commit, working tree clean\n[15:46:19][Step 8/8] [15:46:19] [semantic-release] \u203a \u2139  Running semantic-release version 16.0.0-beta.16\n[15:46:19][Step 8/8] 2019-01-09T15:46:19.189Z semantic-release:config load config from: /home/centos/buildAgent/work/df162c7dd0c21ff7/.releaserc.json\n[15:46:19][Step 8/8] 2019-01-09T15:46:19.195Z semantic-release:config options values: { branches: \n[15:46:19][Step 8/8]    [ 'master',\n[15:46:19][Step 8/8]      { branch: 'alpha', name: 'alpha', prerelease: true } ],\n[15:46:19][Step 8/8]   repositoryUrl: 'git@github.com:OWNER_NAME/REPO_NAME.git',\n[15:46:19][Step 8/8]   tagFormat: 'v${version}',\n[15:46:19][Step 8/8]   plugins: \n[15:46:19][Step 8/8]    [ '@semantic-release/commit-analyzer',\n[15:46:19][Step 8/8]      '@semantic-release/release-notes-generator',\n[15:46:19][Step 8/8]      '@semantic-release/npm',\n[15:46:19][Step 8/8]      '@semantic-release/github' ],\n[15:46:19][Step 8/8]   generateNotes: [ '@semantic-release/release-notes-generator' ],\n[15:46:19][Step 8/8]   prepare: \n[15:46:19][Step 8/8]    [ '@semantic-release/changelog',\n[15:46:19][Step 8/8]      '@semantic-release/npm',\n[15:46:19][Step 8/8]      { path: '@semantic-release/git',\n[15:46:19][Step 8/8]        assets: [Array],\n[15:46:19][Step 8/8]        message: 'chore(release): ${nextRelease.version} [skip ci]\\n\\n${nextRelease.notes}' } ],\n[15:46:19][Step 8/8]   analyzeCommits: \n[15:46:19][Step 8/8]    { preset: 'angular',\n[15:46:19][Step 8/8]      releaseRules: \n[15:46:19][Step 8/8]       [ [Object],\n[15:46:19][Step 8/8]         [Object],\n[15:46:19][Step 8/8]         [Object],\n[15:46:19][Step 8/8]         [Object],\n[15:46:19][Step 8/8]         [Object],\n[15:46:19][Step 8/8]         [Object],\n[15:46:19][Step 8/8]         [Object] ] },\n[15:46:19][Step 8/8]   _: [],\n[15:46:19][Step 8/8]   debug: true,\n[15:46:19][Step 8/8]   '$0': 'node_modules/.bin/semantic-release' }\n[15:46:19][Step 8/8] 2019-01-09T15:46:19.460Z semantic-release:plugins options for @semantic-release/npm/verifyConditions: {}\n[15:46:19][Step 8/8] [15:46:19] [semantic-release] \u203a \u2714  Loaded plugin \"verifyConditions\" from \"@semantic-release/npm\"\n[15:46:19][Step 8/8] [15:46:19] [semantic-release] \u203a \u2714  Loaded plugin \"verifyConditions\" from \"@semantic-release/github\"\n[15:46:19][Step 8/8] [15:46:19] [semantic-release] \u203a \u2714  Loaded plugin \"analyzeCommits\" from \"@semantic-release/commit-analyzer\"\n[15:46:19][Step 8/8] [15:46:19] [semantic-release] \u203a \u2714  Loaded plugin \"generateNotes\" from \"@semantic-release/release-notes-generator\"\n[15:46:19][Step 8/8] 2019-01-09T15:46:19.461Z semantic-release:plugins options for @semantic-release/github/verifyConditions: {}\n[15:46:19][Step 8/8] [15:46:19] [semantic-release] \u203a \u2714  Loaded plugin \"prepare\" from \"@semantic-release/changelog\"\n[15:46:19][Step 8/8] [15:46:19] [semantic-release] \u203a \u2714  Loaded plugin \"prepare\" from \"@semantic-release/npm\"\n[15:46:19][Step 8/8] 2019-01-09T15:46:19.462Z semantic-release:plugins options for @semantic-release/commit-analyzer/analyzeCommits: { preset: 'angular',\n[15:46:19][Step 8/8]   releaseRules: \n[15:46:19][Step 8/8]    [ { type: 'docs', release: 'patch' },\n[15:46:19][Step 8/8]      { type: 'refactor', release: 'patch' },\n[15:46:19][Step 8/8]      { type: 'style', release: 'patch' },\n[15:46:19][Step 8/8]      { type: 'test', release: 'patch' },\n[15:46:19][Step 8/8]      { type: 'build', release: 'patch' },\n[15:46:19][Step 8/8]      { type: 'ci', release: 'patch' },\n[15:46:19][Step 8/8]      { type: 'chore', release: 'patch' } ] }\n[15:46:19][Step 8/8] 2019-01-09T15:46:19.463Z semantic-release:plugins options for @semantic-release/release-notes-generator/generateNotes: {}\n[15:46:19][Step 8/8] 2019-01-09T15:46:19.466Z semantic-release:plugins options for @semantic-release/changelog/prepare: {}\n[15:46:19][Step 8/8] 2019-01-09T15:46:19.466Z semantic-release:plugins options for @semantic-release/npm/prepare: {}\n[15:46:19][Step 8/8] [15:46:19] [semantic-release] \u203a \u2714  Loaded plugin \"prepare\" from \"@semantic-release/git\"\n[15:46:19][Step 8/8] [15:46:19] [semantic-release] \u203a \u2714  Loaded plugin \"publish\" from \"@semantic-release/npm\"\n[15:46:19][Step 8/8] [15:46:19] [semantic-release] \u203a \u2714  Loaded plugin \"publish\" from \"@semantic-release/github\"\n[15:46:19][Step 8/8] [15:46:19] [semantic-release] \u203a \u2714  Loaded plugin \"addChannel\" from \"@semantic-release/npm\"\n[15:46:19][Step 8/8] [15:46:19] [semantic-release] \u203a \u2714  Loaded plugin \"addChannel\" from \"@semantic-release/github\"\n[15:46:19][Step 8/8] [15:46:19] [semantic-release] \u203a \u2714  Loaded plugin \"success\" from \"@semantic-release/github\"\n[15:46:19][Step 8/8] [15:46:19] [semantic-release] \u203a \u2714  Loaded plugin \"fail\" from \"@semantic-release/github\"\n[15:46:19][Step 8/8] 2019-01-09T15:46:19.479Z semantic-release:plugins options for @semantic-release/git/prepare: { assets: [ 'CHANGELOG.md', 'package.json', 'package-lock.json' ],\n[15:46:19][Step 8/8]   message: 'chore(release): ${nextRelease.version} [skip ci]\\n\\n${nextRelease.notes}' }\n[15:46:19][Step 8/8] 2019-01-09T15:46:19.480Z semantic-release:plugins options for @semantic-release/npm/publish: {}\n[15:46:19][Step 8/8] 2019-01-09T15:46:19.480Z semantic-release:plugins options for @semantic-release/github/publish: {}\n[15:46:19][Step 8/8] 2019-01-09T15:46:19.480Z semantic-release:plugins options for @semantic-release/npm/addChannel: {}\n[15:46:19][Step 8/8] 2019-01-09T15:46:19.481Z semantic-release:plugins options for @semantic-release/github/addChannel: {}\n[15:46:19][Step 8/8] 2019-01-09T15:46:19.481Z semantic-release:plugins options for @semantic-release/github/success: {}\n[15:46:19][Step 8/8] 2019-01-09T15:46:19.481Z semantic-release:plugins options for @semantic-release/github/fail: {}\n[15:46:23][Step 8/8] 2019-01-09T15:46:23.203Z semantic-release:get-tags found tags: []\n[15:46:23][Step 8/8] 2019-01-09T15:46:23.203Z semantic-release:get-tags found tags for branch master: []\n[15:46:23][Step 8/8] 2019-01-09T15:46:23.204Z semantic-release:get-tags found tags for branch alpha: []\n[15:46:23][Step 8/8] [15:46:23] [semantic-release] \u203a \u2714  Run automated release from branch alpha\n[15:46:25][Step 8/8] [15:46:25] [semantic-release] \u203a \u2714  Allowed to push to the Git repository\n[15:46:25][Step 8/8] [15:46:25] [semantic-release] \u203a \u2139  Start step \"verifyConditions\" of plugin \"@semantic-release/npm\"\n[15:46:25][Step 8/8] [15:46:25] [semantic-release] [@semantic-release/npm] \u203a \u2139  Verify authentication for registry https://packages.OWNER.com/repository/npm-private-client/\n[15:46:25][Step 8/8] [15:46:25] [semantic-release] [@semantic-release/npm] \u203a \u2139  Wrote NPM_TOKEN to /home/centos/buildAgent/work/df162c7dd0c21ff7/.npmrc\n[15:46:25][Step 8/8] [15:46:25] [semantic-release] \u203a \u2714  Completed step \"verifyConditions\" of plugin \"@semantic-release/npm\"\n[15:46:25][Step 8/8] [15:46:25] [semantic-release] \u203a \u2139  Start step \"verifyConditions\" of plugin \"@semantic-release/github\"\n[15:46:25][Step 8/8] [15:46:25] [semantic-release] [@semantic-release/github] \u203a \u2139  Verify GitHub authentication\n[15:46:26][Step 8/8] [15:46:26] [semantic-release] \u203a \u2714  Completed step \"verifyConditions\" of plugin \"@semantic-release/github\"\n[15:46:26][Step 8/8] [15:46:26] [semantic-release] \u203a \u2139  No git tag version found on branch alpha\n[15:46:26][Step 8/8] [15:46:26] [semantic-release] \u203a \u2139  No previous release found, retrieving all commits\n[15:46:26][Step 8/8] [15:46:26] [semantic-release] \u203a \u2139  Found 16 commits since last release\n[15:46:26][Step 8/8] [15:46:26] [semantic-release] \u203a \u2139  Start step \"analyzeCommits\" of plugin \"@semantic-release/commit-analyzer\"\n[15:46:26][Step 8/8] 2019-01-09T15:46:26.475Z semantic-release:get-commits Parsed commits: [ { commit: { long: '10c3f2dd4cb749d995703cfcc1df1ec893ac40f4', short: '10c3f2d' }, tree: { long: '3ee7be89c537d4ff23debd3b92cfb59aa8e3e132', short: '3ee7be8' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-09T15:42:18.000Z }, committer: { name: 'GitHub', email: 'noreply@github.com', date: 2019-01-09T15:42:18.000Z }, subject: 'Merge pull request #7 from OWNER_NAME/PI-6517/add-branch-to-release-config', body: 'build(semantic-release): Added branch to alpha config', hash: '10c3f2dd4cb749d995703cfcc1df1ec893ac40f4', committerDate: 2019-01-09T15:42:18.000Z, message: 'Merge pull request #7 from OWNER_NAME/PI-6517/add-branch-to-release-config\\n\\nbuild(semantic-release): Added branch to alpha config', gitTags: '(HEAD -> alpha, origin/alpha)' }, { commit: { long: '868599be7524714cc1aeecdbe2b84b892602c645', short: '868599b' }, tree: { long: '3ee7be89c537d4ff23debd3b92cfb59aa8e3e132', short: '3ee7be8' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-09T15:39:55.000Z }, committer: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-09T15:39:55.000Z }, subject: 'build(semantic-release): Added branch to alpha config', body: '', hash: '868599be7524714cc1aeecdbe2b84b892602c645', committerDate: 2019-01-09T15:39:55.000Z, message: 'build(semantic-release): Added branch to alpha config', gitTags: '' }, { commit: { long: '3ad9a845c40f2600b3480ac73a98e827859d120e', short: '3ad9a84' }, tree: { long: '516cf5b54dbab825f99c7c0a8dc400b0add27df3', short: '516cf5b' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-09T15:19:36.000Z }, committer: { name: 'GitHub', email: 'noreply@github.com', date: 2019-01-09T15:19:36.000Z }, subject: 'Merge pull request #6 from OWNER_NAME/PI-6517/correct-typings', body: 'build(types): Prevent spec types being output do the dist', hash: '3ad9a845c40f2600b3480ac73a98e827859d120e', committerDate: 2019-01-09T15:19:36.000Z, message: 'Merge pull request #6 from OWNER_NAME/PI-6517/correct-typings\\n\\nbuild(types): Prevent spec types being output do the dist', gitTags: '' }, { commit: { long: 'f3cb0c454380b3089ae05f0ecd444092164fb954', short: 'f3cb0c4' }, tree: { long: '516cf5b54dbab825f99c7c0a8dc400b0add27df3', short: '516cf5b' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-09T15:16:12.000Z }, committer: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-09T15:16:12.000Z }, subject: 'build(types): Prevent spec types being output do the dist', body: '', hash: 'f3cb0c454380b3089ae05f0ecd444092164fb954', committerDate: 2019-01-09T15:16:12.000Z, message: 'build(types): Prevent spec types being output do the dist', gitTags: '' }, { commit: { long: 'f12bf7a03d1bc69cac2e95a619de4b5734ed8492', short: 'f12bf7a' }, tree: { long: '75fc7ea05473f91989e6c421cacff3514e7d0922', short: '75fc7ea' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-09T14:27:58.000Z }, committer: { name: 'GitHub', email: 'noreply@github.com', date: 2019-01-09T14:27:58.000Z }, subject: 'Merge pull request #5 from OWNER_NAME/PI-6517/harden-publish-config', body: 'build(npm): Added publish config with the registry', hash: 'f12bf7a03d1bc69cac2e95a619de4b5734ed8492', committerDate: 2019-01-09T14:27:58.000Z, message: 'Merge pull request #5 from OWNER_NAME/PI-6517/harden-publish-config\\n\\nbuild(npm): Added publish config with the registry', gitTags: '' }, { commit: { long: '5a0e6e055eb49dc824a861d05b4807b9501e47fa', short: '5a0e6e0' }, tree: { long: '75fc7ea05473f91989e6c421cacff3514e7d0922', short: '75fc7ea' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-09T13:35:19.000Z }, committer: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-09T13:35:19.000Z }, subject: 'build(npm): Added publish config with the registry', body: '', hash: '5a0e6e055eb49dc824a861d05b4807b9501e47fa', committerDate: 2019-01-09T13:35:19.000Z, message: 'build(npm): Added publish config with the registry', gitTags: '' }, { commit: { long: '6b808a124cbcbb3eef407c4b3f9940b86dc8d909', short: '6b808a1' }, tree: { long: '7b91ef22a4389de9699b711ff048029f917211dd', short: '7b91ef2' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-09T10:26:22.000Z }, committer: { name: 'GitHub', email: 'noreply@github.com', date: 2019-01-09T10:26:22.000Z }, subject: 'Merge pull request #4 from OWNER_NAME/PI-6517/allow-alpha-releases', body: 'build(semantic-release): Allow releases from an alpha branch', hash: '6b808a124cbcbb3eef407c4b3f9940b86dc8d909', committerDate: 2019-01-09T10:26:22.000Z, message: 'Merge pull request #4 from OWNER_NAME/PI-6517/allow-alpha-releases\\n\\nbuild(semantic-release): Allow releases from an alpha branch', gitTags: '' }, { commit: { long: 'b12a416497fe272b009cc0edac3987da1a8fdb4e', short: 'b12a416' }, tree: { long: '7b91ef22a4389de9699b711ff048029f917211dd', short: '7b91ef2' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-08T17:13:08.000Z }, committer: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-09T09:55:04.000Z }, subject: 'build(semantic-release): Allow releases from an alpha branch', body: '', hash: 'b12a416497fe272b009cc0edac3987da1a8fdb4e', committerDate: 2019-01-09T09:55:04.000Z, message: 'build(semantic-release): Allow releases from an alpha branch', gitTags: '' }, { commit: { long: '17c33c9c5e64d1967e9641c7a06b6de0a9c404a8', short: '17c33c9' }, tree: { long: 'e74209682d33fd1fb5569e0319b660cb395e0c87', short: 'e742096' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-08T16:34:37.000Z }, committer: { name: 'GitHub', email: 'noreply@github.com', date: 2019-01-08T16:34:37.000Z }, subject: 'Merge pull request #3 from OWNER_NAME/PI-6517/update-package-name', body: 'chore(repo): Updated package name and move release config to separate\u2026', hash: '17c33c9c5e64d1967e9641c7a06b6de0a9c404a8', committerDate: 2019-01-08T16:34:37.000Z, message: 'Merge pull request #3 from OWNER_NAME/PI-6517/update-package-name\\n\\nchore(repo): Updated package name and move release config to separate\u2026', gitTags: '(origin/master, master)' }, { commit: { long: '7182c5b11a60062b7d471e9647b0770c2a73cd7d', short: '7182c5b' }, tree: { long: 'e74209682d33fd1fb5569e0319b660cb395e0c87', short: 'e742096' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-08T16:29:44.000Z }, committer: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-08T16:30:33.000Z }, subject: 'chore(repo): Updated package name and move release config to separate file', body: '', hash: '7182c5b11a60062b7d471e9647b0770c2a73cd7d', committerDate: 2019-01-08T16:30:33.000Z, message: 'chore(repo): Updated package name and move release config to separate file', gitTags: '' }, { commit: { long: '501e6bc1fdf86ec515356562ab3fd0289467a193', short: '501e6bc' }, tree: { long: '9e516dd85055ec2b9d454bb17aa5118dd4ccd216', short: '9e516dd' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-08T15:18:21.000Z }, committer: { name: 'GitHub', email: 'noreply@github.com', date: 2019-01-08T15:18:21.000Z }, subject: 'Merge pull request #1 from OWNER_NAME/PI-6517/update-coverage-threshold', body: 'chore(config): Updated jest config for a higher coverage threshold', hash: '501e6bc1fdf86ec515356562ab3fd0289467a193', committerDate: 2019-01-08T15:18:21.000Z, message: 'Merge pull request #1 from OWNER_NAME/PI-6517/update-coverage-threshold\\n\\nchore(config): Updated jest config for a higher coverage threshold', gitTags: '' }, { commit: { long: 'e58ff83deb32e44b59641915075cca7c02ce95be', short: 'e58ff83' }, tree: { long: '9e516dd85055ec2b9d454bb17aa5118dd4ccd216', short: '9e516dd' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-08T11:14:01.000Z }, committer: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-08T15:16:08.000Z }, subject: 'chore(config): Updated jest config for a higher coverage threshold', body: '', hash: 'e58ff83deb32e44b59641915075cca7c02ce95be', committerDate: 2019-01-08T15:16:08.000Z, message: 'chore(config): Updated jest config for a higher coverage threshold', gitTags: '' }, { commit: { long: '9c7bd1d5fe6c90aaf9751d1fac54443d4be2fbfe', short: '9c7bd1d' }, tree: { long: '6a8c87e83d0cf0f9f23091a9848e2430ed2d9bf0', short: '6a8c87e' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-08T14:52:33.000Z }, committer: { name: 'GitHub', email: 'noreply@github.com', date: 2019-01-08T14:52:33.000Z }, subject: 'Merge pull request #2 from OWNER_NAME/PI-6517/add-bash-scripts-to-enforce-node-version', body: 'build(npm): Check node version before scripts are executed', hash: '9c7bd1d5fe6c90aaf9751d1fac54443d4be2fbfe', committerDate: 2019-01-08T14:52:33.000Z, message: 'Merge pull request #2 from OWNER_NAME/PI-6517/add-bash-scripts-to-enforce-node-version\\n\\nbuild(npm): Check node version before scripts are executed', gitTags: '' }, { commit: { long: 'e8b0ef1691207473f20b23741b07e1ffa6317cf5', short: 'e8b0ef1' }, tree: { long: '6a8c87e83d0cf0f9f23091a9848e2430ed2d9bf0', short: '6a8c87e' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-08T14:30:06.000Z }, committer: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-08T14:30:06.000Z }, subject: 'build(npm): Added lint command', body: '', hash: 'e8b0ef1691207473f20b23741b07e1ffa6317cf5', committerDate: 2019-01-08T14:30:06.000Z, message: 'build(npm): Added lint command', gitTags: '' }, { commit: { long: '05c44e30d5e3ea7a2486287eabefd29da99ff51f', short: '05c44e3' }, tree: { long: 'e404f634a430d033293139e14cec9b161508d7a9', short: 'e404f63' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-08T13:48:29.000Z }, committer: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-08T13:48:29.000Z }, subject: 'build(npm): Check node version before scripts are executed', body: '', hash: '05c44e30d5e3ea7a2486287eabefd29da99ff51f', committerDate: 2019-01-08T13:48:29.000Z, message: 'build(npm): Check node version before scripts are executed', gitTags: '' }, { commit: { long: '6d080bd9d7d3b23c5e078f707742296fff4330f2', short: '6d080bd' }, tree: { long: '734ecb414d0f3335a40e562c06fb8a4c875a4fe1', short: '734ecb4' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-07T16:58:38.000Z }, committer: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-07T17:00:04.000Z }, subject: 'build(repo): Initial setup of the project/repo', body: '', hash: '6d080bd9d7d3b23c5e078f707742296fff4330f2', committerDate: 2019-01-07T17:00:04.000Z, message: 'build(repo): Initial setup of the project/repo', gitTags: '' } ]\n[15:46:26][Step 8/8] [15:46:26] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: Merge pull request #7 from OWNER_NAME/PI-6517/add-branch-to-release-config\n[15:46:26][Step 8/8] \n[15:46:26][Step 8/8] build(semantic-release): Added branch to alpha config\n[15:46:26][Step 8/8] 2019-01-09T15:46:26.491Z semantic-release:commit-analyzer Analyzing with custom rules\n[15:46:26][Step 8/8] 2019-01-09T15:46:26.491Z semantic-release:commit-analyzer Analyzing with default rules\n[15:46:26][Step 8/8] 2019-01-09T15:46:26.492Z semantic-release:commit-analyzer Analyzing with custom rules\n[15:46:26][Step 8/8] [15:46:26] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The commit should not trigger a release\n[15:46:26][Step 8/8] [15:46:26] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: build(semantic-release): Added branch to alpha config\n[15:46:26][Step 8/8] 2019-01-09T15:46:26.493Z semantic-release:commit-analyzer The rule { type: 'build', release: 'patch' } match commit with release type 'patch'\n[15:46:26][Step 8/8] 2019-01-09T15:46:26.493Z semantic-release:commit-analyzer Analyzing with custom rules\n[15:46:26][Step 8/8] 2019-01-09T15:46:26.493Z semantic-release:commit-analyzer Analyzing with default rules\n[15:46:26][Step 8/8] 2019-01-09T15:46:26.493Z semantic-release:commit-analyzer Analyzing with custom rules\n[15:46:26][Step 8/8] 2019-01-09T15:46:26.493Z semantic-release:commit-analyzer The rule { type: 'build', release: 'patch' } match commit with release type 'patch'\n[15:46:26][Step 8/8] 2019-01-09T15:46:26.494Z semantic-release:commit-analyzer Analyzing with custom rules\n[15:46:26][Step 8/8] 2019-01-09T15:46:26.494Z semantic-release:commit-analyzer Analyzing with default rules\n[15:46:26][Step 8/8] 2019-01-09T15:46:26.494Z semantic-release:commit-analyzer Analyzing with custom rules\n[15:46:26][Step 8/8] 2019-01-09T15:46:26.494Z semantic-release:commit-analyzer The rule { type: 'build', release: 'patch' } match commit with release type 'patch'\n[15:46:26][Step 8/8] [15:46:26] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The release type for the commit is patch\n[15:46:26][Step 8/8] [15:46:26] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: Merge pull request #6 from OWNER_NAME/PI-6517/correct-typings\n[15:46:26][Step 8/8] \n[15:46:26][Step 8/8] build(types): Prevent spec types being output do the dist\n[15:46:26][Step 8/8] [15:46:26] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The commit should not trigger a release\n[15:46:26][Step 8/8] [15:46:26] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: build(types): Prevent spec types being output do the dist\n[15:46:26][Step 8/8] [15:46:26] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The release type for the commit is patch\n[15:46:26][Step 8/8] [15:46:26] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: Merge pull request #5 from OWNER_NAME/PI-6517/harden-publish-config\n[15:46:26][Step 8/8] \n[15:46:26][Step 8/8] build(npm): Added publish config with the registry\n[15:46:26][Step 8/8] [15:46:26] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The commit should not trigger a release\n[15:46:26][Step 8/8] [15:46:26] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: build(npm): Added publish config with the registry\n[15:46:26][Step 8/8] [15:46:26] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The release type for the commit is patch\n[15:46:26][Step 8/8] [15:46:26] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: Merge pull request #4 from OWNER_NAME/PI-6517/allow-alpha-releases\n[15:46:26][Step 8/8] \n[15:46:26][Step 8/8] build(semantic-release): Allow releases from an alpha branch\n[15:46:26][Step 8/8] [15:46:26] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The commit should not trigger a release\n[15:46:26][Step 8/8] [15:46:26] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: build(semantic-release): Allow releases from an alpha branch\n[15:46:26][Step 8/8] [15:46:26] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The release type for the commit is patch\n[15:46:26][Step 8/8] [15:46:26] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: Merge pull request #3 from OWNER_NAME/PI-6517/update-package-name\n[15:46:26][Step 8/8] \n[15:46:26][Step 8/8] chore(repo): Updated package name and move release config to separate\u2026\n[15:46:26][Step 8/8] [15:46:26] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The commit should not trigger a release\n[15:46:26][Step 8/8] [15:46:26] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: chore(repo): Updated package name and move release config to separate file\n[15:46:26][Step 8/8] [15:46:26] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The release type for the commit is patch\n[15:46:26][Step 8/8] [15:46:26] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: Merge pull request #1 from OWNER_NAME/PI-6517/update-coverage-threshold\n[15:46:26][Step 8/8] \n[15:46:26][Step 8/8] chore(config): Updated jest config for a higher coverage threshold\n[15:46:26][Step 8/8] [15:46:26] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The commit should not trigger a release\n[15:46:26][Step 8/8] [15:46:26] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: chore(config): Updated jest config for a higher coverage threshold\n[15:46:26][Step 8/8] [15:46:26] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The release type for the commit is patch\n[15:46:26][Step 8/8] [15:46:26] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: Merge pull request #2 from OWNER_NAME/PI-6517/add-bash-scripts-to-enforce-node-version\n[15:46:26][Step 8/8] \n[15:46:26][Step 8/8] build(npm): Check node version before scripts are executed\n[15:46:26][Step 8/8] [15:46:26] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The commit should not trigger a release\n[15:46:26][Step 8/8] [15:46:26] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: build(npm): Added lint command\n[15:46:26][Step 8/8] [15:46:26] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The release type for the commit is patch\n[15:46:26][Step 8/8] [15:46:26] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: build(npm): Check node version before scripts are executed\n[15:46:26][Step 8/8] [15:46:26] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The release type for the commit is patch\n[15:46:26][Step 8/8] [15:46:26] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: build(repo): Initial setup of the project/repo\n[15:46:26][Step 8/8] [15:46:26] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The release type for the commit is patch\n[15:46:26][Step 8/8] [15:46:26] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analysis of 16 commits complete: patch release\n[15:46:26][Step 8/8] [15:46:26] [semantic-release] \u203a \u2714  Completed step \"analyzeCommits\" of plugin \"@semantic-release/commit-analyzer\"\n[15:46:26][Step 8/8] 2019-01-09T15:46:26.494Z semantic-release:commit-analyzer Analyzing with custom rules\n[15:46:26][Step 8/8] 2019-01-09T15:46:26.495Z semantic-release:commit-analyzer Analyzing with default rules\n[15:46:26][Step 8/8] 2019-01-09T15:46:26.495Z semantic-release:commit-analyzer Analyzing with custom rules\n[15:46:26][Step 8/8] 2019-01-09T15:46:26.495Z semantic-release:commit-analyzer The rule { type: 'build', release: 'patch' } match commit with release type 'patch'\n[15:46:26][Step 8/8] 2019-01-09T15:46:26.495Z semantic-release:commit-analyzer Analyzing with custom rules\n[15:46:26][Step 8/8] 2019-01-09T15:46:26.495Z semantic-release:commit-analyzer Analyzing with default rules\n[15:46:26][Step 8/8] 2019-01-09T15:46:26.496Z semantic-release:commit-analyzer Analyzing with custom rules\n[15:46:26][Step 8/8] 2019-01-09T15:46:26.496Z semantic-release:commit-analyzer The rule { type: 'chore', release: 'patch' } match commit with release type 'patch'\n[15:46:26][Step 8/8] 2019-01-09T15:46:26.496Z semantic-release:commit-analyzer Analyzing with custom rules\n[15:46:26][Step 8/8] 2019-01-09T15:46:26.496Z semantic-release:commit-analyzer Analyzing with default rules\n[15:46:26][Step 8/8] 2019-01-09T15:46:26.496Z semantic-release:commit-analyzer Analyzing with custom rules\n[15:46:26][Step 8/8] 2019-01-09T15:46:26.496Z semantic-release:commit-analyzer The rule { type: 'chore', release: 'patch' } match commit with release type 'patch'\n[15:46:26][Step 8/8] 2019-01-09T15:46:26.497Z semantic-release:commit-analyzer Analyzing with custom rules\n[15:46:26][Step 8/8] 2019-01-09T15:46:26.497Z semantic-release:commit-analyzer Analyzing with default rules\n[15:46:26][Step 8/8] 2019-01-09T15:46:26.497Z semantic-release:commit-analyzer Analyzing with custom rules\n[15:46:26][Step 8/8] 2019-01-09T15:46:26.497Z semantic-release:commit-analyzer The rule { type: 'build', release: 'patch' } match commit with release type 'patch'\n[15:46:26][Step 8/8] 2019-01-09T15:46:26.497Z semantic-release:commit-analyzer Analyzing with custom rules\n[15:46:26][Step 8/8] 2019-01-09T15:46:26.497Z semantic-release:commit-analyzer The rule { type: 'build', release: 'patch' } match commit with release type 'patch'\n[15:46:26][Step 8/8] 2019-01-09T15:46:26.498Z semantic-release:commit-analyzer Analyzing with custom rules\n[15:46:26][Step 8/8] 2019-01-09T15:46:26.498Z semantic-release:commit-analyzer The rule { type: 'build', release: 'patch' } match commit with release type 'patch'\n[15:46:26][Step 8/8] [15:46:26] [semantic-release] \u203a \u2139  There is no previous release, the next release version is 1.0.0-alpha.1\n[15:46:26][Step 8/8] [15:46:26] [semantic-release] \u203a \u2139  Start step \"generateNotes\" of plugin \"@semantic-release/release-notes-generator\"\n[15:46:26][Step 8/8] 2019-01-09T15:46:26.515Z semantic-release:release-notes-generator version: '1.0.0-alpha.1'\n[15:46:26][Step 8/8] 2019-01-09T15:46:26.515Z semantic-release:release-notes-generator host: 'github.com'\n[15:46:26][Step 8/8] 2019-01-09T15:46:26.515Z semantic-release:release-notes-generator owner: 'OWNER_NAME'\n[15:46:26][Step 8/8] 2019-01-09T15:46:26.515Z semantic-release:release-notes-generator repository: 'REPO_NAME'\n[15:46:26][Step 8/8] 2019-01-09T15:46:26.515Z semantic-release:release-notes-generator previousTag: undefined\n[15:46:26][Step 8/8] 2019-01-09T15:46:26.515Z semantic-release:release-notes-generator currentTag: 'v1.0.0-alpha.1@alpha'\n[15:46:26][Step 8/8] [15:46:26] [semantic-release] \u203a \u2714  Completed step \"generateNotes\" of plugin \"@semantic-release/release-notes-generator\"\n[15:46:26][Step 8/8] [15:46:26] [semantic-release] \u203a \u2139  Start step \"prepare\" of plugin \"@semantic-release/changelog\"\n[15:46:26][Step 8/8] [15:46:26] [semantic-release] [@semantic-release/changelog] \u203a \u2139  Create /home/centos/buildAgent/work/df162c7dd0c21ff7/CHANGELOG.md\n[15:46:26][Step 8/8] [15:46:26] [semantic-release] \u203a \u2714  Completed step \"prepare\" of plugin \"@semantic-release/changelog\"\n[15:46:26][Step 8/8] [15:46:26] [semantic-release] \u203a \u2139  Start step \"prepare\" of plugin \"@semantic-release/npm\"\n[15:46:26][Step 8/8] [15:46:26] [semantic-release] [@semantic-release/npm] \u203a \u2139  Write version 1.0.0-alpha.1 to package.json in /home/centos/buildAgent/work/df162c7dd0c21ff7\n[15:46:26][Step 8/8] v1.0.0-alpha.1\n[15:46:26][Step 8/8] [15:46:26] [semantic-release] \u203a \u2714  Completed step \"prepare\" of plugin \"@semantic-release/npm\"\n[15:46:26][Step 8/8] [15:46:26] [semantic-release] \u203a \u2139  Start step \"prepare\" of plugin \"@semantic-release/git\"\n[15:46:26][Step 8/8] 2019-01-09T15:46:26.943Z semantic-release:git globed assets: [ 'CHANGELOG.md', 'package.json', 'package-lock.json' ]\n[15:46:26][Step 8/8] [15:46:26] [semantic-release] [@semantic-release/git] \u203a \u2139  Found 3 file(s) to commit\n[15:46:26][Step 8/8] 2019-01-09T15:46:26.972Z semantic-release:git add file to git index { stdout: '',\n[15:46:26][Step 8/8]   stderr: '',\n[15:46:26][Step 8/8]   code: 0,\n[15:46:26][Step 8/8]   failed: false,\n[15:46:26][Step 8/8]   killed: false,\n[15:46:26][Step 8/8]   signal: null,\n[15:46:26][Step 8/8]   cmd: 'git add --force --ignore-errors CHANGELOG.md package-lock.json package.json',\n[15:46:26][Step 8/8]   timedOut: false }\n[15:46:26][Step 8/8] 2019-01-09T15:46:26.973Z semantic-release:git commited files: [ 'CHANGELOG.md', 'package-lock.json', 'package.json' ]\n[15:46:30][Step 8/8] [15:46:30] [semantic-release] [@semantic-release/git] \u203a \u2139  Prepared Git release: v1.0.0-alpha.1@alpha\n[15:46:30][Step 8/8] [15:46:30] [semantic-release] \u203a \u2714  Completed step \"prepare\" of plugin \"@semantic-release/git\"\n[15:46:30][Step 8/8] [15:46:30] [semantic-release] \u203a \u2139  Start step \"generateNotes\" of plugin \"@semantic-release/release-notes-generator\"\n[15:46:30][Step 8/8] 2019-01-09T15:46:30.530Z semantic-release:release-notes-generator version: '1.0.0-alpha.1'\n[15:46:30][Step 8/8] 2019-01-09T15:46:30.530Z semantic-release:release-notes-generator host: 'github.com'\n[15:46:30][Step 8/8] 2019-01-09T15:46:30.530Z semantic-release:release-notes-generator owner: 'OWNER_NAME'\n[15:46:30][Step 8/8] 2019-01-09T15:46:30.530Z semantic-release:release-notes-generator repository: 'REPO_NAME'\n[15:46:30][Step 8/8] 2019-01-09T15:46:30.530Z semantic-release:release-notes-generator previousTag: undefined\n[15:46:30][Step 8/8] 2019-01-09T15:46:30.530Z semantic-release:release-notes-generator currentTag: 'v1.0.0-alpha.1@alpha'\n[15:46:30][Step 8/8] [15:46:30] [semantic-release] \u203a \u2714  Completed step \"generateNotes\" of plugin \"@semantic-release/release-notes-generator\"\n[15:46:34][Step 8/8] [15:46:34] [semantic-release] \u203a \u2714  Created tag v1.0.0-alpha.1@alpha\n[15:46:34][Step 8/8] [15:46:34] [semantic-release] \u203a \u2139  Start step \"publish\" of plugin \"@semantic-release/npm\"\n[15:46:34][Step 8/8] [15:46:34] [semantic-release] [@semantic-release/npm] \u203a \u2139  Publishing version 1.0.0-alpha.1 to npm registry on dist-tag alpha\n[15:46:34][Step 8/8] npm notice \n[15:46:34][Step 8/8] npm notice     @NAMESPACE/PACKAGE_NAME@1.0.0-alpha.1\n[15:46:34][Step 8/8] npm notice === Tarball Contents === \n[15:46:34][Step 8/8] npm notice 2.1kB package.json           \n[15:46:34][Step 8/8] npm notice 29B   CHANGELOG.md           \n[15:46:34][Step 8/8] npm notice 767B  node-version-check.js  \n[15:46:34][Step 8/8] npm notice 45B   README.md              \n[15:46:34][Step 8/8] npm notice 1.3kB dist/main.min.js       \n[15:46:34][Step 8/8] npm notice 53B   dist/types/example.d.ts\n[15:46:34][Step 8/8] npm notice 27B   dist/types/index.d.ts  \n[15:46:34][Step 8/8] npm notice === Tarball Details === \n[15:46:34][Step 8/8] npm notice name:          @NAMESPACE/PACKAGE_NAME\n[15:46:34][Step 8/8] npm notice version:       1.0.0-alpha.1                              \n[15:46:34][Step 8/8] npm notice package size:  2.0 kB                                     \n[15:46:34][Step 8/8] npm notice unpacked size: 4.3 kB                                     \n[15:46:34][Step 8/8] npm notice shasum:        8d2a8140821ab42f1c55a9abefc6ef09325836b3   \n[15:46:34][Step 8/8] npm notice integrity:     sha512-fJ2XoCJ9X2nq/[...]7/lEmNm97e78A==   \n[15:46:34][Step 8/8] npm notice total files:   7                                          \n[15:46:34][Step 8/8] npm notice \n[15:46:34][Step 8/8] + @NAMESPACE/PACKAGE_NAME@1.0.0-alpha.1\n[15:46:34][Step 8/8] [15:46:34] [semantic-release] [@semantic-release/npm] \u203a \u2139  Published @NAMESPACE/PACKAGE_NAME@1.0.0-alpha.1 to https://packages.OWNER.com/repository/npm-private-client/\n[15:46:34][Step 8/8] [15:46:34] [semantic-release] \u203a \u2714  Completed step \"publish\" of plugin \"@semantic-release/npm\"\n[15:46:34][Step 8/8] [15:46:34] [semantic-release] \u203a \u2139  Start step \"publish\" of plugin \"@semantic-release/github\"\n[15:46:34][Step 8/8] 2019-01-09T15:46:34.873Z semantic-release:github release owner: 'OWNER_NAME'\n[15:46:34][Step 8/8] 2019-01-09T15:46:34.874Z semantic-release:github release repo: 'REPO_NAME'\n[15:46:34][Step 8/8] 2019-01-09T15:46:34.874Z semantic-release:github release tag_name: undefined\n[15:46:34][Step 8/8] 2019-01-09T15:46:34.874Z semantic-release:github release name: 'v1.0.0-alpha.1'\n[15:46:34][Step 8/8] 2019-01-09T15:46:34.874Z semantic-release:github release prerelease: true\n[15:46:35][Step 8/8] [15:46:35] [semantic-release] [@semantic-release/github] \u203a \u2139  Published GitHub release: https://github.com/OWNER_NAME/REPO_NAME/releases/tag/v1.0.0-alpha.1%40alpha\n[15:46:35][Step 8/8] [15:46:35] [semantic-release] \u203a \u2714  Completed step \"publish\" of plugin \"@semantic-release/github\"\n[15:46:35][Step 8/8] [15:46:35] [semantic-release] \u203a \u2139  Start step \"success\" of plugin \"@semantic-release/github\"\n[15:46:49][Step 8/8] 2019-01-09T15:46:49.483Z semantic-release:github found pull requests: [ 6, 7, 5, 4, 1, 3, 2 ]\n[15:46:49][Step 8/8] 2019-01-09T15:46:49.496Z semantic-release:github found issues via comments: []\n[15:46:49][Step 8/8] 2019-01-09T15:46:49.497Z semantic-release:github create comment: { owner: 'OWNER_NAME',\n[15:46:49][Step 8/8]   repo: 'REPO_NAME',\n[15:46:49][Step 8/8]   number: 6,\n[15:46:49][Step 8/8]   body: ':tada: This PR is included in version 1.0.0-alpha.1 :tada:\\n\\nThe release is available on:\\n- `npm package (@alpha dist-tag)`\\n- [GitHub release](https://github.com/OWNER_NAME/REPO_NAME/releases/tag/v1.0.0-alpha.1%40alpha)\\n\\nYour **[semantic-release](https://github.com/semantic-release/semantic-release)** bot :package::rocket:' }\n[15:46:49][Step 8/8] 2019-01-09T15:46:49.497Z semantic-release:github create comment: { owner: 'OWNER_NAME',\n[15:46:49][Step 8/8]   repo: 'REPO_NAME',\n[15:46:49][Step 8/8]   number: 7,\n[15:46:49][Step 8/8]   body: ':tada: This PR is included in version 1.0.0-alpha.1 :tada:\\n\\nThe release is available on:\\n- `npm package (@alpha dist-tag)`\\n- [GitHub release](https://github.com/OWNER_NAME/REPO_NAME/releases/tag/v1.0.0-alpha.1%40alpha)\\n\\nYour **[semantic-release](https://github.com/semantic-release/semantic-release)** bot :package::rocket:' }\n[15:46:49][Step 8/8] 2019-01-09T15:46:49.497Z semantic-release:github create comment: { owner: 'OWNER_NAME',\n[15:46:49][Step 8/8]   repo: 'REPO_NAME',\n[15:46:49][Step 8/8]   number: 5,\n[15:46:49][Step 8/8]   body: ':tada: This PR is included in version 1.0.0-alpha.1 :tada:\\n\\nThe release is available on:\\n- `npm package (@alpha dist-tag)`\\n- [GitHub release](https://github.com/OWNER_NAME/REPO_NAME/releases/tag/v1.0.0-alpha.1%40alpha)\\n\\nYour **[semantic-release](https://github.com/semantic-release/semantic-release)** bot :package::rocket:' }\n[15:46:49][Step 8/8] 2019-01-09T15:46:49.497Z semantic-release:github create comment: { owner: 'OWNER_NAME',\n[15:46:49][Step 8/8]   repo: 'REPO_NAME',\n[15:46:49][Step 8/8]   number: 4,\n[15:46:49][Step 8/8]   body: ':tada: This PR is included in version 1.0.0-alpha.1 :tada:\\n\\nThe release is available on:\\n- `npm package (@alpha dist-tag)`\\n- [GitHub release](https://github.com/OWNER_NAME/REPO_NAME/releases/tag/v1.0.0-alpha.1%40alpha)\\n\\nYour **[semantic-release](https://github.com/semantic-release/semantic-release)** bot :package::rocket:' }\n[15:46:49][Step 8/8] 2019-01-09T15:46:49.498Z semantic-release:github create comment: { owner: 'OWNER_NAME',\n[15:46:49][Step 8/8]   repo: 'REPO_NAME',\n[15:46:49][Step 8/8]   number: 1,\n[15:46:49][Step 8/8]   body: ':tada: This PR is included in version 1.0.0-alpha.1 :tada:\\n\\nThe release is available on:\\n- `npm package (@alpha dist-tag)`\\n- [GitHub release](https://github.com/OWNER_NAME/REPO_NAME/releases/tag/v1.0.0-alpha.1%40alpha)\\n\\nYour **[semantic-release](https://github.com/semantic-release/semantic-release)** bot :package::rocket:' }\n[15:46:49][Step 8/8] 2019-01-09T15:46:49.498Z semantic-release:github create comment: { owner: 'OWNER_NAME',\n[15:46:49][Step 8/8]   repo: 'REPO_NAME',\n[15:46:49][Step 8/8]   number: 3,\n[15:46:49][Step 8/8]   body: ':tada: This PR is included in version 1.0.0-alpha.1 :tada:\\n\\nThe release is available on:\\n- `npm package (@alpha dist-tag)`\\n- [GitHub release](https://github.com/OWNER_NAME/REPO_NAME/releases/tag/v1.0.0-alpha.1%40alpha)\\n\\nYour **[semantic-release](https://github.com/semantic-release/semantic-release)** bot :package::rocket:' }\n[15:46:49][Step 8/8] 2019-01-09T15:46:49.498Z semantic-release:github create comment: { owner: 'OWNER_NAME',\n[15:46:49][Step 8/8]   repo: 'REPO_NAME',\n[15:46:49][Step 8/8]   number: 2,\n[15:46:49][Step 8/8]   body: ':tada: This PR is included in version 1.0.0-alpha.1 :tada:\\n\\nThe release is available on:\\n- `npm package (@alpha dist-tag)`\\n- [GitHub release](https://github.com/OWNER_NAME/REPO_NAME/releases/tag/v1.0.0-alpha.1%40alpha)\\n\\nYour **[semantic-release](https://github.com/semantic-release/semantic-release)** bot :package::rocket:' }\n[15:46:50][Step 8/8] [15:46:50] [semantic-release] [@semantic-release/github] \u203a \u2139  Added comment to issue #6: https://github.com/OWNER_NAME/REPO_NAME/pull/6#issuecomment-452743841\n[15:46:53][Step 8/8] [15:46:53] [semantic-release] [@semantic-release/github] \u203a \u2139  Added comment to issue #7: https://github.com/OWNER_NAME/REPO_NAME/pull/7#issuecomment-452743857\n[15:46:56][Step 8/8] [15:46:56] [semantic-release] [@semantic-release/github] \u203a \u2139  Added comment to issue #5: https://github.com/OWNER_NAME/REPO_NAME/pull/5#issuecomment-452743875\n[15:46:59][Step 8/8] [15:46:59] [semantic-release] [@semantic-release/github] \u203a \u2139  Added comment to issue #4: https://github.com/OWNER_NAME/REPO_NAME/pull/4#issuecomment-452743899\n[15:47:02][Step 8/8] [15:47:02] [semantic-release] [@semantic-release/github] \u203a \u2139  Added comment to issue #1: https://github.com/OWNER_NAME/REPO_NAME/pull/1#issuecomment-452743917\n[15:47:06][Step 8/8] [15:47:06] [semantic-release] [@semantic-release/github] \u203a \u2139  Added comment to issue #3: https://github.com/OWNER_NAME/REPO_NAME/pull/3#issuecomment-452743934\n[15:47:08][Step 8/8] [15:47:08] [semantic-release] [@semantic-release/github] \u203a \u2139  Added comment to issue #2: https://github.com/OWNER_NAME/REPO_NAME/pull/2#issuecomment-452743955\n[15:47:13][Step 8/8] [15:47:13] [semantic-release] [@semantic-release/github] \u203a \u2139  Added labels [ 'released on @alpha' ] to issue #6\n[15:47:14][Step 8/8] [15:47:14] [semantic-release] [@semantic-release/github] \u203a \u2139  Added labels [ 'released on @alpha' ] to issue #7\n[15:47:17][Step 8/8] [15:47:17] [semantic-release] [@semantic-release/github] \u203a \u2139  Added labels [ 'released on @alpha' ] to issue #5\n[15:47:20][Step 8/8] [15:47:20] [semantic-release] [@semantic-release/github] \u203a \u2139  Added labels [ 'released on @alpha' ] to issue #4\n[15:47:23][Step 8/8] [15:47:23] [semantic-release] [@semantic-release/github] \u203a \u2139  Added labels [ 'released on @alpha' ] to issue #1\n[15:47:26][Step 8/8] [15:47:26] [semantic-release] [@semantic-release/github] \u203a \u2139  Added labels [ 'released on @alpha' ] to issue #3\n[15:47:29][Step 8/8] [15:47:29] [semantic-release] [@semantic-release/github] \u203a \u2139  Added labels [ 'released on @alpha' ] to issue #2\n[15:47:29][Step 8/8] [15:47:29] [semantic-release] \u203a \u2714  Completed step \"success\" of plugin \"@semantic-release/github\"\n[15:47:29][Step 8/8] [15:47:29] [semantic-release] \u203a \u2714  Published release 1.0.0-alpha.1\n[15:47:29][Step 8/8] 2019-01-09T15:47:29.438Z semantic-release:github found semantic-release issues: []\n[15:47:29][Step 8/8] Process exited with code 0. I'm not sure if it's relevant but the CHANGELOG.md file is empty in the undefined branch (apart from the 1.0.0-alpha.1 (2019-01-09) title. Similarly the github release does not have any release notes either. I've noticed that in my package.json I require the plugins explicitly, which are different versions to what semantic-release@16.0.0-beta.16 requires. I will remove my dependencies and try again to make sure there's no oddities going on there. \nI'll also remove the existing tags and package before doing it and I'll record the logs for you.\nI'll report back soon :). Ok so I effectively cleaned the repo - I removed the undefined branch, the release and tag. I had 2 branches (master and alpha) and in the alpha branch the only commits were from me.\nI used semantic-release@16.0.0-beta.16 with the plugins it requires as dependencies along with @semantic-release/changelog@3.0.1 and @semantic-release/git@6.0.1 (we use these versions along with semantic-release@15.8.1 in another project that populates the changelog.md correctly).\nThe results were exactly the same - I now have 3 branches (master, alpha and undefined), the release commit is only on the undefined branch.\nFull logs:\n[23:20:08][Step 8/8] Starting: /home/centos/buildAgent/work/agentTmp/custom_script6566962328248699906\n[23:20:08][Step 8/8] in directory: /home/centos/buildAgent/work/df162c7dd0c21ff7\n[23:20:08][Step 8/8] On branch alpha\n[23:20:08][Step 8/8] Your branch is up to date with 'origin/alpha'.\n[23:20:08][Step 8/8] \n[23:20:08][Step 8/8] nothing to commit, working tree clean\n[23:20:08][Step 8/8] [23:20:08] [semantic-release] \u203a \u2139  Running semantic-release version 16.0.0-beta.16\n[23:20:08][Step 8/8] 2019-01-10T23:20:08.673Z semantic-release:config load config from: /home/centos/buildAgent/work/df162c7dd0c21ff7/.releaserc.json\n[23:20:08][Step 8/8] 2019-01-10T23:20:08.679Z semantic-release:config options values: { branches: \n[23:20:08][Step 8/8]    [ 'master',\n[23:20:08][Step 8/8]      { branch: 'alpha', name: 'alpha', prerelease: true } ],\n[23:20:08][Step 8/8]   repositoryUrl: 'git@github.com:REPO_OWNER/REPO_NAME.git',\n[23:20:08][Step 8/8]   tagFormat: 'v${version}',\n[23:20:08][Step 8/8]   plugins: \n[23:20:08][Step 8/8]    [ '@semantic-release/commit-analyzer',\n[23:20:08][Step 8/8]      '@semantic-release/release-notes-generator',\n[23:20:08][Step 8/8]      '@semantic-release/npm',\n[23:20:08][Step 8/8]      '@semantic-release/github' ],\n[23:20:08][Step 8/8]   generateNotes: [ '@semantic-release/release-notes-generator' ],\n[23:20:08][Step 8/8]   prepare: \n[23:20:08][Step 8/8]    [ '@semantic-release/changelog',\n[23:20:08][Step 8/8]      '@semantic-release/npm',\n[23:20:08][Step 8/8]      { path: '@semantic-release/git',\n[23:20:08][Step 8/8]        assets: [Array],\n[23:20:08][Step 8/8]        message: 'chore(release): ${nextRelease.version} [skip ci]\\n\\n${nextRelease.notes}' } ],\n[23:20:08][Step 8/8]   analyzeCommits: \n[23:20:08][Step 8/8]    { preset: 'angular',\n[23:20:08][Step 8/8]      releaseRules: \n[23:20:08][Step 8/8]       [ [Object],\n[23:20:08][Step 8/8]         [Object],\n[23:20:08][Step 8/8]         [Object],\n[23:20:08][Step 8/8]         [Object],\n[23:20:08][Step 8/8]         [Object],\n[23:20:08][Step 8/8]         [Object],\n[23:20:08][Step 8/8]         [Object] ] },\n[23:20:08][Step 8/8]   _: [],\n[23:20:08][Step 8/8]   debug: true,\n[23:20:08][Step 8/8]   '$0': 'node_modules/.bin/semantic-release' }\n[23:20:08][Step 8/8] 2019-01-10T23:20:08.953Z semantic-release:plugins options for @semantic-release/npm/verifyConditions: {}\n[23:20:08][Step 8/8] [23:20:08] [semantic-release] \u203a \u2714  Loaded plugin \"verifyConditions\" from \"@semantic-release/npm\"\n[23:20:08][Step 8/8] [23:20:08] [semantic-release] \u203a \u2714  Loaded plugin \"verifyConditions\" from \"@semantic-release/github\"\n[23:20:08][Step 8/8] [23:20:08] [semantic-release] \u203a \u2714  Loaded plugin \"analyzeCommits\" from \"@semantic-release/commit-analyzer\"\n[23:20:08][Step 8/8] [23:20:08] [semantic-release] \u203a \u2714  Loaded plugin \"generateNotes\" from \"@semantic-release/release-notes-generator\"\n[23:20:08][Step 8/8] 2019-01-10T23:20:08.954Z semantic-release:plugins options for @semantic-release/github/verifyConditions: {}\n[23:20:08][Step 8/8] 2019-01-10T23:20:08.954Z semantic-release:plugins options for @semantic-release/commit-analyzer/analyzeCommits: { preset: 'angular',\n[23:20:08][Step 8/8]   releaseRules: \n[23:20:08][Step 8/8]    [ { type: 'docs', release: 'patch' },\n[23:20:08][Step 8/8]      { type: 'refactor', release: 'patch' },\n[23:20:08][Step 8/8]      { type: 'style', release: 'patch' },\n[23:20:08][Step 8/8]      { type: 'test', release: 'patch' },\n[23:20:08][Step 8/8]      { type: 'build', release: 'patch' },\n[23:20:08][Step 8/8]      { type: 'ci', release: 'patch' },\n[23:20:08][Step 8/8]      { type: 'chore', release: 'patch' } ] }\n[23:20:08][Step 8/8] 2019-01-10T23:20:08.955Z semantic-release:plugins options for @semantic-release/release-notes-generator/generateNotes: {}\n[23:20:08][Step 8/8] [23:20:08] [semantic-release] \u203a \u2714  Loaded plugin \"prepare\" from \"@semantic-release/changelog\"\n[23:20:08][Step 8/8] [23:20:08] [semantic-release] \u203a \u2714  Loaded plugin \"prepare\" from \"@semantic-release/npm\"\n[23:20:08][Step 8/8] 2019-01-10T23:20:08.959Z semantic-release:plugins options for @semantic-release/changelog/prepare: {}\n[23:20:08][Step 8/8] 2019-01-10T23:20:08.959Z semantic-release:plugins options for @semantic-release/npm/prepare: {}\n[23:20:09][Step 8/8] 2019-01-10T23:20:09.013Z semantic-release:plugins options for @semantic-release/git/prepare: { assets: [ 'CHANGELOG.md', 'package.json', 'package-lock.json' ],\n[23:20:09][Step 8/8]   message: 'chore(release): ${nextRelease.version} [skip ci]\\n\\n${nextRelease.notes}' }\n[23:20:09][Step 8/8] 2019-01-10T23:20:09.013Z semantic-release:plugins options for @semantic-release/npm/publish: {}\n[23:20:09][Step 8/8] 2019-01-10T23:20:09.013Z semantic-release:plugins options for @semantic-release/github/publish: {}\n[23:20:09][Step 8/8] 2019-01-10T23:20:09.014Z semantic-release:plugins options for @semantic-release/npm/addChannel: {}\n[23:20:09][Step 8/8] 2019-01-10T23:20:09.014Z semantic-release:plugins options for @semantic-release/github/addChannel: {}\n[23:20:09][Step 8/8] 2019-01-10T23:20:09.014Z semantic-release:plugins options for @semantic-release/github/success: {}\n[23:20:09][Step 8/8] 2019-01-10T23:20:09.015Z semantic-release:plugins options for @semantic-release/github/fail: {}\n[23:20:09][Step 8/8] [23:20:09] [semantic-release] \u203a \u2714  Loaded plugin \"prepare\" from \"@semantic-release/git\"\n[23:20:09][Step 8/8] [23:20:09] [semantic-release] \u203a \u2714  Loaded plugin \"publish\" from \"@semantic-release/npm\"\n[23:20:09][Step 8/8] [23:20:09] [semantic-release] \u203a \u2714  Loaded plugin \"publish\" from \"@semantic-release/github\"\n[23:20:09][Step 8/8] [23:20:09] [semantic-release] \u203a \u2714  Loaded plugin \"addChannel\" from \"@semantic-release/npm\"\n[23:20:09][Step 8/8] [23:20:09] [semantic-release] \u203a \u2714  Loaded plugin \"addChannel\" from \"@semantic-release/github\"\n[23:20:09][Step 8/8] [23:20:09] [semantic-release] \u203a \u2714  Loaded plugin \"success\" from \"@semantic-release/github\"\n[23:20:09][Step 8/8] [23:20:09] [semantic-release] \u203a \u2714  Loaded plugin \"fail\" from \"@semantic-release/github\"\n[23:20:15][Step 8/8] 2019-01-10T23:20:15.759Z semantic-release:get-tags found tags: []\n[23:20:15][Step 8/8] 2019-01-10T23:20:15.760Z semantic-release:get-tags found tags for branch master: []\n[23:20:15][Step 8/8] 2019-01-10T23:20:15.760Z semantic-release:get-tags found tags for branch alpha: []\n[23:20:15][Step 8/8] [23:20:15] [semantic-release] \u203a \u2714  Run automated release from branch alpha\n[23:20:18][Step 8/8] [23:20:18] [semantic-release] \u203a \u2714  Allowed to push to the Git repository\n[23:20:18][Step 8/8] [23:20:18] [semantic-release] \u203a \u2139  Start step \"verifyConditions\" of plugin \"@semantic-release/npm\"\n[23:20:18][Step 8/8] [23:20:18] [semantic-release] [@semantic-release/npm] \u203a \u2139  Verify authentication for registry https://packages.REPO_OWNER.com/repository/npm-private-client/\n[23:20:18][Step 8/8] [23:20:18] [semantic-release] [@semantic-release/npm] \u203a \u2139  Wrote NPM_TOKEN to /home/centos/buildAgent/work/df162c7dd0c21ff7/.npmrc\n[23:20:18][Step 8/8] [23:20:18] [semantic-release] \u203a \u2714  Completed step \"verifyConditions\" of plugin \"@semantic-release/npm\"\n[23:20:18][Step 8/8] [23:20:18] [semantic-release] \u203a \u2139  Start step \"verifyConditions\" of plugin \"@semantic-release/github\"\n[23:20:18][Step 8/8] [23:20:18] [semantic-release] [@semantic-release/github] \u203a \u2139  Verify GitHub authentication\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] \u203a \u2714  Completed step \"verifyConditions\" of plugin \"@semantic-release/github\"\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] \u203a \u2139  No git tag version found on branch alpha\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] \u203a \u2139  No previous release found, retrieving all commits\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] \u203a \u2139  Found 23 commits since last release\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] \u203a \u2139  Start step \"analyzeCommits\" of plugin \"@semantic-release/commit-analyzer\"\n[23:20:19][Step 8/8] 2019-01-10T23:20:19.118Z semantic-release:get-commits Parsed commits: [ { commit: { long: '252950698961461a3bfb975911fe46ee1cfb27d5', short: '2529506' }, tree: { long: '69403c84472d53d7de7928f16436e2aa98259950', short: '69403c8' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-10T23:18:09.000Z }, committer: { name: 'GitHub', email: 'noreply@github.com', date: 2019-01-10T23:18:09.000Z }, subject: 'Merge pull request #11 from REPO_OWNER/PI-6588/resolve-alpha-release-issues', body: 'chore(npm): Added semantic-release/changelog dependency', hash: '252950698961461a3bfb975911fe46ee1cfb27d5', committerDate: 2019-01-10T23:18:09.000Z, message: 'Merge pull request #11 from REPO_OWNER/PI-6588/resolve-alpha-release-issues\\n\\nchore(npm): Added semantic-release/changelog dependency', gitTags: '(HEAD -> alpha, origin/alpha)' }, { commit: { long: 'b8000429d5ab19f15c43feb241a00e3b633217d5', short: 'b800042' }, tree: { long: '69403c84472d53d7de7928f16436e2aa98259950', short: '69403c8' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-10T23:16:04.000Z }, committer: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-10T23:16:04.000Z }, subject: 'chore(npm): Added semantic-release/changelog dependency', body: '', hash: 'b8000429d5ab19f15c43feb241a00e3b633217d5', committerDate: 2019-01-10T23:16:04.000Z, message: 'chore(npm): Added semantic-release/changelog dependency', gitTags: '' }, { commit: { long: 'd79970f2811d9d51bfd159618cde9796a1d4c5b2', short: 'd79970f' }, tree: { long: '057abed4b801bb79c0143016148d6b427b13b4b3', short: '057abed' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-10T23:10:08.000Z }, committer: { name: 'GitHub', email: 'noreply@github.com', date: 2019-01-10T23:10:08.000Z }, subject: 'Merge pull request #10 from REPO_OWNER/PI-6588/resolve-alpha-release-issues', body: 'Pi 6588/resolve alpha release issues', hash: 'd79970f2811d9d51bfd159618cde9796a1d4c5b2', committerDate: 2019-01-10T23:10:08.000Z, message: 'Merge pull request #10 from REPO_OWNER/PI-6588/resolve-alpha-release-issues\\n\\nPi 6588/resolve alpha release issues', gitTags: '' }, { commit: { long: '110ea0f329afc1e6e79f373112122ee2fe8d80f4', short: '110ea0f' }, tree: { long: '057abed4b801bb79c0143016148d6b427b13b4b3', short: '057abed' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-10T23:01:02.000Z }, committer: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-10T23:01:02.000Z }, subject: 'build(npm): Removed references to semantic-release plugins automatically installed', body: '', hash: '110ea0f329afc1e6e79f373112122ee2fe8d80f4', committerDate: 2019-01-10T23:01:02.000Z, message: 'build(npm): Removed references to semantic-release plugins automatically installed', gitTags: '' }, { commit: { long: '7945bb56e57999a204a6c680e34a63185e6d65a4', short: '7945bb5' }, tree: { long: 'bc2a0a814ecd47773ddbfe7923e29e9c1efd8670', short: 'bc2a0a8' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-10T12:25:43.000Z }, committer: { name: 'GitHub', email: 'noreply@github.com', date: 2019-01-10T12:25:43.000Z }, subject: 'Merge pull request #9 from REPO_OWNER/PI-6570/add-demo', body: 'chore(demo): Added basic demo app', hash: '7945bb56e57999a204a6c680e34a63185e6d65a4', committerDate: 2019-01-10T12:25:43.000Z, message: 'Merge pull request #9 from REPO_OWNER/PI-6570/add-demo\\n\\nchore(demo): Added basic demo app', gitTags: '(origin/master, master)' }, { commit: { long: '7b11ea2fa68abd47f2e8d890e224e773e27832ac', short: '7b11ea2' }, tree: { long: 'bc2a0a814ecd47773ddbfe7923e29e9c1efd8670', short: 'bc2a0a8' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-10T12:11:10.000Z }, committer: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-10T12:11:29.000Z }, subject: 'chore(demo): Added basic demo app', body: '', hash: '7b11ea2fa68abd47f2e8d890e224e773e27832ac', committerDate: 2019-01-10T12:11:29.000Z, message: 'chore(demo): Added basic demo app', gitTags: '' }, { commit: { long: '0284001bc020f69f4a8af569cf0c0adbe8b2a073', short: '0284001' }, tree: { long: '3ee7be89c537d4ff23debd3b92cfb59aa8e3e132', short: '3ee7be8' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-10T10:05:56.000Z }, committer: { name: 'GitHub', email: 'noreply@github.com', date: 2019-01-10T10:05:56.000Z }, subject: 'Merge pull request #8 from REPO_OWNER/alpha', body: 'Merge alpha setup changes into master', hash: '0284001bc020f69f4a8af569cf0c0adbe8b2a073', committerDate: 2019-01-10T10:05:56.000Z, message: 'Merge pull request #8 from REPO_OWNER/alpha\\n\\nMerge alpha setup changes into master', gitTags: '' }, { commit: { long: '10c3f2dd4cb749d995703cfcc1df1ec893ac40f4', short: '10c3f2d' }, tree: { long: '3ee7be89c537d4ff23debd3b92cfb59aa8e3e132', short: '3ee7be8' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-09T15:42:18.000Z }, committer: { name: 'GitHub', email: 'noreply@github.com', date: 2019-01-09T15:42:18.000Z }, subject: 'Merge pull request #7 from REPO_OWNER/PI-6517/add-branch-to-release-config', body: 'build(semantic-release): Added branch to alpha config', hash: '10c3f2dd4cb749d995703cfcc1df1ec893ac40f4', committerDate: 2019-01-09T15:42:18.000Z, message: 'Merge pull request #7 from REPO_OWNER/PI-6517/add-branch-to-release-config\\n\\nbuild(semantic-release): Added branch to alpha config', gitTags: '' }, { commit: { long: '868599be7524714cc1aeecdbe2b84b892602c645', short: '868599b' }, tree: { long: '3ee7be89c537d4ff23debd3b92cfb59aa8e3e132', short: '3ee7be8' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-09T15:39:55.000Z }, committer: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-09T15:39:55.000Z }, subject: 'build(semantic-release): Added branch to alpha config', body: '', hash: '868599be7524714cc1aeecdbe2b84b892602c645', committerDate: 2019-01-09T15:39:55.000Z, message: 'build(semantic-release): Added branch to alpha config', gitTags: '' }, { commit: { long: '3ad9a845c40f2600b3480ac73a98e827859d120e', short: '3ad9a84' }, tree: { long: '516cf5b54dbab825f99c7c0a8dc400b0add27df3', short: '516cf5b' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-09T15:19:36.000Z }, committer: { name: 'GitHub', email: 'noreply@github.com', date: 2019-01-09T15:19:36.000Z }, subject: 'Merge pull request #6 from REPO_OWNER/PI-6517/correct-typings', body: 'build(types): Prevent spec types being output do the dist', hash: '3ad9a845c40f2600b3480ac73a98e827859d120e', committerDate: 2019-01-09T15:19:36.000Z, message: 'Merge pull request #6 from REPO_OWNER/PI-6517/correct-typings\\n\\nbuild(types): Prevent spec types being output do the dist', gitTags: '' }, { commit: { long: 'f3cb0c454380b3089ae05f0ecd444092164fb954', short: 'f3cb0c4' }, tree: { long: '516cf5b54dbab825f99c7c0a8dc400b0add27df3', short: '516cf5b' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-09T15:16:12.000Z }, committer: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-09T15:16:12.000Z }, subject: 'build(types): Prevent spec types being output do the dist', body: '', hash: 'f3cb0c454380b3089ae05f0ecd444092164fb954', committerDate: 2019-01-09T15:16:12.000Z, message: 'build(types): Prevent spec types being output do the dist', gitTags: '' }, { commit: { long: 'f12bf7a03d1bc69cac2e95a619de4b5734ed8492', short: 'f12bf7a' }, tree: { long: '75fc7ea05473f91989e6c421cacff3514e7d0922', short: '75fc7ea' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-09T14:27:58.000Z }, committer: { name: 'GitHub', email: 'noreply@github.com', date: 2019-01-09T14:27:58.000Z }, subject: 'Merge pull request #5 from REPO_OWNER/PI-6517/harden-publish-config', body: 'build(npm): Added publish config with the registry', hash: 'f12bf7a03d1bc69cac2e95a619de4b5734ed8492', committerDate: 2019-01-09T14:27:58.000Z, message: 'Merge pull request #5 from REPO_OWNER/PI-6517/harden-publish-config\\n\\nbuild(npm): Added publish config with the registry', gitTags: '' }, { commit: { long: '5a0e6e055eb49dc824a861d05b4807b9501e47fa', short: '5a0e6e0' }, tree: { long: '75fc7ea05473f91989e6c421cacff3514e7d0922', short: '75fc7ea' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-09T13:35:19.000Z }, committer: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-09T13:35:19.000Z }, subject: 'build(npm): Added publish config with the registry', body: '', hash: '5a0e6e055eb49dc824a861d05b4807b9501e47fa', committerDate: 2019-01-09T13:35:19.000Z, message: 'build(npm): Added publish config with the registry', gitTags: '' }, { commit: { long: '6b808a124cbcbb3eef407c4b3f9940b86dc8d909', short: '6b808a1' }, tree: { long: '7b91ef22a4389de9699b711ff048029f917211dd', short: '7b91ef2' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-09T10:26:22.000Z }, committer: { name: 'GitHub', email: 'noreply@github.com', date: 2019-01-09T10:26:22.000Z }, subject: 'Merge pull request #4 from REPO_OWNER/PI-6517/allow-alpha-releases', body: 'build(semantic-release): Allow releases from an alpha branch', hash: '6b808a124cbcbb3eef407c4b3f9940b86dc8d909', committerDate: 2019-01-09T10:26:22.000Z, message: 'Merge pull request #4 from REPO_OWNER/PI-6517/allow-alpha-releases\\n\\nbuild(semantic-release): Allow releases from an alpha branch', gitTags: '' }, { commit: { long: 'b12a416497fe272b009cc0edac3987da1a8fdb4e', short: 'b12a416' }, tree: { long: '7b91ef22a4389de9699b711ff048029f917211dd', short: '7b91ef2' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-08T17:13:08.000Z }, committer: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-09T09:55:04.000Z }, subject: 'build(semantic-release): Allow releases from an alpha branch', body: '', hash: 'b12a416497fe272b009cc0edac3987da1a8fdb4e', committerDate: 2019-01-09T09:55:04.000Z, message: 'build(semantic-release): Allow releases from an alpha branch', gitTags: '' }, { commit: { long: '17c33c9c5e64d1967e9641c7a06b6de0a9c404a8', short: '17c33c9' }, tree: { long: 'e74209682d33fd1fb5569e0319b660cb395e0c87', short: 'e742096' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-08T16:34:37.000Z }, committer: { name: 'GitHub', email: 'noreply@github.com', date: 2019-01-08T16:34:37.000Z }, subject: 'Merge pull request #3 from REPO_OWNER/PI-6517/update-package-name', body: 'chore(repo): Updated package name and move release config to separate\u2026', hash: '17c33c9c5e64d1967e9641c7a06b6de0a9c404a8', committerDate: 2019-01-08T16:34:37.000Z, message: 'Merge pull request #3 from REPO_OWNER/PI-6517/update-package-name\\n\\nchore(repo): Updated package name and move release config to separate\u2026', gitTags: '' }, { commit: { long: '7182c5b11a60062b7d471e9647b0770c2a73cd7d', short: '7182c5b' }, tree: { long: 'e74209682d33fd1fb5569e0319b660cb395e0c87', short: 'e742096' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-08T16:29:44.000Z }, committer: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-08T16:30:33.000Z }, subject: 'chore(repo): Updated package name and move release config to separate file', body: '', hash: '7182c5b11a60062b7d471e9647b0770c2a73cd7d', committerDate: 2019-01-08T16:30:33.000Z, message: 'chore(repo): Updated package name and move release config to separate file', gitTags: '' }, { commit: { long: '501e6bc1fdf86ec515356562ab3fd0289467a193', short: '501e6bc' }, tree: { long: '9e516dd85055ec2b9d454bb17aa5118dd4ccd216', short: '9e516dd' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-08T15:18:21.000Z }, committer: { name: 'GitHub', email: 'noreply@github.com', date: 2019-01-08T15:18:21.000Z }, subject: 'Merge pull request #1 from REPO_OWNER/PI-6517/update-coverage-threshold', body: 'chore(config): Updated jest config for a higher coverage threshold', hash: '501e6bc1fdf86ec515356562ab3fd0289467a193', committerDate: 2019-01-08T15:18:21.000Z, message: 'Merge pull request #1 from REPO_OWNER/PI-6517/update-coverage-threshold\\n\\nchore(config): Updated jest config for a higher coverage threshold', gitTags: '' }, { commit: { long: 'e58ff83deb32e44b59641915075cca7c02ce95be', short: 'e58ff83' }, tree: { long: '9e516dd85055ec2b9d454bb17aa5118dd4ccd216', short: '9e516dd' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-08T11:14:01.000Z }, committer: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-08T15:16:08.000Z }, subject: 'chore(config): Updated jest config for a higher coverage threshold', body: '', hash: 'e58ff83deb32e44b59641915075cca7c02ce95be', committerDate: 2019-01-08T15:16:08.000Z, message: 'chore(config): Updated jest config for a higher coverage threshold', gitTags: '' }, { commit: { long: '9c7bd1d5fe6c90aaf9751d1fac54443d4be2fbfe', short: '9c7bd1d' }, tree: { long: '6a8c87e83d0cf0f9f23091a9848e2430ed2d9bf0', short: '6a8c87e' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-08T14:52:33.000Z }, committer: { name: 'GitHub', email: 'noreply@github.com', date: 2019-01-08T14:52:33.000Z }, subject: 'Merge pull request #2 from REPO_OWNER/PI-6517/add-bash-scripts-to-enforce-node-version', body: 'build(npm): Check node version before scripts are executed', hash: '9c7bd1d5fe6c90aaf9751d1fac54443d4be2fbfe', committerDate: 2019-01-08T14:52:33.000Z, message: 'Merge pull request #2 from REPO_OWNER/PI-6517/add-bash-scripts-to-enforce-node-version\\n\\nbuild(npm): Check node version before scripts are executed', gitTags: '' }, { commit: { long: 'e8b0ef1691207473f20b23741b07e1ffa6317cf5', short: 'e8b0ef1' }, tree: { long: '6a8c87e83d0cf0f9f23091a9848e2430ed2d9bf0', short: '6a8c87e' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-08T14:30:06.000Z }, committer: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-08T14:30:06.000Z }, subject: 'build(npm): Added lint command', body: '', hash: 'e8b0ef1691207473f20b23741b07e1ffa6317cf5', committerDate: 2019-01-08T14:30:06.000Z, message: 'build(npm): Added lint command', gitTags: '' }, { commit: { long: '05c44e30d5e3ea7a2486287eabefd29da99ff51f', short: '05c44e3' }, tree: { long: 'e404f634a430d033293139e14cec9b161508d7a9', short: 'e404f63' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-08T13:48:29.000Z }, committer: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-08T13:48:29.000Z }, subject: 'build(npm): Check node version before scripts are executed', body: '', hash: '05c44e30d5e3ea7a2486287eabefd29da99ff51f', committerDate: 2019-01-08T13:48:29.000Z, message: 'build(npm): Check node version before scripts are executed', gitTags: '' }, { commit: { long: '6d080bd9d7d3b23c5e078f707742296fff4330f2', short: '6d080bd' }, tree: { long: '734ecb414d0f3335a40e562c06fb8a4c875a4fe1', short: '734ecb4' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-07T16:58:38.000Z }, committer: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-07T17:00:04.000Z }, subject: 'build(repo): Initial setup of the project/repo', body: '', hash: '6d080bd9d7d3b23c5e078f707742296fff4330f2', committerDate: 2019-01-07T17:00:04.000Z, message: 'build(repo): Initial setup of the project/repo', gitTags: '' } ]\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: Merge pull request #11 from REPO_OWNER/PI-6588/resolve-alpha-release-issues\n[23:20:19][Step 8/8] 2019-01-10T23:20:19.139Z semantic-release:commit-analyzer Analyzing with custom rules\n[23:20:19][Step 8/8] \n[23:20:19][Step 8/8] 2019-01-10T23:20:19.140Z semantic-release:commit-analyzer Analyzing with default rules\n[23:20:19][Step 8/8] 2019-01-10T23:20:19.140Z semantic-release:commit-analyzer Analyzing with custom rules\n[23:20:19][Step 8/8] 2019-01-10T23:20:19.142Z semantic-release:commit-analyzer The rule { type: 'chore', release: 'patch' } match commit with release type 'patch'\n[23:20:19][Step 8/8] 2019-01-10T23:20:19.142Z semantic-release:commit-analyzer Analyzing with custom rules\n[23:20:19][Step 8/8] 2019-01-10T23:20:19.142Z semantic-release:commit-analyzer Analyzing with default rules\n[23:20:19][Step 8/8] 2019-01-10T23:20:19.143Z semantic-release:commit-analyzer Analyzing with custom rules\n[23:20:19][Step 8/8] 2019-01-10T23:20:19.143Z semantic-release:commit-analyzer The rule { type: 'build', release: 'patch' } match commit with release type 'patch'\n[23:20:19][Step 8/8] 2019-01-10T23:20:19.143Z semantic-release:commit-analyzer Analyzing with custom rules\n[23:20:19][Step 8/8] 2019-01-10T23:20:19.143Z semantic-release:commit-analyzer Analyzing with default rules\n[23:20:19][Step 8/8] 2019-01-10T23:20:19.143Z semantic-release:commit-analyzer Analyzing with custom rules\n[23:20:19][Step 8/8] 2019-01-10T23:20:19.143Z semantic-release:commit-analyzer The rule { type: 'chore', release: 'patch' } match commit with release type 'patch'\n[23:20:19][Step 8/8] 2019-01-10T23:20:19.144Z semantic-release:commit-analyzer Analyzing with custom rules\n[23:20:19][Step 8/8] 2019-01-10T23:20:19.144Z semantic-release:commit-analyzer Analyzing with default rules\n[23:20:19][Step 8/8] 2019-01-10T23:20:19.144Z semantic-release:commit-analyzer Analyzing with custom rules\n[23:20:19][Step 8/8] 2019-01-10T23:20:19.144Z semantic-release:commit-analyzer Analyzing with default rules\n[23:20:19][Step 8/8] 2019-01-10T23:20:19.144Z semantic-release:commit-analyzer Analyzing with custom rules\n[23:20:19][Step 8/8] 2019-01-10T23:20:19.145Z semantic-release:commit-analyzer The rule { type: 'build', release: 'patch' } match commit with release type 'patch'\n[23:20:19][Step 8/8] 2019-01-10T23:20:19.145Z semantic-release:commit-analyzer Analyzing with custom rules\n[23:20:19][Step 8/8] 2019-01-10T23:20:19.145Z semantic-release:commit-analyzer Analyzing with default rules\n[23:20:19][Step 8/8] 2019-01-10T23:20:19.145Z semantic-release:commit-analyzer Analyzing with custom rules\n[23:20:19][Step 8/8] 2019-01-10T23:20:19.145Z semantic-release:commit-analyzer The rule { type: 'build', release: 'patch' } match commit with release type 'patch'\n[23:20:19][Step 8/8] 2019-01-10T23:20:19.146Z semantic-release:commit-analyzer Analyzing with custom rules\n[23:20:19][Step 8/8] 2019-01-10T23:20:19.146Z semantic-release:commit-analyzer Analyzing with default rules\n[23:20:19][Step 8/8] 2019-01-10T23:20:19.146Z semantic-release:commit-analyzer Analyzing with custom rules\n[23:20:19][Step 8/8] 2019-01-10T23:20:19.146Z semantic-release:commit-analyzer The rule { type: 'build', release: 'patch' } match commit with release type 'patch'\n[23:20:19][Step 8/8] 2019-01-10T23:20:19.146Z semantic-release:commit-analyzer Analyzing with custom rules\n[23:20:19][Step 8/8] 2019-01-10T23:20:19.146Z semantic-release:commit-analyzer Analyzing with default rules\n[23:20:19][Step 8/8] chore(npm): Added semantic-release/changelog dependency\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The commit should not trigger a release\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: chore(npm): Added semantic-release/changelog dependency\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The release type for the commit is patch\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: Merge pull request #10 from REPO_OWNER/PI-6588/resolve-alpha-release-issues\n[23:20:19][Step 8/8] \n[23:20:19][Step 8/8] Pi 6588/resolve alpha release issues\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The commit should not trigger a release\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: build(npm): Removed references to semantic-release plugins automatically installed\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The release type for the commit is patch\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: Merge pull request #9 from REPO_OWNER/PI-6570/add-demo\n[23:20:19][Step 8/8] \n[23:20:19][Step 8/8] chore(demo): Added basic demo app\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The commit should not trigger a release\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: chore(demo): Added basic demo app\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The release type for the commit is patch\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: Merge pull request #8 from REPO_OWNER/alpha\n[23:20:19][Step 8/8] \n[23:20:19][Step 8/8] Merge alpha setup changes into master\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The commit should not trigger a release\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: Merge pull request #7 from REPO_OWNER/PI-6517/add-branch-to-release-config\n[23:20:19][Step 8/8] \n[23:20:19][Step 8/8] build(semantic-release): Added branch to alpha config\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The commit should not trigger a release\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: build(semantic-release): Added branch to alpha config\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The release type for the commit is patch\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: Merge pull request #6 from REPO_OWNER/PI-6517/correct-typings\n[23:20:19][Step 8/8] \n[23:20:19][Step 8/8] build(types): Prevent spec types being output do the dist\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The commit should not trigger a release\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: build(types): Prevent spec types being output do the dist\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The release type for the commit is patch\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: Merge pull request #5 from REPO_OWNER/PI-6517/harden-publish-config\n[23:20:19][Step 8/8] \n[23:20:19][Step 8/8] build(npm): Added publish config with the registry\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The commit should not trigger a release\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: build(npm): Added publish config with the registry\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The release type for the commit is patch\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: Merge pull request #4 from REPO_OWNER/PI-6517/allow-alpha-releases\n[23:20:19][Step 8/8] \n[23:20:19][Step 8/8] build(semantic-release): Allow releases from an alpha branch\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The commit should not trigger a release\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: build(semantic-release): Allow releases from an alpha branch\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The release type for the commit is patch\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: Merge pull request #3 from REPO_OWNER/PI-6517/update-package-name\n[23:20:19][Step 8/8] \n[23:20:19][Step 8/8] chore(repo): Updated package name and move release config to separate\u2026\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The commit should not trigger a release\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: chore(repo): Updated package name and move release config to separate file\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The release type for the commit is patch\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: Merge pull request #1 from REPO_OWNER/PI-6517/update-coverage-threshold\n[23:20:19][Step 8/8] \n[23:20:19][Step 8/8] chore(config): Updated jest config for a higher coverage threshold\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The commit should not trigger a release\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: chore(config): Updated jest config for a higher coverage threshold\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The release type for the commit is patch\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: Merge pull request #2 from REPO_OWNER/PI-6517/add-bash-scripts-to-enforce-node-version\n[23:20:19][Step 8/8] \n[23:20:19][Step 8/8] build(npm): Check node version before scripts are executed\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The commit should not trigger a release\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: build(npm): Added lint command\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The release type for the commit is patch\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: build(npm): Check node version before scripts are executed\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The release type for the commit is patch\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: build(repo): Initial setup of the project/repo\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The release type for the commit is patch\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analysis of 23 commits complete: patch release\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] \u203a \u2714  Completed step \"analyzeCommits\" of plugin \"@semantic-release/commit-analyzer\"\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] \u203a \u2139  There is no previous release, the next release version is 1.0.0-alpha.1\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] \u203a \u2139  Start step \"generateNotes\" of plugin \"@semantic-release/release-notes-generator\"\n[23:20:19][Step 8/8] 2019-01-10T23:20:19.147Z semantic-release:commit-analyzer Analyzing with custom rules\n[23:20:19][Step 8/8] 2019-01-10T23:20:19.147Z semantic-release:commit-analyzer The rule { type: 'build', release: 'patch' } match commit with release type 'patch'\n[23:20:19][Step 8/8] 2019-01-10T23:20:19.147Z semantic-release:commit-analyzer Analyzing with custom rules\n[23:20:19][Step 8/8] 2019-01-10T23:20:19.147Z semantic-release:commit-analyzer Analyzing with default rules\n[23:20:19][Step 8/8] 2019-01-10T23:20:19.147Z semantic-release:commit-analyzer Analyzing with custom rules\n[23:20:19][Step 8/8] 2019-01-10T23:20:19.147Z semantic-release:commit-analyzer The rule { type: 'chore', release: 'patch' } match commit with release type 'patch'\n[23:20:19][Step 8/8] 2019-01-10T23:20:19.148Z semantic-release:commit-analyzer Analyzing with custom rules\n[23:20:19][Step 8/8] 2019-01-10T23:20:19.148Z semantic-release:commit-analyzer Analyzing with default rules\n[23:20:19][Step 8/8] 2019-01-10T23:20:19.148Z semantic-release:commit-analyzer Analyzing with custom rules\n[23:20:19][Step 8/8] 2019-01-10T23:20:19.148Z semantic-release:commit-analyzer The rule { type: 'chore', release: 'patch' } match commit with release type 'patch'\n[23:20:19][Step 8/8] 2019-01-10T23:20:19.148Z semantic-release:commit-analyzer Analyzing with custom rules\n[23:20:19][Step 8/8] 2019-01-10T23:20:19.149Z semantic-release:commit-analyzer Analyzing with default rules\n[23:20:19][Step 8/8] 2019-01-10T23:20:19.149Z semantic-release:commit-analyzer Analyzing with custom rules\n[23:20:19][Step 8/8] 2019-01-10T23:20:19.149Z semantic-release:commit-analyzer The rule { type: 'build', release: 'patch' } match commit with release type 'patch'\n[23:20:19][Step 8/8] 2019-01-10T23:20:19.149Z semantic-release:commit-analyzer Analyzing with custom rules\n[23:20:19][Step 8/8] 2019-01-10T23:20:19.149Z semantic-release:commit-analyzer The rule { type: 'build', release: 'patch' } match commit with release type 'patch'\n[23:20:19][Step 8/8] 2019-01-10T23:20:19.150Z semantic-release:commit-analyzer Analyzing with custom rules\n[23:20:19][Step 8/8] 2019-01-10T23:20:19.150Z semantic-release:commit-analyzer The rule { type: 'build', release: 'patch' } match commit with release type 'patch'\n[23:20:19][Step 8/8] 2019-01-10T23:20:19.170Z semantic-release:release-notes-generator version: '1.0.0-alpha.1'\n[23:20:19][Step 8/8] 2019-01-10T23:20:19.170Z semantic-release:release-notes-generator host: 'github.com'\n[23:20:19][Step 8/8] 2019-01-10T23:20:19.170Z semantic-release:release-notes-generator owner: 'REPO_OWNER'\n[23:20:19][Step 8/8] 2019-01-10T23:20:19.170Z semantic-release:release-notes-generator repository: 'REPO_NAME'\n[23:20:19][Step 8/8] 2019-01-10T23:20:19.170Z semantic-release:release-notes-generator previousTag: undefined\n[23:20:19][Step 8/8] 2019-01-10T23:20:19.170Z semantic-release:release-notes-generator currentTag: 'v1.0.0-alpha.1@alpha'\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] \u203a \u2714  Completed step \"generateNotes\" of plugin \"@semantic-release/release-notes-generator\"\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] \u203a \u2139  Start step \"prepare\" of plugin \"@semantic-release/changelog\"\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] [@semantic-release/changelog] \u203a \u2139  Create /home/centos/buildAgent/work/df162c7dd0c21ff7/CHANGELOG.md\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] \u203a \u2714  Completed step \"prepare\" of plugin \"@semantic-release/changelog\"\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] \u203a \u2139  Start step \"prepare\" of plugin \"@semantic-release/npm\"\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] [@semantic-release/npm] \u203a \u2139  Write version 1.0.0-alpha.1 to package.json in /home/centos/buildAgent/work/df162c7dd0c21ff7\n[23:20:19][Step 8/8] v1.0.0-alpha.1\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] \u203a \u2714  Completed step \"prepare\" of plugin \"@semantic-release/npm\"\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] \u203a \u2139  Start step \"prepare\" of plugin \"@semantic-release/git\"\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] [@semantic-release/git] \u203a \u2139  Found 3 file(s) to commit\n[23:20:19][Step 8/8] 2019-01-10T23:20:19.891Z semantic-release:git add file to git index { stdout: '',\n[23:20:19][Step 8/8]   stderr: '',\n[23:20:19][Step 8/8]   code: 0,\n[23:20:19][Step 8/8]   failed: false,\n[23:20:19][Step 8/8]   killed: false,\n[23:20:19][Step 8/8]   signal: null,\n[23:20:19][Step 8/8]   cmd: 'git add --force --ignore-errors CHANGELOG.md package.json package-lock.json',\n[23:20:19][Step 8/8]   timedOut: false }\n[23:20:19][Step 8/8] 2019-01-10T23:20:19.891Z semantic-release:git commited files: [ 'CHANGELOG.md', 'package.json', 'package-lock.json' ]\n[23:20:19][Step 8/8] [23:20:19] [semantic-release] [@semantic-release/git] \u203a \u2139  Creating tag v1.0.0-alpha.1@alpha\n[23:20:23][Step 8/8] [23:20:23] [semantic-release] [@semantic-release/git] \u203a \u2139  Prepared Git release: v1.0.0-alpha.1@alpha\n[23:20:23][Step 8/8] [23:20:23] [semantic-release] \u203a \u2714  Completed step \"prepare\" of plugin \"@semantic-release/git\"\n[23:20:23][Step 8/8] [23:20:23] [semantic-release] \u203a \u2139  Start step \"generateNotes\" of plugin \"@semantic-release/release-notes-generator\"\n[23:20:23][Step 8/8] 2019-01-10T23:20:23.422Z semantic-release:release-notes-generator version: '1.0.0-alpha.1'\n[23:20:23][Step 8/8] 2019-01-10T23:20:23.422Z semantic-release:release-notes-generator host: 'github.com'\n[23:20:23][Step 8/8] 2019-01-10T23:20:23.422Z semantic-release:release-notes-generator owner: 'REPO_OWNER'\n[23:20:23][Step 8/8] 2019-01-10T23:20:23.422Z semantic-release:release-notes-generator repository: 'REPO_NAME'\n[23:20:23][Step 8/8] 2019-01-10T23:20:23.422Z semantic-release:release-notes-generator previousTag: undefined\n[23:20:23][Step 8/8] 2019-01-10T23:20:23.422Z semantic-release:release-notes-generator currentTag: 'v1.0.0-alpha.1@alpha'\n[23:20:23][Step 8/8] [23:20:23] [semantic-release] \u203a \u2714  Completed step \"generateNotes\" of plugin \"@semantic-release/release-notes-generator\"\n[23:20:26][Step 8/8] [23:20:26] [semantic-release] \u203a \u2714  Created tag v1.0.0-alpha.1@alpha\n[23:20:26][Step 8/8] [23:20:26] [semantic-release] \u203a \u2139  Start step \"publish\" of plugin \"@semantic-release/npm\"\n[23:20:26][Step 8/8] [23:20:26] [semantic-release] [@semantic-release/npm] \u203a \u2139  Publishing version 1.0.0-alpha.1 to npm registry on dist-tag alpha\n[23:20:27][Step 8/8] npm notice \n[23:20:27][Step 8/8] npm notice     @international/sweden-time-alerts-component@1.0.0-alpha.1\n[23:20:27][Step 8/8] npm notice === Tarball Contents === \n[23:20:27][Step 8/8] npm notice 2.1kB package.json           \n[23:20:27][Step 8/8] npm notice 29B   CHANGELOG.md           \n[23:20:27][Step 8/8] npm notice 767B  node-version-check.js  \n[23:20:27][Step 8/8] npm notice 45B   README.md              \n[23:20:27][Step 8/8] npm notice 1.3kB dist/main.min.js       \n[23:20:27][Step 8/8] npm notice 53B   dist/types/example.d.ts\n[23:20:27][Step 8/8] npm notice 27B   dist/types/index.d.ts  \n[23:20:27][Step 8/8] npm notice === Tarball Details === \n[23:20:27][Step 8/8] npm notice name:          @international/sweden-time-alerts-component\n[23:20:27][Step 8/8] npm notice version:       1.0.0-alpha.1                              \n[23:20:27][Step 8/8] npm notice package size:  1.9 kB                                     \n[23:20:27][Step 8/8] npm notice unpacked size: 4.3 kB                                     \n[23:20:27][Step 8/8] npm notice shasum:        5801c772c8761928473eef8cc7e270918eeb3ac4   \n[23:20:27][Step 8/8] npm notice integrity:     sha512-50FqG3Xfj5djO[...]gvvKrI3k4x79Q==   \n[23:20:27][Step 8/8] npm notice total files:   7                                          \n[23:20:27][Step 8/8] npm notice \n[23:20:27][Step 8/8] + @international/sweden-time-alerts-component@1.0.0-alpha.1\n[23:20:27][Step 8/8] [23:20:27] [semantic-release] [@semantic-release/npm] \u203a \u2139  Published @international/sweden-time-alerts-component@1.0.0-alpha.1 to https://packages.REPO_OWNER.com/repository/npm-private-client/\n[23:20:27][Step 8/8] [23:20:27] [semantic-release] \u203a \u2714  Completed step \"publish\" of plugin \"@semantic-release/npm\"\n[23:20:27][Step 8/8] [23:20:27] [semantic-release] \u203a \u2139  Start step \"publish\" of plugin \"@semantic-release/github\"\n[23:20:27][Step 8/8] 2019-01-10T23:20:27.596Z semantic-release:github release owner: 'REPO_OWNER'\n[23:20:27][Step 8/8] 2019-01-10T23:20:27.596Z semantic-release:github release repo: 'REPO_NAME'\n[23:20:27][Step 8/8] 2019-01-10T23:20:27.596Z semantic-release:github release tag_name: undefined\n[23:20:27][Step 8/8] 2019-01-10T23:20:27.596Z semantic-release:github release name: 'v1.0.0-alpha.1'\n[23:20:27][Step 8/8] 2019-01-10T23:20:27.596Z semantic-release:github release prerelease: true\n[23:20:28][Step 8/8] [23:20:28] [semantic-release] [@semantic-release/github] \u203a \u2139  Published GitHub release: https://github.com/REPO_OWNER/REPO_NAME/releases/tag/v1.0.0-alpha.1%40alpha\n[23:20:28][Step 8/8] [23:20:28] [semantic-release] \u203a \u2714  Completed step \"publish\" of plugin \"@semantic-release/github\"\n[23:20:28][Step 8/8] [23:20:28] [semantic-release] \u203a \u2139  Start step \"success\" of plugin \"@semantic-release/github\"\n[23:20:50][Step 8/8] 2019-01-10T23:20:50.321Z semantic-release:github found pull requests: [ 10, 11, 9, 8, 7, 6, 5, 4, 3, 1, 2 ]\n[23:20:50][Step 8/8] 2019-01-10T23:20:50.335Z semantic-release:github found issues via comments: []\n[23:20:50][Step 8/8] 2019-01-10T23:20:50.336Z semantic-release:github create comment: { owner: 'REPO_OWNER',\n[23:20:50][Step 8/8]   repo: 'REPO_NAME',\n[23:20:50][Step 8/8]   number: 10,\n[23:20:50][Step 8/8]   body: ':tada: This PR is included in version 1.0.0-alpha.1 :tada:\\n\\nThe release is available on:\\n- `npm package (@alpha dist-tag)`\\n- [GitHub release](https://github.com/REPO_OWNER/REPO_NAME/releases/tag/v1.0.0-alpha.1%40alpha)\\n\\nYour **[semantic-release](https://github.com/semantic-release/semantic-release)** bot :package::rocket:' }\n[23:20:50][Step 8/8] 2019-01-10T23:20:50.336Z semantic-release:github create comment: { owner: 'REPO_OWNER',\n[23:20:50][Step 8/8]   repo: 'REPO_NAME',\n[23:20:50][Step 8/8]   number: 11,\n[23:20:50][Step 8/8]   body: ':tada: This PR is included in version 1.0.0-alpha.1 :tada:\\n\\nThe release is available on:\\n- `npm package (@alpha dist-tag)`\\n- [GitHub release](https://github.com/REPO_OWNER/REPO_NAME/releases/tag/v1.0.0-alpha.1%40alpha)\\n\\nYour **[semantic-release](https://github.com/semantic-release/semantic-release)** bot :package::rocket:' }\n[23:20:50][Step 8/8] 2019-01-10T23:20:50.336Z semantic-release:github create comment: { owner: 'REPO_OWNER',\n[23:20:50][Step 8/8]   repo: 'REPO_NAME',\n[23:20:50][Step 8/8]   number: 9,\n[23:20:50][Step 8/8]   body: ':tada: This PR is included in version 1.0.0-alpha.1 :tada:\\n\\nThe release is available on:\\n- `npm package (@alpha dist-tag)`\\n- [GitHub release](https://github.com/REPO_OWNER/REPO_NAME/releases/tag/v1.0.0-alpha.1%40alpha)\\n\\nYour **[semantic-release](https://github.com/semantic-release/semantic-release)** bot :package::rocket:' }\n[23:20:50][Step 8/8] 2019-01-10T23:20:50.336Z semantic-release:github create comment: { owner: 'REPO_OWNER',\n[23:20:50][Step 8/8]   repo: 'REPO_NAME',\n[23:20:50][Step 8/8]   number: 8,\n[23:20:50][Step 8/8]   body: ':tada: This PR is included in version 1.0.0-alpha.1 :tada:\\n\\nThe release is available on:\\n- `npm package (@alpha dist-tag)`\\n- [GitHub release](https://github.com/REPO_OWNER/REPO_NAME/releases/tag/v1.0.0-alpha.1%40alpha)\\n\\nYour **[semantic-release](https://github.com/semantic-release/semantic-release)** bot :package::rocket:' }\n[23:20:50][Step 8/8] 2019-01-10T23:20:50.336Z semantic-release:github create comment: { owner: 'REPO_OWNER',\n[23:20:50][Step 8/8]   repo: 'REPO_NAME',\n[23:20:50][Step 8/8]   number: 7,\n[23:20:50][Step 8/8]   body: ':tada: This PR is included in version 1.0.0-alpha.1 :tada:\\n\\nThe release is available on:\\n- `npm package (@alpha dist-tag)`\\n- [GitHub release](https://github.com/REPO_OWNER/REPO_NAME/releases/tag/v1.0.0-alpha.1%40alpha)\\n\\nYour **[semantic-release](https://github.com/semantic-release/semantic-release)** bot :package::rocket:' }\n[23:20:50][Step 8/8] 2019-01-10T23:20:50.337Z semantic-release:github create comment: { owner: 'REPO_OWNER',\n[23:20:50][Step 8/8]   repo: 'REPO_NAME',\n[23:20:50][Step 8/8]   number: 6,\n[23:20:50][Step 8/8]   body: ':tada: This PR is included in version 1.0.0-alpha.1 :tada:\\n\\nThe release is available on:\\n- `npm package (@alpha dist-tag)`\\n- [GitHub release](https://github.com/REPO_OWNER/REPO_NAME/releases/tag/v1.0.0-alpha.1%40alpha)\\n\\nYour **[semantic-release](https://github.com/semantic-release/semantic-release)** bot :package::rocket:' }\n[23:20:50][Step 8/8] 2019-01-10T23:20:50.337Z semantic-release:github create comment: { owner: 'REPO_OWNER',\n[23:20:50][Step 8/8]   repo: 'REPO_NAME',\n[23:20:50][Step 8/8]   number: 5,\n[23:20:50][Step 8/8]   body: ':tada: This PR is included in version 1.0.0-alpha.1 :tada:\\n\\nThe release is available on:\\n- `npm package (@alpha dist-tag)`\\n- [GitHub release](https://github.com/REPO_OWNER/REPO_NAME/releases/tag/v1.0.0-alpha.1%40alpha)\\n\\nYour **[semantic-release](https://github.com/semantic-release/semantic-release)** bot :package::rocket:' }\n[23:20:50][Step 8/8] 2019-01-10T23:20:50.337Z semantic-release:github create comment: { owner: 'REPO_OWNER',\n[23:20:50][Step 8/8]   repo: 'REPO_NAME',\n[23:20:50][Step 8/8]   number: 4,\n[23:20:50][Step 8/8]   body: ':tada: This PR is included in version 1.0.0-alpha.1 :tada:\\n\\nThe release is available on:\\n- `npm package (@alpha dist-tag)`\\n- [GitHub release](https://github.com/REPO_OWNER/REPO_NAME/releases/tag/v1.0.0-alpha.1%40alpha)\\n\\nYour **[semantic-release](https://github.com/semantic-release/semantic-release)** bot :package::rocket:' }\n[23:20:50][Step 8/8] 2019-01-10T23:20:50.338Z semantic-release:github create comment: { owner: 'REPO_OWNER',\n[23:20:50][Step 8/8]   repo: 'REPO_NAME',\n[23:20:50][Step 8/8]   number: 3,\n[23:20:50][Step 8/8]   body: ':tada: This PR is included in version 1.0.0-alpha.1 :tada:\\n\\nThe release is available on:\\n- `npm package (@alpha dist-tag)`\\n- [GitHub release](https://github.com/REPO_OWNER/REPO_NAME/releases/tag/v1.0.0-alpha.1%40alpha)\\n\\nYour **[semantic-release](https://github.com/semantic-release/semantic-release)** bot :package::rocket:' }\n[23:20:50][Step 8/8] 2019-01-10T23:20:50.338Z semantic-release:github create comment: { owner: 'REPO_OWNER',\n[23:20:50][Step 8/8]   repo: 'REPO_NAME',\n[23:20:50][Step 8/8]   number: 1,\n[23:20:50][Step 8/8]   body: ':tada: This PR is included in version 1.0.0-alpha.1 :tada:\\n\\nThe release is available on:\\n- `npm package (@alpha dist-tag)`\\n- [GitHub release](https://github.com/REPO_OWNER/REPO_NAME/releases/tag/v1.0.0-alpha.1%40alpha)\\n\\nYour **[semantic-release](https://github.com/semantic-release/semantic-release)** bot :package::rocket:' }\n[23:20:50][Step 8/8] 2019-01-10T23:20:50.338Z semantic-release:github create comment: { owner: 'REPO_OWNER',\n[23:20:50][Step 8/8]   repo: 'REPO_NAME',\n[23:20:50][Step 8/8]   number: 2,\n[23:20:50][Step 8/8]   body: ':tada: This PR is included in version 1.0.0-alpha.1 :tada:\\n\\nThe release is available on:\\n- `npm package (@alpha dist-tag)`\\n- [GitHub release](https://github.com/REPO_OWNER/REPO_NAME/releases/tag/v1.0.0-alpha.1%40alpha)\\n\\nYour **[semantic-release](https://github.com/semantic-release/semantic-release)** bot :package::rocket:' }\n[23:20:51][Step 8/8] [23:20:51] [semantic-release] [@semantic-release/github] \u203a \u2139  Added comment to issue #10: https://github.com/REPO_OWNER/REPO_NAME/pull/10#issuecomment-453297310\n[23:20:54][Step 8/8] [23:20:53] [semantic-release] [@semantic-release/github] \u203a \u2139  Added comment to issue #11: https://github.com/REPO_OWNER/REPO_NAME/pull/11#issuecomment-453297325\n[23:20:57][Step 8/8] [23:20:57] [semantic-release] [@semantic-release/github] \u203a \u2139  Added comment to issue #9: https://github.com/REPO_OWNER/REPO_NAME/pull/9#issuecomment-453297336\n[23:21:00][Step 8/8] [23:21:00] [semantic-release] [@semantic-release/github] \u203a \u2139  Added comment to issue #8: https://github.com/REPO_OWNER/REPO_NAME/pull/8#issuecomment-453297344\n[23:21:03][Step 8/8] [23:21:03] [semantic-release] [@semantic-release/github] \u203a \u2139  Added comment to issue #7: https://github.com/REPO_OWNER/REPO_NAME/pull/7#issuecomment-453297357\n[23:21:06][Step 8/8] [23:21:06] [semantic-release] [@semantic-release/github] \u203a \u2139  Added comment to issue #6: https://github.com/REPO_OWNER/REPO_NAME/pull/6#issuecomment-453297386\n[23:21:09][Step 8/8] [23:21:09] [semantic-release] [@semantic-release/github] \u203a \u2139  Added comment to issue #5: https://github.com/REPO_OWNER/REPO_NAME/pull/5#issuecomment-453297409\n[23:21:12][Step 8/8] [23:21:12] [semantic-release] [@semantic-release/github] \u203a \u2139  Added comment to issue #4: https://github.com/REPO_OWNER/REPO_NAME/pull/4#issuecomment-453297420\n[23:21:15][Step 8/8] [23:21:15] [semantic-release] [@semantic-release/github] \u203a \u2139  Added comment to issue #3: https://github.com/REPO_OWNER/REPO_NAME/pull/3#issuecomment-453297446\n[23:21:18][Step 8/8] [23:21:18] [semantic-release] [@semantic-release/github] \u203a \u2139  Added comment to issue #1: https://github.com/REPO_OWNER/REPO_NAME/pull/1#issuecomment-453297463\n[23:21:21][Step 8/8] [23:21:21] [semantic-release] [@semantic-release/github] \u203a \u2139  Added comment to issue #2: https://github.com/REPO_OWNER/REPO_NAME/pull/2#issuecomment-453297481\n[23:21:23][Step 8/8] [23:21:23] [semantic-release] [@semantic-release/github] \u203a \u2139  Added labels [ 'released on @alpha' ] to issue #10\n[23:21:26][Step 8/8] [23:21:26] [semantic-release] [@semantic-release/github] \u203a \u2139  Added labels [ 'released on @alpha' ] to issue #11\n[23:21:29][Step 8/8] [23:21:29] [semantic-release] [@semantic-release/github] \u203a \u2139  Added labels [ 'released on @alpha' ] to issue #9\n[23:21:32][Step 8/8] [23:21:32] [semantic-release] [@semantic-release/github] \u203a \u2139  Added labels [ 'released on @alpha' ] to issue #8\n[23:21:35][Step 8/8] [23:21:35] [semantic-release] [@semantic-release/github] \u203a \u2139  Added labels [ 'released on @alpha' ] to issue #7\n[23:21:38][Step 8/8] [23:21:38] [semantic-release] [@semantic-release/github] \u203a \u2139  Added labels [ 'released on @alpha' ] to issue #6\n[23:21:41][Step 8/8] [23:21:41] [semantic-release] [@semantic-release/github] \u203a \u2139  Added labels [ 'released on @alpha' ] to issue #5\n[23:21:44][Step 8/8] [23:21:44] [semantic-release] [@semantic-release/github] \u203a \u2139  Added labels [ 'released on @alpha' ] to issue #4\n[23:21:47][Step 8/8] [23:21:47] [semantic-release] [@semantic-release/github] \u203a \u2139  Added labels [ 'released on @alpha' ] to issue #3\n[23:21:50][Step 8/8] [23:21:50] [semantic-release] [@semantic-release/github] \u203a \u2139  Added labels [ 'released on @alpha' ] to issue #1\n[23:21:53][Step 8/8] [23:21:53] [semantic-release] [@semantic-release/github] \u203a \u2139  Added labels [ 'released on @alpha' ] to issue #2\n[23:21:54][Step 8/8] 2019-01-10T23:21:54.226Z semantic-release:github found semantic-release issues: []\n[23:21:54][Step 8/8] [23:21:54] [semantic-release] \u203a \u2714  Completed step \"success\" of plugin \"@semantic-release/github\"\n[23:21:54][Step 8/8] [23:21:54] [semantic-release] \u203a \u2714  Published release 1.0.0-alpha.1\n[23:21:54][Step 8/8] Process exited with code 0\nI should be able to create a repo if you think that will help?. I've just ran this locally and I get the same results; an 'undefined' branch is pushed to the repo.\nLogs:\n```\n09:50: ~/REPO_OWNER/REPO_NAME alpha$ npx semantic-release --debug --no-ci\n[09:51:26] [semantic-release] \u203a \u2139  Running semantic-release version 16.0.0-beta.16\n  semantic-release:config load config from: /Users/paul.blyth/REPO_OWNER/REPO_NAME/.releaserc.json +0ms\n  semantic-release:config options values: { branches:\n  semantic-release:config    [ 'master',\n  semantic-release:config      { branch: 'alpha', name: 'alpha', prerelease: true } ],\n  semantic-release:config   repositoryUrl: 'git@github.com:REPO_OWNER/REPO_NAME.git',\n  semantic-release:config   tagFormat: 'v${version}',\n  semantic-release:config   plugins:\n  semantic-release:config    [ '@semantic-release/commit-analyzer',\n  semantic-release:config      '@semantic-release/release-notes-generator',\n  semantic-release:config      '@semantic-release/npm',\n  semantic-release:config      '@semantic-release/github' ],\n  semantic-release:config   generateNotes: [ '@semantic-release/release-notes-generator' ],\n  semantic-release:config   prepare:\n  semantic-release:config    [ '@semantic-release/changelog',\n  semantic-release:config      '@semantic-release/npm',\n  semantic-release:config      { path: '@semantic-release/git',\n  semantic-release:config        assets: [Array],\n  semantic-release:config        message: 'chore(release): ${nextRelease.version} [skip ci]\\n\\n${nextRelease.notes}' } ],\n  semantic-release:config   analyzeCommits:\n  semantic-release:config    { preset: 'angular',\n  semantic-release:config      releaseRules:\n  semantic-release:config       [ [Object],\n  semantic-release:config         [Object],\n  semantic-release:config         [Object],\n  semantic-release:config         [Object],\n  semantic-release:config         [Object],\n  semantic-release:config         [Object],\n  semantic-release:config         [Object] ] },\n  semantic-release:config   _: [],\n  semantic-release:config   debug: true,\n  semantic-release:config   ci: false,\n  semantic-release:config   '$0': 'node_modules/.bin/semantic-release',\n  semantic-release:config   noCi: true } +4ms\n  semantic-release:plugins options for @semantic-release/npm/verifyConditions: {} +0ms\n[09:51:27] [semantic-release] \u203a \u2714  Loaded plugin \"verifyConditions\" from \"@semantic-release/npm\"\n  semantic-release:plugins options for @semantic-release/github/verifyConditions: {} +1ms\n[09:51:27] [semantic-release] \u203a \u2714  Loaded plugin \"verifyConditions\" from \"@semantic-release/github\"\n  semantic-release:plugins options for @semantic-release/commit-analyzer/analyzeCommits: { preset: 'angular',\n  semantic-release:plugins   releaseRules:\n  semantic-release:plugins    [ { type: 'docs', release: 'patch' },\n  semantic-release:plugins      { type: 'refactor', release: 'patch' },\n  semantic-release:plugins      { type: 'style', release: 'patch' },\n  semantic-release:plugins      { type: 'test', release: 'patch' },\n  semantic-release:plugins      { type: 'build', release: 'patch' },\n  semantic-release:plugins      { type: 'ci', release: 'patch' },\n  semantic-release:plugins      { type: 'chore', release: 'patch' } ] } +1ms\n[09:51:27] [semantic-release] \u203a \u2714  Loaded plugin \"analyzeCommits\" from \"@semantic-release/commit-analyzer\"\n  semantic-release:plugins options for @semantic-release/release-notes-generator/generateNotes: {} +0ms\n[09:51:27] [semantic-release] \u203a \u2714  Loaded plugin \"generateNotes\" from \"@semantic-release/release-notes-generator\"\n  semantic-release:plugins options for @semantic-release/changelog/prepare: {} +9ms\n[09:51:27] [semantic-release] \u203a \u2714  Loaded plugin \"prepare\" from \"@semantic-release/changelog\"\n  semantic-release:plugins options for @semantic-release/npm/prepare: {} +0ms\n[09:51:27] [semantic-release] \u203a \u2714  Loaded plugin \"prepare\" from \"@semantic-release/npm\"\n  semantic-release:plugins options for @semantic-release/git/prepare: { assets: [ 'CHANGELOG.md', 'package.json', 'package-lock.json' ],\n  semantic-release:plugins   message: 'chore(release): ${nextRelease.version} [skip ci]\\n\\n${nextRelease.notes}' } +135ms\n[09:51:27] [semantic-release] \u203a \u2714  Loaded plugin \"prepare\" from \"@semantic-release/git\"\n  semantic-release:plugins options for @semantic-release/npm/publish: {} +1ms\n[09:51:27] [semantic-release] \u203a \u2714  Loaded plugin \"publish\" from \"@semantic-release/npm\"\n  semantic-release:plugins options for @semantic-release/github/publish: {} +0ms\n[09:51:27] [semantic-release] \u203a \u2714  Loaded plugin \"publish\" from \"@semantic-release/github\"\n  semantic-release:plugins options for @semantic-release/npm/addChannel: {} +0ms\n[09:51:27] [semantic-release] \u203a \u2714  Loaded plugin \"addChannel\" from \"@semantic-release/npm\"\n  semantic-release:plugins options for @semantic-release/github/addChannel: {} +0ms\n[09:51:27] [semantic-release] \u203a \u2714  Loaded plugin \"addChannel\" from \"@semantic-release/github\"\n  semantic-release:plugins options for @semantic-release/github/success: {} +1ms\n[09:51:27] [semantic-release] \u203a \u2714  Loaded plugin \"success\" from \"@semantic-release/github\"\n  semantic-release:plugins options for @semantic-release/github/fail: {} +0ms\n[09:51:27] [semantic-release] \u203a \u2714  Loaded plugin \"fail\" from \"@semantic-release/github\"\n  semantic-release:get-tags found tags: [] +0ms\n  semantic-release:get-tags found tags for branch master: [] +0ms\n  semantic-release:get-tags found tags for branch alpha: [] +1ms\n[09:51:31] [semantic-release] \u203a \u2714  Run automated release from branch alpha\n[09:51:34] [semantic-release] \u203a \u2714  Allowed to push to the Git repository\n[09:51:34] [semantic-release] \u203a \u2139  Start step \"verifyConditions\" of plugin \"@semantic-release/npm\"\n[09:51:34] [semantic-release] [@semantic-release/npm] \u203a \u2139  Verify authentication for registry https://packages.REPO_OWNER.com/repository/npm-private-client/\n[09:51:34] [semantic-release] [@semantic-release/npm] \u203a \u2139  Wrote NPM_TOKEN to /Users/paul.blyth/REPO_OWNER/REPO_NAME/.npmrc\n[09:51:34] [semantic-release] \u203a \u2714  Completed step \"verifyConditions\" of plugin \"@semantic-release/npm\"\n[09:51:34] [semantic-release] \u203a \u2139  Start step \"verifyConditions\" of plugin \"@semantic-release/github\"\n[09:51:34] [semantic-release] [@semantic-release/github] \u203a \u2139  Verify GitHub authentication\n[09:51:35] [semantic-release] \u203a \u2714  Completed step \"verifyConditions\" of plugin \"@semantic-release/github\"\n[09:51:35] [semantic-release] \u203a \u2139  No git tag version found on branch alpha\n[09:51:35] [semantic-release] \u203a \u2139  No previous release found, retrieving all commits\n[09:51:35] [semantic-release] \u203a \u2139  Found 23 commits since last release\n  semantic-release:get-commits Parsed commits: [ { commit: { long: '252950698961461a3bfb975911fe46ee1cfb27d5', short: '2529506' }, tree: { long: '69403c84472d53d7de7928f16436e2aa98259950', short: '69403c8' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-10T23:18:09.000Z }, committer: { name: 'GitHub', email: 'noreply@github.com', date: 2019-01-10T23:18:09.000Z }, subject: 'Merge pull request #11 from REPO_OWNER/PI-6588/resolve-alpha-release-issues', body: 'chore(npm): Added semantic-release/changelog dependency', hash: '252950698961461a3bfb975911fe46ee1cfb27d5', committerDate: 2019-01-10T23:18:09.000Z, message: 'Merge pull request #11 from REPO_OWNER/PI-6588/resolve-alpha-release-issues\\n\\nchore(npm): Added semantic-release/changelog dependency', gitTags: '(HEAD -> alpha, origin/alpha)' }, { commit: { long: 'b8000429d5ab19f15c43feb241a00e3b633217d5', short: 'b800042' }, tree: { long: '69403c84472d53d7de7928f16436e2aa98259950', short: '69403c8' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-10T23:16:04.000Z }, committer: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-10T23:16:04.000Z }, subject: 'chore(npm): Added semantic-release/changelog dependency', body: '', hash: 'b8000429d5ab19f15c43feb241a00e3b633217d5', committerDate: 2019-01-10T23:16:04.000Z, message: 'chore(npm): Added semantic-release/changelog dependency', gitTags: '(PI-6588/resolve-alpha-release-issues)' }, { commit: { long: 'd79970f2811d9d51bfd159618cde9796a1d4c5b2', short: 'd79970f' }, tree: { long: '057abed4b801bb79c0143016148d6b427b13b4b3', short: '057abed' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-10T23:10:08.000Z }, committer: { name: 'GitHub', email: 'noreply@github.com', date: 2019-01-10T23:10:08.000Z }, subject: 'Merge pull request #10 from REPO_OWNER/PI-6588/resolve-alpha-release-issues', body: 'Pi 6588/resolve alpha release issues', hash: 'd79970f2811d9d51bfd159618cde9796a1d4c5b2', committerDate: 2019-01-10T23:10:08.000Z, message: 'Merge pull request #10 from REPO_OWNER/PI-6588/resolve-alpha-release-issues\\n\\nPi 6588/resolve alpha release issues', gitTags: '' }, { commit: { long: '110ea0f329afc1e6e79f373112122ee2fe8d80f4', short: '110ea0f' }, tree: { long: '057abed4b801bb79c0143016148d6b427b13b4b3', short: '057abed' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-10T23:01:02.000Z }, committer: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-10T23:01:02.000Z }, subject: 'build(npm): Removed references to semantic-release plugins automatically installed', body: '', hash: '110ea0f329afc1e6e79f373112122ee2fe8d80f4', committerDate: 2019-01-10T23:01:02.000Z, message: 'build(npm): Removed references to semantic-release plugins automatically installed', gitTags: '' }, { commit: { long: '7945bb56e57999a204a6c680e34a63185e6d65a4', short: '7945bb5' }, tree: { long: 'bc2a0a814ecd47773ddbfe7923e29e9c1efd8670', short: 'bc2a0a8' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-10T12:25:43.000Z }, committer: { name: 'GitHub', email: 'noreply@github.com', date: 2019-01-10T12:25:43.000Z }, subject: 'Merge pull request #9 from REPO_OWNER/PI-6570/add-demo', body: 'chore(demo): Added basic demo app', hash: '7945bb56e57999a204a6c680e34a63185e6d65a4', committerDate: 2019-01-10T12:25:43.000Z, message: 'Merge pull request #9 from REPO_OWNER/PI-6570/add-demo\\n\\nchore(demo): Added basic demo app', gitTags: '(origin/master, master, PI-6573/add-10-minute-warning-component)' }, { commit: { long: '7b11ea2fa68abd47f2e8d890e224e773e27832ac', short: '7b11ea2' }, tree: { long: 'bc2a0a814ecd47773ddbfe7923e29e9c1efd8670', short: 'bc2a0a8' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-10T12:11:10.000Z }, committer: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-10T12:11:29.000Z }, subject: 'chore(demo): Added basic demo app', body: '', hash: '7b11ea2fa68abd47f2e8d890e224e773e27832ac', committerDate: 2019-01-10T12:11:29.000Z, message: 'chore(demo): Added basic demo app', gitTags: '(PI-6570/add-demo)' }, { commit: { long: '0284001bc020f69f4a8af569cf0c0adbe8b2a073', short: '0284001' }, tree: { long: '3ee7be89c537d4ff23debd3b92cfb59aa8e3e132', short: '3ee7be8' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-10T10:05:56.000Z }, committer: { name: 'GitHub', email: 'noreply@github.com', date: 2019-01-10T10:05:56.000Z }, subject: 'Merge pull request #8 from REPO_OWNER/alpha', body: 'Merge alpha setup changes into master', hash: '0284001bc020f69f4a8af569cf0c0adbe8b2a073', committerDate: 2019-01-10T10:05:56.000Z, message: 'Merge pull request #8 from REPO_OWNER/alpha\\n\\nMerge alpha setup changes into master', gitTags: '' }, { commit: { long: '10c3f2dd4cb749d995703cfcc1df1ec893ac40f4', short: '10c3f2d' }, tree: { long: '3ee7be89c537d4ff23debd3b92cfb59aa8e3e132', short: '3ee7be8' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-09T15:42:18.000Z }, committer: { name: 'GitHub', email: 'noreply@github.com', date: 2019-01-09T15:42:18.000Z }, subject: 'Merge pull request #7 from REPO_OWNER/PI-6517/add-branch-to-release-config', body: 'build(semantic-release): Added branch to alpha config', hash: '10c3f2dd4cb749d995703cfcc1df1ec893ac40f4', committerDate: 2019-01-09T15:42:18.000Z, message: 'Merge pull request #7 from REPO_OWNER/PI-6517/add-branch-to-release-config\\n\\nbuild(semantic-release): Added branch to alpha config', gitTags: '' }, { commit: { long: '868599be7524714cc1aeecdbe2b84b892602c645', short: '868599b' }, tree: { long: '3ee7be89c537d4ff23debd3b92cfb59aa8e3e132', short: '3ee7be8' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-09T15:39:55.000Z }, committer: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-09T15:39:55.000Z }, subject: 'build(semantic-release): Added branch to alpha config', body: '', hash: '868599be7524714cc1aeecdbe2b84b892602c645', committerDate: 2019-01-09T15:39:55.000Z, message: 'build(semantic-release): Added branch to alpha config', gitTags: '(PI-6517/add-branch-to-release-config)' }, { commit: { long: '3ad9a845c40f2600b3480ac73a98e827859d120e', short: '3ad9a84' }, tree: { long: '516cf5b54dbab825f99c7c0a8dc400b0add27df3', short: '516cf5b' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-09T15:19:36.000Z }, committer: { name: 'GitHub', email: 'noreply@github.com', date: 2019-01-09T15:19:36.000Z }, subject: 'Merge pull request #6 from REPO_OWNER/PI-6517/correct-typings', body: 'build(types): Prevent spec types being output do the dist', hash: '3ad9a845c40f2600b3480ac73a98e827859d120e', committerDate: 2019-01-09T15:19:36.000Z, message: 'Merge pull request #6 from REPO_OWNER/PI-6517/correct-typings\\n\\nbuild(types): Prevent spec types being output do the dist', gitTags: '' }, { commit: { long: 'f3cb0c454380b3089ae05f0ecd444092164fb954', short: 'f3cb0c4' }, tree: { long: '516cf5b54dbab825f99c7c0a8dc400b0add27df3', short: '516cf5b' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-09T15:16:12.000Z }, committer: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-09T15:16:12.000Z }, subject: 'build(types): Prevent spec types being output do the dist', body: '', hash: 'f3cb0c454380b3089ae05f0ecd444092164fb954', committerDate: 2019-01-09T15:16:12.000Z, message: 'build(types): Prevent spec types being output do the dist', gitTags: '(PI-6517/correct-typings)' }, { commit: { long: 'f12bf7a03d1bc69cac2e95a619de4b5734ed8492', short: 'f12bf7a' }, tree: { long: '75fc7ea05473f91989e6c421cacff3514e7d0922', short: '75fc7ea' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-09T14:27:58.000Z }, committer: { name: 'GitHub', email: 'noreply@github.com', date: 2019-01-09T14:27:58.000Z }, subject: 'Merge pull request #5 from REPO_OWNER/PI-6517/harden-publish-config', body: 'build(npm): Added publish config with the registry', hash: 'f12bf7a03d1bc69cac2e95a619de4b5734ed8492', committerDate: 2019-01-09T14:27:58.000Z, message: 'Merge pull request #5 from REPO_OWNER/PI-6517/harden-publish-config\\n\\nbuild(npm): Added publish config with the registry', gitTags: '' }, { commit: { long: '5a0e6e055eb49dc824a861d05b4807b9501e47fa', short: '5a0e6e0' }, tree: { long: '75fc7ea05473f91989e6c421cacff3514e7d0922', short: '75fc7ea' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-09T13:35:19.000Z }, committer: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-09T13:35:19.000Z }, subject: 'build(npm): Added publish config with the registry', body: '', hash: '5a0e6e055eb49dc824a861d05b4807b9501e47fa', committerDate: 2019-01-09T13:35:19.000Z, message: 'build(npm): Added publish config with the registry', gitTags: '(PI-6517/harden-publish-config)' }, { commit: { long: '6b808a124cbcbb3eef407c4b3f9940b86dc8d909', short: '6b808a1' }, tree: { long: '7b91ef22a4389de9699b711ff048029f917211dd', short: '7b91ef2' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-09T10:26:22.000Z }, committer: { name: 'GitHub', email: 'noreply@github.com', date: 2019-01-09T10:26:22.000Z }, subject: 'Merge pull request #4 from REPO_OWNER/PI-6517/allow-alpha-releases', body: 'build(semantic-release): Allow releases from an alpha branch', hash: '6b808a124cbcbb3eef407c4b3f9940b86dc8d909', committerDate: 2019-01-09T10:26:22.000Z, message: 'Merge pull request #4 from REPO_OWNER/PI-6517/allow-alpha-releases\\n\\nbuild(semantic-release): Allow releases from an alpha branch', gitTags: '' }, { commit: { long: 'b12a416497fe272b009cc0edac3987da1a8fdb4e', short: 'b12a416' }, tree: { long: '7b91ef22a4389de9699b711ff048029f917211dd', short: '7b91ef2' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-08T17:13:08.000Z }, committer: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-09T09:55:04.000Z }, subject: 'build(semantic-release): Allow releases from an alpha branch', body: '', hash: 'b12a416497fe272b009cc0edac3987da1a8fdb4e', committerDate: 2019-01-09T09:55:04.000Z, message: 'build(semantic-release): Allow releases from an alpha branch', gitTags: '' }, { commit: { long: '17c33c9c5e64d1967e9641c7a06b6de0a9c404a8', short: '17c33c9' }, tree: { long: 'e74209682d33fd1fb5569e0319b660cb395e0c87', short: 'e742096' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-08T16:34:37.000Z }, committer: { name: 'GitHub', email: 'noreply@github.com', date: 2019-01-08T16:34:37.000Z }, subject: 'Merge pull request #3 from REPO_OWNER/PI-6517/update-package-name', body: 'chore(repo): Updated package name and move release config to separate\u2026', hash: '17c33c9c5e64d1967e9641c7a06b6de0a9c404a8', committerDate: 2019-01-08T16:34:37.000Z, message: 'Merge pull request #3 from REPO_OWNER/PI-6517/update-package-name\\n\\nchore(repo): Updated package name and move release config to separate\u2026', gitTags: '' }, { commit: { long: '7182c5b11a60062b7d471e9647b0770c2a73cd7d', short: '7182c5b' }, tree: { long: 'e74209682d33fd1fb5569e0319b660cb395e0c87', short: 'e742096' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-08T16:29:44.000Z }, committer: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-08T16:30:33.000Z }, subject: 'chore(repo): Updated package name and move release config to separate file', body: '', hash: '7182c5b11a60062b7d471e9647b0770c2a73cd7d', committerDate: 2019-01-08T16:30:33.000Z, message: 'chore(repo): Updated package name and move release config to separate file', gitTags: '' }, { commit: { long: '501e6bc1fdf86ec515356562ab3fd0289467a193', short: '501e6bc' }, tree: { long: '9e516dd85055ec2b9d454bb17aa5118dd4ccd216', short: '9e516dd' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-08T15:18:21.000Z }, committer: { name: 'GitHub', email: 'noreply@github.com', date: 2019-01-08T15:18:21.000Z }, subject: 'Merge pull request #1 from REPO_OWNER/PI-6517/update-coverage-threshold', body: 'chore(config): Updated jest config for a higher coverage threshold', hash: '501e6bc1fdf86ec515356562ab3fd0289467a193', committerDate: 2019-01-08T15:18:21.000Z, message: 'Merge pull request #1 from REPO_OWNER/PI-6517/update-coverage-threshold\\n\\nchore(config): Updated jest config for a higher coverage threshold', gitTags: '' }, { commit: { long: 'e58ff83deb32e44b59641915075cca7c02ce95be', short: 'e58ff83' }, tree: { long: '9e516dd85055ec2b9d454bb17aa5118dd4ccd216', short: '9e516dd' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-08T11:14:01.000Z }, committer: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-08T15:16:08.000Z }, subject: 'chore(config): Updated jest config for a higher coverage threshold', body: '', hash: 'e58ff83deb32e44b59641915075cca7c02ce95be', committerDate: 2019-01-08T15:16:08.000Z, message: 'chore(config): Updated jest config for a higher coverage threshold', gitTags: '' }, { commit: { long: '9c7bd1d5fe6c90aaf9751d1fac54443d4be2fbfe', short: '9c7bd1d' }, tree: { long: '6a8c87e83d0cf0f9f23091a9848e2430ed2d9bf0', short: '6a8c87e' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-08T14:52:33.000Z }, committer: { name: 'GitHub', email: 'noreply@github.com', date: 2019-01-08T14:52:33.000Z }, subject: 'Merge pull request #2 from REPO_OWNER/PI-6517/add-bash-scripts-to-enforce-node-version', body: 'build(npm): Check node version before scripts are executed', hash: '9c7bd1d5fe6c90aaf9751d1fac54443d4be2fbfe', committerDate: 2019-01-08T14:52:33.000Z, message: 'Merge pull request #2 from REPO_OWNER/PI-6517/add-bash-scripts-to-enforce-node-version\\n\\nbuild(npm): Check node version before scripts are executed', gitTags: '' }, { commit: { long: 'e8b0ef1691207473f20b23741b07e1ffa6317cf5', short: 'e8b0ef1' }, tree: { long: '6a8c87e83d0cf0f9f23091a9848e2430ed2d9bf0', short: '6a8c87e' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-08T14:30:06.000Z }, committer: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-08T14:30:06.000Z }, subject: 'build(npm): Added lint command', body: '', hash: 'e8b0ef1691207473f20b23741b07e1ffa6317cf5', committerDate: 2019-01-08T14:30:06.000Z, message: 'build(npm): Added lint command', gitTags: '' }, { commit: { long: '05c44e30d5e3ea7a2486287eabefd29da99ff51f', short: '05c44e3' }, tree: { long: 'e404f634a430d033293139e14cec9b161508d7a9', short: 'e404f63' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-08T13:48:29.000Z }, committer: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-08T13:48:29.000Z }, subject: 'build(npm): Check node version before scripts are executed', body: '', hash: '05c44e30d5e3ea7a2486287eabefd29da99ff51f', committerDate: 2019-01-08T13:48:29.000Z, message: 'build(npm): Check node version before scripts are executed', gitTags: '' }, { commit: { long: '6d080bd9d7d3b23c5e078f707742296fff4330f2', short: '6d080bd' }, tree: { long: '734ecb414d0f3335a40e562c06fb8a4c875a4fe1', short: '734ecb4' }, author: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-07T16:58:38.000Z }, committer: { name: 'Paul Blyth', email: 'paul@paulblyth.co.uk', date: 2019-01-07T17:00:04.000Z }, subject: 'build(repo): Initial setup of the project/repo', body: '', hash: '6d080bd9d7d3b23c5e078f707742296fff4330f2', committerDate: 2019-01-07T17:00:04.000Z, message: 'build(repo): Initial setup of the project/repo', gitTags: '' } ] +0ms\n[09:51:35] [semantic-release] \u203a \u2139  Start step \"analyzeCommits\" of plugin \"@semantic-release/commit-analyzer\"\n[09:51:35] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: Merge pull request #11 from REPO_OWNER/PI-6588/resolve-alpha-release-issues\nchore(npm): Added semantic-release/changelog dependency\n  semantic-release:commit-analyzer Analyzing with custom rules +0ms\n  semantic-release:commit-analyzer Analyzing with default rules +1ms\n[09:51:35] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The commit should not trigger a release\n[09:51:35] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: chore(npm): Added semantic-release/changelog dependency\n  semantic-release:commit-analyzer Analyzing with custom rules +0ms\n  semantic-release:commit-analyzer The rule { type: 'chore', release: 'patch' } match commit with release type 'patch' +0ms\n[09:51:35] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The release type for the commit is patch\n[09:51:35] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: Merge pull request #10 from REPO_OWNER/PI-6588/resolve-alpha-release-issues\nPi 6588/resolve alpha release issues\n  semantic-release:commit-analyzer Analyzing with custom rules +2ms\n  semantic-release:commit-analyzer Analyzing with default rules +0ms\n[09:51:35] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The commit should not trigger a release\n[09:51:35] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: build(npm): Removed references to semantic-release plugins automatically installed\n  semantic-release:commit-analyzer Analyzing with custom rules +1ms\n  semantic-release:commit-analyzer The rule { type: 'build', release: 'patch' } match commit with release type 'patch' +1ms\n[09:51:35] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The release type for the commit is patch\n[09:51:35] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: Merge pull request #9 from REPO_OWNER/PI-6570/add-demo\nchore(demo): Added basic demo app\n  semantic-release:commit-analyzer Analyzing with custom rules +0ms\n  semantic-release:commit-analyzer Analyzing with default rules +0ms\n[09:51:35] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The commit should not trigger a release\n[09:51:35] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: chore(demo): Added basic demo app\n  semantic-release:commit-analyzer Analyzing with custom rules +1ms\n  semantic-release:commit-analyzer The rule { type: 'chore', release: 'patch' } match commit with release type 'patch' +1ms\n[09:51:35] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The release type for the commit is patch\n[09:51:35] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: Merge pull request #8 from REPO_OWNER/alpha\nMerge alpha setup changes into master\n  semantic-release:commit-analyzer Analyzing with custom rules +0ms\n  semantic-release:commit-analyzer Analyzing with default rules +1ms\n[09:51:35] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The commit should not trigger a release\n[09:51:35] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: Merge pull request #7 from REPO_OWNER/PI-6517/add-branch-to-release-config\nbuild(semantic-release): Added branch to alpha config\n  semantic-release:commit-analyzer Analyzing with custom rules +0ms\n  semantic-release:commit-analyzer Analyzing with default rules +0ms\n[09:51:35] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The commit should not trigger a release\n[09:51:35] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: build(semantic-release): Added branch to alpha config\n  semantic-release:commit-analyzer Analyzing with custom rules +0ms\n  semantic-release:commit-analyzer The rule { type: 'build', release: 'patch' } match commit with release type 'patch' +1ms\n[09:51:35] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The release type for the commit is patch\n[09:51:35] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: Merge pull request #6 from REPO_OWNER/PI-6517/correct-typings\nbuild(types): Prevent spec types being output do the dist\n  semantic-release:commit-analyzer Analyzing with custom rules +1ms\n  semantic-release:commit-analyzer Analyzing with default rules +0ms\n[09:51:35] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The commit should not trigger a release\n[09:51:35] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: build(types): Prevent spec types being output do the dist\n  semantic-release:commit-analyzer Analyzing with custom rules +0ms\n  semantic-release:commit-analyzer The rule { type: 'build', release: 'patch' } match commit with release type 'patch' +5ms\n[09:51:35] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The release type for the commit is patch\n[09:51:35] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: Merge pull request #5 from REPO_OWNER/PI-6517/harden-publish-config\nbuild(npm): Added publish config with the registry\n  semantic-release:commit-analyzer Analyzing with custom rules +4ms\n  semantic-release:commit-analyzer Analyzing with default rules +0ms\n[09:51:35] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The commit should not trigger a release\n[09:51:35] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: build(npm): Added publish config with the registry\n  semantic-release:commit-analyzer Analyzing with custom rules +1ms\n  semantic-release:commit-analyzer The rule { type: 'build', release: 'patch' } match commit with release type 'patch' +1ms\n[09:51:35] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The release type for the commit is patch\n[09:51:35] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: Merge pull request #4 from REPO_OWNER/PI-6517/allow-alpha-releases\nbuild(semantic-release): Allow releases from an alpha branch\n  semantic-release:commit-analyzer Analyzing with custom rules +0ms\n  semantic-release:commit-analyzer Analyzing with default rules +0ms\n[09:51:35] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The commit should not trigger a release\n[09:51:35] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: build(semantic-release): Allow releases from an alpha branch\n  semantic-release:commit-analyzer Analyzing with custom rules +0ms\n  semantic-release:commit-analyzer The rule { type: 'build', release: 'patch' } match commit with release type 'patch' +1ms\n[09:51:35] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The release type for the commit is patch\n[09:51:35] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: Merge pull request #3 from REPO_OWNER/PI-6517/update-package-name\nchore(repo): Updated package name and move release config to separate\u2026\n  semantic-release:commit-analyzer Analyzing with custom rules +1ms\n  semantic-release:commit-analyzer Analyzing with default rules +0ms\n[09:51:35] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The commit should not trigger a release\n[09:51:35] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: chore(repo): Updated package name and move release config to separate file\n  semantic-release:commit-analyzer Analyzing with custom rules +0ms\n  semantic-release:commit-analyzer The rule { type: 'chore', release: 'patch' } match commit with release type 'patch' +0ms\n[09:51:35] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The release type for the commit is patch\n[09:51:35] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: Merge pull request #1 from REPO_OWNER/PI-6517/update-coverage-threshold\nchore(config): Updated jest config for a higher coverage threshold\n  semantic-release:commit-analyzer Analyzing with custom rules +1ms\n  semantic-release:commit-analyzer Analyzing with default rules +0ms\n[09:51:35] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The commit should not trigger a release\n[09:51:35] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: chore(config): Updated jest config for a higher coverage threshold\n  semantic-release:commit-analyzer Analyzing with custom rules +0ms\n  semantic-release:commit-analyzer The rule { type: 'chore', release: 'patch' } match commit with release type 'patch' +1ms\n[09:51:35] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The release type for the commit is patch\n[09:51:35] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: Merge pull request #2 from REPO_OWNER/PI-6517/add-bash-scripts-to-enforce-node-version\nbuild(npm): Check node version before scripts are executed\n  semantic-release:commit-analyzer Analyzing with custom rules +1ms\n  semantic-release:commit-analyzer Analyzing with default rules +0ms\n[09:51:35] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The commit should not trigger a release\n[09:51:35] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: build(npm): Added lint command\n  semantic-release:commit-analyzer Analyzing with custom rules +1ms\n  semantic-release:commit-analyzer The rule { type: 'build', release: 'patch' } match commit with release type 'patch' +2ms\n[09:51:35] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The release type for the commit is patch\n[09:51:35] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: build(npm): Check node version before scripts are executed\n  semantic-release:commit-analyzer Analyzing with custom rules +0ms\n  semantic-release:commit-analyzer The rule { type: 'build', release: 'patch' } match commit with release type 'patch' +0ms\n[09:51:35] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The release type for the commit is patch\n[09:51:35] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: build(repo): Initial setup of the project/repo\n  semantic-release:commit-analyzer Analyzing with custom rules +0ms\n  semantic-release:commit-analyzer The rule { type: 'build', release: 'patch' } match commit with release type 'patch' +0ms\n[09:51:35] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The release type for the commit is patch\n[09:51:35] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analysis of 23 commits complete: patch release\n[09:51:35] [semantic-release] \u203a \u2714  Completed step \"analyzeCommits\" of plugin \"@semantic-release/commit-analyzer\"\n[09:51:35] [semantic-release] \u203a \u2139  There is no previous release, the next release version is 1.0.0-alpha.1\n[09:51:35] [semantic-release] \u203a \u2139  Start step \"generateNotes\" of plugin \"@semantic-release/release-notes-generator\"\n  semantic-release:release-notes-generator version: '1.0.0-alpha.1' +0ms\n  semantic-release:release-notes-generator host: 'github.com' +0ms\n  semantic-release:release-notes-generator owner: 'REPO_OWNER' +0ms\n  semantic-release:release-notes-generator repository: 'REPO_NAME' +0ms\n  semantic-release:release-notes-generator previousTag: undefined +0ms\n  semantic-release:release-notes-generator currentTag: 'v1.0.0-alpha.1@alpha' +0ms\n[09:51:35] [semantic-release] \u203a \u2714  Completed step \"generateNotes\" of plugin \"@semantic-release/release-notes-generator\"\n[09:51:35] [semantic-release] \u203a \u2139  Start step \"prepare\" of plugin \"@semantic-release/changelog\"\n[09:51:35] [semantic-release] [@semantic-release/changelog] \u203a \u2139  Create /Users/paul.blyth/REPO_OWNER/REPO_NAME/CHANGELOG.md\n[09:51:35] [semantic-release] \u203a \u2714  Completed step \"prepare\" of plugin \"@semantic-release/changelog\"\n[09:51:35] [semantic-release] \u203a \u2139  Start step \"prepare\" of plugin \"@semantic-release/npm\"\n[09:51:35] [semantic-release] [@semantic-release/npm] \u203a \u2139  Write version 1.0.0-alpha.1 to package.json in /Users/paul.blyth/REPO_OWNER/REPO_NAME\nv1.0.0-alpha.1\n[09:51:36] [semantic-release] \u203a \u2714  Completed step \"prepare\" of plugin \"@semantic-release/npm\"\n[09:51:36] [semantic-release] \u203a \u2139  Start step \"prepare\" of plugin \"@semantic-release/git\"\n[09:51:36] [semantic-release] [@semantic-release/git] \u203a \u2139  Found 3 file(s) to commit\n  semantic-release:git add file to git index { stdout: '',\n  stderr: '',\n  code: 0,\n  failed: false,\n  killed: false,\n  signal: null,\n  cmd: 'git add --force --ignore-errors CHANGELOG.md package.json package-lock.json',\n  timedOut: false } +0ms\n  semantic-release:git commited files: [ 'CHANGELOG.md', 'package.json', 'package-lock.json' ] +0ms\n[09:51:36] [semantic-release] [@semantic-release/git] \u203a \u2139  Creating tag v1.0.0-alpha.1@alpha\n[09:51:40] [semantic-release] [@semantic-release/git] \u203a \u2139  Prepared Git release: v1.0.0-alpha.1@alpha\n[09:51:40] [semantic-release] \u203a \u2714  Completed step \"prepare\" of plugin \"@semantic-release/git\"\n[09:51:40] [semantic-release] \u203a \u2139  Start step \"generateNotes\" of plugin \"@semantic-release/release-notes-generator\"\n  semantic-release:release-notes-generator version: '1.0.0-alpha.1' +5s\n  semantic-release:release-notes-generator host: 'github.com' +0ms\n  semantic-release:release-notes-generator owner: 'REPO_OWNER' +0ms\n  semantic-release:release-notes-generator repository: 'REPO_NAME' +0ms\n  semantic-release:release-notes-generator previousTag: undefined +0ms\n  semantic-release:release-notes-generator currentTag: 'v1.0.0-alpha.1@alpha' +0ms\n[09:51:40] [semantic-release] \u203a \u2714  Completed step \"generateNotes\" of plugin \"@semantic-release/release-notes-generator\"\n[09:51:44] [semantic-release] \u203a \u2714  Created tag v1.0.0-alpha.1@alpha\n[09:51:44] [semantic-release] \u203a \u2139  Start step \"publish\" of plugin \"@semantic-release/npm\"\n[09:51:44] [semantic-release] [@semantic-release/npm] \u203a \u2139  Publishing version 1.0.0-alpha.1 to npm registry on dist-tag alpha\nnpm notice\nnpm notice \ud83d\udce6  @international/sweden-time-alerts-component@1.0.0-alpha.1\nnpm notice === Tarball Contents ===\nnpm notice 2.1kB package.json\nnpm notice 29B   CHANGELOG.md\nnpm notice 767B  node-version-check.js\nnpm notice 45B   README.md\nnpm notice 1.3kB dist/main.min.js\nnpm notice 53B   dist/types/example.d.ts\nnpm notice 27B   dist/types/index.d.ts\nnpm notice === Tarball Details ===\nnpm notice name:          @international/sweden-time-alerts-component\nnpm notice version:       1.0.0-alpha.1\nnpm notice package size:  1.9 kB\nnpm notice unpacked size: 4.3 kB\nnpm notice shasum:        7434dfc4da1a3d4253228779889a4f38b5832081\nnpm notice integrity:     sha512-GcnLCYMcC8T8i[...]YzKdaeyIrmyLA==\nnpm notice total files:   7\nnpm notice\n+ @international/sweden-time-alerts-component@1.0.0-alpha.1\n[09:51:46] [semantic-release] [@semantic-release/npm] \u203a \u2139  Published @international/sweden-time-alerts-component@1.0.0-alpha.1 to https://packages.REPO_OWNER.com/repository/npm-private-client/\n[09:51:46] [semantic-release] \u203a \u2714  Completed step \"publish\" of plugin \"@semantic-release/npm\"\n[09:51:46] [semantic-release] \u203a \u2139  Start step \"publish\" of plugin \"@semantic-release/github\"\n  semantic-release:github release owner: 'REPO_OWNER' +0ms\n  semantic-release:github release repo: 'REPO_NAME' +1ms\n  semantic-release:github release tag_name: undefined +0ms\n  semantic-release:github release name: 'v1.0.0-alpha.1' +0ms\n  semantic-release:github release prerelease: true +0ms\n[09:51:46] [semantic-release] [@semantic-release/github] \u203a \u2139  Published GitHub release: https://github.com/REPO_OWNER/REPO_NAME/releases/tag/v1.0.0-alpha.1%40alpha\n[09:51:46] [semantic-release] \u203a \u2714  Completed step \"publish\" of plugin \"@semantic-release/github\"\n[09:51:46] [semantic-release] \u203a \u2139  Start step \"success\" of plugin \"@semantic-release/github\"\n  semantic-release:github found pull requests: [ 10, 11, 8, 9, 7, 6, 5, 4, 3, 1, 2 ] +0ms\n  semantic-release:github found issues via comments: [] +22ms\n  semantic-release:github create comment: { owner: 'REPO_OWNER',\n  semantic-release:github   repo: 'REPO_NAME',\n  semantic-release:github   number: 10,\n  semantic-release:github   body: ':tada: This PR is included in version 1.0.0-alpha.1 :tada:\\n\\nThe release is available on:\\n- npm package (@alpha dist-tag)\\n- GitHub release\\n\\nYour semantic-release bot :package::rocket:' } +0ms\n  semantic-release:github create comment: { owner: 'REPO_OWNER',\n  semantic-release:github   repo: 'REPO_NAME',\n  semantic-release:github   number: 11,\n  semantic-release:github   body: ':tada: This PR is included in version 1.0.0-alpha.1 :tada:\\n\\nThe release is available on:\\n- npm package (@alpha dist-tag)\\n- GitHub release\\n\\nYour semantic-release bot :package::rocket:' } +1ms\n  semantic-release:github create comment: { owner: 'REPO_OWNER',\n  semantic-release:github   repo: 'REPO_NAME',\n  semantic-release:github   number: 8,\n  semantic-release:github   body: ':tada: This PR is included in version 1.0.0-alpha.1 :tada:\\n\\nThe release is available on:\\n- npm package (@alpha dist-tag)\\n- GitHub release\\n\\nYour semantic-release bot :package::rocket:' } +0ms\n  semantic-release:github create comment: { owner: 'REPO_OWNER',\n  semantic-release:github   repo: 'REPO_NAME',\n  semantic-release:github   number: 9,\n  semantic-release:github   body: ':tada: This PR is included in version 1.0.0-alpha.1 :tada:\\n\\nThe release is available on:\\n- npm package (@alpha dist-tag)\\n- GitHub release\\n\\nYour semantic-release bot :package::rocket:' } +0ms\n  semantic-release:github create comment: { owner: 'REPO_OWNER',\n  semantic-release:github   repo: 'REPO_NAME',\n  semantic-release:github   number: 7,\n  semantic-release:github   body: ':tada: This PR is included in version 1.0.0-alpha.1 :tada:\\n\\nThe release is available on:\\n- npm package (@alpha dist-tag)\\n- GitHub release\\n\\nYour semantic-release bot :package::rocket:' } +0ms\n  semantic-release:github create comment: { owner: 'REPO_OWNER',\n  semantic-release:github   repo: 'REPO_NAME',\n  semantic-release:github   number: 6,\n  semantic-release:github   body: ':tada: This PR is included in version 1.0.0-alpha.1 :tada:\\n\\nThe release is available on:\\n- npm package (@alpha dist-tag)\\n- GitHub release\\n\\nYour semantic-release bot :package::rocket:' } +0ms\n  semantic-release:github create comment: { owner: 'REPO_OWNER',\n  semantic-release:github   repo: 'REPO_NAME',\n  semantic-release:github   number: 5,\n  semantic-release:github   body: ':tada: This PR is included in version 1.0.0-alpha.1 :tada:\\n\\nThe release is available on:\\n- npm package (@alpha dist-tag)\\n- GitHub release\\n\\nYour semantic-release bot :package::rocket:' } +3ms\n  semantic-release:github create comment: { owner: 'REPO_OWNER',\n  semantic-release:github   repo: 'REPO_NAME',\n  semantic-release:github   number: 4,\n  semantic-release:github   body: ':tada: This PR is included in version 1.0.0-alpha.1 :tada:\\n\\nThe release is available on:\\n- npm package (@alpha dist-tag)\\n- GitHub release\\n\\nYour semantic-release bot :package::rocket:' } +0ms\n  semantic-release:github create comment: { owner: 'REPO_OWNER',\n  semantic-release:github   repo: 'REPO_NAME',\n  semantic-release:github   number: 3,\n  semantic-release:github   body: ':tada: This PR is included in version 1.0.0-alpha.1 :tada:\\n\\nThe release is available on:\\n- npm package (@alpha dist-tag)\\n- GitHub release\\n\\nYour semantic-release bot :package::rocket:' } +0ms\n  semantic-release:github create comment: { owner: 'REPO_OWNER',\n  semantic-release:github   repo: 'REPO_NAME',\n  semantic-release:github   number: 1,\n  semantic-release:github   body: ':tada: This PR is included in version 1.0.0-alpha.1 :tada:\\n\\nThe release is available on:\\n- npm package (@alpha dist-tag)\\n- GitHub release\\n\\nYour semantic-release bot :package::rocket:' } +0ms\n  semantic-release:github create comment: { owner: 'REPO_OWNER',\n  semantic-release:github   repo: 'REPO_NAME',\n  semantic-release:github   number: 2,\n  semantic-release:github   body: ':tada: This PR is included in version 1.0.0-alpha.1 :tada:\\n\\nThe release is available on:\\n- npm package (@alpha dist-tag)\\n- GitHub release\\n\\nYour semantic-release bot :package::rocket:' } +1ms\n[09:52:10] [semantic-release] [@semantic-release/github] \u203a \u2139  Added comment to issue #10: https://github.com/REPO_OWNER/REPO_NAME/pull/10#issuecomment-453457845\n[09:52:13] [semantic-release] [@semantic-release/github] \u203a \u2139  Added comment to issue #11: https://github.com/REPO_OWNER/REPO_NAME/pull/11#issuecomment-453457868\n[09:52:16] [semantic-release] [@semantic-release/github] \u203a \u2139  Added comment to issue #8: https://github.com/REPO_OWNER/REPO_NAME/pull/8#issuecomment-453457885\n[09:52:19] [semantic-release] [@semantic-release/github] \u203a \u2139  Added comment to issue #9: https://github.com/REPO_OWNER/REPO_NAME/pull/9#issuecomment-453457923\n[09:52:23] [semantic-release] [@semantic-release/github] \u203a \u2139  Added comment to issue #7: https://github.com/REPO_OWNER/REPO_NAME/pull/7#issuecomment-453457948\n[09:52:26] [semantic-release] [@semantic-release/github] \u203a \u2139  Added comment to issue #6: https://github.com/REPO_OWNER/REPO_NAME/pull/6#issuecomment-453457968\n[09:52:28] [semantic-release] [@semantic-release/github] \u203a \u2139  Added comment to issue #5: https://github.com/REPO_OWNER/REPO_NAME/pull/5#issuecomment-453457991\n[09:52:31] [semantic-release] [@semantic-release/github] \u203a \u2139  Added comment to issue #4: https://github.com/REPO_OWNER/REPO_NAME/pull/4#issuecomment-453458004\n[09:52:35] [semantic-release] [@semantic-release/github] \u203a \u2139  Added comment to issue #3: https://github.com/REPO_OWNER/REPO_NAME/pull/3#issuecomment-453458025\n[09:52:37] [semantic-release] [@semantic-release/github] \u203a \u2139  Added comment to issue #1: https://github.com/REPO_OWNER/REPO_NAME/pull/1#issuecomment-453458047\n[09:52:42] [semantic-release] [@semantic-release/github] \u203a \u2139  Added comment to issue #2: https://github.com/REPO_OWNER/REPO_NAME/pull/2#issuecomment-453458078\n[09:52:43] [semantic-release] [@semantic-release/github] \u203a \u2139  Added labels [ 'released on @alpha' ] to issue #10\n[09:52:46] [semantic-release] [@semantic-release/github] \u203a \u2139  Added labels [ 'released on @alpha' ] to issue #11\n[09:52:49] [semantic-release] [@semantic-release/github] \u203a \u2139  Added labels [ 'released on @alpha' ] to issue #8\n[09:52:52] [semantic-release] [@semantic-release/github] \u203a \u2139  Added labels [ 'released on @alpha' ] to issue #9\n[09:52:55] [semantic-release] [@semantic-release/github] \u203a \u2139  Added labels [ 'released on @alpha' ] to issue #7\n[09:52:58] [semantic-release] [@semantic-release/github] \u203a \u2139  Added labels [ 'released on @alpha' ] to issue #6\n[09:53:01] [semantic-release] [@semantic-release/github] \u203a \u2139  Added labels [ 'released on @alpha' ] to issue #5\n[09:53:04] [semantic-release] [@semantic-release/github] \u203a \u2139  Added labels [ 'released on @alpha' ] to issue #4\n[09:53:07] [semantic-release] [@semantic-release/github] \u203a \u2139  Added labels [ 'released on @alpha' ] to issue #3\n[09:53:10] [semantic-release] [@semantic-release/github] \u203a \u2139  Added labels [ 'released on @alpha' ] to issue #1\n[09:53:13] [semantic-release] [@semantic-release/github] \u203a \u2139  Added labels [ 'released on @alpha' ] to issue #2\n  semantic-release:github found semantic-release issues: [] +1m\n[09:53:13] [semantic-release] \u203a \u2714  Completed step \"success\" of plugin \"@semantic-release/github\"\n[09:53:13] [semantic-release] \u203a \u2714  Published release 1.0.0-alpha.1\n```\nSo I think we can rule out TeamCity from being the problem. Am I missing something from the branch configuration in the .releaserc.json?\n\"branches\": [\n        \"master\",\n        {\n            \"branch\": \"alpha\",\n            \"name\": \"alpha\",\n            \"prerelease\": true\n        }\n    ],\nEdit: Interestingly after the semantic-release command has completed my local alpha branch has the release commit. So it is adding the commit to the correct branch but something isn't quite right when it's getting pushed up.. Hey @pvdlg - I've managed to resolve this, and as I expected, it was my configuration. I was not using the beta version of @semantic-release/git\nI think the reason my changelog is empty apart from the title is that all of my commits are build/chore messages rather than any feature/fixes. If that doesn't sound right let me know and I'll raise a separate ticket.\nThank you for your help!. ",
    "pongells": "I \"solved\" the issue by manually providing the necessary ENV variables to the CI.. ugly but working.\nDetails:\nthis module needs: const {isCi, branch: ciBranch, isPr} = envCi({env, cwd}); \nand looking into env-ci for jenkins:\n```\nconst pr = env.ghprbPullId || env.gitlabMergeRequestId || env.CHANGE_ID;\nconst isPr = Boolean(pr);\nconst localBranch = env.GIT_LOCAL_BRANCH || env.GIT_BRANCH || env.gitlabBranch || env.BRANCH_NAME;\nreturn {\n    name: 'Jenkins',\n    service: 'jenkins',\n    commit: env.ghprbActualCommit || env.GIT_COMMIT || head({env, cwd}),\n    branch: isPr ? env.ghprbTargetBranch || env.gitlabTargetBranch : localBranch,\n    build: env.BUILD_NUMBER,\n    buildUrl: env.BUILD_URL,\n    root: env.WORKSPACE,\n    pr,\n    isPr,\n    prBranch: isPr ? env.ghprbSourceBranch || env.gitlabSourceBranch || localBranch : undefined,\n};\n``\nso I just added:withEnv([\"BRANCH_NAME=${params.branch}\", \"gitlabTargetBranch=${params.branch}\"]) {`\nto my Jenkins job.. \ud83e\udd47 . @pvdlg thanks, yeah, cannot use GitLab plugin because.. well because I am using BitBucket \ud83d\udde1 . > Before you spend more time on the PR, this is not something we will implement.\n\nAs mentioned in #753, outputting the version to be released without making a release is a feature that we are still evaluating.\nSo far the only use cases mentioned there that are commons enough and explained in detail are supported via the pre-release feature in version 16.0.0-beta. This use case is to publish release for integration tests purpose only then once the test are successful to publish on the main release channel. This use case is detailed there: https://github.com/semantic-release/semantic-release/blob/beta/docs/recipes/pre-releases.md.\nOther comments in #753 are either:\n\nof the type \"I want it because that's my workflow\" without explanation justifying why that workflow is better than the proposed alternative\nor are not common enough to justify the implementation of the feature\n\nRegarding skipping the PR check this is not something we will implement as we do not want to make releases from a PRs for obvious reasons. If we fail to detect properly that a CI job has been triggered by PR, then will fix the detection.\n\nI have a use case and a motivation for the --skip-tag. \nUse case: I want to use this module locally to generate the CHANGELOG and update the version(s) of my package(s). I want to be able to check the CHANGELOG and eventually manually modify it before merging to master for release. \nMotivation: we can customize and/or skip almost everything, I don't see why the tagging should be forced upon us when it would be so easy to just add the suggested flag. . ",
    "nathanbrock": "Hi @pvdlg. We're currently experiencing the same issue with Jenkins and the latest version of SR. We're not entirely sure if it's 15.13.3 that introduced the issue, but have found pinning the version to 15.9.6, the last version we had running successfully, did the trick. We'll continue to investigate at what point the problem started.  . ",
    "ZebraFlesh": "I ran into this myself and it sounds like the same issue: Jenkins pipeline checks out a detached git head by default, so you'll see weird things like the branch is undefined and/or the git ref spec doesn't match. The solution is to tell jenkins to checkout to a local branch. (I did this in the declarative part of jenkins, instead of in the jenkinsfile; jenkins being jenkins, I'm sure there are multiple ways to achieve this configuration.) Everything worked as expected after that change. A longer discussion can be found in this jenkins issue.. > 1. Release goes great!\n\n\nProve it by executing npm view <my package> version\nReceive error Error: Failed to replace env in config: ${NPM_TOKEN}\n\n\nAs I indicated, the npm view command fails after the release completes. Indeed, all npm commands which must access a registry fail (install, whoami, etc). This is because sematic-release has left some cruft in my .npmrc file. I understand that modifying the .npmrc file is necessary. However, it seems reasonable that a run of semantic-release --no-ci would properly clean up after itself and not corrupt the environment.. ",
    "fltrtsch": "I've not set the GL_PREFIX variable, because it should use the default https://gitlab.mycompany.com/api/v4 endpoint. This should work according to the debug logs. apiUrl is set to 'https://gitlab.mycompany.com/api/v4'. I've also curl-ed the API with the Private-Token: <token> header for a file in my-project and got a valid response.. The calls\ncurl --header \"PRIVATE-TOKEN: mysupersecrettoken\" https://gitlab.mycompany.com/api/v4/projects/mygroup/my-project and \ncurl --header \"PRIVATE-TOKEN: mysupersecrettoken\" https://gitlab.mycompany.com/api/v4/projects/mygroup/my-project.git\nreturning\n{\"error\":\"404 Not Found\"}\ncurl --header \"PRIVATE-TOKEN: mysupersecrettoken\" https://gitlab.mycompany.com/api/v4/projects/mygroup%2Fmy-project and\ncurl --header \"PRIVATE-TOKEN: mysupersecrettoken\" https://gitlab.mycompany.com/api/v4/projects/mygroup%2Fmy-project.git with URL encoding returning\n<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\n<html><head>\n<title>404 Not Found</title>\n</head><body>\n<h1>Not Found</h1>\n<p>The requested URL /api/v4/projects/mygroup/my-group was not found on this server.</p>\n<hr>\n<address>Apache/x.x.x (Linux) Server at gitlab.company.com Port 443</address>\n</body></html>\nI also tried curl --header \"PRIVATE-TOKEN: mysupersecrettoken\" https://gitlab.mycompany.com/api/v4/projects and get an array with my repo inside. This array elements is slightly the same as the response with the project ID curl --header \"PRIVATE-TOKEN: mysupersecrettoken\" https://gitlab.mycompany.com/api/v4/projects/93\n{\n  \"id\": 93,\n  \"description\": \"Awesome description\",\n  \"name\": \"my-project\",\n  \"name_with_namespace\": \"MyGroup / my-project\",\n  \"path\": \"my-project\",\n  \"path_with_namespace\": \"mygroup/my-project\",\n  \"created_at\": \"2018-12-27T10:05:30.623Z\",\n  \"default_branch\": \"master\",\n  \"tag_list\": [],\n  \"ssh_url_to_repo\": \"git@gitlab.company.com:mygroup/my-project.git\",\n  \"http_url_to_repo\": \"https://gitlab.company.com/mygroup/my-project.git\",\n  \"web_url\": \"https://gitlab.company.com/mygroup/my-project\",\n  \"readme_url\": \"https://gitlab.company.com/mygroup/my-project/blob/master/README.md\",\n  \"avatar_url\": null,\n  \"star_count\": 0,\n  \"forks_count\": 0,\n  \"last_activity_at\": \"2019-01-17T13:25:55.487Z\",\n  \"namespace\": {\n    \"id\": 2,\n    \"name\": \"MyGroup\",\n    \"path\": \"mygroup\",\n    \"kind\": \"group\",\n    \"full_path\": \"mygroup\",\n    \"parent_id\": null\n  },\n  \"_links\": {\n    \"self\": \"https://gitlab.company.com/api/v4/projects/93\",\n    \"issues\": \"https://gitlab.company.com/api/v4/projects/93/issues\",\n    \"merge_requests\": \"https://gitlab.company.com/api/v4/projects/93/merge_requests\",\n    \"repo_branches\": \"https://gitlab.company.com/api/v4/projects/93/repository/branches\",\n    \"labels\": \"https://gitlab.company.com/api/v4/projects/93/labels\",\n    \"events\": \"https://gitlab.company.com/api/v4/projects/93/events\",\n    \"members\": \"https://gitlab.company.com/api/v4/projects/93/members\"\n  },\n  \"archived\": false,\n  \"visibility\": \"private\",\n  \"resolve_outdated_diff_discussions\": false,\n  \"container_registry_enabled\": true,\n  \"issues_enabled\": true,\n  \"merge_requests_enabled\": true,\n  \"wiki_enabled\": true,\n  \"jobs_enabled\": true,\n  \"snippets_enabled\": true,\n  \"shared_runners_enabled\": true,\n  \"lfs_enabled\": true,\n  \"creator_id\": 2,\n  \"import_status\": \"none\",\n  \"import_error\": null,\n  \"open_issues_count\": 0,\n  \"runners_token\": \"tokentokentoken\",\n  \"public_jobs\": true,\n  \"ci_config_path\": null,\n  \"shared_with_groups\": [],\n  \"only_allow_merge_if_pipeline_succeeds\": false,\n  \"request_access_enabled\": false,\n  \"only_allow_merge_if_all_discussions_are_resolved\": false,\n  \"printing_merge_request_link_enabled\": true,\n  \"merge_method\": \"merge\",\n  \"permissions\": {\n    \"project_access\": null,\n    \"group_access\": {\n      \"access_level\": 50,\n      \"notification_level\": 3\n    }\n  },\n  \"repository_storage\": \"default\"\n}\nI have not changed or deleted any important information for you in the logs. Only the secrets, domain, group name and project name has been changed with the specials including a \"-\" in the projects name.. Just found something. We proxy our GitLab with an Apache. Maybe the Apache does some URL encoding for the slashes between mygroup and my-project. I'll write you back. :). We added some parameters to the proxy config of Apache and it seems like it's working now. Here's the ticket link for the solution: https://stackoverflow.com/questions/4390436/need-to-allow-encoded-slashes-on-apache/9933890#9933890\nThank you very much for your quick responses Pierre! Absolutely amazing support for an open source project. Have a nice weekend!. ",
    "samAbeywickrama": "This is because I have manually published to the npm. . ",
    "kirasagi": "@pvdlg I wasn't exactly sure if this was a bug, or just some configuration I'm missing. Since you are pointing me to a bug report, I'll go ahead and edit my original post with more info. Please let me know if we need to move this to stackoverflow instead.. I added the githubUrl entry and I'm getting the same error. I have defined GITHUB_URL and GITHUB_PREFIX in my environment also so it should be the same result.. Configuration:\n\"release\": {\n    \"branch\": \"jenkins-build\",\n    \"plugins\": [\n      \"@semantic-release/commit-analyzer\",\n      \"@semantic-release/release-notes-generator\",\n      [\n        \"@semantic-release/npm\",\n        {\n          \"pkgRoot\": \"dist/bti/test-lib\"\n        }\n      ],\n      [\n        \"@semantic-release/github\",\n        {\n          \"githubUrl\": \"https://github.<company>.com/\"\n        }\n      ]\n    ]\n  }\nGH instance url: https://github.<company>.com/ (same value as GITHUB_URL env)\nAPI: https://github.<company>.com/api/v3/ (same value as GITHUB_PREFIX env)\nI tested the API url using curl -u <user> https://github.<company>.com/api/v3/ using my personal access token as the password and it returned me the different endpoints for the API, so I think it works.. It's basically the same as the GH instance url except with /api/v3/ added.\nGH instance url: https://github.<company>.com/ (same value as GITHUB_URL env)\nAPI: https://github.<company>.com/api/v3/ (same value as GITHUB_PREFIX env). That worked. With this I think the GITHUB_PREFIX term is confusing in this case because \"prefix\" usually means something added before, while /api/v3 is after. Thanks for the help!. ",
    "lluchmk": "Commit message not following convention, will reopen with a proper message.. ",
    "dagnello": "@pvdlg thank you, this resolved this configuration issue.. ",
    "darcy-rayner": "I guess my assumption is the pull request is coming from within the same repository. I know a lot of CIs won't expose secrets to PRs coming from forked repositories, like Travis for example. Other CI systems let you lock secrets so they are only exposed during builds against certain branches, or not exposed to PRs. \nThe setup I normally use is to have two github tokens. One token is locked down to just the public_repo scope on GitHub, which can't push to the repository at all but can leave comments on PRs, (which is what danger.js recommends). Then I typically have another github token with push access for semantic-release that is only exposed to builds running on master. On a closed source project, you can use just a single token with the full repo scope. https://danger.systems/js/guides/getting_started.html#setting-up-an-access-token . . ",
    "dcs3spp": "Thanks @pvdlg. I am running npx from node:alpine image in the gitlab CI job.\nnpx is same version, 6.5.0. \nNot sure why but npx semantic-release fails to pull the git and/or changelog plugins for me. The only way that I can get it to work from gitlab CI is to issue:\nnpx -p @semantic-release/changelog -p @semantic-release/git -p semantic-release semantic-release\nWill update issue if I find reason why, otherwise will continue using npx -p ..... ",
    "dominykas": "\nThe other authentication configuration are related to the GitHub, GitLab and npm plugins.\n\nSorry, I suppose I missed this bit, because I was primarily focused on the GH_TOKEN not available error. So, yes, I'm currently interested in GitHub plugin auth.\n\nHaving a file containing your credentials on the CI is effectively the same as having environment variable.\n\nAssuming a single token is very much the model of Travis (and maybe Circle, etc), however I'm currently working on implementing this in Jenkins, with a rather custom setup. We already have the credentials available in ~/.config/hub that we use for other purposes, and there's restrictions on what we can put in env vars. From the access perspective, a publicly accessible file is in effect the same as an env var, but on the other hand, you can't accidentally leak the token by running env or console.log(process.env) while debugging something unrelated.\nThe other example I gave is vault. While at run time, as part of a CI job, the token is easily accessible, it generally rests in a controlled, encrypted environment. In certain environments this is important.\n\nKeychain is probably not available on the CI (or at least it would be empty).\n\nWhile keychain is debatable (as this is meant for CI), it would be extremely handy when you're trying to debug or try out things locally (--dry-run, etc). This would be primarily a usability feature. I work daily with public GitHub and with GitHub Enterprise. They naturally have a different token, therefore a single GH_TOKEN env var does not suit me - I'd have to switch it every time I change repos.\n\nCan you provide a detailed use case that is not currently possible and explain why it would be better than environment variables?\n\nI hope the above explains some of what I'm looking for. I agree with the sentiment that env vars suit most needs, yet I can't even control the env vars or job configurations in our CI environment (for various, mostly reasonable, compliance needs).\nI do have the workaround of reading the file and setting the environment variables at build time via a custom script, but that is a little fiddly, and writing a hub auth plugin would also solve my local debug use cases.\n. While I do agree that my use cases are specific and I do understand that adding more functionality is a burden, as a user I feel that such a burden is significantly less than a burden of maintaining a full blown fork. Because that's what users do - feel that maintainer's work is easier than their own ;)\nWhat I'm proposing, is providing a hook, a way to define a function, which returns the token, as opposed to only reading it from env. If you feel this does not tie into the architecture or bloats the code - I suppose it's your duty to say \"no\".\nThat said, if this can't be implemented on semantic-release side, do you think it would be reasonable to have a plugin, which loads first, before any other plugins, and writes the token directly into process.env (from whatever source it likes)? A bit hacky, but in effect the same as setting it to env from outside semantic-release, but the benefit is that you only need to configure it once, inside the package.json, as opposed to changing build scripts.\n. Doesn't feel like I'll get any traction on this one, so I'll keep on working around for now.. ~~Not sure I follow? With release channel, the situation is exactly the same?~~\n\n~~Create a rc-5 and a rc-6 branch from master (the last release is 1.0.0)~~\n~~Push a feat to rc-5 => release 1.1.0-rc.1@rc-5~~\n~~Push a feat to rc-6 => release 1.1.0-rc.1@rc-6 - the git tag is unique, in theory you'd be publishing into a different dist channel, but you still get the npm error?~~\n\n~~My ultimate goal is channel-less pre-releases, but I'll go read through #1101.~~\nThis is prerelease name, not channel thing.\nNote to self: \u2615 before responding.. OK, so starting off the same version and releasing parallel pre-releases with different contents is an interesting use-case. Is it common? \nSo the decision to make it unique is purely defensive, to avoid a potential tag collision?\nWould it make sense to only apply the restriction if the branches matched by the glob actually start at the same version? If they start at different versions - collision is not possible? The check doesn't even have to analyze commits - just the highest tag on a branch?\nThis also works when a single branch matches the glob, i.e. if rc-5 has released a v1.1.0-rc.1, and you delete it, you will no longer be getting a failure on rc-6?. > A situation were you release 1.1.0-rc.1 then 2.0.0-rc.1 but 2.0.0-rc.1 doesn't contains all the commit included in 1.1.0-rc.1 is problematic.\nAgreed, but this can happen regardless of the config and uniqueness of suffix? If the suffix is unique, then you end up with 1.1.0-rc-1.1.x.1 and 2.0.0-rc-2.x.x.1 which is just as bad, but also has unnecessarily complex version numbers?\nBut also 2.x might be a ground up rewrite, which doesn't need to have anything common with 1.x, so it's not always a bad thing.\nAlso like I mentioned - if the glob matches a single branch, then none of the \"uniqueness\" restrictions apply, yet you can still run into all of the same problems.. That's fine, I already have tooling which automatically creates and removes branches, so that there is only one at a time, but it is hard to explain this behavior to people, it has to be said - this makes it hard to drive adoption.\nIs there a recommended way to work on v2.0.0-beta.1 and v1.1.0-beta.1 simultaneously?\n. Also do you mind if I take a stab at alternative ways of ensuring the conditions you describe (version collision)? Be it a PR or an RFC-ish doc.. Was just about to create this same issue.\nMy motivation for not having the @channel is that by looking at npm version of a dep, you can't simply git checkout vX.Y.Z-rc.N - you have to know the original channel it was published in. It's also not a valid semver version, which complicates other tooling. (But also the tag name with the @channel ugly, sorry, can't help it)\nI see several other options to resolve this:\n\nWhen tagging vX.Y.Z-rc.N@channel, also add a tag at the same place for vX.Y.Z-rc.N (in fact, this is what I think I'll do as a stopgap). Possibly even make the channel-less version the release (i.e. keep the tag@channel for reference)\nAllow an explicit channel: \"\" / channel: false. This would mean that when filtering tags in get-last-release.js, the branch.channel === tag.channel needs to account for branch.channel === '' && isNil(tag.channel). This is a little ugly - I do think that allowing channel-less pre-releases by default is probably better. Alternatively, the \"\" or false could be normalized into undefined.\nAllow a custom extension point for plugins to categorize tags into channels or to override the last/next release version/tag.\n. > That is not possible because the absence of a channel is used for the default one (master branch / @latest dist-tag)\n\nI think this is the bit I don't understand. Why force the pre-releases into channels?\nChannels are a tricky concept to explain and a lot of people don't need them or don't know how to use them, so for private use I'm keen to find any and all simplifications of the process.\nThere is the downside, that npm i package-name, if the package is not yet a dependency in package.json, will install the pre-release version (but it will update your package.json so you do have a chance to spot that you dragged in a pre-release). However, if the dep is in the package.json, despite the fact that @latest is pointing to a pre-release, it will install a matching non-pre-release version.\nI don't see the above as a problem for my use case (i.e. private packages), but I can see how that can be an issue in public open source.\nIs that a big enough deal to completely prevent even the opt-in behavior? I think this is a reasonable simplification. Can it be hidden under an allowUnsafeChannel or smth option?\n\nExternalizing that to a plugin would not change the fact that you need to maintain a state between releases and the only reasonable way to do that is tag naming\n\nExternalizing version retrieval and selection into a plugin takes the burden away from semantic-release altogether?\nOne more storage option is annotated tags, but I haven't considered that deeply.\n. > That is not possible because we wouldn't be able to determine if the code associated with vX.Y.Z-rc.N was merged to master or not\nNot sure I understand this? It's possible to check whether a commit, associated with a tag, is (or isn't) on a specific branch? Why is there a need to check whether it was merged or not? If it was merged - it's no longer a pre-release, therefore a regular vX.Y.Z will happen - rc has nothing to do with it?. Let me elaborate a little on the use case we have (incl. other tooling depending on valid semver tags, etc): we use semantic-release on repos which get deployed directly from git, rather than from docker or npm. While, sure, we can adapt things to deploy vX.Y.Z-rc.N@rc, it is a hassle and it also affects non-dev personnel.\nI have currently set things up to push vX.Y.Z-rc.N as soon as there's a vX.Y.Z-rc.N@rc and that fixes the issue for us. Would be nice to have this built-in.\n. OK, so the use case is for the release on a channel without a prerelease suffix, right?\nIs the channel still mandatory if the suffix is used, i.e. there never is a v1.1.0 on next branch - only a v1.1.0-beta.1?\nBefore I go into details, have these been discarded for some reasons I'm not aware of:\n- having a v1.1.0 and v1.1.0@next tags while on next branch, then when merged to master - add v1.1.0@latest, i.e. follow the same pattern, but the v1.1.0 naked tag is still always there\n- verify whether something is latest or not by actually looking at what npm view (or equivalent used) gives? i.e. if npm view says latest is 1.0.0, and you have a 1.1.0 on master - update latest the dist tag?\n. Before I write things up, on more question.\n\nWe can't use npm view \n\nDo channels matter at all if you're only releasing to git? i.e. does the presence of the tag without the channel (to indicate latest) make a difference? The release name does not include the channel, only the tag does, which is very easy to miss.\nI'll have to look into other publish targets, but I assume they also have a mechanism to determine current version in a channel, i.e. this is target specific?. I'm sorry, I'm not including the Gitlab/non-npm flows, but I hope conceptually it's all the same, plus the source of truth is still the git repo, and that was the goal here, right?\n\n\nPush a commit to master => release version 1.0.0 on @latest\n\n\nSame as already implemented:\n\nsemantic-release adds a v1.0.0 tag\nit creates the GH release\nit publishes on npm with latest dist-tag\n\n\n\nCreate branch next from master\n\n\nSame as already implemented:\n\nsemantic-release sees no commits since v1.0.0 and does nothing\n\n\n\nPush a commit to next => release version 1.1.0 on @next\n\n\nAlmost the same as already implemented (except for the release name and two tags at the same commit):\n\nsemantic-release sees new commits with feat since last release (v1.0.0) and therefore decides that the next release is a v1.1.0\nit knows that things on next branch are prerelease: true\nit creates a tag v1.1.0 to indicate the version\nit creates a tag v1.1.0@next to indicate that the version is only on the next channel\nit creates a GH release with prerelease: true flag for v1.1.0\nit publishes on npm next channel\n\n\n\nMerge next into master => add release 1.1.0 to the @latest channel\n\n\n\nsemantic-release sees only a merge commit since v1.1.0 - no new release is necessary\nit sees that at v1.1.0, there's also a v1.1.0@next, but the master is marked as latest channel, therefore it knows it needs to promote from next to latest\nnote: at v1.0.0, there was no corresponding @next tag, so no need to do anything out of the ordinary\nit knows it because it can run git tag --contains v1.1.0 to list all the tags at the same place (if it doesn't already know that by comparing that sha of every tag)\n\n\nit adds a v1.1.0@latest tag, so that it can check that in the future (there are now three tags - v1.1.0, v1.1.0@next and v1.1.0@latest, but the release name is still v1.1.0)\nit removes the prerelease flag from the GH release\nit updates npm latest dist tag to point to v1.1.0\n\n\nLet's play this through with what the OP suggested, i.e. no channels\n\ndiscussion point: how to set this in configuration - an explicit channel: false for the beta branch or something else\n\n\n\nPush a commit to master => release version 1.0.0 on @latest\n\n\nSame as above\n\n\nCreate branch beta from master\n\n\nSame as above\n\n\nPush a commit to beta\n\n\n\nsemantic-release sees new commits with feat since last release (v1.0.0) and therefore decides that the next release is a v1.1.0\nit knows that things on beta branch are prerelease: 'beta', without a channel\nit creates a tag v1.1.0-beta.1\nit creates a GH pre-release for v1.1.0-beta.1\nit publishes on npm\nit immediately restores the latest dist-tag to what it was before this publish, i.e. back to v1.0.0\nideally publishing a version with an explicitly empty dist-tag would be a feature in npm\nmoreover, possibly npm should not update latest tag at all, if it receives a prerelease or a version older than latest without an explicit dist-tag, but that's not how it works today, and I guess I should raise both suggestions with them.\n\n\n\n\n\nMerge beta into master\n\n\n\nsemantic-release sees a merge commit and the feat commit since v1.0.0\nit ignores a v1.1.0-beta.1 tag because we're on the master branch\ndiscussion point: should this have additionally had a v1.1.0-beta.1@beta if we had the channel: 'beta'?\n\n\nit tags a v1.1.0\nit creates a v1.1.0 release on GH\nit publishes v1.1.0 on npm with latest dist-tag\ndiscussion point: if we had channel: 'beta', should beta channel now get upgraded to v1.1.0? I think Chrome behaves roughly this way with their release channels? i.e. you have the same Cr version (not sure if it's the exact same build) for an overlapping period of time until a new beta comes out.\ndiscussion point: should the v1.1.0 get added onto the same commit as v1.1.0-beta.1 was, rather than on the merge commit?\n\n\n\n\ntl;dr:\n\nif a commit has only a vX.Y.Z, then vX.Y.Z is on ['latest']\nif a commit has a vX.Y.Z and vX.Y.Z@channel1, then vX.Y.Z is on ['channel1']\nif a commit has a vX.Y.Z, a vX.Y.Z@channel1, a vX.Y.Z@channel2, a vX.Y.Z@latest, then vX.Y.Z is on ['latest', 'channel1', 'channel2']\nif a commit has a vX.Y.Z-pre.N, then it is not on any channel, and that is fine\nif this commit is newly merged on master, then it needs to be promoted to vX.Y.Z (either HEAD or the commit itself - debatable)\n\n\nif a commit has a vX.Y.Z-pre.N@pre, then it is on ['pre']\nsame as above, the last pre on master needs to be promoted to full release. Just because I made that mistake myself a couple of times... are you sure the .releaserc you pasted is on 1.0.x branch and not just master?\n\n\n\nThe reason I ask, is because the error message mentions master and alpha, but does not mention beta that you have in the file (which may be an unrelated, misleading bug, but still...). ",
    "raulingg": "Added a image \n\n. ",
    "azdanov": "Here is a hackish workaround:\nsh\nmkdir ~/.ssh/ && echo -e \"Host github.com\\n\\tStrictHostKeyChecking no\\n\" > ~/.ssh/config\nAdd it before npx semantic-release step.. @travi Agreed. I migrated to Travis, no problems there.. ",
    "lukiffer": "After looking into this a bit further, there's a bit more that would have to change other than simply removing the isNil ternary:\nIt appears that the channel criteria is (as expected) being used to determine the latest release, but it is not using the prerelease type (e.g. an alpha branch with tag 1.1.0-alpha.3 being merged into a beta branch (with {\"prerelease\": \"beta\"}, and no beta tag produces:\n[11:44:54] [semantic-release] \u203a \u2139  Found git tag 1.1.0-alpha.3 associated with version 1.1.0-alpha.3 on branch stage\n[11:44:54] [semantic-release] \u203a \u2139  Found 0 commits since last release\n[11:44:54] [semantic-release] \u203a \u2139  Start step \"analyzeCommits\" of plugin \"@semantic-release/commit-analyzer\"\n[11:44:54] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analysis of 0 commits complete: no release\n[11:44:54] [semantic-release] \u203a \u2714  Completed step \"analyzeCommits\" of plugin \"@semantic-release/commit-analyzer\"\n[11:44:54] [semantic-release] \u203a \u2139  There are no relevant changes, so no new version is released.\nOne would expect that it would look for previous x.x.x-beta.x tags and in the case there were none would look back since the latest release version, thus producing 1.1.0-beta.1.. ",
    "zenflow": "@pvdlg What do you think about changing the behavior so that the prepare step is not skipped with the --dry-run option? \nI think that would make the --dry-run option far more useful, and makes more sense, since the idea of the option (if I'm not mistaken) is to see what semantic-release will do, but without committing to the release (i.e. publishing). Currently, I don't think there is any way to make changes to the prepare step, without skipping testing and risking making a bad release.\nEither way the documentation will need to be corrected (does not mention skipping success and fail) and I would be happy to make a PR.. ",
    "nicolasbrugneaux": "Thanks for the quick reply! The link you provided was the first thing I looked at, unfortunately it's only for CI environement as it relies on the passphrase being available in the CI environment of \neg: \nyml\nbefore_install:\n  # Decrypt the git_gpg_keys.asc.enc key into /tmp/git_gpg_keys.asc\n  - openssl aes-256-cbc -K $encrypted_AAAAAAAAAAAA_key -iv $encrypted_BBBBBBBBBBBB_iv -in git_gpg_keys.asc.enc -out /tmp/git_gpg_keys.asc -d\n  # Make sure only the current user can read the keys\n  - chmod 600 /tmp/git_gpg_keys.asc\n  # Import the gpg key\n  - gpg --batch --yes --import /tmp/git_gpg_keys.asc\n  # Create a script that pass the passphrase to the gpg CLI called by git\n  - echo '/usr/bin/gpg2 --passphrase ${GPG_PASSPHRASE} --batch --no-tty \"$@\"' > /tmp/gpg-with-passphrase && chmod +x /tmp/gpg-with-passphrase\n  # Configure git to use the script that passes the passphrase\n  - git config gpg.program \"/tmp/gpg-with-passphrase\"\n  # Configure git to sign the commits and tags\n  - git config commit.gpgsign true\n  # Configure git to use your GPG key\n  - git config --global user.signingkey ${GPG_KEY_ID}\nThis option would allow to use semantic release with tag signing when doing local releases.\nAs for why, it's yet an additional layer of authenticity to the releases on the repo, which is appreciable.\nWhile I understand the concern of adding another option , I just haven't found a suitable solution thus far \ud83d\ude1e . Thank you both for your feedback! \ud83d\ude03 . ",
    "lpatino10": "Thanks @travi, I'll take a closer look to make sure it's what I'm expecting. I've used it without any issues in other projects too so this was pretty weird to me.. Looks like it was an old key encrypted key in the Travis file that I didn't see that was overriding the one I set. Sorry for the false alarm!. ",
    "priyajeet": "I have also started to notice this problem. ~~Specially from clean yarn installs.~~ Seems to be sporadic between different machines. @gempain What does git remote -v show for you? Does the origin remote repo have the branch semantic-release is trying to use from the branches list? I am asking because it seems can get around this above problem by git cloning the whole repo again and running release from there (which forces local origin to be identical to the remote origin).\nI wonder if this is related to https://spectrum.chat/semantic-release/general/how-to-make-semantic-release-use-a-different-remote-than-origin~c7a31922-ac18-4fe7-b512-04d02b8ad5bc. @gempain In your list of branches, I see master but I don't see dev. The ones that failing has remotes/origin/HEAD -> origin/dev while thats passing has remotes/origin/HEAD -> origin/master. I wonder if thats the difference?. ",
    "steffeli": "Thanks for the reply. I will try to dig a bit deeper today to see if I can find more information about the issue. What I find strange is that it works flawlessly with the 15.x.x-version, and I haven't changed anything in particular in our CI pipeline, besides adding and pushing a new branch.. So I fiddled around with moving the repo from Azure Repos to GitHub (where it's supposed to be located anyway) and adjusted the way we fetch Artifacts in our release pipeline. Clearly we tried to just copy the .git folder in order to make semantic-release work, but the credentials are not stored on the host agent if not checking out the specific repo by adding it as an Artifact. But the funny thing is now it works, but it still gives me an error about not having the correct username and password, even though it proceeds and releases a new package and version.\nEdit: I might add that this was regardless of version 15 or 16 of semantic-release.\n2019-03-08T11:51:35.6029686Z [11:51:35 AM] [semantic-release] \u203a \u2714  Loaded plugin \"success\" from \"@semantic-release/github\"\n2019-03-08T11:51:35.6030191Z 2019-03-08T11:51:35.601Z semantic-release:plugins options for @semantic-release/github/fail: {}\n2019-03-08T11:51:35.6030952Z [11:51:35 AM] [semantic-release] \u203a \u2714  Loaded plugin \"fail\" from \"@semantic-release/github\"\n2019-03-08T11:51:37.4172583Z 2019-03-08T11:51:37.416Z semantic-release:get-tags found tags: [ { gitTag: 'v0.0.1', version: '0.0.1', channel: undefined }, { gitTag: 'v0.0.2', version: '0.0.2', channel: undefined }, { gitTag: 'v0.0.3', version: '0.0.3', channel: undefined }, { gitTag: 'v1.3.0', version: '1.3.0', channel: undefined }, { gitTag: 'v1.3.1', version: '1.3.1', channel: undefined }, { gitTag: 'v1.3.2', version: '1.3.2', channel: undefined }, { gitTag: 'v1.3.3', version: '1.3.3', channel: undefined }, { gitTag: 'v1.3.4', version: '1.3.4', channel: undefined }, { gitTag: 'v1.4.0-alpha.1@alpha', version: '1.4.0-alpha.1', channel: 'alpha' } ]\n2019-03-08T11:51:37.5943331Z 2019-03-08T11:51:37.593Z semantic-release:get-tags found tags for branch master: [ { version: '0.0.1', channel: undefined, gitTag: 'v0.0.1', gitHead: 'acab0acbc84e6c1cf928f2f6b0d14bbc604198b9' }, { version: '0.0.2', channel: undefined, gitTag: 'v0.0.2', gitHead: 'e07f5b342746a03af811f7b981ded94d5a327631' }, { version: '0.0.3', channel: undefined, gitTag: 'v0.0.3', gitHead: 'ac09c10e9093db1298afa5e719a546d8793c2d4c' }, { version: '1.3.0', channel: undefined, gitTag: 'v1.3.0', gitHead: 'ac09c10e9093db1298afa5e719a546d8793c2d4c' }, { version: '1.3.1', channel: undefined, gitTag: 'v1.3.1', gitHead: '55766607dc1d842eb1759632dbb85cb8a6f0ad05' }, { version: '1.3.2', channel: undefined, gitTag: 'v1.3.2', gitHead: 'bcaa9e9cab2f48e4e79f23e60cd52a3f1d4951ae' }, { version: '1.3.3', channel: undefined, gitTag: 'v1.3.3', gitHead: '189b869b1fb8c4c20c8dd9132ea12df8173bb251' }, { version: '1.3.4', channel: undefined, gitTag: 'v1.3.4', gitHead: 'cd318e05b955608ea35929d8e4aae17ee2956820' } ]\n2019-03-08T11:51:37.8007164Z 2019-03-08T11:51:37.799Z semantic-release:get-tags found tags for branch alpha: [ { version: '0.0.1', channel: undefined, gitTag: 'v0.0.1', gitHead: 'acab0acbc84e6c1cf928f2f6b0d14bbc604198b9' }, { version: '0.0.2', channel: undefined, gitTag: 'v0.0.2', gitHead: 'e07f5b342746a03af811f7b981ded94d5a327631' }, { version: '0.0.3', channel: undefined, gitTag: 'v0.0.3', gitHead: 'ac09c10e9093db1298afa5e719a546d8793c2d4c' }, { version: '1.3.0', channel: undefined, gitTag: 'v1.3.0', gitHead: 'ac09c10e9093db1298afa5e719a546d8793c2d4c' }, { version: '1.3.1', channel: undefined, gitTag: 'v1.3.1', gitHead: '55766607dc1d842eb1759632dbb85cb8a6f0ad05' }, { version: '1.3.2', channel: undefined, gitTag: 'v1.3.2', gitHead: 'bcaa9e9cab2f48e4e79f23e60cd52a3f1d4951ae' }, { version: '1.3.3', channel: undefined, gitTag: 'v1.3.3', gitHead: '189b869b1fb8c4c20c8dd9132ea12df8173bb251' }, { version: '1.4.0-alpha.1', channel: 'alpha', gitTag: 'v1.4.0-alpha.1@alpha', gitHead: 'e3ce1f8ba8424296b377e8747cdfa29fa67c1ebb' } ]\n2019-03-08T11:51:37.8157704Z [11:51:37 AM] [semantic-release] \u203a \u2714  Run automated release from branch alpha\n2019-03-08T11:51:38.5030329Z 2019-03-08T11:51:38.502Z semantic-release:git Error: Command failed: git push --dry-run https://github.com/Helsenorge/test-project HEAD:alpha\n2019-03-08T11:51:38.5031618Z remote: Invalid username or password.\n2019-03-08T11:51:38.5032296Z fatal: Authentication failed for 'https://github.com/Helsenorge/test-project/'\n2019-03-08T11:51:38.5032685Z \n2019-03-08T11:51:38.5032935Z \n2019-03-08T11:51:38.5033496Z     at makeError (/home/vsts/work/r1/a/_Helsenorge_test-project/node_modules/execa/index.js:174:9)\n2019-03-08T11:51:38.5034106Z     at Promise.all.then.arr (/home/vsts/work/r1/a/_Helsenorge_test-project/node_modules/execa/index.js:278:16)\n2019-03-08T11:51:38.5035964Z     at process._tickCallback (internal/process/next_tick.js:68:7)\n2019-03-08T11:51:39.1772033Z [11:51:39 AM] [semantic-release] \u203a \u2714  Allowed to push to the Git repository\n2019-03-08T11:51:39.1778445Z [11:51:39 AM] [semantic-release] \u203a \u2139  Start step \"verifyConditions\" of plugin \"@semantic-release/changelog\"\n2019-03-08T11:51:39.1806595Z [11:51:39 AM] [semantic-release] \u203a \u2714  Completed step \"verifyConditions\" of plugin \"@semantic-release/changelog\"\n2019-03-08T11:51:39.1808111Z [11:51:39 AM] [semantic-release] \u203a \u2139  Start step \"verifyConditions\" of plugin \"@semantic-release/npm\"\n2019-03-08T11:51:39.2024305Z [11:51:39 AM] [semantic-release] [@semantic-release/npm] \u203a \u2139  Verify authentication for registry https://registry.npmjs.org/\n2019-03-08T11:51:39.7512419Z [11:51:39 AM] [semantic-release] [@semantic-release/npm] \u203a \u2139  Wrote NPM_TOKEN to /home/vsts/work/r1/a/_Helsenorge_test-project/.npmrc\n2019-03-08T11:51:40.1341020Z [11:51:40 AM] [semantic-release] \u203a \u2714  Completed step \"verifyConditions\" of plugin \"@semantic-release/npm\"\n2019-03-08T11:51:40.1343254Z [11:51:40 AM] [semantic-release] \u203a \u2139  Start step \"verifyConditions\" of plugin \"@semantic-release/github. I'm closing this. I came to the conclusion that this most likely are issues with Azure Pipelines and the hosted agents rather than semantic-release.. ",
    "kirach": "I'm having exactly the same issue with semantic-release 16.0.0-beta.18 on jenkins (version 15 works just fine). I'm using argument repositoryUrl to pass an address of github url:\ngroovy\nwithCredentials([usernamePassword(credentialsId: 'kirach_github_token', passwordVariable: 'GITHUB_TOKEN', usernameVariable: 'GITHUB_USERNAME')]) {\n  sh \"npx semantic-release@beta --branch=semantic-release --dry-run --repositoryUrl=https://${GITHUB_USERNAME}:${GITHUB_TOKEN}@github.com/dv01-inc/explorer\"\n}\nand it's faling with the same error: Command failed: git ls-remote --heads origin\nIt looks like the command is not using the passed argument repositoryUrl. ",
    "modean": "@travi from the logs that I have posted above:\n```\n  semantic-release:plugins options for @semantic-release/npm/publish: {} +1ms\n[2:36:13 PM] [semantic-release] \u203a \u2714  Loaded plugin \"publish\" from \"@semantic-release/npm\"\nsemantic-release:plugins options for @semantic-release/github/publish: { githubUrl: 'https://github.xxx.com',\nsemantic-release:plugins   githubApiPathPrefix: '/api/v3/',\nsemantic-release:plugins   failComment: false } +0ms\n[2:36:13 PM] [semantic-release] \u203a \u2714  Loaded plugin \"publish\" from \"@semantic-release/github\"\nsemantic-release:plugins options for @semantic-release/github/success: { githubUrl: 'https://github.xxx.com',\nsemantic-release:plugins   githubApiPathPrefix: '/api/v3/',\nsemantic-release:plugins   failComment: false } +1ms\n[2:36:13 PM] [semantic-release] \u203a \u2714  Loaded plugin \"success\" from \"@semantic-release/github\"\nsemantic-release:plugins options for @semantic-release/github/fail: { githubUrl: 'https://github.xxx.com',\nsemantic-release:plugins   githubApiPathPrefix: '/api/v3/',\nsemantic-release:plugins   failComment: false } +0ms\n[2:36:13 PM] [semantic-release] \u203a \u2714  Loaded plugin \"fail\" from \"@semantic-release/github\"\n```\nFrom the config that I have posted above:\n[\"@semantic-release/github\", {\n      \"githubUrl\": \"https://github.xxx.com\",\n      \"githubApiPathPrefix\": \"/api/v3/\",\n      \"failComment\": false\n    }]. @travi wrt/ the trailing slash I'd like to make the remark that with earlier versions of semantic release that githubUrl and githubApiPathPrefix settings actually did work together with the GHE setup I am using.\nwrt/ to using https:// over ssh:// I'd like to add that the GitHub enterprise instance I am using is configured to not allow https://. As mentioned before with earlier semantic release versions that GHE setting actually did not cause issues. I also spend some time researching and came across this article:\nhttps://semantic-release.gitbook.io/semantic-release/recipes/recipes-1/git-auth-ssh-keys\nIn that article it is explicitly mentioned that SSH as well is supported.\nThe semantic release version that works with our GHE setting is 11.2.0. In the repos where I still use that old version, my repository section in the package.json file looks as follows. That setting works together with the GHE issue I am using.\n\"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git@github.xxx.com:NGP-TWC/wdpx-kube-proxy.git\"\n  },\nBut I figured that this version does not really support features like sharable configs as explained here:\nhttps://semantic-release.gitbook.io/semantic-release/usage/shareable-configurations\nAlso to gain advantage of newly introduced features like advanced workflows, I prefer to not stick with version 11.2.0.. @travi hummm ok thanks. I suppose it would be good a maintainer could shed some light on why the errors do happen with the current version compared to older versions (here: 11.2.0) that did work together with the same GHE setup. That includes pushing releases to GHE and the like.. @pvdlg I disagree for one reason. It is working with version 11.2.0. So what essentially changed in between version 11.2.0 and 15.13.3? All the settings at my end incl. the GHE setup did remain the same. I assume with version 11.2.0 the GitHub REST API is also used.. ",
    "charliebravodev": "Update: I am having the same issue with normal release branches. Here the history:\n- successfully release v1.0.0\n- make a feature\n- successful release of v1.1.0\n- make a fix on dev, merge dev to master\n- semantic-release tries to release v1.1.0 instead of v1.1.1, so it fails because tag v1.1.0 already exists\n\nHere is the log:\n```\nBug Fixes\n\ncannot login due to wrong argument used in docker login (441a00a)\ndocker login not working (d935f34)\n\nFeatures\n\nallow setting image name via DOCKER_IMAGE environment variable (a11548e)\n[2:19:44 PM] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The commit should not trigger a release\n[2:19:44 PM] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: fix: docker login not working\n[2:19:44 PM] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The release type for the commit is patch\n[2:19:44 PM] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: chore(release): 1.1.0 [skip ci]\n\n1.1.0 (2019-03-12)\nBug Fixes\n\ncannot login due to wrong argument used in docker login (441a00a)\n\nFeatures\n\nallow setting image name via DOCKER_IMAGE environment variable (a11548e)\n[2:19:44 PM] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The commit should not trigger a release\n[2:19:44 PM] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: chore: update package.json\n[2:19:44 PM] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The commit should not trigger a release\n[2:19:44 PM] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: Merge branch 'dev'\n[2:19:44 PM] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The commit should not trigger a release\n[2:19:44 PM] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: fix: cannot login due to wrong argument used in docker login\n[2:19:44 PM] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The release type for the commit is patch\n[2:19:44 PM] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: chore(release): 1.1.0 [skip ci]\n\n1.1.0 (2019-03-12)\nFeatures\n\nallow setting image name via DOCKER_IMAGE environment variable (a11548e)\n[2:19:44 PM] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The commit should not trigger a release\n[2:19:44 PM] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: Merge branch 'dev'\n[2:19:44 PM] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The commit should not trigger a release\n[2:19:44 PM] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: feat: allow setting image name via DOCKER_IMAGE environment variable\n[2:19:44 PM] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The release type for the commit is minor\n[2:19:44 PM] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analysis of 10 commits complete: minor release\n[2:19:44 PM] [semantic-release] \u203a \u2714  Completed step \"analyzeCommits\" of plugin \"@semantic-release/commit-analyzer\"\n[2:19:44 PM] [semantic-release] \u203a \u2139  The next release version is 1.1.0\n```\n\nand the release config:\nmodule.exports = {\n  branches: [\n    '+([1-9])?(.{+([1-9]),x}).x',\n    'master',\n    'next',\n    'next-major',\n    {name: 'beta', prerelease: true},\n    {name: 'alpha', prerelease: true}\n  ],\n  plugins: [\n    \"@semantic-release/commit-analyzer\",\n    \"@semantic-release/release-notes-generator\",\n    \"@semantic-release/changelog\",\n    \"@semantic-release/npm\",\n    \"@semantic-release/git\",\n  ],\n};\nCould the problem come from the commit analyzer plugin ? I don't have it installed locally, I use nix semantic-release@beta but I checked and @semantic-release/commit-analyzer is in beta in the package.json of semantic-release, so I guess it's not coming from there.\nAny idea ?\nFor information, downgrading to v15 fixes the problem.. ",
    "plup": "I have the same issue. In a strange way it seems to work correctly when I test in a local container but fails in Gitlab CI. \nIn a local docker container:\n```\nnpm install -g semantic-release@v16.0.0-beta.18\n[skip warnings]\nsemantic-release --no-ci\n[11:33:52 AM] [semantic-release] \u203a \u2139  Running semantic-release version 16.0.0-beta.18\n[11:33:52 AM] [semantic-release] \u203a \u2714  Loaded plugin \"analyzeCommits\" from \"@semantic-release/commit-analyzer\"\n[11:33:59 AM] [semantic-release] \u203a \u2714  Run automated release from branch alpha\n[11:34:07 AM] [semantic-release] \u203a \u2714  Allowed to push to the Git repository\n[11:34:07 AM] [semantic-release] \u203a \u2139  Found git tag v0.2.0-alpha.1@alpha associated with version 0.2.0-alpha.1 on branch alpha\n[11:34:07 AM] [semantic-release] \u203a \u2139  Found 2 commits since last release\n[11:34:07 AM] [semantic-release] \u203a \u2139  Start step \"analyzeCommits\" of plugin \"@semantic-release/commit-analyzer\"\n[11:34:07 AM] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: fix: added all plugins for release\n[11:34:07 AM] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The release type for the commit is patch\n[11:34:07 AM] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: fix: removed tagged commit from test stage\n[11:34:07 AM] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The release type for the commit is patch\n[11:34:07 AM] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analysis of 2 commits complete: patch release\n[11:34:07 AM] [semantic-release] \u203a \u2714  Completed step \"analyzeCommits\" of plugin \"@semantic-release/commit-analyzer\"\n[11:34:07 AM] [semantic-release] \u203a \u2139  The next release version is 0.2.0-alpha.2\n[11:34:10 AM] [semantic-release] \u203a \u2714  Created tag v0.2.0-alpha.2@alpha\n[11:34:10 AM] [semantic-release] \u203a \u2714  Published release 0.2.0-alpha.2\n```\nIn Gitlab CI:\n```\n$ npm install -g semantic-release@v16.0.0-beta.18\n[skip warning]\n$ semantic-release\n[11:45:01 AM] [semantic-release] \u203a \u2139  Running semantic-release version 16.0.0-beta.18\n[11:45:01 AM] [semantic-release] \u203a \u2714  Loaded plugin \"analyzeCommits\" from \"@semantic-release/commit-analyzer\"\n[11:45:08 AM] [semantic-release] \u203a \u2714  Run automated release from branch alpha\n[11:45:08 AM] [semantic-release] \u203a \u2714  Allowed to push to the Git repository\n[11:45:08 AM] [semantic-release] \u203a \u2139  Found git tag v0.1.0 associated with version 0.1.0 on branch alpha\n[11:45:08 AM] [semantic-release] \u203a \u2139  Found 9 commits since last release\n[11:45:08 AM] [semantic-release] \u203a \u2139  Start step \"analyzeCommits\" of plugin \"@semantic-release/commit-analyzer\"\n[11:45:08 AM] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: fix: kept only analyzer plugin\n[11:45:08 AM] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The release type for the commit is patch\n[11:45:08 AM] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: Revert \"fix: added all plugins for release\"\nThis reverts commit 2fb2943a98445f8bdf7d88cf2ce7a9de1cb06734.\n[11:45:08 AM] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The commit should not trigger a release\n[11:45:08 AM] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: feat: trigger alpha release\n[11:45:08 AM] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The release type for the commit is minor\n[11:45:08 AM] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: fix: added all plugins for release\n[11:45:08 AM] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The release type for the commit is patch\n[11:45:08 AM] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: fix: removed tagged commit from test stage\n[11:45:08 AM] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The release type for the commit is patch\n[11:45:08 AM] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: feat: added alpha branch to release stage\n[11:45:08 AM] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The release type for the commit is minor\n[11:45:08 AM] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: feat: added gitlab ci\n[11:45:08 AM] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The release type for the commit is minor\n[11:45:08 AM] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: feat: added prerelease config\n[11:45:08 AM] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The release type for the commit is minor\n[11:45:08 AM] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analyzing commit: fix: this is a patch\n[11:45:08 AM] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  The release type for the commit is patch\n[11:45:08 AM] [semantic-release] [@semantic-release/commit-analyzer] \u203a \u2139  Analysis of 9 commits complete: minor release\n[11:45:08 AM] [semantic-release] \u203a \u2714  Completed step \"analyzeCommits\" of plugin \"@semantic-release/commit-analyzer\"\n[11:45:08 AM] [semantic-release] \u203a \u2139  The next release version is 0.2.0-alpha.1\n[11:45:08 AM] [semantic-release] \u203a \u2716  An error occurred while running semantic-release: { Error: Command failed: git tag v0.2.0-alpha.1@alpha 3535c8379991ee88d3743db6778684ec6c460e19\nfatal: tag 'v0.2.0-alpha.1@alpha' already exists\n```. ",
    "ffflorian": "@travi\nI am sorry, seems like I forgot to read the FAQ :slightly_frowning_face: \nThank you for your help!. ",
    "runia1": "From the docs here\n\nMaintenance branches are always considered lower than release branches and similarly to them, when a commit that would create a version conflict is pushed, semantic-release will not perform the release and will throw an EINVALIDNEXTVERSION error, listing the problematic commits and the valid branches on which to move them.\n\nIn this case it states that the valid branch where these commits should go is master, however we have already published v2.0.0 on master so I don't see how master would conflict with my maintenance branch 1.x.. "
}