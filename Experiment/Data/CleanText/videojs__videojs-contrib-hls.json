{
    "heff": "We're getting closer to having HLS support in video.js, but this version is still far from stable. It's the result of a hackweek project at Brightcove and we've got some work to do to polish it up. You're welcome to dig through the code and ask questions if you're still interested.\nThe example.html doesn't even use .hls(), so the readme is apparently trying to throw people off the scent. :-)\nhttps://github.com/videojs/videojs-contrib-hls/blob/master/example.html\n. Right now there's a fork in how we're approaching HLS. One is in feature/hls and the other is in this repo. The feature/hls version is probably more stable, but we're trying to make this version the one we move forward with. I think this version is a little too complicated and undocumented right now to jump into, but we'll be making progress over the next month.\nIf you'd like to help move things forward, the best place to jump in would be verifying and creating reduced test cases for any of the video.js issues, or answering questions on stack overflow. That would help free up some of the core contributors to this project.\n. @Miserlou we're going to be diving back into this starting next week. It will probably be at least a few months after that before you'll want to try it in production, but feel free to watch the progress on this repo if you want to get in early or even get involved.\n. Maybe a good time to look for smaller modules that could be broken out of contrib-hls?\n. Does this use the video.js sauce labs account or a new one? \nWe're not exposing any sensitive info right?\n. @gkatsev, ok cool, lets make sure we do that.\n@paruls, great, sounds good.\n. I agree with this direction. The more we can modularize things the better it will set us up for sharing code between different adaptive formats/platforms.\nAnd yeah, I don't think this will affect the tech situation directly. Or at least if it works like the DASH.js tech, the tech wouldn't have to know about the different pieces involved.\n. Ran the project through code climate in case anyone's interested. Not sure yet if it's helpful or  distracting to know this stuff.\nhttps://codeclimate.com/github/videojs/videojs-contrib-hls\n. So essentially having an html5 or Flash tech be a child component of the HLS tech that extends MediaTechController?\n. I'm a little worried about the amount of complexity that would add, but it's certainly worth trying. What do you see as the downsides of having two techs?\n. > you won't be able to switch between the two quite as easily\nDo we know specific cases where we'd be switching between them? Like would we ever switch between them to play different renditions in the same manifest?\n\nyou'd need to declare both techs in the tech ordering\n\nYeah, that's not as clean. In the dashjs tech I added it by doing videojs.options.techOrder.push('dashjs');, so it could be that you don't have to deal with techOrder array manually and even see that. I remember there was some discussion as to if that should even be accessible, but that may have just been about accessing it in the player service UI specifically.\n. @dmlap @gkatsev I\u2019ve always liked the idea of contrib-mse working like an abstraction for both real MSE and Flash MSE, but I think the biggest issue we'll run into with that is the API for controlling the video object is different whether it\u2019s using the Flash swf or the video element. So we couldn\u2019t really provide an MSE fallback it in a way that works between browsers without also providing the video API translation (techs), right? I think we could still handle both types of MSE in the same project repo, but I\u2019m not sure anymore if there\u2019s much value in creating an abstraction between the two, since you still have to know what type of video object is being used underneath. Does that make sense, and am I missing any benefits there?\nJumping back up to the HLS tech, honestly the simplest way I can think to implement this is to create two techs, one that extends vjs.Html5 and one that extends vjs.Flash, and share code between them (e.g. manifest handling) through shared modules. They could still both be handled in the same project repo, but video.js would see them as two different techs. It\u2019s not the prettiest to have techOrder:[\u2018hls-html5\u2019, \u2018hls-flash\u2019], but the alternative seems pretty complicated to me -- have one tech that can handle loading and using the API methods from either the flash or html5 tech.\nAnyway, the theme is, with both projects it sounds like we're about to make them smart enough to pick and load Flash or HTML5, which is like the one thing video.js core is good for. :) I just want to make sure if we're going to duplicate that functionality that it's worth it.\n. Didn't mean to discourage forward progress on this if I did. Happy to jump in a hangout to discuss more if that'd be valuable.\n. I think the design issue here is resolved by the source handlers (videojs/video.js#1560), so closing.\n. +1\n. lgtm\n. This is great, and all makes sense to me.\nI think it would be good to talk through what specific decisions each of these metrics will help us make (how they're actionable). That could help us narrow in on what exactly they should be reporting, and make sure we're not creating metrics for metrics sake. It might even be worth listing out the decisions we are able to make in a separate list.\nFor quality, I think it might be more valuable in relation to bandwidth somehow. (dmlap mentioned (bits-presented / video-time) / measured-bw-for-video-time). Basically how well are we maximizing the available bandwidth, as opposed to just how many bits are we sending. That could help us decide if we're making the right renditions at least. Though quality in any form gets a little complicated if we have different dimensions for renditions, and block higher renditions if the current frame size doesn't need it (improving economics). I know that's been mentioned but I don't know where it landed.\nTaking a big step back, I've seen a few YouTube performance talks, and they've wrapped all this up into a single \"watch time\" metric. Every change they make they A/B test and measure how it affected watch time. It's kind of elegant, and ultimately what we want to achieve here, so it might be worth considering. I know they mentioned they had other metrics failures on the way to get there, but can't remember specifics. If that's interesting, we might consider starting from there and figuring out what that doesn't give us.\n. Can you get more specific with the other info? I don't disagree but also not sure exactly what you mean.\nIt would definitely be a different way of thinking about things, especially since we don't segment viewers and A/B test across them yet. But when you do have that, you know what's different between video A and B because you're testing a specific difference and everything else should be the same.\n. @dmlap you're saying implementer A with 30s clips can't compare how well they're doing against implementer B who has 30 minute episodes, yeah? That is something YouTube doesn't deal with since they're the only implementer. You could possibly compare change in watch time vs the standard settings? I'm assuming it's avg watch time per user, so maybe that starts to even out if users watch multiple clips, but I doubt that's enough.\nIt would be cool to track that on the CDN. I wonder how hard it would be to set up a/b testing on it.\nAnyway, I'd still be interested to see how we map these metrics to the dials we can turn. I don't have a good grasp on that yet.\n. Hey Bernd, thanks for submitting these! Some of them like this one look like pretty easy fixes. Would you want to submit a pull request for them?\n. @bparadie I just merged in the reorg PR. I'm going to keep reorganizing some things but either way If you have some time to rebase your changes that would be interesting to see so I have a better understanding of the changes your suggesting.\n. Ok so we had a general architecture discussion today and this is right in line with what we were thinking, we just need to take it a little farther. The goal is to make PlaylistSelector a stateless interaction where you give it a list of playlists and environment data and get back a selected playlist. Once it's there we can make it possible to swap in alternative playlist selectors that use different switching strategies. In order to do that we need to keep the PlaylistSelector API as simple as the function I described, which I believe means moving some of the bandwidth calculation you're doing back into the tech. Does that sound doable?\n. Yeah, but not much bigger plans then what I described in the last comment. Is there anything in there I can clarify better?\nI hadn't seen ExoPlayer yet, it looks like a good project. I'm not totally following the flow of AdaptiveEvaluator but seems worth looking at closer. With the goal of making PlaylistSelector stateless, it might make sense to have a separate concept for tracking bandwidth?\n\nPlease feel free to contact me directly\n\nWe just keep email discussions on github so there's a public record of things, but you should also join the #videojs IRC channel if you get a chance.\n. Ok cool, sounds good.\n. Merging with @dmlap's permission.\n. Nice, thanks!\n. thx :)\n. can you remove the last comma?\n. I think these were valuable updates and want to make sure they don't get lost. Should have pulled them in after hackweek probably. Any objection to pulling them in now?\n. Fixed everything that I didn't comment on and that required a fix.\n. Closing because the DASH work may rename/restructure a lot of this again, so no need to break things right now.\n. Bah! Thanks. Updated it. Yeah there's nothing that jumps out to me there that has to be different. The lastSeekTarget_ vs lastSeekedTime_ is interesting. Unless someone else (@dmlap) knows otherwise I'll probably move forward assuming we can combine these.\nSetCurrentTime was going to be my next question so I guess I don't need to open a different issue for it. Could we just listen for the seeking event from the tech, get the currentTime from the tech (which is updated to the seek target), and use that to update the buffer? That at least appears to be the native workflow when using MSE with a raw video element.\n. Cool, I'll try to validate that. I'm guessing the swf will need to be updated to handle (or just ignore) seeks in the appendBytes mode.\n. The flash tech should be reporting the seek target for currentTime when the seeking even is fired.\nhttp://jsbin.com/vapoha/1\nI don't know if this was before or after you were testing it for HLS, but looks like it was updated in January. https://github.com/videojs/video.js/commit/dd8c25e8d53e3016b181361f4d31a9f9156d138f\nThe video element appears to do the same, at least with MSE. \n. Actually, I think the issue here is that with Flash, we don't actually trigger the events on the tech itself. We bypass the tech and trigger them directly on the player.\nhttps://github.com/videojs/video.js/blob/76e662a75678f46b8c900e1c0842a2a0858537c1/src/js/media/flash.js#L318\nI was only checking the tech events, so it's possible seeking is actually firing, just not where I need it to be. This could be an easy change in the Flash tech.\n. @szatmary, any chance we could get you to take a quick look at this and verify that it's a safe change?\n. RawGit wouldn't work here because we don't store a compiled version of the library anywhere in the repo. We might consider using the approach we're using for video.js here too, where the release gets compiled and tagged off in a branch that never gets merged back into master.\n. Nice. Let me know if you want help setting up something like in core.\n. Is videojs/video-js-swf#80 part of that?\n. I think this can be removed now?\n. We could probably make a case to expose core's xhr to lighten up this tech.\n. There's a number of places where the HLS code accesses itself through the player reference player.hls. I think that's a remnant of the plugin workflow and would be good to move away from that.\n. So the only case where this would be an issue is desktop Safari, right? And HLS support isn't exactly amazing there. Unless there's other issues I'm missing, I'd be fine with relying on our HLS there also.\n. This is the piece that I think we could keep as part of the tech, or \"orchestrator\" as I've been referring to it. Or possibly finding somewhere else to modularize this function so we can keep PlaylistSelector even more simple.\n. I think you mean playlistSelector here?\n. selectPlaylist is called in multiple places and gathers a bunch of data to pass to the playlist selector. I didn't want to repeat that data gathering in multiple places.\n. I believe there was some cleanup in the compare methods but I don't believe any major changes in functionality.\nThe only functions here that aren't used outside of the playlist.js file are the filter/compare functions, so exposing them was more of a necessity of breaking up the code. I left the filter/compare functions exposed thinking they could be used to construct custom playlist selectors, but we can make those private if you want.\n. We added code in video.js core to protect against the case where the tech gets disposed before the element is ready.\n. Are there any good tools yet for just rewriting the code based on a style guide? Code painter sounded promising at one point.\n. If you know there's going to be a merge commit, you might be able to do a git commit --amend and add the changelog change and the message to the merge commit, saving an additional commit. Though I'm not exactly sure how you might prepend to the commit message.\n. Possibly --reedit-message=<commit>. But also how you have it now is perfectly fine.\n. ",
    "raytiley": "Thanks for the response. I guess the main question I have is do I need to use the feature/hls branch of videojs and videojs-swf for this plugin to work?\nI see from the source you linked at that I also need to use videojs-contrib-media-sources. \nThanks for any help. Is there any help needed on this feature that is needed? I would love to do anything I can to make it work, HLS support outside of iOS devices is such a pain right now, and I think its awesome that this project it trying to solve that.\nThanks again.\n. ",
    "chuchujie": "@dmlap  @raytiley  Could you provide the following folder files (../node_modules/**)  download address for test? \nbecause the following codes need those files:\n  <\\script src=\"../node_modules/sinon/lib/sinon.js\">\n  <\\script src=\"../node_modules/sinon/lib/sinon/util/event.js\">\n  <\\script src=\"../node_modules/sinon/lib/sinon/util/fake_xml_http_request.js\">\n  <\\script src=\"../node_modules/sinon/lib/sinon/util/xhr_ie.js\">\n  <\\script src=\"../node_modules/sinon/lib/sinon/util/fake_timers.js\">\n Load local QUnit. \n  <\\link rel=\"stylesheet\" href=\"../libs/qunit/qunit.css\" media=\"screen\">\n  <\\script src=\"../libs/qunit/qunit.js\">\n video.js \n  <\\script src=\"../node_modules/video.js/dist/video-js/video.js\">\n  <\\script src=\"../node_modules/videojs-contrib-media-sources/src/videojs-media-sources.js\">\n. Hi, gkatsev \n    I was testing to play HLS video source with videojs-contrib-hls example file in our server. but it can't  work as expected. Throw an script errors in FireFox console 'The element or ID supplied is not valid. (videojs)'  the test code is here   We want to know when you can provide a better instructions and code demo for us?\n. ",
    "dmlap": "@chuchujie: that folder is populated by npm. Have you run npm install?\n. This PR is out of date. Would be a cool feature to have but it needs a fresh PR at this point.\n. We should have solid support for playlist reloading in master now. Thanks for pointing us in the right direction!\n. Superseded by #7.\n. It's well past time for a milestone. There are still muxing issues with some streams and seeking could use some refinement but we can make those improvements in later pull requests.\n. I would like to find a way to do this with less boilerplate mocking but this is a decent starting point for further tests.\n. Cool, looking forward to that PR.\n. Thanks!\n. Are you attempting to open example.html over the file protocol? Flash security restrictions prevent playback if you're not serving the page over http(s).\n. As a general principle, I'd like to keep code that isn't applicable to HLS-in-general out of this plugin. I propose we either: move Akamai HD2 specific code into a separate plugin that works together with vjs-hls or (better yet) figure out a way to get this working without putting HD2-specific conditionals in. I know you were just experimenting in this PR but I'm stealing the opportunity to get on my soapbox :)\n. This PR is out of date. Please re-open if it's still an issue.\n. Is there a reason to not fix this in video.js core?\n. Given Safari is using native HLS, I think this should be fixed in video.js itself. Closing in favor of https://github.com/videojs/video.js/issues/1058.\n. :camel: \n. @agask2agask2: looks like your video URL has been taken down since you opened this issue. We believe it should be fixed, please re-open if it turns out to still be a problem.\n. :joy_cat: \n. Once this gets merged again with master, :light_rail: \n. Background info: we are thinking hard about converting the HLS plugin into a new video.js tech, which would resolve this issue.\n. Retrying with alternate sources seems out of scope for this project. This would probably be better handled as a video.js plugin or in the main library.\n. Handled through https://github.com/videojs/videojs-contrib-hls/pull/184\n. Would you mind integrating this into docs/live.md?\n. @paruls: bump\n. Obsoleted by #46\n. This isn't ready to merge yet. Update on the way...\n. Small comment, other than that :broken_heart: \n. :heart: \n. This is a very old issue that I believe has been fixed by one of the couple performance runs we've done. Closing.\n. I think turning the plugin into a tech is the right move in the long term as well. I don't believe this PR would affect that one way or another.\n. @gkatsev: I originally implemented most of these errors as events but then I started questioning whether we should have a more nuanced philosophy. Throwing error events is a pretty well established pattern in the HTML5/Video world (see the algorithm for updating a MediaSource duration, for instance). I'm not sure if there's an official policy in HTML regarding errors but it seems to me in general that:\n- errors that are immediate results of user (i.e. developer) interaction trigger exceptions\n- errors that occur asynchronously tend to be exposed as events\nI'm not a big fan of thrown exceptions but I think this implementation is in-line with the rest of the DOM ecosystem.\n. :briefcase: \n. Should I be able to run grunt test locally? I get this output when I try:\n``` bash\n$ grunt test\nRunning \"jshint:gruntfile\" (jshint) task\n\n\n1 file lint free.\n\n\nRunning \"jshint:src\" (jshint) task\n\n\n9 files lint free.\n\n\nRunning \"jshint:test\" (jshint) task\n\n\n10 files lint free.\n\n\nRunning \"manifests-to-js\" task\nRunning \"karma:saucelabs\" (karma) task\nINFO [karma]: Karma v0.10.10 server started at http://localhost:9876/\nINFO [launcher]: Starting browser chrome 34 (Windows 7) on SauceLabs\nINFO [launcher]: Starting browser ipad 7.1 (OS X 10.9) on SauceLabs\nERROR [launcher.sauce]: Can not start chrome 34 (Windows 7)\n  Failed to start Sauce Connect:\n  Could not start Sauce Connect. Exit code 1 signal: null\nERROR [launcher.sauce]: Can not start ipad 7.1 (OS X 10.9)\n  Failed to start Sauce Connect:\n  Could not start Sauce Connect. Exit code 1 signal: null\nWarning: Task \"karma:saucelabs\" failed. Use --force to continue.\nAborted due to warnings.\n``\n. Works great! :elephant: \n. Sorry about the confusion. The latest version of this project is currently built against the latest version of video.js, 4.5. We're tracking the required version of video.js as a peer dependency in package.json so you can check there to find out which versions are compatible.\n. :fallen_leaf: \n. There is one difference in how you configure a tech as opposed to a plugin. Instead of callingplayer.hls()`, you'll need to modify the video.js tech order like this:\nvideojs('myvideo', {\n  techOrder: ['html5', 'flash', 'hls'] // note the addition of the new HLS tech!\n});\nYou also need to include the javascript for the HLS tech before you initialize your player. With a plugin, you're free to pull in the js any time before you actually initialize it.\n. Ok, it must be an issue in the video.js SWF then. We'll investigate.\n. @paytonrules: that does look like a bug. If you feel up for making a patch on video-js-swf, I can help you get it merged in.\n. Personally, I think it would be good for the tests to be robust enough to handle a different value for goalBufferLength. The value that is there now is pretty arbitrary and I'd like the ability to play with different values without losing the assurance of the test suite.\n. I've been looking into the adaptive streaming behavior and the current algorithm could use some improvement. This PR will have to hang out for awhile until we figure out whether goalBufferLength is the right mechanism for managing switching behavior. If you're interested in helping out with that project, check out the feature/switching branch.\n. You're right, segment loads aren't really part of adaptive switching. I've mentally lumped it in there because the timing of segment loads is tied very closely to the logic that performs switching but they're not necessarily related.\nMy main point was that we're experimenting with different mechanisms to manage segment requests  and goalBufferLength is part of the space being scrutinized. If it sticks around, making it configurable seems like a reasonable goal. Thanks for the patch!\n. You can now customize the buffer length by modifying videojs.Hls.GOAL_BUFFER_LENGTH. I wouldn't recommend doing so unless you're ready to test the new value thoroughly but it's there if you need it. The tests should pass even with custom values.\n. This plugin can only improve HLS support on platforms that support Flash so it won't be able to help out on Android. From what I've seen, getting HLS working on Android requires you to be very careful about how you encode your renditions. For instance, if the timestamp values encoded in your segment are non-continuous or you use the #EXT-X-DISCONTINUITY tag in your playlists, Android will choke. \nIf you're building HLS support into a native Android app, you have a lot more options. There are a number of 3rd-party HLS implementations that support more stream features than the native player. If Akamai doesn't offer you the ability to tweak your HLS encodings, this might be the only way you can go.\nI'm surprised to hear you're not seeing adaptive switching on desktop. Do you have an example URL that demonstrates the issue?\n. @Ashim0006 sorry I took so long to look at this. It appears that your link is dead now. Any chance you could update it?\n. I missed this one and created #74. Close?\n. @shacharz: this is more of a design issue. We've been focused on making the Flash HLS fallback robust and so there isn't any progress on native MSE for HLS.\n@gkatsev @heff: I've been thinking recently that we may want to push the transmuxing logic into MSE itself. In this project we could focus on playlist and segment handling; and MSE would be responsible for abstracting out the particular implementation technology-- the video.js swf or native MSE. As an end developer, I think I'd prefer to have just one tech to have to worry about as well.\n. SourceBuffers require a MIME type to be constructed so I was thinking we could use that to determine whether or not to invoke transmuxing. As a user of vjs-contrib-mse, you'd throw DASH or HLS data at a source buffer, and we'd take care of choosing a display tech and converting it into a format that is usable on your platform.\nWe could look into breaking out the format conversion into a separate module as well. Depends on how much of a hassle it is to work with.\n. I'm not discouraged at all :) You're right, the way things are organized today would make it difficult to encapsulate the two implementations into MSE. I feel like there's a better solution out there than \"double-tech\" but it hasn't come to me yet.\n. @sabberworm we're right in the middle of it, so no need! If you'd like to check out our progress, you can keep an eye on the mse-magic branch in my fork. I'll be opening a PR on the main repo as soon as I get all the tests passing again.\n. @arikgilad we've merged MSE into the development branch. The issue you mention should be fixed there.\n. Goal buffer length can be configured globally as of #92 \n. Can you share a link to your test stream? You may want to test again after #91 gets pulled in. I believe it may fix the currentTime calculation issue you're seeing.\n. @mkilling did you have a chance to test with more recent releases? I'd like to close this issue if it's been resolved.\n. Sounds good. Thanks for the update.\n. This should have been fixed when contrib-media-sources was updated to 0.3.1. Please re-open if you're still seeing this issue.\n. @seniorflexdeveloper: review?\n. There are a lot of things that can introduce latency. Have you looked at the network graph in your browser's developer tools? What sort of delay are you seeing to the m3u8s and segments?\n. Apple recommends using 10 second segment durations. Smaller sizes increase the number of round-trips necessary to build up enough buffer to begin playback, so the delays you're seeing are not surprising to me. You can try re-segmenting with Apple's tools or playing with the options in your encoder.\nI'm not sure what method you're referring to with bufferTime(); there is no method with that name in the HLS tech or video.js that I'm aware of.\n. We've made a lot of changes since this bug was filed. I think it needs a re-test so I removed the \"confirmed\" label.\n. Just checked and the master M3U8 is missing Allow-Origin headers. Closing since this is quite old.\n. That's an important detail. Thanks!\n. I think it would be better for now if it just did HLS. The Flash tech is still available for folks who want it and adopting HLS support is less invasive.\n. Merged through #94.\n. Currently, selectPlaylist() is called every time a chunk finishes downloading. The size of the chunk is not exposed but it is possible to determine the amount of time it took to download it and the estimated bitrate of the network connection based on the download time. What are you thinking of doing with the chunk size and timing info?\n. The total download time is exposed as player.hls.segmentXhrTime after each chunk is downloaded. I'll update the README so that's clearer. If you need an absolute start time for the download, you should be able to subtract that value from Date.now() to get it.\nselectPlaylist() is a public part of the API so you don't need to fork the repo to modify it. I would save a reference to the default implementation and override it with a function that calculates your metrics and then delegates back to the original. Patching over selectPlaylist() does seem a little weird for what you're trying to achieve and we may end up adding a first-class event for segment downloads if this turns out to be common. The override solution would still work if we end up going that direction, though.\n. Glad to hear that worked!\nThe loadedmetadata event itself doesn't carry much information but you can look on the HLS tech when it fires to see how the playlist was parsed. The media() method on the playlists object always contains the most up-to-date info on the active playlist, including the target and segment durations.\n. @chuchujie: if you're looking to contribute to videojs-contrib-hls, the instructions @gkatsev gave you will populate the node_modules folder. There are a bunch of tutorials out there if you're interested in figuring out how npm works. If you'd just like to use videojs-contrib-hls in a player you're building, grab one of the downloads from our releases page and then follow the instructions at the top of the README. Hope that helps!\n. Yep. We're planning on starting on it in the next couple of weeks.\n. The change @gkatsev made in ebeb964 may fix #32.\n. The scale is hard to guess from the pictures but those spikes are 5s in duration. If we make the algorithm more stubborn about sticking to bitrates, we run the risk of keeping the video quality artificially low or running out of buffer and stalling. I feel like we need to do some research on the type of bandwidth variations to expect so that we can tune the algorithm to have the right level of responsivity. I'm going to follow up with a proposal on how we might do that.\n. @gquinones: informally, I was trying to capture the notion of \"time that the video player should have been playing but wasn't\". I believe both formulations capture the same info. Thinking about it, I'm liking the original just because 1 === \"success\" may work better for visualizations. That part is totally subjective, though.\n@heff: ultimately, I think \"watch time\" is the actual metric people really care about. It has one disadvantage that strikes me in the context of video.js: it's not very useful for different implementors to compare their setups with because it's tied so tightly to the content. The categories above are all dimensionless or normalized over time so it seems possible you could identify your set of tweaks to bitrate switching have made your setup less effective than the norm. We should definitely think about tracking \"watch time\" for the CDN-hosted version of video.js, at least.\n@gkatsev: I was thinking real hard about what info we would need to determine how best to tune the ABR and I don't think this is it. This is more a summary of player performance and then we'd need to do some specific trawling to figure out a good set of ABR tweaks in practice. On that front, I think we need to get a better understanding of how bandwidth varies in the wild. Capturing the mean/median, min/max, and standard deviation seems like a decent start but I'm not sure that's enough. I think we also need some way to track how closely past measurements of bandwidth predict the future. As you noted in the ABR PR, we might be over-switching in response to bandwidth spikes but we don't have a good way to verify that. I'm not sure what the right way is to measure that \"historical correlation\" factor.\n. @heff: exactly. I was hoping this would be a good framework for understanding if your player configuration was underperforming relative to someone else's setup.\n@pcosta-bc @heff : it would be awesome to have a better understanding of how these factors play off of each other and different configurations. First step is making sure it's possible to collect them. It sounds like these values sound interesting to everyone so I'm going to take a stab at exposing them.\n. We had a good discussion here and made some changes as a result. I'm going to close this for now.\n. Looks good to me. Thanks for the contribution!\n. Any chance you could copy in or link to the m3u8 file you're trying to play? It looks like the tech is having trouble figuring out which segment to start on after performing a quality switch.\n. Hmm. Please do. If it crops up again, can you paste in the media playlists? That would be chunklist_w282278797_b119000_t64NDIyLkJhbmdsYVZpc2lvbg==.m3u8, chunklist_w282278797_b239000_t64NDIyLkJhbmdsYVZpc2lvbg==.m3u8, and chunklist_w282278797_b540000_t64NDIyLkJhbmdsYVZpc2lvbg==.m3u8 from your master playlist above.\nClosing this one until we have more info.\n. @StevenMeyer: If you load the primary m3u8 file (like you did above), you should see some relative URLs following #EXT-X-STREAM-INF that look like this:\n```\nEXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=119000,NAME=\"422.BanglaVision\",CODECS=\"avc1.66.30, mp4a.40.2\",RESOLUTION=480x360\nchunklist_w282278797_b119000_t64NDIyLkJhbmdsYVZpc2lvbg==.m3u8\n```\nOne of those \"chunklist\" URLs is where the problem is actually occurring. You should be able to make a request for that URL directly while your live stream is running and capture that output. If you can grab that info, I think we can figure out what's happening.\n. We cleaned up some issues with translating media indices for live playlists that I believe fixed this. Please re-open if you see it on latest.\n. Good find, thanks. That code is never actually run in practice so we should remove it.\n. Definitely! Thanks for submitting the patch. I think we need to do some testing to validate this one because it seems like it modifies the existing behavior. Either we're missing a test case that should have been complaining about this or that code should just be culled.\n. This has been merged.\n. We've addressed some of these through other PRs. If you think any of the remaining ones are causing incorrect operation, please open up specific issues for them.\n. We are planning on re-organizing the segment parsing & repackaging process significantly so we can support HTML-based HLS playback on browsers that support media sources. We'll be removing this class once that completes which should resolve this issue.\nI'm going to close this because we don't have plans to fix the problem here but if this sort of shenanigans shows up after the re-organization, please open a new issue.\n. I wasn't aware of that-- thanks for the patch. Do you have an example video that demonstrates the issue or a reference that specifies the DTS should be used instead of the PTS?\n. Is that bugzilla link correct?\nI'm going to have to do some testing to validate but I'm cautiously optimistic this will fix some issues I've been seeing. Will update the ticket with results.\n. Ran this through a bunch of test videos this morning and all looked good. I'd still like to track down a video I can guarantee has b-frames so I can see the effect before and after. I'll include that link here if I can find anything without distribution restrictions.\n. I was able to reproduce the issue in Firefox and it does appear fixed by this PR.\n@gutworth: thanks for digging through the transmuxing code to track this one down!\n. :+1: \n. This one has gotten outdated so I'm going to close it for now. If anyone is interested in rebasing it, that would be great.\n. :+1: \n. Looks like play() is being called by video.js before the Media Source has opened so the call is ignored.\n. @thenewguy: what version of video.js are you seeing this on? There's an outstanding issue with the SWF in 4.7 which might be complicating the symptoms.\n. I have a fix for this issue but without https://github.com/videojs/video.js/pull/1415, timeupdates never get synthesized and the player stalls after the first segment.\n. That makes sense (and there's a fairly easy fix). Thanks for the report!\n. @heff I like this update too but I would still like to resolve some of the questions above.\n. We're going to address this in the larger adaptive-streaming reorganization so I'm closing this one.\n. Yep, hoping to finish some testing and cut a release in the next day or two.\n. v0.8.3 is available on the releases page.\n. Merged in via #153. Thanks!\n. :+1: \n. Can you retry this on master? We just fixed another seek bug which may have been involved.\n. @ethietter have you included videojs-contrib-media-sources in your page? What version of video.js and contrib-hls are you currently using? The line it's failing on (in master, at least) is trying to call a method added in media-sources somewhat recently. If you're not on the latest version of that project, upgrading may fix the issue.\n. No problem! @MehSha, I'm closing this one for now. If you are still running into this issue, please comment here with more details.\n. Thanks! I'd like to write a test for this before pulling it in. Hopefully, I'll have a spare min in the next day or two.\n. Segments seem to be delivered to the source buffer correctly. This is looking like a SWF issue.\n. I've re-built the SWF at 4.4.2 locally and the seek problem disappears. The binaries differ. I'm going to look into what's going on with the published SWF but for now, it should be possible to workaround the problem by building it locally and pointing to your copy. It would be great if anyone else has a chance to confirm re-building fixes the issue.\n. You can tell the tech to forward authorization credentials when you initialize your player. I'm not familiar with all of S3's authorization options but you may be able to configure it so that only your site can generate the signature necessary to authenticate the request (don't do it client-side, though!).\nAnother option is to use encrypted HLS and use your own infrastructure to host and authorize the key URLs. We don't have support for that just yet but it's in the works for the next version.\n. I like the general idea of sidestepping the mid-segment switching problem but I'm worried about the initial playback implications of this change. It seems that unless the \"correct\" variant happens to be at the top of the master playlist , this code will add significantly to startup time. I understand that may be a worthwhile tradeoff for some users but if the default rendition is high bandwidth, this could be a painful viewing experience.\nHave you considered providing a quality hint before segments are downloaded? Currently, the initial playlist selection is hard-coded to follow the spec but it seems reasonable to allow for more intelligent selection when the developer has more info about the state of the world than the tech is privy to.\n. We switched from seeked to setCurrentTime() to ensure we are notified of the user's (exact) desired seek target and to make sure all outstanding asynchronous tasks for the previous playback position could be aborted immediately. There is no event that is guaranteed to fire immediately before and not in parallel with a seek as far as I'm aware. I believe something along those lines would be necessary to decouple buffer management from a tech implementation.\nI love the idea of removing the requirement that HLS subclass an existing tech :)\n. This was completed in 1.0.\n. I think our README needs to clarify the intended behavior better. Here's my proposed re-statement:\n\nThe player attempts to load the highest-bitrate variant that is less than the most recently detected segment bandwidth, with one condition: if there are multiple variants with dimensions greater than the current player size, it will only switch up one size greater than the current player size.\n\nThe reasoning for that condition is exactly what @thenewguy is getting at. Resolutions higher than the current player dimensions use up extra bandwidth and CPU for a viewing experience that is actually less true to the content (because of sampling). We can't guarantee that a perfect size match will be available though, so the algorithm should allow the next higher resolution variant to be used rather than falling back to a really poor quality one. \n@bparadie: Does that make more sense? Am I missing an issue in the current implementation that causes it to behave differently than I'm describing?\n. @bparadie: that's a perfect test case, thank you! The current behavior doesn't match our goal for playlist selection so I do agree this is an issue that needs to be fixed. Here's the steps I'm proposing:\n- Update the playlist selection description in the README to clarify the intended behavior\n- Incorporate the test for this issue into our suite\n- Ensure the \"smallest\" playlist with dimensions greater than or equal to the current player dimensions is not filtered in selectPlaylist()\n. This was fixed via #243 \n. We don't have any plans right now because some initial experiments led us to believe that the effort required to support IE8 would be pretty high. Right now, I recommend people include an mp4 source as a fallback for older Android devices and IE8/9. That being said, I'd be thrilled if someone figured out a way to support IE8 that didn't explode the total size of the tech.\n. I believe #142 is related to this as well.\n. #143 should have fixed this issue. Thanks for report!\n. I believe #151 fixed this. Please re-open if that's not true.\n. Yeah, this should be improved.\n. @bc-bbay is looking into this one.\n. Should be fixed in the latest release.\n. Apple recommends leaving at least 30 seconds between the last available second in a live playlist and the point you begin playback from. Do you see the same error if you don't try to seek to the latest available moment?\n. Do you have a public URL we could use that would help us reproduce the issue? I haven't seen this in my usage and am worried that the proposed fix will be hiding a real issue.\n. This issue was filed quite awhile ago and is probably out of date. Please re-open if it's still occurring in the latest builds.\n. Do you have a good idea why tags[i] would be null in this case? I don't believe it should be undefined by that point in the code and if that's the case, we probably want to track down the underlying cause.\n. @Fr3nzzy we made a change that should prevent the player from getting to this point in the code with tags being undefined. If you re-test with 0.10+ and still see this issue, please re-open this.\n. Thanks for the ffmpeg output, that is helpful. If you do manage to find a non-copyrighted stream to share, that would be awesome.\n. Your second link looks to be working now in 1.x (except for a bit later in the stream where I start getting 403 Forbiddens).\n. Um... I had device emulation is turned on in the dev console. False alarm.\n. @orcaman this seems strange to be happening only in HLS. Do you know if this issue is reproducible with just the Flash tech?\n. This appears to be an issue with the Flash tech. Refiled in the main video.js repo.\n. Thanks for the PR! I could use a little clarification though-- why wouldn't segmentXhr be nulled out?\n. Thanks for the patch! I wish we didn't have to use the polyfill for everything but that might be safer than relying on the varying browser behavior. I'd like to get some tests in place before pulling this in so we don't break things in the future. If you have a free min to add a unit test or two, I could get this pulled in more quickly.\n. Looks great to me, too. Thanks for the contribution, @amfr!\n. Using timeupdate to trigger buffer management is starting to look like the wrong mechanism. I think using a simple recurring setTimeout() like @chikathreesix suggests may be the way to go. As a side benefit, it would allow us to fix #133 without doing any gymnastics.\nIf we go this route, I'd want to de-couple the buffer management from time tracking entirely. That is, just set up polling to trigger fillBuffer/drainBuffer and let the Flash tech do its thing with timeupdate generation. We could still trigger the timeupdate event in drainBuffer() if we wanted to signal interesting timeline events, however.\n. @gkatsev right, we're on the same page on this one.\nThe quick summary:\n- HLS should use setTimeout() to periodically check the state of the buffer\n- Standard video.js logic should be left in control of triggering (or not) timeupdate events\n- HLS should trigger timeupdate manually in the case of interesting timeline discontinuities, like seeking while paused\n. False alarm on this one. fillBuffer() should now get called when the player is paused but we still should fire timeupdates when we cross a discontinuity.\n. I think we're all set with this one in 1.x. Thanks for the report!\n. If you play back the video without seeking, you don't see that error?\n. @diogopms do you have a publicly accessible URL to a video where you're seeing this? I don't think we will be able to debug it without that.\n. Without an example, we're not able to debug this issue. Please re-open if you can provide more info.\n. Could you go into a little more detail on what you're looking for? We were trying to highlight the HLS-specific portions of setup in the \"Getting Started\" section, rather than generic video.js setup. Are you aware of the example page?\n. I think we should fix our gh-pages so that we show a properly configured demo player using HLS as we expect people to use it in practice. Leaving this issue open until we get that accomplished.\n. There was a reason for overriding currentTime() at some point but that may have disappeared in video.js updates since then. I can not recall what it might have been right now.\n. I believe it was important that we had access to the seek target so that we could update the NetStream with the new base time offset once seeking had completed. The seek-related events we tried only had access to the current playback time, not the time that the seek was headed to.\n. Fixed in the video.js 5.0 / development branch.\n. This branch is out of date. We'll reopen a new PR if we restart this work.\n. I believe this was fixed via #184. If you're still seeing this issue after the update, please re-open this.\n. :+1: \n. May be related to https://github.com/videojs/videojs-contrib-hls/pull/182\n. We made a fix recently that we think should have addressed this. Can you re-test?\n. Should we be triggering progress events whenever a new segment is downloaded? Would that be a more HTML5-compatible way of doing this?\n. @dista good point. I reviewed the spec and it recommends choosing a starting segment no less than three target durations from the end. That could be more than three segments if the final segments are shorter than the target duration but it does imply we shouldn't hard code it. @bc-bbay can you make that update?\n. @bc-bbay on second thought, this is a big enough improvement we could handle the point about start position as a separate PR. I'm going to pull this in for now and we'll fix the exact timing of start position independently.\n. Thanks for tracking down this issue! We'll get rid of that line and cut a new release of media-sources.\n. We've updated contrib-media-sources to 0.3.1. Please re-open if you're still seeing this.\n. Our goal for seeking right now is to sync back up at key-frames. It's possible to decode intermediate frames during seeks but that could lead to slowdowns on older machines so we haven't put any effort into it yet.\n. This level of decoding is now handled by the browser's media playback engine. I believe the experience is improved a bunch on most platforms. If it's still lacking though, it would be an issue with the underlying browser, not something we could change in this project.\n. It seems like this would be possible. We don't have plans to implement it right now but would be open to a PR if you're feeling brave :)\n. @hc2p I'm having trouble seeing the issue with your example. What should I be looking for, javascript errors?\n. @hc2p ok, thanks. I'll re-try and see if I can trigger it.\n. @hc2p I dug into this and felt like we needed to change the lifecycle of the playlist loader to simplify the process a bit. I think the underlying issue in this PR is resolved via #223. Thank you very much for the PR! (and sorry it took so long for me to get around to reviewing it) If you try out v0.11.1 and see this issue still, please let us know.\n. Thanks! I'd like to put a test case together for this PR before merging but otherwise this looks good.\n. @gkatsev is going to manually merge this one to clean up the commit history a bit.\n. The primary reason is it's a pain to manage the dist version through git (but that's not a good excuse!). @heff has spent a lot of time automating this process for the main video.js project. I'll look into how tough it would be to pull in some of that for contrib-hls.\n. @eseceve: can you retest with video.js 4.11.2? There was an incompatibility introduced in the 4.10 series I think is causing the issue you're seeing.\n. Closing since we haven't heard back. Please re-open if you're still experiencing the issue.\n. @vladutzik have you followed the steps from our example page?\n. Should be fixed in 1.x\n. @bc-bbay do you need help with the rebase?\n. contrib-media-sources has a fix for this in version 0.3.1. If you use the latest in that project, you should not see this issue any longer.\n. Do you have a publicly available example anywhere we could use to debug?\n. Haven't heard back on this one for awhile so I'm going to close it. Feel free to re-open it if you're still running into issues with the latest version.\n. Reviewed by @seniorflexdeveloper \n. @stevemayhew nice find! Can you open up a PR so we can comment on the change more easily?\n. Fixed via https://github.com/videojs/videojs-contrib-hls/pull/203\n. Merged via 66510e67aad74474b6ca44fb98d580f1ee008c63.\n@stevemayhew had a bit of free time so I added unit tests. Let me know if you don't think they cover the case we were mishandling properly. Thank you for the contribution!\n. We'd have to make some pretty significant changes to our release process to address this. I'll think on how best to approach that.\n. Some status update for folks hanging on to this thread: we've tried to formalize a release process that commits the dist/ as part of the plugin generator project. Our focus right now is making sure 1.x aka MSE playback supports all the streams that the old Flash version did but once that is stabilized we'd like to adopt the build and publishing processes in the generator (which would add bower support to all tagged releases). If anyone wanted to take a stab at migrating over the plugin generator's publishing process before we get to it, PRs are always welcome!\n. I think we should have two test-cases for these scenarios: the original test which seeked after playing through some portion of the video and your updated test that seeks directly to a discontinuity. Is there a reason the old test is no long valuable I'm missing?\n. @yurevich1 I think we'll need a test stream to be able to debug this properly. Do you have a public URL that demonstrates the issue?\n. Closing this because we haven't heard from @yurevich1. Please re-open if you're able to provide a test stream to debug.\n. Thanks for the report. The metadata stream shouldn't be a problem but it can't hurt to test without. We'll check out the original over here and update as soon as we have any ideas.\n. @stevemayhew did you close this accidentally?\n. Yeah, that would definitely be helpful.\n. Yes, we would need a class similar to AacStream that would collect and translate MP3 data to get appended into the SWF. If you're interested in adding that support, check out #3. @raytiley gave this a shot and we never got around to merging it because a bunch of refactoring was going on.\n. That is an interesting problem. It does sound like the current behavior is not correct to me. If you'd be willing to take a shot at a PR, that would be great!\n. Merged into master now, will go out with the next update.\n. For future reference: fixed via d94275ef8cf27ae6d227d20ccb9abb9e9cb499ae\n. The initial value of duration is now set by video.js in 1.x so the fact it is not NaN would be better filed over there. I'm seeing plenty of durationchanges during load now, though:\nduration: 0\ndurationchange duration: 1801\nloadedmetadata duration: 1801\nloadedmetadata duration: 1801\ndurationchange duration: 1801.01001\nloadeddata duration: 1801.01001\ncanplay duration: 1801.01001\ndurationchange duration: 1801.020021\ndurationchange duration: 1801.030032\n. Merged via d94275ef8cf27ae6d227d20ccb9abb9e9cb499ae\n. Our intent was that if you wanted to provide custom playlist selection logic, you could just override selectPlaylist():\njs\n  player.hls.selectPlaylist = function() {\n    return userSelectedVariantPlaylist;\n  };\nIs there a reason I'm not thinking of why that wouldn't work?\n. No problem. Glad it worked for you!\n. I want to go through and rename our expected parsed output from .json to .js so that we don't confuse anyone who takes a look over the test cases later. Other than that, this looks great. Thanks!\n. Merged. @rajkosto thanks again for the patch!\n. Fixed by #260 \n. Thank you very much for the test streams! We'll take a look.\n. I'm looking into this now. My hypothesis was swapping byte order before and after decrypting was tons of overhead and taking up the bulk of the time. My initial profiling in Chrome indicates a couple things:\n1. Decryption is at least 10x as expensive as transmuxing right now\n2. Byte-order swapping, CBC, and pkcs7 do not play a significant role in decryption time\n3. AES.decrypt() takes up 2/5 of decryption time in my test runs\nAll of which seem to invalidate my initial hunch. Assuming AES.decrypt() is the culprit, I'm going to explore a couple options:\n- Using TypedArrays instead of vanilla arrays during decryption\n- Finding a way to decrypt asynchronously (web workers, incremental decryption, etc)\nStill investigating.\n. I ended up building v8 and using the debugging console to try out a bunch of crazy ideas. For future reference:\n1. Inlining AES.decrypt() and hoisting loop invariants (the key, table references, etc.) can shave about 5% off decryption time\n2.  DataView.prototype.getUint32 (and cousins) is significantly slower than standard TypedArrays with array accessors\n3. Using Uint32Arrays forced a regular check on signed-ness of  the inputs and caused frequent function de-optimization. Switching to Int32Arrays halved the runtime.\nA typical profile run looked like this:\n```\nStatistical profiling result from v8.log, (3056 ticks, 0 unaccounted, 0 excluded).\nticks  total  nonlib   name\n     51    1.7%          /usr/lib/system/libsystem_platform.dylib\n      1    0.0%          /usr/lib/system/libsystem_c.dylib\nticks  total  nonlib   name\n   1985   65.0%   66.1%  LazyCompile: AES.decrypt src/decrypter-d8.js:209227:20\n    220    7.2%    7.3%  LazyCompile: decrypt src/decrypter-d8.js:209274:19\n      7    0.2%    0.2%  LazyCompile: ~Uint8ArrayConstructByArrayLike native typedarray.js:62:40\n      6    0.2%    0.2%  KeyedLoadIC: A keyed load IC from the snapshot\n      3    0.1%    0.1%  Stub: StoreFastElementStub\n      1    0.0%    0.0%  Stub: VectorRawLoadStub\n      1    0.0%    0.0%  Stub: StoreFastElementStub {1}\n      1    0.0%    0.0%  Stub: LoadFastElementStub\nticks  total  nonlib   name\n    665   21.8%   22.1%  start\n     45    1.5%    1.5%  threadselfusage\n     32    1.0%    1.1%  _libplatform_init\n     18    0.6%    0.6%  _mach_msg_destroy\n      5    0.2%    0.2%  __os_once\n      3    0.1%    0.1%  mkfifoextended\n      2    0.1%    0.1%  simple_getenv\n      2    0.1%    0.1%  chmodextended\n      1    0.0%    0.0%  _vm_read\n      1    0.0%    0.0%  _malloc_zone_malloc\n      1    0.0%    0.0%  _malloc_zone_from_ptr\n      1    0.0%    0.0%  _inet_pton\n      1    0.0%    0.0%  _free\n      1    0.0%    0.0%  _create_scalable_zone\n      1    0.0%    0.0%  simple_asl_send\n      1    0.0%    0.0%  ___cxa_free_exception\nticks  total  nonlib   name\n   2224   72.8%   74.0%  JavaScript\n    780   25.5%   26.0%  C++\n     23    0.8%    0.8%  GC\n     52    1.7%          Shared libraries\nticks    cpp   total   name\n     84  100.0%    2.7%  TOTAL\nNote: percentage shows a share of a particular caller in the total\n  amount of its parent calls.\n  Callers occupying less than 2.0% are not shown.\nticks parent  name\n   1985   65.0%  LazyCompile: AES.decrypt src/decrypter-d8.js:209227:20\n   1984   99.9%    LazyCompile: decrypt src/decrypter-d8.js:209274:19\n   1984  100.0%      Function: ~Hls src/decrypter-d8.js:38:10\n   1984  100.0%        Script: ~src/decrypter-d8.js\n665   21.8%  start\n 19    2.9%    start\n  4   21.1%      LazyCompile: ~Uint8ArrayConstructByArrayLike native typedarray.js:62:40\n  4  100.0%        LazyCompile: ~Uint8Array native typedarray.js:74:31\n  4  100.0%          Function: ~Hls src/decrypter-d8.js:38:10\n  4  100.0%            Script: ~src/decrypter-d8.js\n  3   15.8%      LazyCompile: ~decrypt src/decrypter-d8.js:209274:19\n  3  100.0%        Function: ~Hls src/decrypter-d8.js:38:10\n  3  100.0%          Script: ~src/decrypter-d8.js\n  3   15.8%      LazyCompile: *decrypt src/decrypter-d8.js:209274:19\n  3  100.0%        Function: ~Hls src/decrypter-d8.js:38:10\n  3  100.0%          Script: ~src/decrypter-d8.js\n  2   10.5%      LazyCompile: ~HarmonyToStringExtendSymbolPrototype native harmony-tostring.js:3:46\n  2  100.0%        Script: ~native harmony-tostring.js\n  2   10.5%      LazyCompile: *AES src/decrypter-d8.js:209118:16\n  2  100.0%        LazyCompile: *decrypt src/decrypter-d8.js:209274:19\n  2  100.0%          Function: ~Hls src/decrypter-d8.js:38:10\n  2  100.0%            Script: ~src/decrypter-d8.js\n  2   10.5%      Function: ~Hls src/decrypter-d8.js:38:10\n  2  100.0%        Script: ~src/decrypter-d8.js\n  1    5.3%      Script: ~native harmony-tostring.js\n  1    5.3%      LazyCompile: ~subarray native typedarray.js:113:28\n  1  100.0%        LazyCompile: ~<anonymous> src/decrypter-d8.js:209378:12\n  1  100.0%          LazyCompile: *decrypt src/decrypter-d8.js:209274:19\n  1  100.0%            Function: ~Hls src/decrypter-d8.js:38:10\n  1    5.3%      LazyCompile: ~Uint8ArrayConstructByLength native typedarray.js:48:37\n  1  100.0%        LazyCompile: ~Uint8Array native typedarray.js:74:31\n  1  100.0%          LazyCompile: ~decrypt src/decrypter-d8.js:209274:19\n  1  100.0%            Function: ~Hls src/decrypter-d8.js:38:10\n\n220    7.2%  LazyCompile: *decrypt src/decrypter-d8.js:209274:19\n220  100.0%    Function: ~Hls src/decrypter-d8.js:38:10\n220  100.0%      Script: ~src/decrypter-d8.js\n\n```\nAll of these results were Chrome-only running bleeding edge. I have not checked how much of an effect these optimizations have on any other browsers since it doesn't seem feasible to reduce the runtime by another order of magnitude without giving up IE10 support. At this point, asynchronous decryption seems like the only realistic solution. Web workers have difficult restrictions for us in IE10 so I'll be looking into decrypting incrementally with regular setTimeouts along the way.\n. Chunked up the work of decryption in #251. If there is a performance bottleneck remaining, I think it's in the segment transmuxing, not in the decryption anymore, and it was only noticeable at all for me when I got to testing 8Mbps streams. Closing this one but please feel free to comment if you're still seeing issues anywhere.\n. Fixed via #243 \n. Have you checked out the Getting Started section of the README?\n. I'm going to assume the README was sufficient. Feel free to comment again here if you're still running into issues.\n. No, that sounds like you're doing things correctly. Do you have an example we could check out that demonstrates the issue?\n. I spent some time playing with this yesterday. The errors I saw all originated from the Flash tech so it sounds like their may be some cleanup it's expecting that HLS is missing. Haven't gotten to the bottom of it yet but I'm still looking.\n. This was fixed via https://github.com/videojs/video.js/pull/2125 and is live in video.js 4.12.6. Please re-open this if you're still running into issues after updating.\n. Ah, I guess you're right this wouldn't address firing a timeupdate, though it does fix the fact that seeking while paused wouldn't trigger buffering immediately. Should we address the timeupdate-on-seek issue in the Flash tech?\n. @gkatsev I added a test case to show that buffer checking happens on init and we do have a test that checks event handlers on dispose(). Sound good?\n. Good thinking! I have no idea why travis is trying to run prepublish as part of the CI build, though.\n. @quarkus just tried this out with the 0.13 release and it worked like a charm. Thank you!\n. @ntadej thanks for the PR! I think in this case that something is going wrong at another point in the parsing process that we should probably get to the bottom of. Do you have a reduced test case available that causes this to occur?\n. @ntadej email me at dlapalomento at brightcove dot com.\n. Good to hear @gkatsev's solution worked for you. Closing this one.\n. @bc-bbay can you append an _ to the methods added in this commit? I want to be clear they're not intended for external use.\n. You should use npm to fill in the node_modules folder.\n. This isn't configurable behavior right now in the tech. Our principle has been \"keep on playing if it is at all possible\". We would be open to a PR that added an event whenever a segment download error occurred, if you're up for it.\n. We now temporarily blacklist playlists with segments that are too slow to download or error.\n. Are you sure you have Flash installed on your test machine? It's not installed by default on the VMs from modern.ie, and this issue sounds like a symptom of missing Flash.\n. Would either of you be able to put together an example on jsbin or similar where we can see this occurring? This doesn't happen for me with Chrome on our example page, so we need a bit more context to debug.\n. @patriziomunzi would it be hard to try this out with the unminified version of video.js? I think you might be hitting a variable name-mangling issue.\n. It looks like in your example video.js's time tracking interval is firing before the SWF has been initialized and that's causing an error. It's a bit surprising we don't see this more often but it's hard to predict with race conditions. This technically is an issue with the base playback tech class in video.js so I've filed https://github.com/videojs/video.js/issues/2288 over in the main repo to track it.\n. #213 has been merged and some additional fixes have been merged in the meantime. Are you still seeing this issue in master, @ntadej?\n. Everything in your report sounds correct. I'm not totally sure whether it's worth the extra code to support using an out-of-date playlist in selectPlaylist() but if it's just a tiny update, it doesn't seem like a bad thing. If it's easy to put together a PR to discuss, that would be great. Thanks!\n. Hi @Ulv, it's not obvious to me why your second stream isn't displaying video but if you can keep them live for awhile, we'll try to take a look.\n. @Ulv seems to be working for me in master now.\n. Do you have an example stream that this occurs with?\n. Haven't heard back on this one in awhile. Please re-open it if you're still having issues.\n. This is an issue with the video.js skin and live content-- programmatically, you can seek during live streams if you'd like. We don't have plans right now to add seeking capabilities to the base video.js live skin but would definitely be open to a PR!\n. A better live skin should probably be handled in video.js itself or a stand-alone plugin. Closing the issue here but it would still be very cool if someone was looking for a project.\n. Test case?\nWould it simplify things a bunch to always use resolutionPlusOne? I'm tempted to do that all the time if so.\n. It seems like audio-only would still be chosen in low bandwidth scenarios, which sounds right. LGTM.\n. This could use a test case. Also, will the precise durations get carried along when live playlists reload? I just ran into a problem with keys and playlist reloading in HLSe :)\n. It looks like this PR has picked up some commits that have been merged into master. Can you rebase it agains the current head to clean things up?\n. @dkuryakin this setting in ffmpeg causes TS timestamps to always reset across segments? Do you have a link to the docs for it?\n. This change requires the SWF enhancement in https://github.com/videojs/video-js-swf/pull/150\n. If you're looking to stream to a small audience (1-10), you're probably better off with a peer-to-peer solution involving WebRTC.\nThis project can live stream to large audiences but you'd have to setup a streaming server or work with a service provider first. Wowza is one possibility if you want to try setting up your own live server, or you could checkout a service like Zencoder if you don't want to go through that hassle.\n. @oleynikd yeah, that's definitely the direction we'd like to head. As soon as we get MSE support stabilized, we'd love to upgrade to es6 and browserify like the main video.js code base.\n. @pbacci it's a bit of a laborious process but we're deep in it in the development branch right now.\n. This is still a work in progress. I will be adding the async changes here as well.\n. @dconnolly thanks for the review!\n. I don't understand why this should be removed. Any background on what issues this was causing for you?\n. Could that be an issue with the playback scrubber and not this event? I feel that triggering progress here is consistent with the event definition, i.e. new video data has been downloaded.\n. That definition doesn't count buffering in JS :) I think I understand your perspective on this one but I think what we're currently doing is reasonable, too. I'm closing this one for now but if there's a more fundamental issue with firing progress here, please reopen it.\n. @imdummyhelpme it does look like you are missing CORS headers on your m3u8 files. Flashls is Flash-based (not surprising) and uses a different mechanism to determine whether m3u8 requests are allowed or not. Check out enable-cors.org for instructions on how to setup CORS on your server.\n@ReggiePuksta thanks for the help diagnosing this one!\n. Would you mind setting up an example somewhere (jsbin perhaps)? I'm not sure exactly what the issue is from your explanation.\n. Just tried this with 1.3.7 and it seemed to be working fine:\njs\nplayer.on('loadedmetadata', function() {\n  console.log('current time', player.currentTime());\n});\nLet us know if you're still having problems.\n. This PR is still a work in progress.\n. Merged via #262 \n. Would you mind putting together a minimal example? (You can use jsbin or something similar)\n. LGTM\n. @oldcookie: I modified the format you had used to expose PRIV tags a bit so that it would allow contrib-hls users to get at the data for any ID3 frame. So instead of cue.text being a binary string, you could get at a Uint8Array of a frame through cue.frame.data and the private data portion of a PRIV frame at cue.frame.privateData. How does that sound?\n. How did you produce your blob file? Does it have the same issues if you access it over standard HTTP instead of through blob:?\n. If it happens over standard HTTP, can you put the segment with this issue somewhere public so we can see what's happening?\n. No response on this one for awhile, so I'm closing.\n. Nice!\n. Related: #233 \n. @bc-bbay I just tried this out on a player and it appears preload() is (incorrectly) returning a boolean. Can you double check this is working as you expect?\n. Do you have an example page we can see this on?\n. It's been a month without any activity on this one, so I'm going to close it. If you're still running into this issue, please let us know.\n. I could see this being related to https://github.com/videojs/videojs-contrib-hls/pull/267. Would you mind retesting against master?\n. @dtrikannad did you add your findings to #267? I didn't see any comments from you in that thread.\n. @gkatsev is there an easy way to test this?\n. LGTM\n. I've updated the getting started instructions in the README a bit and created a live demo! If anyone is still having trouble setting things up, please let us know.\n. Side note: I'm using this change to test out using contribflow to manage PRs for this project.\n. Did you notice that you can influence initial rendition selection by overriding the bandwidth estimate on loadstart?\njs\nplayer.on('loadstart', function() {\n  // choose a really high quality rendition, even if bandwidth estimates don't justify it\n  player.hls.bandwidth = 1e9;\n});\nIf your media() solution or the bandwidth-based one don't solve your problem, please comment in here. This is something we would like to ensure is easy to do.\n. loadedmetadata should definitely not be coming before loadstart. If you're able to dig into this a bit deeper, we'd definitely appreciate it. Thanks!\n. Ah, good find! You're right, loadedmetadata should only be filed once per video load; that is not intended behavior. \n. Should be fixed via #356\n. Interesting stuff. I think we should figure out how to get this working but just out of curiosity, does this sort of stream pass in the media stream validator?\n. @mikrohard thanks! I think I have fixes for the tests worked out. I'd like to spend a little bit of time trying to work out the cause behind 4). Any suggestions on how best to reproduce it?\n. @mikrohard That must have been fun to track down :/ I'm a little busy working on some live enhancements this week. If you could write up a test case for this, I can get it pulled in quicker.\n. Yep, you can set the GOAL_BUFFER_LENGTH to whatever number of seconds of content you'd like to be pre-buffered.\n. LGTM\n. contrib-hls defers to native support for HLS when available, and Safari on Mac has built-in support. Unfortunately, Safari doesn't support timed metadata without weird hacks like using  to embed the video. You could override isSupported() for contrib-hls to be used on Safari.\nIt's worth thinking about whether deferring to native support is the right design. We could just rely on the techOrder, for instance. The only scenario where that doesn't quite work correctly is if you have mixed mp4 and HLS sources on a browser without native HLS, and you'd prefer HLS to be used even if native MP4 playback is possible.\n. git bisect says it was introduced in 63c045e6d74efc88fbeec47e2c8b8662aaf83ac0\n. Removing metadata injection when the random access indicator is set in the TS adaptation field causes firefox to delay rendering the new video location but removes the distortion.\n. It also delays rendering the new location in Chrome and others, unfortunately.\n. We recently added a contrib.json so we can automate more of the release process. I plan on adding dist files to the released tags soon so hopefully this one won't be an issue much longer.\n. @cadesalaberry I spent awhile improving the release process yesterday but haven't fixed dist/ yet. Still working on it!\n. @bc-bbay this PR looks like it was improperly rebased. Can you clean up the commits?\n. This is dependent on https://github.com/videojs/video.js/commit/1c35bfafc2d6d65f10f86c0f5918e07e3fd4c4e0\n. I think we need to find some way to unify this with the duration calculation happening in the Playlist module (recently moved out of the main file). Thoughts?\n. I'm going to rebase this one to remove the build commit.\n. @gkatsev any thoughts on this one?\n. Fixes https://github.com/videojs/videojs-contrib-hls/issues/273\n. That squished aspect ratio is the default for the Flash runtime when it is missing video dimension information. We've seen this in the past when videos segments don't begin with a keyframe or equivalent frame metadata (technically, we're looking for an SPS in the H264 data). What encoder are you using to create your stream?\n. I'm working to put together a new release of videojs-swf with @qpSHiNqp's change to fix this.\n. @parrfolio it should be fixed with video.js v4.12.10 which uses video-js-swf v4.7.1.\n. We don't begin loading segments until you actually begin playback for live videos since the \"live point\" is continuously moving and we don't want to waste the viewer's bandwidth. I added a call to play() immediately following your snippet and the behavior looked correct to me:\n\nNote fileSequence3.ts (from the bipbop video) is immediately followed by index.m3u8 and then the segments of the live stream.\n. Sorry if I misunderstood. Actually, do you think you're seeing the issue described in https://github.com/dmlap/videojs-contrib-hls/commit/1e641871380f88ddb210c5f3dca2858360cbd482?\n. Awesome. Thanks for checking!\n. Obsoleted by #321 \n. Fixed in #356 \n. Do you mean when i < playlist.mediaSequence?\n. @oldcookie I was able to check your stream out this morning and hit the error after about 5 minutes of playback. The root exception occurred because segmentsDuration() was getting called with an endSequence number that was greater than the media sequence of the last available segment in the playlist. That shouldn't happen under normal operation though, so I dug a little deeper.\nOn my play through, I actually missed a whole segment between playlist refreshes and that caused the expired segment duration calculation to pass a bad value through to segmentsDuration(). That is, the player had been playing a playlist with mediaSequence 35532 and three segments available and after refreshing, it received a playlist with mediaSequence 35536 and three segments available. Segment 35535 was missed entirely so the two playlists couldn't be synced up and the bad values got pushed into segmentsDuration().\nIn this case though, I believe the problem is with your Wowza setup. The HLS spec asserts that streaming servers must not remove segments from the media playlist unless there is greater than three target duration's worth of segments available. With a 5 second target duration like you have setup, you should have greater than 15 seconds of content in each playlist response. In my play through the playlist responses I saw were about 5 seconds of total content.\nI'm not familiar with Wowza's HLS settings but if there's a way to bump up the window size to at least 30 seconds of content, your stream should be much more stable. Also, I'd consider making your target duration a bit larger if that's easy. I think Apple's current recommendation is 9 second target durations.\n. Interesting! Thanks for following up with the details. I'm going to close this one based on the info we have so far but feel free to re-open if anything new comes to light.\nI understand trying to reduce live latency but I would consider bumping the live window size a bit. Six seconds is not a lot of wiggle room if there are delays publishing the segments or m3u8 updates.\n. This change that caused this was backed out in video.js 4.12.10, so I'm closing this.\n. I ran all of the bipbop segments through ffmpeg/ffprobe and output their durations. I compared our duration with the duration reported by the tool and in each case, we differed by 33ms. This happens to be the PTS interval between the last two tags, which we use to estimate the frame display duration.  Related, the frame duration we measure, 33.3555... ms, is very close to the average framerate (tbr) reported by ffprobe, 29.97 or (1000/29.97) = 33.3667...ms.\nThe next question was whether the time value reported by Flash matched the numbers I saw using our segment parser and ffprobe. In the three cases I tested, the video duration reported by Flash matched the ffprobe duration. That is, it was 33ms shorter than the duration number we were calculating.\nI put together a small playlist and checked the time reported by Flash when it completed to make sure that the final frame duration wasn't re-introduced when the segments were stitched. Strangely enough, Flash reported a total duration of 29.996s, while ffprobe and segment parsing came up with ~30.21s. As a final sanity check, I used high resolution timers to measure the duration of the time between playing and ended for my short playlist, which reported 29.957s.\n. Interestingly, the m3u8 for the short playlist I used for testing included duration numbers that were closer to the duration reported by Flash and timers. On a hunch, I decided to try calculating the duration numbers for the audio and video streams separately instead of mixing them together. As it turns out, the elementary streams in those files don't have matching durations. The minimum duration between the audio and video streams matches up precisely with the durations the segmenter wrote out in the M3U8. For this playlist, summing the durations in the m3u8 gives a duration of 29.9334s.\n. ## Summary\n|  | contrib-hls | ffprobe | Flash | m3u8 | minimum stream duration | safari |\n| --- | --- | --- | --- | --- | --- | --- |\n| single TS | 10.10580 | 10.07 | 10.072 | 9.98458 | 9.98458 | 10.01001 |\n| short m3u8 | 30.21 | 30.21 | 29.996 | 29.9334 | 29.9334 | 29.9508 |\nWe should calculate duration the same way ffmpeg does it, without an estimated final frame duration. The duration of video and audio streams in a segment can differ so we should track them separately and use the minimum of the two when we have to report total duration. Actual playback time may vary by hundredths of milliseconds over a relatively short video so we'll have to take this into account when trying to use currentTime to translate to PTS values, or vice-versa.\n. Another piece of info: the end playback position reported by Flash is consistent across runs. The actual clock time required to hit this position may vary by tenths of milliseconds, however.\n. After #339, I believe we're calculating duration reliably and accurately.\n. Thanks for the report! We are working on it.\n. Should be fixed if you're using video.js 4.12.10.\n. Are you setting display: block on the player or anything? Chrome and Firefox reload the videojs-swf if the <object> element is removed from the DOM and the symptoms you're reporting sound similar.\n. Haven't heard back on this one in awhile. If you're still running into this issue, please re-open.\n. @jstarpl I'm not sure what it might be then. Any chance you could put together an example to show us?\n. Closing since we haven't heard back on this one.\n. Definitely. We're trying to wrap up some general bug fixing we've been working on but should start migrating in a couple weeks.\n. Was the error you noted related to maxVideo/AudioPts or something else?\nYes, I believe this change would invalidate any condition that would cause #307.\n. Missed the Travis issue. I'll update this PR\n. Travis was failing because of the incompatibility with video.js 4.12.9.\n. @forbesjo any idea why Travis is failing now?\n. Did some looking. I think it's #316 \n. LGTM\n. Other than my question about file organization, LGTM\n. I spoke too soon... would you mind adding instructions on how to run the functional tests to the README?\n. This still requires some testing on my part but I wanted to open up the PR for early feedback.\n. We use Flash today for backwards compatiblity-- MSE is not enabled by default in Firefox or IE < 11. We do have plans to add MSE-based HLS in the near future but it's a big project. You can check out our progress in the feature/mp2t-to-mp4 branch or check out a simple demo.\n. LGTM\n. Offline approval from @gkatsev \n. There is no way that I'm aware of to find out when a discontinuity is encountered when native HLS is being used. I don't think we have an obvious event to listen for in the HLS tech but that's something we could consider.\n. What's the use-case for this?\n. You could use in-band metadata tracks to signal timed info (like ads) during playback. It's not signaling the discontinuity specifically but I can say that other folks have used it to trigger these sorts of player changes successfully.\n. @codex-corp We try to stick with the HTML5 standard APIs wherever possible so that you can use the same code whether features are supported natively (i.e. iOS) or not. ID3 tags are exposed in HTML5 video as a metadata text track. Here's how you could listen to find out that a video has ID3 metadata and log out the tags:\n``` js\nplayer.textTracks().on('addtrack', function(e){\n  // find out if the new track is metadata\n  var track = e.track;\n  if (track.kind === 'metadata') {\n// a cuechange event fires when the player crosses over an ID3 tag\ntrack.on('cuechange', function() {\n\n  // in reality, there may be more than one cue active at a time\n  // we'll ignore that for simplicity in this example\n  console.log('found an ID3 tag!', track.activeCues[0]);\n});\n\n}\n});\n```\n. Darn. Thanks for letting us know.\n. The automation still isn't fixed but I did add official builds for 0.17.3.\n. If you use one of the releases, it's included automatically. If you're trying to contribute to contrib-hls, check out the contribution guide.\n. Do you have an example we can look at?\n. This can be reproduced on example.html by seeking to 15:15:\njs\nplayer.currentTime(15.25 * 60);\n. Yes, this should have been fixed after we moved Flash to use mux.js. Please reopen if you're still experiencing it. \n. Are you looking for some sort of programmatic way of providing an encryption key for segments, outside of specifying a URL in the manifest?\n. That's outside standard HLS behavior so it's outside of our focus today. Sorry we can't be of more help.\n. @Llorx I believe the issue you are seeing is fixed by https://github.com/videojs/videojs-contrib-hls/pull/279 which we're testing to pull in right now. On the Android front, contrib-hls falls back to native playback on any platform that has native HLS support. The issue you're seeing is a problem with Android's built-in HLS support and not something we can fix in this project at this time.\n@ntadej any chance you were able to narrow down why this was occurring? Sometimes you can get issues like this to reproduce by capturing the segments that were being requested at the time of the failure and creating a fake VOD stream from them.\n. @Llorx Flowplayer falls back to native the HLS implementation on Android too so I don't think adding it will change the situation much. Unfortunately, there aren't many good options to improve HLS on Android until Google fixes it. contrib-hls and Flowplayer use Flash to play HLS on devices that don't have any native support but Flash isn't an option on mobile. You could swap to MP4s on Android as long as you don't have to do any actual live streaming.\n. @vasklund very glad to hear that! If your testing turns up anything else, please let us know.\n. Also, closes #314\n. Do you have an example of this we could check out?\n. @scramatte looks like you're not using the latest version of contrib-hls. Are you able to try with the latest release?\n. @pbacci thanks for the investigation! I believe we need to add some guards around calls to the segment parser's PTS stat gathering so it doesn't blow up if the audio or video track is missing.\n. Yes, we don't support BYTERANGE style HLS today and that would definitely explain the slow startup. Elastic Transcoder should be able to produce segmented HLS though. Any background on why you're using unsegmented HLS right now?\n. Ah, ok. I haven't heard much demand for BYTERANGE support so it hasn't been high on the list of priorities so far. We do have plans to implement some HLS v4 features soon (multiple audio track support is at the top of the list). If you're feeling ambitious, we'd certainly be interested in a PR to add BYTERANGE support.\n. I'd really like to have it included as well and, while it's not trivial, I think it should be relatively straight-forward. If anyone has some time and is interested in creating a PR, it would be much appreciated!\n. byte-range support is in!\n. Does your stream work in Safari or on iOS? Do you have CORS configured for your video?\n. Thanks for the help, @drumlight! \n@paulwang55: I'm going to close this issue since it seems to be CORS-related but feel free to keep adding questions in here if you have problems with the setup.\n. I don't test with Opera normally but I'd be happy to accept patches to improve Opera support.\n. Do you have CORS configured for your m3u8 and TS files? This plugin is in use by people with Wowza servers right now so there's definitely something else going on.\n. Many mobile browsers have HLS built-in. Built-in browser support isn't subject to the same security requirements that javascript has so in many cases cross-domain HLS can be played back without CORS on those platforms.\nIt sounds like this is a CORS configuration issue so I'm going to close it.\n. Once you dispose the playlist loader, won't it be impossible to rejoin the stream?\n. You are correct and I happen to be working on this right now :) Thanks for the report!\n. Should be fixed in 0.17.6.\n. To test while we're waiting for video.js changes:\n- npm link to dmlap/video.js/5.0-mashup\n- npm i and grunt dist in video.js\n- npm link to dmlap/videojs-contrib-media-sources/vjs-5-update\n. Superseded by the development branch.\n. We're shooting to match iOS's API behavior during live streams so that it's possible to build a cross-platform live DVR set of controls. Apple's implementation (and the HTML spec too from my reading) make duration Infinity for live streams and use the seekable property to expose the sliding content window. Current time is zeroed at the earliest available media timeline position when the user began loading the stream.\ncontrib-hls has had a spec-compliant seekable implementation since 0.17 so it should be possible to build live DVR controls now. A PR for this project that added live DVR controls would be awesome if you're up for it. If you're able to build it so it works on iOS too, we've been wanting something like this for the main video.js repo for awhile. If you have any questions, feel free to drop them in this thread-- I'd be happy to help!\n. @chriswiggins player.hls only shows up when this project is being used and we don't polyfill HLS anywhere it's supported natively (e.g. Safari). You should still be able to build live DVR controls without accessing the extended properties supported by this tech, though. Check out the seekable attribute for a cross-browser way of getting information on the currently available playback positions in a live stream. It should behave the same way whether contrib-hls is being used to provide HLS support or it's built natively into the video element.\n. @imbcmdth What version of the SWF is this tied to? Are we pointing to the right video.js version in our package.json to pick that up?\n. Found it. Dependent on https://github.com/videojs/video-js-swf/commit/08fa8f1fd56c0c63570f8b9d25efd1e7e7e72f1e\n. @eminden we don't support packed AAC segments yet. In the meantime, if you re-encode with audio-only TS segments it should work.\n. This should be fixed in 1.x\n. lgtm\n. This will reopen #277 and #310 until we finish the upgrade to video.js 5. I'm very sorry about the false notifications for those issues but we don't want to make a breaking change without following semantic versioning and we made a decision awhile ago to close 4.x to anything but patch releases. (That said, you can continue to use videojs-contrib-hls v0.17.7 with videojs-swf v4.7.3. We won't be removing them, just reverting this breaking change.)\n. @alexyats thanks for the help getting to the bottom of this issue!\n. All of these features are now supported in the master branch of this project:\n- HLSv4-style alternate audio tracks\n- Subtitles through embedded CEA-608 or sidecar WebVTT\n- Adaptive bitrate selection and customization via overriding selectPlaylist()\n. We don't have a first-class API for this at the moment but we do annotate the segments with PTS information based on the streams we process while buffering. So you could do something like this:\njs\nif (player.hls.playlists.media().segments[i].minAudioPts !== undefined) {\n  // there is audio available for this segment\n}\nWould that work?\n. Thanks! Is there a good way for us to reproduce the audio issues you were encountering?\nAs a side note, we've been working for the past couple weeks on extracting the segment parser and related transmuxing tools into a separate project as part of adding HTML-based HLS playback. Once we get that project into a more stable state I'll be moving it out of my own organization somewhere more public. I hope we don't have this problem with the new TS to fragmented MP4s tools but if you have a free minute to check out the Media Source Extensions PR (coming any day now...), I'd love to hear how well HTML playback works for you.\n. I'm ok with exposing this as a constant (a la GOAL_BUFFER_LENGTH) so someone could overwrite it if they really wanted to. I don't think it's a good idea for anyone to touch this value and I think a full-fledged setter/getter with validation implies a level of support we don't actually provide. Would you mind trying that route instead?\n. This would be a backwards incompatible change. Can we keep the values at the old property names as well and log a deprecation warning if they're accessed?\n. Are the seekable tests checking this anywhere? Are they using a hard-coded value still? Otherwise, looks good.\n. PTS values for MPEG2-TS streams do not start from zero on many encoders so this wouldn't be a general-purpose mechanism for determining the start time of a live stream. Most people I've heard about who do this find an out-of-band way of signaling the live stream start time to their app, e.g. an API endpoint somewhere that returns a datetime. Closing this based on the original problem statement but if there's another use-case for PTS values, please feel free to keep commenting here.\n. Thanks! It looks like this change would cause some of our existing test cases to need an update. In test/manifest there are a bunch of example m3u8 files and a corresponding parsed version that ends in .js instead of .m3u8. Would you be up for giving that a shot?\n. @norlin you can check out the state of things so far in the development branch. It's still very active right now but it won't be too long before we cut a release with video.js 5 compatiblity and MSE included.\n. video.js 5 and a new version of contrib-hls are being released TODAY (woohoo!).\n. @Tralapo @sjernigan we discovered some errors with our test content last week and we decided to delay the official release until we took care of them. Many videos work great with the new branch, though-- please build the development branch and let us know how it works for you if you have the time!\n. Did you turn off the media sources whitelist in Firefox? If not, you were using a refactored version of the Flash fallback. I thought live streaming was up and running there but I'll make sure we take another look.\nOn the Chrome-live question: this is one of the issues we're delaying release for. The underlying problem is an MSE-spec issue (in my opinion, at least) but we're looking into workarounds until there's an official solution.\nThanks for going through the trouble to build everything and try it out!\n. @DJaeger we found issues in testing and decided we needed to delay the official release until we could resolve them. You'll notice we do have an official 1.0.0 out now but it's tagged with \"next\" (not \"latest\", yet) in npm. Right now, we feel pretty good about playback as long as you're doing VOD and you make sure your segments start with keyframes. MSE is a lot more picky about partial frame information than Flash is and stalls with videos that don't have that leading keyframe.\nRight now, we're working on tricks to get MSE working without that leading keyframe requirement. We probably won't be able to get rid of it entirely but we think we can relax it a bit and make a whole bunch more HLS content work. We're also working to get live playback back to the position it is in 0.x. There are a couple fundamental issues that we're going to have to work around until some new APIs are added to MSE.\n. @Tralapo any chance you could put an example up somewhere for us to check out?\n. @Tralapo I was able to see the issue you reported in Firefox, thank you. I believe the error is because of https://github.com/videojs/videojs-contrib-hls/issues/430, which I'm trying to fix in https://github.com/videojs/videojs-contrib-hls/pull/432.\n@ChiliChili: that sounds like you're missing parts of HLS. We didn't include the full distribution in the 1.x releases in npm (sorry!) so the easiest way to get going is probably to clone this project, npm install, and then grunt. The concatenated, minified file will show up in the dist/ directory.\n. @Tralapo shoot. Did you ever put together an example stream for us to take a look at?\n. @Tralapo just tried out your stream using the latest code from all of our sub-projects and it was working for me in FF 42 (your example page is broken on my machine, too). We'll be making a new release in the next day or so, I think you'll be all set then. Thanks for being patient!\n. @Tralapo yes, the Flash fallback on IE11/Win7 is expected. That combo doesn't support MSE so Flash is the only option for HLS playback. If you really want HTML5 playback on that platform, you can include your video in another format like mp4, for instance, and video.js will fall back to playing that file when it detects MSE-HLS is a no-go.\nWe've gotten a bit off-topic in this issue :) Version 1.2.2 is fully video.js 5 compatible so I'm going to close this. If any of the other problems brought up in the comments are still occurring in the latest release, please open up new issues.\n. I struggled with that myself. I think assuming the codecs are constant seems like the right move initially, mainly because it would be a real pain to have to deactivate source buffers and add new ones between renditions. It's something we could add later if it turns out to be popular (though I really hope no one actually does that).\n. metadata-stream is being moved into mux.js in the upcoming release of this project. Would you mind moving your changes to that file to a PR in that project?\n. Merged into development (after much rebasing)\n. Firefox supports MSE now which should address the performance problems introduced by using Flash.\n. Other than my comment about the negative-case for findCurrentBuffered_, LGTM.\n. I believe the underlying causes for this issue have been addressed in the 1.x releases. Please re-open if you're still seeing the issue after upgrading.\n. That definitely should work. Are you creating your video player at the same time you're trying to seek? You do have to wait until the loadedmetadata event fires before you begin seeking.\n. Ah, ok. The latest release of this project just delegates to the native HLS implementation on Android. On most devices, live streaming on Android is very broken and things like currentTime() behave non-deterministically. \nIn our development branch, we're putting the finishing touches on an update that would allow us to take more control of playback and the API on Android devices. We're still tackling issues with some content before we do an official release but you can clone that branch and try it out on Android with your videos today.\n. @himslm01 What browser are you testing with?\n. @himslm01 now that I look at it, I think the problem might be how you're calling videojs. After you initialize videojs for the first time, you'll get weird issues if you call videojs(videoElement) again. I'd suggest saving a reference to the player when you initialize it, and re-using that reference in your event handlers. If that's inconvenient, you can use videojs(theDivThatVideoJsCreatedDuringInit) to get another reference to the player. I'm closing this one but feel free to re-open if you still have issues.\n. Fixed via https://github.com/videojs/videojs-contrib-hls/pull/389\n. Unfortunately, browsers block XHRs over the file protocol, too. This one seems like it is a limitation of web security, so I'm closing.\n. @imbcmdth filed https://github.com/videojs/videojs-contrib-hls/issues/399 to track the enhancements to this PR we'd like to get around to.\n. @mischizzle network disconnection wasn't something I was thinking of this when I filed this issue, but that would be an awesome. I'm closing this one but definitely open that PR if you find any issues with disconnection scenarios.\nThe original motivation for this was fixed with #397 so I'm closing.\n. I think the proposed migration to media-sources will cause loadstart to be emitted a bit too late in the loading lifecycle. loadstart should fire before the resource selection algorithm begins, which would roughly translate to tech/source selection time for video.js. Currently, we wait until the underlying tech fires the event and the SWF doesn't fire it at all in data generation mode. I think the correct solution would be to fire it when src() is called in the player. As a temporary measure, we could fire it the moment HLS is selected as a source handler in Flash mode.\n. We always fall back to the native implementation if it's available today but it would be cool to allow an override. Feel like trying a PR? (Make sure to base it on the development branch if you do.)\n. Looks like this one would be better handled in video.js proper, closing.\n. playlists.media is a getter/setter, you should not overwrite it with a function of your own. Instead, you would do something like this:\njs\nplayer.hls.playlists.media(player.hls.playlists.master.playlists[0]);\nIf I understand your question correctly, you can swap to the beginning of a different quality level and turn off automatic adaptive switching using the src attribute:\njs\nplayer.src('low.m3u8');\nIf you want to asynchronously load the playlist and then swap over at the next opportunity, use the setter version of media() like in my first example.\n. @novoxudonoser do you see any errors in the developer console when this happens? If you look on the network tab, is the player requesting segments in the right order?\n. If you call player.buffered().length, is the return value 1? Would you mind putting up an example somewhere we could check it out?\n. Closing since we haven't heard back.\n. @arikgilad I downloaded the second segment of that stream to debug and it looks like there isn't any video data in it. ffmpeg is unable to transmux it and Quicktime only plays audio. I think you have something misconfigured.\n. @shacharz it looks like some segments in the wowza stream declare an audio track but do not actually contain any audio data. Part of the segment-transformation process is sitting around waiting for audio data and so nothing gets fed to the video. We're looking into a fix.\n. @Pablo76 the HLS spec does require at least one keyframe per segment (see the first full paragraph on page 6). It is probably possible to play back this stream over MSE but it would be a big challenge and might make buffering worse for streams that were well-formed. It's not clear to me, for instance, what the player should do if it's asked to seek into a segment without a keyframe. We'd have to keep buffering backwards an arbitrary number of segments and hold those intermediate segments in-memory until we encountered the keyframe and could transmux to fMP4.\nIf someone has a clever idea to simplify that workflow and wants open up a PR, that would be awesome. Absent that though, I'm not inclined to tackle streams missing per-segment keyframes anytime soon.\n. True enough: SHOULD is not MUST, you've hoisted me by my own pedantic spec reference :)\nThere are two significant challenges playing back this stream that I can see. First off, we carry very little state across segments in the transmux right now and we'd need to hold on to the decoder specific info at least to get this working. Buffering correctly to fetch the decoder specific info would be the other big change. We just modified our buffering strategy to always attempt to fetch segments that would append onto the buffered range that currently contains the playhead. I'm sure that could be enhanced to look back to the first segment if required but segment fetching isn't very well encapsulated right now so it could be tricky.\nThat seems like a bigger job than the other streams in this thread so it might be worthwhile to track it separately.\n. It should be falling back to Flash already if MSE isn't supported. What browsers were you testing with?\n. Everything should be working (including using MSE in FF42) as of 1.2.0. Please reopen if you're still seeing issues.\n. 1.2.2 includes built artifacts again. Sorry about the inconvenience!\n. Have you tried 1.1.0? We made a number of fixes to buffering in that release.\n. Do you think this is an issue in dash.js then?\n. Merged via https://github.com/videojs/videojs-contrib-hls/commit/bce88a1883f7af4573b553c11538afb180f42efd\n. In the 0.x releases of this project, native HTML5 video is being used to playback HLS. This sounds like a device/browser/OS issue. We might be able to fix it in the 1.x release using MSE. Any chance you've tried out a later version on Android Chrome?\n. @sgavali yes, it is. You can clone this project and build the development branch to try out the absolute latest, or pull it down from npm via videojs-contrib-hls@1.2.0.\n. Unfortunately, we're not going to be able to support video that only has a keyframe on the first segment. The HTML5 APIs that allow us to play back HLS are pretty picky and need at least one keyframe every segment to work. In fact, it's a good practice to make sure that your segments lead with a keyframe-- otherwise we may have to download multiple segments to be able to do a quality switch and that could lead to temporary playback stalls. The 0.17.x releases of this project are currently more stable but they do not support HTML-based HLS playback.\n. What version of contrib-hls are you using? Do you have an example segment anywhere we could look at?\n. Do you still see this issue in contrib-hls 1.x? What devices are you testing on? Also, if you have a publicly available stream we can try it against, that would help.\n. Firefox doesn't support source buffers that carry both audio and video data streams combined together right now. We switched to that format because it fixed buffering issues in Chrome 45 but the workarounds don't seem necessary anymore in Chrome 46. We're in the middle of splitting audio and video back out again, which should fix FF.\n. @aronallen basic playback support for FF via MSE should be in place in 1.2.0. Closing this one based on that but please reopen if it doesn't work for you after updating.\n. This has been tackled through a different PR.\n. Merged via 6dcb32ce0511541cabef26fefb935de3c2412f87\n. @IndyIndyIndy looks like the Travis failure was using == instead of ===. Mind updating the PR so we can pull it in?\n. I spoke with @mangui a little bit before hls.js was released and we both wanted to figure out how to combine efforts but it's a bit tricky when you get down to the details. One offshoot of that discussion was spinning off mux.js instead of building equivalent transmuxers for each project independently. If both projects shared that piece of infrastructure that would be pretty cool and a lot less duplicated work.\nMerging the playback engines themselves is harder because porting functionality is hard. My impression is hls.js is further along with stream/platform compatibility and has some cool features like redundant streams that contrib-hls lacks. I believe contrib-hls's live support is deeper (though there are still plenty of problem streams) and we have some features hls.js is missing, like support for AES-128 HLS encryption, timed ID3 metadata, and CEA-608 captions.\nSo in conclusion: awesome work hooking up hls.js to video.js! I'm with you completely that we need to figure out how to work together better. Maybe that means spinning off more parts of hls.js and this project into pieces we can work together on? I'm open to any ideas on the right places to cut things up. @mangui any thoughts to add?\n. Looks good other than the couple questions/comments I put in there. It's awesome that adding support for redundant streams turned out to be a relatively tiny change!\n. @ogzpub glad to hear it's working! We're trying to make this project a bit easier to integrate in 1.0 so we're bundling more up in the official distribution. Sorry if that was confusing.\n. One related thing to note: we suffix variable names with _ to indicate they're \"private\" and could change between releases. If you want access to the media playlists currently in use, you should call hls.playlists.media() on the playlist loader (which essentially returns media_).\nI've seen this streams swap from live mode to VOD mode when #EXT-X-ENDLIST is added to the media playlist myself without issues. Is there anything else interesting about your stream setup that might be influencing this?\n. Seems like we must have a gap in our tests if this snuck by. Otherwise LGTM\n. @ogzpub: We're aware of an issue in 1.2.1 where if you pause too long, the player will not be able to resume a live stream. Does that sound like your issue? If so, it's in progress right now. The goal behavior would be to rejoin the live stream at the moment closest to when you stopped playback.\nReloading the same stream again does seem viable as a workaround for the moment but we agree, it should work out-of-the-box.\n. Resuming live streams should be fixed in 1.2.2. Please give it a shot and let us know you're still seeing issues.\n. Debugging decode errors is a bit tricky right now since the browser tech is so young. In Chrome, you can visit chrome://media-internals/ in your URL bar to bring up a specialized debugging console that can help point out the problem. If the log events on that page are unclear, you can try the debugging workbench in our TS to MP4 transmuxing project. To use the workbench, clone mux.js and open debug/index.html in your web browser. That page has instructions on one technique for identifying problems and provides probably too much info on the results of converting your TS file.\n. I believe we've found (and fixed) other underlying issues that were causing this problem. Please re-open if I'm mistaken.\n. Closed via 7080865c5dbba6c01b46d649c7107d41326882b6\n. Does your m3u8 have codec attributes on the STREAM-INFs? We need to be smarter about audio or video only content but we should work correctly if you warn us ahead of time when you're using single-track streams. \n. Can you add some details on the platform(s) you're seeing this problem on? Specifically: browser and version, OS and version, device make and model.\n. @sgavali 3) sounds like it may be a video.js issue. What is player.currentTime() returning and what are you expecting?\n. It would require digging into the individual AAC packets. It might be computationally/code-size expensive and it's something we don't currently have implemented. I think Chrome is being overly picky about decoder configuration though and filed an issue to see if the restrictions could be loosened.\nIf we were going to detect HE-AAC, it would have to happen during the segment transmuxing process so this should probably be refiled against mux.js if you'd like to discuss it further.\n. This is occurring when you're just starting up your live stream? If that's the case, does it still occur once it's been streaming for 30-45 seconds? Could you capture your m3u8 responses when this is occurring and add them to this issue?\n. Thanks for the update, @Tralapo! We're going to keep this one open until we get rid of that exception but I'm glad it's not breaking playback anymore.\n. Doesn't seem harmful to have the check. LGTM. @imbcmdth?\n. @jvquarck just noticed this PR is against master. Did you mean to open it against the development (aka 1.x releases) branch?\n. Thanks @jvquarck and @forbesjo!\n. Updated our example page to use 1.x.\n. @Tralapo it is. Development is now tracking our update to es6ify everything.\n. Hmm. We have a couple fixes queued up for Flash and they sound similar to the symptoms you're describing. I'm hoping we'll finally get this one nailed in the next release. Stay tuned.\n. You can use the seekable attribute on the player to determine the beginning and end of the live window for a live stream (player.seekable.end(0) is the \"live edge\").\n. Dang, I screwed up. The correct code is player.seekable().end(0) (note the extra method invocation). Sorry!\n. LGTM\n. Imagine this scenario: we have five more seconds of content in the current buffered region, then a gap of 10 seconds, then two minutes of buffered content. We want to continue fetching segments to fill that gap (even though we have a lot buffered) so that we don't stall when we hit it.\n. @many74 that URL errors for me. Can you capture one or two TS files that are generated and link to them?\n. I get errors on the TS segments as well. Would you mind uploading them somewhere else?\n. Ok, I think I know what's going on with this one. We currently generate an mp4 fragment for each MPEG2-TS segment you load into the player. Fragmented MP4s can't reference frames in previous fragments so if your TS file doesn't start with a keyframe, we \"pull back\" the first keyframe we find to the start of that segment. If you make sure your TS segments start with keyframes, this issue should go away.\nFor the future we're thinking about generating MP4 fragments around each keyframe, instead of at the TS segment boundary. That should get rid of this issue where our splitting makes some video data unusable. I've filed https://github.com/videojs/mux.js/issues/45 to track that.\n. We have a PR open now to address this issue: https://github.com/videojs/mux.js/pull/57. If that (or something like it) gets accepted and merged, the keyframe-segmentation restriction will no longer be necessary.\n. That is some weird behavior. Anything info either of you could share about how you're encoding your streams?\n. We have a fix for this on the way.\n. We made a tiny but important improvement to behavior in 1.3.7 which may fix this issue. If anyone has a chance to try that release out and report back, it would be appreciated.\n. Closing this one in favor of the mux.js issue.\n. Your stream looks geo-blocked to me but I think I know what's going on-- it's probably because of a limitation in how Media Sources behave in the browser. Basically, if we start the stream and claim there will be video, the video element stall waiting for video when you switch to an audio only stream. We have logic built in that will avoid audio-only variants to get around this problem as long as you've specified the codecs for each of your variants in your master m3u8. We'd love to do a better job with this scenario but so far the best idea we've come up with is trying to insert no-op video frames into the stream dynamically, and that's pretty complicated. \nClosing this one for now but feel free to continue the discussion in the comments if you have other suggestions.\n. This looks like a case of missing keyframes on segments. We have a new and amazing strategy to deal with it that is working it's way through testing right now.\n. Closing as a dupe of #482 \n. This and #509 are getting at the same underlying issue. Closing this one since we will be addressing this as part of es6ifying the project.\n. Good idea. It seems like it would be a pretty easy PR for anyone interested in contributing.\n. We've swapped everything over to using babelify and npm scripts in the development branch. I don't want to add grunt back in just to do token replacement but I'd be down with a one-off script to do it.\n. We recently added a mechanism that temporarily blacklists a playlist if a segment or m3u8 fail. So the player should try to switch to a different quality level if it runs into segment issues with a particular stream. Are you not seeing that behavior in the most recent release?\n. Ok. I'd look into providing alternate streams then-- retrying segments within the same stream is not something we have planned for this project. If it's difficult to produce multiple streams for some reason, you could try faking it by creating a stub master m3u8 and adding duplicate entries for your primary m3u8.\n. Can you provide some background on why you're trying to determine the current segment that is playing? getMediaIndexForTime() is the way we go about it internally to the plugin but I'm curious what your use-case is.\n. Eventually, we run into resource limitations on the browser and I think 11 players with preloading on a page is something we won't be able to support. Glad preload=none solved your problem though and thanks for reporting the issue!\n. The latest release uses HTML-based playback anywhere that supports the Media Source Extensions API. It requires video.js 5.x (which I believe is why you were seeing your problem 2). Everything else sounds good. If you're having trouble setting it up, check out our example page.\n. We're looking into it as part of supporting alternate audio/video aka media groups. It's still early but we're getting started with #387.\n. Fixed in #533 \n. Playing back mp3s is out of the scope for this project, sorry.\n. The diff doesn't show it but I started moving tests in videojs-hls_test.js into a new module that uses the new test-helpers. I think we should move as much as possible over time but it would be a big effort and this PR is already gigantic.\n. Merged into development (after many rebases)\n. Tests!\n. @fzakaria your page is currently working because you've specified an mp4 fallback source. Chrome doesn't know how to play back HLS natively so it automatically tries the mp4 URL. Audio seemed to be working on my setup but if it was failing, it's a Chrome-MP4 issue, not this project. I think the issue might be that video.js is initializing your player before HLS is loaded. You may want to try removing the data-setup attribute and using videojs(videoElem) once the HLS has loaded instead.\n@maysale01 thanks for the example manifest. Parsing media groups is still a work-in-progress. I'm going to close this issue since it seems to be a misconfiguration but feel free to comment on #387.\n. Needs tests.\n. Good idea though it seems like something may have broken based on the Travis results.\n. @imbcmdth two nitpicky comments, otherwise LGTM\n. We're in the middle of es6ifying the project right now! We should have a PR open something this week (I think).\n. I'd love to es6ify contrib-dash too but I don't know of anyone currently working on it. Feel like submitting a PR? :)\n. The development branch is now converted to es6 and building to babelify!\n. You could seek to a particular timestamp when the play event occurs, then listen for timeupdate events and pause playback once you've hit the \"end\". This is less of a bug and more of a request for implementation help and that sort of thing is probably better handled through sites like Stack Overflow. Good luck!\n. Safari uses OS-level native HLS support for playback-- this project isn't involved in it at all. Sounds like a frustrating Safari limitation. Sorry!\n. @a2dmen we just fixed a FF issue in 1.3.7 which I think could be behind this bug. Any chance you can retry with the latest version?\n. Closed via 7080865c5dbba6c01b46d649c7107d41326882b6. Thanks @KatrinaE and @tenacex!\n. This looks like it was a HUGE effort, thank you! That's kind of a double-edged sword though-- it's so much change, it's really hard to review. Is there any way you can break this up into more bite-sized chunks so the changes are easier to verify?\n. We don't currently have a way of determining that. Can you elaborate on why you'd like to know it?\n. Closing since there hasn't been any activity here.\n. I think we have this fixed in 1.3.7. Please re-open if you're still seeing it!\n. We don't have a way of doing that right now short of overriding adaptive streaming entirely but it's something we'd definitely like to add.\n. That's the default behavior for video.js and live streams. There's been a good deal of discussion about improving it but nothing solid yet.\n. I don't have an Ubuntu machine handy. Anyone else able to verify this issue?\n. The tests aren't running because a number of dependencies aren't in scope in the test environment. I know we're trying to keep this PR small but I think getting the deps imported into the test harness wouldn't add much line-wise. It would also be a good test to show the new build process is doing sane things.\n. LGTM module @imbcmdth's comment as well.\n. Do you know whether your audio is AAC-LC or HE-AAC (or both?). If you're not using AAC-LC, you will need to have a CODECS attribute that specifies the AAC codec specifically in your master m3u8 file. The codec string for HE-AAC is mp4a.40.5.\n. Oh, looks like you have two audio tracks in there. We haven't really dealt with that at all yet. Any chance you have an example segment somewhere we could look at?\n. It seems like this one is related to support for multiple inband audio tracks. That would be a complicated enhancement that we don't have plans for right now so I'm going to close this one. If anyone is interested in giving it a shot, please open a PR!\n. Android devices have native HLS support so this project defers to that implementation. We are thinking about making it possible to force use of contrib-hls on Android but that's not a feature we have today.\n. Sounds like a server misconfiguration so I'm closing. Please re-open if it turns out otherwise!\n. Nothing obviously wrong with your setup. Can you put up a minimal example somewhere?\n. Haven't heard back so I'm closing this one.\n. My goals for modules in this project are:\n- They are short enough you can read through them easily. 500 lines or so seems like a good target.\n- They are not so short it is a pain to figure out how things fit together. Less than 20 lines seems like a warning sign to me.\n- They export functionality that is well-defined and useful stand-alone.\n- The functionality they export is actually used in the app.\nThe decrypt function and object, and the ntoh function don't to meet those criteria for me. AsyncStream is designed to be generic enough that it might be useful outside the decryption process so extracting that is fine by me. The other are not useful enough independently to be worth extracting and the combined module is still reasonably sized.\n. Oops, we need to update that warning. The correct method is:\njs\nplayer.tech({ IWillNotUseThisInPlugins: true }).doSomething();\nVideo.js Doc\n. Oops again. Here's the actual doc link\n. Smoov.\n. In playlist-loader.test.js: pulling respond() out into its own function makes this test file different from others that use sinon and only saves 10 characters or so. Doesn't seem worth it to me.\n. playlist-loader.test.js#650: accidental find-replace in the error message?\n. playlist-loader.test.js#696: find-replace again?\n. playlist-loader.test: linebreak on parens\n. playlist-loader.test: linebreak on parens\n. playlist-loader.test: find-replace this.requests again\n. playlist-loader.test: find-replace\n. playlist-loader.test: linebreak parens\n. playlist-loader.test: existing issue but duplicated assertion\n. playlist-loader.test: pre-existing duplicate again\n. playlist-loader.test: moving this comment makes its intent less clear\n. @BrandonOCasey finished reviewing.\n. @BrandonOCasey that file didn't show up in the diff for me so I had to review it line by line. I tried to link to each of the instances but if that didn't work, you may have to re-review it as well.\n. @BrandonOCasey two more line-break-on-parens in playlist.test.js but otherwise this looks good!\n. Does the SecurityError include a detail message?\n. We test with IE11/Win10 and IE11/Win8.1 over here so there's got to be some other factor at play here. Does your Windows install include all media components? Did you install IE in a non-standard way?\n. I haven't seen the SecurityError but I did find a machine that seems to buffer but not play. My best guess right now is it's an IE11 version issue but I don't have great evidence to back that up. If you discover anything interesting, please let us know!\n. Do you happen to know if the VMs it's failing on have Protected Mode on in IE?\n. Two tiny questions but no blockers. LGTM!\n. I'm going to close this because it seems like a browser limitation that we won't be able to work around. If anyone has any creative solutions though, please comment!\n. @gesinger: this would need to get migrated into the segment-loader PR right?\n. LGTM\n. Weird Firefox test failure in Travis. Investigating. \n. The m3u8 URL you provided is 404ing (and the response is missing CORS). Do you have another stream that is still running?\n. Closing since we haven't heard back on this in awhile. Please re-open if you're still running into this issue.\n. @BrandonOCasey: I'm still trying to work my way through the test cases. I noticed however, that you changed the order of operations in the afterEach() function of videojs-contrib-hls.test.js. This PR should not include any changes that would have required a re-ordering so I have to conclude that we've subtly changed behavior somewhere in videojs-hls.js. Also, you added a bunch of additional clock.tick()s to \"selects the correct rendition by player dimensions\". This also indicates a change in functionality.\n. I went ahead and made a number of tiny fixes as I've been reviewing this PR. You can review them in my repo.\n. My thinking was that we would try to keep index.html relatively simple so it could serve as an example integration for people unfamiliar with how to use the project and we'd put the \"smarts\" into stats/index.html. What do you think about moving these additional options over there? We could link to stats from index.html so it's a bit easier for people to find, if that helps.\n. Thanks for sharing your patch! It looks like there's a couple different tweaks going on in there. Would you mind explaining the extra behaviors you added in and the scenarios where they're helpful?\n. Your TS segments are encoded with HE-AAC audio. Unless you provide codec information, we assume you're using the regular AAC audio codec and Chrome throws an error if you attempt to feed HE-AAC to and AAC SourceBuffer (even though it probably shouldn't). If you create a very simple master m3u8 that lists a single variant and specify the CODECS attribute (i.e. mp4a.40.5) as part of the #EXT-STREAM-INF declaration, your stream should work.\n. One quick observation: the live window in this playlist is very small, just three segments. You will probably get more stable playback if you increase the number of segments available in the m3u8 at any point in time to 5 or greater.\n. That's configured server-side. You'd have to check the documentation for whoever/whatever is backing that live stream.\n. Glad that sorted it out!\n. We have a live example and instructions on this project's github page. Just so you're aware, this project is completely different from flashls. If you need support on using that project, you should head over to the flashls repo\n. If you're using Flash-based HLS playback, you need to worry about the tightening rules for Flash. Safari and Chrome will put Flash into a \"power saving\" mode if your player is below a certain size or not visible on the screen initially. \n. Tried your stream in MSE playback mode. Looks like your first segment is detected as starting at 0.044 seconds and so our segment fetching logic is cycling around trying to find media data for that initial fraction of a second.\n. A little more info: your first segment is detected as starting at 0.044 seconds because that's when the audio begins. The player actually plays fine through that gap but our segment fetching logic isn't smart enough to realize a gap that small at the start of the video is not relevant.\n. Is it safe to assume filterBufferedRanges_() is the only place this fix will be required?\n. Assuming your answer is \"basically, yes\", LGTM\n. We got started on adding support for alternate audio tracks and finishing that up has kept us from looking into a lot of these decode errors. We're wrapping up alternate audio right now though, so we should start addressing these cases soon.\nOne thing to note is there are a lot of different unrelated reasons for MEDIA_ERR_DECODE. If you have a public stream we can test against, adding that to the thread would be incredibly helpful.\n. When it's ready? ;) Rough guess: a week or so.\n. LGTM\n. Good point! Any chance you'd be interested in opening a PR to add it?\n. Should we fix this one in a new release of contrib-mse?\n. We cache of the length of the video so we avoid triggering some video processing more than strictly necessary. The duration may be updated when downloading and buffering a segment reveals that it actually is longer (our shorter) than advertised in the m3u8 file. The times in the m3u8 are often incorrect by seconds or more. \nThe allowCache directive actually applies to the video segment files, and we let the browser's standard caching logic take care of that. \n. For some reason, tiny gaps are being detected between the segments of your video. We need to do some investigation to figure out why.\n. @momkin I'm no longer able to access your stream. Can you provide a link to an m3u8 that's still up?\n. It sounds like your HLS is doing something interesting. How are you creating your videos? Can you put up a segment captured from your failing video somewhere public?\n. Interesting! Thanks for the additional info about the capture.\n. Looks like retrying key requests didn't make the move into the segment loader. I don't think it's a big deal now that we have variant blacklisting so I'm removing the test cases.\n. Two additional issues discovered:\n- Source Updaters hard-code the underlying SourceBuffer's MIME type to video/mp4\n- Source Updaters create their SourceBuffer as soon as their MediaSource opens, which may be before the media playlist has provided the codec configuration\n. This was interesting as a double-check on the other branch that brought over segment loader but won't be merged.\n. It's a little dangerous to fiddle with but you can just write over it at runtime. It's only a constant by convention. If you do decide to change it, keep in mind that setting it too low will cause some of your viewers to buffer during playback, and setting it too high will waste money on bandwidth that may never be used.\n. We've been doing a ton of work to improve compatibility in recent releases. Have you tried the latest version?\n. @imbcmdth updated our changelog with the changes between releases. The big difference is switching to using es6 in 2.x.\n. Can you paste in a snapshot of your m3u8 while your live stream is up? With live streams, buffering is complicated. We try to start playback three segments from live point which may be less time than GOAL_BUFFER_LENGTH. If that's the case, the buffer length is limited by the amount of content available in the m3u8. You'd need to seek backwards from the live point to make sure there's enough room to fill 60 seconds of buffer.\n. Since you have only 60 seconds of content available, you won't be able to see much effect from modifying the goal buffer length. Our default seek point would be 30 seconds from live in your setup which means the maximum possible buffer size would be only 30 seconds. if you seek back to the very beginning of the seekable window (that is, player.seekable().start(0)), the player might be able to buffer the full content window and get approximately 60 seconds buffered. You would be in danger of \"falling off the back\" of the content window in that case though, so I wouldn't recommend it.\nAny chance you could elaborate on why you need 60 seconds of content buffered in your player?\n. Are you experiencing playback problems with the default settings? Sorry to keep digging here, it's just an unusual setup and I want to make sure we're working on the right solution.\n. > NOTES:\n\n\nWe're not listening to audio segment loader progress events. This is because we do not need to switch renditions, and don't gain much by keeping an eye on the bandwidth (instead we rely on the bandwidth estimates from the combined video/audio stream).\nWe're not pausing the alternate audio segment loading on media changes, as we might as well continue loading the same audio track.\n\n\nMakes sense.\n\n\nWe're only tracking expired time for the main stream.\n\n\nSeems like we might run into live-sync issues without per-stream expired tracking but we could layer that in later.\n. Looks like a very promising start. My main suggestion is we work to be clear at  the outset the responsibilities of each part of the system so it's clear where functionality belongs. I'd suggest:\n- MasterPlaylistController: very m3u8/HLS oriented properties and methods. Mostly focused with managing and aggregating playlists loaders.\n- hls: very media-element oriented. Drives MasterPlaylistController and adapts m3u8/HLS events and methods to HTML events and methods.\n. I think this was the issue behind https://github.com/videojs/mux.js/pull/53. That was fixed in mux.js >= 2.0.1, which you should use if you build this project yourself (and in our next release when that happens). Do you see the same error if you build contrib-hls yourself?\n. Would you mind putting together a minimal example we could take a look at?\n. Hmm... that is interesting. Seems likely to be related to https://github.com/videojs/mux.js/pull/57 but the exact mechanism isn't clear to me. Thanks for the report!\n. This project only supports IE>=10. IE8 is just too slow to be able to play back HLS content acceptably on reasonable hardware. I'd suggest including an mp4 as a fallback source for IE8.\n. Right now, we don't throw away any buffered content when you move to fullscreen. With our standard buffering settings, that means it can take up to 30 seconds for the player to adapt to the new dimensions. \n. We could remove some portion of the buffer (currentTime + 5 seconds, say?) on the fullscreen transition to force a quicker upswitch. The downside of that approach is we risk stalling if the network happens to dip in performance right then.\n. Hard to say from your description. Have you ever seen this behavior with non-live content? Any chance you have an example stream we can look at?\n. Good point, we should clean that up. Seems like an easy project if anyone is looking for a way to contribute.\n. Do you have a link to an example stream?\n. Not today. It would be a cool addition if you're interested in contributing!\n. With Chrome's auto-updating policy, we can't realistically support versions as old as 34. If you're seeing issues in newer Chrome though, please open another issue. Sorry!\n. I don't see anything that would pause the segment loader if a bad audio track is encountered. Am I just missing the connection?\n. I think you nailed it, @t-n. For now-- make sure your streams have proper codec declarations. Once the Chrome fix hits general release, this won't be such an issue anymore.\n. Mentioned it in #647 but IE doesn't support responseURL\n. We're trying to support IE and (as written) this PR wouldn't work because of its use of responseURL. If you have another approach to solve this problem, don't hesitate to re-open this!\n. responseURL isn't supported in IE :(\n. @forbesjo there is no equivalent mechanism in IE. We could only use responseURL where available but that would make m3u8s with this type of redirect fail in IE and work elsewhere. That's pretty confusing for end-users and developers so I lean towards failing everywhere and encouraging people to not host m3u8s with an initial redirect.\n. Some combinations of Windows10/IE11 have bad MSE behavior that we don't think is workaround-able or even detectable. We decided to note this in the README rather than baking-in Flash-based MSE with UA detection in case other people wanted to try it out for themselves.\n. We're not planning on overriding native HLS behavior for Firefox on Android soon, so I'm going to close this one.\n. @BrandonOCasey what's the intended precedence on the options? It would be nice to have a test that enforced that (if we don't already).\n. Otherwise, LGTM\n. Thanks for providing an example stream!\n. Given we never merged the retry change, I have to conclude this test is not valid. Please fix @imbcmdth's comments, include his original change, and rewrite the test so that it would fail without the retry enhancements.\n. Fix for #621\n. Currently, we let native HLS implementations take over if they're available. It seems reasonable to add some option to use contrib-HLS even when a native implementation is available, though. Interested in trying to write a PR for that?\n. LGTM\n. Looking in the wrong place, nevermind.\n. We have but we see a lot of differentiation between MSE behavior within IE11 that we still don't understand. On some machines, things works great and on others MSE doesn't work at all. The current theory is Windows updates to the underlying media libraries affect MSE support in IE and it's not clear what is installed where.\n. As a workaround, you can force Flash-based HLS on IE11 if too much of your audience seems to be encountering it.\n. Re. #655: sorry, didn't see that was a merge into the blacklist-manifest-stuck branch. Looks good to merge into blacklist-manifest-stuck to me. @imbcmdth?\n. Do you have a link to the stream you're seeing problems with?\n. I'm not re-reviewing this sucker :) LGTM!\n. LGTM\n. We have this sort of thing reported from time to time and it is typically something weird in the TS segments. We can't fix it without an example TS, though. Can you capture one of the segments that are getting downloaded in a loop and attach it to this issue?\n. We don't have plans to support raw TS playback in this repo. You could probably build something yourself with mux.js. If you do, please let us know!\n. @tenacex @imbcmdth The term \"adaptive seeking\" is jargon-- it's not descriptive enough to be clear to someone who hasn't been intimately involved in this project. Jargon makes it harder for new people to figure out what's going on and help out. It's fine if you'd like to refer to this technique as adaptive seeking among yourselves but we should use more accessible terminology in the code, even if it means we have to be more verbose.\n. @BrandonOCasey I like that idea a lot. I'm digging through the HTML spec to see if there's a semantic equivalent for playbackstalled just to make sure we don't create a new name if one already exists. skipTheGap() or similar sounds like a good name-- I like that it's very clear about the side-effect of calling it.\n. That's a surprise. Do you see segment XHRs being sent in the dev console?\n. Your m3u8 is working for me with contrib-hls 3.0.2 and video.js 5.10.2. Closing based on that. Please re-open if you still have issues after upgrading.\n. It seems like the idea was to call the tech when currentTime() was required. Why not update fastQualityChange_ to call the tech?\n. What version of contrib-hls and video.js are you using? Is your stream publicly available for us to check?\n. LGTM\n. It might not be the most discoverable location but you can check our package.json to see the minimum video.js version for contrib-hls.\n. When a decode error is hit, the source buffers, media source, and video element are put into an unrecoverable state. To handle this situation, we'd have to unload the media source which would throw out all existing buffering. After creating a new media source and attaching it, the choices I see are:\n1. Seek forward immediately past the broken segment. Under normal operation we're buffering 30 seconds ahead of currentTime so this will probably result in the viewer missing 40 seconds of content.\n2. Rebuffer content at currentTime up to the broken segment, wait for playback to stall at the gap, and then skip over it.\n3. If there's a variant playlist available, blacklist the current playlist, rebuffer everything, and hope that the decode error doesn't occur in the variant.\nIn 1. and 2., there's still a question of what to do if the viewer seeks back to the broken segment. In any of the cases, the viewer is definitely going to notice something bad is happening and I don't think the experience will be better than destroying and recreating the player. \nAll of the options are quite complicated and seem like they would result in a bad user experience (without better platform support, at least). Based on that, I think the best option is to fix whatever issues are causing the DECODE errors in the first place. I'm going to close this one based on that analysis but if anyone has an alternate implementation idea that has better behavior than my proposals above, please continue commenting!\n. @pedromcunha any chance you could share your micro-library? Sounds like some of the folks on this issue would be very interested.\n. Thanks for the PR! It seems to me though that we should have unregistered the handleUpdateEnd_ listener after dispose() so this shouldn't have been invoked in the first place. Would you be up for modifying this PR to properly clean up the listener on dispose instead?\n. Perfect, thanks!\n. LGTM after a rebase.\n. Amazing! LGTM\n. LGTM though we might want to add some tests around this at some point.\n. That URL is using a private subnet IP address-- we won't be able to access it to help you debug. Do you have a public example anywhere?\n. Agreed on the TODO. LGTM pending tests.\n. Also, we should add a test for this scenario along with the real fix.\n. It would probably be helpful at this point to break out any remaining problems into separate issues. I'm going to close this one based on @imbcmdth's analysis. Don't hesitate to create a new issue (with an example m3u8) if anyone is still having problems with the latest release.\n. Sorry, on most modern browsers requests for HTTP content will be blocked if they're loaded from an HTTPS page. Your best bet is to find a way to host your videos over HTTPS as well.\n. Based on the video type attribute at the end of your comment, it sounds like you're trying to play an mp4. This project is for playing back HLS video. I'd suggest checking out a primer or two on HTML video and if you still think you're having an HLS issue, filing  a new issue using our template. \n. Some minor comments but otherwise LGTM\n. I am. Fixing up the test cases and then I'll open a PR. \n. @MichaelSavin fmp4 support is in master now! Worth noting: the Flash fallback doesn't support fmp4 playback so it only works on browsers that support MSE (and don't have native HLS capabilities).\n. Codec support is handled by the individual browsers. It sounds like Chrome doesn't support that audio codec so unfortunately there's nothing we can do in this project. If you can, try re-encoding with a more common audio codec. \n. The browser should be applying standard caching rules to the XHRs for keys. @maddygoround @benvirus @colt082295, do you have caching headers setup for your keys? Also, make sure you have caching turned on if you're watching requests in the developer console. I'm pretty sure caching is turned off when the dev console is open by default.\n. Should be fixed in 3.5.1.\n. It seems wrong to me that the ordering of these two calls on segment loader causes a problem. What changes would be required to segment loader so that this code wouldn't be so sensitive?\n. This doesn't make things clearer for me, but if you guys think it's easier to work with I don't object. \n. What happens when you call pause() in the init  state? \n. Could you elaborate on the purpose of the PRELOAD? What information is required to move the loader into READY?\n. @mjneil so INIT is basically PAUSE? :)\n@gesinger seems like a reasonable suggestion to me. \n. You would need a server somewhere to add up all of those viewer counts, and then some way of querying for the current count of viewers from that server. That's definitely doable but this project is focused on the in-browser aspects of live streaming so we wouldn't take on something like that. Sorry!\n. The last test is failing because of the issue fixed by https://github.com/videojs/videojs-contrib-hls/pull/838\n. Alternate audio is working correctly again after my last update. Requires https://github.com/videojs/videojs-contrib-media-sources/pull/101\n. Found an issue with MP2T streams that do not begin playback from a muxed variant. When the timestamp ID3 frame is parsed, the base timestamp for the AAC stream is undefined. That causes the cueTime of the corresponding id3 object to be NaN when the timelineStartPts is subtracted from it. Attempting to create a cue with NaN start and end times throws an exception and prevents playback.\n. Fixed the issue mentioned above via https://github.com/videojs/mux.js/pull/115. My last commit addresses a source buffer codec problem that was revealed after that fix. I've tried with a bunch of different muxed and unmuxed media configurations now and feel this is ready for testing.\n. @dgoldstein0 we're using the <base> element because m3u8 URLs need to be resolved relative to the m3u8, not the page the player is hosted on. The standard a.href approach doesn't work because that calculates relative to the page the player is running on. parseUrl() does half the job but it would still require us to translate interesting URL features like relative paths and I've been hesitant to do that because URLs are pretty complicated when you get into the nitty-gritty.\nWe're open to solutions that don't use <base> and IE6 support isn't a requirement :) Have any suggestions?\n. M3U8 is the \"master inventory\" for an HLS video stream. When you specify an HLS video to a player, you're actually handing it a URL to an M3U8 file. That file can specify the different bitrates available for the video or a list individual video chunks. In ugly ASCII diagram format, M3U8s form a hierarchy that kind of looks like this:\nmaster.m3u8\n|- low-bitrate.m3u8\n|  |- low/0.ts\n|  `- low/1.ts\n`- high-bitrate.m3u8\n   |- high/0.ts\n   `- high/1.ts\nIn this example, if master.m3u8 was hosted at https://example.com/videos/master.m3u8, the first low-bitrate segment would be at https://example.com/videos/low/0.ts. The tricky part here is  when you're resolving those relative URLs (e.g. low/0.ts) from a player hosted at a different base path than the M3U8s. If your player was at https://example.com/pages/example.html and you tried using the a.href approach, the first low-bitrate segment would be incorrectly requested from https://example.com/pages/low/0.ts. The mechanism we're currently using in resolvePath can handle base paths that are different from the containing page and a whole bunch of other URL complexities since it's piggy-backing on top of the browser's native URL resolution.\n. @sobytes thanks for following up with the root cause.\n. Should be fixed in master now. Rerunning Travis.\n. LGTM\n. @BrandonOCasey there is no playlist selector on the prototype before this test runs. While I know delete is a no-no, this resets the prototype back to the state it was in before the test started mucking with it.\n. @SuriGill are you retaining all segments in the m3u8 for the duration of your stream? You may just be hitting the limits of available memory on the machine you're playing the stream from. We're open to changes that improve memory efficiency but you'll probably be better off by clearing out old content from that m3u8 as time progresses.\nI'm closing this one based on that recommendation but feel free to continue commenting if something more complex is going on.\n. You're in luck! The default adaptive switching algorithm in this project already does that. Technically, we will switch to the rendition that's just bigger than the player's display size if there isn't an exact match, but we wouldn't choose a rendition any bigger than that. More details in our design doc, if you're interested.\n. Our goal for converting CEA-608 would be to follow the current W3C spec so if you see particular instances we're not achieving that, please file separate issues for any you find. We are missing support for parsing some of the positioning and formatting commands in CEA-608 as well as paint-on mode today. If you're interested in helping out with that, please check out mux.js!\n. Most live HLS that I've seen removes content from the beginning of the stream when it adds content to the end. For long-running streams (days/weeks/years), this is important to ensure the m3u8s don't grow to GBs. If our merge is inefficient, PRs to fix that would be totally welcome but we want to retain the capability to correctly play back live content that drops segments over time.\n. Looks good. Thanks @piotr-cz!\n. @TylerZubke resuming live streams paused for a long time should be fixed by https://github.com/videojs/videojs-contrib-hls/pull/899 in v3.6.8.\n@mkhazov we'd like to allow users to be able to pause live streams for a short period of time and resume without forcing them to seek back to the live point and miss some content. If we don't keep reloading manifests and buffering content, there will be a gap in the buffer and those segments may have disappeared by the time we resume playback. It does mean some extra buffering could occur but that amount is limited to 30 seconds. Safari on iOS behaves similarly in my testing. I'm closing this issue since this behavior is intended but I'm happy to continue the discussion.\n. @benvirus do you have caching headers setup on your key URL? Also, have you turned off HTTP caching when the developer console is open? The browser should be caching keys automatically unless your headers specify otherwise.\n. @russitto were you testing this in Edge? Edge has native support for HLS. Currently this project delegates to a native implementation of HLS if one is available.\n. LGTM\n. LGTM\n. @mjneil naming question but LGTM\n. Ran tests on my machine since Travis is running into DNS issues, all good.\n. Yes, you can override hls.xhr to implement your own segment loading.\n. @silverbucket depending on what you're trying to do, you can override hls.xhr or (better) provide an implementation of videojs.Hls.xhr.beforeRequest.\nClosing since I think that covers your question. Feel free to comment if I missed something.\n. I think you're overriding the wrong function. If you'd like to completely overwrite requests, you do it on a per-player basis (not globally for the page). Like this:\n``` js\nvar player = videojs('video');\nplayer.ready(function () {\n  player.src({\n    src: \"https://d2zihajmogu5jn.cloudfront.net/bipbop-advanced/bipbop_16x9_variant.m3u8\",\n    type: \"application/x-mpegURL\"\n  });\nplayer.tech({ IWillNotUseThisInPlugins: true }).hls.xhr = function (url, callback) {\n    console.log('XHR called ', url, callback);\n  };\n  player.play();\n});\n``\n. Good find and thank you for the running example!\n. @imbcmdth has proposed https://github.com/videojs/video.js/pull/3736 to address this.\n. I've never seen that happen. Can you provide us with a [reduced test case](https://css-tricks.com/reduced-test-cases/),?\n. @askaliuk thanks for noting that fixed the issue. Closing.\n. @askaliuk the^` operator in the version should pick up the latest patch version of contrib-media-sources so it's only necessary to rebuild and re-tag to pick up the change. I definitely agree it's a bit confusing.\n. LGTM\n. @gesinger good point, fixed.\n. LGTM\n. Still looks good.\n. @smarshallsay I don't know if the way you're specifying your audio-only variant stream is valid. contrib-hls is most likely loading the audio-only variant since it avoids renditions that are significantly bigger than the player viewport and your renditions are bigger than the average web player viewport. I created an alternate master m3u8 that only included the audio-only variant and that stream failed for me immediately in Safari as well.\nI think this would work if you can remove the audio group definition from your audio-only stream. That is, the last entry in your master m3u8 would look like this:\n```\nEXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=146000,CODECS=\"mp4a.40.2\"\njensentest_HLSv4_audio_v4.m3u8\n```\nIt's not clear to me the correct way to specify alternate audio for audio-only variants. It may be a case that isn't actually handled in the spec right now. Closing this issue but please keep commenting if I've missed anything.\n. Minor comments. LGTM\n. @arendjr @rgc you make compelling arguments. I closed the other PRs on platform-consistency grounds but three independent contributions is a pretty strong indication I was probably wrong. Here's my question: is there any way we can warn people in IE that their video isn't working because of redirects? Speaking selfishly as one of the folks who reviews issues, I'd like to make this problem easy to diagnose.. @arendjr that sounds like a pretty good idea. Would you or @rgc be interested on modifying this PR to do that?. LGTM\n. LGTM\n. That is supported, as long as you're using whole-segment AES and not \"sample AES\". Can you share your m3u8 or (better yet) a link to your stream?. When are you activating your plugin? If you do it immediately after setting the source, I would think your modified playlist selector would kick in before any buffering.. I'd suggest the fix for this is to update videojs/m3u8-parser so empty manifests return an empty array, instead of undefined.. Looks like that issue has already been filed over there: https://github.com/videojs/m3u8-parser/issues/8. @gkatsev yeah, that would be cool. Good to note for the future.. @mjneil I verified in Edge-- it's exploding as designed.. Closing based on @forbesjo's testing. Please reopen it if you're still having problems after updating.. LGTM. Adapted from http://miskun.com/javascript/internet-explorer-and-binary-files-data-access/. I attempted the ActiveX alternatives but gave up on them because they popped up an \"Accept ActiveX control?\" dialog on my VM.\nThe ballpark performance numbers in the link imply we'd have a ~1Mbs throughput limit in IE8 if we were willing to freeze the UI during segment parsing.\n. This has no effect in IE8.\n. I didn't get around to it but this forEach would also have to be converted to a loop.\n. Most of the lines below are bad diff processing/whitespace changes.\n. Use an old-fashioned loop instead of forEach\n. I bumped this up two orders of magnitude. The author of this comment is correct, it definitely looks like the browser has locked up with large arrays :)\n. Related SO post\n. Do you mean to do a signed shift here?\n. If I had to guess why this isn't working, I'd bet the answer to this is \"yes\".\n. @bclwhitaker: @heff pointed me at the vtt.js tests as a strategy to cut down on the boilerplate in our tests cases. I like the very declarative test case setup but really wanted tests to continue to run in real browsers instead of just node. This is my attempt to balance those two concerns. You can add any m3u8+json file pair, and they'll be automatically exposed to the test harness and compared for deep equality. I converted all of your test cases to this format. Let me know what you think.\n. I think this still doesn't quite match the plugin naming conventions, but it's a lot closer.\n. @heff: this isn't the transparent HLS support we were shooting for so we'll have to take another pass at that some point soon.\n. @gkatsev: I didn't feel like I could get the PEG-based parser to handle crazy manifests and bring the file size down to something reasonable without rewriting the whole grammar from scratch. Given that, I felt it was less effort to go this route. I suspect you'll disagree with me on this one but I wanted us to have a concrete alternative to discuss. Feel free to rip this implementation apart in the comments :)\n. It might be more accurate to call this object an EventEmitter but I went with Stream because of the pipe method. I would have liked to piggy-back on video.js's event system but that would have required extending Component and creating an unnecessary DOM element. \nI've written something like this in a couple plugins now. It may be worth extracting and standardizing somewhere.\n. I was prepping for adaptive streaming but these properties aren't used anywhere yet.\n. All the XHRs in this file could use some error and retry logic.\n. Sounds nicer to me. I'll look into that in a future update.\n. That's a possibility. I could also just use a switch-case which is probably more familiar than this form. I'll look into switching it to one of those.\n. @seniorflexdeveloper: this change broke a bunch of the test cases, can you please fix them?\nMy organizational plan was that all of the logic that normalizes manifests would be performed by the Parser object and trigger an info or warning event. How would you feel about moving this logic into there?\n. One day... I've been converting them gradually as I run across one and it sufficiently annoys me.\n. Yes\n. How long until the SWF changes can be merged into mainline? I'd prefer to hold off on updating dependencies until we can be on the official branch of everything.\n. Yeah, that should be it.\n. Good point. Adding.\n. Why make this a function?\n. I don't understand how the plugin could work with this section commented out.\n. videojs.util.mergeOptions\n. I've been trying to follow jQuery plugin naming conventions  and call this variable settings.\n. I believe this needs to move above the call to xhr()\n. This can't be pulled in through npm?\n. Why add the else?\n. Why does Flash need to know about the new duration?\n. When is totalDuration called with an undefined playlist? Should there be a test for that scenario?\n. Can we get rid of this variable by setting a default response type in the declaration of options?\n. This looks tons better. Huge improvement!\n. Kill this comment.\n. Is this necessary with sinon?\n. Works for me.\n. \"sinon\": \"^1.9.0\"?\n. Gotcha. Not worth holding this PR up on, but can't we just not call sinon's request.respond to simulate an arbitrarily delayed request?\n. Can you add a note on how this interacts with CORS (and why you might not want this to be on)?\n. Smooth.\n. Agreed. At the time we wrote this, get was missing a lot.\n. It's probably better to internally reference the tech through this but there are some properties and configuration that can be handy to have access to at runtime. It's useful to understand what state the playlist loader is in, for instance.\n. The tables have turned, I see... :)\n. How about abortTimeout?\n. Can you switch this to unshift()? Ideally, HLS would be used if the provided sources were:\njs\n[{ \n  src: \"movie.m3u8\", type: \"application/x-mpegURL\" \n}, {\n  src: \"movie.mp4\", type: \"video/mp4\"\n}]\nAlso, we need to double-check that the HLS tech is not used if native HLS is available through the HTML tech.\n. Yes, it's just desktop Safari. Safari still does a couple things better than the HLS plugin (alternate codecs, segment discontinuity, \"interesting\" encodings), though. I think native is worth keeping.\n. I don't feel that the additional function is really worth it here. fillBufferand drainBuffer already have to check the presence and type of their first argument to operate safely. Adding the wrapper creates an extra bit of indirection and doesn't relieve them of that responsibility.\n. That is true and I agree that it is weird that the event gets packaged up in the segmentBuffer. In drainBuffer, we do check to make sure the value is a number so I don't think there's a logic error here. It is quite detached from the origin of offset though and that it is definitely confusing. Rather than wrapping the registration of fillBuffer in an anonymous function, how would you feel about something like this early in fillBuffer:\njs\noffset = typeof offset === 'number'? offset || 0;\n. If you're up for it, that would be great! I think it may also be necessary to modify that line of code you cited above:\njs\n// if there is plenty of content in the buffer and we're not\n// seeking, relax for awhile\nif (typeof offset !== 'number' &&\n  // ...\n. Sounds great, thanks for all the help with this. We'll have to weed out that code that is relying on the Event-- anything that does that sounds like a bug to me.\n. The sinon version is to work around a bug in the latest edition. You're right we need to get back onto mainline. There's no reason to use the patched version of 4.6.1 anymore.\n. From my reading of the spec, endOfStream() should be called once you append the last bytes of a video into the active source buffer, not once the source buffer has been exhausted. It would be great if we verified that, however. In this form, it achieves the goal of this PR: the spinner doesn't show up and hitting play restarts the video.\n. Is it safe to assume all of these functions are just moving (i.e. no logic changes)?\n. Why can these lines be removed?\n. I would say this is a SWF issue. The loadedmetadata event here is more accurate than anything Flash could be inferring based on the NetStream.\n. This is a good comment but I think it would be more helpful to note when the indexes might change (live).\n. Why does playlistSelector and selectPlaylist take different arguments?\n. I really wish @seniorflexdeveloper would finish the documentation of this function...\n. A lot of these functions were file-scoped because they were intended for internal-use only. I don't see a lot of harm in exposing them but I don't think they're written to be general-purpose utilities.\n. There should be whitespace between the opening curly brace and the close parenthesis.\n. I think I prefer aligning variable declarations like this but we haven't been using this style elsewhere.\n. Returning here means the buffer won't be filled and the next call to fillBuffer() will trigger the segment to be downloaded again. If it takes awhile to fetch the new media playlist, it seems like this could end up eating a lot of bandwidth.\n. Good point. The change wasn't intentional.\n. It's an external dependency but I wrote it so I'm pretty comfortable with it :) It seemed like it was isolated enough that we didn't need to include it in the main library. Plus, I wanted a command-line utility for testing and the number of utilities already in the test/ directory is getting a bit out-of-hand.\n. Most of the fancy stuff is from SJCL but thank you!\n. Update the test message (according to you).\n. Inconsistent variable indentation.\n. I think this should be player.hls.playlists.media(). If it's unused, please remove it.\n. Is it necessary to push in the PES object here? Won't each element of stream have the same data at a more granular level?\n. Should we unregister readystate handlers like we when aborting the segmentXhr?\n. This test file is massive. Since this only touches xhr(), it would be nice if we kept it separate.\n. These conditionals are really complex. At the least, there should be a comment describing the desired effect here. It feels like we're trying everything and seeing what works, however. I think this deserves a re-think.\n. This operates by waiting until a media playlist has loaded and then switches to a different one if it seems like the original choice was incorrect?\n. Whitespace after the ,\n. Might be worth elaborating on when a second playlist should be downloaded.\n. Whitespace around operators. Why would we want bandwidth calculations to be NaN?\n. If we're going to expose this function, can we make it a bit more generic? We could allow it to accept a generic object that included the bandwidth stats we're looking for.\n. Is this the first segment of media1? Is there any way to make this a little clearer?\n. It would be safer to actually walk back across individual segments and accumulate their individual durations until there's enough content ahead of the starting index.\n. What about using setBandwidth() to change the associated properties and trigger the event?\n. Our convention is to have whitespace around keywords like if (so add a space between it and the open paren).\n. Can you move the var declarations up to the top of the scope? You can still wait to define them until down here.\n. Nice! Thanks for the test.\n. It expects roundTripTime, bandwidth, and bytesRecieved. BytesReceived are defaulted to zero if not supplied. roundTripTime isn't actually used anywhere and setBandwidth() is happy to set it to undefined.\n. I'm wondering if there's a better name for this method now that we'll be using it for more than just segment URL resolution.\n. The comment above this line is now incorrect.\n. From my reading, it's entirely informational at this point. I included it just for completeness sake.\n. VTTCue is the only concrete implementation of TextTrackCue that I'm aware of. I would have preferred using a more generic cue type for this but I don't think that's supported anywhere.\n. I'm not completely sure why this text is highlighted in red in github. A text encoding issue, maybe?\n. For most of the other properties in this parser, we haven't added key/values for attributes that weren't present in the m3u8.\n. Ok, cool.\n. Added a feature detect before the metadata event handler a couple lines up.\n. I was thinking 250ms was a bit more frequent than we actually needed, given we call fillBuffer() explicitly whenever we take an action that has a big effect on the buffer.\n. We could try to be more clever about when buffer checking was in effect but trying to be clever was the reason for these issues in the first place. This iteration does some extra work when no video is loaded or buffering has completed but it makes the tech lifecycle more consistent. The extra checks don't even show up in the profiler for me so I feel like this is reasonable.\n. @rajkosto this is a great place for the key when it's present in the manifest. If it's not present though, we've been signaling that by not including the property name. Could you update this so that entry.attributes.IV is only set if a custom IV is present in the m3u8?\n. Ok, that makes sense. Any reason you went with Uint32Array instead of Uint8Array here? I'd be cool with pulling this in if you could change the file extension of the examples to .js. We'll just have to be strict about the sort of expressions we let in here in the future.\n. Should we be calling this function with a half-loaded playlist now?\n. We don't support IE8 in this project but you should get into the habit of using this.hasClass() for maximum compatibility.\n. Please document this function. Also, we should denote it as private (append an _) unless there's a good reason it should be exposed.\n. Also, \"set\" in the name implies some sort of mutation to me. I like side-effect free but the name should change.\n. For consistency with the rest of video.js, I think it's still better to use hasClass(). Plus, it's actually less typing here.\n. We should make an index page of some sort for docs but my main point with this PR was to expand on the adaptive switching info.\n. \"Always be playing\" is my motto :) I skipped over it for simplicity sake in this write-up but we will use the first listed encoding if all the available encodings are filtered out by other parts of the process.\n. Added a line at the end to clarify the worst-case scenario.\n. That's a good point. There's a bunch in the mp2t-to-mp4 branch that I'd like to move into master someday...\n. Are the key properties important to this test?\n. Please add whitespace between arguments to functions.\n. If you could add a comment explaining why this comparison proves that drainBuffer() isn't dropping segments, I think that would make this test easier to understand.\n. Why is this necessary?\n. Should those tests be invoking this method without segments?\n. Are you doing this inside the loop in case PTS values are not ordered ascending? I don't think that's necessary.\n. Can you calculate the segment duration immediately following the muxing so you don't have to check whether it needs to be calculated or not every time the duration is computed?\n. Won't this trigger endOfStream() after every segment finishes?\n. Why did you remove this?\n. updateend should fire after every appendBuffer() operation has completed, not the end of the stream. I think this test is asserting on the wrong thing now.\n. This section could use some commenting about what is going on and why.\n. More concisely (though maybe not more readably): dur += segment.preciseDuration || segment.duration || playlist.targetDuration || 0\n. Can you add a condition to show that the calculated total duration of the video is affected by now having preciseDuration?\n. @mmcc I'm with you-- I definitely want to adopt standard across all the contrib plugins. We haven't had a chance to convert this project over, however, so I'm following the current conventions until we can do that sweep.\n. Should the second condition be player.preload() === 'none'? options are set on player creation and (I believe) ignored from that point out.\n. What changed in here?\n. I know this code is very inconsistent about variable naming but we should stick with camel case.\n. Why do you parse these additional fields?\n. What about if we made this a getter/setter method so it was a little clearer there are side effects going on behind the scenes?\n. Cool. I do think we should nix them before merging.\n. I was thinking of turning keyFrame into a combo getter/setter but setNextFrameToKeyFrame seems like a legit option, too.\n. In the future, please try to split refactor PRs from functionality-changing PRs so it's clearer what needs to be reviewed.\n. This had to be a huge pain to track down. Thank you!\n. Isn't this equivalent to the computation of translatedMediaIndex? If original.mediaSequence === update.mediaSequence, then:\n(mediaIndex + (original.mediaSequence - update.mediaSequence))\n=> (mediaIndex + (0))\n=> mediaIndex\nThe only case where that value is unused is if the resulting index is outside the scope of the current playlist. Were you seeing situations where translatedMediaIndex === update.segments.length?\n. Ok, that makes sense. It seems to me that the conditional is wrong. If we made the test translatedMediaIndex >= update.segments.length + 1, would that resolve the issue?\n. When all the segments currently available in a live playlist have been downloaded, mediaIndex will point to one beyond the end. There's nothing wrong with this situation, we're just waiting for a playlist refresh. It's incorrect to reset mediaIndex back to the live point if this occurs.\n. Good point, it would be nice to piggyback the changelog onto the merge commit. \n. Why are two cases necessary here?\n. endList is the signal that the playlist is complete and there will be no further updates, i.e. it's now a VOD playlist.\n. If currentTime is zero, would this cause unnecessary re-buffering?\nAre you sure that currentTime === duration? Could currentTime be 9.9999 and duration be 10, for instance? We support m3u8 annotations (#ZEN-TOTAL-DURATION) which might not be perfectly accurate.\n. My reading of the ended property seems to imply that currentTime should never be zero at this point. I think we should fix that rather than have all of these cases to handle here.\n. Accidental whitespace?\n. Looks like you may be using tab-based indentation. This project uses 2-space indent\n. Why the change in this URL?\n. Why add these two jshint overrides? What are they?\n. I think these are all whitespace changes. If so, they should be removed from this PR.\n. Can you be a bit more descriptive?\n. Where is length defined?\n. This test doesn't exercise any of contrib-hls. You want to show that when seeking, we can iterate off the end of the parsed tags if the target PTS value is greater than the PTS value of the latest tag. You'll probably need to involve the mockSegmentParser and an instance of the HLS tech itself.\n. Yes, please remove the overrides. The hint was telling you not to use tabs for indentation :)\n. Yep. preciseDuration didn't account for time-shifted audio and video tracks or the gaps between PTS values across multiple segments. That could add up to tens of milliseconds of error per segment.\n. We should. I was shooting for MVP with this PR because the releaser was a bit finicky. Hopefully it will be easy to add the unminified version to this once we get the process working smoothly.\n. is there any way we can unify this with the regular test harness so we don't have to update script locations in more places?\n. I didn't realize merge wouldn't complain about that. Good suggestion!\n. This way the viewer misses the minimum amount of content relative to when they paused the broadcast. The choice is a bit subjective but I think this is defensible.\n. I don't believe calculating seekable end is expensive enough to worry about caching.\n. I was trying to ensure the change was applied cleanly on top of HEAD, not merged. My understanding is this after-the-fact rebase accomplishes that. You don't think so?\n. Turns out this would put the changelog commit before the body of the patch, which isn't what we're shooting for. Sticking with --amend for now.\n. So grunt test would not run the end-to-end tests?\n. Doesn't setCurrentTime() already handle this?\n. I believe this function got re-added somewhere along the way. It should be removed entirely.\n. Basically, yes. It tries to find the longest span of segments that have PTS info available at the start and end. It does this by:\n1. Splitting the interval into ranges that do not have internal discontinuities\n2. For each of these ranges, finding the earliest and latest segment with PTS info\n   1. Adding up the differences between the earliest PTS and the latest PTS in each range\n   2. Adding up the M3U8 based durations for any segments in the range that aren't in the interval above\n. Yes. It makes splitting intervals into continuous spans a lot simpler.\n. Oops\n. Why is this line necessary?\n. This can be rewritten a bit more succinctly as player.tech.el().vjs_getProperty\n. The code below makes sense but this comment confuses me.\n. If that's true, it sounds like a bug to me. Anytime a seek completes, lastSeekedTime_ should be set to null.\n. In that case, I think we should be consistent about what value we choose for lastSeekedTime_ to indicate \"unset\". What do you think about initializing it to null in the init function and then just checking for null?\n. If you seek once the video has ended, ended() should be false.\n. I believe we'll be switching all of the vjs-has-started to a mechanism like hasPlayed_ with the video.js 5.x update. I was trying to minimize the surface area of this particular PR.\n. You can detect whether DataCue or VTTCue is available and use the appropriate one where available:\njs\nnew (DataCue || WebKitDataCue || VTTCue)(0, 1, 'hi this is text');\n. What happens if WebKitCue is not defined?\n. Could we add deprecation warnings for the old property locations so we can clean them up before too long?\n. It appears this code will only run for the last cue created in the for loop above.\n. Nice.\n. This default seems a bit weird given the name of the method.\n. Not for this PR but we should just focus on the tech for these tests in the future (i.e. don't create a player at all).\n. It looks like these statements are overwriting the values at cue.frame.whatever with getters that log a warning and return undefined. Am I reading that correctly?\nI thinking make the old properties still usable (for now), but log a warning. More like:\njs\nObject.defineProperty(cue.frame, 'id', {\n  get: function() {\n    videojs.log.warn('cue.frame.id is deprecated. Use cue.value.key instead.');\n    return cue.value.key;\n  }\n});\n. Yes :/\n. I was shooting for a low-impact change while we figure out something more comprehensive. I agree we should have a more robust solution but (for now) this does seem to work very reliably in my testing.\n. The entries of a media playlist should be segment objects-- [undefined] is not a legal value for that array. Side note: it would be better to file this sort of thing as an issue. Line comments might get overlooked.\n. My philosophy with all things playback is we should not punish the viewer for the sins of the publisher :) If it's possible to work around problems without strong-AI in our error handling, I think contrib-hls should do so.\n. Agreed this is a better algorithm. Defer to another PR?\n. Statements like \"somehow\" make me nervous. Why would this condition occur?\n. I think you should use numSegments as your end condition here for consistency or get rid of the alias entirely. I kind of lean towards dropping numSegments since we already have a ton of function variables in scope but it's your call.\n. Aren't we guaranteed this condition would be handled in our backward-walking loop?\n. js\ni = 0;\ni = 0;\n. \"Algorithm Jon\" is a funny name but I think we should be less entertaining, more informative in the comments.\n. I'd put more detail on what \"Algorithm A\" is here.\n. You've switched back to clamping return values to valid indices in the segment array. At the time I tried this, I felt like failure to find an index was indicative of a problem elsewhere in the code and clamping would obscure that. You think that worry is unfounded?\n. I have tried to consistently use the suffix \"sequence\" only for variables that store numbers in the media sequence number line. Looks like you're using it for an available segment index here.\n. s/loose/lose/\n. It's unclear to me why we would look for this condition instead of just checking to see that a timeline update was made. Maybe a comment would help?\n. This conditional is pretty hefty. What about inverting it and short-circuiting?\n. There may be multiple updateend listeners on a source buffer and one of the previous ones could perform an operation that causes it to enter the updating state.\n. Huh?\n. We discussed normalizing this elsewhere. I still think that's the right move.\n. If getMediaIndexForTime() didn't clamp, the instance variable wouldn't be necessary.\n. Unused, remove.\n. This is to account for videos that don't appear to start from zero? I think we need to get to the bottom of that issue in the transmuxer, not here.\n. Ok, that makes more sense. Can you replace \"somehow\" in the comment with that example?\n. I'm not sure I totally follow your explanation. Assuming there is a need to signal something about why getMediaIndexForTime() did not find a segment, wouldn't -1 and segments.length indicate in what direction the failure occurred as well as let the caller know that an actual match wasn't found?\n. I only see it being assigned to here and the comment at the top of this function indicates playlist.mediaSequence is already a component. Seems like a bug waiting to happen.\n. Can we use currentTime !== 0 to capture that case? The 0.05 is the part of this condition that has me hesitating.\n. What is this?\n. I still think we can get rid of this additional instance variable but that explanation makes sense if you allow that it should exist in the first place :)\n. This is the actual rename.\n. Oops, forgot to address this one in my update. We should probably do a sweep to fix this all over the place.\n. Can end be less than zero after the previous line?\n. Should we make this a private function instead of keeping it inline?\n. Wouldn't this become a no-op in fillBuffer() anyways?\n. Yuck. We need to clean up this workflow but I'm ok with this as a temporary solution.\n. Should we be passing the entire error object here?\n. When would this occur? (Maybe a comment would help here)\n. Nice. We shouldn't assume segment.duration is always defined, though-- how about a fallback to targetDuration?\n. You kind of killed a test for 500 response codes here. Intentional?\n. > a ... the\n. Yep, this is definitely confusing :)\n. This fudge factor shouldn't be necessary but it looks like getMediaIndexForTime is rounding improperly right now. I'm looking into the fix but this makes rejoining live streams reliable for the moment.\n. Could we eliminate this extra condition by testing if time <= 0 on line 493 above?\n. Do we need to handle the time === 0 case?\n. Why increase the blacklist time?\n. Why increase the fudge factor?\n. I think this function would be easier to understand if the name of checkEdges() laid out what exactly it was checking. What about overlapsCurrentEnd()?\n. Could this be span[0] <= end && span[1] >= end?\n. This else is unnecessary. I typically drop the nesting in that case but the current else clause is so short it's not a big deal. Just noting for consistency elsewhere.\n. It looks like we're still nulling segmentXhr_ for all code paths after this point. Why repeat it within each of the conditionals?\n. I'm not clear on why this got distributed below either.\n. Beautiful tests!\n. ... and I should look more carefully before commenting.\n. Ah, ok. The exclusive-end argument makes sense to me.\n. So it can be un-redistributed?\n. When we have to reload the playlist because the video is live, I believe we recreate the segment objects and merge the properties together, which would cause this check to fail.\n. If you like this function on the HlsHandler prototype, I think it should be marked \"private\". We normally indicate a function is internal-only by appending an underscore.\n. Same comment about this function being marked internal.\n. This might be a controversial move but I'm ok with trying it for awhile.\n. You should check if the sourceBuffer is currently updating here, too.\n. This doesn't test the live case which is the more important one, right?\n. This comment seems out of date (specifically, the bits about clearing the buffer aren't at least out of order in this new location)\n. Couldn't this case be handled using segmentTimestampOffset as well?\n. Ok, I wrote up #474 to keep track of that.\n. I think it still does. In this case, the order the arguments are evaluated as they are passed to findRange_() is actually relevant.\n. :tophat: \n. Note for the future: this doesn't work at all. Duration is set in MSE on the MediaSource, not the SourceBuffer, and requires all attached source buffers to be in an updatable state. That might mean we need an abstraction that manages updates all the way up at the MediaSource level but that seems complicated so I've skipped it so far.\n. I intentionally made this function explicit in the inputs it accepts, instead of relying on state stored on this (maybe I should have put it on the module object instead of making it instance level), so that we could easily unit test it. Hopefully this will make tracking down stream-sync issues easier to debug.\n. This is a bit confusing. Did you forget to bump the package.json in the last release?\n. Another flag, eh?\n. If the media source duration isn't NaN, should we ever be returning Playlist.duration()?\n. I don't think this works. Elsewhere in this file we're comparing lastSegmentLoaded to a URL which will always fail after this change.\n. @KatrinaE: actually, I do think checking the URI and byterange seems like the right move here (I'd really like to get rid of lastSegmentLoaded_ entirely but I'm not sure how to yet). If you have bandwidth, we'd love a helping hand to get this merged. If you could switch this to the URI and byterange check instead of the object equality one, I think we're good to go.\n. I think we're kind of inconsistent with this if. We guard the second clause with an else if even though we short-circuit the loop if the first clause is hit. Then in the third clause, we don't guard with an else, even though the second clause now short-circuits if it's run.\n. Space between if and (.\n. This is too early to fire loadedmetada. It's supposed to fire when we've successfully received the first media playlist. This fires right before we make the second request.\n. I know this is a bit out of date but why delete everything?\n. This additional license information is important, it cannot be deleted.\n. HLS is not a tech, it is a source handler.\n. It looks like this whole file is out of date. I think that means we need a rebase on this PR.\n. Out of date.\n. This is the file that actually needs the license notice from SJCL\n. This file doesn't actually contain any of the code referenced in this notice.\n. Personally, I think breaking out single functions that aren't used outside a particular module is overkill and makes things harder to track down.\n. Indent is off here\n. Why use typeof checks to find undefined?\n. These objects don't make sense as plugins to me. Plugins are intended for player-level customizations. MediaSource and URL don't affect individual player operation.\n. hipchat and irc notices should not be removed.\n. Is this page functional?\n. Stub comment.\n. contrib-hls isn't a plugin, so this entire file should be removed.\n. contrib-hls is not a plugin so this shouldn't be the main file.\n. Should this be committed? Previously this was generated as part of the build process.\n. Do these imports still work?\n. Can we just combine all of these individual browser modules into a single file? They're only eight lines apiece.\n. Just curious, why did this move?\n. I don't think running one specific browser at a time means we need separate files for each of the configs but that sounds like it's a generator problem, not an issue with this patch.\n. I didn't even notice that! :) I was actually asking why the <script> elements moved from the top of the file to the bottom.\n. It would be wise to at least emit warnings in these cases.\n. This is a class-level comment on the ParseStream object. Seems misplaced.\n. We should collapse this into the outer if. Not vital for this PR.\n. Class comment is missing.\n. Very nipticky but we don't line break after parens elsewhere in this project.\n. Seems worth consolidating constructor and init while we're in here.\n. I do wish this file name was more descriptive. Are you against videojs-hls.js for the project entry point?\n. This mix of src and dist dependencies is surprising to me. Is that because this is only one step of the migration?\n. We should file an issue for this.\n. Why not use module-level variables for these items? Technically the scope could leak across QUnit modules but it saves a ton of thiss.\n. Parens-line-breaks\n. Same naming question with this file. What about test-manifests.js?\n. Stream is an internal prototype. I think it's fine to consolidate.\n. Ok, makes sense.\n. Yeah, that makes sense. It's not where we want to be though, so it would be good to at least keep track of it.\n. Filed it: https://github.com/videojs/videojs-contrib-hls/issues/538\n. Ah, ok.\n. This notice should be at the top of the file.\n. I think you'll be re-pre-computing for every AES instance by moving this into the constructor.\n. Erm... or we were also re-computing in the old version. Still, I think this step can be done once and then re-used by each of the instances.\n. ...and now I see that we mutate the sub-arrays. precompute() still seems idempotent but maybe not worth the effort. Thoughts?\n. linebreak on parens\n. linebreak on parens\n. linebreak on parens\n. linebreak on parens (sorry!)\n. Just noticing the Decrypter never invoked the Stream constructor. Seems like that inheritance is unnecessary.\n. Should this be capitalized to indicate it's a constant?\n. I would guess it's ok to define the constant value here instead of using the intermediate constant. Did that not work?\n. linebreak on parens\n. linebreak parens\n. The deep copy might be kind of a pain but if you can find an easy way to do it, sweet.\n. We normally use _ to indicate a method or field is private. Is there a reason for the prefix here?\n. Fancy :) Does this actually save us anything over recomputing on each construction?\n. DECRYPTER_STEP. Also, can this just be declared and defined as Decrypter.STEP?\n. Sorry to do this... local variables don't need to be prefixed with _\n. This file needs a comment describing its contents.\n. > of 0 making its duration\n. Subjective: I think it's better to split this kind of thing into a non-side-effecting function that determines whether endOfStream() should be called and perform the side-effect at the call site. It's easier to test if that's necessary and (hopefully) keeps the side effects clear and close together.\n. I'm kind of shocked we weren't doing this already...\n. Needs a file-level comment.\n. Given the check on line 1213/1298, why is this necessary?\n. linebreak on parens\n. All of these fields should be suffixed with _ to indicate they're private.\n. Yay!\n. Looks like there are a couple refactorings going on simultaneously in this class. Can this be split up into something like:\n1. es6 stuff\n2. (optional) reorder stuff\n. All looks good in this file.\n. An upcoming PR will remove the implementation of this function elsewhere?\n. linebreak on parens\n. linebreak on parens\n. linebreak on parens\n. linebreak on parens\n. linebreak on parens\n. I'm still a little hesitant about overwriting duration during playback but let's see how it goes.\n. Seems kind of weird that this function is checking this.mediaSource, given it's totally stateless outside this expression.\n. This file looks good now.\n. > 'MediaSource is a function'\n. I don't think we should be looking at this.mediaSource.mediaSource_ in this project at all (which I know the next line is violating). Can this be fixed in contrib-mse?\n. This looks copy-pasted from the main test file (and it looks like we didn't get rid of it back there).\n. This appears to be unused.\n. It might be more appropriate for this prototype to extend videojs.EventTarget.\n. With this many constructor arguments, it's probably time to switch over to options-object style.\n. We should be switching to using import for this.\n. One goal that I have for this refactor is to reduce bi-directional dependencies. Passing the HlsHandler along here seems very close to the dependency between techs and the player object that we just untangled with great effort in video.js 5. This isn't any worse than the status quo but we should think long and hard about how to avoid two complex objects that mutually and directly invoke one another. It seems possible to reformulate a lot of the interaction with HlsHandler as it driving MasterPlaylistController, and allow communication back to happen through events.\n. I think it would be cool if we could encapsulate PlaylistLoader creation in MasterPlaylistController. What about taking a playlist object or an index instead?\n. Many of the calls to hlsHandler in this method could be converted to queries against playlists or playlist loaders. !this.mainPlaylistLoader_.media().endList is equivalent to this comparison, for instance.\n. The name of this method might be confusing. You wouldn't want to pause the segment loaders if the player is paused.\n. The MasterPlaylistController will need to take all active loaders into account for this to work correctly.\n. In putting the segment loader together, I came to the conclusion that we're doing this totally wrong :) I think we should set the duration when the first media playlist loads and then let media sources manage it from that point out. As it stands, I think we may be invoking the coded frame removal algorithm unnecessarily.\n. canplay indicates media data is available in the buffer. That should never happen until we begin buffering and we don't begin buffering live streams until you hit play. Seems like this condition shouldn't be hit.\n. Were these moved or is it just the diff?\n. Oh wow. I haven't been looking at es6 enough yet. Nevermind!\n. I'd want to keep the existing overrides around. I think your proposal for passing selectPlaylist() down and keeping it updated sounds like a good one.\n. I think so but let me try restating it just to verify we're on the same page. I was thinking the MPC would listen for refreshes and signal them to the segment loaders. When it's instructed to load alternate audio, it would start up an alt audio playlist loader and activate the appropriate segment loader once the alt audio playlist was ready. \nSince the MPC handles the entire playlist loader lifecycle, it doesn't have to expose them to hls/the media element adapter. HLS could signal the MPC to begin loading alternate audio by name or URI:\njs\n// by name:\nmpc.useAudio('Espanol');\n// by index:\nmpc.useAudio(2);\n. I think we'd need to do the intersection-- if one playlist is missing content we'd stall by seeking there.\n. It's legal to add variants to a live stream while it's in progress which is one way this scenario could show up. If you're running a 24/7 news channel, you might decide to add a 4k variant to your stream while it's running and there would be less video available for that variant while it filled out the live window.\n. The tech is a required argument for new AudioTracks?\n. This project doesn't support IE8 so as long as this doesn't fail at parse-time, it's ok to skip IE8 compatibility stuff.\n. No action necessary but when the branches of conditionals get this big I tend to favor short-circuit returns so you don't have to remember what block you're in for so long while reading.\n. No objection to this change but was there a particular reason for it?\n. This assertion still seems valid. Why remove it?\n. Another non-critical comment: you can use deepEqual to cut down on the amount of typing you need to do for these sorts of tests.\n. +1 for \"default\"\n. webworkify only runs agains mux.js so that shouldn't cause problems here.\n. Ohhh... no idea. Would be fun to find out :)\n. It's not clear to me why it should be. If the tech owns the audioTracks and the audioTracks is called to add a track, it seems like the audio tracks could pass along the tech instead of requiring it from the caller.\n. For later: we will need to resolve these URIs\n. Log a warning of some sort here\n. I think it's worth considering making this an object so that you can index into them by URI below.\n. I would rather we adopt the convention that loaders always start paused (a la segment loader) and provide a mechanism to begin loading explicitly. Having the two loader types share a basic lifecycle sounds like a nice simplification to me.\n. Similar to my comment above, what do you think about calling this load() to align with segment loader?\n. Looks like the changes below are to remove the master-playlist fetching capabilities of this object and are not quite finished. Is that correct?\n. seekable() is a media-element thing, so it seems like it should be calculated by hls.js\n. Where will this be used? Why do we need a separate variable for it?\n. Does this mean the old options location will be ignored?\n. I thought this was actually a general IE11 issue. No?\n. This code would never be run in IE8.\n. Why add the default value?\n. I would be inclined to mark it as unusable somehow, rather than removing it. I think it would be clearer in a hypothetical UI to mark an audio track as \"bad\" than having it just disappear.\n. This method name is very confusing. blacklistCurrentPlaylist() optionally takes a non-current playlist to blacklist? Ugh.\n. I think that only occurs if it's in the parse-time execution path (but it's definitely worth checking).\n. I was thinking add a property like error_ to the audio track and then revert any attempts to switch to that track in the future. That might fall into the \"hacky\" category for you :) The advantage (IMO) is API consumers can introspect on the audio tracks and discover something is wrong more easily. It would probably take some thinking to figure out why an audio track disappeared if you weren't familiar with our code and the complexity of the problem.\n. The underscore means \"don't use outside this project\" to me. I feel like this is a handy debugging capability but I don't think we advertise it as a first-class part of the API (today).\n. Yeah. I experimented with a ton of ways to avoid the infinite event dispatch loop between the player and tech. A number of them technically did the job but they felt grafted-in or added significant capabilities to video.js that I didn't think were warranted. I'm not a huge fan of touching globals but this seems safe & correct to me.\n. I debated using the segment loader's bandwidth info and the bitrate of the newly selected bitrate to calculate a safe removal range. Seems like it might be a good idea but I thought it could wait for a separate PR. Seem reasonable?\nProxying remove() calls from the segment loader to the source updater increases encapsulation but I don't think it was worthwhile given all the actors are in the same project in this case.\n. I'll do that.\n. Given you know all the trackProps ahead of time, you probably should use a static defineProperties() call to do this instead of creating properties in a for-loop (and that gets rid of the eslint issue).\n. Also, why do these need custom properties?\n. I'm not 100% consistent about this myself but I think it's better to null the field out instead of using delete.\n. > called too early or no track is enabled\n. This comment is a bit hard for me to parse.\n. This property seems like the sort of thing that is project-internal to me. Could we get away with just using this.audioTracks_ directly?\n. Why not just run the revert() action inline in your conditional?\n. Should these two be public? If so, they need docs. If not, they need _s.\n. That's true but do you need the key to be removed from the object?\n. It might be a good thing to throw a helpful error in that case. It seems to me this would only occur because of programmer misconfiguration and normally it's good to point that out during development.\n. Looking over this, the order seems wrong. Object-level options should trump page-level and this looks like it does the opposite. Could that be what's making the code below hard?\n. videojs.options.hls may not be defined.\n. I think we should try to avoid registering the HlsSourceHandler if the mode setting prevents it from being useful.\n. Not sure why these need to be deleted. Doesn't seem right to me.\n. This is a very (too) specific spoof. Why is avc1.77.30 unique in triggering this? Also, this kind of browser/MSE compatibility issue should probably be fixed in videojs-contrib-media-sources.\n. Not really. I was using it as a separator for \"dependencies that need to be removed\" :)\n. I can understand that feeling. I was thinking the MPC is a \"project private\" sort of thing so it didn't need its own set of configuration options.\n. Good catch!\n. > This would restrict when the mode can be overridden.\nI don't understand what \"this\" is. My point was you may be dereferencing undefined in this line.\n. I understand your point about consistency but I think it's more important to use the least-powerful tool that gets the job done. Custom properties imply extra functionality to anyone debugging and that would be misleading in this case.\n. audioinfo will fire when there is no change in the audio settings? Seems like this could be managed at a lower level and remove the need for this objectChanged()\n. What's the point of this method over accessing the property?\n. @gkatsev it seems like the SourceHandler options should be passed to this method as well. As it stands, we can't figure out a way to force HLS to use Flash (or MSE) at the player level. Instead we have to use the kind of ugly global method you can see below.\n. Why is this a getter?\n. > controller controller\nNot a blocker.\n. Should we verify this in a test?\n. progress in this file was written in the spirit of the HTML5 progress event, which is supposed to fire every ~350ms when media data is being loaded. I think it's fair to count segment loads against an old rendition as progress based on that.\n. We should definitely add tests that verify the error is triggered and loading paused when this condition is reached.\n. Seems like this should have been caught in a test. Sorry to be a broken record in this PR but... mind adding one?\n. Our standard pattern in video.js has been to fire \"simple events\" when interesting state changes and provide accessors to query state. For consistency, I think we should continue to follow that pattern here.\n. We could also look at how MSE exposed video quality for inspiration on how to expose this info in a way that fits with the rest of the platform.\n. Use test-helpers, do not copy-paste this setup code from elsewhere.\n. This function was intended to be non-side-effecting. Is there a way to reorganize the responsibilities here so that the time correction can be performed in one of the explicitly side-effecting portions of the code?\n. Thought: would it be clearer if we made checkBuffer_() a utility function instead of a method?\n. This is crazy.\n. Naming nitpick (sorry!): video.js doesn't typically use the get prefix for getters. That is, s/getMediaRequests/mediaRequests/g.\n. When we've defaulted m3u8 attributes elsewhere, we've done it in the parser and emitted an info event\n. This comment needs to be updated to account for the new parameter.\n. We shouldn't be apply Flash-specific fixes in this project. Can we move this into the Flash tech or media sources?\n. I spoke too soon, ignore that comment.\n. I've been trying to keep this free of this references so the state it depends on is explicit in the parameters. Is it possible to move this out to the caller or add additional info to the calling arguments?\n. The new param should be added to the doc comment.\n. It's a little weird that the loader is not paused but not fetching segments. I understand we don't want to trigger blacklisting in this particular case but maybe we should trigger a non-error event and pause the loader?\n. Thought: should we move this utility into the Ranges module? It doesn't have any loader dependency and might keep us from accidentally tying the two together in the future. (Not a blocker for this PR or anything)\n. Great tests.\n. The tech is a big ball of shared state so I wish we could minimize the parts of the system that touch it.\n. That sounds like a good idea.\n. Interesting. Something to keep thinking on.\n. Bandwidth is Infinity?\n. This member variable is never used. In general, we should be try to minimize dependencies on the player and techs. They're both really complex, stateful objects and they're shared among many different actors. Definitely don't store it if you're not going to use it.\n. Won't this output <gap-skipper> <initialize>? Are you planning on feeding your log statements to an XML parser? :)\n. It seems like you could get away with using only the tech and skipping the player reference here. Given this is going to be used by the Source Handler, it seems like only referencing the tech would be preferable.\n. I don't think waiting is actually the event we're looking for here. My reading of the spec says waiting is reserved for scenarios where the user or user agent has triggered a condition that requires buffering before playback but there's no evidence that buffering won't be 100% successful. For instance, seeking out of buffer would trigger waiting because it's an intentional decision to move into a state that requires buffering. \nstalled indicates that buffering is being attempted but no progress is being made. This sounds closer to the scenario we're dealing with (\"I'm trying to buffer but failing!\") but still not right.\nA related issue was recently filed against the media sources spec. If the application developer (us) is doing the content fetching, are progress, waiting, and stalled events well-defined? I lean towards \"no\" which makes me think we shouldn't overload an existing event for this functionality. All this is an extraordinarily long-winded way of saying, I think we should make our own event, possibly trigger it in response to waiting and stalled, and use that new event for gap skips.\n. This could be a const and moved out of the constructor.\n. Why are all the other handlers declared inline in the constructor except for this one?\n. This sounds like playerId is a required parameter. You should throw an error instead of returning a broken object in this case.\n. s/pkayer/player/\n. You can rely on javascript's implicit boolean conversions to avoid the ternary:\njs\nelement.excludeUntil <= Date.now() || !element.excludeUntil\nSince your second expression is a pre-requisite of the first, I'd swap the order:\njs\n!element.excludeUntil || element.excludeUntil <= Date.now()\nThe || operator will short-circuit and skip the date comparison which is nice (but not important), too.\n. This is very similar to enabledPlaylists(). Why not reuse that here?\n. I'd err towards markings methods private unless you have a good use-case for adding them to our public API. We indicate private methods in video.js projects by appending an underscore to the method name. You could also convert this into a function by taking the master playlist as the first argument and then just skip exporting it.\n. You could set the initial bandwidth estimate to something really low to cause the loader to actually select the lowest rendition and skip this mocking.\n. Good comment.\n. This seems duplicative of the tests below. Is the intent to short-circuit the rest of this function when there is no possibility of a video gap? Is this code performance sensitive enough to warrant that?\n. This seems worth a comment about why seeking to currentTime resolves this issue.\n. \"with gaps\" is not very precise.\n. We don't normally newline on (\n. @imbcmdth how do you feel about this style? If I'm the only one that has trouble parsing it, I'll retrain my brain.\n. Good catch! I just moved this but it's worth fixing.\n. Oops...\n. Added it.\n. I was actually just fixing punctuation here. I'll add a \"known issue\" about Edge support.\n. I can't wait to delete these suckers.\n. We should probably make this property private so we can remove it once FF 48 falls out of support.\n. Maybe we should rename this to something like checkCurrentTime now that we're no longer using timeupdate?\n. I think we should replace this test with an equivalent test that the default and overrides work with the new option.\n. I think this name is really funny but folks who are not familiar with the project may be confused. How unhappy would you be about a more conventional and descriptive name?\n. When would this occur?\n. Since seekable.start(0) will always be zero for VOD, I don't think you need to worry about whether the playlist is live or not which would eliminate the need to pass in playlist here.\n. Design comment: I like the practice of splitting side-effecting operations from pure ones, all other things being equal. Instead of writing a function that checks-and-seeks-if necessary, you could write a check function and a seek-to-live function.\n. It seems like this method name and jsdoc may be out of date.\n. These tests would probably be less complicated if you split the side effects of the check out of the check itself.\n. ?\n. Alternative: put getSource in the default options.\n. Amazing tests!\n. jsdoc comment?. Why export this if it's only used in this module?. True. I didn't want to have to update this with every release. I hope it doesn't end up being an issue but we'll see. . It might be more useful to just merge these properties onto the created cue object. . ",
    "paytonrules": "Couldn't you stop trying to reload the hls file if the playlist is a VOD and not an EVENT? Since VOD streams are not allowed to be updated anyway.\n. Yup I did.  Thanks\n. Any idea what the time frame is on that? I'm not sure if I should wait for the fix or try to come up with a work around.\n. Please forgive my ignorance - what's the difference between a tech and a\nplugin?  Do they install the same way?\nOn Tue, May 20, 2014 at 6:46 PM, Gary Katsevman notifications@github.comwrote:\n\nThe tech is available for playing around in PR #62https://github.com/videojs/videojs-contrib-hls/pull/62.\nFeel free to try it out and let us know if the canplay event fires then.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/videojs/videojs-contrib-hls/issues/61#issuecomment-43697353\n.\n. I haven't gotten a chance to work with this yet - but I noticed pull request #62 is merged to master. Just to be sure - can I try the current master and make the changes that dmlap mentions?\n. I have tried version 0.7.0 and still do not see a canplay event, at least on Chrome.\n\nWhen I use the developer tools to start the video it stutters and fails, again on Chrome. \n. I'm getting some deadline pressure from a client.  Is there a way I can help via a test case or .. [ insert thing here ]\n. Is the problem potentially here: \nhttps://github.com/videojs/video-js-swf/blob/8a989103788b23fd59a847b0389bb261c80aeec1/src/com/videojs/providers/HTTPVideoProvider.as#L526-528\nIt looks like CAN_PLAY is not being fired until the buffer is full.  On an HLS Stream - particularly the EVENT/LIVE streams that we are using the buffer is never truly full because you don't download the entire thing.\n. I'd love to - except I haven't written so much as \"hello world\" in ActionScript.\n. It looks like I had operator error.\nI was listening for the :canplay event via  (psuedocode warning) $(\"video\").on(\"canplay\", function() {blah})\nLooking at it I realized that OF COURSE it doesn't work in Chrome since the video element goes away.  Sure enough I'm getting the canplay event when I use videojs.on.\n. ",
    "gkatsev": "LGTM\n. If we are going to do more setTimeout stuff, we should consider pulling in sinon's fake timers.\n. lgtm\n. I assume this is superceded by #30?\n. LGTM.\n. This is fixed. The regex we are using is now case-insensitive: https://github.com/videojs/videojs-contrib-hls/blob/master/src/videojs-hls.js#L474\n. Looking at a cookie solution next.\n. Yes. We should see if we can further modulerize this.\nAnd yes, we probably shouldn't have vendor specific code in the main codebase.\n. LGTM\n. I'm not sure why this change was made to the hipchat notifications? Was the previous value set up against brightcove/videojs-contrib-hls?\n. How do you choose whether to run on local browsers vs saucelabs?\nIs it just grunt karma:chrome karma:firefox etc?\n. @BCjwhisenant no, there isn't. However, we can and should copy jquery's build system that does exactly that. Or rather, their custom task that does this.\n. Not anymore. However, I think the access-token for the videojs saucelabs was commited at one point unencrypted. So, we might want to generate a new access-token and put the newly encrypted value in here instead.\n. Updated tests to use sinon's fake xhr. They pass now.\n. Updated based on code review comments and moved sinon to be a dev dependency rather than a regular dependency. Also, merged in the feature/live-um branch so that the PR will have a nice big green button.\n. Reopening up this PR against master now that live-um has been merged.\n. New PR is #35 \n. The build is currently failing because the new test that was added isn't using sinon's fakeXHR but rather the previous overriding of the XHR constructor. I'll update later.\n. Just merged master in here.\n. HLS has been converted into a videojs tech, so, different video formats should work better.\nI'm not sure it will solve the issue of trying a different source if HLS is not available because of CORS issues.\n. @dmlap will this mend your :broken_heart: ?\n. @dmlap want to load a non-graffle file version of the diagram?\n. Looks good, though, I'm unsure about the way that errors are being thrown. Is anything catching these errors currently? Are the conditions where we throw the errors really that exceptional that we should throw? I think might be better to just trigger error events for these cases instead.\n. :package: \n. I want to make grunt test run either saucelabs karma or local karma depending on whether we are on travis or not, so that we don't need to have two grunt tasks.\nAlso, I want to make a grunt task that allows you to specify multiple browsers in the task, so you could do: grunt karma:chrome,firefox instead of grunt karma:chrome karma:firefox.\nBut these shouldn't necessarily hold up this PR.\n. Updated karma to run in latest chrome and latest ipad/mobile safari on saucelabs.\n. Yes, right now you need to run it via grunt test-local or grunt test-local karma:dev or grunt test-local karma:chrome.\nI'm working on making it know when we are running in travis, so, npm test will work on both. We probably should've named it test-saucelabs and test in hindsight. \nThough, I guess we can change the names.\n. The build is failing because travis isn't exporting the saucelabs credentials for some reason.\n. It's failing because travis isn't exporting secure credentials for PRs from forks: http://docs.travis-ci.com/user/pull-requests/#Security-Restrictions-when-testing-Pull-Requests\n. Merged in via bc2d1c4d299b4800e387e3734d411137bfd41024\n. Seems to just require us to call player.error() with the error. It will make the error value accessible to consumers of the error event and trigger an error event for us.\n. Fixed by #76.\n. LGTM.\nJust wanted to note that this depends on the new error handling of vjs that was added in videojs/video.js#1197\n. This should no longer be needed once the HLS Tech (#62) PR gets merged in.\n. This probably has to do with the fact that this plugin just sits on top of videojs right now and comes into play if videojs isn't able to play the hls stream another way.\nWe're working on making it into a videojs \"tech\", which should fix this problem and others.\n. Hopefully, some time this week.\n. The tech is available for playing around in PR #62. Feel free to try it out and let us know if the canplay event fires then.\n. A tech is a different way of doing things behind the scenes. It's a way to abstract out the flash fallback from the videojs api.\nUsage is the same, you just include all the javascript files like you did for when it was a plugin.\n. Cool! Glad you were able to figure it out. Please open up more issues if you find other problems.\n. I am not sure what this would fix.\nHowever, take a look at #66, I think whatever was broken was fixed there.\n. Oh, I see.\nHm... I'm not sure that it's necessarily a bad thing for the tests to fail when the goalBufferLength changes.\n. This is because of the new videojs errors work release in 4.6.x. Once we release the re-architecture of the plugin into a tech (#62) it will go away.\n. Looks like I totally misread the original issue.\nAndroid and iOS browsers use the native HLS implementation for HLS playback, since plugin does nothing.\nCan you provide more information on how you are setting up your player?\n. We'll look into this once we get the hls-tech (#62) work merged in.\n. We are looking into it. It is most likely a video-js-swf issue.\n. This should be fixed in in #66.\n. @mkilling you need videojs/video-js-swf#93 as well\n. @mkilling so it was. I forgot. Hm... it was definitely working for us yesterday...\nIs it giving you any errors? Also, are you loading it properly as a tech now?\n. Is it playing otherwise?\n. Hm... I guess we didn't fix this it fully. Thanks for reporting.\n. @mkilling No worries. So, it works as expected now?\n. Awesome, thanks for verifying!\n. It will get merged in this week. Hopefully, released this week as well.\n. Updates have been released. Closing now as it should be fixed, but feel free to reopen and comment if there are still problems.\n. The tech conversion has already been merged.\n. We'd need to change the \"plugin\" options to describe how you can give the option to the tech but this is a good start.\n. I think keeping it extending vjs.Flash for now is alright and once we're ready to make an html5 MSE HLS, we should probably just make it extend the MediaTechController directly and then have a Flash or Html tech inside of it depending on whether we're supporting native MSE or MSE via the flash fallback.\n. Yeah, I think that might be the way to go to so that we won't need to make two HLS techs.\n. The downside would be that you'd need to maintain two techs and that you won't be able to switch between the two quite as easily. If there are two techs, you'd need to declare both techs in the tech ordering rather than just having one tech:\njs\ntechs: ['html5', 'hls-mse', 'hls-flash', 'flash'],\n//vs\ntechs: ['html5', 'hls', 'flash']\n. Don't really have a usecase for switching between them at run-time. More along the lines of switching between the two upon initialization when needed without needing to duplicate the tech.\n. @dmlap what about DASH? Would MSE be incharge of deciding whether we're transmuxing to DASH/mp4/flv? Otherwise, I like this direction as well. \nPerhaps we should have a separate module that is in charge of transmuxing and MSE is strictly into creating a cross-browser API for MSE.\n. If you set the url to the swf:\njs\nvideojs(\"video_player\", {\n  playbackRates: [1, 1.5, 2, 3], \n  techOrder: ['hls', 'html5', 'flash'],\n  flash: {\n    swf: 'http://example.com/video-js.swf'\n  }\n});\ndoes it work?\n. Looks good to me. Would be nice if there was a test that tested the setting directly as well. I.e., if goalBufferLength is set to 20, things work slightly differently than if it is set back to 5.\n. You can set it directly on the tech:\njs\nvideojs.Hls.GOAL_BUFFER_LENGTH = 30;\n. This fixes #58.\nAlso, LGTM.\n. Do we want the HLS tech to play back Flash things as well or only HLS?\n. LGTM.\n. node_modules will get populated after you run npm install.\n. We probably should have some better instructions about what to do when you clone this repo, if you want to work on it.\n. Cool.\nI guess we now need to figure out how to minimize those extra single dots on the higher/lower bandwidth with the quick spike tests.\n. \"watch time\" is actually a pretty good metric for videos in general. A lot of analytics systems focus on that as well, perhaps under different names like \"engagement\".\nWhile knowing the \"watch time\" and optimizing for it is good, we need other info to know what things are different or how well the algorithm is working so we know why \"watch time\" for video A is higher than for video A'.\n. Don't know what other info we need. I guess an example could be info that tells us whether our ABR algorithm is working correctly or not.\n. @dmlap yeah, it was just an example and definitely not an easy thing to figure out.\nJust meant that I dont think tracking just \"watch time\" would actually help us that much if we don't know what is going on that is making \"watch time\" increase.\nI guess that is also a more concise way of saying what I was thinking.\n. LGTM\n. LGTM\n. Yes, we haven't implemented seeking for live events yet as it is significantly more difficult than regular VOD HLS streams.\n. Closing this in favor of a rebased version (#177).\n. And that one has been merged in. Thanks @gutworth!\n. Well, that was quick, since 4.7.0 was just released, but thanks. Though, it's weird because I don't think the swf was updated during 4.7.0\n. I believe video-js-swf 4.4.2 is from videojs 4.6.4: https://github.com/videojs/video.js/pull/1343/files#diff-b9cfc7f2cdf78a7f4b91a753d10865a2R24 and https://github.com/videojs/video.js/blob/master/CHANGELOG.md#464-2014-07-11\n. Cool, thanks. Either way, needs to be fixed.\nAlso, can you please describe in some more detail what you are seeing specifically? How is it broken?\n. We're working on another way of doing midsegment (and possibly pre-play) switching in #174.\n. > Should the resolution matter if you only have two choices? Shouldn't we always go for the better bandwidth?\nIf you are showing the player in a small window, it isn't really that useful to grab the bigger resolution/bandwidth because the user won't see it.\nMoreover, it means that we are making the user use more bandwidth and a lot of users, especially on mobile (where resolution is on the small side still), so, we shouldn't just assume that highest bandwidth available is the best.\n. LGTM.\n. LGTM.\n. LGTM.\n. Looking into getting this pulled in.\n. This will get merged in via #156.\n. Thank you.\n. I believe this will be fixed in the mid-segment switching implementation ( #174 ) . Stay tuned.\n. html5 tech mutes the video but the controls don't update. Flash tech doesn't mute the video: http://jsbin.com/hiyemiwaci\n. @orcaman I think this is taken care off #156, can you double check? thanks!\n. I'm going to close this for now. Please reopen/let us know if it isn't yet fixed in master.\n. We're using sinon's fakeXMLHttpRequest, you can check the other tests to see how we're using it.\n. Much better. Thanks.\n. LGTM. Any other thoughts @dmlap?\n. Awesome, thanks!\n. You should be able to just always use player.currentTime(offset) rather than calling HLS's setCurrentTime method. In fact, that is the recommended approach.\n. Yes, not sure about the issue, unfortunately.\n. I think I'm currently investigating a similar issue. I believe part of the issue is caused by the segmentXhr not getting nulled out properly, though, I think there's another issue with the netstream taking several seconds to properly display the video after a seek.\n. @jtennen cool, let us know if you have more issues or find more info around this one.\n. Looks good. Can you add a test to check for the presence of the responseText in the errors?\n. Cool, thanks.\n. Merged in via #166 (also, amusing that this is 155 and the new PR is 166).\n. Do you mean videojs 4.8.3?\n. Thanks. I can confirm that it is broken. Thanks for reporting it.\n. I have a fix outstanding againt the swf: https://github.com/videojs/video-js-swf/pull/121, hopefully, we'll get it out soon in a new patch release.\n. Fixed in videojs 4.8.5.\n. canPlaySource will always tell you whether a source is supported or not. videojs has isSupported convention for checking whether a particular tech is supported or not.\n. At first, I would've been inclined to say that we don't want to trigger timeupdate while the video is paused but reading the spec, seems like timeupdate should also be called when currentTime changed in an interesting way, like during a discontinuity, so, we definitely need to fix that.\nGiven that videojs already has the manual time updates because this is currently using the flash tech, I'd be inclined to not way another setInterval. Instead, we probably do want to just trigger the timeupdate right after setting currentTime in the disconinuity but make sure that fillBuffer and drainBuffer don't react to our own timeupdates.\n. I have no thoughts as of yet. Maybe set a flag that fillBuffer and drainBuffer check, though, flags are not great. Maybe remove the handler, trigger the event and reattach the handler.\n@dmlap any thoughts?\n. I may have misread the original post but having a timer for fillBuffer/drainBuffer sounds ok to me. I just don't think this tech needs to handle manual timeupdates itself.\n. You need to use application/vnd.apple.mpegurl or application/x-mpeglurl for m3u8 files. You cannot have an m3u8 with a type of video/webm or video/mp4.\nIn addition, the endpoint needs to have CORS headers configured or else this wont work.\n. LGTM\n. I wanted to point out that this project and the flashhls project are separate. Flashhls does all the HLS work in flash, whereas this project grabs the HLS data in javascript and shuttles it across (to the standard videojs swf) via vjs-contrib-media-sources.\n. The example page in this repo is set up correctly. However, you still need to take the hosting considerations into account. It won't work unless CORS headers are set up correctly.\n. Probably shouldn't be merged in quite yet.\n. It's possible that we don't need to override the currentTime function in HLS. We definitely need to override the setCurrentTime function.\nAlso, you accidentally linked to currentTime for HLS and setCurrentTime for flash.\n. Listening to seeking may work.\n. Do you have an example of the manifest? Does the #EXTINF contain the correct length for that segment?\nI guess the issue is that we do segment.duration || playlist.targetDuration. So, we should probably make sure that segment.duration isn't 0.\nDo you know why zero-length segments are used?\n. Yeah, that was basically my proposed fix.\nWant to submit a PR for this?\n. ### TODO\n- [ ] HLSe\n- [ ] Make sure discontinuity works\n  - [x] especially when discontinuity is in the middle of a tag slice\n- [ ] identify the specific cases for midsegment switching and only do so then\n  - don't mid-segment switch if we have more than one segment's worth of buffer\n- [x] make sure not to midsegment switch down\n- [ ] more tests for tagBuffer\n- [x] tests for midsegment switching\n- [ ] drain buffer drains the buffer too quickly\n- [ ] fix 'buffered' calculation\n  - swf buffer\n  - js buffer\n. This is related to #170.\nBut I agree with @seniorflexdeveloper, we don't actually seek in flash other than setting a currentTime on flash so flash knows where we are now playing.\n. @seniorflexdeveloper that will not be an option with the tagbuffer work since the flash buffer will be barely 2 seconds long.\n. This doesn't currently check whether the first downloaded playlist (first rendition in master) is the item we want to download if the user clicks play too soon or if we can/should download the the first segment from the playlist we were just switching to.\n. Trigger a progress event whenever we download a new segment would match the spec, but I'm not sure that is exactly what we want here. We want to know exactly when the bandwidth change happened, which currently happens in two places:\n- when a segment finishes downloading\n- in loadedmetadata\nA progress event seems to be fired whenever new media data is being fetched, e.g., when we are starting to download a new segment or downloading a new playlist, assuming playlists count as 'media data'.\n. @dmlap switched to use setBandwidth\n. Merged in via c54a20335133a2d8a1eef2cde80e04d77376c3df\n. @TylerGarlick can you provide more information? Even better if you can provide a working example on jsbin or jsfiddle. Thanks.\n. I've updated the example to include the extra necessary files and I don't see the error in the first comment.\nhttp://jsbin.com/jasujijazu\n. Also, can you do a git rebase against master? Let me know if you need help with that.\n. Merged in via 3a3037d02e0bb9e37d03f2a8451fcb8a6b138d7b\n. The license is Apache 2. The file header is wrong. See the license file in the repo: https://github.com/videojs/videojs-contrib-hls/blob/master/LICENSE\n. Given that we're shipping this project as a whole, the main license is the one that matters. It's mostly pointless to just use the videojs-hls.js file by itself. However, yes, we definitely should fix that.\n. Looks like there's a test error now https://travis-ci.org/videojs/videojs-contrib-hls/builds/47580832\nThe issue is that on travis we run phantomjs whereas locally, we use karma to run it in chrome.\n. No need to post any more +1, please use the new github reaction feature to show your support instead.\n. Are you trying to play back an RTMP stream? If so, you should open an issue against the main videojs repo as this plugin is strictly for HLS.\n. If you think it's good for review, go ahead an open a PR :)\n. You can see the test output on travis: https://travis-ci.org/videojs/videojs-contrib-hls/builds/50511160#L339\nYou can run the tests by simply running npm test inside the project.\nAlso, check out the CONTRIBUTING.md which has more info.\n. You need to install grunt-cli locally. See https://github.com/videojs/videojs-contrib-hls/blob/master/CONTRIBUTING.md#modifying-the-code\n. Seems like there an issue on line 24 of the segment-parser.js:\nsh\n    TypeError: undefined is not a function\n        at new videojs.Hls.SegmentParser (/home/rdg/projects/videojs-contrib-hls/src/segment-parser.js:24:19)\nAlso, you can open the test/videojs-hls.html file in a browser and use the debugger to pause on exceptions.\n. You'd need to add it to both the videojs-hls.html and the karma.conf.js files in the appropriate place.\n. Thanks! We'll get it reviewed when we get the change.\nAny chance you could add some tests that test this new functionality? That would be awesome and help this get merged in quicker.\n. LGTM\n. Does this actually fix #160? I don't see any new triggering of timeupdate.\n. It definitely makes it possible for us to fire timeupdates now and not worry about infinite loops.\n. Assuming the flash tech won't break if we fire a timeupdate from it on seek that's fine, though, we still would need to fire a timeupdate at a discontinuity in this project.\n. Do we want a test for checking that startCheckingBuffer_ is called on init and stopCheckingBuffer_ is called on dispose?\n. That should check that waiting is removed but nothing is verifying that the timeout has been cleared.\nOtherwise, LGTM.\n. (Also, make sure that #160 stays open when this gets merged in)\n. LGTM.\n. I believe it's a bug with npm. We probably want to update our travis config to use a newer version of npm as well as using newer versions of node/iojs.\n. A workaround is to change the \"before_script\" property in .travis.yml to be install and append npm install to it.\nyaml\nbefore_script:\n- npm install -g grunt-cli\nshould turn into:\nyaml\ninstall:\n- npm install -g grunt-cli && npm install\nSee my changes here: https://github.com/videojs/videojs-contrib-ads/pull/72\n. @quarkus hey, want to make the change to the .travis.yml file?\n. LGTM\n. Also, I just realized there's a better way of doing it. Instead of changing the install script in the travis.yml, we can just declare grunt-cli as a devDependency.\n. Yes, it would. Especially since videojs now has really nice vtt support.\nUnfortunately, it's unlikely we'll get to that any time soon.\nHowever, if you are willing to submit a PR, we'll gladly review it.\n. You probably want to keep a reference to the old selectPlaylist before setting it.\njs\nvar oldSelectPlaylist;\nvar customPlaylist = function() {\n  oldSelectPlaylist = vidPlayer.hls.SelectPlaylist;\n  vidPlayer.hls.selectPlaylist = function() {\n    maestro = vidPlayer.hls.playlists.master;\n    return maestro.playlists[i];\n };\nvar standardPlayling = function() {\n  vidPlay.hls.selectPlaylist = oldSelectPlaylist;\n}\n. Unlikely to happen any time soon. See #135 for a more detailed answer.\n. Nice art :)\nLGTM\n. Yep, working on a test case.\nIt definitely would simply things to always use resolutionPlusOne, though, I think, keeping the exact match is a good compromise. The main issue I think is a scenario where the resolution under the player size is just slightly below it where-as the resolutionPlusOne is significantly bigger.\nI.e., player size is 300x150 but resolutionPlusOne is 1920x1080 and the resolution under ends up being 264x149. I guess it would be best to take distance into account but not sure it is worth it.\n. I updated tests.\nAlso, just realized that with this we would never end up choosing the audio-only rendition in just about any case. Thoughts, @dmlap?\n. Yes. That does sound right, actually.\n. LGTM. @dmlap?\n. LGTM\n. By default this tech adds itself to the tech order in the beginning. But if you're setting a custom tech order, you need to make sure to add hls back in. The tech name is hls and should probably come before html5 in the tech order list.\n. I guess this would be the closest: https://github.com/videojs/videojs-contrib-hls#options\n. The current UMD that videojs has doesn't work great. But we're working for 5.0 to rework it to use browserify.\nThis project does include the dist file on npm. We probably need to point the browser field of the package.json to point at the dist file.\nAlso, one of the things I would like to do with this project is break things up into separate projects. For example, have the m3u8 parser a separate dependency that can be included via browserify. We've already started doing that internally.\nHowever, we'd be more than happy to accept the changes to switch this project to commonjs/browserify.\nP.S., you could probably use browserify-shim to make the current files work via browserify as a stop gap.\n. videojs 5.0 should work nicely with browserify (and to a certain extent in node).\nIt's probably not worth having anyone work on this right now because this project is in flux right now as we're trying to get MSE support added.\n. I believe this is now available in the dev branch.\n. Yup, the 2.x and 3.x releases should be available. Works great with browserify right now. Still some issues with webpack ( #600 )\n. LGTM\n. Other than the minor comment, LGTM\n. Not sure. I have a stream that shows this issue currently.\nWorking on the failing test currently as well.\n. Looks like the current test is failing because it is entering into this section, so, might be able to duplicate the currently failing test into a working test for this option.\n. I have an update to fix the currently broken test. I don't currently have a test that checks the functionality in this PR because it's impossible to stub out the methods that we care about, currently.\n. Duplicate of #107.\n. Looking into build failure.\n. LGTM\n. Weird. I know if there's anyone we could ask about why this could happen.\n. Otherwise, LGTM\n. It should have been there but seems like we're ignoring dist/ in the .npmignore file.\n. LGTM\n. Sounds like this might be the correct course of action. Safari already has this and Chrome has filed an intent to implement (https://groups.google.com/a/chromium.org/forum/#!msg/blink-dev/U06zrT2N-Xk/RFS_q-Hi2wMJ).\nThe spec is available here: http://www.w3.org/html/wg/drafts/html/master/semantics.html#datacue\nSeems right now that it required to be used for metadata tracks but are trying to remove that restriction: https://www.w3.org/Bugs/Public/show_bug.cgi?id=25261\n. Style issues that would need to be addressed as well :)\n- [ ] extra whitespace\n- [ ] removed vertical whitespace\n- [ ] multi-line variables squashed into one line\n- [ ] comments should be on the preceding line and not on the same line\n- [ ] url change\n- [ ] consistent indentation (2 spaces)\n. LGTM\n. Make sure that your iframe has the allowfullscreen attribute on it (possibly with vendor prefixing as well). You won't be able to take the player fullscreen otherwise.\n. Oh, I see. I somehow totally missed that part.\nI've not heard of anything similar happening. What version of videojs/hls are you using?\n. LGTM, though, there's an error.\nAlso, would this affect #307? Seems like the duration and pts updates might change whether we get the issue or not.\n. LGTM\n. Sure. :P\n. The reason why it's failing is that we do not currently support byterange requests for segments with the same ts file.\n. LGTM\n. LGTM\n. We're currently working on making this work with MSE and mp4s. MSE is supported in all current major browsers and will be shipping in MS Edge. The only possible issue is Firefox, which currently has a whitelist for MSE support, but firefox is supposed to drop the whitelist in a recent future version.\nWhen we have the MSE version of HLS, it will use MSE when available and drop down to flash only for browsers that would require it, like IE10 and older version of firefox.\nThanks for the question. Hopefully, the above helps.\n. LGTM\n. LGTM\n. What version of videojs are you using?\n. the 0.17.8 release of contrib-hls isn't compatible with videojs 5 (what's currently in videojs master).\n. You need to make sure that you have CORS headers enabled, see here in the README. I can see that you don't currently have that up on your m3u8 or ts files.\n. Why not expose it like we have for bandwidth and use it as a variable that way?\n. The released version of contrib HLS doesn't currently support vjs 5.0. However, we're working on a version that supports vjs 5.0. Unfortunately (though, also fortunately) it's tied up with our transition to using MSE for playback to limit how much flash is used. Stay tuned.\n. Unfortunately, it's not quite ready yet :(\n. Sorry, not quite sure what the status is. @dmlap will be able to provide a better answer in the following week.\n. :+1: to handling that later\n. Wrong branch.\n. Given that this project relies on flash (though, hopefully not for much longer) you have to load it in over a local webserver because flash doesn't like loading in over the file: protocol.\n. I don't think we currently support that directly. However, the browser should cache the ts segments and so subsequent requests shouldn't actually re-download the segments from scratch.\n. Hello,\nhls.js is pretty cool. We've been working for a while on making this project use MSE internally for playback when possible and fall back to flash in other cases. You can see where we are now in the development branch of this repo. Also, you can track updates on this issue #382 since we are also updating contrib-hls with videojs 5.0 support at the same time.\nThanks!\n. You won't be able to build it from an npm install because there's devDependencies. If you clone the git repo and run npm install in that folder, you should be able to then run grunt build\n. You can also download the \"source code\" tarball from the releases page.\n. This is the project. Unfortunately, it isn't quite ready yet. See the development branch and follow this thread for updates: https://github.com/videojs/videojs-contrib-hls/issues/382\nSorry for the confusion.\n. No problem.\n. Thanks for the question.\nUnfortunately, no. Flash doesn't support it natively, afaik, and we don't have any plans to try and add that support in.\nOnce we ship the MSE portion, that should hopefully allow us to play back with variable playback speeds.\n. Thanks for the bug report. The 1.0.1-0 is a prerelease. It partly works but we're working on it.\n. That's awesome. Thanks.\nWe're currently trying to get MSE support with HLS happen in the development branch of this repo. That branch also supports videojs 5.x. Would be awesome if you could update this PR against that branch instead.\n. The 1.x tags (or @next on npm) are vjs 5.x compatible. It's what is in the development branch.\n. No worries.\n. Volume remembering hasn't really been supported in a long time in videojs. It's been buggy and partially removed already. In videojs 5, it's not present at all. See https://github.com/videojs/video.js/issues/1929\nThat thread also mentions that there's a plugin available to do this: videojs-persistvolume.\n. Well, that's an issue for that plugin then :P\n. Merged via #466 \n. @shacharz the current 1.x releases are not full releases and more of prereleases. We've released them so that people can try it out and report issues and help us get a full release for HLS with MSE. Also, videojs 5.x support.\n. That's super weird. I'm pretty sure that prepublish isn't supposed to be run like that.\n. @imbcmdth investigated and found that firefox does fire a canplay event. However, it only happens after you hit play. We should file a bug against firefox for this and we'll try and build a workaround for contrib-ads instead of in this project.\n. https://bugzilla.mozilla.org/show_bug.cgi?id=1231780\n. We have plans to turn this into a browserify module (and there by making it work with webpack). We don't currently have an ETA for it, though.\n. there's a transform we're using in other places (like videojs) that can do a token replacement. https://www.npmjs.com/package/browserify-versionify\n. Can you include the versions of videojs-contrib-hls used and also versions of browsers tested against? Thanks.\n. The player doesn't generate any urls. It just takes what it is given and tries to to use it.\nYou can try replacing the space in there with the the encoded something like: http://www.mydomain.com/download_video.php?path=/HLS%2520Test/hls/hls_me_4/hls_me_4.m3u8\nThe player will not work if it doesn't get working url.\n. Hm... that's an interesting problem. The spec for the 302 status code tells us to not use the new URI for the new requests, 301 tells us to use the new URI. However, segments and media manifests are relative to the location of the m3u8 file, so, if the playlist was redirected, do we use the new URI for the playlist or our original one?\nI assume that Safari/iOS is able to play this correctly?\n. Yeah, it looks like we cannot read the value without making a separate HEAD request directly and looking at the headers: https://dvcs.w3.org/hg/xhr/raw-file/tip/Overview.html#infrastructure-for-the-send%28%29-method\n. Unfortunately, we cannot play back HLS videos that do not have CORS headers. Please see the hosting considerations in the README for more details.\nThanks.\n. Unfortunately, we cannot play back from file://. That is because we use XmlHttpRequest (XHR) to load the HLS manifests and segments and file:// is disallowed from XHR.\nFor bests results, we really do urge you to use a webserver with CORS enabled.\n. Both the manifests and ts segments are loaded in over XHR. Normal browsers do not allow you to do XHR from the file:// protocol or to file:// protocols, I do not know about Cordova.\n. LGTM\n. What version are you using currently? The current versions do not allow this. But will soon be available. See https://github.com/videojs/videojs-contrib-hls/issues/490, https://github.com/videojs/videojs-contrib-hls/issues/509, and https://github.com/videojs/videojs-contrib-hls/issues/250. Thanks.\n. See #600 for issues with webpack and solutions around it in the meantime.\n. I wonder if the issue is that we set the end of the range to be offset+length-1 see here. This could possibly cause us to miss a byte.\n. No, Looks like it should be fine as is, I previously tested with the last segment and the content-length in the response was correct for both, tried a different segment and without the -1 it produced a content-length of one extra byte.\n. I think contrib-hls 2.2.0 won't require any aliases anymore. Though, unfortunately, that version also requires videojs 5.10.1 and up.\n. If webworkify is the only problem, we should consider swapping it out for another module with similar functionality that works in both webpack and browserify.\n. There seems to be a webworkify-webpack module which may work for webpack but it doesnt work for browserify. Someone should write a module that works for both.\n. After some thought and some discussion in babel's chatroom, it seems like the correct solution is to not rely on a packer transform or loader to the web worker inline but rather do it as a separate source transform. I saw https://github.com/mohayonao/inline-worker which may help but also maybe there's some babel plugin that allows us to do this.\nUnfortunately, this is a low priority for us because there's more pressing specific issues and it can be worked around by using the dist file or maybe running webworkify-webpack over the code. If anyone is willing to submit a PR to fix this issue we'll definitely take a look and work with you to land it.\nThanks!\n. Anyone know of a babel webworkify plugin? If we can inline the webworker at that point, we can easily support both webpack and browserify without extra work on the user's part\n. @Ambroos also, thanks for making the dropin replacement package, seems like it'll make things a lot simpler in the meantime.\n. I wonder if we can turn webworkify into a babel plugin. Then we could just run it at build time and users of contrib-hls won't need to bother with configuring their bundlers.. The reason why is because we use browserify to build out the pre-build standalone file. To do that we use the webworkify module that you're replacing with the dropin one for webpack. What would need to happen is to switch to either a babel plugin or something external to the bundler to do the webworker inlining.. Are you setting the withCredentials option when initializing videojs?\n. It's either the same issue as #481 or something new. Will you be able provide a reduced test case/m3u8 url?\n. Do they download 10 times in a row immediately without any wait between them?\n. What versions of videojs and contrib-hls are you using? Also, what OS are you running this on?\nCurrently, contrib-hls (and actually videojs) isn't smart enough to switch from one tech to another when there's a playback error, so, if it detects that HLS+MSE is supported, it tries to play that.\n. As discussed on IRC, using the dist file requires that you add videojs as a global before including contrib-hls.\n. Going to close this to continue alternate discussion in #636.\nThere are two bugs, one is how we export this package (which is fixed by #638) and also the issue in #636 where we always shim videojs.\n. You actually don't need to videojs.Hls = require(...), when you require videojs-contrib-hls, it binds itself to videojs.\nAre you requiring it directly or using the dist file?\n. I think one of the issues is that we always shim videojs into the build, we should fix that.\nAs a workaround, you could do something like this:\njs\nvar videojs = require('video.js');\nwindow.videojs = videojs;\nrequire('videojs-contrib-hls');\nWhen we fix the issue, you should be able to omit line 2.\n. Ah, cool, didn't realize it was the same issue. I'll try and go through out plugins and update the build process this week.\n. @nehakhandelwal what browser are you running this on? How are you compiling and bundling your javascript?\n. LGTM, thanks!\n. This will break everyone using contrib-hls. Those that include it via browserify will break because the es5 folder is missing. Those that include it via the dist folder would break because that folder is missing.\n. Oh, too much read obscured things, while it should work, I think it's nicer to have all the files included in npm.\n. removing dist-test sounds fine. I think keeping the rest would be good.\n. Interesting, I didn't realize that we actually had access to the redirected url. We had an issue about this recently (https://github.com/videojs/videojs-contrib-hls/issues/548) and we thought we couldn't handle it.\n. We don't really do testing on Firefox for Android. We register the source handler with videojs after the native html5 tech, plus, firefox claims that it could possibly play back HLS (it returns \"maybe\" from canPlayType) and thus when trying to play back an m3u8, we just hand it off to firefox directly which it fails. To fix this, we'd need to check for Android and register the source handler before the native one (https://github.com/videojs/videojs-contrib-hls/blob/5a4d09f71ad22fcbb31fc3f52df4a8a1bcb87ac7/src/videojs-contrib-hls.js#L1601-L1603). But then, when our source handler is loaded, it would still end up disabling it because we think that native HLS is supported (https://github.com/videojs/videojs-contrib-hls/blob/5a4d09f71ad22fcbb31fc3f52df4a8a1bcb87ac7/src/videojs-contrib-hls.js#L1588-L1590).\nHope that helps.\n. I'm not sure what the questions is really but videojs-contrib-hls not videojs itself rely or require you to use or have jquery available.\n. Unfortunately, this plugin can't really support older IE than 10 because most of the work happens in javascript and two big things that we depend on (TypedArrays and CORS) don't really work properly in those browsers or the available shims are too slow to be practical for this usecase.\n. Must've missed that one in https://github.com/videojs/videojs-contrib-hls/pull/675\ncan you double check and make sure that's the only one left over?\n. LGTM\n. We should wrap that in a null-check. In the meantime, you can try updating your version of videojs to 5.10.1.\n. @imbcmdth @BrandonOCasey do you think there's a good way of null-checking audiotrack and doing nothing? Or is 2.2.0 going to require videojs 5.10.1 and up? \n. Talking with @imbcmdth offline, we decided that while we didn't intentionally make it require videojs 5.10.1, making 2.2.0 backwards compatible with older versions of videojs will be very hard.\nSo, videojs-contrib-hls 2.2.0 and up will now require videojs 5.10.1 and up.\n. Yeah, the CONTRIBUTING.md is completely out of date. We don't use grunt anymore.\nEverything is done through npm scripts, an overview can be found here: https://github.com/videojs/generator-videojs-plugin/blob/master/docs/standards.md#automation\nThe tl;dr is that you can run npm run build to contrib-hls, npm test to run the tests. Also, npm start will set up a watcher that re-builds contrib-hls while also running a local web server that serves up the project directory.\nThe npm and uglify warnings shoudn't be an issue.\nHope that helps.\n. What version of contrib-hls are you using? Also, what versions of Chrome and on what OS were you testing with? Also, can you please provide a reduced test case? It would make it a lot easier for us to reproduce the issue you are experiencing and thus fixing it.\nThanks.\n. You should be able to use 2.1.1 if it fixes the issue for you.\n. We should do a better job of this. I believe that the versions of contrib-hls that support videojs 4 are the pre 1.0 versions. The latest one being v0.17.9. I also want to add that while it works, it still has a lot of issues and missing features that were added in recent versions of contrib-hls, so, I would definitely urge you to update.\n. See #600. It should all work except for our usage of webworkerify which doesn't work with webpack.\n. Unfortunately, we're all very busy and can't always reply to issues immediately. If you'd like us to help you, can you please provide the information again?\n. Also, it was answered in the videojs issue: https://github.com/videojs/video.js/issues/3359#issuecomment-224389149\n. I'm not sure what you're asking. contrib-hls doesn't add any other styles.\nAlso, questions about the skin generally should go into the main repo video.js.\n. Can you elaborate a bit more? Though, it sounds to me like this issue should belong in the main repo video.js.\n. Are you using the metadata inside the hls stream? Also, how are you playing back the ads?\n. There's the new \"representations\" API that you can use to limit contrib-hls to a certain subset of playlists.\nA menu can be made using videojs's MenuButton component.\n. @clzola it depends on how wide you want each item to be. For example, you could have several 720p resolution streams but with different bitrates. So, when a user selects 720p, you'll enable all of those by calling enabled(true) and then disable the rest with enabled(false).\nYou could also widen the rage by say including 540p streams when you want to show 720p just so that the video will be less likely to buffer, so, it'll be possible for contrib-hls to do rendition switching a bit.\nIt all depends on how wide a band you want to define as \"720p\".\n. @piotr-cz it should be available. If you go to our live example and type player.hls.representations() into the console, you should see it give you back an array with several items.\n. Going to close this but we can definitely continue the discussion here and if we find an issue we can either re-open or open a new issue.\n. Safari doesn't run contrib-hls, we let the native HLS implementation take over.\n. Unfortunately, there isn't any way to ask Safari to switch to a specific rendition.\nWe'll be investigating soon (not sure how soon) being able to force contrib-hls on on browsers that we previously use native HLS implementations but we don't have that functionality easily exposed right now.\n. If it works on Safari, it's because they aren't relying on native behavior at the moment.\n. On Android, we don't yet run contrib-hls but let the native functionality handle HLS since most modern versions of Android support it natively -- at least to some extent. Android simulators tend to be very finicky with respect to videos so I'm going to wager that that is the issue. Playing the demo page on my physical 6P device works just fine.\n. Looks like the m3u8 you have is a media playlist. Those just have the video to play in a single resolution. To get multiple resolutions, you need a \"master\" playlist that has links to different media playlists with resolution and bandwidths properties for each of those playlists.\nYeah, we should update the documentation. Perhaps we can just make the representations always be available but in this case it only returns one item in the representations. Not sure if @imbcmdth has already thought through that, though.\n. I thought we fixed that already...\nWould you be willing to make a PR for that?\n. We don't currently support it. The correct place would be to look in the m3u8-parser. I believe that @nickygerritsen was interested in that as well but I'm not sure whether he had a chance to start on it or anything but if he hasn't done work yet, a PR would be great.\n. I'm not sure that a custom tech is really required. Most of the changes can be gotten via event listeners like for volume changes you can listen to volumechange. Check out this page for an example: http://videojs.com/advanced/. Some of the videos on there use contrib-hls.\n. contrib-hls doesn't currently run on Chrome for Android. We let the native HLS functionality take over. Native Chrome for Android does not support alternate audio tracks right now.\nWe are thinking of making contrib-hls run on chrome for android over the native functionality but that might take a while because we'd need to test it and fix any issues.\n. What version of videojs are you using? Are you using our built file from the releases?\n. Version 3.1.0 of contrib-hls requires videojs 5.10.1 and up because of the audiotrack functionality.\n. Do you have a link to your m3u8 or an example m3u8?\n. Looks like a bug.\n. Tests are failing.\n. Because we're no longer making a uint32, so, the output is different.\n. Thanks!\n. contrib-hls doesn't run on Android yet, though, we'll be looking soon into enabling it.\nYou must be using a feature that Chrome for Android doesn't support.\n. contrib-hls can parse it and even supports multiple audio but it doesn't run on Chrome for Android at all, everything is done natively. I do know that Chrome for Android doesn't support multiple audio tracks right now so, removing those to get it working makes sense.\nWe'll be looking soon into enabling contrib-hls on Chrome for Android because it lacks features that we support and it supports MSE APIs which contrib-hls uses.\nThanks.\n. Thanks for moving the issue here.\nCan you elaborate on what you mean by the player reseting to 00:00 when you seek to bufferedEnd? Is the new currentTime returning 0 or just the display of the control bar?\nPerhaps what you actually want to use is seekable rather than bufferedEnd. And get seek to the end of the last seekable range available.\n. Did that work for you?\n. Awesome!\n. Looks like the tests are failing due to the linter which should end up getting fixed by https://github.com/videojs/videojs-contrib-hls/pull/788\n. Also, this actually won't prevent issues because of the transitivity of dependencies.\nBecause videojs-standard depends on eslint-config-videojs with a ^ so it'll  pick up any patch and minor changes.\nWhat we should've done is revert the change, release a patch version with the reversion, and then make a major update so consumers can update at will.\nShould we just do it now anyway? @misteroneill \n. I think that README misleading. It is a replacement for this project using hlsjs. This project is still well and alive.\n. Yeah, making a PR would be good. There's an issue on that project in the meantime.\n. Thanks for being responsive :)\n. If the issue is because of clearing the buffer when switching to fullscreen on the fullscreenchange event, we possibly would want to debounce the event so that if we get several fullscreenchangeevents, we won't try clearing the buffer on each one.\n. I believe we don't support mp3s currently. Does it work if you use AAC?\n. Unfortunately, right now we don't run contrib-hls on Android, so, what you're seeing is a native behavior and Chrome for Android doesn't support multiple audio text tracks.\nWe are investigating enabling contrib-hls on Chrome for Android but haven't done so yet because we want to test it thoroughly. We've previously just let the native functionality take over because it generally provides a good enough experience and it's always nice when we can do less work and let the browser handle everything.\n. It's on the road map. We probably should add an option to force it.\n. Please answer the questions listed in the [issue template](https://github.com/videojs/videojs-contrib-hls/blob/master/ISSUE_TEMPLATE.md)\n. LGTM\n. Make sure that links are publicly available\n. Thankfully that spec is an unofficial draft at the moment. I think the reason why Safari does these things so dynamically is because cues from id3 aren't made until basicallycuechangetriggers, so, safari doesn't know when to end the previous cue until that time. But you need to do it right because because otherwiseactiveCueswill have multiple cues. This also seems like the flaw in that spec.\n. What version of chrome and what version of windows? Do you have a screenshot of how it looks?\nJust tried it on windows 10 and chrome 53.0.2785.143 and it seems to be looking just fine. Also, thanks for the test case link.\n. This is because on Safari contrib-hls isn't run. We use the native HLS implementation on Safari.\n. Unfortunately, there isn't a way of doing it natively. I believe we're working on a way to force contrib-hls to run on any browser which would enable you to use it on Safari. Though, I don't think we have an ETA for that yet.\n. That seems like a reasonable change, however, why are you using the pre-build file in browserify? This project is built so that you should be able to just require it.\n. Yeah, why is that file (dist/`) being used in a browserify build-system? This project is set up so that you can require it (https://github.com/videojs/videojs-contrib-hls/blob/master/package.json#L5) and when you run browserify on your own code, everything gets bundled together. Just trying to understand the usecase better.\n. Hls.js is an unrelated project to this one.\n. Answered here: https://github.com/videojs/video.js/issues/3752\n. Answered here: https://github.com/videojs/video.js/issues/3752\n. The reason why you're not able to play back your stream is because it doesn't have CORS headers enabled on it. Please see the hosting considerations section of our README about it.\nThanks.\n. On the HLS url: http://smartcastlivuni-lh.akamaihd.net/i/0xxhn2w5q_1@436144/master.m3u8\n. What about using a url like: https://unpkg.com/videojs-contrib-hls@latest/dist/videojs-contrib-hls.js\nOr maybe even have a dropdown for tags that loads in @{{tagname}} based on the dropdown.. sh\n$ npm dist-tag ls videojs-contrib-hls\nlatest: 3.6.13\nnext: 4.0.2\nlooks like that's what the tags are. I think it would be great to have a tag/version dropdown similar to how unpkg.com has (see top right corner): https://unpkg.com/videojs-contrib-hls@3.6.13/dist/. Verified this PR in Edge.. Unfortunately, most of the sources from Apple don't include CORS headers, which is required for us to work. See the hosting considerations section in the README.\nI think we have a test stream but don't have a link right now.. Because this project uses javascript to request the segments, they're required to have CORS headers from the server as outlines in the hosting considirations in our README.\nSafari runs HLS natively and thus doesn't require CORS headers.. The header needs to be set on the server serving the HLS manifests and segments. Since the url is from ustream.tv, it would need to be there.. I think this is an issue with chrome. We have a workaround in videojs 5.16.\nIt's been out for a while and we haven't heard bad stuff about it, so, probably will promote it to latest soon.. LGTM. Yup, we need to change getComponent to getTech. I was planning on making a PR at some point. But anyone can do it as well.. Looks like this doesn't fix compat for vjs 6 since Hls a regular object is registered as a component which is currently disallowed.. A potential workaround is to not register Hls as a component if we're in a videojs 6 env. For example:\njs\nif (!videojs.use) {\n  videojs.registerComponent('Hls');\n}\nThis keeps compat for 5.x and sets us to remove it from hls when 5.x support is dropped.. Also, for better or worse, videojs 6.0 no longer checks for components on the videojs object, it won't error out/warn in the way that prompted using it in the first place.. I think this PR could go in without answering the registerComponent question.. And for plugin, we could either leave it or we can change it to be something like:\njs\nif (videojs.registerPlugin) {\n  videojs.registerPlugin(...);\n} else {\n  videojs.plugin(...);\n}. So, I updated the PR:\n use getTech instead of getComponent\n verify that the flash tech is included before attaching something to it\n if registerPlugin is available, use it instead\n if videojs.use is available, don't register \"Hls\" as a component\n  this isn't too bad since videojs.Hls is still around. Plus, that one won't cause any issues since the code that checks for components on the videojs object is removed in videojs 6. Plus, given that this is a videojs project, I don't think it's too bad for it to be attaching itself as videojs.Hls.. It seems to be working just fine for me? Maybe the version of vjs I was testing with is a bit outdated, hm.... Saw an issue with evented which should be fixed here: https://github.com/videojs/video.js/pull/3990. Oh, I had to set the useCueTags option. Updated that line.. I'm looking into the test failures with vjs 6.0. However, those are going to go into a separate PR. We should figure out how to use the event object in the progress listener to have better bandwidth reporting. Particularly around aborted segments. The progress event has a loaded and total attributes which contain the currently loaded amount and the total for what we're downloading.\nThis definitely should go in another PR, though, but, I thought it would be good to mention here.. This fixes ~90% of the tests with videojs 6. The stuff that are left are unusual tests that have expectations that have changed, like logs and flash.\nFor whatever reason, tests aren't being generated correctly if videojs-flash is being imported via a linked dependency. Might be solved with a real release. Currently, most of them are now wrapped in a null check.. Needs to be rebased against master. Also, the checking for whether Flash exists can be removed. Otherwise, all tests pass locally when run against vjs 6.0.0-RC.1.. Re-opening this PR because #1151 is done. I'll rebase it against master and fix issues.. To answer @gesinger's question, there's no need to pass a clock into createPlayer in all cases. It's only necessary if createPlayer is with a particular source/tech and so we need to tick the clock before we call mockTech or else it blows up.. oh, yeah, forgot to run it. Let me do that now.. Please fill out the issue template, without answering those questions, there is not enough information to answer your question. Some important stuff to answer is browser and OS versions as well as version of videojs. It will be best if a reduced test case can be provided as well.. Can you please fill out the issue template? Specifically, the sections around which versions of contrib-hls, video.js, and browser and OS.\nA reduced test case would be appreciated as well.\nThanks.. Seems like that stream doesn't have any CORS headers which are required. hlsplayer.net seems to be playing it back in flash, which has different different hosting considerations.. contrib-hls has an issue with webpack around webworkify, there's a workaround here: https://github.com/videojs/videojs-contrib-hls/issues/600#issuecomment-258400412\nHope that helps.. I wonder if we should get the s1 projects unpublished; thoughts @nickygerritsen?. Making XHR requests on a page opened from the file system is a recipe for failure. Running via a local static file server is highly recommended.. Different browsers have different restrictions. It's possible that in this case firefox is letting the requests through and chrome isn't. I would urge you to always use a static file server locally for testing these types of things as they would provide the most realistic scenario to work with.. On Safari, contrib-hls is disabled by default in lieu of the native playback capabilities. (You can overrideNative if you want.)\nFor the best support, I would recommend waiting at least for loadedmetadata if not canplay before trying to set the currentTime. The problem is that Safari is still loading the video when you call currentTime and thus it is basically ignored.\nHope that helps.. You're welcome.. From https://github.com/videojs/video.js/issues/4292\n\nDescription\nWhen playing a server side ad stitched stream, the video/audio gets off sync after a ad break or two. The theory is that this might be caused by discontinuity. \nvideo url:\nhttp://csm-e.cds1.yospace.com/csm/live/122906630.m3u8\nSteps to reproduce\n\nPlay the video url in videojs player in chrome.\nWait for at least one ad break\nWhen the content starts again, check the sync between audio and video \n\nResults\nExpected\nthe video/audio is synced\nActual\nthe video/audio is not synced (roughly 2-3 seconds)\nError output\nNo console error. \nAdditional Information\nNo additional information\nversions\nvideojs\n\"video.js\": \"^5.19.0\",\n\"videojs-contrib-hls\": \"^5.3.3\"\n\nbrowsers\nChrome\nOSes\nApple desktop\nplugins\nNo additional plugins. I'm guessing that the problem is that webpack needs to be configured as outlines in #600.. Unfortunately, because of the usage of webworkify, I'm not sure this is sufficient to cover all bases.. It is: https://github.com/videojs/videojs-contrib-hls/blob/master/package.json#L99. I added an mp4 fallback in the index.html page and was able to run this in IE8 without any errors.. I believe IE8 works because of the es3 transform.. I think we shouldn't store things in local storage by default but have an option to enable it. This is because of the EU cookie laws where users have to be informed if things are stored locally. While local storage isn't specifically called out, it's best to play it safe. In Video.js, we have an option to persist caption settings for the user but it is disabled by default.\nThen, when a site that has the cookie notification uses Video.js, they could enable the option to persist this information.\nWith ABR, we'd have two things that are stored in local storage, optionally, I don't think it quite warrants a combined API, but we should keep our eyes out, maybe we'll want to combine both of these into a common videojs api and a common allowPersistence option that enables or disabled all persistence via that new API.. This will need to wait till videojs-contrib-media-sources is also rolluped, which I'm working on next.. While this PR works great, media-sources couldn't be rolluped easily with a large increase in file-size. Unfortunately, we have to abandon this effort in until we can figure out how to deduplicate muxjs in media-sources.. Hey, this sounds like a dupe of #600. Unfortunately, right now you have to include webworkify-webpack-dropin because the module we use is browserify specific. You can see an example config here: https://github.com/videojs/videojs-contrib-hls/issues/600#issuecomment-258400412\nHope that helps.. Should be merged after https://github.com/videojs/videojs-contrib-hls/pull/984. Oops, didn't realize it was against the vjs-6-tests branch.. This means that the server isn't set up with the correct headers to be playable via contrib-hls. Please refer to the hosting considerations in the README for modifying the server.\nHope that helps.. If I understand the google translate correctly, you're trying to use this project with webpack and it isn't working. Unfortunately, there are some issues with this due to how we built this project.\nThere's a lot of discussion and work-arounds in #600. Unfortunately, refactoring the project to provide support for webpack without configuration changes has proven non-trivial.. I'm not sure this will actually fix it. Not sure about webpack, but browserify doesn't like importing browserified code unless it ran through derequire, so, that could be an issue.\nThough, I think the main issue is that webpack users would still need to configure this because our UMD build expects videojs to be available globally: https://github.com/videojs/videojs-contrib-hls/blob/master/package.json#L63-L67. Some more information: this happens because of Video.js's handling for \"late init\". If the video has already loaded, Video.js tries to just go with it instead of selecting another tech and source handler. We probably would want to add some kind of option to Video.js to force it to go through source selection even in late-init case.. probably something that might be worth to add for v7 with VHS in by default. But we should probably also be recommending the <video-js> embed since it gets around the \"late init\" issue.. It's possible the index.m3u8 loaded just fine and has CORS headers bu the media playlists and segments don't have CORS setup.. iOS does not support MSE and videojs-contrib-hls will defer to native implementations when available (at least on Safari on desktop).\nAlso answered in https://github.com/videojs/videojs-contrib-hls/issues/1216#issuecomment-319209490 and https://github.com/videojs/videojs-contrib-hls/issues/1280#issuecomment-372819768. by default, contrib-hls only runs on browsers that don't support HLS natively. Also, it cannot run on browsers that do not support MSE which will be iOS.\nFor other browsers like Android or desktop safari (which we don't officially support yet) you'd want to set the overrideNative option.. Worth looking at npm deprecate instead of a custom postinstall script.. @murtaz53 can you open a new detailed issue about the problem? What you're doing, what you're expecting, what's happening etc.. Video.js 7 comes with Video.js HTTP Streaming by default, which is the next generation version of videojs-contrib-hls. If you're using vjs 7 you don't need to include contrib-hls manually anymore.. Looks like that's the resolution for everyone's problem. Sorry I didn't realize earlier and thanks for everyone's patience on this.\nIf you're using the main Video.js script, you do not need to include videojs-contrib-hls manually as VHS is included by default and has the same functionality.. @yoko10000 that sounds like a separate issue. Can you open a new issue and fill out the issue template?. If you're using the default, it could be empty too, fwiw. Sounds good!. Given that there's a lot more discussion in the other issue (https://github.com/videojs/video.js/issues/5366), I'll close this one and have us continue over there.. I'm actually not seeing such an audio quality selector. In addition, unless I'm mistaken, the audio qualities are associated with particular video renditions and I'm not sure that we can switch it out because we don't know if the audio would fit.\nThe @videojs/playback team may have more information. Here's the master manifest for ease of access:\nhttps://bitdash-a.akamaihd.net/content/sintel/hls/playlist.m3u8\n```\nEXTM3U\nEXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"stereo\",LANGUAGE=\"en\",NAME=\"English\",DEFAULT=YES,AUTOSELECT=YES,URI=\"audio/stereo/en/128kbit.m3u8\"\nEXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"stereo\",LANGUAGE=\"dubbing\",NAME=\"Dubbing\",DEFAULT=NO,AUTOSELECT=YES,URI=\"audio/stereo/none/128kbit.m3u8\"\nEXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"surround\",LANGUAGE=\"en\",NAME=\"English\",DEFAULT=YES,AUTOSELECT=YES,URI=\"audio/surround/en/320kbit.m3u8\"\nEXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"surround\",LANGUAGE=\"dubbing\",NAME=\"Dubbing\",DEFAULT=NO,AUTOSELECT=YES,URI=\"audio/stereo/none/128kbit.m3u8\"\nEXT-X-MEDIA:TYPE=SUBTITLES,GROUP-ID=\"subs\",NAME=\"Deutsch\",DEFAULT=NO,AUTOSELECT=YES,FORCED=NO,LANGUAGE=\"de\",URI=\"subtitles_de.m3u8\"\nEXT-X-MEDIA:TYPE=SUBTITLES,GROUP-ID=\"subs\",NAME=\"English\",DEFAULT=YES,AUTOSELECT=YES,FORCED=NO,LANGUAGE=\"en\",URI=\"subtitles_en.m3u8\"\nEXT-X-MEDIA:TYPE=SUBTITLES,GROUP-ID=\"subs\",NAME=\"Espanol\",DEFAULT=NO,AUTOSELECT=YES,FORCED=NO,LANGUAGE=\"es\",URI=\"subtitles_es.m3u8\"\nEXT-X-MEDIA:TYPE=SUBTITLES,GROUP-ID=\"subs\",NAME=\"Fran\u00c3\u00a7ais\",DEFAULT=NO,AUTOSELECT=YES,FORCED=NO,LANGUAGE=\"fr\",URI=\"subtitles_fr.m3u8\"\nEXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=258157,CODECS=\"avc1.4d400d,mp4a.40.2\",AUDIO=\"stereo\",RESOLUTION=422x180,SUBTITLES=\"subs\"\nvideo/250kbit.m3u8\nEXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=520929,CODECS=\"avc1.4d4015,mp4a.40.2\",AUDIO=\"stereo\",RESOLUTION=638x272,SUBTITLES=\"subs\"\nvideo/500kbit.m3u8\nEXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=831270,CODECS=\"avc1.4d4015,mp4a.40.2\",AUDIO=\"stereo\",RESOLUTION=638x272,SUBTITLES=\"subs\"\nvideo/800kbit.m3u8\nEXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=1144430,CODECS=\"avc1.4d401f,mp4a.40.2\",AUDIO=\"surround\",RESOLUTION=958x408,SUBTITLES=\"subs\"\nvideo/1100kbit.m3u8\nEXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=1558322,CODECS=\"avc1.4d401f,mp4a.40.2\",AUDIO=\"surround\",RESOLUTION=1277x554,SUBTITLES=\"subs\"\nvideo/1500kbit.m3u8\nEXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=4149264,CODECS=\"avc1.4d4028,mp4a.40.2\",AUDIO=\"surround\",RESOLUTION=1921x818,SUBTITLES=\"subs\"\nvideo/4000kbit.m3u8\nEXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=6214307,CODECS=\"avc1.4d4028,mp4a.40.2\",AUDIO=\"surround\",RESOLUTION=1921x818,SUBTITLES=\"subs\"\nvideo/6000kbit.m3u8\nEXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=10285391,CODECS=\"avc1.4d4033,mp4a.40.2\",AUDIO=\"surround\",RESOLUTION=4096x1744,SUBTITLES=\"subs\"\nvideo/10000kbit.m3u8\n`` . Ok. Looking at this, it seems better than the previous parser. We could always revisit this later on and swap this parser out for a pegjs or other parser or something.\n. can we pull these objects out so 1) they don't need to be recreated on everydataevent and 2) this piece of code data-handler would be more readable?\n. Why not make Stream into a mixin function rather than what you're doing here?\nThen, to use it, rather than doingFoo.prototype = new Stream(), you could dostream(Foo)and it'll mix stuff in toFoo.prototype?\n. why not just call this as an IIFE?\n. Looks like the problem is that because the totalDuration is added here but not in the expected jsons, the tests are breaking.\n. Sincemanifest.segmentsis an array, we want to use a regular for loop here.\n. looks like this is the change that really broke the tests. Not the above. Since the above section is never run in the tests because we don't actually run XHR to grab the manifest and thus don't fire theloadedmanifestevent.\n. can we go through all of contrib-hls and change all the yoda expressions to normal expressions? :goberserk: \n. is this the only actual code change?\n. how come?\n. What is the issue? Is it documented anywhere?\n. Cool. That's weird.\n. your line is too long. :x:  REJECTED\n. oops. Those should've changed to bequery`.\n. why not just\njs\nwindow.videojs = window.videojs || {};\nwindow.videojs.hls = window.videojs.hls || {};\n. This also creates a new XHR for 1.ts, I wasn't sure if it was supposed to or not.\n. I guess since we are returning from the error, it isn't necessary.\n. Maybe. I wasn't sure whether the npm version of sinon worked outside of node module-land without browserify.\n. Otherwise, in onDurationChange, when we ask the tech for the current duration, the flash tech will tell us that it is a duration of 0.\n. I could just inline options.responseType on line 130.\n. I guess. This is what npm did back when I used it.\n. Yes, because in this test, I couldn't figure out how to convert it to sinon, so, it's basically not using sinon.\nCouldn't figure out how to mock out the long-running XHR in sinon without completely breaking this test.\n. Possibly. Don't remember why I don't have it that way in the first place.\n. Good idea.\n. Good idea.\n. when an additional video.\n:tongue: \n. I so wish that js had better support for curry for cases like this.\n. really, we should just glob src/**.js. But let's leave it like this for now.\n. Apparently, vjs had a get method, we should consider beefing that up and using that instead (in the future).\n. Probably.\n. This makes a clone of the hls, so, that if we modify settings, we also don't modify the the value that is available via player.options().hls.\n. Yes, there will need to be a cleanup before this is merged in.\n. The current state of core's XHR doesn't have everything needed by this tech. However, in the long term, yes, it would be good to beef up core's XHR and get rid of this.\n. Maybe a slightly more specific name?\n. Yeah, we removed the thing that makes sure that native hls works.\nA suggestion to what we can do:\njavascript\nvideojs.Hls.canPlaySource = function(srcObj) {\n  var hls = mpegurlRE.test(srcObj.type);\n  if (hls) {\n    return !videojs.Html5.canPlaySource(srcObj);\n  }\n  return hls;\n};\n. JSCS. Been meaning to write up a config for it and jshint that can be used everywhere.\n. We may want to link to https://github.com/bitwiseshiftleft/sjcl/blob/master/README/COPYRIGHT even though we reproduce the BSD license below.\n. I believe we want to check the typeof offset here.\n. Calculate the bandwidth for the master. This can probably be removed because the master manifest will almost always be too small to give us a good estimate.\n. calculate the bandwidth for the first playlist downloaded.\n. If we fillBuffer here, we're going to get the first downloaded playlist (gear1), even if we decide to switch immediately. Instead, fillBuffer is called loadedplaylist after we finish downloading the first playlist and have a bandwidth value\n. on first playlist load, we don't want to update the media index or call fillBuffer.\n. Looks like this currently has an issue if the bandwidth ends up selecting the first playlist (gear1) again, it won't fillBuffer properly the first segment but instead will switch directly to gear4 as we've already calculated better bandwidth and already downloaded it.\n. It switched to gear4 because the sourceBuffer is aborted below.\n. you shouldn't need any setTimeouts at all. You should be able to use sinon's clock to tick the world forward.\nIn that case you won't need to make this an asyncTest either, since those are generally going to end up breaking.\n. Why not just set the timeout directly on the specific XHR we're testing? Something like requests[0].timeout = 0; before line 1123, before the clock.tick\n. Yeah, if you can create an xhr.test file, it would be great :smile_cat: \n. I'm not sure this is correct either.\nthe currentSegmentStartTime and nextSegmentDuration variables are in seconds, while playerCurrentTimeInMilliseconds is in ms and that is what getSwitchBuffer is supposed to return.\nAlso, why does this include the duration of the next segment? We haven't downloaded it yet. I think it should just be currentSegmentRemainingPlaybackTime.\n. I'll have a propose fix in the new upcoming branch.\n. That's true. I especially don't like that there are 3 if clauses that just do this.fillBuffer().\nThough, there are test cases that cover each of these conditions.\n. Yep. A master manifest is unlikely to be long enough to actually get us an accurate reading.\nNow that I think about it, as long as a user hasn't started playback yet, we should try and go to a higher rendition based on the bandwidth from the segment download.\n. It won't be. The Date will be converted into a number.\n. Oh, the comment is wrong.\n. I think so. We probably should. I basically just copied the test above it.\n. I'll change (and also the playlist loader one) it to setBandwidth.\n. that is a great idea.\n. What about:\njs\ntargetTail = (selectedPlaylist.targetDuration || 10) * 3;\n. does setBandwidth expect only an object with a bandwidth property?\n. So, basically it just cares about bandwidth. LGTM, then.\n. The expected value should be the second item with the actual value being the first.\n. would we want to make sure this method exists before using? This would mean that hls will no longer be usable with versions of vjs below 4.12.\n. FYI, emulated tracks currently ignore this property.\n. I was going to mention that on iOS6 or 7, we only have TextTrackCue and not VTTCue but then I realized this doesn't apply to iOS.\n. Yeah, it seemed that way. One of the reasons why I chose not to implement it. Just wanted to call it out directly.\n. VTTCue is what we should be using unless we're on that specific version of iOS.\n. This is a JSON file. You can't have js expressions in it.\n. Apparently, it needs to be uppercase ascii\n. why 500?\nThis PR unhooks listening to timeupdate to run fillbuffer right? That used to run at either 250 or less.\n. Are there any other cases where we would want to call stopCheckingBuffer?\n. Definitely not talking about \"clever\" places to call it but rather if there were other obvious places aside from dispose that we would want to stop buffering. I can't really think of any.\n. I think classList actually exists in all the browsers we care to support by this project.\n. Yep, consistency is good.\nI'd love to move everything to classList, though.\n. perfect.\n. It should theoretically be re-added via the player sizing, but yeah, I agree.\n. Given that we only have a few articles, I feel like that ToC should live in the README.\n. why not default it null? Then below on line 890 you only need to check for truthyness.\n. could we calculate the preciseDuration statically instead of having to re-calculate it every time?\nOr perhaps, we could store it into a preciseDuration after the first calculation.\n. also, var should be declared at the top of the scope :)\n. the var thing? Yeah, it just lines up the names with one (2-space) indent.\n. it's a mishmash of several rules we've been following. Like only declaring vars at the top and using function expressions instead of function declarations.\n. Yep, part of the idea for forking standard to videojs-standard was that we could have it included in all our projects.\n. each of these should be on new lines.\n. we only really care about the random_access_indicator currently, so, I could remove the others if needed.\n. I'm not certain whether this is a good way of doing it. Another idea I have is something like h264Stream.setNextFrameToKeyFrame() or something.\nHowever, this does work.\n. According to szatmary, the RAI means keyrame\n. I moved the H264ExtraData object into its own file instead of having it live inside of h264-stream.js\n. I literally copy/pasted this from the spec :), but yes, sticking with camel case is fine.\n. Purely for completeness. I wanted to parse it out to compare it with other output but we don't really need them here yet (maybe ever) but at least now they'll be in the history.\n. Getter/setter for h264Frame or for keyFrame?\nMy other comment went away when I fixed the test but I said I was thinking about maybe having something like h264Stream.setNextFrameToKeyFrame().\n. Updated to use h264Stream.setNextFrameKeyFrame().\n. when creating a new h264Frame, check to see if it'll be a keyframe.\n. where the function is defined.\n. defaulting nextFrameKeyFrame to false.\n. could it be that you get an endList in a sliding window manifest? In which case, the start range shouldn't be zero.\n. Or would this only come up in the DVR/VOD case only?\n. How do we know that a sliding window has ended, assuming it isn't turning into a VOD playlist?\n. Don't we generate an unminified version of the concatenated file? Why not make it available as well?\n. where is length defined?\n. so, preciseDuration gets subsumed into the new duration calculation stuff?\n. minVideoPts is a function.\n. as is maxVideoPts\n. never mind, I see now.\n. never mind\n. git pull does a fetch followed by a merge, meaning this rebase won't be necessary. That's what it was previously git pull --rebase.\n. why not move this one down below git add CHANGELOG? Then git commit --amend shouldn't be necessary.\n. in this case, do we want to seek to the earliest position or to the \"3 segments behind live\"/\"live point\" position?\n. what about storing seekable end in a variable?\n. I would just do git pull --rebase in the same command.\n. so discontinuityStarts end up being a list of indexes pointing at segments that begin a discontinuity?\n. I thought we don't have preciseDuration anymore?\n. so all this stuff tries to find those overlapping ranges of audio and video durations and take the greatest of them?\n. looks good other than this.\n. I still hate this so much.\n. (The fact that we need to list out all our files, that is).\n. Yes.\n. Yeah, re-add it here and get rid of it in .npmignore.\n. we probably should also see if we can use a DataCue instead of a VTTCue for this.\n. Also, we could use Object.defineProperties here, though that shouldn't hold up this PR:\njs\nObject.defineProperties(cue.frame, {\n  'id': {\n    get: () => cue.value.key\n  },\n  value: {\n    get: () => cue.value.data\n  },\n  privateData: {\n    get: () => cue.value.data\n  }\n});\n. We should still be entertaining but also informative.\n. I'm not sure whether it's safe to use this here.\n. Date.now() is supported in all browsers we care to support. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/now#Browser_compatibility\nNot a blocker.\n. Not a big issue.\n. version got reset. Also, we try to keep the order of properties the same (name, version, description). This may have been fixed in a newer version of the generator.\n. If you rebase against dev, it should fix itself.\n. You could either PR to @tenacex's fork or just make a new PR to this repo.\n. typeof returns a string, so yes. Why not just if (entry.attributes.IV) {...}?\n. If you remove lint from this for now, it won't fail linting. We can then have a separate PRs for the browserification and es6ification and then we can add it back in then.\n. if it's just a local variable and doesn't get exported, it doesn't need any prefix or postfix indicating that it is private. Variables are inherently private by default.\n. qunit requires an assertion.\n. Function#bind is an issue on pages with broken polyfills like prototypejs and mootools.\n. Another question, do audioTracks and videoTracks actually need a reference to the tech inside them? TextTracks do because that's how they update activeCues but TextTracks are also not generally created by hand but via helper methods.\nMaybe only TextTracks need to require techs?\n. js\nQUnit.deepEquals(_.pick(at[0], ['label, 'enabled', 'language', 'kind']), {label: 'English', enabled: true, langauge: 'eng', kind: 'main'});\nor something.\n. no, don't do this :P\n. nah, there's no benefit, at that point, you might as well just drop the if and just do\njs\nthis.sourceUpdater_ && this.sourceUpdater_.dispose()\n. this is because the fullscreenchange bubbles up from the player element to the document and as a way to get around the infinite loop that could be created by listening to it on the player/tech?\n. Also, audioTracks isn't an array but an AudioTrackList object.\n. Ah, carry on then.\n. delete should be avoided as much as possible because it de-optimizes the objects associated with it in the engine, so, unless absolutely required, nulling them out would be best.\n. We heard you like getters so we put a getter inside your getter so you can get while you get\n. Should we just pass the options to each of the methods?\n. or return canPlay.some(Boolean) since maybe and probably would be true and an empty string would be false\n. why not just have this be a list of strings and then in the return statement do a map before the some?\n. I assume this is one with contrib-hls included?\n. why does this need to be a plugin?\n. your code fences are inconsistent, should be lowercase and without a preceding space.\n. Though, apparently, it still works?\n. can we call out explicitly that enabled(true) enables the representation and that enabled(false) disabled it?\n. why not make it a prototype method?\n. should we default id to something?\n. Ranges.findNextRange handles the case where the time ranges are of length zero, so, you could just remove this this if statement.\n. you can't have an array of length less than 0.\n. Not sure, is it possible for it to be called without an id?\n. you could store the playlist on the instance.\n. \ud83d\udc4c \nAlso, what about using videojs.bind instead if native bind?\n. while we're at it, why not change this to defineProperties?\n. window is the default export from global or global/window, does this work? don't we want to do import window from 'global/window'? (or import window from 'global')\n. No strong preference, import window from 'global/window' is nice because that's what we use elsewhere.\n. please use cuesTrack.addEventListener('cuechange' over oncuechange if possible.\n. I've been starting to use es6 in code samples as well when it's reasonable. So, these would just end up being lets. But no strong preference either way.\n. The \"short\" value should be like 0.5s.\nAlso, we might want to consider making these have a start time of 0 and an end time of the cue time. That's what that w3c spec draft recommends for cuepoints.\n. this means that selectPlaylist can only be changed when a source is changed?\n. Yes, but also so that when we're using the emulated text tracks, we don't lose the cue altogether.\n. extra let activeCue;\n. you should use the cloudfront url for this.\n//d2zihajmogu5jn.cloudfront.net/bipbop-advanced/bipbop_16x9_variant.m3u8\n. why not use element.one?\n. Oh, totally missed that. I guess I was focused on less code :P\n. yes.\n. this link to master without a specific revision. If the README changes the url will no longer be valid.. I don't think you need .bind(this). Video.js takes care of that for you.. er, wait, never mind. Ignore me. However, we shouldn't use .bind because it's slow and doesn't run everywhere where we want to run.\nYou should be able to use an arrow function instead.. heh, oops. I think it's ok to do here since it's fairly simple and we're creating metadata tracks.. The track is added automatically inside of addTextTrack.. haha, whoops. if you pass options as the second argument to super, the Component constructor will take care of setting this.options_ correctly.. The general convention we've had is that options is the name of the arguments passed in and settings is the merged options to be used internally. Not sure how consistent we've been in our projects but that was the idea.. Maybe we should just always run npm install \"video.js@$VJS\"?. should there be a test that sets it in the player directly?. would be good to add explanation of default behavior. updating qunit is probably fine.. Video.js couldn't because it had to support IE8 and qunit 2 dropped support for it but contrib-hls never supported IE8.. might as well move the comment to be above the line it comments, too :). we can leave this as deprecated but then archive the repo when it's actually deprecated. ",
    "tomjohnson916": "@dmlap - I talked to @heff on Friday and found out the tag versions of VJS now provide a full dist structure, removing the need for the postinstall hook moving forward. Will remove and set package.json dependency to a tagged version.\n. Per previous conversation with @dmlap \n. Closing in favor of PR #17 \n. Not using this, closing down.\n. The only reason being that I have not noticed the error on anything other than HLS streams. That being said we certainly could add the ended event to the array of listeners in vjs -> loading-spinner.js and that should resolve the issue as well. I brought that up to @mmcc under the issue posted in vjs core.\n. @agask2agask2 - the adaptive bitrate algorithm is handled in the javascript layer and works well in all browsers. The MBR branch was an exploration into additional features for multi bitrate content and is unstable at best. It should not be used at this time and will probably be removed of a more robust plugin in the future.\n. Hey @agask2agask2 - I just pulled up your URL in the example.html sandbox and the video worked. Was there a specific segment you received that error on?\n. Updated SWF reference in the example.html away from the old videojs-swf repo reference, but otherwise works as anticipated.\n. I think this PR covers a lot of ground. One of the things @heff and I discussed on Friday was turning the HLS work into a tech. Haven't reviewed yet, but I would be curious if some of this could be off loaded to the tech level.\n. @gkatsev @BCjwhisenant please review when convenient.\n. Would adding a if player.error().message condition make this backwards compatible? Because pre error api, that would be false and the rest would be skipped, correct?\n. I think this would require the tech conversion. Not sure if that is already merged or not. Otherwise I agree and am in favor of remove seeking in favor of currentTime normalization.\n. Sanity check shows that grunt works and builds without error. not sure what is up w Travis.\n. I agree. this pr was just to get the ball rolling now that the tech work was in master.\n. Yeah #74 was duplicate and already merged so I will close this.\n. Sorry forgot to comment. Looked at this last night and it LGTM as well. \n. @aldricdacast - We did take a look at several alternative implementations, including the mangui swf referenced. However all of them encapsulated more of the process within the swf than we were ultimately comfortable with moving forward. That is not to say they are not well written, personally I think very highly of the mangui alternative. It is just to say that they didn't meet our needs for the VideoJS vision which has a reduction in dependency on the flash layer. \n. Overall this looks good to me. Per comments in hipchat conversation; I disagree with our use of 45 seconds for timeout scenarios in general.\n. @dmlap - CORS?\n. @jsanford-bc - CORS does not appear to be setup. This can be confirmed by curl -XGET - i http://bc-jsanford.s3.amazonaws.com/instant_play_demo/1402004163/index.m3u8 \nThat returns the following headers;\nHTTP/1.1 200 OK\nx-amz-id-2: 14I9fiMW8q5lNkQxeS4XqdgOsDB07ozR0wX991IX5fuRAiTzzVIq7donicxfHeRV\nx-amz-request-id: BE97BF8D7B9D88F7\nDate: Thu, 05 Jun 2014 21:56:56 GMT\nLast-Modified: Thu, 05 Jun 2014 21:36:36 GMT\nETag: \"d9e7529f7643820ac9e6134804ccfd08\"\nAccept-Ranges: bytes\nContent-Type: application/vnd.apple.mpegurl\nContent-Length: 272\nServer: AmazonS3\nWhat you should see in addition are the headers for;\nAccess-Control-Allow-Credentials: true\nAccess-Control-Allow-Headers: X-Requested-With\nAccess-Control-Allow-Origin: *\n. @jsanford-bc - for a positive path example try the following. I know solutions.brightcove.com does have CORS;\ncurl -XGET -i http://solutions.brightcove.com/jwhisenant/hls/brightcove/fishtank/16x9-fishtank-master.m3u8\nAlso, just an FYI as to why Safari plays it but Chrome does not; HLS is natively supported in Safari so the player is not using the XHR requests of this plugin and therefore does not require CORS.\n. I'm not the right resource for S3 configurations unfortunately. That being said, I'm confident that is the root of your playback issue.\n. Hey Justin - I am going to take a look at this and see what I can find. I do a curl on that new URL and get the required headers.\n. I also think it should ONLY do HLS.\n. A similar implementation as @heff recently did in his DASH.js tech work. Much cleaner syntax on the player.\n. @dmlap - This looks good to me. I had tried implementing something similar at the onset of our live development cycle, but it looks to have not made it in.\n. LGTM.\n. LGTM. I like the unshift v push\n. LGTM other than the VJS reference in package.json.\n. updated a fix for @rdabreo request.\n. +1. Concerns noted in conversation, otherwise LGTM. Looks like this was quite a bit of effort.\n. I had an old PR #42 for achieving this. We may want to revisit.\n. @sblandford - Based on a curl request for your stream, I did not see any CORS headers. However it does appear you have an open crossdomain.xml off the domain root. This probably explains why your stream works with the new swf.\n. LGTM\n. I believe zero duration segments is outside the HLS specification. CDNs also have segment minimum durations, so I don't know of any non-proprietary real world scenarios where this would be encountered. @heff / @gkatsev thoughts?\n. @gkatsev - I'm not sure who you are asking, but the only use case I can remember zero second segments being used is as a cue point type placeholder system for stream stitching. I've seen similar concepts, but the placeholder segments were replaced with full segments of differing content prior to player decode/playback. Even then, these were not industry standard solutions and were generally proprietary one-offs (which it sounds like @jtennen case is also).\n. Fixed per PR #173 . Closing.\n. @gkatsev approved.\n. @heff - I don't know that we ever actually seek inside the SWF. When we set currentTime in the tech I thought we purged the buffer, grab the new content, and force it in/ update time values. If that is correct, I would say we should fire seeking in the tech.\n. We may want to look at doing an 'in buffer' seek where we calculate if the seekTarget is within the buffered range then netstream.seek to that value else standard purge/grab/set routine. Just a thought.\n. There is a known issue with videojs and node <0.10.11 that I ran into, so I started making this a requirement.\n. http://stackoverflow.com/questions/16769772/node-js-crashes-when-serving-video-file is where i found the root of my problem a while back.\n. so it can be overridden in a cleaner fashion by anything built on top of this plugin. the sourcebuffer.addEventListener for 'update' works also, but fires a lot of times each segment.\n. https://github.com/brightcove/videojs-mbr/blob/master/src/videojs-mbr.js#L56-L70\n. line #478 encapsulates this behavior. it was being duplicated and it needs external reference on switching of indexes.\n. https://github.com/brightcove/videojs-mbr/blob/master/src/videojs-mbr.js#L77\n. this is for first play only. per player.js instructions it should be player.one.\n. @gkatsev - Should this be pushed back to non-dev version?\n. I don't understand this line. What value is merging an empty object with player.options().hls over just making settings = player.options().hls here?\n. Ah ok, thx.\n. This commented out stuff needed?\n. Commented items (see above).\n. whitespace!\n. extra console\n. I like the use of an array here versus the count integer vars we are using in other plugins.\n. +1 abortTimeout\n. Should this be pointed here?\n. I certainly could be wrong on this, but I thought end of stream calls executed when the final buffer data was emptied, not necessarily when it was loaded. If I've read this correctly an example would be if the stream were paused immediately prior to actually ending [i.e. empty buffer], but were in the final media index; then this would fire yet the stream itself would not have finished.\nAnother issue I could potentially see with this implementation is plugins that are triggered on 'ended' firing before the stream playback has finished. End caps, related content screens, analytics, etc.\n. Got it, thx.\n. @dmlap - https://github.com/videojs/videojs-contrib-hls/pull/121\n. @rdabreo - the return type is listed here\n. Are we ok with adding this external dependency to our HLS solution? I understand there may not be a choice just asking/noting.\n. For the example page, I personally think the default stream should remain bip bop vs. an Oceans encrypted stream. It's a valid example, just a minority for those downloading the project as a whole. Just my opinion.\n. See above comment re external dependency.\n. Very nice work here.\n. May want to check w legal on this.\n. ",
    "bclwhitaker": ":confetti_ball:\n. Yes. And the encryption is based on the github path.\n. Was this limited to live only?  Feels like we would want it to throw if it was a VOD playlist?\n. :dragon:\n. In addition to the CORS issue, this particular manifest has carriage returns and line feeds on each line.  This was causing the manifest parser not to match the EXTINF tags and thus failed to parse out any segments.  I just opened a pull request which should address the carriage return issue.\n. :convenience_store:\n. @gkatsev thanks!\n. :+1: \n. LGTM\n. The video.js Flash swf updates the buffered progress on the control bar without this line.  \nWhen the video was looping, I recall that updating progress here was causing the buffered progress not to be correct (i.e. it wasn't extending all the way to the end of the video even though it had buffered it all). As a result, the playback scrubber would pass the buffered area without actually buffering making the buffered region representation unreliable.\n. I think that definition assumes that downloading it means its added to the buffer, which in this case isn't true until its sent to the swf.\n. LGTM\n. is it worth adding another shift()() and then assert that the callbacks.length is 0? i.e. that tasks will run to empty as the test name implies?\n. Yay npm!\n. just links to docs folder?\n. Yes, it was.  Most of this logic has now been moved into the mediaSources project via https://github.com/videojs/videojs-contrib-media-sources/pull/24\n. progress events are already firing from videojs because the bufferedPercent is changing.  Since all the other changes in this pull has been moved into mediaSources I opened a separate pull request to remove just this event #252.  Firing progress here was sometimes causing the buffered region in the player to misreport.\n. audio-only\n. Would it make sense to add an || 1 here?\n. ditto\n. would be nice if all the descriptions were updated to match the new property too\n. ",
    "BCjwhisenant": "LGTM too - pulled the branch down into socrates and gave it a spin in Firefox and Chrome OSX, and IE10.\n. Also, is there a way to chain the browsers you want to run, a la:\ngrunt karma:chrome,firefox,safari\n?\n. @agask2agask2 Can you supply a URL to a manifest?\n. The reason is that 9x9ch1.goodtv.org needs to have CORS headers enabled for both m3u8 and ts file requests. This is how the plugin requests these types of assets.\nThere are many good resources online that talk about configuring CORS headers, among them:\nhttps://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS\nhttp://www.html5rocks.com/en/tutorials/cors/\nand\nhttp://docs.brightcove.com/en/video-cloud/concepts/cors/cors.html\n. manifest.frm is actually manifest.f4m\n. This should be player.on.\n. ",
    "forbesjo": "This currently works in master if your video starts with the audio only rendition then switches up, this will not work with the new multiple audio track feature work because we are creating both audio and video source buffers early and browsers don't allow for switching source buffers after the fact. We might fix this in the future if the browsers start behaving.\n. This is probably fixed with all the MSE changes and other changes over the years.\n. It looks like the dist folder is missing from npm/the latest github tag which should include the combined videojs-hls.js file and the minified version. The getting started section also does not direct users to use the files in the dist folder or how to build it locally using grunt. I also agree that this plugin should be on a CDN if it would help people get set up faster.\n. Getting started and the deploy process are updated to handle this problem\n. I think it fires now.\n. We plan on only supporting npm for our plugin projects, we don't plan on supporting bower specifically.\n. This is very done\n. Closing, if this is still an issue in the latest version let us know! Thanks\n. See my comment here https://github.com/videojs/videojs-contrib-hls/pull/214#issuecomment-158205285 could you update your PR?\n. We've done a lot of refactoring, could you open a PR against mux.js? Sorry about taking so long to get back to you.\n. We think this is fixed with HLS 1.0, could you test this in the development branch?\n. Is this still an issue for anyone in the thread? \n. We believe this is fixed, if this is still a problem with the latest version please let us know!\n. Is this still an issue?\n. You should probably make every segment a discontinuity if you want to do this.\n. This looks fixed, closing.\n. We believe this is fixed in the latest version, if anyone else sees this issue please let us know!\n. :+1: \n. Is this still an issue?\n. Is this still an issue?\n. LGTM\n. :+1: \n. See https://cdnjs.com/libraries/videojs-contrib-hls\n. :+1: \n. LGTM\n. Moved to VHS. Closing since this plugin should be on npm.\n. Closing this as it is not present in the video.js 5.0 update\n. :+1: \n. Issue is fixed already, closing.\n. I'm seeing failing tests with the latest master HLS code, maybe something changed with a dependency?\n. Could you reopen this PR against the development branch, we've done major changes that may make this enhancement incompatible. Also, this request isn't totally clear for us, could you expand upon why this is important to you?\n. Closing due to inactivity, going to open an enhancement issue in VHS to allow built-in DVR. Should be fixed in the development branch.\n. @imbcmdth thoughts? We already have audioTracks\n. Closing, if you are still having problems please open a new issue\n. If this is still an issue could you open a PR/issue against mux.js?\n. Is this still an issue?\n. This calculation is totally redone for contrib-hls 1.0, could you see if this issue still exists in the development branch?\n. We won't be making anymore changes in master at this time unless they're critical. Could you please open a new PR against development?\n. We are currently working on this, stay tuned! :tv: \n. I see the error as well but the video does load for me on OS X and Windows 10.\n\n. 41.0.1 and I just installed it on my Win 10 machine\n. This plugin does require flash to be installed (I didn't have it installed on my initial test on Windows 10)\n. I believe it will fall back to the mp4 version (given you provide one) instead of prompting the user to install flash. I'll see if there are any video.js issues that discuss adding a prompt for flash. \n. Could you provide more information for us to debug?\n. I'm not seeing any issues with the posted sources, closing since this seems to have been addressed.. Please reopen if this is still an issue\n. We won't be making anymore changes in master at this time unless they're critical. Could you please open a new PR against development if the same issue exists there?\n. Closing since the dailymotion issue has been closed. Please reopen if this is still an issue\n. Is this still an issue? If so please reopen.\n. Looks like IE11 Win 8.1 and IE11 Win 10 have different behaviors? IE11 on Win 10 skips the first 10 seconds. @KatrinaE did you see the issue on Win 10?\nIE11/Win8.1\n\nIE11/Win10\n\n. Is this still an issue?\n. Closing \n. It would be great if this could be opened as a new PR against development.\n. This seems to fix #465 \n. Closing, thanks for the issue\n. Closing since this has been resolved\n. Looks good to me.\n. If anyone is still having this problem please comment and I'll reopen, this should be fixed.\n. With Flash slowly dying, especially in Chrome, we will not be implementing this fallback feature. . This is probably fixed, if not please reopen\n. This should be handled in VHS (next major version) now. I'm able to play and hear the posted source with the latest version of this plugin, closing since this seems to be addressed.. This is similar to this issue (https://github.com/videojs/videojs-contrib-quality-levels/issues/13), the resolution was to listen to the addqualitylevel event because player.qualityLevels() is not populated yet. We will update the repo's instructions for clarity.. We tested this on the advanced player page at http://videojs.com/advanced/ switching with the sintel HLS source and ended fired both times. Is this still an issue, if so could you provide a reduced test case?\n. Is this still an issue?\n. @imbcmdth do you think we should bring this in?\n. Is this still an issue with https://github.com/videojs/http-streaming? That version of this project uses a different method for creating webworkers. We've added a lot of fixes related to gaps, is this still an issue when using the latest version?\n. This should be working, here's an example\n``` js\nvar videojs = require('video.js');\nrequire('videojs-contrib-hls');\nvar videoEl = document.createElement('video');\nvideoEl.id = 'vid';\nvideoEl.setAttribute('controls', '');\nvideoEl.setAttribute('width', '600');\nvideoEl.setAttribute('height', '300');\nvideoEl.className = 'video-js vjs-default-skin';\ndocument.body.appendChild(videoEl);\nvar player = videojs('vid');\nplayer.ready(function() {\n  player.src({\n    src: '//d1sh0fycs31s5a.cloudfront.net/eleph/index.m3u8',\n    type: 'application/x-mpegURL'\n  });\n});\n``\n. Closed by #819 \n. Closing since https://github.com/videojs/video.js/pull/3223 will have the button in the player itself\n. Is still an issue?\n. This was a regression in one of the recent versions of Chrome. The problem is not caused by contrib-hls.\n. @imbcmdth what are your thoughts?\n. We are in the midst of a massive change to the segment fetching portions of contrib-hls. These changes might fix your issue. Stay tuned! :tv:\n. Closing due to inactivity, if this is still an issue please open against https://github.com/videojs/http-streaming/issues. Could you provide a reduced test case?\n. Thanks for the quick reply, I'll close this issue for now and it can be reopened when necessary.\n. Yes, we are currently working on it. Stay tuned!\n. Looks good to me.\n. Moved to the VHS (next major version of this project) issues. Right now we need to keep the way it is for backwards compatibility. However, we may look into a different way of exposing these components in a future version.\n. Could you post another test page, it looks like the link is gone.\n. This is fixed, closing\n. I'll just removedist-testandutils(20mb) in this PR.\n. Could you add a check for responseURL to handle IE?\n. Could you add a check for responseURL to handle IE?\n. I'm unable to reproduce this issue, if it's still happening for others please link a source (or a video of the video playing too fast)\n. Please reopen if filling in the missing audio samples didn't work.\n. Looks good to me.\n. Is this still an issue with the latest version? If so could you post a stream?\n. Fixed by https://github.com/videojs/videojs-contrib-hls/pull/788\n. Looks good to me.\n. How is your player set up? Are you using Browserify? Everything seems fine with this simple example https://jsbin.com/yoxekofunu/edit?html,output\n. Looks like the freezing is caused by video underflow, #774 fixes this. Closing\n. Looks good to me\n. @dmlap I believe you were working on a PR for this?\n. Closing, in progress at #829 \n. Looks good to me \n. LGTM\n. Looks good to me\n. looks good to me \ud83d\udcfa . We tried your steps to reproduce the issue but are not able to see what you are describing, if this is still an issue could you provide a demo player or source?\n. Should be fixed now with v3.6.12\n. Does the end of your stream have the#EXT-X-ENDLISTtag? If so you should not encounter this kind of error and the stream should revert to VOD behavior. If your stream does end with this tag then this is a bug.\n. Thank you for your PR but we will not be accepting new changes for this repo and will be [archived](https://help.github.com/articles/about-archiving-repositories/) very soon. I would advise you to open your PR against the next iteration of this project at https://github.com/videojs/http-streaming.. Looks good to me\n. Could you provide a reduced test case or sample live stream that is causing the issue?\n. Sounds resolved\n. I'll open PRs against the HLS projects with^5.0.0after the video.js linting process has finished up\n. If this condition is encountered in a master-playlist with multiple media-playlists, we will blacklist the currently playing media-playlist and switch to another. In this case, there are no other renditions or media-playlists, and the blacklist logic triggers the error. This is as designed.\n. I'm seeing it select the 720p playlist, is this still an issue for you?\n. Could you provide a source that is causing this issue for us to debug? Thanks\n. Closing due to inactivity, if this is still an issue please open against https://github.com/videojs/http-streaming/issues. Moving to VHS. @javadi69 Firefox should support AAC audio. We are not sure exactly what is going with your encoding settings. We can't provide support for using FFMPEG to generate HLS because that is outside the scope of this project.\n. Could you provide an example source that demonstrates this issue for debugging, thanks!\n. Looks like this is fixed in Chrome 53\n. @gesinger check out https://d2zihajmogu5jn.cloudfront.net/bipbop-advanced/bipbop_16x9_variant.m3u8 and see if this fixes it\n. Could you provide more information about your player or post an example?\n. Closing because of inactivity\n. @ColdHeat does your stream start with combined audio/video and proceed to have segments with one or the other but not both?\n. @Poordeveloper This looks to be an unrelated issue, could you open as a separate issue.\n. I've published version 1.1.1 of aes-decrypter that reverts the changes between 1.1.0 and 1.0.3, this should fix your issue. The changes in 1.1.0 are now part of 2.0.0\n. The aes-decripter built into the videojs-contrib-hls dist file is 1.0.3 so you shouldn't have this problem if you're using that. If you're using browserify it'll automatically pick up 1.1.1 because it's in our semver range.\n. Fixed by #818 \n. Yes it does fix that issue\n. Does your VM have Flash installed?\n. Closing since this only seems to be a problem in jsbin and not in a real page\n. @imbcmdth we should add a property to representations() that indicates if a representation is blacklisted\n. Thanks glad it worked out :+1:\n. Closing since this is in progress\n. We're currently looking into enabling MSE-based HLS over native functionality in certain browsers in order to work around the browser's various quirks to maintain consistent behavior across platforms. We're still in the process of investigation. Please keep an eye out for this change.\n. A quick way to prioritize contrib-hls over native is to remove thesupportsNativeHlscheck in https://github.com/videojs/videojs-contrib-hls/blob/master/src/videojs-contrib-hls.js#L681 and modify https://github.com/videojs/videojs-contrib-hls/blob/master/src/videojs-contrib-hls.js#L695 tovideojs.getComponent('Html5').registerSourceHandler(HlsSourceHandler('html5'), 0);` which will put contrib-hls first in the HTML5 sourceHandler list.\nNote that you may have to load your video source with player.src() and not use a source element.\n. We now use a purely javascript resolver (https://github.com/tjenkinson/url-toolkit) so this should no longer be an issue. Would you be able to link your stream so we could debug? Thanks\n. LGTM\n. LGTM\n. We may have a fix for this, stay tuned :movie_camera: \n. Looks good to me\n. LGTM\n. We may have a fix for this, stay tuned :tv: \n. LGTM\n. This appears to be a browser bug that was fixed with Chrome 53, closing since it is out of our control\n. Looks like you're using an older version of video.js that doesn't support the audio track API, please try video.js 5.10.1+. https://github.com/videojs/video.js/blob/master/CHANGELOG.md#5101-2016-05-03\n. HLS is supported natively on Safari so in that scenario this plugin is automatically skipped by video.js's source handler selector. It looks like Safari can't handle looping HLS videos (see http://jsbin.com/gabiqedumi/1/edit?html,output)\n. Closing since this is a native bug\n. LGTM\n. In VHS you'll want https://github.com/videojs/http-streaming#hlsstats. lgtm\n. We have a fix for this in the works and will release shortly\n. This might actually be a different issue than I initially thought, could you provide an example source?\n. If you take a look at the demo page at http://videojs.github.io/videojs-contrib-hls/ you'll see a code snippet that includes the video.js library and this plugin which enables HLS playback on non-Safari browsers. Basically all you need to do is provide your HLS source either using a source element or calling player.src(yourSource), video.js will automatically select HTML5 or Flash playback depending on the browser's capabilities. . LGTM\n. Looks good to me.\n. We'll investigate and make it error out in the correct way.\n. Need to update the README to document this feature\n. LGTM\n. LGTM aside from Garrett's comment\n. (ignore my approval, I was messing around with the github review feature and clicked the wrong thing)\n. LGTM\n. Pulling over the tests\n. Looks like this has been handled by #1213, closing. LGTM. Thank you for your PR but we wont be adding this setting at this time since there doesn't seem to be much demand.. Try https://d2zihajmogu5jn.cloudfront.net/advanced-fmp4/master.m3u8. This seems like an unusual use case, if you would like to break the timeline of segments you'll have to indicate this with a discontinuity tag. The reason why Chrome and Safari are behaving differently is because the native HLS playback in Safari is probably just appending the segments while the MSE playback in Chrome is overwriting the segment in the timeline position.\nWe believe that the Chrome behavior is preferable.. Moving this enhancement request to VHS. Would you be able to provide a sample source to debug? Also I would recommend disabling the native audio and video track APIs with:\njs\nvar player = videojs('player', {\n  html5: {\n    nativeAudioTracks: false,\n    nativeVideoTracks: false\n  }\n});\nhaving these options on may cause conflicts.. Moving this enhancement to VHS. LGTM. Looks like uglify has --screw-ie8 as true by default now which is unquoting reserved keywords in IE8. I'll add --support-ie8 to our uglify step. Thanks for catching this!. This will be fixed in the next version (#971). This no longer seems to be an issue, most likely due to IE11 MSE fixes we've made. Closing.. Some further information: IE11 on Windows 10 and 8.1 does support MSE so this plugin will by default not fall back to Flash playback.. Looks good to me. LGTM too, merging. When I run the tests with vjs 6 many fail saying IS_FIREFOX is read only and cannot be reassigned. One suggestion but otherwise LGTM. This is currently in progress in https://github.com/videojs/http-streaming. Moved to VHS. Thank you for your PR but we will not be accepting new changes for this repo and will be archived very soon. I would advise you to open your PR against the next iteration of this project at https://github.com/videojs/http-streaming.. This may be related to this known issue https://github.com/videojs/videojs-contrib-hls#ie11. @gesinger I think we should update the known issue note with something like \njs\nif ((/Trident\\/7.0/i).test(USER_AGENT) && (/rv:11.0/).test(USER_AGENT)) \n  videojs.options.hls.mode = 'flash';. videojs.browser.IE_VERSION can be used to detect IE11, in the future we'll be making this override easier. . It looks like you're using pretty old versions of contrib-hls and video.js. I can see that this source works with the latest versions when loaded into http://videojs.github.io/videojs-contrib-hls/\n\n. Looks good to me (once tests pass). @BrandonOCasey do you remember in what scenario the ad tag track already exists before a source is loaded? . Thank you for your PR but we will not be accepting new changes for this repo and will be archived very soon. I would advise you to open your PR against the next iteration of this project at https://github.com/videojs/http-streaming.. Could you open this issue against https://github.com/videojs/videojs-flash? This would apply to all video formats that use Flash for playback.. This needs to wait until https://www.npmjs.com/package/video.js latest is 6.0. Moved this to VHS. Have you tried using this source https://d2zihajmogu5jn.cloudfront.net/bipbop-advanced/bipbop_16x9_variant.m3u8 ? The source in the jsbin no longer exists. Confirmed that this is still an issue. Moved to VHS. Let's open this against VHS. Closing and opening against VHS in the future. Is this still an issue after Chrome updates and updates to this project? If so we'll reopen and investigate. Done, closing. Closing since there's a PR open. cc @zhuangs . We'll be looking to migrating this feature to VHS. See issue https://github.com/videojs/http-streaming/issues/116 for tracking. Thank you for your PR but we will not be accepting new changes for this repo and will be archived very soon. I would advise you to open your PR against the next iteration of this project at https://github.com/videojs/http-streaming.. Let's open this against VHS. @gkatsev what are your thoughts on plugins using local storage? Should there be a common API provided by video.js or should the plugins do this directly?. Looks good to me. This issue seems to have a combination of different backend related issues going on, if anyone is still having a problem with their stream please open a new issue.. See https://github.com/videojs/http-streaming. Moving this enhancement to VHS. In order to use fmp4 segments in Edge and Android Chrome please override the native HLS functionality with https://github.com/videojs/videojs-contrib-hls#overridenative. Yes we would continue to defer to native playback on Safari. We have not seen problems with this setup on other browsers. . I would suggest using !videojs.browser.IS_ANY_SAFARI. Closing this since video.js should shim the vttcue automatically and the original issue is fixed by using the withCredentials option\nBut thank you for the PR!. Should this just get combined with #984?. Thank you for your PR but we will not be accepting new changes for this repo and will be archived very soon. I would advise you to open your PR against the next iteration of this project at https://github.com/videojs/http-streaming.. We'll update this PR with tests.. Thank you for your PR but we will not be accepting new changes for this repo and will be archived very soon. I would advise you to open your PR against the next iteration of this project at https://github.com/videojs/http-streaming.. For testing the advanced bipbop test stream can be used. The English caption track has \"English subtitle 15\" across two vtt files. This fixes #1185. Thank you for your PR but we will not be accepting new changes for this repo and will be archived very soon. I would advise you to open your PR against the next iteration of this project at https://github.com/videojs/http-streaming.. Closing due to inactivity, if this is still a problem please let us know.. This plugin defers to native HLS playback if it's available, if you would like smoother playback please override the native functionality https://github.com/videojs/videojs-contrib-hls. Putting this in the VHS backlog\n/move to http-streaming. Thank you for your PR but we will not be accepting new changes for this repo and will be archived very soon. I would advise you to open your PR against the next iteration of this project at https://github.com/videojs/http-streaming.. Currently the player will show a source not supported error, this is because the user agent for the Nokia Lumia 520 (Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 520)) indicates that it's IE10 which we have dropped support for. Due to the decreasing support for Windows phones we may not consider fixing this issue.\nPlease let us know if this support is still desired and we'll consider it for the VHS project (the next major version of videojs-contrib-hls). Looks good to me. We'll add the caching to #1322, @gesinger could you add this to your PR? Here's the related blog post https://blog.travis-ci.com/2013-12-05-speed-up-your-builds-cache-your-dependencies/. Could you share a jsbin of your code for debugging?. I do not see an issue in the latest version of the project, please let us know if this is still an issue. videojs-contrib-hls requires MSE in order to work and Android 4.4 is the earliest version with MSE support. Is your Samsung S3 on 4.4? Also Safari on iOS does not support MSE. Chrome for iOS uses WKWebView so it's basically Safari. . Thank you for your PR but we will not be accepting new changes for this repo and will be archived very soon. I would advise you to open your PR against the next iteration of this project at https://github.com/videojs/http-streaming.. You can let the player preload segments by using the auto preload setting and you should be able to see the buffered time range with player.buffered(). Thank you for your PR but we will not be accepting new changes for this repo and will be archived very soon. I would advise you to open your PR against the next iteration of this project at https://github.com/videojs/http-streaming.. I do not see any problems with using an emulated Pixel 2 or Galaxy S5. If this is still a problem please let us know. #600 is fixed, closing. This is related to https://github.com/videojs/videojs-contrib-hls/issues/1435, closing this in favor of the other issue. Moving this to VHS and we can fix this initial playlist selection logic there\n/move to http-streaming. You may need sudo: required. Deleted my comment because I ran my commands against videojs-http-streaming and not this project. Currently testing this PR against a couple of sources and will merge shortly.. Thank you for your PR but we will not be accepting new changes for this repo and will be archived very soon. I would advise you to open your PR against the next iteration of this project at https://github.com/videojs/http-streaming.. Thank you for your PR but we will not be accepting new changes for this repo and will be archived very soon. I would advise you to open your PR against the next iteration of this project at https://github.com/videojs/http-streaming.. \nIs the square ratio what you're referring to as cropping? If you load the source in QuickTime you'll see that the source itself is square. Thank you for your PR but we will not be accepting new changes for this repo and will be archived very soon. I would advise you to open your PR against the next iteration of this project at https://github.com/videojs/http-streaming.. We are currently thinking of ways to stop the m3u8 refresh when it is unnecessary so this at the moment is a known issue. This change looks good to me save for the big package-lock changes. Thank you for your PR but we will not be accepting new changes for this repo and will be archived very soon. I would advise you to open your PR against the next iteration of this project at https://github.com/videojs/http-streaming.. Thank you for your PR but we will not be accepting new changes for this repo and will be archived very soon. I would advise you to open your PR against the next iteration of this project at https://github.com/videojs/http-streaming.. Here's a snippet for setting up overrideNative https://github.com/videojs/http-streaming#overridenative. We've recently made a fix for live stream disconnects, is this still an issue for you in the latest version of video.js? Video.js 7 now includes HLS playback by default and includes https://github.com/videojs/http-streaming which is the next version of this project.. It looks like your test page uses the hls.js library for HLS support via videojs-contrib-hlsjs, is this correct?. I believe this project specifically won't preload live content so that the initial play always starts at the live edge and to reduce bandwidth from segments that may not be used.  . We'll consider providing a way to preload live streams in the next major version of this project at VHS (https://github.com/videojs/http-streaming), closing this and opening an enhancement there. Thanks for the PR, would you mind adding documentation for this option to https://github.com/videojs/videojs-contrib-hls#list and a test?. Thank you for your PR but we will not be accepting new changes for this repo and will be archived very soon. I would advise you to open your PR against the next iteration of this project at https://github.com/videojs/http-streaming.. - [ ] Add a warning for npm install to point to VHS. I would suggest using https://github.com/videojs/http-streaming (if using videojs 6.x) or just videojs 7 alone, those are more compatible with webpack. Thank you for your PR but we will not be accepting new changes for this repo and will be archived very soon. I would advise you to open your PR against the next iteration of this project at https://github.com/videojs/http-streaming.. Hey sorry we haven't looked at this issue for a while, is this still an issue for you? If so you'll have to update your test page for debugging. Thank you for your PR but we will not be accepting new changes for this repo and will be archived very soon. I would advise you to open your PR against the next iteration of this project at https://github.com/videojs/http-streaming.. It looks like you're encountering Chrome's new autoplay restrictions, we have a blog post that details ways for you to deal with these restrictions http://blog.videojs.com/autoplay-best-practices-with-video-js/. It looks like videojs-resolution-switcher doesn't support videojs-contrib-hls which is why you're not seeing the quality menu. You'll have to build your own quality menu UI using the videojs-contrib-quality-levels API or open an issue in videojs-resolution-switcher for that feature.. There is a lot going on in your web page and it will be difficult to debug your issue. Could you include a reduced test case, we have a starter template on JSBin.. Thank you for your PR but we will not be accepting new changes for this repo and will be archived very soon. I would advise you to open your PR against the next iteration of this project at https://github.com/videojs/http-streaming.. I'm not able to reproduce the autoplay then stop behavior in Chrome 67, it just completely blocks autoplay for me (as expected). Would you be able to provide us a sample stream to debug?. Would you be able to provide an example jsbin of your player for debugging? Here's a template (http://jsbin.com/vokipos/8/edit?html,output). @benwilber are you still interested in this feature?. Thank you for your PR but we will not be accepting new changes for this repo and will be archived very soon. I would advise you to open your PR against the next iteration of this project at https://github.com/videojs/http-streaming.. To override native HLS playback you'll want this as your player constructor options:\njs\nvar options = {\n  html5: {\n    hls: {\n      overrideNative: true\n    },\n    nativeAudioTracks: false,\n    nativeVideoTracks: false,\n  }\n};. You may want to try loading the source with player.src(sourceObj), perhaps the native video element is picking up the source element and bypassing this project. I'd like to err on explicit options so a user can see everything at a glance. Would you be able to provide a source for us to debug this issue? Thanks!. According to the spec If an EXT-X-STREAM-INF tag or EXT-X-I-FRAME-STREAM-INF tag contains\n   the CODECS attribute, the attribute value MUST include every media\n   format [RFC6381] present in any Media Segment in any of the\n   Renditions specified by the Variant Stream.\n@gesinger what are your thoughts about going beyond the spec?. Closing since this looks to be answered. Thank you for your PR but we will not be accepting new changes for this repo and will be archived very soon. I would advise you to open your PR against the next iteration of this project at https://github.com/videojs/http-streaming.. As @gkatsev noted the stereo and surround audio groups are associated with specific rendition playlists so there isn't a way to switch between the two. Each group has an alternate track so you will see a choice of en or dubbing. This is also how native HLS playback behaves in Safari.. Do you see this issue in http://videojs.github.io/http-streaming/ ? Could you provide clarification for what you're seeing in IE11? Is the program freezing or not responding?. We use the native player on iOS Safari so you may be experiencing a problem due to content misconfiguration. Do you see any console errors?. Closing due to inactivity . That's expected behavior, please see https://github.com/videojs/http-streaming/blob/master/docs/troubleshooting.md#network-requests-are-still-being-made-while-paused. Looking into enhancing grunt-protractor-runner so that it will automatically do this on install or with an option in the task.\n. grunt test will run the end-to-end tests.\n. Would browserify make this simpler?\n. Why don't shouldn't the dist just live on npm?\n. I've added a story to our backlog to come back to this code later and figure out a way to do this without accessing private properties.\n. Change this back to the previous video source.\n. It's been decided that this should not be exposed as a plugin since it is not going to be used by any other projects soon.\n. Could you add some new lines to these tests? It's difficult to read.\n. Unnecessary new line.\n. No need to move this.\n. Missing ../..\n. Shouldn't we add the browserify command to the build scripts as well?\n. Ignore my comment, npm start will handle this\n. Same as my above comment, npm start will handle this\n. I'm just disabling temporarily in order to get karma to run. When the linting issues are resolved I'll rebase and remove the commit.\n. Yes\n. I'll do that, just did a quick copy/paste of autoplay\n. By that I mean videojs.options.hls.overrideNative = overrideNative === 'on'\n. I want the function to fire when the targeted event is triggered and a certain condition is met. Using one will just remove it the first time the event is fired.\nFor example, I use this with timeupdate and some target time.\n. That's what I get for copy/paste\n. currentSource_\n. currentTime, buffered\n. Looks like we're doing the same thing for falling out of the live window, maybe the logic should be combined.\n. qunit will automatically reset the fixture it provides https://qunitjs.com/cookbook/#keeping-tests-atomic\n. I'll update Qunit\n. https://github.com/apsdehal/qunit-migrate might be useful for the other projects that are going to update qunit.\nNever mind, this doesn't really work well with ES6\n. We might want to suggest this plugin first. This should be removed. Can't useBandwidthFromLocalStorage do both?. This will pick up video.js@6 in videojs-flash and never install video.js@6 at the top level. Perhaps instead use npm list video.js --depth 0 . Sounds like the simplest course of action. Might want to use in-publish so this doesn't run on npm install. We'll want this added to the README eventually. This pattern runs build:js and build:test in parallel, it will ignore the third level\nSee https://github.com/mysticatea/npm-run-all/blob/master/docs/npm-run-all.md#glob-like-pattern-matching-for-script-names . Yep will do. I'll move these down to their appropriate if blocks. doh. At least the tests caught it. You can remove node_js: since this is already defined in the .nvmrc. Should we still let GK keep updating the qunit and sinon dependencies? . I would suggest deregistering the plugin if it exists so players would get the \"newer\" version of the plugin. ",
    "paruls": "new PR with travis fix\n. @heff  it uses the old one for now, I believe Jackie is in the works of getting an enterprise account set up. I also tried to encrypt everything so I believe there's no exposure\n. @gkatsev  it's set up, for now, to be grunt karma:chrome for local. If you wanted more you would do grunt karma:chroma karma:firefox. You could also use grunt karma:dev which runs all local browsers. \nFor saucelabs, it's grunt karma:saucelabs \n. Had to create a new PR for this. I integrated the changes into doce/live.md in https://github.com/videojs/videojs-contrib-hls/pull/56\n. ",
    "agask2agask2": "here is the video im trying to stream    https://s3.amazonaws.com/MichaelandLeann/Back2Basics/Chapter2/MasterChapter2.m3u8  \n. also while im in here does the adaptive bit rate work well in all browsers with flash? or do i need to get that MBR branch to do that?\n. ## thanks for the quick replies guys,  so i just have the one issue above then.\nUncaught RangeError: Offset is outside the bounds of the DataView flv-tag.js:293\nfinalize flv-tag.js:293\nself.getNextTag segment-parser.js:143\nsegmentXhr.onreadystatechange videojs-hls.js:591\n. around 7 i think..  and if i skip around i get the red errors occationally..\n2m7\nlet it run for a bit and then i noticed the errors...  \nDate: Tue, 25 Mar 2014 07:40:38 -0700\nFrom: notifications@github.com\nTo: videojs-contrib-hls@noreply.github.com\nCC: agask2@hotmail.com\nSubject: Re: [videojs-contrib-hls] HLS Range Error in flv-tag.js (#32)\nHey @agask2agask2 - I just pulled up your URL in the example.html sandbox and the video worked. Was there a specific segment you received that error on?\n\u2014\nReply to this email directly or view it on GitHub.                  \n. check it its around the 2meg number 7. i turn on console profiler in firefox and chrome and get the same\nhttp://usagrandnationals.com/videojsvod/index2.html\n. any luck on this around 2meg number 7 \nhttp://usagrandnationals.com/videojsvod/index2.html\n. i just noticed this happens alot on full screen when i skip.. etc..\nRangeError: argument 1 accesses an index that is out of range\nthis.view.setUint32(this.length, this.length);\nusing firebug console i can see it\n. to clarify if someone copied our hls url we don't want them to be able to simply use that some where..\n. ",
    "CodingFabian": "I  am seeing the same error on some segments:\nUncaught RangeError: Offset is outside the bounds of the DataView videojs.hls.js:961\nfinalize videojs.hls.js:961\nself.getNextTag videojs.hls.js:1980\n(anonymous function) videojs.hls.js:577\nrequest.onreadystatechange\nthe line in question is \nthis.view.setUint32(this.length, this.length);\n. length is 16382 in the case where it fails for me.\nthis.bytes = new Uint8Array(16384);\n  this.view = new DataView(this.bytes.buffer);\nthis means that the length is a 4 byte int, which should go to pos 16382,16383,16384 and 16385. But the buffer only has 16384 spots making the last index 16383.\nI dont understand the logic (yet) but it seems that either the buffer is to small, the length is to long, or the position is wrong.\n. After looking at some commits @dmlap has fixed similar problems by growing the array.\nI monkeypatched a  prepareWrite(this, 4); just before line 961 and it then worked fine.\nI assume there is a better place to do that, maybe some of the buffer size calculations are off by 2?\n. #66 has nothing to do with it.\nif i change goalBufferLength, some testcases fail because they have a hardcoded ssumtion that goalBufferLEngth is 5\n. i just created a PR which allows setting the value of goalBufferLength as hls tech option. it solves my requirement and looks to be a useful option. I am not sure about the naming conventions. let me know if i need to update the PR.\n. the main reason for us was not adaptive switching, but that the loading usually started late with only 5 seconds.\n. @gkatsev i can still observe the same after upgrading to the merged #62\n. when I downgrade videojs to 4.5.1 then it works for me. looks like others have similar problems (https://github.com/videojs/video.js/issues/1226). I consider it more likely to be a videojs rather than a hls-contrib issue, but would appreciate you looking into it anyway\n. I can verify it is working here as well. Any chance to get all the stuff merged and released? Right now our next production deployment will contain unmerged and unrelease changes and I want to avoid maintenance nightmares :-)  thanks!\n. I have updated my pull request. there is now a second c&p'ed test with a different goalBufferLength. not super nice but working.\n. @dmlap how does that PR allow customising it as user? its not an option.\n. ",
    "joechen1018": "Thanks. Looking forward to updates.\n. ",
    "entone": "I was able to get around the mergeOptions issue with this videojs.util = {'mergeOptions':{}}; but I also get this error, which seems a little more serious \nUncaught TypeError: undefined is not a function videojs.hls.js:289\nmediaSource = new videojs.MediaSource()\n. I got this working using the latest tag, https://github.com/videojs/video.js/releases/tag/v4.5.2\n. ",
    "ugin": "That's because videojs-contrib-media-sources is a dependency and must be included also:\n<script src=\"video.js\"></script>\n<script src=\"videojs-media-sources.js\"></script>\n<script src=\"videojs-hls.min.js\"></script>\nBut you'll still might get other errors, mergeOptions is a function used by hls.js, so making it a noop will lead to other errors ;)\n. ",
    "Ashim0006": "Actually we were using android native player. As akamai is our CDN partner they are giving us the streams in HLS format. The HLS streams from AKAMAI are not supported by all android device. Thats why we are looking for Video.js now. \nWe have embedded video.js in our website in a HTML page. As per the instructions from video.js's website. It works fine in PC browser's but it wont do the adaptive switching. And we couldnt play it on android and iOS browsers.\nIs that possible to re-direct the streams to HTML player without going to Native player?\nWe have seen some android applications they are using HTML player smoothly \neg: Spuul\n.  here is our channel link :http://cinesoftlive-lh.akamaihd.net/i/mathrubhumitv_cinesoft@192173/master.m3u8\nNow the problem with player is that in windows web browser's like chrome and Mozilla fire fox is that it will not play smoothly and adaptive Multi Bitrate Switching is not properly done.Only a single resolution will play continuously.But it will work fine in ios and android.\n. helps should be appreciated\n. ",
    "mkilling": "The video controls still don't show up for me after pressing the play button (Google Chrome). My setup:\n- video.js at master\n- video-js-swf at master\n- videojs-contrib-media-sources with videojs/videojs-contrib-media-sources#11 merged\n- videojs-contrib-hls with #66 merged\n. @gkatsev Wasn't videojs/video-js-swf#93 already merged into  videojs/video-js-swf master?\n. No errors in the console...\nhtml\n<video id=\"video-player\" class=\"video-js vjs-default-skin\" controls preload=\"auto\" width=\"620px\" height=\"465px\" poster=\"https://my_thumbnail\">\n    <source type=\"application/x-mpegURL\" src=\"http://s3.amazonaws.com/my_bucket/my_video\">\n</video>\nI initialize the player like this:\njavascript\nvideojs(\"video-player\", { playbackRates: [1, 1.5, 2, 3], techOrder: ['html5', 'hls', 'flash'] });\n. Yes, the video is playing. Only the large play button in the top left corner does not disappear and the video controls don't show up. It works with the same setup when pointing it to an mp4 file instead of the m3u8\n. Turns out I didn't specify the right .swf file. It works for me now. Sorry for the confusion.\n. Yes it does. Controls show up and everything is fine ;-)\n. I did not have Flash installed in Firefox. Sorry for the confusion and thanks for your help!\n. Unfortunately the stream is confidential material, so I can't share it. I'll test it with #91 pulled in though.\nI'm working on preparing a public stream that illustrates this issue and another unrelated issue.\n\nOn 25.06.2014, at 01:13, David LaPalomento notifications@github.com wrote:\nCan you share a link to your test stream? You may want to test again after #91 gets pulled in. I believe it may fix the currentTime calculation issue you're seeing.\n\u0081\\\nReply to this email directly or view it on GitHub.\n. I haven\u2019t yet. What about closing this issue for now? I\u2019ll re-open it if I can reproduce the problem with a recent release.\n\nOn 12 Aug 2014, at 15:58, David LaPalomento notifications@github.com wrote:\n\n@mkilling did you have a chance to test with more recent releases? I'd like to close this issue if it's been resolved.\n\u2014\nReply to this email directly or view it on GitHub.\n. I'll try to find that out and if so provide a sample stream that causes the crash.\n. \n",
    "shacharz": "Any news here?\n. Tested it then on FF 41.\n. Tested again on a bunch, FF41 looks ok now (plays on Flash).\nIE11 on win8.1 is not playing and not falling back to Flash.\n. Something is unclear with the releases here.\nYou've just added this to 1.0 Release milestone, while 1.2.2 was released a couple of days ago.\n. I might find time to do it, are you ok with setting a videojs.Hls.VERSION = '__VERSION__' somewhere in https://github.com/videojs/videojs-contrib-hls/blob/master/src/videojs-hls.js\nand replacing it in grunt build, similar to https://github.com/videojs/video.js/blob/93f2f83723cee9cc229030b9586d1ca24a32d62f/build/grunt.js#L30 ? (just without browserify)\n. FF 43.0, \nUbuntu 14.04.3 LTS, Release: 14.04, Codename: trusty\n. seems to be working, thanks\n. @tenacex \n\nCurrently you can input a url to a stream\n\nHow? I dont see any query string option or something like that from the source code\n\ndo you mean to say that we should add something like a drop down menu feature?\n\nYea, that's what I had in mind\n. Oh that's not the error I was referring to, the link is probably geo blocked to Israeli ip's.\n. ",
    "sabberworm": "@gkatsev Regarding the \u201cdownside\u201d you mentioned of having to declare hls three times in techOrder: I, for one, would love that. I have found hls-flash to be incredibly buggy and would love for there to be a way to excluding it from the available techs whilst keeping native and mse in. Also, how would that make \u201c[switching] between the two\u201d harder? It would make it easier, no?\n. @heff So if this issue was closed because the \u201cdesign issue is resolved\u201d, should I open a new issue for actually implementing HLS via MSE?\n. @dmlap That\u2019s great news!\n. ",
    "arikgilad": "I tried to test the mse-magic version but I was not able to make it work.\nWhen running the example I found many issues:\n1. in videojs-hls.js i got typerror on \nvideojs.Hls = videojs.extends(Component, {...\nI had to change videojs.extends to videojs.extend\n1. The code is using request.response/request.responseText in videojs-hls.js and playlist-loader.js instead of request.body.\nEven after fixing those issues, the video was still not playing.\nIt was downloading all the ts files but never played them because drainBuffer() was doing nothing because this.sourceBuffer.updating was set once and never unset.\n. Also have problems playing:\nhttp://makostore-vh.akamaihd.net/i/SHORT/CH22_NEWS/2015/09/press_vtr2_n20150903_v1/press_vtr2_n20150903_v1_,500,850,.mp4.csmil/master.m3u8?hdcore=3.0.3\nThe video will start playing but after seeking the video is distorted or freeze while sounds is still playing properly.\n. ",
    "Yoshka": "Player starts to play after downloading  4-5 ts segments, each segment has length 1 sec\nAnd it seems like .setBufferTime() is set to minimum(0.5 sec)\n. ",
    "Alster": "In ffmpeg you can use \"-g\" parameter, which means \"frames per chunk\". In case of 24fps and desired 2sec per chunk, you can set parameter like \"-g 48\"\n. ",
    "jsanford-bc": "CORS should be enabled on that entire bucket.\nThe stream plays correctly in Safari using the same player configuration that fails in Chrome\n. @seniorflexdeveloper - As I understand S3 CORS, those headers are only returned if there is an Origin header in the request. For example, see the below CURL call. Is there a way to force S3 to return those headers all the time? I couldn't find it online, but I definitely could be mistaken.\njsanford$ curl --header \"Origin: google.com\" -XGET -i http://bc-jsanford.s3.amazonaws.com/instant_play_demo/1402004163/index.m3u8\nHTTP/1.1 200 OK\nx-amz-id-2: 5QLGmDW6cWl+VK5hOHDcg9517FogTzu4v71r4TGsKfKsNFvq8lU9khkT7q2/yh2a\nx-amz-request-id: 65AA97EA1C115F91\nDate: Thu, 05 Jun 2014 22:37:23 GMT\nAccess-Control-Allow-Origin: *\nAccess-Control-Allow-Methods: GET\nVary: Origin, Access-Control-Request-Headers, Access-Control-Request-Method\nLast-Modified: Thu, 05 Jun 2014 21:36:36 GMT\nETag: \"d9e7529f7643820ac9e6134804ccfd08\"\nAccept-Ranges: bytes\nContent-Type: application/vnd.apple.mpegurl\nContent-Length: 272\nServer: AmazonS3\n. Hey Tom - I tried this through a CDN, which always returns the headers for CORS. The new URL is http://bcjsanford.com.global.prod.fastly.net/instant_play_demo/1402013949/index.m3u8\nI still can't get this to work with the HLS player. I am trying to load the manifest in dynamically through the player.src method, but I always get the following errors in the console:\nUncaught TypeError: Cannot read property 'currentTime' of null  --  video.js:105\nUncaught TypeError: Cannot read property 'vdata1402014589192' of null  --  video.js:12\n. ",
    "r-clancy": "@dmlap Thanks.\nI require the start and end of the download time of each chunk to calculate metrics based on the video playback.\nHow is it that I could determine the start time of the download? Also, is it possible to listen for the start and end of the download, or would I have to fork the project and add my own code into the selectPlaylist() function?\n. Thank you for the information, that should be what I need.\nI'm assuming the loadedmetadata event has information associated with it such as the target duration of the chunks?\n. Meant for main VideoJS repo, closing.\n. ",
    "gquinones": "We should see if we can express these goals such that we can apply Pareto Optimization:\nhttp://en.wikipedia.org/wiki/Multi-objective_optimization#Solving_a_multi-objective_optimization_problem\nThere may be tools available to help us solve the problem.\n. The definition of continuity as stated defines speed of play with values above one implying fast-forward and values below one implying slow-motion. Either one would be bad, so the optimal is 1. Perhaps continuity should be described as drift away from one. Like this, for example:\ncontinuity = abs(1 - video-time/time)\n. Gary,\nCheck if the guy is running on a Mac, specifically with the El Capitan OS.\nI've had similar problems and it turned out to be that I needed to update\nXcode and accept the licensing agreement. Super annoying and obscure issue,\nespecially since they point the finger of blame elsewhere.\nhttps://github.com/phonegap/ios-deploy/issues/161\nOn Wed, Dec 9, 2015 at 9:59 AM, Gary Katsevman notifications@github.com\nwrote:\n\nThat's super weird. I'm pretty sure that prepublish isn't supposed to be\nrun like that.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/videojs/videojs-contrib-hls/issues/468#issuecomment-163281115\n.\n\n\n\nGerardo Qui\u00f1ones\n. When I upgraded my rig to El Capitan, everything broke for me. Even after I\nupdated Xcode, things were still broken. It wasn't until I opened Xcode and\nwent through the process of accepting the license agreement that npm\ninstall started working correctly again. Totally different packages but\nsame tell-tale behavior of saying:\n\nThis is most likely a problem with the  package,\nGlad you're back up and running.\nOn Wed, Dec 9, 2015 at 9:07 PM, Hanfei Sun notifications@github.com wrote:\n\n@gquinones https://github.com/gquinones Yes, I'm using El Capitan OS.\nWhen I use Git URL in package.json:\n\"devDependencies\": {\n    \"videojs-contrib-hls\": \"git+https://github.com/videojs/videojs-contrib-hls#v1.2.2\"\n  }\nEverything works well..\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/videojs/videojs-contrib-hls/issues/468#issuecomment-163463579\n.\n\n\n\nGerardo Qui\u00f1ones\n. Rado and I can provide some assistance in evaluating how this change might\nimpact bandwidth consumption by the player.\n\nLet us know if you want us to help.\nOn Thu, Mar 31, 2016 at 10:32 AM, Brandon Casey notifications@github.com\nwrote:\n\ntests? or are we just trying to get something working for now?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub\nhttps://github.com/videojs/videojs-contrib-hls/pull/629#issuecomment-203988103\n\n\n\nGerardo Qui\u00f1ones\n. We should never discard the lowest available rendition based on bitrate. Otherwise we're left with no renditions to play at all. The question is: which is better, playing a rendition that will buffer due to bandwidth limits, or not play at all? In my opinion it is better to at least try to play because bandwith limits could be temporary or they could be caused by our bitrate sampling limitations.\n. Choose the simplest description that explains the process, but no simpler. :)\n. \n",
    "pcosta-bc": "Really good discussion. I think the main thing I'd want to add back in is that many of these metrics don't necessarily have inherent value but are probably best thought of as variables you can use to measure cost/performance. For instance, you will obviously have a tradeoff between quality and cost since delivering a higher bitrate is more expensive. The real question is where you reach diminishing returns. When does delivering a better bitrate no longer have a material impact on the metric that matters to you -- engagement, customer satisfaction, call to action, etc. If delivering a 720p bitrate gets you higher satisfaction than 480p, it might be justified, but it switching to 1080p has no incremental benefit, it's probably in the customer's interest to eliminate it. Similarly, startup time (performance) may have a big impact for short form but a much lower impact for long-form.\nThe real payoff for customers would be if we could tell them that in order to maximize [insert goal here] they should optimize their [insert metric here] but not let any of these other metrics fall below X.\n. ",
    "StevenMeyer": "Watching the Network pane in Firefox, it seems to be requesting the same chunk many times over. It is always getting a response, but seems to not be using it. I imagine that is related to the JavaScript error already mentioned.\n. This is generated by Wowza based on a generated MediaList (like a SMIL file). I may be missing something.\nThe result of requesting the m3u8 file is as follows:\n```\nEXTM3U\nEXT-X-VERSION:3\nEXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=119000,NAME=\"422.BanglaVision\",CODECS=\"avc1.66.30, mp4a.40.2\",RESOLUTION=480x360\nchunklist_w282278797_b119000_t64NDIyLkJhbmdsYVZpc2lvbg==.m3u8\nEXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=239000,NAME=\"422.BanglaVision\",CODECS=\"avc1.66.30, mp4a.40.2\",RESOLUTION=480x360\nchunklist_w282278797_b239000_t64NDIyLkJhbmdsYVZpc2lvbg==.m3u8\nEXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=540000,NAME=\"422.BanglaVision\",CODECS=\"avc1.66.30, mp4a.40.2\",RESOLUTION=640x480\nchunklist_w282278797_b540000_t64NDIyLkJhbmdsYVZpc2lvbg==.m3u8\n```\n. Can someone suggest a public HLS live stream (adaptive bit rate)? I've tried a few such as NASA and Apple's feeds, but they don't seem to have CORS set up for the flash player.\n. Deleted a comment by accident. The issue has cropped up again.\n. The playlist is generated on the fly in Wowza, so there is no master playlist, unfortunately.\n. I've made requests for each of the three chunklist M3U8 files whilst the stream was running.\nFor chunklist_w2145899247_b119000_t64NDIyLkJhbmdsYVZpc2lvbg==.m3u8\n```\nEXTM3U\nEXT-X-VERSION:3\nEXT-X-ALLOW-CACHE:NO\nEXT-X-TARGETDURATION:12\nEXT-X-MEDIA-SEQUENCE:1451\nEXTINF:9.742,\nmedia_w2145899247_b119000_t64NDIyLkJhbmdsYVZpc2lvbg==_1451.ts\nEXTINF:10.845,\nmedia_w2145899247_b119000_t64NDIyLkJhbmdsYVZpc2lvbg==_1452.ts\nEXTINF:9.208,\nmedia_w2145899247_b119000_t64NDIyLkJhbmdsYVZpc2lvbg==_1453.ts\n```\nFor chunklist_w2145899247_b239000_t64NDIyLkJhbmdsYVZpc2lvbg==.m3u8\n```\nEXTM3U\nEXT-X-VERSION:3\nEXT-X-ALLOW-CACHE:NO\nEXT-X-TARGETDURATION:12\nEXT-X-MEDIA-SEQUENCE:1453\nEXTINF:9.208,\nmedia_w2145899247_b239000_t64NDIyLkJhbmdsYVZpc2lvbg==_1453.ts\nEXTINF:11.145,\nmedia_w2145899247_b239000_t64NDIyLkJhbmdsYVZpc2lvbg==_1454.ts\nEXTINF:9.41,\nmedia_w2145899247_b239000_t64NDIyLkJhbmdsYVZpc2lvbg==_1455.ts\n```\nFor chunklist_w2145899247_b540000_t64NDIyLkJhbmdsYVZpc2lvbg==.m3u8\n```\nEXTM3U\nEXT-X-VERSION:3\nEXT-X-ALLOW-CACHE:NO\nEXT-X-TARGETDURATION:12\nEXT-X-MEDIA-SEQUENCE:1455\nEXTINF:8.976,\nmedia_w2145899247_b540000_t64NDIyLkJhbmdsYVZpc2lvbg==_1455.ts\nEXTINF:10.443,\nmedia_w2145899247_b540000_t64NDIyLkJhbmdsYVZpc2lvbg==_1456.ts\nEXTINF:10.011,\nmedia_w2145899247_b540000_t64NDIyLkJhbmdsYVZpc2lvbg==_1457.ts\n```\nThere was a brief gap between requests so that I might copy and paste the next chunklist URL.\n. This issue seems to crop up intermittently.\n. The problem is occurring in translateMediaIndex, where, in an example execution, mediaIndex is -39.\noriginal.uri is chunklist_w1345154760_b444000_t64NDIyLkJhbmdsYVZpc2lvbg==.m3u8.\noriginal.segments contains 1 item: an object whose uri is media_w1345154760_b444000_t64NDIyLkJhbmdsYVZpc2lvbg==_147.ts.\noriginalSegment is undefined because mediaIndex - 1 = -40, so there is no item at original.segments[-40].\nWhile the player is waiting for the user to press play, the function is executed with a mediaIndex of 0 and then 1 and is successful. Around 10 seconds later (regardless of whether the video has been played or not), it is called again with a negative number such as -42.\n. ",
    "gak2": "Hi,\nI am really struggling with this issue of a live HLS stream from Wowza freezing after 10 seconds in Chrome/Firefox.  I have tried all combinations of videojs 5.2.0 \u00bb 5.10.1, and videojs.hls 1.2.0 \u00bb 2.2.0, to no avail.  It does stream fine to Android though, so I don't think Wowza setup is the problem.\nOn both Chrome and Firefox, it looks as though the media blocks run into a loop ...\nmedia_w1438989202_52.ts    \nmedia_w1438989202_53.ts \nmedia_w1438989202_54.ts \nmedia_w1438989202_53.ts \nmedia_w1438989202_54.ts \nmedia_w1438989202_53.ts\n... after 10secs this fails and the browser goes into an endless request for the same media_xxxxxx.ts chunklist.  Result is: video stops dead in Chrome, and on Firefox goes into eternal loading-circle.\nBizarrely, it will keep playing in IE, where is seems to alternate loading .m3u8, .ts, .m3u8, .ts, .m3u8 ... it would be great if I could even see a link where someone has this working correctly?\nAll help greatly appreciated  :)\nThanks  :)\n. I'm struggling with this issue: live HLS stream from Wowza freezes after 10 seconds.  I have tried all videojs/hls combinations outlined above, all to no avail. On Chrome and Firefox, the media blocks run into a loop:\nmedia_w1438989202_52.ts media_w1438989202_53.ts media_w1438989202_54.ts media_w1438989202_53.ts media_w1438989202_54.ts media_w1438989202_53.ts\nAfter 10secs this fails and the browser endlessly requests the same media_xxxxxx.ts chunklist. Result: the video stops dead in Chrome and Firefox goes.  It does play on IE though, where it's alternately loading .m3u8, .ts, .m3u8, .ts, \nAnyone got any ideas?\nThanks!\n. I abandoned it Alon.  Couldn't make it work.\n. Sven, I am experiencing exactly these issues live-streaming from Wowza: the browser seems to lose track of .ts files and just loops, loading the .m3u8 file.\nI am very hopeful that your script might help, but - apologies for my inexperience - I'm have trouble applying it!  I am running 'video.js' from ZenCDN, and v.2.0.0 of 'videojs-contrib-hls.js' locally - all on a Windows server.  Could you please help me test your changes?  \nI've tried replacing the latter file with yours from the 'src' folder on your fork, but it doesn't work.  Do I need more files from your fork?  Is non-Windows compilation required?  Even a working example would be great, just so I could follow the source code!\nThank you Sven ..\n. Sven, I used your code to replace the middle section of v1.3.11/videojs.hls.js.  It runs, but didn't fix the problem.  I'm pretty stuck, unsure whether the issue is HLS/Wowza/my code.  Any guidance / live streaming examples greatly appreciated!\nThanks!\n. @ROKAISAKKON Thank you so much for replying.\nBut how do I do add @svenspielvogel 's code?  I am now using the following files:\n- http://vjs.zencdn.net/5.9.2/video.js\n- hls/v2.0.1/videojs-contrib-hls.js\nSo which file / files do I add from https://github.com/mevango/videojs-contrib-hls to replace \"videojs-contrib-hls.js\"?  Really appreciate your help with this.\nThank you again!\n. @svenspielvogel Hey, thanks for the reply!\nI'm sure I'm doing something wrong here, but the command-line spinner just spins endlessly on npm install  :\\  I'll keep working at it .. in the meantime, is there any way you could please provide a dist of the videojs-contrib-hls.js?\nThanks Sven!\n. @svenspielvogel Thank you so much for this.  Your help is greatly appreciated.  I still can't get it to work however.  \nFirst, Video.js throws an error: (CODE:2 MEDIA_ERR_NETWORK) \"A network error caused the media download to fail part-way.\"\nThen your file throws this error: videojs-contrib-hls.js:11329 Uncaught InvalidStateError: Failed to execute 'endOfStream' on 'MediaSource': The MediaSource's readyState is not 'open'.\nAny thoughts on why this might be happening?  I've tried tweaking Wowza CupertinoStreaming setup, but no luck .. thank you Sven!\n. @svenspielvogel Thanks for this!\nI now get this error: \nvideojs-contrib-hls-mevango2.js:9668Uncaught TypeError: _this.player_.audioTracks is not a function\nAnd the stream does not improve:\nmedia_w222106005_60.ts  \nmedia_w222106005_61.ts  \nmedia_w222106005_59.ts  \nmedia_w222106005_60.ts  \nmedia_w222106005_61.ts  \nmedia_w222106005_59.ts  \nmedia_w222106005_60.ts  \nmedia_w222106005_61.ts  \nmedia_w222106005_59.ts  \nmedia_w222106005_60.ts  \nmedia_w222106005_61.ts  \nmedia_w222106005_59.ts  \nmedia_w222106005_60.ts  \nmedia_w222106005_61.ts  \nchunklist_w222106005.m3u8   \nchunklist_w222106005.m3u8   \nchunklist_w222106005.m3u8   \nchunklist_w222106005.m3u8   \nchunklist_w222106005.m3u8   \nchunklist_w222106005.m3u8\nAny thoughts!?\nThanks Sven!\n. @ROKAISAKKON Thanks for this!  But I'm afraid my video stops after a few seconds.\nCould you please send me your HTML?  So I can try to replicate your setup?\nThanks!\n. Same problem on 5.7.0 @ROKAISAKKON  :(\nIt keeps jumping between two .ts files, then loops requesting the .m3u8 file.  \nIt must be something to do with the source video format: VOD works fine (eg. http://www.streambox.fr/playlists/x36xhzz/x36xhzz.m3u8), but this live stream from a Wowza server doesn't work.  It will stream OK through other players though, like VLC.  Have you any thoughts/experience on live Wowza streaming in the browser?\nThank you!\n. Hi @ROKAISAKKON ,\nThanks for the response!  I have a lot of other code in the files re. other javascript libraries - for example wrapping the video around a sphere with three.js - so it's very messy and I'd need to tidy it up for you.\nOther VOD streams do work fine with my code though - it's just this live Wowza stream that keeps breaking.  And even the live stream works in VLC player.  So I'm starting to think it may an incompatibility between videojs-hls and the keyframing/Wowza transcoding ..?\nCould you possibly send a simple outline of your HTML markup?  At least then I could ensure I'm not making a silly mistake in my code!\nThanks again for your help.\n. Hello again @ROKAISAKKON !\nMy markup is now very simple, and these scripts work perfectly for VOD.\nHowever, they don't work for live video streamed over Wowza:\n\nYour thoughts/ideas would be greatly appreciated!\nThanks again ..\n. Hi @dmlap thanks for getting back to me!\nI suspect you're right: after some digging, it looks like the video source [Vahana \u00bb Wowza] is somehow corrupting the Audio stream.  Looks like there might be missing audio samples.  So I'm attempting to resolve this at the source first .. then I'll come back here to confirm!\nThanks again - watch this space ..\n. ",
    "bparadie": "Are you guys okay with me submitting a PR for this one?\n. No problem. Thanks for taking care of this.\n. No problem, I can submit some PRs. Do I need permissions that allow me to push to videojs-contrib-hls? Or do you guys accept PRs from any forked repo?\n. Got it! Thx. This doc also explains everything perfectly:\nhttps://github.com/videojs/videojs-contrib-hls/blob/master/CONTRIBUTING.md\n. @dmlap I just noticed https://github.com/videojs/videojs-contrib-hls/pull/115, which might clash with this PR. I am glad to see some clean up. Please let me know if I should integrate https://github.com/videojs/videojs-contrib-hls/pull/115 into this PR.\n. @heff Sounds good. So it seems like this PR is somewhat pointing in the right direction. But you guys have bigger plans. Please feel free to contact me directly at bparadie at adobe dot com if you are interested in starting an offline discussion about refactoring PlaylistSelector.\nBTW, this PR is somewhat inspired by Google's ExoPlayer architecture:\nhttps://github.com/google/ExoPlayer\nThis is a pretty good introduction:\nhttps://www.youtube.com/watch?v=6VjF638VObA\nLong story short, ExoPlayer implements a DefaultBandwidthMeter that you stick into an AdaptiveEvaluator. That AdaptiveEvaluator has a method called evaluate() that expects MediaChunks (~HLSSegments) and could be used instead of selectPlaylist. Either way, I just wanted to mention were I am coming from...\nCheers,\n- Bernd\n. @heff If it's okay with you I am going to withdraw this PR. I think, we all agree with the direction. But there seem to be more refactoring work under way and this PR looks out of date. Also, my proposal for separating the PlaylistSelector as a separate entity was motivated by a bug I was hoping to solve with an improved PlaylistSelector. \nAs it turned out, an improved PlaylistSelector would not fix that bug I am working on (see IRC discussion about mid-segment switching).\nIn regards to isolating a BandwidthMeter class: Yes, I would strongly recommend isolating a BandwidthMeter class. I like ExoPlayer's implementation:\nhttps://github.com/google/ExoPlayer/blob/master/library/src/main/java/com/google/android/exoplayer/upstream/DefaultBandwidthMeter.java\nThe code can easily be ported to JS.\nCheers,\n- Bernd\n. @dmlap I am not sure whether the current algorithm matches your description. BigBuckBunny has two channels. Let's assume that the first entry is the low bandwidth entry with BANDWIDTH=280000,RESOLUTION=280x160 and the second entry is the higher bandwidth with BANDWIDTH=560000,RESOLUTION=560x320. If the target size is 600x300 then the current algorithm picks BANDWIDTH=280000,RESOLUTION=280x160 even if we could present BANDWIDTH=560000. The quality difference is noticeable. \nWhat you describe sounds more like a situation with more than two channels. For example, if we had three channels BANDWIDTH=280000,RESOLUTION=280x160, BANDWIDTH=360000,RESOLUTION=360x200, BANDWIDTH=560000,RESOLUTION=560x320. Having the choice of switching from 280000 to either 360000, or 560000 the algorithm should pick the one with the better resolution match.\nI could see an argument for that. But that's not at all what's happening in selectPlaylist().\nShould the resolution matter if you only have two choices? Shouldn't we always go for the better bandwidth?\n. David suggested that I should write up a test case that shows the problem.\nHere we go:\n1 Create ./test/manifest/bigBuckBunny.m3u8 with this in it:\n```\nEXTM3U\nEXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=150000,RESOLUTION=400x224\nhttp://c.brightcove.com/services/mobile/streaming/index/rendition.m3u8?assetId=3198916946001&videoId=3198908353001\nEXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=514000,RESOLUTION=640x360\nhttp://c.brightcove.com/services/mobile/streaming/index/rendition.m3u8?assetId=3198916958001&videoId=3198908353001\n```\n2 Add this test case to videojs-hls_test.js\n```\ntest('selects the correct rendition by bandwidth', function() {\n    var playlist;\nplayer.src({\n    src: 'manifest/bigBuckBunny.m3u8',\n    type: 'application/vnd.apple.mpegurl'\n});\n\nopenMediaSource(player);\n\nstandardXHRResponse(requests[0]);\n\n// bigBuckBunny.m3u8 has two channels:\n// #EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=150000,RESOLUTION=400x224\n// #EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=514000,RESOLUTION=640x360\n// What happens if the bandwidth high enough for serving 514000,\n// but the dimensions match the lower bandwidth?\n\nplayer.width(639);\nplayer.height(359);\nplayer.hls.bandwidth = 3000000;\n\nplaylist = player.hls.selectPlaylist();\n\ndeepEqual(playlist.attributes.RESOLUTION, {width:640,height:360},'should return the correct resolution by bandwidth');\nequal(playlist.attributes.BANDWIDTH, 514000, 'should have the expected bandwidth in case of multiple');\n\n});\n```\n3 run grunt, and you'll get this error:\n```\nChrome 36.0.1985 (Mac OS X 10.9.4) HLS selects the correct rendition by bandwidth FAILED\n    should return the correct resolution by bandwidth\n    Expected: [object Object]\n    Actual: [object Object]\n        at Object. (.../videojs-contrib-hls/test/videojs-hls_test.js:628:34)\n        at Object.Test.run (.../videojs-contrib-hls/node_modules/qunitjs/qunit/qunit.js:203:18)\n        at .../videojs-contrib-hls/node_modules/qunitjs/qunit/qunit.js:361:10\n        at process (.../videojs-contrib-hls/node_modules/qunitjs/qunit/qunit.js:1453:24)\n        at next (.../videojs-contrib-hls/node_modules/qunitjs/qunit/qunit.js:1446:3)\nshould have the expected bandwidth in case of multiple\nExpected: 514000\nActual: 150000\n    at Object.<anonymous> (.../videojs-contrib-hls/test/videojs-hls_test.js:629:30)\n    at Object.Test.run (.../videojs-contrib-hls/node_modules/qunitjs/qunit/qunit.js:203:18)\n    at .../videojs-contrib-hls/node_modules/qunitjs/qunit/qunit.js:361:10\n    at process (.../videojs-contrib-hls/node_modules/qunitjs/qunit/qunit.js:1453:24)\n    at next (.../videojs-contrib-hls/node_modules/qunitjs/qunit/qunit.js:1446:3)\n\n```\nMy question is: Do we all agree that this is an error? Or do you guys think that we should choose resolution over bandwidth and this is not a bug?\n. @dmlap Sounds good! Thanks for taking care of this. \n. Oops, that's in my code! Sorry. Closing.\n. This is not about syntactic sugar, I believe this is a real bug:\nThe intend of the original code is having fillbuffer called on 'timeupdate' events, right? But since fillbuffer will always be called with an event object, this piece of code looks really wrong:\nsegmentBuffer.push({\n          mediaIndex: player.hls.mediaIndex,\n          playlist: player.hls.playlists.media(),\n          offset: offset,\n          tags: tags\n        });\nIf I am not mistaken, this code may assign an Event object to the offset property, which might end up in the segmentBuffer.\nThere is this piece of code, which might kick in here and there:\n// if there is plenty of content in the buffer and we're not\n      // seeking, relax for awhile\n      if (typeof offset !== 'number' &&\n          bufferedTime >= videojs.Hls.GOAL_BUFFER_LENGTH) {\n        return;\n      }\nBut if bufferedTime < videojs.Hls.GOAL_BUFFER_LENGTH you'll end up with an offset stored away as an Event object.\nOr did I miss something?\n. That's much better. Would you like me to make that change in this PR? Or are you guys taking care of that later?\n. @dmlap I thought about removing that line. But I decided against it, because that would change the semantics. I can't tell whether that if-block should only be entered if fillbuffer had been called by the 'timeupdate' event dispatcher, or not.\n. @dmlap I followed your suggestion and added this code for normalizing offset.\n. @dmlap Sorry for the back and forth on this one. I was running the wrong unit tests. When I did this normalizing line  was triggering 12 errors. The version that is now checked in uses fillbuffer without function wrapper but does not normalize fillbuffer's offset parameter. \nIf I had to guess I'd say that there is code out there that relies on having offset stored as an Event object in segmentBuffer. I propose revisiting this problem later and moving on with the rest of this PR. Agreed?\n. no problem! Let me know if there are more places that need to be changed in this PR.\n. bandwidthVariance used to be a global var in videojs-hls.js\n. bandwidth is an optional parameter. Some unit tests punch in their own bandwidth values via members in videojs-hls.js. Moving forward we might want to change the unit tests such that we can remove the bandwidth parameter from the API.\n. The code in this method is almost identical with the original selectPlaylist() implementation in videojs-hls.js.\n. The code below has been moved to playlist-selector.js\n. I left the old implementation of selectPlaylist() in here. Please let me know if you would like me to remove it.\n. Another tiny difference: Instead of calculating the bandwidth, this code now asks the playerSelector, which does all the work now.\n. In order to make the delegation to PlaylistSelector work, I require three calls from xhr(): onTransferStart, onBytesTransferred, and onTransferEnd. Note that I have added an onprogress handler for collecting data as we are downloading the segment.\n. Yes, good catch! At least I was consistent. I will change both places to playlistSelector.\n. In theory this code can oscillate: low -> high, high -> low, low -> high etc.\nIf you guys agree with the solution I will add additional code to prevent oscillation.\n. Had to relax the test case, because of pre-segment switching you may get additional calls. \n. Had to relax the test case, because of pre-segment switching you may get additional calls. \n. Here is a radical thought: Should resolution even be considered when picking the best playlist?\nWhy not just this?:\nreturn  bandwidthBestVariant || sortedPlaylists[0];\nand removing the code that calculates resolutionBestVariant?\n. ",
    "mmcc": "Nah, no permissions needed, we accept PRs from forked repos. Generally we like people to fork, then do work in a feature branch, then submit a PR against master. Thanks for the help!\n. As far as I know, if the EXT-X-PLAYLIST-TYPE is missing, the playlist is presumed to be \"live\" (following the Pantos HLS spec). Try specifying EXT-X-PLAYLIST-TYPE as either \"event\" (if you plan to append segments later) or \"VOD\" (if the playlist will never change after loading).\n. We don't host these on a CDN, but you could use something like rawgit if you'd like.\n. Ah you're right, I was assuming there was a dist in the release tags like with VJS.\n. You can find the minified files in the releases.\n. Closing this as a duplicate of #291\n. Ended up being an issue with OP's environment: videojs/video.js#2446\n. If someone else runs into this, please post a new issue with details and ideally a reduced test case so we can dig into it. \n. @chrisfronda / @voilageapp You were asked for more info and never gave anything but snarky responses. The worst of which aren't reflected in this thread since you seem to have deleted them. So yes, if someone else runs into this problem and would like to collaborate constructively with the rest of the community and maintainers to try and find a solution, they're welcome to.\n. Yeah I think they mean it's a replacement for this project if you'd prefer\nto use HLS.js, not that the project actually replaces this one.\nThe wording is confusing, though, we should put together a PR to clarify a\nlittle (or see if they will).\n\nMatthew McClure\nOn July 26, 2016 at 5:48:14 PM, Gary Katsevman (notifications@github.com)\nwrote:\n\nI think that README misleading. It is a replacement for this project using\nhlsjs. This project is still well and alive.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/videojs/videojs-contrib-hls/issues/797#issuecomment-235449803,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAwhbJPY8Gr42JjhJu2EWdMlXL0Yo3i_ks5qZqrOgaJpZM4JVuk6\n.\n. This is way out of the scope of this review, so no changes requested here, just curious. Is there a reason for this beyond style choice? \n. Well I see why var is there, I'm more asking about the benefits of having an 80 line multiple var statement. Not trying to be contrary, I've just seen this pattern pop up in a few different projects recently.\n. Those are all great rules by themselves, but I think the combination makes for a breadcrumb trail made of commas and pain. For what it's worth, I really like Ben Alman's take on multiple var statements. Feels roughly similar to where we've landed in VJS core?\nMy rule is as-follows: I\u2019ll put multiple comma-separated declarations in a single var statement, but only if they don\u2019t have assignments. Assignments must be in their own var statement. Like this:\njavascript\nvar foo, bar, baz;\nvar abc = 1;\nvar def = 2;\n\nAgain, this probably isn't the place for this conversation, but as someone not familiar with this style, this is ripe for massive wtf moments. Anecdotally, I had one of those massive wtf moments when trying to help someone out internally with BCC code that uses this same style.\nSomewhat related: are we planning on using standard across contrib plugins as well?\n/me climbs off soap box\n. :+1: Sounds good. Call me crazy, but purely stylistic changes can probably sit on the back burner for a little while. :)\nI'm down to help with those when the time comes, it'd be nice to get a better feel for the internals of some of these contrib plugins.\n. ",
    "benjaminp": "Any H264 video with B-frames (enabled on the main profile) should do the trick. I also noticed Chrome's embedded Flash player compensates for this error somehow, so you have test with Firefox/Opera. I assume the actual spec language for this behavior is behind a paywall somewhere. I checked for a few other projects, and they all seem to use dts in the tag header. GStreamer just fixed it recently: https://bugzilla.gnome.org/show_bug.cgi?id=73135\n. Oops, copy-paste fail. See https://bugzilla.gnome.org/show_bug.cgi?id=731352\n. I hope this can be merged soon, since it fixes a rather serious and visible bug.\n. Fixed.\nOn Wed, Jul 16, 2014, at 12:14, Steve Heffernan wrote:\n\ncan you remove the last comma?\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/videojs/videojs-contrib-hls/pull/119#issuecomment-49212755\n. Isn't video-js.swf 4.4.2 new in video.js 4.7.0?\n\nOn Tue, Aug 5, 2014, at 21:11, Gary Katsevman wrote:\n\nWell, that was quick, since 4.7.0 was just released, but thanks. Though,\nit's weird because I don't think the swf was updated during 4.7.0\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/videojs/videojs-contrib-hls/issues/128#issuecomment-51291763\n. Ah, you're right. I think I must have forgot to upgrade the Flash\ncomponent when going from 4.6.3 to 4.6.4. I can confirm the bug happens\nwith 4.6.4 but not 4.6.3 and 4.7.0.\n\nOn Wed, Aug 6, 2014, at 07:24, Gary Katsevman wrote:\n\nI believe video-js-swf 4.4.2 is from videojs 4.6.4:\nhttps://github.com/videojs/video.js/pull/1343/files#diff-b9cfc7f2cdf78a7f4b91a753d10865a2R24\nand\nhttps://github.com/videojs/video.js/blob/master/CHANGELOG.md#464-2014-07-11\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/videojs/videojs-contrib-hls/issues/128#issuecomment-51341430\n. Attempting to seek causes video playback to stop and never resume. I see segments are still being downloaded, though.\n. \n",
    "thenewguy": "I am encountering this issue as well.  Here is a sample playlist\n```\nEXTM3U\nEXT-X-MEDIA-SEQUENCE:0\nEXT-X-ALLOW-CACHE:YES\nEXT-X-VERSION:3\nEXT-X-TARGETDURATION:10\nEXTINF:9.075744,\nhttp://foo.bar/path/to/98d2a607938600000.ts\nEXTINF:9.009011,\nhttp://foo.bar/path/to/98d2a607938600001.ts\nEXTINF:9.009,\nhttp://foo.bar/path/to/98d2a607938600002.ts\nEXTINF:9.009011,\nhttp://foo.bar/path/to/98d2a607938600003.ts\nEXTINF:9.009011,\nhttp://foo.bar/path/to/98d2a607938600004.ts\nEXTINF:9.009011,\nhttp://foo.bar/path/to/98d2a607938600005.ts\nEXTINF:9.009011,\nhttp://foo.bar/path/to/98d2a607938600006.ts\nEXTINF:9.009,\nhttp://foo.bar/path/to/98d2a607938600007.ts\nEXTINF:9.009011,\nhttp://foo.bar/path/to/98d2a607938600008.ts\nEXTINF:9.009011,\nhttp://foo.bar/path/to/98d2a607938600009.ts\nEXTINF:9.009011,\nhttp://foo.bar/path/to/98d2a607938600010.ts\nEXTINF:9.009011,\nhttp://foo.bar/path/to/98d2a607938600011.ts\nEXTINF:9.009011,\nhttp://foo.bar/path/to/98d2a607938600012.ts\nEXTINF:9.009,\nhttp://foo.bar/path/to/98d2a607938600013.ts\nEXTINF:9.009011,\nhttp://foo.bar/path/to/98d2a607938600014.ts\nEXTINF:9.009011,\nhttp://foo.bar/path/to/98d2a607938600015.ts\nEXTINF:9.009011,\nhttp://foo.bar/path/to/98d2a607938600016.ts\nEXTINF:9.009011,\nhttp://foo.bar/path/to/98d2a607938600017.ts\nEXTINF:4.162367,\nhttp://foo.bar/path/to/98d2a607938600018.ts\nEXT-X-ENDLIST\n```\nIt is hosted locally right now so I shortened excessively long paths.  If needed, I can post it somewhere.  The playlist plays and ends correctly via videojs on my android phone (galaxy note 3).  I get a loading spinner when playback stops on Chrome on my desktop.\n. I am seeing this too\n. It doesn't seem possible to manually kick this off either.  The following still requires a click from the user in Chrome 36 and IE10 before the video actually plays.\n```\n... snip ...\nvideojs(el, opts, function(){\n                // Player (this) is initialized and ready.\n                var player = this;\n            // Manually trigger autoplay\n            if (autoplay) {\n                    player.play();\n            }\n\n... snip ...\n```\nI'm using:\nvideojs-contrib-hls - v0.8.3 - 2014-07-25\nvideojs 4.7.1\n. Note that removing the videojs.hls.js script from the page causes the code above to autoplay correctly.\n. I thought that might be the case but using a 1.5 second timeout on the play call still failed. I don't know if that helps narrow it down or not.\n. I updated to video.js 4.7.1 when I was having problems.  I'm travelling until next week so I can't check against other versions right now.  I was using a local copy of the release from the github repo.\n. great. thanks\n. I think it is important to consider device resolution.  Maybe it should just be modified to show the next higher resolution if the client device resolution falls in between two resolution choices.  It doesn't make sense to send a 360p mobile device 1080p content just because it is connected to wifi.\n. This appears to be from https://github.com/videojs/video.js/issues/1570\nI've rewritten the initiator to take the linked issue into account.\n. Maybe byte range should be added to the list of unsupported features on the README?\nThere are tests that seem to indicate that byte ranges are supported:\n- https://github.com/videojs/videojs-contrib-hls/blob/master/test/manifest/byteRange.js\n- https://github.com/videojs/videojs-contrib-hls/blob/master/test/manifest/byteRange.m3u8\nI thought I read awhile back that the byte ranges would be downloaded in js and passed into the flash player?\n. I've encountered this with a VOD master playlist on version v1.3.11\n. It looks like updating to v2.0.1 fixes the issue on the stream giving me problems.  Couldn't update to v2.1.1 because the release doesn't include dist files and I couldn't get my vagrant box to build the code.\n-- edit --\nUsing video.js 5.8.8\n. So upgrading to v2.0.1 did not fix the problem.  The problem was hidden because this version will play one particular variant playlist but none of the others and happened to select the variant that played when I was checking different streams\n. I figured out the issue with the video that was giving me trouble.  After ensuring both the height and width were divisible by 2 and converting it to yuv420p the issue is gone.\n-- edit -- I also made some other changes such as enforcing video profile and level for segments.  So I am not sure exactly which change fixed it but it definitely looks like it was a video encoding issue causing the endless segment fetching on my stream.\n. A changelog update or some sort of short blog post summary would be very helpful if you are able to find the time for it.  The current changelog indicates that 0.17.6 is the official version and doesn't mention the 1.x or 2.x branch at all\n. Perhaps it would be helpful in this situation if there was a brief howto in the readme to go over building the project when this happens\n. ",
    "cdhowie": "This problem seems to have recurred in 1.3.5 (possibly prior versions) and still remains in 1.3.7.  I will open a new issue referencing this one.\n. The v2.0.0 release has fixed this problem for me, but I don't know about others.\n. I take it back; there are still some videos where the ended event doesn't fire, even with v2.0.0.\n. v2.0.0 seems to fix the \"ended\" issue for me (#555).  I'm not sure why, but it does.\n. I take it back; there are still some videos where the ended event doesn't fire, even with v2.0.0.\n. +1 Happens for me in Firefox 44.0.2 on OS X 10.11.3, but not in Chrome, with every HLS video I try.\n. We are having the same issue on v2.0.1.  The first chunk plays fine, but in the next chunk the video plays super fast while the audio does not, and it plays through the next chunks so fast that it has to stop to buffer.\nThis only seems to happen in Firefox, and only on Windows (tested both 7 and 10) -- I do not have the issue at all on OS X.\n. I'm not using Browserify, I'm just including this HLS script (using <script>) alongside video.js.\n. videojs version 5.4.6.  Yes, I was using the 3.1.0 minified release.\n. I see, thanks.\n. Is this the same as #592?\n. ",
    "ethietter": "I'm getting the same \nissue as MehSha, using the master I downloaded from today:\n\n. Excellent, that worked. It looks like I had found an outdated version of videojs-contrib-media-sources. Thanks for the help!\n. ",
    "chikathreesix": "I am facing exactly the same issue. This is because onreadystatechange is called when its abort method is called even though readystatechange event is defined not to be triggered in the specification.\nSo I think it's better to just set null to its onreadystatechange callback before calling the abort method. I have created another pull request #143. I am sorry for making it complicated.\nThanks :)\n. Thanks!\n. > we probably do want to just trigger the timeupdate right after setting currentTime in the disconinuity but make sure that fillBuffer and drainBuffer don't react to our own timeupdates.\nYes, that is definitely the best way to fix this. I'm currently triggering timeupdate in setCurrentTime but as you mentioned, it makes fillBuffer and drainBuffer to be called twice.\nDo you have any idea to implement it? Trigger with an event object that has some data which can be considered as a our own timeupdate? Sounds not so good though... I'd like to somehow catch the events at the lower level however there is no lower level so far.\n. My original suggestion was having a timer for manual timeupdates, but having a timer for fillBuffer/drainBuffer sounds much better. Thanks!\n. ",
    "dananichev": "This is possible fix, but it leads to not accurate seek if something goes wrong. So, i think, this is not the best solution.\n. Yes, i tried to seek to different values. Between 0-320 seconds. For example, in this case 220 leads to this error and 240 is not. I mean, maximum is 320 (playlist with segments total 5 min).\n. For some reason, he can't find closest segment (tag) to specified seek value. As far as i understand.\nAlso i will try to prepare some public live stream demo for this case. Maybe it will be helpful. The only problem is that all streams are private.\nBut, i think, it will be easier to provide some specific debug info. Can you tell me what can i provide to you? Or describe parsing/playing/demuxing process?\nPlaylist example can be found in #144.\n. @dmlap Sorry i'm kinda busy right now. Wasn't able to provide any help. Thanks, i will try it!\n. ",
    "stevemayhew": "My pleasure...  Here's two URL's, the first plays, the second does not.\nhttps://hls-videojs-test.s3.amazonaws.com/21945.m3u8\nhttps://hls-videojs-test.s3.amazonaws.com/12979.m3u8\nLooks like segment-decoder is trying to skip the extra mpegts stream, there are logs about the unknown PID's \nGET https://hls-videojs-test.s3.amazonaws.com/12979/26109136797762/22401/3\nVIDEOJS: Unknown PID parsing TS packet: 4097\nVIDEOJS: Unknown PID parsing TS packet: 2\nVIDEOJS: Unknown PID parsing TS packet: 4097\nNot sure if the issues is with skipping the garbage in the mpegts or something entirely different.  But both streams play in Safari.\nAnything else I can help with let me know.  I'll write a test case if someone can figure out the bug ;-)\n. The theory that something is wrong with the segment-decoder may be debunked.  After stripping off the extra streams from the mpegts packets with ffmpeg:\nffmpeg -vcodec copy -acodec copy -f mpegts -i xxx xxx\nThe video is still not showing.\n. Sure.  Will do\n. @dmlap The first checkin failed jsHint, that is fixed.  The top of tree for the branch passes all the build tests (on my mac).   Here's the pull request.  Let me know if/where I should add tests:\nhttps://github.com/videojs/videojs-contrib-hls/pull/203\nAlso I'm looking at an issue with video/audio sync for the same stream.  I'll try to extract the transport streams that cause the issue.\n. The build is not failing with my last checkin?  Why does this message persist?  Is there something else I need to do.\n. Ah, that is this one:\n<>Running \"karma:phantomjs\" (karma) task\n <>PhantomJS 1.9.8 (Linux) ERROR\n <> TypeError: 'null' is not an object (evaluating 'toolbar.appendChild')\n <> at /home/travis/build/videojs/videojs-contrib-hls/node_modules/qunitjs/qunit/qunit.js:2534\nLooks like I need to fire up my linux VM?  We have had lots of trouble with PhantomJS tests, particularly on Windows.\nI'll try and see if I can reproduce it.\n. Thanks David.  I found the Transmux Analyzer test yesterday, great tool.  I'm expanding on it a bit to see if I can track down the nature of the issue.  I have a shorter sample MPEGTS file I'm working with, here to get a golden FLV file to use with Transmux Analyzer\n. Here's more background for you, I think the issue is VideoJS is generating incorrect timestamps on the FLV tags.  \nThe first few tags are where the problem starts, the negative DTS is used as the timestamp for FLV:\n| Tag | Size | PTS | DTS |\n| --- | --- | --- | --- |\n| metadata: | 92B | 0 | 0 |\n| video: | 58B | 0 | 0 |\n| video: | 28987B | 0 | -33.35555556 |\n| video: | 6715B | 33.35555556 | 0 |\n| metadata: | 121B | 0 | 0 |\n| audio: | 19B | 0 | 0 |\n| audio: | 376B | 0 | 0 |\n| audio: | 418B | 32 | 32 |\nLooking at the FLV file decoded we see this:\nxml\n<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n<flv xmlns=\"http://schemas.flvmeta.org/FLV/1.0/\" xmlns:amf=\"http://schemas.flvmeta.org/AMF0/1.0/\" hasVideo=\"true\" hasAudio=\"true\" version=\"1\">\n  <tag type=\"scriptData\" timestamp=\"0\" dataSize=\"77\" offset=\"13\">\n    <scriptDataObject name=\"onMetaData\">\n      <amf:associativeArray>\n        <amf:entry name=\"videocodecid\">\n          <amf:number value=\"7\"/>\n        </amf:entry>\n        <amf:entry name=\"width\">\n          <amf:number value=\"1280\"/>\n        </amf:entry>\n        <amf:entry name=\"height\">\n          <amf:number value=\"720\"/>\n        </amf:entry>\n      </amf:associativeArray>\n    </scriptDataObject>\n  </tag>\n  <tag type=\"video\" timestamp=\"0\" dataSize=\"43\" offset=\"105\">\n    <videoData codecID=\"AVC\" frameType=\"keyframe\"/>\n  </tag>\n  <tag type=\"video\" timestamp=\"-33\" dataSize=\"28972\" offset=\"163\">\n    <videoData codecID=\"AVC\" frameType=\"keyframe\"/>\n  </tag>\n  <tag type=\"video\" timestamp=\"0\" dataSize=\"6700\" offset=\"29150\">\n    <videoData codecID=\"AVC\" frameType=\"inter frame\"/>\n  </tag>\n  <tag type=\"scriptData\" timestamp=\"0\" dataSize=\"106\" offset=\"35865\">\n    <scriptDataObject name=\"onMetaData\">\n      <amf:associativeArray>\n        <amf:entry name=\"audiocodecid\">\n          <amf:number value=\"10\"/>\n        </amf:entry>\n        <amf:entry name=\"stereo\">\n          <amf:boolean value=\"true\"/>\n        </amf:entry>\n        <amf:entry name=\"audiosamplerate\">\n          <amf:number value=\"32000\"/>\n        </amf:entry>\n        <amf:entry name=\"audiosamplesize\">\n          <amf:number value=\"16\"/>\n        </amf:entry>\n      </amf:associativeArray>\n    </scriptDataObject>\n  </tag>\n  <tag type=\"audio\" timestamp=\"0\" dataSize=\"4\" offset=\"35986\">\n    <audioData type=\"stereo\" size=\"16\" rate=\"44\" format=\"AAC\"/>\n  </tag>\n  <tag type=\"audio\" timestamp=\"0\" dataSize=\"361\" offset=\"36005\">\n    <audioData type=\"stereo\" size=\"16\" rate=\"44\" format=\"AAC\"/>\n  </tag>\n  <tag type=\"audio\" timestamp=\"32\" dataSize=\"403\" offset=\"36381\">\n    <audioData type=\"stereo\" size=\"16\" rate=\"44\" format=\"AAC\"/>\n  </tag>\n  <tag type=\"video\" timestamp=\"33\" dataSize=\"8258\" offset=\"36799\">\n    <videoData codecID=\"AVC\" frameType=\"inter frame\"/>\n  </tag>\nWe generated a FLV file that does play properly using ffmpeg, dumping the tags in that we see it generates the single opening metadata tag with the framerate for both audio and video, and it delays sending the AVC frames until it has sent the AAC audio frames that have earlier timestamps, and is computing different timestamps on the AVC packets\n``` xml\n<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nisom\n\n\n512\n\n\nisomiso2avc1mp41\n\n\nLavf54.59.106\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```\n. Duh, yes...  I'm working on it still too.  I've got some code that uses NodeJS to generate the FLV file from the TS.  With that I can experiment with tag order and timestamp values (which appears to be the net of the issue).\nI'll put up a branch of that code (sloppy right now, existing videoJS is not require/node friendly yet) if it helps you.\n. Here you go:\n    https://github.com/stevemayhew/videojs-contrib-hls/compare/commandline-flvgen\nReach me on Skype (mayhew.steve) if you want to collaborate on the audio sync fix more in real time.\n\nOn Feb 2, 2015, at 8:43 AM, David LaPalomento notifications@github.com wrote:\nYeah, that would definitely be helpful.\n\u2014\nReply to this email directly or view it on GitHub https://github.com/videojs/videojs-contrib-hls/issues/208#issuecomment-72489987.\n. I think this is the function where the issue comes (cleaning up the cryptic self-modifing code is also called for ;-)):\n\n``` javascript\n    //(pts:uint, dts:uint, dataAligned:Boolean):void\n    this.setNextTimeStamp = function(pts, dts, dataAligned) {\n      // on the first invocation, capture the starting PTS value\n      pts_offset = pts;\n  // on subsequent invocations, calculate the PTS based on the starting offset\n  this.setNextTimeStamp = function(pts, dts, dataAligned) {\n    // We could end up with a DTS less than 0 here. We need to deal with that!\n    next_pts = pts - pts_offset;\n    next_dts = dts - pts_offset;\n\n    // If data is aligned, flush all internal buffers\n    if (dataAligned) {\n      this.finishFrame();\n    }\n  };\n\n  this.setNextTimeStamp(pts, dts, dataAligned);\n};\n\n```\nLooking at other FLV muxers, they look for a negative DTS to result from the initial start time adjustment then invert and add that negative value back to the Timestamp written to the FLV file.\nI'll try the fix and put up another branch / pull if it works.\n. Yeah, me too.  How about:\n1. resolvePlaylistRelativeUri\n2. playlistUriToUrl\n3. resolveUrl (might be hard to search for vs similar names)\nPersonally I like option 2 best, we are resolving a URI in the playlist (which may be a URL) to a URL.  PS, for people that always confuse the two (like me ;-)).   Here's a simple non-geekly explanation of the difference that is pretty accurate URL vs URI\n. ",
    "shanepoints": "@dmlap, do you know why emulation causes failure?  I was a bit worried earlier when all (emulated)android devices were failing when attempting to load hls.  Testing on the real devices revealed that the stream was loading perfectly, and playing as expected.  So why does the Chrome Android emulator cause this to fail?  I was able to reproduce this issue with the live example, http://videojs.github.io/videojs-contrib-hls/ , also. \nOS 10.11.3 \nChrome 48\n. This is causing me pains as well.  The player does not seek to the beginning, but the larger problem is that I cannot bind any actions using the vjs 'ended' event: \nPlayer.on('ended', function(){\n   //Do something when the video ends\n});\n. I seem to have isolated this problem to situations where the Player instance has called the dispose() method and then re-initialized a new player.  \nFor example, I have a playlist on a page.  Clicking on a video in the playlist calls dispose() on the current Player and then re-inserts a new video tag and initializes a new player instance. The 'ended' event is registering properly for the first video that loads... however the second video(and subsequent videos) will not register this event.\nThis issue is only encountered when loading an HLS stream.  It cannot be reproduced when mp4 or webm are in use.  Tested on latest versions of Chrome and Firefox.\n. ",
    "amfr": "I'd be happy to add unit tests.  The only problem is I'm not sure how to mock out ajax timeouts in pure JS.  It seems like we would need some server side support correctly testing timeouts, but it doesn't seem like the karma server supports that.  I was thinking of trying to hit a URL such as http://www.google.com:81 which will cause a timeout, but this isn't guaranteed to work in the future.  Should I push a test with that included for now?\n. So I added a test that fails on the old code and passes on the new code, but it's a bit hacky.  The problem is that sinon doesn't actually ever call ontimeout, even if a timeout is specified (and I wouldn't necessarily trust it to call ontimeout/onreadystatechange in the same order that the browsers do anyway).  Therefore, this test will hang on the old code.  As such, I added a timeout that will auto fail the test after 10 seconds.  I feel like this isn't really testing the right stuff for the old code though.  Any suggestions?\n. Thinking about it more, I'm not sure that there is even a way to create a reliably failing test for the old code, since the error relies on something that is, as far as I can tell, undefined behavior (i.e. the order of ontimeout vs. onreadystatechange callbacks in the browser).\n. Hey, any updates on this? Sorry to be pushy, but we're actually having problems with this in production.\n. The test should be in a better place now.  Let me know if you need any more changes.\n. Actually I don't think we need it at all.  It can't go before the clock.tick() anyway because the timeout function will already have been created by then.\n. Added a new test file for XHR.  Decided not to move the second test there since it isn't really testing xhr functionality.\n. We still want the onreadystatechange handler to fire here because that's what actually handles the timeout\n. Is there another file where this would make more sense? If not, should I create a new one? And lastly, should I move the test above it along with it?\n. ",
    "jtennen": "Although that does simplify the code, the issue persists in all browsers. \n. It appears the issue is the same as 141; the mediaIndex is incremented after the segment aborts.  The mystery, then, is why the apparent fixes seem to cause the audio stream to not load properly.\nOther methods I've attempted include shifting the getMediaIndexByTime call to after the segment abort and simply decrementing mediaIndex if aborted (obviously a bad idea, but proves the point.)\n. The segmentXhr would definitely be causing the mediaIndex to increment.  However, further testing reveals that the audio fallback DOESN'T fail if the initial time seek is directly on a new segment.  For bipbop, initial seek to 60 results in audio as normal, whereas 61 or 59 will both result in no sound.  This seems to indicate that an issue also lies in seeking to a nonzero offset relative to the current segment.  \nThis would also explain why it would have audio without fixing the mediaIndex; in the repo version, you'd seek to :45 -> segment aborts, mediaIndex increments -> new segment starts at :50, so the furthest back it'll go is the start of the segment.\nAgain, though, this is only a problem in regards to seeking while the video is playing.  I haven't figured out how to work around it for the initial seek (yet), but the same issue would apply to seeking at all while the video is playing.  Seeking while the video is paused works fine (though the initial seek is still bad as I've described).  Would someone with more experience/insight to the code than I be willing to lend a hand to the matter while I continue digging?\n. #156 fixed it, but also I was listening for the wrong event.  The corrected code is being added to the first post.  Will continue testing.\n. One issue I seem to be having is that sometimes on loading the page, the video is blank.  Sometimes it'll act as though the video completed, sometimes seeking will correct it, and sometimes it'll eventually load with no sound like we were experiencing earlier.  I'm wondering if something isn't being cleared out on page change (actual different video or refresh), as that would parallel earlier problems.\nPreliminary poking around in the console shows, whenever this is happening, the play icon changes to pause (indicating the player thinks it's playing) but it's stuck in loading.  I can see the XHR request for the segment go through, and then the requests for the entire rest of the video.  Pausing during this time indicates duration = 0, thus triggering the behavior for the video completing.\nOn a similar note, I noticed that player.dispose() is not called when you exit the page; is it advisable to manually call player.dispose() in handling onbeforeunload?\n. The code in the OP does not seem to work in 0.9.2 after subsequent page views, in Chrome 38; Firefox seems okay, and Chrome 37 seems to trigger the issue in my previous comment much less frequently.  The symptoms are a) the video scrollbar seeks to the current time, but the video itself is stuck on loading for a very long time; b) after the loading stops, either the video simply doesn't play from this point or (rarely) the current time will jump into several hundred minutes; c) seeking during this load often (not always) results in no audio.\nNoticed some interesting behavior in the console.  The XHR requests I mentioned are being generated by 'fillBuffer(),' which is a direct result of a constant stream of 'timeupdate' events, even though the player's time has not changed (it stays stuck on the time I seek to).  This also triggers 'drainBuffer().'\nInterestingly, 'timeupdate' is being passed to 'drainBuffer()' via the 'offset' parameter, which strikes me as odd.\nThat's as far as I've been able to track it down.  I'll try to whip up an example page on jsbin, but surely I'm not the only person trying to accomplish this; I'm just not certain what the right way to do it is.\n. Yes.  Corrected.\n. Seconding that it's not entirely clear.  The example.html page is very useful for testing changes to the source code; however, I believe a second example page based off the compiled code (located in /dist/videojs.hls.js) would be very helpful for getting started.\nI believe you need at minimum to import videojs.hls.js, videojs-media-sources.js, and a distribution of video-js (including the .SWF to pass to the constructor), though please feel free to correct me if I'm incorrect here.\n. So I thought, yet I see a handful of them with time calculated incorrectly (checked Chrome vs. Safari, which does not utilize the plugin).  Each discrepancy is exactly [playlist.targetDuration] seconds long, and when viewing the data returned in a video player (in my case, VLC), I can see that the last segment returned by Brightcove does not play at all.  Unfortunately the playlists that exhibit this behavior appear to be proprietary.\nThe following workaround seems to account for this using the reasoning stated above, though I'm not certain it doesn't violate intended behavior:\n[...]\ndur += (segment.duration !== undefined ? segment.duration : playlist.targetDuration || 0);\n[...]\nOff the top of my head, this kind of segment shouldn't even be calculated; it may exist as a result of using \"<\" instead of \"<=\" but relevant video data ends at the second-to-last segment.  The zero-length segments is probably bad data (I do not have control over the original video, only what I access via CDN), so I don't think particular thing is general case.\nWill try to get an example playlist in the near future.\n. ",
    "q2apro": "\nc) seeking during this load often (not always) results in no audio.\n\nI stumbled over the same problem with the latest videojs. When jumping through the video, suddenly the audio stops. I have a pseudo-streaming php script (that reads byte ranges). Note: The mp4 has a mono audio stream\nDoes somebody know a fix?\n. ",
    "t2y": "OK, I will.\n. Sorry, diff is not acceptable.  I rebased trunk, then added only  fdc5c5bc9f12ee32aa8ab1d7056587b4550a48b1 for testing.\n. ",
    "diogopms": "Yes that right. If i play the video widhtout seek i dont see this error\nThanks\nNo dia quinta-feira, 2 de Outubro de 2014, David LaPalomento \nnotifications@github.com escreveu:\n\nIf you play back the video without seeking, you don't see that error?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/videojs/videojs-contrib-hls/issues/163#issuecomment-57668639\n.\n. \n",
    "sblandford": "Perhaps a sentence on the Getting Started section referring to the example.html page would be helpful.\nAlso the code shown in the \"Getting Started\" section doesn't get anyone started. It doesn't work. If a whole bunch of .js and .css files are required to make it work then I suggest it either be listed right there or the code removed altogether and a pointer to the example.html page put there instead.\nFor me the confusing thing is how many .js files actually need to be included or not since I managed to get the player to work with both Flash and on Android/IOS sans Flash from an example page that only uses video.js, video-js.css and hls_streams.js. http://www.flashls.org/videojs/flash_demo.html.\nUpdate: I've been a bit clueless. I can see that the various JS files are all included in the distribution videojs-hls.js file. However this still means that the example.html file isn't really a real-world example because most applications would be using the compressed js files. So an example on the \"Getting Started\" section that actually plays, for example, a live HLS TV stream might be useful.\n. OK. This is a simple demo I just tested. I created the environment as follows...\n- Download the video.js from http://www.videojs.com/ and unzip\n- Create a sub-directory called \"videojs-contrib\" and in this directory...\n- Download the videojs-contrib-hls distibution file from https://github.com/videojs/videojs-contrib-hls/releases\n- Download the videojs-media-sources.js distribution file from https://github.com/videojs/videojs-contrib-media-sources/releases\nI found that the video-js.swf file seems to be broken in the current release, at least with videojs-hls. So I downloaded the SWF file used on the working demo page, http://www.flashls.org/videojs.\n- Download http://www.flashls.org/videojs/video-js.swf place in the top directory (where your index.html file will be)\n- Create the following index.html file. The videojs and videojs-contrib directories should be below this location.\nThis should load a live TV channel and play it.\n```\n<!DOCTYPE html>\n\n\nvideo.js HLS demo\n\n\n\n\n<script type=\"text/javascript\">\n  videojs.options.flash.swf = \"video-js.swf\";\n\n  function loadStream(url) {\n    var vid_obj = videojs(\"example_video_player\");\n\n    vid_obj.src(url);\n    vid_obj.on('loadstart',function(){\n        vid_obj.play();\n    });\n  }\n</script>\n\n\n\n\n\n\n\n```\n. ",
    "ptz-nerf": "Does this work? I just tested my hls stream on http://www.flashls.org/videojs/flash_demo.html. Stream works. But using video.js v4.9.1 and example above(by sblandford) nothing works(error: No compatible source was found for this video.).\nUpdate: Sorry, it works! But it is necessary to specify 'video/mp4' type, not 'application/x-mpegurl'. I think it is flashhls bug.\n. gkatsev, is there some working demo with native swf, where I can test my stream? \n. ",
    "campones": "a very meaningful post.. indeed, for random users, this tech is hardly applicable. \nI gave up trying and I am using mangui video-js.swf that works out of the box\n. Same here, on last chrome (win7)\nhttps://i.gyazo.com/a16a4910a8be914fae04678f16e32688.png\nOn Firefox, also \nhttps://i.gyazo.com/5a5915ea925fce6522eee30e1207e89a.png\nPlays very well on my android 4.0.4 (xperia)\n. and I did what op did, rolling back to previous version. Now it doesn't stop downloading .ts files but video isn't fluid, there are  plenty micro freeze (maybe between each segment). Sound is ok, no cut\n. yes there is a substitute, based on the flash player \nhttps://github.com/mangui/video-js-swf\nThis is very stable, I m using for over a year. Of course  the interest in hls.contrib. is to get rid of flash \n. same for me.\nI setup a low bitrate tv live stream, and on chrome, it stop after 5 6 segments. (using last chrome)\nCuriously I tried on an old xperia from 2012 running android 4.0.4 and it plays perfectly..  Which is kind surprising for me to see something running smooth on mobile and not on my desktop.\nWaiting for further development on this because I think this is highly interesting (getting rid of flash player)\n. same happen if your internet is too bad and can't follow the stream. It will stop dl .ts file while .m3u8 are still downloaded. It should at least try to fetch new segments\n. Sorry I can't tell, I work with single bitrate streams\n. could you show me an example of flash fallback using videojs-contrib-hls?\ncurrently I m using hls.js  and the only solution has been to setup 2 sources with 2 different extension ( application/x-Mpeg and video/mp4 )\nit seems videojs-contrib-hls has a builtin flash fallback feature so I would love to see a proper setup for this, possibly using the html player setup . yes I realized later it was now totally automatic . same here with 4.0.3\nps:  just putting back my hls.js (mangui) + the adaptation for videojs (https://github.com/benjipott/videojs-hlsjs) and the stream recover even after pausing the playback for 10min or more. ok sorry there is actually nothing to setup, except removing the second source :)  \ngreat work, thanks. working fine now on my end,  that's great! . yea, i m testing last videojs contrib hls (5.4.0) along with videojs (v5.19.1) and it behave really badly, especially and start a long pause..  first I don't see why it needs to download all segments of the playlist to start streaming, that makes the thing very slow for people with bad internet connection.  Plus, it download segments in wrong order, or sometimes even twice.. if you check the console you know the stream is coming, but for regular users, they just think it isn't working..\nhttps://i.gyazo.com/475828eab1aca09a00ac206b7a29c754.png\nps: interestingly I was in a skype call when I did that screenshot, and when I close the call, things seems to works much better. Note that I have a bad internet connection (ping and bandwidth) \nps2: seems I was wrong, still closing skype, and after a long pause, clicking play: \nhttps://i.gyazo.com/2eee24126a8611a406bef9e6fa92eb69.png\nI had to download that amount of data and like 4 segments, many twice, to finally get the stream starting.. . \"However, when using flash, it plays the audio with no video (and starts immediately).\"\nthis is normal, there are parameters if you want to change that behavior in the rtmp streamer. either it plays audio immediately or you set it up in a way it sync with the video, which takes more time to play. usually the default is the best so your users know it's working . they would work in the modified version of mangui flash player that can play m3u8 , but as said, in the hls html5 version you need cors to be setup properly. if you don't own the m3u8,  nothing you can do about it. no sorry but the segment contains both audio and video.   \nI tested in last chrome win7 x64. actually it is funny..  I have  been switching to another stream type, pseudo live, meaning those are pre-encoded files with ffmpeg that I stream, and not real live streaming that I restream ,and then it starts on first segment.\nSo  one possible reason would be the metadata?\nStill the hls.js library along with the benji-pot videojs integration is able to play those real live streams after downloading one segment, unlike videojs-contrib-hsl. so yea, taking that into account I just tried restreaming a live stream but this time, reencoding also the video track, using libx264 , and indeed videojs-contrib is able to display the video after the first segment.  \nObviously usually, I never encode the video track since this is very cpu consuming and not necessary with hls.js  \n/usr/local/bin/ffmpeg -re -i pipe:0 -c:v libx264 -c:a libfdk_aac -f flv  will work on first segment\n/usr/local/bin/ffmpeg -re -i pipe:0 -c:v copy -c:a libfdk_aac -f flv   will need to download 2 segments to start.\nThis is rather surprising since the original video track is anyway in h264 codec video, but native as per ffmpeg\nStream mapping:\n  Stream #0:0 -> #0:0 (h264 (native) -> h264 (libx264))\n  Stream #0:1 -> #0:1 (aac (native) -> aac (libfdk_aac)). I did a little media info on both segment\nvideojs-contrib need 2 segments\n```\nGeneral\nID                                       : 1 (0x1)\nComplete name                            : D:\\Downloads\\test1-3.ts\nFormat                                   : MPEG-TS\nFile size                                : 8.60 MiB\nDuration                                 : 18 s 0 ms\nOverall bit rate mode                    : Variable\nOverall bit rate                         : 3 642 kb/s\nVideo\nID                                       : 256 (0x100)\nMenu ID                                  : 1 (0x1)\nFormat                                   : AVC\nFormat/Info                              : Advanced Video Codec\nFormat profile                           : Main@L3.1\nFormat settings, CABAC                   : Yes\nFormat settings, ReFrames                : 3 frames\nCodec ID                                 : 27\nDuration                                 : 20 s 0 ms\nBit rate mode                            : Variable\nMaximum bit rate                         : 3 303 kb/s\nWidth                                    : 1 280 pixels\nHeight                                   : 720 pixels\nDisplay aspect ratio                     : 16:9\nFrame rate                               : 25.000 FPS\nStandard                                 : Component\nColor space                              : YUV\nChroma subsampling                       : 4:2:0\nBit depth                                : 8 bits\nScan type                                : Progressive\nColor range                              : Limited\nColor primaries                          : BT.709\nTransfer characteristics                 : BT.709\nMatrix coefficients                      : BT.709\n```\nvideojs-contrib need only 1 segment:\n```\nGeneral\nID                                       : 1 (0x1)\nComplete name                            : D:\\Downloads\\test1-25.ts\nFormat                                   : MPEG-TS\nFile size                                : 3.79 MiB\nDuration                                 : 18 s 280 ms\nOverall bit rate mode                    : Variable\nOverall bit rate                         : 1 228 kb/s\nVideo\nID                                       : 256 (0x100)\nMenu ID                                  : 1 (0x1)\nFormat                                   : AVC\nFormat/Info                              : Advanced Video Codec\nFormat profile                           : High@L3.1\nFormat settings, CABAC                   : Yes\nFormat settings, ReFrames                : 4 frames\nCodec ID                                 : 27\nDuration                                 : 23 s 520 ms\nWidth                                    : 1 280 pixels\nHeight                                   : 720 pixels\nDisplay aspect ratio                     : 16:9\nFrame rate mode                          : Variable\nColor space                              : YUV\nChroma subsampling                       : 4:2:0\nBit depth                                : 8 bits\nScan type                                : Progressive\n```\nnot sure why the difference but maybe you do. follow up.. \n. hi,\nfor example this live stream need 2  (or even 3) segments on chrome to start \nhttps://goo.gl/eQ4GKz\nthis other live stream (pseudo live already reencoded with ffmpeg) needs only one segment\nhttps://goo.gl/xokSb1. first, thanks for your (long) answer. \nThis is what I am using to stream or restream. Maybe you see some directives that could resolve that issue like maybe hls_sync? \nhttps://github.com/arut/nginx-rtmp-module/wiki/Directives#hls\nI didn't really understand how this target duration is created. I realize that having pre.encoded with ffmpeg helps doing a smoother streaming and create a better playlist, somehow.  \nAlso, it is normal a video stream to be heavier in term of bitrate than a cartoon.  Actually this stream is web ready (it's just the one I got from their iphone app.. )\nI cannot re code 30 live streams in real time, that would take a huge server just for that purpose. And remember, I m currently using a 2015-16 version of hls.js with hlsjs videojs integration from benjipot, and I don't have this issue thankfully. \nThe reason I m using 20s segment is basically because the token is created via php-fpm and when I got hundreds of users on a single server, if I setup a 5s segment, it will multiply the number of requests and they ll soon get a 502 bad gateway response from nginx..  Basically too many requests.  Maybe my server isn't strong enough but this also is costly.. any updates on this?. kinda make laugh to see that this and that is supported but when I m doing some test, only some streams are actually working with videojs-contrib, while they are all working with hls.js, even with a 2 years old library.  . ",
    "Tralapo": "This issue has been silent since December last year, but I would like to support this. I don't want to be negative, I just want to explain how difficult I find it to use this tech so you guys, who know this stuff very well, can maybe use this to make it easier for people to understand.\nIn my opinion, \"Getting started\" should, just like over at the main video.js, be enough to actually get started. Over here, it isn't. I did develop a few websites over the years and I do use video.js with success, so I do have some coding experience and feeling, but I've never ever once got this tech working.\nAt the moment, the Getting Started is suggesting that, next to the video.js files (can I use the CDN hosted fikes, like video.js advices in their Getting Started? Or do I need to use unminified Dev versions?), you just add:\n<script src=\"videojs-media-sources.js\"></script>\n<script src=\"videojs-hls.min.js\"></script>\nWhich is not the case. It won't work. You just get 'No compatible source found'. By the way, videojs-hls.min.js isn't even available to download, so you have to change it to videojs-hls.js, which is a bad first impression.\nBut, as said, it just won't work (for a HLS live stream that is). So, confused as you are, you open 'example.html'. Where you find a lot of files included. And I really mean a lot. Should I include all of them too? Why aren't they mentioned in the Getting Started? What do they do? Are they important? I don't know. Some of them use node_modules, but are traceable to media-sources or video.js itself, so that's fine and I can find those files over there. But this? What is this?\n<script src=\"node_modules/pkcs7/dist/pkcs7.unpad.js\"></script>\nI don't know. Do I need it? Where do I have to get it? It's just confusing.\nIn the release blog for Video.js 5.0, they speak very enthusiastic about the 1.0 version of contrib-hls coming up soon. And using HLS in browsers without Flash IS amazing. But video.js itself can be very easily deployed, even by people who almost never code. You just copy 'Getting Started' and it works. This isn't. Especially because of the fact contrib-hls is now named in the 5.0 release blog, it should be more noob-proof. It would be a shame if all the hard work is for nothing, because people can't get it to work.\n. @forbesjo You appear to be right, the /dist folder is just missing. That explains why the files found in the repo don't work and the Getting Started is confusing.\nI see @dmlap is addressing this in #291 too.\n. Offcourse. But if you want your project to be easy to deploy for everyone (like Video.js itself is!) it should be included, because not everyone is able to build it.\n. Is v 1.0 delayed? The blogpost about Video.js 5.0 is speaking about it with a lot of enthusiasm, and it sounds good, but it's not released yet?\n. Any idea when it will be, @gkatsev? And will it contain a /dist folder by then? (#167)\n. @dmlap I found out how to build this and gave the development branch a try with VideoJS 5. Worked quite well! Used it with a HLS livestream, created with Wowza. I had a few issues:\n- In Firefox, the loading spinner keeps spinning while the video was already playing. It won't go away.\n- In Chrome, it looks OK, apart from one problem, which is a bit specific maybe: I used to use the code below to assure the stream would always start at the most recent point again, after someone had pressed pause and play again after a few minutes\n```\nfunction yourSweetReadyFunc() {\n  var player = this;\n  player.on(\"pause\", function () {\n    player.one(\"play\", function () {\n      player.load();\n      player.play();\n    });\n  });\n};\nvar myPlayer = videojs('my_video_1', {}, yourSweetReadyFunc);\n```\nThis does not work with VideoJS 5 and the development branch of videojs-contrib-hls. In Firefox the stream will restart but at the point I pressed pause, in Chrome the stream won't start again and goes black. 9 out of 10 times I get this in the console. Any idea?\n\n- Edit: The HLS-stream stops after about 10 seconds in Firefox, with a 'unknown network problem' in the console. In Chrome this does not happen. I would think it's not able to grab a new chunklist?\n. I set the media.mediasource.whitelist to false and now it keeps playing in Firefox. But that's not a workable situation then, it should fall back to Flash I would think. I can't notify all my users to disable the whitelist.\nNow, in Firefox with the whitelist disabled, the behaviour with my play/pause is the same as in Chrome: black screen and network errors in the console. Not the one Chrome is showing by the way.\nIn Internet Explorer I get the classic The media could not be loaded, either because the server or network failed or because the format is not supported. after pause/play.\n. @dmlap I gave this another try with a HLS livestream created with the NGINX-RTMP module, and this stream isn't working at all. In all browsers the screen is black and the spinners keeps spinning. Nothing in the Console, I can see it's downloading chunklists and files.\nStream does work in Microsoft Edge, which has native HLS-support.\n. @dmlap Did a new build today, the infinite spinner in Firefox is gone. Edit: If I set media.mediasource.whitelist back to true (standard) in Firefox, I can play now (I couldn't before, so that's good), but the infinite spinner is back too. With the whitelist disabled everything is fine.\nMy problem about restarting in https://github.com/videojs/videojs-contrib-hls/issues/382#issuecomment-146238131 still exists.\nEdit: It looks like Firefox (whitelist enabled) is choking itself. It keeps downloading the same .ts chunk over and over and over again. Pressing pause in the player won't stop it. This is when the spinner is spinning by the way. Strange thing is the stream does keep playing (not looping). Eventually Firefox will crash.\n\n. Updated to Firefox 42 (64 bit version!) and HLS now stopped working at all. Video won't load, nothing.\nConsole gives me this:\n\n. @DJaeger Well, you can try that for your own situation by just downloading and building the development branch? I mostly have some problems with Firefox.\n@dmlap Yes, I will create an example for you later today\n. @dmlap Here is my example: -- link removed --\n. @ChiliChili I use the latest build of the development branch\n. @dmlap Did a new build today, still no luck in Firefox I'm afraid.. \n. @dmlap I do. This is the one that's causing trouble for me in Firefox: -- link removed --\n. @dmlap Looking forward to that! Thanks for the help.\n. @dmlap This is freaking bizarre. I was playing around with example.html and indeed found my stream was working there. After a lot of trying, copy-paste and other stuff, I finally made my own example work in Firefox.\nI found out it was still failing, because I had no poster specified.\nThis is working, not mentioning a poster at all:\nhtml\n<video id=\"Video\" class=\"video-js vjs-default-skin vjs-big-play-centered\" controls preload=\"none\" width=\"640\" height=\"360\">\nThis fails, an empty poster:\nhtml\n<video id=\"Video\" class=\"video-js vjs-default-skin vjs-big-play-centered\" controls preload=\"none\" width=\"640\" height=\"360\" poster=\"\">\nHow about that............\n. @dmlap Although I still got a lot of error messages in the console (most of them seem to come from video.js itself by the way) I decided to go ahead and use this tech in a live environment because it's working fine with all my browsers and mobile devices.\n\nI get a lot of complaints from people with Internet Explorer 11, especially from Windows 7. I personally use Windows 10 and Internet Explorer 11 is fine here, what would cause errors in W7 then? Is that browser much different from the one in W10? I would say it wasn't?\n. I found out MSE is not supported by Internet Explorer 11 in Windows 7? https://msdn.microsoft.com/en-us/library/dn594470(v=vs.85).aspx\nShould it fall back to Flash then? How does that work exactly?\nEdit: I see it does fall back to Flash, but the loading spinner isn't always hiding. I 'fixed' this for now by disabling the loadingSpinner completely in the data-setup.\nCPU usage with Flash is exessive, much higher then with the normal version of Video.js. Is it a bug, or is that as expected with HLS?\n. This was discussed in #167 too. For people who don't know how to build it, this plugin is not usable right now. Should be made easier to deploy by including the build.\n. Download -> npm install -> grunt build works for me.\n. I used to use the code below with the default video.JS (so without this contrib-hls) to make sure it would always load the most recent part, both for RTMP on desktop and HLS on mobile.\n``` javascript\nfunction yourSweetReadyFunc() {\n  var player = this;\n  player.on(\"pause\", function () {\n    player.one(\"play\", function () {\n      player.load();\n      player.play();\n    });\n  });\n};\nvar myPlayer = videojs('my_video_1', {}, yourSweetReadyFunc);\n```\nBut with contrib-HLS, this code no longer works, you end up with a spinner only. Maybe someone could provide help with that? It would fix the problem you describe.\n. Even YouTube does that with livestreams, so I guess it's kind of a standard to start again where you stopped before. I don't think it's a logical thing, but a lot of people seem to think it is.\nI'm perfectly fine with using a workaround. Do you have any idea how to change mine above to make it work for contrib-hls? It works on places (mobile) where hls is native, but it breaks with contrib-hls in desktop browsers.\n. @dmlap You say \"The goal behavior would be to rejoin the live stream at the moment closest to when you stopped playback\", but I don't think that is logical behavior for a live stream. Rejoining at the moment closest to when you stopped, isn't live. It's more like VOD. In my opinion, it should just jump to the most recent part: that's live.\nIf I turn off my TV and turn it on ten minutes later, I missed ten minutes. It's not displaying things that happened on TV ten minutes ago, that would be weird. Why is it normal for HLS?\nApart from that, it will fail anyway. My server does not store the chunks forever, if I pause a stream for 10 minutes and then hit play again, it would play the latest chunks it had available and will fail after a few seconds because of 404's. Another reason why it should download a new playlist en jump forward.\n. @ogzpub Does not work\n. The stream in your example is working for me (except in Firefox, which is, as always, complaining about origin of the stream). Are you sure your video.js file is build right? I would think that's the problem if it's not happening with the CDN-version?\n. I have a page with four players and those streams only show the video after hitting play/pause a few times. In the meantime, it's downloading .m3u8 and .ts files as expected and normal.\nThe MediaSource.addSeekableRange() error is coming up all the time when the stream is up and running. After 30 seconds of playing, my console counted 275 of those errors. That's with one video playing, but it's picking up that error from the other players too (as they do download .ts files while they aren't playing).\nA second time I tried it only came to ~50 errors in the console. So it seems to be a bit random to me? On a page with only one player, the error seems to stop after 4-5 times.\nBut, to be short: it's not possible to start a stream directly. I have to press pause/play several times for the video to show up.\nWith <1.2.2 everything is fine.\n. With 1.3.0 and Video.JS v5.3 Chrome still trows a Uncaught InvalidStateError: MediaSource.addSeekableRange() can only be invoked when the duration is Infinity at me, but only once and it does not prevent the stream from starting like it did in 1.2.2. \nSo it doesn't look like it's still a problem.\n. I'm not experiencing the kind of lag like you show in your video, but when Flash is used my streams do have hiccups where the stream stops for a millisecond and then jumps ahead again (Firefox 42, media sources disabled, Windows 10). \nOn Windows 7 with IE11 (where MSE is not supported), I also have some 'snow' from time to time.\n. I'm using the development branch in a live environment for some time now. There are some bugs, but on the other hand: the master branch isn't working at all with Video.JS v5.\nSo I think it's a good idea.\n. Looks like development is now merged in master? Correct?\n. @dmlap I did a new build with the latest commits from @imbcmdth and found out something interesting. Tested again with Firefox 42, MSE disabled in about:config.\n- First, loading the page;\n- Hit play;\n- The loading spinner stays visible, stream stops after the first .m3u8 file ends (3 .ts files);\n- Hit pause, hit play again;\n- Video reloads, loading spinner disappears this time and stream will keep on playing without stopping;\n. Latest commits did indeed fix this problem. But now it's the HTML5 one that's breaking after a few segments (#483).\n. I see exactly the same behavior as @billybobilly. Flash did this before (#471) but is now fine.\nThe stream seems to break the moment the first segment of a new list is downloaded in my case.\n. Tried this again with the latest commits from @imbcmdth and it's still terrible. I get the feeling the stream is even dropping earlier then it did before. No console errors, m3u8-files are downloaded, not the .ts files inside after the first m3u8 ends.\nI use contrib-hls v1.2.0 in production(!) for quite I while now and it's working perfectly. Don't know what went wrong after that.\n. I use VideoJS v5.2 and contrib-hls 1.2.0 in production without much problems.\n. Android has native HLS-support just as Microsoft Edge. That browser works fine too, because of that. That's how this plugin works, it kicks in if there's no native support and makes it work through Media Source Extensions like in Chrome or Firefox. It switches back to Flash if there's no support for MSE, like in IE11 on W7 for example.\n. @u0x01 I did a test and that one does indeed work in all versions.\nBut your example looks more like some kind of VOD thing other then a real livestream.\n. I believe not. I'm sticking with videojs-contrib-hls 1.2.0 for now, that one works perfectly fine. Something failed after that.\n. Well yes, obviously, just this repo. But I use development version 1.2.0. Not the current one, 1.3.3.\n. Problem still there in the most recent version /*! videojs-contrib-hls - v1.3.4 - 2016-01-13\n. @u0x01 https://gist.github.com/Tralapo/9f2b789b6c5ca28994e4\n. > What version of videojs-contrib-media-sources are you using? \nGood question, because I'm still not convinced of the need for that one, maybe @dmlap can comment on that? I test sites with contrib-media-sources loaded and sites without it and I do not experience any difference between the two.\n\nSo you're using hls 1.2.0 and videojs 5.2.0, correct?\n\nNo, I'm using videojs-contrib-hls 1.2.0 together with videojs 5.4 (CDN loaded) at the moment, without problems.\n\nChrome, which uses the Flash player\n\nI think something is wrong with your setup then, because Chrome does not fall back to Flash if you use videojs-contrib-hls.\n. @jhumbug No, I'm sorry, I can't share my stream unfortunately. The example you give doesn't work for me either. This one does: http://playertest.longtailvideo.com/adaptive/bipbop/bipbop.m3u8 \nBy the way: videojs-contrib-media-sources is now deleted from the readme, so you indeed do not have to include it anymore.\n. @imbcmdth @dmlap The problem is still there in 1.3.5.\n. @jhumbug No, that's not it. It always fails after the first m3u8 is finished. With or without switching tabs.\n. @dmlap Tested with 1.3.7 and Video.js 5.4, 5.5 and 5.6: still no luck. Stream still breaking after first .m3u8 list ends. \n. Did a new build today and it seems to be working? Finally? More people that can confirm?\n. @mikeevstropov I can. My working copy of version 1.3.8: https://gist.github.com/Tralapo/94291509f987d0d56e05 . I use it with Video.JS 5.6 now.\n. @raj2569 Do a build of this repo today (2.1.1 I see it's called now) and try it with the CDN version of 5.8. Works for me.\n@billybobilly I think it should be closed indeed.\n. #483 \n. The last version I have absolutely no problems with (even in use on a live site) is 1.2.0, with 1.2.2 I ran into #460. In the versions after that #460 was fixed, but this issue and #483 appeared... \n/*! videojs-contrib-hls - v1.2.0 - 2015-11-21\n. @imbcmdth @dmlap Problem still there in 1.3.5.\n. Try this one, 1.2.0, works for me: https://gist.github.com/Tralapo/9f2b789b6c5ca28994e4\n. @hybrisCole Shame it doesn't work for you. I use the 1.2.0 in my gist for I while now on my website without problems. \nI do not use videojs-contrib-media-sources by the way. There's no need to include that. It's removed from the readme now too. Maybe you have more luck after dropping videojs-contrib-media-sources.\n. Did a new build just now, after reading #552 and reading his comment about .min working and indeed the problem seems to be finally fixed?! My streams keep playing now @dmlap \nBoth minified and non-minified by the way, can't reproduce the problem reported in #552.\n. Why would you? Every browser supports native mp3-playback with <audio> these days.\n. Known. Livestreams stop playing after the first .m3u8 file is 'finished'. See #483 and #491. Trying a new build now seems to fix it finally.\n. @forbesjo I was just making one, when the latest Firefox-update got pushed to my browser, version 48.0.2, Windows 10 64-bit and the problem seems to be over now.\nBoth 2.1.1 and VideoJS 5.10 in my live environment as well as VideoJS 5.11 and VideoJS-HLS 3.5.3 seem to play just fine now in Firefox.\n. ",
    "ingen0s": "the /dist folder is not missing - you just have to build it\n. ",
    "ssendev": "basically fixed. the problem is that my server has 30 seconds of content in the playlist with 10 seconds target duration so it starts playing at the edge of the playlist which can cause jumps when the playlist length varies. but it dosn't freeze anymore. so it'ts fixed but it would be cool if the start time could be configured\n. ",
    "dista": "since pull request #184 has already updated on this, this can be ignored\n. iPhone starts to play live stream from the third from last ts segment.\nIf one segment is 5 seconds.  It is 15s before live. so I think should not  hardcode it to 30 seconds\n. after some investigation. \nI found the problem is fromvideojs-media-sources.js:\n```\n videojs.SourceBuffer.prototype.appendBuffer = function(uint8Array){\n    var binary = '',\n        i = 0,\n        len = uint8Array.byteLength,\n        b64str;\nthis.buffer.push(uint8Array);\n\n// base64 encode the bytes\nfor (i = 0; i < len; i++) {\n  binary += String.fromCharCode(uint8Array[i])\n}\nb64str = window.btoa(binary);\n\nthis.trigger({type:'update'});\n\n// bypass normal ExternalInterface calls and pass xml directly\n// EI can be slow by default\nthis.source.swfObj.CallFunction('<invoke name=\"vjs_appendBuffer\"'\n                                + 'returntype=\"javascript\"><arguments><string>'\n                                + b64str\n                                + '</string></arguments></invoke>');\n\n\nthis.trigger({type:'updateend'});\n\n};\n```\nAfter I comment out this.buffer.push(uint8Array);,  the memory usage will not increase.\n. after replace it with https://github.com/videojs/videojs-contrib-media-sources/blob/master/src/videojs-media-sources.js, the problem is gone\n. I added a test case for it, please have a look if it is ok.\n. ",
    "sevteen": "If I correctly understand the process, decoding intermediate frames is not necessary at all, wouldn't be possible to start audio from keyframe's time, instead of starting from the sought position?\nIn other words sync video, audio and entire playback.\n. ",
    "hc2p": "@dmlap yes. Following my instructions you end up with an Uncaught TypeError: Cannot read property 'segments' of undefined error\n. @dmlap thanks a lot for looking into this. I'll give v0.11.1 a shot. \n. @many74 did you find a solution to your problem?\n. ",
    "hanfeisun": "+1\n. currently there isn't a \"concatenated\" js file, so I need to import every js file in my HTML page if I don't want to use npm install and grunt build in the video-hls folder..\n. @gquinones Yes, I'm using El Capitan OS.\nWhen I use Git URL in package.json: \n\"devDependencies\": {\n    \"videojs-contrib-hls\": \"git+https://github.com/videojs/videojs-contrib-hls#v1.2.2\"\n  }\nEverything works well..\n. Maybe related to https://github.com/videojs/videojs-contrib-hls/issues/494\nI'm not sure whether there is an easier way.\n. It is solved. The reason is that the Java version in Mac OSX El Capitan is 1.6, while selenium need 1.7. After I installed jdk 1.7 from oracle, it works well now\n. @samward1985  No, it doesn't work under Webpack now.. So I am still using videojs-contrib-hls 1.3.11..\n. ",
    "thais-molica": "+1\n. ",
    "DJLebedev": "+1\n. ",
    "kiaplayer": "+1\n. ",
    "TylerGarlick": "I'm seeing the exact same behavior on video.js#4.11.4, media-sources#0.3.1, hls#0.10.4\n. Here is an example.  http://jsbin.com/repara/2/edit?html,js,console,output\nThanks!\n. ",
    "vladutzik": "Hey guys, i'm trying to fix HLS video in Chrome, and it's a hell. I can't get it why it doesn't work. It works perfectly in safari and it works on mobile version on Android, but it won't start in Chrome.\nMy console is screaming like: \"Uncaught TypeError: videojs.Hls.SegmentParser is not a function\" \nor when i try to press play button it throws \"Uncaught TypeError: Cannot read property 'media' of undefined\".\nAnybody can give me some clues how to fix this?\nThanks in advance.\n. ",
    "albertyw": "I can confirm it happens in my test environment also.\n. ",
    "colt082295": "This issue is still happening for me. All packages at their latest versions, etc.. +1 I'm currently having the same issue. It also seems like the server with the key (out of my control) isn't happy with requests, and throws 403 errors sometimes that eventually break the stream.\n. ",
    "needo2": "I will in a few hours\n. ",
    "berndfo": "Indeed, it looks like you say. However, as far as I know, the current file header is overriding what's in the LICENSE file, especially if videojs-hls.js is distributed without the license and without the rest of the files, which seem likely to me. So unless the header is changed, JS code cannot be used legally without prior permission from Brightcove.\nThanks again for all the great work on video.js.\n. ",
    "cadesalaberry": "What about taking the dist/* out of the .gitignore so that changes get updated after each commits ?\n. @dmlap are you planning on including the dist/ folder anytime soon ? I would love to have it accessible !\nCheers :monkey: \n. @dmlap Thanks a lot for the update, I will check the repo regularly meanwhile.\n. ",
    "mgreer": "Agreed: had to do this locally anyway in order to commit the built file.\n. Issue resolved. For the curious, here is what happened:\n1) On IE11, videojs-hls uses the base element if present as a reference for requesting playlists\n2) Our Angular app routing setup demanded that we set <base href=\"/\"> \n3) Only on IE11, videojs-hls looked to that base href (sometimes) as the base for requests, and borked.\nSince we're not actually using routing in Angular, we just removed the <base href=\"/\"> . Fixed.\n. I've seen this too, it is intermittent. Since the files are statically served, and thus unchanging, it likely isn't missing a keyframe at the start on some calls and not on others.\n. ",
    "evanbeard": "+1\n. ",
    "numbata": "+1\n. ",
    "cladera": "+1\n. +1\n. Thank you @mgood,\nIt does like the issue you mention. I'm closing this issue then. \n. I continued digging and I learned Android is using native support for HLS, which makes totally sense. But, Android's HLS implementation does not support in-band metadata text tracks yet.\nUsing overrideNative option I can make text tracks work in Android devices. However it will make Safari browsers stop working due to the error below.\n[Error] TypeError: Attempted to assign to readonly property.\n    createTextTracksIfNecessary (videojs-contrib-hls.js:17969)\n    data_ (videojs-contrib-hls.js:20201)\nApparently in Safari inBandMetadataTrackDispatchType property is read-only. \nConclusion: in order to make text tracks work in Android devices and Safari the player should be created as follows:\nlet player = videojs('my_video_1', {\n      html5: {\n        hls: {\n          overrideNative: true\n        },\n        nativeVideoTracks: false,\n        nativeAudioTracks: false,\n        nativeTextTracks: false\n      }\n});\nIn my opinion, this should be warned since this issue will affect all kind of metadata text tracks including segment-metadata. If any one relies on that they should be aware Android devices won't behave as expected. . @Sathishchary if you want to play hls streams in iOS devices you should not disable native support. \nSafari on iOS devices does not support media source extensions which makes video and audio tracks to fallback to native. However, videojs will still try to use emulated text tracks which makes the browser crash since for Safari (and the standard BTW) inBandMetadataType is a read-only property. \nWe ended up detecting the platform and device and disable native support for all devices and browsers but Safari and ios devices (iphones and ipads).\nHope this helps you out.. For iOS devices you should configure options like follows:\nvideojs.options.hls.overrideNative = false;\nvideojs.options.html5.nativeAudioTracks = true;\nvideojs.options.html5.nativeVideoTracks = true;\nvideojs.options.html5.nativeTextTracks = true;\nOr do not configure them at all, since these values are the default.. We are going out of topic here. Please, create a stack overflow question and I will answer it.. ",
    "muratakbal": "+1\n. ",
    "Cweili": "+1\n. ",
    "kohey18": "+1\n. ",
    "ogheo": "up, +1\n. ",
    "jetway-software": "+1\n. ",
    "ssurana2": "+1\n. ",
    "gesinger": "As of video.js 6, bower is no longer officially supported (see https://github.com/videojs/video.js/issues/4012). As mentioned in the video.js issue, there are bower-npm resolvers to help manage dependencies on npm when using bower. Please use those if you need support for your bower setup. Thank you.. Hey @Agnostic , sorry to hear you are seeing the issue still. Often times the problem ends up getting fixed through changes we make over time, and we close issues that should be fixed. And other times the problem still exists, but if we haven't seen it ourselves, it's hard to identify it as a bug and create a fix for it. For tickets where there's a reduced test case using a jsbin template, we make our best effort to fix the problem, and leave it open as long as we continue to see the problem. But if we don't have an example of the problem, and haven't seen it/can't reproduce it, we close the ticket, as it often has to do with a person's specific configuration, stream, or an error in another part of their application. We'd be happy to look into the issue if you can provide a reduced test case for it. Feel free to re-open the issue or create a new one with a jsbin example. Thank you.. It looks like gist may no longer exist. Any chance you still have a stream available that exhibits this issue?. Closing for now. If you are still experiencing this issue with the latest version of videojs-contrib-hls (as of this comment, v5.5.3), please re-open the issue and if you have the gist available, or can provide a reduced test case using this template, we'd appreciate it. Thank you.. In addition to @dmlap 's recommendation of in-band metadata tracks, we also now support the \"soft standard\" of EXT-X-CUE-OUT, EXT-X-CUE-OUT-CONT, and EXT-X-CUE-IN (can see some examples of their use in https://github.com/videojs/m3u8-parser/blob/63dd2e4dad33dbb53d71cb3ae06c802a284a4baa/test/m3u8.test.js ) by setting the useCueTags option: https://github.com/videojs/videojs-contrib-hls#usecuetags\nPlease let us know if these do not satisfy your use case. Thanks.. @dmlap , was this using a different stream at the time (from bipbop), or have we addressed this issue in the meantime? I ran player.currentTime(15.25 * 60) in utils/stats/index.html and index.html and have not encountered the error.\n. I know this hasn't been updated in a while, but many changes have been made since its report. Are you still experiencing this issue (I noticed that the link is now down)? If so, would you be able to include a reduced test case. There's a starter template on JSBin you can use. Thanks!\n. Sorry this ticket has gone a long time without much attention. We've made a lot of changes to videojs-contrib-hls in the meantime. Would you be able to give the latest version (as of this comment, v4.1.1) a shot? If it's still a problem, would you be able to re-open the issue and provide a reduced test case using this template?\nAnd @tjenkinson is right that we use native playback for Safari HLS.\nThank you again for reporting the issue.. Sorry this ticket has gone a long time without much attention. We recently added the ability to track which segments are currently in the buffer and when they change via the segment-metadata text track: https://github.com/videojs/videojs-contrib-hls#segment-metadata . This should help to know not just which playlist is selected, but which is actually playing. Please let us know if this doesn't resolve your use case. Thank you.. Hey @chriswiggins , sorry this issue has gone so long without much attention.\nIf you are still experiencing the issue with the latest version of videojs-contrib-hls (as of this comment, v4.1.1), would you happen to have a playlist that is accessible (the gist didn't appear to have full URIs for the segments)?\nThanks again for reporting the issue!. Closing for now. If you are still experiencing this issue with the latest version of videojs-contrib-hls (as of this comment, v5.0.0), please re-open the issue and provide a reduced test case using this template. Thank you.. For those asking about overriding behavior and having access to more of videojs-contrib-hls' functions within browsers that have native implementations, overrideNative (https://github.com/videojs/videojs-contrib-hls#overridenative) is the solution for that, however, there is a known bug with overriding Safari's playback: https://github.com/videojs/videojs-contrib-hls/issues/1005 \nPlease follow that issue if you're looking for a solution for Safari. Thanks.. Thanks for giving it a shot @aamelegy . If you are having trouble with getting overrideNative to work (that isn't due to https://github.com/videojs/videojs-contrib-hls/issues/1005 ), would you be able to open a new issue and provide a reduced test case using our starter template? Thanks.. Hey @Llorx , sorry this ticket has gone a long time without much attention. I know you've posted the workaround, but we've made a lot of changes to videojs-contrib-hls in the meantime.\nWould you be able to give the latest version (as of this comment, v4.1.1) a shot? If it's still a problem, would you be able to re-open the issue and provide a reduced test case using this template? If it's still problematic, we can take another look at the snippet and see if it works for the new flow.\nThank you again for reporting the issue.. @jimmywarting , sorry that we haven't had any updates in a while. This has actually come up multiple times, and we think the best overall idea is to have the projects working closer together to develop shared components such that the open source community doesn't have too many different codebases doing similar things (with different bugs/features in each).\nThis is still a great idea, and we should start pushing towards the goal. I think the best way to start may be by extracting modules for specific functionality. This is something we are looking into doing more in the near future (and have done with certain aspects, e.g., https://github.com/videojs/m3u8-parser and https://github.com/videojs/aes-decrypter ). Once we have distinct modules for critical features, and different implementations can combine them in simple ways, it may promote more reuse among the community.\nWe also opened https://github.com/dailymotion/hls.js/issues/477 and while I haven't had a chance to look into it too much yet, I think it may be another great place to work from.. Hey @FDiskas . Sorry this ticket has gone a long time without much attention. We've made a lot of changes to videojs-contrib-hls in the meantime, particularly around how we handle live streams. Would you be able to give the latest version (as of this comment, v5.2.1) a shot? If it's still a problem, would you be able to re-open the issue and provide a test case with your stream using this template? Thanks.. Closing for now. If you are still experiencing this issue with the latest version of videojs-contrib-hls (as of this comment, v5.3.3), please re-open the issue and provide a reduced test case using this template. Thank you.. I think we might be OK on this one now @imbcmdth \n. Hey @ntadej , are you still encountering the error? If so, would you be able to include a reduced test case? There's a starter template on JSBin you can use. Thanks!\n. Sorry this ticket has gone a long time without much attention, and thanks for the update with your work around. I think this case should work with the latest player. If you still need it without the workaround, please give the latest version (as of this comment v5.2.1) a shot and let us know if you're still seeing issues. Thank you.. Hey @ntadej . Sorry this ticket has gone a long time without much attention. We've made a lot of changes to videojs-contrib-hls in the meantime, including work on playback with misaligned content. Would you be able to give the latest version (as of this comment, v4.1.1) a shot? If you're still seeing those issues, would you be able to re-open the issue and provide a reduced test case using this template?\nThank you again for reporting the issue.. Sorry this ticket has gone a long time without much attention. We've made a lot of changes to videojs-contrib-hls in the meantime, and haven't seen this issue in a while. Would anyone who is experiencing this issue be able to give the latest version a shot (as of this comment, v5.4.0), and provide a sample stream if you're still seeing issues? Thank you.. Closing for now. If you are still experiencing this issue with the latest version of videojs-contrib-hls (as of this comment, v5.4.1), please re-open the issue and provide a reduced test case using this template. Thank you.. @FDiskas , are you still experiencing the lags with the latest version of the player?\n. @dmlap , looks like we changed where/when we're setting timestampOffset to only do it when we're on a different timeline (we are crossing a discontinuity), and when the start of the segment is less than the current timestampOffset. OK to close?\n. Hey @cagen , sorry this ticket has gone a long time without much attention, and thanks for all of the detailed debugging info. We've made a lot of changes to videojs-contrib-hls in the meantime, and I noticed that the original streams are down. Would you be able to give the latest version of videojs-contrib-hls a shot (as of this comment, v5.4.0), and if you're still seeing issues, let us know what source your are using? Thank you.. Closing for now. If you are still experiencing this issue with the latest version of videojs-contrib-hls (as of this comment, v5.4.1), please re-open the issue and, if possible, provide a reduced test case using this template, and/or the source you are using. Thanks again for all of the debugging info.. Thanks for the update @cagen. And yeah, since the flash tech is no longer there by default in video.js v6 (and must be added via the videojs-flash plugin), I imagine that even if the issue is present somewhere for flash, it will be less of a concern.. Hey @camlowe , are you still experiencing the issue where the stream stops after 7-10 minutes?\n. Sorry this ticket has gone a long time without much attention. We've made a lot of changes to videojs-contrib-hls in the meantime. Would you be able to give the latest version (as of this comment, v4.1.1) a shot? If it's still a problem, would you be able to re-open the issue and provide a reduced test case using this template?\nThank you again for reporting the issue.. Sorry this ticket has gone a long time without much attention. We've made a lot of changes to videojs-contrib-hls in the meantime, and the original posted streams seem to play with the latest version of videojs-contrib-hls (v4.1.1). Please give it a shot and let us know if you're still seeing issues. Thank you.. Thanks for the video @sreym . I tried out your source and had trouble starting the stream. It ended up playing in Safari (after a while of loading), but I haven't seen it play in other browsers. From a brief overview, it looks like the live stream has only a few segments in the window, they are short, and the connection is slow to download the segments. This means that by the time we end up downloading the segments, they have fallen off the playlist (which makes the issue look like it is related to https://github.com/videojs/videojs-contrib-hls/issues/982 ). I'll post the source in there so we can take a look at the stream as that issue gets investigated.. Closing as this case looked like it was resolved.\nHowever, for anyone else in a similar solution, I wanted to add some generic information on why there isn't an easy API to grab the currently playing segment, and what might be done to solve your issue.\nFiguring out the currently playing segment is hard. To determine which one is playing requires some rough guesswork based on the segment and the state of the buffer before and after appending the segment, then relying on the timing to remain accurate.\nDifferent use cases often seem to require knowledge of the currently playing segment, but many times can be resolved in other ways. For instance, id3 metadata may be a good option to trigger necessary info when the segment is playing.\nEach use-case is unique though, and can be solved in different ways.. Hey @u0x01 , sorry this ticket has gone a long time without much attention. I gave it a shot with the latest version of videojs-contrib-hls (as of this comment, v5.3.3), and it seemed to work on Chrome. Please give it a shot and let us know if you're still seeing issues. Thank you.. Sorry this ticket has gone a long time without much attention, and thank you for the update @maysale01 . We now publish the npm package along with github release to ensure that both reflect the latest version.. We have since added https://github.com/videojs/videojs-contrib-quality-levels , which is a plugin that provides an easy API for enabling/disabling quality levels. If you see any issues with this plugin, please let us know. Thanks!. Closing since we can't reproduce. Please re-open if this is still an issue on the latest player, and please provide a reduced test case using this template if you can. Thank you.. Sorry this ticket has gone a long time without much attention. This looks like it was resolved during Windows updates for IE 11.\nFor IE 10, which doesn't support web worker blob URLs, we are deprecating support with v5 https://github.com/videojs/videojs-contrib-hls#ie10-and-below .\nPlease let us know if you are still experiencing issues. Thank you.. Yeah. I think all of the buffer trimming will need to be migrated in (I believe it might've gotten lost somewhere).\n. Sorry this ticket has gone a long time without much attention. We've made a lot of changes to videojs-contrib-hls in the meantime, including a lot of changes around segment fetching logic.\nWould you be able to give the latest version (as of this comment, v4.1.1) a shot? If it's still a problem, would you be able to provide a reduced test case using this template and a sample stream?\nThank you for reporting the issue.. This looks similar to: https://github.com/videojs/videojs-contrib-hls/issues/775 and https://github.com/videojs/videojs-contrib-hls/issues/982 .  Closing in favor of those. If this is a separate issue from those, and you are still experiencing this issue with the latest version of videojs-contrib-hls (as of this comment, v5.1.0), please re-open the issue and provide a reduced test case using this template. Thank you.. Sorry this ticket has gone a long time without much attention. We've made a lot of changes to videojs-contrib-hls in the meantime. If it's still a problem for anyone, would you be able to re-open the issue and provide a reduced test case using the latest version via this template?\nThank you for reporting the issue, and for all of the added info.. Thanks again for the PR @svenspielvogel . As to your comments above regarding what this fixes, we actually have made a lot of changes around those very areas (since we found them problematic as well). In order:\nProblem: Video stops playing since there is a gap\nSolve: if next timerange isnt far away (<0.5secs) jump over gap\nWe do a few different things now. In mux.js, we will fill some audio gaps with silent frames ( https://github.com/videojs/mux.js/pull/130 and https://github.com/videojs/mux.js/pull/143 ). In videojs-contrib-hls, we have https://github.com/videojs/videojs-contrib-hls/blob/master/src/playback-watcher.js which will skip over gaps in known error conditions.\nProblem: Video loads segments in a loop: e.g. media_0.ts >> media_0.ts and so on.\nSolve: Find real buffered end and get media index - my approach might still lead to a loop if we have 3 time ranges, but are still playing in the first time range. I'm gonna fix this pretty soon. I've to iterate through all timeranges. another solution, maybe the better one would be not to create a second timerange. Actually I wasn't able to figure it out in that short time I had, so this might be a good way. Any ideas on that?\nWe now have much better fetching behavior, and it has been resilient against looping segment requests. Please give it a shot and let us know if you see otherwise!\nThe Plug-In doesn't always throw correct errors. e.g. loosing network or poor network (GPRS 64kBit/s)\nSolve: setting up a retry count and throw error if it occurs.\nWe've been working on better error reporting/events, and now will retry the last stream if it fails https://github.com/videojs/videojs-contrib-hls/pull/1039 .\nAs for the case @TylerZubke posted, it looks like that was solved.\nThanks again for the PR, and please let us know if you're still experiencing issues with the latest version of videojs-contrib-hls (as of this comment, v5.5.0). Thank you.. Hey @amkgo , sorry this ticket has gone a long time without much attention. We've made a lot of changes to videojs-contrib-hls in the meantime. Would you be able to give the latest version (as of this comment, v4.1.1) a shot? If it's still a problem, would you be able to re-open the issue and provide a reduced test case using this template?\nThank you for reporting the issue.\n. Sorry this ticket has gone a long time without much attention. It looks like the original sample page may no longer exist.\nWe've made a lot of changes to videojs-contrib-hls in the meantime (including around gaps, which potentially was causing the freeze in the original problem). Would you be able to give the latest version (as of this comment, v5.0.0) a shot? If it's still a problem, would you be able to re-open the issue and provide a reduced test case using this template?\nThank you for reporting the issue.. Hey @whatvn , sorry this ticket has gone a long time without much attention\nI tried the test stream in the original issue, but it looks like it must've expired.\nWe've made a lot of changes to videojs-contrib-hls in the meantime. Would you be able to give the latest version (as of this comment, v4.1.1) a shot? If it's still a problem, would you be able to re-open the issue and provide a reduced test case using this template?\nAnd for others also seeing the issue/similar issues, @dmlap is right that MEDIA_ERR_DECODE can be various different cases. If anyone is seeing an issue along those lines, please feel free to open a new issue with a reduced test case. Thank you.. I see a lot of people have seen this issue as well. I tried the listed steps with the latest player, but was unable to reproduce the problem. Would someone who is seeing the issue be able to provide a reduced test case using this template?\nThank you all for reporting the issue.. @aquu , do you happen to have a stream we can test with?. While I haven't yet been able to create a reproducible test case, when running a local server with the template I saw it happen now and again on refreshes. Probably related to a timing issue.. We are currently working on a fix for this issue. We will link a pull request as soon as we have one ready. Thanks again for the reporting and all of the activity.. Hey @poohitan , sorry for the delay. Just submitted the PR. We'll try to get it reviewed and tested soon.. Thanks again for everyone reporting the issue and adding more information. videojs-contrib-hls v5.4.1 was released yesterday which included PR https://github.com/videojs/videojs-contrib-hls/pull/1061. Now a proper player error should be triggered even if the MediaSource is not ready (we catch the thrown exception and manually trigger a player error ourselves). There is still a known bug around the player sometimes clearing the error overlay ( https://github.com/videojs/videojs-contrib-hls/issues/1079 ), however, the error event is now properly thrown and no exception is triggered.. Sorry this ticket has gone a long time without much attention.\n@momkin , I tried the m3u8 you posted with the latest player, and it seems to work for me.\nWould you be able to give the latest version (as of this comment, v4.1.1) a shot? If it's still a problem, would you be able to re-open the issue and provide a reduced test case using this template?\nThank you for reporting the issue.. Hey @ChrisWhiten , sorry this issue has gone so long without much attention.\nI tried the stream listed above, but it looks like the playlist is now empty.\nWe've made a lot of changes to videojs-contrib-hls in the meantime. Would you be able to give the latest version (as of this comment, v4.1.1) a shot (you can also use this template to create a reduced test case with the stream)?. Closing for now. If you are still experiencing this issue with the latest version of videojs-contrib-hls (as of this comment, v5.0.0), please re-open the issue and provide a reduced test case using this template. Thank you.. Hey @mpaldheCM , sorry this issue has gone so long without much attention.\nI tried the link posted above, but it looks to have expired.\nWe've made a lot of changes to videojs-contrib-hls in the meantime. Would you be able to give the latest version (as of this comment, v4.1.1) a shot? If it's still a problem, would you be able to re-open the issue and provide a reduced test case using this template?\nThank you.. @shacharz , sorry this ticket has gone a long time without much attention. We've made a lot of changes to videojs-contrib-hls in the meantime.\nI gave the link a shot with the latest player and it seems to be working.\nWould you be able to give the latest version (as of this comment, v4.1.1) a shot? If it's still a problem, would you be able to re-open the issue and provide a reduced test case using this template?\nThank you for reporting the issue.\n. This was fixed as part of https://github.com/videojs/videojs-contrib-media-sources/pull/104 and https://github.com/videojs/mux.js/pull/120 . Thank you for updating @mattblaha , and thank you to everyone else for reporting the issue and adding debugging information.. Sorry this ticket has gone a long time without much attention.\nI tried out the original URL with the latest player, and couldn't reproduce the issue.\nWe've made a lot of changes to videojs-contrib-hls in the meantime (particularly around segment loading logic). Would anyone experiencing the issue be able to give the latest version (as of this comment, v4.1.1) a shot? If it's still a problem, would you be able to re-open the issue and provide a reduced test case using this template?\nThank you all for reporting the issue.\n. Maybe this is out of scope for now, but if a playlist is switched, should we clear out the alternate audio tracks and re-add them with the associated ones from the new playlist?\n. Hey @waster , sorry this ticket has gone a long time without much attention.\nI saw that the URL is no longer up, but would you be able to give the latest version (as of this comment, v4.1.1) a shot? If it's still a problem, would you be able to re-open the issue and provide a reduced test case using this template?\nThank you again for reporting the issue.\n. Sorry this ticket has gone a long time without much attention. Judging from the example provided, it looks like the problem was the options that were passed. In the example provided, the options are set to {hls: {withCredentials: true}}, however, the option should be inside of the tech, i.e., {html5: {hls: {withCredentials: true}}}. Please give it a shot and let us know if you're still seeing issues with the latest version of videojs-contrib-hls (as of this comment, v5.4.1). Thank you.\n. Looks like a console error is logged: Cannot read property 'video' of undefined at Object.pmt. From the looks of it, the segment might not have a PMT (program map table).. Sorry this ticket has gone a long time without much attention. We've made a lot of changes to videojs-contrib-hls in the meantime. Would you be able to give the latest version (as of this comment, v4.1.1) a shot? If it's still a problem, would you be able to re-open the issue and provide a reduced test case using this template?\nThank you again for reporting the issue.. Thanks for reporting the issue, and thank you for the PR @samward1985 . We are keeping Hls on the videojs object, however, we are also now calling registerComponent for Hls.\nPlease let us know if you are still seeing the warning. Thank you.. Made changes.\n. Hey @webcast33 , sorry this ticket has gone a long time without much attention. We've made a lot of changes to videojs-contrib-hls in the meantime. Would you be able to give the latest version (as of this comment, v4.1.1) a shot? If it's still a problem, would you be able to provide a reduced test case using this template?\nThank you for reporting the issue.. Closing for now. If you are still experiencing this issue with the latest version of videojs-contrib-hls (as of this comment, v5.0.0), please re-open the issue and provide a reduced test case using this template. Thank you.. This was since released as part of #659 . While the timing has changed slightly for fastQualityChange_ since that release, this should switch faster than when first reported.\nThank you again for reporting @drizzt .. I like the cleanup (and it was about time those Ranges didn't have the \"private\" underscore at the end of them). And the adding audio tracks function on loadedmetadata in HlsHandler looks really clean. A couple general notes:\n- I know we discussed doing the audio track setting logic on loadedplaylist instead of loadedmetadata. I think we can cover that in a separate PR. Or here. Up to you.\n- There are a couple minor items that I did in https://github.com/videojs/videojs-contrib-hls/pull/619 that I'll copy over when doing a rebase (e.g., an additional method in MasterPlaylistController to get some of the internals like the current media instead of using masterPlaylistLoader_). Will save some time rather than worrying about them here.\n. LGTM\n. This has since been added. You can override native playback using videojs.options.hls.overrideNative = true (or by setting overrideNative to true as part of the hls options). Thanks for reporting the issue @alouane . LGTM\n. (Though Travis has some complaints)\n. Nice test addition. Some minor comments, but otherwise, looks good.\n. @sirisian , sorry this ticket has gone a long time without much attention. And @hdezela , thanks for doing so much debugging on it!\nWe've made a lot of changes to videojs-contrib-hls in the meantime. @sirisian , would you be able to give the latest version (as of this comment, v4.1.1) a shot?\nThanks again.\nAnd @mina64 , would you be able to open a different issue (to keep this thread from going on with different problems)? Thanks!. Closing for now. If you are still experiencing this issue with the latest version of videojs-contrib-hls (as of this comment, v5.0.0), please re-open the issue and provide a reduced test case using this template. Thank you.. Thanks for the added info @thebeachtoday !. Hey @jviney , sorry this ticket has gone a long time without much attention. I gave the stream a shot in our latest player (v5.3.0) and it seems to play back fine (I didn't see the glitches). Would you be able to give it a shot and let us know if you're still seeing issues. Thank you.. Thanks @jviney !. @powrsurg , it looks like the beforeRequest function will allow a user to modify the options then return the resultant options object (or return the options object without any change). Were you seeing otherwise?. You're right that it does replace options.\nThe recommended use of it though is to simply modify/remove/add the options that are needed: https://github.com/videojs/videojs-contrib-hls#hlsxhr\nI think both accomplish the same goal, it just depends on how you want the API to look. Merging allows a user to return a separate object that gets merged in vs current functionality which allows a user to modify the object in-place.\nEDIT: Granted, merging does allow either method.. @imbcmdth what do you think of using a merge instead of replacing?. Thanks for reporting, and for the recommendation of using a merge. We may end up adding that as an enhancement, so that the API can be used in either way, but I gave the API a test as-is, and so long as the options are read/modified from and returned in the beforeRequest function, they persist and are used.. LGTM\n. Hey @rickymartinss , sorry this issue has gone a long time without much attention.\nIf you take a look at http://output.jsbin.com/bisajo , I created a sample page with an iframe referencing  our example template http://jsbin.com/vokipos/8/edit?html,output to play an m3u8 file using Video.js and videojs-contrib-hls. You can see the code for the iframe at http://jsbin.com/bisajo/edit?html and the template above for the page it is referencing. Hope this helps!. PR created https://github.com/videojs/videojs-contrib-hls/pull/983. Thanks again for reporting the issue, and for everyone adding on with more information. Yesterday v5.4.1 was released with PR https://github.com/videojs/videojs-contrib-hls/pull/983 included. beforeRequest is now no longer copied when a new HLS instance is created, but is instead read live from the HLS instance when requests are made. This means that player.hls.xhr.beforeRequest and videojs.Hls.xhr.beforeRequest can be changed as a source is playing. As before, if you want to have a per player per source modified beforeRequest, please use player.hls.xhr.beforeRequest, and if you want to have a global modified beforeRequest, please use videojs.Hls.xhr.beforeRequest. Thanks.. LGTM\n. Do we know if anyone was setting Hls.GOAL_BUFFER_LENGTH after the src was set and expecting the value to be used?\n. LGTM\n. Hey @jpfranco , sorry this issue has gone a long time without much attention.\nI know Firefox 45 is long past, but I gave it a try with the latest versions of Video.js and videojs-contrib-hls and it works with Firefox 50.1.0. If you are still seeing this issue, please re-open the ticket and provide a reduced test case using this template? Thank you!. Maybe it isn't worth it for this, but we could have some tests for those formats.\n. Thanks @BrandonOCasey , and we'll definitely be trying to move towards a cleaner playlist-loader, however, with the changes made to playlist-loader since this PR, it may be easier to to start anew than to rebase, and if we do move towards better syntax, we'll probably be better off doing it in pieces and trying to make things more functional.. Hey @erbing , sorry this ticket has gone a long time without much attention. By default we use Android's native HLS player, so this issue is most likely related to Android. We do provide an option to override native playback via videojs.options.hls.overrideNative = true. If you try that, and still see the issue, would you be able to reopen the ticket and provide a reduced test case using this template? Thank you.. Hey @erbing , sorry this ticket has gone a long time without much attention. We've made a lot of changes to videojs-contrib-hls in the meantime. Would you be able to give the latest version (as of this comment, v4.1.1) a shot? If it's still a problem, would you be able to re-open the issue and provide a reduced test case using this template?\nThank you for reporting the issue.. Hey @justinoue , we've made a lot of changes to videojs-contrib-hls in the meantime, including in live playback. We've also been successful with live streams greater than 3 hours. Would you be able to give the latest version (as of this comment, v4.1.1) a shot? If it's still a problem, would you be able to re-open the issue and provide a reduced test case using this template?\nThank you for reporting the issue.. Hey @vineetphillips , sorry this ticket has gone a long time without much attention. It's interesting that play/playing were not working for you, but we've made a lot of changes to videojs-contrib-hls in the meantime. Would you be able to give the latest version (as of this comment, v4.1.1) a shot? If it's still a problem, would you be able to re-open the issue and provide a reduced test case using this template?\nThank you for reporting the issue.. Sorry this ticket has gone a long time without much attention. We've made a lot of changes to videojs-contrib-hls in the meantime, and haven't seen this issue in a while. It also looks like https://github.com/videojs/videojs-contrib-hls/issues/460 is the same issue. Going to close this one in favor of the older one, but would anyone who is experiencing this issue be able to give the latest version a shot (as of this comment, v5.4.0), and provide a sample stream if you're still seeing issues (I know that it has been a while, so the provided samples above are down)? Thank you.. Hey @halibegic , sorry this ticket has gone a long time without much attention.\nWe don't currently have an official debug mode, but it is on our radar and something we are considering adding to the player.. Closing this in favor of https://github.com/videojs/videojs-contrib-hls/pull/1156. LGTM\n. Sorry this ticket has gone a long time without much attention.\nI haven't seen that error happen recently, however, we've made a lot of changes to videojs-contrib-hls in the meantime. Would you be able to give the latest version (as of this comment, v4.1.1) a shot? If it's still a problem, would you be able to re-open the issue and provide a reduced test case using this template?\nThank you for reporting the issue.. Closing, as much of the generator has changed since this PR, and with the changes in https://github.com/videojs/videojs-contrib-hls/pull/1151 , if we do want to update to the latest version of the generator, we'll be better off starting fresh after that PR.. LGTM\n. Sorry this ticket has gone a long time without much attention. We've made a lot of changes to videojs-contrib-hls in the meantime, including around skipping and filling gaps, as well as around requesting segments in order to prevent browsers from creating gaps.\nIn addition, it looks like a few different problems were encountered.\n@laurent-dazzl MEDIA_ERR_DECODE usually indicates a problem or unsupported feature of the stream itself, but is most likely a different issue from the gaps.\n@Rellim7 , I gave your stream a shot with the latest version (as of this comment, v5.4.0), and it seemed to play through on Mac/Chrome. Would you be able to give it another shot, and if it doesn't work, let us know what version of Chrome you are using?\nThanks to all who reported. If you have a chance, please give the latest version of videojs-contrib-hls a shot (as of this comment, v5.4.0). And if you're still seeing issues, let us know the source you are using and what browser/OS. Thanks.. Hey @asharptlm , thanks for all of the details. With overrideNative, we have some known issues around its use with Safari: https://github.com/videojs/videojs-contrib-hls/issues/1005 . The information you posted will be helpful in that ticket in helping to track down the root causes of the issues people are seeing.. Thanks again for the info @asharptlm . Those problems look to be centered around overrideNative on Safari (both mobile and desktop). It would be helpful to add that info to https://github.com/videojs/videojs-contrib-hls/issues/1005 , and we can address them there.\nFor this ticket, it looks like there were a few different errors, though they were from a while ago.\nClosing this ticket for now. Thanks to all who reported. If anyone is still seeing issues with the latest version of videojs-contrib-hls a shot (as of this comment, v5.4.1), please re-open this ticket or create a new issue with a reduced test case/example source, and let us know the source and what browser/OS you are using. Thanks.. Hey @githubdoramon , sorry this ticket has gone a long time without much attention. When you say that it doesn't work sometimes, were you seeing the events not firing?\nWould you be able to give the latest version (as of this comment, v5.0.0) a shot? If it's still a problem, would you be able to provide a reduced test case using this template?\nThank you.\n. Closing for now. If you are still experiencing this issue with the latest version of videojs-contrib-hls (as of this comment, v5.1.0), please re-open the issue and provide a reduced test case using this template. Thank you.. Thanks @gkatsev , and thanks @piotr-cz for reporting the issue.\nWe now have https://github.com/videojs/videojs-contrib-quality-levels which should provide a nicer API for quality level selection than the rendition one. This should also make cases involving media playlists easier. Please let us know if you have any trouble with it.. Hey @whatvn , sorry this ticket has gone a long time without much attention. We've made a lot of changes to videojs-contrib-hls in the meantime, and the original posted streams seem to play with audio with the latest version of videojs-contrib-hls (v5.4.0): http://jsbin.com/nojeyeqizu/1/edit?html,output\nPlease give it a shot and let us know if you're still seeing issues. Thank you, and thanks @CSilivestru  for helping out with some recommendations.. Thanks @TV5Dev for all of the information. As mentioned, the HLS spec includes \"Matching content in Variant Streams MUST have matching timestamps. This allows clients to synchronize the media.\" Without the match, the player can't make reasonable determinations about the content. Closing this issue for now, but if anyone finds any other solution to the problem of out-of-sync primary backup failover, we're happy to hear the suggestions. Thanks again.. Although we still have to tackle this problem, we haven't seen it cause too much trouble in the real world, and we'll most likely approach it after we try to bring videojs-contrib-media-sources back into this project.. Sorry this ticket has gone a long time without much attention. We've made a lot of changes to videojs-contrib-hls in the meantime. Would anyone seeing this issue mind giving the latest version (as of this comment, v5.3.3) a shot? If it's still a problem, would you be able to provide a reduced test case using this template? Thank you.. Closing for now. If you are still experiencing this issue with the latest version of videojs-contrib-hls (as of this comment, v5.4.0), please re-open the issue and provide a reduced test case using this template. Thank you.. Hey @sobytes , sorry this ticket has gone a long time without much attention.\nThis error usually identifies a problem with downloading a segment/playlist (usually indicates a server error or a problem with the network), but may be hard to diagnose without seeing the stream itself. That said, judging by the CORS error reported, it looks like it has to do with the server settings. I'm not sure what the proper setup would be server-side to make it work, but if the browser is reporting that CORS error then the XHR will get an error and we'll try another playlist if available.\nIf you are still seeing this without CORS errors being reported, would you be able to give the latest version (as of this comment, v4.1.1) a shot? And if it's still a problem, would you be able to re-open the issue and provide a reduced test case using this template? Thank you.. Thanks @samueleastdev ! Glad to hear it.. Sorry this ticket has gone a long time without much attention. We don't support manipulating caption track labels.. Sorry this ticket has gone a long time without much attention. If you are looking to check which playlist is currently being played, we recently added the ability to track that via the segment-metadata text track: https://github.com/videojs/videojs-contrib-hls#segment-metadata . This should help to know not just which playlist is selected, but which is actually playing. If instead you are looking for the currently selected playlist (what playlist is being loaded from, but not necessarily which is buffered/playing), there is the media getter: https://github.com/videojs/videojs-contrib-hls#hlsplaylistsmedia . Please let us know if these don't resolve your use case. Thank you.. Sorry this ticket has gone a long time without much attention.\nIt looks like this may have been due to https://github.com/videojs/mux.js/pull/112\n@ianwelsh , would you be able to give the latest version a shot (as of this comment, v5.4.0), and if you are still seeing the issue, let us know the source you are seeing it with?\nThanks for reporting the issue.. Thanks!. Hey @zisuc , sorry this ticket has gone a long time without much attention. We've made a lot of changes to videojs-contrib-hls in the meantime. Would you be able to give the latest version (as of this comment, v4.1.1) a shot? If it's still a problem, would you be able to re-open the issue and provide a reduced test case using this template?\nThank you for reporting the issue.. Sorry this ticket has gone a long time without much attention. I tried to check the streams, but it seems that they are now down. We've made a lot of changes to videojs-contrib-hls in the meantime. Would you be able to give the latest version (as of this comment, v5.3.3) a shot? If it's still a problem, would you be able to provide a reduced test case using this template?\nThank you for reporting the issue.. Hey @aun343 , thanks for posting the stream. I gave it a shot in Chrome 56/OS X with videojs-contrib-hls 5.3.3 and seeked to 13:14:06 and played through both of those times without any stopping. Would you be able to give the latest version a shot and see if it resolves the issue for you? Thanks.. Closing for now. If you are still experiencing this issue with the latest version of videojs-contrib-hls (as of this comment, v5.4.0), please re-open the issue and provide a reduced test case using this template. Thank you.. Updated.\n. Hey everyone, thanks for creating the issue and providing more information on it. Would anyone be able to provide a reduced test case using this template? It would make it easier for us to see the problem. Thanks.. Hey @apara , the txt file you linked to seems to just say \"To view this video please enable JavaScript, and consider upgrading to a web browser that supports HTML5 video.\"\nDo you happen to have a link to a publicly accessible m3u8?. Hey @apara , thanks for posting the stream. Leaving it running now to see how it goes.. Thanks for leaving the stream up @apara . Ran it a few times, and have some results.\nAs you said, when running with the latest version of videojs-contrib-hls, it'll eventually stop. There are a few reasons for this. (1) The playlist window is really short (there are only three segments in the playlist at any given point), meaning that normally mild issues (some explained in next points) will present themselves more often. (2) There are gaps between some segments. This is OK, as playback-watcher will skip over them, however, when it has to skip gaps, there is a slight delay (we give time in case the video catches up). With that combination (3) we fall off the back of the playlist. When this happens, we try to seek to the live point, however, if there is a gap at the live point or really slow responses (particularly with a short window) the player can get stuck.\nThe good news is that we were working on a fix for getting stuck when seeking in https://github.com/videojs/videojs-contrib-hls/pull/1006 . I tried the stream in this branch and have not seen it permanently freeze yet (has gone for over 8000 seconds, versus a permanent freeze in under 2000 seconds with main branch).\nFeel free to try https://github.com/videojs/videojs-contrib-hls/pull/1006 , though we hope to get it into master and cut a new version soon (we just need to do some more testing for it).. PR #1006 has since been merged and the m3u8s posted on this page are running for me. If anyone is still experiencing issues with the latest version of videojs-contrib-hls (at the time of this comment, v5.3.2), please let us know. Thank you all for the comments and examples.. Thanks to all for reporting the find and adding information. As @dmlap mentioned, we use the browser cache to handle the caching of key requests. While we might be able to do the caching of the key ourselves, we'd have to be aware of potential \"HTTP expires\" headers to handle mentioned key rotation and make other considerations in the code. As of now, it is simpler to make use of the browser cache.. Sorry this ticket has gone a long time without much attention. There are a couple of approaches, depending on what you're looking for.\nFor the case where the live stream isn't a valid URL/stream yet: videojs-contrib-hls only focuses on playing provided HLS streams. Once the stream is provided to the player, videojs-contrib-hls expects the stream to be active and valid. However, this could be a good use-case as a plugin outside of videojs-contrib-hls (such that a stream is only set once it is live), or can be handled on the server by having a live stream running but using an image or simple animation as a placeholder.\nFor the case where the live stream is running, but you want to know when it transitions from some placeholder to the proper live stream: this could be a good use case for in-band metadata: https://github.com/videojs/videojs-contrib-hls#in-band-metadata . When the live stream starts (switch from the placeholder), the segment could come with some metadata to say that the stream is starting.\nHope these help, and thanks for posting and the shared workaround code.. Closing for now. If it's still a problem, would you be able to re-open the issue and provide a reduced test case using this template? Thank you.. Note that this simply removes all old cues and adds new cues when loading a new playlist. We can change this to de-duping if it is preferable, but it seemed to make sense as when seeking back with a new playlist we'd want the new playlist's cues rather than the old. However, this could also cause some false cues to be triggered if we are seeking back into buffered range of an old playlist. We can discuss specifics around that case.\n. Updated.\n. Rebased on master and fixed linting errors.\n. The audio pops/clicks in Firefox were fixed as part of https://github.com/videojs/videojs-contrib-media-sources/pull/104 and https://github.com/videojs/mux.js/pull/120 . Thank you all for reporting the issue and the added information.. LGTM\n. Closing since we can't reproduce. Please re-open if this is still an issue on the latest player, and please provide a reduced test case using this template if you can. Thank you.. @titpetric , one thing to note with your example is that there are only 3 segments in the live window. This means that the player will be hovering at the start of the playlist at all times, and will easily fall off. The short segment durations may exacerbate this problem. And with key frames at 10 second intervals, is it possible there are no key frames in that window (of less than 4.5 seconds)?\n@instanceof , I believe your problem may be related to a different issue addressed in https://github.com/videojs/videojs-contrib-hls/issues/1030\n@ddunkin , how long does it usually take to see the error? And what version of the player are you using?\n@zzzhr1990 , sorry, I know the stream is older and has been taken down, but would you happen to have another source displaying the problem? And are you still seeing it with the latest version of the player (v5.4.0)?\n. Looks good, but I think a test would be good to add.\n. A couple tests that would be good to add:\n- Some tests for findAdCue (it is a simple function, but always good to have tests for it, even though it is implicitly tested by the updateCues_ tests)\n- Tests with multiple ad cues\n. Thanks for the update @Prendo93 . Please let us know if you run into any other issues.. Hey @benweidig , if you'd like to override native HLS playback on Android, you can now use https://github.com/videojs/videojs-contrib-hls#overridenative . Let us know if you find any issues.. Closing for now. Please give the latest version of videojs-contrib-hls (as of this comment, v5.3.3) a shot. If it's still a problem, please re-open the issue and provide a reduced test case using this template. Thank you.. Would it have any real negatives if we got rid of our current logic of finishing appends if someone calls abort/pause? I know that it potentially saves us some bandwidth and processing time if we finish our appends once we're in the process, but I imagine the extra calls and time are pretty small relative to the simpler and more straightforward code if we are able to remove the notion of PAUSING and abort/pause retain their inherent meaning of immediate action (instead of delayed). Also, once the requests are finished, most browsers I imagine will retain the response in cache, so we shouldn't spend too much extra bandwidth if we have to make the call again.\n. LGTM\n. @marguinbc looks like there's a linting error for trailing spaces.\n. Thanks for the code @adgoncal . I'm going to close this issue though in favor of another that reflects the same issue: https://github.com/videojs/videojs-contrib-hls/issues/354. Some version of IE11 have known issues playing back content using native HTML SourceBuffers. The workaround for these issues is to force the player to use flash when running on IE11. See https://github.com/videojs/videojs-contrib-hls#known-issues for more details. Thank you for reporting the issue.. LGTM\n. Sorry this ticket has gone a long time without much attention. We've made a lot of changes to videojs-contrib-hls in the meantime. Would you be able to give the latest version (as of this comment, v5.3.3) a shot? If it's still a problem, would you be able to provide a reduced test case using this template or a sample command with mediastreamsegmenter? Thank you.. Closing for now. If you are still experiencing this issue with the latest version of videojs-contrib-hls (as of this comment, v5.3.3), please re-open the issue and provide a reduced test case using this template or a sample command with mediastreamsegmenter. Thank you.. Sorry this ticket has gone a long time without much attention.\nWe've made a lot of changes to videojs-contrib-hls in the meantime, and it looks like the original issue may have been resolved.\nFor anyone still having trouble with the issue, please give the latest version of videojs-contrib-hls (as of this comment, v5.3.3) a shot. If it's still a problem, please re-open the issue and provide a reduced test case using this template. Thank you.. Sorry this ticket has gone a long time without much attention. We recently added the ability to track the actively playing segment via the segment-metadata text track: https://github.com/videojs/videojs-contrib-hls#segment-metadata . Please let us know if this doesn't resolve your use case. Thank you.. Sorry about that @piotr-cz , and thanks @mjneil . It was just released as part of v5.4.0.. Looks like a small typo in the directory they are being moved to (,git instead of .github):\nISSUE_TEMPLATE.md \u2192 ,git/ISSUE_TEMPLATE.md\nPULL_REQUEST_TEMPLATE.md \u2192 ,git/PULL_REQUEST_TEMPLATE.md\n. Thanks @piotr-cz , LGTM\n. Hey @arendjr , thanks for the PR, but if (as @gkatsev mentioned) the project is required through a browserify build system, the addition is not required, as it is all handled by browserify. We recommend in these cases not requiring from the dist dir directly, and instead using a browserify based build system. Thanks.. Hey @mjprude , sorry this ticket has gone a long time without much attention. We recently updated how we handle errors like this, and now if a playlist errors (including a 404 for a TS file) we will blacklist the playlist. If the playlist is the last one available, we will retry after a delay. I tested the scenario with a 404ing TS file, and the behavior followed that logic (and no longer throws an exception).\nPlease give the latest version of videojs-contrib-hls a shot (as of this comment, v5.4.0), and let us know if you notice any issues. Thanks for posting the issue and for the debugging information.. LGTM\n. LGTM\n. https://github.com/videojs/video.js/pull/3736 has since been merged into Video.js. @askaliuk , have you had a chance to give it a shot? Thanks again!. Confirmed in http://jsbin.com/sacizecaqe/3/edit?html,output . Thanks again for reporting the issue @askaliuk , and let us know if you encounter any more issues.. Closing for now. If you are still experiencing this issue with the latest version of videojs-contrib-hls (as of this comment, v5.0.0), please re-open the issue and provide a reduced test case using this template. Thank you.. Nevermind. I was trying to think of cases where a sync point showed what should be segments going over target duration (an invalid playlist, but curious to know the result), but I believe that should be covered.\n. LGTM\n. Hey @apatinoyu , did you have any luck with getting HTTP responses?  We've made a lot of changes to videojs-contrib-hls in the meantime. Please give v5.0.0 a shot (latest version as of this post), and if you're still experiencing issues, would you be able to put together a reduced test case using this template? Thanks.. In the latest player, we are seeing a bug where overrideNative does not work for Safari. That is being investigated in https://github.com/videojs/videojs-contrib-hls/issues/1005 . Closing this issue for now. Thank you.. Are there any unit tests we can pull over/modify as well?\n. We have a PR that we hope to get in soon that should address playback stopping for live streams when trying to resume after being paused for long periods of time: https://github.com/videojs/videojs-contrib-hls/pull/1006 . \nThanks for the test stream @blendi-93 . I tested it with the current player and the branch from the PR and confirmed the bug in the current player as well as working behavior when using the branch.. This should be fixed as of the latest release (v5.3.2). Please give it a shot and if you are still experiencing an issue, please re-open or file a new issue. Thank you.. Thanks for the note @bigt11 . @runtheyards are you still experiencing this issue with the latest version of videojs-contrib-hls (as of this comment, v5.4.0)?. Thanks for the update @runtheyards , we appreciate it. Closing this ticket. If anyone is still experiencing this issue, please let us know.. Sorry this ticket has gone a long time without much attention.\nAs @ip said, now that Chrome stable is past 55, and doesn't present the problem anymore (I can't reproduce the issue with the provided test streams), it sounds like the issue was addressed at the browser level.\nWe've also made a lot of changes to videojs-contrib-hls in the meantime. Closing for now, but If anyone is still experiencing this issue, please let us know. Thank you for reporting the issue, and for all of the debugging info.. Closing for now. If you are still experiencing this issue with the latest version of videojs-contrib-hls (as of this comment, v5.1.0), please re-open the issue and provide a reduced test case using this template. Since it requires network speed to be low, it's also ok to provide throttling settings for the Chrome dev tools in order to reproduce. Thank you.. LGTM. Thanks for reporting @arendjr , we have updated the documentation in https://github.com/videojs/videojs-contrib-hls/pull/992. Resolved as part of https://github.com/videojs/videojs-contrib-hls/pull/966. LGTM. Hey @fakirpic , is the stream stuck because it is still loading, because there's a gap in the buffer, or another reason? Do you happen to have an example that you can provide in a reduced test case using this template? Thanks.. Closing for now. If you are still experiencing this issue with the latest version of videojs-contrib-hls (as of this comment, v5.0.0), please re-open the issue and provide a reduced test case using this template. Thank you.. Hey @surikat1978 , it's hard to debug the issue without seeing it on a page. If you're still having trouble, would you be able to re-open the issue and provide a reduced test case using this template? Thanks.. Hey @Kasher , thanks for reporting the issue! The current behavior is definitely an issue (the player getting stuck and never loading), however, for load calls with the HTML tech, the underlying video element is sent a load, which resets the media element ( https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-load ). I think to resolve this and keep close to the spec we'll have to do some of the aborting behavior as well in videojs-contrib-hls.\nWe will still try to find a way to fix this, but is there a specific use-case you were looking to solve?\nThanks again!. Hey @Kasher , thanks again for reporting, and for providing the information. I just saw https://github.com/videojs/videojs-contrib-hls/issues/806 looks to be the same issue. Going to close this one in favor of the older one.. Hey @zainmansoor and @mjneil , I also watched both videos (in the jsbin and in the geo.tv link) multiple times, with skipping around and without, and though I think I recall seeing a longer ending once in the flash variant, they both now appear the same to me for the last 15 seconds, and I can't seem to validate the other behavior that I recall.\n@zainmansoor , are you seeing this with other sources, or just this one? And does it replicate the same behavior in flash vs html every time, or just some/most times?. @zainmansoor , I created a jsbin with the latest Video.js and videojs-contrib-hls ( http://jsbin.com/requfo/1/edit?html,output ), as well as with 5.10.2 and 4.0.2 (the version @mjneil created) ( http://jsbin.com/requfo/4/edit?html,output ) and don't see the issue in either.\n\n\nChrome version: 55.0.2883.95 (64-bit)\nWhat version of Chrome are you using?. @zainmansoor , have you been able to test with another version of Chrome?. Is there anything else in your environment that could be impacting it (maybe a browser extension)?. Thanks for testing in different environments @zainmansoor . If we notice this come up locally we'll try to post here with any info we gain (or potential solutions). If you happen to stumble across any reason that it was occurring, we'd be happy for the info too. Thanks again.. Good call @imbcmdth . Here are a couple approaches (I think (1) is better, but there are definitely alternatives from these as well):\n1) When we update segment loader's playlist with a refresh and change the media index of segmentInfo, we also change the segment reference. We'd have to check that the segment exists on the new playlist (media index did not turn negative). If it doesn't exist, we simply leave the old segment reference (it'll save info onto a segment that is missing from the playlist, but no harm will be done). This is the simplest change from the current code.\n2) Instead of saving the segment reference on segmentInfo, we continue to use mediaIndex and the playlist reference but save old segments that are not officially part of the playlist anymore for the case where they fell off. This may lead to misleading playlist objects, as we will save information that technically no longer exists in the playlist.. Updated. Thanks for reporting @delgermurun , and thanks for the response @andreyhammer . This behavior is intended, and we rely on the browser cache to handle the caching for keys. While we might be able to do the caching of the key ourselves, we'd have to be aware of potential \"HTTP expires\" headers to handle mentioned key rotation and make other considerations in the code. As of now it is simpler to rely on the browser cache.. Hey @fakirpic , it sounds like there might be gaps in the stream. This could be due to a variety of reasons. Would you be able to put together a reduced test case on JSBin using this template? Thank you!. @fakirpic , usually that error indicates that there is a problem downloading the playlist or segment from the server (usually this means the server is having a problem or is missing the information).\nIf you have a way to provide a sample stream that demonstrates this issue, we can check to see what might be going on. But without the stream itself, we can't reproduce it. If the problem of different domains is due to a lack of CORS, we might be able to proxy a CORS header to test.. Closing for now. If you are still experiencing this issue with the latest version of videojs-contrib-hls (as of this comment, v5.0.0), please re-open the issue and provide a reduced test case using this template. Thank you.. We're developing a plugin for that. Keep an eye on https://github.com/videojs/videojs-contrib-quality-levels and https://github.com/videojs/videojs-contrib-hls/pull/929. And let us know if you have any questions about them.. Leaving open for now until the PR is merged.. Thanks for the recommendation @mkhazov ! @elhampour , we actually just merged in https://github.com/videojs/videojs-contrib-hls/pull/929 and https://github.com/videojs/videojs-contrib-quality-levels is available as a plugin to make it easy to request player.qualityLevels() and enable/disable them. videojs-contrib-hls now supports it as of version 4.1.0. https://github.com/videojs/videojs-contrib-quality-levels has some documentation on how you can use the feature. Please let us know if you encounter any issues with it.. Hey @stoicbuddha , we do have a beforeRequest function that can be overridden to modify the URLs before they are requested: https://github.com/videojs/videojs-contrib-hls#hlsxhr\nPlease let us know if that doesn't work for you!. We don't have an exposed API to clear out the buffer/cause an immediate switch. However, if you use https://github.com/videojs/videojs-contrib-quality-levels then it should start overlaying content, and should switch within 1 segment duration (possibly sooner, possibly a bit later).. @elhampour , does this satisfy your use case?. Closing for now. If this didn't satisfy your use case, please let us know. Thank you.. Looks like the cases were solved. Closing.. Thanks for reporting @architsinha . Confirmed with latest version (v5.3.0) and the provided source.. Looks like this has been fixed. Closing. If you are still experiencing issues with the latest version of videojs-contrib-hls, please let us know. Thank you.. Thanks for reporting @fozzle . https://github.com/videojs/mux.js/pull/151 was recently merged in. This is pending a release of mux.js, but should be resolved soon.. A fix for this was merged in via https://github.com/videojs/mux.js/pull/151 , and was released as part of v4.1.3 of mux.js. videojs-contrib-media-sources and videojs-contrib-hls were also updated to point to the new version. Please give the latest version of videojs-contrib-hls (v5.5.0) a shot and let us know if you are still experiencing issues. Thanks for reporting the issue!. Dependency requirement on m3u8-parser 2.0.0 updated and released as part of videojs-contrib-hls 4.1.0. Thanks @zshenker !. Closing for now. If you are still experiencing this issue with the latest versions of videojs-contrib-hls  and Video.js (available via the jsbin template below) please re-open the issue and provide a reduced test case using this template. Thank you.. Hey @mkhazov , sorry this issue has gone a while without much attention. I tried playing your stream, but it seems that a lack of CORS headers was preventing me from playing it: XMLHttpRequest cannot load https://embed.life.ru/playlist/e2edb01fb1d61d965328785310e3f617/index.m3u8. No 'Access-Control-Allow-Origin' header is present on the requested resource. Would you be able to add CORS headers so we can give it another go? Thanks.. Closing for now. If you're still having trouble, please add CORS headers to the stream and re-open the issue. Thank you.. Hey @csuarez93 , are you trying to prevent the player from downloading any m3u8 file until after the play button is clicked?. @stoicbuddha , there isn't a current solution, however, we are looking at ways to add it via a configuration flag. Hey @zshenker , thanks for letting us know it was resolved. I don't imagine there should've been issues with those versions of each project, though it's possible the issue was due to videojs-contrib-hls' listing of video.js ^5.15.1 as a dependency for videojs-contrib-hls 4.0.3. Please let us know if you find any more issues, and thank you.. Hey @DonkeyInBeijing , when you seek in a video, even with good network speed, the segment must be downloaded, transmuxed, and then appended to the buffer. And with certain HLS playlists, sometimes the first seek is not accurate due to inaccurate timing information, meaning we have to restart the process to get a new segment until we find the segment that covers the seeked to time.\nIf you have an example playlist that seems to be taking a while on seeks, we'd be happy to take a look and see if maybe due to stream timing issues our seeks are not optimal, the segments are large enough to be causing delays, or there are any optimizations we can make (with the stream or player). Let us know, and thanks.. Closing for now. I tested some sources comparing the players and saw similar performance for seeking in both. If you have a certain source that seems to perform better in one player versus the other when seeking, please let us know. Thanks!. Hey @TylerZubke , when a live stream is set we want to seek to the latest seekable position (so that we are at the live point). If a preroll has to play before it, it might make sense for that source to be set before the live source is set (or some other alternative). This might make more sense to be handled outside of videojs-contrib-hls, as this project should seek to the live point as soon as possible for a live source.. Closing for now. Thanks for reporting @TylerZubke , but I think this should be handled outside of videojs-contrib-hls, since videojs-contrib-hls should only focus on playing HLS. However, if it turns out that videojs-contrib-hls is not firing appropriate events/handling order of operations for playback in a sane way that allows other plugins to listen and act appropriately, feel free to re-open or create a new issue here.. Hey @servercimen , sorry this ticket has gone a while without much attention, and thank you for reporting the issue. We've made a lot of changes and improvements to our segment fetching logic, including around seeking. I gave it a shot with our latest player: http://jsbin.com/vokipos/34/edit?html,output (at the time of this comment, v5.3.3), and the seeking looks much snappier and consistent versus the sample you provided from version 4.1.0. Please give it a shot and let us know if you are still experiencing issues. Thank you.. Video.js 5.16.0 is now latest. Closing for now. If you are still experiencing this issue with the latest versions of Video.js (as of this comment, 5.16.0) and videojs-contrib-hls (as of this comment, v5.1.0), please re-open the issue and provide a reduced test case using this template. Thank you.. Glad to hear it @DonkeyInBeijing , thanks for letting us know!. @gkatsev , I assume this is expected since it is for Video.js 6 and videojs-contrib-hls has not yet been updated to support it?\nException on line: videojs.getComponent('Html5').isSupported() where getComponent('Html5') returns undefined.\nJSBin: http://jsbin.com/catonuj/2/edit?html,output. LGTM. Example jsbin: http://jsbin.com/puqihuc/3/edit?html,output. Tested, but with the same code I can't get it working on IE11/Windows 7 (not even getting cuechange events from the segmentMetadataTrack), whereas it works even for Flash (and HTML) on Chrome/Mac.. From issue https://github.com/videojs/videojs-contrib-hls/issues/491 , a live stream that may exhibit the same issue is http://mahoaobj.b5695cde.cdnviet.com/tuandn/videojs/hls/vtv5-high.m3u8 .\nThis stream only has 5 segments in the live window, with each around 4 seconds. Due to a slow connection, the playlist refreshes before the segment download completes, and the segment falls off the end of the playlist.\nPlayback eventually started when running in Safari, but I haven't managed to get playback to start in Chrome.. Should be handled by https://github.com/videojs/videojs-contrib-hls/pull/1006. This should be fixed as of the latest release (v5.3.2). Please give it a shot and if you are still experiencing an issue, please re-open or file a new issue. Thank you.. Good call @mjneil , changed it so that they can be changed anytime.. Thanks @gkatsev . Closing in favor of https://github.com/videojs/videojs-contrib-hls/pull/1151. Hey @sgavali , Android supports native HLS playback, so we use their player if available, and you may not have access to all of videojs-contrib-hls' features. You can override that behavior using https://github.com/videojs/videojs-contrib-hls#overridenative if you'd like.\nIf that doesn't work, please let us know. Thanks.. In our testing, playback seemed relatively equitable. Though as always there's the possibility of bugs. If you don't need many advanced features, native can be a good choice for browsers that support it. But if you want the full range of features that videojs-contrib-hls supports with its own playback on top of the basics, then it might be worth giving native override a shot.. As an update, videojs-contrib-hls might not be fully supported for some older versions of Chrome (re: Chrome 46 mentioned in your comment).. Hey @onigetoc , do you have an example of your page?. Hey @onigetoc , glad to hear you got it working. If anything else comes up, please let us know. Thank you.. That is definitely something we will consider, or it can be done via a plugin @onigetoc \nAs for the behavior we have implemented in the above PR, we try to resume from wherever the viewer paused, but if it has been a long enough time that the paused time fell out of the available window, we seek to the live point and resume from there.. This should be fixed as of the latest release (v5.3.2). If you are still experiencing an issue, please re-open or file a new issue. Thank you.. I updated the title @kjdev-lytleworks , hope that is alright. As mentioned higher up, the issue is due to there being multiple audio tracks in each segment. The issue is the same as https://github.com/videojs/mux.js/issues/106 and will be resolved there.\nRight now, we don't currently support having two audio tracks in one TS file, as it isn't too common (since it uses excess bandwidth to pass both). However, we do support alternate audio tracks, which separates the audio from the video, meaning the player only needs to download the relevant audio file for the user's selection (or whatever is defaulted). We recommend using that instead.\nBut the audio distortion and syncing issues should still be resolved, and the player should just choose one included track and stick with it (and possibly log a warning).\nThanks for posting the issue and relevant debugging information (and thanks for finding the source @nconcetti and @cronello ).. Hey @seeLuck , thanks for reporting, but I'm going to close this ticket in favor of https://github.com/videojs/videojs-contrib-hls/issues/600 . Thanks @mahpah for referencing it.. Hey @gnujosh , thanks for the PR.\nThe Tavis CI build failed due to linting errors. One I noticed was an extra space at the end of line 125 of src/master-playlist-controller.js https://github.com/videojs/videojs-contrib-hls/pull/996/files#diff-3f8fe2d6cf175982cf8257063da92a81R125\nAs for the change, we may want to consider another option to test for transport streams. The only reason I mention that is that it is possible the URI will not end in .ts (for instance, there could also be GET data after the .ts). Do you have any other ideas offhand on methods we can use? Otherwise, we may have to consider inspecting the init segment to determine if it is mp4 or mpeg2ts.. Thanks for the catch @kitce ! Created a PR to fix it at https://github.com/videojs/videojs-contrib-hls/pull/1001. We could run doctoc for the TOC, but not a big deal. YAY!. Thanks for reporting @kennypavan . Yeah, we haven't used overrideNative for Safari, and it seems there is an issue here. It definitely warrants further investigation.. Hey @dtiesling , thanks for reporting. Do you have a sample video you can drop into our starter template to demonstrate the issue?\nAnd when you noticed it on Safari, were you overriding native playback?. Thanks for trying to make something publicly available.\nAs for Safari, the reason I ask is that by default on Safari videojs-contrib-hls will use Safari's native HLS player. If you're hearing the audio desyncing with both the videojs-contrib-hls player on Chrome and on Safari's player, it potentially points to a content issue.\nWe have tested the plugin on long encrypted videos (both VOD and LIVE), and they seem to work well, although it's always possible a bug may have appeared or the content is encoded in such a way that it leads to a new issue.. Hey @dtiesling , it looks like it's most likely coming from the stream. When playing, I get logs in chrome://media-internals where it is dropping audio frames, e.g., Dropping audio frame which failed decode with timestamp: 10432000 us, duration: 21333 us, packet size: 359 bytes, and Large timestamp gap detected; may cause AV sync to drift. time:33472000us expected:33407999us delta:64001us. Hope this helps.. Hey @caobug , the HLS spec only allows certain formats (e.g., MPEG-2 Transport Streams and Fragmented MPEG-4). Behavior is not defined for other formats (including flv). However, a videojs playlist plugin might work in this case. Would that help your use case?. Hey @caobug , for that XML file to be playable, you can create a Video.js plugin (see https://github.com/videojs/video.js/wiki/Plugins for details) to parse and play that content . But since that is a different file type and spec from HLS, it'll have to be outside of the videojs-contrib-hls plugin.. Hey @caobug , if you go to https://github.com/videojs/video.js/wiki/Plugins , you can see some documentation about how to create Video.js plugins and some example plugins on the page. If you follow those instructions and examples, you should be able to create your own plugin that can parse the example XML file you posted, then append the flv data to https://github.com/videojs/video-js-swf similar to how it is done in https://github.com/videojs/videojs-contrib-media-sources .. @alibrightman , that looks like it is due to https://github.com/videojs/videojs-contrib-hls#ie11. Hey @mikhoul , thanks for the reporting the issue. I definitely see that the stream makes a lot of segment requests before it begins to play, and then plays without audio, whereas it's able to play with audio in Safari. We'll take a closer look to try to figure out what's going on.. It seems to download the whole playlist before playing the video with no audio when using HTML. However, when using flash, it plays the audio with no video (and starts immediately).. Thanks @shaolintibo for reporting the issue and providing the sample (and @mikhoul and @mjneil for debugging the issue). Let us know if the player still has trouble after the gap resolution.. ~~Hey @mikhoul , thanks for posting the stream. Usually that error indicates a problem downloading either the m3u8 file(s) or the segment(s). I tried to go there myself to see the playlist but just got \"Access Denied You don't have permission to access \"http://chaine_tva_uls-lh.akamaihd.net/i/tvago_1@410563/master.m3u8?\" on this server.\"~~\nEDIT: sorry, just noticed the token part. After generating a new token I was able to play the stream in the player at http://videojs.github.io/videojs-contrib-hls/# .. Hey @mikhoul , I noticed that in the Firefox screenshot you are getting 403 forbidden responses for the segment requests. That looks like it must be a problem either with the server, or with the credentials/client requesting the segments. I also noticed that in the Chrome screenshot those requests are for the manifest refreshes (since it is a live stream), not for TS fragments (one way you can tell, even without the full URL, is that the requests seem to be at 10 second increments which is the target duration for that stream). I am still able to play the stream in the example page after generating a new token. Would you be able to give it another shot? Thanks.. Hey @mikhoul , I gave it another shot in the environment you mentioned (Chrome on Windows 7) and it worked for me there too. I still haven't been able to replicate the issue. It's possible that it could be related to some Chrome config or plugin, or possibly a network related issue that you are experiencing when using Chrome.. Hey @mikhoul , have you been able to find the source of the issue? I still haven't been able to reproduce the problem. Would you be able to give it a shot on a different machine?. Closing for now. If you are still experiencing this issue, please give it a shot on another machine and let us know if the result is the same. If it is, let us know if you took any different steps to reproduce the problem. Thanks.. Looks like the root of the problems for the available streams was missing CORS headers. If you are encountering any other issues with the player, please let us know. Thank you.. Hey @mikhoul , haven't gotten to look too closely at the stream yet, but I do see that it is not playing back. I think it's the same issue/stream as posted in https://github.com/videojs/videojs-contrib-hls/issues/1013 , so I'm going to close this one in favor of the other issue. If you believe they are separate issues, we can re-open this one or add a separate issue.. @dbryand , thanks for the update.\n@vpowers , are you still experiencing this issue with the latest versions of video.js and videojs-contrib-hls?. Closing for now. If you are still experiencing this issue with the latest version of videojs-contrib-hls (as of this comment, v5.5.3), please re-open the issue and provide a reduced test case using this template. Thank you.. Thanks for reporting the issue @dtiesling , and thanks for the sample code (as well as the PR using some of it from @leonardo-hotmart ).\nI posted a bit over in https://github.com/videojs/videojs-contrib-hls/pull/1042 , but I wanted to copy over some of the conversation, as well as an update on addressing this issue.\nWhile that sample code may help relieve the problem, it may also cause some other behavior. For instance, if the requests keep erring for the same playlist, we do want to try a different one (if one is available). Or if someone tries to pause the video during the 5 second delay, then that code will automatically resume after those 5 seconds (though that can be resolved with more state management).\nTo address at least part of this issue, we have a PR incoming that never blacklists the final rendition available: https://github.com/videojs/videojs-contrib-hls/pull/1026\nWhile this means for streams with multiple renditions a loss of connection may end up blacklisting all but one rendition (for a period of 5 minutes), it should solve the problem for single rendition playlists, and will help prevent connectivity loss from blacklisting all playlists when multiple are available.\nPlease let us know if you have any ideas for improving/enhancing this logic, or if this solution will work for you.. @leonardo-hotmart , while right now 5 minutes has been our standard blacklist duration, I think that, as you mentioned, an option for the blacklist duration may be a good idea.\nAnd in the case you gave, playing on the lowest rendition for potentially 5 minutes is definitely not the optimal solution Right now, if we see that a playlist errors, we want to blacklist it and move on to the next playable playlist, regardless of what the error is (because our information regarding the error is often too limited to make a decision otherwise). But maybe a good enhancement to the current solution would be: if all playable playlists are blacklisted, instead of remaining on the last one, we shorten the blacklist duration on the others/clear the blacklist and try again after a delay.\nWhat're your thoughts?. Thanks @leonardo-hotmart .\nThe initial fix for this issue was released as part of v5.4.0, so I'm going to close this. However, I opened https://github.com/videojs/videojs-contrib-hls/issues/1070 and https://github.com/videojs/videojs-contrib-hls/issues/1071 to address the enhancements discussed above.\nThanks again to everyone for your input and debugging info. Please let us know if you experience any problems.. Hey @omakogon , thanks for pointing out the association with the other issue. I think we should close this one and continue the discussion over there. And thanks for the source. I tried to reproduce the issue locally and in the example template provided in https://github.com/videojs/videojs-contrib-hls/issues/963 , but was only able to get \"Failed to execute 'appendBuffer' on 'SourceBuffer': This SourceBuffer has been removed from the parent media source.\" however the video still played. Are you still able to reproduce the issue, and is there any chance you'd be able to create a reproducible test case in this template? Thanks.. Hey @mescalito , thanks for the information, debugging, and the video. We really appreciate all the effort you put in into helping discover the problem.\nYou found the exact problem spot too, and we actually started working on a fix for it the other day, to allow for proper error events in the case where the media source's readyState is not yet open and the source stream fails.\nI'm going to close this issue, just because we have https://github.com/videojs/videojs-contrib-hls/issues/575 reporting the same item, but we'll be trying to get out a fix for it soon. Keep an eye on that issue, as we'll update as we get a pull request ready.\nThanks again!. Hey @belling , thanks for reporting. I confirmed the issue you were seeing. It looks like in the example you posted, the TS files have two audio tracks per segment (one for stereo and one for 5.1). We don't currently support having two audio tracks in one TS file, as it isn't too common (since it uses excess bandwidth to pass both). However, we do support alternate audio tracks, which separates the audio from the video, meaning the player only needs to download the relevant audio file for the user's selection (or whatever is defaulted). We recommend using that instead.\nIf you are still experiencing issues with only one audio track in the stream (or none if using demuxed audio/video as part of alternate audio tracks), please let us know. Thanks again.. Hey @leonardo-hotmart , thanks for the contribution!\nThis is an interesting problem, and you're right (as well as the posts in #1030 ), in that we shouldn't blacklist the playlist for a momentary loss of connectivity. This PR definitely can solve it, but it might introduce some other scenarios where the behavior is not quite optimal. For instance, if the connection keeps dropping for the same playlist, we may want to try a different one. Or if someone tries to pause the video during the 5 second delay, then it'll automatically resume after those 5 seconds (though that can be resolved with more state management).\nIt's also hard to detect the reason for the error. While an XMLHttpRequest status of 0 can be because of a momentary connectivity loss, it can also be because of CORS, firewalls, or another reason. In these cases we do want to blacklist and try another playlist.\nIt may be worth it for us to open up the discussion in the issue to see what people think would be the most optimal approach for error handling in these cases, but I'm interested to hear your thoughts.. Hey @naveen2245 , when someone hits the play button, if the video has ended, we seek back to the beginning of the video to restart: https://github.com/videojs/videojs-contrib-hls/blob/1fceb3e8932bd5b88acaa2e38d284441b9fbbb6a/src/master-playlist-controller.js#L925\nThis should be the case for at least any browser that doesn't support HLS natively (e.g., Safari), since it'll run through that code.\nI'm going to close this issue for now as answered, but if you are experiencing any other behavior (for instance, the video not restarting or different behavior per browser), please re-open and let us know what you're seeing. Thanks!. Thanks @samueleastdev for reporting the issue and opening https://github.com/videojs/videojs-flash/issues/13 . Closing this issue in favor of that one.. Added to README. Thanks for the suggestion @mjneil !. Hey @amit1990sumit , the primary and backup stream syncing is usually on the software used to generate the streams, however, if those appear to be in sync but the client (videojs-contrib-hls) is desyncing the streams, we will definitely want to look into the issue. Do you have a publicly accessible m3u8 you can throw into a template for us to check out?\nAs for the timestamps, are you trying to get the PTS/DTS values of different segments of the stream? I don't believe we have a public API at the moment to get those, but is the use-case simply for debugging purposes, or something beyond?. Closing for now. If you still need an API for PTS/DTS values of different segments, please let us know your use-case (for debugging, or beyond) and provide a reduced test case of your stream using this template. Thank you.. This is definitely a good idea. We should try to categorize what sorts of scenarios we want to test in this issue (maybe start with those you mentioned), so that we can check them off as we add them and ultimately resolve this issue.. Hey @selimatmaca , if that stream and template works on Android, but a different stream with the same template doesn't work, it points to it most likely being an issue with that different stream. If you are able to provide that stream , it can help us debug the issue.\nAlso, for Android, it should be using the native player, however, you can try using overrideNative to override that native player and see if it works otherwise. If you can give that a shot and let us know if it helps, that may also help point to the source of the issue.. Thanks for the tips @samueleastdev , and for the issue info @selimatmaca . It looks like this was an issue with the Android OS itself. Closing for now, but if you see any info regarding the issue that could point to something else, please let us know. Thanks.. Hey @onigetoc , I left the stream running for a bit, but I didn't see any errors. Do you happen to have any other information around the request that might help? And what version of videojs-contrib-hls are you using? Thanks.. @onigetoc , how long do you normally run that stream before it stops?. @onigetoc , I left it running for over 10 minutes, often in a background tab, but it never stopped playing for me. Is there anything in the console or any more network trace info?. @onigetoc , that sounds like it has to do with the server if it is returning a 403 or 404. However, we do have logic in the latest version of videojs-contrib-hls (v5.4.0) that will not blacklist the final rendition on a 403/404 and will continue trying. This means that even if there is a momentary loss of connection or a server error, the player won't give up, and will retry after a delay. Would you be able to give that version a shot and see if you still experience the error?. Hey @onigetoc , you may have to include the full 5.4.0 in the URL: https://cdnjs.cloudflare.com/ajax/libs/videojs-contrib-hls/5.4.0/videojs-contrib-hls.min.js. These errors sound like they are coming from the stream itself. Unfortunately, there isn't much we can do for the server responses, since the player seems to be making valid segment requests.. That's correct @onigetoc . One of the recent changes to the player is that we don't blacklist the final rendition, meaning that the player will keep trying that stream. This is normally fine, as the stream should be able to play within a player without trouble, and normally when errors happen it is due to the server being down temporarily, rather than a complete block due to permissions (in which case the stream isn't usually meant for that domain/user to play). However, it would be nice for developers to be able to react to such an event, so I opened: https://github.com/videojs/videojs-contrib-hls/issues/1074\nFor the purpose of this issue though, it looks like the server was creating the errors, rather than the player itself. Thanks for all of the examples and info. Closing this ticket, as the player is working as designed.. Hey @cjdeleon62 , it sounds like there might be something wrong with how you're packaging your application together. Would you be able to provide more details as to how you're building your application and making use of videojs-contrib-hls? Thanks.. If it works locally, then that leads me to believe it has something to do with the config for production deployment, or how heroku is setup for it. I know that some people have had trouble and success in https://github.com/videojs/videojs-contrib-hls/issues/600 with issues around packaging videojs-contrib-hls with webpack, so maybe something in there may help. Otherwise I'd recommend looking to webpack or heroku support. Since this works locally, and doesn't seem to be an issue with videojs-contrib-hls, I'm going to close the issue here, as it can be hard for us to debug the config and functionality of other modules and systems. If you do happen to find an answer, please let us know in this issue or the associated webpack issue, as it might help someone searching in the future. Thanks!. Hey @hmd13 , thanks for all of the details.\nThe second error looks to be due to CORS, as the server doesn't allow cross-domain requests (and when your page is hosted locally, the domain doesn't match what the server expects). This must be remedied server-side (as the server must allow CORS for your/all domains).\nAs for the first error, is \"blob:null/288470a8-ae84-4891-a545-7752a7387bc3\" set as the source of the video? Do you have a copy of the page you are hosting locally?. @hmd13 , @gkatsev 's answer should be the reason you are getting the first error (don't need to send the file).. Thanks @gkatsev . @hmd13 , let us know if you experience any problems with the player when using a server. Thanks.. Hey @Henry-nie , I noticed that in the sample you listed, you aren't including videojs-contrib-hls. video.js by default doesn't include videojs-contrib-hls, so it won't be able to play the m3u8 without it. Would you be able to try including it and see if it helps? And if it doesn't, would you be able to put together a reduced test case using this template. Thanks.. Thanks for the update @Henry-nie .. Hey @adnankorkmaz , thanks for reporting the issue, and for providing reproduction steps. For Chrome's device emulation though, it doesn't provide exact device emulation, only pieces of the device (e.g., it helps for responsive web debugging and handling device input -- https://developers.google.com/web/tools/chrome-devtools/device-mode/emulate-mobile-viewports).\nAndroid Chrome should be using native playback for HLS, unless override native is used (https://github.com/videojs/videojs-contrib-hls#overridenative). It may help if you could identify the Android device you are specifically testing the sample page on, as it could be a bug with their native playback. Thanks.. Thanks for the update @adnankorkmaz !. Thanks for reporting @pacepace . I gave the HLS test page a shot on Chrome 56 and Chrome 57 with hardware acceleration enabled on both (on a Mac), and it seemed to play through the first few segments without a problem. Maybe it is a problem related to the specific source, or possibly OS related. Would you mind including a link to the m3u8 you are using?. Interesting that it only happens on Chrome (works for me in Firefox too). chrome://media-internals doesn't show anything abnormal except audio splice trimming.. Hey @pebanfield , would you happen to have an example page demonstrating the error?. @pebanfield , looks like https://github.com/videojs/mux.js/issues/131 is most likely source of the issue (the error when building possibly stops contrib-hls from being included).\nvideojs/mux.js#151 was recently merged in. This is pending a release of mux.js, but should be out soon.. Hey @pebanfield , we cut v4.1.3 of mux.js with the fix for the browserify-shim error. Please give the latest version of videojs-contrib-hls (v5.5.0) a shot and if you are still experiencing the issue, please re-open the issue/let us know. Thanks for reporting the issue.. That's great to hear @pebanfield ! Thanks for updating.. Merged as part of https://github.com/videojs/videojs-contrib-hls/pull/1095 . Thanks for reporting the issue @gkatsev !. Sorry this ticket has gone a while without much attention. We've made a lot of changes to videojs-contrib-hls in the meantime, and I see that the stream is down. If this is still an issue with an active stream and the latest version of videojs-contrib-hls, please let us know. Thank you.. Hey @stoicbuddha , there seems to be a lot going on on that page, making it hard to try to trace down the problem. In particular, since iOS Safari uses a native player, it's either iOS Safari's native player being unable to play that source, or some configuration that is not being run because the native player is being used/iOS functioning differently. Would you be able to create a reduced test case using our starter template that just has an m3u8 exhibiting the problem? Thanks.. Hey @stoicbuddha , are you still having trouble with your stream?. Hey @zdenham , thanks for reporting the issue. Right now we don't support audio only streams. We have an enhancement issue opened to add support for it in https://github.com/videojs/videojs-contrib-hls/issues/499 . Safari uses the native player for HLS playback, and that native player does have support right now (why it works in Safari but not Chrome). Closing this ticket in favor of https://github.com/videojs/videojs-contrib-hls/issues/499. Hey @hmd13 , you can do this via a few methods.\nOne is that I noticed you're changing the src of the video element. Instead, try using the videojs src method and including the type of content. For instance:\n```\nvar player = videojs('myvideo');\nplayer.src({\n  src: 'http://d2zihajmogu5jn.cloudfront.net/bipbop-advanced/bipbop_16x9_variant.m3u8',\n  type: 'application/x-mpegURL'\n});\n```\nIn addition, you can use a playlist plugin (e.g., https://github.com/brightcove/videojs-playlist) to play videos in sequence instead.\nHope this helps, and let us know if you're still having trouble.. A test we should check for: if a live stream ends, and we switch to a playlist that we haven't seen before (don't have syncInfo), or, we tune into a live stream towards its end and rendition switch, then it is possible this may change that behavior.. We should also have tests for video/mp4 and audio/mp4. @samueleastdev , when I pasted the m3u8 directly into Safari I got the same message of \"Missing Plug-in.\" Did you manage to get around that error?. Sorry this issue has gone a while without much attention. I see that the stream is down now. Closing for now, but if this is still an issue with an active stream please let us know. Thank you.. Thanks for reporting @pandaiolo . This is an interesting case, and as we're looking into improving our ABR, we should investigate this more.. Good points @pandaiolo . And these issues are definitely on our minds as well. A PR was just submitted for a moving-average playlist selector: https://github.com/videojs/videojs-contrib-hls/pull/1125 which is another approach (instead of us simply using the last bandwidth to determine what playlist to select). This is towards a goal of experimenting with different ABR algorithms, and determining the best default, as well as giving people more choices for their specific players. The PR is one such example, but we have more in the works. In addition, we have other approaches being considered for the larger ABR \"epic\" https://github.com/videojs/videojs-contrib-hls/issues/1114\n. Hey @petergeneric , thanks for reporting. We definitely want to find a case where this is happening, however, we've haven't been able to replicate this behavior with any of our streams. Would you be able to provide a sample m3u8? Thanks.. Nice catch @mjneil . @petergeneric , while we should consider approaches to finding a fix for this, is there any way you could use shorter playlists, or does your use case require multi-day m3u8s?. Thanks for following up @petergeneric . Since your real world use cases are a shorter duration, I'm going to close this issue for now, as we don't often see people using multi day windows for their production playlists.\nIf you are still having any trouble, please let us know. Thanks again for posting.. Hey @manishchauhanquovantis , this looks like it might be an error with either video-record, or the webpack configuration. If it is the former, it might be better to open an issue in the video-record repo. If it is the latter, as @gkatsev mentioned, we have https://github.com/videojs/videojs-contrib-hls/issues/600 for webpack configuration. Hope this helps.. Closing as support has been added.. Closing for now. We may re-examine this in the future.. https://github.com/videojs/videojs-contrib-hls/pull/1135. PR was merged.. Only into a separate branch. Closing for now. We may re-examine this in the future.. ## Done\n [X] We can run simulation with multiple files\n [X] We get an output of relevant numbers (and in JSON format)\n* [X] We have some real results we can use to verify the simulator (with GOAL_BUFFER_LENGTH of 60)\nNext Steps\n\n[ ] Create scripts to summarize numbers\n[ ] Verify results\n[ ] Gather more files to do simulations\n[ ] Create ability for simulator to dynamically change configuration (e.g., automatically test GOAL_BUFFER_LENGTH values from 30 => 60 incrementing by 1 each time)\n\nLater\n\n[ ] Possibly extract to its own project\n[ ] Worry about automation\n[ ] Add ability to use an m3u8 instead of specifying bitrates and segment sizes. Tested, will merge once build passes.. Thanks @misteroneill . Closing in favor of https://github.com/videojs/videojs-contrib-hls/pull/1151. Hey @adel1ne , it's hard to debug what's happening without the stream and the page you are using it in. Would you be able to put together a reduced test case of what you are doing (and the stream you are using) using this template? Thanks.. Closing for now. If you are still experiencing this issue, please re-open the issue and provide a reduced test case using this template. Thank you.. Thanks @gkatsev . Closing in favor of https://github.com/videojs/videojs-contrib-hls/pull/1151. Hey @rishigohil , how are you playing the webm files? Would you be able to put together a reduced test case using our starter template? Thanks.. Hey @tchakabam , thanks for the awesome PR, we definitely should have support for multiple video tracks. As a start, I saw you mentioned that you are setting up some test content. We'd definitely like to give it a shot and see it in action.. Hey @hungsama , I don't have a webOS TV to test on, but checking online it looks like they may support native HLS playback. In videojs-contrib-hls we will default to native playback if it is supported, otherwise fall back to using media source extensions (a browser feature). While webOS TV may support native playback, in our code we check by using: https://github.com/videojs/videojs-contrib-hls/blob/master/src/videojs-contrib-hls.js#L254 . Would you be able to run that code on a device and say if any of the canPlayType calls return \"maybe\" or \"probably?\" It's possible it is not returning either of those for any of the types, and is trying to fall back to media source extensions (which the browser may or may not support, and if the browser doesn't support it, videojs-contrib-hls won't have any more options for playback).. Closing for now. If you are still experiencing this issue, please re-open the issue and let us know what the result of running that code is. Thank you.\n. Hey @yuetianle , thanks for reporting, but right now there isn't much browser support for h265 ( https://caniuse.com/#feat=hevc ), and due to that we have no current plans for adding h265 support.. Confirmed the behavior on Chrome. Thank you for reporting the issue and providing the sample source @tommobicast !. Hey @poda5d2 , MEDIA_ERR_SRC_NOT_SUPPORTED usually indicates that either videojs-contrib-hls is not being included and there is an m3u8 provided as the source, or that the content is not playable by any of the available technologies (e.g., the source's content type is mislabeled).\n\nI think there may be a few issues going on here though. From your source of http://82.141.138.201/livevideo it doesn't look like that leads to a playlist, and is not segmented. Judging by the playlist you posted, there's only one link (that provided source), where in HLS the content should be segmented, and for live HLS streams there should be a minimum of 3 segments in the playlist at any given time.\nIn addition, there are two types of playlists: master, which has a list of other playlists (different variants/renditions), or a variant/rendition playlist, which has the list of segments. Master playlists require more information for each of the variants (e.g., each must have BANDWIDTH information), and variant/rendition playlists must have target durations and a duration for each segment.\nFor more details, the latest spec for HLS can be found at https://tools.ietf.org/html/draft-pantos-http-live-streaming-23. Interesting. Would you be able to put together an example of each (working with older version, not working with newer version) using our start template? Thanks.. Hey @poda5d2 , I looked at the examples. As you said, the old example doesn't seem to use HLS, and is instead using video/x-flv. It also didn't seem to play for me.\nThe HLS manifest that you have as playlist.m3u8 in the new example isn't a valid HLS playlist, and HLS also doesn't support streaming FLV.. Closing for now. Please try setting up your HLS playlist with valid ts or fmp4 segments and give it another shot. If you're still having trouble with that, let us know. Thanks.. Closing in favor of https://github.com/videojs/http-streaming/pull/275. Hey @d3im , thanks for reporting. We haven't experienced this issue before. Would you be able to provide a sample m3u8 you used that demonstrates this issue? Thanks.. Hey @martinstender , thanks for the issue, but this looks like it has to do with contrib-ads rather than contrib-hls (contrib-ads might be seeking as it restores the state, thereby clearing the buffer  after contrib-hls may have started playing, leading to a stall as it reloads content). I think it might be better as an issue on that repo rather than here, unless this can be replicated with contrib-hls without the addition of contrib-ads.. Hey @martinstender , I see the issue posted at https://github.com/videojs/videojs-contrib-ads/issues/263 .\nIs there any chance you might be able to reproduce the issue without the contrib-ads plugin (using just our starter template )? If so, then we can definitely take a look at it here. Otherwise, I think we should close this one in favor of the other issue. The main reason for that is because it seems the problem goes away whenever ads are disabled.. Closing for now. If you are still experiencing this issue with the latest versions of videojs-contrib-hls and videojs-contrib-ads, please let us know. Thank you.. Hey @HankBrown , the JS Bin referenced in the \"Check out our live example if you're having trouble.\" part of our README is actually up-to-date. We don't usually include references to other plugins (and we don't actually manage https://github.com/streamroot/videojs-quality-picker ). We recommend that you ask there for an example on how to use it.. Those numbers sound good to me @mjneil . https://github.com/videojs/videojs-contrib-hls/pull/1156. Hey @WaluTechnician , thanks for providing a sample page. I took a look and noticed that your js/videojs-contrib-hls.js just references the main file of the project, not the actual built project. Would you be able to update that reference and give it a shot again? Thanks.. No problem @WaluTechnician , glad to hear it helped. As for the playbackRates, yeah, that would be something outside of contrib-hls.\nGoing to close this issue for now. If you're still having trouble with any HLS features, please let us know. Thanks.. Closed https://github.com/videojs/videojs-contrib-hls/pull/720 in favor of this PR. Hey @WaluTechnician , Android Chrome should be using native playback for HLS, unless overrideNative is used (https://github.com/videojs/videojs-contrib-hls#overridenative). This means that if you're using native playback, the issue has to do with the Android Chrome browser, rather than videojs-contrib-hls.\nIf you can, try using overrideNative and see if playback rate changes as expected. Let us know if that helps.. Hey @WaluTechnician , have you had any luck with overrideNative?. Thanks for the update @WaluTechnician , and we'll definitely have to take you up on that!. Hey @Esteban555 , it looks like there's a special VLC related tag that mentions the user agent option in that playlist. Is this m3u8 meant only for playback on iPhones? We don't really look to override the user agent string on the player. Is that what you're looking for?. Hey @Esteban555 , trying to bypass the security via the client is generally something we want to avoid. Instead, it would be preferable to set up the server in such a way as to allow clients that need to be supported. If the security from the server says that the specific client shouldn't play it, we probably shouldn't play it.. Closing. Please try modifying the server to allow the devices from which you are trying to play back your content. Thank you.. Hey @klimentLambevski , thanks for reporting. Right now iOS doesn't support media source extensions ( http://caniuse.com/#feat=mediasource ) which is required for us to override native functionality ( https://github.com/videojs/videojs-contrib-hls#overridenative ). Without MSE support, videojs-contrib-hls can't play HLS, so we continue to use native support. Once iOS supports MSE, we'll be able to override the native functionality.. No problem @klimentLambevski .\nAs for HLS stream resolutions, we haven't found a way yet to manually change renditions in browsers with native playback, as the W3C spec doesn't yet define an API for it, and we haven't seen the native players providing separate APIs either.\nThere might be a way to get around that by having controls which set different sources on the player (and then tries to seek to the previous time), and I'm not positive but there might be plugins for videojs out there that do that already.. Hey @maryam-abdullah , it looks like the http request for that TS segment had an error (could be a timeout, lost connection, server had an error, etc.). Would you be able to check your network tab in developer tools to see what the response is? Thanks.. I'm not sure why they're not in the network tab. Did you get the network tab screenshot around the same time as those errors occurred?. And which browser are you using?. Is there anything else in the console log? And would you be able to link your playlist?. It's possible it's from the internet connection, though I'd still expect to see something in the network tab or in the console. It's hard to diagnose without being able to reproduce it though. Any chance you'd be able to find a way to reproduce it (if it is internet connection related, maybe using chrome's network tools)?. @maryam-abdullah , you can try using Chrome's network tools (specifically their throttler) to slow down and disable your internet connection.. That sounds like good news! In that case, I'm going to close this issue. If you see it happening again, try to create a reproducible test case for it and open a new issue. Thank you.. Hey @kiscoman , thanks for reporting, but Chrome's device toolbar is limited in its functionality. While it is often helpful to test certain aspects of these devices, it has many limitations ( https://developers.google.com/web/tools/chrome-devtools/device-mode/emulate-mobile-viewports#limitations ). Is this the feature you are using, and would you be able to test on a physical device? Thanks.. That seems to be correct behavior, that a real device would work but Chrome's device toolbar would not always be expected to work.\nAs for the mobile data vs wifi, would you be able to explain that case a bit more? Are you using a real device and changing the network during streaming, or if you start up on mobile data vs wifi the behavior is different? Does the player say anything specific? Thanks.. Do you see that happening with the default template https://github.com/videojs/videojs-contrib-hls/issues/url ?. Not sure why it would cause that (not too experience with WOWZA), but we're happy to hear the issue went away. If it returns, please let us know, and thank you.. Hey @rishigohil , I created a jsbin with that source here http://jsbin.com/nuqehab/1/edit?html,output and I don't see the error you are seeing. Would you be able to put together a jsbin based on that template that exhibits the error? Thanks.. Thanks for the update @rishigohil , and glad to hear it's working.. It also looks like the source is down now. @Dolphy888 , please give @mjneil 's suggestion a shot, and if you are still experiencing problems, please open a new issue with the example source in our starter template. Thank you.. Thanks for updating @sbalay , as you noticed, the simulator is the cause of the problem. This is because the Chrome device simulator does not simulate all aspects of the device needed for playback (see https://developers.google.com/web/tools/chrome-devtools/device-mode/emulate-mobile-viewports#limitations for reference).\nPlease give it a shot with a real device, and if you are still seeing problems there (or with any desktop browsers), please let us know. Thanks.. Thanks for answering @mister-ben . @beautylix , please try adding CORS headers to your stream and give it another shot. If you notice any problems after that, please let us know with a new issue. Thank you.. Sorry this ticket has gone for a while without much attention. Many mobile browsers use native playback for HLS, meaning our APIs won't be available. https://github.com/videojs/videojs-contrib-hls#overridenative can be used for browsers that support MSE (and the features we need), including some mobile browsers, but it may impact some aspects of playback. Hope this helps.. Thanks for answering @mister-ben ! As @mister-ben said, if it plays back on desktop browsers but has trouble somewhere a native player is used (e.g., iPad Safari or Safari on desktop), it is most likely a problem with the stream or the native player. It may also be worth giving it a try in desktop Safari, where we use the native player.. Hey @triwav , thanks for reporting and for providing the example. I think it's doubling up because there are multiple instances of each caption. For instance, the first caption segment has \n```\nWEBVTT\nX-TIMESTAMP-MAP=MPEGTS:900000,LOCAL:00:00:10.000\n01:24.360 --> 01:28.381\n.\n\n\nI THINK IT IS IN DIRECT\n```\n\n\nwhile the second has\n```\nWEBVTT\nX-TIMESTAMP-MAP=MPEGTS:900000,LOCAL:00:00:10.000\n01:24.360 --> 01:28.381\n.\n\n\nI THINK IT IS IN DIRECT\n\n\n01:28.381 --> 01:34.531\nCONTRADICTION TO WHAT WAS SAID\nLAST WEEK, THAT HE DOESN'T\n```\nNotice that \"I THINK IT IS IN DIRECT\" is specified multiple times (as you said, because it crosses segment boundaries). We don't dedupe captions, as we just read them as if they are one big document that has been cut up into segments. That is probably the reason they are doubling up in the stream.. I think you're right @triwav . The spec reads:\n\"Each WebVTT Segment MUST contain all subtitle cues that are intended to be displayed during the period indicated by the segment EXTINF duration.\"\nThis means that if a subtitle is split over two segments, it should appear in both webvtt segments (by my interpretation). So we should handle the case presented here.\nI'm going to consider this a bug unless anyone has other thoughts on it (or different interpretations). And thanks again for reporting @triwav . Hey guys, sorry you are having trouble with webpack and videojs-contrib-hls. Some people have found success with webpack in https://github.com/videojs/videojs-contrib-hls/issues/600 . Please give some of those strategies a shot. I'm going to close this issue in favor of the other.. Hey @AleksanderSadov , I see that your playlist is live. I've been running it for a while, but haven't run into the issue yet (Chrome on Mac).\nI see that you're running on Linux and encountering the issue after a few seconds. Maybe that could provide a difference. Would you be able to encounter the issue again, then go to chrome://media-internals, find the relevant player, and see if there are any logs?\nThanks!. Sorry for the delay, one problem with MEDIA_ERR_DECODE errors are that they are usually stream specific. The Chrome media-internals logs can help, as those logs from the browser can sometimes have helpful information about what caused the error. Usually though, the issue is something to do with the stream or how it is segmented. The most helpful thing for us to debug these issues is to:\n1) Provide the chrome://media-internals log\n2) Provide a reproducible test case: if the stream is live, or is a long playlist, making a shorter playlist from the segments around when the error occurs can be helpful (so long as it reproduces the issue, it is much easier to determine what is happening and why the segments might cause the problem). Hey @beautylix , were you able to add CORS headers for the other requests within the playlist?. Closing for now. If you are still having trouble, please let us know. Thank you.. Hey @sea-kg , thanks for submitting a PR. Have you tried using the withCredentials option? https://github.com/videojs/videojs-contrib-hls#withcredentials. Hey @tchakabam , thanks for the PR, we really appreciate it! The graph looks really cool. We're still looking at some of the changes, particularly related to switching without clearing the buffer, but for the quality graph and tracking the buffered qualities, did you happen to look into the utils/stats/index.html page ( https://github.com/videojs/videojs-contrib-hls/blob/master/utils/stats/index.html ) and the segment-metadata track ( https://github.com/videojs/videojs-contrib-hls#segment-metadata ) ?. Hey @Okapist , are you still experiencing this issue? And is the player re-requesting some fmp4 segments, or you're just seeing the live playlist updating?. Closing for now. If you are still experiencing this issue with the latest version of videojs-contrib-hls, please let us know (and provide a test stream if possible). Thank you.. Hey @ChoOo7 , thanks for providing the sample source. I believe this is an issue with the source itself, as if you play it in Safari (just copying and pasting the URL into the address bar) it will behave the same (changing aspect ratio). If you open the m3u8 and look at the segments from different renditions, you can also see this. For instance:\nhttps://damdy-dam-videos-pad.brainsonic.com/dam/20170718-144907-5638b245/hls_1/main_stream_610k-00000.ts\nfrom the 610k rendition behaves as you expect (expected aspect ratio). However,\nhttps://damdy-dam-videos-pad.brainsonic.com/dam/20170718-144907-5638b245/hls_1/main_stream_4550k-00000.ts\nfrom the 4550k rendition (same segment) has the stretched aspect ratio.\nHope this helps!. Thanks for the sample @shinefour . One thing that may contribute to the issue is that I saw there are CORS errors being logged to the console for both Chrome and Safari. Here's an example from Chrome:\nText track from origin 'http://vod-origin.globalmest.net' has been blocked from loading: Not at same origin as the document, and parent of track element does not have a 'crossorigin' attribute. Origin 'http://ext.globalstudio.es' is therefore not allowed access.\nXMLHttpRequest cannot load http://vod-origin.globalmest.net/8RK9QO/RNeL5y/Q4ZlLR.vtt. No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'http://ext.globalstudio.es' is therefore not allowed access. The response had HTTP status code 404.\nAnother thing to note is that Safari uses native playback by default, but seems to be able to play the m3u8 if loaded directly into the browser. It's possible that the CORS errors are preventing Safari from playing back the content.\nPlease try adding CORS support, giving it another shot, and letting us know. Thanks.. Thanks for the info @shinefour and @hazarartuner . I see the issue. Another interesting note is that if you include default in the track, it will show the first caption in safari (overlayed by the error).. Thanks for the update @hazarartuner . Closing for now. If anyone is still experiencing this issue with the latest version of videojs-contrib-hls, please let us know. Thank you.. @tchakabam is right. In order to follow the spec, we only want to allow a playlist to be LIVE if there is no EXT-X-ENDLIST present. Closing since this follows the spec, but definitely check your encoder, as there should be a way for it to not include an EXT-X-ENDLIST until the stream is over.. Thanks for the issue, ~~however, we haven't seen it ourselves (or in our starter template)~~ [edit: turns out I am actually self assigned to this issue at https://github.com/videojs/m3u8-parser/issues/25]. ~~Would you be able to provide an example using our starter template that shows the issue? Thank you.~~ We'll get to this shortly.. @mjneil is right. We will get to https://github.com/videojs/m3u8-parser/issues/25 shortly.. In progress with PR: https://github.com/videojs/videojs-contrib-hls/pull/1214. Yup @thecotne . We'll try to cut a release soon to get this issue resolved.. Hey @roweldeguzman , thanks for the issue, however, it is hard to debug without a sample page and information about the issue. Would you be able to provide a sample page showing the issue using our starter template, as well as fill out the information in our issue template? Thank you.. Do you have a link to your live stream @roweldeguzman , and any steps to reproduce? Thanks.. Hey @rahulsingh9096806080 , you can see details on usage at https://github.com/videojs/videojs-contrib-hls#initialization . \nIf you are still having issues with the latest version of videojs-contrib-hls and using https://github.com/videojs/videojs-contrib-hls#overridenative please let us know.\nThank you.. Closing in favor of https://github.com/videojs/videojs-contrib-hls/pull/1220. Sorry @SleepWalker , we'll try to get this tested and merged shortly.. Sorry about that @SleepWalker . Thank you for the PR!. Hey @KingHorse2015 , this is a longer question that is better served by the HLS specification at https://tools.ietf.org/html/draft-pantos-http-live-streaming-23 , specifically, section 4.3.4.2 https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.4.2 , however, the short version is that HLS uses a manifest file called an m3u8 that points at different variants (renditions) of the content, which themselves are m3u8 manifests that point to the segments. The m3u8 files are provided as the source of the video tags.\nIt is useful to look at some example m3u8 files, e.g., http://d2zihajmogu5jn.cloudfront.net/bipbop-advanced/bipbop_16x9_variant.m3u8 to see their structure. There are also probably some shorter tutorials online describing how to create HLS content, however, the spec itself is quite descriptive.\nHope this helps!. Hey @39ro , thanks for reporting the issue. This is due to the fact that we use native playback when on Safari (both desktop and mobile). Because native playback is used, we don't have the same feature set on Safari as on other browsers.\nYou are right that overrideNative should help this case, however, we have a known issue that using overrideNative for Safari causes other problems: https://github.com/videojs/videojs-contrib-hls/issues/1005\nOnce https://github.com/videojs/videojs-contrib-hls/issues/1005 is solved beforeRequest should work in combination with overrideNative. Closing this ticket for now in favor of the other issue.. Hey @ebraan , if you are still looking for a flash fallback with support for demuxed audio and video, there is now https://github.com/brightcove/videojs-flashls-source-handler that can be used alongside videojs-contrib-hls. Hope this helps.. Hey @manuliner , I haven't used Vue.js myself, but is id=example-video proper syntax for an ID?. Hey @denisvlr , is this something you see with just HLS sources, or is it replicable with an MP4 source as well?. Hey @ruchigupta19 , what is barrage?. It's possible you are running into native playback on Android (where Android has support for HLS and we relinquish control of playback over to the native player). Check out https://github.com/videojs/videojs-contrib-hls#overridenative if you'd like to override this functionality, and let us know if this helps.. Thanks for letting us know @jeffmikels . If you do decide to use videojs-contrib-hls again, let us know if you run into anything else.. Closing for now. If https://github.com/videojs/videojs-contrib-hls#hlsxhr doesn't match your use cases, please let us know. Thank you.. Hey @IBD , if the stream has both audio and video, then the browser expects there to be both, and, except for cases of buffer underflow (small gaps), won't resume playback of just one stream until it has buffered enough of both. This is to prevent the browser from skipping content that is simply pending download. Closing for now, as this is expected behavior. Please let us know if anything else comes up. Thank you.. Closing as answered for now. If you're still having trouble, please let us know. Thank you.. In order to try to replicate and debug the issue, we generally have to have a stream to test with. If you cannot change the headers themselves, sometimes sending a subset of the stream as a zip (so we can test locally) can work. Closing for now. Please give the latest version of videojs-contrib-hls a shot, and if you are still having trouble, let us know (and see if you can provide an accessible sample). Thank you.. Hey @manuliner , right now we only support AAC, and don't provide an API for exposing the bytes themselves. If browsers provide a way to access the buffered data of a video element, it may be possible, however, we aren't looking to add the feature at this point in time. Hope this helps.. Thanks for providing the answer @nomayonnaise ! Closing for now, as we don't support mp3.. Thanks for the contribution @thijstriemstra . It's now merged as part of https://github.com/videojs/videojs-contrib-hls/pull/1322 . Thanks again!. Hey @luchoweb , ~if I'm understanding correctly, the player does not start playing until 3 segments have loaded. It could be due to short segment durations, but~ do you happen to have a sample stream, and would you be able to use our starter template to create a reduced test case? Thank you.\nEDIT: It seems that maybe the player never starts. Would you be able to use the starter template to create a reduced test case, and provide information on what browser and OS you are using? Thank you.. Closing for now. If you are still experiencing this issue with the latest version of videojs-contrib-hls, please re-open the issue and provide a reduced test case using this template. Thank you.. Closing for now. If you are still experiencing this issue with the latest version of videojs-contrib-hls, please re-open the issue and provide a reduced test case using this template. Thank you.. Closing for now. If you are still experiencing this issue with the latest version of videojs-contrib-hls, please re-open the issue and provide a reduced test case using this template. Thank you.. Thanks for the PR @LukasDrgon . Sorry this issue has gone a while without much attention. It looks like that stream may be down (or behind protection). Are you still experiencing this issue with the latest version of videojs-contrib-hls, and if so, would you be able to bring the stream back up (slash make it accessible)? Thank you.. Closing. If you are still having issues with the latest release of videojs-contrib-hls, please let us know (and provide a new stream/open the posted stream if possible). Thank you.. Sorry this issue has gone a while without much attention. It looks like that stream may be down (or behind protection). Are you still experiencing this issue with the latest version of videojs-contrib-hls, and if so, would you be able to bring the stream back up (slash make it accessible)? Thank you.. Closing. If you are still having issues with the latest release of videojs-contrib-hls, please let us know (and provide a new source if possible). Thank you.. Hey @ccrsky , Safari uses native playback for HLS, and doesn't provide us APIs for transforming requests. Native playback can be overridden by https://github.com/videojs/videojs-contrib-hls#overridenative , however, as a warning we have seen some other issues with non native Safari playback. In addition, iOS Safari doesn't provide MSE, so we are not able to use non native playback there. Sorry about the trouble, but hope this explanation helps.. Safari uses native playback for HLS, and we don't have access to the requests to modify them. This may be overridden by https://github.com/videojs/videojs-contrib-hls#overridenative , however, as a warning, we have seen some issues with overrideNative on Safari that we have other open issues for.. As @squarebracket mentioned, we do have https://github.com/videojs/videojs-contrib-hls#hlsbandwidth for determining the bandwidth from the last segment request. We don't currently have any plans for a UI built into contrib-hls, however, we always welcome others to create such a plugin.. Hey @ebraan , if you are still looking for a flash fallback with support for demuxed audio and video, there is now https://github.com/brightcove/videojs-flashls-source-handler that can be used alongside videojs-contrib-hls. Hope this helps.. If anyone is still encountering this issue, would someone be able to create a reduced test case using our starter template on JSBin? Thank you.. Closing. If anyone is still having issues with the latest release of videojs-contrib-hls, please let us know (and provide a reduced test case if possible). Thank you.. As @mjneil mentioned, the mime type specifies a specific format. Since HLS and MP4 are different formats, a single mime type will not cover both. Using a conditional based on the source type is the route to go (as you're doing). Hope this helps.. Hey @lixiaochun , if you're watching multiple live streams, your bandwidth may not be able to keep up with the streams themselves. This is usually on an individual basis (per computer's bandwidth and processing power when appending segments). Increasing the buffer may not help (unless you are pausing to allow it to buffer larger amounts of video).\nHowever, while it isn't recommended, you can change buffering amounts via the properties defined here: https://github.com/videojs/videojs-contrib-hls/blob/master/src/videojs-contrib-hls.js#L48 \nHope this helps.. As @mister-ben said, if you are on a browser with native HLS support, there won't be an object. If you are on a browser without native HLS support, you may have to wait for the player to be ready/a loadstart event (as @eklimas mentioned) before accessing the object, as until the source is setup by video.js, the hls object won't be configured.. Hey @robov , if you want to add session information for the requests, you can either use https://github.com/videojs/videojs-contrib-hls#withcredentials or you can modify the requests using https://github.com/videojs/videojs-contrib-hls#hlsxhr .. Hey @fyahb , sorry this has gone for a while without much attention. If you are still experiencing the issue, would you be able to provide a reduced test case using this template? Thanks.. Closing for now. If you are still experiencing this issue with the latest version of videojs-contrib-hls, please re-open the issue and provide a reduced test case using this template. Thank you.. For cases that are allowed by the browser, we have https://github.com/videojs/videojs-contrib-hls#hlsxhr . For cases disallowed by the native XMLHttpRequest, we don't currently have more control.. And thanks @Timsonrobl !. Hey @lgyytm , I noticed that the stream only has 2 segments in it. The HLS specification requires at least enough segments to cover 3 target durations worth of time: https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-6.2.2\nThe server MUST NOT remove a Media Segment from a Playlist file\n   without an EXT-X-ENDLIST tag if that would produce a Playlist whose\n   duration is less than three times the target duration.  Doing so can\n   trigger playback stalls.. Closing in favor of https://github.com/videojs/videojs-contrib-hls/issues/600. If you are still having issues, please try out webwackify (see https://github.com/videojs/videojs-contrib-hls/issues/600#issuecomment-363249094 ). Hey @robov , details for setup of EXT-X-KEY and the structure of the key file can be seen in the latest HLS specification at https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.2.4 and https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-5\nHope this helps.. Yeah @squarebracket , it's been a fun one. Still have one test to fix, but 12/13 have been resolved. Hopefully have enough hair left for that one, but it may be close.. Hey @niccout , if your manifest is short (shorter than 10 seconds in your example), then this is expected behavior. Otherwise, we should resume from where the video was paused. Are you still seeing this behavior, and would you be able to provide a reduced test case using this template? Thank you.. Closing for now. If you are still experiencing this issue with the latest version of videojs-contrib-hls, please re-open the issue and provide a reduced test case using this template. Thank you.\n. Thanks for the PR @tjenkinson !\nre: the broken test case. Will the protocol that URLToolkit returns be the same as the page?. Hey @chianhsieh , sorry this ticket has gone a while without much attention. I see that the stream is now down. Do you have any live examples we can take a look at? Thank you.. Appreciate the update and the details @chianhsieh ! Interesting problem and solution. It looks like that's a good solution. Closing this ticket then, and thank you.. Thanks for another contribution and all the detailed notes!\nI agree that the timeout solution, while simplest, is not the most pleasant. If the browsers aren't (or aren't consistently) managing the state when dealing with adding multiple source buffers in quick succession, it may be necessary for us to consider wrapping the media source itself (and/or making changes via videojs-contrib-media-sources) and making the functions async to ensure that we are waiting for each addSourceBuffer to appropriately finish (as you mentioned, listening for updating and updateend). That would at least be a little more deterministic than timeouts.\nThere are a few more details in https://www.w3.org/TR/media-source/#methods , but not complete there either.. Hey @huanghanzhilian , would you be able to provide an example of what you're looking for? Thank you.. Closing for now. If you are still experiencing this issue with the latest version of videojs-contrib-hls please let us know. Thank you.. Hey @Rushijain , would you be able to create a reduced test case using our starter template? Thank you.. Closing. If you are still having issues with the latest release of videojs-contrib-hls, please let us know (and provide a reduced test case if possible). Thank you.. Hey @keeleys , I think you might have an issue with your content. I was not able to play it in Safari (which uses native HLS playback) or Quicktime player, and while VLC loaded it (though rather slowly), it ended up freezing after a seek.. Closing for now. While some players are able to work around content issues, others may not. If you're able to get the content playing in Safari (where they have relatively robust native playback, and I currently get a corruption issue when trying the stream), please let us know. Thank you.. Hey @robov , are you using https://github.com/videojs/videojs-contrib-eme for EME management, AES encryption, or something else?. When a key is returned from the server the response can still be seen in the network tab, regardless of what is accessible through the console.. Closing for now as it's expected that browser requests will be present in the network tab, and since key requests are made through the browser, they will be visible.\nIf you want to try obfuscating the requests, so long as you implement your server and custom client code to handle the obfuscation, you can use the techniques in https://github.com/videojs/videojs-contrib-hls#hlsxhr to hook into or override the XMLHttpRequest module and can implement custom code there.. Hey @grobolom , sorry about the delay. No set timeline, we were just focused on some other issues. That said, this is all set to go except we do a quick round of manual testing before merging it in. We'll try to get around to it today if we can.. @gkatsev , should this be moved over as a possible enhancement issue in video.js' repo?. Thanks @gkatsev . Closing over here (in videojs-contrib-hls) then, as that sounds like a good solution.. Hey @chaner , thanks for the PR. Have you tried out using beforeRequest https://github.com/videojs/videojs-contrib-hls#hlsxhr ?. Thanks @Nickman87 ! Closing for now, as it looks like @Nickman87 answered the question. @alexchern , please let us know if you encounter any other issues.. Hey @robov , Safari will use native playback instead of playback via videojs-contrib-hls. Usually, if a stream fails in Safari, then it points towards an issue with the content. In some cases, our code will still be able to playback this content, however, the content itself could be out of spec.\nJust to test this, if you put the m3u8 URL directly in the Safari address bar, does the content still fail?. videojs-contrib-hls has support for encrypted HLS content. And in this case, since it is failing in Safari, and videojs-contrib-hls uses native (browser) playback for Safari, it looks more like a potential content issue or something separate.\nWould you be able to provide the sample m3u8 URL? Thanks.. Hey @robov , not sure on specific encoder settings that may help, just a note that Safari's native playback is usually a good bet for if the content is configured properly or not.\nHowever, if you want to try overriding native playback, you can use https://github.com/videojs/videojs-contrib-hls#overridenative . We haven't done much testing on Safari with overrideNative, and have seen some reported issues, but it is an available option.. Closing for now since we can't provide precise encoder settings, and since Safari has native playback, except for the override native case we can't change the playback The spec has some details on AES encryption and server responsibilities, but won't be able to talk about a specific preset either (see https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-6.2.3 for details). Please let us know if you encounter any more issues. Thank you.. Hey @Nagaraj-Prabhu , it looks like you are encountering a CORS issue. Please have a look at https://github.com/videojs/videojs-contrib-hls#hosting-considerations . Thanks.. Hey @varadarajana , you may have to wait for player.ready before listening for addtrack. But would you be able to create a reduced test case, using our starter template on JSBin? Thanks.. Closing. If you are still having issues with the latest release of videojs-contrib-hls (after waiting for player.ready), please let us know (and provide a reduced test case if possible). Thank you.. Thanks for sharing @CalibanAngel . Going to close this ticket though as it isn't a current issue.. This is intended behavior for live videos, as it allows us to keep in sync with the stream, and is not usually an issue as m3u8 manifests should be relatively small. However, as @forbesjo mentioned, we are looking to add a feature that allows people to pause such an update. Going to change this issue to an enhancement pending such an addition.. Hey @gregfr , if you want to try writing a custom ABR function for selecting playlists, you can do so using https://github.com/videojs/videojs-contrib-hls#hlsselectplaylist . Please let us know if that helps.. Closing for now. If this doesn't help your use case, please let us know. Thank you.. Hey @slvrtrn , we don't have that kind of information offhand, and it can depend on a lot of factors. For instance, leaving aside other processes on individual computers, differences between browsers and what they're using to decode and playback content, and differences between other hardware and support for hardware based decoding, the content can also be encoded with various profiles, some of which emphasize easier decoding but higher bitrates, others with more aggressive encoding leading to lower bitrates but more processing required. In addition, the content itself can lend itself to more or less intensive processing.\nThat said, we do have the throughput property ( https://github.com/videojs/videojs-contrib-hls/blob/d263eeaeb844e1d0feffb3d7308ed081e9f9d508/src/videojs-contrib-hls.js#L324 ) which tracks the bitrate of the entire process post download: decrypting, transmuxing, and appending.  These are both used as part of our systemBandwidth ( https://github.com/videojs/videojs-contrib-hls/blob/d263eeaeb844e1d0feffb3d7308ed081e9f9d508/src/videojs-contrib-hls.js#L359 ) calculation for ABR, thus letting us downswitch in cases where either the client doesn't have enough bandwidth, or the processing is taking too long to smoothly play higher quality content.\nWhile we can't provide hard numbers, you may be able to determine the numbers for your content with those properties, and if you add some lower quality renditions, videojs-contrib-hls will automatically play the most appropriate content for a given system and network.\nHope this helps.. Closing. If you are still having issues with the latest release of videojs-contrib-hls, please let us know. Thank you.. Hey @daliwell , thanks for the samples and the notes. We should definitely check into what's going on, but one thing to note is that right now we don't have full support for non native Safari playback (we haven't tested it much), but it is something we're hoping to look into soon. As for Edge, that reported issue seems to be a likely case, but we can re-examine it with these new details.. @sdahdaah thanks for reporting. We'll take a look into it.. Hey @Rushijain , would you be able to provide a reduced test case, using our starter template on JSBin and provide your source so we can see what's happening? And what browser/OS are you using? Thanks.. Closing for now. If you're still having trouble with the latest version of videojs-contrib-hls, please let us know (and provide a reduced test case with your source and platform details). Thank you.. Looks like a combined segment type is being passed back (which we can't process). We'll take a look, and thanks for reporting and for the sample!. Hey @earl3s , sorry for the delay. We looked at a few of the segments in the stream and noticed that some of them didn't start with \"ID3.\" From the HLS spec:\nhttps://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-3.4\n\nEach Packed Audio Segment MUST signal the timestamp of its first sample with an ID3 PRIV tag [ID3] at the beginning of the segment. The ID3 PRIV owner identifier MUST be \"com.apple.streaming.transportStreamTimestamp\".\n\nLet us know if this helps!. Duplicate of https://github.com/videojs/videojs-contrib-hls/issues/1393. Duplicate of https://github.com/videojs/videojs-contrib-hls/issues/1393. Closing as per other issue. Thanks for posting!. Hey @longlivelance , this is happening because you have both audio+video (muxed) and audio only manifests listed in the master playlist, but no CODECS attribute in the manifest describing them as such (see: https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.4.2 ). Since we have to decide on the types of source buffers we need (whether audio and video or only audio) at start of playback (browser limitation), we can't switch between audio only and video+audio in either direction. If the CODECS attribute is added to the manifest, then the player will only switch to compatible renditions, meaning if it started on audio only it will stay on audio only, and if it started on video+audio it will stay on video+audio.\nIf you don't want to have only audio as an option, you can remove them from the master playlist.\nHope this helps.. No problem, and thanks for the update. Let us know if anything else comes up.. While going around the spec can sometimes help problematic streams, in this case, because the spec is pretty clear on MUST, the stream could cause unexpected issues on environments where we use native playback.\nAlso, we may actually have some bugs if we try to work around a mislabeled CODECS attribute. For instance, it would set up an audio buffer for streams which should be video only, and thus not allow for video only playback.\nUltimately, we probably shouldn't trust the manifest at all, and delay creation of source buffers until we parse the content, which is something being worked on with \"transmux before append.\" But for the meantime, we can't assume the audio codec based on manifest-only information if it goes against spec.. Hey @beautylix , this is a limitation of the browsers requesting mixed content. See https://developers.google.com/web/fundamentals/security/prevent-mixed-content/fixing-mixed-content and https://developer.mozilla.org/en-US/docs/Web/Security/Mixed_content/How_to_fix_website_with_mixed_content for details.. Hey @canbing3345 , videojs-contrib-hls is meant to support playback of HLS content, which requires an m3u8 manifest. Though we do support TS playback within the project (as HLS manifests may use TS segments), we don't have a way of providing that feature directly. However, you can feel free to use some of the logic and other projects used by videojs-contrib-hls to write a video.js plugin yourself to play back TS files directly. To do that, you'd probably want to use https://github.com/videojs/mux.js to transmux those TS files to MP4 files before appending to the browser via a source buffer https://developer.mozilla.org/en-US/docs/Web/API/SourceBuffer.\nIt may help to look through some of the logic of videojs-contrib-hls to do that. Specifically, https://github.com/videojs/videojs-contrib-media-sources/blob/master/src/virtual-source-buffer.js#L506 in videojs-contrib-media-sources is the start of where we abstract away the native source buffer's appendBuffer function, and send the TS bytes to a WebWorker wrapped around mux.js, get back bytes for a fragmented mp4, then append those to the native source buffer.\nUsing those methods it should definitely be possible to pass TS data over a websocket, transmux it, then append it to the browser's native source buffer.\nHope this helps!. Hey @swaraasolutions , would you be able to include a reduced test case, using our starter template on JSBin and include the source you are using? Thank you.. Hey @varadarajana , for live videos (those without an EXT-X-ENDLIST tag), the player starts at the \"safe live point,\" ~3 target durations from the end of the playlist. Thus, this should be expected behavior. If you want to play back starting from the beginning of the playlist, you can seek to the beginning, or you can change the live window for which segments the server shows at any given point. Hope this helps.. Hey @murtaz53 , you can use the video.js audio tracks API: https://docs.videojs.com/tutorial-audio-tracks.html . Hope this helps.. @murtaz53 , it should be accessible through the same API. If you're still having trouble, would you be able to post an example using our starter template on JSBin? Thanks.. Thanks for the contribution!. Hey @mzxjhx , I noticed when trying to play the m3u8 playlist via Safari alone (by pasting it into the address bar), Safari doesn't recognize the content. I think there may be an issue with the content itself.. Is this preferred over leaving a comment above selectPlaylist that an error should not be thrown?\n. Ah, gotcha. Thanks.\n. I agree. I'll take a look at removing it.\n. Over destructuring?\n. We might be able to do a playlist object, but we'd have to have to have the reference to the playlist loader to deal with refreshes. Were you thinking that MasterPlaylistController can do the listening to the active playlist loader and appropriately update the playlist, and by the time we get to loadAlternateAudioPlaylist the MPC would already have started listening and doing the refreshes of the playlist?\n. Good call. Will change.\n. For now I figured we would be deferring duration/seekable/other timing related information to the video/combined track only. Should we do both to start (i.e., take the longest of both)?\n. Good call.\n. The main reason we are passing hlsHandler right now is to allow users to override what they previously could override. For instance, the selectPlaylist function. At the moment people can set that to be whatever function they want, and expect it to be called with the HLS Handler. We could pass the bound function down instead, which prevents MasterPlaylistController from having the entire hlsHandler reference, but it might not buy us too much in terms of separation, and if the user updates it again, we'd have to call back in to MPC and modify it (which is fine, we'd just have to agree on that interaction). Were you thinking of a different relationship?\n. Will try for that.\n. I see what you're saying now. It lets us encapsulate the selection logic (rather, the listening to selected audio tracks) within HLS, instead of MPC having to keep track of that as an external reference to the player's audio track list change events.\nThat makes a lot of sense, and I'll modify it to allow for that interaction.\n. That's a fair point. Though do you know if it's valid for an alternate audio track to have a longer or shorter duration than the video/combined track? I could definitely see the video stalling if it is pending information from one source, but if that is allowed it could also create other sorts of problems (from usage point of view, a shorter audio track could potentially cut off portions of video, and a longer audio track would be cut off as well).\n. Turns out that in this case, using import will create a cyclical dependency (a sign of another problem, but that should go away over time).\n. Is it actually empty?\n. I think that is just the diff. What I did here was just move the initial loading into the function loader.start and changed the indentation level.\n. The problem with using dispose here is that we reuse the alternate audio playlist loader the if it is selected in the future (we don't create them when they are selected).\nIt would also still need to be set to null for some other checks to work (it isn't the optimal approach, but right now we use if (this.audioPlaylistLoader_) to determine if we are using an alternate audio playlist.\n. This might just be a style preference (so feel free to ignore), but I think it would look cleaner (and save variables) as:\njavascript\naudioTracks.addTrack(new AudioTrack({\n  kind: hlstrack.default ? 'main' : 'alternative',\n  enabled: hlstrack.default || false,\n  language: hlstrack.language || '',\n  label,\n});\n. Is anyone listening to mediachange?\n. Isn't audioPlaylistLoader_ a separate reference? Setting it to null shouldn't modify the entry in audioPlaylistLoaders_. It should just stop pointing to the entry.\nThe benefit to keeping them around and not re-creating them is that we save on time to start if the playlist is already loaded. Not a 100% requirement, but it is helpful.\n. Nice catch. Will do.\n. With our ES6 styling, each let gets its own line.\n. Same as other.\n. Might not be strictly necessary, but it seemed to read a little better. That said, maybe that isn't true. I'll try it out without the variable and see how it looks.\n. Yeah, a variable for this.tech_.audioTracks() looks like a good idea.\n. Same as above.\n. For ES6, it actually is block scoped here.\n. No worries. I was doing it until the linter caught me.\n. I think in this case it may be better for us to not do some guards. They are definitely safe to have, but it might hide a bug later on (for instance, if someone does try setting useAudio before they are supposed to, we'd simply return here, instead of an error being thrown which could clue someone into the problem--that they are calling useAudio too early, before they are supposed to--immediately).\n. That said, we definitely need some guards (for instance, the !media.attributes for the case of the src URL being a playlist, and not a master)\n. This is more for me, but do you know if we're doing all of our let declarations at the top of the function, except for variables declared within inner blocks, or are we doing the declaration when we define it within the function?\n. This is probably too picky (and introduces shadowing), but we have a variable called audioTrackList that is the same thing above as audioTracks is here (same as in different names representing the same thing, though their values will be different).\n. Is this an error condition?\n. I think the warn log is enough (without the comment).\n. Interesting, it seems Safari keeps playing the audio.\n. I'll comment it back out again for now then. I think I added it back to fix some tests, but I'll skip them for the time being.\n. Yeah, for now. Once logic similar to the timelineUpdated check is added back in, we can return it: https://github.com/videojs/videojs-contrib-hls/pull/619/files#diff-d5c992e639e8f39a5f94c4a3a6582a00R677\n. I couldn't think of a better name. I was thinking that \"r\" was too ambiguous, but I suppose it is better than \"oldRequest.\" Any suggestions though?\n. In this case no one should be creating a source updater without passing in a media source (I am pretty sure).\n. I agree that the warnings are a pain in the tests, but are they something we should address? Or can we never get around them, as we need to use the internals of videojs?\n. Minor type (on => one)\n. I even made a typo in the last comment...\n. We can probably use:\njavascript\nreturn mpc.master().playlists.find(playlist => playlist.attributes.AUDIO !== oldMediaGroup);\n. If this is used in videojs-contrib-hls, should we remove the \"private\" underscore?\n. EDIT: I did not read far enough. Looks good.\nI guess it would signal a bigger problem if the main track caused the change and had the issue. If it is possible to have that condition though, it looks like this might throw an error (down when we call mainTrack.enabled).\n. Nevermind, I noticed the guard below. Looks safe!\n. I think this will break if error is undefined.\n. If this is being used outside of master-playlist-controller (i.e., in videojs-contrib-hls), should we remove the underscore that identifies it as private?\n. Should we be using 5 as a set amount, or do we want to do a segment duration if we have that information available?\n. And do we want to add a method to SegmentLoader for removing certain time ranges?\nEDIT: changed mainSegmentLoader to SegmentLoader\n. Should we add a check for the start as well as the end?\n. Both seem reasonable\n. Is this extra line on purpose?\n. I know it's not really in scope, but it would be so much prettier with with find() and a polyfill for IE.\nOtherwise, again out of scope, but it may read easier if we create a variable for this.tech_.audioTracks()\n. It's minor, but passing the whole this.options_ object when creating MasterPlaylistController feels a bit strange to me. Maybe it all is needed right now for MasterPlaylistController, and in the future, if we're ever leaking more information than we should, we can just specify what we need to send then. But it just feels a bit odd.\n. I think we're only triggering progress on the tech. That said, MPC should probably trigger it on itself too (or only trigger it on itself, and let this guy trigger it on the tech).\n. Is this used anywhere?\n. Space (and the beforEach/afterEach below this one)\n. I know that later on we use options.GOAL_BUFFER_LENGTH || 30. In the case of 0, we will accept the value, but ignore it later. I know that no one should be using 0, and it might be somewhat silly to guard against, but we can ensure v > 0 and warn below that it must be a number greater than 0.\n. || v <= 0\n. Since we just want to test that they are not an empty string, would it be simpler to remove the array and the some call and just do a return with ors between each?\nreturn video.canPlayType... || video.canPlayType... || ...\nOr are we protecting against other potential values of canPlayType?\n. I think I remember that the reason we had the readyState check was because firefox expected a segment to be loaded before a certain action took place. Was it loadedmetadata firing (which I know we handle ourselves now), or was it the ability to do a seek?\n. Is it OK that we are now triggering progress even if we have switched playlists, whereas we weren't before?\nFor instance, if we go to appendBuffer, playlist is switched, and we just go ahead and append the buffer after appendBuffer finishes, we have progress for the old rendition, but not the current one. Should that count?\n. Should we set more information about the error?\nFor instance, we can use the this.error function\n. Was this sentence cut off a bit?\n. downloaded\n. Was this meant to be removed?\n. Very minor, but: Can (or Can above to can)\n. You're right. I tried to separate steps a little bit for clarity (and possibly for a bit of efficiency), but it may not even be much more efficient, and it ends up being clearer without this step. Removing.\n. I thought it might've been more readable, but I think it is just as readable moving it all back up.\n. There's also a defined property with a setter: https://github.com/videojs/videojs-contrib-hls/pull/795/files/ab06b98349f7525e80386d624a49d0ce6597941f#diff-b97e9f0783b7b7b3b21cfaa1457b03eaL393\n. ID3 uses a duration of \"0\" (start time and end time are equal).\nThe goal is that we want to trigger these cue points once we cross between segments (for us, we are considering it the beginning of the segment the tag precedes). We only need it to trigger the cue change and remain active long enough for a listener of the event to grab the cue.\n@gkatsev is the recommendation for 0.5 seconds the minimum for it remaining active long enough for a user to retrieve and make use of?\n. Better to return null here\n. When checking for undefined, I think our linter expects typeof cue !== 'undefined'\n. Better to set to null instead of undefined. Or if you want undefined, I think our linting expects void 0\n. Also, for this check, whether undefined or null, checking for falsey should be fine. if (!cue)\n. Are we OK making the assumption here that all cueOutCont tags will be of the format #EXT-X-CUE-OUT-CONT:5/10 ? If we are, we should add a comment that we expect that form, and add that to the README\n. If this always relies on mediaTime, do we need a check?\n. Same comment as below regarding assumption around the format of the CUE-OUT\n. Should we be creating another cue on cueOutCont? Wouldn't the cue be an extension of the above created cueOut cue?\n. The code may be easier to read if, instead of doing the find here and decrementing i to redo the loop, move a conditional check up to do\nif (!cue) {\n  cue = findAdCue(...);\n}\naround the beginning of the loop, then continue with the rest of the code.\n. It may just be me, but the wording here threw me off a bit. Are you saying that we've already adjusted the current cue's end time to account for this segment's duration on a prior call to updateCues_?\n. I see that we're never removing cues now. Are we OK with the assumption that different playlists will always have cues at the same segments and times (included in this is that segments have the same duration across playlists)?\n. I don't believe you have to remove the cue at the end of the test\n. It's a bit odd to pass the caller to this function so that it can set a value on the caller. If we want to separate responsibility, we can either create an AdCueTagManager (or something similar) that maintains its own state (keeping hold of the cueTagsTrack) with MasterPlaylistController having only an instance of the manager, or create the cue tags track in MasterPlaylistController (move the innards of this function to MasterPlaylistController) and continue to pass in that reference as you do later on. I think the latter might make the most sense, as these functions are merely utility functions, and MasterPlaylistController is the one who should know a bit more about its state, and what gets added to Video.js type APIs (i.e., the new text track).\n. Extra space here (and at the end of the block)\n. Minor note, but phrasing for end times seems a bit off\nAlso, while they should be the same, can't hurt to check adStartTimes and adEndTimes as well\n. Also worth it to have one more checking that it matches start time.\n. Not a big deal, but we can just do:\nvideojs.options.hls.overrideNative = overrideNative === 'on' ? true : false;\n. Did we need this to be registered first to avoid native?\n. Good call. Will try for that. Will make unit testing easier as well.\n. It could be a relic of some old changes, but I remembered seeing waiting fired twice. I will switch it out and see if I can uncover why that was happening instead.\n. Makes sense, and I'm cool with it. Will come up with some alternatives.\n. I think the original reason I used side-effects was because video underflow would have to pass back a value in addition to whether or not the condition happened (to prevent having to re-calculate the value). That said, you're still right, and if it doesn't get too messy I can just pass back an object containing all necessary information.\n. Or just use the value itself.\n. Nice call. Definitely cleans things up.\n. I have to go back and try to re-create it. I was seeing it happen before, but maybe it was something else. If I can't reproduce, I'll remove the check.\n. Should this say \"detected not on lowest renditions?\"\n. Would it make sense to simply set seekable_ to videojs.createTimeRanges() at the start?\n. Should this allow a fall through to the next conditional (which can check for length of 0) so that seekable is set only based on mainSeekable?\n. Just my opinion, but this comment seems to just repeat a lot of the logic, and is more at risk of becoming outdated/losing precision. Better to have individual comments within each of the logical blocks, closer to their relevant code, specifying high level concepts of what is going on.\n. And it seems like the comment is mixed (order-wise) from the conditionals below.\n. I think you're right (on this and the comment above), we do want the intersection if an audio playlist is available.\n. I believe it is just the comments, as I think it makes sense to prioritize firstSyncPoint.\n. Should we use async and done instead of stop and start?\n. An object with names will make it easier to read the result.\n. given. Any reason to not just use \"player?\". Worth adding checks to verify excludeUntil values are still 0. Is this guaranteed to be the same index as the index in QualityLevelList?. Not a big deal, but I generally like to keep the index vars within the scope of the loop when possible, as outside of it the context is often lost, even when the code is close together. Maybe we can use selectedIndex as the var?. Any specific reason for going down rather than up?. Do we want to trigger if -1?. Exported for unit tests. Do we want to say this, or should we deprecate it/mention it is deprecated?. Do we need the loader and playlist URI instead of just using the playlist?. This may get overly complicated, but would it be better for us to use something else to identify incompatible variants versus temporary suspensions? It may make more contextual sense, but if it ends up being too many options, the check for not Infinity could be an OK solution for now.. selectedIndex. Makes sense \ud83d\udc4d . Will this trigger a change event even if a playlist refreshes but doesn't change?. We should add another with excludeUntil between 0 and Infinity.. blacklisted. \ud83d\udc4d . Minor, but might be useful to have one with expired excludeUntil. That is true, and maybe in this case it would be overdoing it to add another one, but usually it is good to have a non 0 test, as 0 is falsy and often is an edge case.. Why do we need this in addition to monitorBufferTick_? It seems that by changing calls from fillBuffer_ to monitorBuffer_, we already get the guard that checks whether the state is READY.\nfillBuffer_, if it starts a segment request, will synchronously get to the WAITING state. This means that any subsequent calls to monitorBuffer would be safe with the READY guard.. As a followup, spoke with @imbcmdth , and he pointed out that monitorBuffer_ contextually is async, and is safer  as async when there are events that are being listened to that may happen around a segment's end of processing (as an example, if monitorBuffer_ was synchronous, by the time listeners received the events, a new segment may have already been requested and a lot of state changed).. Why did this decrease?. In the case where this results in a mediaIndex < -1 (we fell two slots behind the end of the playlist), do we want to handle the case in any way (since we knowingly fell off the back), or let playback watcher catch that we fell off the back in its own time (or another resolution, e.g., we keep the index at -1 and hope it'll create a 1 segment gap that will be skipped over by the gap skipper)?. \"each time we get a new playlist\" may be a bit confusing in this context. Is the action specifier necessary since we're only decrypting?. Style preference, but maybe indent the cases.. If we're resetting in afterEach, do we need to do it here?. I know it shouldn't matter, but since this test is specific to IE 10 testing, may want to keep this is proper casing. Why do we create one decrypter here to share among loaders instead of creating a decrypter in each loader?. maybe \"...into a new object with separated properties...\". Only used once. Probably simpler to just do Object.keys(message).forEach(.... Really minor, and up for debate (not sure which is actually better), but maybe it would make sense to call this function expandTypedArrays.. Just preference, but it might be good to keep this as else if (event.data.source === 'audio'). Yeah, it's probably fine to do that. The behavior at least will be the same as current.\nBut it may be an interesting idea for the future. Since we're in a place where we knowingly will fall back to playback-watcher, and the user will experience a pause in playback, maybe we should at least add a comment or TODO to consider taking action.. I don't think we have to be guarding against these.. So cue ends up with a stringified value for its text, then has a value property which has the value object, including the stringified value?. Would also be worth testing the behavior with overlapping times from a different timeline.. Minor, but can do buffered = [[0, 9], [10, 20]];. Might be worth verifying liveresync stays the same at the end.. Good call on checking for segmentMetadataTrack_. \ud83d\udc4d . I think keeping Safari support is a good idea (just in case). Maybe a comment and/or some kind of helper method would help.. track's. Usually for JS blocks it's good to try to keep it as standard JS. Maybe something like:\n```javascript\ncue.value = {\n  uri, // segment uri\n  ...\n};\n// or:\nlet data = cue.value;\ndata.uri; // the segment uri\n...\n. Might be useful to say what the timeline is. Can get rid of this and just use `segmentInfo.playlist.uri` below. Really long line. And it might be a good idea to just write out checkBuffer_. While changing, would be good to write out getMediaIndexForTime. Instead of writing this function and the check for the debug setting in each module we want to log, we should just have the actual logger passed in, and check for the debug option at the highest level.. This line I think is for a different PR. The waiting event can fire and cause `waiting_` to run independent of `checkCurrentTime_`. Might read better as just \"If we just appended\". Is it possible for segment to be null here?. In a case where currentTime is equal to segment.start and we have a distance of 0, it seems that the next iteration will skip over this and skip over the next conditional to set the sync point to the next segment.. Same comment as above re: case of distance 0.. Would be good to have a test with exact start as currentTime as well. Yeah, it's a tough one to decide between.. Not two segments with the same start time, but if `currentTime` is equal to `segment.start` then `distance` is 0 and the `syncPoint` would be set to the following segment (if one exists) because when `lastDistance` is 0 for the next iteration, this condition is false and the next condition (where it checks for `!lastDistance`) would result in true (leading to an overwrite of syncPoint).. Minor, but can just have one conditional:js\nif (properties.characteristics &&\n    properties.characteristics.indexOf('public.accessibility.describes-video') >= 0)\n``. Is it possible for there to be two tracks with 'public.accessibility.describes-video' (something like analt-desc)?. Thanks @kitce ! Submitted a PR https://github.com/videojs/videojs-contrib-hls/pull/1046 to fix it..audioSegmentLoader_always exists, even if not being used. audioPlaylistLoader_only exists if we are using alt audio. extra comment. Can remove a lot of lines up top if we create the variables where they are first used.. If there is no seekable range, can we be technically stuck at playlist end?. Since this is only used in one place, it may be clearer to just use it in the calculation directly:endTime = Hls.Playlist.playlistEnd(playlist) - lastBufferedEnd;. We should also change the comment to say it is using the absolute end of the playlist, and not the safe live end.. WhileNaNcan sometimes be OK, it is usually good to try to avoid using it. In this case, where we need the amount of time buffered, this should be 0 instead ofNaN`.. I'm not sure if it's clearer or not, but I think we can set up the conditionals to handle separate cases for buffer existing and buffer not existing. Maybe something like:\n```js\nlet seekable = this.seekable();\nif (!seekable.length) {\n  // playlist doesn't have enough information to determine whether we are stuck\n  return false;\n}\n// does not use the safe live end, since we don't want to say we are stuck while there is still content\nlet absolutePlaylistEnd = Hls.Playlist.playlistEnd(playlist);\nlet currentTime = this.tech_.currentTime();\nlet buffered = this.tech_.buffered();\nif (!buffered.length) {\n  // playhead reached absolute end of playlist\n  return  absolutePlaylistEnd - currentTime <= Ranges.TIME_FUDGE_FACTOR;\n}\nlet bufferedEnd = buffered.end(buffered.length - 1);\nreturn\n  // too little buffer left\n  bufferedEnd - currentTime <= Ranges.TIME_FUDGE_FACTOR &&\n  // buffer has reached absolute end of playlist\n  absolutePlaylistEnd - bufferedEnd <= Ranges.TIME_FUDGE_FACTOR;\n``. It might be worth adding a comment here describing our decision to blacklist on the first outdated event when we're stuck at the end. For instance, there are cases where the playhead could be near the end of the playlist (we've seen cases where we end up playing too close to the edge of the playlist instead of the safe live point 3 segments back), we make a request before the server has updated, and the request simply takes a bit longer to return, allowing us to get stuck at the end of the playlist in the interim. In this case we blacklist the playlist even though it updated on the server in the meantime, but we're safe once https://github.com/videojs/videojs-contrib-hls/pull/1026 is in, because we won't blacklist the final rendition, and if it is not the final rendition, then it gives the player a chance to re-adjust to the proper live point on a different playlist. Though that is probably too many words for one comment.... Long line. If this function just calls the other function, do we need both?. Would be good to keep some documentation about the method, particularly the definition ofuseSafeLiveEnd(i.e., \"live playlists should not expose three segment durations worth...\"). Can just return directly instead of creating a variable for it.. We might be able to usestandardXHRResponseto save some lines. We can also usethis.requests.shiftto make it so that the latest outstanding request is always at the beginning of the array (no need to keep track of them via indexing).. playlist wasn't blacklisted. Since this is only used in one place right now, we can either remove it and pass in true after, or if you want to keep it for clarity, it may be worth addinglet isFinalRendition = this.masterPlaylistLoader_.isFinalRendition_()above the conditional, then use it asif (!isFinalRendition). Since this is cleared in both cases (in the condition and outside of it), it can be moved above the condition.. Since this is only used in the conditional it can be moved to whenrefreshDelayis actually set.. Was this meant to be removed?. Why is this only done for live playlists?. Really minor, and is mostly style preference, but if you change to use a check for it being the final rendition, and handling that case and returning, only one line needs to be indented, and the standard case (of blacklisting) can follow.. Don't need the variable if only used in one place.. Is something else changing the state necessitating a reversion to the starting state?. Why is it that it no longer is set to SWITCHING_MEDIA? Is SWITCHING_MEDIA still needed/used as a state?. media wasn't blacklisted because it's the final rendition. Isn't this saying that no warning was logged?. Why is this now responding with a master playlist? The URL above (provided assrc) seems to indicate that it is a media playlist.. (As per above): Why is this now responding with a master playlist? The URL above (provided assrc`) seems to indicate that it is a media playlist.. of the playlist. Thinking again about the comment, I think it might make sense to put it in here as something like:\njs\n// Playlist has stopped updating and we're stuck at its end. Try to blacklist it and switch to another\n// playlist in the hope that that one is updating (and give the player a chance to re-adjust to the\n// safe live point).. My fault, but maybe add a clarification (like you did below in the return comment \ud83d\udc4d ) to something like: // return true if the playhead reached the absolute end of the playlist. I think this description can just be left as Calculates the playlist end time since the parameter describes its use. If it is a boolean maybe change the param from Object|null to Boolean|false\nAnd the description could probably be something like Whether or not the playlist end calculation should consider the safe live end (truncate the playlist end by three segments). This is normally used for calculating the end of the playlist's seekable range.. Can remove the \"seekable range\" part. playlistEnd. Can move this down to where it is first set.. Maybe just \"Playlist Seekable and End\". account. use. Probably something like \"detects if we are stuck at the playlist end\" or \"detects if the player is stuck at the playlist end\". Since these are testing MasterPlaylistController's stuckAtPlaylistEnd_ function, they'd probably be better in test/master-playlist-controller.test.js. Can be moved down to where it is used. maybe  // not stuck at playlist end when no seekable but current time is at the end of the buffered range. For all of these really short functions, when we don't need a specific context, it is sometimes nice to use the ES6 syntax: hls.masterPlaylistController_.seekable = () => videojs.createTimeRange(0, 130);. current time reached the buffer end. I think there might be one more interesting case, where seekable is a normal range, the buffer reaches the absolute end of the playlist, and current time is in the buffered range (but not yet at the absolute end, say 1 second before it). This case should return that we aren't yet stuck.. I'd just move this inside of the conditional (since the phrasing considers that we already checked playlistOutdated).. indicating. Maybe indent to align?. ~~to~~. I think this test can be moved to test/master-playlist-controller.test.js. Are these beforeEach and afterEach methods needed anymore?. Would be worthwhile to trigger an event just after with something like: \njs\n// useful for monitoring QoS\nthis.tech_.trigger('playliststuck');. We can also pass some error info into blacklistCurrentPlaylist regarding the error itself, so we can log appropriately.\ne.g.,\njs\nthis.blacklistCurrentPlaylist({\n  message: 'Playlist no longer updating.'\n});\nThen in blacklistCurrentPlaylist add a check for an error message and include it in the middle of logs (where it makes sense).. Playlist. I think this may be cleaner as:\njs\nvideojs.log.warn('Problem encountered with the current HLS playlist.' +\n                 (error.message ? ' ' + error.message : '') +\n                 ' Switching to another playlist.');. We should also trigger an event with:\njs\n// useful for monitoring QoS\nthis.tech_.trigger('playliststuck');. playlist => player. Though I think it could make sense to provide a bit more context around why we're calling load if it isn't paused (what exactly is kicking it back into gear). Maybe something like If the player isn't paused, ensure that the segment loader is running, as it is possible that it was temporarily stopped while waiting for a playlist (e.g., in case the playlist errored and we re-requested it)... Probably better to keep this closer to where it is used.. Extra line. I think if you move it closer you can also remove the check for loader.master in loader.isFinalRendition_. We probably still want some kind of warning log.. it's. this.player.tech_.hls.playlists.media(). Should this be half the target duration / 5 seconds? Might be worth checking with two clock ticks that add up to verify that it uses the target duration / 5 seconds, and doesn't happen before.. Indentation. ~~more~~. ~~more~~. I think we need one more test for the behavior of a playlist error (404 or 500) on the first request for that playlist (that it should fail fast when there is only that one media playlist and no master). It looks like this was changed such that it gets a response first and is never blacklisted, which is a good test to have, but we should have the other case too.. Long line, and maybe error on the first playlist request triggers a media source error when there is only a media playlist. For good measure, maybe have an assert before the request that ensures it does not exist (maybe something like assert.notOk(this.player.tech_.hls.mediaSource.error_, 'no media source error');. I think this should be error on the first playlist request doesn't error. This was entirely my fault, but reading it again, I think it should be error on the first playlist request does not trigger an error. Good point. I think that leaving in tests that make use of seekable values is good, even if stuckAtPlaylistEnd_ doesn't use them, since the tests shouldn't know too much about the internal workings of the function. But you're right that the scenario of playlistEnd equaling seekable's end shouldn't be a common case. However, in the event that a playlist changes from LIVE to VOD (at the end of a stream), and the only update was the addition of #EXT-X-ENDLIST, seekable's end should equal playlistEnd, and I think it's possible that this case is a valid one.. I know it's not part of the changes, but worth touching up this comment.. Should this check for current request headers?. With XMLHttpRequest aborts, it looks like the readystatechange event is not fired (source: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/abort ).. On dispose is fine, but what about on source changes? Since the hls object is per player, shouldn't it continue to exist and not be disposed?. none. Might be worth adding a comment why this is default. playlist. Since this is being modified, it's not really returning an error. Might be worth leaving it at // Not enough information. Should we log a warning or info here? Although I agree that we have to default to some kind of codec, the codec should be specified in the manifest in a case like this, and not including it is potentially dangerous.. If someone provides the CODECS attribute, but only sets the audio codec, then bothVideoAudio could end up with something like: 'video/mp2t; codecs=mp4a.40.2'. Would that be valid for when we need to play both video and audio?\nEDIT: Noticed there is a test for this case, so I'm assuming it's valid, but just wanted to make sure.. Would be good to use different codecs from the defaults when testing provided codecs. This still seems so odd to me.. Can just do syncPoint.time *= -1. strategies. ano. Maybe use Infinity?. Long line. Maybe also use Infinity here?. point. Assertion would probably be clearer using your below format. Something like estimated expired time using sync info. Probably better to use estimated expired time... instead of start for these and others. seen. .. contiguous. With really short segments it's possible this can break. We may want to use a function that checks to see if we're within a buffered region (and if we want to be careful around edges, we can use a margin of some partial second, as 1 may be too long).. We should log here.. Do we want to guard against cases where we're at the end of the buffered region and just waiting for data?. Although shorter segments aren't all too common, the original one could break because it wasn't checking to see if the current time was within a buffered range. This one does check that the current time is within a buffered range. The TIME_FUDGE_FACTOR may be enough of a safety margin from the edge of a buffered region, but it could be worth being a bit safer with how far it is from the edge of its containing region.. Would be good to add a short note about how we can't predict when these events will occur for the browser.. What do you think of putting this in waiting_ after the techWaiting_ checks? It might make sense for either, but I'm inclined to keep it closer to the other logic that cancels out of \"waiting\" type events and keep this method simple.. I think that !buffered.length will prevent us from checking for fellOutOfLiveWindow_ and running fixesBadSeeks_ on environments where the waiting event might not fire and we rely on our implementation.. ~~in~~. is fired. Good point, will just trigger from MPC on the tech.. vnd.apple.mpegurl denotes an m3u8 playlist. This should probably be moved up. Long line. I also just realized that there is no period between media1.m3u8 Switching (from before, but might be nice to fix.. Technically, I think this comment might need to change. Why did this new response need to be added?. It might be clearer to delete playlist.excludeUntil for each.. Long line.. Although this may be true, since it's only testing that it got a blacklist event, maybe it is worth having two different checks, one for getting the blacklist event, the other checking for the excludeUntil. was. Would be good to check excludeUntil was deleted. Not a big deal, but any reason you chose bind instead of call?. Minor, but might be worth adding average = decay * systemBandwidth + (1 - decay) * average above. We should just note for VOD.. We can just add \"For VOD\" here, and below we can say \"For live, we want to avoid using a low water line, as we only have 3 segment durations worth of content to buffer.\". Rather than describing what the code is doing, it might make more sense to have a comment about the reason we are doing it. Something like Since we're on the final non-blacklisted playlist, and we're about to blacklist it, instead of erring the player or retrying this playlist, we clear out the current blacklist so the other playlists may be attempted in case any have been fixed.. Can just be removed first media from blacklist. Might be worth adding a warning log here with something like Clearing blacklist because last rendition is about to be blacklisted.. I believe there should be more places that it makes a difference. For instance, comparePlaylistResolution will use BANDWIDTH vs AVERAGE-BANDWIDTH if there is a matching resolution. In addition, it keeps consistency with what bandwidth we are using for comparisons (versus overwriting a playlist's attribute/maintaining a pseudo playlist with altered values), and also combines a lot of the standard guards against missing/empting attributes and BANDWIDTH properties.. For sorting, if a playlist has a higher bandwidth, then it should have a higher average-bandwidth as well\nThat is actually part of the reason why AVERAGE-BANDWIDTH can sometimes make a difference, is because it is possible for a playlist to have a higher BANDWIDTH but a lower AVERAGE-BANDWIDTH than another playlist (and vice versa).\nSince AVERAGE-BANDWIDTH is an optional property, if we opt to use it in either a sorting or filtering scenario, all it takes is for one stream in the list to not include the attribute and all the sort/filters will be incorrect.\nIn practice, most m3u8s should exhibit all or nothing, either AVERAGE-BANDWIDTH is present on all playlists, or it is present on none. However, in the event that it is only available on some, AVERAGE-BANDWIDTH will be used unless it is not available, at which point the compared to playlist will use BANDWIDTH. While that isn't an \"apples-to-apples\" comparison,  it should be using a \"best available information\" approach.. That's a good point. We should be able to remove that comparison. The only reason we might be inclined to keep it is for backwards compatibility since comparePlaylistResolution is exposed.. That's definitely true, though if someone was using comparePlaylistResolution as part of their own selectPlaylist function (or for some other reason), the behavior difference could be noticeable (albeit, that is probably not too common of a case).. I believe that is the intention. The idea of using AVERAGE-BANDWIDTH is that when we've crossed a certain threshold, we're no longer worried about what a max bandwidth is on an individual segment (since we have buffer shielding us), but are more concerned with what the segments average out to be.. I believe that should be a few lines up (uses BANDWIDTH when only one available). Would be good to add a comment about how 1 second is about when the request should've ramped up to near its max bandwidth. Would be good to have a comment about why these numbers were chosen. For instance, why we're adjusting the playlist bandwidth down so much when we start the request, but slowly increase to the actual bandwidth number (with a max of 80% of the bandwidth) as we get closer to 5 seconds.\nWould also be good to call it playlistBandwidthAdjustment, since it is adjusting the playlist bandwidth rather than the recorded bandwidth.. loaded only seems to be supported in Firefox and Edge. Is there any alternative for other browsers? Otherwise, do we want to handle the case where it is undefined?. amount. Should we check that this is available (e.g., media playlist cases). Why 5 seconds? Would it make more sense around target duration or the segment's specified duration?. Might make more sense as millisUntilFirstByteReceived. We should have comments above each part explaining it. For instance\n``\n// checks timeout property as is indicates whether this playlist is on lowestEnabledRendition\n// TODO replace with a boolean indicating lowestEnabledRendition\nif (this.xhrOptions_.timeout &&\n    // Wait at least 1 second before using the calculated bandwidth from the\n    // progress event to allow the bitrate to stabilize. Bandwidth information\n    // during the first second is highly variable and inaccurate.\n    firstByteReceived > 1000 &&\n    stats.bandwidth < playlistBandwidth * playlistBandwidthAdjustment) {\n  ...\n}. If it is undefined, should we handle the case differently?. Options. Maybe a hard number is OK. Since it is dependent on ramp up time for requests, that should be consistent regardless of segment size. Have we seen a max amount of time for requests to ramp up to full bandwidth?. Makes sense \ud83d\udc4d . Can we guarantee we will always get NaN? Maybe it would be better to do something likeprogressEvent.loaded || 0(or some other value that we can guarantee). This variable loses some clarity of what it actually is, andstats.roundTripTimeis only used in one place. Probably better to not use a variable for it.. UsingundefinedorNaNin formulas still concerns me. Maybe instead we only setstats.bandwidthifprogressEvent.loadedis a valid number, and if it isn't, thenabortRequestEarly_can simply return false ifstats.bandwidthisundefined`?. Might be easier to above just do:\nif (!this.playlist_.playlist || !this.playlist_.attributes.BANDWIDTH) {\n  return false;\n}. can. I like separating low waterline and goal buffer length variables for finer control.\nAs for time vs rate, I think it would be worth testing both.\n. It seems that settings and options are used interchangeably throughout the code (for instance, here settings are passed as the options parameter). I think it may make more sense to contextualize more. Maybe something like mergedOptions after merged, or playerOptions for player specific ones.. does not resync. does not resync. Would be better to move up these conditions and return early. Reduces indentation and makes it easier to read.. Same re: returning early and removing indentation.. stabilize. realBandwidth doesn't add much context to what we're identifying. Maybe measuredBandwidth or simply bandwidth (and the other bandwidths will be prefixed with the types they are).. Maybe estimatedSegmentBits?. We should check for attributes and attributes.BANDWIDTH higher up and return if not available.. Maybe estimatedRemainingSeconds?. Maybe secondsUntilRebuffering?. Do we want to allow for some variance here? I can see us going either way, since right now we have a variance on the bandwidth when choosing the playlist. That said, it might be useful to take note of that variance here. If there is an allowed variance when selecting a rendition, then we shouldn't consider one here. If there isn't, maybe we should think about having one here.. Since filter creates a new array, do we have to slice?. Instead of doing the logic here, I think we can move this over to playlist-selectors as a function that takes in the playlists, bandwidth, and forward buffer, and returns the playlist that should be able to provide a segment within the remaining buffer time. It can also make use of some of the player size information to ensure that we over select for our window size.. Don't need parenthesis.. Same thing re: naming with these variables (as above). If that is the case, shouldn't we just call them mergedOptions?. Makes sense.. Maybe maxBandwidthWithoutRebufferingSelector?. Instead of providing roundTripTime and returning an object, can we just return null if there's no playlist (since it's possible the playlist will be null anyway).\nThis would also allow us to remove minEstimatedRoundTripTime and simplify the loop a bit.. Only used once, might be simpler killing this variable. Isn't this remaining time?. Minor, but since the other conditionals do the return false early, otherwise continue, may look nicer to check for cases we want to return with false instead, then the final return is true.. Makes sense \ud83d\udc4d . the first byte. firstByteReceived still seems to imply a boolean to me, not a time. Maybe stats.timeFirstByteRecieved? The variable is also the same name as the stat, which is a bit confusing. Might be better as timeSinceFirstByteReceived, or, Ssnce it is only used in one spot, might be easier to just remove the variable.. Minor, but maybe <=. add. ]. playlist. minimumTimeSavings. I don't think this comment (or the others in the conditional) add anything to the code itself.. Can remove this comment (and possibly the one above checking BANDWIDTH). ]. I agree. I think we need <= to achieve that.. aggressive. minimumTimeSavings. Can remove the comments around the conditionals here, since they don't add much over reading the code itself.. Since local storage is limited in size (before access to more space must be granted by the site visitor), it is possible that a user of videojs-contrib-hls doesn't want the project using some of the space if they've carefully accounted for the amount allotted to them.. Don't need parens around Config.EWMA_DECAY (both cases). It is allowed to be 0 in the function itself.. Isn't this already the default?. Should this comment be removed?. Why did these need to change?. Isn't this already the default?. Isn't this already the default?. Sounds good \ud83d\udc4d . Will change to just one.. Comment above says force media1 to be requested. I believe the title of this test is no longer accurate. Maybe selects a playlist below the current moving average bandwidth. Might want a comment about why this number is the way it is. May want to change this to settings. Was there before, but containing. Can get rid of commonSettings entirely if we want to do it in one statement. a. I think this one is global.. I think this one is local.. This will get logged for every playlist. May just want to log it once.. We probably want this comment outside of the loop as well.. isFinite is not supported in IE. Do we have a polyfill for it?. Minor, but putting it just before the loop might be better for a couple reasons: (1) if something breaks (throws an exception) during the loop, we know the last warning log and it can help us determine what broke and (2) we already cleared everything, so Clearing might be more accurate before. Since this is no longer selecting anything (instead it returns everything), we should change the function name.. Actually, since it is much smaller, it might be worth inlining it. It would also shorten later code.. Minor, but the segments on different playlists might have different durations, thus could have a small impact. I doubt it will be noticeable, but it's possible. (Same for two request sets, but probably isn't worth worrying too much about.). rebuffering. Comment is out-of-date, can remove.. Maybe:\n\nUsage tracking events are fired when we detect a certain HLS feature, encoding setting, or API is used. These can be helpful for analytics, and to pinpoint the cause of HLS errors. For instance, if errors are being fired in tandem with a usage event indicating that the player was playing an AES encrypted stream, then we have a possible avenue to explore when debugging the error.\nNote that although these usage events are listed below, they may change at any time without a major version change.. I think all of these may be better off in tables. Something like:\n\n\nEach of the following usage events are fired once per source if (and when) detected:\n| Name | Description |\n| --- | --- |\n| hls-webvtt |  master manifest has at least one segmented WebVTT playlist |\n| hls-aes | a playlist is AES encrypted |\n| hls-fmp4 | a playlist used fMP4 segments |\n| hls-demuxed | audio and video are demuxed by default |\n| hls-alternate-audio | alternate audio available in the master manifest |\nEach of the following usage events are fired per use:\n| Name | Description |\n| --- | --- |\n| hls-gap-skip | player skipped a gap in the buffer |\n| hls-player-access | player.hls was accessed |\n| hls-audio-change | a user selected an alternate audio stream |\n| hls-rendition-disabled | TODO |\n| hls-rendition-blacklisted | a rendition was blacklisted |\n| hls-timestamp-offset | a timestamp offset was set in HLS (can identify discontinuities) |\n| hls-playlist-cue-tags |  a playlist used cue tags (see useCueTags for details) |\n| hls-unknown-waiting | the player stopped for an unknown reason and we seeked to current time try to address it |\n| hls-live-resync | playback fell off the back of a live playlist and we resynced to the live point |\n| hls-video-underflow | we seeked to current time to address video underflow |\n| hls-error-reload-initialized | the reloadSourceOnError plugin was initialized |\n| hls-error-reload | the reloadSourceOnError plugin reloaded a source |\n| hls-error-not-reload | TODO |\n\nSee other comments for TODOs. ~Tracking~. If this is for both enabled/disabled, the event should be renamed. But better than that, we should either have two different events (hls-rendition-enabled and hls-rendition-disabled) or only use the one we feel is most important. I think separating should be fine though.. Maybe hls-error-reload-canceled?. an error occurred too soon after the last reload, so we didn't reload again (to prevent error loops). If we call the variable defaultDemuxed we can probably remove the comment. Can remove the comment. Can remove the comment. Can remove the comment. Can remove the comment. it => the playlist. Can remove the comment. Can remove the comment. Should have a description of the assertion. I think this is detectable before many of these requests are fulfilled. a. Can combine both of these into one listener if you want. an fmp4 segment. This is a bit deceptive. Our check for fmp4 is a little improper right now, in that we only check for #EXT-X-MAP, however, for good measure we should still have 0.mp4 here.. no source was set. after an error caused. no hls-timestamp-offset event was fired. an hls-timestamp-offset event was fired. no hls-player-access event was fired. an hls-player-access event was fired. no hls-rendition-blacklisted event was fired. an hls-rendition-blacklisted event was fired. an hls-rendition-blacklisted event was fired. no hls-audio-change event was fired. an hls-audio-change event was fired. For this and other event counters, I think it is more readable with camelCase, e.g., hlsPlaylistCueTags or even hlsPlaylistCueTagsEvents to be more precise about what is being tracked. Should this have the clock passed?. Should this have the clock passed?\n. Should this have the clock passed?. Can probably just do one line:\nlet isEndOfStream = this.audioPlaylistLoader_ ? this.audioSegmentLoader_.ended_ && this.mainSegmentLoader_.ended : this.mainSegmentLoader_.ended;\nor\nlet isEndOfStream = this.mainSegmentLoader_.ended && (this.audioPlaylistLoader_ ? this.audioSegmentLoader_.ended_  : true);. This comment is a bit extraneous now. I think at least for this top piece, we can move it above the relevant lines below.\njavascript\n          // switch down to lower resolutions quickly to continue playback\n          nextPlaylist.attributes.BANDWIDTH < currentPlaylist.attributes.BANDWIDTH ||\n          // ensure we have some buffer before we switch up to prevent us running out of \n          // buffer while loading a higher rendition\n          forwardBuffer >= bufferLowWaterLine) {. containing. If there is no. Can remove parenthesis. Comment for 1 minute is out of date (above). And we should probably mention that we have to keep it lower than max LWL. Though we should probably calculate based on LWL, particularly if people set their own values.. A lot of these are simply copies. We should have a method that generates them, and make all of them one line function calls.. For consistency, maybe BUFFER_LOW_WATER_LINE_RATE?. Makes sense to me. Makes sense.. I think since the variable name is only used in one spot, it might make more sense to keep it as a string inline. If we end up using it in more than one spot, then we should consider making a constant for it.\nI think we can remove the various constraints for now. Most people should realize that setting a LWL above GBL just won't work. If people run into trouble with them in the future, then we can add in the config specific constraints again.. Should this be bitsReceived. \ud83d\ude0e . This may be too high.. Might be easier to read as must be greater than or equal to 0. Might be easier read/more precise as INITIAL_BANDWIDTH_MOBILE and INITIAL_BANDWIDTH_DESKTOP. Should this be <=?. Although I'm usually for non shared tests, these are similar enough that it might be worth abstracting the test logic, and also checking the warning messages.. I don't think that a change should happen when the bandwidths are equal (either by how the code works or by what we should do).. Might be worth having another for forward buffer equal to dynamic LWL. Would be good to have some tests for always switching when duration < LWL.. That would be good. formatted. Would be good to at least have a warning log here.. Since BANDWIDTH is the only required attribute, maybe it makes sense to just write something like \"Invalid playlist STREAM-INF detected. Missing BANDWIDTH attribute.\". Technically, I think the second one is the one that is invalid, but it may be worth checking both.. Can also check the warning text.. For comments like this, it's probably better to put it right where the action is taking place, and you don't have to specify that the code is below. Maybe something like:\n// remove any overlapping cues to prevent doubling\nthis.remove(firstCueEndTime, lastCueEndTime);. Minor, but these can be const since they never change.. This is more of a preference thing, but you can remove the variables and just do it all in one line:\nthis.remove(segmentInfo.cues[0].endTime, segmentInfo.cues[segmentInfo.cues.length - 1].endTime). If the player has not started yet, but starts later, will PlaybackWatcher end up running?. Definitely, good call. I'll do both.. It's a tough one, and I can see the argument from both sides. But if we don't have the bandwidth now to support the playlist, either because of inconsistent network or because of a low bandwidth network, but can support a different one, I can see this playlist being a poor choice for future selection, as it will likely cause more problems. Two minutes is an arbitrary selection, but seemed long enough to help prevent the segment loops. Maybe it is too long though. Do you think one minute might be better, or did you have another duration in mind?. Good call on the bandwidth being artificial, therefore not triggering. Will do that instead.. I agree that the test is too complicated. We discussed a bit via chat, about how this seems to combine unit and integration testing to create one inordinately long test, and that it would be better to split it up into functional pieces. However, for the time being, I think I'm going to go with option 2 (a comment block explaining the test steps) as this is a bit of an odd case, and we should eventually find a way to extract this kind of integration test into a separate test setup.. This would be good to add as a comment above the clock tick (since clock ticks are generally pretty mysterious through our tests).. Since it's only used in one place, probably can get rid of the var. Is this load no longer necessary?. s/for//. default. Preference, but this can probably be return tracks.filter((track) => track.enabled)[0] || null?. Preference, but this can probably be return tracks.filter((track) => track.mode === 'showing')[0] || null?. Up to you (style wise), but you can reduce down to one line by doing:\nreturn ['AUDIO', 'SUBTITLES', 'CLOSED-CAPTIONS'].reduce((acc, type) => {\n  acc[type] = {\n    ...\n  }\n  return acc;\n}, {});. This got a bit tricky to read, in that mediaGroups_ has groups. I looked again at the spec to try to find specific terms, and maybe it makes sense (maybe it doesn't) to use mediaTypes or mediaPlaylists for the outermost object, then groups within those, since technically groups are within the different EXT-X-MEDIA types, and the EXT-X-MEDIA types don't have a collective term (rather than their types).. Minor, but since the function is called noop, I think we can remove the comment.. It may be useful specifying why we chose not to go destructive here (for a preservation of business logic).. Especially since, in the case of switching back to muxed audio, we are destructive.. Maybe it doesn't matter, but if nothing has changed is it worth starting again?. Maybe just mediaGroups.tracks.forEach((track) => track.enabled = track === defaultTrack);. Technically it can log an error from blacklist. Technically it can log an error from blacklist. Is this possible for subtitle playlists?. Here's where some of the naming gets a little tricky. Trying to mentally parse what a masterGroup is from masterGroups, versus groups and groups[masterGroup] gets a bit tricky. Maybe we can use some different naming?. It also may help to use a masterGroups[type].forEach. Should default be enabled?. Same comments re: groups and naming. Since it is spec logic, might be worth adding something like // forced subtitle tracks are baked into the stream or something along those lines.. Same comment re: grouping/naming ~/forEach~. the provided type. parameter. Maybe this should be called variants?. Preference, but might be clearer as result.filter((props) => props.id === track.id)[0] || null. Extra space?. \ud83d\udc4d . Yup, it was the diff \ud83d\udc4d . \ud83d\udc4d . Shouldn't this still have an activePlaylistLoader?. Are we foregoing this?. Does this test make sense in this file?. Does this test belong in this file?. Will deep equal not work for empty objects?. (For this and others, may be good to have one disabling/hiding.). Should there be multiple groups here to test that it also defaults to main when multiple?. Should we also have a test for when there's a group but none reference it?. Nice try, but we need the \\'. changing. I'm surprised this test passes. properties. loaders. I'm in favor of either of those, since this test won't directly touch the segment loader.. Any of those options sound good \ud83d\udc4d . I think it might be overboard, good as is with that explanation \ud83d\udc4d . I was thinking that there could be a subtitle group, but none of the renditions actually reference it, but after re-reading the test I don't think it would make sense contextually here, and I doubt we'll run into an issue with it being in a manifest.. I'm not sure if we support it, but I put the test in since we don't want to throw the error there for now (until we re-consider). I can remove the test case if we want, until we are sure about behavior.\nSeems from @shahlabs ' testing we may want to consider an error anyway.. It might be worth considering, but can take out the TODO for now so it doesn't produce excess noise in the linter.. Since the calculateSegmentTimeMapping_ function is simple enough, maybe it would be better to change the function to get the segment time mapping and call it again here instead of including the hasMapping property. But either way is fine.. I know we discussed it, but I'm still uneasy about using the event to communicate with videojs-contrib-media-sources. Although it's better not to add non-standard APIs to videojs-contrib-media-sources, making an event is essentially creating an API for it anyway, and makes the code harder to follow. Although it does help in cases where we don't want to fail on native media sources, I'm thinking that it might be better for us to have a specific method in source updater and contrib-media-sources to accept the data, just to make things easier to follow. Eventually contrib-media-sources will go away, removing the issue.\nI do understand the arguments for using the event though (in that we aren't adding a \"supported\" non standard API to videojs-contrib-media-sources). If we do go with the event route, we should at least add some comments here and in videojs-contrib-media-sources to more easily understand how it is being passed between the two projects.. Since it is used in multiple places, may be worth creating a variable like Ranges.SAFE_END_DELTA and putting the comment there.. Same re: comment. Or we can have a constant elsewhere. Like Ranges.SAFE_END_DELTA and leave a comment above it.. For readability sake, I think the logic is easier to follow if this line is kept within the else below and we simply keep the variable declaration here.. If there are no media segments, should we be more or less aggressive than half the target duration? Is there any recommendation of what to do in that case from Apple, or what Safari does?. Preference, but this can be one line.. While the HLS specification is stricter, since someone can theoretically have a playlist of 3 segments, would it be better to return -1 or null here? I know that the value gets used directly later, but maybe it would be better to consider that case and warn or debug?. Preference, but you could move it into a for loop:\n```\nlet distanceFromEnd = playlist.segments[playlist.segments.length - 1].duration || playlist.targetDuration;\nconst safeDistance = distanceFromEnd + playlist.targetDuration * 2;\nfor (let i = playlist.segments.length - 1; i >= 0; i--) {\n  distanceFromEnd += playlist.segments[i].duration;\nif (distanceFromEnd >= safeDistance) {\n    return i;\n  }\n}\nreturn null; // changed as per comment above\n``. Is this from a different PR?. If we're going by this comment, shouldn't it be9 - 3 * 2?. Preference, but for this (and below) the variables don't add much to just making the call in a single line.. I think this one still needs to be changed.. I'd say either capsReturnor remove period. This logic block looks like a good candidate for creating a function.. Maybe we should just use TIME_FUDGE_FACTOR * 3?. Maybeallows seeking no further than the start of the segment 2 target durations back from the beginning of the last segment?. This test seems pretty complicated to set up. Maybe it would be better if we could make the trim function call another function with the right passed properties to get the trim range, so that that function can be tested in isolation.. This comment should probably go in thetrimBackBuffer_function, since we aren't doing any trimming here. This line and comment might be better just as part of theMath.minreturn. We can remove the variable since it just obfuscates the meaning (since it is just a subtraction of two numbers).. Good call. Looks much nicer there \ud83d\udc4d .we are triming pre-emptively, enqueueing=>we trim preemptively, and enqueue.triming actively=>trimming.If we...jamming situationI think we can remove, since the comment above states the intention well. trimming. Any specific reason for the/ 3? Maybe we can calculate how much buffer we need to trim judging by segment starts/ends and their respective sizes?. trimming. Not too big of a deal, but I think this comment still makes sense to be in thetrimBackBufferfunction, since that is where the logic of how much to clear happens.loadSegmentjust needs to know to calltrimBackBuffer. Makes sense, but is a bit hard to read. Maybe the conditionals just set the value ofsegmentDuration(or a ternary is used), thenthis.mediaSecondsLoaded += segmentDurationexists after?. Instead of putting all of the buffer info inSourceUpdaterand keeping track of it, maybe it makes sense for us to add byte info to the segment metadata track https://github.com/videojs/videojs-contrib-hls#segment-metadata and we can make use of that.. I think these two are reversed. And did these have to be changed to get Safari to work?. Was there a specific reason this condition was removed?. This file no longer exists.. Might be good to add a comment here that we check for the existence ofresponseURLto prevent breaking IE or other browsers that don't support it.. We now have a function,goalBufferLengthin MasterPlaylistController that may be a good spot for this to exist.. Might just be preference, but any specific reason for counting backwards with the while instead of usingfor (let i = 0; i < tracks.length; i++)`?\nMight also be good to have a separate function for some of this code, just to keep the constructor cleaner.. Should we have a negative case as well?. \ud83d\udc4d updated. This is available through options: https://github.com/videojs/videojs-contrib-hls#withcredentials. Minor, but since this is time elapsed since either start or last seek, maybe we should leave it somewhat generic and call it elapsedTime()?. Preference, but the function could just be return this.tech_.currentTime() - this.startTime_. Would this change make sense as part of a separate PR?. This is technically not after a seek, right?. This is technically not after a seek, right?. I'm not sure if we have to warn here, since most playlists will not need a redirect (meaning browsers that don't support redirects will warn even if there's nothing to act on).. Maybe we can reuse the comment from above, just worded a little differently for this case (just for consistency).. I think it might be easier to either just use seekable.end(0) in the two places it's needed, or rename the variable as seekableEnd, since the variable doesn't change. We may want to update the comment above setupFirstPlay as well. We may want to update this comment. By https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.5.2 , I think we need to account for PRECISE, or at least mention it in a comment (it's probably OK to ignore using it and just add in a comment for the time being, since this PR just makes things better). I think seekable.end(0) should be the \"safe seekable end\" meaning 3 segments from the end of the playlist, whereas the spec says the offset should be from the end of the playlist.\nWould be good to add a test for that.. It might be clearer (and easier to test independently) to wrap all of this inside of another function. e.g., startTime = mediaStartTime(media.start.timeOffset, media.start.precise, seekable.end(0)). Might be good to use a positive number since 0 is often an edge case.. I think this is meant to be 1 since the values are initialized to the first element at 0. I think that handling the gap resolution logic may be better in playback watcher, probably within fixedBadSeeks_: https://github.com/videojs/videojs-contrib-hls/blob/2158b756eef8a2441fa580f673e316391d63ada6/src/playback-watcher.js#L157\nThis would also allow us to re-seek.. Since it's all relative to the first timestamp offset we append, wouldn't the numbers come out equitable whether we subtract the starting timestamp offset versus use the actual timestamp offsets provided? I saw you mentioned that it helps handle gaps, but would you be able to provide a case where it happens?. Extra logging statement.. It probably is still a bit ambiguous, I may just be hooked onto it reading Time somewhere. Isn't that an issue that's present without the other change?. My mistake. I saw the seek a couple tests higher and assumed the test after had to do with the seek, but then following tests had to do with just normal playback from that point (since only currentTime changed, but not via setCurrentTime again), but you're right, it's still after a seek.. It's possible that the user did not specify a bandwidth value and set useBandwidthFromLocalStorage to true, but there was nothing in local storage, leaving bandwidth undefined.. Thanks for all the examples. I see what you mean. It's an interesting question, and we may want more input on it. One thing we may also want to consider is we do have the minimumTimeSaving variable which is adjusted in the case where we're already rebuffering, which should count for the case of seeking.. I think we should default this to false to maintain current behavior.. Since \"playlist loader\" is a bit internal, maybe something like \"When the followRedirects property is set to true, manifest requests which are redirected will have their URL updated to the new URL for future requests.\". Technically we do follow redirects for certain requests. I think something like handleManifestRedirects might be a bit more descriptive for the intended behavior.. controls. Minor, but can use notOk for these. Minor, but can use notOk. Yeah, I think the stalling issue after 1 second of playback is what we should avoid.\nIn my mind, the perfect case would be: you seek, we load the same quality. If it's going to take a while we can still wait, up to a point (though that \"point\" is not well defined).\nI think the \"best\" answer would be to change our seeking behavior such that we only resume playback after we have enough segment data to continue playback without a stall for our current throughput and rendition. If that takes (or will take) in excess of X time, then we consider downswitching.\nHowever, that case may be tricky to implement. In the meantime, I don't think the abort early with downswitching is a bad situation, so long as we avoid playback stalls.. I think the linter might warn to use typeof playPromise !== 'undefined'. Thanks for the update @grobolom ! Though in this case the typeof comparing to a function is OK (and preferred), but the playPromise !== undefined should probably be typeof playPromise !== 'undefined'. Sinon will break our tests, not sure offhand about qunit.. It may be worth pointing to the VJS 7 blog post or have some short description of the reason why it's the next version.. Minor, but usually for multi-item objects the codebase tends to put them on different lines.. Minor, but linter usually complains if there isn't a space after a variable declaration.. Safari passes?. We may want to wait to update this line until it's officially deprecated.. Very minor, but may be worth changing \"blog post\" to \"blog post for details.\". ",
    "yurevich1": "hls, of course. If I open realtime stream (nginx + rtmp to hls) on my iPad - all works correctly. But if I open stream in hls in Chrome/FF- nothing.\nThe debugger in Chrome  says all files are downloaded. Very strange - the are downloaded but are never played.\nindex.m3u8:\nEXTM3U\nEXT-X-VERSION:3\nEXT-X-MEDIA-SEQUENCE:0\nEXT-X-TARGETDURATION:15\nEXT-X-DISCONTINUITY\nEXTINF:10.000,\n10.ts\nEXTINF:10.000,\n11.ts\nEXTINF:10.000,\n12.ts\nEXTINF:10.000,\n13.ts\nEXTINF:10.000,\n14.ts\nEXTINF:10.000,\n15.ts\nEXTINF:10.000,\n16.ts\nEXTINF:10.000,\n17.ts\nEXTINF:10.000,\n18.ts\nEXTINF:10.000,\n19.ts\nEXTINF:10.000,\n20.ts\nEXTINF:10.000,\n21.ts\nThe flash-app begins to play when server write into end of the file:\nEXT-X-ENDLIST\n. ",
    "hyurtseven81": "Hi,\nIs there any update for this issue?\nThank you.\n. Same with this: https://cdn.blutv.com.tr/kdv/S6/HLS_VOD/92658_d24b/index.m3u8\nalso there is lip sync problem with this hls but on our old player http://quark.dogannet.tv/player, there is no problem\n. Same with 2.0.1 version\n. After testing with 1.3.3 version, there is no problem\n. There is another problem, when i try to play video on android devices sometimes and some devices player sends byterange request to m3u8 and it takes 2 kb empty manifest and it shows  \"The media could not be loaded, either because the server or network failed or because the format is not supported\" error and can't play\n. Problem has solved, \nThe problem was about Allow-access headers android devices look those headers to play video,\nI didn't know that.\nThank you\n. I've found a way to find current playing segment but when discontinuety comes it gives undefined,\nIs there any help?\nvar mediaIndex = _self.playlists.getMediaIndexForTime(self.tech.currentTime());\nvar _segment = _self.playlists.media().segments[_mediaIndex];\nconsole.log(_segment);\n. Actually we're working a dynamic ad insertion project for live streams, we add some extra metadata on advert ts's like #EXT-ADVERT with discontinuety tag, we added advert property on segment object in hls plugin and we can get back it with above _segment object, and i've finally solved the problem, now i can get playing segment with discontinuety and advert properties and i can fire an event that says start request ads from adserver and it's working right now, but i've made a lot of changes.\ni can share my code but i'm not sure it is a generic solution of course, but now i can do dynamic ad insertion on player side with some modifications on m3u8 files.\nBy the way i developed a bitrate selector menu,\nvideojs.hls.txt\nyou can check my modifications with // HY: Custom add comments\nThank you for your help\n. I've found an interesting situation, if you decrease browser size to half of the screen when you use max resolution on 15.4 macbook pro, there is no problem again, so i think the problem is related to resolution. but i don't know where can i look?\nI'm waiting your help.\nThank you.\n. Thank you for your quick reply, we're trying to fix our hls's\n. Thanks for your helps, we fixed one of our HLS with ffmpeg and with this fix everything seems perfect.\nhttps://cdn.blutv.com.tr/kdv/S6/HLS_VOD/92744_f130/index.m3u8\nThanks again.\n. ",
    "rdgRmCore": "Thanks for the pointer. I will check it out.\n. @dmlap, \nI made the changes based on the previous work of @raytiley.\nI tested the changes localy with a test stream and the audio track played back.\nThe changes are on the master branch of my fork.\nShould I create a pull request?\n. @gkatsev \nI tried to create the pull request.\nThe Travis CI is failing.\nIt looks like some tests are failing on the new Mp3 class.\nI am not sure how to proceed.\nI am not sure what exactly is failing.\nI don't know how to run the tests locally.\n. I am running Ubuntu and this is what happens when I run npm test:\nnpm test\n\nvideojs-contrib-hls@0.10.4 test /home/rdg/projects/videojs-contrib-hls\ngrunt test\n\nsh: 1: grunt: not found\nnpm ERR! weird error 127\nnpm WARN This failure might be due to the use of legacy binary \"node\"\nnpm WARN For further explanations, please read\n/usr/share/doc/nodejs/README.Debian\nnpm ERR! not ok code 0\n. @gkatsev \nThanks for all your help. I am now able to run the tests locally. However, the output doesn't make a whole lot of sense. Here is the first error as far as I can tell.\n\n\u001b[1A\u001b[2K\u001b[31mChrome 40.0.2214 (Linux) segment parser creates an flv header FAILED\u001b[39m\n    beforeEach failed on creates an flv header: undefined is not a function\n    TypeError: undefined is not a function\n        at new videojs.Hls.SegmentParser (/home/rdg/projects/videojs-contrib-hls/src/segment-parser.js:24:19)\n        at Object.module.setup (/home/rdg/projects/videojs-contrib-hls/test/segment-parser.js:42:16)\n        at runHook (/home/rdg/projects/videojs-contrib-hls/node_modules/qunitjs/qunit/qunit.js:916:20)\n        at process (/home/rdg/projects/videojs-contrib-hls/node_modules/qunitjs/qunit/qunit.js:573:24)\n        at begin (/home/rdg/projects/videojs-contrib-hls/node_modules/qunitjs/qunit/qunit.js:618:2)\n        at /home/rdg/projects/videojs-contrib-hls/node_modules/qunitjs/qunit/qunit.js:634:4\n\n    Died on test #2     at /home/rdg/projects/videojs-contrib-hls/test/segment-parser.js:46:3\n        at /home/rdg/projects/videojs-contrib-hls/test/segment-parser.js:375:3: Cannot read property 'getFlvHeader' of undefined\n    TypeError: Cannot read property 'getFlvHeader' of undefined\n        at Object. (/home/rdg/projects/videojs-contrib-hls/test/segment-parser.js:47:51)\n        at Object.Test.run (/home/rdg/projects/videojs-contrib-hls/node_modules/qunitjs/qunit/qunit.js:885:28)\n        at /home/rdg/projects/videojs-contrib-hls/node_modules/qunitjs/qunit/qunit.js:1014:11\n        at process (/home/rdg/projects/videojs-contrib-hls/node_modules/qunitjs/qunit/qunit.js:573:24)\n        at begin (/home/rdg/projects/videojs-contrib-hls/node_modules/qunitjs/qunit/qunit.js:618:2)\n        at /home/rdg/projects/videojs-contrib-hls/node_modules/qunitjs/qunit/qunit.js:634:4\n\n\nIt seems like there is a problem creating an object. I don't know what line of code is failing. Can you tell what line of code is failing from the output?\n. @gkatsev \nOK. Thanks for taking a look. I was confused because there are two segmet-parser.js files. One of them is under test the other is under src.\nIt seems like when the unit test is running that it doesn't know about the Mp3Stream class that is in the file src/mp3-stream.js\nHow do I tell the tests where to find mp3-stream.js?\n. @gkatsev \nThanks again for your help. The tests pass locally. The Travis CI build completed.\n214\n. @gkatsev \nI will give testing some thought.\nRight now I have tested it manually with an actual transport stream.\nI would have to come up to speed on your unit testing framework. \n. @gkatsev \nI added a unit test.\n. @gkatsev Is there any news or updates regarding this pull request?\n. ",
    "avreg": "Fixed by https://github.com/videojs/video.js/pull/1858, closed.\n. ",
    "ronhopper": "FYI -- I'd be happy to implement and submit a pull request, if someone can confirm desired behavior. Thanks.\n. That sound's reasonable. Let me try it that way and, assuming it works, I'll close this out.\n. I was able to do this the way that you suggested. Thanks!\n. ",
    "ntadej": "This fixes audio-video sync with our streams without any noticeable regressions.\n. Our streams do not start properly with your HLS implementation do to missing ADTS headers at the beginning. This may cause the issues, but our streams play completely fine on iOS, Android and other devices.\nWe are preparing a test stream for you (I plan to open another bug, as there are some problems with quality switching and general playback after 0.11.1 -> 0.11.2 update). Is there a preferred email to send the URL to you, as we can't make it public at the moment?\n. I've sent you the url on email and opened #236. Note that playback on 0.11.2 works again after updating to Video.js 4.12.5 but quality switching still has problems as described in #236.\n. We investigated why this is necessary and found out that H264 data is not aligned inside the TS packet at start of playback. It seems to be a valid case to have this h264Frame validation and data before first frame can be ignored.\n. Unfortunatelly, yes. There don't seem to be any visible improvements. In some cases it even took longer for playback to recover to normal state.\n. Updated PR according to your comments.\n. Here is the validator output: https://gist.github.com/ntadej/245e53acc6b7548d418a\nThe stream plays completely fine on iOS or OS X.\n. Yes, we tested version 2.2.0 few days ago with our streams that have approximately 1 second delay between audio and video. There are two possible scenarios that still happen (none of them is ok):\n- only first segment of stream gets played with audio/video in sync, then stops without any error in console or in MSE log\n- stream plays continuously but with audio/video out of sync (delay is noticeable)\nYou should still have access to our test live stream.\n. I use autoplay in player configuration (so I don't have to call play command after initialising player).\nI don't have any problems with line 912.\n. This seems to be fixed with combination of latest stable video.js and videojs-hls.\n. The stream will be invalid anyway so a new source will be used. There playlist loader will be initiated again.\n. Isn't player.hls.playlists.media() the playlist currently selected by player.hls.selectPlaylist? This would mean that it may already change compared to currently played stream.\nI currently detect audio only quality by reading current playlist and comparing it with our backend. The problem is, that it changes before actual playing content.\n. I'm not sure if this is specific to our streams, probably we can provide you with a sample. These are PVR recordings made from same source as our live stream (that I already sent you a while ago).\nSteps to reproduce:\n- play video for a while so it buffers a few segments\n- seek to position into future -> it works OK and plays from that position, but min audio PTS on first segment will be wrong (it will be max audio PTS from last buffered segment)\n- seek to another position later than previous seek -> it will seek to same position again, because PTS in previously seeked position is wrong and so duration of segment too\nWhen calculating duration of playlist you use segment.maxPts - segment.minPts (simplified) which causes wrong seek position.\nI will look at Media Source Extensions PR when ready and report back.\n. We prepared samples of our PVR and VOD videos. This and #379 can be reproducible with first. I sent them over email to @dmlap.\n. There was an issue with Chrome I think where it didn't properly detect HE vs LC AAC. It works now with latest version. There are still other issues with our streams though ;)\n. According to Apple documentation, this should not be present in live playlists:\nThe EXT-X-ENDLIST tag is not present in the Live playlist, indicating that new media files will be added to the index file as they become available.\nWe want to replicate the following iOS feature:\nhttps://developer.apple.com/reference/avfoundation/avplayeritem/1388752-canusenetworkresourcesforlivestr?language=objc\nWhen live stream is paused, we do not want it to continue requesting any playlists or segments from server,\n. Yes, the problem is when translatedMediaIndex === update.segments.length. The index gets increased and falls out of the playlist.\n. Shouldn't there be || instead of &&? Your fix changes existing behaviour.\n. ",
    "szatmary": "I see nothing obviously wrong\n. ",
    "JacobRichardt": "Did this ever get merged? I'm having some trouble getting mp3 audio to play.. ",
    "GerardVirga": "We are seeing this same problem with live streams published from FMLE: H264 video with MP3 audio (44htz)  to Wowza 4.6.x. When the live video streams from FMLE include MP3 audio there is no sound. When published with AAC from FFMPEG or Wirecast the sound renders. We understand that this is a legacy application but want to head off any future support issues if FMLE or an MP3 codec is used in the future. \nThe playlist shows MP3 codec as as mp4a.40.34. Which should be right? I think this ticket deals with MP3 Audio Only streaming but it sounds like a variation of the same problem. I also think the same problem exists in HLS.js when we test with the demo player. \nWe are still learning the framework and protocol for bugs so forgive me if I missed something or posted in the wrong place.. I also wanted to add that the use case here is less FMLE but more important for users of vMix or older Tricasters which still automate FMLE behind the scene. . Echoing more support a resolution to this issue - see my comments on #214 . ",
    "anthropos9": "Has there been any progress on this issue? \nI have a project that is pulling an m4u8 playlist with mp3s from a WowzaStreamingEngine/4.7.0 server, it reads the playlist, but when it tries to play an individual mp3 it just hangs.\nAny update would be helpful. Thanks.. ",
    "himslm01": "Sure.\nhttps://github.com/himslm01/videojs_test1\nI'm serving the folder src/main/webapp through a web server, and looking at the page in Chrome 41.0.2272.76 (64-bit) on a Mac.\nView the index.html page.\nOpen the JavaScript Console.\nPress the 'Create video' button.\nDo not play the video.\nPress the 'Dispose video' button.\nBasically, you get \"TypeError: undefined is not a function {stack: (...), message: \"undefined is not a function\"}\" errors if you have not played to the end of the video before you dispose, and not playing the video at all is the same as not playing it to the end.\n. Thanks for the update, David.\nOne thing I also notice is, for longer clips - if I dispose of the video player while it is playing but before all of the HLS segments have been downloaded then I see logs being printed saying that the rest of the HLS segments are being downloaded - and lots and lots of \"TypeError: undefined is not a function...\" exceptions.\nI've also seen the last segment be downloaded again and again in a loop.\nI don't believe (from looking at web server logs) that the segments are actually being downloaded, just that the dispose hasn't stopped the download process from happening. \n. In my instance, this issue is seen on non-Android platforms.\nI've added an on('loadedmetadata', function() {}); to my test, which displays a button, which, when clicked, always returns 0 for the HLS media in my demo.\nhttps://github.com/himslm01/videojs_test2\n. Ive tested on both Chrome and Firefox, they both show the same.\n. ",
    "vasklund": "Although I haven't looked at this in detail, it sounds like it could be related to this bug I filed a while ago:\nhttps://github.com/videojs/video.js/issues/1896\nEssentially the Flash tech doesn't clean itself up correctly when it is disposed, leaving old event handlers alive with references to objects and functions that are removed correctly (thus the null/undefined references).\nIf you want to, you could try my attempt at fixing the above bug at https://github.com/vasklund/video.js/tree/flash-dispose-fix. I suspect there are a lot of bugs that are caused by https://github.com/videojs/video.js/issues/1896, but having some real world cases would be much better than just my speculations.\nFor reference, I filed the bug above after having problems doing similar things to what you are doing @himslm01.\n. I'd be happy to prepare a PR, I just want to make sure I'm not missing anything (in the latter case, updating the code).\n. https://github.com/videojs/videojs-contrib-hls/blob/master/src/videojs-hls.js#L193\n. Ok, It seems I'm able to sidestep the problem by setting the playlist manually with player.hls.playlists.media:\nplayer.ready(function () {\n  // force the fourth playlist for the initial segment\n  player.hls.playlists.media(player.hls.playlists.master.playlists[3]);\n});\nThis seems to work and I can leave player.hls.selectPlaylist and player.hls.bandwidth alone, but it seems kind of counterintuitive that I need to use player.hls.playlists.media() to set the quality for the first segment. I thought I would be able to achieve similar results by overriding player.hls.selectPlaylist(), but it seems I can't override it before it gets called (if I override it in player.ready() it has already been called once for the initial segment).\nI'll comment again if I find anything else, but for now I might just go with the media() workaround.\n. I'd like to reopen this, since I'm still not able to override the initial quality selection.\nThe problem in both cases (using player.hls.playlists.media(myHighQualityPlaylist) and the bandwidth spoofing above) is that there's no good event to hook the custom logic to.\nThe bandwidth spoof seems like the easiest implementation, but the problem is that the loadstarted event sometimes happens after the loadedmetadata event. The bandwidth spoof has no effect in this case since it is read in the (playlists) loadedmetadata handler (videojs-hls.js#L157), where it is still undefined.\nI set up a simple test page on:\nhttp://output.jsbin.com/vuzime/1/\nI see the error about 50% of the time (loadedmetadata happens after loadstart), on a couple of different browser/OS combinations, so hopefully you should be able to reproduce easily with a couple of refreshes.\n. I might be able to spend some time on this, but before that I'd like to ask whether the behavior above (loadedmetadata sometimes comes before loadstarted) is expected behavior or not? If not I could look into it; if it is I'm not really sure how we want to approach the problem described in the issue.\n. Looking at this now and have a quick follow-up question:\nI'm seeing the loadedmetadata event twice, once from videojs-hls.js#L146 and once from Flash via vjs.Flash['onEvent']. I was expecting the event only once, but I haven't read the specification that closely. Do you know if this is intended or not? \nI've just started digging into this so I don't know if it's intended or if it has any negative implications.\n. I haven't been able to find a good solution to this yet, but I've documented what I think is the root problem in a new issue at #310. We've sidestepped the problem by monkey-patching videojs.Hls.prototype.src for now (not a wonderful solution), so this issue can be closed at your discretion.\n. PR #311 shows a naive approach to solving the issue described above - it's most certainly not a good solution.\n. @dcrockwell: There's a very crude monkey-patch which works as a short-term workaround if you really need it. Notice line 63. Maybe there are better workarounds, but this is what we are forced to used at the moment.\n. Our bad! Seems the problem was with videojs-contrib-media-sources and was fixed with 0.3.2 and 1.0.0. If it's OK I'll leave the issue open for a few days while we do some more extensive testing, but it seems the issue doesn't exist with 1.0.0.\n. Haven't seen the issue since we bumped media-sources, so closing the issue.\n. ",
    "quarkus": "@gkatsev sorry .. i have been pretty busy over the last days. is the change correct ? i am not totally sure what i\u00b4m doing here ;) \n. ",
    "squarebracket": "The changes in #681 allows for doing this easily now, yes? I didn't dig into the code too much, but based on what's written here, it looks like a similar flow could be used to implement handling the WebVTT playlist + segments. \n. just found a problem -- need to ignore CEA708 tracks since we don't support them.. Yeah, by inspecting the value of INSTREAM-ID. For 608 the values are CC1-CC4, for 708 the values are SERVICE1-SERVICE-64. We can just do a regex match.. I'm doing some manual testing and I'm getting a 708 track added, looking into it.... Nevermind.. Was mistakenly using wrong code :roll_eyes: . The native HLS playback in Edge doesn't support captions. I use these configurations settings for Edge and Android, to ensure feature parity across all browsers:\nvar config = {};\nif (videojs.browser.IS_EDGE || videojs.browser.IS_ANDROID) {\n  config = {\n    html5: {\n      hls: {\n        overrideNative: true\n      },\n      nativeAudioTracks: false,\n      nativeVideoTracks: false,\n      nativeCaptions: false\n    }\n  }\n}\nTry it out here: http://jsbin.com/juvixaf/edit?html,output\nThe demo page does not include this config stanza. . No problem, glad to help.. Hmm. You're right; playing the BipBop feed in Edge does show all captions. I'll have to take a look into this when I get a moment.. It would be nice if you could modify this test to test that the new attributes are added to the cue. You could modify this line for the test helper playlist creator to be\nattributes: conf && typeof conf.attributes !== 'undefined' ? conf.attributes : {}\nand then you could simply attach some test data to the playlist creation with\nlet playlist = playlistWithDuration(50, {attributes: {BANDWIDTH: 4500000, ...}});. Added cool off for a segment duration post-seek. Let me know if you want me to add any tests.. I added tests for the dynamic buffer stuff and elapsedSinceStart. It'll probably take me a while to figure out how to write a test for the cool-off behaviour. I saw this test but couldn't really figure out what's going on. I guess I'll see if I can find a test that uses the actual download workflow since I think that's what needed here.\nOn another note, is there a test for aborting when the buffer is low? i.e. like this but for buffer size? I saw a test for the logic inside minRebuffer... but not for the abort logic.. Why doesn't it trigger at the first (well, second) progress event? 2B/s is lower than all the playlist bandwidths. . Oh... wait... it's 2000B/s..... nevermind. I can't math good :). Oh, my bad, I thought it was \"wait until first byte\", not \"wait until 1 second after first byte\".. @mjneil you meant something like this, right? Note, I had to tick 1000ms first so that I could reach the seeking code path.. Made the changes and rebased. Changes since the last review are in commit 4509642 and forwards.. Hey @tchakabam!\nWe've been talking in the slack channel about how to handle QuoteExceededErrors in the most robust fashion. There's a consensus that we should catch the exception and dynamically change BACK_BUFFER_LENGTH, MAX_GOAL_BUFFER_LENGTH, and MAX_SOURCE_BUFFER_OCCUPATION_BYTES based on the amount of time and data in the buffer when the exception occurs. This way we could handle various buffer sizes without knowing them in advance, and adjust them on-the-fly if system memory pressures force them to decrease in size.\nThat solution would require some additional functionality to what you've got here, and a new PR to contrib-media-sources, since there's a SourceBuffer shim that's used when transmuxing from MPEG-TS. (It calls appendBuffer async, so it can't be caught by contrib-hls.)\nWould that be something you're up for? I can walk you through the details if you're interested. No pressure if not; I can code up the PRs and credit you with the basis for the solution :)\nThanks again for taking the time to contribute and moving us forwards on a fix.. Sounds good :) thanks again for the initial PR.\nI'll close this one once I've got a new one open.. Yes, actually! My apologies, I forgot to comment in this ticket.\nThese features are now being tracked in #1416. It would certainly be a big help to me if everyone interested in these features could go build the project with those changes and test it out with their sources / devices.\nClosing this PR in favour of #1416.. I'm not sure what you're asking for here. Does the token expire while the stream is playing?. By show, do you mean via UI? The bandwidth measured from the last segment request is accessible via the tech.. Is there a reason you can't use the API, i.e. calling player.src and providing the type? Like this.. Reopening as it's unrelated to #1435 (segment size isn't what's causing the describing problem per se).\n@Kjeld your playlist confuses me. You have an EXT-X-MEDIA for the audio with no URI, but then have an audio-only EXT-X-STREAM-INF later. Is there a reason you're not just using it as the URI attribute of the EXT-X-MEDIA?\nIn any case, what's happening here is that the initial bandwidth is low enough and the video playlist's BANDWIDTH is high enough that the initial playlist selector is choosing the audio-only playlist by default. Once that happens, it's locked into audio-only; the source buffers are made only once, and since the first playlist it selects only has audio, it only creates an audio source buffer.\nIf you feed in a pre-programmed bandwidth to use during initial playlist selection, \u00e0-la\njavascript\nvideojs('videojs-contrib-hls-player', {html5: {hls: {bandwidth: 30000000}}})\nit will select the audio+video playlist and everything will work out.\nPerhaps we should add something to the initial playlist selection that disregards any audio-only variants if there are any audio+video variants.\nThat being said, unless you need it, you should consider dropping the only audio-only variant playlist. Note that Apple no longer recommends using an audio-only playlist in its HLS authoring guidelines; it now recommends a playlist with low-bitrate audio and video. Alternatively, simply encode more variants that have lower-bandwidth streams.. Not sure if these fixes will stop errors like this, but I've had sporadic disconnect errors in the past when testing. Maybe we should add browserDisconnectTolerance: 3 to the karma config?. Wow, what a roller coaster. Hopefully you still have some hair left cuz I\u2019d have pulled all of mine out. . Are those playlists using byte-range requests like https://devstreaming-cdn.apple.com/videos/streaming/examples/bipbop_16x9/gear1/prog_index.m3u8?. I think I've managed to nail down all the fiddly bits here.\nI had some trouble with the tests, like mediachange not firing for some reason, so it'll probably take me a bit to get through making the tests, but the code itself should be feature-complete. . Added browser workarounds for old vjs versions. For anyone who lands here, I opened PR videojs/http-streaming#370.. Made appropriate changes, plus a couple little other ones. For some reason, on my test mac, but not on other platforms, chrome won't let autoplay happen with\njavascript\nthis.player = videojs(video, {muted: true});\nbut does let it happen with\njavascript\nthis.player = videojs(video);\nthis.player.muted(true);\nwhich confuses me greatly, but hey, that it makes it work, so..... :man_shrugging: . Err, the package-lock wasn't updated, so that will probably have to be done.. Note that tests will fail until #1412 is merged in and I can rebase against it.. Rebased against master to make (most) tests pass. Only failing test now is related to VTT cue removal, which will keep failing until videojs/videojs-contrib-media-sources#178 is merged in; I coded the tests for the new media-sources version, and all tests pass locally when using the patched media-sources.. @genelamarellis pretty much, though you have to make sure contrib-hls is building with the patched version of contrib-media-sources, which it will not do by default. The easiest way I know of to do this:\n```shell\ngit clone https://github.com/videojs/videojs-contrib-media-sources.git\ngit clone https://github.com/videojs/videojs-contrib-hls.git\ncd videojs-contrib-media-sources\n\nnpm link\ncd ../videojs-contrib-hls\nnpm link videojs-contrib-media-sources\n\nnpm install\nnpm run build\n```\nOnce you've got that done, as you say, upload the dist directory and reference the appropriate file.. Excellent! I'm excited to hear the results.. Great, glad to hear it! It's a fair bit of code, so it might be a bit until it's merged in. Hopefully it won't be too long.. > Rather than have this be getters/setters on the master playlist controller, these could just be settings/options passed into the master playlist controller, then passed down to and modified on the segment loaders.\nIf I understand correctly, you're saying that they could be static for a single playback? If so, then maxGoalBufferLength could be a statically configured value (and essentially is that), but goalBufferLength and backBufferLength must be dynamic to support dynamic buffer sizes.\nImagine this situation, as it may help to explain why. You have configured contrib-hls 30s back buffer and 60s forward buffer, and start playing a high-res stream. At 10s, you bust the size of your browser's buffer and a QuoteExceededError occurs. That means, you can have buffered at any given time ~10s of the stream. Any more than that, and you've got a problem. But if you're keeping 30s of back buffer, then that means once those 10s are behind your playhead, you won't be able to download any more data (as you won't be ejecting anything from the back buffer). So you'll just end up in an unrecoverable state of not being able to play back anything other than those 10s.\nIt's a bit more complicated than that, but hopefully it's instructive enough to get across why the dynamic adjusting is important. If I misunderstood and you were motivating for dynamic buffers, but just another way of doing it, then I'm afraid you'll have to be a bit more -vvvv as I don't get what you're saying.\n\nWhy does the time matter if we are also using the amount of data in the buffer?\n\nThat's true that data is the important factor here, but the underlying MSE functions (like removing from the buffer) work with time, not data. So we need at least rough estimations of the equivalent time.\nThat being said, maybe I missed something, so if you can think of a way of doing it without time, I'm all ears!\n\nSeems like trimming the back buffer should be done in another method outside checkBuffer_\n\nIt is. checkBuffer_ is simply an algorithm to see whether or not a new segment should be downloaded, based on what is currently in the buffer. In this case, the answer is no, but it also tries to free up stuff in the back buffer since the check for \"do we have more than goalBufferLength in the buffer?\" returns false.\n\nIf I understood correctly, we are appending and removing whole segments in this PR right? Why is it needed to split up the segment into chunks?\n\nYou understand correctly (though it has always been my intention to add subdividing by GOP when making this PR against VHS). We need to split it into 5MB chunks because Firefox will throw a QuotaExceededError on the first append when the segment is too large. You can trigger it with this feed.\n\nIs there a specific use for the min bytes in the buffer? Would the ideal be to play it safe and always assume the max is in the buffer?\n\nAs you'll see in the code, the way things work out, in certain situations the safest thing to do is take the max, and in other situations the safest thing to do is take the min.\n\nI thought this exists in contrib-media-sources?\n\nIt removes all cues within a time range. removeNonBufferedSegmentCues loops through the buffers and removes cues wholly outside the buffered data. It could use removeCuesFromTrack for the actual removal, but you would still need to determine the time ranges to remove. \n\nReading this naively, it seems like the remove and reappend attempt can be done before the original pendingCallback is run. Is there something preventing this?\n\nCan you clarify what you mean? Every append has a callback that needs to be run after the append succeeds. If the buffer is full, we need to remove data from the buffer, then append the original data to the buffer, then run the original callback. However, since the SourceUpdater needs to act like an abstraction of a native SourceBuffer, the SegmentLoader needs to make sure that sourceBuffer.updating === false, otherwise any remove or append operations will fail. In SourceUpdater, updating will be true if pendingCallback_ is not null. I experimented with other ways of having updating be false, but I could never get them working.\nThis is certainly a place in the code where a fresh pair of eyes could help.. > they could be getters/setters at the segmentLoader level. That would allow different values for different loader types, though admittedly I don't see an immediate need for that level of flexibility.\nRight ok, I understand what you're getting at now. That was actually the original design I implemented but found that I needed to change it to what you see now. That's probably a design decision I should have documented in the PR description.\nIIRC, it was something related to switching rates. I may just be thinking of this, but I feel like there was something else that caused me to pull that functionality into the master playlist controller.\nIf you'd like I can try pushing them down to the SegmentLoader. This code did go through several heavy rewrites and redesigns, so it's entirely possible that the requirements at the time are no longer needed.\n\nI suppose a potential alternative would be to try and match a TimeRanges object returned from buffered().\n\nI'm not sure I follow here? We want to know the amount of time in the buffer when we get a QuotaExceededError so that we can\na) know how much forward buffer (in s) we should have before we stop downloading chunks (because we don't want to put too many bytes into the buffer)\nb) pass time-based parameters to MSE functions (like remove(0, currentTime - backBufferLength))\nIt's annoying, but everything uses time, except for the error which is triggered by bytes.\n\nWhat I meant was that the order of execution could be:\n\ntrim back buffer if needed and adjust other buffers to match\ncheckBuffer_ to see if we need to download the next segment\n\n\nTrue, we could trim the back buffer on every loop, and not only when it looks like the next segment will bust the buffer. That way, checkBuffer_ (mostly) remains a series of yes/no questions that take no actions.\nThere is kind of an open question to me, here, which is how we should prioritize the various goals (and thus how/when we should trim/not download). For instance, say you've got a back buffer goal of 10, a forward buffer goal of 30s, and GOPs are every 2s. Imagine that your forward buffer falls below 30s, but you see that the next segment will burst your buffer. Should slice a couple GOPs off your back buffer, even if it brings it down to 6s? Or should you just wait until you can download that segment and not trim off any more than 10s?\nThis is a part of the PR that I very much want feedback on, so I'm anxious to hear what you think is the best behaviour once you've gone through all the code.\n\nSounds like you hit a wall\n\nThat is 100% how I would describe it, yes :sweat_smile: . :one: Fixed.\n:two: Good question. It's probably fine to remove the handler when it thinks it can append, provided the calculations are correct 100% of the time and the browser isn't engaged in shenanigans. You're right that it's possible remove will be called twice, in which case an InvalidStateError would be thrown.\n:three: Did we conclusively decide on renames? backBufferLength is already a function on the MPC. \n:four: I think you're misunderstanding the point of adjusting the buffers. It is unrelated to actual buffered data, simply on setting the desired lengths of the forward/back buffer. Trimming the back buffer simply lobs off data. In order to reduce priority on the back buffer and increase priority on the front buffer, the respective goal lengths must change. Or I suppose, I should say, that's the way I understand priority -- if you have a fixed amount of time that you can buffer (which is the case after a QuotaExceededError), then increasing priority on the forward buffer means allocating more of that overall fixed time to the forward buffer.\nAt first glance, it does appear that I could perhaps be using the forward buffer here instead of secondsInBuffer. But I will need to meditate on how that will change things. \n\nIt's likely that we are \"seeing more back buffer than forward buffer\" because we are using the old backBuffered time and we should wait for trimming to be complete via updateend before checking the buffered times again anyway.\n\nI find this extremely unlikely. In my experience the problem comes from not being able to set the back buffer less than a target duration (which is of course done since we aren't slicing on GOPs).\n\nAs far as I understand, backBufferLength is an actual value in the buffer rather than a goal\n\nThis is incorrect; it is the equivalent of goalBufferLength for the amount to buffer behind the playhead. \n\nbackBufferLength should reflect the time in the buffer behind the playhead.\n\nNo, semantically it should be the target amount of back buffer. In the latest code it is called backBufferGoal.\n\nHaving the adjustBuffers event seems undesirable since I believe we want to adjust buffers after removing the appropriate amount of back buffer?\n\nNo, definitely not this. To simplify the explanation, assume a fixed bitrate stream. When you get the QuotaExceededError, you know that staying within currentlyBufferedSeconds of total (fwd + back) buffer will mean you will never get another QuotaExceededError, because it's the next append that pushed you over the top. This is a good conservative estimate, without being too conservative. \nIf you trimmed your back buffer before adjusting the buffers, that means you'd have smaller buffer sizes than you can actually handle. In this case, you'd be going too conservative, which means a greater likelihood of getting stuck.\n\nEither way, having adjustBuffers() be called more clearly either before or after handleBufferMaxed would be good.\n\nThat is actually exactly what is done, see source-updater.js. It triggers adjustBuffers then it triggers event (which is bufferMaxed).\n:five: No, it is only ever used for both those functions described. It calculates the lower limit on the amount of bytes buffered within the range start, end. This is because the browser may yank bytes from the buffer, so you always have to make sure your stored values haven't changed without you knowing. See this note in the spec.\nHowever, upon closer reading of the spec, it seems to say that coded frame eviction will take place only after appending to the SourceBuffer, so we could potentially run removeNonBufferedSegmentCues on the append handler, and then remove all the buffer checking nonsense from minBufferedBytes and maxBufferedBytes, which would be fucking fantastic.\n:six: The section you highlighted doesn't repeat. That first call to safeBackBufferTrimTime is actually inside an else block.\nTrixy hobbitses, I know.\n\nMy questions/comments about your approach:\n\nSo you're saying the SourceUpdater would trigger on the SegmentLoader which would trigger on the MPC? Also, you don't need to pass those values since they're accessible by the MPC, but that's just some pedantry.\nTrimming means you have now invalidated your maxNumberOfBytes and maxNumberOfSeconds. Always adjust your maxes before trimming.\n\n\nuse the maxNumberOfSeconds to determine whether we need to set a new goalBufferLength value and maxGoalBufferLength value\n\nWhen would this not be the case? We're never going to buffer more than forwardBufferGoal + backBufferGoal. So we'd never hit a QuotaExceededError where we don't need to adjust the buffer sizes.\n\nprioritizing having more seconds for the forward buffer than the back buffer\n\nHow would you do this? A sliding scale like GBL? Currently I'm doing newBackBufferGoal = 1/3 * maxNumberOfSeconds and maxForwardBufferGoal = 2/3 * maxNumberOfSeconds.\n\nWe only need to set a new one if the maxNumberOfSeconds is very close to or less than the current goalBufferLength value.\n\nAs explained above, it's impossible to have a QuotaExceededError and have more time in the buffer than the GBL, since it determines scheduling of downloads.\n\ndon't change the goalBufferLength after this if the maxNumberOfSeconds does not change.\n\nWhy would trimming the back buffer cause maxNumberOfSeconds to change? Unless you're saying, just remove the buffer readjustment that I am doing.\n\nif we are unable to remove enough from the buffer to download a new segment, we must error, we cannot recover as the segment sizes are too large.\n\nWe only know we're screwed for sure if we've stalled AND the next segment will bust the buffer, since any advancement of the playhead may result in us being able to trim some more back buffer. We do know, though, that if we try to readjust the back buffer, and we're already at a target duration, then we're in danger.. Updated some code, haven't updated tests.. Travis is switching to all non-containerized infra, so this PR is no longer relevant.. derp derp, thanks.. attributes being undefined was fixed in #1214. You do still need to change to dot notation though.. I feel like bitrate is a bit ambiguous here. Without seeing the code, I'd probably assume it would be the same thing as bandwidth. I think I favour dropping it for clarity's sake since it can be calculated from the other values. Is there a reason you're including it, other than convenience?. For reference, the PR to include the required information in the segment metadata is #1210.. Sure, if you think that's descriptive enough, I'm fine with changing it. . Good point, not sure why I did it like that.. Care to elaborate? This test exists to make sure the dynamic GBL works as expected after a seek. I'm making the assumption in this PR that a seek will clear the buffer, so we should treat that as if we've started fresh. So here I'm seeking via setCurrentTime and testing to see that GBL responds in the same way as it does when starting from a fresh playback.. Same comment as above.. Consider seeking to a time which is right before a segment ends. The segment will download and be appended to the buffer, and you'll seek within that buffer to right before its end. Without this, I imagine the rate selection logic will abort the download for the higher rate since the buffer is so low.. Yeah, it's hard to think of a good name that's not super long. I'd say maybe like a timeSinceEmptyBuffer but I'm not sure that accurately encapsulates the purpose of the function.. Ok, I went back and verified the behaviour to make sure I clearly remember what each change does. In short, the GBL change makes the time spent at a lower rate smaller, and the noAbortsUntil removes it completely. So, even though they're disjoint, without the noAbortsUntil addition, there's still a drop to the lowest quality when seeking.\nI'm gonna use the example above again but go a bit more into detail about what's actually happening so you can understand what's actually changing.\nCurrent behaviour\n(playing at high rate)\n-> seek to right before segment ends\n-> ABR selects the lowest rate because buffer is so low\n-> player buffers a few segments (6 in my case) at lowest rate\n(playback resumes after 1st segment complete)\n-> player starts buffering higher rate segments\n(resume normal behaviour)\nWith GBL change\n(playing at high rate)\n-> seek to right before segment ends\n-> ABR selects the lowest rate because buffer is so low\n-> player buffers 1 segment at lowest rate\n(playback resumes)\n-> player starts buffering higher rate segments\n(resume normal behaviour)\nWith noAbortsUntil\n(playing at high rate)\n-> seek to right before segment ends\n-> ABR selects current rate because of noAbortsUntil\n-> player buffers 1 segment at current rate\n(playback resumes)\n-> player starts buffering higher rate segments\n(player stalls because it can't download the next segment fast enough)\n(playback resumes when the next segment finishes downloading)\n(resume normal behaviour)\nNotice the tradeoff with the noAbortsUntil -- that the player stalls.\nI considered the changes \"omnibus\" because in my mind I was trying to fix the downswitch in quality when seeking, which required the noAbortsUntil. But I have no problem separating them -- I can see why the noAbortsUntil change would be contentious, and the behaviour is still improved with just the GBL changes.\nLMK what you think is best.. It's semantically equivalent, but I'm wondering why you didn't include this as an else in the clause above. i.e. if use local storage, grab it, otherwise set the bandwidth from a constant.. ah good call. So... is that a \"yes, split them up\"?\nSetting minimumTimeSaving to be a segmentDuration for 2 segments after a seek would be a clever way of keeping the same rate but still aborting on too-long downloads. Of course, if you did get an abort, you'd still be kicked down to the lowest rate; the playlist selection logic will always choose the lowest rate since it'll have the least rebufferingImpact.. Removed the noAbortsUntil_ stuff. Renamed to elapsedTime.. I guess we should probably QUnit.skip when running on Safari or something... . The forward buffer scales with time, so at the beginning it would be 60 (GOAL_BUFFER_LENGTH + BACK_BUFFER_LENGTH) and after playing for a bit it would be 90 (MAX_GOAL_BUFFER_LENGTH + BACK_BUFFER_LENGTH).\nThe constants could probably use some renaming to make them more clear :). Err could you clarify what you mean? You expected the Length part to mean bytes instead of seconds? . Indeed! I just used the values that were already in the code.. According to this jsdoc page, that's Google Closure-style optional notation, which is used elsewhere in this code base. It's optional because it functions as both the setter and getter.. Right, I guess since the bufferLowWaterLine is never used for media that's shorter than the max, a smaller water line due to a QuotaExceededError would be irrelevant. . > shouldn't this be the max?\nNo. The Math.min guarantees that if we have to shorten the buffer due to a QuotaExceededError, it never enlarges again. It may not be strictly necessary, but I opted for safety.\nIf it was Math.max, the maxGoalBufferLength would never change.\n\nFurther, why is the maxGoalBufferLength changing at all?\n\nThe buffer lengths are adjusted so that we don't keep calling the event loop. If we don't adjust the buffers, then checkBuffer_ gets called way more frequently, and just keeps exiting without downloading because it would see that the next segment would bust the buffer (in terms of bytes). Adjusting the buffer sizes means we can actually meet the desired buffer length, and cool off the checkBuffer_ calls.. Yeah alright, that makes sense to me. . Just to hopefully clarify, when using this function as a setter, you're saying that's the largest you ever want the return of goalBufferLength() to be. It could be smaller, but it will never be larger.\nIt will be smaller if initial + currentTime * rate is less than the max. The buffer length and the water line scale up over time from start (t=0) to some time later (t=n). goalBufferLength is the value at t=0 and maxGoalBufferLength is the value at t=n.. Correct. Do you think that's a problem? I figure once we hit a limit because the segments are too big, it makes sense to keep that limit in case we're experiencing bandwidth fluctuations since we could jump back up to the rate that caused the decrease in the first place.. Exactly. This ensures bufferLowWaterLine() <= goalBufferLength will always be true.. The third option would involve coding media-sources to pass the GOP timing info to contrib-hls. Option 3 wouldn't be possible without that message passing. Which I could do, I just... opted not to do here. It is my intention to have GOP timing info available when this PR is ported to VHS, so that we could chop as much as possible when desired.\nAs I said in my latest wall-of-text comment, I'm very much looking for feedback on what should prioritized regarding forward/back buffers. Do you think forward buffer should always be prioritized over back buffer?. full disclosure: I have no idea what the seekable range means. I don't think I ever entered this code path when dealing with this PR.. oh wait lol, sorry I misunderstood your comment, that's exactly what you meant. Any suggestions for a rename?. I don't think it's possible to know that frames are being dropped, but I'd have to research it more.. Oops, good catch, should also be added to dispose. Oh actually, I'm not sure the segment loaders are re-init after they're reset. In any case, I'll do some checks and make sure the event handlers are being removed when appropriate. . Since the only byte information we have is at the entire segment level, if our buffer size ends up not locked to segment boundaries, it's unknown how much data we should include from that partial segment. So we have minBufferedBytes which excludes it (and gives us a lower bound), and maxBufferedBytes which includes it (and gives us an upper bound).\nSo here, we're getting the upper bound for the amount of bytes in the buffer.. Correct. Note that if this is 100% effective always, we wouldn't need min/maxBufferedBytes as we could always be sure that we have no partial segments in the buffer. But, from my testing I wasn't always sure that's what was happening.. You are correct. I believe I followed the syntax that was already present.. I do believe it gets transpiled by Babel correctly. IIRC most (all?) of this project doesn't use template strings so I avoided it, but if you consent then I will happily use them :grin: . Correct. I think this is a reasonable assumption to make on the browser's part (that it will never increase the size of its buffer).. Because it's maximum allowable forward buffer, not largest possible forward buffer.. yeah, or just plain forwardBufferLength. It's used by the source updater to trigger things properly. So it's needed unless you came up with a way to not use deferredCallback_ in the SourceUpdater.. :man_facepalming: . This is inside the tryAppend function.. Please elaborate?. Can't, unless you're suggesting I also make pendingAppend and timeupdateHandler properties of SegmentLoader. Yeah that sounds right, in which case I think any numerical comparison would fail, no?. Added comment that it's calculating the moving average (I know, it's hard to understand when you first see it). It would not. getBufferedBytesUpperBound would be, though.. I think you should consult #1147 and #1134 since I am merely integrating with pre-existing functionality. My understanding is that the way things are currently working, is the desired behaviour -- abstracting away a growing buffer goal. The other members of the team who made that functionality are probably in a better place to answer your more in-depth questions than I am. \n\nDoes that mean that both the goalBufferLength and maxGoalBufferLength are exactly the same?\n\nYes.\n\nIs that ideal?\n\nThere's no room left to scale, so... :man_shrugging:  I think that's another question for the original authors.. Even if another part of the code tries to make the buffers larger, the Math.min will prevent it. This is what should be happening. While it's true that you'd expect an actual setter to always set the value, this is not an actual property setter.\nIf your argument is semantic -- that a thing that looks and sounds like a setter should behave like a setter -- then I understand where you're coming from. They could, I suppose, be split into functions like getGoalBufferLength and safelySetGoalBufferLength (or better named versions) to break the semantic paradigm, if you think that would avoid any confusion. However, I don't think changing the actual underlying behaviour would be beneficial -- that safety is important for proper functioning. . Precisely. With fixed values, the low water line could never be less than the target buffer length. But since the target buffer length is now dynamic, we need to make sure that bufferLowWaterLine() <= goalBufferLength.. Just a note here that after some discussions on slack, forward buffer should indeed be prioritized. I would say that is done as much as possible here, without having access to the GOP timing info.. Ah, ok. I'm not sure it's reasonable to assume there will never be 4K live streams. I guess I should try to test with one.. There's a symmetry in meaning between goalBufferLength and backBufferLength, though -- both refer to the amount of time that should be \"kept\" for a buffer.. Do you think a change to the jsdoc to explicitly point out that it's a measurement of time would be sufficient?. > So in the above we're saying \"I'm guessing we were able to fit the whole last segment in the buffer\"(bufferedBytes) \"now see if we can fit the next one in without going over the maxBytes\"?\nI'm not sure what this has to do with the last segment...? What happened in the past is irrelevant, it's strictly based on the amount of bytes currently in the buffer. We're just testing if the next segment request (nextSegmentSize) will push the (worst case) amount of bytes in the buffer (bufferedBytes) over the maximum amount of bytes allowed in the buffer (maxBytes), which was calculated from the amount of bytes in the buffer when the QuotaExceededError happened.. And you think the additional complexity would be worth it?. changed to:\njavascript\n      // the first append caused a QuotaExceededError, so don't adjust buffers. safety.. Err, yes, if you take forward buffer to mean buffered time ahead of the playhead. But here we're just using math to calculate what the buffer targets should be. So if you'd prefer, I can rename them to have goal in their name.. forwardBufferGoal, backBufferGoal and totalBufferGoal may be more understandable here.. Sorry, I don't understand what you mean. In (forwardBuffer / configTotalBuffer) * secondsInBuffer, secondsInBuffer represents the new maximum total buffer, as it's the amount of time we had in the buffer when the QuotaExceededError was thrown. So, we just do simple ratio math. (oldForwardBufferGoal / oldTotalBufferGoal) * newTotalBufferGoal === newForwardBufferGoal.. Your suggested name changes have been helpful, but I don't think I can get on board with this one. networkIdealMaxForwardBuffer really makes me scratch my head. What does that have to do with the network? And why is ideal there?\nI would strongly prefer something like the newForwardBufferGoal I put above.\nThat being said, I do entirely agree that max is very ambiguous here.. Yeah, that's a very good point actually. Do you think forwardBufferGoal is too ambiguous? I guess forwardBufferGoalSeconds would be super explicit about what it is.. - Append blocks any future requests until its updateend handler is called\n- When the QuotaExceededError happens, we unblock only the source updater (by nulling out pendingCallback_), but nothing will still happen automatically since the updateend handler has not fired\n- In handleBuffersMaxed, we never call an append before a remove\n- Therefore we'll never have tryAppend fire from an append, it will only be fired from a remove. bytesTrimmable is the amount of bytes that we can remove from the back buffer. So we're just checking if the segment size is less than the amount of bytes that can be trimmed.. Refactor to use the properties on Hls (see this). This must exist to handle errors thrown by fmp4 streams (where media-sources is not used).\nAdded the error checking.. IIRC simply removing || this.pendingCallback_ from here caused problems, but I'm open to trying it again.. It's the target for the number of seconds we want in the buffer.\nIf it's really causing that much confusion, I think we should just rename it and have goalBufferLength throw a deprecation notice and call the new name.\nNow that there's many similarly-named things (and you've suggested adding forwardBuffer and backBuffer to the mix), it's probably worthwhile to just s/oldNaming/logicallyConsistentNaming/g and deprecate as appropriate.. Impossible to explain in the first line. Generic\n\nHandle a call to appendBuffer that failed \n\nFollowed by a paragraph explanation. . Made it a Config, though maybe that was a step too far.. The idea of the dangerZone is that it's one last hail mary to try to unblock the append. Unfortunately, it's pretty much worthless without GOP slicing, since if you're operating that near the threshold of getting stuck, your back buffer is probably already at its lowest possible value -- a target duration.\nIt removes any whole segments that are within the time range [0, currentTime - targetDuration].. I mean, just follow through the code. You'll see that this.state is READY whenever it's idle / ready to do things. Of particular importance:\n- Don't download new segments if our state isn't READY\n- Set state to APPENDING when we have data to append to a buffer\n- Set the state to READY on updateend\nIf you follow through all of them you'll see that the state is reset to READY in a number of circumstances.\nIf we didn't reset to READY, a seek would do nothing because no segments would be downloaded and it would just be stuck forever with no buffer. So this reseteverything handler must be done to ensure that it works in all playback scenarios, like seeking while there's a pending append.. It's just saying that if our passed start or end are outside the current buffer period's start or end, to use the buffer's start or end.. Yeah basically, protect against stupidity or whatever I guess.. Can't modify an array while iterating over it.. Probably.. (I said this because your solutions seem to imply that requirement). ",
    "BrandonOCasey": "Yeah the flow would probably be similar to what is outlined there\n. Did this already get merged with #670?\n. merged to development https://github.com/videojs/videojs-contrib-hls/commit/b0caca889d322bd5c51ccd18b3c7497b6195d1c0\n. it will have to be moved into https://github.com/videojs/m3u8-parser as this code was recently moved there\n. closing as this code has been moved out of this project\n. @dmlap maybe I am just missing something but some of your comments are not attached to any lines in the playlist-loader.js file. (Mainly the duplicate assertion and comment placement comments) are what I am concerned about.\n. see #689 \n. @dmlap I will look into putting the order back to the way that it was or finding out why these things changed\n. LGTM\n. I think we will leave changing the logic to loadedplaylist for another PR. I will work on addressing the other concerns. Thanks for the review!\n. seems like this needs a rebase on development\n. Once #619 is merged we should try to get the skipped tests in Segment Loader and Master Playlist Controller working for this PR\n. tests? or are we just trying to get something working for now?\n. This still needs tests but is waiting on #619 \nEDIT: All tested and ready to go, rely's upon PR's in mux.js and MSE\n. ok so ultimately I decided that it would be good to force us to make sure that we are logging. So I mock the log as a did previously and on this.env.restore() we verify that log functions were called 0 times. I added a getter to the log stubbing that will reset it to zero. Basically if you check how many calls happened with that then we know you checked (I guess you could still throw it to the void but CR's would catch it).\n. see #651\n. @dmlap we have tests to verify that mode and withCredentials options will work when passed in with a source, or passed in globally. I am not sure what your first question is asking. \nEDIT: do you mean which option should be used in the case where we have both? If so in my option the global option should be overridden by the source option. I will add tests for this if that is what you mean.\n. Travis was failing in my last commit as it seems Chome just dropped support for Ubuntu Precise, so I changed the travis.yml to get it working again. here is a link to the issue on travis https://github.com/travis-ci/travis-ci/issues/5899\n. @imbcmdth changes made, ready for a re-review\n. I am going to close this PR, as I think we are going to go another direction with this\n. im not sure @imbcmdth @dmlap \n. see #686 \n. LGTM\n. @dmlap let me see if I can explain how I interpreted what you said. You tell me if it is inline with what we want to do. \nWe want the stat events that I currently have implemented to keep being fired. Rather than having the stat event carry data we store the data on SegmentLoader. The object that is listening for the stat event on SegmentLoader will grab the stat from the instance of segment loader that fired the stat event.\nor\nGet rid of all events, store the stats on each segment loader. add a method on MasterPlaylistController to get all of the combined stats for SegmentLoaders. Call that function on HLS when we need to get stats for analytics.\n. @dmlap I rebased and removed the get prefix from those functions\n. the travis build is stalling after unit tests pass??? EDIT: Seems to have been fixed\n. will do\n. @gkatsev seems like the only one that was missed was the one for watch:js:browserify\n. I am of the option that we should say that 2.2.0 requires videojs 5.10.1 and up, as I think trying to null check AudioTrack would end in lots of specific code to handle the usage of a non-existing HlsAudioTrack class. What do you think @imbcmdth?\n. ~~GapSkipper.js should probably be gap-skipper.js to fit in with the common file names of the files in this project~~ EDIT: this is done\n. @dmlap any suggestions on a name other than adaptive seeking? \nMy idea is to turn the adaptive-seeking event into a playbackstalled event. Then maybe just call the adaptiveSeeking function gapFound or skipTheGap or something like that\n. @tenacex any more progress on this PR?\n. LGTM\n. just need doc comments and that that thing about combining the if statements and I think your good to go. More info on doc comments or you can just look at a file that has a class in it and copy the formatting.\n. Once that doc comment is fixed LGTM\n. LGTM\n. see #735\n. I think that I fixed this in a more recent version of HLS, what version are you currently using?\n. 2.2.0 was recently released with a fix for this issus and a few others as well. You will need to use video.js 5.10.1+ to use 2.2.0+\n. Did 2.2.0 resolve your issue?\n. OK awesome! I am going to close the issue, if there are any other issues related to this feel free to comment or re-open\n. LGTM\n. LGTM\n. LGTM\n. LGTM as well (pending tests)\n. I think that you will have to wait for the loadedmetadata event on the player before player.hls.representations will be available. Example:\nJavaScript\nplayer.on('loadedmetadata', function() {\n  // player.hls.representations should be exist now\n});\n. once this is tested I will merge this PR\n. #788 \n. LGTM\n. linting should be resolved by #788\n. As long as you have video.js and HLS included in your page you should be able to use it like this (from the examples in the README). basically we initialize the player, and the call player.src with src set to a url and type set to an hls source type.\n``` JavaScript\nvar player = videojs('some-video-id');\nplayer.src({\n  src: \"http://solutions.brightcove.com/jwhisenant/hls/apple/bipbop/bipbopall.m3u8\",\n  type: 'application/x-mpegURL'\n});\n``\n. we will have to find out if this is an HLS issue or a general video.js issue. https://github.com/videojs/video.js/issues/3466\n. I think I created them all and added all of the files for them. Thanks for bringing this to our attention\n. HLS on npm does not contain all of the files needed to build it, and I think that is why you are seeing the error. You can checkout a release tag from the git repository (probably the preferred way) and then runnpm link in the project that you are trying to use it in. If you need any more info on this feel free to re-open this issue!\n. LGTM\n. also does this fix #816?\n. LGTM\n. Did you change thetechOrder` to force flash playback on ie11? Its currently a know issue that some implementations of IE11 in the wild have issues with HLS playback in HTML mode.\nHere is a better example of forcing flash (just in case):\nJavaScript\nvar player = videojs('my-video-id', {techOrder: ['flash']);\n. seems like #785 may be related to this\n. LGTM\n. It is a known issue that IE11 has problems playing HLS video in HTML mode. We suggest forcing Flash mode (which we don't do in the demo page but probably should)\nhttps://github.com/videojs/videojs-contrib-hls#known-issues\n. please answer all of the questions in the ISSUE_TEMPLATE\n. not sure why a test is failing, doesn't seem related to anything I did...\n. should we just set this back to the original playlist selector rather than deleting?\n. * I'm not sure that registerComponent call is actually needed I commented it out and HLS seems to work (the index page demo at least)\n* We have to change the reloadSourceOnError plugin from a video.plugin to videojs.registerPlugin to prevent a deprecation warning. @gkatsev you will also have to change addTrack_ to addTrack on vjs6 https://github.com/videojs/videojs-contrib-hls/blob/master/src/master-playlist-controller.js#L217. Also a lot of the unit tests are failing on vjs6,. this PR should also include videojs-flash as a dev dependency so that flash tests can always run. vjsstandard (linter) complains about directly using undefined, not sure why other than that\n. right now we just lint ':' which pretty much means lint nothing.\n. I think we have all these files so that you can test one specific browser at a time example: \nnpm run test:chome. \nThere is also a \"detected\" file which will detect which browsers you have available and test on all of them. This is the main thing that will run when you do npm run test.\n. moved it with all the other files that were not specifically unit tests\n. yeah dist is the only thing that we will need to include in the future. Right now it only contains stub.js (which adds our objects to HLS directly so that the unit tests will still work), m3u8, and stream. As we go through the stages things will be removed from here and into that dist file.\n. stub.js will be removed on the final part of these pull requests and videojs-contrib-hls.js will be set as the main file again. stub.js is the main file for now because it allows us to keep all the unit tests passing by stubbing old functionality (adding m3u8 to video.js and Stream to videojs.Hls and more as the PRs go on).\n. I thought about this as well, I just was not sure how backwards compatible that was.\n. i was running into issues in a few of these files related to tests not cleaning up after themselves when they modify the global, or redeclaring the global in their scope (and the linter complaining that the variable was already declared). I have also had problems with tests in the past that use globals which caused future tests to fail/pass making it very confusing to debug. the generator also generated several tests that all used this. so I assumed that was the way we probably wanted to go.\nThat being said I am not opposed to reverting it to not us this.. It just seemed easier to reason about tests if there was no chance that scope would leak.\n. The old unit tests only ran against Chome/Firefox and when I attempted to run them in safari they all failed. Once I updated the code I tried to run them again and they failed, so I turned off safari. Safari does launch and run, but a lot of the unit tests fail.\n. I will change the name of this file as It makes a lot more sense\n. this has been fixed\n. I think changing it makes sense. Only precompute once, and only do it when/if we need to. Any other time AES is called we will use the tables that has already been precomputed.\n. haha its my own fault :)\n. yes\n. yeah it should be much faster\n. well we made the function local to the module in this case, and we don't export it so essentially it is private now. My gut feeling on the prefix with _ rather than postfix _ was probably from a copy paste.\n. added\n. added\n. yeah from the main videojs-contrib-hls file\n. yeah I will submit another PR for the reorder/refactor stuff\n. It will look like this: \nJavaScript\n  {\n    language: '',\n    label: '',\n    enabled: true,\n    id: '1',\n    kind: 'main',\n };\nmaybe default would be better wording here?\n. I think that we were having difficulties with webworkify not quoting the default key and it causing issues at parse time. I don't think we have a work-around yet so I quoted it just in case.\n. yes\n. will deepEqual work with Object.defineProperties?\n. I think that some of these unit test changes may have been from an old version of my-rebase, as I did not change any of them. I will look into this.\n. well in our case we would also not be quoting a key called default and I don't think IE would like it but I can test to make sure.\n. yeah deepEquals will not work quite right as AudioTracks are an object with lots of functions and internal variables etc.\n. Yeah I don't think that AudioTracks or VideoTracks should actually require/need tech_. We will have to get rid of that requirement in video.js\n. the problem comes in when we set an audioPlaylistLoader_ to null. which sets an entry in audioPlaylistLoaders_ to null. Then when we go to switch back to the audio a second time there is no PlaylistLoader to use for that track. Maybe we could not create all the playlist loaders at the start? and only create them when we use them?\n. at first I thought we could watch for it in hls and then update video.js audiotracks. but it turned out that that was the wrong event. I will remove this line good catch.\n. yeah your right not sure what I was thinking. Will be committing an actual fix in a minute or two\n. from what I understood we only did that when we used var to declare all variables at the top, comma separated. I don't think we need them all to be at the top with let.\n. Not picky at all, they will actually have the same value here, we can just re-use that old variable, as they will both return the same video.js tracklist (it never gets deleted or re-created just cleared out)\n. should we add a warning log in some cases here rather than just a return? (but only do it for the ones that make sense)\n. I will just change the name re-use over the scope won't work to well. I guess I misunderstood.\n. from the api it is possible, but I am not sure what we should do if it actually happens\n. clarified that we will do the same in the same comment this line points to\n. didn't know you could do this! Awesome\n. Should we still be skipping this one? Not that you have to add it back in right now, just curious.\n. Type comes before parameter name and is followed by description (not that its really needed in this case) so it would look something like this. (some of our current doc comments do it backwards, which I will fix later)\nJavaScript\n/**\n* Calulate the intersection of two TimeRanges\n* @param {TimeRanges} bufferA the first buffer\n* @param {TImeRanges} bufferB the second buffer\n* @return {TimeRanges} The intersection of the two buffers\n*/\nWe may also want to add in @private for this function, unless we expect the outside work to modify or use this function.\n. same as the previous comment https://github.com/videojs/videojs-contrib-hls/pull/629/files#r58073036\n. Maybe it personal preference here but its nice not to have so many spaces between lets.\n. same as the previous comment https://github.com/videojs/videojs-contrib-hls/pull/629/files#r58073036\n. do we want to log some kind of warning here?\n. why oldRequest here?\n. ehh I think oldRequest works when I look at it some more. The only other thing I could think of naming it would be req\n. we need to change the rest of the variables in this scope to timelineUpdated or change this variable to timelineUpdate\n. I think we may be able to get rid of this issue without silencing the log, took a few minutes to narrow it down, I will write a test around it to verify that nothing changes basically it involves the depreciation warning when we use player.hls. when we were checking if player.hls existed when it did exist we inadvertently called it and caused the warning to showup.\n. :)\n. seems to work on Firefox/Chrome\n. your right, I will mention in in the README instead\n. OK I removed the edit in the maat docs and added a known issues section to the README\n. It would I think I have a more backwards compatible solution, I will submit it shortly\n. We do need IE8 to not throw an error when loading the script though. I can do some testing to verify that we need these. When we were working with webworkify they added an unquoted parameter called default that would error throw an error on IE8 while loading the script.\n. Right now don't have an api for an audio button yet, and we don't have anything in the official API on video.js to disable or mark a track as bad. Do we want to change this functionality when something like that comes around, save this PR for later when we can get an API addition, or do something else that would probably be slightly hacky.\n. Basically so that we can call blacklistCurrentPlaylist without passing an error which we only used for the error.playlist value anyway. I can switch it back to not using the default but then I will just be doing the same thing the code does when it finds that error has no playlist:  currentPlaylist = error.playlist || this.masterPlaylistLoader_.media();\n. agreed it is rather confusing\n. well we do log an error, with lots of detail in the console\n. Well if we get here with a with videojs.options.hls.mode = 'flash' but the tech is currently html and we were passed mode = 'html' by the HlsSourceHandler a MediaSource error will be thrown, so we only ever want to use what HlsSourceHandler passes us.\n. well we don't have this.options_ at this point and this.options_ is used in the src() function\n. we do, I will add some code to loop through and dispose them\n. good call will replace with something else\n. We probably don't want to do it as it will be changed in #661\n. @gkatsev in video.js thats the case, but this is a different list stored on Master Playlist Controller\n. I will implement the properties using Object.defineProperties as that sounds better.\nThey don't have to be custom properties, but I think that it makes it more consistent since they should never change, and since AudioTrack in video.js uses custom properties for everything already. \n. nulling the field would not actually remove the key from the object. Unless I am thinking about this wrong.\n. well object level options don't really exist atm, unless that PR I mentioned in the comment above was recently merged.\n. you cannot override mode as a source option, it won't work because the tech that is being used has to be the mode we are in. So if you are using HTML tech and you do player.src({mode: 'flash'}) things would break because we can't use Flash mode with HTML tech. maybe there could be a way to do it in the future but I don't see it right now.\n. This would restrict when the mode can be overridden. It would have to be done before the HLS script is even loaded in your case. Which I am not so sure we want.\n. My comment was really talking about your second comment, but it was admittedly badly worded. Your first comment is correct and something that needs to be checked for.\nYour second comment, where we avoid registering the HlsSourceHandler if the mode settings specifies not to, would force anyone who uses the project to declare mode overrides before we load the HLS script. This is due to the fact that we register HlsSourceHandlers in the main body of the script\n. yeah that makes more sense\n. made them private\n. Originally it was at a lower level but it ended up with HLS trying to revert data on MediaSources which was a big jump. So it was determined that we should just fire 'audioinfo' every time we get it, and have the objects that care about the event act on it. In this case HLS.\n. we can probably just use the property\n. sounds like a better solution to me\n. I don't think it should be, I could change it back to what it was before\n. Yeah I don't think its possible to test that loaded metadata fires without using real data, and I am not sure that a unit test should cover that scenario.\n. Not a good reason, but I kept it around so that I could listen to it for one of the tests in videojs-contrib-hls.test.js. We can probably remove it \n. I think we should yeah\n. not in this implementation but it will be, talked to Jon about it the other day\n. makes sense to me\n. do we want to return maybe/probably here rather than a boolean? EDIT: never mind the code above this does that for us.\n. Maybe to prevent confusion we should still return false in this function, since empty string is going to be used as false in this case, and since we return a boolean below anyway. EDIT: either that or have this function return empty string/maybe so that it can be used like that wherever it happens to get called like line 523\n. maybe to cut down on typing put video.canPlayType in here? doesn't really matter though\n. doc comments appear to be backwards (endSequence {number} should be {number} endSequence) also you can signal optional by putting and equal sign after the type decleration ie {Number=}\n. good catch\n. the same is true for any other global configuration though, I could see setting GOAL_BUFFER_LENGTH back to default on HLS dispose but on src change I think that global options should remain at what it was set to. We basically need HLS and SegmentLoader to share the value somehow so I went with this as it did not seem like we wanted to use crazy getters and setters.\n. I would rename this file gap-skipper to be more in line with the other files in the src folder.\n. I also think we wanted to use this more like a plugin for video.js https://github.com/videojs/video.js/blob/master/docs/guides/plugins.md\n. I would register the plugin below, where we do videojs.registerComponent\n. gapskipper should be an instance to player so you can probably just do this.tech_ inside of it\n. comment is no longer needed\n. where does the 'adaptive-seekingevent come from?\n. player should emit all tech events so you probably don't even need tech\n. You should be able to register this at the bottom where we do videojs.registerComponent\n. we should probably make this a class/object rather than using module local variables\n. we should probably trigger this on the new gap-skipper object rather than on the tech directly\n. player should fire this event as well we probably don't even need to use tech in gap-skipper\n. player should fire this event as well so that we can remove tech usage in gap-skipper\n. we should move this line outside of this if check, maybe even into the src function of HlsHandler\n. it would probably be good to have a file just for gap skipper\n. make the plugin a function that uses a gap-skipper object\n. you may just want to make this a method of seeking object so that you don't have to use a global reference\n. this should probably be a const rather than being defined above, also I don't think it takes any options anymore. \nex:const gapSkipper = function() {. The same goes foradaptiveSeeking. I would add this to the top or bottom of the constructor rather than in this if statement, as it no longer needs to be here. You also don't need to pass it an empty object.\n. this line needs to be removed\n. I wouldn't store a reference to player or tech here I would just use them directly. Then you can makeadaptiveSeeking a method of seekingObject and have access to it as long as you use() =>rather thanfunction() {\n. I think that you should make seekingObject extend videojs.EventTarget so that it can fire this event itself rather than firing it on the tech\n. we may just want to pass the tech to segment loaders at some point, just a note. I don't know if we want it in this PR\n. Needs doc comments\n. yes and an m3u8 source \n. Remove lastRecordedTime and adativeSeeking as they don't seem to be used.\n. declare the object here rather than in the module scope with let aka\nJavaScript\nlet seekingObject = { player: this\n...\n. we don't need this first import\n. does videojs.gapSkipper also call this function? if so we should call gapSkipper somewhere else. Preferably towards the bottom of this constructor.\n. it is being designed so that we can pull it out of HLS and have it stand on it's own if needed\n. these should line up with the player variable above\n. any status on this?\n. Can we get a test for seeking into a gap?\n. use arrow functions () => to pass this down a scope rather than defining this as self\n. we don't have to extend EventTarget as we are not emitting any of our own events\n. this file could probably use doc comments similar to the rest of the project\n. I would return from the function if we are seeking so we don't have to wrap so many this code in so many if statements. Example:\njavascript\nif (this.seeking) {\n  return\n}\n. remove Adaptive seeking from the test name since we are not using that name anymore\n. Call this module GapSkipper\n. remove Adaptive seeking from the test name since we are not using that name anymore and it will be covered by the GapSkipper module name above\n. you can probably do the same with this if statement and the next one as well\n. for the next two if's you can check the opposite of what they are checking and return right away\n. you may even just want to declare all the variables at the top and combine all of the if statements\n. if this is private you should add an _ at the end of the name\n. need to add an @param for options\n. Should be @param {object} options an object that includes the tech and settings\nSpecifically the parameter name comes after the type\n. I think you can actually pass an array of events to on, so we won't have to loop over them here.\n. Should GapSkipper have a dispose function that gets called by HLS?\n. Debugging code! NICE!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n. doc comment spacing is off for all of the functions in this file\n. maybe add in specifics about firefox and the issue on their board here?\n. maybe merge this if statement and the one above it since they do the same thing?\n. merge these two if statements as well (since they both only do a return)\n. something tells me the linter doesn't like the length of this line...\n. yeah, it could have been it it's own PR but it doesn't actually change anything since the setOptions_ call above runs the same code.\n. I think there was talk of doing posttest linting rather than pretest linting\n. ahh ok\n. The build shows that it works. I think that import window from 'global/window'; makes sense too and if you have a strong preference to it I can change it. I think we use it similarly in other projects. I don't really like import window from 'global' as it may be confusing since global can be used to require more than just window.\n. ok I agree and will change it to that\n. Shouldn't this have just been changed to this.tech_.textTracks().addTrack(this.cueTagsTrack_); rather than removed?. the foo is strong with this one :). ",
    "mjneil": "This is happening in #1064 !Keep an eye on the PR for updates. Closing this issue for now.. I've got some (hopefully) good news for you all. I've created webwackify, which is basically the webworkify and webworkify-webpack-dropin projects combined into a single module. I've got an experimental build of videojs-contrib-hls using this project and it can be bundled with browserify and webpack with no extra config options as seen in this example project.\nHowever, this example is extremely basic so I was hoping some of you could try out this build without the tricks mentioned in this thread and see if it resolves the issues you are having. If successful we can bring this in upstream.\nThe build has been published under the qa tag as version 5.12.3-rc-1, and you can install with\nnpm install videojs-contrib-hls@qa\nor you can specify the version directly in package.json\n\"videojs-contrib-hls\": \"5.12.3-rc-1\". Has anyone been able to give the build in my previous comment a try? Would really appreciate any feedback on whether it works in any of your custom builds or what breaks.\nPinging a few people that have been active recently @rparjun @MCDELTAT @AndrewKirkovski @brainthinks @jide @gregorskii . Thank you @rparjun @alexandrzavalii and @kapersoft for testing it out and confirming it works. v5.13.0 of videojs-contrib-hls has been released that include these fixes! Anyone looking to support webpack should upgrade to 5.13.0 and should be able to include the project without extra webpack configuration.\nI am closing this issue as resolved. Please reopen the issue or create a new one if you experience any issues after updating.. @ffischetti it looks like its the way react activates the css-loader is causing issues, its using the inline with json object options method. Looks like the keys of that json options object have \" that are not being escaped by webwackify. I'll get started on a fix, it doesn't look like it'll be too difficult. @ffischetti this should be fixed in v5.14.0. LGTM\n. Closing in favor of #804 \n. Looking into this more, the way segment loader currently handles being paused and unpaused is a big part of the reason why aborting before pausing solves this. We could change the state logic within segment loader to allow a paused state. This would make the state of the segment loader much more clear and hopefully less error prone in the long run. I have a branch with the proposed state changes here. The race condition is the above fixes no longer appears regardless of the order of calls with the more defined states.\n. Calling pause in the init states doesn't have an effect and will stay in the init state. The loader is still initializing and does not have all the information needed to load segments.\n. PRELOAD is similar to INIT. Both require a SourceUpdater and a playlist. When in the PRELOAD state, the loader will begin fetching segments as soon as both have been set, where as in the INIT state, a call to load() is required even after both have been set.\n. @gesinger Is the suggestion that calling pause would abort the current process and pause from future loads instead of just pausing from future loads? Once we send the segment to the source buffer for appending, PAUSE can no longer be an immediate action since we have to finish the processing of metadata post append. The current issues with the loader are not during this time period so this is ok, however we would either need to keep some notion of a PAUSING state or go back to not having PAUSED or PAUSING be an explicit loader state. \n@dmlap yes, with the slight difference of not having a SourceUpdater or playlist. If we go with @gesinger's suggestion with taking PAUSED and PAUSING back out of the states, we can make the INIT state more clear.\n. lgtm\n. lgtm\n. lgtm\n. This should be updated to work like the contrib-media-sources pull request\n. Would you be able to provide a link to your playlist that causes this?\n. There is a good chance this is realted to BaseMediaDecodeTime being a 32 bit value rolling over at around 13 hours. There is a pull request that is still in review to switch to version 1 tftd boxes. @SuriGill can you try using the PR to see if it corrects your issue?\n. @piotr-cz It is currently unreleased in master. I'm not sure when the next release will be but it should be soon. Can you provide your source playlist.m3u8?\n. I think the latest version of contrib-hls 3.6.5 fixes this problem, can you try and confirm if you are still experiencing issues?\n. LGTM\n. Ive introduced new things to this PR so previous LGTM are void. Going to close this and open a new PR as the scope of this PR has drastically changed. LGTM\n. LGTM\n. It looks like a gap is being created on the segment boundary due to a rendition switch. The gap skipping logic should detect and skip past the gap, but seems like a bug is causing it to think there is no gap to skip. We should be able to get a fix for this\n. Can you clarify odd scenarios? \n. Safari supports native HLS, so the player lets Safari take over, so the source handler is never initialized. \nWe are currently working on a beta build that changes a lot of our segment fetching logic. v3.7.0-beta4 has a change that allows you to override native HLS to force the source handler to be created. This can be done by setting videojs.options.hls.overrideNative = true. This build may be unstable though.\nAlternatively, you could try adding the override changes to your own fork and give it a try.\nI don't think theres been much testing on using contrib-hls in Safari in favor of the native implementation yet, so these suggestions may not work, but a good place to start.\n. LGTM\n. LGTM\n. The most recent release includes a ton of live stream stability enhancements. Can you try your stream with the latest version (4.0.2) and see if this is still an issue for you?. can you provide an example with this happening?\n. For the VOD source (https://vod054-ttvnw.akamaized.net/472ed5089b_rhykker_23620411488_544946608/medium/index-dvr.m3u8), the browser throws No 'Access-Control-Allow-Origin' header is present on the requested resource.. Twitch must've recently disabled CORS or this would probably still work. Nothing we can really do about this.\nFor the live, its interesting that it was working previously and not anymore. I wonder if they recently made some changes to their encoding that is causing a slight difference in timing that is causing the segment fetching logic to hang up. The good news is whats failing here is one of the many problems we've been trying to address in our current beta build. The current build is 3.7.0-beta4. you can see here that the live stream seems to be working with this build. Note that since its still in beta, its not completely stable, but it is close, so stay tuned.\n. Can you try using the latest version of videojs-contrib-hls and see if your issue still occurs?. What mobile device, OS, and browser are you using? Can you provide a code example and stream source that reproduces the error?\n. LGTM (jumped the gun a bit on this one). LGTM official this time. RE: Also would probably be worth adding tests for enableFunction\nThere are already tests to ensure that calling representation.enable() calls the fastQualityChange_ function and tests to make sure the fastQualityChange_ function is functioning properly,  so I don't think more tests need to be added. Playing encrypted streams in a background tab has been a problem area. We hope to address and fix issues with background tab playback in the next few months, so stay tuned.. This should be fixed as of v5.0.0.  Closing this issue, if you still experience problems please open a new issue.. if data-setup=\"{ \"html5\": { \"nativeTextTracks\": false },\"playbackRates\" : [0.7, 0.8, 0.9, 1, 1.2, 1.5]}\"> is a snippet from your html code, your double quotes within the attribute are probably causing some issues. try using data-setup='{ \"html5\": { \"nativeTextTracks\": false },\"playbackRates\" : [0.7, 0.8, 0.9, 1, 1.2, 1.5]}'>. If that is not the issue, please make an issue in the video.js project since this is not an hls specific issue.. Using character entities won't work. Try using single quotes for the outer quotations or single quotes for all the quotes within the outer qoutes\ndata-setup='{ \"html5\": { \"nativeTextTracks\": false },\"playbackRates\" : [0.7, 0.8, 0.9, 1, 1.2, 1.5]}' \nor\ndata-setup=\"{ 'html5': { 'nativeTextTracks': false },'playbackRates' : [0.7, 0.8, 0.9, 1, 1.2, 1.5]}\". You can try listening to the waiting event on the player for when the spinner is active and listen for playing when the spinner deactivates. If this doesn't work, please make an issue in the video.js project as this is not an hls specific issue.. What do you mean by the video is cut? Can you provide a reduced test case exhibiting the problem behavior? What version of videojs-contrib-hls are you using?. I am not seeing the issue here http://jsbin.com/kunuquqeri/edit?html,output can you try updating to the latest version of videojs-contrib-hls and see if that solves your issue?. LGTM. lgtm. We've made some improvements to the SourceUpdater and VirtualSourceBuffer that should fix these issues. Can you try out the latest version (v5.5.3) and see if it resolves the issues for you?. videojs-contrib-hls requires video.js version ^5.15.1. Can you try updating your video.js version and see if that solves your issues?. LGTM. If users expect to be able to access hls with videojs.getComponent('Hls') then we would lose backwards compatibility with removing the register.. LGTM. It would be nice to have a unit test that emulates the scenario that caused the issue.. LGTM. Thanks for catching this bug and submitting a fix for it!\nAfter some conversation with @gkatsev, videojs.players[playerId] should be set and how we should be access the player. It seems that since the Hls object is registered as a component, it gets initiated when the tech is created before videojs.players[playerId] is set. Calling videojs(playerId) to access the player before it is finished initializing could potentially cause a errors or a re-initialization of the player. Can you update your PR so that setupQualityLevels_ isn't called until the ready event is fired by the tech (or use tech.ready(callback). This should fix the issue and avoid any potential unwanted side effects.. I do believe for the same reasons that call could also be problematic, but for the purposes of this PR let's not worry about it. It'll be better to investigate that separately.\nThis looks good to me. LGTM. Many of the people in the issue you referenced mention that using the global override videojs.Hls.xhr.beforeRequest isn't working and the only way to override the function is at runtime. Is that still an issue and does this address that?. Resuming live stream after a long pause is being address in #1006 so keep an eye out for when that gets merged in. LGTM. PR stands for pull request\nSince the changes are small enough, you can do this all through the github website.\nFirst you would want to fork this repo, go to the fork in your repositories and edit the files with these changes and when committing the changes, just make sure \"Create a new branch for this commit and start a pull request.\" is selected. (Since you make changes on multiple files, just make sure to not have \"Create a new branch for this commit and start a pull request.\" selected for the other files, but instead just make sure you are currently viewing your newly created branch and just have \"Commit directly to the your-branch branch.\" selected). LGTM. v5.11.1 of videojs-contrib-hls will now use only a single audio/video track when multiple are present to prevent the distortion. Closing this for now as fixed. If you continue to experience problems please re-open or submit a new issue.. LGTM. LGTM. @forbesjo I think we should raise an issue with video.js to set videojs.browser.IE_VERSION = 11 when those user agent tests pass. Changes need to be made in MasterPlaylistController so that the debug option is added onto the settings object passed to the segment loaders as well as a settings object needs to be passed to the sync controller. Don't forget to migrate the change from here to this PR. It looks like there is something wrong with the stream itself. Looking at things more closely, I see that the buffer is filled with 4 second gaps every 6 seconds. It appears that the last (or first) 4 seconds of every segment is not included in the ts file. You can see this if you try and play your stream in VLC or another video player. If you watch the timestamps on the bottom closely, you'll notice every 6 seconds, it freezes with potentially some visual artifacts, and then jumps ahead 4 seconds. I'm having no issue and seeing no errors playing the stream on http://videojs.github.io/videojs-contrib-hls/#\nThe repeated buffering spinner you are seeing is because of those 4 second gaps I mentioned. When a gap is detected, a timeout is set to seek over the gap after the duration of the gap has completed. So what I'm seeing is it playing those 6 seconds, watching the time on screen increase, then when it hits the gap, the spinner appears for 4 seconds, then it jumps forward and starts playing again, repeat.\n. Thanks for the contribution @OwenEdwards . I think #1016 will address this issue. This looks to be a bug. If the last rendition available in the playlist is playing, requests shouldn't timeout, but these requests are. It looks like the check for last rendition is only called on mediachange events, which should also happen for the initial rendition. This should be fixed by #1032 . Sorry this has gone unnoticed for so long. @vpowers looking at your reduced test case, it looks like 2 versions of videojs are being loaded into the page, 5.16.0 for the project's dependency, and 5.18.4 (as of today) for the ^5.17.0 dependency in contrib-hls. The project works properly for me if I update the dependency in the root project to ^5.16.0 so that npm can load just 1 version of videojs that covers both dependency requirements. @imbcmdth Right now, if a segment request fails on the last rendition, the segment loader is paused and the player will either stall at the end of the buffer until it times out or if its live, falls off the live window and playback watcher gets things moving again when seeking to live. Do you think we should unpause the segment loader in this case.\nAlso, there is nothing currently limiting the requests made. When the final rendition fails, it will keep trying to reload it indefinitely (or for at least 5 minutes until the other renditions are no longer blacklisted). Is this ok behavior?. Well the segment loader gets paused on the error and reset to READY, so it should just be as simple as a call to load to get the segment loader working again. \nTalking manifest refreshes, but in this case the retry happens right away instead of setting another timeout for refresh delay, so it repeated requests as fast as they respond/fail. (If we move to retry segments then we are talking segment requests too). Closing as this is now contained within #1039 . @mgara videojs-contrib-hls does include a plugin that will reload the source on player errors. It's turned off by default, but you can turn it on by adding the plugin to your player options\n```\nvar options = {\n  plugins: {\n    reloadSourceOnError: {}\n  }\n};\nvar player = videojs('myVideo', options);\n```\nThis may not solve all the issues, but may help your scenario. That in combination with the pull requests @gesinger mentioned will probably be what you are looking for.. Would be good to have a some tests for playlistEnd. Closing in favor of #1057 . ~~I'm not sure what detail I'm missing here since Travis obviously seems to think the tests should pass, but I notice that all the mediaSegmentRequest unit tests have assert.expect(n) but only have n - 2 asserts, which would lead me to believe that the tests should fail.~~\nEDIT: Ran the tests locally and see that is because of no unexpected logs at level \"warn\" and no unexpected logs at level \"error\": assertions run on every test. I think it would be good to have a test that makes sure doneFn isn't called until segment, key, and init segment requests have responded. Is it even necessary to reset the audio loader on fast quality change? If fastQualityChange_ causes a rendition switch, the mediachange event listener will call setUpAudio if the active audio group has changed. setUpAudio will tear down the playlist loader and reset the segment loader. Thanks for bringing this to our attention. I've updated the README to include a notice.. videojs-contrib-hls-s1 appears to be an old fork of this project that someone published to npm. It is very outdated (over a year since its last update) and is not maintained by the videojs organization. I recommend using videojs-contrib-hls and not the s1 package. The ABR algorithm doesn't take order into consideration when selecting a rendition, except in the case of redundant streams (same width/height/bitrate) in which case it will choose the redundant stream based on the order it is listed in the playlist (this was the change you saw in the changelog). What it does take into account is the player size and user's bandwidth. The player defaults an initial bandwidth of 4194304, which is below the bandwidth of your 720 rendition, which would explain why it isn't selecting that. You can change the initial bandwidth to be above the bandwidth of your 720 rendition to have it selected first by setting it through the player options during player creation. \n```\nvar options = {\n  hls: {\n    bandwidth: 10525595\n  }\n};\nvar player = videojs('myPlayer', options);\n```\nI've edited your jsbin to show this working https://jsbin.com/lonipisodu/edit?html,output. Hi @JPeMu Do you have a publicly available source I can use to look into this?. Thanks for helping solve this issue! This should be fixed in v5.4.1.. Can you provide a source that causes the problem and try loading it here. I am seeing no issues with a 6 second source.. Looking at the console, I am getting\nXMLHttpRequest cannot load http://breakdownservices-dev.s3.amazonaws.com/media/ecocast/209462/videos/209462-8ecd721a-e6d6-4992-9715-db9edcb112d7/hls10.ts. Response to preflight request doesn't pass access control check: No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'http://null.jsbin.com' is therefore not allowed access. The response had HTTP status code 403.\nContent needs to have cors headers otherwise the browser wont allow the player to load the source. See https://github.com/videojs/videojs-contrib-hls/blob/master/README.md#hosting-considerations. The presence of the autoplay attribute does not make a difference for me. I am still seeing errors saying the content do not have CORS headers. The response MUST contain a Access-Control-Allow-Origin header, otherwise the player will not be able to play the video. Please refer to the section about hosting in our README\nI'm closing this issue for now. If you configure your server to attach CORS headers to media responses and still have problems, please reopen the issue or create a new one.. #1076. #1080 has been merged into master. Thanks for finding this issue and adding it to our docs. I think it would be good to move the code workaround example and add details about the issue in Edge to the Known Issues section and to make note in the beforeRequest section that there is more information in the known issues. LGTM. Blocked on\nhttps://github.com/videojs/videojs-contrib-media-sources/pull/140\nand\nhttps://github.com/videojs/mux.js/pull/150. Oh those can be specified in manifest as well. Is there a way to tell them apart in manifest?. That scenario is definitely a problem, but it is not a very common case. I think it will be ok to move forward with this and make an issue for that case to address in another PR. I believe this issue is because of the multi-day long m3u8. Timestamps in MPEG2TS streams are 33 bits, with a max value around ~26.5 hours, so there will be multiple segments with the same exact timestamp.  Currently, we don't have a great way of dealing with seeks that span very large time ranges. During the transmuxing stage, we try and account for this rollover by comparing and adjusting the timestamps when a rollover is detected. https://github.com/videojs/mux.js/blob/master/lib/m2ts/timestamp-rollover-stream.js#L34\nThe SyncController is also probably experiencing issues since we inspect each segment before transmuxing for timing information https://github.com/videojs/videojs-contrib-hls/blob/master/src/sync-controller.js#L409 \n. this was added in #1176 . this was added in #1176 . this was added in #1176 . #1176 . Issue moved to videojs/videojs-contrib-dash #186 via ZenHub\n. This was added in #1176 . Didn't we want to turn on the storing of local storage but leave the using of it off for now?\nAlso do you think this would be a good thing to allow turning off and on through the player options?. We should add the usage tracking event for when localstorage values have been used. LGTM. @gesinger thoughts on the defaults for the constants? 0-30 low waterline, 30-60 goal buffer length at a rate of 1 will reach the max at 30 seconds. Are these the values we want to test out? . @WaluTechnician You've got the right idea.\n<script>\n  // Set the HLS overrideNative option globally\n  videojs.options.hls.overrideNative = true;\n  // Player instance options\n  var options = {\n    html5: {\n      nativeAudioTracks: false,\n      nativeVideoTracks: false\n    }\n  };\n  var player = videojs('test', options);\n</script>\n. Hi @Tanyavdc Thanks for reporting the issue. Would you be able to provide a reduced test case http://jsbin.com/vokipos/8/edit?html,output or provide a link to your stream?. Let's add an event for hls-playlist-cue-tags here https://github.com/videojs/videojs-contrib-hls/blob/master/src/master-playlist-controller.js#L303\nand an hls-error-reload around here https://github.com/videojs/videojs-contrib-hls/blob/master/src/reload-source-on-error.js#L51. Your playlist is a fragmented MP4 stream, but you are missing the EXT-X-MAP. Each segment must have an EXT-X-MAP tag applied to it. It looks like the issue started happening after this merge #1099 . I'm currently working on a fix for this, stay tuned. @mlumbroso technically, the audio only fix does not address your issue, you just happened to expose the audio only issue indirectly. Your specific source has issues with the video not appearing when using the master m3u8 because the 600k stream only has audio codec information CODECS=\"mp4a.40.2\" vs the other streams which have both video and audio CODECS=\"avc1.4d0016,mp4a.40.2\". If the 600k stream is selected first, the player is going to think the stream only contains audio and will setup an audio only buffer. Including the video codec in there as well should solve your problems\n. This has been fixed by #1195 please update to videojs-contrib-hls v5.8.1 to start using the changes. If you still experience issues please open a new issue.. @mlumbroso did you see my previous comment regarding the CODECS specified in the manifest? Since one of your manifests only contains an audio codec, we treat it as an audio only source, and will not create video source buffers or append any video data. If I edit the CODEC attribute to also include a video codec, video plays just fine. The stream returns a 401 Unauthorized error code. Can you make the stream publicly available?. It looks like your audio stream is stream type 3, the mp3 audio layer, which we don't support. If you can encode your stream using the stream type 15 for ADTS AAC, the audio should work. Since the spec states it MUST contain all the cues for that time period, it may be as simple as removing all cues from the track that are between the start of the first cue in the segment and the end of the last cue in the segment. If there is overlap across segments, we will just be removing and immediately re-adding a the same cue. . A fix for this has been released in v5.8.3. Please open a new issue if you continue to experience any issues.. Sounds like this is a duplicate of #1179 ?. This has been fixed by #1195 please update to videojs-contrib-hls v5.8.1 to start using the changes. If you still experience issues please open a new issue.. Any browser that supports MSE would be able to support playing back fmp4 when using a library like this one. If you mean what browsers support an fmp4 HLS manifest natively without this project, then only browsers that support MPEG2TS HLS natively (e.g. Edge, Safari) should be able to play back the manifest.. This is the error I get when trying to load your stream\nXMLHttpRequest cannot load http://live.g3proxy.lecloud.com/gslb?stream_id=lb_mv_1000&tag=live&ext=m3u8&sign=live_tv&platid=10&splatid=1009&format=letv&expect=1. Redirect from 'http://live.g3proxy.lecloud.com/gslb?stream_id=lb_mv_1000&tag=live&ext=m3u8&sign=live_tv&platid=10&splatid=1009&format=letv&expect=1' to 'http://23.248.182.24/m3u8/lb_mv_1000/desc.m3u8?stream_id=lb_mv_1000&path=23\u2026&geo=US-107-0-100&tmn=1499811147&pnl=955,955,939,512&ext=m3u8&sign=live_tv' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.. player.hls is setup after the source selection process and the hls source handler is created. Since setting the source is asynchronous in videojs 6, I think the best way to do this is to set the global override for beforeRequest. Note that this will affect all videojs players on the page, so if you have multiple players on one page that need different beforeRequest you'll have to go with another approach\nvideojs.Hls.xhr.beforeRequest = function(options) {\n  options.headers['X-User-Id'] = 'nhat';\n  console.log(options);\n  return options;\n};\nvar player = videojs('my-video')\nplayer.src({\n  src: 'http://localhost:3000/video',\n  type: 'video/mp4',\n  withCredentials: true\n});. @m2008m1033m You can still set beforeRequest on a per-player basis, it just needs to be set after calling player.src. One downside to that is if you require changing the headers for the initial manifest request, it may already be too late to set the function after calling src. One idea for a workaround for that would be define all your unique beforeRequest functions, then set a global beforeRequest that will attach the custom player specific beforeRequest functions to each player on the page. Outside of that, changes to the source code would have to be made to allow passing in a beforeRequest as a player or source option, or some other way to set the function before the first request is made. Thanks for reporting this @Okapist Could you provide some more info like Videojs version, videojs-contrib-hls version, browser, os? If its possible for you to provide a source or a reduced test case in jsbin, that would be very helpful. Not really sure why this isn't working in safari, especially since I can get it to working locally with a different m3u8 and vtt source, but not with yours. However, I could get your sources working locally by disabling native text tracks videojs.options.html5.nativeTextTracks = false. Maybe give that a try and see if it fixes your issue?. you might need to move the videojs script tags into your <head> as well\nAlso, I was a bit misled with, \"got it working with your sources\", by moving the script tags to the top, I don't get the media error, but safari encounters an error when trying to request your vtt file (though it doesn't provide any error message or status code...), but if I download and host your vtt file locally it works. There may be an issue with how you are serving your vtt file as well\nedit: nvm it was cors issue I was running into. I would try the moving scripts to <head> and disabling native text tracks and see if that fixes it for you. This bug happens when using a non master manifest as the source as the parser won't have any attribute data to add to it. we can address this either at the parser level  or within PlaylistLoader. A fix for this has been released in v5.8.3. Please open a new issue if you continue to experience any issues.. It looks like your stream has audio that is unsupported by chrome\nwindow.MediaSource.isTypeSupported('video/mp4; codecs=\"avc1.42001f,mp4a.40.34\"')\nwhich prompts contrib-hls to blacklist the playlist, but since you only have a single variant, there are no enabled playlists for the selector to pick from. #1207 would fix the error from occuring, but audio will continue to not work unless you update your encoder settings. You should no longer see the undefined error in v5.12.0. Closing this issue for now, please re-open or submit a new one if you continue to experience issues.. Thanks for the PR, this is definitely something we should handle gracefully. \nImplementation looks solid, would you be able to add a unit test for this behavior?\n(I agree, bit by bit is easier to consume \ud83d\ude42). You can use the Segment Metadata text track to get information about the segment currently being displayed. The active cue will contain the playlist uri which you can use with the representations or qualityLevels api to get additional information about the playlist. Yes the Segment Metadata track will give you this information. The track is populated with cues where each cue represents the segment loaded into the buffer at the time of the cue. So while playing the video, the active cue in this track will have information about the segment currently being played on screen.. Here is an example of using the segment metadata track to log info about the current playing segment\nhttp://jsbin.com/fuqelosavi/edit?html,output\n. It's possible the track is already created and added at this point. You could try searching for it first and if it's not there, add the listener. Try something like this\n```\n'onVideoPlay': function (scope) {\n  scope.player.on('play', function (e) {\n    var textTracks = scope.player.textTracks();\n    console.log(textTracks) ;// its working upto here.\n    var i, metadaTrack;\nfor (i = 0; i < textTracks.length; i++) {\n  if (textTracks[i].label === 'segment-metadata') {\n    metadataTrack = textTracks[i];\n    break;\n  }\n}\n\nif (metadataTrack) {\n  metadataTrack.on('cuechange', function () {\n    var activeCues = metadataTrack.activeCues;\n    for (i = 0; i < activeCues.length; i++) {\n      console.log(activeCues[i].value);\n    }\n  });\n} else {\n  textTracks.on('addtrack', function (event) {\n    if (event.track.label === 'segment-metadata') {\n      metadataTrack = event.track;\n      metadataTrack.on('cuechange', function () {\n        var activeCues = track.activeCues;\n        for (i = 0; i < activeCues.length; i++) {\n         console.log(activeCues[i].value);\n        }\n      });\n    }\n  });\n}\n\n});\n}\n```. Are you able to setup a code example with our starter template http://jsbin.com/vokipos/8/edit?html,output that shows the behavior you are seeing?. Both Android and iOS support native HLS playback, so this track will be unavailable in native playback as there is no API currently to get this type of information natively. \nYou can override the native HLS playback with videojs-contrib-hls in Android by following the instructions here. MSE is not supported in iOS however, so this information is unavailable in iOS. Closing this as it is a duplicate of #1208. Please continue discussion in #1208. Do you think it would be appropriate to move the other codec functions/constants within MasterPlaylistController.js into utils/codecs.js? \nspecifically \n defaultCodecs\n mapLegacyAvcCodecs_\n makeMimeTypeString\n getContainerType\n getCodecs\n mimeTypesForPlaylist_. Does the codec test get run properly with npm run test? i think util/codecs.js needs util/codecs.test.js. would it make sense to move the bin-utils.js file to util/bin.js?. We don't currently have any plans to support mp3 audio and I don't see that changing anytime in the near future. #214 is a very old PR, and the code that it changes now lives in https://github.com/videojs/mux.js \nIf anyone is interested in updating #214  to be compatible with latest and opening a new pr to mux.js, we can consider pulling in mp3 support. I'm not sure what the specifics of the presets are, but being hls v4, I assume that all your content is unmuxed into separate video and audio streams, making use of alternate audio groups. For Win 7 IE 11 playback, a flash fallback is used where we transmux the mpeg2ts into flv tags, which does not support unmuxed audio. If possible, I suggest having an hls v3 source available to serve to win7 ie11 users, or setup your transcoder settings to output muxed audio and video. Yes making that switch should get audio working again. xhr.beforeRequest sounds like what you are looking for https://github.com/videojs/videojs-contrib-hls#hlsxhr. Timestamps in MPEG2TS streams are 33 bits, with a max value around ~26.5 hours, so there will be multiple segments with the same exact timestamp. Currently, we don't have a great way of dealing with seeks that span very large time ranges. During the transmuxing stage, we try and account for this rollover by comparing and adjusting the timestamps when a rollover is detected. https://github.com/videojs/mux.js/blob/master/lib/m2ts/timestamp-rollover-stream.js#L34\nThis is something we'd like to address but has not been prioritized . If there is a large gap in video or audio, the player cannot play over it. That is why you are seeing the jump to 34 seconds, the PlaybackWatcher detects a gap in the content and sets a timer to skip past the gap after the gap's duration. A test for the cooloff behavior and a test for elapsedSinceStart behavior would be great. I believe XHR within the tests do not trigger progress events on their own, so you will have to do something similar to the test you linked by manually waiting clock ticks and triggering progress events when you want them. Basically what is happening in that test is mimicking the behavior of playback start, where the request is the first segment, and you basically take the loaded property divided by the number of clock ticks that have passed to get the calculated bandwidth.\nSo\ntick(999)\nloaded: 2000 // 2000bytes/999ms\ntick(2)\nloaded(2001) // 2001bytes/1001ms\nAt which point the code decides to abort early.\nI would say you could use this test as the ground work for the cool-off test. Basically before the progress events for the first test, you'd want to mock seeking to true, check that its not aborted from progress events even though it would've if seeking was false, then youd want to complete the request and make seeking false again so another gets started, then show that it does not abort that one because of the cool-off. Finally I would then complete that request and use enough clock ticks so that you get past the cool-off period and show that it will abort again post cool-off if bandwidth is still low\nIt looks like there isn't a specific test for when there is forward buffer but it is low. The test you linked doesn't seem to mock anything with the buffer so its basically testing the already buffering case. You were right the first time with 2B/s :) The reason it does not trigger right away is that it waits until it has been a full second since the first progress event before considering an abort because we've seen that progress events have an initial ramp-up period where the calculated bandwidth is very innacurate and tend to stabilize after a second. nice test, ya thats what I meant. If I understand correctly, the problem is that you have a page that users can visit to tune into your live stream, but an error is displayed when trying to visit the page before you have started the rtmp stream?\nOne suggestion if possible is to have your rtmp stream running just serving a static clip on loop until your actual content starts.\nAnother idea could be to not set the source in the player and have a custom script running on your page that pings the server and when it sees that the stream has started, set the source in the player and play. . It appears to also not work in the ouput page  for the jsbin http://output.jsbin.com/xosefiyijo , but does work in their embedded runner\n. You should also be overriding native playback for android, otherwise Android will use its own native hls playback and not contrib-hls. This specific source has multiple video tracks within the stream. Previously we did not account for multiple tracks, so data from all tracks were being merged together resulting in playback errors or distortion. v5.11.1 of videojs-contrib-hls will now use only a single audio/video track when multiple are present to prevent the distortion. Closing this for now as fixed. If you continue to experience problems please re-open or submit a new issue.. Please refrain from creating duplicate issues in the future, one is enough. I am closing your other issue in favor of this one.\nIt's hard to say what is going wrong without a full example. Could you provide a reduced test case (http://jsbin.com/vokipos/8/edit?html,output) that shows the behavior you are seeing?\n. I'm not seeing any issues on edge myself. Does player.qualityLevels() return an empty list on edge for you? It's possible that the levels are getting added to the list before the hlsSourceSelector plugin can setup its event listeners. I would try initializing the plugin through videojs options.\nvar player = videojs('my-video', {                                                                                                           \n  fluid: false,\n  poster: \"https://static.vod-platform.net/VideosThumbsImages/admin/200000/Poster-277470-1-6771897-1.jpg\",\n  preload: \"auto\",\n  controlBar: {\n    volumePanel: { inline: false }\n  },\n  plugins: { hlsSourceSelector: {} }\n});. Great glad that worked for you! Closing this issue, if you run into more problems please re-open or submit a new issue. I cannot play your sources because CORS is not enabled. CORS will have to be enabled before I can load this into a player to diagnose. Looks like metadata cues are not being added to the track in an audio only case. Comment in contrib-media-sources \nhttps://github.com/videojs/videojs-contrib-media-sources/blob/master/src/virtual-source-buffer.js#L516\n// TODO: are video tracks the only ones with text tracks? I guess this answers that question. Github won't let me comment on the line because no changes were made, but line 468 of playback-watcher.test.js test description is 'seeks to live point if we try to seek outside of seekable' which is not quite true anymore since it may seek to the start of the window depending on where you are trying to seek. ffmpeg -i input.mp4 -bsf:v h264_mp4toannexb -codec copy -hls_list_size 0 output.m3u8 this works for me, maybe try starting with this and add/edit options to get your desired output . No sorry, the fix is still being reviewed/tested. The fix has been released in v5.12.0. Closing this issue for now, please re-open or submit a new one if you continue to experience issues.. Can you provide the error output using the un-minified script or create a reduced code example with our starter template?. Is the issue that when providing an HLS and DASH source and HLS is not supported, the player falls back to playing HLS with flash instead of first trying the DASH source? This could be be fixed by having html come first in the tech order.\nOr is the issue that when providing an HLS and DASH source, HLS is not supported, and flash is NOT installed, the player fails with the HLS source and does not ever try the DASH source?\nIf you could provide a code example that might be helpful. Looks like since the PAT and PMT packets are not the first packets of the segment, mux.js attempts to cache the initial video packets until it sees the PMT, and then processes those video packets. However it looks like mux.js is processing those packets too soon, before it can setup the rest of the pipeline with the data from the PMT.. No what you are doing currently is fine. The data for the segment you are sending has everything needed, PAT and PMT packets and a complete GOP. Your data is a bit outside of the HLS spec recommendation though. The first two Transport Stream packets in a Segment without an EXT-X-MAP tag SHOULD be a PAT and a PMT. In your case, the PAT and PMT packets are in the middle. While it goes against the recommendation, it is still valid. You could always ensure the PAT and PMT are the first two packets, which should correct the problem. However, since your segment is still valid, this is a bug in mux.js not properly processing the packets that come before the PAT and PMT. I'll update this issue when a fix has made it into a contrib-hls release. Maybe sometime next week, though I don't have an accurate ETA at the moment.. The fix for this has been released in v5.12.0. Closing this issue for now, please re-open or submit a new one if you continue to experience issues.. It doesn't look like your example is actually using the overrideNative options. I added the options to the jsbin http://output.jsbin.com/dubiqucimi and it is working for me on mobile. I tested in Chrome on my android device and the jsbin I linked works just like desktop. I did not test on an ios device though. Hi @campones \nThe player should start playing after the first segment has downloaded. The only scenarios I can think of that would require 2 segments to be downloaded before playback are if the audio and video are demuxed, i.e. in separate streams, both an audio and a video segment need to be downloaded before starting. The other case is if you are playing a live stream in IE11 on windows 8.1 or 10 because of an issue with seeking before the tech is ready in IE11.\nIf these scenarios are not what you are doing, it sounds like it could be a bug, but hard to say without an example. Would you be able to provided a code example or source?. Hi @campones sorry for letting this go unnoticed for so long, I did not see your updates after my last response. Based on the information you provided, I'm not quite sure why this issue is happening. Would you be able to provide both streams or 2 consecutive segments from both (with and without the video being re-encoded) so that I can take a closer look?. Thanks for providing the sources @campones \nSo it looks like in the case where 2 segments are needed, the playlist has a window of 4 segments each with duration 20s, and a target duration of 20s. Apple specifies that last segment duration + 2 * target duration is unsafe for smooth playback, so the player calculates the seekable range to be 0-20s. On playback start, the player seeks to the end of the seekable range to start as close to the live edge as possible. Because this is right at the segment boundary, the player ends up requesting the first segment (this is because the segment fetching logic around segment boundaries is conservative to simplify things), which is actually roughly 19.8s (this is ok, manifest durations are not required to be perfectly accurate), but because the player is trying to play content at 20 seconds, it requires the next segment to get started.\nThe other stream also has a window of 4 segments, but the target duration differs, and segment durations are not all the same. This seems to cause seekable range to be calculated as 0-0s, so when seeking to the live point at play start, its just a seek to 0, and the player is able to play once the first segment is downloaded at content is buffered at 0.\nI can\u2019t imagine you are the only one experiencing this issue, so it is something I\u2019d like to address at some point. However it is a more complicated problem in practice than it seems on paper, so I don\u2019t expect any solutions in the short term.\nI can provide some suggestions to help avoid the issue. My first suggestion would be to encode the video track like you do the second stream. While I understand that it is very CPU intensive, it provides other benefits to yourself and viewers. The segments in the first stream are over twice the size of the files in the second stream. Even with a very fast connection, some segments take longer than their duration for me to download. This will lead to repeated stalling and buffering, as well as much slower startup times (which becomes an even bigger problem when combined with the issue you reported here). Encoding the video track will reduce bandwidth consumption and improve overall playback experience. If this just isn\u2019t an option, another thing you can try is to segment the stream more. The 20 second segments produce large files that are required to be downloaded in full before playback can begin. Apple recommends segments with a duration of 6 seconds. If you can segment at a smaller interval such as 6s, file sizes will be reduced and hopefully improve startup time even if the double segment download is unavoidable.. I am getting a 403 Forbidden and No 'Access-Control-Allow-Origin' header errors for https://live.impresa.pt/live/sic/sic.m3u8. What OS are you using?\nVersions of contrib-hls and videojs?\nCan you provide a source or reduced test case?. It looks like you just have some syntax issues with your example. Specifically missing a comma after loop: false, opts being undefined, and no closing parenthesis for the videojs() call\nfixing your setup to be \nvideojs('my_video_1', {\n      \"controls\": true,\n      \"autoplay\": false,\n      \"preload\": true,\n      \"poster\": '',\n      \"loop\": false,\n      \"html5\": {\n        hls: {\n          withCredentials: true\n        }\n      }\n  });\nwith the above snippet it is working fine for me with cookies being sent. You can't support both static a static mp4 and a streaming m3u8 with a single MIME. You'll have to dynamically set the MIME like you do with the source. Probably something along the lines of \n<source  data-bind=\"attr:{src:URLToPlay, type:MIMEToPlay}\" id=\"video-source\"> where MIMEToPlay is the correct MIME for URLToPlay. It sounds like you are just loading the page and media via the file protocol and not hosting it on a web server.  Chrome will not allow this so you will have to run a web server to serve the content over http. I'm surprised Firefox actually allows this. More Info: https://github.com/videojs/videojs-contrib-hls#hosting-considerations. >For file: URLs, each distinct file pathname is a distinct origin, but we report the problem as if it were a regular (scheme, host, port) origin.\nLooks like when the file protocol is in use, chrome treats each path as its own origin even if they have the same base path. Your only options to work around this are to run a local server (recommended) or disable browser security features (NOT recommended)\nFound from this chromium ticket https://bugs.chromium.org/p/chromium/issues/detail?id=512542. It looks like your audio is encoded in a format that isn't supported by the transmuxer. Right now the transmuxer can only detect audio streams of stream type 15 ISO/IEC 13818-7 ADTS AAC (MPEG-2 lower bit-rate audio) in a packetized stream, however your audio is stream type 4 SO/IEC 13818-3 (MPEG-2 halved sample rate audio) in a packetized stream. Re-encoding your audio to be ADTS AAC should correct the issue. videojs-contrib-hls supports encrypted playback, all you need to do is provide your source to the player. You should be able to test it out by replacing in your source here http://jsbin.com/vokipos/8/edit?html,output. The decryption keys are specified within the m3u8 playlist as a media segment tag\ne.g.\n```\nEXTM3U\nEXT-X-VERSION:3\nEXT-X-MEDIA-SEQUENCE:0\nEXT-X-TARGETDURATION:6\nEXT-X-KEY:METHOD=AES-128,URI=\"https://priv.example.com/key.php\"\nEXTINF:6,\nhttp://media.example.com/fileSequence0.ts\nEXTINF:6,\nhttp://media.example.com/fileSequence1.ts\nEXTINF:6,\nhttp://media.example.com/fileSequence2.ts\nEXT-X-ENDLIST\n```\nIf you need help on how to generate playlists with the decryption key, this looks like it will be helpful http://hlsbook.net/how-to-encrypt-hls-video-with-ffmpeg/ . I believe this is a bug with Android's native HLS implementation, which will be used by default. If you use the overrideNative option for Android devices, videojs-contrib-hls will be used for playback instead of Android native.. The overrideNative options should go under the html5 property e.g.\nplayer = videojs('example-video', { html5: config }) . No problem, glad I could help! Go ahead and star the project if you feel so inclined :) Closing this issue, feel free to open a new one if you encounter more issues. It looks like you are generating a Master playlist.m3u8 file for each of your renditions that contain a single chink.m3u8 stream file within each, is that correct? Sorry, but it is not possible to set up the player in this way. You will have to host a single Master manifest file that references each chunk.m3u8 as a separate EXT-X-STREAM-INF to make use of ABR.. You should be able to use the waiting event on the player. I think this is because with the setTimeout it gives the browser a chance to handle the source natively before videojs can intervene. If you need the setTimeout, I suggest either setting the source with the player api player.src() instead of using the <source> element. Another option could be to use the <video-js> embed element instead of <video>. That should allow you to use <source> element without the browser handling it natively.. We have had issues with webpack in the past (you can see its long history in #600) We recently released v5.13.0 of videojs-contrib-hls that is supposed to fix support for webpack. I suggest updating to 5.13.0 and see if that fixes your issue . Originally the check was to call enabledPlaylists() to determine if there was only one enabled playlist left and to call onLowestRendition() to check if the lowest rendition was active. This would fail if all but one rendition were disabled, but the enabled one was not the lowest. Since I'm not too familiar with how the player selects a playlist, this may not be a use case we have to check for? By adding the check for being enabled in this filter, it fixes that problem and removes the need to have to call enabledPlaylists() in the check at all. I left enabledPlaylists() in since I was under the impression the method was desired. If that is not the case we can remove it.\n. This test looks like it is basically doing a similar test, except the option is being set at player creation level and not loader (which is how it needs to be done with this change now)\nhttps://github.com/videojs/videojs-contrib-hls/blob/master/test/videojs-contrib-hls.test.js#L1204\nCould add a second test to make sure that passing in the option would override the global default to cover these cases?\n. This is the case where in a live stream, you enter the stream and the first tag you see is a cueOutCont. There would be no cueOut to extend to since we haven't seen a cue out. If we've already seen a cue out we wont even enter the else block so a new cue won't be created.\n. Yes that is correct.\nFor example, if in the stream we have this playlist\n```\nO      C1      C2\n```\nand then we load another playlist as the stream progresses and the sliding window moves\n```\nC1     C2      C3\n```\nThe duration of the segments with tags C1 and C2 have already been added to the cue's end time, so we want to skip over that segment\n. I think its ok to make the assumption for now since the parsing only affects adStartTime and adEndTime which don't actually affect the functionality of the cue, but only give some extra metadata to the user. parseFloat will also ignore anything after it sees the first non-numerical character, so as long as that data is first, it won't be affected.\n. This will return true if b[prop] is a falsely value such as false or 0 even if it hasn't changed from a\n. Should there also be an abort case for this.initSegmentXhr?\n. I believe you meant !this.xhr_.initSegmentXhr\n. The issues involving native support occur with Edge. In IE11 the issues stem from using flash playback not supporting fmp4\n. Made private\n. done\n. Made some rename changes to better reflect what they do\n. This looks like if there is only one segment with the current timeline, we pick that, otherwise pick the second of the list. Why are these options better candidates than any of the other segments?\n. Do we actually need to keep track of seekedAtTime? I can't think of a scenario where we will reach the check this.seekedAtTime === currentTime and have that be true\n. There is a lot going on in this function. I think it would be helpful for readability if the different checks (\"check to see if we fell out of the live window\", \"check for video underflow\", \"check for gap\") were made out into their own functions \n. Might be better to say \"Periodically check the currentTime\" since we are no longer using timeupdate events\n. should this be \"played for ~~three~~ two more seconds\" ?\n. I notice you call cancelTimer_ in the other two cases that you setCurrentTime without setting a timer (fall off live window and video underflow). Should we do that before setting current time here too?\n. Probably not an issue but do we want to remove the element from the DOM between tests?\n. Good point, old habits die hard\n. The current implementation of seekable uses both the main playlist and audio playlist, taking the intersection of the two as the seekable range, so I wanted to keep behavior as clsoe as possible. If the main playlist had a seekable window of 50 - 150 seconds, but the audio playlist had a seekable window of 75 - 125 seconds, I think it would make sense to not allow seeking outside of the audio range. \n. Yes I think it will result in multiple events, but I don't think it will be an issue. Once the durationchange eventually fires, since seekable value is \"cached\" and only updated on sync points, each call to addSeekableRange from the event listeners should all get the same seekable value and since addSeekableRange_ checks end > this.nativeMediaSource_.duration after the first call, the subsequent calls will do nothing if they get the same seekable value\n. I guess this depends on if we want seekable to depend on the audio playlist seekable range ( see conversation above with @imbcmdth ). If the answer is yes, then if the audio playlist doesn't have a seekable range, then we probably don't want the player to think it has a seekable range when there is no seekable range for the alternate audio\n. It felt pretty good to delete this\n. I'll reword/structure the comments here to make more sense. Just to clarify, the only issue here is the comments, or is there issues in the code logic as well that is at risk of losing precision?\n. I want to say I had a reason for doing this, but I can't recall what it would've been. Looking at it now don't really see any harm in setting this.seekable_ = videojs.createTimeRanges() at the start. I'll give it a shot and make sure it doesn't break things.\n. You can use Date.now() instead of creating a new object\n. Why does a reset of throughput set the count to 1, but reseting the bandwidth below resets the throughput to a count of 0?\n. startOfLoad_ is a bit misleading since this is actually a timestamp post-load\n. This is the same test as line 472\n. in a fragmented mp4 and/or encrypted stream case, we have to wait for all our requests (init segment and/or key), depending on the order we receive the responses, setting the date here will affect the throughput calculation. Not sure if this behavior is ok or not\n. not really, was just following suit of already existing code https://github.com/videojs/videojs-contrib-hls/blob/master/src/videojs-contrib-hls.js#L287. If the list is changes (e.g. a quality level is removed with removeQualityLevel, then it wont be the same. A quick search to confirm the index will fix this.. added (not sure why github didnt pick this up as outdated along with the other comments)\n. Was just trying to avoid an extra check. If no quality level is found with the correct id, i will become -1 at the end of the loop, which is what we want to set selectedIndex if there isnt a selected QualityLevel, but along with your comment above, it definitely makes things less clear and its nothing extra to restructure this in a more clear way. Yes, although selectedIndex shouldn't ever be -1 unless a user manually changes the quality level list, if listening to the change event, this will allow them to see the invalid state and correct or catch any errors instead of this changing out from under them. Can we actually get to this check if the segment is a sync request? In handleSegment_ we return if it is a sync request and never append, so I would think this check is unnecessary. . Good call, I'm thinking an isEnabled(playlist) exported from playlist.js since we have other playlist utility functions there . The function is not as useful here since we still need to get the intermediate information of whether the playlist is blacklisted or not. In the other places we only care about if the playlist is enabled or not, but here we want to make sure that the playlist isn't blacklisted even if enable differs from currentlyEnabled before calling the changePlaylistFn. This doesn't really affect anything since this function doesn't use this, but I think it's safer to not use arrow function syntax for top level functions just because it creates special behavior. Can we add an underscore and @private to this since we don't want this to be a part of the api that we are exposing. I think we should plan to not do a deep import in the future, but it is ok for now. Good catch, slipped through the rebase. So I added this to filter out media that was blacklisted in excludeIncompatibleVariants_ so that we don't add quality levels for a playlist that will never be selected. It's a good point that since every time representations is called, it rebuilds its list with this filter, so temporary blacklisting will get removed here. With respect to quality levels this isn't an issue since we only call representations once and then work with the quality level list. Could filter on media.excludeUntil !== Infinity instead to remove the permanent blacklisted media but still allow temporary blacklists through.. Yes, the original function used just the playlist but this PR needed to change that since the call to bind below would reference an outdated playlist object since PlaylistLoader overwrites the reference when it gets a new playlist. This ensures we are acting on the correct object.. Nope, we fire a loadedplaylist event every time we refresh a playlist, but only fire mediachange when the playlist uri changes. This function is only called on those mediachange events.. I think the current decision is that the current solution is OK for now, and we can revisit it later.. That is actually covered with the above playlist excludeUntil: 0. I think it would be good to also check loader.pendingSegment_.segment.uri is what you expect whenver checking loader.pendingSegment_.uri to to make sure the new segment object we are attaching to segmentInfo is the correct reference. Why do we only do these adjustments for non-sync requests. It probably doesn't matter if we don't save the info on an outdated segment object when its a sync-request because we don't append it and if we do need to append it in the future, we are going to have to re-request/probe/sync it anyway. However, I think it probably doesn't hurt to make sure the timing info we get from the probe of the sync request to be put onto the segment object. It might help make other calculations that fallback to target duration when start and end times are unavailable be more accurate. vjsstandard linting rules require the cases to be the same indentation of the switch. I too prefer the cases indented. This is to limit the number of workers we are creating. We currently already have one worker for transmuxing. Creating the decrypter in each loader brings that number up to 3, but there really isnt any reason we can use the same worker since decryption doesn't need state. Also, since we always create an audio segment loader, but the common use case is muxed video and audio source, the audio loader is often not used, but would still create a wasted worker. A short comment here explaining that you're setting currentTime to 31 so the loader selects segment 3.ts would be helpful. It took me a while to figure out why segmentInfo.mediaIndex starts at 3 down below when loader.mediaIndex = null was being set. You don't need to check for tech.hls.xhr.beforeRequest here. Even if beforeRequest is undefined, the next line won't cause an  exception.. Could change this to previousBeforeRequest = tech.hls.xhr.beforeRequest || videojs.Hls.xhr.beforeRequest; This could remove the need for the if statements below to instead just always set tech.hls.xhr.beforeRequest = previousBeforeRequest;. However, the code in its current state may be more understandable, so I'd only consider this comment if you think its an improvement there. You're right with not needing a check for segmentInfo but i think for check for the track is still needed since both the main and audio segment loaders are instances of this class, but the audio segment loader doesnt have a segment metadata track, so we just want this function to be a noop in that case. Yes and no. It mainly depends on the const Cue = window.WebKitDataCue || window.VTTCue; line. I was following what is done in contrib-media-sources when adding id3 tags, but WebKitDataCue is only in safari right now, and there are some small differences between WebKitDataCue and VTTCue. Mainly, WebKitDataCue does not have a text property but instead a value. For id3 tags this value property has a key and data property usually. My goal with these lines was to minimize the differences between the two cues so that you can just use cue.value in all the browsers. After having to explain this, it may just be better to only use VTTCue and not jump through all these hoops. Adding a test for overlapping segments is definitely a good call. I don't think being on a different timeline makes a different and needs to be tested. At the point of creating the cues, the start and end times have been converted to display time, so the non-congruent timestamps across discontinuities are not a factor. Well VTTCue is supported in safari, its just that WebKitDataCue is only supported in safari. Is it best practice to use these types of cues for certain purposes, or are they more general purpose and its not \"wrong\" to just use the VTTCue for safari as well?. Deciding to stick with what we do for id3 metadata tags since these cues are another form of metadata. do you mean if say you wanted the uri, accessing it should look like cue.uri instead of cue.value.uri?. The names here do not match the actual parameter names. Array.sort works on the array in place, so the indices of items will change as this function is sorting. You need to use the original indices of the items in the array for stability. Since we are trying to avoid adding properties to the original elements, I'd suggest creating a copy of the array before sorting to check indexOf on. The slice call here is a lot of overhead just to get the last element of the array. You can just index into length - 1 like you do in the bandwidthBestVariant filter above. Same thing with this slice as the other comment. While I think in most cases, resolutionPlusOneList[0] will be the smallest resolution, the original list of playlists is only sorted by bandwidth. This leaves the possibility that a variant with lower bandwidth but higher resolution would come first in the list.. I think it would be good to test not only same bandwidth, but combinations of playlists that have the same resolution and bandwidths, playlists with same resolution and different bandwidths, and playlists with same bandwidths but different resolution.. You're right, I missed that. This should be fine then. You can avoid this if you make str and array pushing each start+end and return str.join(','). (It's also better for performance, not that these ranges will ever be large enough for that to matter). seekable -> seeking. It's probably safer to leave this check in here, just thought I'd note that I don't think we can get into this function with seeking is false since the check this.tech_.seeking() && this.fixBadSeeks_() won't call fixBadSeeks_ if seeking returns false. Why is this check made in both checkCurrentTime_ and waiting_?. I understand this is to limit ping-ponging between renditions without at least appending another segment, but i worry this could cause unwanted timeout errors. I could imagine that in a live scenario where we are close to the live point, and we do a rendition switch, now if this is a new rendition, we have to wait for a sync point, then another load + append, and another load + append before we are considered walkingForward. If in this intermediate time, we reach the end of the buffer and waiting on buffering, we may not fire progress events for some time if bandwidth conditions cause those loads to take a long time. This could cause a timeout when we otherwise would be notifying the player that we are making some type of progress. I don't think its bad to have this for VOD. Seekable doesn't change in VOD anyway, so if someone tries seeking outside of the duration of the video, this would just adjust it to 0 or end of video depending on which direction they overseeked. You can just pass loader.master.playlists.filter(isEnabled) for the callback instead of defining an anonymous function that just calls it. Description doesn't match what is being asserted. if currentPlaylist === this.masterPlaylistLoader_.media() the call to media() on the playlist loader will exit early without starting another request for the playlist because it considers it not a change in media. Playlist loader should continue refreshing the live playlist until the playlists stop erroring  (or the player would timeout if videojs-errors is included in the page). I think it would be good to pull out this section of calculations to a separate function as this event handler is getting quite gnarly. seekableEnd, lastBufferedEnd and endTime have the potential of being NaN at this point since seekableEnd and lastBufferedEnd may never be assigned a value if the conditionals for the if statements fail, and playEnd may be null from this.playlistEnd() affecting the calculation of endTime. It isn't necessary to attach this function to MasterPlaylistController, you can just call playlistEnd directly where you need it. On top of that, if you attach playlistEnd to the default export of playlist.js, the default export is already included in the Hls object available in this file. If you go that route, you do not need to import this function in a seperate import call, and instead could just call Hls.Playlist.playlistEnd() . this function is very similar to seekable defined just below. Is there any way we can reduce the amount of repeat code here?. No I don't think that will work. When a playlist request errors, PlaylistLoader triggers an error and returns without setting up another request. At this point we want to kick PlaylistLoader back into gear to start requesting the final rendition again. Calling media() will normally do this as long as the media passed in is not the same as the current media. Calling load() will also kickstart the loader, but depending on the loader's state after an error occurred, a load may never actually get the loader started. This will probably require some changes to the way PlaylistLoader handles errors so after an error, it gets reset to a state that it can start loading again. Ah didn't notice that. Hmmmm, its not a big deal to attach the function, but if you come up with another solution that doesnt require it, thatd be great. With lastBufferedEnd for example, you declare lastBufferedEnd at the start of this function, so it is undefined. The only location lastBufferedEnd is assigned a value is on line 378, which is inside the if (buffered.length) check. If buffered.length === 0 then lastBufferedEnd will still be undefined and any calculation involving lastBufferedEnd e.g. endTime = playEnd - lastBufferedEnd will result in NaN.\nWith that said, looking at this again, it may be ok for this to happen. Since any comparison with NaN will return false, seekable.length === 0 or buffered.length === 0 probably means we don't have enough information to know if the playlist stopped updating and probably shouldn't blacklist it. This will require testing to see if we can create a scenario in which those values result in NaN but we still want to blacklist. I think this should use stats.roundTripTime or use Math.max when initializing roundTripTime to avoid division by 0 (I assume the use of Math.max above was to not report a round trip of 0). Wouldn't unshifting cause the original error that caused all the aborts to be at the end of the array? You abort all the other requests, unshift the error, and then when the aborted requests get handled, they would have an error here and unshift themselves in front of the original?. Does it hurt to call abort on a request that has already been aborted? If so should probably add a check for that here as well. If one of the requests causes an error, the rest of the requests are aborted which in turn would cause an error on the aborted request, which would loop through all the requests again, even the aborted one. This bandwidth array isn't used anywhere. What is it for?. I think {Object|null} or {Error|null} would be acceptable here. gathers some ~~states~~ stats. This is a bit confusing. Can you explain the limitation? (Not requesting you add more detail to the actual code comment). why remove this?. This definitely has the effect we are going for, but changing the playlist loader's state outside of itself like this can make debugging difficult because now you have to know about this one line of code in a separate file that changes the state. I think we can safely restore the state in certain error conditions without introducing regressions. There are only a few places that errors trigger in PlaylistLoader and some places already use the playlistRequestError function which the optional third parameter takes a state value to reset that to.  I think you should be able to safely reset the state in each error condition using this.. This should return null by default isntead of 0. If there isn't enough information to determine expired time, returning 0 would be sending false information if there actually is expired time.. Since you moved getPlaylistSyncPoints to calculateExpiredTime calling it again here just to check for null on expiredSync segmentSync is unnecessary work. If calculateExpiredTime starts returning null when it can't calculate expired, you can just check for null on expired instead of checking the sync points. minor, but I think we can come up with a better name for the method. Maybe isPlaylistOutdated_, isPlaylistStagnant_, isPlaylistUpdating or something along these lines that is a bit more descriptive of what the method does. (note the return value should reflect the name logically). This method should also be private, indicated by the _ appended to the end of the name. That is a good point, but I don't think returning 0 is the right call here since there are live scenarios where we may not have any sync points, but there has been expired time, we just can't calculate it. Since endList indicates a VOD asset, we actually already have a known sync point then just off knowing endList alone, which would be { time: 0, mediaSequence: 0 } since VOD always starts at time 0 segment 0. I'd say it would make most sense to update getPlaylistSyncPoints to set expiredSync to { time: 0, mediaSequence: 0 } if  playlist.endList, otherwise set to playlist.syncInfo, and finally resorting to null. That way calculateExpiredTime can properly calculate for VOD case, while still returning null in the live case where we don't have enough information. I think it would be better to do Math.random().toString(36) like you do with decryptionId in mediaSegmentRequest.. Why not use segment.requestId here instead of generating another random string?. So I was giving this more thought and I think we can avoid worrying about it all together by calling this method and blacklisting the playlist outside of the loadedplaylist listener. Playlist Loader already knows when a playlist it has loaded didn't actually update the live window. The isPlaylistOutdated_ method more so checks if the player is stuck at the end despite loading \"fresh\" playlists. If instead playlist loader triggered an event at that moment it knows the playlist isnt a fresh update, then MasterPlaylistController can listen to that and run the checks for playlistOutdated and if those checks pass, then we blacklist. This way we wont run these checks every time the playlist is refreshing correctly and run the risk of accidentally blacklisting a playlist we don't want to. From #1043 \n@imbcmdth: Just curious: why this was renamed?. from #1043 \n@imbcmdth: At some point I feel like it might just be nice to have an array of active segment loaders. Then we can just do this.segmentLoaders_.forEach((l) => l.load());... not necessary now but maybe a good idea to think about soon.. from #1043 \n@imbcmdth: If handleSubtitleError_ calls setupSubtitles is there a possibility that an infinite loop of failure will result?. from #1043 \n@imbcmdth: Why not move this to where the SegmentLoader is paused above. It's easier to reason about the state of the loader if it is manipulated in one place. Also, shouldn't it be reset even if there is no track?\n. from #1043 \n@imbcmdth: Is this function used anywhere? If so, it needs a comment.. from #1043\n@imbcmdth: Couple of thoughts on this whole block:\n\nWe should pre-calculate the vttLineTerminators value because it's a typed array that never changes.\nI think we should do the entire append process when we first get the response for the initSegment so that we the object stored in this.initSegments_[initId] already has the value that would be in combinedSegment.. from #1043\n@imbcmdth: If error is fatal it should have some code set in addition to the message. The code is important for reporting reasons.. from #1043\n@imbcmdth: Everything about this feels wrong and dirty! \ud83d\ude31 . @gesinger and I noticed that load calls start if start hasn't been called yet and is safe to call multiple times, but start should only be called once. Since this call is in the MasterPlaylistController constructor, theres no risk of running into that scenario, but we decided to just change any calls to start into load so we didn't have to concern ourselves with it. We can change it back if you think start makes more sense semantically  . It shouldn't since just above we set the current active tracks mode to 'disabled'. This has the same effect as turning off subtitles through the UI. . setupSubtitles gets called everytime the player's TextTrackList fires a change event. When changing subtitle tracks through the player ui, depending on which track was selected and which track you are changing to, this event will fire multiple times. (it also fires a change event if you select the already active track in the UI) Only one of these calls will actually reset the playlist loader and segment loader to start loading from a new track. By only resetting when we are actually changing tracks, we avoid reseting the segment loader after its already started from the previous call, or if the user selected the already active track, then all that happens is the segment loader is paused and unpaused. Also, yes it should be reset even if there is no track, but since we always reset before starting a new track, it will get reset when the user turns subtitles back on.. Agree with both, good ideas. The mediaUpdateTimeout should be cleared immediately after this if block in case load is called from somewhere else and that caller doesn't want to wait the delay, we dont want the delayed call to run as well. maybe name the event playlistunchanged ?. I know I've suggested renaming this already, but now that we have an event that signifies the playlist is outdated/not refreshing, and this method more checks if we are stuck at the end of the playlist, so maybe somthing like stuckAtPlaylistEnd_or isAtPlaylistEnd_. Then our logic sort of semantically reads like if the refreshed playlist is unchanged and the player is at the end of the playlist, blacklist this playlist.. reminder to self to revert back before releasing. the resync functionality actually checks for the existence of segment.end so we are safe leaving it here if we never set it. For the vtt-loader, no it isnt. I think it would be good to add a check between the two refreshes to make sure the playlist wasnt blacklisted early. (you may have to move the play and playing triggers up, not sure though). This test is actually outdated from before simple-fetcher times when there was the offset correction variable to handle incorrect guesses, (now we just walk forward), it just wasnt skipped/removed previously because it happened to pass after segment loader changes. If you notice the other playlist offset tests are also skipped. I was planning on cleaning up skipped tests when the loaders get refactored. While the state is not WAITING any aborts will just clear pending segment (which at this point there isn't one yet) and does nothing else. The callback will set the state to ready and call monitorBuffer_ to restart the lifecycle. Since it starts back from the beginning, any seeks or subtitle changes that happened in the waiting time shouldn't have adverse effects. This is basically the same as aborting while waiting in the DECRYPTING stage, the callback will call handleSegment_ again and if it was aborted while we were waiting, the first if block will reset the loader to READY. I think it will be better to do these changes when we integrate mediaSegmentRequest since that changes when the maps are stored in initSegments_. setTimeout needs to be passed a callback that calls loader.load(false). You could also bind a call to load with false passed, loader.load.bind(null, false) You should also return after setting the timeout, otherwise the rest of this function continues to run anyway eliminating the delay. surprised this went unnoticed for so long being cased incorrectly  \ud83d\ude04. Why should this be audioPlaylistLoader_ vs audioSegmentLoader_?. I believe that is why, but now since the playlist loader has a delay, it should probably be done for both live and vod. What about putting the endOfStream call in a try catch and if it fails trigger the error on MPC? I feel like we probably want to still call endOfStream in the common case of not hitting an InvalidStateError. Since stuckAtPlaylistEnd_ only uses seekable to check if we have a seekable range, but doesn't use seekable.end(0) for any of its checks, is there even a point to checking not stuck at playlist end when currentTime not at seekable end even if the buffer is empty?\n\nIf we still want to keep this part in, I'm not sure having playlistEnd and seekable.end(0) both be the same (130) is representative of an actual scenario since seekable.end is the time since playback started to minus 3 segment durations from the end of the window, where playlistEnd is time since playback started to minus 0 segment durations from the end of the window.. When a live stream is finished, usually an EXT-X-ENDLIST tag is applied to the end of the playlist even though it wasn't originally a VOD. This would set expiredSync to { time: 0, mediaSequence: 0 } even if that isn't an actual sync point. We should prioritize playlist.syncInfo if it exists, otherwise { time: 0, mediaSequence: 0 } if playlist.endList is true, otherwise null.. Can you go into detail of what the issue was and why changing the order of checking for timeout then errors solves it?. ~~Should this be moved to test-helpers.js so all our tests involving XHR act more like real, native XHR?~~\nCommented before I got to the bottom of the PR. Why is this here in this test and in test-helpers.js? Won't oldXHRPrototype be what we want?. Shouldn't this be fakeEnvironment.xhr.prototype?. Now that xhrFactory adds the aborted property to aborted requests, shouldn't these tests still pass since there will be an aborted property?. Right, thats the point of this test. I mean that with the combination of xhrFactory also setting aborted to true and the reordering of checking for timeouts and aborts before errors sounds like all the other tests that would break by the removal of the line that sets aborted to true in sinons FakeXHR should not break, and if they are, I feel those tests should be updated to check for the correct error condition. You should specify what the unit of time is here. I think allowing blacklistDuration to be set in seconds by the user and converting to ms here would make this option easier to use. if a playlist is blacklisted. duation. If the user sets blacklistDuration to 0 this will change it to 5 minutes. Probably also want to make sure it is a number ~~and use options passed to player.src~~ like bandwidth below. I think you should add a check here to make sure blacklistplaylist is still 1. This can just be this.masterPlaylistLoader_.master.playlists. Is there any reason we wouldn't want to return this error for key requests? I think it would make sense to put this check at the end of handleErrors and just return the errorObj instead of making the check in both segment and init responses.. That was why I originally had the 1 second safety net. The Ranges.findRange function uses TIME_FUDGE_FACTOR which I thought was more inline with your previous comment. I'll make sure to test this exact scenario and see if it triggers the event, and if so, we can discuss an appropriate fudge factor to protect against this. I'm not sure how necessary the 0.5 safety offset is now that in checkCurrentTime_ we check to see if we are at the end of the buffer. Thoughts?. It has to go here actually. If we put it in waiting_, it'll be too late and we get the same problem of consecutiveUpdates surpassing 5 while waiting on slow connection, then when the buffer is asynchronously appended to, everything will look fine in techWaiting_, so waiting_ will trigger the unknownwaiting event. Putting the buffer check here before we increment consecutiveUpdates allows us to not consider waiting on a slow connection as a possible stall. That way when we actually run the checks in waiting_ and techWaiting_,, we know those checks are attempting to correct an actual stall, and not just slow connection.. any reason to not trigger straight from the tech within MPC if the HLS source handler isn't doing anything other than forwarding the event to the tech?. I think it would be a good idea to make movingAverageBandwidthSelector and lastBandwidthSelector not rely on this. I think that this is the only place that using average bandwidth vs bandwidth makes a difference. Is there a way we can contain the changes to here?. We use bandwidth comparisons for two different operations, sorting and filtering.\nFor sorting, if a playlist has a higher bandwidth, then it should have a higher average-bandwidth as well, so it should be safe to use BANDWIDTH instead of the average for sorting.\nFor filtering, (ignoring the filter I commented on saying the average makes a difference), we compare the bandwidths to check that they are equal for the purpose of identifying redundant streams. The attributes of redundant streams should be the same, so it should be safe to use either here. Apple also doesn't specify if the AVERAGE-BANDWIDTH attribute needs to be the same across redundant streams, so I may even argue not using the average is safer here to make sure primary is chosen over backup.\nI'd say that it actually is less consistent with which bandwidth we are using for comparisons and guards less against missing/empty attributes. Since AVERAGE-BANDWIDTH is an optional property, if we opt to use it in either a sorting or filtering scenario, all it takes is for one stream in the list to not include the attribute and all the sort/filters will be incorrect.\nThe filter at this line however, is comparing bandwidths to the HlsHandlers computed bandwidth numbers in order to filter out playlists that have too high bitrate for the current bandwidth. Using the AVERAGE-BANDWIDTH here lets us consider a playlist we would otherwise throw out because its max bandwidth was too high, but on average, is lower bandwidth.\n(made a separate comment regarding comparePlaylistResolution) . I actually think this fallback is no longer needed now that we've introduced stable sort a while back. In the playlist selector, we first sort and filter by bandwidth, and then sort by resolution. Since we are sorting a pre-sorted list by bandwidth and using a stable sort, any entries that have the same resolution, will maintain their bandwidth sorting.. In practice, most m3u8s should exhibit all or nothing, either AVERAGE-BANDWIDTH is present on all playlists, or it is present on none.\nI agree with this, and a \"best available information\" approach for this case seems like it will still give desired results.\nit is possible for a playlist to have a higher BANDWIDTH but a lower AVERAGE-BANDWIDTH than another playlist\nI'm not entirely convinced this means we want to use the average when sorting. If I'm not mistaken, the goal of the playlist selector is to select the highest bandwidth+resolution we can support with the current system bandwidth. If a playlist with a lower BANDWIDTH has a higher AVERAGE than others, then it will be considered to have a higher bandwidth in sorting. This could make the player select the playlist with a lower overall bandwidth but higher average. Maybe this is desired, but from my understanding it is not. \nRedundant streams with differing averages still concerns me, but I haven't seen any real world examples of redundant streams with average-bandwidth to know whether they are likely to differ or not.. I don't think we need to keep it for that reason. comparePlaylistResolution may be exposed, but its exposure is not documented anywhere as something that can/should be changed, so I think its reasonable to change it. This is the same reasoning as the call to not worry about this method (and the bandwidth comparator) being moved from videojs-contrib-hls.js to playlist-selectors.js such that STANDARD_PLAYLIST_SELECTOR no longer uses the comparators attached to the Hls object.. Do this first, and then use stableSort on this list for both comparePlaylistBandwidth and comparePlaylistResolution. This way both those functions do not need to add a new parameter useAverageBandwidth and you can use comparePlaylistResolution again instead of the anonymous function.  Then you just need to check rep.bandwidth in the compare functions (this makes comparePlaylistBandwidth a one-liner!). \nId say the main argument against this approach which I predict will concern you, is that it changes the compare functions internally such that anyone using the exposed compare functions (even though we've never said you should do that) will break. Again I still believe this is ok. We've already broken overriding the compare functions but not the simple selector by moving these functions to their own module.. the || void 0 isn't needed here since if playlist.attributes.BANDWIDTH doesn't exist, bandwidth will already be undefined. Though I'm ok with leaving it in for the sake of making it clear the function returns undefined in some cases. since we are no longer sorting the sortedPlaylists itself, this can just be master.playlists.map(... without affecting the sorting of the original list. don't needrep.bandwidth &&since you default toMAX_VALUEwhen creating the reps. If you do this before the sort above, and then stable sorthaveResolutionyou can remove the local constants and make it a one-line like the bandwidth sort. Should we add a suggestion on what alternative the user has if they get this message? e.g. one of our other deprecation messages saysplayer.hls is deprecated. Use player.tech_.hls instead.I guess the alternative here is, write your own compare function, so maybe an alternative doesn't really apply here.. Maybe add a test that ifuseAverageBandwidthis true but the avg isn't available, it falls back to the max. For this test (and any others that use any of the constants inConfig, I think it would be a good idea to override the config option with a set value for the test, and then restore is at the end. That way down the line if we decide that there is a better default value for that constant, we don't have to change all the tests that are written in a way that assume the old default value since a different default does not change testing the functionality . Or use it when creating the time ranges like you did belowvideojs.createTimeRanges([[10, 10 + Config.BUFFER_LOW_WATER_LINE]]). In the name of style consistency, can we put);on the next line like you do in line 222.bandwdith ~~0~~ undefined`. hmm I do see MDN says that, but it is working in chrome, so the MDN pages for progress events must be very out of date. Do we want separate rates for low waterline and goal buffer length? Or a single rate that they both increase at?\nAnother note, maybe instead of defining a rate so that we scale current time with and add to the min, what about defining a max, and a time at which the max should be reached. and just interpolate. e.g. with wanting to reach max at 30 seconds, let t = Math.min(currentTime / 30, 1); GBL = (1 - t) * 30 + t * 60;\nThoughts @gesinger ?. I'll do a double check in our platforms to see whats in event.loaded I think at this spot we dont have to do anything different, but in the abort early section when we look at the stats we should check that its a valid value. 5 seconds is arbitrary. I like the idea of using target duration or the segments specified duration. Maybe half the segment duration? If we've already spent half the duration requesting the segment and bandwidth is still low, it might be a good time to switch. Another idea is what if we incorporate forward buffer so that the closer we get to the end of the buffer, the higher the adjustment ramps up?. IE11 and Chrome both are giving values in loaded, so we should be covered but have a guard in case is a good idea. well here const firstByteReceived is the time that has passed since we received the first byte of data. msSinceFirstByteReceived maybe. Actually, we don't need any checks because NaN < Number will always return false, so we won't actually act upon undefined values. If you do a math operation with undefined you'll get nan, so stats.bandwidth = Math.floor((stats.bytesReceived / stats.roundTripTime) * 8 * 1000); will be NaN if bytesReceived is NaN. Even if NaN wasn't guaranteed, compare operations with undefined will be false as well. I'm skeptical of setting it to any other numerical number because then we may act upon that value when really we only want to act when we know we have actual info\n. Well, I feel like this adjustment number is doing 2 things. \n1. is accounting for bandwidth ramp up, as time goes on, bandwidth will have ramped up and become more stable, so we can use a value closer to the real bandwidth of the playlist. This is also why below we make sure its been about 1 second since first byte seen. I've run some (granted not very exhaustive) experiments that seemed to show around 1 second is when bandwidth from the progress events stabilizes.\n2. is that increasing the adjustment as time goes on, allows us to be more likely to emergency abort when the request is taking too long. I like the idea of using segment duration here because 5 seconds may not be too long for 10 second segments, but for 2 second segments it is definitely way too long, and we probably should've been using the full 08. well before 4 seconds since request. I don't think there is any need to consider the player size for this because it is only checking playlists with a lower bandwidth than the current, which will most likely be a smaller size than the current, and even in the chance there are bigger ones with lower bandwidth, if it means that we can avoid any rebuffering, that benefit out weighs picking an appropriate resolution for the window size. It's not grabbing just the max bandwidth that wont have rebuffering. Its returning the playlist that will provide the minimum amount of time rebuffering. If there is a playlist where the amount of time rebuffering is 0, then it will be the max-bandwidth that can do it, but if none can bring that to 0, it will pick whichever has the least impact on rebuffering times. this roundTripTime value is used in the return function. We can calculate it again when we get it back, but that seems pointless when we already have the value here.. If the two values are equal, we might as well just stick with what we got and not abort, so I think strict is reasonable here. You're right, thinking backwards again. Is this option needed? Any reason to not just have storage always enabled, and allow the setting of whether its actually used?. Why not just merge options into the first parameter instead of having two parameters that are both option objects?. Maybe just rename segmentLoaderOptions to segmentLoaderSettings then. not necessary but maybe make options = {} optional. That way you don't need to add the empty objects in the test files. Maybe in SyncController as well. Sticking w/ Rate for this PR. You can just make this a single region [[0, 19]] and same with the buffered a few lines below. Not a blocker though. Config.MAX_BUFFER_LOW_WATER_LINE. It's only storing 2 ints though, so I don't think it will be a big issue. Either way, I agree with @forbesjo , we should just use one flag to turn off both storing and using. I know previously we've discussed turning on the storing but not the using, but I don't think that matters much, especially since we are wanting to go the usage event route. Yes, but because of the way the closure works, if we don't do this between tests, each test will be using the moving average of all the previous tests. yes good catch\n. Since the selector now uses a moving average instead of the instantaneous, the bandwidth value that is being compared is the moving average of 1 and 4Mb, instead of 1. Needed to update the bandwidth of the playlist so it would still select . Yes, but because of the way the closure works, if we don't do this between tests, each test will be using the moving average of all the previous tests. Yes, but because of the way the closure works, if we don't do this between tests, each test will be using the moving average of all the previous tests. Yes good point. this event will fire for every source, regardless of alternate audio usage. This event (and the hls-fmp4 event below) will trigger for every rendition, as well as every playlist refresh in a live playlist, however for these two events, we only care to fire it once per source. I don't think we will encounter a scenario where some variants use fmp4 and others use ts, or some have hlse and some dont.. This should be moved into the if block just above.\nrep.enabled(false);\nrep.enabled(false);\nwill cause two triggers, but I don't think it makes sense to trigger the event twice when its not switching from enabled/disabled. can delete these comments. should trigger this on this.tech_. We want this event to mean that video and audio is demuxed by default instead of when alternate audio is present. However, it would still be nice to know when alternate audio is present. I suggest changing this event to hls-alternate-audio.\nFor the hls-demuxed event, I think a good place to put it is within fillAudioTracks_. Since the DEFAULT attribute for media tags is optional, the best way we can detect that video and audio are demuxed by default is if all audio renditions have a URI, since the lack of uri means the audio is muxed with the video for that rendition. fillAudioTracks_ already has to loop through all the audio groups, so I suggest checking each one within the loop for a uri, and after the loop if they all had it, fire the event. I think it makes sense to move this event to videojs-contrib-hls.js in the audioTrackChange_ method. You should be able to trigger on the loader yes.. It didn't work because tech.hls is already a property (gets attached on HlsHandler creation). This event is a bit weird because we'd have to define the getter before creation, but that means an code within the project itself that accesses tech_.hls would fire that event. For now we can hold off on having an hls-tech-access event and stick with just the hls-player-access. We should move these checks out of the loadedplaylist listener and into loadedmetadata listener. laodedplaylist will be fired for every playlist refresh in a live stream. \nAlso, since loadedmetadata is only fired once for the first media playlist we load, moving this there would remove the need to have extra state for isAes_ andisFmp4`.\nI also think it would be a good idea to move these loops into helper functions either on the PlaylistLoader or in playlist.js . since we control this event and its being triggered on the PlaylistLoader and not the tech, we don't need to have the hls prefix. But the usage event fired on the tech should still have the hls- prefix. since we control this event and its being triggered on the SegmentLoader and not the tech, we don't need to have the hls prefix. But the usage event fired on the tech should still have the hls- prefix. This is true. There are two problems regarding the segment duration. One is that not all segments have to have the same duration. Second is that if we have not yet requested one of the playlists, we don't even have target duration yet to estimate segment sizes on that playlist. I thought that the best alternative would be to use the duration of the segment we are requesting, because although not required, its likely that across renditions, the segments are segmented in a similar way, so if we want to cancel the current request to request a smaller replacement, we will probably be requesting a segment with similar duration to the one we are cancelling . We should update the 3 other trigger calls in PlaybackWatcher into usage events hls-live-resync hls-video-underflow and hls-unknown-waiting. for this test you'll want to be checking for the hls-video-underflow event. The gap skip event wont fire in the video underflow scenario. I think these would be better suited as utility functions inplaylist.js. They don't rely on any state of the loader so lets not put them on it. these two methods could use a simple unit test each. maybe hls-error-reload-initialized. You need to save a reference to the original Hls.Playlist.isAes function and restore it at the end instead of the Hls.Playlist object. since Hls.Playlist is an object, playlistCopy is just a reference to the object and not an actual copy. Same goes for isFmp4. You either need to pass in an object representation of a playlist like in the test above or create a loader like the test 2 below and respond to the xhr request with this string. These tests should be failing, but passed in traviscli (and probably locally for you) because of the overriding of the isAes and isFmp4 methods you did in master-playlist-controller.test.js. we should add tests for the error reload events. . isAesCopy. isFmp4Copy. while functionally this works, it doesn't make much sense to use trigger() to also get the values of whether other events have been triggered. \nYou can mock the tech in a similar way the player is so that it gets event handling automatically.\nthis.tech = new videojs.EventTarget();\nthis.tech.currentSource_ = {\n  src: 'thisisasource.m3u8',\n  type: 'doesn\\'t/matter'\n};\nthis.player.tech = () => this.tech;\nthis.player.tech_ = this.tech;\nWith this you should be able to listen on the tech for the events you want within the individual test runs. same concept here regarding trigger. the hls-demuxed event is triggered in fillAudioTracks_ which is called after loadedmetadata handler which happens after the first non-master playlist request, so there should be no need to wait for a video or audio segment request to be fulfilled before seeing this event. long ternaries can be hard to read. minor but can we check if(enable) and switch the order of the triggers. At first glance I thought these were wrong because currentlyEnabled is true but we trigger disabled. reload-canceled event has .... this should be a presence stat. we should make this private and maybe name change triggerPresenceUsage_. this whole if block is not needed. The properties within mediaGroups.AUDIO are objets instead of arrays so this check will fail. You could check Object.keys(mediaGroups.AUDIO[audioGroupKeys[0]]).length. Could also make use of the audio group loop you do above for demuxed and use a counter to see if there is more than 1 alternate audio. Since reloadSourceOnError is a plugin, sometimes the tech is not available yet during plugin initialization. We should change these 3 events to be on the player player.trigger.\nAlso because plugins can be initialized before the player is ready, the hls-error-reload-initialized should get wrapped in a ready handler\nplayer.ready(() => {\n  player.trigger(....\n});\n. To keep style consistency (and follow linter rules), lets put the && at the end of the previous line instead of the start of this line. Maybe add that \n\nHLS usage events are triggered on the tech with the exception of the 3 hls-reload-error events, which are triggered on the player. . This shouldn't be necessary since you set this.player.ready in the beforeEach. We should make getter functions on MPC for low water line and goal buffer length, and pass the GBL one down to the segment loader to use. firstByteRoundTripTime is probably not the most accurate property name. let's do this todo. I think maybe we should calculate based on GBL. The reason we lowered this was we increased GBL from 30 -> 60, so we decreased the trim. Maybe we should have a rule of only having 90 (or something similar, while also having some minimum trim incase someone sets GBL very high, we still want to trim content) seconds buffered max and depending on GBL, trim the remaining?. Should we make them all have the same constraints (e.g. positive integer) and remove the low waterline constraints for being below GBL? We can just make sure to check for valid numbers whenever we use them and make no assumptions about what the numbers are, which we already do I believe. One reason is that we reuse haveResolution in different filters to get different values, so it's probably better to sort once then filter twice than filter twice and sort twice. We only ever sort twice, once by bandwidth and once by resolution and I think its easier to reason about the filters when they are working on sorted lists. should GOAL_BUFFER_RATE be updated to GOAL_BUFFER_LENGTH_RATE then?. Yea it selects the best rendition available given the bandwidth and player size constraints. This test is actually just one test, order is very important here. There is only one segment request in flight for this test, each dispatchEvent call is mocking a progress event for the xhr request. using the value on loaded within the event and the number of clock ticks that have passed since the request has been made is what is being used for the estimated bandwidth. deciding to go back to 60 second trim. Comment in code above stating 150mb should actually be 150MB which is ~5 minutes of playback, so we should be safe keeping 60 sec of back buffer. In the test suite i decided to set this.goalBufferLength = MasterPlaylistController.prototype.goalBufferLength.bind(this) to eliminate the duplication. How are you with that approach?. No, thats why we multiply by 8 to convert to bits. You just like making staying under 90 chars per line difficult\n\nedit: this fits perfectly\n. It looks like it succeeds here because currentTime === 0 and initial BUFFER_LOW_WATER_LINE is 0, so the check forwardBuffer >= bufferLowWaterLine is true. . attributes may be undefined on the playlist object so you'll want to check for it before accessing the inner properties.\nAlso travis is failing because the linter prefers dot notation playlist.attributes.BANDWIDTH. new bandwidth ~~does not~~ seems too high. You'll have to sort, no guarantee of order . After a source change, this will set the initialSelectPlaylist to be the standard selector and not the initial one. You should add another properties to the source handler for selectInitialPlaylist and then this becomes this.selectInitialPlaylist ? this.selectInitialPlaylist.bind(this) : Hls.INITIAL_PLAYLIST_SELECTOR.bind(this).\nside note, by my snippet you'll see i personally prefer selectInitialPlaylist over initialSelectPlaylist, but either is descriptive and fine, so feel free to change or keep the naming. @gesinger probably has his own preference. fixing the attributes is something we want to address, see #1205 and https://github.com/videojs/m3u8-parser/issues/25 so we could just wait on that before merging these changes in. Also just adding attributes as a property to value would work as well I'd think, though it may be better to individually set values so the cue isn't holding on the memory reference of the playlist object. Because of the way our PlaylistLoader works live playlist refreshes create a deep copy of the playlist and updating the copy, instead of just updating the original reference. The attributes aren't going to change on refreshes, and its possible there are other places in our code that is holding onto old playlist references, but its probably a good idea to not do so if we know about it. attributes: videojs.mergeOptions(segmentInfo.playlist.attributes, {}). since sort messes with the array, you should use a copy of playslists with slice. you could omit this and just return playlistsWithVideo[0] || playlists[0];. since the initial selector is called within the loadedplaylist event handler which fires everytime a live playlist is refreshed, I think it would be worth simulating a live refresh and confirming that the initial selector is not called a second time. These two responses should go after the sourceopen trigger, also I would expect that the numCallsToSelectInitialPlaylistCalls should increment after just the master response. You can do this without needing to create the initialPlaylistSelector variable. I think it might be a good idea to assert SegmentLoaders bandwidth after the segment request responses to make sure it sets to 800bps and didn't enter the cache path. I think it would be good to finish this request as uncached and observe that bandwidth values are updated and a media change happens. this comment is a bit outdated now. shouldn't need this tick. Can you add Expects to be called within the context of an instance of HlsHandler to this. see lastBandwidthSelector jsdoc . instead of returning null, you could call the last bandwidth selector with the current context\nreturn playlistsWithVideo[0] || lasBandwidthSelector.call(this); I think this would also remove the need to for the temporary selectedMedia. We should probably dig into why this was happening since I don't think it should cause the test to break. Looked into this a bit more, its because if you set this.initialMedia_ and then try and load that media, but the request fails e.g. 404, when on the final rendition, we get back to here, and updatedPlaylist is still undefined because we haven't successfully loaded one yet, but initialMedia_ has been set from the previous time here. I think it would make sense to set initialMedia_ in the loadedmetadata handler if it hasnt been set yet as the first time we get into loadedmetadata is after the first media playlist has been loaded. . Based on the findings from the 404 unit test failing (discussion in other comment thread), this selector should probably filter by isEnabled similar to the simpleSelector since this may try and re-select a playlist that just 404'd. makes sense \ud83d\udc4d . this could be one line const enabledPlaylists = playlists.filter(Playlist.isEnabled);. the || false is not necessary a && b will just be the value of b when a == true. The description is no longer accurate (now returns null) Same goes for the assertion description below. could replace this slice call with the enabled filter, then you wouldn't need to do it later or have the local const. 2 minutes seems very long to me. Should we log a warning like we do when blacklisting other playlists? Related, should we change this to be an event that can notify MasterPlaylistController that it needs to blacklist the playlist so that all blacklisting goes through the same path?. I agree that if we had to abort early because of poor network, it is likely that it will still be an issue in the future. My concern is that this would happen during startup or very early in playback, but then as we have substantial forward buffer, we could up-switch without causing rebuffering, but it may still be within that 2 minutes. This could just be a hypothetical situation that wouldn't actually play out in. I don't think so. I think we would have to wait for either the ready or canplay event from the tech. If the tech is not ready by the time this constructor runs, this will continue to be broken. You should setup an event listener for the ready event instead of checking the private variables on the tech. The tech has a this.tech_.ready() function that will either setup a listener for when the ready event will be fired, or will run your callback immediately if the tech is already ready. . is skipPlaylistSelection really necessary? I think it would be better to leave playlist selection here as is and just trigger abortearly and not bandwidthupdate from segmentLoader. If we are blacklisting the current playlist, I don't really see a scenario in which we would not want to switch from it. I think it's also reasonable to not trigger bandwidthupdate for the early abort case, as the bandwidth set in the segment loader after an early abort is not necessarily the bandwidth of the user, but a specific bandwidth to force playlist selection to select a certain variant. It's a bit of a lie for segment loader to claim it has an update to calculated bandwidth. . Maybe mention this behavior is amplified by browser and cdn caching. If we change this parameter from true to false, video.js will take care of removing the track on source changes. \ud83c\udfb8 \ud83d\udd08 . you should off the handler in the dispose method below like the other handlers\nedit: resolved. This change was needed because previously, after an updateend event, SegmentLoader.handleUpdateEnd_ would call SegmentLoader.monitorBuffer_ which would setup a timeout to call SegmentLoader.fillBuffer_ on the next clock tick, but with the addition of calling load on a seek, this would clear that timeout and set a new one for the next clock tick.. bump :). I'm not sure what you are asking. load is still called on the subtitleSegmentLoader_ it's just that the check for the playlist loader was changed to a different reference. Maybe there is confusion because git diff is matching the load call with one much lower from another function that was removed? (line 1159 for this file, line 636 in the new file)? . I agree the groups groups group grouping gets confusing. I wasn't sure what the best naming would be since as you said, there isn't a collective term, but I like mediaTypes I'll note that the m3u8-parser outputs a mediaGroups property on the parsed manifest object. Not sure if we would rather come up with a naming convention that ties the two together. We need to restart them here because the first action of this function is stopping the loaders. mediaGroup.tracks is an object not an array. Ya it's definitely confusing. masterGroups is the media groups object from the parsed master manifest, where groups is an object we are creating in this function that is in a slightly different format that is easier to work with.\nmasterGroups[type] is also an object, so can't use forEach. default gets enabled later in setupMediaGroups. We could do that here, but default is optional, and if its not specified, we will have to enable a default still anyway.. Object :/. Object :/. actually subtitle errors do not blacklist, so no error will be logged. It is switching from unmuxed to muxed audio. When we are in the muxed audio case, there is no active audio playlist loader because the audio content is coming from the video stream. I left these tests in here as integration tests. I'm in favor of (re?)moving them if you think they would be better placed in the media-groups.test.js or if they are already covered by another test. I left these tests in here as integration tests. I'm in favor of (re?)moving them if you think they would be better placed in the media-groups.test.js or if they are already covered by another test. It might, I didn't think to try that for some reason. I was trying strictEqual but that was not working\nedit: it does :). well thats not really a scenario that would happen. the main group is only created if the master manifest doesn't specify any audio groups. We would run into this problem if a master manifest specifies audio groups, but then has a STREAM-INF that does not have an AUDIO attribute, which I suppose is possible because of the wording of the spec, though ive never seen a playlist like that. Maybe we want to rethink how it falls back in such an event. We could first try to fall back to the group with attribute DEFAULT and if there is none, fallback to some private main_ group that we always create regardless?. not sure what you mean. Do we support this?. Well according to the MSE spec, going from audio only to audio + video will be dependent on browser\n\nFor example, a user agent may throw a QuotaExceededError exception if the media element has reached the HAVE_METADATA readyState. This can occur if the user agent's media engine does not support adding more tracks during playback.\nhttps://w3c.github.io/media-source/#dom-mediasource-addsourcebuffer\n\nSo if we want to support this, we should make sure which browsers support it, and handle the error in browsers that dont. I think its preferable to just not allow switching between audio only and video+audio and vice versa.\nMight be worth seeing what happens when going from video only to audio+video as well, though I'm not sure if that is something anyone is trying to do in their manifests.\n. WRT the other discussion on going from audio only to video+audio\nIf we decide that we want to support that, this will NOT trigger an error in the event that you start audio only, switch to video+audio, and then try to switch back to audio only since this.isUsingVideo_ will be set to false from the initial audio only timing source. Since the much of this is the same, maybe just set a seekTime variable and do the log/seek at the end if it was set\nlet seekTime = NaN;\nif (after) seekTime = seekable.end;\nif (before) seekTime = seekable.start + 0.1;\nif (!isNaN(seekTime)) log; setCurrentTime(seekTime);. seekable can have a length of 0, in which case this will error. Both beforeSeekableWindow_ and afterSeekableWindow_ check the length and return false if it is 0, so you could not create these const here and just access seekable.start(0) if you get into the appropriate if block. Otherwise you will have to check the length here as well. you switched up seekableStart and seekableEnd . a bit misleading saying we expected \"video only\" as we can go from starting with video only to video + audio (sort of, if starting was video only because there was a separate audio segment loader and not because there was just only video stream). I think we could simplify this and still give informative messages\nif (startingMedia.containsVideo && !newSegmentMedia.containsVideo) {\n  return 'Only audio found in segment when we expected video.' +\n             ' We can\\'t switch to audio only from a stream that had video' +\n             ' To get rid of this message, please add codec information to the manifest.';\n}\nif (!startingMedia.containsVideo && newSegmentMedia.containsVideo) { \n  return 'Video found in segment when we expected only audio.' +\n             ' We can\\'t switch to a Video stream from a stream that had only audio' +\n             ' To get rid of this message, please add codec information to the manifest.';\n}. Maybe add a test that has startingMedia = { containsAudio: true, containsVideo: false }; and newSegmentMedia = { containsAudio: false, containsVideo: false }; just to confirm it also returns 'Neither audio nor video found in segment.'. Maybe another test like this but switching from audio only to video and audio. I think it would be good to adda test that passes type === 'audio' since the audio segment loader will also be calling this function. const. Since you make use of the return value, it might be a good idea to explicitly return null or false. Looks like you forgot to updated containsVideo here, this test is exactly the same as the one on line 55. Also would be nice to move the two tests for 'Neither audio nor video found in segment.' next to each other just for reading through, but not necessary . I'm pretty sure everywhere within contrib-hls uses playlists as an array and would require that the index based referenced be updated in order to get the new segments. surprised you didn't use arrow notation here. not necessary, but if you want to cover another edge case, you can have a muxed audio label without a uri in one audio group, and the same labeled audio in another group can have unmuxed so it would have a uri. Playlist loader doesn't care about this detail though, its taken into account in media-groups, but incase you wanted another test case. I snuck this change into this PR because the mode can only be flash or html5, so checking for the case of auto is unnecessary. . You don't need to change these because whats really being tested is object copy and merging, which doesn't care about the content, but it was a little confusing to see a combination of segment and playlist objects being used to test updateSegments.. I'm not sure I follow. This function setupFirstPlay is called when play is triggered until this.hasPlayed_() returns true. Currently, with a VOD, we update hasPlayed_ to return true the first time we get a play call and we've loaded the media. Currently in a live stream, we update hasPlayed_ to true the first time we get a play call, we've loaded the media, and have calculated seekable, so that we can seek to the live point and that segmentloader knows it can start filling the buffer. Since now we have to wait for loadedmetadata from the tech in IE11 before we can seek, we wait to update hasPlayed_ until we've gotten loadedmetadata which happens after we append the first bytes to the source buffer. Since this is asynchronous, this local var setHasPlayed is used to know if we can set hasPlayed_ to true yet. Does this answer your question?. made a function mappingForTimeline. I do understand that the event is more difficult to follow than a direct api, but since we plan on moving away from contrib-media-sources (sooner the better eh) and we already use this event approach else where, I added comments so we can save time on testing a refactor. I've also added comments in the contrib-media-sources pr. Previous assertions failing won't prevent the following from being run, tested your example and variable segments still gets hit and passes. I can still break them up if you think its a good idea, but all the assertions in this test are testing the same function, just different input edge cases, so to me it makes sense to keep all the safeLiveIndex assertions within the same test. Ya we'll just merge that one first and i can rebase this or vice versa. It is used in many different places. Increasing the TIME_FUDGE_FACTOR to 0.1 for everywhere might be a good idea, but it increases the scope of this change a lot and I'm not sure if the other places using this value require more precision. . It might be worth considering adding a warn or debug after loading the first playlist and see it is too short to be safe, but I don't think here is a good place as this is done everytime we calculate seekable, which would flood the console with warnings when one would be sufficient. It only has the recommendation of if the playlist is unchanged, to do half of target duration. It also has this statement\nHowever the client MUST NOT attempt to reload the Playlist file more\n   frequently than specified by this section, in order to limit the\n   collective load on the server.\nSo I think it we should not be more aggressive and just stick with the half target duration when we encounter strange edge cases. With the changes to the safe live point, it created the problem where on some streams, we would be removing a portion of the GOP that currentTime was currently playing. This would cause chrome to remove the entire GOP, leaving currentTime outside of a buffered range, causing a playback stall.. So I tried to make this more clear by including the wording Adding segment durations starting from the end to get that 6s target. Basically the rule we are following is that we cannot start playback any later than lastSegment Duration + 2 * targetDuration from the end of the playlist (which reminds me I need to update this comment as its still saying 3 * targetDuration). However, for robustness sake, instead of just setting seekable end to be PlaylistEnd - (lastSegment Duration + 2 * targetDuration) We find the segment that that value falls under and use that segment's start time as seekable end. So in this case, the safest point we could start loading from is at 3 seconds. We have a segment that goes from 2-4s, so we set seekable end to the start of that segment, which is 2s. does that make sense? any ideas on how i can make that more clear in the comment?. I feel like this would make more sense being in the playlist.js file now that its not tied to the playlist-loader instance . I think putting these tests in playlist.test.js would be more appropriate and then you can test on just plain objects with the info thats needed instead of all this extra creating a loader, responding to request, etc.. master-playlist-controller.test.js also already has integration tests for isLowestEnabledRendition, so even more reason to convert these to unit tests. There is already an entire module of tests for blacklisting and enabled states near the bottom of this file...\nhttps://github.com/videojs/videojs-contrib-hls/blob/master/test/playlist.test.js#L791. I don't think we will encounter this because of when this is called with isFinalRendition === true, playlist is an object, but we support playlist being a string as you can see just below this, so it may be better to move this block below the string check. Since PlaylistLoader now takes an options object, the destructuring and restructuring of requestOptions is unnecessary . can also just pass in this.requestOptions_ instead. ",
    "hdezela": "I was afraid you'd say that...when I do that it errors out complaining about this() being undefined and others. It seems to need access to a bunch of other (internally-declared) data to work. I'll try and see if I can re-write it as an external function.\n. Well that was simple enough...I thought it was going to be much more trouble.\nTo return to automatic bandwidth switching you need to set the SelectPlaylist() function to:\nvidPlayer.hls.selectPlaylist = function() {\n            var player =\n                vidPlayer.player(),\n                effectiveBitrate,\n                sortedPlaylists = vidPlayer.hls.playlists.master.playlists.slice(),\n                bandwidthPlaylists = [],\n                i = sortedPlaylists.length,\n                variant,\n                bandwidthBestVariant,\n                resolutionBestVariant;\n            sortedPlaylists.sort(videojs.Hls.comparePlaylistBandwidth);\n            while (i--) {\n                variant = sortedPlaylists[i];\n                if (!variant.attributes || !variant.attributes.BANDWIDTH) { continue; }\n                effectiveBitrate = variant.attributes.BANDWIDTH * 1.1;\n                if (effectiveBitrate < player.hls.bandwidth) {\n                    bandwidthPlaylists.push(variant);\n                    if (!bandwidthBestVariant) {\n                        bandwidthBestVariant = variant;\n                    }\n                }\n            }\n            i = bandwidthPlaylists.length;\n            bandwidthPlaylists.sort(videojs.Hls.comparePlaylistResolution);\n            while (i--) {\n                variant = bandwidthPlaylists[i];\n                if (!variant.attributes || !variant.attributes.RESOLUTION || !variant.attributes.RESOLUTION.width || !variant.attributes.RESOLUTION.height) { continue; }\n                if (variant.attributes.RESOLUTION.width <= 1920 && variant.attributes.RESOLUTION.height <= 1080) { resolutionBestVariant = variant; break; }\n            }\n            return resolutionBestVariant || bandwidthBestVariant || sortedPlaylists[0];\n        };\nAlthough I think it would be easier (cleaner?) to have something built-in that you can just call like \nvidPlayer.hls.selectPlaylist = function('auto') {}\nDoing that is beyond my JS knowledge though.\n. If you're using the latest versions, you don't need media-sources. Also, like @tenacex said, your m3u8 is being served as document, and not as application/x-mpegURL.\nI tried your files with this code and it worked fine:\n<html>\n    <head>\n        <meta charset=\"UTF-8\">\n        <title></title>\n        <script src=\"video.min.js\"></script>\n        <script src=\"videojs-contrib-hls.min.js\"></script>\n    </head>\n    <body>\n        <video id=example-video width=960 height=540 class=\"video-js vjs-default-skin\" controls>\n            <source src=\"hls/hdmi/index.m3u8\" type=\"application/x-mpegURL\">\n        </video>\n        <script>\n            var player = videojs('example-video');\n            player.play();\n        </script>\n    </body>\n</html>\n. You're right, I get the same thing when disabling flash. That generally means something wrong with the encoding itself (flash is very forgiving), what did you use to encode the original video and how did you then segment it?\nTry playing around with different profiles and sizes, start at baseline 3.0 and step up from there.\nThis is what I use, which works with the setup described above:\nffmpeg -y -async 1 -vsync -1 -analyzeduration 999999999 -i [INPUT]  -movflags faststart -keyint_min 30 -x264opts \"keyint=30:min-keyint=30:no-scenecut\" -g 30 -filter:v \"scale=iw*min(1280/iw\\,720/ih):ih*min(1280/iw\\,720/ih), pad=1280:720:(1280-iw*min(1280/iw\\,720/ih))/2:(720-ih*min(1280/iw\\,720/ih))/2\" -r:v 30 -s 1280x720 -b:v 1280k -c:v libx264 -pix_fmt yuv420p -profile:v baseline -level 3.1 -c:a libfdk_aac -ac 2 -ar 48000 -b:a 128k \"720p.mp4\"\nAnd for segmenting:\nffmpeg -y -async 1 -vsync -1 -analyzeduration 999999999 -i \"720p.mp4\" -codec copy -map 0 -f segment -segment_list \"720p.m3u8\" -segment_time 10 -segment_list_type m3u8 -bsf:v h264_mp4toannexb \"segment%05d.ts\"\n. Start super basic with something that's sure to be understood by even the most basic player like\nffmpeg -y -re -i http://192.168.1.168/hdmi -keyint_min 30 -x264opts \"keyint=30:min-keyint=30:no-scenecut\" -g 30 -r:v 30 -s 320x180 -b:v 256k -c:v libx264 -preset ultrafast -pix_fmt yuv420p -profile:v baseline -level 3.0 -c:a libfdk_aac -ac 1 -ar 48000 -b:a 96k -f flv rtmp://127.0.0.1/live/hdmi\n,and then work up (size,bitrate,profile) from there.\n. Can you post the output of\nffprobe -loglevel 40 -i http://192.168.1.168/hdmi\n. It looks like there is an issue with your source stream, the message \"non-existing PPS 0 referenced\" means its looking for a keyframe for the PPS and SPS info, but it is never received.\nI wouldn't recommend filing a bug with ffmpeg as it is actually working quite heroically in this is case, its amazing the poor thing is able to output anything without keyframes.\nI'd take a look at what is generating the http://192.168.1.168/hdmi origin (it being http makes me think there might be an sdp file somewhere you could reference) to make sure it's sending at least one keyframe every 1s or so.\n. ",
    "bc-bbay": "Will do.\n. Replaced by pull #260 \n. You're right, preload was a boolean in the SWF. I've updated that project and this pull now depends on this one in video-js-swf: https://github.com/videojs/video-js-swf/pull/155\n. Obsolete by #308 \n. Looks great! Thanks a lot, David!\n. More like #377? I'll close whichever of these you prefer @dmlap \n. Never in production, in theory, but we do it all the time in the unit tests. This is the breakage I was seeing after my first two commits. \n. Will update, thanks.\n. Making the segment a key makes the bug-infected code throw an error sooner. It gets to the segmentBuffer.shift() without having to override other function calls that happen in drainBuffer() and are irrelevant to the test, and I think it's the lesser of two evils.\n. Will do.\n. Will do.\n. Yeah, in some cases, that's the point.\n. hasClass isn't defined in this scope, but you recommended using it in a previous PR review, so this addition keeps the test working.\n. This change doesn't feel right. Segments is a 0-indexed array, so update.segments.length is an out-of-bounds element. Why is this necessary?\n. So that the condition above returns true, and we know to reset. It's not wiped out automatically at the end of playback, but continues to store the last seeked value (if the user ever seeked at all).\n. I'll reword it.\n. Will update\n. Sorry, you're right, that's both the correct behavior and what is actually happening. But null != undefined and still affects the reset at post-end playback.\n. Would we then not unset to null after a seek completes? Because the question I'm asking is, \"has there been a seek since the video ended\", and if video ending and seek completing do the same thing, I can't get the answer.\n. @gkatsev To answer your question, this was basically the reason for the getter/setter structure. I want to make sure this value is at least 1, since making it anything less doesn't make sense and breaks the code. It seemed easier/smarter to police the value in a setter than in every place it's referenced forever and always.\n. ",
    "kimchirichie": "I'm also looking for a solution to this problem. Seems like adding preload=\"false\" only copies the attribute to the resulting element.\n. ",
    "ysksuzuki": "@dmlap I see. I'll try it.\n. ",
    "ghost": "The error happens in the video.js file with the message, \"Uncaught TypeError: this.el_.vjs_getProperty is not a function\". This only happens in the Opera browser.\n. My problem goes away in Chrome on a refresh. But this problem appears on first page load. It's not a case of Flash being blocked as I can see it on the page and functioning correctly through the API. However, this is a blocking issue in Opera and my player will not work. Firefox seems to be fine and I now wonder if it's an issue with media sources.\n. Yeah I can confirm that the SWF gets loaded twice by the browser. It's worth noting that this problem (certainly for me) only happens when using only the API JS.\n. @dmlap @redmacs Any update on this issue?\n. Indeed. The changes @dmlap made still do not solve the problem for me. The SWF is also being downloaded twice on my page.\n. i tried that  but still doesnt work im sending screenshot of network tab http://i.imgur.com/Yv8kr7b.png thanks for helping http://imdummyhelpme.github.io/index.html i made git page as well\n. I don't think m3u8 file is the issue because when I tested the same file at  http://www.flashls.org/videojs/flash_demo.html it works fine I tried couple of other players as well they all work fine with same file its just that I like videos player framework  better then the other ones \n. Okay so if I was to use flashbulbs it might work since swf was modified? Thanks for helping \n. For Cors with your own 'm3u8 file or the one  have? To my understanding Cors has be enabled on wowza server right \n. Thanks for explaining you have been really helpful \n. Is there any chance of a fix for the seek bar overflowing? This pull request (#345) seems to fix the symptoms, but it has not been merged. \nThanks!\n. Thank you  @codex-corp, your method is great.\nBut I got a exception when I changed the resolution again and again.\nFor example, if my list has 2 resolutions which are A and B.\nIf I selected A and then B, and selected A and then B again, the exception will be threw as the following:\nVIDEOJS: ERROR: TypeError: Cannot read property 'playlist' of undefined\nAnd the root cause is this line\nrep.enabled(false)\nDo you have any idea on this exception?\nMany Thanks.\n`. http://caniuse.com/#search=aac\nFirefox doesn't seem to natively support aac audio. Try to encode your audio stream with libmp3lame instead of libfdk_aac.\n. debug from Chrome chrome://media-internals/\nrender_id: 324\nplayer_id: 33\ninfo: Effective playback rate changed from 0 to 1\npipeline_state: kStopped\nfound_video_stream: true\nvideo_codec_name: h264\nfound_audio_stream: true\naudio_codec_name: aac\naudio_dds: false\naudio_decoder: FFmpegAudioDecoder\ndebug: Skipping audio splice trimming at PTS=5013291us. Found only 42us of overlap, need at least 1000us. Multiple occurrences may result in loss of A/V sync.\nvideo_dds: false\nvideo_decoder: GpuVideoDecoder\naudio_buffering_state: BUFFERING_HAVE_ENOUGH\nvideo_buffering_state: BUFFERING_HAVE_ENOUGH\nheight: 720\nwidth: 1280\npipeline_buffering_state: BUFFERING_HAVE_ENOUGH\nduration: 6257.991317\nevent: PAUSE\nseek_target: 5943.519392\nerror: audio error during playing, status: PIPELINE_ERROR_DECODE\npipeline_error: PIPELINE_ERROR_DECODE\nI think the main cause is the bold line above. Is there anybody can help me to solve this issue?\nThank you.. I uploaded a demo page to here.\nhttp://106.186.118.214/mmm/videojshls.html\nThe old versions of Chrome or Safari, Firefox, IE do not have this issue, but the newest Chrome version  64.0.3282.119 which was released on January 24, 2018 does.\nPlease help me check the root cause.\nMany thanks. . Hello @gesinger ,\nIt was caused by some garbage packages in the video. There are lots of discussion in this issue:\nhttps://github.com/video-dev/hls.js/issues/1529#issuecomment-372710545\nThe newest Chrome (after version 64) does not handle this broken case, so the video cannot be played anymore. The broken video should be re-encoded using the newest ffmpeg which support SSR or libfdk and the problem will be solved.\n. ",
    "patriziomunzi": "I've got the same problem in chrome.\nIt's a blocking issue for me. I don't think the question tag is appropriate for this.\nAny feedback?\n. I haven't tried on opera yet, but in chrome in my case does not work.\nI cannot understand why it's browser based.\n@jezhodges A strange thing I see is that the swf get loaded twice.\nDo you have the same double loading?\n\n. You can find a html page showing the problem here: http://beta.hypertvx.com/videojs_test.html\nI ran some additional tests an I noticed that the problem arises only when there are more than one source (which is not the case of your example).\nThe problem does not show off all the time but if you don't see it, keep reloading and it will happen.\nAttached a screenshot of the problem.\n\n. @dmlap have you had the chance to look at it? It's a blocking issue for me.\nThanks\n. ",
    "maxgallo": "hi @dmlap I work with @patriziomunzi, here you can find the same page with dev version of videojs: http://beta.hypertvx.com/videojs_test_dev.html\nWe've got the same issue also with dev version.\n. Not on our side @jezhodges, we're waiting for @dmlap !\n. Thanks @dmlap ! Actually it seems that the SWF is downloaded two times. Right after the second load, videojs time tracking interval fails. \n. Hi @samward1985 , unfortunately we didn't use SWF anymore, so I didn't found any fix.\n. ",
    "samward1985": "Having the same issue with the swf loading twice (only in Chrome, strangely enough). I only have one video source.\n@redmacs @jezhodges @patriziomunzi you ever find a fix?\n. @redmacs @jezhodges @patriziomunzi @dmlap  \nI figured it out! I found that the error was due to the SWF being loaded twice in Chrome, which caused some synchronization issues between the JS and SWF. I started digging around trying to find any reason the SWF might be loaded twice, and I came across the following:\njavascript\n  // IE6 seems to have an issue where it won't initialize the swf object after injecting it.\n  // This is a dumb fix\n  var newObj = par.childNodes[0];\n  setTimeout(function(){\n    newObj.style.display = 'block';\n  }, 1000);\nFor whatever reason, this causes Chrome to reload the SWF. If IE6 isn't important to you (and it shouldn't be!), just comment this block out, and you're good to go. Otherwise, some browser detection would clean this right up. HTH! Please let me know if a 4.x fix gets merged! \n. +1\nNot 100% sure if this is a contrib-hls bug or a https://github.com/videojs/video.js bug...\nI previously was using vjs 4.x with contrib-hls 0.17.9, and the buffering caused the waiting event to fire correctly. Looking at the code implies that this is more likely a vjs bug...\n. +1\nfeeds are working fine in other browsers...chrome having issues\n. +1\nGoing to try building contrib-hls myself now.\n. Eh - no luck... @hanfeisun did you find a solution?\n. This is due to a change between VideoJS 4.x and 5.x. Components should be registered with registerComponent.\nDeprecated way:\nvideojs.Hls = require('videojs-contrib-hls');\nNew way:\nvideojs.registerComponent('Hls', require('videojs-contrib-hls'));\nLooks like the problematic lines are here:\n_videoJs2['default'].HlsHandler = HlsHandler;\n_videoJs2['default'].HlsSourceHandler = HlsSourceHandler;\n_videoJs2['default'].Hls = Hls;\n_videoJs2['default'].m3u8 = _m3u82['default'];\nI'll open a PR.\n. https://github.com/videojs/videojs-contrib-hls/pull/632\n. +1 to having major issues in Chrome - FF and Safari seem fine. I'll get more specific as I experience issues.\n. I get this a lot, seemingly randomly: VIDEOJS: ERROR: (CODE:3 MEDIA_ERR_DECODE) The media playback was aborted due to a corruption problem or because the media used features your browser did not support. \nonly in chrome\n. Ha! It looks like we were doing this at the exact same time, and came up with about the same solution: https://github.com/videojs/videojs-contrib-hls/pull/647\n:D\n. ",
    "jstarpl": "I've managed a quick fix, however I'm not well versed in the structure of the plugin to know if this is a good way to fix this.\n--- \"a/videojs.hls-21daf1f-left.js\"\n+++ \"b/videojs.hls-d7f9669-right.js\"\n@@ -360,6 +360,7 @@ videojs.Hls.prototype.updateDuration = function(playlist) {\n   // if the duration has changed, invalidate the cached value\n   if (oldDuration !== newDuration) {\n     player.trigger('durationchange');\n+    player.duration(newDuration);\n   }\n };\n. I have allowfullscreen attribute on the element and the player actually goes full screen - it's just that the \"video\" content disappears and the playback gets stuck (the timecode doesn't progress).\n. I'm running HLS plugin 0.12.0 with Video.JS 4.12.5.\nHere's the debug report when running the .dev.js version:\nVIDEOJS: Video.js: paused unavailable on Hls playback technology element. TypeError: this.el_.vjs_getProperty is not a function\n    at api.(anonymous function) as paused\n    at vjs.Player.techGet (http://127.0.0.1:8001/:63031:31)\n    at vjs.Player.paused (http://127.0.0.1:8001/:63086:16)\n    at null. (http://127.0.0.1:8001/:89221:44)\n    at HTMLDivElement.ret (http://127.0.0.1:8001/:59606:15)\n    at HTMLDivElement.data.dispatcher (http://127.0.0.1:8001/:59081:29)\n    at Function.vjs.trigger (http://127.0.0.1:8001/:59326:25)\n    at vjs.Component.trigger (http://127.0.0.1:8001/:61212:7)\n    at null. (http://127.0.0.1:8001/:65491:19)\n    at ret (http://127.0.0.1:8001/***:59606:15)\n. Yup, I've just updated to the latest version (0.17.2) and it's still happening.\n. Well, I've checked your suggestion, and I'm not setting display: block on neither the video-js div or the object containing the flash player backend, so that's not it.\n. ",
    "Ulv": "Thank you very much for reply @dmlap! We will keep our streams live.\n. ",
    "dkuryakin": "Yeah, this option allow TS segments to be shuffled in random order. So, it's possible to generate valid  dynamic m3u8 playlists.\nI find following links:\nhttp://stuff.onse.fi/man?program=ffmpeg-formats&section=1\nhttps://searchcode.com/codesearch/view/37369513/\nExample of ffmpeg command I use:\nffmpeg -y -i $INPUT -vcodec libx264 -acodec aac -r 30 -g 300 -sc_threshold 30 -keyint_min 3 -force_key_frames \"expr:gte(t,n_forced*10)\" -flags -global_header -f segment -segment_list stream.m3u8 -segment_time 10 -segment_format mpegts -profile:v baseline -segment_list_type m3u8 -strict experimental -segment_list_entry_prefix segments/ -reset_timestamps 1 segments/%03d.ts\n. ",
    "gotling": "Ok, that was easy enough to fix. Is there any documentation mentioning the the tech name hls? I couldn't find it.\n. I had this problem as well together with contrib-ads, but with version 0.16.0 it seems to be working as expected. Before that I was doing trix on event 'loadeddata' which seemed to be working all the time but was sometimes slow to load.\n. ",
    "alexbakum": "Thanks for suggesting usage of the browserify-shim transform module.\nNow I have working example of bundled videojs+videojs-contrib-hls.\nYou can clone it and just open index.html in your browser to see that the bundle works.\nhttps://github.com/alexbakum/example-videojs-hls-bundle\nBut this solution looks quite ugly.\nAlso i saw some issues for todos not only for videojs-contrib-hls plugin but also for others:\n- require cannot resolve paths (no main field in package.json) for: videojs-contrib-hls, videojs-contrib-media-sources, videojs-swf(just cannot imagine if browserify will do this for AS3 project)\n- dist/pkcs7.unpad.js from brightcove/pkcs7 project cannot be bundled with browserify, so I had to bundle full dist/pkcs7.js due to it's proper UMD wrapper\n- I'm not sure of bundling vtt.js to my bundle.\n- latest videojs-contrib-hls project version does not have dist/videojs.hls.min.js and 'dist/videojs.hls.js` files on npm\nYou've mentioned that your team will be happy to accept some changes to switch project to commonjs/browserify. Do you have some kind of roadmap for changes or suggestions where to start from?\nI'm still on my way to make bundle or some kind of recipe of bundling current versions of videojs and it's plugins.\nP.S., I'm using videojs, some plugins authored by videojs team and brightcove(pkcs7) projects as dependencies in my example project and don't have license. What license will you suggest for it?\n. ",
    "darrennolan": "Hey just popping in on this thread,\nVideo.js v5 is getting better support for browserify via umd which is great.  But without browserify shim I can't seem to get this plugin working.  \nWhat is the plan for using plugins within Video.js under umd?  Shimming is not available for what I'm trying to achieve (I'm trying to use Video.js under node for isomorphic code). Just trying to work out a plan of attack for these plugins.\n. Confirm we have the same issue but strangely enough, Chrome seems to behave fine without withCredentials being passed against the source.\nNot sure if I'm right in doing so, but I updated to the following;\nif (this.source_.withcredentials !== undefined || this.source_.withCredentials !== undefined) {\n    this.options_.withCredentials = this.source_.withcredentials || this.source_.withCredentials;\n  } else if (videojs.options.hls) {\n    this.options_.withCredentials = videojs.options.hls.withCredentials;\n  }\n  this.playlists = new videojs.Hls.PlaylistLoader(this.source_.src, this.options_.withCredentials);\nWhich if I understand correctly, allows the withCredentials to still be set (as camelCase) with videojs.src([]); as well as taking it from the lowercase attribute.\n. ",
    "seankoji": "+1 to node use please.  How would we go about making this changes/possible pull requests ourselves?\n. @tenacex that commit you linked to doesn't seem to have any fix for the issue that I can see?\n. ",
    "nigelwtf": "I'm also jumping on the bandwagon - as I've been looking at this for a while. Would be good to be able to use videojs this without shimming any dependencies. Even if not for isomorphic use, it's still rather inelegant to shim.\n. ",
    "oleynikd": "\nvideojs 5.0 should work nicely with browserify (and to a certain extent in node).\n\nGreat, but what about require('videojs-hls'); ? It would be great to avoid shim...\n. Looking forward, thanks.\nIt would also be great if you'd made it CommonJS compatible...\n. @dmlap Could you please tell approximate schedule for video.js 5 and MSE compatible release? Thanks.\n. Woohoo!!!!!!!! :)\n. @dmlap How can I try development version with CommonJS (using browserify)? Thanks.\n. OK, I figured out how to build it...\nHave the same problems as @Tralapo mentioned.\n- Firefox has the infinite spinner.\n- HLS doesn't work in Opera at all.\n- In Chrome I had some strange periodic problems like freezes and audio without video.\n. Hi, guys, could please someone explain how to use this inside SPA? I tried @vpowers solution, but I still get webworkify-webpack: Could not locate module containing worker function! Make sure... I'm using vuejs\nThank you in advance.. ",
    "pbacci": "Hello there, are there any updates on a timeline to be able to do require('videojs-hls'); ? We are hitting the same problem and we are trying to understand if we should go with a shim solution in the interim or wait for this to be fixed more properly\n. here is an isolated way to repro. Decompress the zip file and point the browser to test_failing.html. There is also the same exact content that works (test_working.html) with 0.11 version\nhttps://www.dropbox.com/s/8jnge9aqs9gelam/test.zip?dl=0\n. @dmlap did some digging today to isolate when the regression got introduced and it's originating in\ncommit cc20895dd4992590f7cf36da181f5020c36c67d7\nAuthor: David LaPalomento dlapalomento@gmail.com\nDate:   Thu Jun 18 15:27:21 2015 -0400\nRecord min and max PTS values for segments\nSegment duration can have different interpretations in different contexts. To ensure we have all the information we need to seek accurately, record PTS values for the audio and video streams within a segment. For #314.\n. thanks a lot for the quick fix @dmlap !\n. ",
    "builtbylane": "has this been implemented in the master branch? \n. ",
    "dconnolly": "Overall LGTM. Hopefully at some point we can pull in some of the boilerplate AES stuff from something like sjcl, as long as it doesn't conflict with the v8 optimization work.\n. Correct, i have to fix the tests. Closing until then.\n. ",
    "ReggiePuksta": "if you just use videojs('test-vid') and delete player.play() it should work.\nOtherwise you might have wrong script sources. You can use Chrome dev tools Network tab. There you can see all resources that were loaded. Use ctrl+shift+i to bring it up and choose network tab. \n. If you open your Console tab on Chrome Dev tools you will see that your server that contains .m3u8 file doesn't have CORS headers setup. I guess you are using Wowza server, so this might help: http://www.wowza.com/forums/showthread.php?21818-Adding-CORS-to-the-HTTP-header\nThere is probably a way to do it through the Wowza Manager UI as well.\n. As far as I know, flasHLS and videojs-hls-tech are two different things. I know, it's confusing. The demo page above uses modified videojs swf file https://github.com/mangui/video-js-swf that implements flasHLS project. So for flash to work with external resources you need crossdomain.xml file. Which is on your server root already. That's why it works fine if you use your .m3u8 link on the demo page. If you want to use video-hls-tech across different domains, you have to setup CORS headers on your server.\n. Actually I tried to use flasHls locally with videojs. It was no success. It might be that you need very old version of videojs, not sure. Though videojs-hls tech works fine for me with Cors enabled.\n. Yeah, my own. Yes.\n. ",
    "imbcmdth": "This is so old that I doubt it's easily rebased... While useful, it might take a lot to get this working again so I'm closing this.. LGTM :tongue: \n. LGreatTM :tongue: \n. LGTM :toilet: \n. @dmlap LGTY?\n. Rebased to pull in test fixes from @dmlap..\n. You probably want to make this patch to the development branch as well and submit a PR. That branch is the massive ball of changes to the HLS plugin for VJS 5!\nPS. The hotfix label is for things we are fixing in master that need to be applied to development as well.\n. LGTM :+1: \n. Just one question:\nShould we handle the situation where the codecs change between renditions? Is that even allowed?\nOtherwise, LGTM :yum: \n. Despite my last comment, LGTM\n. Out of date.\n. LGTM\n. LGETM\n. @zuzzurro We have continued to work on caption support and recently fixed some bugs related to captions. If you still have problems with the latest builds it would help us out if you could provide some samples. One of the most difficult parts of 608/708 development is finding samples to test against!\nThe only remaining limitation that I know of is the lack of official \"paint-on\" caption mode support.\n. One minor comment. Otherwise LGTM\n. > It's awesome that adding support for redundant streams turned out to be a relatively tiny change! \nEven WITH blacklisting timeouts!  :wink: \n. Do you have an example of a playlist on which this happens?\n. Amazing - thanks for doing the extra legwork to add this feature to the development branch!\nRE:\n1) Segment fetching in infinite loop - hopefully this behavior has been corrected or at least improved by #463\n2) IE11 this is definitely strange! @forbesjo Can you reproduce this? \n. Thanks again for the feature! We are prepping this for inclusion and have the PR in #515.\n. This is something we have noticed too and are eager to fix before the v1.x.x release milestone.\nThank you for your report @sgavali \n. LGTM.\n. MSE (at least in Chrome) has issues with fragments that do not start with keyframes. As a work-around, we detect those cases and pull the first keyframe forward (extending it's duration.) That \"work-around\" accounts for the hitching that you are seeing. If you re-segment on keyframes, the stream should play without issue.\n. Except for cue.frame.data being deprecated and changed to cue.value.data it all looks good to me!\n. Needs tests.\n. This has been superseded by #505\n. Closing to make PR against master\n. Closed because it needs to be rebased since a lot has changed and this behavior hasn't been something we have needed in over a year.. I ended up making this slightly more complicated because there was still a case that didn't seem right to me - we always want to pick the highest bitrate we can play among the renditions that aren't too much larger than the player size.\nThe algorithm in https://github.com/videojs/videojs-contrib-hls/commit/af7f8e21f5b43340335106373527621b632beb61 was always selecting the lowest bitrate rendition if multiple renditions shared the same resolution. The later commit https://github.com/videojs/videojs-contrib-hls/commit/7671b5a0ae529576d07334cd7719e94b6d11b0cc corrects that.\n. Can't reproduce!\n. What version of FF?\n. Needs test(s).\n. Once you fix the name of the test, this looks good. We should squash this so that we can merge a single clean commit for this fix.\n. I believe the HLS spec specifies the live point as 3 target durations from the end of the playlist... LGTM!\n. There is no reason not to bring this in - it seems like a bug in the first place. Rebase and merge at your leisure. \ud83c\udf4a \n. LGTM\n. Superseded by #618 \n. Superseded by #618 \n. Also you need to make this PR against development branch.\n. Fairplay encryption is not supported yet but is something we are planning on adding support for at some point in the near future. If this is something you decide to add yourself, we welcome any contributions!\n. LGTM\n. NICE. \ud83d\udc36 \n. Thank you for the test case! This is definitely an issue and we will be working on a fix. Stay tuned.\n. LGTM\n. LGTM\n. LGTM\n. Your audio codec is mp4a.40.34 which is MP3 audio using an old codec not supported by Chrome.\nhttps://bugs.chromium.org/p/chromium/issues/detail?id=489520\nEven if it was supported, mux.js does not have any provision to support MP3 in an mpeg2ts stream. I would recommend that you try switching to AAC encoded audio (a higher quality codec anyway!) stored in an ADTS stream.\n. I just tested it (in the latest 3.0.5) and it was working. Those attributes are optional in an HLS manifest and I would verify that the manifest you are trying to play has attributes specified.\n. Also, this should be referenced someplace from the main (index) page and made to look like that page.\n. LGTM\n. In addition to the tests not passing, this is also missing the other acceptance criteria requirement - that we don't time-out when we are already on the lowest rendition.\n. LGTM\n. LGTM\n. LGTM\n. LGTM\n. LGTM\n. LGTM\n. LGTM\n. LGTM\n. I think this functionality should be moved so that there are a minimal number of changes to master-playlist-controller.js which has already grown into an unwieldy large file.\n. @SuriGill Thanks for the submission!\nWe put a lot of work into the areas around this search and the result was that we were able to remove it completely. As a result, the search performance is no longer an issue in the latest versions of videojs-contrib-hls. we have tested with streams that were 5 days (!!) long and saw no performance problems seeking around.. LGTM\n. Also this should have a test.\n. LGTM\n. LGTM\n. LGTM as well\n. LGTM\nThough this is not strictly necessary. Normally, you would just do a clean install of contrib-hls's dependencies and the new version will get built into the dist when you make a new release.\n. Added via #899 . The addSeekableRange function was based on a API proposal by @dmlap that wasn't accepted as-is. The replacement has a different function that performs similarly. I wonder if this is a good time to change the names in videojs-contrib-media-sources and here to match the new api in the MSE specification.\nAFAIK, no browser implements the new API natively though we should come up with a plan to support the native API incrementally as it becomes available.\nAPI\n\nsetLiveSeekableRange\nclearLiveSeekableRange\n. We decided not to do this for now as it adds complications to work around a problem with the stream that should exist in the first place.. LGTM\n. LGTM\n. Requires https://github.com/videojs/videojs-contrib-media-sources/pull/119\n. We decided to remove the loadedplaylist function since it seems like the function is very much internal to HLS and only bad things can happen if user rely on that function.\n\nThe other events are accessible through other means now - mediachange is available via change events on the QualityLevelsList implementation on the player and loadedmetadata is still available on the player.. LGTM. Awaiting QA approval before merging.. When a playlist is refreshed, the segments in the new playlist are copies of the old segments. That means that if playlist is refreshed between segment request and xhr completing, we will annotate the old segment object at: \nhttps://github.com/gesinger/videojs-contrib-hls/blob/b426cc22fe27de3d96a53d5586c0ab3a451d3ad1/src/sync-controller.js#L310-L314. LFGTM. LGTM!. Can you update the README to point out that this change means we no longer support IE10.. Looking good to me.. LGTM. LGTM. LGTM\nI love all removal PRs!!. What do you do with the data pointed to by the map? MPEG2TS don't really have a concept of the \"initialization segment\" - what is usually pointed to by the EXT-X-MAP header.\nWhat is in that 376 bytes? Does it contain the PSI and PMT packets?\nI am curious but this is a good point and something we should look into. Can you submit a PR with your changes so we can discuss this further?. LGTM. Won't Fix.. Rebasing this for clarity.... LGTM!. @mjneil Right now we are using global videojs HLS options for this. The settings object remains unchanged but the merger with the global options brings the debug flag. I decided to remove the options for sync-controller since it wasn't being used anyway.. We need to test the behavior when a segment request errors on the final available rendition. Do we re-request? Give up somehow?. @mjneil For the first paragraph: Sounds like we need some sort of retry logic for segment requests in this case. We are out of options so just keep retrying for 45 seconds.\nFor the second paragraph: What requests are you talking about here? Manifest refreshes?. The manifest refreshing as fast as possible is a bug and a huge bandwidth hog for customers. That needs to be fixed!. We decided to remove the code if it is redundant and to add a test to prove that it was not necessary.. Minor nitpick .. LGMT otherwise!. @imbcmdth Find out why this didn't seem to help much!. Good thing git can now squash and merge.. This might be the ugliest commit list in the history of videojs! \ud83d\ude06 . Is there a way to break this process out into it's own module? Seems like the same function will be added to most of the grunts.\n. We can't assume a single region any more so we have to be smarter about calculating the amount of buffered data.\n. Left behind debugging code?\n. I think this should be red. :bike: :arrow_right: :house: :laughing: \n. This doesn't handle the case where the mediaIndex was for a segment that is too early in the timeline, right?\nI know that case will be handled \"automatically\" but it feels suboptimal (since it could take a while to catch up and we have a limited forward buffer with which to work.) Also, I don't think we will ever correct the \"TimelineOffset\" in that case which might, in the long run, be a confusing behavior.\nIn other words, I think we should always attempt to correct the timeline offset because some other code may depend on that correction one day.\n. What about frame.data?\n. Nice!\n. Is the || here necessary? Target duration is a required field in HLS, if anything we should throw an error if it was never specified.\n. I feel like we could be smarter than a binary search here but I am trying to find a way to explain it..\nBasically we know the last point we have accurate information on (the start_point) Starting with the lemma that \"every segment.end is the next segment's start\" - we either know the start of i-- (when we find a known start) or the start of i (when we find a known end). (It's i-- or i because you have already incremented i after the loop.)\nLikewise, we just found a segment we know about so now we know: either the start of segment j (the case where segment.start is not undefined) or the start of segment j++ (in the case where segment.end is not undefined).\nWith that information we know exactly the number of segments between two known points (either j-i, j-i+1 or j-i+2) and we know exactly the range - from one known start point to the other known start point.\nWith that we can calculate i + Math.floor(numSegments * (range / time)) to get a much better idea of which segment we are likely in. Again, the same convergence as with the binary search will occur if we happen to be wrong but we are much more likely to be right the first time and, as a consequence, likely to converge on the correct answer more quickly.\n``` javascript\nvar\n  knownRangeStartTime,\n  knownRangeEndTime,\n  knownRangeStartIndex,\n  knownRangeEndIndex;\n// Figure out the start of the unknown range...\n// The key here is that if we have a starting segment with only a start-time we\n// need to include that segment in the unknown range since it's duration is unknown\nif (segment[i--].end !== undefined) {\n  knownRangeStartTime = segment[i--].end;\n  knownRangeStartIndex = i;\n} else if (segment[i--].start !== undefined) {\n  knownRangeStartTime = segment[i--].start;\n  knownRangeStartIndex = i--;\n}\n// Figure out the end of the unknown range...\n// The key here is that if we have a ending segment with only an end-time we\n// need to include that segment in the unknown range since it's duration is unknown\nif (segment[j].start !== undefined) {\n  knownRangeEndTime = segment[j].start;\n  knownRangeEndIndex = j;\n} else if (segment[j].end !== undefined) {\n  knownRangeEndTime = segment[j].end;\n  knownRangeEndIndex = j++;\n}\nvar\n  range = knownRangeEndTime - knownRangeStartTime,\n  numSegmentsInRange = knownRangeEndIndex - knownRangeStartIndex;\nreturn knownRangeStartIndex + Math.floor(numSegmentsInRange * (range / time));\n``\n. Understand. I don't agree but I get the reasoning.. :hear_no_evil: \n. Safari handles live streams differently than the \"spec\" we should probably not use TARGET_DURATION and just base the calculation on \"3 segments from the end\" like Safari.\n. This is actually a common condition: We are looking for the next segment in a live playlist that hasn't updated yet so we are effectively searching for a time after the known end of the last segment.\n. I thinknumSegments` is the way to go.. it's easier to read and I hate seeing repeated object traversal. That's a code smell to me.\n. Good point.\n. Thanksgiving leftovers!\n. In the live case, we can't rely on knowing anything about the playlist. If we have failed to find an index, we need more information. Clamping tries to pin down the start/end of the playlist (what I think of as 'anchoring'.)\nEven if anchoring fails to give us new information we will fall back to walking forward until we have all the segments or finally learned something to help us pick the right segment.\n. Fancy book lernin'!\n. Removed\n. No this is to cover the strange condition mentioned in the comment below. We are not seeking, current time is not zero and we don't have any buffered data. In that case we need to set timestampOffset before placing the segment. I saw this several times while trying to get live streams to work.\n. I'm not sure we ever came up with a good solution for that one yet. This also handles the case where our start isn't quite zero. This is an interim solution.\n. Wha?\n. Done.\n. Done.\n. In this case, it is being used as a \"sequence\" for the purposes of the calculation later. It seems silly to introduce another variable and/or a condition when a simple assignment will suffice.\n. Done.\n. This was being called twice. The correct place to call it is after pendingSegment_ is reset.\n. Changed and moved to below segment annotation.\n. Basically we say: If we aren't in a live playlist and the last segment has a duration equal to the end point of the currently buffered region, we consider the video to have ended.\n. When we are seeking, we shouldn't care if we load the same segment as last time - this was mostly a problem in flash because we don't have a buffer on seek so we potentially need to load the exact same segment again in this one case.\n. I agree that I'd like to have less \"global\" state but for now it's required..\n. Below we trigger durationchange after setting seekable; here we do it before. Since there is no seekablechange event, we probably want to trigger durationchange afterwards here as well for now.\n. The issue is that the code after this condition cancels the segment XHR and clears the this.pendingSegment_ property. When 'updateend' is called we have no way of annotating segments. This was resulting in us getting the same segment (the first) twice during a live playlist start.\nThe steps went something like:\n- We would start the request for the right segment via checkBuffer_ (based on currentTime)\n- The seek handler would try to cancel it but it was already in flight\n- We would finish appending the segment but store no information about it in updateend\n- Then we would fetch the same segment (based on currentTime)\n- In that second segment's updateend, we would record no new information because the buffer already has the same segment!\nIt was a strange and difficult to track down situation.\n. I would support this.. It's messy as-is.\n. No. Fixing.\n. All non-200 responses are handled by exactly the same code. I didn't see the point of testing each individual code! :D\n. Unfortunately no. That would select segments which we don't necessarily want because the time can equal 0 right at the end of a segment (it's the old exclusive segment end time issue) when we really want the next segment before that one.\nThe only time time can be 0 and we do want to fetch that segment is on the very first segment. It's a complicated case.\nSay you have three segments:\n1.  4.5 seconds long\n2. 4.6 seconds long\n3. 4.5 seconds long - this is the only segment you have information for\n   - Ends at 13.6 exactly\nThe fetcher is going to try and fetch time 9.1. So we find the last segment and do time = 13.6 - 9.1 so time is 4.5. It then enters this loop and gets the first segment subtracting 4.5 and time is equal to 0 - if it fetches the last segment it enters a loop since it'll never really get the right segment.\n. I don't think we do when walking forward.\n. Because of Sintel! (It's doesn't start at zero and 1/60th is way too small a fudge for a 30fps video...)\n. This was something left over when I was befuddled by the randomness of failures. \nI knew something was causing stuff to run out of order. I also knew that the fill/drain cycle is locked by the truthyness of pendingSegment_ and segmentXhr_ so I was making sure that either pendingSegment_ or segmentXhr_ was always set by not clearing segmentXhr_ until after pendingSegment_ was set which required re-organization.\n. Same reason as above.\n. As we discussed, I feel like this whole section must be revisited at some point in the near future but I am hesitant to make changes until we have the first official release of MSE-HLS out the door, so to speak.\n. Yes this was vestigial. I will remove/reword.\n. If we are going through the effort to pull these functions into their own file, maybe we should consider giving fillBuffer/drainBuffer better names?\n. Not sure that the order-of-operations in this comment applies to what the code is doing..\n. Nor here either..\n. No newline! :smiley: \n. This whole file :+1: \n. Because of the way we fake mediaSource duration during live playlists, we need to return the playlist's duration because the mediaSource.duration will be an actual value so we can seek to the live point on play.\n. I did but then I pushed to development and these commits didn't go away. They are the same commit as the latest master so I think it's just cruft.\n. Damnit you noticed! I couldn't think of a better way to detect that we have failed (twice) to detect changes.\n. I think a PR to @tenacex will be cleaner. Thanks!\n. These type functions should be static functions so that they are at the constructor level and not in the prototype.\n. Might as well make this assignment part of the media variable's declaration above.\n. Extra line.\n. We capitalize the first letter of multi-word variable names (and we don't capitalize the whole acronym) so this would be localXhr.\n. Missing a space after the word 'current'.\n. You removed the else which is possible since all of the other cases explicitly return. We tend to keep the else (even if it is redundant) just to make the control-flow explicit. Also it protects us if, for some reason, one of the previous clauses are changed to no longer return.\n. Nice, though I am not sure that we actually emit errors from this function. Might want to do something like what we do when a key fails though instead of simply throwing.\n. We only want to reset the loader.state to 'HAVE_MASTER' if it was in the 'HAVE_MASTER' state before the request that caused the error.\nRight now, this code would trigger a loadedmetadata each time we switch to a new playlist as a result of an error fetching the previous playlist.\n. I'm not convinced that you need a new function to hold this functionality.\n. Make this a local URI to a resource.\n. Couple of comments:\nThe goal of the test should be to ensure that loadedmetadata event is triggered on a successful load after a 404 for the first playlist. You should bind an event listener to loadedmetadata and record the number of times it was called. After the 404 it should have been called 0 times and after the successful playlist load it should be 1.\nThen you should have a more descriptive name. Think about what you are testing and why and come up with a name that will have some meaning to someone even if they never looked at the code before.\n. Name should be loadedmetadata. How about \"After an initial media playlist 404s fire loadedmetadata once a playlist request succeeds\"? :)\n. There are two reasons for this change:\n1. It just makes it consistent that all the values we are pulling into local variables come from segmentInfo\n1. I had planned to move maybeEndOfStream_ functionality to before the early exit if we switched renditions. I wanted to signal the end-of-stream no matter what happens if we need to... \nObviously, #2 never happened but since I shall be changing the function anyway given your other comment, I might as well do that too!\n. Probably just something \"left on the cutting room floor\" during source-handler conversion.\n. You are disposing of this.audioSegmentLoader_ twice here.\n. With the changes in useAudio this whole handler can just be a call to useAudio without any arguments and it'll automatically select the enabled audio track.\n. I don't like these kind of changes! Nothing is hurt by calling the argument duration.\n. We need to guard against there being no media(), attributes, or mediaGroups properties in the two assignments above.\n. This was commented out for a reason. I decided that we shouldn't overload the expired time tracking because it just makes things more difficult to reason about. I have another PR #626 that adds this back but uses a separate value for this purpose that we reset once we have \"gotten back on track\".\n. You should do prefix = event.attributes.IV.substring(0, 2).toLowerCase() and simplify the condition here to prefix === '0x'. \n. On line 681, timelineUpdated is defined.\n. We talked about this in person. The consensus was that timeCorrection has a different lifespan from expired and conflating the two variables would lead to heartache.\n. This kind of change is just going to create merge conflicts. Specifically, when #626 is merged..\n. This kind of change is just going to create merge conflicts. Specifically, when #626 is merged..\n. I'm wondering if this should be \nreturn !this.sourceBuffer_ || this.sourceBuffer_.updating;\nSince code outside of sourceUpdater to determine when it is ok to load segments. Right now, the code outside will get the \"all clear\" when there is no sourceBuffer_. With the change above, outside code would think we were busy (which we kind of are; in a way) and not do anything silly quite yet.\n. Stop removing my beautify whitespace! :laughing: \n. We should probably keep the comment warnings. They don't break tests and it is good to be reminded that TODOs exist.\n. This useAudio line must be moved to loadedmetadata handler for it to have any effect. Right now we don't select an audio track if the source is demuxed (pretty much everything but Advanced BipBop.)\n. Good point!\n. Nah, we should be quiet unless something has actually gone wrong. I think we are too verbose as it is. We'll need to remove some of the logging at some point. (Or hide it behind a debug flag of some kind if it's useful.)\n. I want to blame someone else for these broken style comments. It wasn't me, I don't even write comments! :wink: \n. I don't think find is polyfilled.. it'll work in Chrome but not everywhere.\n. This comment needs some love: \"this will video.js to to not use\" and \"overriden\".\n. this.options_ is already built from options. I'm not sure what this line is accomplishing.\n. So this.options_ is never used?\n. The changes to this file should not be included!\n. Any function passed in to act as selectPlaylist expects this to be equal to the HlsHandler object and have access to it's non-underlined functions specifically.\n. You can't use Array's find that only works on Chrome.\n. Don't we need to still dispose of audioPlaylistLoaders? I think the active playlistLoader could have a timer (to refresh the playlist on a live hls stream) or an outstanding XHR request that we aren't cleaning up/aborting.\n. Is there any reason to still emit this? I see you removed the loadedmetadata handler from videojs-contrib-hls.js below.\n. Hmm, this test might need to be rethought completely.. It really isn't testing anything now but I'm not sure if it is possible to test that loadedmetadata is being fired by the video element without appending some real data.\n. A getter calling a getter? A setter calling a setter?\nIt's madness.. MADNESS!\n. There is really little reason to make this a getter/setter combo. We tend to avoid them except where required for compatibility reasons.\n. I am thinking that we should deprecate this property (log a warning) and prefer a GOAL_BUFFER_LENGTH being set via options.\n. I would remove this then and the test below then. They seem superfluous now anyway.\n. GOAL_BUFFER_LENGTH is not intended to be a settable option. It is meant to be something that we don't support but you could change if we understood the consequences.\n. I kind of, sort of did that in a later commit.\n. That's exactly the point of this removal. It was an older version of FF with this limitation.\n. Dammit!\n. I don't think it should be deprecated if we don't provide any other way of setting. It's UNSAFE but not necessarily deprecated!\n. I don't think it should be deprecated if we don't provide any other way of setting. It's UNSAFE but not necessarily deprecated!\n. This has always bothered me.. It's 0.5MB/s not mbps - I know you didn't write this comment but I would be very appreciative if you could fix it!\n. I believe this will import the same object every time so that it is shared between videos. Meaning that the stats will increment forever even when we change sources.\n. Config will be the same object every time so that each source will start off with the config of it's predecessor instead of the default config.\n. The idea here is that expired will only ever be used when we do not have accurate timing data in the manifest. In most cases we do so the original code was not advancing the fetcher. Now we are directly fudging the currentTime so we force the fetcher to walk forward even if we have some (possibly incorrect) information recorded into the segment annotation.\n. This is a separate fix. I noticed that after seeking a lot we ended up with monitorBuffer_ being called ever few milliseconds instead of twice a second. Something was causing the timer to be set repeatedly.\nThere is no good reason not to unset the timer before creating a new one just to guard against some other code calling monitorBuffer_.\n. The condition here was moved into the updateTimeline_ function.\n. Don't exit early so that we have a chance to set timeCorrection_.\n. Done.\n. Done.\n. Now we use timeCorrection_ to walk forward if we have a >90% buffered segment.\n. On it.\n. /**\n * It clamps\n */\nJust kidding..\n. There is no reason it couldn't be placed into fillBuffer_ though at some point fillBuffer's responsibilities are going to be a strange mish-mash.\nI'm feeling that we should start making predicate functions that we can use to  wrap functions like loadSegment and keep the actual body of the functions clear of all the special cases we have to watch out for...\n. What would unpause the loader?\nAlso it isn't quite not fetching segments anymore - it's just given up on the walk forward. It'll still get the event in 500ms and try to make some progress (maybe, the buffer might be full enough.) The whole thing is ugly but I think it is the best we can do without introducing some more state (like a history of requests).\n. That is a good idea. It evolved into something pretty general-purpose.\n. Each instance would still need a partially-applied version with the playlist and fastChangeFunction (the second one isn't explicitly required but I like the decoupling) which would make it pointless to have it on the prototype.\n. Why?\n. No, it's called by us only (it is not exposed) and it gets an id from the index parameter of an array map which is always defined.\n. Sure, makes sense.\n. I don't want to leak anything more than what is exposed. Putting the playlist on the representation encourages the user of the API to do HLS-specific things in their renditions selection functions.\nAs we will be using the API to build a general-purpose implementation on the VideoTrack object, I don't want to include any information that won't available for every ABR video source.\n. You shouldn't need this file at all. This functionality is included in the latest releases of video.js natively.\n. This file is loaded by video.js from the CDN there is no need to set this.\n. Added a dispose and refactored some stuff for that purpose.\n. I'm not sure which behavior is right. Or if Firefox is wrong. That is why I left as just an explanation of why we have two ways to trigger this gap-skipping behavior.\n. Nope. Without closing tags I'd need something less strict to be able to parse this ..an HTML parser!\n. Very true.\n. We have been trying to avoid adding more and more state to the segment loader (even though we haven't been doing a great job at that!) Is there another way to accomplish this goal?\n. This could be more concisely written with a filter and returning the resultant array's length.\nYou should avoid using plain-ol'-for loops whenever possible.\n. This is not at all the solution was discussed at kickoff.\nSee the this.hls_.xhr function being invoked a few lines below this one? The first parameter is an object. The idea was that the base of that object would come from the MasterPlaylistController and have things like timeout and withCredentials set there. Then that object get passed along to the SegmentLoaders whenever a playlist update happened so that it was always current. In SegmentLoader, the default xhr options from MasterPlaylistController would get merged with an object with the uri and responseType properties whenever we need to call xhr to create the final xhr-related options that we will pass along to the xhr function.\n. stalled is definitely not the right event either. That only applies when the user-agent is also responsible for the fetching of media data. With MSE that responsibility is no longer in it's hands.\nThere are two main reasons that we can't use stalled:\n1. What the event means in terms of \"how long the data has been not forthcoming\" is pretty much left to the browser (though the spec does helpfully say \"about 3 seconds\").\n2. The event can be fired while we are playing. In fact, it often is fired while there is plenty of data in the buffer and the condition usually resolves itself (data arrives) without the browser taking any extra steps.\nWaiting is the event IMO that should fire when player has reached the end of the buffer and is waiting for MSE to provide more data.\nI agree that we probably shouldn't be firing waiting ourselves. I will stop triggering waiting myself and call the waitingHandler function directly from the work-around for non-waiting-triggering browsers.\n. This is a total nitpick but on* functions names are historically used to denote an event handler. Something like isLowestEnabledRendition_ would be potentially less confusing.\n. I wish we could find a way to run this kind of test. There were cases in the past where the withCredentials option was not being properly handled. Can you think of a way to test that the right withCred. option is passed to a SegmentLoader?\n. Nice!\n. Yup, sounds great! Then I would be ok with removing the commented out block completely.\n. This whole function is starting to get rather large. How do you feel about pulling the back-buffer removal code (all of it) into it's own function?\n. Change the duration of the cue to be a short, non-zero value to be an \"instantaneous\" type cue. Follow the example in contrib-media-sources for ID3-tag cues.\n. We should rename this TextTrack to 'ad-cues' as it no longer contains 'hls-segment-metdata'.\n. I think a rebase pulled in something it should not have.. this code appears to be from the last commit in master.\n. This also came from that last commit in master.\n. Remove these commented lines completely.\n. I think we settled on using the UA string parsing to check the browser version.\n. Can we add the slight differences from this code to the code above for detectEndOfStream and move this check from here to fillBuffer_?\n. I like that you made checkBuffer_ no longer rely on this...\n. People can put all sorts of terrible things in the configuration. I think checking if bandwidth is a number is a safer approach here.\n. We might need to rethink hasPlayed_ soon... it is complicated to get this working in all 4 cases:\n- MSE & VOD\n- MSE & Live\n- Flash & VOD\n- Flash & Live\nTo get halfway to a proper fix may require first fixing the tech's played function (especially in the flash case).\n. Missing a semicolon.\n. I think it is time to start defining let inline where they are first created. One of the nicest features of let is that it enforces lexical scoping and emits nice exceptions when those rules are violated. By defining them at the top of function scopes, we are introducing the potential for \"quiet\" bugs that are more difficult to track down.\n. If the playlist is updated multiple times before duration is set to Infinity, wouldn't this result in multiple events waiting for durationchange so that they can call addSeekableRange? If so, do you think that is a problem or will it work out either way?\n. See above...\n. Should we bother to listen on audioSegmentLoader? We previously assumed that only the main playlist determined the seekable range.\n. I wonder if we can make this function a whole lot simpler by just ignoring the audioSegementLoader...\n. YAY!\n. Wow, that is a lot of state for one function! \ud83d\ude2e  I feel that at that point it might make more sense to break this into a few smaller functions.\nAlso the same comment as above about creating these inline. \n. Hmm, ok. I'll take your word that it's ok. This is on your head if it goes wrong! \ud83d\ude04 \n. Sounds good. I think long run we have to look at combining the separate SyncControllers between segment loaders so that they can use the same information when choosing and placing segments. Specifically, I am thinking about the mapping of timestamps to display time.\n. I concede.\n. Very true. I was copying the style used elsewhere but I forgot that this is for IE8 which we don't support anymore.\n. When you set the throughput you are giving it an initial value for the cumulative average so it is already a sample.\nWhen throughput is set to 0, it is basically disabling it from being considered for systemBandwidth but then it has no samples so the count is 0 - otherwise the value of 0 will be included in the average.\n. Unfortunately bandwidth is only the segment request. So the rest of the process is something I current consider \"overhead\" so I can capture key response overhead.\n. These two lines are the same thing as the lines 233-235. I think making these two lines a function that takes a playlist parameter would be better (something like isPlaylistEnabled_(playlist) {...}. Then the enabledPlaylists_ function becomes return loader.master.playlists.filter(isPlaylistEnabled_).length and these two lines become just something like let enabled = isPlaylistEnabled_(playlist);. I think Matt means \"Can we actually get rid of this check\" which I agree with!\n. Another perfect place for a hypothetical isPlaylistEnabled_ function. \ud83d\udc4d . You know what would be really great here!?. I thought we wouldn't filter blacklisted media here?. The real difference is in how long in the future things are scheduled. Calling monitorBuffer_ forces the tick to happen next (it either schedules or reschedules the timer tick to be just one millisecond). Whereas monitorBufferTick_ always schedules the next time to be 500ms in the future.\nOriginally, I had a piece of code with an optional parameter to monitorBuffer_ to set/reset different timer durations in one function but I decided that was \"too clever\".. Prior to this change, the request happened immediately. As a result, there were two clock ticks between the request and the response. Now, the request happens later and only one tick happens now (the first tick becomes the tick that triggers the request).. I think it might be time for a helper function to make these objects. Something so that we can do:\n...\n  encrypted: transferTypedArray(segmentInfo.encryptedBytes),\n  key: transferTypedArray(segmentInfo.key.bytes),\n  iv: transferTypedArray(segmentInfo.key.iv)\n},\n.... I think work is a bit generic and worker would be a more descriptive name for the function.. Matt and I discussed turning this into a set of if/else instead of an evil switch statement!! Just noting that incase someone else notices the switch statement and feels ill.. Transferrable is the name given to the class of objects that can be zero-copied into a webworker. ArrayBuffers are one of those types but to be able to reconstruct them we need some more data. This function prepares them for transferrability. Personally, I think the name mostly makes sense but I think it might be better to call it createTransferableMessage.. I think it is ok to let playback watcher handle this scenario instead of introducing complexity here. What do you think?. I think it would be better to create two different objects.\nPerhaps using Object.create to make the mainSegmentLoader_'s object with segmentMetadataTrack added to the base object.. Can you create a reusable stableSort(array, sortFn) function that doesn't require a modification to the objects with an index?. IMO both while loops in this function should be converted into Array#filters for readability.\n. As I mentioned above, a stable sort can be achieved without changing either of these functions.. As I mentioned above, a stable sort can be achieved without changing either of these functions.. This might be easier done as a filter to get all of the renditions with the same (highest) bandwidth and then taking the very first element.. There is no reason to declare this variable outside of the sort function below.. I think this boolean logic could use some cleaning up. Right now it says length not greater than or equal to one  which is difficult to wrap my brain around. I think a better one is simply length is zero.. Can we please, please rename fixBadSeeks_ to fixesBadSeeks_ because that would make me soooo happy.. Should this function ever run in VOD?\nIt seems wise to check to see if the duration is \"Infinity\" before taking any other measures.. I plan on doing this later by pulling in Pat's logger/history thing. This change was just to get rid of that ugly hack since we already have support for a less-ugly option in playback-watcher.. LOL. I'm not sure I understand. How can you ever have two segments with the same start-time?. Oh, your complaint was that I need to do lastDistance !== null ... Why did you just say so! \ud83d\ude06 . I discussed this with Matt in person. Basically, there are trade-offs either way. With this in place we may not respond to bandwidth issues as quickly but we ensure that we are always in a stable playback mode before we do switch. This is less important for VOD but it's a different story for live. One problem is that seekable can become stalled because we are changing playlists without having sync. Another problem is that we can conservatively guess multiple times in a row and will end up fetching the same segment over and over at different renditions (worst-case being ping-ponging as Matt put it.) This change should always result in a sync point being established and some forward progress being made before a rendition is allowed to change. Timeout-caused rendition changes will still happen immediately so that the player can take emergency action.. I think a better way would be to just always return true if there is only a single variant.. Removed.... Done. I haven't seen any issues. Aborting an already aborted xhr seems to be a no-op and doesn't trigger any sort of readystatechange.. You might be right. It looks like I was seeing sinon's mock xhr results (which are synchronous) and was confusing it with actual behavior.. Done. Fixed. Because we have this same test dozens of times and it's very redundant. I actually tried to remove more of them but lost hope.. Why did the alphabetical order get changed?! (Total nit-pick!). Interesting that linting didn't catch this unused value. I guess it's because it isn't a variable.. I'm so glad this will be going away with the fancy mediaSegmentRequest PR.. Just curious: why this was renamed?. Forgot to remove or uncomment?. At some point I feel like it might just be nice to have an array of active segment loaders. Then we can just do this.segmentLoaders_.forEach((l) => l.load());... not necessary now but maybe a good idea to think about soon.. If handleSubtitleError_ calls setupSubtitles is there a possibility that an infinite loop of failure will result?. Why not move this to where the SegmentLoader is paused above. It's easier to reason about the state of the loader if it is manipulated in one place. Also, shouldn't it be reset even if there is no track?. Everything about this feels wrong and dirty! \ud83d\ude31 . Is this function used anywhere?. Couple of thoughts on this whole block:\n\nWe should pre-calculate the vttLineTerminators value because it's a typed array that never changes\nI think we should do the entire append process when we first get the response for the initSegment so that we the object stored in this.initSegments_[initId] already has the value that would be in combinedSegment.. If error is fatal it should have some code set in addition to the message. The code is important for reporting reasons.. What does this mean?. If so, it needs a comment.. Sounds good to me. \ud83d\udc4d  . We decided not to do this now as we plan on revisiting how and when we emit errors at some point in the near future.. We decided to try not storing segment start and end times and letting the conservative guess make it work since web vtt segments should be much smaller than video or audio segments.\n\nOne thing to be careful about is that the \"resync\" functionality needs to be removed since it will continuously reset the segment loader on poor guess instead of just walking forward.. Do it! \ud83d\ude03 . I feel like a short version of this explanation needs to be in this function somewhere!. Well, is it? \ud83d\ude06 . What happens if we switch subtitles or seek while the state is 'WAITING_ON_TIMELINE'?. What happens if we switch subtitles or seek while the state is 'WAITING_ON_VTTJS'?\n. This seems like the perfect case to use this.subtitlesTrack_.tech_.one('vttjsloaded', ...). This seems like the perfect case to use this.syncController_.one('timestampoffset', ...). Why was this test skipped?. There is a small (1-line) difference between them.\nBasically, the one in test-helpers.js removes a line that triggered the error callback (since that is clearly wrong) but kept everything else the same.\nThis one additionally removes the setting of the aborted property to true since the goal of the test is to make sure that happens. Native browsers do not set that property but removing it from all FakeXHR instances would break other tests (namely, playlist loading tests) that rely on the property's presence to know if a request was aborted during the test.. The error parameter can be set for a variety of reasons. The only time we should consider it an actual error is when neither timedout nor aborted are set.\nThe issue was that a timeout was being interpreted as an error because the error parameter was set and the request wasn't aborted.\nIn the unit tests, Sinon's FakeXHR was setting the aborted property on timeouts avoiding this condition but the browser's native XHR does not set that property.. Sinon globally replaces XMLHttpRequest constructor. The two are equivalent.. That is exactly the point - to make sure we are adding the property ourselves even when Sinon isn't (like in the native browser).. All this code comes from Sinon - the only thing I changed was to remove the dispatching of an error event at the end of the function.. See above.. I think to ensure we don't introduce a regression in the future, we need a unit test around modification of timestampOffset (which we do in mp4Probe) to make sure it doesn't change the start and end time of the segment.. Not sure how I feel about this. We should be cleaning up tech.hls on dispose anyway. That we don't is actually a bug.. No, the source handler is disposed of on each source change.. In fact, the HLS property on the player is for compatibility reasons. David and I were considering removing the object all together if HLS is used with Video.js 6+. I feel this name is a bit ambiguous. Not sure if it's worth fixing but something like processedAppend_ might be more clear.. Good point.. I'm not sure there is a reason other than \"This was a common configuration when we started writing this project...\" which is a crappy comment :1st_place_medal: . Done. I don't know.. It seems like a fairly common configuration with MAAT unfortunately.. I add a warning log.. Changed to localOptions because mergedOptions and videojs.mergeOptions(..) is too confusing!. Because that are distinctly different \"options\" one comes from outside the project and the other is more of an object with functions necessary to the correct functioning of SegmentLoader.\nMerging them feels very wrong.. ",
    "TuanLDT": "I run example.html. See error: http://lh6.googleusercontent.com/-ITLBn8Rr9r8/VVHVC2rPSOI/AAAAAAAAAHI/T_TOJkqbjIM/w440-h330-p/e1.png\n. @dmlap . I think my problem have been solved.\nBut if you seek to the end of the progress bar and then seek to any position on the progress bar. Finally, you press the play button. The video will play, however it don't play from the position that you\nselected, it play to the first segment\n. ",
    "yaboo777": "+1\n. ",
    "drumlight": "The sample streams seems to have been taken down but I saw the same message when I had a dedicated PCR pid configured in the encoder instead of embedding PCR in the video PID. \n. Playback also worked for me but on a live stream I would expect to see some synchronization issues eventually.\n. Paul,\nIt depends a little upon the webserver that is hosting the stream but the documentation should be easy to find online. For Nginx I\u2019ve enabled CORS for all domains with the final line in the short snippet of my server configuration below.\nserver  ## For Serving HLS Segments\n{\n    listen       80;\n    server_name  localhost;\n    add_header Access-Control-Allow-Origin *;\n\u2026\u2026\u2026.\nIn your case you could also only access for the domain you are coming from by replacing the wildcard with a specific IP eg\nadd_header Access-Control-Allow-Origin 172.16.63.146;\nHope that helps but a quick search for your webserver and \u201cenable CORS\u201d should provide documentation relevant to your specific server.\nJake\nFrom: paulwang55 [mailto:notifications@github.com]\nSent: July-13-15 4:42 AM\nTo: videojs/videojs-contrib-hls\nSubject: Re: [videojs-contrib-hls] HLS playlist request error (#343)\nHi David,\nI get the following error message from my \"Google Chrome\" Javascript Cpnsole.\nXMLHttpRequest cannot load \"my index_512k.m3u8\". No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'http://172.16.63.146' is therefore not allowed access.\nDo you have any suggestion how I can solve this error ?\nRegards,\nPaul Wang\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/videojs/videojs-contrib-hls/issues/343#issuecomment-120851817.\n. I haven\u2019t checked up in the last couple of releases but the last time I saw a similar message it was because my stream had a dedicated PCR pid rather than including it in the video pid. It seems like a similar situation might occur with an audio only stream as the PCR may not be where it is expected.\nJake\nFrom: Emin [mailto:notifications@github.com]\nSent: July-30-15 3:20 AM\nTo: videojs/videojs-contrib-hls\nSubject: [videojs-contrib-hls] audio only playlist not working (#357)\nAudio only playlist is logging to console as follows , and no sound is produced.\ntested with putting a reverse_proxy in front of the following url for cors headers and an audio only stream produced by wowza, both has the same problem.\nhttps://devimages.apple.com.edgekey.net/streaming/examples/bipbop_4x3/gear0/prog_index.m3u8\nVIDEOJS: Unknown PID parsing TS packet: 2834\nvideo.dev.js:1457 VIDEOJS: Unknown PID parsing TS packet: 175\nvideo.dev.js:1457 VIDEOJS: Unknown PID parsing TS packet: 1808\nvideo.dev.js:1457 VIDEOJS: Unknown PID parsing TS packet: 3858\nvideo.dev.js:1457 VIDEOJS: Unknown PID parsing TS packet: 4537\nvideo.dev.js:1457 VIDEOJS: Unknown PID parsing TS packet: 6138\nvideo.dev.js:1457 VIDEOJS: Unknown PID parsing TS packet: 7059\nvideo.dev.js:1457 VIDEOJS: Unknown PID parsing TS packet: 1941\nvideo.dev.js:1457 VIDEOJS: Unknown PID parsing TS packet: 5282\nvideo.dev.js:1457 VIDEOJS: Unknown PID parsing TS packet: 6830\nvideo.dev.js:1457 VIDEOJS: Unknown PID parsing TS packet: 3442\nvideo.dev.js:1457 VIDEOJS: Unknown PID parsing TS packet: 2233\nvideo.dev.js:1457 VIDEOJS: Unknown PID parsing TS packet: 6693\nvideo.dev.js:1457 VIDEOJS: Unknown PID parsing TS packet: 851\nvideo.dev.js:1457 VIDEOJS: Unknown PID parsing TS packet: 7155\nvideo.dev.js:1457 VIDEOJS: Unknown PID parsing TS packet: 1698\nvideo.dev.js:1457 VIDEOJS: Unknown PID parsing TS packet: 4959\nvideo.dev.js:1457 VIDEOJS: Unknown PID parsing TS packet: 5992\nvideo.dev.js:1457 VIDEOJS: Unknown PID parsing TS packet: 4918\nvideo.dev.js:1457 VIDEOJS: Unknown PID parsing TS packet: 5860\nvideo.dev.js:1457 VIDEOJS: Unknown PID parsing TS packet: 4022\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/videojs/videojs-contrib-hls/issues/357.\n. ",
    "oldcookie": "Looks good, thanks!\n. Thanks @dmlap, overriding would work in my case.  \nNot sure what's the best way though, I mean, in most cases defaulting to native is probably good.  In this particular case, it's a bit weird cause natively has less functionality available.\n. Actually, I think I read the values wrong.  Will have to test it again tomorrow.   The end result is that segment is undefined.  So segment.preciseDuration causes an exception.  Not sure if I can fix this by checking if segment is defined, or if the sequence needs to be fixed.  Will test and update tomorrow.\n. So here's a capture of what happens.  I was wrong in the descriptions, it's actually i-playlist.mediaSequence being greater than the length of the playlist.segments.  \n\nWould a simple check of light of segments fix this? \n. Don't have one readily available, I'm just testing with our test server locally.  The stream is a live RTMP stream transcoded to HLS by Wowza.   Let me see if I can put something up on EC2 that can replicate this.\nOne question, is this potentially an issue with the way Wowza or us is doing the transcoding?\n. Ok, I have a stream running on this url that has this problem: http://54.147.189.132/yanked/comic-con/playlist.m3u8\nHopefully it stays up until you guys get to check it. :)\nIf you point example.html to it, run it for a while, you should see the issue.  It's been happening pretty consistently for me.\n.  Our configure is shorter than the recommended, in that chunk duration is set to 2s and playlist chunk count is set to 3, so about a 6s worth of content.  We set it like this to reduce latency.   Will test the longer duration and report back.\n. So we've dug more into the way Wowza works.  Looks like Wowza changes the target duration based on the longest gap between keyframes.  So even though we set target duration to 2s, if keyframe rate drops to 5s per keyframe, it would change the target duration to 5s.   So we suspect that the content size in each playlist is not changing by the target duration was changed, and hence creating this issue.\n. ",
    "FranklinWaller": "The blob file was produced by appending TS files. Which the player can handle when you start from 0. And if i try to access it from standard HTTP it's still the same. \n. ",
    "sgavali": "I'm also seeing this issue on android phone, after seek some times audio continues but video is frozen. If I use pause and play after this situation video resumes correctly. Is this chrome decoder issue ?\nProblem is seen on 0.x as well as 1.x plugin.\n. Adb logs shows no video decoder prints when video is in freeze condition. Manual pause and play resumes decoding.\n. I'm also seeing such issue after seek, progress bar starts from 0, while player is playing from seeked location. \nSometimes player does not seek to desired location.\n. What could be reason for progress bar showing incorrect playback time ?\n. +1\n. Where can I get working js files for latest 0.17.x release. Can someone update demo page using those so they can be easily available without building plugin.\n. 1.3.0 is source only too.\n. I tried to build dist package by cloning and running grunt, so far no luck. I'm trying 0.17.9 version.\n. I'm using these steps;\n$ npm config set strict-ssl false\n$ npm config set registry \"http://registry.npmjs.org/\"\n$ npm -proxy http://abcd:80 install videojs-contrib-hls@0.17.9\n$ grunt build\nWarning at grunt build,\n\n\nWarning: Task \"build\" not found. Use --force to continue.\nAborted due to warnings.\n\n\nConfiguration used, ubuntu 15.04, \n$ npm -version \n1.4.21\n$ grunt -version\ngrunt-cli v0.1.13\n$ nodejs --version\nv0.10.25\ngrunt v0.4.5\n. Is there way to trigger buffering in this scenario ?\n. Latest version of chrome also shows this issue.\n. Is 1.x beta available for testing ?\nBetween I tried hls plugin mentioned in https://github.com/videojs/videojs-contrib-hls/issues/437 it does solves this issue.\nBut I saw crash on Galaxy S3 (android 4.3 and latest chrome) with this error,\n\n\nSsbSipMfcDecInit] IOCTL_MFC_DEC_INIT failed\n. Thanks dmlap, I see 1.2.1 is released, but I'm getting errors while using it. Issue maybe version of video.dev.js and videojs-media-sources.js, I'm using these from videojs-contrib-hls demo page.\n\n\nError's are \n1. Uncaught TypeError: videojs.extend is not a function\n2. VIDEOJS: ERROR: (CODE:4 MEDIA_ERR_SRC_NOT_SUPPORTED) No compatible source was found for this video. \n. I could run 1.2.1 latest video.js and videojs-media-sources.js. There is no crash on galaxy S3 we can close this issue.\n. I'm using v0.17.1, issue is specific to device and not stream.\nAlso on some device I see different playback time stamp than what it should be, is this issue in Chrome stack ?\n. Is MSE support varies between Android release ? I tried this plugin for a issue https://github.com/videojs/videojs-contrib-hls/issues/424 I was facing and it worked on Android 4.4.x but crashed on Android 4.3\n. I also see issue with IE, I'm using all latest plugins.\n\n\nVIDEOJS: InvalidStateError Video is not ready. (Video.js)\n. I'm seeing issue on Android, it's not specific to OS / Chrome version. Issue 3 is easily seen on Xiomi redmi 4i phone. What may be causing this, is this related to https://github.com/videojs/videojs-contrib-hls/issues/358 ?\n. One more observation, on doing multiple seeks I'm seeing crashes due to audio discontinuity. The content is playing properly without doing seek.\n\n\n1)\nD/NuPlayer( 254): got audio decoder EOS\nD/NuPlayer( 254): got audio decoder discontinuity, (consume status: 0, 0)\nW/NuPlayerRenderer( 254): numFramesAvailableToWrite(8916), mAudioSink frameCount(8916), mAudioQueue size(1), numFramesPlayed(0), mNumFramesWritten(0)\nD/NuPlayerRenderer( 254): audio played time(0 us), system time(235749053376 us),S-A\nI/AudioSink( 254): [stop] stop\nD/AudioTrack( 254): audiotrack 0xabb16150 stop done\nD/MediaPlayer( 4252): handleMessage msg:(100, 1, -1004)\nD/NuPlayerRenderer( 254): audio position EOS\nE/MediaPlayer( 4252): Error (1,-1004)\nE/NuPlayerDecoder( 254): Stream error for OMX.MTK.VIDEO.DECODER.AVC (err=-1004), EOS successfully queued\n2)\nE/NuPlayer( 238): audio track encountered an error (-1004)\nE/ ( 238): not in avi mode\nV/MediaPlayer(30374): message received msg=100, ext1=1, ext2=-1004\nE/MediaPlayer(30374): error (1, -1004)\nV/MediaPlayer(30374): callback application\nV/MediaPlayer(30374): back from callback\nV/MediaPlayer(30374): getCurrentPosition\nE/NuPlayer( 238): video track encountered an error (-1004)\nV/MediaPlayer(30374): message received msg=100, ext1=1, ext2=-1004\nV/MediaPlayer(30374): seekTo 6136808\nE/MediaPlayer(30374): Attempt to perform seekTo in wrong state: mPlayer=0x59b32168, mCurrentState=0\nV/MediaPlayer(30374): message received msg=100, ext1=-38, ext2=0\nE/MediaPlayer(30374): error (-38, 0)\n. I checked with 1.2.1 plugin and crash issue looks to be gone. It was seen with 0.x plugin.\nRegarding seek issue no 3, I still see using 1.2.1, putting alert in seeked event the time shown is correct, but progress bar shows different value. \nIt happens frequently when seek is done towards end of video while current position is at beginning. The progress bar still shows old value, does this mean for calculation of progress bar %, playback time before the seek is getting used ?\n. One more observation. Sometimes seeked event is not coming, and player continue to show loading spinner. Any seem using seekbar does not help.\nFor issue 3 I'm seeing current time corresponding to seeked location which is different than intended position.\n. The last issue looks same as https://github.com/videojs/video.js/issues/2647\nBut I can still see using latest video js and hls plugin on some android phones.\n. I can reproduce using bipbopall.m3u8 .\n\n. I checked using 1.3.0 and issue is fixed. Thanks.\n. I'm also seeing this issue with my stream, but the bipbopall stream is not showing this problem.\n\n\nUncaught TypeError: Cannot read property 'segments' of undefined(\u2026). Is there anything needs to be done while creating playlist ?. My issue looks to be related to content, got it working with different stream. . Thanks Garrett, a naive question, using videojs-contrib-hls on Android chrome with native playback supported is as good as not using videojs-contrib-hls plugin's implementation ? \n\n\nI tried using overrideNative along with other html5 override, I was not able to play playlist on a Android 5.0.2 with Chrome 46.. Thanks Garrett for information. . ",
    "Agnostic": "I don't know why these issues are being closed even if there are more people having the same issue, I saw some tickets talking about some problems I had and closed because \"no response for a while\" or insufficient information, currently I am having this issue, after seeking the video freezes, I have to manually pause and play again to \"fix\" this behavior, and only sometimes works.. I understand, I'll try to share a test case on the next time, also I will try to be up to date with the library, thank you!. I have the same issue, any updates on this @forbesjo?\n. The issue is that the player tries to get always the best resolution available, even if it fails at the first time, if you look at the network log it will show something like this:\nDownloading chunk (512) ... (exceeds timeout)\nDownloading chunk (256) (Loaded successful) Video starts...\nDownloading chunk (512) ... (exceeds timeout) - Video pauses...\nDownloading chunk (256) (Loaded successful) Playing...\nDownloading chunk (512) ... (exceeds timeout) Video pauses again...\nSo I think the video should be playing smoothly based on the bandwidth instead of pausing every time it tries to download the biggest chunk.\n. ",
    "featheast": "I am having exactly the same issue with you @mpotra , and wondering if you or anyone else have a solution yet?\n. I have been trying by either re-init or re-load the HLS plugin or the playlists, but not having any luck so far. \n. ",
    "ahomu": "i have same issue too...\n. ",
    "shaharmor": "+100 ! this is very disturbing!\n. This specific video is a VOD stream that i'm playing in a loop. It was generated using Kaltura server\n. You right that adding a .play() will start playing immidiatly, but that is not the issue.\nI used the snippet in the first post just to change the source.\nconsider this: If you have a page with a live url, once you click the play button it waits to download another manifest file, even if it just downloaded the last one a second ago.\nSo i'm mimicing it by changing the source and then manually clicking play\n. Possible.. i'm not really into all the internals of stuff, but i just know that the playback doesn't start until another manifest file is downloaded after you click the play button.\nBtw, waiting for another manifest file is fine, as long as the request for that manifest file is being made immediately after a user clicks the play button. (Today it waits the default time)\n. Just checked and it indeed fixes the issue.\n. ",
    "dtrikannad": "Forgot to mention that this occurs in both Firefox and Chrome browsers on Mac OS X Yosemite, but seems to play just fine in the safari browser.\n. I have tested on both but thought the most relevant place to post my findings was on 267. \nSent from my iPhone\n\nOn May 18, 2015, at 8:44 AM, David LaPalomento notifications@github.com wrote:\nI could see this being related to #267. Would you mind retesting against master?\n\u2014\nReply to this email directly or view it on GitHub.\n. Looking to know when either a specific TS file is playing so that the player can take custom actions. I'm looking to serve ads server side from within the m3u8 manifest of the main program but need to lock playback controls during ads etc and then unlock them when the ad is done. \n\nSent from my iPhone\n\nOn Jul 1, 2015, at 12:17 PM, David LaPalomento notifications@github.com wrote:\nWhat's the use-case for this?\n\u2014\nReply to this email directly or view it on GitHub.\n. \n",
    "hubertperron": "+1 for this. It's not really clear how to use the plugin at all\n. ",
    "anthonyettinger": "I can't figure it out either. Does the .min file have everything I need?\nI jsut load the 3 js files and create my video tag, but it doesn't work in Chrome.\n. ",
    "mikrohard": "I see that some unit tests fail... probably due to https://github.com/mikrohard/videojs-contrib-hls/commit/f90651b3c85890842dbe116745a786249c363063 Guess it'll have to be fixed in a different way.\n. Great news about the tests...\nAbout issue no. 4... I can't give you a 100% reproducible case. But if you take the sample content I provided above and start seeking to a random position the moment is starts playing (sometimes even before it starts) it should be quite easy reproducible. I reverted my last commit and it took me about a minute to get this: https://dl.dropboxusercontent.com/u/8261657/videojs-hls-seeking-crash.png\n. Ok... I did a little digging about issue no. 4.\nI found out that seek always fails if seeking in between two segments where the preciseDuration of the segment is shorter of the duration provided by the playlist.\nHere is a list of preciseDuration vs. duration reported by playlist for the above sample:\nvod-01.ts: 9.548822222221643 vs. 9.873\nvod-02.ts: 9.664244444443845 vs. 9.706\nvod-03.ts: 9.70351111111138 vs. 9.707\nvod-04.ts: 9.081799999999815 vs. 9.124\nvod-05.ts: 9.473755555556156 vs. 9.457\nvod-06.ts: 9.54339999999944 vs. 9.54\nvod-07.ts: 9.914911111112684 vs. 9.915\nvod-08.ts: 9.613066666666418 vs. 9.623\nvod-09.ts: 9.891711111110636 vs. 9.873\nvod-10.ts: 9.86848888888862 vs. 9.873\nvod-11.ts: 6.246177777779288 vs. 6.248\nWhat happens:\n1.) User seeks to 19.3 seconds (this is between the preciseDuration 19.213 and playlist duration 19.579)\n2.) The previous logic downloaded the segment at index 1 (because the seek time is below 19.579)\n3.) The logic expected to find the PTS for time 19.3 (which was in segment at index 2 because the seek time is above 19.213)\n4.) It crashed in the while loop\nWhat I did to fix this:\n1.) Use preciseDuration whenever possible. This selects a correct seek media index if preciseDurations are already known.\n2.) Fallback to closest timestamp if desired PTS not found. I think this is a reasonable fallback because the error should never exceed a few hundred milliseconds. We could correct the mediaIndex and load the correct segment... but this would unnecessarily increase the seeking time.\n. @dmlap Any comments about my findings on issue no. 4?\n. Sorry... I did try to get grunt working but it just gets stuck at \"Running \"jshint:test\" (jshint) task\" and using 100% CPU. I don't have the time to debug this... I guess it's just gonna have to wait.\n. It looks good as far as I'm able to say be just looking at it. Will do a runtime test tomorrow...\n. I can confirm that it works the way it should. Great job!\n. ",
    "carpasse": "Want me to do a quick PR to remove the dist from .npmignore??\nAlso regarding bower, do you have any plans to publish the plugin there?\n. ",
    "saxena-gaurav": "This is getting addressed in #395 \n. @dmlap : Thanks for the review. I have created new PR #386. Closing this PR.\n. This PR is against the development branch. Same as #375 which is against master branch.\n. @dmlap : Thanks for the review. I have addressed the code review comments.\n. https://github.com/videojs/mux.js/pull/21\n. Against development branch:  https://github.com/videojs/videojs-contrib-hls/pull/395\n. closing in favor of #395 \n. Not needed. This will be in the videojs-contrib-media-sources project. \nhttps://github.com/videojs/videojs-contrib-media-sources\n. This is not needed any more. This work has been merged to development branch.\n. LGTM\n. I think we don't need the below lines now \nhttps://github.com/dmlap/videojs-contrib-hls/blob/flash-mode-loadstart/src/videojs-hls.js#L147-L149\n. LGTM\n. @dmlap : Changes looks good.\n. done.\n. WebKitDataCue is not available in Chrome/FireFox. We have to stick with VTTCue for now. There is an issue filed for this: https://github.com/videojs/videojs-contrib-hls/issues/303\n. In discussion with @imbcmdth , we do not need frame.data. \n. ",
    "parrfolio": "Would love to get this fix. \n. ",
    "scramatte": "I still got the issue with  Firefox 39.0 on Mac with OS X Yosemite.\nChrome and safari   are Ok.\nhttp://iptv.nicos.es/hlsbug/\n. It seems that the issue still occurs on Mac. On Windows it looks OK.\n. http://iptv.nicos.es/hlsbug/\nIt occurs mainly when switch channels\n. Do you mean  master branch  ?\n. ",
    "Awais-cb": "I am facing this issue today.on windows on latest chrome is there anyone who could help me about it.. @heff @ronhopper @makotokw @dmlap @t2y is there anyone who could respond about this issue?. @forbesjo  sir can i please ask you one thing on which OS and browser you are testing this video?\nissue appears on Windows 10 with chrome as browser. ",
    "troyanskiy": "Hello @Awais-cb \nI'm facing the same issue. Did you found a solution?. ",
    "dcrockwell": "+1 this is blocking #277, which in turn is blocking our team.\n. @vasklund excellent! Thank you very much.\n. ",
    "vdeshpande": "Hi @oldcookie ,\nI stepped through the code for the playlist.js file using a sample live stream however I did not get a value of undefined on segment while letting the live stream play.\nAre you able to point me to a page where this condition is met and can be reproduced on a regular basis ? \n. It would be difficult to say anything unless the I can see the issue and which is reproducible at a fairly constant rate.\nOne thing which I have observed , which I'll share is this:\nWhile testing locally as well, if I put in breakpoints on the lines of code which you had mentioned earlier, and if I let the live stream play and immediately pause it, and try debugging and stepping through the code using the browser tools until we get to the point where all the segments obtained till that point have been exhausted, the error of undefined on the segment gets thrown which seems logical to me since we don't have any further segments to get.\nOtherwise if I let the LIVE stream play in the player the issue does not seem to occur.\n. yes, will fix that. thanks!\n. This change is accidental\n. I was adding these overrides because of the jshint error I was getting while grunting the repo. Mixed spaces in the repo.\nDo these overrides cause any issues ? Should I remove ?\n. Will do that.\n. I'll rename the function. Should I be very descriptive or just an in short description will do ?\n. I'm just getting the length of the fictitous array\n. ",
    "alex-steel": "Thanks!\n. yes\n. ",
    "Llorx": "To add a bit of info for this to be available, nginx rtmp from Arut creates a discontinuity tag line (EXT-X-DISCONTINUITY) between .ts files inside m3u8 manifest. This usually happens when resetting an stream.\n. This is happening to me too.\nAlso, I noticed this only with autoplay enabled. Without autoplay it loads a few ts files, shows them and then hangs without loading any more files. (With autoplay I mean adding player.play() to the code)\nAnd one more thing. I disabled condition that starts in line 912 in videojs-hls.js (if (typeof offset === 'number') {) because it was returning this error on startup: Uncaught TypeError: Cannot read property 'pts' of undefined. This was the line while (tags[i].pts < ptsTime) { around line number 915.\n. I've modified it a bit and seems to work:\nptsTime = offset - segmentOffset + tags[0].pts;\nwhile (tags[i] && tags[i].pts < ptsTime) {\n  i++;\n}\nwhile (!tags[i] && i > 0) {\n    i--;\n}\n// tell the SWF where we will be seeking to\nBut now I have the problem that it don't plays in Android, but I think that is something with my stream, because also with another player don't works (don't remember it).\n. Not using android 5.0, but good to know because my streams have underscores.\nThank you!\n. @dmlap I see. Thank you for your reply.\nSo I'm going to add Flowplayer fallback with Andoird then. Thank you for your work here!\n. @dmlap Now I thought. Can you push an option to force your playback instead of using the native one? So I can try contrib-hls in Android, because Android one seems glitchy. Also, if your option fails for wahtever reason, then fallback to native one (just in case some devices can run it).\nThank you.\n. @dmlap I said that because Flowplayer works on Android. Don't know exactly why but it works. Tried contrib-hls and another player that I don't remember (medialement I think) and both gave exactly the same result on Android until I checked Flowplayer. I have to say that on Android Flowplayer shows its own player and not the default one that \"comes\" with Android like the other two players.\nI thought that contrib-hls was pure Javascript without Flash fallback. The bad thing is that my site is about live events and I cannot add a direct mp4 video. I can use HLS and RTMP links (that act like direct mp4 video) but I can't find any Javascript player that switches between RTMP links with different bitrate hls-adaptive-like when detect bandwith problems.\nIf you want to check, I can leave my computer on with a loop stream and I can give you a link with both players, contrib-hls and Flowplayer, so you can check the differences. I checked the mobile console with the PC when tried it and returned no errors so If all players fall to the same thing, I don't get a clue on what's happening.\n. I've made a workaround, adding this in the line 185 in playlist.js:\n// accumulate the segment durations into the result\n/* ADDED WORKAROUND */\nif (endSequence - startSequence > playlist.segments.length) {\n    endSequence = startSequence + playlist.segments.length;\n}\n/* END WORKAROUND */\nresult += accumulateDuration(playlist,\nThis ensures that it will not ask for more segments than needed.\n. I've switched to Flowplayer some time ago, as I needed a production-secure release.\nSince videojs-contrib-hls has changed a lot lately, I have to give it a try again.\nThank you for the follow up.. ",
    "codex-corp": "@dmlap \ncan you please write a example how to use in-band meta data with videojs\ncheck the code for jwplayer\n```\nplayer.onMeta(function(evt) {\n    if (evt.metadata.TXXX) {\n        //console.log(evt.metadata.TXXX);\n        index = evt.metadata.TXXX.indexOf(\"adID:\");\n        if (index >= 0 ){\n            req = evt.metadata.TXXX.substring(index+5);\n            req2 = decodeURIComponent(req);\n            //console.log(req2);\n        player.playAd(req2);\n    } \n}\n\n});\n```\n. @dmlap \nGreat , thanks!\n. @norlin \ni have the same problem , wired .\n. Here my solution to add level switcher menu, it's not ready 100% but it's working fine for me \ud83d\udc4d\n\n\"video.js\": \"^5.19.2\",\n\"videojs-contrib-hls\": \"^5.4.1\",\n\"videojs-contrib-quality-levels\": \"^2.0.3\",\n\n\n```js\n/\n * Author (c) Hany alsamman\n * Licensed under the Apache-2.0 license.\n /\n(function () {\n    / jshint eqnull: true/\n    / global require /\n    'use strict';\n    var videojs = null;\nif (typeof window.videojs === 'undefined' && typeof require === 'function') {\n    videojs = require('video.js');\n} else {\n    videojs = window.videojs;\n}\n\n(function (window, videojs) {\n    'use strict';\n\n    var defaults = {};\n\n    /**\n     * Return MenuButton's MenuItems.\n     *\n     * @method MenuButton.getItems\n     * @return MenuItem[]\n     */\n    var MenuButton = videojs.getComponent('MenuButton');\n\n    /**\n     * Set current level.\n     * This provides interface to either Player tech.\n     *\n     * @method setLevel\n     * @param  {Number} level\n     * @return Levels[]\n     */\n    videojs.getComponent('Player').prototype.setLevel = function (level) {\n        var current_list = player.hls.playlists.master.playlists;\n\n        player.hls.representations().forEach(function(rep) {\n            if (rep.bandwidth === level) {\n                // player.handleTechWaiting_();\n                current_list.forEach(function(list,index) {\n                    if(list.attributes.BANDWIDTH === level){\n                        // console.log(player.hls.playlists.master.playlists[index]);\n                        player.hls.playlists.media(player.hls.playlists.master.playlists[index]);\n                    }\n                });\n                rep.enabled(true);\n                // player.hls.bandwidth = level;\n            } else {\n                rep.enabled(false);\n            }\n        });\n        player.handleTechPlaying_();\n        // this.getTech().setLevel(level);\n    };\n\n    var MenuItem = videojs.getComponent('MenuItem');\n\n    videojs.MenuItemTest = videojs.extend(MenuItem, {\n\n        constructor: function (player, options, onClickListener) {\n            this.onClickListener = onClickListener;\n\n            // Call the parent constructor\n            MenuItem.call(this, player, options);\n            this.on('click', this.onClick);\n            this.on('touchstart', this.onClick);\n\n        },\n        onClick: function () {\n            this.onClickListener(this);\n            var selected = this.options_.el.value;\n            console.log(this.options_.el.value);\n            player.setLevel(selected);\n        }\n    });\n\n    /**\n     * LevelsMenuButton\n     */\n    videojs.levelsMenuButton = videojs.extend(MenuButton, {\n\n        className: 'vjs-menu-button-levels ',\n\n        init: function (player, options) {\n\n            videojs.getComponent('MenuButton').call(this, player, options);\n\n            this.controlText('Quality');\n\n            var staticLabel = document.createElement('span');\n            staticLabel.classList.add('vjs-levels-button-staticlabel');\n            this.el().appendChild(staticLabel);\n\n        },\n\n        createItems: function () {\n\n            var component = this;\n            var player = component.player();\n            var fetch_levels = player.qualityLevels();\n            console.log(fetch_levels);\n            var levels = fetch_levels.levels_;\n\n            var item;\n            var menuItems = [];\n\n            if (!levels.length) {\n                return [];\n            }\n\n            // Prepend levels with 'Auto' item\n            levels = [{\n                name: 'Auto',\n                index: -1\n            }].concat(levels);\n\n            var onClickUnselectOthers = function (clickedItem) {\n                menuItems.map(function (item) {\n                    if ($(item.el()).hasClass('vjs-selected')) {\n                        $(item.el()).removeClass('vjs-selected');\n                    }\n                });\n                $(clickedItem.el()).addClass('vjs-selected');\n            };\n\n            return levels.map(function (level, index) {\n\n                // Select a label based on available information\n                // name and height are optional in manifest\n                var levelName;\n\n                if (level.name) {\n                    levelName = level.name;\n                } else if (level.height) {\n                    levelName = level.height + 'p';\n                } else {\n                    //levelName = Math.round(level.bitrate / 1000) + ' Kbps';\n                    if (level.bitrate) {\n                        levelName = (Math.round(level.bitrate / 1024) + 'kb');\n                    } else {\n                        return null;\n                    }\n                }\n\n                item = new videojs.MenuItemTest(player, {\n                    el: videojs.getComponent('Component').prototype.createEl('li', this, {\n                        label: levelName,\n                        value: level.bitrate,\n                        class: 'vjs-menu-item'\n                        //tabIndex: 0,\n                    })\n                }, onClickUnselectOthers);\n\n                /**\n                 * Store MenuButton's MenuItems.\n                 * @return object\n                 */\n                menuItems.push(item);\n\n                if (level.name === 'Auto') {\n                    $(item.el()).addClass('vjs-selected');\n                }\n                $(item.el()).html(levelName);\n\n                return item;\n            });\n        }\n\n    });\n\n    // register the plugin\n    videojs.plugin('levels', function (options) {\n\n        var settings = videojs.mergeOptions(defaults, options);\n        var player = this;\n        var button = null;\n\n        player.on('loadedmetadata', function (evt) {\n            if (button) {\n                button.dispose();\n            }\n            button = new videojs.levelsMenuButton(player, settings);\n            button.el().classList.add('vjs-menu-button-levels');\n\n            player.controlBar.addChild(button);\n        });\n    });\n\n})(window, videojs);\n\n})();\n```. @dmlap hi master, could you help to make this code better.. ",
    "apadhye": ":+1: \n. ",
    "tokmak": "Hi, thanks for the response. I dont have a public url\n. ",
    "c3iq": "I'll try elsewhere for now.  I have thousands of videos, without single_file I might reach the limits of the file system.  Good luck with this plugin.\n. ",
    "MarcusOhman91": "Android 5.0 introduced an issue where you cannot play hls livestreams if the URL contain any underscores (native issue), might be why its not working for you.\n. ",
    "seamug": "@scramatte is your problem solved cos I'm having the same issue\n. ",
    "trungpham": "i'm having the same issue too.\n. ",
    "jpfranco": "@dmlap yes, sorry about the late reply. We're trying out HLS 4 because we use signed urls, so with byte ranges we can avoid having to sign a bunch of separate .ts files. We do keep a separate HLS 3 stream, so I guess we'll just switch to that for now. Do you guys have plans to implement these newer HLS features? Thanks\n. @t-n yes, it's working for me too with the latest mux.js\n. We've been experiencing the same issue lately. I've been able to reproduce it consistently using this source:\nSource\nThe issue occurs randomly and always at a different position, but it's very easy to reproduce if you just let the video play in the background and come back later. Once the video freezes, no more chunks are downloaded until you seek past the frozen point. If you seek to a previous time though, the video will freeze again when reaching the time at which the problem occurred. \nThis was seen on Chrome (latest) using VideoJS 5.10.4 and videojs-contrib-hls 3.1.0.\nEdit\nI just noticed that right before the freeze I get a durationchange event with a slightly different duration. The original duration was 2471.24 and then right before the freeze it changed to 2471.2147469999577. \n. ",
    "spg": "I would definitely be interested in byterange support. +1\n. ",
    "paulwang55": "Hi David,\nMy stream can be worked in Safari and iOS when I excute \"example.html\" with my m3u8 playlist.\nI don't have CORS configured for my \"Live TV\" stream.\nRegards,\nPaul Wang\n. Hi David,\nI get the following error message from my \"Google Chrome\" Javascript Cpnsole.\nXMLHttpRequest cannot load \"my index_512k.m3u8\". No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'http://172.16.63.146' is therefore not allowed access.\nDo you have any suggestion how  I can solve this error ?\nRegards,\nPaul Wang\n. ",
    "htn264": "It is from the same domain (just different port) and the cross domain error on desktop still occurred. Right maybe. I will try to configure CORS. I got some guides from Wowza and some guides from CORS. \nFor the m3u8 from public places, I guess they are blocked also.\nI just wonder why the link m3u8 from wowza run on mobile does not need CORS configured anything ???????????? They still run fine without any CORS configured. (same domain - just call to different port 1935)\nNote: The CORS config Wowza offer currently does not work in my situation. I have checked configuration files like 5 times already, and the cross domain issue on desktop was still there. I am asking them on their forum but this simplest config currently does not work in my case:\nProperty\nName cupertinoUserHTTPHeaders   Name\nValue Access-Control-Allow-Origin: *   Value\nProperty\nNote above: Github removed all tags so I had to removed them. However, if you did it, then you would understand what I mean.\n. I see on the webpage information that it still requires Flash.\nHow about the second problem that is mentioned above ?\n. ",
    "misteroneill": "Pending resolution of my one inline comment, this LGTM.\n. Looks like the video is not served via SSL, we'll want to fix that. I am getting the following error in Firefox 41.0.1 on OS X:\n\nBlocked loading mixed active content \"http://solutions.brightcove.com/jwhisenant/hls/apple/bipbop/bipbopall.m3u8\"\n. You can do this, but I wouldn't suggest it. There was a recent change to the linter that accidentally introduced breaking changes (my fault!), but typically this shouldn't happen. I'd suggest reconsidering.\n. Well, it'll be needed anyway. Another question: if webworkify is used, why isn't it a dependency of the project?. Most places are checking hasPlayed_ except here. Wondering if that's intentional or, at least, not harmful.\n. \n",
    "chriswiggins": "Lots of questions about where to start but I'll have a look around and let you know :-)\nGuessing I'll just start looking at what parses the m3u8 and sets the duration. Hopefully it'll be fairly straightforward to know what segment we're currently displaying vs what segment is at the end of the playlist. Does video.js provide a mechanism to \"go back to live\" or should we just rely on the user seeking to the end? I suppose I could always add a controlbar plugin to add that feature.\nI'm not sure if this will work on iOS as I've never had any success with the native player (it just shows live). Does video.js just talk with the player or does it set a whole lot of things itself?\nThanks for the support @dmlap !\n. I'm giving this a go again but have run into an issue. I need to access properties set inside the HLS tech from another plugin however player.hls seems to be undefined? It is mentioned in the readme that there are methods available there so i'm wondering why I can't access them both inside another plugin or directly after setting up the player:\njavascript\nvar player = videojs('video');\n    player.play();\n    player.on('timeupdate', function(duration){\n        console.log(player.hls); //<------ This is undefined?\n    });\nHelp appreciated as I'm thinking this will be easier than first anticipated :-)\n. Scratch that - it just doesn't show up in Safari. Although that in itself raises another potential problem for another day!\n. Back to playing with this again - seems to be a weekend sort of project :-)\nIts weird I now can't get my development environment to work at all now, nor using any public live HLS playlists. I'll try and sort this out but its been an hour and still no luck. It works in Safari but something weird must be going on with my Flash install as it doesn't work in Chrome/Firefox...\nHowever I do still have a question or two. Its appears as if player.seekable().end(0) gives the current position in the live playlist, not the end? I.e the 'end' of the playlist should typically be about 3 seconds ahead of the current position due to HLS having to buffer at least 3 segments correct? Is there a way to figure this out?\nAlso, how can I modify the behaviour of the controlbar to enable scrubbing? Can I override events emitted by the HLS plugin to trick the controlbar into allowing scrubbing etc?\nAppreciate the help @dmlap - hoping to put more time into this in the coming weeks too\n. Its also noted here docs/live.md so we should make sure the same behaviour is seen (or mimicked) in the browser version\nThe currentTime is equal to the amount of the stream that has been played back on the device.\n. @jimmywarting try peer5/videojs-contrib-hls.js. ",
    "kmahelona": "Hey, we're a non-profit media company in NZ (http://tehiku.nz) and we're looking for a good, open-source, nDVR player for our livestreams. Had a play with clappr, which is great, but buggy (and currently not building).\nIf you ever need a live nDVR stream let me know and I'll spin up some servers and make a stream for you. I only ask for a time window so we're not incuring too much AWS costs. Also keen to help with testing.\n. ",
    "nickygerritsen": "Hmmm I came across this issue and I think it is the best place for the following:\nBefore even starting to try to implement some UI for DVR, it seems there is some bug: the player.seekable does not get updated during playback of the stream.\nI.e. it has one range in the beginning and that range is static; it is never updated to a new range.\nIs this a bug or is this never implemented?\n. Ah it seems this is expected, as this timerange is relative to the first moment that is still playable. E.g. for me it is always [0,120] as I have a DVR length of 120.\nHowever, how do I convert this into something I can pass to currentTime, i.e. how do I know what timing we can use? Preferably without using any HLS plugin specifics, as then a DVR could be created for any stream that is live and seekable, i.e. also for DASH and native-HLS.\n. Hmmm now I'm really confused; it does seem to update the data correctly using values I can pass to setCurrentTime.\nHowever it only updates every few seconds, so if we were going to use this for DVR and the user seeks to the beginning of the DVR window, that part will most probably be gone already. Any suggestions on this?\n. Great! I guess I can wait a week :).\nIf you need any feedback or so with the ES6-thingy, let me know!\n. Btw (maybe not the right spot to ask), but is such a plan also in the works for the DASH contrib plugin?\n. Perhaps if you have ES6'ed contrib-hls I can use that as a basis for dash :).\n. \\o/\n. We seem to also have this issue, but (manually) applying the patch did not really solve it... \nI do get the following console errors after a short while:\nVIDEOJS: WARN: Problem encountered with the current HLS playlist. No suitable alternatives found.\nvideo.js:19152 VIDEOJS: ERROR: (CODE:4 MEDIA_ERR_SRC_NOT_SUPPORTED) The media could not be loaded, either because the server or network failed or because the format is not supported. MediaError {code: 4, message: \"The media could not be loaded, either because the \u2026rk failed or because the format is not supported.\"}_logType @ video.js:19152log.error @ video.js:19103error @ video.js:11654handleTechError_ @ video.js:10459ret @ video.js:18981ret @ video.js:18981data.dispatcher @ video.js:18629\nvideo.js:19152 VIDEOJS: WARN: Problem encountered with the current HLS playlist. No suitable alternatives found.\nvideo.js:19152 VIDEOJS: WARN: Problem encountered with the current HLS playlist. No suitable alternatives found.\n17transmuxer-worker.js:49 Uncaught InvalidStateError: Failed to set the 'duration' property on 'MediaSource': The MediaSource's readyState is not 'open'.\nWhich I didn't get before.\n. No problem, it is: http://hls.streamonecloud.net/livestream/amlst:h3kXcf2yyam/playlist.m3u8\n. I have not worked on it yet. Feel free to add it to m3u8-parser or otherwise I will add it at a later time.\n. The benjipott version should work. We are using it in our player with contrib-hls and contrib-dash and everything works.\nNote that if you want to have a playlist with multiple items it doesn't work out of the box, but we have created a fork that should work.\n. ",
    "FDiskas": "Same problems :+1: \n. I'm actualy parsing the playlist - searching for the ENDLIST tag then forsing with player.playlists.media().endList = true; :)\nhack as hell :dancers: \n. Result https://youtu.be/7wltaNrqqtQ\nMy problem, is that videojs is not triggering ended event then on DVR updatets metatag endlist \n. To many issues on dailymotions LIB. This one works better. For example LG G3 phone is not playing videos on dailymotions but works on this\n. Then #EXT-END-LIST added the player does not trigger ended event\n. And you got the ended event?\n. And if I try player.hls.duration() I always get response as Infinity\n. :water_buffalo:\nNo lag using http://whatsmybrowser.org/b/YL6D2PF\nBut there is some other issue: http://i.imgur.com/YZi9cZZ.png using http://whatsmybrowser.org/b/H1DOV00\n. Thanks but even that plugin does not works :) only stores the values.\n. The link is 404\n. +1\n. what if dynamically #EXT-ENDLIST was added to playlist?\nFor me it looks like hls object is not updated correctly.\nI don't have anything specific to this, but just the gues...\n. So why I opened that issue...\nI dont know how to change this. I need an example.\nI tryed just videojs.Hls.GOAL_BUFFER_LENGTH = 60; but this not works. Still got the same 30s. buffer.\nAnd one more issue. It should be imposible to seek LIVE stream to the time that is higher than the current time - buffer size.\n. @dmlap - reopen the issue.\n. +1\n. in m3u8 file i have 6 segments with 10s. duration each. There always is minimum 6 segments. So I changed constant\nI changed GOAL_BUFFER_LENGTH to 60. Rebuilded the scripts to dist and runned included tests in development branch and there was ~17 failed tests. All them talks about seek problems or something.\n. > Any chance you could elaborate on why you need 60 seconds of content buffered in your player?\n\nJust to have more time for server sync\n. Yes, sometimes the video is to close to the live last segment in playlist. If the are some issues with stream servers and segments are not synchronized correctly the user's video is usually stops playing if reaching the last segment. So I need to increase that and force users to watch live with 60s. delay.\n. :information_source: I'm not working on that project any more.\n. You can check all problems here http://bit.ly/2aEjHvF\n. if I add .hls.playlists.media().segments = new Array(1) I will get error TypeError: Cannot read property 'minVideoPts' of undefined\n. \n",
    "jaq316": "@FDiskas... The video at the link seems to be removed. \nHas anyone had any luck implementing this?\n. I would suggest something along the lines of... If the playlist is blacklisted but there are no other playlists, retry the download of the segment for a configurable amount of time, or at least, fire off an event so that we can handle this case in some other way. What do you guys think about that?\n. I've also seen this. If you open the stream directly in Firefox, it plays, so FF definitely supports AAC audio.\nMy HLS streams are from Wowza\n. ",
    "Jrubensson": "Just looked into this, since we switched from JW Player to VideoJS but are missing the DVR. Did anyone solve this?\n. This plugin solved our issue: \nhttps://github.com/toolbox-tve/videojs-dvrseekbar. Any news on this? Would also like to use some functions relative to the HLS-object in VideoJS in Safari, and would be glad if I could override the native Safari playback. . ",
    "AlexMurm": "I also have the same issue. Link to reproduce:\nhttp://origin.platformcraft.ru/alexmurm/videojs/5tv_5.html\n. At the moment there are some problems with original stream (http://hls.tntmusic.cdnvideo.ru/tntmusic/tntmusic2.smil/playlist.m3u8). So this is new stream with the same issue for test purposes:\nstream:\nhttp://live.musicbox.cdnvideo.ru/musicbox/musicbox.sdp/playlist.m3u8\npage url:\nhttp://cdn.platformcraft.ru/alexmurm/tntmusic/test_hls.html\n. Don't see bug now. Reopen if needed.. ",
    "tjenkinson": "For reference it looks like this is where the error is occurring:\nhttps://github.com/videojs/videojs-contrib-hls/blob/master/src/playlist.js#L133\nSafari supports hls natively so my guess would be that this code never runs there.\n. Sorry about that fixed now. Thanks for reporting.. Hey @imbcmdth just realised this is still open. Is there a problem? Version 2 was a rewrite from the spec. Bump. done! https://github.com/videojs/videojs-contrib-hls/pull/1327. That's strange I just updated package.json and ran\nnpm install\nWill have a look\nOn 26 Jan 2018, at 22:42, Joe Forbes notifications@github.com<mailto:notifications@github.com> wrote:\nLooks like there are a lot of package-lock updates. When I removed and re-added your module to update/unlock I only noticed url-toolkit update (and karma-detect-browsers was removed). Could you update the module that way and overwrite this commit?\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHubhttps://github.com/videojs/videojs-contrib-hls/pull/1327#issuecomment-360912349, or mute the threadhttps://github.com/notifications/unsubscribe-auth/ADG-WVFIF8IYW96-prPknJfQ6VjZJM9Eks5tOkbggaJpZM4Ru0JO.\n. @forbesjo instead of tweaking package.json manually I ran npm install url-toolkit@^2.1.3 --save and the changes are actually slightly less now. thanks!. Ah it does break a test\nhttps://github.com/videojs/videojs-contrib-hls/blob/11987cc1cf987d1c17da86cc2e22f7a763b9174a/test/resolve-url.test.js#L14\nExpected: \"//a.com/b/cd/z.ts\"\nActual: \"http://a.com/b/cd/z.ts\"\nMaybe this is a problem, in which case just close this. The protocol will match the one that is the relative URL, or the base URL, or window.location.href\nOn 30 Jan 2018, at 00:18, Garrett Singer notifications@github.com<mailto:notifications@github.com> wrote:\nThanks for the PR @tjenkinsonhttps://github.com/tjenkinson !\nre: the broken test case. Will the protocol that URLToolkit returns be the same as the page?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHubhttps://github.com/videojs/videojs-contrib-hls/pull/1328#issuecomment-361421058, or mute the threadhttps://github.com/notifications/unsubscribe-auth/ADG-WY_exlT8KN3S9SUyB1grMuNvrnHcks5tPlHRgaJpZM4Ru9yd.\n. ",
    "alexyats": "\nI've sent you my proposal at upwork and after that I've digged a little bit more and solved your issue. You should store all the files from this repository to your web-server: https://github.com/videojs/videojs-contrib-hls/tree/master/src\nafter that, fix your html by including all the script files:\n``` html\n<!DOCTYPE html>\n\n\nHLS demo\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n m3u8 handling \n\n\n\n\n\n\n\n\n\n  var player1 = videojs('example-video-1');\n\n\n  var player2 = videojs('example-video-2');\n\n\n\n```\n. it is working ok now, but you should do one of two things:\n1) either start chrome with  --disable-web-security option (see screenshot attached)\n2) or enable CORS (cross-origin-resource-sharing) on your storage. It should add Access-Control-Allow-Origin: * for all your hls files, because your player is requesting the content from another domain than itself resides. \nit seems something is broken at upwork now but they promising to fix it soon.\nEDIT: forgot the chrome settings screenshot\n\n. glad to hear it was resolved. Could you please leave a review for me at upwork (Alexey Y)?\n. ",
    "jcapucla": "Hi alexyats-\nThanks for looking in to this; I didn't see any response on Upwork though. Can you verify/resend it?\nAlso, I've added those js files to a public folder on my server, and linked to them as you suggested. But the stream is still failing.  Please see the demo:  http://goo.gl/Ug6oMI\nI was also able to take a quick screenshot of an error message:\nHLS playlist request error at http://cdn.lsatengine.com/HLS3/HLSdemo/HLSdemo.m3u8\nYou can see it in the screenshot below:\n\n. Great. This was the problem. I had assumed that because my cdn and website were on the same domain, my XHR requests wouldn't need a CORS setup. I was mistaken: apparently all requests with different hosts or subdomains requires CORS.\n. Sure. No problem. I will contact you through upwork.\nOn Tue, Aug 18, 2015 at 10:40 PM, alexyats notifications@github.com wrote:\n\nglad to hear it was resolved. Could you please leave a review for me at\nupwork (Alexey Y)?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/videojs/videojs-contrib-hls/issues/364#issuecomment-132452719\n.\n. Hey Alexey- I contacted an \"Alexey Y\" on github, but it wasn't you. Please\nsend me a link to your user profile, and I will be happy to leave you a\npositive review.\n\nSend it to justin.capuano at gmail.com. And thanks again for the help.\nOn Tue, Aug 18, 2015 at 10:40 PM, alexyats notifications@github.com wrote:\n\nglad to hear it was resolved. Could you please leave a review for me at\nupwork (Alexey Y)?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/videojs/videojs-contrib-hls/issues/364#issuecomment-132452719\n.\n. \n",
    "luhaiyong": "hi , \nv0.3.1 (videojs-contrib-media-sources)\nv0.17.8 (videojs-contrib-hls )\nthe latest (video.js-master)\n. \n\n\nand i cant see the file videojs-hls.min.js,where is it?\n. could u tell me ,which version ,i can use ?\n. ",
    "dstieglitz": "+1 I'm also interested in obtaining pts values\n. ",
    "KorsaR-ZN": "@dmlap Yes. tomorrow I will fix\n. @dmlap Please help me fix tests\n. @ntadej Not\nNo. It's all right\nexample:\nvar line = \"#EXT\";\nconsole.log((line.indexOf(\"#EXT\") !== 0 && line.indexOf(\"#ZEN-\") !== 0)) // false\nconsole.log((line.indexOf(\"#EXT\") !== 0 || line.indexOf(\"#ZEN-\") !== 0)) // true\n. ",
    "norlin": "Is there any progress with it? Do you have MSE transition issue opened or someone just working on it?\nAnd btw what exactly need to do? :-)\n. That's ok, but when we have 2 (or more) ranges one by one? Say 0-60 & 60-120, and current time == 55. It will get 5 sec buffered time and will start to fetch next segment while it's already buffered.\n. @outlawtorn Thanks, but it seems doesn't help for me...\n. @outlawtorn Hmm, weird, for me it's still not working:\nScreenshot: http://norlin.guru/st/hls_bug_preload_1C46480D.png\n. @outlawtorn I know it's happening only with some files. But it's a bug with decoder, I guess, not with files.\n. ",
    "sjernigan": "+1 also eagerly awaiting 1.0.  Thanks for working on this and sharing the results.\n. ",
    "lardawge": "I am using development build and ran into an error in chrome. It seems that playback works but when trying to destroy the player it raises an error: Uncaught InvalidStateError: Failed to execute 'abort' on 'SourceBuffer': This SourceBuffer has been removed from the parent media source.\nI have no issues in Safari...\n. ",
    "Ivshti": "I like to mention dailymotion/hls.js here as it might be of some help\n. Cool, thank you @gkatsev \n. ",
    "DJaeger": "Still no release?\n. It's really bad to promote a release on the blog, which is much time after still not available...\n. @mgood: That's clear to me.\nBut the blog post for \"the official Video.js v5 release\" is telling \"[...] have reached some major milestones. videojs-contrib-hls 1.0 [...]\". (Has this text been changed? I think there was also a \"release\" mentioned)\nBut here is no release of version 1.0.\nThat shouldn't be...\n. @dmlap: So do I understand you correct, that VOD playback is mostly working and live playback is mostly NOT working?\nAre you able to tell me a approx. percentage of how much of VOD and live playback is working?\n. ",
    "mgood": "@DJaeger it sounds like there are still some playback bugs with the new version. This issue seems to be updated as they're making progress.\n. @DJaeger the official Video.js v5 release is out and available from the main site. This issue is just regarding this plugin providing additional HLS compatibility. This is a \"contrib\" module, which is a common term in open source projects for software that has been contributed by the community, but not an official part of the main software. It sounds like there are a few technical issues with updating this module for the new release, but the people you see commenting here are working on it.\n. This sounds like the issue described in #491. Unfortunately it doesn't look like there's a solution yet, but take a look at the discussion there.\n. ",
    "ChiliChili": "@Tralapo, which version you use from videojs-contrib-hls (videojs.hls.min.js) and videojs-media-sources.js? Im try fire up my page with HLS stream, but so far unsuccessfully. Im try  with video.js ver 4.x and 5.x and copy of your example, but it does not work.\nNavigated to http://ip:9802/vhls1.html\nvhls1.html:9 GET http://ip:9802/videojs-media-sources.js \nvhls1.html:10 GET http://ip:9802/videojs.hls.min.js \nvideo.min.js:19VIDEOJS: ERROR: (CODE:4 MEDIA_ERR_SRC_NOT_SUPPORTED) No compatible source was found for this video. i {code: 4, message: \"No compatible source was found for this video.\"}e @ video.min.js:19h.error @ video.min.js:19b.error @ video.min.js:15(anonymous function) @ video.min.js:15e @ video.min.js:19\nThe m3u8 link works fine with OS X/iOS or ip-tv devices\n. @Tralapo Ok, i use the latest videojs-contrib-hls (1.2.0), and videojs-contrib-media-sources (2.3.0), with video.js 5.1.0 and  the HLS stream (m3u8) still does not work.\nUncaught TypeError: videojs.Hls.PlaylistLoader is not a function videojs-hls.js:151\nThe line 151:\nthis.playlists = new videojs.Hls.PlaylistLoader(this.source_.src, this.options_.withCredentials);\n. >  We didn't include the full distribution in the 1.x releases in npm (sorry!)\n@dmlap Thanks a lot, it works!\n. Hi! How to generate m3u8 stream? Maybe with ffmpeg+rtmp+nginx?\n. I mean, unfortunately, this is not my experience. It was a similar problem, but nginx and ffmpeg solution and parameterization solved.\n. ",
    "aramazhari": "@dmlap I've tried this on an Android device in crosswalk browser and it doesn't work. The currentTime is simply ignored and always says 0. Even after the video starts playing it still isn't seekable. This may not be videojs but actually those particular devices with problems. The content within our m3u8 files are .ts extensions. \n. ",
    "mischizzle": "I'm currently looking at getting the plugin to reconnect after network disconnection. From this issue, I'm assuming this is in the pipeline, but not yet implemented? \nIf I get something working, I'll create a pull request\n. ",
    "novoxudonoser": "Sanks a lot for fast answer. You're right, I think cache headers will do the stuff.\n. the same fing is for\n```\nEXTM3U\nEXT-X-VERSION:3\nEXT-X-TARGETDURATION:3\nEXT-X-MEDIA-SEQUENCE:0,0\nEXT-X-ALLOW-CACHE:YES\nEXTINF:1,\n21:23:00_11.05.2013_to_21.23.11_11.05.2013/index0.ts\nEXTINF:1,\n21:23:00_11.05.2013_to_21.23.11_11.05.2013/index1.ts\nEXTINF:1,\n21:23:00_11.05.2013_to_21.23.11_11.05.2013/index2.ts\nEXTINF:1,\n21:23:00_11.05.2013_to_21.23.11_11.05.2013/index3.ts\nEXTINF:1,\n21:23:00_11.05.2013_to_21.23.11_11.05.2013/index4.ts\nEXTINF:1,\n21:23:00_11.05.2013_to_21.23.11_11.05.2013/index5.ts\nEXTINF:1,\n21:23:00_11.05.2013_to_21.23.11_11.05.2013/index6.ts\nEXTINF:1,\n21:23:00_11.05.2013_to_21.23.11_11.05.2013/index7.ts\nEXTINF:1,\n21:23:00_11.05.2013_to_21.23.11_11.05.2013/index8.ts\nEXTINF:1,\n21:23:00_11.05.2013_to_21.23.11_11.05.2013/index9.ts\nEXTINF:1,\n21:23:00_11.05.2013_to_21.23.11_11.05.2013/index10.ts\nEXTINF:1,\n21:23:14_11.05.2013_to_21.23.25_11.05.2013/index11.ts\nEXTINF:1,\n21:23:14_11.05.2013_to_21.23.25_11.05.2013/index12.ts\nEXTINF:1,\n21:23:14_11.05.2013_to_21.23.25_11.05.2013/index13.ts\nEXTINF:1,\n21:23:14_11.05.2013_to_21.23.25_11.05.2013/index14.ts\nEXTINF:1,\n21:23:14_11.05.2013_to_21.23.25_11.05.2013/index15.ts\nEXTINF:1,\n21:23:14_11.05.2013_to_21.23.25_11.05.2013/index16.ts\nEXTINF:1,\n21:23:14_11.05.2013_to_21.23.25_11.05.2013/index17.ts\nEXTINF:1,\n21:23:14_11.05.2013_to_21.23.25_11.05.2013/index18.ts\nEXTINF:1,\n21:23:14_11.05.2013_to_21.23.25_11.05.2013/index19.ts\nEXTINF:1,\n21:23:14_11.05.2013_to_21.23.25_11.05.2013/index20.ts\nEXTINF:1,\n21:23:14_11.05.2013_to_21.23.25_11.05.2013/index21.ts\nEXT-X-ENDLIST\n``\n```\n. @dmlap\n\ndo you see any errors in the developer console when this happens?\n\nNo.\n\nIf you look on the network tab, is the player requesting segments in the right order?\n\nAll in the right order.\n. ",
    "sutiwo": "@forbesjo \nI desire to use the videojs of hls tech and access to some of this functionality in Safari and Edge.\nCould you tell me when to complete?\n. @gesinger \ni'm very sorry.\nthat m3u8 domain has already moved.\nhere is new m3u8 URL.\nhttps://movie.freshlive.tv/manifest/1024/archive.m3u8\n. ",
    "aamelegy": "I'm also using hls.xhr.beforeRequest for securing the urls but it is not working in safari and android. Would be cool if I can override the native implementation. @gesinger I think it is no related only to safari. I'm trying to override the native HLS it is not working on Safari and on Android Chrome which also supports Native HLS. There is no errors generated in the console but still the native HLS is used. \nI'm using HLS stream that requires a secure token generated by the client to be sent with the manifest files or segments, but no way to do it without \"hls.xhr.beforeRequest\".\nI'm willing to contribute to fix the bug can you give me any pointer where to dig in the code ?. I'm using exactly those three lines in Safari.\nvideojs.options.hls.overrideNative = true;\nvideojs.options.html5.nativeAudioTracks = false;\nvideojs.options.html5.nativeVideoTracks = false;\nNo errors in the console however still the native HLS is used , Same behaviour in Android Chrome. ",
    "lunejy": "Interesting.. I tested it on Windows 8 and Windows 10 with the latest firefox, but it didn't work. What's your firefox version?\n. Thanks, I manually installed Flash from https://get.adobe.com/flashplayer/\nBut without manually installing the plugin, is it possible for Firefox to detect whether the flash plugin is not installed in the current browser, and display a message to install the plugin easily? I'm hosting a webpage and the most of users are not tech-savvy.\n. ",
    "Pablo76": "@dmlap regarding second segment: there is probably no issues with the segment (HLS spec would need to be consulted if something like that is allowed). Basically, it looks like entire original .ts was split into chunks on 188-byte boundary and without 1st segment other segments are useless. If you simply concatenate chunks then everything will play fine. You can also play the stream in VLC to confirm that in fact there is video data in second segment. flashls also plays this clip perfectly.\nThe reason ffmpeg cannot \"see\" video in second chunk is because sps+pps are only in the first segment. \n. Sorry for late reply. Just to make it clear: this stream has no key-frames, but at the same time it doesn't need them to play video or seek. According to HLS segments SHOULD have keframes and should be playable on their own, but should means that they don't have to :)\nSo, there are two separate issues: 1) keyframes, 2) decoder specific info, a.k.a. sps+pps.\nThis particular stream doesn't need keyframes, it has something equivalent. If you try to naively search for IDR-nal type you won't be able to handle the stream properly. Try to re-wrap stream using ffmpeg into mp4 (-vcodec copy, without re-encoding h264 bitstream), and you'll see that seeking works even tough it looks as if the stream doesn't have any keyframes: it has recovery points instead.\n2) decoder specific info... these are present in first segments only in this stream. So, if switch happens to alternative stream on 1+Nth segment and if there is no decoder specific info present before handling keyframe (or something equivalent) then hls-contrib should try to retrieve it from first segment in the stream, first segment of a stream must have decoder specific info available.\n. ok, regarding HLS and html5 playback. Is it supported by older release?\n. With latest release reported issue seems to be fixed. However, it seems that worse problems are there now.\nInstead of cycling the same clip I got it cycling on my playlist now, with minor \"bug\" in cycling algorithm: it restarts downloading hls segments from second one: http://i.imgur.com/ZS68ne2.png\nJust open this one: http://test.kolontsov.com/~/index-tv-v1.1.0.html without even trying to play you'll see the \"magic\" happening. Also, another unrelated issue: it doesn't play properly this particular clip: video will stop after first segment. Don't try to fix the issue, it might be complicated or to get it working with HTML5 (it works with flashls by the way). If you want to know what issue is: the video uses intra-frame refresh (no keyframes except first segment), sps/pss are in first segment only. If switch happens to different bitrate then first segment has to be checked for sps/pps. Not sure if that valid according to HLS spec, but it works in flashls.\nNote, to see previous release just load this one: http://test.kolontsov.com/~/index-tv-v1.0.1-0.html without even playing it will loop on the 3rd segment.\nanother issue: encrypted videos that used to play do not play anymore.\nCan you lease recommend what version of hls-contrib should be used for html5-hls?\nthanks\n. These segments use intra-frame refresh, which is effectively the same as key-frame, except that they do not have IDR nal_type. The other issue is that sps/pps are only at the beginning of each stream, and according to HLS spec, this is valid.\n. ",
    "ironweber": "@dmlap I'm wondering if there has been any updates on this? ... I am having a very similar issue. Though the segment with no keyframe plays in Firefox 48 but does not play in Chrome 52 (MacOS 10.11.6) I thought this might be a MSE issue but hls.js plays the stream fine in both Firefox and Chrome. The loadeddata event never fires and also when I go to chrome://media-internals/ there isn't anything there.\n. So I've been able to change qualities by just changing the source to one of the playlists on hls.playlists.master.playlists.\n```\nvar currentTime = player.currentTime();\nvar src = player.sources[level].src;\nplayer.src({\n  src: src,\n  type: 'application/x-mpegURL'\n});\nplayer.currentTime(currentTime);\nplayer.play();\n```\nTo switch back to auto I just reload the master.m3u8 playlist again. Probably not optimal but it gets the job done until manual level switching is actually implemented.\n. ",
    "thomaspeeters": "I've narrowed it down to the following line (using dash.debug.js instead of dash.all.js):\njavascript\n// dash.debug.js v1.5.1 line 1251\nif (undefined === btoa) {\n    var btoa = BASE64.encode;\n}\nLooks like dash.js implements its own base64 encoding into a globar var which conflicts with window.btoa in IE11.\nI'm not sure why dash.js does this, especially overriding the default implementation. Is something wrong with the default browser implementation? Does anyone know more? Why does this only fail in IE?\n. I believe it is. I forgot to mention here that I also opened an issue in the dash.js project (see: Dash-Industry-Forum/dash.js/issues/866) to address this. \nAt the time of writing there has been no response there and I don't know whether or not the btoa and atob declarations are safe to remove, though I suspect they are. There is still the possibility that additional, optional components I did not compile into my dash.js file make use of the declarations. An expert over at the dash.js project should be able to answer that question.\n. I'm closing this issue, it should be solved in the next release of dash.js. https://github.com/Dash-Industry-Forum/dash.js/issues/866\n. Can you try setting the MIME type to application/vnd.apple.mpegurl instead of application/x-mpegURL and reporting back if that solves the problem?\n. I have no experience with DVR streams, hopefully someone else can help you with that.\n. No problem. Thanks for finding the cause so quickly.. ",
    "jimkang": "OK, thanks for the clarification!\n. ",
    "tchakabam": "generally totally agree on the idea :+1: \n. we had this problem with 4K streams as they are just too big, and videojs only limits by buffer time duration, but not size.\ni have a fix here: https://github.com/videojs/videojs-contrib-hls/pull/1242\nwhere we track buffer occupation in bytes and limit loading accordingly. \nbut it hasn't been looked at by anyone at videojs unfortunately :(. Hey, \nThe problem is just that you are getting the options wrong. \nThis is how it should work like: \nvar player = videojs('example-video', {\n  html5: {  \n    nativeAudioTracks: false,\n    nativeVideoTracks: false,\n    hls: {\n      debug: true,\n      overrideNative: true\n    }\n}});\nNOTE that the hls options always are embedded inside the html5 tech options - this is the mistake in your above configuration.\nThis isn't a bug, I got this working flawlessly with the above snippet.\nEDIT: Your Safari still needs to support MediaSource obviously, which is from Yosemite and above as far as I remember.\nEDIT: Note that mobile Safari does never support MediaSource. Please check this test-page: http://tchakabam.com/test/2coders-videojs/\nIMPORTANT: You need to press the \"load\" button to make sure videojs-hls initializes correctly with the desired config (not using native Safari HLS precisely).\nThis behavior (needing to press load) is only on Safari, and it may be a bug that need to be investigated.\nHowever this example shows that generally the config can be applied to do this.\nWe should probably close/rewrite this issue to what it really is.. @BrandonOCasey @imbcmdth Hey :) This is about allow having multiple video tracks, for multi-view apps (so renditions not qualities!).\nThis is for multi-view applications where we live-stream from multiple cameras. So it is a really nice thing we think :)\nSo there are for example 4 cameras, so 4 video renditions, and each renditions has multiple quality levels, just as we know it, but times 4 :)\nWe are doing this with Wowza, which supports it, and it is also allowed by the HLS spec. So we think that this lib should support it, we hope you guys will collaborate to bring into the upstream branch so we dont need to do our stuff in a fork anymore :)\nI will set up some test content if you are interested. We probably should have some also for the test suite, which needs to be updated here obviously.\nFor better understanding, a playlist may look like this:\n```\nEXTM3U\nEXT-X-VERSION:3\nEXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"aac\",LANGUAGE=\"en\",NAME=\"English\",DEFAULT=YES,URI=\"chunklist_b192000_ao_slen_t64RW5nbGlzaA==.m3u8\"\nEXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"mobile\",NAME=\"Camera 1\",DEFAULT=YES,URI=\"chunklist_b500000_t64Q2FtZXJhIDE=.m3u8\"\nEXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"mobile\",NAME=\"Camera 2\",DEFAULT=NO,URI=\"chunklist_b500000_t64Q2FtZXJhIDI=.m3u8\"\nEXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"mobile\",NAME=\"Camera 3\",DEFAULT=NO,URI=\"chunklist_b500000_t64Q2FtZXJhIDM=.m3u8\"\nEXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"mobile\",NAME=\"Camera 4\",DEFAULT=NO,URI=\"chunklist_b500000_t64Q2FtZXJhIDQ=.m3u8\"\nEXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"low\",NAME=\"Camera 1\",DEFAULT=YES,URI=\"chunklist_b500000_t64Q2FtZXJhIDE=.m3u8\"\nEXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"low\",NAME=\"Camera 2\",DEFAULT=NO,URI=\"chunklist_b1000000_t64Q2FtZXJhIDI=.m3u8\"\nEXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"low\",NAME=\"Camera 3\",DEFAULT=NO,URI=\"chunklist_b1000000_t64Q2FtZXJhIDM=.m3u8\"\nEXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"low\",NAME=\"Camera 4\",DEFAULT=NO,URI=\"chunklist_b1000000_t64Q2FtZXJhIDQ=.m3u8\"\nEXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"medium\",NAME=\"Camera 1\",DEFAULT=YES,URI=\"chunklist_b2000000_t64Q2FtZXJhIDE=.m3u8\"\nEXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"medium\",NAME=\"Camera 2\",DEFAULT=NO,URI=\"chunklist_b2000000_t64Q2FtZXJhIDI=.m3u8\"\nEXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"medium\",NAME=\"Camera 3\",DEFAULT=NO,URI=\"chunklist_b2000000_t64Q2FtZXJhIDM=.m3u8\"\nEXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"medium\",NAME=\"Camera 4\",DEFAULT=NO,URI=\"chunklist_b2000000_t64Q2FtZXJhIDQ=.m3u8\"\nEXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"high\",NAME=\"Camera 1\",DEFAULT=YES,URI=\"chunklist_b4000000_t64Q2FtZXJhIDE=.m3u8\"\nEXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"high\",NAME=\"Camera 2\",DEFAULT=NO,URI=\"chunklist_b4000000_t64Q2FtZXJhIDI=.m3u8\"\nEXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"high\",NAME=\"Camera 3\",DEFAULT=NO,URI=\"chunklist_b4000000_t64Q2FtZXJhIDM=.m3u8\"\nEXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"high\",NAME=\"Camera 4\",DEFAULT=NO,URI=\"chunklist_b4000000_t64Q2FtZXJhIDQ=.m3u8\"\nEXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"hd\",NAME=\"Camera 1\",DEFAULT=YES,URI=\"chunklist_b7500000_t64Q2FtZXJhIDE=.m3u8\"\nEXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"hd\",NAME=\"Camera 2\",DEFAULT=NO,URI=\"chunklist_b7500000_t64Q2FtZXJhIDI=.m3u8\"\nEXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"hd\",NAME=\"Camera 3\",DEFAULT=NO,URI=\"chunklist_b7500000_t64Q2FtZXJhIDM=.m3u8\"\nEXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"hd\",NAME=\"Camera 4\",DEFAULT=NO,URI=\"chunklist_b7500000_t64Q2FtZXJhIDQ=.m3u8\"\nEXT-X-STREAM-INF:BANDWIDTH=500000,NAME=\"Camera 1\",CODECS=\"avc1.66.30,mp4a.40.2\",RESOLUTION=512x288,AUDIO=\"aac\",VIDEO=\"mobile\"\nchunklist_b500000_t64Q2FtZXJhIDE=.m3u8\nEXT-X-STREAM-INF:BANDWIDTH=1000000,NAME=\"Camera 1\",CODECS=\"avc1.77.32,mp4a.40.2\",RESOLUTION=640x360,AUDIO=\"aac\",VIDEO=\"low\"\nchunklist_b1000000_t64Q2FtZXJhIDE=.m3u8\nEXT-X-STREAM-INF:BANDWIDTH=2000000,NAME=\"Camera 1\",CODECS=\"avc1.77.41,mp4a.40.2\",RESOLUTION=848x480,AUDIO=\"aac\",VIDEO=\"medium\"\nchunklist_b2000000_t64Q2FtZXJhIDE=.m3u8\nEXT-X-STREAM-INF:BANDWIDTH=4000000,NAME=\"Camera 1\",CODECS=\"avc1.100.41,mp4a.40.2\",RESOLUTION=1280x720,AUDIO=\"aac\",VIDEO=\"high\"\nchunklist_b4000000_t64Q2FtZXJhIDE=.m3u8\nEXT-X-STREAM-INF:BANDWIDTH=7500000,NAME=\"Camera 1\",CODECS=\"avc1.100.40,mp4a.40.2\",RESOLUTION=1920x1080,AUDIO=\"aac\",VIDEO=\"hd\"\nchunklist_b7500000_t64Q2FtZXJhIDE=.m3u8\n```. @gesinger Hey thank you very much for your answer! We would really love to continue using the Videojs HLS library as it proved to support well a couple of things we needed, and adding the Alternate Video feature was easy enough :) So would be great to get this in so we can keep the benefits on all sides.\nWe are currently setting up some test content (we can not share the content of our direct customers).\nWe are going to put this on a spoofed CDN name and then we can share it here :) . @gesinger \nHere is the test content. I have made a commit which replaces the test URL \n (we will revert that later). with our multi-video-track test stream, which you find here: http://13.81.114.0:1935/vod/smil:playlist.smil/playlist.m3u8\nThat should make it very easy for you to test, just git-checkout this branch head.\nThen you may use the player object in window like this to switch tracks from console:\nplayer.hls.enableVideoTrack(0..2)\nand\nplayer.hls.enableAudioTrack(0..2)\nWith the respective track index you want. Each video track has 3 quality variants :) Any combination is possible (just like for audio and text).\nThis content is Bigbuckbunny, TOS and Sintel on one stream (cropped to the length of BBB).\nThere are also the three respective audio tracks of course.\nLet us know how this works for you. We think it's a pretty promising feature.\nRemaining TODOs may be:\n\n\nFigure out if automatic and manual ABR switching will still work in all cases (it should not jump back to the initial video track..).\n\n\nWe need an options parameter to set the initial video track to start with. We also think this should exists for audio. As the bandwidth overhead of loading the \"wrong\" one is high and can double join time.\n\n\nWe need to write some tests obviously.\n\n\nThe resulting M3u8 looks like this:\n```\nEXTM3U\nEXT-X-VERSION:3\nEXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"aac\",LANGUAGE=\"en1\",NAME=\"English Big Buck Bunny\",DEFAULT=YES,URI=\"chunklist_w991032164_b192000_ao_slen1_t64RW5nbGlzaCBCaWcgQnVjayBCdW5ueQ==.m3u8\"\nEXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"aac\",LANGUAGE=\"en2\",NAME=\"English Sintel\",DEFAULT=NO,URI=\"chunklist_w991032164_b192000_ao_slen2_t64RW5nbGlzaCBTaW50ZWw=.m3u8\"\nEXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"aac\",LANGUAGE=\"en3\",NAME=\"English Tears of Steal\",DEFAULT=NO,URI=\"chunklist_w991032164_b192000_ao_slen3_t64RW5nbGlzaCBUZWFycyBvZiBTdGVhbA==.m3u8\"\nEXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"low\",NAME=\"Big Buck Bunny\",DEFAULT=YES,URI=\"chunklist_w991032164_b1500000_t64QmlnIEJ1Y2sgQnVubnk=.m3u8\"\nEXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"low\",NAME=\"Sintel\",DEFAULT=NO,URI=\"chunklist_w991032164_b1500000_t64U2ludGVs.m3u8\"\nEXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"low\",NAME=\"Tears of Steal\",DEFAULT=NO,URI=\"chunklist_w991032164_b1500000_t64VGVhcnMgb2YgU3RlYWw=.m3u8\"\nEXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"high\",NAME=\"Big Buck Bunny\",DEFAULT=NO,URI=\"chunklist_w991032164_b3000000_t64QmlnIEJ1Y2sgQnVubnk=.m3u8\"\nEXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"high\",NAME=\"Sintel\",DEFAULT=NO,URI=\"chunklist_w991032164_b3000000_t64U2ludGVs.m3u8\"\nEXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"high\",NAME=\"Tears of Steal\",DEFAULT=NO,URI=\"chunklist_w991032164_b3000000_t64VGVhcnMgb2YgU3RlYWw=.m3u8\"\nEXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"hd\",NAME=\"Big Buck Bunny\",DEFAULT=NO,URI=\"chunklist_w991032164_b5000000_t64QmlnIEJ1Y2sgQnVubnk=.m3u8\"\nEXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"hd\",NAME=\"Sintel\",DEFAULT=NO,URI=\"chunklist_w991032164_b5000000_t64U2ludGVs.m3u8\"\nEXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"hd\",NAME=\"Tears of Steal\",DEFAULT=NO,URI=\"chunklist_w991032164_b5000000_t64VGVhcnMgb2YgU3RlYWw=.m3u8\"\nEXT-X-STREAM-INF:BANDWIDTH=1500000,NAME=\"Big Buck Bunny\",CODECS=\"avc1.100.40,mp4a.40.2\",RESOLUTION=640x360,AUDIO=\"aac\",VIDEO=\"low\"\nchunklist_w991032164_b1500000_t64QmlnIEJ1Y2sgQnVubnk=.m3u8\nEXT-X-STREAM-INF:BANDWIDTH=3000000,NAME=\"Big Buck Bunny\",CODECS=\"avc1.100.40,mp4a.40.2\",RESOLUTION=1280x720,AUDIO=\"aac\",VIDEO=\"high\"\nchunklist_w991032164_b3000000_t64QmlnIEJ1Y2sgQnVubnk=.m3u8\nEXT-X-STREAM-INF:BANDWIDTH=5000000,NAME=\"Big Buck Bunny\",CODECS=\"avc1.100.40,mp4a.40.2\",RESOLUTION=1920x1080,AUDIO=\"aac\",VIDEO=\"hd\"\nchunklist_w991032164_b5000000_t64QmlnIEJ1Y2sgQnVubnk=.m3u8\n```\n. Concerning the multiple audio tracks, there seems to be a problem with the 2nd and 3rd.\nWe'll look at fixing that. Because of course we need to make sure there is no regression on the audio-track switching feature coming with this. Meanwhile, we can also test with content that has multiple audio tracks still to see if that still works :). @gesinger Hey, well in that case I have built a feature without knowing part of the feature already exists hahaha :D \nSo now I have taken a look at the segment-metadata solution. For our needs it does what we want actually for now :) \nBut it is a bit unhandy to resolve the actual media attributes or quality-levels properties based on the m3u8 URL. but i do understand you can not put living objects into the text-track :)\nbut why not copy in the playlist attributes?\nEDIT: we would also like to have effective bitrate of segments, so for each segment-metadata cue object we'd like to add the byte-range / size. currently one only has the URI (which is not a unique identifier of the segment when using byte-ranges in playlist).\nmaybe we could add these fields so to improve that feature in this PR as well?\nAbout the smooth quality switching: We are coordinating several Videojs HLS instances on the same page, and telling them to switch around qualities from an external controller.\nTherefore we are doing \"manual\" switching based on representations API (or via the qualityLevels plugin, which eventually used Representations).\nSo when doing that and it doing always \"fast\" switching, it turns out to actually waste bandwidth a lot because it will flush buffers already loaded, i.e overwrite and load from an earlier point to be \"fast\".\nWe dont want to be \"fast\" we just want to maintain safe buffer levels :) \nI think even for manual switching it should be left to user choice if the switch is \"flushing\" or not. Even totally unrelated to our \"special\" use-case which requires us to have that in order to implement a multi-player coordinating switching behavior basically.\nOf course we could build a PlaylistSelector that takes the \"orders\" from outside, but it seems like the Representations API should just also allow to choose about this smooth vs fast choice as well, right?. @eightHundreds i don't think so. that would be against the standard. the player is supposed to behave depending on what the playlist advertises.\nyou should figure out how to generate a proper live playlist if your content is live. so it will also work with any player without any special settings :). Note: this is already contained in https://github.com/videojs/videojs-contrib-hls/pull/1199 but I'll remove it from there, as it will be more consumable to ship things bit by bit per scope :) . sure, will do :+1: . https://github.com/videojs/videojs-contrib-hls#segment-metadata. oops, haven't looked into this since a while. yeah sure we can do that! will keep you posted about it.. this now also includes the fix from: https://github.com/videojs/videojs-contrib-hls/pull/1207. Hey, thanks for the review!\nAnd yes @squarebracket is right, if we combine both contributions, no need anymore for the rough estimation with the /3.\nI hope I can progress on both of these this week! Thanks for the patience ;). @squarebracket Hey, thanks for the update on this.\nThese days I've got quite some new things on my plate, and unfortunately wont get to work on this one here anytime soon.\nSo please go on with that proposed solution :) Sounds very good to me :+1: \nAdapting the buffer limit dynamically is definitely favorable, \nand even more favoreable to leverage the contrib-media-sources layer to handle this stuff, as it will be a common concern for any user of the API :)  \nFeel free to continue or close this here as you see fit!. Some tests need to be adapted, since the behavior of SourceUpdater changes concerning creation of SourceBuffer.\nThis fix isn't nice, but it's a workaround for a very real issue (which may also be browser-related).\nIt happens very reproducibly when the media segments are cached, and thus there seems to be a very short period of time after creation of the MediaSource where calls to addSourceBuffer will lead to fatal errors.\nHls.js always has a few more ticks between creating MediaSource and adding buffers, which is maybe why we never have observed the issue there.\nI am actually not exactly sure if the issue also happens when the call to addSourceBuffer happens from the sourceopen event dispatcher.\nWhat I am sure is that most of the cases I've seen were when the MediaSource was advertising open ready-state, and thus no event-handler was attached and creation was attempted immediatly (and then failed).\nHope this may help to understand better what's going on.\n. Just another thought: This seems to happen actually only when we need to create several SourceBuffer objects. This leads me to the doubt wether somehow browsers implementations have introduced an intermediate state just after creation of SourceBuffers where we need to wait before the next call to addSourceBuffer. Maybe we need to check updating property, wait for an updateend event? Just checked the spec again, it's not mentioning any of that or giving any clues about repeated calls to addSourceBuffer, see https://developer.mozilla.org/en-US/docs/Web/API/MediaSource/addSourceBuffer. @gesinger Yes totally agree about that. I'd also want the fix/solution to be robust against anything, and for that we need to do it as you describe.. should we not rather fix the fact that attributes may be undefined? it could be initialized to {} by default?\nsure, we can go for dot notation :)\nand how about we just add attributes as such property to the cue data? that way the user has all the info, no need to make this here a replication of the semantic that is already in attributes with lots of checks and so on. Because the attributes themselves may not be present in some playlists. It's just about making available all the info we have I guess :)\n. running this immediately (zero timeout) doesn't fix the issue. \nwe have experienced that this type of \"delay\" allows for a reliable behavior.\nthat proves this is a pretty \"fuzzy\" issue in the lower layers imho.. ",
    "aronallen": "Sounds great you have similar ideas, I really think this whole streaming thing is a mess right now, too many formats, protocols, and implementations, add the diversity of content decryption modules and you are deep down a rabbit hole. If we could somewhat limit this Cambrian explosion by aligning projects it could be great. The guys at Canal Plus are also working on some cool DASH technology, built on top of reactive extensions, a reactive approach seems to be more sane in the highly dangerous and asynchronous world of adaptive streaming, but developers are in general less familiar to reactive approaches, I am myself only getting familiar with it, my dream is to build a rx based HLS player, and a well tested mux.js would ease my efforts.\nIt could be cool to develop some small AI that was specialized in parsing m3u8 manifests, there are so many slight variations in them, the variations are often obvious to humans, but a regular parser seems to very sensitive. I am no AI expert, but I imagine it should be possible to make something work, in the space of HLS manifests.\nIn addition, I would like to know how to make my tech a propper plugin like this one. it seems in videojs 5 a lot of objects are private and I can't figure out how to hook into them dynamically, also I don't quite know the difference between a component and a tech, if someone had the time to answer my questions on gitter, I would be very grateful, and I could release the plugin independently, instead of forking videojs. \n. ",
    "zuzzurro": "I see you mention support for CEA-608 captions as a feature you have as opposed to hls.js. I am trying the player with a captioned stream but I see nothing showing up. Is the support really there?\n. I would love to try it. Don't you have a demo page where I can easily load and test my videos? Flashls demo pages are very convenient in this respect.\n. I have two videos, coming from two different encoder brands. Flashls is able to decode the captions fine in one video while can't decode the other ones. I'm pretty sure the files are ok as both VLC and jwplayer show the caption tracks. I would love to compare your demux implementation in order to see its behavior.\n. ",
    "jimmywarting": "Bump, updates?. ",
    "ogzpub": "I just realized this is actually code from videojs-contrib-media-sources that's throwing the error. However it's only when I update my snapshot of this project that the issue occurs. If I rollback to my version of videojs-contrib-hls to the 12th it works with both the media-sources from the 12th and the most recent version.\n. Every stream I've tried from a wowza server has done it. Here's one from their demo page that I confirmed does as well.\nhttp://184.72.239.149/vod/smil:bigbuckbunnyiphone.smil/playlist.m3u8\n. I have some good news. Updating to videojs-media-sources 2.4.1 fixed the issue. I almost didn't notice though as I didn't realize videojs-contrib-hls was bundling it's own copy and overriding mine. Is that intentional?\n. I've been using something similar to that for RTMP as well with good success. I believe they said once they weren't going to fix RTMP since it wasn't the focus of the project and the fix works well enough. So I'm ok with continuing to use that for RTMP.\nWith HLS I imagine I'll probably end up coding a similar workaround for now but I think it would be nice to have it work out of the box instead if possible since it is the project's focus time time.\n. @dmlap That's the issue exactly. Glad to hear it's in the works. \n@Tralapo Reloading the source should solve your issue for now. Something like this. \nplayer.on(\"pause\", function () {\n  player.one(\"play\", function () {\n    if (player.techName_.toLowerCase() == 'flash') {\n      player.load();\n      player.play();\n    } else if (player.techName_.toLowerCase() == 'html5') {\n      player.src(sources);\n      player.play();\n    }      \n  });\n});\nI don't know if there's a better way to determine the current tech type I just did this real quick since it will go away soon anyway once a true fix is available.\n. @Tralapo That's odd, it does work for my particular setup. What happens when it tries to resume? I should have clarified that you would need to replace \"sources\" in the player.src(sources) line with your source data. In my case sources contains an array such as the one below.\nvar sources = [\n  { type: \"video/mp4\", src: \"http://www.example.com/path/to/video.mp4\" },\n  { type: \"video/webm\", src: \"http://www.example.com/path/to/video.webm\" },\n  { type: \"video/ogg\", src: \"http://www.example.com/path/to/video.ogv\" }\n];\n. @dmlap It does indeed have the codec attribute.\nCODECS=\"avc1.66.31\"\nThese particular files were created with Adobe's Flash Media Live Encoder by just unchecking the audio source.\n. ",
    "thomasmattheussen": "This had something to do with ffmpeg segment settings...\n. ",
    "KatrinaE": "Sure, I can take a look.\n. Is there a build of videojs-contrib-hls that works with 5.x?\n. Ahh, sorry. Just reread your comment. My apologies.\n. @forbesjo yes, this was just on Win 10 - I did not test on Win 8.\n. Are you referring to the this.lastSegmentLoaded_ === this.playlistUriToUrl(segment.uri) check on line 857? I had updated that comparison to look at the entire segment, but per your comment here it sounds like that won't work. Is there some other way we can uniquely identify segments there? The quick and dirty option would be checking both URI and byterange as part of that if statement, but I'm not sure if that's up to your standards.\nI've been away for a bit but have some bandwidth now to fix this up. Would you be okay with a quick fix like the one I suggest? Would you prefer a different type of identifier? Or is this not worth tackling right now?\nI think this is the only other place in the file where we use lastSegemntLoaded_. If we can take care of this, it should be ready to go. Let me know what I can do to help.\n. I've added the byterange comparison, merged the development branch and @tenacex's changes (thanks for adding them!), and pushed them to my fork. I can't update this PR since I don't have push access to @tenacex's fork. Should I create (yet another) one?\n. Right, didn't know if you guys had a preference.\n. If not I will just PR to @tenacex to keep things cleaner.\n. ",
    "thebeachtoday": "In case anyone else has this issue, here is clarity on the root cause and work-around.\nRequirement: Seamlessly transition between video files [e.g. mp4] and live streaming [i.e. m3u8] using JQuery\nIssue: videojs.dev.js included initializes the player as  for video files and ... for live streaming.  This means if the first video initialized is streaming, then the user selects to play a movie, the JQuery call to a  element does not exist, thus fails.  Similarly, if a video file is called first, then a live stream is requested, an error of \"incompatible type\" appears since the  element [and its related technical parts] is not available\nWork Around:  Create two players in the index.php file [i.e. before videojs is initialized].  Make sure to place a \"holder\" file in the  tag for each if an initial file is not available.  For example, on my site, www.johnspass.tv, a database-driven file appears as the main file on the index.php page.  This could be a video or live stream.  If the main file is a video, we create \n<video ...><source src = \"/path/to/real/file.mp4\" type = \"video/mp4\"></video>  \n<video ...><source src = \"holder.m3u8\" type = \"application/x-mpegURL\"></video>.\nIf the main file is live stream, we create \n<video ...><source src = \"holder.mp4\" type = \"video/mp4\"></video> \n<video ...><source src = \"/path/to/real/file.m3u8\" type = \"application/x-mpegURL\"></video> .\nNow all subsequent JQuery calls will properly play in the correct player. \nNOTE:  Updates will be finished by 28-NOV-2015.  If you're reading this on Thanksgiving Day or the day after Thanksgiving, all changes may not be in effect on www.johnspass.tv.  Also feel free to contact me directly if you have any questions - it's a bit of a mess, but it is working.  \nGood luck all!\n. @gesinger --- after a lot of issues, I found a root cause with a very specific setup that might help others.\nFunctional Issue: same as this: cannot play on Chrome, FF; same errors.  Will play on IE, IOS\nSetup:  Stream from Raspberry Pi [i.e. Raspivid] piped to FFMPEG out to FLV to NGINX RTMP Module.  That is then creating the m3u8 and ts files for VideoJS [latest release, basic settings]\nTechnical Root Cause: hls_fragment_size, hls_playlist.  Fragment size was too small [was 500ms]; Playlist was too short [was 10s].   Now using the NGINX RTMP defaults [i.e. I just commented out the values from the nginx.conf file], and it works fine on all browsers.  It is choppy, but it works and is a place to start now.\nBottom line: nginx rtmp module settings in nginx.conf can cause weird errors and allow the stream to play just fine on certain platforms and not others.  With so many moving parts, hopefully this gives someone an idea how they might troubleshoot their issue that isn't obvious from the server log files or client error messages.  \nThanks for all the help; your support and everyone else saves me a ton of time [and money]!. ",
    "lime-green": "@dmlap I get the same exception. The video stops indefinitely after about 10 seconds (still shows as unpaused but it is not playing the content), but the XHR requests are still being made. Switching all the way back to version 1.2.1 solved the issue though. \n. ",
    "billybobilly": "Having same problem.  The code in videojs.hls.js looks like it is erroring when you try to set the start and stop of the seekable range to 0 and 0 but the buffer length (duration) is not Infinity.  \nIs it possible that the error is thrown when the player initially trys to load a left-over segment from a previous live stream of the same name?\nWe stream live with a particular hash in the file name.  That name gets reused the next time we stream the same event.  When the player first loads, it will load the last segments of the previous live stream (only now as VOD) until the new live stream is available.  \nWe wait until the live stream has actually started before calling play().  The problem for us is that this exception is preventing me from calling play() when the live stream is in fact ready and duration == Inifinty.  Play() has no effect at that poiint.\n. We don't have any problems with stuttering playback after rolling back to the previous version.  Is it possible that your segment length and/or number of segments are causing it for you?\n. video.js version 5.3.0\nvidoejs.hls.min.js version 1.2.2\n. I wish I was a better js coder so I could look into it -  but I'm not.  \nIt seems like a good place to start looking would be if there are any places in the code where it treats or sees an Android client differently than a web client?.  My experience with the newest version is that it works on Android but fails on web.\n. Just confirmed issue with 1.3.7 using 5.3\n. @mikeevstropov   I tried the newest build last week and had the same problem as you when source is a VOD.  The LIVE stream is now working like @Tralapo says, but when I switch the source of the encoder to a VOD file, I get the same result as @raj2569\nAny new work on this problem?\n. From what I can tell, dailymotion doesn't use videojs so the plug-ins I'm using from the videojs project won't work there. \n. If you press stop/pause on the stream and then start it again after it stops getting the ts files, then it will start back up.    the videojs console note said  it attempted to seek to a spot but it was too soon, seeked to a later spot and started streaming again.\n. Finally have it all working.  Using latest video.js, videojs-hls.js, .css, etc.    \nThe live from capture card and 'live' from vod are both playing without freezing.  The vod problem turned out to be a parameter in the ffmpeg encoder where we had -c copy in the command.  removed that and everything is fine.  \nUnless someone else has a continuing problem, I think this issue can be closed.\n. Unfortunately, we are seeing that the live works now, but the problem has now moved to when you use a VOD as the source of an encode.\nhttps://github.com/videojs/videojs-contrib-hls/issues/483\n. related?  #650 \n. related?   #650 \n. We don't do any non-live, so no.  I can turn on a live stream when you need it.  How can we set up a time?    Can we PM off the list so I can give you the live URL and coordinate?\n. I haven't solved it, but have worked around it by altering a few settings\non the encoder to limit how fast it encodes, adding to the number of\nsegments per manifest, and changing the buffer time in\nvideojs-contrib-hls.js to 60 seconds.  I left everything else\nin videojs-contrib-hls.js alone. I've played the same stream on other\nplayers an never been able to duplicate the problem.\nSo what I've found is that if the encoder delivers segments any faster than\nabout 1.2x the fps rate of playback, the buffering mechanism on the player\ncan't keep up and eventually skips a .ts segment which causes it to set the\nduration of that segment to the last known total length and then calls that\nsegment  'end'.  At that point the buffer plays out and no more .ts files\nare downloaded.  For example, if my encoder is encoding at a pace of 50 fps\nand the target frame rate of the output .ts files is 29.97 fps, then it is\ndelivering .ts files at about 1.66 times faster than the player will\nconsume them.\nI believe what's happening is that while the player is emptying it's buffer\nto hit it's target buffer of 30 seconds, it takes too long and the manifest\nno longer has the next .ts in the list.  That must cause the player to\nloose it's place and quit. This is just a guess since I don't really know\nhow videojs-contrib-hls.js triggers its downloads.\nThat's why a combination of forcing the encoder to take it's time encoding\nframes, adding to the number of .ts files there are in the manifest, and\nmaking the videojs-contrib-hls.js buffer 60 seconds allows it to keep\ngoing.\nUnfortunately, it's not very easy to tune the encoder to hit a target of\n1.2x the output framerate so I either encode too slowly and the playback\nstutters waiting for the next segment, or I go too fast and overrun the\nbuffer and crash it.\nI hope this helps.  I'm not a good .js programmer so I'm afraid I'm not\nmuch help.  If you still want a stream to test with, I can schedule some\nlive streams for you over several hours one day if you tell me when you can\nlook at them.\nBill\nOn Fri, Apr 15, 2016 at 10:59 AM, David LaPalomento \nnotifications@github.com wrote:\n\nHard to say from your description. Have you ever seen this behavior with\nnon-live content? Any chance you have an example stream we can look at?\n\u2014\nYou are receiving this because you commented.\nReply to this email directly or view it on GitHub\nhttps://github.com/videojs/videojs-contrib-hls/issues/625#issuecomment-210494435\n. In the end, it turned out to be a problem with encoding.  In ffmpeg, using the -re flag in the command forces ffmpeg to encode at the sources' frame rate.  For example: \" /usr/local/bin/ffmpeg -re -loglevel info . . . \"\n\nIt makes sense.  You can't push more into the player than it can playback in the given time.  Eventually the buffer will overrun.\nWe didn't see it with live streams because a live source can't create more than a real time stream.  We only saw the problem with a pre-recorded file.  In the case of the file, ffmpeg without the extra -re flag will encode it as fast as it can and results in ffmpeg output at sometimes more than double the framerate as the playback.  Clearly, if the player can't play out everything the encoder is sending in the given buffer size, it will overrun.  The buffering can compensate for momentary surges or gaps, but not a long term net positive.\nHope this helps.\n. I can confirm that our final fix of adding the -re flag to ffmpeg, telling it to encode at the source video frame  rate resolved the buffer overrun. So, it was on the encoder side. This was for VOD.  Live encoding was not affected because it can only be encoded at it's original frame rate and ffmpeg can't get ahead of it. \nThe way we identified that it was a buffer overrun in the first place was by adding a couple of debugging console.log() lines to the buffering section of video.js to watch the size of the buffer, what the m3u8 file list  contained, and see when it was asking for more .ts files.  That's where we saw it get behind the m3u8 list and then crash - presumably because it couldn't 'skip' a whole chunk and go to the next one.\nIf adding to the buffer size delays the crash for you, then I'd have to guess that it's a buffer overrun like we were having.  I haven't used Elemental encoders, so I can't help there.\n. related? #650 \n. Appears that when the buffer is full for a while before needing to request the next segment, it will skip to the following segment (skipping one) and that's when the spiral downward to eventual -1 index begins.\nSo, for example, segment blabla-11.ts downloads successfully.  and then the buffer is full so it waits until the buffer has depleted enough to get another segment, but by this time, the first segment  (position 0) in the m2u8 file is no longer blabla-12.ts, it is now blabla-13.ts.  \nI have confirmed this is consistently the case by increasing the buffer to 60 seconds from 30 and also changing my segment sizes from 10 to 20 seconds.  It always follows the same pattern.\n. Instead of an error in handling the buffer, it might be an error in reading the manifest.\nIt seems to be misreading the duration of a segment.  See the following details:\n---- when it gets to segment 15, it erroneously finds it to be 160.xxx seconds long.  Which could throw off setting the mediaIndex I'm pretty sure.\nvideojs-contrib-hls.js:11136 new mediaIndex: 0\nvideojs-contrib-hls.js:11137 currentTime: 97.743855\nvideojs-contrib-hls.js:11139 buffered time if mediaInex === 'undefined': 37.391277\nvideojs-contrib-hls.js:11160 downloaded segment: {\"duration\":160.760754,\"uri\":\"14bfa6bb14875e45bba028a21ed38046_20160411162221_0015.ts\",\"end\":160.760754}\n----- But in the manifest, it shows the correct segment duration of 4.83 . . . seconds\nEXTM3U\nEXT-X-VERSION:3\nEXT-X-ALLOW-CACHE:NO\nEXT-X-TARGETDURATION:16\nEXT-X-PROGRAM-DATE-TIME:Mon Apr 11 16:24:28 2016\nEXT-X-MEDIA-SEQUENCE:15\nEXTINF:4.838167,\n14bfa6bb14875e45bba028a21ed38046_20160411162221_0015.ts\nEXTINF:15.281956,\n14bfa6bb14875e45bba028a21ed38046_20160411162221_0016.ts\nEXTINF:4.371033,\n14bfa6bb14875e45bba028a21ed38046_20160411162221_0017.ts\n----- and even on the file system, the file is the correct size for its length\n-rw-r--r-- 1 www-data www-data 567196 Apr 11 16:24 14bfa6bb14875e45bba028a21ed38046_20160411162221_0015.ts\n. if you have a short segment list (eg: 3 segments of 10 seconds), then when the buffer is full, there is the possibility of waiting too long and therefore missing the target segment.  When that happens, it looks like it sets the segment duration to the end duration and that seems to break it, causing the mediaIndex to be set to -1 so nothing else happens.\n. Turned out to be an encoding problem.  Neglected to use -re on the input stream of the ffmpeg command.  Therefore, ffmpeg was encoding at a faster rate than the original source material, causing a buffer overrun in videojs.  I guess I'm just not very sharp :-)\n. ",
    "amkgo": "I get this error just one time whenever I refresh the page.(videojs-contrib-hls ver 1.3.7 / videojs ver 5.6)\nI use only a video tag in the body:\n<video id=\"example\" class=\"video-js vjs-default-skin\" controls preload=\"none\" width=\"640\" height=\"360\" data-setup=\"{}\">\n    <source src=\"http://192.168.1.12/hls/test.m3u8\" type=\"application/x-mpegURL\">\n  </video>\n. ",
    "howieye": "The newest videojs-contrib-hls\n- @version 3.1.0\n  Found this error too.\n. ",
    "adam187": "Still issue at  3.5.0\n. I have same issue, but apparently it works when autoplay option is enabled, then stream starts without this error. \n@alexey2baranov @kudoz83 can you confirm?\n. From what i debugged so for https://github.com/videojs/videojs-contrib-hls/blob/master/src/videojs-contrib-hls.js#L507-L508 setting source here should trigger sourceopen event and change readyState to open but apparently it doesn't  https://w3c.github.io/media-source/#h-mediasource-attach\nSimilar issues:\nhttps://github.com/dailymotion/hls.js/issues/109\nhttps://github.com/videojs/videojs-contrib-hls/issues/460\n. ",
    "WoZ": "See the same error on 3.5.3. I have some extra info about percentage of errors in different browsers.\n97% of errors were received from Opera 39+ (up to 42) on Windows 7, 8.1 and 10, OS X, other 1.5% from Vivaldi browser and the last 1.5% from Chromium and Chrome.\nI think it's common problem on Opera. \n. ",
    "jvquarck": "Adding this check also in the seeking function (setCurrentTime).\n. @dmlap Yes, my bad. Do you prefer I create a new PR or anything else?\n. ",
    "hejinqiao": "@dmlap hi, but it says player.seekable.end(0) is not a function? I am pretty new to this stuff, i will really appreciate if you would like to guide me more specifically. Thank you very much!\n. ",
    "many74": "@dmlap Hmm, The URL works for me. Anyway the URL.s to the ts files are as follows . The file only has one rendition. \nhttp://stream.demo.bvod.tv/i/,60s.mp4,.csmil/segment1_0_av.ts\nhttp://stream.demo.bvod.tv/i/,60s.mp4,.csmil/segment2_0_av.ts\nhttp://stream.demo.bvod.tv/i/,60s.mp4,.csmil/segment3_0_av.ts\netc\nCan you access them or do you want me to upload the ts files somewhere?\n. @dmlap Seems to be some weird dns problems. Test this one instead\nhttp://bvoddemo-vh.akamaihd.net/i/,60s.mp4,.csmil/master.m3u8\nI will try to find a place to put the ts files\n. If the above dont work you should be able to download first 10 segements via \nhttp://segements.s3-website-eu-west-1.amazonaws.com/segment1_0_av.ts\nhttp://segements.s3-website-eu-west-1.amazonaws.com/segment2_0_av.ts\nhttp://segements.s3-website-eu-west-1.amazonaws.com/segment3_0_av.ts\n..\n. ",
    "khueue": "On behalf of many74, no, not really. Our workaround will probably be to re-encode the videos that cause this behavior (with keyframes configured properly).\n. ",
    "outlawtorn": "I have the same problem. The temporary fix is to set the preload to \"none\" and set controls to true.\n. hi @norlin in your jsbin i edited the video tag to \n< video id=example-video width=600 height=300 class=\"video-js vjs-default-skin\" controls preload=none>\nand it works.\n. I think there is some problems in the encoded source file.\nTry this source http://solutions.brightcove.com/jwhisenant/hls/apple/bipbop/bipbopall.m3u8.\n. ",
    "huangyg11": "+1. I am using version 1.3.7\n\n. ",
    "ehsan89": "+1\n. +1\n. ",
    "halibegic": "+1\n. +1\n. I'm end up using https://github.com/streamroot/videojs5-hlsjs-source-handler (based on Dailymotion's hls.js library)\nTo enable bitrate selection use player.qualityPickerPlugin().\n\n. @talk2cerlin https://halibegic.github.io/hls/\n. @talk2cerlin\nhls.min.js => https://github.com/dailymotion/hls.js/tree/master\nvjs-hls.min.js => https://github.com/streamroot/videojs5-hlsjs-source-handler\n. @salvaaod https://halibegic.github.io/hls/. Hi @ndhao94 \nJust run the npm install command and after that npm run build.\nYou should get the the dist directory and videojs-hlsjs-plugin.js inside it.\nHere is the dist directory dist.zip\n. You need to include vjs-quality-picker.js. You\u00a0can\u00a0download it from\u00a0the https://github.com/streamroot/videojs-quality-picker and run the command npm install, npm run build.\nIn case you need dist directory dist-videojs-quality-picker.zip\n. +1\n. Yes\n. Thank you for your reply.\nPlugin was working correctly for the past two days and I don't know what caused this problem.\nMaybe I have some network issue or something like that but if it's occurs again I will provide you demo link.\nThank you.\n. ",
    "cagen": "@gesinger Sorry for my late reply.\nI checked the lastest stable version of the video.js(v5.19.2) and videojs-contrib-hls(v.5.5.0). \nI cannot reproduce the issue anymore. I think it was fixed already.\nIf anyone interested, here is the new example which seems to work pretty well:\nhttps://plnkr.co/edit/DsVoSLIyhw6vbvk7PC6E?p=preview\nI replaced the expired video streams and try other three different sources and all of them are correct.\nAnd since the flash tech has been removed from the video.js v6.0.0, maybe it was not a problem in the future?. ",
    "abdulla16": "I'm running version 1.3.5 and I'm also running into the same issue that @ziddey is running into. Any chance the fix for this issue will be merged into master soon?\n. ",
    "cowanmax": "I have the same problem. http://bulgartravel.tv/videojs. It has little stops video :( I have no idea to fix it.. I have tested in Firefox.\n. love FP but it has problems with crossdomain policy :(\n. Which H264 profile you can recommend ? Now I use H264 Baseline, level 3.1, keyframe frequency 4 sec, threads 4, network buffer 20. We have a 2 streams 700 & 1500 kbit/sec 1280x720\n. have anybody any ideas to fix it??\n. Now we have use an uppod player (it's free) and it works great with HLS. But it use Java for desktops and HTML5 for Android and iOS.\n. have the same problem :((\n. which version of videojs-contrib-hls do you use??\n. We use an Adobe Media Server.\n. Have the same problem but it stops after 10-15 segments.. Hope to fix it very soon. BTW with VOD is works very well. So it problem only for LIVE streams.\n. ",
    "camlowe": "Apologies for the delay in getting back to you guys.\nWe're using ffmpeg to broadcast the stream with a key frame interval of 2 seconds, and a segment length of 10 seconds.\nCmd line for broadcast (we're broadcasting in two qualities, but only using the higher quality in the videojs example):\nffmpeg -threads 2 -re -fflags +genpts -stream_loop -1 -i $F \\\n    -s 640x360 -ac 2 -f flv -vcodec libx264 -profile:v baseline -b:v 600k -maxrate 600k -bufsize 1200k -r 24 -g 48 -ar 44100 -c:a libfdk_aac -b:a 64k $S1 \\\n    -s 1920x1080 -ac 2 -f flv -vcodec libx264 -profile:v baseline -b:v 2000k -maxrate 2000k -bufsize 4000k -r 24 -g 48 -ar 44100 -c:a libfdk_aac -b:a 64k $S2\nAbove should be setting keyframe every 2 seconds (48 frames).  Keyframes should be aligned with each segment start as 2 seconds divides evenly into the segment length of 10 seconds.\n. Hi guys,\nAny updates on this issue?\nI've tried the latest version, and I'm still seeing slight hitching.\n. Awesome! Thanks @dmlap :) The video hitching has been removed.\nThe only issue we're seeing now is that the stream will stop after 7-10 minutes.\nExample here: https://streamshark.io/example/videojs/v2.html\n. Hi @gesinger, I've just done a test on the latest version and it does appear to no longer an issue.\nI'll close this ticket.\n. ",
    "raj2569": "I too have the same problem, on Chrome Version 47.0.2526.106 (64-bit) Debian Jessie. \nHow do I find out the exact version of the Video.js and vidoejs.hls.min.js?\n. Issue still persists:\nvideo.js: v5.7.1\nvideojs.hls.js: https://gist.github.com/Tralapo/94291509f987d0d56e05\nbrowser: Version 47.0.2526.106 (64-bit)\nStream: http://178.63.55.206/live01/test01/index.m3u8\nURL: http://178.63.55.206/player1.html\nI am using the following ffmpeg cmdline for generating the stream:\n~/ffmpeg-git-20160227-64bit-static$ ./ffmpeg -loglevel verbose -re -i ../videos/tears_of_steel_720p.mov  -vcodec libx264 -vprofile baseline -acodec libmp3lame  -vf scale=640:268 -ar 44100 -ac 1 -f flv rtmp://178.63.55.206/live01/test01\nAttached is the screenshot of the chrome inspector. \n\nPlease let me know if any additional information is needed or any testing is to be done to isolate this issue.\n. @billybobilly\nCan you specify the exact versions of video.js, videojs-hls.js, .css, etc,\nyou are using?\nraj\nOn Sat, Apr 2, 2016 at 11:42 PM, billybobilly notifications@github.com\nwrote:\n\nFinally have it all working. Using latest video.js, videojs-hls.js, .css,\netc.\nThe live from capture card and 'live' from vod are both playing without\nfreezing. The vod problem turned out to be a parameter in the ffmpeg\nencoder where we had -c copy in the command. removed that and everything is\nfine.\nUnless someone else has a continuing problem, I think this issue can be\nclosed.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly or view it on GitHub\nhttps://github.com/videojs/videojs-contrib-hls/issues/483#issuecomment-204768076\n. Have the same problem here, using chrome. Version 47.0.2526.106 (64-bit) in Debian Jessie. The chrome inspector network diagnosis is attached. Let me know if any information/help is needed from my side to nail this issue.\n\n. \n",
    "u0x01": "I have same problem.\nBut I found out that this HLS example is good working on all browser.\nhttp://developer.qiniu.com/resource/FgCBc3IlydY6CFIA8jhe7jIxCt1y\n. Has any other plugin can substitute videojs to play HLS?\n. @Tralapo It's this of your sticking?\nhttps://github.com/videojs/videojs-contrib-hls\n. @Tralapo Where can download your forking repo of 1.2.0?\n. @Tralapo Thanks!\n. ",
    "dobri-dobrev": "Same happens for me. As far as my debugging could show, the this.tech_.currentTime() randomly returns a time significantly earlier than the current time causing the player to crash. The currentTime increases sequentially until it seemingly randomly jumps way back and the player stops loading new segments.\nI could only track the issue down to src/videojs-hls.js fillBuffer(). Hope this helps. It is unfortunately a significant blocker for us\n. Same happens for me. As far as my debugging could show, the this.tech_.currentTime() randomly returns a time significantly earlier than the current time causing the player to crash. The currentTime increases sequentially until it seemingly randomly jumps way back and the player stops loading new segments.\nI could only track the issue down to src/videojs-hls.js fillBuffer(). Hope this helps. It is unfortunately a significant blocker for us\n. @bobgle still having issues with 1.2.2\nI run videojs 5.3.0 (also tried 5.4.4)\nand videojs-contrib-media-sources-2.4.3\n. ",
    "jhumbug": "@Tralapo So you're using hls 1.2.0 and videojs 5.2.0, correct?  What version of videojs-contrib-media-sources are you using?  \nI ask because when I go back to 1.2.0 and 5.2.0 (i'm experiencing this same .ts file bug when you switch tabs) on Chrome, which uses the Flash player, I only get the lowest quality bitrate loading, which for us is an audio only version.  It never switches to the higher one.  \nHere's hls 1.2: http://www.adultswim.com/dev/as-player-1.2/\nHere's hls 1.3.4: http://www.adultswim.com/dev/as-player-1.3.4/\n. @Tralapo  Thanks for the clarification.\nI'm now using those same versions and got it using the html5 video object for Chrome (had to change something in the options I was passing in) but it's still not switching the bitrate above audio only.  Strange... \nMaybe it's my m3u8: http://adultswim-lh.akamaihd.net/i/marathon_1@318516/master.m3u8 \nAny chance you could link the m3u8 that's working for you?\n. @imbcmdth @dmlap In my personal experience this issue only occurs when I switch tabs while letting the stream play on.\nIf you have a network logger open while in another tab, you can watch the m3u8 files download, but not the ts files.\nAs soon as I go back to the tab playing the stream it artifacts and catches back up to where it thinks it should be and starts downloading the ts files again.\nHere's a page my stream using 1.3.4:  http://www.adultswim.com/dev/as-player-1.3.4/ \nNote, I'm using Flash first on this page because for some other strange reason it won't switch bitrates when I try to use html and gets stuck on the audio only version in the playlist.\n. @Tralapo Well I can't properly test the html tech version, so I can't say for sure what happens there, but what I'm experiencing with my Flash version is definitely happening on all Desktop browsers and seems to at least be somewhat related to this.\n. ",
    "andrewho83": "Can confirm that the latest version also halts when window/tab is not focused.  Reverting back to 1.2.1 seemed to fix it.\n. +1\n. ",
    "temaptz": "It also affects 1.3.6.\n. ",
    "sirhanshafahath": "Cool..\nWorking with,\nvideo.js: v5.6.0 & v5.7.0\nvideojs.hls.js: v1.3.7\ntechOrder: html5\nbrowser: Chrome  v48.0.2564.103\nbrowser: FireFox v44.0\ntest source type: live stream from flussonic media server\n. ",
    "dijjit": "We are still finding the same both with the latest and the existing versions recommended above - stream available for testing if it helps isolate this...\nhttp://live.ortana.tv/1280x720_2.m3u8\nThis is being made using FFMPEG - with the segment length set to 6 seconds, with a 10 second segment history in the M3U8 file\n. If someone can share I can retest on the same faulty stream as before.\nSent from my Samsung Galaxy S6 Edge+ - powered by Three\n-------- Original message --------\nFrom: mikeevstropov notifications@github.com\nDate: 19/02/2016 18:15 (GMT+00:00)\nTo: videojs/videojs-contrib-hls videojs-contrib-hls@noreply.github.com\nCc: James Gibson james@ortana.tv\nSubject: Re: [videojs-contrib-hls] segment files stop downloading but new m3u8 files keep coming (#483)\n@Tralapohttps://github.com/Tralapo Friend can u share last build please? I have problem with npm on win. Thank you!\n\nReply to this email directly or view it on GitHubhttps://github.com/videojs/videojs-contrib-hls/issues/483#issuecomment-186342946.\n. ",
    "mikeevstropov": "@Tralapo Friend, can u share last build please? I have problem with npm on win. Thank you!\n. @Tralapo I tried your build 1.3.8 with video.js 5.6 and it's working correctly on live.\nps. But i have problem not for this issue. The VoD stream stops on 30sec after 5-7 segments. =/\n. @billybobilly Hi. I cannot understand what contrib-hls wants to work fine. Now i'm using hls.js (dailymotion) with custom player controls. (mdn reference: https://goo.gl/Y20qNW w3school: http://goo.gl/sYGOul) And it's not so hard like what i thought. But, if you want you can use video.js with hls.js.\n. ",
    "ssanth": "I am still seeing this issue on live streams\nvideojs 5.15.1\ncontrib hls v4.1.1\nMainly on chrome, probably repros on firefox too and looking for a fix.\nFew more of us are also seeing the issue and mentioned in the ticket:\nhttps://github.com/videojs/videojs-contrib-hls/issues/491. I am facing the same issue as well on live streams\nvideojs 5.15.1\ncontrib hls v4.1.1\nMainly on chrome.\nWould like to reopen this issue and looking for a fix.\n. I am still seeing this issue on live streams\nvideojs 5.15.1\ncontrib hls v4.1.1\nMainly on chrome and looking for a fix.. I am facing this issue on live streams on chrome, \nvideojs 5.15.1\ncontrib hls v4.1.1\nThose settings are not helping as I want low latency as well.\nLooking forward for a solution.\n. https://github.com/videojs/videojs-contrib-hls/issues/982\nin the above template, replacing the VOD stream with this live stream http://mahoaobj.b5695cde.cdnviet.com/tuandn/videojs/hls/vtv5-high.m3u8  will showcase the issue.. ",
    "vpowers": "I'm also seeing this on live streams.  Seems to be mainly chrome for me as well although I haven't done enough testing in other browsers.\nvideojs 5.16.0\ncontrib hls 4.1.1. I'm also seeing this on live streams. Seems to be mainly chrome for me as well although I haven't done enough testing in other browsers.\nvideojs 5.16.0\ncontrib hls 4.1.1. I am also seeing this error with Win 8.1 + IE 11 on Browserstack.  . @Ambroos I've tried your solution and I'm getting an error thrown here in webworkify-webpack-dropin:\nif (typeof key === 'undefined') {\n        throw new Error('webworkify-webpack: Could not locate module containing worker function! Make sure you aren\\'t using eval sourcemaps and that you pass named functions to webworkify-webpack!');\n}\nI've made sure that I'm not using eval sourcemaps.\nI've upgraded my versions of videojs-contrib-hls and video.js to v3.7.0-beta3 and 5.12.6, respectively.  The only difference is my project is a react app using nwb, if that makes any difference.  Any ideas?\n. @Ambroos Here is my nwb.config.js.  Webpack configuration is passed in:\n```\nmodule.exports = {\n...\n  webpack: {\n    devtool: 'cheap-source-map',\n    html: {\n      favicon: 'vendors/favicon.ico'\n    },\n    extra: {\n      resolve: {\n        alias: {\n          webworkify: 'webworkify-webpack-dropin'\n        }\n      }\n    }\n  }\n}\n```\nHere is the line in virtual-source-buffer.js (es5) from videojs-contrib-media-sources that executes webworkify-webpack-dropin:\n// append muxed segments to their respective native buffers as\n// soon as they are available\nthis.transmuxer_ = (0, _webworkify2['default'])(_transmuxerWorker2['default']);\n. I've attempted to isolate the issue by creating a small app using videojs-contrib-hls and bundling with webpack and @Ambroos 's solution does work.  I had been testing this within a larger react app that uses nwb so somethings going on there.  I'll provide an update if I can figure out the issue.\n. @dbryand My react app is using nwb for bundling instead of plain webpack.  (nwb uses webpack under the hood).  This seems to be the difference.  Are you just using webpack?. I've created two small applications. One using webpack and video.js with hls plugin and a react app using nwb (https://github.com/insin/nwb) and video.js with hls plugin.  Both of them are swapping out the webworkify module with @Ambroos's webworkify-webpack-dropin module.  The webpack app is working with this solution but the react app using nwb is not.  If anyone has any experience with nwb or is feeling helpful, take a look at these projects.  Any help would be appreciated!\nhttps://github.com/vpowers/simple-react-app\nhttps://github.com/vpowers/simple-webpack-app. In case someone comes along and needs to support videojs-contrib-hls in a react app using nwb, I have forked @Ambroos webworkify-webpack-dropin to support how nwb bundles code:\nhttps://github.com/vpowers/webworkify-nwb\nFollow the instructions in this comment but use the module above instead.. I've tested this fix with PR #1006 and playback is working as expected. Test was done with a long running live HLS stream using Wowza. I can't confirm in the master branch (after merge) since playback of HLS is not longer working. . @LeonidasEsteban Seems to be an issue with the build using ^5.17.0 of video.js.  My workaround was to fork videojs-contrib-hls and rollback to using ^5.15.1 and load from my own repo until they address the issue.. ",
    "tim1mw": "This still happens with the latest release v5.11.0, it also causes the page load to be very slow if the underlying m3u8 file has been deleted.. ",
    "aydinkn": "I have same problem with v1.3.8\nChrome result:\n\nFirefox result:\n\n. I confirm this issue. I upgrade conrtib-hls from 1.3.11 and show up this problem.\n. But, I don't have this problem with contrib-hls 1.3.11 on chrome @forbesjo \n. Hi, this method didn't work for me.\nconst videojs = global.videojs = require('video.js');\nrequire('videojs-contrib-hls');\nI've got this error:\nUncaught TypeError: Cannot read property 'xhr' of undefined\n// request the specified URL\n    request = this.hls_.xhr({\n      uri: srcUrl,\n      withCredentials: withCredentials\n    }, function (error, req) {\n    .....\n. I found my problem. When i fetch master playlist for quality switcher:\nlet loader = new videojs.Hls.PlaylistLoader(playlistSource);\nloader.on('loadedplaylist', function () {\n        // Fetch quality for quality switcher\nI got this error.\n. ",
    "leon-wbr": "Can you tell us more about the headers, which ones are important? Any link? There doesn't seem to be anything specific in the docs, except for CORS which we have enabled.\n. Latest working version is 1.2.2. Can you confirm try that version and report back @dobri-dobrev?\n. ",
    "Abdurraheem": "i am also facing same problem ..can u help me..its not playing in android its shows same error...media could be not loaded,either becoz the server or network failed or becoz the format is not supported. ",
    "bernhardreisenberger": "can confirm, that the problem still exists in 1.3.5 with video.js 5.6.0\nvideojs-contrib-hls - v1.2.2 is working for me\n. v2.0.0 non-/minified version: no issues in chrome. in firefox however, it stuck after 10min-30min.\nv1.3.7 non-/minified version: playback stuck after a few seconds\n. ",
    "isabo": "With video.js v5.4.x and videojs-contrib-hls v1.2.0 it doesn't work for me on Chrome/OSX. The only way I got it to work was to force it to use Flash, in which case I get a low quality video, but it's better than nothing.\n. ",
    "hybrisCole": "Same here, using videojs 5.6, videojs-media-sources 2.4.5 and 1.3.7, tried to downgrade to 1.2.1 but remains the same\n. @Tralapo it works for like 10 seconds, then it will say:\nVIDEOJS: ERROR: (CODE:3 MEDIA_ERR_DECODE) The media playback was aborted due to a corruption problem or because the media used features your browser did not support. MediaError {code: 3, message: \"The media playback was aborted due to a corruption\u2026media used features your browser did not support.\"}code: 3message: \"The media playback was aborted due to a corruption problem or because the media used features your browser did not support.\"proto: MediaError_logType @ video.js:19117log.error @ video.js:19068error @ video.js:11619handleTechError_ @ video.js:10424ret @ video.js:18946ret @ video.js:18946data.dispatcher @ video.js:18594\n. I got this working using the following:\nVideoJS: 5.2\nvideojs-contrib-media-sources : 2.4.5\nvideojs-contrib-hls : 1.2.1\nBUT, when I dispose my videoJS Reference, I got this:\nDOMException: Failed to execute 'abort' on 'SourceBuffer': This SourceBuffer has been removed from the parent media source.(\u2026)\nindex.js:60 DOMException: Failed to execute 'abort' on 'SourceBuffer': This SourceBuffer has been removed from the parent media source.(\u2026)\nWrapping the dispose() around a try catch made the trick for me.\n. @Tralapo yeah I read somewhere that it's not needed, but for some reason it won't detect my video format :S hehe\n. Well I'm basically doing this \n<script src=\"videojs/videojs.hls.js\"></script>\n<script src=\"videojs/video.min.js\"></script>\nand I have a React Component like this:\nconst videoView = (props) => {\n  const videoSourceRMTP = `rtmp://${VIDEO_URL}/com-apogee/${props.videoId}_${props.quality || QUALITY}`;\n  const videoSourceHLS = `//${VIDEO_URL}/com-apogee/hls/${props.videoId}_${props.quality || QUALITY}.m3u8`;\n  // const videoSourceDASH = `//${VIDEO_URL}/com-apogee/dash/${props.videoId}_${props.quality || QUALITY}.mpd`;\n  // <source src={videoSourceDASH} type=\"application/dash+xml\" />\n  const options = {\n    techOrder : ['flash', 'html5'],\n    controls  : false,\n    autoplay  : true,\n    width     : props.windowWidth,\n    height    : props.quality === 'birdseye' ? props.windowHeight : (props.windowWidth * ASPECT_RATIO),\n  };\n  return (<video id={props.videoId}\n           className=\"video-js vjs-default-skin\"\n           autoPlay=\"autoPlay\"\n           data-setup={JSON.stringify(options)}\n           controls>\n    <source src={videoSourceRMTP} type=\"rtmp/mp4\" />\n    <source src={videoSourceHLS} type=\"application/x-mpegURL\" />\n  </video>);\n};\n. ",
    "alonfixler": "Hi,\nDid someone manage to fix this issue with the current version of videojs-contrib-hls?\nAlon\n. Hi,\nI'm suffering from the same issue. I've noticed that enlarging the buffer causes the stream to play longer without getting stuck but eventually it's stopping.\nIs there any way to solve this issue? I'm dealing with many frame rates so trying to change the encoder is not something I want to do.\n. Hi,\nIn the end, for many reasons I decided to go with hls.js (https://github.com/dailymotion/hls.js/tree/master) and not with videojs-contrib-hls so I can't help you on this issue.\n. @juliomenendez I integrated hls.js with video.js with the help of vjs-hls: A small video.js plugin that creates the connection between hls.js and video.js.\n. Hi,\nI solved the issue by changing the following values in Cupertino Streaming Packetizer properites:\n1. cupertinoMaxChunkCount: set it to 15 (Instead of the default which was 10).\n2. cupertinoPlaylistChunkCount: set it to 10 (Instead of the default which was 3).\nAlon\n. ",
    "sreym": "This bug can be reproduced for the video:\nhttp://mahoaobj.b5695cde.cdnviet.com/tuandn/videojs/hls/vtv5-high.m3u8\"\nVersions: videojs 5.11.0, videojs-contrib-hls 4.1.1. ",
    "ghaydarov": "I am having the same issue with latest versions of videojs 5.16.0 and videojs-contrib-hls 4.1.1 on all browsers except safari. Any ideas how to fix this?. Here is how I got rid of this issue. My setup is on aws. I transcode videos with elastic transcoder, and I used cloud front to serve them. \nInitially I was using hlsv4 with aes encryption and I had this problem, video not playing after 5-10 seconds. Now I switched to hlsv3 with aes encryption and everything is working nicely. \nI hope this helps.. I am getting the same error with latest versions.\n\nUncaught TypeError: Cannot read property 'segments' of undefined\n\nContent of m3u8\n\nEXTM3U\n\nEXT-X-VERSION:3\nEXT-X-MEDIA-SEQUENCE:0\nEXT-X-ALLOW-CACHE:YES\nEXT-X-TARGETDURATION:12\nEXT-X-KEY:METHOD=AES-128,URI=\"http://localhost:3000/my-data-key.key\",IV=0x41c086d257f79afc44e91d10bc9c05b5\nEXTINF:11.344667,\nChapter_1_hls1M00000.ts\nEXTINF:11.261233,\nChapter_1_hls1M00001.ts\nEXTINF:7.507489,\nChapter_1_hls1M00002.ts\nEXTINF:11.261244,\nChapter_1_hls1M00003.ts\nEXTINF:5.255233,\nChapter_1_hls1M00004.ts\nEXT-X-ENDLIST\nFull error:\n\nUncaught TypeError: Cannot read property 'segments' of undefined\n    at http://localhost:3000/assets/videojs-contrib-media-sources/dist/videojs-con\u202685dfba2372d7d02f621728fda9c4517280661bbdf8f92a10b59fd87c.js?body=1:2351:25\n    at Array.reduce (native)\n    at VirtualSourceBuffer.processPendingSegments_ (http://localhost:3000/assets/videojs-contrib-media-sources/dist/videojs-con\u202685dfba2372d7d02f621728fda9c4517280661bbdf8f92a10b59fd87c.js?body=1:2346:45)\n    at VirtualSourceBuffer.done_ (http://localhost:3000/assets/videojs-contrib-media-sources/dist/videojs-con\u202685dfba2372d7d02f621728fda9c4517280661bbdf8f92a10b59fd87c.js?body=1:2184:12)\n    at Worker.VirtualSourceBuffer.transmuxer_.onmessage (http://localhost:3000/assets/videojs-contrib-media-sources/dist/videojs-con\u202685dfba2372d7d02f621728fda9c4517280661bbdf8f92a10b59fd87c.js?body=1:2009:22)\n. Hi @benvirus, I implemented encryption with key, however, my links are visible and downloadable as opposed to yours, on your example here, where your links are encrypted. What are the plugins you are using for this and I am using HLSv3 on aws and serving with cloudfront cdn.  Can you please tell me how you are doing that? I don't want my videos to be downloaded.\n\nThanks. Thanks @benvirus , I emailed you about this. Thank you!. ",
    "erald": "Am using it for VOD with the latest releases.\nAm offering multiple streams\nsrc type rtmp,\nsrc type hls\nscr type mp4\nscr type webm\nI see in Chrome this result in \n\nam expecting to see the videofile in the src. The video never starts and in Firefox it gives invalid source.\nof course if I change the order (first type mp4 then type has) most browsers play without problems the type mp4. have to test it with iPhone and iPad if they pick up the xls stream instead of the mp4 stream\n. ",
    "arikkrol1": "Same goes for failed m3u8 playlist request.\n. ",
    "piotr-cz": "Unfortunately this hack doesn't work anymore (probably since v2)\nThe getMediaIndexForTime function is not exposed anymore.\n. Did you guys find a way to retrieve current playing segment?\n. Is it available in v3.1.0? It doesn't seem that the player.hls.representations function is defined/ exposed\n. True, thanks for checking.\n. @gkatsev \nSomehow the renditionSelectionMixin which sets representations on the hlsHandler is not invoked in my app.\nProbably because there is no audio in the stream info (I'm streaming from live cams with no audio), this code block doesn't run\n. @adityaj221 Have you tried with the latest release of videojs-contrib-hls?\nAlso, does your stream contain audio?\n. @sobytes Which videojs-contrib-hls version are you using?\n. @BrandonOCasey \nNo, unfortunetally no joy. I've tried on 5 webcam streams and latest libraries.\nplayer.hls.representations is still undefined.\nIt's because this line always evaluates to false in my case and no other code is triggering event selectedinitialmedia which on the other hand sets up representations (renditionSelectionMixin)\nWhen I trigger the event manually using player.hls.masterPlaylistController_.trigger('selectedinitialmedia'), representations are available.\n. So it seems that the source I'm using doesn't allow Multi-Bitrate HLS playlists (Adaptive bitrate streaming).\nThe source of index.m3u8 file is\n```\nEXTM3U\nEXT-X-ALLOW-CACHE:NO\nEXT-X-TARGETDURATION:8\nEXT-X-VERSION:3\nEXT-X-MEDIA-SEQUENCE:137090\nEXTINF:7.480,\n2016/09/14/08/41/45-07480.ts\nEXTINF:7.540,\n2016/09/14/08/41/53-07540.ts\nEXTINF:7.470,\n2016/09/14/08/42/00-07470.ts\nEXTINF:5.000,\n2016/09/14/08/42/08-05000.ts\n```\nWhile in the videojs-contrib-hls example each playlist entry has properties like BANDWIDTH and RESOLUTION\nI'm not sure if this is the case, but even when I was able to invoke creation of representations, only available representation didn't have width attribute.\nI think the readme file could state that when the hls.representations function is not available, stream index file doesn't have any information on available adaptive bitrates.\n. Thanks, I'll check it out, but now I know that we need to setup media server to provide lower resolution streams.. Thank You!\n. Since which version is this available, is it v5.3.3?. ATM I'm using this simple code for playing stream. For paused stream I'm storing stale media and pausedAt timestamp.\n```js\nvar targetMedia = this.hls.playlists.media();\nvar snapshotTime = this.player.currentTime();\nvar segment;\nvar segmentTime;\n// Itinerate trough available segments and get first within which snapshotTime is\nfor (var i = 0, l = targetMedia.segments.length; i < l; i++) {\n    // Note: segment.end may be undefined or is not properly set\n    if (snapshotTime < targetMedia.segments[i].end) {\n        segment = targetMedia.segments[i];\n        break;\n    }\n}\n// Null segmentTime in case it's lower then 0.\nif (segment) {\n    segmentTime = Math.max(0, snapshotTime - (segment.end - segment.duration));\n// Because early segments don't have end property\n} else {\n    segment = targetMedia.segments[0];\n    segmentTime = 0;\n}\napiRequest({'videoTime': segmentTime, 'videoUri': segment.uri});\n``\nI'm not able to retrieve Segment Metadata like described in docs as the textTracks method returns empty array (player.textTracks().length === 0`) in both v4.1.1 and v5.3.3. ah, OK, I'll wait then - releases come pretty often.\nI'd be cool if releases on release page would come with it's changelog segment like for example in video.js releases. Thank you that was a bad typo. It's fixed now.\n. I'm having similar issue:\nChrome 59M on Android adds a header Range:bytes=0- every time when requesting a playlist m3u8 file.\nServer responds with 206 Partial content response, but chrome doesn't download response body and player is stuck at the loading state forever.\nChrome on desktop doesn't add this header by default but when I enforce it, response body isn't downloaded as well,\nTo reproduce:\njs\nfetch('http://d2zihajmogu5jn.cloudfront.net/bipbop-advanced/bipbop_16x9_variant.m3u8', {\n  headers: {range: 'bytes=0-'}\n}). Well, in my case this might be a problem with Flussonic server and CORS configuration.\nIt responds with playlist body to OPTIONS request and afterwards with an empty response body to GET request when triggering fetch manually (I can see just second request when using video.js).\nWhen running fetch in Firefox, both requests contain full body with playlist.\nAnyway I wonder why request to bipbop playlist doesn't get any response body, event that CORS look fine. @thecotne Thanks, after long debugging I had a feeling that it's probably a problem with server which doesn't properly respond to requests of new versions of chrome.\nWhat is the Flussonic version that you updated to?. Thank you, will check it out. @thecotne Flussonic server is being managed by other company and they decided to update when new release comes up which should be in about two weeks - and they responded with It works for me type of reply.\nUnfortunately when streams don't work they tend to blame player.. @arski For us the issue was that Chrome on android changed CORS behavior for HLS streams.\nWe had to update media server (Flussonic) where they introduced correct CORS handling.\nI'm afraid that I can't help you more as I can't reproduce the issue. Get in touch with your media server support. It's been almost 6 months since Chrome v59 for Android has been released and the must have a solution by now.. ",
    "eminden": "Is the any plan to support AAC container (audio only streams) on the development branch? I guess what @ram651 is looking for this as same as me.\n. ",
    "eranwo": "You are right, but i need prevent download the mp3 files.\nSo, far as I know streaming is the best way to protect from downlod.\nIt's  for audio on demand project.\nMaybe anyone know how to do this?\n. ",
    "gnz00": "+1 I'm having a similar issue, but only on certain manifests. I haven't narrowed it down yet.\nFor the sake of discussion, we're both using videojs v5.4.6 and videojs-contrib-hls v1.3.3.\nExample of one of my manifest chains: https://gist.github.com/maysale01/745be38db6f0bf42ba50\n. See this pull request: 387.\nBoth of our manifests use media groups.\n. @lime-green I found that this issue was because I was using assuming that src/videojs-hls.js was the proper entrypoint for the plugin. \nYou need to build the dist version and use dist/videojs-hls.js. If you're using npm to install the package from git (thanks to https://github.com/npm/npm/issues/3055), you'll need to manually run cd node_modules/videojs-contrib-hls && npm install (which will fail since the tests are in the .npmignore file). Then run grunt build. \nThis should be remedied, as the npm package version is growing out of date with the github release version. \n. ",
    "tenacex": "@dmlap @imbcmdth https://github.com/videojs/videojs-contrib-hls/pull/655\n. I watched the first video, and it didn't freeze for me. \n. @Tralapo, I have confirmed that the current build indeed fixes this issue.\n. @shacharz What do you exactly mean by making it easy to play other videos on the demo page? Currently you can input a url to a stream, do you mean to say that we should add something like a drop down menu feature?\n. I noticed that this is an encrypted stream. The second segment, where the lag in playback is seen, is failing to decrypt properly on my hls-fetcher that uses the same decryption that we use in contrib-hls. The 4th segment, which is a 4 second segment, also is not decrypting properly, thus causing playback to stall. I am looking into what is going wrong during decryption and will keep you posted. \n. It says link not found.\n. I believe this is due to the browser not being able to access the playlist file at the given link. I have attached a screenshot of what happens when I try and visit the link in the browser. Typically visiting the link would download an .m3u8 playlist file. Since this isn't happening, I think we can attribute the fault to the stream, and not HLS.\n\n. Directly, not that I know of. But.... Feel free to use this: https://github.com/tenacex/hls-fetcher/tree/livestream-support\n. @SudoPlz @imbcmdth wrote the original, so you can thank him! I am adding my addition for livestream support to the npm registry, so you keep a lookout for that in the next hour or so. it will be live-hls-fetcher\n. What do you mean by what files you need?\n. It would be pretty easy to do actually. Pessimist is the module that feeds the input into the starting function. The whole project starts at the getIt function in index.js. So just hook up your code to that part. \n. :+1: \n. I haven't put it on the master branch. Are you getting the livestream-support branch?\n. If not, you can clone my repo, switch to the livestream-support branch, and then run npm i -g ./\n. perfect.\n. Checkout https://github.com/videojs/mux.js. It will take some time, but if you hook it up directly, you could feed the data from the ts segments into it and get back content in an mp4 wrapper. \n. I wasn't able to replicate this bug in FF 44.0.2 on Yosemite. What is the link to the exact stream you are using?\n. We are working on the segment loading logic right now. It should fix your problem, stay tuned and checkout the better-fetching branch.\n. IE11 is having some issues. We are currently working on patching these up. \n. I believe you can accomplish what you are trying to do by using: https://github.com/videojs/videojs-contrib-hls#hlsselectplaylist\n. How are you adding HLS to VJS?\n. Looks good\n. @sirisian Any chance you could assemble a test page on a server that causes the error? It would make testing for our team a whole lot easier.\n. Hmm, when I plug that link into my player, it doesn't load too. I noticed that when I visit: http://sirisian.com/randomfiles/testhls/hls/hdmi/index.m3u8\nIt doesn't download a playlist file, like it has everywhere else for me. Perhaps you could look into that? \n. @dmlap I'm not entirely sure I understand. I created this new PR: https://github.com/videojs/videojs-contrib-hls/pull/670\nIt includes his original change(retry logic), I took out the index.html file(like Jon requested), and I ran the test in the development branch, where it failed. Did I do what you wanted me to do?\n. @BrandonOCasey just got time to address these, I'll let you know when I push. \n. @imbcmdth I thought we agreed that if we had only one more enabled playlist we were on the lowest rendition? \n. Temporarily I changed the code back to what you had originally. Lets talk about how you want this code to be improved because I am not quite sure I understand exactly what you mean.\n. Reverted back to only error checking and reverting loader.state.\n. can't line 344 be shortened to \njavascript\nmediaGroupName = media.attributes.AUDIO;\n. idk if this would be any better, but could shorten to one line with \njavascript\nif (this.sourceUpdater_ && this.sourceUpdater_.dispose()){}\nNot sure if this is bad practice tho :p\n. Shouldn't all of these be declared with just one let, like:\njavascript\nlet var1,\n  var2 = 'meh',\n  var3;\n. One let?\n. do you need the timelineUpdated variable if you only use it here?\n. I think you should make a variable for this.tech_.audiTracks()[i]\n. one let.\n. key should be instantiated at top of function\n. so sexy tho\n. My bad\n. I really gotten learn my es6\n. ooooh, do it @gesinger :p\n. No expert on this pr, but should you maybe check to see if we have this.mediaSource?\n. mwahaaha\n. Wouldn't this be \njavascript\nif (typeof v !== 'number' || v <= 0)\n?\n. Perhaps a test that would have caught this.\n. Besides that LGTM\n. Does the getter really need to set this? Seems a bit odd to me. \n. Besides that it looks good\n. I'll change it right now\n. removed\n. I tried that originally, it didn't work. Not sure why its undefined\n. It comes from the custom chrome waiting event\n. changed.\n. changed.\n. I changed it to only listen to player events but it didn't work, going to leave it the way it is now, but I will investigate why it isn't working\n. aren't plugins always functions?\n. It is the only place in the project where we have a guaranteed reference to player, and if I moved it to the src function, I wouldn't have access to the tech. \n. Still looking into why it doesn't re-emit these events\n. Done\n. Done. it is called skipTheGap\n. Changed.\n. Only reason I have kept it here is because it is the only place we have a reference to the player. \n. Removed empty object.\n. Done.\n. What do you mean they don't seem to be removed? I still use lastRecordedTime, but I can remove adaptiveSeeking\n. Changed.\n. Removed\n. seeking into a gap doesn't work.\n. Sorry @BrandonOCasey making the changes now.\n. I don't think videojs calls this function, isn't this how you instantiate a plugin? Either way this is all subject to change because I am turning it into a module, so stay tuned. \n. Changed.\n. Good call.\n. Isn't this the same if statement?\n. I changed the one that check if we had a playerID though\n. Changed\n. K\n. Thanks. I needed that advice badly\n. Sure.\n. Removed.\n. Fixed it up.\n. Changed.\n. The reason i chain them together is because I don't want to call the functions to create the variable values without first checking if the input arguments are valid. I think it might be best to keep it this way.\n. great @gkatsev \n. Changed.\n. Added\n. Changed. \n. Trying to figure out an alternative. \n. Sorry, I didn't fully understand you I guess. One problem I see with that is the request timeout isn't really calculated until we know the segment duration, which is only in the segment loader. Since we won't know the timeout request time within the MPC, I think there are only 2 ways to approach passing it in. We could either pass in an enable/disable timeout property, kind of like I used above. We then could use this switch to decide what timeout to use. as an alternative we could use the goal segment duration as the calculator for the timeout request, since I believe the playlists belonging to the MPC know this. Any preference?\n. ",
    "mogita": "In my case, this is relevant to the custom logics based on the file names of the segments, which are predefined by the video/streaming service provider. Being unable to fetch this information simply disabled me from implementing those custom in-browser logics, I'll have to do it the harder way. I think this should make sense. :)\n. ",
    "namor": "+1 here\n. Try setting AUTOSELECT to YES\nSurprisingly you got the DEFAULT option to work (on bitmovin). They renamed the option in production to is_default last tuesday\n#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"audio\",NAME=\"English\",DEFAULT=NO,AUTOSELECT=YES,LANGUAGE=\"en\",URI=\"video_audio_track_english.m3u8\". ",
    "villos": "+1\n. ",
    "mkhazov": "+1\nvideojs-resolution-switcher plugin has videojs-contrib-hls support (on branch), but it works with some flaws.\nAlso there is videojs-quality-picker which can be integrated manually\n. I've tried every solution described in this issue, and also http://docs.videojs.com/tutorial-webpack.html, but I always get VIDEOJS: ERROR: (CODE:4 MEDIA_ERR_SRC_NOT_SUPPORTED) No compatible source was found for this media error.\nI use\n    video.js@6.2.5\n    videojs-contrib-hls@5.9.0\n    webpack@2.7.0. Probably the same as #765 \n. @forbesjo, @imbcmdth \nCan this issue be re-opened and considered as a feature request?\n. Thanks for this feature, it's very helpful!\nProbably reloadSourceOnError plugin need to be mentioned in the library's documentation.\n. you can try https://github.com/Go-Promo/videojs-resolution-switcher/tree/hls. Any update on this?\nThe problem is the player reloads playlist every manifest.targetDuration seconds even if the playback was not started.\n@dmlap explained why the plugin reloads manifest while playback is paused, but is there a reason to automatically load master playlist in case of preload=none?. ",
    "talk2cerlin": "@halibegic : any sample implementations for this plugin?\n. @halibegic : thanks for the link. May i know what these two files are?\n<script src=\"js/hls.min.js\"></script>\n<script src=\"js/vjs-hls.min.js\"></script>\n. is there any resolution switching button?? \nsomething like\n\n. ",
    "rohityadav876": "@gesinger can you just let us know how to use that plugin, I tried to use it but getting nothing to be in the player menu.\nThe HTML I am using:- \n<video id=\"player-video\" width=600 height=300 class=\"video-js vjs-default-skin\" controls> </video>\nJS :- \n```\n",
    "salvaaod": "@halibegic  the sample at http://halibegic.info/p/hls/   is not working anymore, can you upload it again ?\nThanks.. Hi, tried the sample on Windows (Chrome) and works fine the quality selection button is there, but on Android and iOS seems not to have any effect and there is no quality select button.\nAny idea why ?. ",
    "kuzroman": "Hello everybody! @halibegic or somebody can say why your sample does't work on my android 7?\nIs it really make button for phones (ios, android)?\nI am used plugin videojs-contrib-quality-levels and it work only in desktop, why?. ",
    "DarkMatterCore": "I thought it would be OK to share my solution as well:\n```\n\n\n\n\n\n\n\n    var options = {\n        html5:{\n            hls:{\n                enableLowInitialPlaylist:true\n            }\n        },\n        flash:{\n            hls:{\n                enableLowInitialPlaylist:true\n            }\n        },\n        inactivityTimeout:0,\n        controls:true,\n        autoplay:true,\n        preload:\"auto\",\n    };</p>\n<pre><code>var player = videojs('example-video', options);\n\nvar qLevels = [];\n\nplayer.qualityLevels().on('addqualitylevel', function(event) {\n    var quality = event.qualityLevel;\n    console.log(quality);\n\n    if (quality.height != undefined &amp;&amp; $.inArray(quality.height, qLevels) === -1)\n    {\n        quality.enabled = true;\n\n        qLevels.push(quality.height);\n\n        if (!$('.quality_ul').length)\n        {\n            var h = '&lt;div class=\"quality_setting vjs-menu-button vjs-menu-button-popup vjs-control vjs-button\"&gt;' +\n                    '&lt;button class=\"vjs-menu-button vjs-menu-button-popup vjs-button\" type=\"button\" aria-live=\"polite\" aria-disabled=\"false\" title=\"Quality\" aria-haspopup=\"true\" aria-expanded=\"false\"&gt;' +\n                    '&lt;span aria-hidden=\"true\" class=\"vjs-icon-cog\"&gt;&lt;/span&gt;' +\n                    '&lt;span class=\"vjs-control-text\"&gt;Quality&lt;/span&gt;&lt;/button&gt;' +\n                    '&lt;div class=\"vjs-menu\"&gt;&lt;ul class=\"quality_ul vjs-menu-content\" role=\"menu\"&gt;&lt;/ul&gt;&lt;/div&gt;&lt;/div&gt;';\n\n            $(\".vjs-fullscreen-control\").before(h);\n        } else {\n            $('.quality_ul').empty();\n        }\n\n        qLevels.sort();\n        qLevels.reverse();\n\n        var j = 0;\n\n        $.each(qLevels, function(i, val) {\n            $(\".quality_ul\").append('&lt;li class=\"vjs-menu-item\" tabindex=\"' + i + '\" role=\"menuitemcheckbox\" aria-live=\"polite\" aria-disabled=\"false\" aria-checked=\"false\" bitrate=\"' + val +\n                                    '\"&gt;&lt;span class=\"vjs-menu-item-text\"&gt;' + val + 'p&lt;/span&gt;&lt;/li&gt;');\n\n            j = i;\n        });\n\n        $(\".quality_ul\").append('&lt;li class=\"vjs-menu-item vjs-selected\" tabindex=\"' + (j + 1) + '\" role=\"menuitemcheckbox\" aria-live=\"polite\" aria-disabled=\"false\" aria-checked=\"true\" bitrate=\"auto\"&gt;' +\n                                '&lt;span class=\"vjs-menu-item-text\"&gt;Auto&lt;/span&gt;&lt;/li&gt;');\n    }\n});\n\n$(\"body\").on(\"click\", \".quality_ul li\", function() {\n    $(\".quality_ul li\").removeClass(\"vjs-selected\");\n    $(\".quality_ul li\").prop(\"aria-checked\", \"false\");\n\n    $(this).addClass(\"vjs-selected\");\n    $(this).prop(\"aria-checked\", \"true\");\n\n    var val = $(this).attr(\"bitrate\");\n\n    var qualityLevels = player.qualityLevels();\n\n    for (var i = 0; i &lt; qualityLevels.length; i++)\n    {\n        qualityLevels[i].enabled = (val == \"auto\" || (val != \"auto\" &amp;&amp; qualityLevels[i].height == val));\n    }\n});\n</code></pre>\n<p>\n```\nI suppose you could say it is a little bit 'hack-ish', but it works.. ",
    "ndhao94": "@halibegic sorry, I'm newbie and I met the trouble. I can't use grunt to create vjs-hls.min.js from https://github.com/streamroot/videojs5-hlsjs-source-handler like what you did. Can you give me some suggestion or tutorial to create this file. Thank you!. @halibegic oh, What a surprise. Last night I did not sleep to build index.html just like you.\nBut even I included 2 file hls.js and videojs-hlsjs-plugin.js into index.html. I still do not see button for changing bitrate level.\nI used this tool to convert .mp4 file to .m3u8: https://github.com/Hemisphere-Project/HLS-segmenter\nWhat am I missing something?. huh. I have checked console and found an error: Uncaught TypeError: player.qualityPickerPlugin is not a function!!!. ",
    "IvanBue": "@DarkMatterCore How can I make it reproduce the highest possible quality in your code? Thank you. ",
    "ravi155": "+1\n. +1\n. +1\n. ",
    "djevo1": "That fixed the problem, however the seekbar doesn't show up on a dvr stream\n. ",
    "SteffenDE": "I can confirm it. FF 44.0.2, Ubuntu 14.04.4.\n. ",
    "nafisakanwal": "Demo is not working at mobile Firefox, \nPlease anyone can helps \nthanks in advance\n. ",
    "GeorgySerga": "\nStream #0:0: Video: h264 (High) ([27][0][0][0] / 0x001B), yuv420p, 1920x1080 [SAR 1:1 DAR 16:9], 25 fps, 25 tbr, 90k tbn, 50 tbc\n    Stream #0:1: Audio: aac (LC) ([15][0][0][0] / 0x000F), 48000 Hz, stereo, fltp, 171 kb/s\n    Stream #0:2: Audio: aac (LC) ([15][0][0][0] / 0x000F), 48000 Hz, 5.1, fltp, 196 kb/s\n\nLooks like it's AAC-LC. Checked with the latest FF stable version (44.0.*) on Ubuntu right now, still crashes.\n. ",
    "Alesiks": "my versions:\nvideojs-contrib-hls - v1.3.5 \nvideo-js-5.6.0\nfirefox 44.0\nand chrome version 47\n. We found that it is our problem. Some problems in transcoding video and creating .ts files. \nThanks.\n. ",
    "HankBrown": "Wish you had said more about what you found. I'm scratching my head with the same issue.\nIn this case I am using files created by the bitmovin encoding service.\nPerhaps the demo page at http://videojs.github.io/videojs-contrib-hls/ could show an ffmpeg command line or similar. The search continues...\n. What if doSomething() no longer exists?\nplayer.hls.xhr.beforeRequest() and videojs.Hls.xhr.beforeRequest()\nhave apparently moved elsewhere.\nNeed to get some extra params into the uri.\n\"This is try and prevent misuse of techs by plugins\" and zero familiarity with the codebase says I better ask how...\nPlease and thank you.\nNext day... updated/re-installed node, npm, videojs and hls-contrib...\nplayer.tech({ IWillNotUseThisInPlugins: true }).hls.xhr.beforeRequest  works now. Awesome!\nvideojs.Hls.xhr.beforeRequest=function(opt) still does not seem to get the event.\n. Thank you for a prompt and helpful answer. \n. ",
    "whatvn": "your server has to reply with full m3u8 url \n. with newest version I no longer can override xhr. beforeRequest by writing my own videojs.Hls.xhr. beforeRequest function. \nThe only way to do this is override that function at runtime : player.hls.xhr.beforeRequest. \nAnd as described in contribute hls doc, we also can override hls.xhr, although it's not recommended, but it's possible. With previous version of contrib-hls, i can override xhr by writing my own videojs.Hls.xhr, but now it's not possible too. \nAny idea? \n. understood!\n. ",
    "veeyenkay": "Is it possible to update the player source code to generate URL in this format? Can you give some pointers on where the URL is getting generated on the player?\n. ",
    "elmehdielkettani": "Unfortunately no (this is IE after all). \nAfter further investigation, SecurityError was fired in the console only Win 8.1 and before even clicking on the play button (so it may not be related). Windows 10 seems to have the same behaviour (buffering but never playing) but no console error.\n. The SecurityError only occurred on a Windows 8.1 virtual machine. But the on Windows 10, no errors in the console.\nI have done further investigation. I could not reproduce this on any of the Mircrosoft free VMs (https://dev.windows.com/en-us/microsoft-edge/tools/vms/). The machine where I can constantly reproduce the issue (and where I was never able to make contrib-hls work) is a Windows 10 Pro Machine. It is a standard installation and the machine has nothing installed but a few testing browsers. I updated it to the latest version of Windows 10 (no more updates as of the writing of this post).\nWindows Pro 10\n- Version: 11.103.10586.0\n- Update Version: 11.0.28\nBefore the update I did yesterday, this was the version of IE11 and had the same issue.\n- Version 11.63.10586.0\n- Update Version: 11.0.26 (KB3104002)\nAs a note, Edge works fine (since it uses native HLS I guess)\n. Turning off Protected Mode does not solve the issue.\n. I have investigated the issue and noticed that it happens with a number of my streams. The common thread between the streams is that the last segment is very small (100ms or so). I hope that helps.\n. Facing the same issue. 'withCredentials' does not seem to work for me either.\n. ",
    "ntamblyn": "I am also getting security warnings for Win 8.1 + 10 for IE 11 using release 2.0.1. \nVia the console its is complaining about line 10029. \nreturn new Worker(URL.createObjectURL(\n        new Blob([src], { type: 'text/javascript' })\n    ));\nI am doing the tests via browserstack\n. ",
    "vfreman": "I have the same Security Error on Win 8.1 / IE 11 and it seems to be related to the fact that IE 10 & IE 11 doesn't allow web workers from blob url :\nhttps://connect.microsoft.com/IE/feedback/details/801810/web-workers-from-blob-urls-in-ie-10-and-11\nI've tested to use the fallback with eval from this answer on stackoverflow and it works.\nhttp://stackoverflow.com/questions/10343913/how-to-create-a-web-worker-from-a-string#answer-10372280\nvar worker = new Worker(scriptPath + 'videojs-contrib-hls.worker.js');\n    worker.postMessage(src);\n    return worker;\nwith this in videojs-contrib-hls.worker.js :\nself.onmessage = function(e) {\n    self.onmessage = null; // Clean-up\n    eval(e.data);\n};\nBut I know encounter another issue line 3880 ( SCRIPT5022: DataCloneError ) :\nthis.transmuxer_.postMessage({\n        action: 'push',\nwhich seems to be related to this issue :\nhttps://connect.microsoft.com/IE/feedback/details/1121134/ie11-throw-a-datacloneerror-when-re-post-a-message-received-from-another-window-even-on-the-same-domain\n. ",
    "viasors": "Same probleme here. Install windows update on virtual machine, that helped us. Works like a charm now..\n. ",
    "jfizz": "I am still seeing this error with Win 8.1 + IE 11 on Browserstack. The issue can be reproduced here: http://videojs.github.io/videojs-contrib-hls/. Seems to be related to an issue with Win 8.1 as Win 7 + IE11 and Win10 + IE11 both work.. Sorry about that, I wasn't clear. I am using the latest version of videojs-contrib-hls to play HLS/fmp4 streams. I recently did some browser testing and was not able to get fmp4 streams to work on a few browsers on Browserstack. Also note that the default video (non fragmented mp4) worked fine on all the browsers below.\nPlayer: http://videojs.github.io/videojs-contrib-hls/\nPlaylist: https://d2zihajmogu5jn.cloudfront.net/advanced-fmp4/master.m3u8\n\n\nWin10 - IE 11 \nActually works. I was using the wrong version of windows when I tested initially.\n\n\nWin10 - Edge 14\nNo error, but showed the loader for a minute before I gave up. I can confirm that the playlist file was downloaded successfully by checking out the network panel.\n\n\nWin10 - Edge 15 (Latest)\n{\n  code: 4,\n  MEDIA_ERR_ABORTED: 1,\n  MEDIA_ERR_CUSTOM: 0,\n  MEDIA_ERR_DECODE: 3,\n  MEDIA_ERR_ENCRYPTED: 5,\n  MEDIA_ERR_NETWORK: 2,\n  MEDIA_ERR_SRC_NOT_SUPPORTED: 4,\n  message: \"The media could not be loaded, either because the server or network failed or because the format is not supported.\",\n  status: null\n}\n\n\nGalaxy S7 - Chrome 58 (!!MediaSource === true)\n{\n  code: 3,\n  message: \"The media playback was aborted due to a corruption problem or because the media used features your browser did not support.\"\n}\n. \n\n",
    "mryarbles": "Still seeing this issue on Browser stack. Windows 8.1 and IE 11.\nIn VirtualBox IE 11 windows 8.1 it's working fine. \nSeems to be related: \nhttps://connect.microsoft.com/IE/feedback/details/801810/web-workers-from-blob-urls-in-ie-10-and-11. ",
    "matheusmoreira-hotmart": "The error is occurring due to the use of a decrypter that runs on a web worker. This issue can be validated by putting a breakpoint on the line 619 of the builded script.\nthis.decrypter_ = (0, _webworkify2['default'])(_decrypterWorker2['default']);\nWhich i think that matches with the line 278 of the following file:\nhttps://raw.githubusercontent.com/videojs/videojs-contrib-hls/9b95d1edb1b6fb7a48573a6c05f74614904c3b7a/src/master-playlist-controller.js\nAs @vfreman has said, the issue seems to be solved by using eval, same solution adopted by the following lib:\nhttps://github.com/padolsey/operative#no-worker-via-blob-support. ",
    "Naouak": "Safari and Edge play this correctly.\nI look if there is an easy way to get this issue right but it seems XHR\ndoesn't tell if there was a redirection.\nOn Wed, Feb 10, 2016 at 7:24 PM, Gary Katsevman notifications@github.com\nwrote:\n\nHm... that's an interesting problem. The spec for the 302 status code\ntells us to not use the new URI for the new requests, 301 tells us to use\nthe new URI. However, segments and media manifests are relative to the\nlocation of the m3u8 file, so, if the playlist was redirected, do we use\nthe new URI for the playlist or our original one?\nI assume that Safari/iOS is able to play this correctly?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/videojs/videojs-contrib-hls/issues/548#issuecomment-182515693\n.\n. \n",
    "dcamillo": "Hi Naouak,\nAre you sure you are able to play this on EDGE ?\nI have this issue on IE-EDGE.\nSo I am testing the index.html\nhttps://github.com/videojs/videojs-contrib-hls/blob/master/index.html\nI clone the project using git and at first attemp does not matter URL I place in the TextBox it does not play the new URL, always the one was loaded in the Video tag.\nAm I doing something wrong ? Are you guys able to play it successfuly ?\n. ",
    "svenspielvogel": "I addressed this in my fork. The problem is, that wowza hls chunks seem to be too short, so the buffer misses some milliseconds. this results in a loop.\nsee https://github.com/mevango/videojs-contrib-hls\n. see https://github.com/videojs/videojs-contrib-hls/pull/561\n. Hey @ROKAISAKKON , @gak2 ,\nsorry for not replying yet.\nDid you use my current fork? I merged 2.0.1 into it.\nhttps://github.com/mevango/videojs-contrib-hls\nafter npm install you need to run npm run build.\nFeel free to ask if it didn't build. I could provide you a dist then.\n. @gak2 there you go\nvideojs-contrib-hls.zip\n. videojs-contrib-hls-mevango.zip\ntry this @gak2 \n. i was able to fix it in https://github.com/videojs/videojs-contrib-hls/pull/561. Any better ideas?\n. Hey David. The problem is, that in some cases, especially when the video itself might be missing some audio frames the Wowza tends to pass the streams damaged as they are. This might lead to a gap between segments. What does that mean? Let's say Segment 1 Ends at Timestamp 5.300 - then it might happen, that the next segments starts at 5.350. This results in two timerange object. Or, what i discovered yesterday to even more TimeRanges. \n1. Problem: Video stops playing since there is a gap\nSolve: if next timerange isnt far away (<0.5secs) jump over gap\n2. Problem: Video loads segments in a loop: e.g. media_0.ts >> media_0.ts and so on.\nSolve: Find real buffered end and get media index - my approach might still lead to a loop if we have 3 time ranges, but are still playing in the first time range. I'm gonna fix this pretty soon. I've to iterate through all timeranges. another solution, maybe the better one would be not to create a second timerange. Actually I wasn't able to figure it out in that short time I had, so this might be a good way. Any ideas on that?\n3. The Plug-In doesn't always throw correct errors. e.g. loosing network or poor network (GPRS 64kBit/s)\nSolve: setting up a retry count and throw error if it occurs.\n. Another thing. Travis fails. But this is because of 9d075a3. At this commit i set up my own 404 handling. Because the plugin throws an instant error even if enough buffer is present.\nJust imagine followin use case: You sit in a Metro and at Station 1 you have 4G so you are buffering. Then you drive further and suddenly network falls away. Then, just 5 seconds later you get 4G again.\nWhat happens at the old build and the current Tests: Even with 30 seconds in Buffer a miss on loading a segments leads to a error.\nMy Approach lets you still play the stream as log as you have buffer. (I love this behavior from the Amazon Instant Video Player). And as soon as you have Network the same segment gets buffered. After stalling too long, i will still throw a error 2.\n. Can you provide the Video. I'd like to have a look into it. @nickygerritsen \n. ",
    "ROKAISAKKON": "@gak2 try v2.0.1  and video js last version \nhttps://github.com/videojs/videojs-contrib-hls/releases  \n@svenspielvogel thank so much\n. @gak2 try  https://github.com/videojs/videojs-contrib-hls/releases/download/v2.0.1/videojs-contrib-hls.min.js  and without modifying it\nWork for me.\n. @gak2 try Video.js 5.7.0\n. @gak2\n\nIt work!\nCan you sent all file to me ?\n. ",
    "mikhoul": "@gesinger \n\nWould you be able to give the latest version (as of this comment, v4.1.1) a shot? If it's still a problem, would you be able to provide a reduced test case using this template and a sample stream?\n\nI'm new to Video.js and I tried to set-up a simple instance of video.js on Jsbin.com and with MP4 file npo problem but when I tried to use an M3U8 stream to test it,  I encountered problems... :disappointed: \nI was looking to find why it happen, if I do something \"wrong\" browsing the \"Issues\"  here and I found your template :smile_cat: \nSo I tried my stream http://www.streambox.fr/playlists/test_001/stream.m3u8 in your template and the same problem happened sadly, at least I know now the problem was not because my vdeo.js instance had an error.\nCould you help me to find why this error happen with this stream ?   Why the stream don't play but keep loading .ts files in the browser console ? \nThe stream work fine on other players like mediaelement or VLC.  I tried it in Firefox and Chrome with the same result.\nRegards :octocat: . Here's the result I have in VLC:\n```\nmpeg4audio info: AAC channels: 1 samplerate: 8000\ndirect3d9 error: SetThumbNailClip failed\nadaptive info: Encountered discontinuity\ncore error: ES_OUT_SET_(GROUP_)PCR is called too late (pts_delay increased to 8000 ms)\nmpeg4audio info: AAC channels: 1 samplerate: 8000\ndirect3d9 error: SetThumbNailClip failed\nts error: libdvbpsi error (PSI decoder): TS duplicate (received 0, expected 1) for PID 4095\nts error: libdvbpsi error (PSI decoder): TS duplicate (received 0, expected 1) for PID 4095\nts error: libdvbpsi error (PSI decoder): TS duplicate (received 0, expected 1) for PID 4095\nts error: libdvbpsi error (PSI decoder): TS duplicate (received 0, expected 1) for PID 4095\nts error: libdvbpsi error (PSI decoder): TS duplicate (received 0, expected 1) for PID 4095\nts error: libdvbpsi error (PSI decoder): TS duplicate (received 0, expected 1) for PID 4095\nts error: libdvbpsi error (PSI decoder): TS duplicate (received 0, expected 1) for PID 4095\nts error: libdvbpsi error (PSI decoder): TS duplicate (received 0, expected 1) for PID 4095\nts error: libdvbpsi error (PSI decoder): TS duplicate (received 0, expected 1) for PID 4095\ndirect3d9 error: SetThumbNailClip failed \n```\nThe stream cut lot of time... but it should at least play minus the cut but for me I'm not able to have it play with http://videojs.github.io/videojs-contrib-hls/# .. Thanks for the help @gesinger ,\nHere's a screenshot of what happen when I enter the full URL \"http://chaine_tva_uls-lh.akamaihd.net/i/tvago_1@410563/master.m3u8?hdnea=st=1487363778~exp=1487363868~acl=/i/tvago_1@410563/*~hmac=3c8f8f06910cdcbc7779ee67c659254001518c3a23d30fb2e8f1a7d242b46625\" and press \"Load\"\nIn Firefox: http://i.imgur.com/Pn1aM0y.png + http://i.imgur.com/GbnPoli.png\nIn Chrome: TS Fragment are loading but I have a Black Screen: http://i.imgur.com/ZI6sj48.png\nWhat I'm doing wrong ?\nRegards :octocat: . Hi @gesinger ,\nI tried again but I have the same results with both Firefox and Chrome.\nI can confirm that the Stream is not the problem since I have no problem at all playing the  stream with FlasHLS with Video-js-swf on Firefox or Chrome.\nIf you need more information just ask.\nRegards  :octocat: . @aranondo \nI don't know how to do that exactly, could you show me with an example on JsBin ?\nRegards ! :octocat:  . @onigetoc   It's look like you have almost the same issue I have here:  https://github.com/videojs/videojs-contrib-hls/issues/1021\nI tried your URL and I can see the stream loading but nothing appear in the player sadly.\nRegards. :octocat: . The best I found to test a stream is to use VLC 3.x beta , this way you can see quickly if the stream is protected or not and you can see also what kind of stream it is via the Tools menu option.\nI'm just beginning playing with the streams and players, I've see that some stream that DON'T work with \"videojs-contrib-hls\" will work with the \"Flashls\" plugin, to test the stream just go here:  http://www.flashls.org/videojs/flash_demo.html and copy paste the URL.\nIf you like it, it's not hard to install the plug-in but it is VERY hard to find clear information to do it... \nTo install \"Flashls\" plugin: You MUST use this fork: https://github.com/tommyh/videojs-flashls anything else will NOT work.\nHopping it will help you to have most of your your streams to work.\nYou can also take a look at \"Clappr\" it is also a very good small video/audio player too: https://github.com/clappr/clappr\nRegards ! :octocat: . ",
    "incompl": "LGTM\n. ",
    "TylerZubke": "This is still happening for me. See #834. \nI tried @svenspielvogel fixes and the stream freezes with no error or anything indicating what happened. It also seems to happen more frequently than what occurs in my issue.\n. Sorry I forgot to update this. I've done a lot more digging and this is definitely a server side issue. \nI don't know if it's possible, but it would be nice if the plugin could continue streaming and not error out when one .ts file 404s. If this is something that you guys would consider implementing I can change this to a feature request or something. If not, I'll just close it. \nI know there are other people having similar problems with Wowza so I wanted to briefly document the problem here in case it helps anyone. When a request is made for a chunklist (.m3u8), the .ts files listed in the response for the chunklist MUST go to the same instance. We have our EC2 instances behind a load balancer, and occasionally the load balancer would send the requests for a .ts file to a different instance which caused the 404. Enabling stickiness on the load balancer is the solution.\n. I have also noticed this issue.\nAre you able to continue watching a live stream after pausing for more than 20 seconds or so? If I pause a live stream while watching the network tab, once it gets to the point that it is only pulling down .m3u8 files I hit play and get a loading spinner and the video never resumes playing. \n. I'm also wondering on the status of this. There are certain cases where the vast-vpaid plugin loads a preroll and this error gets thrown.. ",
    "rafaelmcgs": "Hi there, Im encoding audios with HE-AAC and creating MP4 files...\nTo make the playlist files, im using nimble and smil, what is automatic...\nI wanna force the code to read the Codec attribute \"mp4a.40.5\" without change playlists, because all of them are using HE-AAC...\nI just wanna change the default value (AAC) to my own (HE-AAC)\nAny Idea? Where I can set this in the code?\n. ",
    "tomaj": "Same problem here. Safari is working perfect, but Chrome freeze as @kchris78 mentioned.\nVersions:\n- Video.js 5.5.3\n- videojs-contrib-hls - v1.3.7\n. ",
    "luklapp": "I can reproduce this issue. Video.js 5.7.1, videojs-contrib-hls 1.3.11 (and also 2.0.0). But it's working 1-2 seconds \"longer\" with 2.0.0\n. ",
    "kchris78": "Upgraded the video and videojs-hls to version 2.0.1 but the problem is still there :(.\n. ",
    "bson": "We're seeing the same.  If we keep reloading it sometimes work, maybe 20-25% of the time.  If we use the network console tab to set a high latency, > 200ms, it fails consistently - as in, never starts up properly.  Verified it occurs in Chrome on OSX, while Safari is fine.  IE is fine on Windows; Chrome fails.  I don't think we're tried Firefox on either yet.\n. We narrowed down the problem to calling .load() from the .ready() callback.  If we only use .src() and follow it with .play() if we want to autoplay, then it works fine.\n. ",
    "minh1903": "Thanks @gkatsev,  I hope this issue will be fixed as soon as.\n. @dmlap where can I increase the number of segments in window ? \n. @dmlap Thanks :+1: \n. ",
    "mimcz": "Isn't the problem with your source? I tried this one and it works ok on your test version:\nhttps://playertest.longtailvideo.com/adaptive/wowzaid3/playlist.m3u8\nIt looks like you don't have CORS (Access-Control-Allow-Origin') on your source.\n. ",
    "keylase": "with this source https://playertest.longtailvideo.com/adaptive/wowzaid3/playlist.m3u8 stream is frozen after 30 seconds.\nSource with similar problem http://btv-net.mediacdn.ru:8080/otv/index.m3u8\nconsole.log:\nError Script error. (line 0)\nvideojs.hls.min.js:3 Uncaught InvalidStateError: MediaSource.addSeekableRange() can only be invoked when the duration is Infinity\n. ",
    "michael-riha": "Thanks @gkatsev  for this quick response.\nIf I may, i have an additional Question on that subject.\nThis CORS Problem results because of the *.m3u Parser, right?\nIf i would Whitelist the Domain of the HLS Stream (in Adobe Cordova) theoretically it should work?\nOr are there any additoonal CrossDomain Requests i have to watch out for, in this lib?\nthx in advance!\n. it is the same in Cordova, but i guess if we add the video-CDN's Domain to the CORS-Whitelist it might work. THX a lot!\n. ",
    "vietlongn": "+1\n. Same here, it's seem like videojs-contrib-hls messed up with HE-AAC codec\n. ",
    "juliomenendez": "Any solution for this yet?\n. @alonfixler did you integrate hls.js with video.js or just went without video.js entirely?\n. ",
    "creativefull": "+1\n. ",
    "sashee": "This just bit me too. Could you find a workaround?\n. ",
    "t-n": "No, not yet.\n. This seems to be fixed with contrib-hls 2.1.1 and mux.js 2.1.2\n. There is a bug in Chromium regarding playing HE-AAC streams with an AAC-LC header, which is vaild according to the standard but breaks in Chrome. (https://bugs.chromium.org/p/chromium/issues/detail?id=534301)\nYou can easily test to see if this is the issue by editing the m3u8 and changing all mp4a.40.2 to mp4a.40.5. \nIf it works you either have to update all m3u8 or re-encode with the correct settings.\nOr you could do something like this, but only for the streams where it's needed,\nlet ParseStream = videojs.m3u8.ParseStream;\n    ParseStream.prototype._originalPush = ParseStream.prototype.push;\n    ParseStream.prototype.push = function(line) {\n      line = line.replace(/mp4a\\.40\\.2/, 'mp4a.40.5');\n      this._originalPush(line);\n    };\nAnd it actually seems that this bug is finally fixed in Chrome Canary.\n. ",
    "ZacharySato": "Having the same issue. \nI try to bind player rebuilding on 'error' event, but in this case 'error' isn't actually triggered. \nStrange thing is that 'InvalidStateError' appears randomly across correct 'CODE:4 MEDIA_ERR_SRC_NOT_SUPPORTED'.\nI.E:\n\nHere everything is fine twice.\n. ",
    "mrmckeb": "We're also seeing this issue intermittently, but it doesn't appear to be causing any actual problems in the video streams.\n. We're experiencing the same issue, not sure how to resolve.\n. ",
    "askaliuk": "I confirm this issue. Thank you everybody. Very helpful.\n. Thank you very much for quick response.\n1. new currentTime returning 0. It's simple to repeat. Just call player.currentTime(player.bufferedEnd()); at any point of time. It's basically seeking to the future attempt. You may also try player.currentTime(player.bufferedEnd() + X); to see the same behaviour. \n2. Thank you for an advice about seekable. I'll work on this approach.\n. Yes. seekable is exactly what I need\n. ```\nvar player = ....\nvar _getSeekable = function() {\n        var seekable = null;\n        if (player.seekable().length > 0) {\n          seekable = player.seekable().end(0);\n        }\n    return seekable;\n},\n\nvar customButtonClickHandler = function() {\n   var seekable = _getSeekable();\n   player.currentTime(seekable);\n}\n``\n. http://stackoverflow.com/questions/40225756/how-to-detect-http-response-code/40269301\n. @gesinger I didn't try new version. I will as soon as I can. . Looks like it was fixed in https://github.com/videojs/videojs-contrib-media-sources/pull/113\n. @dmlap thank you. May I ask when this change will go intovideo-contrib-hls` release?\nI saw this commit:\nhttps://github.com/videojs/videojs-contrib-hls/commit/2165f9dc0090449fa8106fcf361730df001af528\nBut videojs-contrib-media-sources was not updated.\n. @dmlap just tested. Unfortunately your commit does not fix the issue.\n. Thank you for clarification. ",
    "aquu": "@gesinger I just noticed that I can reproduce that error if I get 404 response straight from the streaming server (in my case Wowza) but if url points to cloudfront (as in that template), then videojs handles it right.. @gesinger I tested it on another computer and I can't reproduce it now with our servers.. However I get same error when hosting that template code with php.\nI'm running local server on Ubuntu 16.04 with php -S localhost:8000 and when I open browser I get following on the console. No 404 error is thrown.\n\n. I just noticed that adding this MediaSource.isTypeSupported -check leads problems with HLS playlists using EXT-X-VERSION: 3 that is default version in Wowza Streaming Engine 4.x\nAt least on Chrome MediaSource.isTypeSupported returns false for codec \"avc1.66.31,mp4a.40.2\" although it's playing normally. This causes excluding all playlist files.\nThis problem seems to be fixed if I change EXT-X-VERSION to 4 because then it reports codecs in this format: \"avc1.42001f,mp4a.40.2\" and MediaSource.isTypeSupported returns true.\nAbout changing EXT-X version https://www.wowza.com/forums/content.php?380-How-to-change-the-EXT-X-VERSION-for-Apple-HTTP-Live-Streaming\nHere is examples of playlist used\n```\nEXTM3U\nEXT-X-VERSION:3\nEXT-X-STREAM-INF:BANDWIDTH=2289146,CODECS=\"avc1.77.32,mp4a.40.2\",RESOLUTION=1280x720\nchunklist_w1345153233_b2289146.m3u8\nEXT-X-STREAM-INF:BANDWIDTH=1510142,CODECS=\"avc1.66.31,mp4a.40.2\",RESOLUTION=960x540\nchunklist_w1345153233_b1390142.m3u8\nEXT-X-STREAM-INF:BANDWIDTH=740142,CODECS=\"avc1.66.30,mp4a.40.2\",RESOLUTION=640x360\nchunklist_w1345153233_b690142.m3u8\n```\n```\nEXTM3U\nEXT-X-VERSION:4\nEXT-X-STREAM-INF:BANDWIDTH=3354411,CODECS=\"avc1.4d0020,mp4a.40.2\",RESOLUTION=1280x720\nchunklist_w663865548_b3354411.m3u8\nEXT-X-STREAM-INF:BANDWIDTH=1510164,CODECS=\"avc1.42001f,mp4a.40.2\",RESOLUTION=960x540\nchunklist_w663865548_b1390164.m3u8\nEXT-X-STREAM-INF:BANDWIDTH=740164,CODECS=\"avc1.42001e,mp4a.40.2\",RESOLUTION=640x360\nchunklist_w663865548_b690164.m3u8\n```\n. ",
    "poohitan": "Same issue.. @gesinger how are things going with this issue?. @gesinger cool, waiting for it to be merged. Thanks for the effort!. ",
    "AndriyOleksyuk": "The same issue for me.\nFor me it is critical situation because i can not catch error from player and handle it.\nMore info:\nOn PC player request for playlist.m3u8 and first chunklist even when preload set to \"none\". But it should not to do it (you can check how it works on mobile). And if machine for request for playlist.m3u8 is unavailable we will have error described above.  \nSo preload is also important thing. Because if you have few players on page each of them makes 2 unnecessary request even before any player start to play. Thats is not good for analytics and performance.. @gesinger, yes. ",
    "icetronics": "Hi @gesinger! Thanks for the fix though I experience that the standard error media event does not get triggered on the underlying video element. Is that possible? Is there another way to attach an error handler on the player? Thank you in advance!. Thanks for this @lionxcr, I was able to set it up following your guide.\nIs there no other way to integrate it more seamlessly without additional Webpack config?\nThanks!. Thanks @gkatsev! Would you be able to provide an example or some further pointers so I could try setting it up?. ",
    "rishigohil": "I am having the same issue and it seems that it's not handled with the latest release. The video keeps on loading and does anyone know if we can handle this error from our end until we get support from the plugin? Or am I missing something?\n\n. http://jsbin.com/zidelo/edit?html,js,output\nHere you go. You can also check here. \nhttps://cobweb1.fau.edu/Demos/VideoJs.html. @gesinger Any luck?. Alright so turns out that it's the issue of videojs-contrib-hls.js version 5.3.3. It works fine with the CDN version of 5.5.3. I've updated the bin with my version of videojs-contrib-hls.js and it gives the error. Thanks. for the help though. \nhttp://jsbin.com/miguyaq/1/edit?html,js,output\n. ",
    "vpezeshkian": "Version 2.0.0\nDo you have ETA?\n. :+1:\nCould you please notify me on this thread? \nThank you.\n. ",
    "gaglage": "solved? any news?\n. Thansk for the answer.\n I'm getting an error (Uncaught TypeError: Cannot convert undefined or null to object,      var cacheKeys = Object.keys(cache);). Maybe webpack configuration. I'll try to find the solution! thanks\n. Hi @AdamTyler I fixed the issue via #600\n. Thanks a lot.  I'll chek it because I'll need it soon. Only a consideration the property in angular-cli.json  \"scripts\" .\n. ",
    "nehakhandelwal": "I too facing the same issue .\n. I am facing the same and added below code too.\nresolve: {\n  alias: \n{ 'videojs-contrib-hls': dirname + '/node_modules/videojs-contrib-hls/dist/videojs-contrib-hls', \n    webworkify$: 'webworkify-webpack'\n  }\n},\n and getting this error\n19:31:03.939 TypeError: _videoJs2.default is undefined\n[72]<() bundle.js%20line%205005%20%3E%20eval:8312\n[72]<() bundle.js%20line%205005%20%3E%20eval:7848\ns() bundle.js%20line%205005%20%3E%20eval:7\ns/<() bundle.js%20line%205005%20%3E%20eval:7\n[71]</<() bundle.js%20line%205005%20%3E%20eval:7668\n[71]<() bundle.js%20line%205005%20%3E%20eval:7640\ns() bundle.js%20line%205005%20%3E%20eval:7\ns/<() bundle.js%20line%205005%20%3E%20eval:7\n[76]</<() bundle.js%20line%205005%20%3E%20eval:8886\n[76]<() bundle.js%20line%205005%20%3E%20eval:8870\ns() bundle.js%20line%205005%20%3E%20eval:7\ns/<() bundle.js%20line%205005%20%3E%20eval:7\n[94]</<() bundle.js%20line%205005%20%3E%20eval:14668\n[94]<() bundle.js%20line%205005%20%3E%20eval:14627\ns() bundle.js%20line%205005%20%3E%20eval:7\ne() bundle.js%20line%205005%20%3E%20eval:7\n<anonymous bundle.js%20line%205005%20%3E%20eval:7\n bundle.js%20line%205005%20%3E%20eval:7\n bundle.js%20line%205005%20%3E%20eval:7\n bundle.js%20line%205005%20%3E%20eval:1\n bundle.js:5005\n__webpack_require() bundle.js:556\nhotCreateRequire/fn() bundle.js:87\n bundle.js%20line%204993%20%3E%20eval:29\n bundle.js%20line%204993%20%3E%20eval:1\n bundle.js:4993\nwebpack_require() bundle.js:556\nhotCreateRequire/fn() bundle.js:87\n bundle.js%20line%204081%20%3E%20eval:21\n bundle.js:4081\nwebpack_require() bundle.js:556\nhotCreateRequire/fn() bundle.js:87\n bundle.js%20line%20691%20%3E%20eval:19\n bundle.js:691\nwebpack_require() bundle.js:556\nhotCreateRequire/fn() bundle.js:87\n bundle.js:588\nwebpack_require() bundle.js:556\n bundle.js:579\n bundle.js:1\n1 bundle.js%20line%205005%20%3E%20eval:8312:1\n. this is giving the error of \nwebworkify-webpack: Could not locate module containing worker function! Make sure you aren't using eval sourcemaps and that you pass named functions to webworkify-webpack!\n. Hi I have done code like below:\nhtml : \nhtml\n<video id=\"really-cool-video\" className=\"video-js vjs-default-skin\" preload controls width=\"600\" height=\"300\">\n            </video>\nJS: \n``` js\nimport video from 'videojs-contrib-hls';\nimport videojs from \"video.js\";\nwindow.videojs = videojs;\nlet player = videojs(\"really-cool-video\", {html5: {\n     hls: {\n     withCredentials: false}}});\nplayer.src({\n     src: \"http://clips.vorwaerts-gmbh.de/big_buck_bunny.webm\",\n     type: 'video/webm'\n     });\n let hls = player.tech({ IWillNotUseThisInPlugins: true }).hls;\npalyer.play();\n```\nand this hls is coming undefined.\nme too have the same issue and apply all things u have suggested. still facing same issue.Please suggest.\n. browser is mozila and chrome\n. ",
    "AdamTyler": "@gaglage did you find a workaround for your issue? I'm seeing the same error. @gkatsev is there a quick and dirty workaround for the meantime to force Safari to use contrib-hls?\nI tried making supportsNativeHls return false but that didn't seem to do the trick.\n. @forbesjo has there been any progress on this investigation?\nIf it is still going to be a while, can you point me to a quick and dirty to force the plugin over the native browser hls?\n. Thanks for the reply. That does get contrib-hls to work over the native implementation (testing in Safari 9). It worked using the source element too.\nThere are some issues I'm seeing though. It doesn't seem to maintain the buffer so when you seek backwards it gets error code 3 but I guess that is to be expected since the plugin hasn't been developed to be used instead of the native. \ud83d\ude15 \n. ",
    "momkin": "Hello\ni don't know why its working with flashhls and daylimotion hls script\nbut its not working with yours !\ncan you please check why ?\n. thank you very much !\nOn 11 March 2016 at 15:57, Dylan Dove notifications@github.com wrote:\n\nI noticed that this is an encrypted stream. The second segment, where the\nlag in playback is seen, is failing to decrypt properly on my hls-fetcher\nthat uses the same decryption that we use in contrib-hls. The 4th segment,\nwhich is a 4 second segment, also is not decrypting properly, thus causing\nplayback to stall. I am looking into what is going wrong during decryption\nand will keep you posted.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/videojs/videojs-contrib-hls/issues/583#issuecomment-195400357\n.\n. also i'm using this for streaming\nhttps://github.com/kaltura/nginx-vod-module\nif this helps !\n\nOn 11 March 2016 at 16:02, MOHAMED KHANKHAM payfortr@gmail.com wrote:\n\nthank you very much !\nOn 11 March 2016 at 15:57, Dylan Dove notifications@github.com wrote:\n\nI noticed that this is an encrypted stream. The second segment, where the\nlag in playback is seen, is failing to decrypt properly on my hls-fetcher\nthat uses the same decryption that we use in contrib-hls. The 4th segment,\nwhich is a 4 second segment, also is not decrypting properly, thus causing\nplayback to stall. I am looking into what is going wrong during decryption\nand will keep you posted.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/videojs/videojs-contrib-hls/issues/583#issuecomment-195400357\n.\n. https://github.com/kaltura/nginx-vod-module\n\n\nOn 11 March 2016 at 16:34, Dylan Dove notifications@github.com wrote:\n\nIt says link not found.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/videojs/videojs-contrib-hls/issues/583#issuecomment-195417938\n.\n. Hello any news ??\n\nits working perfectly with https://github.com/dailymotion/hls.js/releases\n. http://s2.lody.to/hls/16ar.mp4/index.m3u8\nhttps://www.avast.com/sig-email?utm_medium=email&utm_source=link&utm_campaign=sig-email&utm_content=webmail\nGaranti\nsans virus. www.avast.com\nhttps://www.avast.com/sig-email?utm_medium=email&utm_source=link&utm_campaign=sig-email&utm_content=webmail\n<#DDB4FAA8-2DD7-40BB-A1B8-4E2AA1F9FDF2>\nOn 26 May 2016 at 15:27, David LaPalomento notifications@github.com wrote:\n\n@momkin https://github.com/momkin I'm no longer able to access your\nstream. Can you provide a link to an m3u8 that's still up?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly or view it on GitHub\nhttps://github.com/videojs/videojs-contrib-hls/issues/583#issuecomment-221886665\n. \n",
    "theleon": "Hi, any updates on that?. ",
    "ChrisWhiten": "@dmlap The URL provided in the example (http://204.101.47.141:8080/cameras/IYnHqNXQg3n474bQ/video.m3u8?begin=1457326800000&end=1457413199999&stream=82e97bc4-5f24-4b3d-8548-63da11ab947e) should be publicly accessible.  \nI've spent some time reviewing it with a colleague and we've found some interesting details.  This particular stream was created by a DVR using an HTTP stream straight from VLC (using a command like vlc -vvv --loop my_footage.ts --sout '#standard{access=http,mux=ts,dst=:8812}').  On that same DVR, streams recorded from a true RTSP stream work perfectly with this setup.  Perhaps there is something different about the way VLC handles this\n. ",
    "leighfarrell": "I seem to be having the same issue with some of my HLS files. Certain ones work great in Chrome, while others trigger the above errors. They're all being instantiated the same way, which leads me to believe it might have to do with how the videos are being created/encoded. Any progress/leads on this?\n. +1\nI'm encountering the same issue. Others have reported video playback freezing, however I haven't been able to recreate. It's primarily happening in IE, though we have a few reports of it occurring in Chrome.\n. ",
    "mpaldheCM": "The tests in manifest have the same format. So I doubt if we are missing any bytes. Also the first three or four byte ranges work perfectly fine. So why does it fail only around the 8th/9th second?\n. I missed some information.\nI did notice that a lot of xhr requests are timing out because the timeout in xhr call is only around 50 ms for those.\nSo I updated the code to:\n    timeout: Math.max((segment.duration * 1.5), 0.5) * 1000,\nso that the timeout is at least 500 ms.\n    Original code: timeout: (segment.duration * 1.5) * 1000,\nPS: Editing the original post to add this.\n. I am trying to debug this issue, and I think this can be a relevant cause?\nhttp://stackoverflow.com/questions/28105950/html5-video-stalled-event\n. ",
    "SudoPlz": "This looks exactly what I was looking for I'll test it immediately, thank you tenacex!\n. Great I will be waiting for this, thanks !\n. Also it would really save some time for me if you told me which files I need in order to run it in a javascript file instead of a as a command in the terminal.\n. I guess that was just my lazy part talking. I wondered if there was a quick way to discard all the code that has to do with the command line, and just use the library from javascript code. \n. Awesome, exactly the answer I was looking for, thanks again man..!!\n. npm install live-hls-fetcher works by the way, is it your latest code (because you have lots of branches)\n. I'm using \n\"dependencies\": {\n    \"live-hls-fetcher\": \"tenacex/hls-fetcher#livestream-support\"\n  },\non my package.json and I'm positive that I receive the correct branch.\n. Awesome, I did exactly what I wanted to do, now I have another quick question (last one I promise..) are you aware of any code that binds the ts files into 1?\n. ",
    "mattblaha": "I just tried it on several more Macs and with several more sets of ears. We just used the test page here:\nhttp://videojs.github.io/videojs-contrib-hls/\nIt's really the perfect example. Listen right as the count down hits one and the rocket engine fires up. The first pop shows up right there, but I can't hear it in Chrome or Safari, just Firefox.\n. I recently noticed a this issue seems to have been fixed, perhaps inadvertently by some other change.\nRunning a side by side comparison with an old install and a new install, both quite identical except for the videojs/videojs-contrib-hls versions, the pops are gone with the new code but present with the old.\nCan anyone else verify the same results?. @sobytes \nI believe this is the same issue as #592. I'm not sure if this is the more info you need, but I've noticed the popping/slipping seems to occur exactly as segments are changed. If the segments are ten seconds each, listen closely and you can hear it at every ten second interval.\nDebugging this is beyond me, but hopefully that will give someone else a clue as to what's going on.\n. ",
    "carloscarnero": "On FF 44.0.2 on Linux (Fedora) I confirm that audio discontinuities can be heard from the public test. The same happens in an internal VoD source, where each segment is 10 seconds, and the pops are audible at each segment start.\n. It turns out that @imbcmdth is correct. Upon closer examination, it became apparent that I was using the wrong playlist. Manually creating a simple Master Playlist with the proper tags was all I needed.\n. ",
    "waster": "Same for me in Firefox for HLS in FF 45.0 (Windows/Linux) for audio only stream.\n. The same problem for me for audio-only stream with the latest videojs 5.8.0 and videojs-contrib-hls 2.0.1 in FF 45.0 (Windows) but not in Chrome. Player starts to download ts-segments infinitely however stream is playing. It happens with flash tech (video-js.swf) in particular. BTW, sound alos pops, while next ts-fragment is downloaded.\n. I tried to do npm test and it's failed:\n/usr/local/src/videojs-contrib-hls/src/master-playlist-controller.js:241:13: Unexpected \"todo\" comment.\n. The same for me for audio only ts stream.\n. ",
    "PNixx": "+1 in Firefox 45.0.1 on OS X 10.11.4\n. ",
    "JackSimth": "I am seeing the same thing, with both audio and video (combined stream).  I'm fortunately testing with a CentOS server, and have full root access.  I actually went through and compared the apache logs to the underlying files:\nWhat seems to me to be going on is that the player isn't actually buffering the segments in FireFox (that, or it stops playing to pull the next - either way).  The skip happens at segment borders, and when I went through the apache logs, my test client was pulling the segments every nine seconds, while the m3u8 file was reporting that the segments were eight seconds long (I'm rounding in both cases - 8.015 is close enough to 8 for my purposes, and the apache logs in question had a resolution of 1 second, but still, it was pulling less often than it should have).  I was also able to confirm this is what's going on by setting things up to exaggerate the issue - setting the stream to 8 mbps and then using tc (linux traffic control settings command) to limit the server to 10 mbps on that card exaggerated the issue to a serious degree - the fraction of a second skip I'd been dealing with became about six seconds long.  \nSo my conclusion is that it's either not actually downloading segments before they're needed, or it stops playing while it's downloading segments.  I'm only seeing this behavior in FireFox - I'm not seeing it in Chrome or Edge.\n. I should probably add a short log snippet showing the behavior from when I was doing some testing... sorry for the delay, I don't always think things through.\nApache log:\n10.0.0.95 - - [23/Aug/2016:08:00:02 -0700] \"GET /hlstest/main6.ts HTTP/1.1\" 200 7294588\n10.0.0.95 - - [23/Aug/2016:08:00:11 -0700] \"GET /hlstest/main0.ts HTTP/1.1\" 200 9155600\n10.0.0.95 - - [23/Aug/2016:08:00:21 -0700] \"GET /hlstest/main1.ts HTTP/1.1\" 200 7279924\n10.0.0.95 - - [23/Aug/2016:08:00:31 -0700] \"GET /hlstest/main2.ts HTTP/1.1\" 200 7230668\nThe m3u8 file that ffmpeg was spitting out at the moment of that last entry:\nEXTM3U\nEXT-X-VERSION:3\nEXT-X-TARGETDURATION:10\nEXT-X-MEDIA-SEQUENCE:20\nEXTINF:8.003000,\nmain6.ts\nEXTINF:9.803000,\nmain0.ts\nEXTINF:8.002000,\nmain1.ts\nEXTINF:8.003000,\nmain2.ts\nEXTINF:8.002000,\nmain3.ts\n. Huh, that's interesting... following apache logs while looking at the underlying files with a simple while true loop:\nIt only seems to happen when the player is loading just the oldest entry.  For whatever reason, it doesn't always pre-load the three I've got listed.  When it starts with the middle or last entry, everything's fine for a long, long time.  \nIs there any way to change the player behavior such that it tries to load at least three segments always (maybe an initialization variable)?\n. This snapshot was generated by way of a simple while true loop running on the server to give me a nice live view of what my browser was pulling and what the server was showing.\nEXTM3U\nEXT-X-TARGETDURATION:7\nEXT-X-VERSION:4\nEXT-X-MEDIA-SEQUENCE:608\nEXTINF:8.004933,\nasegment.8.ts?stream=5&cam=AWeRTla4wtLAtfca&time=1473435188\nEXTINF:7.995000,\nasegment.9.ts?stream=5&cam=AWeRTla4wtLAtfca&time=1473435196\nEXTINF:7.976022,\nasegment.10.ts?stream=5&cam=AWeRTla4wtLAtfca&time=1473435204\nFri Sep  9 08:33:33 PDT 2016\n10.0.0.95 - - [09/Sep/2016:08:32:45 -0700] \"GET /hls/asegment.1.ts?stream=5&cam=AWeRTla4wtLAtfca&time=1473435132 HTTP/1.1\" 200 1973436\n10.0.0.95 - - [09/Sep/2016:08:32:48 -0700] \"GET /hls/alayer.m3u8?stream=5&cam=AWeRTla4wtLAtfca HTTP/1.1\" 200 308\n10.0.0.95 - - [09/Sep/2016:08:32:53 -0700] \"GET /hls/asegment.2.ts?stream=5&cam=AWeRTla4wtLAtfca&time=1473435140 HTTP/1.1\" 200 1990732\n10.0.0.95 - - [09/Sep/2016:08:32:55 -0700] \"GET /hls/alayer.m3u8?stream=5&cam=AWeRTla4wtLAtfca HTTP/1.1\" 200 308\n10.0.0.95 - - [09/Sep/2016:08:33:01 -0700] \"GET /hls/asegment.3.ts?stream=5&cam=AWeRTla4wtLAtfca&time=1473435148 HTTP/1.1\" 200 1976068\n10.0.0.95 - - [09/Sep/2016:08:33:02 -0700] \"GET /hls/alayer.m3u8?stream=5&cam=AWeRTla4wtLAtfca HTTP/1.1\" 200 308\n10.0.0.95 - - [09/Sep/2016:08:33:09 -0700] \"GET /hls/asegment.4.ts?stream=5&cam=AWeRTla4wtLAtfca&time=1473435156 HTTP/1.1\" 200 1983400\n10.0.0.95 - - [09/Sep/2016:08:33:09 -0700] \"GET /hls/alayer.m3u8?stream=5&cam=AWeRTla4wtLAtfca HTTP/1.1\" 200 308\n10.0.0.95 - - [09/Sep/2016:08:33:16 -0700] \"GET /hls/alayer.m3u8?stream=5&cam=AWeRTla4wtLAtfca HTTP/1.1\" 200 308\n10.0.0.95 - - [09/Sep/2016:08:33:17 -0700] \"GET /hls/asegment.6.ts?stream=5&cam=AWeRTla4wtLAtfca&time=1473435172 HTTP/1.1\" 200 1972496\n10.0.0.95 - - [09/Sep/2016:08:33:20 -0700] \"GET /hls/alayer.m3u8?stream=5&cam=AWeRTla4wtLAtfca HTTP/1.1\" 200 308\n10.0.0.95 - - [09/Sep/2016:08:33:27 -0700] \"GET /hls/alayer.m3u8?stream=5&cam=AWeRTla4wtLAtfca HTTP/1.1\" 200 308\n10.0.0.95 - - [09/Sep/2016:08:33:27 -0700] \"GET /hls/asegment.7.ts?stream=5&cam=AWeRTla4wtLAtfca&time=1473435180 HTTP/1.1\" 200 1991108\n10.0.0.95 - - [09/Sep/2016:08:33:27 -0700] \"GET /hls/asegment.8.ts?stream=5&cam=AWeRTla4wtLAtfca&time=1473435188 HTTP/1.1\" 200 1970240\n10.0.0.95 - - [09/Sep/2016:08:33:28 -0700] \"GET /hls/asegment.9.ts?stream=5&cam=AWeRTla4wtLAtfca&time=1473435196 HTTP/1.1\" 200 1976068\n-   Fixed itself for a while when it decided to load all three.  Then eventually crashed again, but it took a while.\n. I am seeing the same thing, with both audio and video (combined stream).  I'm fortunately testing with a CentOS server, and have full root access.  I actually went through and compared the apache logs to the underlying files:\nWhat seems to me to be going on is that the player isn't actually buffering the segments in FireFox (that, or it stops playing to pull the next - either way).  The skip happens at segment borders, and when I went through the apache logs, my test client was pulling the segments every nine seconds, while the m3u8 file was reporting that the segments were eight seconds long (I'm rounding in both cases - 8.015 is close enough to 8 for my purposes, and the apache logs in question had a resolution of 1 second, but still, it was pulling less often than it should have).  I was also able to confirm this is what's going on by setting things up to exaggerate the issue - setting the stream to 8 mbps and then using tc (linux traffic control settings command) to limit the server to 10 mbps on that card exaggerated the issue to a serious degree - the fraction of a second skip I'd been dealing with became about six seconds long.  \nSo my conclusion is that it's either not actually downloading segments before they're needed, or it stops playing while it's downloading segments.  I'm only seeing this behavior in FireFox - I'm not seeing it in Chrome or Edge.\n. I should probably add a short log snippet showing the behavior from when I was doing some testing... sorry for the delay, I don't always think things through.\nApache log:\n10.0.0.95 - - [23/Aug/2016:08:00:02 -0700] \"GET /hlstest/main6.ts HTTP/1.1\" 200 7294588\n10.0.0.95 - - [23/Aug/2016:08:00:11 -0700] \"GET /hlstest/main0.ts HTTP/1.1\" 200 9155600\n10.0.0.95 - - [23/Aug/2016:08:00:21 -0700] \"GET /hlstest/main1.ts HTTP/1.1\" 200 7279924\n10.0.0.95 - - [23/Aug/2016:08:00:31 -0700] \"GET /hlstest/main2.ts HTTP/1.1\" 200 7230668\nThe m3u8 file that ffmpeg was spitting out at the moment of that last entry:\nEXTM3U\nEXT-X-VERSION:3\nEXT-X-TARGETDURATION:10\nEXT-X-MEDIA-SEQUENCE:20\nEXTINF:8.003000,\nmain6.ts\nEXTINF:9.803000,\nmain0.ts\nEXTINF:8.002000,\nmain1.ts\nEXTINF:8.003000,\nmain2.ts\nEXTINF:8.002000,\nmain3.ts\n. Huh, that's interesting... following apache logs while looking at the underlying files with a simple while true loop:\nIt only seems to happen when the player is loading just the oldest entry.  For whatever reason, it doesn't always pre-load the three I've got listed.  When it starts with the middle or last entry, everything's fine for a long, long time.  \nIs there any way to change the player behavior such that it tries to load at least three segments always (maybe an initialization variable)?\n. This snapshot was generated by way of a simple while true loop running on the server to give me a nice live view of what my browser was pulling and what the server was showing.\nEXTM3U\nEXT-X-TARGETDURATION:7\nEXT-X-VERSION:4\nEXT-X-MEDIA-SEQUENCE:608\nEXTINF:8.004933,\nasegment.8.ts?stream=5&cam=AWeRTla4wtLAtfca&time=1473435188\nEXTINF:7.995000,\nasegment.9.ts?stream=5&cam=AWeRTla4wtLAtfca&time=1473435196\nEXTINF:7.976022,\nasegment.10.ts?stream=5&cam=AWeRTla4wtLAtfca&time=1473435204\nFri Sep  9 08:33:33 PDT 2016\n10.0.0.95 - - [09/Sep/2016:08:32:45 -0700] \"GET /hls/asegment.1.ts?stream=5&cam=AWeRTla4wtLAtfca&time=1473435132 HTTP/1.1\" 200 1973436\n10.0.0.95 - - [09/Sep/2016:08:32:48 -0700] \"GET /hls/alayer.m3u8?stream=5&cam=AWeRTla4wtLAtfca HTTP/1.1\" 200 308\n10.0.0.95 - - [09/Sep/2016:08:32:53 -0700] \"GET /hls/asegment.2.ts?stream=5&cam=AWeRTla4wtLAtfca&time=1473435140 HTTP/1.1\" 200 1990732\n10.0.0.95 - - [09/Sep/2016:08:32:55 -0700] \"GET /hls/alayer.m3u8?stream=5&cam=AWeRTla4wtLAtfca HTTP/1.1\" 200 308\n10.0.0.95 - - [09/Sep/2016:08:33:01 -0700] \"GET /hls/asegment.3.ts?stream=5&cam=AWeRTla4wtLAtfca&time=1473435148 HTTP/1.1\" 200 1976068\n10.0.0.95 - - [09/Sep/2016:08:33:02 -0700] \"GET /hls/alayer.m3u8?stream=5&cam=AWeRTla4wtLAtfca HTTP/1.1\" 200 308\n10.0.0.95 - - [09/Sep/2016:08:33:09 -0700] \"GET /hls/asegment.4.ts?stream=5&cam=AWeRTla4wtLAtfca&time=1473435156 HTTP/1.1\" 200 1983400\n10.0.0.95 - - [09/Sep/2016:08:33:09 -0700] \"GET /hls/alayer.m3u8?stream=5&cam=AWeRTla4wtLAtfca HTTP/1.1\" 200 308\n10.0.0.95 - - [09/Sep/2016:08:33:16 -0700] \"GET /hls/alayer.m3u8?stream=5&cam=AWeRTla4wtLAtfca HTTP/1.1\" 200 308\n10.0.0.95 - - [09/Sep/2016:08:33:17 -0700] \"GET /hls/asegment.6.ts?stream=5&cam=AWeRTla4wtLAtfca&time=1473435172 HTTP/1.1\" 200 1972496\n10.0.0.95 - - [09/Sep/2016:08:33:20 -0700] \"GET /hls/alayer.m3u8?stream=5&cam=AWeRTla4wtLAtfca HTTP/1.1\" 200 308\n10.0.0.95 - - [09/Sep/2016:08:33:27 -0700] \"GET /hls/alayer.m3u8?stream=5&cam=AWeRTla4wtLAtfca HTTP/1.1\" 200 308\n10.0.0.95 - - [09/Sep/2016:08:33:27 -0700] \"GET /hls/asegment.7.ts?stream=5&cam=AWeRTla4wtLAtfca&time=1473435180 HTTP/1.1\" 200 1991108\n10.0.0.95 - - [09/Sep/2016:08:33:27 -0700] \"GET /hls/asegment.8.ts?stream=5&cam=AWeRTla4wtLAtfca&time=1473435188 HTTP/1.1\" 200 1970240\n10.0.0.95 - - [09/Sep/2016:08:33:28 -0700] \"GET /hls/asegment.9.ts?stream=5&cam=AWeRTla4wtLAtfca&time=1473435196 HTTP/1.1\" 200 1976068\n-   Fixed itself for a while when it decided to load all three.  Then eventually crashed again, but it took a while.\n. 404=file not found.  It's a return status code from the server.  The 404 would be generated by the WOWZA server (or perhaps a proxy in line), not the javascript itself.  I'd be inclined to start by looking for server side problems - too much load, a disconnected stream, file maintenance deleting a segment while computers are still requesting it, and so on.\n. I ran across an issue where when the segments got over about 2 MB, it'd do that.  Given the nature of what I'm working with, it wasn't significant for me - I just changed the segment size to account for the bandwidth setting.  What happens if you decrease the size of the underlying files?\n. ",
    "pedromcunha": "Any updates on this issue? Currently dealing with it myself.\n. We're currently using version 2.1.1, was there a new version released?\n. I agree with your analysis and have implemented something similar to this. Basically I keep in memory a hashmap of where the decode error happened and then reload the player. I then go one segment past the affected segment. Whenever the video loops or the user seek, I check to see if the seeked to time is in the affected range and push it forward past the range.\nI also added a fallback in case a video gets stuck download the same segment for eternity (it's a weird bug that's been posted around in this repo). I hope to have a micro library that will hopefully patch these issues for the time being. I agree that the platform support would make this micro library obsolete but for now it's the best we can do.\n. What's the status on this issue? Is there a workaround? Just started getting this error after updating to the latest version.\nError Message:\nInvalidStateError\u00b7Uncaught InvalidStateError: MediaSource.addSeekableRange() can only be invoked when the duration is Infinity\nHappens to us about 99% of the time on Chrome. Mostly on windows.\n. ",
    "andrewmnlv": "Hello all!)\nYou can set alias for hls in webpack config. It works for me:\nresolve: {\n      alias: {\n         'videojs-contrib-hls': __dirname + '/node_modules/videojs-contrib-hls/dist/videojs-contrib-hls'\n      }\n   }\nvideojs-contrib-hls v2.2.0\n. @gkatsev i have videojs v5.10.2, but webworkify breaks webpack build because of\nno fallbacks for arguments\n. @dmlap np, on weekend\n. @dmlap up\n. ",
    "ScottLNorvell": "I was having the same issue with webpack and contrib-hls. I was able to get it working by aliasing webworkify to webworkify-webpack in my webpack config like so:\njavascript\n// ...\nresolve: {\n  alias: {\n    webworkify$: 'webworkify-webpack'\n  }\n},\n// ...\nThe strange caveat is that I need point to version 1.0.6 in my package.json instead of the current version (which is 1.1ish). Got that little tidbit from a separate issue here\nHope this helps anyone!\n. Ok... So webworkify-webpack worked for a few weeks to months, then webworkify-webpack-dropin worked for a few more. Now I am on the latest of everything (contrib-hls: 5.4.1, video.js: 5.19.2 as of this writing) and everything is working! Here is how I did it:\nAlias videojs-contrib-hls per @lionxcr's suggestion:\njavascript\n// webpack.config.js\nvar path = require('path');\n// ...\n  resolve: {\n    alias: {\n      'videojs-contrib-hls': path.join(\n        __dirname,\n        'node_modules',\n        'videojs-contrib-hls',\n        'dist',\n        // You can use the unminified version and let the minifier minify!\n        'videojs-contrib-hls.js'\n      ),\n    }\n  }\n// ...\nMake videojs global (also per @lionxcr's suggesiont):\njavascript\n// webpack.config.js\n// ...\n  plugins: [\n    new webpack.ProvidePlugin({\n        videojs: \"video.js\",\n        \"window.videojs\": \"video.js\"\n    })\n  ]\n// ...\nAfter all of that, I was getting the same error as @serv. After some digging, I found the DefinePlugin. It turns out uglify was doing strange things with global, so I aliased typeof global to \"undefined\" so that the minifier would remove it! \njavascript\n// webpack.config.js\n// ...\n  plugins: [\n    new webpack.DefinePlugin({\n      'typeof global': JSON.stringify('undefined')\n    })\n  ]\n// ...\nAlso, if at some point had you aliased webworkify, un-alias it!\njavascript\n// webpack.config.js\n// ...\n  resolve: {\n    alias: {\n      // webworkify$: 'webworkify-webpack',\n      // webworkify$: 'webworkify-webpack-dropin',\n    }\n  }\n// ...\nPhew! That works for now... Hope this helps!. ",
    "Ambroos": "If anyone else encounters this issue again (or a similar one) and wants to use videojs-contrib-hls with Webpack:\nwebworkify-webpack shims window to {}, which causes global/window to return the wrong context in a web worker, which in turn causes things to fail. I've created a fork of webworkify-webpack that's compatible with the original webworkify and works with videojs-contrib-hls!\nJust add webworkify-webpack-dropin@^1.1.9 to your dependencies and add the following alias to your Webpack config:\njavascript\nresolve: {\n  alias: {\n    webworkify: 'webworkify-webpack-dropin',\n  },\n}\nIt's been tested on videojs-contrib-hls v3.7.0-beta3 and video.js 5.12.6.\n. @vpowers Could you show me your webpack config? I can't really think of any reason for this error to appear.\n. ~~I am encountering this exact same issue. segment.type is set to combined. If it'd be helpful I can provide some examples privately.~~\nThe issue was failing AES decrypting in my case, because Yarn picked up the wrong version of aes-decrypter (1.1.0 instead of 1.0.3). This bad decrypting led to segment.type being set to 'combined', which caused the errors.\nUpdate: We've encountered this on one of our streams and noticed that we were using an unsupported encryption method, causing decryption to fail silently and the type being marked as 'combined'. The stream we used was encrypted with SAMPLE-AES (visible in the manifest). It seems that videojs-contrib-hls only has support for AES-128 (which makes sense). SAMPLE-AES is only useful when combined with FairPlay and only works in Safari and Edge with the native implementation.\n. ",
    "dbryand": "@Ambroos's solution worked for me, but I had to turn off eval for source maps in my large react app, @vpowers. (edit: I see now that you're using cheap-source-map, so that probably won't help you). Yes, a home-rolled webpack config.. The solution by @ScottLNorvell worked for me, but this part led to some very tricky to debug issues with another library (GSAP) in my app. \nnew webpack.DefinePlugin({\n         'typeof global': JSON.stringify('undefined')\n       }),\nIn retrospect it seems obvious that other libs may rely on the typeof global and this could blow things up.\nEDIT: In removing this I don't see any impact to video.js / hls.. Now have confirmed that I'm getting the dreaded 't is not defined', too, when I package and ship to s3.\nEDIT: I turned off uglification in the app and it works.. Yes, I dropped videojs and just went with html5 + hls.js. Sorry I can't be more helpful :). Just filed an issue with that test repo, but there were two issues for me. The .m3u8 link in the repo is broken. When I upgraded to \"video.js\": \"5.19.2\" and entered a link to a working .m3u8 file and this worked for me.\nhttps://github.com/vpowers/videojs-contrib-hls-test/issues/2. ",
    "chrispappas": "Running into this issue here as well, same error as @oleynikd is reporting - any updates since last month on this? Also using vuejs and importing as es6 module, compiling with webpack. Tried the webworkify-webpack-dropin plugin but no dice.. ",
    "lionxcr": "So Basically here is the setup you need to get this up and running.\nI am using node 7.4 and a boiler from create-react-app.\nThis is my webpack config:\nresolve: {\n        // This allows you to set a fallback for where Webpack should look for modules.\n        // We read `NODE_PATH` environment variable in `paths.js` and pass paths here.\n        // We use `fallback` instead of `root` because we want `node_modules` to \"win\"\n        // if there any conflicts. This matches Node resolution mechanism.\n        // https://github.com/facebookincubator/create-react-app/issues/253\n        fallback: paths.nodePaths,\n        // These are the reasonable defaults supported by the Node ecosystem.\n        // We also include JSX as a common component filename extension to support\n        // some tools, although we do not recommend using it, see:\n        // https://github.com/facebookincubator/create-react-app/issues/290\n        extensions: ['.js', '.json', '.jsx', ''],\n        alias: {\n            'videojs-contrib-hls':paths.appNodeModules+'/videojs-contrib-hls/dist/videojs-contrib-hls.min.js'\n        }\n    }\nI am also using this plugin to set videojs globally on my scope:\nnew webpack.ProvidePlugin({\n            videojs: \"video.js\",\n            \"window.videojs\": \"video.js\"\n        }),\nAdditionally on my video component JS I use the following:\nimport 'videojs-contrib-hls';\nlet video;\nLater on my component did mount:\n```\ncomponentDidMount(){\n        const options = {\n            height: \"100%\",\n            width: \"100%\",\n            hls: {\n                withCredentials: true\n            }\n        };\n        video = window.videojs(\"video-player\", options);\n    }\n```\nfinally you need to set your src m3u8 file and type using Javascript if not this will not work:\n```\nvideo.src({\n                src:'https://master.m3u8',\n                type: 'application/x-mpegURL'\n            });\nvideo.play();\nrender(){\n    return(\n         \n     );\n}\n```\nFinally got my video to play hope this helps!\nYou will need to use the same plugin and change the alias in your production configuration so the library can run properly:\nUSE THE ES5 VERSION\n'videojs-contrib-hls':paths.appNodeModules+'/videojs-contrib-hls/es5/videojs-contrib-hls.js'\nADD THE WEBWORKIFY DROPIN\n'webworkify$': 'webworkify-webpack-dropin',\nNPM Modules used:\n```\n\"video.js\": \"^5.12.6\",\n \"videojs-contrib-hls\": \"^3.7.0-beta3\",\n\"webworkify-webpack-dropin\": \"^1.1.9\"\n```. @icetronics You are so welcome! As far as I know contrib-hls is not supported in webpack just yet so by far this is the best hack to get m3u8 videos to work properly in react.. ",
    "cansin": "In case there are people having the same problems as I did:\n~~I have been trying to make this work with webpack 2.2.1, video.js 5.18.4 and videojs-contrib-hls 5.3.3. I was able to get webworkify-webpack-dropin to work with a small change: https://github.com/Ambroos/webworkify-webpack-dropin/pull/1/files . I am hoping @Ambroos will merge the PR and release the version to NPM soon.~~  ~~Change in plans. I am trying to release a fix as a separate npm package, yet still trying to figure out how to make it work with uglify-js atm.~~ Gave up :(. I actually couldn't figure out how to make webworkify-webpack-dropin work with my case. Instead I ended up separating videojs-contrib-hls through:\njs\nrequire.ensure(['videojs-contrib-hls/dist/videojs-contrib-hls.min'], require => {\n    require('videojs-contrib-hls/dist/videojs-contrib-hls.min');\n}, 'package-videojs-contrib-hls');\nand then disabled UglifyJS for this separate bundle via:\njs\nnew webpack.optimize.UglifyJsPlugin({\n    sourceMap: false,\n    compress: {\n        warnings: false,\n    },\n    exclude: /package-videojs-contrib-hls/,\n})\nI know this is less than ideal, yet it works for now. Could be an alternative to what you did @everett1989 .. ",
    "everett1989": "@cansin and anyone else who's using webpack's UglifyJsPlugin. I found that if I set compress to false and mangle to true, like so:\nplugins: [\n    ...\n    new webpack.optimize.UglifyJsPlugin({\n      compress: false, // leave false for now. This breaks the videojs-contrib-hls package\n      mangle: true,\n      sourceMap: true\n    }),\n    ...\n],\nThis will uglify it without breaking the videojs-contrib-hls package. For me, it was like less than 40KB difference between compress being true vs false. \nI'm also importing the package like so: import 'videojs-contrib-hls/dist/videojs-contrib-hls.min.js'\nThis is a nice workaround for me until videojs-contrib-hls is compliant with the compression tool. @cansin I'll try it out, thanks for the example. ",
    "cjdeleon62": "hi all, does anyone know if this webpack fix works when deploying to heroku? I am currently trying to deploy to heroku and I am getting an 'Uncaught SyntaxError: Unexpected token {'  . @gesinger I am building my application on Node.js and I am trying to use video-contrib-hls and video.js  with React.js. I I am using webpack to bundle the application and I think that is where it goes wrong. I saw on another forum that people resolved the issue of importing video-contrib-hls by doing the following:\nwebpack.prod.config.js\n  resolve: {\n      extensions: ['', '.js', '.jsx'],\n      alias: {\n          webworkify: \"webworkify-webpack-dropin\"\n      }\n    },\nthis was added to import video-contrib-hls into my application\nand this is the react component I import video-contrib-hls into along with video.js in order to get the player running:\nimport React, { Component } from 'react';\nimport videojs from 'video.js';\nimport 'videojs-contrib-hls';\nclass Player extends Component {\nconstructor(props) {\n    super(props);\n  }\ncomponentDidMount() {\n    const options = {\n        hls: {\n            withCredentials: true\n        }\n    };\nthis.player = videojs(\"video-player\", options).ready(function(){\n  console.log(\"i am ready\");\n});\n\nthis.player.src({src: 'http://184.72.239.149/vod/smil:BigBuckBunny.smil/playlist.m3u8', type: 'application/x-mpegURL'});\nsetTimeout(() => {this.player.play()}, 1000);\n\n}\ncomponentWillUnmount() {\n    this.player.dispose();\n  }\nrender() {\n    return(\n      \n\n\n    )\n  }\n}\nexport default Player;\nanother thing to note is that this works locally when i run npm start, but when I push it to heroku, I get the Uncaught SyntaxError: Unexpected token {.\nAlso, this error is showing in some blob file on heroku that I have no idea where it is coming from.\nI'm pretty noob at this stuff and I am trying to learn but this has me stumped. Be patient with me and let me know if I need to clarify more things. Thanks\n. ",
    "MCDELTAT": "EDIT: With the help of zshenker on Slack I followed @Ambroos but that required me to turn off my source maps. This got me over the error referenced above, but then it ultimately fails to load because I get a simple syntax error \"Uncaught SyntaxError: Unexpected token {\". Is their really no way to turn on source map with webworkify?\nEDIT2: So the syntax error problem appears to be occurring because of the common UglifyJs plugin in my webpack.config. When I get rid of it, the error goes away, but unfortunately that leaves me with a file that went from 1.04MB to 2.86MB. Ideas on how to fix those syntax errors and still use Uglify?\nEDIT3: It appears to be a problem with the version of uglify that is bundled with the latest Webpack v1 (1.14.0). I installed uglifyjs globally and ran the bundle.js file through the command line manually, with no syntax error. It also maintains roughly the same as listed above. So I guess I'll try to update to Webpack 2 soon and verify if the error exists there.. @thecotne Thanks. I had suspected that because for debugging purposes I also moved to Webpack 2, and that didn't fix the issue (has more up to date Uglifyjs) I temporarily solved it by running uglify as part of my \"npm build\" script outside of webpack. Looks like he just needs to pull from where he forked from because they claim to have a fix that works with Uglify. I'll look at that today.. @serv Yep. As was discussed in my posts above, there is a very strict regex function in the current version of webworkify-webpack-dropin. Uglify gains one of its shrinkage abilities by deleting functions that it determines are unused, but webworkify is still looking for them. For now, just turn off uglify in webpack, or you can make a npm script that builds your webpack and then runs uglify, which I did with success. I will be trying to get @Ambroos to update his fork here soon, given that I suggested that people use it in the webpack docs.. ?? Decided to visit this again today because I got the classic error 'fs is not defined' in Safari (but not Chrome). But I still can't get webpack to run uglify from the config file. It passes, but then gives like above, 't is not defined in blob' when the page is opened. So I'm going back to my method of just running webpack, and then using uglify after the fact. Somehow that doesn't cause any problems.. For what it's worth, I started working on a new project for a client and wanted to investigate if I needed to change anything up, and I decided to test out the regular 'videojs-contrib-hls' and was getting all of those same fun problems. Instead I followed @rparjun and his comment above to use https://github.com/Peer5/videojs-contrib-hls.js and everything worked right out of the box. I haven't compiled a production webpack build yet, but I'm feeling good about that.. ",
    "thecotne": "it's not UglifyJs's bug it's bug in this code https://github.com/Ambroos/webworkify-webpack-dropin/blob/master-v1/index.js#L92\nit appears when code is minimized and unused function names are removed\njs\nmoduleWrapperStrings[moduleId] = wrapperFuncString.substring(0, wrapperFuncString.length - 1) \n+ '\\n' + fnString.match(/function\\s?(.+?)\\s?\\(.*/)[1] + '();\\n}';\nthis regex is matching function name but if there is none it will match some weird shit \nand syntax error will appear after compilation in webworker code generated at runtime  in browser\n. @ffischetti do you import videojs-contrib-hls/dist/videojs-contrib-hls.min or videojs-contrib-hls ?\ni have webpack + react + videojs + videojs-contrib-hls and with latest version everything works fine\ndo you still have any \"hacks\" left maybe?\n. @ffischetti videojs-contrib-hls.js is completely different package and what i am saying is that this package videojs-contrib-hls works for me and maybe you are doing something wrong\n. if you import like this \njs\nimport 'videojs-contrib-hls'\nimport videojs from 'video.js'\nit should work (works for me). @forbesjo video.js@6.1.0 is latest version. @forbesjo videojs-contrib-hls flash does not work for me \nin chrome \nVIDEOJS: Error: Error: Failed conversion between PP_Var and V8 value\nin firefox it does not work but there is not error message\nany ideas?\nEDIT this was problem with my setup webpack+hls+flash i fixed it with script-loader. this is problem with webworkify-webpack-dropin not playing well with uglify js \nsee https://github.com/videojs/videojs-contrib-hls/issues/600#issuecomment-293550845. android chrome has native support for hls streams so you need to test it with raw video tag\nif it does not play it's problem with server not player\ni had same issue updating Flussonic to latest version fixed it. 4.6.16 (latest)\n. @piotr-cz any progress?. you need to make example with raw video tag with there .m3u8 url and apple\nexample stream and show them that in android chrome apple hls example works\nand old Flussonic not\nwhen my player did not work everyone blamed player including me but then i\ntested native support with video tag\nOn Sat, Jul 15, 2017, 11:58 Piotr notifications@github.com wrote:\n\n@thecotne https://github.com/thecotne Flussonic server is being managed\nby other company and they decided to update when new release comes up which\nshould be in about two weeks - and they responded with It works for me\ntype of reply.\nUnfortunately when streams don't work they tend to blame player.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/videojs/videojs-contrib-hls/issues/1162#issuecomment-315517802,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABiFURmpiOmC5KVh-yf0J80XwXutgMWUks5sOHEmgaJpZM4N4VSK\n.\n. @gesinger PR is merged so it will be fixed in next release right?. @gkatsev \nour UMD build expects videojs to be available globally\n\nwhy is that?\nwouldn't UMD package use require/define function to import dependencies ?\nand use global variables if require and define are not available \nand list dependencies as peerDependencies \nlike this https://github.com/umdjs/umd/blob/master/templates/jqueryPlugin.js . ",
    "serv": "When I try to compress the js bundle using webpack and uglify, in the browser console, I get this error\nUncaught ReferenceError: e is not defined\n. ",
    "correju": "So far I can create development bundle without a problem and plugin works perfectly, but when I build production I get this error in run-time:\nUncaught ReferenceError: n is not defined blob:http://localhost/659f9283-bbc2-4836-ae79-ebb3cd70a83a:1\nI solve this issue passing: \ndevtool: (isProd ? '#eval' : '#source-map') \nmy original set up is \ndevtool: (isProd ? false : '#source-map')\nThe problem is that my bundle pass from 1.3MB to 4.3MB when I set eval to devtool.\nhas anyone solve this issue completely? . Can you send your webpack configuration?. @GJordan904  I had same problem I solved I solved using this\nvideojs(video, {html5: {\n  hls: {\n    withCredentials: true\n  }\n}});. ",
    "emilioastarita": "@dbryand same here \"t is not defined\" . Did you find any solution? . ",
    "GJordan904": "After trying everything with the latest stable releases to no avail, I was able to get everything up and running with a modified version of @ScottLNorvell 's solution. \nI used the same versions (contrib-hls: 5.4.1, video.js: 5.19.2) and the following lines are all I have in regards to video.js in my webpack conf:\njavascript\nresolve: {\n    alias: {\n        'videojs-contrib-hls': path.resolve(__dirname, 'node_modules/videojs-contrib-hls/dist/videojs-contrib-hls.js'),\n    }\n},\nplugins: [\n    new webpack.ProvidePlugin({\n        'window.videojs': 'video.js/dist/video.js',\n    }),\n]\nI then simply require('videojs-contrib-hls'); and what do ya know, no more Code 4 errors and I can read, and most likely play, .m3u8 playlist. \nOnly one small problem, my cookies are not being sent with the request. I can generate a signed url and access the playlist, unfortunately, the subsequent requests fail of course so I haven't gotten to test playback yet.\n. ",
    "Adynnor": "Man this is a bit of a headache.. :( \nAny fix for using uglify? I'm getting these errors\ne is not defined\nand/or\nUnexpected token {. ",
    "VadimBrodsky": "This Uglify issue was already fixed in Uglify 3.0.17, but Webpack's uglifyjs-webpack-plugin does not support Uglify JS 3 yet.\nMy solution was to downgrade uglifyjs-webpack-plugin and webpack for now, to versions before the breaking change.\njavascript\n// package.json\n{\n    \"uglify-js\": \"2.7.5\",\n    \"uglifyjs-webpack-plugin\": \"0.2.2\",\n    \"webpack\": \"2.2.1\"\n}. ",
    "jou": "I've convinced videojs-contrib-hls to work with Webpack and Uglify by using the dist file and imports-loader to define global as undefined. This causes the check for global (which causes the t is not defined thingie) to be short circuited and everything seems to be working so far:\n```js\n// webpack.config.js\nresolve: {\n    alias: {\n        'videojs-contrib-hls': 'videojs-contrib-hls/dist/videojs-contrib-hls',\n    }\n},\nplugins: [\n    new webpack.ProvidePlugin({\n        'videojs': 'video.js',\n        'window.videojs': 'video.js',\n    }),\n]\n// videojs-with-plugins.js (we have a wrapper module that loads video.js plugins and set up the strings we use)\nimport videojs from 'video.js'\n// If you're not using webpack.ProvidePlugin anyways, you can also shim videojs here direcly\nimport 'imports-loader?global=>undefined!videojs-contrib-hls'\nexport default videojs\n```. ",
    "zcoding": "Browserify is dead. Please consider webpack only.. ok, i give up. it still has a long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long long way to be compatible with webpack... \ud83d\ude43. +1. video.js v5.19.2\nvideojs-contrib-hls v5.8.2. ",
    "jide": "Folks, there is a much much simpler solution.\nJust require the dist bundle like this : \njs\nimport 'videojs-contrib-hls/dist/videojs-contrib-hls.js';\nYou may need to make videojs global too : \njs\nimport videojs from 'video.js';\nwindow.videojs = videojs;. The main entry in package.json should definitely point at the dist bundle imho.. Oh my... This is driving me nuts. My own solution does not seem to work anymore.\nI now have the same issue as @AndrewKirkovski.\nThere is so much confusion, a dozen solutions here + instructions here, each trying to solve a different issue.\nHere is a list of the different issues discussed here : \n- webworkify causes uglifyjs error (also makes nwb production build break)\n- videojs global\n- package.json \"main\" field not pointing to the dist bundle\n- videojs dep returning \"default\"\nWilling to help making sense of all this, but confused atm : \n- Are there compatibility issues with videojs versions here ?\n- Why doesn't main point to a bundled file ?\n- Why is the videojs global needed ?. For me, the only working combination is @lionxcr answer https://github.com/videojs/videojs-contrib-hls/issues/600#issuecomment-273289790, with exactly the versions used (they are mentioned at the end of the comment). Which is sad, because I could not make this work with newer releases.\nAnd if you also need to support youtube with this, you need to use videojs-youtube@2.2.0.. So, I decided to give https://github.com/benjipott/videojs-hlsjs a try, and it works well. So I thought you should know.\nThe fun thing is it needs some webpack tricks too, but it was much easier: https://github.com/SRGSSR/videojs-hlsjs/issues/4\nAnd from my early testing, it works better (seeking is faster for example).. @gregorskii like this: \n```js\nimport videojs from 'video.js';\nimport 'videojs-hlsjs';\nconst player = videojs(node, { techOrder: ['hlsjs', 'html5'] });\n```. @gregorskii So everything's fine now ?. If you have errors using ProvidePlugin, be aware that it does not actually expose the module on window, it mimics it, that's why when having some complex setups, exposed modules won't be on window object.\nSee this comment: https://stackoverflow.com/a/39891365/302731\nThat's why using expose-loader works in these cases, as @drexseoj said.. ",
    "latelt-j": "@jide I try your solution but I have this error : Uncaught TypeError: Cannot read property 'EventTarget' of undefined\nDid you add import 'videojs-contrib-hls/dist/videojs-contrib-hls.js'; on your React Component ? I'm a little lost.... ",
    "moshest": "This is my solution:\n```js\n// webpack.config.js\n{\n  resolve: {\n    alias: {\n      'video.js$': 'video.js/dist/video.cjs.js',\n      'videojs-contrib-hls': 'videojs-contrib-hls/dist/videojs-contrib-hls',\n    },\n  },\nplugins: [\n    // Make videojs global\n    new webpack.ProvidePlugin({\n      videojs: 'video.js',\n      'window.videojs': 'video.js',\n    }),\n// Fix UglifyJsPlugin global\nnew webpack.DefinePlugin({\n  'typeof global': JSON.stringify('undefined'),\n}),\n\n],\n}\n```\nEDIT: Add fix for UglifyJsPlugin.. ",
    "brainthinks": "@moshest - your answer worked for me - thank you!\nHere is the code I used in my actual application after including @moshest webpack config:\n```javascript\nimport videojs from 'video.js';\nwindow.videojs = videojs;\n// @see - https://github.com/videojs/videojs-contrib-hls/issues/600#issuecomment-321281442\nrequire('videojs-flash');\nrequire('videojs-contrib-hls');\n// ... rest of my application\n```. I started getting the same problem that @correju ran into:\nUncaught ReferenceError: n is not defined\nWhen I run my project through webpack using uglify.  After some googling, it seems that there is another project, react-mapbox-gl has this problem as well.  The issue they came up with is documented here:\nhttps://github.com/mishoo/UglifyJS2/issues/2011\nIn order to get rid of the error, I had to add the following option to my uglify plugin:\njavascript\n{ \n  compress: {\n    comparisons: false,\n  },\n}\nThat option is documented here:\nhttps://github.com/mishoo/UglifyJS2#compress-options\nMy uglify plugin in my webpack config looks like this now:\njavascript\n// webpack.config.js\n{\n  // other webpack config options\n  plugins: [\n    // other plugins\n    new webpack.optimize.UglifyJsPlugin({\n      compress: {\n        comparisons: false,\n        // other uglify compress options\n      },\n    }),\n  ],\n}\nSo, all in all, I had to implement the following:\n\nthe compress option from this comment (above)\nall options from this comment: https://github.com/videojs/videojs-contrib-hls/issues/600#issuecomment-321281442\neverything from my previous comment: https://github.com/videojs/videojs-contrib-hls/issues/600#issuecomment-321399363\n\nHope this helps!. @AndrewKirkovski @jide - are you trying to create a package that utilizes video js, then import your package in another project?\nI ask because I got the error you describe in that scenario.  If that is the problem you're running into, here is how I was able to fix it:\njavascript\n// webpack.config.js\n{\n  output: {\n      library: {\n        root: 'myCustomPlayer',\n        amd: 'myCustomPlayer',\n        commonjs: 'myCustomPlayer',\n      },\n      libraryTarget: 'umd',\n  },\n}\nSee https://webpack.js.org/guides/author-libraries/. ",
    "markisme": "So....there is still no some fix is working??. ",
    "AndrewKirkovski": "I'm getting a different issue\n_videoJs.EventTarget is not a constructor in playlist-loader\nThis applies to dist and es5 way of including hls plugin\nMaking videojs global has no effect, it seems require('video.js') in playlist-loader is returning {default: ...} object instead of videojs itself\nAnybody has this problem?. I've done a lot of digging and it seems there is no reliable solution while webworkify-webpack-dropin is used. Problem with that module is that is searches for webpack modules by toString() of default export and matches whatever comes first. (See potentialFnModuleIds.find logic)\nDefault export can be as simple as function(t){ new d(t)} I've encountered situation where 2 modules has exactly same minified string for default export function. So sometimes it work, sometimes it doesn't and that depends on how minification behaves and if you use other minified dependencies.\nwebworkify-webpack is using searching by moduleId since v2 and that works reliably. Unfortunately it is no longer a drop in replacement as needs usage modifications i.e. require.resolve instead of regular require\\import\nI've ended up using own hacked webworkify-webpack-dropin version that is better aware of what's it is looking for and has function name regexp patched. If I manage to make it less hacky I'll post it somewhere.\n. ",
    "kenju": "Hi all,\nWould anyone publish the working sample repository? \ud83d\ude4f \nThere are so many workarounds here, and I really appreciate that. However the specific versions of libraries (webpack, videojs, videojs-contrib-hls, etc) are also important, still each workarounds are missing them. That is why a bunch of workarounds have sprung up but no one still finds the best solution.\nThen we can figure out which workarounds work with which library versions, whose are noted in the package.json.\n(I personally hope someone write a working repo with webpack v2 version, not v1). ",
    "drexseoj": "After 2 days of trying different solutions to get this running with webpack and react I finally found a simple solution which does not require any change to the webpack config file.\n\nnpm install expose-loader --save\nimport videojs and videojs-contrib-hls as follow\nimport \"expose-loader?videojs!../node_modules/video.js/dist/video.js\";\nimport \"../node_modules/videojs-contrib-hls/dist/videojs-contrib-hls.js\";\nTested with:\nvideo.js 6.2.7\nvideojs-contrib-hls 5.11.0\n. \n",
    "gregorskii": "@jide what does your client code look like with videojs-hlsjs? I tried the details on your linked issue but I have the same code 4 error.\nNot having luck with the other solutions in this package. I get the library to load correctly, but I get the Code 4 error consistently.. @jide Thanks for this. I did not know about the techOrder. I added that and I can more clearly see the issue. videojs-hls sets the global videojs value with the correct techOrder, but it's not available outside of the videojs-hls module scope.\nMy output in the console ends up being this:\n\nInside the videojs-hlsjs plugin I consoled window.videojs, window.Hls, and window.videojs.options.\nInside the plugin everything is correct, the tech order gets set, outside its the original videojs that I imported in my module.\nI don't want to harp too much on videojs-hlsjs as it's not this plugin, but what do you think?\n. Similar to @drexseoj this finally appears to be registering:\nalias: {\n      'video.js': 'video.js/dist/video.js',\n      'videojs-contrib-hls': 'videojs-contrib-hls/dist/videojs-contrib-hls.js',\n    }\n{\n  test: /video.js$/,\n  use: {\n    loader: 'expose-loader',\n    query: 'videojs'\n  }\n},\n{\n  test: /videojs-contrib-hls$/,\n  use: {\n    loader: 'imports-loader',\n    query: 'video.js'\n  }\n},\nimport videojs from'video.js';\nimport 'videojs-contrib-hls';\nconsole.log(window.videojs);\n\n. Ya, appears to be working with this plugin.. ",
    "trinonsense": "I got a running solution with the uglifyJS issue (Unexpected token {):\npackage.json\n\"video.js\": \"^6.2.8\",\n\"videojs-contrib-hls\": \"^5.12.0\",\n\"webpack\": \"1.14.0\"\nwebpack.config.js\n// plugins\nnew webpack.ProvidePlugin({'window.videojs': 'video.js'}), \nnew webpack.optimize.UglifyJsPlugin({\n  mangle: true,\n  comments: false,\n  compress: {warnings: false}\n})\nMyVideo.jsx\n```\nimport videojs from 'video.js'\n// react class\ncomponentDidMount() {\n    require('videojs-contrib-hls/dist/videojs-contrib-hls.min')\n}\n```\n. ",
    "rparjun": "Combining inputs from comment and videojs guide I was able to make it work with react-babel-webpack project:\nwebpack: \"^3.4.1\"\nbabel: \"^6.5.2\"\nyarn add video.js@6.2.8\nyarn add videojs-contrib-hls@5.11.0\nWebpack config:\n```\nplugins = [ \n  new webpack.ProvidePlugin({\n    videojs: \"video.js\",\n   \"window.videojs\": \"video.js\"\n  })\n],\nmodule:{\n  loaders: [\n    {\n      test: /.(png|woff|woff2|eot|ttf|svg)$/,\n      loader: 'url-loader?limit=100000',\n    }\n  ]\n}\nresolve: {\n  alias: {\n    webworkify: 'webworkify-webpack-dropin',\n    'videojs-contrib-hls': 'videojs-contrib-hls/dist/videojs-contrib-hls.min.js'\n  }\n}\n```\nReact component:\n```\nimport React from 'react';\nrequire('video.js/dist/video-js.css');\nimport 'videojs-contrib-hls';\nclass Videojs extends React.Component{\n  componentDidMount() {\n    this.player = window.videojs(this.videoNode, {});\n  }\n  render(){\n    return(\n       this.videoNode = node } controls className=\"video-js vjs-default-skin\">\n        {/\n\n/}\n        \n\n    )\n  }\n}\nexport default Videojs;\n```\nWe can also lazy load this component to the app.\nThanks @lionxcr ! :smile: \nEdit\nEven though above method worked in dev environment, when running  webpack in production mode(webpack -p) or when we pass the bundle to uglify, the output file will throw a syntax error while loading as mentioned in this comment\nEnded up using https://github.com/Peer5/videojs-contrib-hls.js which uses hls.js.\n. @alexandrzavalii Please check the edits in my comment, the config may not work in production environment. . @MCDELTAT I am using the same in some production environments from December and no issues until now. :smiley: . @mjneil Thanks :smiley: \nI will take a look into it this weekend and let you know.. Hi @mjneil , videojs-contrib-hls@qa is working fine. I was able to verify it with multiple streams, all looks good. :tada:. @mjneil  Thanks :smile: . @ffischetti I can take a look into this if you can share a repo where i can reproduce this issue.. @gesinger I had a similar issue, when loading a mpeg2video file using m3u8 playlist, it was crashing with an error 'Cannot read property 'segments' of undefined' at at 'https://unpkg.com/videojs-contrib-hls@5.5.3/dist/videojs-contrib-hls.js:18036:25'.\nType was coming as 'combined' and that key was not present in 'segmentObj'. \nCan we have a friendly error message if this is not supported.\nVideo.js 5.19.2\nvideojs-contrib-hls.js: v5.5.3\nGoogle Chrome: 58.0.3029.110\nGenerating m3u8:\nffmpeg -i inp.ts -f segment -segment_time 10 -segment_list list.m3u8 -segment_format mpegts 'list-file%5d.ts'\n. ",
    "alexandrzavalii": "Thanks @rparjun :)\nI managed to make it work with your webpack config on AngularJS.\nThe only mystery remaining is that I have to console.log(HLS) before using it. Yes, sounds very strange :)\n```\nimport * as HLS from 'videojs-contrib-hls';\nrequire('!style-loader!css-loader!video.js/dist/video-js.css');\nexport function VideoController(...) {\n  let player,\n       $video = $element.find('video');\nfunction onInit() {\n        console.log(HLS); //if I remove this HLS is not loaded.\n        const options = {};\n        player = videojs($video[0], options);\n    player.src({\n        src:'https://s3.amazonaws.com/_bc_dml/example-content/bipbop-advanced/bipbop_16x9_variant.m3u8',\n        type: 'application/x-mpegURL'\n    });\n    player.play();\n\n}\n```\nAny ideas to solve this ?. @mjneil \nBig thanks! \nTested thoroughly , all works \nFinally we have a clean solution!. ",
    "kapersoft": "@mjneil I have tested it with a Laravel Mix / VueJS setup and it works like a charm! Thanks :smiley:. @ffischetti I have tested v5.13.0 with my Laravel Mix / VueJS setup and didn't experience any problems.. ",
    "ffischetti": "@mjneil thanks for the awesome effort.  FYI, with v5.13.0 I'm still getting the unexpected identifier issue  Anyone else have that problem?. Thanks @thecotne  \nI'm doing: import 'videojs-contrib-hls,' as when I try to import videojs-contrib-hls/dist/videojs-contrib-hls.min, I get the following error: videojs-contrib-hls.min.js:2 Uncaught TypeError: Cannot read property 'EventTarget' of undefined\nhttps://github.com/Peer5/videojs-contrib-hls.js works fine.  But video-js-contrib-hls throws the unexpected token '{' error.\nFYI, the app is bootstrapped with create-react-app.. @thecotne I'm doing exactly that and it throws the error.  I'm aware that videojs-contrib-hls.js is a different package.  I trying to point out that I seem to be experiencing the same state the others did prior to the fix.  \nI appreciate the help and it's totally possible I'm doing something wrong.  However, I suspect that some other dependency or action might be necessary to get  v5.13.0 working with create-react-app, and that just hasn't been made explicit.  \nOut of curiosity, does anyone have this working with create-react-app?  If so, please share any details.  They'd be much appreciated.  Thanks in advance!\n. Hi @rparjun,\nThanks for the kind offer.  I've created a very basic app that will allow you to reproduce the issue: \nsample app.\nPlease let me knows if this helps or not.  Thanks!\n. Confirmed it's working.  You rock.  Thanks @mjneil ! . ",
    "MosheAtOwal": "Worked for me too, with Webpack (2!) and VueJS.. ",
    "bachue": "I found if you disable Hardware-accelerated video decode from chrome://flags, this issue wouldn't be existed.\n. ",
    "lukasz-wojcik": "I also get CODE:4 MEDIA_ERR_SRC_NOT_SUPPORTED on version 2.0.1\nIs there any hope for that issue being fixed in a near future?\n. I have get rid of that error on IE 11 using following setup\nvideojs-contrib-media-sources - version 3.0.1\nVideo.js  - version 5.8.8\nvideojs-contrib-hls - version 2.0.1\nI have provided 2 sources .webm and .m3u8  to video tag\nI got that working on chrome/firefox/safari/IE/Edge(checked only newest versions)\n. I have used all abovementioned libs in those exact versions(did not check newer versions if there are any)\nIn my view I have placed html that looks like this:\nhtml\n<video id=\"my_id\">\n  <source src=\"http://link.to.video.m3u8\" type=\"application/x-mpegURL\"/>\n  <source src=\"http://link.to.video.webm\" type=\"video/webm\"/>\n  <source src=\"http://link.to.video.mp4\" type=\"video/mp4\"/>\n</video>\n. ",
    "GarethMobey": "Hello Lukas-wojcik,\nCould you please give a brief explanation of what you did.  Struggling with the same issue at the moment.\nMany thanks\n. Thank you very much.\n. ",
    "scaryguy": "Sure, I do. Here is how I instantiate the videojs object:\njavascript\nvar player = videojs('example-video', {hls: {withCredentials: true}}, function() {\nthis.play();    \n});\nIs there something wrong with this setup?\n. Any ideas?\n. ",
    "stoicbuddha": "I'm also having the same issue now.  Are there any updates for this?. @will3216 That's not the same issue. This is what happens when it doesn't send things with the manifest files.\n\n. I'm still having this issue as of videojs-contrib-hls v5.10.1\nI instantiate the player like so:\nvideojs(opts.videotagid, {\n                \"controls\": !opts.disablecontrolbar,\n                \"autoplay\": false,\n                \"preload\": opts.preload,\n                \"poster\": '',\n                \"loop\": opts.loopplayback,\n                \"html5\":\n                    {\n                        hls: {\n                            withCredentials: true\n                        }\n                    }\n            }, function() { .... It seems to be fine in Chrome (haven't tried FF yet), but fails in Safari 11.\n. Is there any solution to this?. I'll try to put something together tomorrow.  If I can't get to it, it'll have to wait until the 1st. . Yes, but I've been unable to put something together yet due to various outside demands.  I'll reopen once I'm able to put something together for you to look at.\n. Is there any update on this?. Is there any news on this?  I know it's the holidays and it might be harder to get to.. Do you have a fix for the Safari issue?. ",
    "will3216": "I am also running into this issue with the same instantiation as @scaryguy \n\nI am using the following package versions:\nhls.js - 0.6.15\nvideo.js - 5.14.1\nvideojs-contrib-hls.js - 2.0.1 (with some minor modifications for use with webpack)\n. @stoicbuddha Yeah, I was mistaken. I found the issue I was having: I had npm installed the wrong video-contrib-hls package. ",
    "leogdiniz": "@forbesjo Were these changes released already?\nI tried this with the latest release of videojs and contrib-hls and it still happened.\nhttps://jsbin.com/noqarafiru/edit?html,output\nHere says we should use AES-128 in CBC mode with PKCS7 padding. Do you think that maybe it's using a different padding or mode?\nDo you remember what you used @jstarpl ?\nCheers. ",
    "y284663247": "in chrome browser, the question happened,\n. ",
    "webcast33": "gkatsev,\nThanks for answering. I'm using video.js 5.8.0 and video-contrib-hls.js 2.0.1. My tests were run on a Windows 7 machine.\n. I just wanted to mention that my Firefox problems occur in version 45, which I believe should support HLS through the MSE. As I reported, when I tried to stream an on-demand file from our CDN using the current versions - video.min.js (v 5.8.0) and videojs-contrib-hls.min.js (v2.0.1) - I experience the odd effect of the video speeding up after 8-10 seconds and then freezing (with a spinner). But when I fall back to older versions - video.js (v 5.4.6 ) and videojs.hls.min.js (v 1.3.1) - it works much better: no speed-up and no freezing, though there is a slight, but noticeable, pause in the video (not audio) each time a new fragment is transferred from our CDN. \n. ",
    "nhollander": "@billybobilly and @alonfixler we are seeing these freezing issues when Live streaming via an Elemental encoder. We are not using a wowza config however can reproduce the same issue you have both laid out.We are trying to narrow down whether this is an encoder issue or a video.js player. Can you both confirm that your fix was on the encoders end and that video.js player can do live streaming without these issues?\n. @billybobilly thank you for the response. I am wondering if you might be able to take look here at our player with the a live streaming running in it and see if you can replicate the issue \nhttp://devmobilerider.com/users/julio/test_player_20160928.html \n. Hi we are experiencing the same issue for live. Any update on the fix @forbesjo ? \nThis looks like there is an issue with packager at the encoder as well as player itself. The reason being why the issue is replicable in all players as well as in safari is due to packager not updating the chunk lists with current ts set causing the player running out of buffer.\nWe are able to replicate the issue and seeing player is requesting only chuncklists repeatedly and not playing ts segments.\nCapturing HTTP request and response confirms the following behavior:\n1. After the chuncklist master_270p.m3u8 which has 00385.ts, the next request for the same ts segment is successful\n2.    \nAfter that, for more than 1 minute, the chuncklist is not updated with current ts segments causing only to request chuncklist and buffering out player.\n\n\nWe also see the player also requesting same ts segments multiple times as well as in random orders.\nSample log lines for the client requested ts segments- time sorted:\ntime #object_size #content-byte_served #status code #ARL\n2016/09/27-22:01:45+0000 1663236 1663236 200 hls/live/261224/mrtest/master_360p_00415.ts\n2016/09/27-22:01:45+0000 1663236 1663236 200 hls/live/261224/mrtest/master_360p_00415.ts\n2016/09/27-22:01:45+0000 1663236 1663236 200 hls/live/261224/mrtest/master_360p_00415.ts\n2016/09/27-22:01:45+0000 1663236 1663236 200 hls/live/261224/mrtest/master_360p_00415.ts\n2016/09/27-22:01:46+0000 1663236 1663236 200 hls/live/261224/mrtest/master_360p_00415.ts\n2016/09/27-22:01:50+0000 667024 667024 200 hls/live/261224/mrtest/master_270p_00413.ts\n2016/09/27-22:01:51+0000 671912 671912 200 hls/live/261224/mrtest/master_270p_00414.ts  -\u00e0 random order\n2016/09/27-22:01:51+0000 671912 671912 200 hls/live/261224/mrtest/master_270p_00414.ts\n2016/09/27-22:01:51+0000 671912 671912 200 hls/live/261224/mrtest/master_270p_00414.ts\n2016/09/27-22:01:51+0000 671912 671912 200 hls/live/261224/mrtest/master_270p_00414.ts\n2016/09/27-22:01:51+0000 667024 667024 200 hls/live/261224/mrtest/master_270p_00413.ts\n2016/09/27-22:01:51+0000 671912 671912 200 hls/live/261224/mrtest/master_270p_00414.ts\n2016/09/27-22:01:52+0000 671912 671912 200 hls/live/261224/mrtest/master_270p_00414.ts\n2016/09/27-22:01:52+0000 671912 671912 200 hls/live/261224/mrtest/master_270p_00414.ts\n2016/09/27-22:01:52+0000 671912 671912 200 hls/live/261224/mrtest/master_270p_00414.ts\n2016/09/27-22:01:52+0000 667024 667024 200 hls/live/261224/mrtest/master_270p_00413.ts\n2016/09/27-22:01:52+0000 671912 671912 200 hls/live/261224/mrtest/master_270p_00414.ts\n2016/09/27-22:01:53+0000 671912 671912 200 hls/live/261224/mrtest/master_270p_00414.ts\n2016/09/27-22:01:53+0000 671912 671912 200 hls/live/261224/mrtest/master_270p_00414.ts\n2016/09/27-22:01:53+0000 671912 671912 200 hls/live/261224/mrtest/master_270p_00414.ts\n2016/09/27-22:01:53+0000 667024 667024 200 hls/live/261224/mrtest/master_270p_00413.ts\n2016/09/27-22:01:53+0000 671912 671912 200 hls/live/261224/mrtest/master_270p_00414.ts\n2016/09/27-22:01:54+0000 671912 671912 200 hls/live/261224/mrtest/master_270p_00414.ts\n2016/09/27-22:01:54+0000 671912 671912 200 hls/live/261224/mrtest/master_270p_00414.ts\n2016/09/27-22:01:54+0000 671912 671912 200 hls/live/261224/mrtest/master_270p_00414.ts\n2016/09/27-22:01:54+0000 667024 667024 200 hls/live/261224/mrtest/master_270p_00413.ts\n2016/09/27-22:01:54+0000 671912 671912 200 hls/live/261224/mrtest/master_270p_00414.ts\n2016/09/27-22:01:55+0000 671912 671912 200 hls/live/261224/mrtest/master_270p_00414.ts\n2016/09/27-22:01:55+0000 671912 671912 200 hls/live/261224/mrtest/master_270p_00414.ts\n2016/09/27-22:01:55+0000 671912 671912 200 hls/live/261224/mrtest/master_270p_00414.ts\n2016/09/27-22:01:55+0000 667024 667024 200 hls/live/261224/mrtest/master_270p_00413.ts\n2016/09/27-22:01:56+0000 671912 671912 200 hls/live/261224/mrtest/master_270p_00414.ts\n2016/09/27-22:01:56+0000 671912 671912 200 hls/live/261224/mrtest/master_270p_00414.ts\n2016/09/27-22:01:56+0000 671912 671912 200 hls/live/261224/mrtest/master_270p_00414.ts\n2016/09/27-22:01:57+0000 671912 671912 200 hls/live/261224/mrtest/master_270p_00414.ts  -> multiple requests\nAs you also will see that there is one more weird behavior that no ts requests made by the player for more than 1minute, though the ts segments are advertised. (After master_720p_00661.ts no requests for ts but chunk list showing till master_720p_006618ts).\n\nThe same behavior cannot be replicated in IOS native player (safari). This shows that the issue is more likely with the HTML5 player implementation.\n.  @forbesjo   Here is a live Stream to test with in our player: \nhttp://devmobilerider.com/users/julio/test_player_20160928.html\n. ",
    "m1ch3lp3r3z": "@billybobilly, @alonfixler just to support @nhollander comment, below is an image snap from the issue actually happening. This test was performed on Chrome browser using video js player. At some point in the video the TS requests start to getting behind with respect to the range given by the m3u8. Our first guess is that those TS are becoming available faster than the player is consuming them, however the player was not showing any pauses or cuts. And the interesting part is that the player stopped calling TS when the last loaded TS (154) was not anymore among the ones in the range from the m3u8, which was already starting from 155. So this sounds similar in some way to the issue you've described that's why we think there might be contact points.\nhttps://www.evernote.com/l/AN4ZjYdIMl5IpL88VH977hFqjG42pP_05eE\nSorry for the blurred areas, we need to keep privacy from a third party.\nThank you.\n. [UDPATE] I tested with the most recent version of videojs-contrib-hls (v5.1.1), and I'm still seeing the issue I just get the loading spinner forever, I can even hear the audio trying to play for some milliseconds and then stops.\n[EDIT] Actually I get two spinner rounds a couple of seconds apart. ",
    "sevagsim": "Thanks!\n. ",
    "jlwuleo": "~ ~, I have encountered the same problem today, you can play properly on the IE11 browser, will not stop, waiting line\n. ",
    "alexchern": "Hi Gary, thanks for your help. \nI tried to replace videojs.Hls = require(...) with just require('videojs-contrib-hls'); but it didn't help.\nHow should I do this? Sorry for the novice questions...\nThanks,\nAlex\n. Hi Gary,\nYep, that worked! It also solved my other problem with playlist plugin.\nThanks a lot,\nAlex\n. Hi there,\nThanks for your answer. \nI ended up putting both video.min.js and videojs-contrib-hls.min.js into index.html (it works). Will try the above as it is a cleaner solution.\nThanks again,\nAlex. Yep. But your approach should nicely package videojs libraries :-). ",
    "ducdigital": "FYI This should work for webpack. window.videojs did not work for me here\nglobal.videojs = videojs;\nrequire('./dist/videojs-contrib-media-sources.js');. ",
    "asokani": "Either method didn't work for me - Webpack2\nJust add this to your webpack.config:\nnew webpack.ProvidePlugin({\n    'window.videojs': 'video.js/dist/video.min',\n}),\nand replace const videojs = require('video.js'); with const videojs = window.videojs;. That workaround works for me.. FYI https://github.com/videojs/videojs-contrib-hls/issues/636#issuecomment-296364099. ",
    "hungsama": "I'm using for React create webapp for WebOs LG and Samsung Tizen.\nI had been run build on chrome and firefox browser, it's OK !\nHower, when run on webOs and Tizen will appear error : \n\"VIDEOJS: ERROR: (CODE:4 MEDIA_ERR_SRC_NOT_SUPPORTED) No compatible source was found for this media. \nMediaError\"\nPlease, help me !\nThis code here:\nimport React from 'react'\nimport video from 'videojs-contrib-hls';\nimport videojs from \"video.js\";\nwindow.videojs = videojs;\nclass PlayerStream extends React.Component {\ncomponentDidMount() {\n   let player = videojs(\"really-cool-video\", {\n    html5: {\n      hls: {\n        withCredentials: false\n      }\n    }\n   });\nplayer.src({\n     src: \"http://www.streambox.fr/playlists/x36xhzz/x36xhzz.m3u8\",\n     type: 'application/x-mpegURL'\n   });\n    player.play();\n  }\n  render() {\n    return \n<video id=\"really-cool-video\" controls>\n    </video>\n\n  }\n}\nexport default PlayerStream. ",
    "Hoshinokoe": "Provided solution doesn't work for me. \nvar videojs = require('video.js');\nwindow.videojs = videojs;\nrequire('videojs-contrib-hls');\nAll require modules combined into one single file and videojs-contrib-hls fails after load:\nUncaught TypeError: Cannot read property 'EventTarget' of undefined\n    at Object.<anonymous> (BC8B1AB3F6A7B6D221C89543E59CDE21.js:sourcemap:2739)\n    at Object.n.9 (BC8B1AB3F6A7B6D221C89543E59CDE21.js:sourcemap:2739)\n    at r (BC8B1AB3F6A7B6D221C89543E59CDE21.js:sourcemap:2738)\n    at BC8B1AB3F6A7B6D221C89543E59CDE21.js:sourcemap:2738\n    at Object.<anonymous> (BC8B1AB3F6A7B6D221C89543E59CDE21.js:sourcemap:2744)\n    at Object.n.77 (BC8B1AB3F6A7B6D221C89543E59CDE21.js:sourcemap:2745)\n    at r (BC8B1AB3F6A7B6D221C89543E59CDE21.js:sourcemap:2738)\n    at e (BC8B1AB3F6A7B6D221C89543E59CDE21.js:sourcemap:2738)\n    at BC8B1AB3F6A7B6D221C89543E59CDE21.js:sourcemap:2738\nAs result it breaks whole app.\n@gkatsev please think about any possible workaround.. ",
    "RobertLowe": "@Hoshinokoe same issue, in meteor.js (if that's what you're using), I had to put, video.js, videojs-flash.js, videojs-contrib-hls.js into the compatibility folder which is essentially loading libs in <head> rather then having babel/meteor concat them... So try just loading them in <head> \ud83d\ude1e \npls fix, lost ~3 hours. ",
    "winterfellzone": "Someone Please?\n. ",
    "pacepace": "I'm experiencing this problem with Chrome 57.  Firefox, Safari, Edge all work fine.  On Chrome it will play the first segment and then it will fail with the \"The media playback was aborted due to a corruption problem or because the media used features your browser did not support.\"  If I disable the hardware acceleration in Chrome, playback continues beyond the first segment.  This problem is occurring across all the Chrome's I've tested.  Please note that all the machines I tested on have hardware accelerated graphics.  None of them are funky weird graphics, they are either higher end Nvidia cards (980s, 1080s) or they are integrated Intel. All the systems are WIndows 10.\nAdditionally, on the first load of the page (regardless of the hardware accel setting) on Chrome it says \"No compatible source for this media\" and never tries to load the m3u8.  A force-refresh on the page brings it to the point where it can play the first segment.. Thanks for the help!\nHere's a link to my test: http://jolokia.http.internapcdn.net/jolokia/jolokia/test/ondemand.html\nHere's a link to my m3u8: http://beta.plgen.jolokia.com/plgen.fcgi?bw=520381,670087,840281,1119720,1419460,2018309&bwdef=840281&w=440,548,684,840,1040,1280&base=//jolokia.ios.internapcdn.net/jolokia/jolokia_networks/demos/avatar-tlrf_adaptive__IDX__.mp4&ver=1&of=m3u8. Issue remains the same with videojs 6.0.0. If I use the Peer5 videojs-control-hlsjs and hls.js, my issues clear up.  Really looking like something specific to videojs-contrib-hls.  Would love to help it get fixed.  Let me know what I can provide.\nHere's a link to my working player: jolokia.http.internapcdn.net/jolokia/jolokia/test/ondemandP5.html. Just tested Chrome 58.  Same issue, unable to play past first segment.... Might be unrelated, I've got a similar problem where Chrome gets unhappy with the same message.  This happens on initial page load and before it even tries to load the m3u8.  If you watch the network tab it just dies before it loads the m3u8, etc.  If you hit force-refresh, it will load the m3u8.  Please note that the below link is for a live player and that live stream is not currently running, but it demonstrates the problem (at least for me) as it doesn't even try to load the m3u8 before it dies on the first load:\nhttp://jolokia.http.internapcdn.net/jolokia/jolokia/test/live.html\nMy testing is with Chrome 57 and Windows 10.. ",
    "brain64bit": "For zencoder if you want to provide 144p (audio bitrate < 80 kbps) rendition by default it will be use HE-AAC, fortunately there is option for forcing aac profile to be use AAC-LC just pass an option:\nmax_aac_profile: \"aac-lc\"\nThanks\n. ",
    "sirisian": "http://sirisian.com/randomfiles/testhls/index.html\nNot sure if the timing will be right though playing from an index.m3u8 like that, but that URL contains a full example with all the files I'm using and a snapshot of the index.m3u8 and ts files. (Just for clarification my real streaming URL only works in the intranet so I can't link directly to it).\n. I don't have cross origin enabled for that directory. That's why I linked the tar.gz previously so the files could be ran locally on your test environment. You'd need to download them and place them into a relative directory. My link specifically though on my server has them relative so there's no cross origin issues and it doesn't do anything other than download them in the network tab. In Ubuntu 13.04 I can navigate to the index.m3u8 with the untarred files and it loads and displays one of the ts files (using Quicktime plugin). In Windows 10 edge I can navigate to the index.m3u8 and it plays for a few seconds also.\n. Which browser did you use? Also just to be clear. I do not have Flash. (I don't even have it on the device I'll be running it on. If you can test again, but disable the Flash plugin I think you'll see my results). I just tried that exact code with my files and it doesn't play. In Firefox in the console I see:\n\nGET http://sirisian.com/randomfiles/testhls/hls/hdmi/index.m3u8\nGET http://sirisian.com/randomfiles/testhls/hls/hdmi/1460412184500.ts\nSpecified \"type\" attribute of \"application/x-mpegURL\" is not supported. Load of media resource hls/hdmi/index.m3u8 failed.\nAll candidate resources failed to load. Media load paused.\nAll candidate resources failed to load. Media load paused.\nGET http://sirisian.com/randomfiles/testhls/hls/hdmi/index.m3u8\nGET http://sirisian.com/randomfiles/testhls/hls/hdmi/index.m3u8\n... and it continues getting the index.m3u8 forever.\n\nIn the network tab it shows it request those files successfully.\nIn Chrome nothing happens and nothing is displayed in the console, but in the network tab I can see the following successful requests:\n\nindex.html\nvideo.min.js\nvideojs-contrib-hls.min.js\nindex.m3u8\n1460412184500.ts\nindex.m3u8\nindex.m3u8\n... and the index.m3u8 repeats\n. Currently the only ffmpeg I'm using is going from an h264 stream to rtmp which I then feed into nginx-rtmp.\n\nffmpeg -i http://192.168.1.168/hdmi -codec copy -bsf:a aac_adtstoasc -f flv rtmp://1270.0.0.1/live/hdmi\nI'll experiment a bit.\n. woah, that works. Will continue to investigate. This could prove useful for others.\nedit: hmm might have spoken too soon. Randomly it stops working. Seems like an ffmpeg bug maybe.\nedit2: Made a post with an error, but I changed something in my streaming device from \"Package A\" to \"Package B\" and it's no longer throwing an error. Going on 10 minutes of playing at 320x180. :\\ Weird. Need to experiment a lot more I guess.\n. Here's the ffprobe you requested: http://pastebin.com/sVzbZ9Un\nI think I've figured out partly what's happening. If ffmpeg can't encode faster than it reads it'll fail due to some kind of circular buffer overflow. Here's a run at 30 fps 1280x720@30Hz re-encoding http://pastebin.com/Qt9iV2m3 . The device can only encode at around 25 fps due to performance reasons and fails after a few minutes never recovering.\nWith -preset ultrafast where it manages to encode at 30 fps it never crashes. The quality is bad though at 768 kbps with ultrafast enabled. Also after about 5 minutes in video.js it stops playing. It continues to request new m3u8 files but no ts file is ever requested. The new .ts files on the machine are being generated fine are all being cycled just fine and the m3u8 file seems fine, but it just glitches and stops requesting the .ts files. If I refresh it starts playing again for 3 minutes then locks up up for 10 seconds continuing to request .ts files and then starts playing again then locks up 30 seconds later then stops requesting .ts files for good again while continuing to request new m3u8 files forever never recovering. I refresh this process seems to repeat. Also I've watched it for a bit and it gets really laggy for a while before it stops requesting ts files. The buffering pops up and it'll play for a second then buffer for what seems like 100 ms then play and do this a few times then stop requesting .ts files.\nNot sure if any of that helps. (I'll be submitting an ffmpeg bug with my data once their bug tracker is back online).\n. These are the settings I have to play with on the HTTP device:\n\nThat seems to indicate it's creating a keyframe once a second. Also I think the \"non-existing PPS 0 referenced\" is normal since it's looking at delta frames and waiting for a keyframe, no? I see it referenced online a lot and people don't seem bothered by it. The errors I'm talking about though are below those.\nThe video.js issue I explained in the second large paragraph still occurs even when there are no errors with ffmpeg. (It did stop working after a while even with ultrafast, but it took like an hour http://pastebin.com/hFrZFVMH see line 152 ). The whole issue of not requesting ts files anymore even though they're being created seems to be an issue with video.js since I can watch it play for a few minutes, stop playing, and refresh to repeat. Something in video.js seems to trigger it to stop requesting new ts files even when the m3u8 is requested and references new ones.\n. Interesting. I plugged in a Matrox Maevex 5150 I have and used ffmpeg to passthrough the 1920x1080@30Hz stream from rtsp to rtmp then used nginx-rtmp to convert it to hls.\nIn video.js after a few minutes (between 3 minutes and up to 30 minutes) of playing it stops requesting the new ts files and just continues to request m3u8 files. It runs fine in VLC. Is there nothing built into video.js or videojs-contrib-hls to recover from whatever error is occurring internally?\nInterestingly when I refreshed once in a great while it would output in Firefox:\n\nVIDEOJS: ERROR: (CODE:2 MEDIA_ERR_NETWORK) A network error caused the media download to fail part-way\n\nNot sure what that's about since it's playing just fine in VLC. Then when I refresh it starts playing again fine.\nAlso when it fails I see this in the console:\n\nInvalidStateError: An attempt was made to use an object that is not, or is no longer, usable.\n\nThat repeats over and over. If I refresh it starts playing again fine for a long time until it fails again. I might try to use the non-minified version of the code and see if it tells me the line it failed at.\nheh after 15 minutes I also saw:\n\nVIDEOJS: ERROR: (CODE:3 MEDIA_ERR_DECODE) The media playback was aborted due to a corruption problem or because the media used features your browser did not support.\"\n\nand\n\nInternalError: uncaught exception: out of memory\n\nThis goes away if I restart the browser.\nI have another streaming device I can try later that outputs just hls. This whole process of going through nginx-rtmp might not be ideal for reliable streaming.\n. ",
    "matotiker": "I have the same issue .. it works on IE but there are issues on chrome and mozilla.\nhttp://cdn.magictvbox.eu/eutv.m3u8 \nit can be played on https://www.hlsplayer.net/ \n. ",
    "mina64": "Hi there,\nwe have an hls link that our CDN provider is Akamai. everything works perfect with VideoJS plugin just it doesn't have sound on Desktop browsers. Do you have any idea how to fix it. Here is link:\nhttp://www.kanatelevision.com/en/kana-tv-live-stream\nThanks for any response!\nRegards,. ",
    "bellenuit": "We have the same problem, audio glitches every 10-12 seconds.\nhttps://www.artfilm.ch/cafe-odeon-test\nThe film runs on Video.js with HLS plugin on Chrome and Firefox.\nLook at the music on the opening titles, they are interrupted every 12 seconds.\nTo compare you can view with Flash (Link below Video), or look with native HLS on Safari or Mobile browsers. In all other configurations, there is no glitch.\nWe use 44100 audio because of synch with Flash. \nI did also test 48000, but the result is the same\nhttps://www.artfilm.ch/cafe-odeon-test-48k\nThis said, you did already a great job. But you should fix it. It is disturbing particularly if you have music.\nMatthias\n. I have to correct myself. The glitches only happen on Firefox. Chrome is fine.\nMatthias\n. Thanks it works for me also now :-). ",
    "jviney": "Pasting the m3u8 here because the link above is now broken:\n```\nEXTM3U\nEXT-X-VERSION:3\nEXT-X-MEDIA-SEQUENCE:0\nEXT-X-ALLOW-CACHE:YES\nEXT-X-TARGETDURATION:9\nEXTINF:9.0,\nhttps://gloryleague-vid-encoded-syd-events.s3-ap-southeast-2.amazonaws.com/8/8/882b60b1-b825-4961-b2b9-2ce70ff8e842/475670/1460171823-475670-0.ts\nEXT-X-DISCONTINUITY\nEXTINF:9.0,\nhttps://gloryleague-vid-encoded-syd-events.s3-ap-southeast-2.amazonaws.com/8/8/882b60b1-b825-4961-b2b9-2ce70ff8e842/475706/1460171824-475706-0.ts\nEXT-X-DISCONTINUITY\nEXTINF:9.0,\nhttps://gloryleague-vid-encoded-syd-events.s3-ap-southeast-2.amazonaws.com/8/8/882b60b1-b825-4961-b2b9-2ce70ff8e842/475710/1460171824-475710-0.ts\nEXT-X-DISCONTINUITY\nEXTINF:9.0,\nhttps://gloryleague-vid-encoded-syd-events.s3-ap-southeast-2.amazonaws.com/8/8/882b60b1-b825-4961-b2b9-2ce70ff8e842/475731/1460171824-475731-0.ts\nEXT-X-DISCONTINUITY\nEXTINF:9.0,\nhttps://gloryleague-vid-encoded-syd-events.s3-ap-southeast-2.amazonaws.com/8/8/882b60b1-b825-4961-b2b9-2ce70ff8e842/475740/1460171824-475740-0.ts\nEXT-X-DISCONTINUITY\nEXTINF:9.0,\nhttps://gloryleague-vid-encoded-syd-events.s3-ap-southeast-2.amazonaws.com/8/8/882b60b1-b825-4961-b2b9-2ce70ff8e842/475750/1460171824-475750-0.ts\nEXT-X-DISCONTINUITY\nEXTINF:9.0,\nhttps://gloryleague-vid-encoded-syd-events.s3-ap-southeast-2.amazonaws.com/8/8/882b60b1-b825-4961-b2b9-2ce70ff8e842/475782/1460171824-475782-0.ts\nEXT-X-DISCONTINUITY\nEXTINF:9.0,\nhttps://gloryleague-vid-encoded-syd-events.s3-ap-southeast-2.amazonaws.com/8/8/882b60b1-b825-4961-b2b9-2ce70ff8e842/475807/1460171824-475807-0.ts\nEXT-X-DISCONTINUITY\nEXTINF:9.0,\nhttps://gloryleague-vid-encoded-syd-events.s3-ap-southeast-2.amazonaws.com/8/8/882b60b1-b825-4961-b2b9-2ce70ff8e842/475716/1460171824-475716-0.ts\nEXT-X-DISCONTINUITY\nEXTINF:9.0,\nhttps://gloryleague-vid-encoded-syd-events.s3-ap-southeast-2.amazonaws.com/8/8/882b60b1-b825-4961-b2b9-2ce70ff8e842/475725/1460171824-475725-0.ts\nEXT-X-DISCONTINUITY\nEXTINF:9.0,\nhttps://gloryleague-vid-encoded-syd-events.s3-ap-southeast-2.amazonaws.com/8/8/882b60b1-b825-4961-b2b9-2ce70ff8e842/475650/1460171823-475650-0.ts\nEXT-X-DISCONTINUITY\nEXTINF:9.0,\nhttps://gloryleague-vid-encoded-syd-events.s3-ap-southeast-2.amazonaws.com/8/8/882b60b1-b825-4961-b2b9-2ce70ff8e842/475709/1460171824-475709-0.ts\nEXT-X-DISCONTINUITY\nEXTINF:9.0,\nhttps://gloryleague-vid-encoded-syd-events.s3-ap-southeast-2.amazonaws.com/8/8/882b60b1-b825-4961-b2b9-2ce70ff8e842/475703/1460171823-475703-0.ts\nEXT-X-DISCONTINUITY\nEXTINF:9.0,\nhttps://gloryleague-vid-encoded-syd-events.s3-ap-southeast-2.amazonaws.com/8/8/882b60b1-b825-4961-b2b9-2ce70ff8e842/475743/1460171824-475743-0.ts\nEXT-X-DISCONTINUITY\nEXTINF:9.0,\nhttps://gloryleague-vid-encoded-syd-events.s3-ap-southeast-2.amazonaws.com/8/8/882b60b1-b825-4961-b2b9-2ce70ff8e842/475785/1460171824-475785-0.ts\nEXT-X-DISCONTINUITY\nEXTINF:9.0,\nhttps://gloryleague-vid-encoded-syd-events.s3-ap-southeast-2.amazonaws.com/8/8/882b60b1-b825-4961-b2b9-2ce70ff8e842/475759/1460171824-475759-0.ts\nEXT-X-DISCONTINUITY\nEXTINF:9.0,\nhttps://gloryleague-vid-encoded-syd-events.s3-ap-southeast-2.amazonaws.com/8/8/882b60b1-b825-4961-b2b9-2ce70ff8e842/475789/1460171824-475789-0.ts\nEXT-X-DISCONTINUITY\nEXTINF:9.0,\nhttps://gloryleague-vid-encoded-syd-events.s3-ap-southeast-2.amazonaws.com/8/8/882b60b1-b825-4961-b2b9-2ce70ff8e842/475766/1460171824-475766-0.ts\nEXT-X-DISCONTINUITY\nEXTINF:9.0,\nhttps://gloryleague-vid-encoded-syd-events.s3-ap-southeast-2.amazonaws.com/8/8/882b60b1-b825-4961-b2b9-2ce70ff8e842/475797/1460171824-475797-0.ts\nEXT-X-DISCONTINUITY\nEXTINF:9.0,\nhttps://gloryleague-vid-encoded-syd-events.s3-ap-southeast-2.amazonaws.com/8/8/882b60b1-b825-4961-b2b9-2ce70ff8e842/475771/1460171824-475771-0.ts\nEXT-X-ENDLIST\n```\n. Looks fine with Chrome 56.0.2924.87, video.js 5.17.0 and videojs-contrib-hls 5.3.0. ",
    "powrsurg": "By latest do you mean you pulled from source, or the latest distribution. There was a bug in this and it was fixed 19 days ago.\n. @gesinger, beforeRequest replaces existing options. I believe that it should instead call mergeOptions to merge the existing options, with the options from beforeRequest overriding the existing options. Ideally I feel the code would be beter with:\nif (newOptions) {\n        options = mergeOptions(options, newOptions);\n}. @gesinger, this is going back a number of months where I am not working on that aspect of the project right now, but I believe the issue I had experienced was that the default timeout that is added a few lines prior was being lost since it was being replaced. I had to update my function to ensure that a timeout was set.. I was literally just starting to write a bug report for the main videojs library because this issue occurs there too for non-HLS content. On Android every request that needs withCredentials will fail because the native playback function does not send cookie data with it. The only way for a site to deliver content that requires cookies is for Html5.nativeSourceHandler.canPlayType, Html5.nativeSourceHandler.canHandleSource, and videojs.HlsSourceHandler.canPlayType to detect Android requests that need withCredentials and prevent them from return a successful criteria.\nI have currently figured out how to detect Android, but have not yet determined how to detect the specific player for the given request that is being tested. Once I do that I will submit a pull request to patch such.\n. It was just pointed out to me that I have been mistaken on this. Applying crossorigin=\"use-credentials\" fixed this for me.\n. We were running 1.3.11 with videojs 5.10.4 and one of our developers was experiencing that in Chrome, usually on videos that he has fullscreened. I just updated to 3.1.0 and am getting it pretty consistently with new videos. If you restart it works fine.\nOne thing I'm noticing is it seems to skip segments. For instance, in a recent occurrence it downloaded chunk 01.ts and then 03.ts and I had to click the video on the progress bar and to force it to get 02.ts.\n. I have found that the fixes from the live-stream-fixes branch seem to correct the issue for me. \n. I was allowed to take another video, so I have posted an example codepen:\nhttp://codepen.io/powrsurg/full/jrWzLv/\nIf you let the video play for a few seconds and then use Chrome's Dev Tools to throttle the speed to, say, Regular 3G, the video will end up pausing during playback.\nAlso, upgrading to version 3.5.3 does not fix the issue.\n. I just updated to the latest versions of VideoJS and the HLS plugin and it seems to be working for me. The player does get to spots where it may pause as it buffers, but it continues to play once it has the necessary segments.\n. ",
    "apatinoyu": "Hello @cambeyer, did you make it work? because I made it work but I had new issues on Safari and Edge, here the new issue -  Issue\nThanks.. Hello. Di you fix it? I am trying to set it as a global variable videojs.Hls.xhr.beforeRequest = function (options) {\n//here I add my headers\n}\nbut no success\n. Hi @kazazes, thanks for the help, did you test on Safari or Edge (those Browsers have Native Hls support )? \nI made it working with the current version hls-contrib @version 4.0.2, beforeRequest is called adding this line to confirm the override Native videojs.options.hls.overrideNative = true; \nDid not work on Safari, Edge.\n. Hello, thanks for your fast reply.\nI added the videojs-contrib-hls.js  from the repository v3.7.0-beta4 .\nand now I get the errors:  \nvideojs.Hls.xhr.beforeRequest  . while debugging Hls is undefined. \nor\nvideojs.options.hls.overrideNative = true;  while debugging options does not have hls, so hls is undefined.\nSo far I use the videojs-contrib-hls.js . Do I need something else from the repository  v3.7.0-beta4 ?\nRegards.\n. I built thev.3.7.0 Beta and added the contrib-hls.js into my project .\nGood news: I properly set and send the headers on Safari.\nBad new: I could not get a response, status still pending. \nI'll go deeper and be coming back in case I may close the issue.\nRegards.\n. ",
    "cambeyer": "@apatinoyu I was able to make it work after I pulled from source per @powrsurg's suggestion.  I haven't had need for this functionality recently and have only ever tried it in Chrome, never Safari or Edge.. ",
    "sdcoca": "Have similar issue. And see two additional unexpected behaviours:\n- If videojs.Hls.xhr.beforeRequest is changed, then it is never called since a copy of it seems to be used instead of the actual. Thus, if not updated before it is copied (which I cannot manage to do) then it is ignored.\n- When the player switches sources, the player.hls.xhr hook gets removed as if it was a new player instance.\n. ",
    "kazazes": "I'm also experiencing this regression. My videojs.hls.xhr overridden function used to be called, now it isn't.\n. @whatvn @apatinoyu @sdcoca, overriding the method on a per-player instance works. Try player.tech_.hls.xhr = videojs.Hls.xhr after initializing the player. Note, the player should already have an HLS stream as a source before this point or it won't have the hls tech. For whatever reason videojs is always loading the HLS methods from the defaults, even if they're overridden.\n. ",
    "afulist": "Similar issue to me. But v2.0.0 work fine.\n. ",
    "mayanksriv": "Used v2.0.0. Video didn't start for me. I had to scribe on the progress bar to start the video and then it played ok.\n. ",
    "nicenicenicerice": "I discovery that there is no problem by using another Pad \nInfo:\n(1)Android 4.4.4\n(2)Chrome 47.0.2526.83\nmay be it is the problem of pad.\n. ",
    "mishazawa": "478 .",
    "ptrwtts": "So while creating a reduced test case, I discovered that 2.1.1 actually fixes the issue. We were using 2.0.1 on our site. Is this stable, or should we hold out a little longer for a stable 2.1? Thanks!\n. Cheers\n. ",
    "chnl": "it isn't resolved v.3.5.3 in combination with v5.11.6\n. this solved it for me however... \nvar hls = player.tech({ IWillNotUseThisInPlugins: true }).hls;\n. ",
    "vineetphillips": "Thanks! \nit seems to be an issue with SegmentLoader not having the updated playlist, if the playlist has been loaded previously. \nRight now, triggering \"loadedplaylist\" on media change to a fully loaded playlists seems to have fixed it for me. But I know this isn't the optimal solution, thanks for looking into it.\n. 3.0.5 resolved this issue. thanks.\n. ",
    "mrocajr": "This has been tested and is working as expected.\n. QA verified.  No issues found.\n. Sounds good.\n. Perhaps video/MP2T would be more appropriate?. Yep, just noticed that \ud83d\udc4d . ",
    "nearwmy": "use  the version 2.0.1 ,and I try to change key for 'loadSegment' ,In this function can change 'removeToTime',but not work.because our ts sheet is really big ,so maybe over the chorme's limit\n. ",
    "RichardLanham": "I think I know what the problem was, and the solution. I was getting the identical error. Identical. But I think I fixed it incidentally by doing player.dispose().\nIn my case, I was creating, starting, and destroying multiple video.js HLS players. I noticed in the network tab that they weren't really going away, so I looked for the proper way to get rid of them: dispose(). The ghost players went away, of course, and incidentally, I have not seen this error since then.. ",
    "alexey2baranov": "I will try restrem it into internet as is (without recoding) and notify hire later\n. ",
    "josh-sachs": "Having the same issue here - videojs 5.11 confrib-hls ver 3.3.0.\nI've got a live stream running here \nhttps://j9x8b8p4.map2.ssl.hwcdn.net/hls/joshms-bre9g-qtmrc-8gkc7-3wqn2/index.m3u8\n. just to chime in, this is an issue for me with or without autoplay enabled.  \nWhat is interesting is I don't get the error when I load a master M3U8 manifest that has multi-rendition sub-manifests.   If the manifest I provide into videojs contains .ts segments directly then this error fires on initial play-start. \n. ",
    "Syra": "Same problem (videojs-contrib-hls 3.4.0 & Video.js 5.11.0).\nvideojs-contrib-hls.min.js:10 Uncaught InvalidStateError: MediaSource.addSeekableRange() can only be invoked when the duration is Infinity\nMy index.m3u8.\n\nEXTM3U\nEXT-X-VERSION:3\nEXT-X-MEDIA-SEQUENCE:66\nEXT-X-TARGETDURATION:25\nEXTINF:25.000,\n66.ts\nEXTINF:25.000,\n67.ts\nEXTINF:25.000,\n68.ts\nEXTINF:25.000,\n69.ts\nEXTINF:25.000,\n70.ts\nEXTINF:25.000,\n71.ts\n\nGenerated via https://github.com/arut/nginx-rtmp-module.\nProject https://github.com/dailymotion/hls.js didn't has that problem tho.\n. ",
    "mrmookie": "Same issue here 2 months later. Player still works but I see the errors.. ",
    "abondarenko": "The same for me.\nVersions: videojs-contrib-hls 3.5.2 & Video.js 5.13.2\nBrowser: Google Chrome\nCan't give you playlist sample. :-(. ",
    "Kasher": ":+1: \n. :+1: \nstill happens in version 3.7.0-beta4. Thanks you @mjneil ,you have helped me a lot :+1: :+1: \nI will try the beta version for sure .\n. :+1: \nThis is really a critical bug for us.\nIs there any estimation about how long will it take to fix it?\nThanks!. ",
    "julius": "+1 (videojs 5.10.4, contrib-hls 3.0.4)\n. The last contrib-hls version which has sound for me is 2.1.1\n. ",
    "PLobo87": "Also occurs on Mac / Chrome with videojs 5.10.4, contrib-hls 3.0.4\n. ",
    "zhufengme": "Also occurs on Win10 / Chrome51.0.2704.79 with videojs 5.10.4, contrib-hls 3.0.4\nThe test url: http://devlink.cn/videojs/test.html\n. ",
    "chrisfronda": "Any updates...now a total of a month with no answer or even a clue has gone by....I know we are all busy but I guess I am using JW Player after all...\n. Gotcha...well is it considered a problem on my end or your end?  Should I be matching bitrates or is it acceptable that I'm not?  And if its your end, any idea on a fix for this?\n. I do not get the flickering with JWPlayer\n. Ugh...wasted my time again. JW Player it is.\n. If someone else runs into this, please be aware that no help will be provided by VideoJS guys.\nI find it a bit odd MMCC you would not help for over a month and then post that you guys are happy to dig into it without attempting to resolve mine.\n. ",
    "twinfifty": "I can confirm this issue. It flickers when switching between bitrates.\n. ",
    "slowmove": "@gkatsev as of now you do keep getting cue events when timed metadata events is fetched. Often this is used for ads, in which case you would like to have an event when the ad is over, i.e. the metadata has stopped.\nI do understand that this may be impossible by how the metadata track is implemented in html5, but would like to get it confirmed in that case.\n. ",
    "clzola": "@gkatsev For example lets have 240p, 360p,480p, 720p, 1080p.\nIf I want to show video 720p, i should iterate over all representations and for each that is <= 720p I should call enabled(true) otherwise enabled(false).\nOr for 360p, i should call for all that are <= 360 enabled(true) otherwise enabled(false)\nOr should I call enabled(true) only for that particular level and calling enabled(false) for others?\n. ",
    "adityaj221": "When I try to run player.hls.representation() on Safari. It throws an error \nTypeError: undefined is not an object (evaluating 'player.hls.representations')\n\nCan anyone help me on this.\n. @piotr-cz Yes I'm using the latest version of videojs-contrib-hls\nAlso, the above screenshot is from the live example\nSame thing is happening on my code as well and we do have audio too in the stream. I'm using:\nvideojs: 5.11.6\nvideojs-contrib-hls: 3.5.3\n. @gkatsev - Is there a way in the native HLS implementation to set the representations in that case.?\n. Thanks for the information. \n. @gkatsev - I've seen this link by hls.js and they have the manual switching implemented. \n. @stoicbuddha Was this fixed for you.?\nHow did you address this. I'm facing the same issues with cookies not being sent on player calls on iOS  Safari.\nIt works on desktop clients.. ",
    "blazarev": "not sure that you really need in this case manually select playlist through player.hls.playlists.media call. Seems to be enough to disable all representations except selected - then default adaptive algorithm will have no choice, except one enabled representation.\n. ",
    "achru": "thank you, tried that branch, but same thing happens \n. ",
    "Rellim7": "I have encountered what i think is a similar issue to this on a later release.\nwindows/chrome\nvideojs 5.16\nvideojs-contrib-hls 4.1.1\nA video will consistently freeze at 1:17 with this combo.   Here is a jsbin of the video that will do it.\nhttp://jsbin.com/miyunoleqa/edit?html,console,output\nThis might be a separate issue though.. ",
    "laurent-dazzl": "Same (?) issue with live casts using Evostream Media Server solution.\nvideo.js version 5.16.0, videojs-contrib-hls 5.2.1\nHLS play fine with Safari on MacOS, Safari on iOS, firefox on iOS, Chrome on Android,\nbut freeze on chrome and firefox on MacOS.\nChrome gives more logs :\na first error \nVIDEOJS: ERROR: (CODE:3 MEDIA_ERR_DECODE) The media playback was aborted due to a corruption problem or because the media used features your browser did not support.\nthen a repeated error (maybe each time the playlist is reloaded) : \nUncaught DOMException: Failed to set the 'duration' property on 'MediaSource': The MediaSource's readyState is not 'open'.\nFirefox gives no logs, continue to get the playlist file but stop getting video segments. ",
    "asharptlm": "I wouldn't say \"randomly\" but I am having a somewhat similar issue. Using videojs-contrib-hls with \"overrideNative\" on, and after a small fix (see below) I get the same MEDIA_ERR_DECODE. \nI have written my own monitoring Component in videojs for both the segment being streamed/downloaded, and the segment being played. At the point at which it tries to playback a segment from a different playlist, is when the error occurs. ie, it has acquired segments of a better quality, but crashes when it tries to play those segments.\nFor some further detail:\nPlatform: 2011 MacBook pro running macOS Sierra (10.12), error is on Safari Version 10.0 (12602.1.50.0.10). I am using videojs-contrib-hls version 5.4.0 with Video.js 6.0.0-RC.6\nIt DOES work however on the same MacBook's Chrome (which does not need overrideNative) and Android's (Samsung Galaxy S6) latest Chrome (which does need overrideNative). The stream I am using (internal only, unfortunately) also plays fine in native Safari HLS support but of course I can neither see nor control what it is doing with the playlist.\nI am also enabling cueTags in order to utilise the cuechange event to see when the playlist changes. With this enabled, for Safari to even start playing video at all (a TypeError occurs otherwise), I had to comment out this line in MasterPlaylistController:\nthis.cueTagsTrack_.inBandMetadataTrackDispatchType = '';\nHOWEVER I have just tested without cues at all, and put that line back in, and I still get the Decode error, so I am certain it is unrelated. There are otherwise zero customisations to videojs and -contrib-hls libraries themselves.\n. Thank you for response, @gesinger . I've also since discovered that on iOS (Chrome and Safari on iOS 9.3.5 for iPad, and Safari on iOS 10.xx tested so far) that overrideNative is having no effect - indeed no hls tech is loaded at all into videojs in such cases. Of course, I can use the native hls implementation just fine, but the additional insight into activity with your contrib package is very useful.\nI didn't find any specific instructions for making the hls contrib package work on iOS, nor have I found anyone else reporting this as an issue - so forgive me if I've missed anything. I also apologise if this is not the best place to post the issue; I can make a separate report, but I figured all things related to overrideNative are really best in one place?. ",
    "scottschafer": "Actually, installing the latest version of Flash Player solved this issue.\n. ",
    "sobytes": "Also have this issue\n. I also seem to be getting this error.\n. I increase my segments from 10s to 20s.\nThis still doesn't work i am getting it will lots of videos load fine first time then certain playlists don't load they get blacklisted.\nXMLHttpRequest cannot load https://ireland.s3-eu-west-1.amazonaws.com/encoded/hls1500k/hls1500k.m3u8. No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'https://example.com' is therefore not allowed access.\nexample.min.js?ver=60:16 VIDEOJS: WARN: Problem encountered with the current HLS playlist. Switching to another playlist.\nMy aws bucket cors are fully open.\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<CORSConfiguration xmlns=\"http://s3.amazonaws.com/doc/2006-03-01/\">\n    <CORSRule>\n        <AllowedOrigin>*</AllowedOrigin>\n        <AllowedMethod>GET</AllowedMethod>\n        <MaxAgeSeconds>30000</MaxAgeSeconds>\n        <AllowedHeader>*</AllowedHeader>\n    </CORSRule>\n</CORSConfiguration>\nGoing to keep going through the code see if i can find a fix, it must be something to do with the xhr i am thinking..\nThanks\n. This seems to work best.\nvar hls = videoPlayer.tech({ IWillNotUseThisInPlugins: true }).hls;\n                    videoPlayer.on('timeupdate', function () {\n                        var sdata = hls.selectPlaylist();\n                        hls.representations().forEach(function(rep) {\n                            if(sdata.attributes.BANDWIDTH === rep.bandwidth){\n                                console.log(rep);\n                            }\n                        });\n                    });\n. A bit simpler.\n```\nvideoPlayer.controlBar.addChild('button', {\n    text: \"\",\n    tabIndex: 999\n}).addClass(\"button-999\");\nvar hls = videoPlayer.tech({\n    IWillNotUseThisInPlugins: true\n}).hls;\nvideoPlayer.on('timeupdate', function() {\n    var sdata = hls.selectPlaylist();\n    $(\".button-999\").html(sdata.uri);\n});\n```\n. Hi All,\nNot a silly issue i would also like to know if there is a work around for this issue here is what i currently have.\nApologies for the terrible code in advance.\n```\nvar isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\nvar videoPlayer = videojs(\"video\", {\n    \"preload\": \"none\",\n    \"techOrder\": (isSafari) ? [\"html5\"] : [\"flash\", \"html5\"],\n    \"autoplay\": true\n}, function() {\n    $(\"#video .vjs-control-bar\").addClass(\"vjs-control-bar-float\");\n    $(\"#video .vjs-progress-control\").css(\"opacity\", 0);\n    $(\"#video .vjs-remaining-time-display\").text(\"LIVE\");\n    if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {\n} else {\n    var extraButtons = [{\n        text: \"Brand\",\n        image: \"/images/circle_red.png\",\n        link: \"http://sobytes.com\"\n    }];\n    for (var i = extraButtons.length - 1; i >= 0; i--) {\n        var brandButton = videoPlayer.controlBar.addChild('button', {\n            text: extraButtons[i].text,\n            tabIndex: i\n        });\n        brandButton.addClass(\"sobytes-brand-button-\" + i);\n        $(\".sobytes-brand-button-\" + i).html(\"<a onclick='return false;' href='#'><img id='sobytes-live-image' width='20' src='\" + extraButtons[i].image + \"' /></a>\");\n    };\n    var last_value = 0;\n    var offline_test = 0;\n    videoPlayer.on('timeupdate', function() {\n        $(\"#sobytes-liveplayer-offline-message\").hide();\n        if (videoPlayer.currentTime() === last_value) {\n            if (offline_test > 3) {\n                videoPlayer.userActive(true);\n                $(\"#video .vjs-live-display\").text(\"OFFLINE\");\n                $(\"#video .vjs-remaining-time-display\").text(\"OFFLINE\");\n                $(\"#sobytes-live-image\").attr(\"src\", \"/images/circle_red.png\");\n                offline_test = 0;\n            }\n            offline_test++;\n        } else {\n            offline_test = 0;\n            $(\"#video .vjs-live-display\").text(\"LIVE\");\n            $(\"#video .vjs-remaining-time-display\").text(\"LIVE\");\n            $(\"#sobytes-live-image\").attr(\"src\", \"/images/circle_green.png\");\n        }\n        last_value = videoPlayer.currentTime();\n    });\n    videoPlayer.on('error', function() {\n        $(\"#sobytes-mediajs-broadcaster-video-mobile-\" + options.Pid).append('<span id=\"sobytes-liveplayer-offline-message\">' + options.OfflineMessage + '. <a onclick=\"window.location.reload(); return false;\" href=\"#\">Refresh</a></span>');\n        $(\"#sobytes-liveplayer-offline-message\").css(\"opacity\", 1);\n    });\n}\n\n});\n```\nThe reason there is a safari call at the top is because safari does not handle rtmp streaming very well which is what i have setup rtmp then hls.\n. Any suggestions on why this might be happening or what I can look into to help try find a solution?\nThanks \n. This works.\nvideoPlayer.on('loadedmetadata', function(){\n                    var hls = videoPlayer.tech({ IWillNotUseThisInPlugins: true }).hls;\n                    hls.representations().forEach(function(rep) {\n                        console.log(rep);\n                      /*if (rep.width >= 720) {\n                        rep.enabled(true);\n                      } else {\n                        rep.enabled(false);\n                      }*/\n                    });\n                });\n. Here is a little pure js solution for resolution switching that i thought i would share.\nIt doesn't work in firefox yet it will output this error.\n\nVIDEOJS: WARN: \"The rendition that we tried to switch to had different audio properties (channels, sample rate, etc.) or changed in some other way.  This behavior is currently unsupported in Firefox due to an issue: \n\nhttps://bugzilla.mozilla.org/show_bug.cgi?id=1247138\nUnfortunately that means we will have to blacklist the current playlist and switch to another. \n\nSorry!\"\n\nHope fully there will be a fix soon and it also doesn't work in safari but i am looking into this i think from a previous post its because it default back to safari's in built hls.\n```\nvar hls = videoPlayer.tech({\n    IWillNotUseThisInPlugins: true\n}).hls;\nfunction addResolutionSwitches(data) {\nvar myPlayer = data.player,\n    controlBar,\n    newElement = document.createElement('div');\n\nnewElement.id = \"switch\";\nnewElement.className = 'vjs-hide-me vjs-control line-height';\n\n\nvar menuUL = document.createElement(\"ul\");\nmenuUL.className = 'vjs-menu-content';\nmenuUL.style.width = \"50px\";\nmenuUL.style.left = \"25px\";\n\nfor (var i = 0; i < data.buttons.length; i++) {\n    var child = document.createElement(\"li\");\n    child.className = 'vjs-menu-item';\n    child.id = data.buttons[i].width;\n    child.style.fontSize = \"10px\";\n    child.innerHTML = data.buttons[i].uri + '<span class=\"vjs-control-text\"></span>';\n    child.addEventListener(\"click\", function(e) {\n\n        var ratesSelected = this.getAttribute(\"id\");\n        var hls = videoPlayer.tech({\n            IWillNotUseThisInPlugins: true\n        }).hls;\n        hls.representations().forEach(function(rep) {\n            if (rep.width == ratesSelected) {\n                rep.enabled(true);\n            } else {\n                rep.enabled(false);\n            }\n        });\n\n    }, false);\n    menuUL.appendChild(child);\n}\n\nnewElement.innerHTML = '<div class=\"vjs-playback-rate vjs-menu-button vjs-menu-button-popup vjs-control vjs-button \" tabindex=\"0\" role=\"menuitem\" aria-live=\"polite\" aria-expanded=\"false\" aria-haspopup=\"true\"><div class=\"vjs-menu res-btn\" role=\"presentation\"></div>' +\n    '<span class=\"vjs-control-text\">Playback Rate</span>' +\n    '<div class=\"vjs-playback-rate-value\">' +\n    '<i class=\"fa fa-cog line-height\"></i>' +\n    '</div>' +\n    '</div>';\n\n\ncontrolBar = document.getElementsByClassName('vjs-control-bar')[0];\ninsertBeforeNode = document.getElementsByClassName(\"vjs-fullscreen-control\")[0];\ncontrolBar.insertBefore(newElement, insertBeforeNode);\napUl = document.getElementsByClassName('res-btn')[0];\napUl.appendChild(menuUL);\n\nreturn newElement;\n\n}\nvar setupReosltionButtonsOnce = true;\nvideoPlayer.on('loadedmetadata', function() {\nif (setupReosltionButtonsOnce) {\n\n    var playlistOutputs = [];\n    var mapIt = hls.playlists.master.playlists;\n\n    hls.representations().forEach(function(rep, index) {\n\n        var hurl = mapIt[index].uri;\n        rep.uri = hurl.substring(0, hurl.indexOf('/'));\n        playlistOutputs.push(rep);\n\n    });\n\n    var ratesBtn = addResolutionSwitches({\n        buttons: playlistOutputs\n    });\n    setupReosltionButtonsOnce = false;\n\n}\n\n});\n```\n. This issue relates to having different audio encoding settings for individual playlists keep them all the same and they encode and play correctly. \n. ",
    "pswolfe": "Great, thanks @gkatsev and @nickygerritsen ! You'll have a PR coming up on the m3u8-parser soon. \n. Hey again. I've done the work on the parser; you can find the PR for my proposed changes here.\n. This work has been merged into the parser codebase; will close the ticket once it becomes available through NPM. \n. Closing since this has been deployed in 1.1.0 of the m3u8-parser on NPM.\n. ",
    "CSilivestru": "I had a very similar experience but it turned out that I was editing my playlist files in TextEdit on MacOS X and, since Mavericks, it doesn't insert ASCII compliant quotes in your plain text documents. This was causing my playlist files to look correct but be mis-parsed.\nI highly suggest you run your stream files through Apple's mediastreamvalidator module. Helpful video here\nYou can download the tools at their developer download page here\nHope that helps!\n. ",
    "TV5Dev": "I have just curled some of my playlist files.\nThe primary child playlist contains following:\nEXTM3U\nEXT-X-TARGETDURATION:9\nEXT-X-MEDIA-SEQUENCE:5594\nEXTINF:9,\nWhile the backup child playlist contains following:\nEXTM3U\nEXT-X-TARGETDURATION:9\nEXT-X-MEDIA-SEQUENCE:72745\nEXTINF:9,\nCould anyone confirm that for primary / backup failover this sequence number needs to be exactly the same, and that the .ts file names don't matter at all?\nThanks in advance.\n. https://tools.ietf.org/html/draft-pantos-http-live-streaming-19#section-6.3.2\n\nA client MUST NOT assume that segments with the same Media Sequence Number in different    Variant Streams or Renditions have the same position in the presentation; Playlists MAY have independent Media Sequence Numbers.  Instead, a client MUST use the relative position of each segment on the Playlist timeline and its Discontinuity Sequence Number to locate corresponding segments.\n\nSo looking into another reason on why this is happening.\n. Looks like videojs-contrib-hls is using the sequence numbers to calculate the position.\nhttp://pastebin.com/xYWvZdm7 @ line 550 you can see what happens when it switches from primary to backup.\n. Well... The root cause was not the Media Sequence Numbers, but rather PTS/DTS timestamps in individual .ts packets not being in Sync. Using a MPEG-2 TS packet analyser, you can download the matching segments between primary and backup (same video), and open both in the analyser. Then you may see the PTS/DTS timestamps. This number should be very close to each other, if not identical. Now if this is not the case, it's only normal that the player would keep searching for next presentation timestamp in other packets, which will never be found, causing it to hang or loop forever.. Reading through the HLS spec : https://tools.ietf.org/html/draft-pantos-http-live-streaming-19#section-6.2.4\n\nEach Variant Stream MUST present the same content. (quite impossible when you have two independent systems generating the same stream)\nMatching content in Variant Streams MUST have matching timestamps. This allows clients to synchronize the media.\n\nYou can download the ffmpeg package, which includes ffprobe, which allows you to analyse the segment PTS/DTS values. \"ffprobe -show_entries packet=codec_type,stream_index,pts,dts inputfile> output\"\nAlso having tried various famous players, all have the same problem, they get stuck when trying to switch to a failover playlist.\nFor example one can see the primary PTS would be 7214757856 and the backup PTS would be 4747165408. If you would like to see timestamps you can do so using following command \"ffprobe -show_entries packet=pts_time,duration_time inputfile > output\"\nThis will output 80163.976178 and 52746.282311 for both segments files instead of the previously mentioned value.\nHowever for working failover streams we can see the PTS/DTS values are aligned quite closely.\nFilenames or media sequence number do not matter for failover to work, unless the players have implemented the HLS spec wrongly.\nEdited to add pts_time command.. The problem we face is the primary and backup are from 100% independent sources. Haven't found a solution for our case other than using a device which takes two signals and outputs it into one. This one signal would then be encoded into a primary and backup stream. (from the same source) However having this device would beat the purpose of a failover since it's not redundant...\n. ",
    "RyanEdwardHall": "I've encountered this problem too. If the media sequence number of the backup stream is behind master, the player will sit in a buffering state until it catches up. Have you found a good resolution?\n. ",
    "bradleyfalzon": "If a playlist switches, the player should also know that the timestamps will not match between segments of primary stream to the backup stream, it should treat the new playlist as if it had a discontinuity flag. \nI'd say the issue is not that the two backends had different timestamps, but the player, when switching should've been aware this would happen and do whatever it does when it comes across a EXT-X-DISCONTINUITY flag.. Matching content in Variant Streams MUST have matching timestamps. This allows clients to synchronize the media. Yes, that does make my statement incorrect, thanks for clarifying.. ",
    "topherlandry": "@TV5Dev Did you solve this problem for your system then? It sounds like it would be quite the feat to ensure that the packets were in sync with PTS, since analyzing during transcode to figure out where your PTS would begin could be off, since that is a moving target.\nI suppose that's not terrible if you are able to estimate since you've found that closely aligned values are not at fault.. It should be fine, because \"primary / backup\" are really just terms we use for simplification. Should be good for all variant streams.. ",
    "allensun421": "same problem here, how you guys solved it out?. ",
    "yonimor": "+1. +1. ",
    "parkej60": "Seeing pretty much the exact same thing. Works fine in Safari, but get these errors in Chrome. Any updates? \n. ",
    "samueleastdev": "Hi @gesinger this issue has defiantly been resolved in one of the updates no longer having any issues. . I was also getting this error on IE 11 \n~~~\nNo compatible source\n~~~\nBut after installing flash then everything worked fine, can we alert the user that not having flash installed is the cause of the issue?\nHow would you hook into a specific error message for IE using the video js framework? and present the user with a clearer message informing them to download flash ill have a go at setting it up.\nThanks \n. Just an update for testing works fine in every other browser and mobile I have tested just seems to be an issue with chrome\n. Any suggestions on what I can check for? \nI have tried the latest version and it still stops on the specific segment should it switch?\nThanks \n. Ok thanks @mjneil that would be great. \n. Awesome I see it's all working with the new version ;) really appreciate your updates on this legends \n. Hi @gkatsev,\nThanks for the update.\nI have tried adding this to my .htaccess. \n~~~\nSolution using mod_headers and mod_setenvif\n\n       SetEnvIf Origin (.*) AccessControlAllowOrigin=$1\n       Header add Access-Control-Allow-Origin %{AccessControlAllowOrigin}e env=AccessControlAllowOrigin\n       Header set Access-Control-Allow-Credentials true\n \n~~~\nAnd tried adding this to my vhosts file\n~~~\nHeader set Access-Control-Allow-Origin \"*\"\n~~~\nAnd tried adding this to my php app\n~~~\nheader('Access-Control-Allow-Origin: *');\n~~~\nNot sure what else i can try?. ah right ok thanks @gkatsev . Hi @sea-kg,\nThanks for the response sorry for the basic question but where are you putting this in your code after the ready call?\n~~~\nvar videoPlayer = videojs(\"video-player\", {}, function() {\n    var player = this;\n    player.options.overrideNative = true;\n});\n//or just after the call\nvideoPlayer.options.overrideNative = true;\n~~~\nThanks. Ah right thanks @sea-kg felt a bit dumb fo asking but better to know ;)\n. Working now thanks ill close ;). Hi All,\nI am also getting this issue on android chrome it won't work for me.\nTo test you can paste this url.\nhttps://s3.amazonaws.com/Loop.Sam/alien-covenant-trailer-1_h1080p/encoded-Sun-Mar-2017-19-00-42/encoded-Sun-Mar-2017-19-00-42.m3u8\nInto the demo.\nhttps://videojs.github.io/videojs-contrib-hls/\nI am testing on a Samsung Galaxy S3.\nThanks\n. @selimatmaca yes I think that might be the case spent the whole day trying to debug this ended up stripping everything back to just the basic HTML video tag with a mp4 and I was still getting issues I posted an issue here. https://github.com/videojs/video.js/issues/4214 then I suddenly had an update to Chrome on Android and it started working I upgraded to version 56.0.2924.87 . Hi All,\nAfter finding out it wasn't working in the desktop browsers either and debugging this some more, the link plays fine in VLC player and pasted directly into Safari.\nI rolled back the release one by one and it turns out everything worked up until version 5.5.1 on a desktop browser so the issue seems to have been introduced in this version, taking a look at the logs to see if I can find out what changed just to note this is only an audio m3u8.\nVersion 5.5.0 works in the browser haven't tested on mobile Safari running some more tests today.\nThanks\n. I feel like our issue is related.\nTested with this url this will work up to version 5.5.0 but doesn't work in version 5.6.0\nExample here: http://jsbin.com/gavunimaku/1/edit?html,output\nSimply switch the version in the url to see the error.\nThanks\n. Just to update tested with 5.7.0 latest release and this still seems to be happening sometimes it will work and then it will stall again.\nTo test Example here: http://jsbin.com/gavunimaku/1/edit?html,output \nKeep clicking run with js then click play.\nversion 5.5.0 will always play version 5.7.0 will play and then sometimes stall.\nThanks. Awesome thanks, @mjneil ;) not sure whether this issue might be related.\nhttps://github.com/videojs/video.js/issues/4483\nI haven't tested in IE ill run some tests today.\nThanks\n. Yes, this is exactly the same problem as @mjneil mention tested up to 5.8.0\nWe are running video.js 5.20.1 & video.js hls 5.5.0 without any issues anything higher than that it breaks.. We have had issues when setting overrideNative from Safari users.\nI am not sure it is the best option for every situation just from our experience leaving native take over has resolved problems. I agree it would be great to have it set as default but is it granted to work in every scenario?\n. ok, thanks @forbesjo good to know ;). Hi @forbesjo,\nSo would you suggest doing this until it has been imlemented?\nif (!navigator.userAgent.match(/iPhone|iPad|iPod/i)) {\n    videojs.options.hls.overrideNative = true;\n    videojs.options.html5.nativeAudioTracks = false;\n    videojs.options.html5.nativeTextTracks = false;\n}\n// Video js code\nWill this resolve IE issues\n. @mjneil updated to also work in output . Hi @mjneil \nI tried that, I have updated the jsbin links with the new setup.\nhttp://jsbin.com/gofibonahe/1/edit?html,output\nhttp://output.jsbin.com/gofibonahe\nHere is also a full screengrab of the output of the chrome inspection tools with the Samsung Galaxy plugged in.\n\nI initially didn't think it was an issue but I can definitely recreate it on my Samsung Galaxy.\nThe issue is only related to Android Chrome if I open up the jsbin output in Firefox on the same Android phone it will work without and issues.\nLet me know what other information could be provided to try to find the issue, spent a long time with AWS support and they seem to think it's a player issue?\nThey mentioned something about the content range\nContent-Length:705\nContent-Range:bytes 0-704/705\nThanks\n. So debugging a little further.\nOn Android the Response Headers are as follows.\n~~~\nAccept-Ranges:bytes\nContent-Length:705\nContent-Range:bytes 0-704/705\nContent-Type:application/x-mpegURL\n~~~\nAnd on iPhone Chrome, desktop Chrome they are.\n~~~\nAccept-Ranges:bytes\nAccess-Control-Allow-Methods:GET\nAccess-Control-Allow-Origin:*\nAccess-Control-Max-Age:3000\nContent-Length:705\nContent-Type:application/x-mpegURL\n~~~\nAlso related this seems to be the exact issue i am facing: https://productforums.google.com/forum/#!topic/chrome/3irwxyZYQBU\nThink it might be an Android Chrome bug posted about it here: https://bugs.chromium.org/p/chromium/issues/detail?id=734441&can=2&start=0&num=100&q=m3u8&colspec=ID%20Pri%20M%20Stars%20ReleaseBlock%20Component%20Status%20Owner%20Summary%20OS%20Modified&groupby=&sort=. This post is also related https://github.com/bentasker/HLS-Stream-Creator/issues/16\n\nThose first 2 requests do include the referer - I'm not sure why the player drops it.... Going to close this issue the HTTP referrer lockdown seems unreliable and not all browsers send the referrer, going to look into signed cookies.. Found the error so I will close, I had two Chrome extensions installed.\n\nFlash Video Downloader\nVideo Downloader professional\nAs soon as I disabled these two extensions all my errors went away it actually solved a few things. Its good in a way because it prevents users having those plugins installed.\n. Hi @mjneil,\nThanks for the quick response ;) but if you test on a iPhone with Chrome Browser or Android with Chrome it doesnt work for me. Works through the dev tools but not a real device?\n. Strange it's definitely not working for me I am running on quite an old Samsung S3, and it's not working on my iPhone 6 what I'm seeing below.\n\n. I just fired up a Samsung S7 with Genymotion and it appears to be working on that, I guess its old Androids (maybe specific versions) and IOS.\n\n. Hi, @forbesjo thanks for the info pretty sure my Samsung S3 Android is running lower than 4.4. \nSo we can only expect to get the representations on Android 4.4 that's fine at least I can relay the info to my users ;). Hi @robov @gesinger @mjneil \nI know this is closed but I was wondering if any has found a solution to prevent this extension with 128 AES encrypted hls?\nhttps://addons.mozilla.org/en-GB/firefox/addon/video-downloadhelper/\nNot sure how it gets around the encryption if you go to its preferences after it's been installed and check.\nRequest headers: Download using the same headers as the original request\nWithout this checked it doesn't work just interested if anyone has a solution?\nThanks. ",
    "ianwelsh": "Yes, https://github.com/videojs/mux.js/pull/112 fixed it.. ",
    "Boxie5": "After update contrib-hls to 4.10.0 and videojs to 5.16.0, I'm still facing this issue while #798 is not happening.\nI dig into the code of contrib-hls, found that was because segment repeats downloading when timeout. This is implemented in #770 .\nBut this really happens frequently if our customers try to switch to a resolution which needs higher network speed. Basically, this will led to loading repeatedly forever and a lot of wasted traffic.\nSo, I would like to ask is it possible to set the timeout value dynamically for different repeating times. Looking forward to @mjneil 's reply, thinks a lot!. ",
    "xarques": "Hi,\nI've got the same issue on Chrome :\nvideojs-contrib-hls.min.js:9 Uncaught NotSupportedError: Failed to execute 'addSourceBuffer' on 'MediaSource': The type provided ('audio/mp4;codecs=\"mp4a.804c\"') is unsupported.\nAny updates ?\nThanks\n. I tried to catch the exception raised by the native browser and then replace the codec by a default one (defaultCodecs = {\"audio\": \"mp4a.40.2\", \"video\":\"avc1.4d400d\"}.\nIt works but every 10 seconds (size of each segment), the player stops the video during 1 second and then plays the next segment. Any idea why ?\nMy workaround is available here :\nhttps://gist.github.com/xarques/4b9f689c9287f99ce6fa85a84c57eb6d\n. ",
    "marguinbc": "@imbcmdth, broke out the functionality that checks for the portion to be trimmed as trimBuffer_() - feel free to re-review.\n. QA passed. Looking for one more core contributor to review and add a LGTM\n. Thanks @gesinger! I found and fixed it, but now I am behind master again so I need to rebase, etc.\n. Think I fixed my branch - reopening\n. There is a test that is failing that has been fixed by PR 838\n. Sure thing!\n. ",
    "crmsoft": "+1\n. ",
    "titpetric": "I am experiencing a similar problem with shorter chunks. The m3u8 request before the last .ts gives me 3 chunks, with duration of [10, 10, 2.8], and playlist target duration probablly at 10 or 11 secs. Unfortunately you didn't include the m3u8 before the last .ts request, I suspect it might be the same. Did you ever solve this issue?\n. I'm dealing with the same scenario as @ddunkin, we're using wowza and simulating live streams with a stream schedule smil. We set the pre-roll to repeat=true for the amount of 10 minutes, keyframe 10 seconds, but duration not exactly 10 seconds (10.2). Chunks while the pre-roll is playing are 10 seconds each, but as soon as the pre-roll ends and the video begins, one of the chunks drops down way below TARGETDURATION, at about 2.8 seconds. This is somehow random and depends on pre-roll duration and timing I guess. When this happens, videojs requests this short .ts chunk, displays \"playback aborted due to corruption or unsupported media features\", stops requesting .ts chunks, but keeps requesting .m3u8.\nAny ideas?\n. Going to a low keyframe results in a m3u8 like this, completely breaks videojs immediately:\n```\nEXTM3U\nEXT-X-VERSION:3\nEXT-X-TARGETDURATION:10\nEXT-X-MEDIA-SEQUENCE:25\nEXTINF:1.666,\nmedia-ucg6f0kgw_b1500000_25.ts\nEXTINF:2.1,\nmedia-ucg6f0kgw_b1500000_26.ts\nEXTINF:0.666,\nmedia-ucg6f0kgw_b1500000_27.ts\n```\n. @gesinger Ah your guess is as good as mine. The thing is that I suspect Wowza should report TARGETDURATION=3 at this point - because the video switches to a low-latency one (meaning, shorter keyframe intervals). The issue became apparent when the video with keyframes @ 10secs (pre-roll loop) switches to the live video with keyframes @ 1-2 sec...\nIn other words, TARGETDURATION= should be ignored completely, and calculated from the EXTINF values depending on what the chunklist returns. This may already be done, didn't check code.. ",
    "apara": "BROWSER: Google Chrome Version 56.0.2924.87 (64-bit)\nOS: MacOS Sierra 10.12.3\nLibraries used:\nhttps://vjs.zencdn.net/5.16.0/video.js\nhttps://cdnjs.cloudflare.com/ajax/libs/videojs-contrib-hls/5.2.1/videojs-contrib-hls.js\nWe have been testing with Wowza streaming and are seeing the same behaviour.  After some time, the player just downloads the chunklist and no segments are being retrieved.\n\nThe VLC player we have running side-by-side, is working just fine and is having no issues with playing the HLS stream.  We are also playing the RTMP stream at the same time using VideoJS and that stream is also continuing to play just fine.\nThe .html file we are using for our test is attached.\nindex2.html.zip\nThis is a serious issue for us that is making us look at other solutions.  . I re-uploaded the file zipped.  Working on making the stream available publically without exposing our server to script kiddies.  Thanks for any help you guys can offer.. Here is the public URL: \nhttp://wowza-1646319330.us-east-1.elb.amazonaws.com/123-Live/Alex-Demo-Prep/manifest.m3u8\nUpdated code to use the public URL:\nindex2.html.zip\nMake sure to open the player and let it run for a while...\nThe stream is running now.... I have been able to re-create the failure.  Just need to leave the browser up and running for a bit.\n\n. @gesinger I am leaving the stream running.  I can consistently get the HLS to hang.  All I do is start the browser and then walk away or get tied up in the meetings.  When I come back, it's usually hung.  Let me know if you are going to have a chance to look at or troubleshoot this, otherwise I will stop the stream.. @gesinger I will leave the stream running for the weekend into next week.  Let me know when you are done with it and I will shut it down.\nThanks for the heads up on the playlist window, we may need to adjust that anyway for better reliability of the stream.  We will not make the change,  until you have had a chance to test/verify new code/branch.. @gesinger do you still need the stream running?. ",
    "maddygoround": "Here it is - http://djyjlsv34fx05.cloudfront.net/10minscat/10minscat.m3u8\n. good to know.\n. ",
    "ellyjonez": "Any movement here? I've noticed this happening as well, on OSX Chrome and OSX Firefox. I am concerned it may be contributing to an uptick in complaints from our users about video stopping to buffer too much.\nvideojs version: 5.10.7\nvjs-hls-contrib version: 3.5.3\nhere's a screenshot of what I'm seeing. (those POSTs to viewing_events.json is our event tracker at work):\n\n. ",
    "benvirus": "I've solved this problem and will make a pull request as soon as possible.Be patient.\n. Thank you very much for your reply.\nI tried the link on windows10 and chrome 51.0.2704.106 m.\nPlease look at the screenshot as follow:\n\nAs you can see: the video can not show the whole picture of the video file.\nBut on mac OS,test with chrome 53.0.2785.143.Please see the screenshot as follow and focus on the part marked with red line:\n\nNow The difference appears.\nLooking forward for your reply.\nThank you again.\n. @ghaydarov We generate the m3u8 file everytime when the browser request the playlist. So we have chance to generate the key link everytime and we only allow one request to the key from every key link.The next time request from the same key link ,you will get a wrong key. For more, we encrypt our key with our own encryption algorithm and decript it in video-contrib-hls plugin.\nFrom more ,Please email to benchen19921130@gmail.com without hesitation.. ",
    "arski": "@kevinzang was it failing always on W7IE11? I tried the steps to reproduce and it plays fine.. hmm.. is the patch really necessary?. @piotr-cz @thecotne I read through the thread multiple times but still can't quite figure out what to do.. I'm having a similar issue with my m3u8, Chrome on Android returns a 200 for the request, but nothing in the body, so the player is just stalled.. Works on FF/Android, Chrome/Desktop etc.\nI know on Safari on OSX, when there is an issue with the CORS headers, the request returns a 403, which is.. fine, OK, different problem. But the fact that here it's a 200 (so seemingly all good) but then nothing in the body is a bit weird.\nAny suggestions on how to debug this on server side?. hello kind people of videojs-contrib-hls :) could you share your thoughts on this please. @imbcmdth is this library still actively maintained? I see quite a few issues and PRs hanging about :(. fair enough, thanks for your replies. we will work on fixing our manifests instead :). ",
    "sackos": "Hi @sobytes I really liked how you made use of timeupdate function to get around this issue. I'll certainly try to see if that could fit into my application. Thanks a lot!\n. ",
    "RavWar": "I've found the issue: http://jsbin.com/fibuqawaxe/edit?html,output\nModification or removal of  tag in Firefox causes such freezes, but only if there are sufficient  tags present on the page. Probably Firefox has some kind of link re-validation logic on each  change.\nThis is a consistent problem which needs to be fixed. Not sure if reporting this bug (or maybe feature :smile:) inside Firefox bug tracker would yield anything anytime soon. We can try switching to a more robust solution like one hls.js has: https://github.com/dailymotion/hls.js/blob/master/src/utils/url.js\n. I can confirm this bug on Chrome 55 (which is now stable).\nTest link: https://raw.githubusercontent.com/RavWar/RavWar.github.io/master/sample.m3u8\nIf i test it here: http://videojs.github.io/videojs-contrib-hls/, it hangs after 4 seconds, right between 2 chunks.\nHls.js demo http://dailymotion.github.io/hls.js/demo/ plays it just fine.\nI work with a lot of hls streams and this problem occurs in a fair amount of them, multiple times per stream.\nCan someone help get to the bottom of this?\n. ",
    "mattsobo": "Thank you for your response.  I was debugging a little more and when I modified the master playlist no error code occurred.  Is videojs-contrib-hls unable to parse the master playlist from Apple?  Or is this a Chrome issue.\nSame page with modified master playlist: http://sorcetrainingsystems.com/wp-content/themes/sorce/index_hls_test2.php\nI removed the multiple audio references.\nBefore (Error Code 4):\n```\nEXTM3U\nEXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"audio1\",NAME=\"audio1\",DEFAULT=YES,AUTOSELECT=YES,FORCED=YES,CHANNELS=\"1\"\nEXT-X-STREAM-INF:AVERAGE-BANDWIDTH=1301043,BANDWIDTH=1344861,CODECS=\"mp4a.40.2, avc1.4d401f\",RESOLUTION=640x360,FRAME-RATE=29.970,CLOSED-CAPTIONS=NONE,AUDIO=\"audio1\"\nmed/STS_SinDeqLvl1_01.m3u8\nEXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"audio2\",NAME=\"audio2\",DEFAULT=YES,AUTOSELECT=YES,FORCED=YES,CHANNELS=\"1\"\nEXT-X-STREAM-INF:AVERAGE-BANDWIDTH=2629437,BANDWIDTH=2688516,CODECS=\"mp4a.40.2, avc1.4d401f\",RESOLUTION=1280x720,FRAME-RATE=29.970,CLOSED-CAPTIONS=NONE,AUDIO=\"audio2\"\nhigh/STS_SinDeqLvl1_01.m3u8\nEXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"audio3\",NAME=\"audio3\",DEFAULT=YES,AUTOSELECT=YES,FORCED=YES,CHANNELS=\"1\"\nEXT-X-STREAM-INF:AVERAGE-BANDWIDTH=535653,BANDWIDTH=573764,CODECS=\"mp4a.40.2, avc1.42c01e\",RESOLUTION=416x234,FRAME-RATE=29.970,CLOSED-CAPTIONS=NONE,AUDIO=\"audio3\"\nlo/STS_SinDeqLvl1_01.m3u8\n```\nAfter (Success on Android Chrome browser):\n```\nEXTM3U\nEXT-X-STREAM-INF:AVERAGE-BANDWIDTH=1301043,BANDWIDTH=1344861,CODECS=\"mp4a.40.2, avc1.4d401f\",RESOLUTION=640x360,FRAME-RATE=29.970\nmed/STS_SinDeqLvl1_01.m3u8\nEXT-X-STREAM-INF:AVERAGE-BANDWIDTH=2629437,BANDWIDTH=2688516,CODECS=\"mp4a.40.2, avc1.4d401f\",RESOLUTION=1280x720,FRAME-RATE=29.970\nhigh/STS_SinDeqLvl1_01.m3u8\nEXT-X-STREAM-INF:AVERAGE-BANDWIDTH=535653,BANDWIDTH=573764,CODECS=\"mp4a.40.2, avc1.42c01e\",RESOLUTION=416x234,FRAME-RATE=29.970\nlo/STS_SinDeqLvl1_01.m3u8\n```\n. Thank you\nOn Wed, Jul 20, 2016 at 11:33 AM, Gary Katsevman notifications@github.com\nwrote:\n\ncontrib-hls can parse it and even supports multiple audio but it doesn't\nrun on Chrome for Android at all, everything is done natively. I do know\nthat Chrome for Android doesn't support multiple audio tracks right now so,\nremoving those to get it working makes sense.\nWe'll be looking soon into enabling contrib-hls on Chrome for Android\nbecause it lacks features that we support and it supports MSE APIs which\ncontrib-hls uses.\nThanks.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/videojs/videojs-contrib-hls/issues/782#issuecomment-234004983,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ARFys4-Rh7FmZ7ymXscdSE4z_ed7fGQmks5qXk3egaJpZM4JOXlC\n.\n. \n",
    "arnaudgandibleux": "@askaliuk Can you put an example of the solution?\n. Android, Ipad, Iphone. None are working. I use Firefox, Chrome, safari.\nThe stream source I can't provide because a VPN is needed. I'm sorry\nCode: \n<video id=\"really-cool-video\" width=\"960\" height=\"540\" class=\"video-js vjs-default-skin vjs-big-play-centered\" preload=\"auto\" controls>\n        <source src=\"http://10.3.50.11/live/test/index.m3u8\" type=\"application/x-mpegURL\">\n    </video>\n. And the stream is a nginx server which set an rtmp stream to hls. Footage is sent by OBS to the server\n. Okay, found problem. The problem was not HLS but the panorama plugin. Sorry for bothering you =D. ",
    "react2k": "I think I'm seeing this same issue with FF 48.0.1 on OSX.\nWhat I notice from network inspector is that, upon pressing play, Chrome immediately loads 3 segments in quick succession to build a substantial buffer. By contrast, FF only loads the first segment then waits until 10 seconds later to try loading the next one, really too late to maintain consistent play.\nEventually FF gets so far behind it gets confused and stops playing. Loads the same segment 3 times, then reverts to loading the chunklist repeatedly.\nSeems to only affect live HLS feeds via Wowza for us. The bipbop_16x9_variant demo video pre-loads segments consistently in both browsers.\n. ",
    "whadar": "We accepted the PR - We didn't mean to replace this plugin. \nApologies again.\n. ",
    "sriman": "yeah need to have fix for this, coz we are daily reported by our consumers saying timeout issue, I can recreate the issue anytime on any video of hls in video js open source player.\n. ",
    "sweissman59": "I've been digging through the videojs-contrib-hls code this morning, and I'm wondering if this issue might have to do with calling pause() on the segment-loader while the segment-loader's state is 'WAITING'.\nWhen switching into fullscreen and back out repeatedly, the master-playlist-controller is getting 'mediachanging' and 'mediachange' events from the masterPlaylistLoader, and those event handlers are calling pause(), abort(), playlist(), and load() on the mainSegmentLoader.\nIt looks like if that pause() call happens while the segment-loader's state is 'WAITING', then abort() is called while it's both paused and waiting, so the internal abort_() call happens, and the state remains 'WAITING' because it's paused.  The playlist() call similarly doesn't change the state because paused() is true, and so load() is called while the state is still 'WAITING', meaning it returns before calling fillBuffer_().\nOne way or another it seems like the segment-loader's state shouldn't be 'WAITING' after an abort() call.  I'm going to continue messing around and see if I can fix the issue, but I'm pretty new to using this plugin, so I might be missing other ramifications of that 'WAITING' state.\n. ",
    "vojneski": "Hi,\nWe have the same problem with HLS.\nWe use Video.js 5.11.6 and videojs-contrib-hls 3.5.3. \nFor some reason when one .ts segment return 404, player stop playing video. \n\u0410lso happens with VOD HLS content. When first chunk is missing player cannot start playing. \nWhen we try with desktop player like MPV player, player ignore missing chunk and continue to play.\n. Thanks for reply.\nWe test with this settings but unsuccessful.\nHere is test URLs:\nhttp://54-89-99-99/chunk1/master.m3u8 - missing chunk 1\nhttp://54-89-99-99/chunk2/master.m3u8 - missing chunks 5, 10, 15, 20\nhttp://54-89-99-99/chunk3/master.m3u8 - missing chunks 1, 5, 10, 15, 20\nWe test with other player and player continue playing video.\n. ",
    "rditreeni": "Hi, Use below set.\n\n\n\n. <link href=\"https://cdnjs.cloudflare.com/ajax/libs/video.js/5.13.0/video-js.min.css\" rel=\"stylesheet\">\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/video.js/5.13.0/video.min.js\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/videojs-contrib-hls/3.5.3/videojs-contrib-hls.min.js\"></script>\n. ",
    "blagojcoJuca": "+1 for the same problem. As @mkhazov suggested, can that chunk be skipped or the player tried to reconnect to the stream (that is what the other players is doing)?\nThanks\n. Here is another case: \nThe player is playing several minutes and for some reason in some time when he try to her the m3u8 playlist it is receiving \"Not found 404\", If we manually download the the same link 1 second after, the link is reachable and the m3u8 playlist can be downloaded. Is possible the player to make few retries before he give up?\nAttached is an image.\nThanks,\nBlagojco\n\n. ",
    "lilyxs": "Two after to request TS file request is not too small, even if the file is still behind the request to the error still will not continue to play video, use the videojs@version 5.19 videojs-contrib-hls@version 5.3.3. I have a similar problem,HTML5 play m3u8 video stream requests a history, drag a TS file, take a long time, no timely request to the corresponding TS document, network error caused the error A media download to fail part-way, then the TS file, call the play method, the error is to stay, not to play video. Excuse me, how to solve??? @TylerZubke \n\n. ",
    "ddunkin": "We also see this occasionally on a simulated live stream from a Wowza server.\nPlayer URL: https://faithlifetv.com/media/300027\nStream URL: https://logos-channel.scaleengine.net/logos-channel/live/biblescreen-ad-free/playlist.m3u8\nHere's an error report from Raygun with the call stack:\n{\n  \"Error\": {\n    \"ClassName\": \"InvalidStateError\",\n    \"Message\": \"Failed to set the 'duration' property on 'MediaSource': The MediaSource's readyState is not 'open'.\",\n    \"StackTrace\": [\n      {\n        \"UnmappedLineNumber\": 20,\n        \"LineNumber\": 8693,\n        \"UnmappedColumnNumber\": 16790,\n        \"ColumnNumber\": 0,\n        \"UnmappedClassName\": \"line 20, column 16790\",\n        \"ClassName\": \"line 8693, column 0\",\n        \"UnmappedFileName\": \"https://faithlifetv.com/dist/1.595f7b326e8f1fdc8582.bundle.js\",\n        \"FileName\": \"webpack:///./~/videojs-contrib-hls/dist/videojs-contrib-hls.js?98c7\",\n        \"UnmappedMethodName\": \"HtmlMediaSource.addSeekableRange_\",\n        \"MethodName\": \"end\",\n        \"Snippet\": \"      }\\n&nbsp;\\n      if (end > this.nativeMediaSource_.duration || isNaN(this.nativeMediaSource_.duration)) {\\n#pps#        this.nativeMediaSource_.duration = end;#/pps#\\n      }\\n    }\\n&nbsp;\",\n        \"SnippetLine\": 8690\n      },\n      {\n        \"UnmappedLineNumber\": 17,\n        \"LineNumber\": 822,\n        \"UnmappedColumnNumber\": 19405,\n        \"ColumnNumber\": 0,\n        \"UnmappedClassName\": \"line 17, column 19405\",\n        \"ClassName\": \"line 822, column 0\",\n        \"UnmappedFileName\": \"https://faithlifetv.com/dist/1.595f7b326e8f1fdc8582.bundle.js\",\n        \"FileName\": \"webpack:///./~/videojs-contrib-hls/dist/videojs-contrib-hls.js?98c7\",\n        \"UnmappedMethodName\": \"Stream.<anonymous>\",\n        \"MethodName\": \"addSeekableRange_\",\n        \"Snippet\": \"      // update seekable\\n      seekable = _this.seekable();\\n      if (!updatedPlaylist.endList && seekable.length !== 0) {\\n#pps#        _this.mediaSource.addSeekableRange_(seekable.start(0), seekable.end(0));#/pps#\\n      }\\n    });\\n&nbsp;\",\n        \"SnippetLine\": 819\n      },\n      {\n        \"UnmappedLineNumber\": 18,\n        \"LineNumber\": 4312,\n        \"UnmappedColumnNumber\": 25910,\n        \"ColumnNumber\": 0,\n        \"UnmappedClassName\": \"line 18, column 25910\",\n        \"ClassName\": \"line 4312, column 0\",\n        \"UnmappedFileName\": \"https://faithlifetv.com/dist/1.595f7b326e8f1fdc8582.bundle.js\",\n        \"FileName\": \"webpack:///./~/videojs-contrib-hls/dist/videojs-contrib-hls.js?98c7\",\n        \"UnmappedMethodName\": \"Stream.trigger\",\n        \"MethodName\": \"apply\",\n        \"Snippet\": \"        args = Array.prototype.slice.call(arguments, 1);\\n        length = callbacks.length;\\n        for (i = 0; i < length; ++i) {\\n#pps#          callbacks[i].apply(this, args);#/pps#\\n        }\\n      }\\n    }\",\n        \"SnippetLine\": 4309\n      },\n      {\n        \"UnmappedLineNumber\": 17,\n        \"LineNumber\": 1765,\n        \"UnmappedColumnNumber\": 31129,\n        \"ColumnNumber\": 0,\n        \"UnmappedClassName\": \"line 17, column 31129\",\n        \"ClassName\": \"line 1765, column 0\",\n        \"UnmappedFileName\": \"https://faithlifetv.com/dist/1.595f7b326e8f1fdc8582.bundle.js\",\n        \"FileName\": \"webpack:///./~/videojs-contrib-hls/dist/videojs-contrib-hls.js?98c7\",\n        \"UnmappedMethodName\": \"d\",\n        \"MethodName\": \"trigger\",\n        \"Snippet\": \"      }, refreshDelay);\\n    }\\n&nbsp;\\n#pps#    loader.trigger('loadedplaylist');#/pps#\\n  };\\n&nbsp;\\n  // initialize the loader state\",\n        \"SnippetLine\": 1762\n      },\n      {\n        \"UnmappedLineNumber\": 18,\n        \"LineNumber\": 1970,\n        \"UnmappedColumnNumber\": 979,\n        \"ColumnNumber\": 0,\n        \"UnmappedClassName\": \"line 18, column 979\",\n        \"ClassName\": \"line 1970, column 0\",\n        \"UnmappedFileName\": \"https://faithlifetv.com/dist/1.595f7b326e8f1fdc8582.bundle.js\",\n        \"FileName\": \"webpack:///./~/videojs-contrib-hls/dist/videojs-contrib-hls.js?98c7\",\n        \"UnmappedMethodName\": \"at \",\n        \"MethodName\": \"haveMetadata\",\n        \"Snippet\": \"      if (error) {\\n        return playlistRequestError(request, loader.media().uri);\\n      }\\n#pps#      haveMetadata(request, loader.media().uri);#/pps#\\n    });\\n  });\\n&nbsp;\",\n        \"SnippetLine\": 1967\n      },\n      {\n        \"UnmappedLineNumber\": 18,\n        \"LineNumber\": 4412,\n        \"UnmappedColumnNumber\": 26993,\n        \"ColumnNumber\": 0,\n        \"UnmappedClassName\": \"line 18, column 26993\",\n        \"ClassName\": \"line 4412, column 0\",\n        \"UnmappedFileName\": \"https://faithlifetv.com/dist/1.595f7b326e8f1fdc8582.bundle.js\",\n        \"FileName\": \"webpack:///./~/videojs-contrib-hls/dist/videojs-contrib-hls.js?98c7\",\n        \"UnmappedMethodName\": \"at \",\n        \"MethodName\": \"callback\",\n        \"Snippet\": \"        error = new Error('XHR Failed with a response of: ' + (request && (request.response || request.responseText)));\\n      }\\n&nbsp;\\n#pps#      callback(error, request);#/pps#\\n    });\\n&nbsp;\\n    request.requestTime = new Date().getTime();\",\n        \"SnippetLine\": 4409\n      },\n      {\n        \"UnmappedLineNumber\": 1,\n        \"LineNumber\": 2526,\n        \"UnmappedColumnNumber\": 25443,\n        \"ColumnNumber\": 0,\n        \"UnmappedClassName\": \"line 1, column 25443\",\n        \"ClassName\": \"line 2526, column 0\",\n        \"UnmappedFileName\": \"https://faithlifetv.com/dist/1.595f7b326e8f1fdc8582.bundle.js\",\n        \"FileName\": \"webpack:///./~/video.js/dist/video.js\",\n        \"UnmappedMethodName\": \"at \",\n        \"MethodName\": \"apply\",\n        \"Snippet\": \"  return function () {\\n    if (called) return\\n    called = true\\n#pps#    return fn.apply(this, arguments)#/pps#\\n  }\\n}\\n&nbsp;\",\n        \"SnippetLine\": 2523\n      },\n      {\n        \"UnmappedLineNumber\": 1,\n        \"LineNumber\": 2404,\n        \"UnmappedColumnNumber\": 23225,\n        \"ColumnNumber\": 0,\n        \"UnmappedClassName\": \"line 1, column 23225\",\n        \"ClassName\": \"line 2404, column 0\",\n        \"UnmappedFileName\": \"https://faithlifetv.com/dist/1.595f7b326e8f1fdc8582.bundle.js\",\n        \"FileName\": \"webpack:///./~/video.js/dist/video.js\",\n        \"UnmappedMethodName\": \"loadFunc\",\n        \"MethodName\": \"callback\",\n        \"Snippet\": \"        } else {\\n            err = new Error(\\\"Internal XMLHttpRequest Error\\\")\\n        }\\n#pps#        callback(err, response, response.body)#/pps#\\n&nbsp;\\n    }\\n&nbsp;\",\n        \"SnippetLine\": 2401\n      },\n      {\n        \"UnmappedLineNumber\": 1,\n        \"LineNumber\": 2334,\n        \"UnmappedColumnNumber\": 22588,\n        \"ColumnNumber\": 0,\n        \"UnmappedClassName\": \"line 1, column 22588\",\n        \"ClassName\": \"line 2334, column 0\",\n        \"UnmappedFileName\": \"https://faithlifetv.com/dist/1.595f7b326e8f1fdc8582.bundle.js\",\n        \"FileName\": \"webpack:///./~/video.js/dist/video.js\",\n        \"UnmappedMethodName\": \"XMLHttpRequest.readystatechange\",\n        \"MethodName\": \"loadFunc\",\n        \"Snippet\": \"&nbsp;\\n    function readystatechange() {\\n        if (xhr.readyState === 4) {\\n#pps#            loadFunc()#/pps#\\n        }\\n    }\\n&nbsp;\",\n        \"SnippetLine\": 2331\n      }\n    ]\n  },\n  \"Environment\": {\n    \"UtcOffset\": -4,\n    \"Browser-Width\": 1280,\n    \"Browser-Height\": 614,\n    \"Screen-Width\": 1280,\n    \"Screen-Height\": 720,\n    \"Color-Depth\": 24,\n    \"Browser\": \"Mozilla\",\n    \"Browser-Name\": \"Netscape\",\n    \"Browser-Version\": \"5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.116 Safari/537.36\",\n    \"Platform\": \"Win32\"\n  },\n  \"Client\": {\n    \"Name\": \"raygun-js\",\n    \"Version\": \"2.4.1\"\n  },\n  \"UserCustomData\": {},\n  \"Tags\": [],\n  \"Request\": {\n    \"Url\": \"https://faithlifetv.com/media/300027\",\n    \"QueryString\": {},\n    \"Headers\": {\n      \"User-Agent\": \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.116 Safari/537.36\",\n      \"Referer\": \"https://faithlifetv.com/\",\n      \"Host\": \"faithlifetv.com\"\n    }\n  },\n  \"Version\": \"Not supplied\",\n  \"OccurredOn\": \"2016-09-23T22:42:54.297Z\"\n}\n. @forbesjo do you still need more info on this?. The timing of the error is very sporadic, sometimes tens of minutes, sometimes hours. We see this a lot with 5.3.3, but the message is now \"Message: Failed to set the 'duration' property on 'MediaSource': The 'updating' attribute is true on one or more of this MediaSource's SourceBuffers.\" We'll update to 5.4.0.. It looks like this was removed in the audio track refactor by @imbcmdth. https://github.com/videojs/videojs-contrib-hls/commit/2cce0c1859a53fee5c6ed46deb79cfc550cead45#diff-b97e9f0783b7b7b3b21cfaa1457b03eaL1149. There's a call to videojs() in the HlsHandler constructor. https://github.com/videojs/videojs-contrib-hls/blob/407d41d24915a7d29b19abe05ab2b9abd7ad7920/src/videojs-contrib-hls.js#L320\nIs that also problematic for the reasons above?. @gkatsev I made the requested changes. Does it look good?. Ha, I used an arrow function then changed it to bind because I saw it used elsewhere.. ",
    "instanceof": "One other sequence that causes this same stack trace, is when there is an invalid element (404) in the playlist, which then causes HLS to go into a loop producing the 'duration' error.\nConstruct a playlist with an invalid item.\n```\nEXTM3U\nEXT-X-VERSION:3\nEXT-X-ALLOW-CACHE:NO\nEXT-X-TARGETDURATION:9\nEXT-X-MEDIA-SEQUENCE:39582\nEXTINF:8.55,\nmedia_w827914265_39582.ts\nEXTINF:7.675,\nmedia_w827914265_39583.ts\nEXTINF:7.674,\nmedia_w827914265_39584.ts\nEXTINF:8.633,\nmedia_w827914265_39585.ts\nEXTINF:7.675,\nmedia_w827914265_39586.ts\nEXTINF:7.674,\nmedia_w827914265_39587.ts\nEXTINF:8.425,\nmedia_w827914265_39588.ts\nEXTINF:7.675,\nmedia_w827914265_39589.ts\n```\n```\nGET https://logos-channel.scaleengine.net/logos-channel/live/biblescreen/media_w827914265_39589.ts 404 (Not Found)      video.js:2481\n    createXHR     @    video.js:2481\n    createXHR      @    video.js:2320\n    XhrFunction    @    videojs-contrib-hls.js?98c7:4564\n    loadSegment   @    videojs-contrib-hls.js?98c7:3793\n    fillBuffer_    @    videojs-contrib-hls.js?98c7:3689\n    monitorBuffer_ @    videojs-contrib-hls.js?98c7:3492\nVIDEOJS: WARN: Problem encountered with the current HLS playlist. No suitable alternatives found.      video.js:21323\n    logByType                 @ video.js:21323\n    log.warn                  @ video.js:21371\n    blacklistCurrentPlaylist  @ videojs-contrib-hls.js?98c7:1301\n    (anonymous function)      @ videojs-contrib-hls.js?98c7:911\n    i.dispatcher.i.dispatcher @ video.js:20804\n    trigger                   @ video.js:20911\n    a.trigger                 @ video.js:8670\n    handleResponse_           @ videojs-contrib-hls.js?98c7:3867\n    (anonymous function)      @ videojs-contrib-hls.js?98c7:4590\n    (anonymous function)      @ video.js:2524\n    loadFunc                  @ video.js:2402\n    readystatechange          @ video.js:2332\nVIDEOJS: ERROR: (CODE:2 MEDIA_ERR_NETWORK) A network error caused the media download to fail part-way.  video.js:21323\n    logByType                 @ video.js:21323\n    log.error                 @ video.js:21358\n    error                     @ video.js:12513\n    handleTechError_          @ video.js:11302\n    ret                       @ video.js:21159\n    ret                       @ video.js:21159\n    i.dispatcher.i.dispatcher @ video.js:20804\nUncaught DOMException: Failed to set the 'duration' property on 'MediaSource': The MediaSource's readyState is not 'open'.(\u2026)   videojs-contrib-hls.js?98c7:14260\n    addSeekableRange_     @ videojs-contrib-hls.js?98c7:14260\n    (anonymous function)  @ videojs-contrib-hls.js?98c7:838\n    trigger               @ videojs-contrib-hls.js?98c7:4490\n    d                     @ videojs-contrib-hls.js?98c7:1818\n    (anonymous function)  @ videojs-contrib-hls.js?98c7:2025\n    (anonymous function)  @ videojs-contrib-hls.js?98c7:4590\n    (anonymous function)  @ video.js:2524\n    loadFunc              @ video.js:2402\n    readystatechange      @ video.js:2332\n...\n```\n. ",
    "tingulfsen": "Thank you very much! It does indeed work if I re-encode using AAC.\n. ",
    "vantassell": "Firefox doesn't support AAC directly. It defers to the OS to provide proprietary codecs. That's why your firefox has audio (because your os is providing the codec) and your fathers firefox has no audio (because his os is not providing the codec).. ",
    "se7en007": "Just passing by, this issue is possibly due to bug in chrome version 52. FYI:- The same video(the one that I am testing) plays well on chrome v51, firefox and safari.\n. Sorry, but that will be difficult as it is from our platform. You can try any video which has rotation metadata set. Use imagemagick to get video which has orientation. You can check the bug here:  https://bugs.chromium.org/p/chromium/issues/detail?id=637312\n. Sorry, you should check issue: (bug 632624). The earlier one is duplicate. This bug manifests as the rotated video is stretched to fit to the unrotated video size. \n. ",
    "Prendo93": "Confirmed same behaviour on Mac OS X FireFox\n. Update: The renditions were missing the audio codec in both manifests, I understand that the ios implementation can handle that, but the HTML5 cannot, hence the failure for the 'URI-less' manifest in HTML5 player.\n. Thanks @gkatsev, I didn't realise that was native Android behaviour. Is the enabling of contrib-hls on android on the roadmap, or available on android behind a flag? Alternative audio tracks are a high priority for our project.\nKind regards,\n. ",
    "benweidig": "Any updates on this issue?\nWe would love to use videojs with HLS, but we need to support multiple audio tracks on Android.. Hi @gesinger,  I've tried overrideNative.\nNo matter what I can't get a language switcher to show up in Chrome in Android.\nFirefox on Android is working as expected.\nMaybe I dig a little deeper into the code tomorrow and debug it a little more to better understand where my problem is.\nThx!. ",
    "lipxitutvl10": "i using videojs 5.10.2 and videojs-contrib-hls 3.4.0. i want show button change bitrate for m3u8 file. i try working with document but not woking?\n. ",
    "Poordeveloper": "I have similar issue, but mine is\n\nvideojs-contrib-hls.js:3435 Uncaught TypeError: Cannot read property 'length' of undefined\n\nif (!playlist.segments.length) {\n        return;\n}\n\nsegments is undefined.\n\nThis happens when videojs failed to load m3u8 file, and I tried to src again when m3u8 file ready.\nI think this plugin has some problem to deal with some failure case.\n. ",
    "ColdHeat": "To the best of my knowledge it does not. It is a feed from a home security camera. \n. Is the new aes-decrypter in v3.6.12 ?\n. ",
    "royendgel": "same here mine is on line 15048\nvideojs-contrib-hls.js:15048 Uncaught TypeError: Cannot read property 'segments' of undefined\n\nthe type is set to \"combine\"\n\nI hard coded the type to \"video\" but gives problem with other things. \n. ",
    "hoodsy": "@DoM1niC did you have any luck getting a viewer count? I'm struggling with this as well.. ",
    "swordsreversed": "I didn't so I installed Flash 22.0, restarted and tried in a private browsing tab (no caching) and still couldn't get it to play. Same error in console. Do you have different result?\n. So I just tried \nvar player = videojs('my_video_1', {techOrder: ['flash']});\nand still no luck. Perhaps its also a jsbin issue as the main example works. Strange.\n. ",
    "adgoncal": "I am currently trying to achieve this. So far, this is what I have:\njavaScript\nvar lastDuration = Infinity;\nplayer.on('timeupdate', function() {\n  var duration = player.duration();\n  if(!isFinite(duration)) {\n    var start = player.seekable().start(0);\n    var end = player.seekable().end(0);\n    if(start !== end) {\n      // 5 seconds offset to prevent freeze when seeking all the way to left\n      duration = end - start - 5;\n      if(duration >= 0 && duration !== lastDuration) {\n        player.duration(duration);\n        lastDuration = duration;\n      } else if(isFinite(lastDuration)) {\n        player.duration(lastDuration);\n      }\n    }\n  }\n});\nProblems I have found with this:\n- When a new segment is loaded, player.duration() is set to Infinity and there is a flicker on the controlBar because the vjs-live class is added and immediately afterwards it is removed due to the above code setting duration to a finite number.\n- Sometimes the video is frozen with the loading indicator on top after seeking. This is fixed by seeking again.\n. @Eriken \nNo, I did not.\nI tried using https://github.com/toolbox-tve/videojs-dvrseekbar but ran into some of the same issues. \nIn the end I had to write a custom seekbar because the flicker was not acceptable. \nSomething like this:\n```javaScript\nvar seekbarTracker = {\n  duration: 0,\n  time: 0,\n  seekPercent: 0,\n  hasDVR: false,\n};\nplayer.on('timeupdate', throttle(function() {\n  var hasDVR = false;\n  var duration = Math.floor(getDuration(player) * 1000);\n  var time;\n  var seekPercent;\nif(duration) {\n    seekbarTracker.duration = duration;\n// constrain time\ntime = Math.floor(Math.max(0, Math.min(duration, player.currentTime() * 1000)));\nseekbarTracker.time = time;\nseekPercent = time / duration;\nif(seekPercent !== seekbarTracker.seekPercent) {\n  onSeekPercentChange(player, seekPercent, duration);\n}\nseekbarTracker.seekPercent = seekPercent;\n\n// duration is not Infinity, so if isLive() returns true, then player should have DVR.\nhasDVR = isLive(player);\n\n}\nseekbarTracker.hasDVR = hasDVR;\n}, 100));\nfunction getDuration(player) {\n  var seekable = player.seekable();\n  return seekable && seekable.length ? seekable.end(0) - seekable.start(0) : 0;\n}\nfunction onSeekPercentChange(player, seekPercent, duration) {\n  var seekable = player.seekable();\nif(seekable && seekable.length) {\n    // constrain currentTime\n    player.currentTime(Math.max(0, Math.min(seekable.end(0), seekable.start(0) + (seekPercent * duration))));\n  }\n}\nfunction isLive(player) {\n  if(!isFinite(player.duration())) {\n    return true;\n  }\nvar acceptableDelay = 30;\n  var seekable = player.seekable();\n  return seekable && seekable.length && seekable.end(0) - player.currentTime() < acceptableDelay;\n}\n``. @Eriken \nThrottling is not required. What throttle does is take a function and limit how often it runs. If you throttle something to 100ms, then it will only run once every 100ms no matter how many times you call that function. Thetimeupdate` event happens many times per second, but we don't really need to update the seekbar that often. You can use any throttling method for this. \nThrottle Examples\n\nhttps://remysharp.com/2010/07/21/throttling-function-calls\nhttp://benalman.com/projects/jquery-throttle-debounce-plugin/\n\nThe code I posted was not tested. It is not the exact code I am using, but a reduced (untested) version that serves as an example of how you can keep track of the seek position and implement your own seekbar. You can use it as a reference, but you may need to modify it.. @mkorszunsands: I am confused. On the initial post you wrote multiple times that you tested on version 4.2.0, but the latest version I could find is 4.0.3. Have you tried with version 4.0.3? Does it work?\nI am having a similar issue and setting videojs.options.hls.overrideNative = true together with the code by @forbesjo does not seem to solve it. I am still investigating my issue though.\n--\nEdit: I figured out my issue. It was not related to this.. ",
    "eriken": "@adgoncal \nDid you improve on your fix?. @adgoncal\nThank you very much for the quick response!\nI have very little experience with JS so sadly I could not get your example to work. Is the timeupdate event handler suppose to call a throttle function with your given parameters?\nI tried omitting the throttle function and just passed the parameter as an anonymous function, which resulted in an unplayable result.. Ah, that makes sense. Thanks for your time!\nI will post a working solution here when able.. ",
    "sgromkov": "\nWhen a new segment is loaded, player.duration() is set to Infinity and there is a flicker on the controlBar because the vjs-live class is added and immediately afterwards it is removed due to the above code setting duration to a finite number.\n\nTo remove flickering you can add next code to dvrseekbar.js:\n```\nvar Slider = _videoJs2['default'].getComponent('Slider');\nSlider.prototype.update = function update() {\n  // In VolumeBar init we have a setTimeout for update that pops and update to the end of the\n  // execution stack. The player is destroyed before then update will cause an error\n  if (!this.el_) {\n    return;\n  }\n// If scrubbing, we could use a cached value to make the handle keep up with the user's mouse.\n  // On HTML5 browsers scrubbing is really smooth, but some flash players are slow, so we might want to utilize this later.\n  // var progress =  (this.player_.scrubbing()) ? this.player_.getCache().currentTime / this.player_.duration() : this.player_.currentTime() / this.player_.duration();\n  var progress = this.getPercent();\n  var bar = this.bar;\n// If there's no bar...\n  if (!bar) {\n    return;\n  }\n// Protect against no duration and other division issues\n  if (typeof progress !== 'number' || progress !== progress || progress < 0 || progress === Infinity) {\n    progress = 0;\n  }\n// Convert to a percentage for setting\n  var percentage = (progress * 100).toFixed(2) + '%';\n// Set the new bar width or height\n  if(progress != 0) {\n    if (this.vertical()) {\n      bar.el().style.height = percentage;\n    } else {\n      bar.el().style.width = percentage;\n    }\n  }\n};\n```\nFlickering is happened cause progress value sometimes < 0 or Infinity. And Slider sets the bar.el().style.width to null, and then to real position. \nIn my code I check the progress value, and if it null do not change the bar width. So, flickering is not happened to me now.\nThen you should customize player css, to remove seekbar twitching. But it's much more easy, than the seekbar flickering problem. Something like this:\n```\n.vjs-dvrseekbar .vjs-dvrseekbar-progress-control {\n  display: flex !important;\n}\n.vjs-dvrseekbar .vjs-live-button {\n  width: auto;\n  cursor: pointer; }\n.vjs-dvrseekbar .vjs-live-button .label,\n.vjs-dvrseekbar .vjs-live-button .vjs-live-label {\n  display: -webkit-box;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-align: center;\n  -ms-flex-align: center;\n  align-items: center;\n  font-size: .7em;\n  padding-left: 6px;\n  padding-right: 6px;\n  height: 100%;\n}\n.vjs-dvrseekbar .vjs-live-control {\n  display: none;\n}\n.vjs-dvrseekbar .vjs-remaining-time {\n  display: none;\n}\n```. @prashanthag can you show me your work example?. @prashanthag and could you try to use my branch of dvrseekbar.js: https://github.com/sgromkov/videojs-dvrseekbar/tree/fix-seekbar-flickering\nJust take a videojs-dvrseekbar.js from it and try.. ",
    "prashanthag": "@sgromkov \nTried as you said but I still see flickering now ..I am using  video.js videojs-contrib-hls .. your css works for twitching\n```\n\n\n\n  // following code does not work as expected to remove flickering of scrubbing bar\n  var Slider = _videoJs2['default'].getComponent('Slider');</p>\n<p>Slider.prototype.update = function update() {\n    // In VolumeBar init we have a setTimeout for update that pops and update to the end of the\n    // execution stack. The player is destroyed before then update will cause an error\n    if (!this.el_) {\n      return;\n    }</p>\n<pre><code>// If scrubbing, we could use a cached value to make the handle keep up with the user's mouse.\n// On HTML5 browsers scrubbing is really smooth, but some flash players are slow, so we might want to utilize this later.\n//var progress =  (this.player_.scrubbing()) ? this.player_.getCache().currentTime / this.player_.duration() : this.player_.currentTime() / this.player_.duration();\nvar progress = this.getPercent();\nvar bar = this.bar;\n\n// If there's no bar...\nif (!bar) {\n  return;\n}\n\n// Protect against no duration and other division issues\nif (typeof progress !== 'number' || progress !== progress || progress &lt; 0 || progress === Infinity) {\n  progress = 0;\n}\n\n// Convert to a percentage for setting\nvar percentage = (progress * 100).toFixed(2) + '%';\n\n// Set the new bar width or height\nif(progress != 0) {\n  if (this.vertical()) {\n    bar.el().style.height = percentage;\n  } else {\n    bar.el().style.width = percentage;\n  }\n}\n</code></pre>\n<p>};\n\n```\n. ",
    "cevenega": "Great! but \"auto\" level never works.\n. ",
    "dgoldstein0": "What's m3u8?\nOn Thu, Sep 22, 2016, 9:18 AM David LaPalomento notifications@github.com\nwrote:\n\n@dgoldstein0 https://github.com/dgoldstein0 we're using the \nelement because m3u8 URLs need to be resolved relative to the m3u8, not the\npage the player is hosted on. The standard a.href approach doesn't work\nbecause that calculates relative to the page the player is running on.\nparseUrl() does half the job but it would still require us to translate\ninteresting URL features like relative paths and I've been hesitant to do\nthat because URLs are pretty complicated when you get into the nitty-gritty.\nWe're open to solutions that don't use  and IE6 support isn't a\nrequirement :) Have any suggestions?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/videojs/videojs-contrib-hls/issues/832#issuecomment-248952305,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABBnd61iZnI8tDPPADevLv5c4g_2-8MDks5qsqo6gaJpZM4JroY4\n.\n. ah, makes sense.\n\nWould it be possible to create an iframe, and then put your base tag and a tag inside that iframe? I believe that way the base-uri CSP policy for the main page wouldn't apply within the iframe.\n. awesome, thanks for the fix!\nOn Fri, Mar 16, 2018 at 11:37 AM Joe Forbes notifications@github.com\nwrote:\n\nWe now use a purely javascript resolver (\nhttps://github.com/tjenkinson/url-toolkit) so this should no longer be an\nissue\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/videojs/videojs-contrib-hls/issues/832#issuecomment-373807023,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABBnd2oYBpD3ZngatarZq3WmHC7rq2qZks5tfAZegaJpZM4JroY4\n.\n. \n",
    "paulomedia": "Hi,\nIn window 8 and window 10 with IE11 we have to forze always to tech flash to reproduce hls live/vod, but in windows 7 IE11 videojs detect that the browser don't support Media Extensions and change the tech to flash, we don't have to forze the change of tech.\nversions used in tests:\nvideojs - 5.12.6\nvideojs-contrib-hls - 3.6.12\n. ",
    "omarosman107": "Description\nEvery time I go to my website cablecentral.tk and load Cbsn from the list it sometimes says can't load file.\nSources\nCBSN\nSteps to reproduce\nExplain in detail the exact steps necessary to reproduce the issue.\n1. 2. 3.\nResults\nExpected\nplayer to have started and streaming video.\nError output\nAdditional Information\nvideojs-contrib-hls version\n3.5.3\nwhat version of videojs-contrib-hls does this occur with? videojs-contrib-hls x.y.z\nvideojs version\n5.11.4\nwhat version of videojs does this occur with? video.js x.y.z\n5.11.4\nBrowsers\nchrome\nwhat browsers are affected? please include browser and version for each *\nPlatforms\nwhat platforms are affected? please include operating system and version or device and version for each *\nwindows\nOther Plugins\nare any other videojs plugins being used on the page? If so, please list them with version below. *\nOther JavaScript\nare you using any other javascript libraries or frameworks on the page? if so please list them below. *\n. ",
    "SirBryan": "No difference.  It is jumpy whenever it loads a new segment.  Making the segments 2 seconds long causes it to be very jumpy.  Setting them to 12 seconds reduces the amount of pausing, but eventually it still gets out of sync.\n. See this commit over on hls.js (https://github.com/dailymotion/hls.js/commit/d30459f3b0a4578e85bb0b0d29fefb4e752dfc08).\nIt seems as though the tail end of the AAC PES (as segmented by mediastreamsegmenter) isn't padded the same way as those by ffmpeg, so I'm guessing there is the potential for the clocking to go askew.\n. ",
    "SuriGill": "Also you might see I had to change one of the tests because the VOD was actually 40 seconds long but it was trying to trim the buffer at 60 seconds. I'm guessing that was a bug because the buffer shouldn't have even loaded to that point when you skipped to 120 seconds even though it is 60 seconds before as the test describes. The live buffer trim test has the same expected results. \n. Unfortunately it's created using ffmpeg and it's around 20gb to upload. I'm not able to upload such a big file as I'm not subscribed to any provider that hosts files that big. You can create your own live stream quickly from terminal by installing ffmpeg and then entering this command:\nffmpeg -y -f lavfi -i \"testsrc2=size=426x240:rate=30\" -threads 0 -t 60000 -c:v  libx264 -pix_fmt yuv420p -preset ultrafast -profile:v main -tune zerolatency -c:a aac -strict -2 -b:v 10M -b:a 96K -x264opts keyint=30:min-keyint=30:scenecut=-1 -hls_list_size 0 -hls_time 1 -hls_flags single_file test4.m3u8\nIt'll get to 13 hours pretty quick if you have a good fps count when creating and you can point your localhost or where ever you're hosting your stuff for videojs-contrib-hls to view it in that folder.\n. ",
    "huanghanzhilian": "\u60a8\u597d\uff0c\u6211\u60f3\u95ee\u4e0b\u5982\u4f55\u4f7f\u7528\u60a8\u63d0\u4ea4\u7684\u4ee3\u7801\uff1f. Thank you, let me unlock the doubt.. ",
    "russitto": "Sorry, forget about Safari and Edge. But Firefox? Chrome?\n. ",
    "toddaa": "I just pulled in 3.6.6 this morning and tested.  Works perfect now.  Thanks all for the update!\n. ",
    "antondomratchev": "@eric7578 I am not sure if this will solve your problem. I've encountered similar issue and my solution has been to specify the source type as type=\"application/x-mpegURL\" this maybe different for you depending on the media type being consumed.\n. ",
    "eric7578": "@antondomratchev thanks for the reply\nI just solved my problem by the following workaround.\nimport 'videojs-contrib-hls/dist/videojs-contrib-hls';\n. ",
    "zymtx5g79k": "Thanks for quick answer!\nIs there way to limit bandwidth on Safari? I need change level (quality) in js.\n. ",
    "arendjr": "What do you mean by \"pre-build\" file? I'm taking the one that's built in the dist/ directory, just not the one that's minified. I prefer to use the non-minified versions of libraries for development purposes, and I have my own build system minify them when I'm going to production.\n. Well, that's a good question. It was my understanding if I want to use it like that, I should install the project through NPM. But that doesn't seem very attractive as soon as I want to customize my video.js build, because the NPM version of videojs-contrib-hls will automatically pull in the stock version of video.js. So that's why I went this route. But I admit I'm just getting started setting the whole thing up, so if I'm missing something, I'd gladly hear what'd be an easier setup :)\n. I'd love to use a patch like this. Unfortunately, it seems you're the third person to attempt to write a patch like this (previous ones: #646 and #647) and both the previous ones got rejected on the grounds it's not supported in IE.\nSo I'd like to take this opportunity to address the maintainers to please give this patch fair consideration for inclusion. If 3 people independently develop a patch for this (I would've been the fourth, given that the older two don't work against master anymore, had I not checked again to see if there are any more solutions since yesterday when I also investigated this) it seems there's a real demand for this.\nAlso, the argument it doesn't work in IE is irrelevant at least to us because IE11 seems to have issues with the HLS plugin anyway (documented here: https://github.com/videojs/videojs-contrib-hls#ie11), which is why we don't use this plugin for IE to begin with.\nSo I hope this patch gets tidied up (I doubt the failing tests are the result of this patch, but I guess at least another comment in the README to warn people trying to use this functionality with IE would be warranted) and gets approved, so we can prevent some duplication of work for the future. Thanks!\n. Btw, in order for us to get this patch to work, we also needed the following change:\ndiff --git a/src/playlist-loader.js b/src/playlist-loader.js\nindex d1fd48f..98ddd32 100644\n--- a/src/playlist-loader.js\n+++ b/src/playlist-loader.js\n@@ -478,7 +483,9 @@ const PlaylistLoader = function(srcUrl, hls, withCredentials) {\n\n       loader.state = 'HAVE_MASTER';\n\n-      parser.manifest.uri = srcUrl;\n+      if (parser.manifest.uri != req.responseURL) {\n+        parser.manifest.uri = req.responseURL;\n+      }\n\n       // loaded a master playlist\n       if (parser.manifest.playlists) {\n\nThis change originally came from PR #646.. Furthermore, I'd suggest adding this to the README:\ndiff --git a/README.md b/README.md\nindex fa3030b..4d17c63 100644\n--- a/README.md\n+++ b/README.md\n@@ -441,6 +441,10 @@ SourceBuffers functionality. This leads to various issues, such as\n videos stopping playback with media decode errors. The known workaround\n for this issues is to force the player to use flash when running on IE11.\n\n+Also it is known that IE cannot load videos if a redirect is performed\n+when loading the playlist URL. The workaround for this is to pass the\n+destination URL directly to the player.\n+\n ### Fragmented MP4 Support\n Edge has native support for HLS but only in the MPEG2-TS container. If\n you attempt to play an HLS stream with fragmented MP4 segments, Edge. Sure, that sounds fine to me.. That's a good question. Best I can think of is to detect whether the\n\nresponseURL property is supported (from what I read it's as easy as\nchecking whether it's undefined) and use that in case loading of the\nplaylist works, but loading of the chunklist fails with a 404 or similar\nand print a log in such case to check whether it's because of a redirect.\nOn Wed, 23 Nov 2016 at 21:53 David LaPalomento notifications@github.com\nwrote:\n\n@arendjr https://github.com/arendjr @rgc https://github.com/rgc you\nmake compelling arguments. I closed the other PRs on platform-consistency\ngrounds but three independent contributions is a pretty strong indication I\nwas probably wrong. Here's my question: is there any way we can warn people\nin IE that their video isn't working because of redirects? Speaking\nselfishly as one of the folks who reviews issues, I'd like to make this\nproblem easy to diagnose.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/videojs/videojs-contrib-hls/pull/912#issuecomment-262627492,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAgjLmV1pv8zxLYorA7etC9VtF2WgPK3ks5rBKfhgaJpZM4Kyp-B\n.\n. \n",
    "silverbucket": "Does anyone have any idea about this? I basically want to be able to pass in Hls config (as described here) https://github.com/dailymotion/hls.js/blob/master/API.md#fine-tuning when using videojs-contrib-hls.\nI tried passing in a config object when initializing videojs like this:\n``` javascript\nvar options = {\n  html5: {\n    hlsjsConfig: {\n      fLoader: function () { console.log('test'); }\n    },\n    hls: {\n      hlsjsConfig: {\n        fLoader: function () { console.log('test'); }\n      }\n    }\n  }\n};\nvar player = videojs('video', options);\n```\nPlacing the hls-specific config in any of those positions in the options object don't seem to have any effect. Is there a way to pass in options to Hls?\n. ping @dmlap and @forbesjo because you seem to be active with this repo. ^^\n. @gkatsev ah right, I was confusing Hls with hls.js, thanks for correcting me. So, with that in mind - do you know a way to over-ride the Media fetching function when initializing the library?\n. @dmlap thanks for the reply. I tried overriding videojs.Hls.xhr but the function never seems to be called. \n``` javascript\nvideojs.Hls.xhr = function (url, callback) {\n  console.log('XHR called ', url, callback);\n};\nvar player = videojs('video');\nplayer.ready(function () {\n  player.src({\n    src: \"https://d2zihajmogu5jn.cloudfront.net/bipbop-advanced/bipbop_16x9_variant.m3u8\",\n    type: \"application/x-mpegURL\"\n  });\n  player.play();\n});\n```\nThis function never ends up being called.\n. ping @dmlap ?\n. ",
    "anaszgh": "Hello, \nI'm facing the same issue on Video-Js version 7.0.2, how can i fix it.\n. ",
    "smarshallsay": "Thank you for your response.\nI have tried editing the M3U8 as you specify and the audio does play but without the picture - also I receive the following errors from VideoJS\nChrome: Uncaught TypeError: Cannot read property 'filter' of undefined\nFirefox: TypeError: this.activeAudioGroup(...) is undefined\nI am using Amazon Elastic Transcoder to make the HLS files and in the documentation it mentions that for HLS you should split your video streams from audio to leverage the late binding audio feature of HLS. AET generates the M3U8 file for me automatically based on the inputs. \nI feel like I'm missing something but I'm not sure what it is as this technique has worked flawlessly with your plugin for every video we've uploaded so far.\nThanks for your assistance with this, I realise it may not be your 'problem' since it may well not be an issue with the plugin - I appreciate the help all the same.\n. ",
    "rgc": "arendjr,\nI apologize for not checking the pull request history -- thank you for the considerate and informative reply.\nI understand the desire to stay consistent across platforms, but would argue that it's more important to adhere to the RFC and allow the platform developers to do the same.\nWhen dealing with a URI, we should attempt to conform to RFC3986, which states in section 5.1.3 that \"if the retrieval was the result of a redirected request, the last URI used (i.e., the URI that resulted in the actual retrieval of the representation) is the base URI\".\nHTML5 players have been slow to implement this since XMLHttpRequest has historically hidden the fact that a redirect has occurred. Only recently the XMLHttpRequest spec 4.6.1 has added the responseUrl attribute.\nI appreciate the consideration and time of the maintainers, please let me know what other steps are required to tidy up this patch.\nThank you!\n. Arend,\nI thought that perhaps adding options to enable this would be a good\noption. By default, it would operate as it does now, but we can make\n\"follow redirect\" and \"sticky redirects\" options.\nOn Mon, Nov 21, 2016 at 8:25 AM, Arend van Beelen jr. \nnotifications@github.com wrote:\n\nFurthermore, I'd suggest adding this to the README:\ndiff --git a/README.md b/README.md\nindex fa3030b..4d17c63 100644\n--- a/README.md\n+++ b/README.md\n@@ -441,6 +441,10 @@ SourceBuffers functionality. This leads to various issues, such as\n videos stopping playback with media decode errors. The known workaround\n for this issues is to force the player to use flash when running on IE11.\n+Also it is known that IE cannot load videos if a redirect is performed\n+when loading the playlist URL. The workaround for this is to pass the\n+destination URL directly to the player.\n+\n ### Fragmented MP4 Support\n Edge has native support for HLS but only in the MPEG2-TS container. If\n you attempt to play an HLS stream with fragmented MP4 segments, Edge\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/videojs/videojs-contrib-hls/pull/912#issuecomment-261937876,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AACh2fWiPMGuHATXr5_95SQ4iHgbnSVOks5rAZvQgaJpZM4Kyp-B\n.\n. OK - will do.\n\nI'm working with a specific use-case in mind, so I don't want to assume too\nmuch about the general use of this plugin.\nThanks,\nRob\nOn Tue, Nov 22, 2016 at 10:12 AM, Arend van Beelen jr. \nnotifications@github.com wrote:\n\nSure, that sounds fine to me.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/videojs/videojs-contrib-hls/pull/912#issuecomment-262266408,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AACh2bMixT-cKjf7lv3baR3b9zlG94gaks5rAwZUgaJpZM4Kyp-B\n.\n. Yes - I can do that...   I've been a bit busy this week, but should have\ntime later this week to add that and the other options I was speaking about.\n\nAlso, I'll try to get a property spun up for testing.\nThanks for the feedback and suggestions,\nRob\nOn Wed, Dec 7, 2016 at 5:27 PM, David LaPalomento notifications@github.com\nwrote:\n\n@arendjr https://github.com/arendjr that sounds like a pretty good\nidea. Would you or @rgc https://github.com/rgc be interested on\nmodifying this PR to do that?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/videojs/videojs-contrib-hls/pull/912#issuecomment-265593668,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AACh2ZXDNk_COz4MzLaiJZtt4MBfhnCQks5rFzLngaJpZM4Kyp-B\n.\n. \n@SleepWalker - this looks good to me, appreciate the addition of the unit tests and the re-factoring.\n\n. ",
    "blendi-93": "have the same problem streamplaylist: https://streaming-02.mivitec.net/live/smil:test.smil/playlist.m3u8\n(only useable from german ips sry). still an issue.\nvideo-js: 5.14.1\nvideo-js-hls-contirb: 4.0.2\nFirefox: 50.1.0\nWindows: 10. ",
    "AgustinLado": "Hey! It's still an issue with video.js 5.16.0 and videojs-contrib-hls 4.1.1 (using Chrome 55).. ",
    "bigt11": "I have credential working.  Here is how i have it in JS.  It passes on my cookies\n//setup videojs\nvideojs(VideoIdName, {\n  \"controls\": true,\n  \"fluid\": true,\n  \"preload\": 'none',\n  \"techOrder\": [\"html5\"],\n  \"html5\": {\n    \"hls\": {\n      \"withCredentials\": true,\n    }, \n  },\n}, function(){. ",
    "runtheyards": "@gesinger I was not using it within the html5 prop. Not working on this project anymore but would guess that was the issue.. ",
    "masterful": "I was also able to reproduce this. It looks like the difference may have something to do with the duration/timing of the two chunks.\nAccording to chrome://media-internals -> the contrib-hls approach has the following:\nGenerated splice of overlap duration 3166us into new buffer at 4156833us.\nWhile hls.js does not.\nI tried re-encoding the segments with ffmpeg (first combined and then re-split):\nhttps://masterful.github.io/test-pages/stream-test/sample.m3u8\nThis one works on the contrib-hls but stutters between the two segments - so perhaps the issue is coming from the mux library?. So there are some handlers around here for when playback enters a waiting state. At the moment they have to do with checking for underflow or gaps, but if I had to guess it looks like the two segments are actually overlapping ever so slightly, which causes issues moving to the next segment?\nIf we're able to detect this better we could probably modify this section to poke the video along a short amount (a second or so) and have it resume playback.... The delay size (0.125s) might be related to finding a useable keyframe to jump to. But that's just a guess. I think the ideal solution would be to figure out why the segments are causing that overlap in the first place, as I agree that the waiting handler is an ugly (although effective) workaround.. gah - I'd completely forgotten about this - is it worth revisiting?. I'm not sure I understand where the tests are failing :disappointed: . I don't have the data to say otherwise, but I'm curious to know how you determined it was an edge case, since my primary use case is to use 0.... ",
    "ip": "Hello, I'm trying to fix this bug. I used the sample @RavWar provided. That's what I found so far.\nThere is following sequence of events on the <video> element until hang moment:\nplay\nplaying\ntimeupdate\ndurationchange\ndurationchange\ndurationchange\ntimeupdate\ntimeupdate\n...\ntimeupdate\nstalled\ntimeupdate\ntimeupdate\ntimeupdate\nwaiting\nAccording to description of waiting event, Either seeking is true, or the current playback position is not contained in any of the ranges in buffered.\nSo I have inspected the state of player's HTMLMediaElement object (it is the same as <video> element) at the moment of lag:\n- seeking === true\n- buffered includes the whole video interval - from 0 to 8.341666\n- seekable interval is the same\nAlso:\n- error === null\n- networkState === NETWORK_LOADING\nMaybe this can help. I'll continue to explore it.. Here is a snippet for Chrome that I used for event logging:\n```js\nlet video = player.children()[0]\nlet eventNames = [\n    'durationchange',\n    'loadedmetadata',\n    'loadeddata',\n    'canplay',\n    'canplaythrough',\n    'ended',\n    'emptied',\n    'stalled',\n    'suspend',\n    'play',\n    'playing',\n    'pause',\n    'waiting',\n    'seeking',\n    'seeked',\n    'ratechange',\n    'timeupdate',\n    'volumechange',\n    'complete',\n    'ended',\n    'audioprocess'\n]\neventNames.forEach((event) => {\n    video.addEventListener(event, () => {\n        console.log(' event triggered: ', event)\n    })\n})\n. @masterful I just tried your suggestion with this snippet and it kinda works:js\n(() => {\n    let video = player.children()[0]\nlet listener = () => {\n    console.log('waiting event')\n    video.currentTime += 0.25 / 2\n}\nvideo.addEventListener('waiting', listener, { once: true })\n\n})()\n```\nBut there is blinking loading indicator and this is pretty rough hack. Also, it works in my case only with a given delay (0.25 / 2) or bigger and I haven't figured out why.. This bug doesn't exist in Chrome 56, which is now stable. Does it still make sense to fix it?. ",
    "alexistkd": "but on which side do i need to enable CORS? on streaming507.com? or in akamai side\n. ",
    "xiaosunJessica": "I met the similar problem, can you tell me how to solve it , or how the problem caused by the panorama plugin . ",
    "wuyuedefeng": "how solve?  I has same problem with hls, aes 128,   Desktop chrome safari is ok, but on mobile every safari show browser did not support.. ",
    "lykata": "Was testing on Genymotion... seems to be working on phones... ",
    "rudemateo": "should the video.js version be updated from 5.10 to the latest 5.12.6 as well? https://github.com/videojs/videojs-contrib-hls/blob/gh-pages/index.html#L154. fwiw, if you leave the version range off, the \"latest\" currently resolves to 3.6.13. ",
    "murmanskiy": "I need to contact you\nskype - murmanskiy.bhf\nTelergam - @murmanskiy. ",
    "surikat1978": "data-setup=\"{ &quot;html5&quot;:\nthat's Rules html\n  this is my code. And any questions do not arise without  HLS !\n. not one editor does not support a single quotes.  Such as TinyMCE or FroalaEditor .. \nit is against the rules of html.\nOkay! It does not matter! HLS does not support data- setup...\nNever mind!\n Thanks!\n. ",
    "fakirpic": "i am still waiting for  response. for god sake thank you. @gesinger its not possible,my stream can't be watched over different domains. i tried that template on my server it fails to load second hls and giving these errors.\nVIDEOJS: WARN: Problem encountered with the current HLS playlist. No suitable alternatives found.\n_logType @ log.js:79\nVIDEOJS: ERROR: (CODE:2 MEDIA_ERR_NETWORK) A network error caused the media download to fail part-way. MediaError {code: 2, message: \"A network error caused the media download to fail part-way.\"}\n.\nios can play without problems.\nmy videojs player can play but it stucks every time but i dont see any network problem\nhttps://i.imgur.com/Iqc3iqP.jpg here how the network tab looks like when it stucks. ",
    "muhammad-ammar": "@gkatsev @forbesjo Thanks for your help.. ",
    "zainmansoor": "The issue is that we uploaded different ratio video that's why some part has been cropped, But when i set my videojs player primary flash then its work fine for me.. @mjneil you can use below hls URL for testing.\nhttps://stream1.jeem.tv/vod/dbb6625bdeecc2b566b047bc5e183ead.mp4/playlist.m3u8?wmsAuthSign=c2VydmVyX3RpbWU9MTIvMTkvMjAxNiA5OjQ5OjMzIEFNJmhhc2hfdmFsdWU9dzhucXdXb2lZZmE4MXhIdjI4YWRiUT09JnZhbGlkbWludXRlcz02MCZpZD0x\nthis URL has different ratio now put this on your player and set primary html5 and run on chrome to see the issue. @mjneil watch last 4 seconds than you will understand my issue. But its work fine here https://www.geo.tv/latest/124229-Abbottabad-Commission-report-should-be-made-public-Justice-r-Iqbal\n because we used primary flash tech order on it. You can compare both url to understand.\n. @gesinger see screen shot \nHTML5 PLayer:\n\nFlash Player:\n\nBut if you open jsBin link in Firefox its work fine but if you open this in chrome then you will face this issue. And its just happen in some video. Well i used only flash now because its work fine on flash every time. Problem with html5 on chrome.\n. @gesinger your provided both links behave same as my issue, may be its my chrome version issue my current version is  55.0.2883.87 m (64-bit).\n. @gesinger i updated my version 55.0.2883.87 m (64-bit) TO 56.0.2924.87 (64-bit) but issue is still happening.. @gesinger i have tested it more than 5 pc's but still facing same problem, so i used primary flash for these videos.\nThank you for helping me. its just browser specific issue we can use primary flash for that.\nNow i'm going to close this issue.\nThanks @gesinger . ",
    "strashila": "Hi,\nWe have the same issue - the right part of the video is cropped in Chrome only, and inside HTML5 based player only. Works fine in Firefox, IE, and on Android an iOS native browsers\nThanks,\nAlex. ",
    "Frindecent": "The issue is still there in video.js on chrome (windows version). The issue occurs on videos with resolution like 1680x1050. t\n@gesinger you can reproduce the error when using chrome on windows (any version of chrome). you can use video like screen recordings. it will have the right side cropped. Please let me know if you have any way around that.. Unfortunately we were not able to solve it with videojs. What I did was while encoding our videos , I maintained the aspect ration between height and width of the videos and the new videos due to their proper height/width ratio didnot had this issue.. ",
    "donlaur": "I have seen the issue on Windows Chrome, but not on Mac.  Did anyone happen to find the reason or a fix?. ",
    "dtiesling": "Here's a sample HLS you can download - https://storage.googleapis.com/jouststudio-public/encrypted_bunny.m3u8\nIt probably won't play directly from there due to CORS settings on the google buckets.\nThis is the ffmpeg I am using to generate the files if that helps at all.\nffmpeg -i input.mp4 -vf scale=-852:480 -b:a 128k -pix_fmt yuv420p -vcodec libx264 -profile:v high  -hls_list_size 1000000 -hls_flags single_file  -hls_key_info_file info.txt output.m3u8\n. I've also tried encrypted the .ts file myself and I get the same result. It throws the error above and the plays the first segment before freezing.. @dmlap Have you successfully generated an HLS that uses BYTERANGE, a single segment, and AES encryption?. Looks to be a bug in ffmpeg - https://trac.ffmpeg.org/ticket/5858. \nI've had success using bento - https://www.bento4.com/developers/hls/. I am not setting the override option so whatever the default is. All of content is password protected so I'm working getting something hosted publicly to try in the template. \nAre there settings anywhere for the playback speed of the audio that I'm missing? It seems to get ahead of the video at a fairly constant rate.. Here's a new piece of information. When I switched to unencrypted files the audio maintains sync. Has it been confirmed that the plugin works with encrypted videos longer than a couple of minutes?. Issue has been replicated here - http://output.jsbin.com/fagituguba\nI've also tested the encrypted videos using the built-in ios player and the audio stays synced.. @gesinger Were you able to view the example? Do you know yet if this is a bug in the plugin or an issue with the stream?\n. Thanks for the prompt responses @gesinger and all the help. Just a couple more questions.\nSince the stream is handled without issue by the iOS player it looks like it could be played. Are you guys going to look into this further or is this going to be a \"won't fix\"?\nIf it is a \"won't fix\" do you have a list of specs for encrypted videos that work best with the plugin (i.e. aes-128, AAC audio, mpeg 2 chunks, etc.)?. I'm using a single .ts file for the .m3u8 playlist instead of creating a separate file for every chunk. Could that be related?. It looks like the issue is that the chunk sizes are not divisible by 16 so the decryption bombs out. @gesinger  does having the player add padding to any chunks that are not divisible by 16 seem like a viable option? . The bento4 packager has been updated to create valid streams. The new streams with valid sized chunks play flawlessly. Thanks again for the help debugging.. For reference I swapped in this block of code and it seems to solve the problem.\n@ line 763\n```\nthis.mainSegmentLoader_.on('error', function () {\n        this3.mainSegmentLoader.pause();\n        if (this3.audioPlaylistLoader) {\n          this3.audioSegmentLoader.pause();\n        }\n    setTimeout(function(){\n      _this3.mainSegmentLoader_.load();\n        if (_this3.audioPlaylistLoader_) {\n          _this3.audioSegmentLoader_.load();\n        }\n    }, 5000);\n  });\n\n```. ",
    "andreyhammer": "HI.\n I think that isn't bug. it is key rotation for each segment.. ",
    "elhampour": "Tnx for your respond, but im in need a solution here, what do you suggest ? . This is not about the initial moment, lets say my video has two format both of them in hls format. when user plays the video the bad quality ( 240p ) gets activated and the next two part of video immediately gets downloaded, bit if user decides to view th 360 quality, i change the playlist like the solution above , but the default behaviour of contrib plugin is to play the downloaded part ( 240P) first and after them it goes to download the 360 format, but i want to make the plugin to play and download 360 format immediately after user change the quality.. no one ? i need it asap.. @gesinger no it does not satisfy my need, i can change the quality through the plugin that you mention but i have to wait for the downloaded part to play and then my new quality comes into play. but i want to change that imminently . i dont have any error in ie 11 or below, but my videos wont play, maybe i have to use different coding for ts files or some thing else.\nWhat should we do for this problem ?. ",
    "msencenb": "Thank you for doing this, and the excellent contrib-quality-levels plugin. Today I wrote a custom UI component that exposes a little quality picker, and to turn on a specific quality I loop through the players qualityLevels and set everything except one to disabled. But it appears that it doesn't switch to the new stream until the next segment. Is there anyway to force contrib-hls to reload the current segment with the new qualitylevels set on the player, rather than waiting for the existing segment to finish?. ",
    "klimentLambevski": "@gesinger Hi i know this is closed but i need to ask if you have any kind of option for clearing out downloaded segments? i want to clear segments after switching to higher resolution because if the user has chosen lower resolution and many segments are preloaded the video continues to buffer after those downloaded segments. @gesinger thanks for the quick answer. Can I control hls stream resolutions when hls tech es not available (trough html5 tech)? sorry for unrelated question for this issue but my problem is that i can't control hls resolutions without videojs-contrib-hls. @gesinger thanks i will try that. ",
    "keelbo": "@elhampour @gesinger  Any update on this? . ",
    "pureexe": "I'm also waiting for API to clear buffers.. same issue here.. ",
    "mkorszunsands": "@forbesjo thank you so much for this hint!!! It solves the problem :) \ud83d\udc4d . ",
    "zshenker": "Fix for this was merged into m3u8-parser in https://github.com/videojs/m3u8-parser/pull/12. Additional note to this, I just tried updating video.js from 5.14.1 to 5.15.1, and this error is resolved.\nOn GitHub, 4.0.2 is marked as \"Latest\" of videojs-contrib-hls, but on npm 4.0.3 is latest. While with video.js 5.14.1 is \"Latest\"(on GitHub & npm) and 5.15.1 is \"Pre-Release/next\".\nIs it expected that there would be issues using videojs-contrib-hls 4.0.3 with video.js 5.14.1? and should 4.0.3 be latest on npm?. ",
    "kiscoman": "Hello, \nI\u00b4m having the same problem. Is easy to reproduce, just using the developer tools of Chrome, select any of the 3 android devices, and go to the template that suggest \"gesinger\". Error code 4 appear.\nBut with any other equipment selected, like ipad works.. Hello, \nYes, I tested the template in a Real device and works, but not my web page.\nI put exactly the same scripts but with my own hls stream, and is funny because works when the device use mobile data, and doesn't work using WiFi. . Hello again. \nIf I open the web page where the streaming is using mobile data it works, but with using wifi not. \nIs something related with settings the source. If I change to WiFi once I see the video keeps working, but if I load Another not. \nWhen doesn't work te he player says error code 4.\nUsing the debug with the device connected to a laptop I can see the error code 4, but any other difference in the behaviour except that. The m3u8 file is downloaded in the same way, and Take more or less the same time. . ",
    "wangxd8": "I have also encountered such a problem, how can I solve it?\n. ",
    "418900516": "hi  @gesinger @DonkeyInBeijing  ,now we use the hls.js library ,found the time when the segment appended the buffer to the seeked is less than the videojs-contrib-hls library and the time reduced from the seeking to the seeked \u3002\nthe hls.js demo:\n           http://dailymotion.github.io/hls.js/demo/\n. we have this problem. when get the segment and push the buffer,the seeked event not trigger ,delay some seconds before play. Are you solution the problem?. I try videojs-contrib-hls version 3.6.13,but the case still appear. Are you know the seeked event what time is triggered? . I found this issue too.when click backwards ,the video back to the forward position on the progress bar, and play the video continue, but the time on the progress bar stop,later the video stop play. . ",
    "servercimen": "No solution yet, I just use videjs-contrib-hls version 3.6.13 which doesn't have the same problem. ",
    "DonkeyInBeijing": "@gkatsev @gesinger Thanks Gary , Garrett\uff0c I did not expericence this issue any more after upgrade to version 5.16.. ",
    "scrouchman": "Closing this as while a few 'issues' suggest this should be automatic its clearly not. Solved by doing some browser detection and changing the techOrder. ",
    "onigetoc": "I did some modifications and i make it work now, Do not really know what i did wrong but it's working now.\nhttp://codesniff.com/jquery/hls-http-live-streaming-video-for-videojs-plugin-for-wordpress-m3u8. Pure CSS RED / GREY light Before LIVE text.\n.video-js .vjs-live-display:before {\n      content: \"\u2022\";\n      font-size: 172%;\n      padding-right: 5px;\n      vertical-align: sub;\n      color: #ccc;\n    }\n    .video-js.vjs-playing .vjs-live-display:before {\n      color: red;\n    }\n    .video-js.vjs-paused .vjs-live-display:before, .video-js.vjs-waiting .vjs-live-display:before, .video-js.vjs-seeking .vjs-live-display:before {\n      color: #ccc;\n    }\nBut need a javascript solution to restart the video in real time and not in the buffer. When you pause a HLS m3u8 video, it won't restart in you click play. \nLike Youtube, I though about a way to click the LIVE text to reload the video to real time streaming, It may be implemented in your js.\n// RELOAD VIDEO ON CLICK LIVE BUTTON \n    $(document).on('click', '.vjs-live-display', function () {\n      player.src({\"type\":player.currentType(), \"src\":player.currentSrc()});\n      player.load();\n      player.play();\n    });\nOR javascripts only\n```\n    videojs('my_video_1', {}, function(){\n  var player = this;\n\n  var liveHSL = document.getElementsByClassName('vjs-live-display')[0];\n\n  liveHSL.addEventListener('click', function(event) {\n    event.preventDefault();\n    player.src({\"type\":player.currentType(), \"src\":player.currentSrc()});\n    player.load();\n    player.play();\n  });\n\n});\n\n```\n. what about the idea to go real time when clicking the LIVE button?\nYoutube do it this way: https://www.youtube.com/watch?v=MTBOptDSVhQ\nIf you click play it will play the video in buffer i guess and if you play LIVE it will reload in real time.. It's working well.\nI did find out that if i seek, the video will restart too. It's look faster than reloading the video.. I found lot of list of m3u8 file that do not work with this videojs hls plugin.\nI found a Chrome extension to read m3u8 right in your browser to test m3u8 files. (i found dozen of m3u8 files who is working with this chrome extension who not work with videojs hls) \nhttps://chrome.google.com/webstore/detail/native-hls-playback/emnphkkblegpebimobpbekeedfgemhof\nI think it based on hls.js (from dailymotion i think)\nThere's also a Chrome extension to download or view all Chrome extension files.\nChrome extension source viewer: \nhttps://chrome.google.com/webstore/detail/chrome-extension-source-v/jifpbeccnghkjeaalbbjmodiffmgedin\nTo check the m3u8 chrome extension source code. (Or others chrome extensions)\n@mikhoul your m3u8 file in the #1021 issue do work in the chrome extension\n. Do this is updated on the CDN?\nsome LIVE videos who work with the Chrome HLS extension but not with videojs HLS\nEXTINF:-1,BBC Arabia **\nhttp://bbcwshdlive01-lh.akamaihd.net/i/atv_1@61433/master.m3u8\nEXTINF:-1, MTV AM **\nhttp://mtvam.ru/hlsam/playlist.m3u8\nEXTINF:-1, M6 Music **\nhttp://sslhls.m6tv.cdn.sfr.net/hls-live/livepkgr/definst/m6_music_hits_hls_aes/m6_music_hits_hls_aes_856.m3u8\nEXTINF:-1,VOX Music TV **\nhttp://stream.smcloud.net/live/vox2/stream1/VOX%20Music%20TV.m3u8\nEXTINF:-1,Radio Montecarlo TV **\nhttp://fms.105.net:1935/live/rmc1/playlist.m3u8\nEXTINF:-1,Virgin Tv **\nhttp://fms.105.net:1935/live/virgin1/playlist.m3u8\nEXTINF:-1,Radionorba Tv **\nhttp://85.17.80.132:80/radionorbatv/norbatv_source.stream/playlist.m3u8. Ok, i did find out that most of theme have this message in the inspector.\nXMLHttpRequest cannot load http://77.92.76.135:1935/tvce/livestream/playlist.m3u8. No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'http://www.example.com' is therefore not allowed access.\nI guess that my Chrome extension plugin to read hls m3u8 files bypass these restrictions. I did a test\nthis m3u8: http://live.lachainenormande.fr:80/live/lcn/livestream/playlist.m3u8\nwork here: https://www.hlsplayer.net/\nbut not with videojs HLS\nhttp://www.scriptsmashup.com/scripts/videojs-contrib-hls-master/demo-live-tv.html. It's hard to tell, it may be my internet connection, but it do not stop on my iPad and Android tablet but it stop on Chrome on desktop.\nThe also do not stop with this m3u8 chrome extension hls player (Sometime, i can see the segment error but it do not give up and the .ts segment is loading)\nhttps://chrome.google.com/webstore/detail/native-hls-playback/emnphkkblegpebimobpbekeedfgemhof\n(Created with the original hls.js plugin)\nOn video js, if the .ts segment fail it do not try to load it like the Chrome extension.\nMany m3u8 videos stops, it's hard to tell why some stop and some not. But they never reload or restart, they also stop on Chromecast. (But like i said, they do not stop on my two tablets (IOS / Android))\n\nJust another note with no relation the above problem:\nVideos who are blocked in the header (403 or 404) are not blocked on mobile tablet.. May be 2 to 3 minutes, tryed again on Android and it work but stop on desktop Chrome . Console log after around 2 min give me a .ts file cancel 403 or 404 (not sure).\nafter it load the .m3u8 file many time but it's never followed by a .ts file.\nIt is my internet connection, or the external .ts file that was down some seconds and it do not try to reload this file?\nBecause, most of the m3u8 videos work well and do not fail loading the .ts files.\n. Hi, i test from CDN but the 5.4 is not there. i guess i should wait a little bit.\nOK\nhttps://cdnjs.cloudflare.com/ajax/libs/videojs-contrib-hls/5.3.3/videojs-contrib-hls.min.js\nNot OK\nhttps://cdnjs.cloudflare.com/ajax/libs/videojs-contrib-hls/5.4/videojs-contrib-hls.min.js\nMy nodejs on my computer is caput since many weeks and i can't fix it at all.\nIs there a link with the latest compiled version?. It may depend of the time of the day i'm checking the video, but until now i got no connection error but the video stopped again after around 3 minutes.\nNow it try again and again to load this URL: \nhttp://infowarslive-lh.akamaihd.net/i/infowarslivestream_1@353459/index_800_av-p.m3u8\nBut not followed by a .ts file.\nI did a click call on the LIVE text and the video reloading the video url and the video type but it won't restart, i should reload the web page to restart the video.\ni just got this error in console\n\nUncaught DOMException: Failed to set the 'duration' property on 'MediaSource': The 'updating' attribute is true on one or more of this MediaSource's SourceBuffers.\n    at t.value (https://cdnjs.cloudflare.com/ajax/libs/videojs-contrib-hls/5.4.0/videojs-contrib-hls.min.js:6:20569)\n    at t (https://cdnjs.cloudflare.com/ajax/libs/videojs-contrib-hls/5.4.0/videojs-contrib-hls.min.js:1:10120)\n    at https://cdnjs.cloudflare.com/ajax/libs/videojs-contrib-hls/5.4.0/videojs-contrib-hls.min.js:1:10310\n    at . (https://cdnjs.cloudflare.com/ajax/libs/videojs-contrib-hls/5.4.0/videojs-contrib-hls.min.js:1:10314)\n    at .value (https://cdnjs.cloudflare.com/ajax/libs/videojs-contrib-hls/5.4.0/videojs-contrib-hls.min.js:3:267)\n    at f (https://cdnjs.cloudflare.com/ajax/libs/videojs-contrib-hls/5.4.0/videojs-contrib-hls.min.js:2:2787)\n    at https://cdnjs.cloudflare.com/ajax/libs/videojs-contrib-hls/5.4.0/videojs-contrib-hls.min.js:2:4673\n    at Object.callback (https://cdnjs.cloudflare.com/ajax/libs/videojs-contrib-hls/5.4.0/videojs-contrib-hls.min.js:3:12746)\n    at j (https://vjs.zencdn.net/5.16.0/video.min.js:19:29664)\n    at f (https://vjs.zencdn.net/5.16.0/video.min.js:19:29532). And every time i reload my web page i got this error in the begining.\n\nBut not if is a Youtube video, only if it's HLS video\n\nVIDEOJS: WARN: Problem encountered with the current HLS playlist. Trying again since it is the final playlist.\nc.logByType @ video.min.js:18\ni.warn @ video.min.js:18\nvalue @ videojs-contrib-hls.min.js:1\n(anonymous) @ videojs-contrib-hls.min.js:1\nd.dispatcher.d.dispatcher @ video.min.js:18\nk @ video.min.js:18\ng.trigger @ video.min.js:14\nvalue @ videojs-contrib-hls.min.js:2\n(anonymous) @ videojs-contrib-hls.min.js:1\n(anonymous) @ videojs-contrib-hls.min.js:1\n(anonymous) @ videojs-contrib-hls.min.js:3\nj @ video.min.js:19\nf @ video.min.js:19\nb @ video.min.js:19\n. Now the sound is not in sync with the video. Now the hls plugin try too much to find inexisting or not working video, it never stop trying loading a failing video.\nhttp://streaming-hub.com/stream/arte.m3u8\n\nI think these video block call from other domain, but the 5.4 hls plugin never stop trying to load it.. ",
    "gnujosh": "Yeah, I think it was the PAT and PMT packets that were within that 376 bytes.  We are under some constraints with the data we are working with, so we can't ensure that the files we are given will start with PAT / PMT packets since we can't change how they are written to disk.\nI'm a bit of a github noob, so I'm not sure what you mean with \"submit a PR\".  Since it was just a few changes in a few spots, I thought it would be easier to just point out the locations of changes we made rather than download git, clone the repo, download npm, and get all the tooling set up.. OK, I hope I was able to get the order correct, my attempt at a pull request is here: https://github.com/videojs/videojs-contrib-hls/pull/996. I see a message above that \"The Travis CI build failed\".  I looked at the details and it is not clear to me why or even where it failed.  Perhaps someone else can give some advice on this.. ",
    "move[bot]": "This issue was moved by forbesjo to videojs/http-streaming#151.. This issue was moved by forbesjo to videojs/http-streaming#132.. This issue was moved by forbesjo to videojs/http-streaming#133.. This issue was moved by forbesjo to videojs/http-streaming#138.. This issue was moved by forbesjo to videojs/http-streaming#146.. This issue was moved by forbesjo to videojs/http-streaming#139.. This issue was moved by forbesjo to videojs/http-streaming#143.. This issue was moved by forbesjo to videojs/http-streaming#144.. This issue was moved by forbesjo to videojs/http-streaming#152.. This issue was moved by forbesjo to videojs/http-streaming#130.. This issue was moved by forbesjo to videojs/http-streaming#135.. This issue was moved by forbesjo to videojs/http-streaming#145.. This issue was moved by forbesjo to videojs/http-streaming#141.. This issue was moved by forbesjo to videojs/http-streaming#134.. This issue was moved by forbesjo to videojs/http-streaming#175.. This issue was moved by forbesjo to videojs/http-streaming#137.. This issue was moved by forbesjo to videojs/http-streaming#142.. This issue was moved by forbesjo to videojs/http-streaming#136.. This issue was moved by forbesjo to videojs/http-streaming#140.. ",
    "kjdev-lytleworks": "Just tested using the hls.js demo player and the same example playlist and there is no distortion heard in Chrome on Windows 7.. Yes this source had multiple audio tracks.  Removing the second audio track fixed the audio issues in Chrome/Firefox.  My guess is that both audio tracks were getting presented for playback.. ",
    "nconcetti": "I tested it using the provided VideoJS HLS Demopage and i can confirm that the audio is badly distorted using Chrome 55.0.2883.95 (64-bit) on OSX 10.12.2. Worked fine on hls.js demo.\nDiggin a bit deeper i found out that your segments have 2 audio streams (AAC-LC) which share the same properties. I wonder if it works with one audio track.... This seems to be very related to this issue at mux.js. ",
    "cronello": "Yes, the problem is at the mux.js \nThey put all audio track into the one audio buffer that is outputed.\nWorkaround can be done by selecting just the first audio track to be outputed at\nElementaryStream.push pes function. ",
    "mahpah": "you might want to read #600 comments. ",
    "kitce": "I found the bug.\nIn MasterPlaylistController -> this.decrypter_.onmessage:\naudiosegmentLoader_ should be audioSegmentLoader_. There should be more than one, such as\nhttps://github.com/videojs/videojs-contrib-hls/blob/master/src/master-playlist-controller.js#L701. ",
    "kennypavan": "No problem. Thanks for your quick response @gesinger. . ",
    "drakunov": "This error on Safari  10.0.2, OSX 10.12.2\nusing \nvideojs.options.hls.overrideNative = true;\nvideojs.options.html5.nativeAudioTracks = false;\nvideojs.options.html5.nativeVideoTracks = false;\n\n[Info] Source changed to auto (path, line 75)\n[Error] VIDEOJS: (4)\n\"ERROR:\"\n\"(CODE:3 MEDIA_ERR_DECODE)\"\n\"The media playback was aborted due to a corruption problem or because the media used features your browser did not support.\"\nd {code: 3, message: \"The media playback was aborted due to a corruption\u2026media used features your browser did not support.\", status: null, MEDIA_ERR_CUSTOM: 0, MEDIA_ERR_ABORTED: 1, \u2026}\n    logByType (video.min.js:18:21374)\n    error (video.min.js:15:22741)\n    handleTechError_ (video.min.js:15:14221)\n    dispatcher (video.min.js:18:18660)\n[Log] JavaScript error: InvalidStateError (DOM Exception 11): The object is in an invalid state. on line 6 for http://urlurl/contrib/videojs-contrib-hls.min.js (mobile-logger.js, line 6)\n[Error] InvalidStateError (DOM Exception 11): The object is in an invalid state.\n    value (videojs-contrib-hls.min.js:6:29976)\n    (anonymous function) (videojs-contrib-hls.min.js:2:29983)\n    (anonymous function)\n    value (videojs-contrib-hls.min.js:2:30886)\n    value (videojs-contrib-hls.min.js:2:30728)\n    value (videojs-contrib-hls.min.js:2:29943)\n    value (videojs-contrib-hls.min.js:2:27144)\n    value (videojs-contrib-hls.min.js:2:26279)\n    value (videojs-contrib-hls.min.js:2:26082)\n    value\n    (anonymous function) (videojs-contrib-hls.min.js:3:12748)\n    j (video.min.js:19)`. \n",
    "sbminimalistics": "Guys, what is the status of this issue?\nIs there any way to overwrite native hls player on Safari?\nThe thing why I'm asking this is the fact that m3u8 manipulation is easy doable through videojs.Hls.xhr.beforeRequest method. Alas it's not available when native playback is on.\ntest environment on my machine:\nvideojs-contrib-hls @version 5.5.3\nVideo.js 6.2.0\nflags rewriting:\nvideojs.options.html5.nativeAudioTracks = false;\nvideojs.options.html5.nativeVideoTracks = false;\nvideojs.options.hls.overrideNative = true;. As far as I know there are no updates on this.\nAlso it depends which Safari you have in mind.\nNative playback can not be overridden if \"Media Source Extensions\" is not supported. With that in mind, information given over here\nhttp://caniuse.com/#search=mse\nimplies  that at the moment native playback could not be overridden on iOS Safari doesn't matter how much effort you pay. But from my understanding Safari on Mac should be able to handle hls non natively. But as guys on this thread mentioned there are some errors popping out while playing hls non-natively on non-mobile Safari.. ",
    "jorisvervuurt": "+1 for @sbminimalistics: I'd like to know too, because I'd like to set the beforeRequest method in Safari too. Ain't possible right now (latest Video.js 6 release). :-(. ",
    "petrklus": "+1 for @sbminimalistics from my end too - seeing the issue on Safari 10, vjs version 5 and latest HLS.. ",
    "brycefisher": "Discussed this issue today on the Videojs Slack channel. I'm also having a possibly related problem. \nOne possible solution raised by the maintainers was to avoid using the html element <source>, since Safari might start using the native HLS implementation before contrib-hls has a chance to intercept it. Instead, avoid creating a <source> element inside the video tag. Manually call player.src('https://example.com/hls.m3u8') so that videojs can fully control the process.\nThis solution didn't work for me, but I'm on a different version of videojs and contrib-hls than the OP. It might be worth a quick try?\n. @gesinger We're seeing a very similar issue on ChromeOS since Chrome 59 but also in Chrome 60. Any thoughts or other information needed beyond what's in this issue?. ",
    "gfx0": "Changing the source using an object like may also help with this problem:\nplayer.src( { src: 'https://example.com/hls.m3u8', type: \"application/x-mpegURL\", withCredentials: false } ). ",
    "buccfer": "@gesinger Is there any update on this? I'm experiencing issues with Safari and overrideNative as well.\nBest.. ",
    "yoshz": "I can confirm that this issue still exists even with the options set right @tchakabam.\nWith overrideNative enabled on Safari 8 it doesn't start at all because of the errors and on Safari 10/11 it fails to load files when you seek to a different time.. ",
    "shreysaroch": "Issue persists on and above iOS 11.2.1,videojs works perfect on and below iOS 11.0\nWhat is the current status?. ",
    "m1neral": "Failed in safari <= 9\n[Error] TypeError: Attempted to assign to readonly property. (blob:http://localhost:3000/bc24f9dd-aa20-4aef-9d5f-304314fa0b7a, line 19565)\n[Error] TypeError: undefined is not an object (evaluating 'this.messageHandlers') (blob:http://localhost:3000/bc24f9dd-aa20-4aef-9d5f-304314fa0b7a, line 19569, x3). ",
    "bamboodigital": "Confirming this is still an issue on the following versions, any updates on a solution in progress? : \nVideoJS\n6.6.0\nvideojs-contrib-hls\n5.12.2\nSafari\n11.0.2\nErrors\n[Error] TypeError: Attempted to assign to readonly property.\n[Error] TypeError: undefined is not an object (evaluating 'sortedSegments.audio.initSegment.byteLength')\n[Error] TypeError: Attempted to assign to readonly property.\n[Error] Unhandled Promise Rejection: [object DOMError]\n. ",
    "RafalLukawiecki": "Same issue. @chaner regarding your comment on 14 Feb. The link you provided relates to iOS Safari, where Media Source is undefined. However, this issue affects the regular, desktop Safari on recent macOS, which has supported MediaSource for a while. Have I misunderstood you, perhaps? Apologies if so.. ",
    "wugengsong": "same issue. ",
    "harshil93": "Happening on Chrome Mobile, Edge Mobile and Edge desktop. This happens when your video.js and contrib-hls.js are loaded after your video tag is already created. \nPut your js files before your video elements and everything works fine.. ",
    "chaner": "Ran it in debug, seeing undefined is not an object (evaluating 'this.tech_.hls.xhr. Somehow the xhr object is not being instantiated on iOS.. Debugged further, looks like MediaSource is undefined:\nhttps://forums.developer.apple.com/thread/90712. ",
    "aaronchenweb": "Same issue. I got same problem, please help. ",
    "caobug": "@gesinger Thank you. I have a full video be split to many flv files, I hope it can play like m3u8. \nA plugin ckplayer can load an XML file, It contains video clip information, I hope videojs can support:\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<ckplayer> \n  <video>\n    <file><![CDATA[a.flv]]></file>\n    <size>32594386</size>\n    <seconds>204</seconds>\n  </video>\n  <video>\n    <file><![CDATA[b.flv]]></file>\n    <size>31835748</size>\n    <seconds>189</seconds>\n  </video>\n  <video>\n    <file><![CDATA[c.flv]]></file>\n    <size>48219871</size>\n    <seconds>189</seconds>\n  </video>\n  <video>\n    <file><![CDATA[d.flv]]></file>\n    <size>49745973</size>\n    <seconds>206</seconds>\n  </video>\n</ckplayer>\n\n. @gesinger Can you help me? . ",
    "alibrightman": "Windows 7 + IE 11 doesn't work either.\nvideojs-contrib-hls 5.2.1\nVideo.js 5.16.0\nTest using http://videojs.github.io/videojs-contrib-hls/\nOr http://jsbin.com/vokipos/8/edit?html,output\nVideo is expected to play, but doesn't.\nConsole errors:\nVIDEOJS: WARN: Failed to create SourceBuffers TypeError: Object doesn't support property or method 'vjs_appendChunkReady'\n(the debugger breaks at https://unpkg.com/videojs-contrib-hls/dist/videojs-contrib-hls.js Line 9398)\nVIDEOJS: ERROR: (CODE:3 MEDIA_ERR_DECODE) The media playback was aborted due to a corruption problem or because the media used features your browser did not support.\n. ",
    "shaolintibo": "Thanks for your feedback, I'll search why the  buffer is filled with 4 second gaps every 6 seconds.. ",
    "aranondo": "Same happened to me and the solution was to use \"hls: {withCredentials: true}\" when creating the videojs object. Without that option the response from the server was a 403 because of the access control allow origin header. Could you try that?. @mikhoul Sorry I don't know why it's not working in jsbin. Here is the code in pastebin, you can use is as html and works fine por me https://pastebin.com/qBmUW089\nChange the src with a valid one.. ",
    "OwenEdwards": "If/when PR 14 gets pulled into m3u8-parser and released, I'll update the package.json file to reflect the version of that package that is needed to support this.. I'll take a look at how to set up some tests.. In theory that's possible; I'd assume it would need to follow the same rules as, say, a CAPTIONS or SUBTITLES tracks:\nhttps://tools.ietf.org/html/draft-pantos-http-live-streaming-20#section-4.3.4.1.1:\n\nAll EXT-X-MEDIA tags in a Playlist MUST meet the following\n   constraints:\no  All EXT-X-MEDIA tags in the same Group MUST have different NAME\n      attributes.\no  A Group MUST NOT have more than one member with a DEFAULT\n      attribute of YES.\no  All members of a Group whose AUTOSELECT attribute has a value of\n      YES MUST have LANGUAGE [RFC5646] attributes with unique values.\n\n\nSo you could tell them apart by name (label) and language. But it wouldn't change the audio track's kind. Is that what you were wondering about?. Sure - I wasn't sure how to deal with the line getting too long! I'll change that.. ",
    "LeonidasEsteban": "Same issue here. any idea for fix it?. ",
    "frontMoment": "@vpowers @LeonidasEsteban same issue, any solution by using dependency via package.json?. ",
    "gdenisov": "@mjneil switching the dependencies to the latest video.js 5.19.0 and videojs-contrib-hls 5.3.3 loads only one version of video.js for me, but the video in the above test case or my own project still does not work. ",
    "cedricve": "@dtiesling also OSX/chrome is affected.. cool @leanoardo-hotmart. same issue when upgrading to Chrome 58, didn't experienced with Chrome 57. I get this error.\n\n. Having similar issue when upgrading to Chrome 58, the player is stuck after loading the second segment. Following error is thrown.\n\n. ",
    "mgara": "Is there any way to actually force the player to reload the video and play it back again ? I'm trying to do a \nplayer.on(\"error\",function(e){\nsetTimeout(function(){\nplayer.load();\n}, 5000) \n});\nbut the player goes to \"stalled\" State.\n. ",
    "leonardodiniz-hotmart": "@gesinger\nHaving at least one playlist out of the blacklist seems fine to me.\nI believe it will solve the connection problem.\nYou said in your comment that now all playlists but one will be blacklisted for a period of 5 minutes.\nDon't you think 5 minutes is too long?\nCan't we have an option for this?\nIn a momentary connection loss scenario, imagine we would blacklist all playlists but a 224p.\nWhen we have the connection back we would play 224p video for 5 minutes.\nDid I get it right?\nIn this case I think five minutes would be too much. Most videos nowadays are 10 to 12 minutes long. Therefore we would list blacklist for 50% of the video.\nWhat do you think about this time?\nDoes it make sense?\nCheers. I think that's a great idea @gesinger .\nHaving an option for the blacklist duration and this new approach would solve the connection loss issue and all the other factors that cloud blacklist a playlist would be covered as well.. I can't see why the build is failing.\nI've ran the tests locally and everything went fine.\nWould it be the chrome version? Mine is 55\n\n. Hi @gesinger. Thanks for your answer. I'll give my thoughts on #1030 Ok?\nCheers. ",
    "omakogon": "Hello,\nThis problem occurs when I use HLSv4 (video+audio streams). For HLSv3 this problem does not occur.\nAlso noticed that this error occurs when HLSv4 posted on my high-speed CDN.\nWhen the same HLSv4 is hosted on Dropbox, everything works fine.\nThis error has the same error described in post #963\nAnd obviously this bug has to do with the speed of access to a content of HLS.\nFor example carlosllera I place the code:\n// JUST WAIT FOR A LITTLE ---------------------------\nthe delaytime is function(delay) {\n var start = new Date().getTime();\nwhile (new Date().getTime() < start + delay);\n}\nthe delaytime is(700);\nbefore filling the buffer:\nvideojs-contrib-hls.js:15683\nbuffer = new _virtualSourceBuffer2'default';\nAfter that, the error no longer occurs.\nSincerely,\nOleg. ",
    "belling": "Ah, thanks for looking into it. I was just using that source video because it was handy and couldn't figure it out.. ",
    "sea-kg": "I use \"videojs.options.overrideNative = true\" - it worked for emulator chrome browsers (and in adnroid chrome) . It's global options of videojs. You must set this options before creation.\nI m using like:\n...\n<script src=\"js/videojs-contrib-hls.js?v=1\"></script>\n<script>\nvideojs.options.hls.overrideNative = true;\n</script>\n\n. You welcome ). ",
    "zswxp32": "@gkatsev  thank you for help, it's useful.. ",
    "pinglikethinking": "how did you resolve your problems I have the same\n\n. I have solved this.\njust delete original video-js.swf\nand\nimport a new video-js.swf ,put it into static , and use it by\n Object.assign({\n       flash: {hls: { withCredentials: false }, swf: '/static/video-js.swf'}}, this.options)\nsource style is this,when play hls\nvideojs.options.sources=[{\n            withCredentials: false,\n            src: links,\n            type: 'application/x-mpegURL'\n          }]. ",
    "jasonbouffard": "Thanks for the explanation.. ",
    "russ": "I'm having the same issue. I took at a look at the jsbin fix posted above but that is showing the same problem. It should load the 720 but if you look at your inspector, you'll see it's loading the 480 version instead.\nhttps://www.dropbox.com/s/tyjkr39she88ynu/Screenshot%202018-09-26%2014.16.55.png?dl=0. I noticed that Safari picks the video correctly where Firefox and Chrome do not.. ",
    "jwoertink": "Something I noticed was this depends on your screen size. When shrinking the screen size down, it drops to the lower rate, but doing full screen, it jumps up to a higher rate. Maybe there's a config option for this to say always do the higher rate? (unless on mobile). ",
    "JPeMu": "You can use one of our test streams (I have seen the fault on this specific stream):\nhttp://csm-e.cds1.yospace.com/csm/extlive/yospace02,sampledroid.m3u8?yo.ac=true\nThis is a continuous-running live stream with very frequent discontinuities (for ad insertion). Unfortunately, this means that most of the time you won't see this problem as the PTS continuously rolls (and wraps). Only when it gets to a large value will the problem appear, and that only happens for a relatively short window every ~25 hours or so.\nI have also uploaded 2 sample TS segments here:\nhttp://demo.yospace.com/tony/110611066.ts\nhttp://demo.yospace.com/tony/yospace02.ts\nAs examples of the issue. The first (110611066) plays prior to the discontinuity and the second plays after the discontinuity. It is the second ts which contains ID3 metadata whose cue startTimes end up being negative.\nHope this helps - let me know if you need anything else. Thx.. ",
    "selimatmaca": "I tested  https://d2zihajmogu5jn.cloudfront.net/bipbop-advanced/bipbop_16x9_variant.m3u8 on http://jsbin.com/peyikedime/edit?html,output on android devices and it works.\nI am using the exact same code from http://jsbin.com/peyikedime/edit?html,output (except the source of course) and my hls stream can not be seen on videojs on android devices. On other platforms such as windows PC, Mac PC, iPhone my hls stream can be displayed.\nAny idea?. Hi Gesinger,\nI used override option as below and it didn't fix the issue. \noverrideNative: true\nvideojs.options.html5.nativeAudioTracks: false\nvideojs.options.html5.nativeVideoTracks: false\nI also tried viblast player, bitmovin player and those player does NOT show my video on android either.\nI am streaming some youtube videos from a laptop for you to test my stream. \nMy stream link is here: https://stream.sehir.edu.tr/mezuniyethls/sehirhlstest.m3u8\nI hope you guys can help. Thanks a lot. I have been streaming for the last 3 days (24/7),did you get a chance to check my stream?. I tested on many other players such as viblast and bitmovin. They dont work on android, too. Yesterday we tried android nougat and it works. So, I think this is an issue with android os, not with videojs player. What do you think?. ",
    "JohnnyDev0918": "Here's the video that I've been getting the error in Chrome only:\nhttp://breakdownservices-dev.s3.amazonaws.com/media/ecocast/209462/videos/209462-8ecd721a-e6d6-4992-9715-db9edcb112d7/playlist.m3u8\nOn Tuesday, March 28, 2017 7:58 AM, Matthew Neil <notifications@github.com> wrote:\n\nCan you provide a source that causes the problem and try loading it here. I am seeing no issues with a 6 second source.\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub, or mute the thread.  \n. Here's an example (see code below). If remove the \"autoplay\" attribute from the video element, then you won't receive the error \"VIDEOJS: ERROR: (CODE:4 MEDIA_ERR_SRC_NOT_SUPPORTED) The media could not be loaded, either because the server or network failed or because the format is not supported. MediaError {code: 4, message: \"The media could not be loaded, either because the \u2026rk failed or because the format is not supported.\"}\", but if you leave the \"autoplay\" attribute there, you will receive the above error after refreshing the page a couple times.\n<!DOCTYPE html>\n\n\n\nvideojs-contrib-hls embed\n\u00a0 \n\u00a0 <!--\nUses the latest versions of video.js and videojs-contrib-hls.\nTo use specific versions, please change the URLs to the form:\n\n\u00a0 \n\u00a0 \n-->\n\n\u00a0 \n\u00a0 \n\u00a0 \n\n\n\u00a0 Video.js Example Embed\n\n\u00a0\u00a0\u00a0 \n\u00a0 \n\u00a0 \n\u00a0 \n\u00a0 \n\u00a0 \n\n\nPlease help! Many thanks in advance.\nOn Tuesday, March 28, 2017 11:05 AM, Peter Le <peter_le1@yahoo.com> wrote:\n\nHere's the video that I've been getting the error in Chrome only:\nhttp://breakdownservices-dev.s3.amazonaws.com/media/ecocast/209462/videos/209462-8ecd721a-e6d6-4992-9715-db9edcb112d7/playlist.m3u8\nOn Tuesday, March 28, 2017 7:58 AM, Matthew Neil <notifications@github.com> wrote:\n\nCan you provide a source that causes the problem and try loading it here. I am seeing no issues with a 6 second source.\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub, or mute the thread.  \n. ",
    "itspwk": "I have set on the \"Cross-origin resource sharing (CORS) (for HTTP-based streams)\", but still getting this error on chrome. i have latest chrome installation\nBelow is the code :\n```\n<!DOCTYPE html>\n\n\n\n\n\n\n\n\n\n\n\n<script src=\"https://unpkg.com/video.js/dist/video.js\"></script>\n<script src=\"https://unpkg.com/videojs-contrib-hls/dist/videojs-contrib-hls.js\"></script>\n\n\n```\nin Firefox, getting this error msg : \"A network error caused the media download to fail part-way.\". ",
    "hmd13": "@gesinger and @gkatsev thank you for the answers, I will try that\n@gesinger , I'm not able here to attach the file.\n. @gkatsev thank you again for the answer, but do you know why it works on Firefox, and not in chrome ? . ",
    "zhuangs": "1080 . Tested and LGTM. Tested and LGTM. Issue: #1137\n. Not only sorted by bandwidth but also sorted by resolution in line 172. the unit test above and also 'selects the correct rendition by tech dimensions' one covered playlists with same resolution and different bandwidths, and playlists with same bandwidths but different resolution, added the playlists that have the same resolution and bandwidths. . yes, that will be much clear. yes, nice call, changed it . changed it to 'media not blacklisted after playlist 404'. so if it's the final rendition, just return without call the media() function, is this correct?. I attached this function to MasterPlaylistController because I was trying to call this function in the videojs-contrib-hls.test.js file. but maybe there is better way to do this . I thought seekableEnd, lastBufferedEnd, endTime being NaN may only happen at the very beginning of a playlist and that isn't the case we should blacklistCurrentPlaylist, is this correct? In that case, it doesn't affect the if statement. Did you mean we should check seekableEnd, lastBufferedEnd, endTime isNaN() inside the if?. yes, I found directly override Hls.Playlist.playlistEnd() in the test file is better :). changed this. changed this. changed it to set the loader's state when detect it's the final rendition and before calling load(). Trying to do this because I think reset the state after an error happens may mess the normal error handle logic of those non-final renditions. But not sure if it's the right way to do this. . Did this in the first place but then I found there is a case that the playlist contains the endList, so the seekableEnd will return the duration of playlist but the seekableStart returns null. I think that's why I changed here to return 0 and check for null on the sync points instead of checking expired. . fixed this. fixed this. fixed this. changed as suggested. changed! nice catch :). renamed!. makes sense! renamed!. I think it's because we don't want the segment requests to go off too much and VOD triggers the loadedplaylist immediately. cc @mjneil . seems unintentionally. Because it has to have multiple playlists then the playlist which key requests fail can be blacklisted. It seems I forgot to change the media.m3u8 to master.m3u8. . Because when the refresh request is aborted, playlistRequestError is called and we reset the loader.state to startingState(HAVE_METADATA). so that no longer is set to SWITCHING_MEDIA. I think if switching happens without error, the loader.state as SWITCHING_MEDIA won't be affected.. removed! :). changed! sorry for keeping making this mistake. added :). If the new response didn't be added here, it will error for the second(final) rendition. Since we clear blacklist duration for the first rendition when final rendition errors, we can't test if the blacklist duration is set through option successfully. . I think we have that excludeUntil check in line 1141? . You are right about that. But there is one more problem with this trigger, it seems I can't trigger event on the loader passed in. It says loader.trigger is not a function, isn't it supposed to be used like a regular playlist loader?. trying to do the detection of accessing player.tech_.hls here(fire hls-tech-access event when player.tech_.hls is accessed). was planning to define a get method for tech_.hls for the detection purpose but it seems that doesn't work. Do you have any good idea about how to detect the player.tech_.hls?. Makes sense! Changed as suggested. the demuxed event is triggered after the video segment request is fulfilled, should i remove the audio media request or just leave it there?. my bad forgot to delete this one and deleted. ",
    "amunan": "thanks, is this reason. i solved. ",
    "AndyBarron": "Any updates on this PR? The blacklisting is actively affecting a project I'm working on, would love to see this fixed :). ",
    "adnankorkmaz": "Thanks @gesinger for the response.\nI had said in my first comment that I had \"created a test page to reproduce the error\", different than the demo page. \nThe original error-reproduction page involved Google's ima3.js. \nIt is a rare combination of videojs + videojs-contrib-hls + mobile chrome + autoplay + m3u8 playlist of short video (<3 secs) + preroll ad request.\nUpon further investigating and toggling scripts in turn, the real issue turned out to be a concurrency problem where IMA and videojs was trying to initialize the same player; and that unmuted autoPlaying videos on Mobile was not allowed without user interaction first. Not quite having solved the real issue, I am pretty sure that it doesn't happen due to video-*.js at the moment.\n(Added details for possible future developers facing the same issue, however unlikely)\nTLDR, closing the issue.. ",
    "pebanfield": "I've been working in my production codebase which is not practical to share. I would need to create a separate stand alone example. I was hoping this might be a known issue? I will create an example. Thanks!. @gesinger - I have created a very basic test project demonstrating this issue - \nhttps://github.com/pebanfield/hls-contrib-build-test\nThe sample uses grunt-browserify rather than gulp or webpack as I must integrate this into an older codebase.\nAt present I am still experiencing this issue - \nhttps://github.com/videojs/mux.js/issues/131\nIt is not clear to me that your fix has made it into the current build version?\nI think the media not supported error is simply being thrown because I have not yet successfully imported hls-contrib. There are lots of threads related to this, but I have yet to find a definitive solution. \nAny help is much appreciated. Thanks.. Ok I will check back. Thanks for the update!. @gesinger - Thanks for the heads up. This fixed the issue. My sample is playing video now. Thanks!. ",
    "SVyatoslavG": "Have same issue.. ",
    "Sathishchary": "@gesinger , @samueleastdev, I am following the same videojs versions but i am not able to play the m3u8 files in the iOS devices and safari browsers, can you please help me how you played m3u8 files in iOS devices.. Hi, I am also facing the same kind of problem. My m3u8 files are playing with videojs contrib hls in computer. And those same videos are not playing in  ipad, iphone and android ( checked in marshmallow version). Its just showing the videolength time as '0:00', and stopped playing, I am using latest videojs contrib hls version\nversions:\nvideojs - 6.4.0\nvideojs contrib-hls: 5.12.2\nused flash also: videojs-flash: 2.0.1\nm3u8 url : https://d2zihajmogu5jn.cloudfront.net/bipbop-advanced/bipbop_16x9_variant.m3u8\nbelow hls example is perfectly working in android.\nhttp://videojs.github.io/videojs-contrib-hls/\ncan any one help me on this\nthanks\n. thanks @cladera, I have tried to play the m3u8 files in mobile devices. but it dint worked, after adding your code i am able to play m3u8 files in android devices, but in IOS devices its not working, I am following the new versions of videojs and videojs contrib hls, I have added the videojs flash also,\nversions:\nvideojs - 6.4.0\nvideojs contrib-hls: 5.12.2\nused flash also: videojs-flash: 2.0.1\nm3u8 url : https://d2zihajmogu5jn.cloudfront.net/bipbop-advanced/bipbop_16x9_variant.m3u8\nis there any way to play m3u8 files in ios devices?\nthanks. thanks @cladera .for the nice clarification,I am disabling the native support for all devices and browsers, but not for the iOS and Safari. I am doing like  below, dynamically adding the native true and false \n  for the mobile devices and browsers. \nandroid devices and browsers\n\nvideojs.options.hls.overrideNative = true;\n    videojs.options.html5.nativeAudioTracks = false;\n    videojs.options.html5.nativeVideoTracks = false; \n    videojs.options.html5.nativeTextTracks = false; \n\nI am setting the videojs options native like below for the iOS and Safari\n\nvideojs.options.hls.overrideNative = false;\n   videojs.options.html5.nativeAudioTracks = false;\n   videojs.options.html5.nativeVideoTracks = false; \n   videojs.options.html5.nativeTextTracks = false; \nplease correct me if i am doing wrong,\nAndroid devices are working fine, but i am not able to play the m3u8 files in iOS and safari with hls. can you help me what i need to do for the iOS devices and Safari browsers to play m3u8 files without showing the error.\nI am seeing the issue for the iOS and safari only, 'the media could not be loaded because the server or network failed'.. thanks @cladera for your valuable time, I have configured that options, but it dint worked in iOS, just showing the same error, no campatible source found, I have created one  jsFiddle Link. please can you check the link, what i am doing wrong, is the problem with new videojs version, if yes please can you share which videojs hls version will work in iOS devices, thanks  .  I have already asked the question, please find it stackoverflow link .  You can answer it, thanks @cladera , I will check that . thanks @cladera ,, its working like a champ.. you saved my time,,. \n",
    "pandaiolo": "I realized later that this is a broader problem. Bandwidth is computed only using the last download, AFAIK. It is normal for an \"adaptive\" player to adapt to the latest network conditions, but on small segments, a small variation in last segment download can be a \"false negative\" and cause a useless drop in quality. The same video on safari with native HLS always keep the highest quality settings, not with videojs on Chrome. I don't know how the bandwidth measurement is done in a native client but I am free to help in any direction you feel appropriate, so let me know if you have any plans on this.. ",
    "petergeneric": "I've included a snippet of the m3u8 below - I'm not currently able to release the source material, however this command (run against the most recent FFmpeg) should create the same sample media and m3u8:\n```\nmkdir essence\nffmpeg -y -f lavfi -i smptebars=size=1920x1080 -re -f lavfi -i \"aevalsrc=sin(4002PIt)|sin(4102PIt)|sin(4202PIt)|sin(4302PIt):s=2000\" -vf format=yuv420p,yadif -nr 600 -vcodec libx264 -preset veryfast -qp 23 -pix_fmt yuv420p -acodec aac -b:a 128k -f hls -hls_time 30 -hls_list_size 0 -hls_segment_filename essence/%05d.ts example.m3u8\n```\nMy m3u8:\n```\nEXTM3U\nEXT-X-VERSION:3\nEXT-X-TARGETDURATION:40\nEXT-X-MEDIA-SEQUENCE:0\nEXTINF:30.000000,\n00000.ts\nEXTINF:30.000000,\n00001.ts\nEXTINF:30.000000,\n00002.ts\nEXTINF:30.000000,\n00003.ts\nEXTINF:30.000000,\n00004.ts\nEXTINF:30.000000,\n00005.ts\nEXTINF:30.000000,\n00006.ts\nEXTINF:30.000000,\n00007.ts\n...continues on like this for 46,000 lines...\n```\nHere are the JS includes I'm using:\n<link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/semantic-ui/2.2.10/semantic.min.css\"\n          integrity=\"sha256-5+W3JHnvGYIJkVxUBsw+jBi9+pOlu9enPX3vZapXj5M=\" crossorigin=\"anonymous\" />\n    <link rel=\"stylesheet\" href=\"/css/main.css\"/>\n<script src=\"//ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js\"\n        integrity=\"sha384-3ceskX3iaEnIogmQchP8opvBy3Mi7Ce34nWjpBIwVTHfGYWQS9jwHDVRnpKKHJg7\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdn.jsdelivr.net/semantic-ui/2.2.10/semantic.min.js\"\n        integrity=\"sha256-97Q90i72uoJfYtVnO2lQcLjbjBySZjLHx50DYhCBuJo=\" crossorigin=\"anonymous\"></script>\n<script src=\"//unpkg.com/moment@2.14.1\"></script>\n<link href=\"//unpkg.com/video.js@6.0.1/dist/video-js.css\" rel=\"stylesheet\" />\n<script src=\"//unpkg.com/video.js@6.0.1/dist/video.js\"></script>\n<script src=\"/vendor/videojs-contrib-hls-5.5.1/videojs-contrib-hls.js\"></script>\n<script src=\"/vendor/videojs-dvrseekbar/videojs-dvrseekbar.js\"></script>\nI'm using a custom videojs-dvrseekbar.js to work around an issue, however I was experiencing the issue before using dvrseekbar. I've attached it videojs-dvrseekbar.js.txt\nHere's my modified version of videojs-contrib-hls 5.5.1 to work around this issue: \nvideojs-contrib-hls.js.txt\nMy movie HTML is very simple:\n<video id=\"main-movie\" class=\"video-js vjs-default-skin\" controls=\"controls\" preload=\"auto\" width=\"480\" height=\"270\">\n                <source src=\"playlist.m3u8\" type=\"application/x-mpegURL\"/>\n            </video>\nAnd I'm initialising videojs with:\n```\n    // Initialise the main movie\n    player = videojs('main-movie', {\n        startTime: desiredStartOffset,\n        controlBar: {\n            volumePanel: {\n                inline: false\n            }\n        }\n    });\n```\n. Ah, excellent @mjneil thanks! Hadn't thought about pts rollover.\nIn my use case recordings should all be ~20 hours long (my playlists in this case being so long is a result of using the system in test mode) so it shouldn't be an problem going forward.. ",
    "manishchauhanquovantis": "Getting error\nModule not found: Error: Cannot resolve 'file' or 'directory' /home/manish/Documents/OPENSOURCE/videoRecordingReact/cfg/node_modules/videojs-record/dist/videojs.record.js in /home/manish/Documents/OPENSOURCE/videoRecordingReact/src/components\n @ ./src/components/Main.js 15:25-55\nWEBPACK configuration\nresolve: {\n    extensions: ['', '.js', '.jsx'],\n    alias: {\n      actions:${defaultSettings.srcPath}/actions/,\n      components:${defaultSettings.srcPath}/components/,\n      sources:${defaultSettings.srcPath}/sources/,\n      stores:${defaultSettings.srcPath}/stores/,\n      styles:${defaultSettings.srcPath}/styles/,\n      config:${defaultSettings.srcPath}/config/+ process.env.REACT_WEBPACK_ENV,\n      'react/lib/ReactMount': 'react-dom/lib/ReactMount',\n      'videojs-contrib-hls': path.join(\n        __dirname,\n        'node_modules',\n        'videojs-record',\n        'dist',\n        // You can use the unminified version and let the minifier minify!\n        'videojs.record.js'\n      ),\n    }\n  },\n. ",
    "idealhack": "Sorry, I just realized the video format are not supported by Chrome.. ",
    "jmeintjes": "Hey everyone... Just curious to know whether there's a plan to have this in a release soon? #1304 is also asking for it. . ",
    "enzanki-ars": "Sorry that I did not realize that this pull request existed.  My searching failed me as I only searched for the technical term.  \nI have been thinking about this for a while now, and I think that video.js should add video tracks there first before here allowing people to use video tracks anywhere and not just with HLS streams.  Once that is added, that might allow this project to add video tracks in a more consistent manor.  . ",
    "jfrux": "I'm also building apps for Smart TV's and am experiencing these issues.\nThe rendering engine is Chromium 38.0.2125.122, WebKit v537.36.\nI have a copy of Chromium 38.0.2125.0 on my Mac and it won't play HLS content either.  But shows a different error.  Says something about corruption or network error on the TV, but on desktop it says No compatible source was found for this media..\nAfter trying your suggestion, getting maybe responses when running on the TV Device.\nThis may also be of interest to getting it working, although I don't think it's helping me any...:\nhttp://webostv.developer.lge.com/api/web-api/mediaoption-parameter/\nstreamURL: https://content.uplynk.com/29ffc4ce6d504cfd92c1d68ff4d7378b.m3u8 playlist-item.js:96\ncanPlayType: application/x-mpegURL: maybe webos.js:37\ncanPlayType: application/vnd.apple.mpegURL: maybe webos.js:38\ncanPlayType: audio/mpegurl: probably webos.js:39\nMediaPlayer: play player.js:92\nMediaPlayer: loadstart player.js:63\nVIDEOJS: ERROR: (CODE:3 MEDIA_ERR_DECODE) The media playback was aborted due to a corruption problem or because the media used features your browser did not support. MediaError {code: 3, message: \"The media playback was aborted due to a corruption\u2026media used features your browser did not support.\", status: null, MEDIA_ERR_CUSTOM: 0, MEDIA_ERR_ABORTED: 1\u2026}. Also having this issue, anyone know what to do?  I'm using videojs-contrib-hls 5.10.1.. ",
    "jayarjo": "They got their own player in Tizen to play HLS content: AVPlayer.. ",
    "poda5d2": "I forgot to write that this source works older version of videojs without videojs-contrib-hls with flash fallback. Does it mean anything? Thanks. Working example: development.terpola.hu/hls/older.html\nStarttemplate: development.terpola.hu/hls/starttemplate.html\nSorry for miss click to close and comment.. ",
    "d3im": "Please look at:\nAES one file XHR (glitches):\nhttp://testeria.xf.cz/5C.html\nAES separate files (OK):\nhttp://testeria.xf.cz/6C.html\nThanks :-). seems hls.js have this problems too. (This particular server doesn't serve right mimetypes)\nhttp://testeria.xf.cz/5C1.html\nhttp://testeria.xf.cz/6C1.html. Seems the problem is not in hls.js itself, but in tools writing ranges to .m3u8 file (Bento4, FFmpeg).. ",
    "cpeterso": "The http://testeria.xf.cz/5C1.html video does not play for me in Firefox 54, Chrome 60, or Edge on Windows 10. The http://testeria.xf.cz/5C.html video seems to play fine for me in Firefox 54.. ",
    "martinstender": "Thank you for your answer.\nI already posted an almost identical issue on contrib-ads, but I was kinda sent over here... :-)\nIf nothing else, this post might reach someone who is not on Slack and might have experienced something similar.\nBest regards \nMartin. ",
    "WaluTechnician": "Thank you for your prompt response, @gesinger \nI\"m afraid I'm still quite novice, I loaded the VideoJS and HLS contrib with CDN and I'm not having issues with Playback anymore. I feel a bit silly...\nI did run into something else though.\nwalukungfu.org/test3.html\nI'm trying to use \n        data-setup='{ \"playbackRates\": [0.5, 1, 2, 3] }'\nBut it's only working on desktop. When I open it with Android Chrome I'm not getting the speed option on the controls. Is this something I'll have to go to the VideoJS git about?\nThank you for any help you can offer.. Hello again, @gesinger \nI eliminated a few variables and wanted to come back to you about the playbackRate issue for a moment.\nI'm now running VJS 6.2.0 hosting it off my server, and still loading the HLS-contrib via CDN.\nThe playbackRate functions properly with MP4 sources on desktop and mobile, but when I try to use an M3U8 source it only works on Desktop. \nOn Android Chrome v58 I'll see the option appear, but it does nothing when I select a different rate. \nI've brought this up over at the main Video JS git as well after gkatsev helped me get the playRate option to appear by reminding me to update my browser. \nI thought I would mention it to you here instead of opening another issue, since MP4 sources are working I thought it might have something to do with the HLS-contrib.\nThank you for your time.. Oh, here:\nWalukungfu.org/test2.html. I'm afraid I'm still quite novice at coding.\nso my intitialization code will go from this:\n    <script>\n    var player = videojs('test');\n    </script>\n\nto this:\n    <script>\n    var player = videojs('test');\n    var options = {hls: {\n    overrideNative: true;\n    videojs.options.html5.nativeAudioTracks: false;\n    videojs.options.html5.nativeVideoTracks: false;\n    }};\n    </script>\n\nyes?\nThanks, I'll try it now..  Thank you for being so prompt with your response, @gesinger \nI tried the initialization options I asked about in my previous comment and I'm getting no change in behavior.\nwalukungfu.org/test2.html\nhere's my code:\n    `<video id=\"test\" class=\"video-js vjs-default-skin vjs-16-9\" data-setup='{ \"playbackRates\": [0.5, 1, 2, 4] }' poster=\"images/indexvidposter.png\" controls>\n<!--<source src=\"images/indexvid.mp4\" type=\"video/mp4\"/>-->\n<source src=\"images/indexvid/playlist.m3u8\" type=\"application/x-mpegURL\"/>\n\n            </video>\n            <script>\nvar player = videojs('test');\nvar options = {hls: {\nvideojs.options.hls.overrideNative = true;\nvideojs.options.html5.nativeAudioTracks = false;\nvideojs.options.html5.nativeVideoTracks = false;\n}};\n</script>`\n\nAm I doing this wrong?\ndoes it have anything to do with this:\nhttps://github.com/videojs/videojs-contrib-hls/issues/403\n?\nThanks for your help.. Hey, @gesinger\nSorry, that got reprioritized and I forgot about it. Thank you for reminding me. \nIll test it and let you know this evening so we can get to closing this.. @gesinger \nThat did it!\nThank you @gesinger and @mjneil for your help. \nIf you're ever in South Florida you've got a Kung Fu Class waiting for you.. ",
    "Esteban555": "Hi there! Thank you for the reply. Im running a streaming app and only have the option to input a URL to play the .m3u8 in my app, so with that info on the .m3u8 file, how would i open it by just the URL, not just for iphones but it was a way to bypass that security. Any ideas im all ears.. Thank you sir.\nAny ideas wich method wll be better for the procedure you suggest\nEl mar., 20 jun. 2017 a las 19:37, Garrett (notifications@github.com)\nescribi\u00f3:\n\nClosing. Please try modifying the server to allow the devices from which\nyou are trying to play back your content. Thank you.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/videojs/videojs-contrib-hls/issues/1158#issuecomment-309911655,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/Ab-5CMgYU7Od5BMKTKEcQSYd01pF-l4Tks5sGEnAgaJpZM4N2Np8\n.\n. \n",
    "maryam-abdullah": "I got two warnings today\n\nVIDEOJS: WARN: \"Problem encountered with the current HLS playlist. HLS request errored at URL: Switching to another playlist.\"\nVIDEOJS: WARN: \"Problem encountered with the current HLS playlist. HLS request errored at URL: Switching to another playlist.\"\n\n\nBoth don't exist in the network tab. How is that even possible?\n. I took the screenshot after the warning occured.\nAnd I'm using Chrome. . There's nothing else. And I'm actually suspecting that it's cause of the Internet connection. Cause it doesn't happen all the time.\nWhat do you suggest?. Is it possible to reproduce it? If so, please tell me how.\nOnce it occurs again, I will check the network tab to see the response.. I tried what you told me, but the warning message no longer appears.. ",
    "mohsinworld": "I face the same thing. The link is work on VLC media player but not work in the web player. what is the solution here? This is the link http://ipme.oncast.me:1935/forchannels/boishakhitv-org-forchanels.stream/playlist.m3u8. ",
    "coolicer": "Same problem in chrome simulator when use hls live stream.. ",
    "Tanyavdc": "Thanks for responding @mjneil \nIn the process of putting up a test link, the issue went away, which makes me suspect that it is a WOWZA streamlocking issue. Any idea why the WOWZA token would cause AV drift? . ",
    "sbalay": "I've found something a little strange.\nIf I took the code in the example page, and only add this:\n<script>\n    const a = videojs('my_video_1');\n  </script>\nThe example will still work, unless the chrome dev tools are open.\nIf the dev tools are closed, the example works. If the dev tools are open the following error will appear:\nVIDEOJS: ERROR: (CODE:4 MEDIA_ERR_SRC_NOT_SUPPORTED) The media could not be loaded, either because the server or network failed or because the format is not supported.\nEDIT:\nThat was caused because I was simulating a Nexus 5X with chrome dev tools. With the device simulator toggled off, or simulating an iPhone 6 the example works fine.. ",
    "jinagko": "I'd the same problems . ",
    "camille666": "me too.. ",
    "mister-ben": "You're missing CORS headers. iOS has native HLS support so does not need CORS headers.\nhttps://github.com/videojs/videojs-contrib-hls#hosting-considerations. On iOS the device native HLS playback is used rather than videojs-contrib-hls.\nmp4.csmil/master.m3u8 isn't a different format; it's regular HLS output from Akamai's re-packaging. iOS doesn't have a problem in general playing content from Akamai, this issue is most likely specific to the encoding of your particular video(s). . You're adding a video element but not initialising the player. Add videojs(video) after appending the video element to the doc. The data-setup attribute on a video element triggers automatic initialisation of video when they're present when the script executes / on document ready, but not for video elements added later on.. You need to enable CORS on the server. https://enable-cors.org/\niOS works because its native HLS playback does not make XHR requests. The player at hlsplayer.net is probably Flash-based as there's just a big empty box in my browser; Flash has a different mechanism to handle cross origin requests.. JSONP doesn't apply as you're not fetching JSON. You need to fix CORS by adding headers at the server. You cannot circumvent it on the client side.. That proxy is only adding CORS headers to the master playlist. The playlist contains absolute URLs to another server that does not use CORS headers. This is easily verifiable in the console, you'll see\nXMLHttpRequest cannot load http://23.248.182.28/121/33/98/letv-uts/14/ver_00_22-303050723-avc-1153420-\u2026tmcd=106&buss=5997&cips=65.122.49.226&source=vod&ver=live_3&ntm=1500153000. No 'Access-Control-Allow-Origin' header is present on the requested resource.. If it's a browser with native HLS support there would be no hls object. .\n",
    "treyhoover": "We're experiencing the same thing and were able to reproduce the issue in your demo on MS Edge 16.\nAny idea what the issue may be? I'd be happy to help track this down.. ",
    "mattbrundage": "I'm not sure what's happening. I do know that Edge supports these features natively, so perhaps there's some buggy feature-detection going on.. @squarebracket, based on my tests, the native HLS playback in Edge does support captions.\nAttached image: Edge handling captions in its native video player. (No JavaScript.) I'm almost certain that this HLS stream is using 608 over 708, rather than WebVTT.\n\n. ",
    "triwav": "In case nobody's tried it, I tried forcing Flash on Edge and that doesn't appear to be working either. The only solution I have currently is telling Edge users to use IE11 as captions do work correctly there if you force Flash. Might be worth noting this is for Webvtt captions. It's possible CEA608 captions would work correctly.. Thank you @squarebracket! I had a feeling that was what was going on. @mattbrundage comment made it seem like this feature was built in and was about to test that out when you replied. Really appreciate your help.. Gotcha. Are there any plans to change this? Like I said I can work around it but that sounds like it could be handled better. . ",
    "mlumbroso": "Hey @samueleastdev , what I can see in addition, I think some behaviors you describe might be due to cache (the fact it's working sometimes with 5.7.0 seems to be)\n5.7.0 : https://output.jsbin.com/hijexaz : when I first open without cache it never works. If I try after 5.5.0 which is working and loading the video, and then try to open back 5.7.0 then I can only get the sound (no video). If I do a hard refresh it stops working though, it must be related to the segments being cached when we open a working version => Please note this only happens for me on Chrome (Win 10), on Firefox it's constantly not working. \n5.6.0 https://output.jsbin.com/hijexaz/1 : same behaviour as 5.7.0\n5.5.0 https://output.jsbin.com/hijexaz/2 : working consistently. Hi,\nAnything we can do to help fix the issue ? \nThanks :). Hi,\nThanks for the fix.\nJust tested it here : https://jsbin.com/mexiyehepo/1/edit?html,output\nIt fixed the audio, but not the video that was working with 5.5.0 and then stopped working (see here : https://jsbin.com/mexiyehepo/2/edit?html,output )\nMaybe there is the same issue for video codecs as per audio codecs ?\n. Sorry, forgot to update you about this. \nThanks a lot for the investigation, thought the 2 issues were related in the first place, hence my question. This is actually a bug in Amazon Elastic Transcoder on their 600k preset with setting baseline, I've reported it to them. Thanks for your help and keep up the great work here :). Hi,\nyou have to get the video element inside, since that's how video.js transforms it :\nvar video=document.querySelector('#videoPlayer video');\nYou should be fine with this :). ",
    "bklava": "Ooops, my bad. Fixed. Can you try it again?. Yep, that solved our issue. Thanks @mjneil for the quick feedback ;). ",
    "cppbitman": "It works. Thanks a lot.. ",
    "h94": "Video.js: ^6.2.0\nvideojs-contrib-hls: ^5.7.0\nhttp://jsbin.com/lejevodecu/edit?html,output. In webpack inside?. Have the same problem. ",
    "harispp": "Thanks for the replay, I resolved the issue by initializing the player like,\n```\n        parent.appendChild(video);\n        var player = videojs(video);\n\n```\n                   . ",
    "AleksanderSadov": "Hello, @gesinger \nSame problem also exists on Windows 10 and Chrome 59.0.3071.115 and not only on Ubuntu 16.04.2 LTS. We have not tested it on Mac.\nHere are the logs from chrome://media-internals after player crushes:\nPlayer Properties:\nrender_id: 128\nplayer_id: 175\npipeline_state: kStopped\nevent: PAUSE\nurl: blob:http://192.168.0.227/1c9cf24b-2352-4120-a7e5-4e5f2027c496\nduration: 217.227387\nfound_video_stream: true\nvideo_codec_name: h264\ndebug: FFmpegVideoDecoder: avcodec_decode_video2(): Invalid data found when processing input, at timestamp: 19203533 duration: 0 size: 45 side_data_size: 0 is_key_frame: 0 encrypted: 0 discard_padding (ms): (0, 0)\nfound_audio_stream: true\naudio_codec_name: aac\nseek_target: 18.802965\naudio_dds: false\naudio_decoder: FFmpegAudioDecoder\nvideo_dds: false\nvideo_decoder: FFmpegVideoDecoder\nvideo_buffering_state: BUFFERING_HAVE_ENOUGH\nheight: 480\nwidth: 640\naudio_buffering_state: BUFFERING_HAVE_ENOUGH\npipeline_buffering_state: BUFFERING_HAVE_ENOUGH\nerror: video decode error\npipeline_error: PIPELINE_ERROR_DECODE\nLog:\n00:00:00 00 | pipeline_state | kCreated\n-- | -- | --\n00:00:00 00 | event | WEBMEDIAPLAYER_CREATED\n00:00:00 00 | url | blob:http://192.168.0.227/1c9cf24b-2352-4120-a7e5-4e5f2027c496\n00:00:00 00 | pipeline_state | kStarting\n00:00:00 480 | duration | 18.802965\n00:00:05 532 | found_video_stream | true\n00:00:05 533 | video_codec_name | h264\n00:00:05 533 | debug | Detected an append sequence with keyframe following a non-keyframe, both with the same decode timestamp of 9.60877\n00:00:05 534 | found_audio_stream | true\n00:00:05 534 | audio_codec_name | aac\n00:00:05 536 | debug | Detected an append sequence with keyframe following a non-keyframe, both with the same decode timestamp of 10.0077\n00:00:05 536 | debug | Detected an append sequence with keyframe following a non-keyframe, both with the same decode timestamp of 10.4075\n00:00:05 538 | debug | Detected an append sequence with keyframe following a non-keyframe, both with the same decode timestamp of 10.8074\n00:00:05 538 | debug | Detected an append sequence with keyframe following a non-keyframe, both with the same decode timestamp of 11.2069\n00:00:05 538 | seek_target | 18.802965\n00:00:05 539 | debug | Detected an append sequence with keyframe following a non-keyframe, both with the same decode timestamp of 11.6059\n00:00:05 539 | debug | Detected an append sequence with keyframe following a non-keyframe, both with the same decode timestamp of 12.0048\n00:00:05 539 | debug | Detected an append sequence with keyframe following a non-keyframe, both with the same decode timestamp of 12.4041\n00:00:05 546 | debug | Detected an append sequence with keyframe following a non-keyframe, both with the same decode timestamp of 12.8036\n00:00:05 546 | debug | Detected an append sequence with keyframe following a non-keyframe, both with the same decode timestamp of 13.2032\n00:00:05 546 | debug | Detected an append sequence with keyframe following a non-keyframe, both with the same decode timestamp of 13.603\n00:00:05 547 | debug | Detected an append sequence with keyframe following a non-keyframe, both with the same decode timestamp of 14.0031\n00:00:05 548 | debug | Detected an append sequence with keyframe following a non-keyframe, both with the same decode timestamp of 14.4028\n00:00:05 548 | debug | Detected an append sequence with keyframe following a non-keyframe, both with the same decode timestamp of 14.8022\n00:00:05 549 | debug | Detected an append sequence with keyframe following a non-keyframe, both with the same decode timestamp of 15.2019\n00:00:05 549 | debug | Detected an append sequence with keyframe following a non-keyframe, both with the same decode timestamp of 15.6017\n00:00:05 550 | audio_dds | false\n00:00:05 550 | audio_decoder | FFmpegAudioDecoder\n00:00:05 557 | debug | Detected an append sequence with keyframe following a non-keyframe, both with the same decode timestamp of 16.0015\n00:00:05 557 | debug | Detected an append sequence with keyframe following a non-keyframe, both with the same decode timestamp of 16.4019\n00:00:05 557 | debug | Detected an append sequence with keyframe following a non-keyframe, both with the same decode timestamp of 16.8028\n00:00:05 558 | debug | (Log limit reached. Further similar entries may be suppressed): Detected an append sequence with keyframe following a non-keyframe, both with the same decode timestamp of 17.2031\n00:00:05 558 | debug | Video rendering in low delay mode.\n00:00:05 559 | video_dds | false\n00:00:05 559 | video_decoder | FFmpegVideoDecoder\n00:00:05 559 | pipeline_state | kPlaying\n00:00:05 560 | pipeline_state | kSeeking\n00:00:06 387 | pipeline_state | kPlaying\n00:00:06 388 | debug | Audio buffer splice at PTS=18824671us. Trimmed tail of overlapped buffer (PTS=18813628us) by 12176us.\n00:00:06 397 | video_buffering_state | BUFFERING_HAVE_ENOUGH\n00:00:06 400 | height | 480\n00:00:06 400 | width | 640\n00:00:06 416 | audio_buffering_state | BUFFERING_HAVE_ENOUGH\n00:00:06 426 | pipeline_buffering_state | BUFFERING_HAVE_ENOUGH\n00:00:06 428 | event | PLAY\n00:00:06 389 | duration | 28.321631\n00:00:06 544 | video_buffering_state | BUFFERING_HAVE_NOTHING\n00:00:06 549 | video_buffering_state | BUFFERING_HAVE_ENOUGH\n00:00:06 781 | debug | FFmpegVideoDecoder: avcodec_decode_video2(): Invalid data found when processing input, at timestamp: 19203533 duration: 0 size: 45 side_data_size: 0 is_key_frame: 0 encrypted: 0 discard_padding (ms): (0, 0)\n00:00:06 781 | error | video decode error\n00:00:06 822 | pipeline_error | PIPELINE_ERROR_DECODE\n00:00:06 826 | pipeline_state | kStopping\n00:00:06 828 | pipeline_state | kStopped\n00:00:06 828 | event | PAUSE\n00:00:21 236 | duration | 37.726459\n00:00:32 233 | duration | 46.939933\n00:00:43 231 | duration | 56.724885\n00:00:54 226 | duration | 66.721438\n00:01:05 225 | duration | 87.12149\n00:01:16 228 | duration | 96.962376\n00:01:27 229 | duration | 107.298085\n00:01:37 841 | duration | 117.446685\n00:01:48 231 | duration | 127.439058\n00:01:59 229 | duration | 137.65772\n00:02:10 230 | duration | 147.440426\n00:02:21 229 | duration | 157.292045\n00:02:32 228 | duration | 177.199272\n00:02:43 231 | duration | 187.354078\n00:02:54 256 | duration | 197.089029\n00:03:04 530 | duration | 207.005814\n00:03:15 226 | duration | 217.227387\n00:03:26 227 | duration | 227.3993\n00:03:37 228 | duration | 247.193959\n00:03:48 229 | duration | 257.396235\n00:03:59 223 | duration | 267.196155\n00:04:10 223 | duration | 277.179558\n00:04:21 222 | duration | 287.245454\n00:04:32 220 | duration | 297.077026\n00:04:43 223 | duration | 317.484342\n00:04:54 227 | duration | 327.250348\n00:05:05 222 | duration | 337.07459\n00:05:16 225 | duration | 347.289027\n. ",
    "ahmadawada11": "i have the same problem any solution?. HI, \ni modified the code in http://jsbin.com/futexiboci/1/edit?html,js,output\nthanks in advance.\n. Hi the above solution worked on edge.\nalso after i changed my code to set the player src using code not in video tag the list now appear on chrome on android mobile also.. the changes solved the issue did this fix included in v5.11.1?\n. yes  the issue that when providing an HLS and DASH source, HLS is not supported, and flash is NOT installed, the player fails with the HLS source and does not ever try the DASH\nin the console i see this error\nInvalidStateError: An attempt was made to use an object that is not, or is no longer, usable in contrib-hls\n. ",
    "lexandr": "The same problem.  \nWindows 10, Chrome 60.0.3112.113 \nLive stream - http://link11.cam2site.com:8080/cam/amlst:arena-mo/playlist.m3u8\nPlayer properties\nProperty | Value\n-- | --\ndebug | FFmpegVideoDecoder: avcodec_decode_video2(): Invalid data found when processing input, at timestamp: 80000 duration: 0 size: 18 side_data_size: 0 is_key_frame: 0 encrypted: 0 discard_padding (ms): (0, 0)\nduration | 879.799999\nerror | video decode error\nfound_video_stream | true\norigin_url | http://localhost/\npipeline_error | PIPELINE_ERROR_DECODE\npipeline_state | kStopped\nplayer_id | 205\nrender_id | 279\nurl | blob:http://localhost/39fcc624-ac81-48f5-9f80-ac418058459b\nvideo_codec_name | h264\nvideo_dds | false\nvideo_decoder | FFmpegVideoDecoder\nLog\nTimestamp | Property | Value\n-- | -- | --\n00:00:00 00 | pipeline_state | kCreated\n00:00:00 00 | origin_url | http://localhost/\n00:00:00 00 | url | blob:http://localhost/39fcc624-ac81-48f5-9f80-ac418058459b\n00:00:00 00 | pipeline_state | kStarting\n00:00:00 253 | duration | 0.000001\n00:00:01 619 | found_video_stream | true\n00:00:01 619 | video_codec_name | h264\n00:00:01 619 | debug | Video rendering in low delay mode.\n00:00:01 622 | video_dds | false\n00:00:01 622 | video_decoder | GpuVideoDecoder\n00:00:01 622 | pipeline_state | kPlaying\n00:00:01 637 | video_dds | false\n00:00:01 637 | video_decoder | FFmpegVideoDecoder\n00:00:01 645 | debug | FFmpegVideoDecoder: avcodec_decode_video2(): Invalid data found when processing input, at timestamp: 80000 duration: 0 size: 18 side_data_size: 0 is_key_frame: 0 encrypted: 0 discard_padding (ms): (0, 0)\n00:00:01 645 | error | video decode error\n00:00:01 646 | pipeline_error | PIPELINE_ERROR_DECODE\n00:00:01 646 | pipeline_state | kStopping\n00:00:01 646 | pipeline_state | kStopped\n00:00:01 619 | duration | 0.6\n00:00:11 418 | duration | 10.799999\n00:00:22 625 | duration | 21.799999\n00:00:33 798 | duration | 32.799999\n00:00:45 72 | duration | 43.799999\n00:00:56 254 | duration | 65.799999\n00:01:07 448 | duration | 76.799999\n00:01:18 750 | duration | 87.799999\n00:01:29 957 | duration | 98.799999\n00:01:41 149 | duration | 109.799999\n00:01:52 360 | duration | 120.799999\n00:02:03 595 | duration | 131.799999\n00:02:14 798 | duration | 142.799999\n00:02:26 117 | duration | 164.799999\n00:02:37 995 | duration | 175.799999\n00:02:49 145 | duration | 186.799999\n00:03:00 715 | duration | 197.799999\n00:03:11 860 | duration | 208.799999\n00:03:23 94 | duration | 219.799999\n00:03:34 277 | duration | 230.799999\n00:03:45 463 | duration | 252.799999\n00:03:56 699 | duration | 263.799999\n00:04:07 918 | duration | 274.799999\n00:04:19 189 | duration | 285.799999\n00:04:30 789 | duration | 296.799999\n00:04:42 66 | duration | 307.799999\n00:04:53 253 | duration | 318.799999\n00:05:04 448 | duration | 329.799999\n00:05:15 635 | duration | 351.799999\n00:05:26 823 | duration | 362.799999\n00:05:38 17 | duration | 373.799999\n00:05:49 246 | duration | 384.799999\n00:06:00 490 | duration | 395.799999\n00:06:11 669 | duration | 406.799999\n00:06:23 98 | duration | 417.799999\n00:06:34 317 | duration | 428.799999\n00:06:45 498 | duration | 450.799999\n00:06:56 723 | duration | 461.799999\n00:07:07 923 | duration | 472.799999\n00:07:19 97 | duration | 483.799999\n00:07:30 326 | duration | 494.799999\n00:07:41 517 | duration | 505.799999\n00:07:52 715 | duration | 516.799999\n00:08:03 972 | duration | 527.799999\n00:08:15 151 | duration | 549.799999\n00:08:26 323 | duration | 560.799999\n00:08:37 508 | duration | 571.799999\n00:08:48 689 | duration | 582.799999\n00:08:59 878 | duration | 593.799999\n00:09:11 237 | duration | 604.799999\n00:09:22 582 | duration | 615.799999\n00:09:33 771 | duration | 626.799999\n00:09:44 953 | duration | 637.799999\n00:09:56 160 | duration | 659.799999\n00:10:07 350 | duration | 670.799999\n00:10:18 582 | duration | 681.799999\n00:10:29 885 | duration | 692.799999\n00:10:41 74 | duration | 703.799999\n00:10:52 311 | duration | 714.799999\n00:11:03 493 | duration | 725.799999\n00:11:14 676 | duration | 736.799999\n00:11:25 860 | duration | 758.799999\n00:11:37 33 | duration | 769.799999\n00:11:48 223 | duration | 780.799999\n00:11:59 399 | duration | 791.799999\n00:12:10 614 | duration | 802.799999\n00:12:21 853 | duration | 813.799999\n00:12:33 306 | duration | 824.799999\n00:12:44 489 | duration | 835.799999\n00:12:55 671 | duration | 857.799999\n00:13:06 848 | duration | 868.799999\n00:13:18 239 | duration | 879.799999\n00:13:29 423 | duration | 890.799999\n00:13:40 659 | duration | 901.799999\n00:13:51 866 | duration | 912.799999\n00:14:03 119 | duration | 923.799999\n00:14:14 297 | duration | 934.799999\n00:14:25 486 | duration | 956.799999\n00:14:36 694 | duration | 967.799999\n00:14:47 891 | duration | 978.799999\n00:14:59 88 | duration | 989.799999\n00:15:10 263 | duration | 1000.799999\n. ",
    "savokiss": "Same problem, any clue ?. Also having the same issue, use chrome on win10...... ",
    "anton-asnitsky": "Hi there. \nI have pretty same issue.\nPage with problematic video stream:\nhttps://vod.walla.co.il/movie/2827433\nError message I've got:\nVIDEOJS: ERROR: (CODE:3 MEDIA_ERR_DECODE) The media playback was aborted due to a corruption problem or because the media used features your browser did not support. MediaError\u00a0{code: 3, message: \"The media playback was aborted due to a corruption\u2026media used features your browser did not support.\"}\nVideoJs version: 6.8.0\nvideojs-contrib-hls version: 5.14.1\nDo anyone have some advice what to do?. ",
    "shotap": "+1. ",
    "canhnm": "+1. ",
    "arslanyunus": "+1. ",
    "SuYuWei": "+1. same issue. ",
    "srkidd": "Im am also having this issue with just Chrome. Is there a recommended solution?. ",
    "beautylix": "There is not CORS error, CORS error has different error output.\nCurrent player can only read URL like http:/domain.com/a/b/c.m3u8, but cannot read stream from URL like http://domain.com/index?id=3&extent=m3u8&token=123. Is there any code available to overcome CORS or crossdomain obstruct? jsonp or other methods?. The CORS question has been resolved, and data stream look well, but there is still no video and audio.\nTest URL\nhttps://crossorigin.me/http://live.gslb.letv.com/gslb?stream_id=lb_mv_1300&tag=live&ext=m3u8&sign=live_tv&platid=10&splatid=1009&format=letv&expect=1\nHow to fix it?. It is not caused by videojs, but windows XP.. ",
    "m2008m1033m": "@mjneil What if I wanted to have different headers for different player instances? A global beforeRequest function will force me to have the same header for all players, which is not always the case.. ",
    "Okapist": "Yes. \nI'm using VideoJS-HLS from demo page.\nBrowser: Firefox 54.0.1 64 bit\nOS: Windows 10\nMake test page is difficult. It's live video from camera with streaming video server made by me (video server based on this project). I may attach init.mp4 and some fmp4 parts if needed.\n. ",
    "jiahaikun": "videojs-contrib-hls.js:2190 Uncaught TypeError: Cannot read property 'requestTime' of null\n    at getProgressStats (videojs-contrib-hls.js:2190)\n    at MockXMLHttpRequest. (videojs-contrib-hls.js:2447)\n    at MockXMLHttpRequest.dispatchEvent (mock.js:8468)\n    at XMLHttpRequest.handle (mock.js:8300). ",
    "ChoOo7": "Thanks  !\nIn vlc no issue, but definitivly the issue seems to be on source !. ",
    "shinefour": "Thanks for the feedback.\nI've moved the subtitle file to the same domain. The origin error does not appear anymore.\nI don't see any errors en chrome anymore, but the problem persists.. Hey, thanks for getting back.\nI'm not sure what you're referring to. The .vtt is in no way connected to or included in the .m3u8 file.\nThe m3u8 by itself works fine (as shown in the example) and the vtt file works fine with an mp4.\nJust in combination not.. Ah, but that can't be the solution, right? I'm not generating that m3u8 file and adding html5 tracks is something the videojs clearly supports as seen in the other examples. sorry for insisting.\nI've already tried debugging this on my own, but since it's all event driven the trace-stack is not really conclusive.. No worries, I get what you're saying.\nlet's see if someone else can help. not sure how they review these things here. would really appreciate any help. can the \"needs info\" label be deleted as to not confuse people? I think all info has been provided, right?. @gesinger \nHey Garret, I wanted to check if you have an idea about solving this problem. is there anything that I can do to help?. ",
    "hazarartuner": "I'm getting same issue too. I noticed that in \"videojs-contrib-hls's\" sample, track files look like embedded in the .m3u8 file. It works fine but I use tracks as external files and do not want to embed it to m3u8 file. I think the problem occurs from this situation.. @shinefour I'm sorry I said wrong. When I say your sample, I mean \"videojs-contrib-hls's\" own sample: http://videojs.github.io/videojs-contrib-hls/ :). Yes I aggree with you. This can't be the solution. Actually I wished to notify one of the contributors in this repo :D Maybe it would help them for where they should look for :D Btw, english is not my mother language,  I'm so sorry If I make confusing sentences :D . Yes I agree with you. @gesinger what do you think, do you need any additional info? . @gesinger @shinefour I wasn't looking for this issue for a long time, this week I had to check it again and found the problem for my situation. I think there is no bug, subtitles do not come because safari behaves strict on cross origin errors and blocks text tracks. I noticed that in my app I recieve cors errors, after I fix it, subtitles begin to work :D Hope it'd be helpfull :) . ",
    "champion97": "+1\n<script src=\"https://unpkg.com/video.js/dist/video.js\"></script>\n <script src=\"https://unpkg.com/videojs-contrib-hls/dist/videojs-contrib-hls.js\"></script>. ",
    "SzHeJason": "platform : MAC\nbrowser : Chrome and firefox (ps : Safari is normal )\nDemo\n\n. ",
    "CatchLife": "+1\nwe use ffmpeg to split the videos\uff0cis this reason\uff1f\nffmpeg -i \"G:/videos/MV/my.mp4\" -vcodec libx264 -acodec aac -f hls -hls_list_size 0 \"G:/videos/MV/hls-no-aes/my.m3u8\". i want this too. ",
    "roweldeguzman": "hi @gesinger ,\nseems this error only occur when in live broadcasting. VOD has no error showing.. Hi @gesinger ,\nhere is jsbin http://jsbin.com/viwoga/edit?html,output to show the error in console. for Live just wait a few seconds after you play the video.. ",
    "rahulsingh9096806080": "@mjneil..i am having single hls video. from that i want to extract the chunks which we can see in network tab of devloper tool.can you help me out . @mjneil can you give youe email id show that i can contact you.code snippet is as follows\n'onVideoPlay': function (scope) {\n      scope.player.on('play', function (e) {\n        var textTracks = scope.player.textTracks();\n        console.log(textTracks) ;// its working upto here.\n          textTracks.on('addtrack', function (event) {\n          var track = event.track;\n          if (track.label === 'segment-metadata') {\n            track.on('cuechange', function () {\n              var activeCues = track.activeCues;\n              for (var i = 0; i < activeCues.length; i++) {\n                console.log(activeCues[i].value);\n              }\n            });\n          }\n        });\n}.  if (textTracks[i].label === 'segment-metadata')\n\nhere it is the issue. always false. Hi,\non mobile devices i am not gettig details... can you make changes for that...in the demo\n. ",
    "OshinKaramian": "I do think so as I kind of started doing that then pulled back. I was trying to go with a softer touch on this PR (also it's unclear if this will end up getting folded into the greater project).  I think doing that in a separate PR might make the most sense.. @mjneil I opened up https://github.com/videojs/videojs-contrib-hls/pull/1217 in response to your comment about moving some more generic things out of master-playlist-controller.. Whoops, I didn't realize that that's how tests were run (I assumed it was picking out anything with Qunit in the test folder and running it).  Should be resolved on the latest commit.. Closing this, as it will cause conflicts when moving to videojs/http-streaming.  Refactor PRs should probably go in there as this project is deprecated in favor of videojs/http-streaming.. Reference: https://github.com/videojs/http-streaming/pull/17 for similar changes.. Might make sense to put this magic number into a const somewhere.. This is a big test... it might make sense (if possible) to break it down into a few smaller tests.  Tiny tests make debugging and finding issues a little bit easier.. If you export the const you might be able to reference it here.. There is some duplication of this function in the test suite.  You could:\n1.Take currentTime in as a variable into the function and use that for testing OR\n2. Take currentTime in and set it to a default value, then change it/set it in the test.\nThis would also let you write a couple of tiny unit tests to check the internal logic of this function if you wanted to.\nYou could probably do the same for bufferLowWaterLine if you wanted to test it similarly.. Given that I am a big n00b it would be nice to have this function commented, at the moment I'm guessing it selects the proper rendition based on the criteria that's passed in.. This seems to be sorting and then filtering it, is there any reason not to sort the final output from whatever filters you've applied?. Anyway to break this almost 100 line function down into a couple of smaller functions?  \nMaybe some of the \"ifs\" could be moved elsewhere? Or some of the logic in the sort functions?. Could just move this condition up into the if statement above.. Could do something like let { segments = [] } = playlist;. I would also add that you could shove the property string 'MAX_GOAL_BUFFER_LENGTH' into a variable somewhere.\nIf these functions are all similar enough you could probably dump them all in an array and run through it to define these objects.. Would be neat to store these constants in a couple of variables.. This is the function I mentioned before that you may be able to avoid duplicating here.. If the order of each test here is unimportant (one test doesn't rely on another) you could break it up into a few smaller/more specific tests.  It might make it easier to debug if one specific case fails but the rest work.. Ah, makes sense.. Gotcha, that makes sense.. \ud83d\ude0e . This function doesn't seem to be reliant on being here (there are a few other functions here that could be moved as well).  I shifted this into a util module as I wanted to use this to check whether a playlist contained video or not in the playlist selection algorithm below.. Made an assumption here that may or may not be true, where the playlist are sorted by bitrate.  If that's not true I can add a sort in here.. Good catch, I reworked things a bit (I set the selection in the master-playlist-controller) and must have mucked that up.. Kind of a nitpick, by why let and not const?  If statement is the scope and the value doesn't seem to change.. Just a note here.\nOne of the tests was breaking on this (https://github.com/videojs/videojs-contrib-hls/blob/fast-start-time/test/videojs-contrib-hls.test.js#L1221) (I didn't have the temp variable, and instead set this.initialMedia_ twice, once in each if block).\nOnce I set things to the temporary variable the problem resolved itself.  I'm assuming there are side effects off of setting this.initialMedia_... I didn't really dig deep enough to understand what was going on.  It seems a little dangerous to have side effects off of setting a variable (when the setter isn't explicitly a function) if this is the case.. We discussed that we were going to use the desktop bandwidth number everywhere, so this test had to be updated to account for that (I figured I would update over removing).. If possible I'd like to avoid coupling this function to a separate algorithm, and allow the consumer to decide the alternative.  I think long term adding the complexity here over elsewhere will be a bit confusing, as well as making unit testing and changes harder/more complex. . That loop seems like a code smell to me, though I can't think of a better way to deal with it in the current context.\nI believe I handled the other scenario in your comment below with the latest commit.  I'll look at this one as well.. Good catch, I believe the latest commit should deal with that scenario.. This test looks like a bit of a bear.  It might be helpful to do one of a few things to make things clearer to future explorers:\n\nFind a way to break this test up into a few smaller tests... maybe evaluate each stage as its own test.  I don't know if qunit lets your group things as you can in mocha with describe blocks, but you could have something like:\n\n```\ndescribe('caching', () => {\n  describe('does not get stuck in a loop due to inconsistent network/caching' () => {\n    before(() => { // bootstrap data these tests use });\n    function setUpStep1() => { ... };\n    function setUpStep2() => { ... };\nit('tests the first step', () => {\n setupStep1();\n assert(x,y, 'output of step 1 looks good!');\n});\n\nit ('tests second step', () => {\n     setupStep1();\n     setupStep2();\n     assert(x,y, 'output of step 2 looks good!');\n   });\n  })\n})\n```\nThis might yield more code, but the tests themselves might end up looking a bit clearer, since each is testing a distinct scenario with regards to your use case.  It might make debugging a bit easier (instead of the caching test as a whole breaking on an assert that you need to dig through, the test that broke should give you the information that you need to debug a little bit faster).\nThere is a library that could work (there could be others), I don't know if we want to introduce it here: https://github.com/square/qunit-bdd\n\n\nIf you don't want to do that, maybe adding a comment block on this test that describes what's going on would be useful.  Looking at this test I'm aware that there is some kind of loop that is caused by caching, but the use case is hard to tell without reading through the entire test.  If someone introduces something that breaks this test it might be difficult to debug whether something is supposed to break based on the change, or if their change broke functionality that we need to preserve.\n\n\nMaybe find a way to break some things up into separate files.  The path of having a test per file seems to have kind of outgrown its usefulness here.  We could break the per-file tests into folders, then have test files for various scenarios (or something).  Basically breaking this part of the file into something like test/master-playlist-controller/caching.test.js.. Why is this set here, and not where hasPlayed_ is set?  You could move this into the loadedmetadata function above, and set it on line 733 as well.  \n\n\nI'm mostly suggesting this because I think it will be easier from a maintenance standpoint.. The most nitpicky of comments: this should probably be a const.. If not for the UNSAFE_LIVE_SEGMENTS piece above, I think you could do:\nPlaylist = {\n  duration,\n  seekable,\n  safeLiveIndex,\n  etc...\n};\nWhich would be cleaner.. It's slightly unclear what's going on here.  It might make sense to make this wordier so that the test is a bit quicker to understand.  I'm guessing something like playlists.segments[0].duration + segments[1].duration....  I'm also guessing the 9 is the total sum of the duration.  Either that or a comment to highlight what these numbers are would be helpful.. Also I can't comment on code you haven't touched :) But it might be wise to change the let playlist to a const playlist unless you're expecting the functions it's passed into to reassign it in some way.. It might be wise to break this up into 3 tests; \nsafe live point for standard durations, correct media index for variable durations, no safe live point.  \nThis will make it easier to debug (it's very clear which test is failing), and I believe that the following assertions  won't get hit if one assertion fails.  As an example, if standard durations fails, but variable segments passes that is useful debug information (or if both fail).  I think that gets lost with this though.. I think keeping the tests kind of small/specific will make maintenance longer term a bit simpler.  Particularly if another case gets tacked on here.. Might hit a merge conflict due to: https://github.com/videojs/videojs-contrib-hls/pull/1271.. Could we maybe break this test up in some way?  Maybe one for if playerlist.disabled is set to true? Or maybe based on the expectation (should be enabled vs should not be enabled)?\nIt also might be safer to not maintain the const playlist here and instead pass the raw values for playlist in.  As an example:\nplaylist.excludeUntil = Date.now() - 1;\nassert.ok(Playlist.isEnabled(playlist), 'playlist is enabled');\nJust becomes:\nassert.ok(Playlist.isEnabled({ excludeUntil: Date.now() - 1 }), 'playlist is enabled');\nThis way you don't need to worry about deleting things and the order of the tests won't matter.\n. Similar to my comment below, you could just get rid of const playlist and pass the raw values into the method under test.. Might need something like \"Unless segment length does not exist, in which case returns 0.\". I'm not super familiar with this... why not just change the value of TIME_FUDGE_FACTOR instead of making this a hard coded value?  Is TIME_FUDGE_FACTOR using in a bunch of spots?  \nMight also be good to comment on why 0.1 seconds for future explorers.. Nit: Is there any reason this can't be a const?. ",
    "SleepWalker": "@arendjr, @dmlap, @rgc can you take look and check if everything is ok?\nI've checked this code on production, where I was faced with redirects in playlists. Everything is works fine after this PR applied, but, probably, I've missed something important.... @BrandonOCasey do I continue resolving conflicts, or you are not interested in this feature?. @mjneil looks, like you are the most active. Can you look at this PR, please?. @gesinger I've merged with current master branch and added an option followRedirects to enable redirect support. I'm agree with everything. I'm on vacation till Sunday. I'll push the fixes, when I'll be at home.. @gesinger looks like everything is ok now. Hi @gesinger, it is stuck again. @gesinger can you please view this PR?. did you mean this comment?\n\n// if the playlist returns a 302 redirect for manifest, ...\n\nor which comment from above?. Oh, sorry, that was a typo :). ok. My concern was, that enumeration of all options is more explicit. updated the both files. ",
    "generhim": "Interesting, thanks MJ. So if we switch to hlsv3 and maintain transmuxed mpeg2ts it should work? \nThanks\n. ",
    "ebraan": "Hello,\nI am facing the same problem as described here. I have noted the only solution is to move to maximum hls V4. Unfortunately my packager (Shaka-packager)  seems to format HLS ouput only in V6. \nDoes someone find a turn around to play hls V6 when flash fallback is used (Win 7 IE 11 playback)?\nMany thanks \nRegards\nEric. ",
    "RecherJ": "the same as you @manuliner  :(. @GitZy1821411611 I have been changed for using hls.js.. ",
    "GitZy1821411611": "hey\uff0cfriend\uff0cHas the problem been solved?. @manuliner  thanks very much\n. ",
    "manuliner": "yes i did\n```\n\n\n\n\n\n\n\n  import { videoPlayer } from 'vue-video-player'\n\n  require('video.js/dist/video-js.css')\n  require('vue-video-player/src/custom-theme.css')\n  require('videojs-contrib-hls/dist/videojs-contrib-hls')\n\n  export default {\n    components: {\n      videoPlayer\n    },\n    data () {\n      return {}\n    },\n    methods: {\n      onPlayerPlay (player) {\n        // console.log('player play!', player)\n      },\n      onPlayerPause (player) {\n        // console.log('player pause!', player)\n      },\n      playerStateChanged (playerCurrentState) {\n        log.debug('player current update state', playerCurrentState)\n      },\n      playerReadied (player) {\n        this.player = player\n        if (this.player.readyState() < 1) {\n          this.player.one('loadedmetadata', function () {\n            let hls = player.tech({IWillNotUseThisInPlugins: true}).hls\n        })\n      }\n    }\n  }\n\n```\nand this are my player options\nplayerOptions: {\n        muted: false,\n        controls: false,\n        controlBar: false,\n        language: 'en',\n        fluid: true,\n        preload: 'auto',\n        playbackRates: [0.7, 1.0, 1.5, 2.0],\n        sources: [ {\n            src: 'pathTom3u8',\n            type: 'application/x-mpegURL'\n        }],\n        flash: {\n          hls: {\n            withCredentials: false\n          }\n        },\n        html5: {\n          hls: {\n            withCredentials: false\n          }\n        }\n}\n. @jonasgroendahl \nplease check my comment above.  There i posted my code which solved that issue for me . ",
    "jonasgroendahl": "I'm also having trouble getting this to work with VueJS using webpack. What did you exactly @manuliner to get it working?\nIt will work if I put the cdn of .js files in the html index file but will stop working when i leave the page and go back so I have to get the setup right with webpack.\nCode:\n```\nimport videojs from 'video.js'\nimport *  as HLS from 'videojs-contrib-hls'\n```\nerror:\nindex.js?f68e:10 Uncaught TypeError: Cannot convert undefined or null to object\n    at Function.keys ()\n    at module.exports (index.js?f68e:10)\n    at new MasterPlaylistController (master-playlist-controller.js?b41a:314)\n    at HlsHandler.src (videojs-contrib-hls.js?260d:335)\n    at Object.handleSource (videojs-contrib-hls.js?260d:623)\n    at Html5.Tech.setSource (video.cjs.js?0e26:9000)\n    at new Html5 (video.cjs.js?0e26:16502)\n    at Player.loadTech (video.cjs.js?0e26:19215)\n    at Player.src_ (video.cjs.js?0e26:20828)\n    at eval (video.cjs.js?0e26:20775). ",
    "ddereszewski": "Take a look at solution provided by @lionxcr. It helped me \nhttps://github.com/videojs/videojs-contrib-hls/issues/600#issuecomment-273289790\n. ",
    "Jayant-Purohit": "@manuliner is it working in production too? \n- I'm using \".m3u8\" it works fine in dev mode but it throws an error in production \nerror in production :\n video.cjs.js:450 VIDEOJS: ERROR: (CODE:4 MEDIA_ERR_SRC_NOT_SUPPORTED) No compatible source was found for this media. lt\u00a0{code: 4, message: \"No compatible source was found for this media.\noptions for the player it looks like this : \nplayerOptions: {\n              height: '360',\n            //  autoplay: true,\n            //  muted: true,\n            //  language: 'en',\n            //  playbackRates: [0.7, 1.0, 1.5, 2.0],\n              sources: [{\n                type: \"application/x-mpegURL\",\n                src: \"\",\n              }],\n              controlBar:{\n                timeDivider: false,\n                durationDisplay: false\n              },\n              html5: {hls:{withCredentials: false},\n              hlsjsConfig: {\n                debug: true\n              },\n              },\n              poster:''\n            },. ",
    "denisvlr": "So it looks like the bug doesn't appear anymore on Chrome 60.\nI guess it was a browser bug, we can close until someone manages to reproduce.. ",
    "jeffmikels": "I've given up on WebView video and HLS. I am now using LibVLC in my app to\nlaunch a dedicated RTMP player window.\n. ",
    "hei-yu-fa": "p2p need,the same question for me. ",
    "remy": "Found this issue with a google search unrelated to video.js, but I can chime in to say that I'm seeing the exact same thing when I request a vimeo.mp4 from Chile (failure) and from the US & Europe (success).\nThis issue isn't videojs specific, it's to do with vimeo's CDN configuration, and somehow Amakia setup stripping headers (or even query strings I've noticed\u2026but I'm not 100% sure if that has an impact). \nIn Safari I've seen the error reporting that CORS is not enabled for the video file, and in Firefox I've seen the same error mentioned here that the mime type is not supported.\nI'm raising a ticket with Vimeo and pointing them to this issue as it has solid information on the requests and response.. @charlesfonlupt I was just able to work around the issue by removing the crossOrigin attribute on the video element.\nI'm certain that Vimeo are wrong as I'm able to replicate with a plain video tag, and I'm 100% certain that with cross origin enabled on the request, their Akamai CDN is somehow chewing up the headers and corrupting them (one big difference I noticed on my requests that the final URL was missing a token query string - but I'm unsure if that's the final issue).. Got a reply and a fix from Vimeo yesterday:\n\nI truly appreciate you sending over such an in depth analysis of the issue. Using this information (and that of others on the github thread), our engineering team was able to work with Akamai to resolve this issue. Your video should now play within error in your videojs player.\nThe cause for this issue was two CORS headers. Akamai was not obeying the normal CORs workflow and unconditionally appending two headers:\nAccess-Control-Allow-Headers: X-Requested-With\nAccess-Control-Allow-Origin:\nThis created two sets of headers when a CORS request was made (a request with an 'Origin' header).  The two headers being returned to the client broke CORS, and stopped the download of segment/file in it's tracks. As a solution Akamai is now doing the appropriate behavior when a CORS response is received and echoing the requesting origin in the allowed response CORS headers. \n\nI was able to work around my own problem, but I think this change now means that your videojs player should work with the crossOrigin attribute attached.\nHope that helps!. ",
    "charlesfonlupt": "Hi Remy : We opened a ticket with Vimeo last week. \nHere is the answer they give us : \n\nI just heard back from our developers on this issue. They've done some testing, and they can suspect this is likely a videojs bug.\nTo confirm, we played your video using the Akamai redirect link in a plain HTML5 tag, and the video  played without error. There seems to be a compatibility issue on the videojs side of things. We recommend submitting an issue in their tracker here: https://github.com/videojs/videojs-contrib-hls/issues/. If you can acquire additional information from the developers of the videojs framework, I'm happy to pass this along to our engineering team. At this time, it's still unclear why your player is not accepting the Akamai URLs, so it's difficult for us to make modifications to accomodate this.\n\n. @remy : thanks for the work-around, but as @Born2BCoder is mentioning, we need the cross-origin element to be able to reproduce the video correctly, using other libraries as videojs-panorama. . Hi @remy : Thanks a lot for you help. \nThe change allow us to resolve our issue.  The \"crossOrigin\" problem we had is resolved. . ",
    "Born2BCoder": "We were able to reproduce the plain video as well removing the cross-origin attribute, but the main issue now is that its required so the videojs-panorama can bend it to a 360 view mode. without it it throws an DomException bug  failing to excecute the texImage2D on  the WebGLRendering Context\n\nDOMException: Failed to execute 'texImage2D' on 'WebGLRenderingContext': The video element contains cross-origin data, and may not be loaded.\n\nThis causes the video sound to be heard but not the image.\nSo we are left trying to figure out a way to pass through the cross-domain issue. \n. ",
    "japettyjohn": "@SVyatoslavG I have the same problem - have you found anything on this?\nIt's playing fine for a single quality, but when switching from a low quality to the next quality the picture pauses, audios continues, then the picture catches up. But I am seeing this on MacOS on Chrome as well - not just Android.. ",
    "ariel-devsar": "Could it be maybe because your ts file is not right encoded?\nI am just guessing but if you check the media info you can see that video is 3 seconds and audio 16s in the second ts file.  first TS file is like 16sseconds video + 3 seconds for this one and then there is no video.\n$ mediainfo playlist21.ts -v\nGeneral\nID                                       : 1 (0x1)\nComplete name                            : playlist21.ts\nFormat                                   : MPEG-TS\nFile size                                : 523 KiB\nDuration                                 : 2s 533ms\nOverall bit rate mode                    : Variable\nOverall bit rate                         : 692 Kbps\nVideo\nID                                       : 256 (0x100)\nMenu ID                                  : 1 (0x1)\nFormat                                   : AVC\nFormat/Info                              : Advanced Video Codec\nFormat profile                           : High@L3.1\nFormat settings, CABAC                   : Yes\nFormat settings, ReFrames                : 4 frames\nCodec ID                                 : 27\nDuration                                 : 2s 734ms\nWidth                                    : 800 pixels\nHeight                                   : 600 pixels\nDisplay aspect ratio                     : 4:3\nFrame rate                               : 15.000 fps\nColor space                              : YUV\nChroma subsampling                       : 4:2:0\nBit depth                                : 8 bits\nScan type                                : Progressive\nAudio\nID                                       : 257 (0x101)\nMenu ID                                  : 1 (0x1)\nFormat                                   : AAC\nFormat/Info                              : Advanced Audio Codec\nFormat version                           : Version 4\nFormat profile                           : LC\nMuxing mode                              : ADTS\nCodec ID                                 : 15\nDuration                                 : 16s 623ms\nBit rate mode                            : Variable\nChannel(s)                               : 2 channels\nChannel positions                        : Front: L R\nSampling rate                            : 44.1 KHz\nFrame rate                               : 43.066 fps (1024 spf)\nCompression mode                         : Lossy\nDelay relative to video                  : -128ms\nLanguage                                 : English\nAny one knows about if there is a gap to big without video between ts files the player freeze? . ",
    "IBD": "Hi,\nThe file was recorded over network. I guess there's a drop frames in the encoder side. There you see video stream shorter than audio stream.\nEven though this is the case, the player should continue to play the audio stream. Spinning loading should not appear on the player. . ",
    "Vantrix-Bitm": "Dammit, wrong account.. ",
    "fbeaudet": "Hi :)\nI'm having this issue only in firefox, I think my samples are limit. Looking forward for that robust solution, gonna update as soon as it's out.\nThank you!. ",
    "genelamarellis": "I know it's been a while, but any progress on this? Running into the exact same issue! I tried implementing the fix but I'm still running into an issue. Running this on some SmartTvs. The error is thrown on some, but not all. Question, if I wanted to reduce the size even more, which values should I change in the code? Thank you! . Amazing! Thank you so much! Just double checking the implementation steps to test this. I understand how to fetch the pull request for #1416. Then do I fetch the pull request for https://github.com/videojs/videojs-contrib-media-sources/pull/178 as well. Then rebuild both, upload the dist directories, reference the proper js files, and call it a day?. Ok thank you so much! I have run all of the commands and I'm waiting for my team to give me an update to see if it worked. Thanks!. Hero! This has solved our issues! Thank you so much! I hope this gets merged into the main branch. Life saver! Thanks again!. ",
    "Shamaon": "Hey, thanks for the reply, both ideas are nice but i did not have time to try them both. Ill let you know when if i ever get to try them out!. ",
    "bnussey": "Also having same issue, upgraded to 5.11.0 but still seeing it. Thanks.. ",
    "hayatbiralem": "I use Win10 and Chrome, and I have the same problem.. ",
    "azizantoun": "Same here. . ",
    "hiepnm": "The same issuse.\nvideojs-contrib-hls: 5.12.1.\nMac OSX Sierra and Chrome.\n. ",
    "morkov4o": "any update ? we face the same problem ? is`t fixed ?. ",
    "SolmazKh": "I am having the same problem. V  5.12.2\nAny updates about this issue?. I am having the same problem. Any news?. ",
    "zhangzs000": "i have the some problem Video.js 6.2.8. ",
    "sumeetkate": "Hi Folks,\nIs there update on the issue ?. ",
    "vakuzmin": "the same issue . please don't forget to include as well\n\"../node_modules/video.js/dist/video-js.min.css\",\nmoreover here is the link to the custom component guide \nhttps://www.arroyolabs.com/2017/03/angular-2-videojs-component/. ",
    "liupeng5843": "the same issue. ",
    "ciki6": "the same issue on version 5.18.4. ",
    "IhorVimmi": "Opera 54.0.2952.60 Ubuntu 16.04 same issue. ",
    "bogatisuman": "Same issue on Chrome of Android(kitkat).. ",
    "dannyf620": "the problem is in the Streaming signal and not in the player, sometimes it happens after a specific time, consult the problem with the streaming provider. To verify try with another different signal and you will see the difference,\nverify whit chorme or firefox device simulator without some player direct url 'inspect'. ",
    "UniqueMarvin": "Same issue on Chrome\uff0cbut the same media file is OK on flash of IE 11 win7. ",
    "zhengtulymGh": "I\u2018m sorry, I do not have permission to change the CORS, what else information can I provide?. ",
    "Toninie": "I maybe have the same problem.Some m3u8 source cannot play with this plugin,but it work in VLC and mobile browser,and I also print some log in console.The ts slice in m3u8 cannot be found the audio/video tracks by this plugin,. ",
    "hefeng1208": "thanks @gkatsev . ",
    "NickyHeuperman": "FFMPEG seemed to not like decoding ac3 to both stereo and surround at the same time, demuxing it seperately made it work, sorry. ",
    "nomayonnaise": "Since I'm trying to get help here too, I thought I'd be useful and answer.\nThe audio is MP3 (see ffprobe output below), which isn't supported (https://github.com/videojs/videojs-contrib-hls/issues/1218)\n\nTry AAC or HE-AAC for audio, should work!. Thanks @mjneil for pointing me in the right direction.. ",
    "jamesjieye": "@mjneil, I've created a pull request on videojs-contrib-media-source which fixes this issue. Could you merge the PR?\nThanks,\nJames. @uraspaz88, the pull request is still open https://github.com/videojs/videojs-contrib-media-sources/pull/172.\nThe current workaround is to change the library in node_modules directly which is not ideal. \nI've sent request to @mjneil but no reply yet. . It looks like the code is from videojs-contrib-media-sources here https://github.com/videojs/videojs-contrib-media-sources/blob/637ecf0a6d19b590f20b16eefd23b4dac1cebf7b/src/virtual-source-buffer.js#L609. @mjneil, re-encoding the audio to AAC fixes my issue. Thank you!. ",
    "uraspaz88": "I don't think the merge has been done yet but I can confirm that the issue is still present. I'm using videojs-6.8.0, and videojs-contrib-hls-5.14.1. Something I noticed in my cross-browser/device testing was that Safari on OSX/iOS does fire the cuechange event with audio-only HLS streams, possibly due to Apple's native HLS support, but other browsers/devices fail to fire the cuechange event for audio-only HLS streams.\nRelated, the native HLS support built into Edge and Android seems to have an issue where the addtrack event doesn't fire when the initial ID3 info is received. In this case, using the hls.overrideNative option is a decent work-around. I'm a github noob, so if I can provide other info, let me know.. ",
    "thijstriemstra": "@forbesjo should i make a separate pr for the caching or can you just pick the caching-related commit?. Ok in my setup it's a little different I notice now, and you're right so ignore this change.. ",
    "ronlinet": "@mjneil it does the trick ! \nI just had to add and additional scaling coz I am resizing the medias per per client's bandwidth. \nffmpeg -i ../tmp/short.mp4 -vf scale=320:184 -bsf:v h264_mp4toannexb -hls_list_size 0 playlist.m3u8 \nCheers !. I have just found out that files generated with the above ffmpeg snippet works everywhere except the Android. The Android Chrome browsers abort the streaming with \u2018Media could not be loaded\u2019 error. I don\u2019t get the error with your .ts files served by bipbop_16x9_variant.m3u8 . \nWould you mind to stick here the ffmpeg command used for your demo ts files?. Missing dollar sign field delimiter at file header #EXTM3U in m3u8 manifest is enough to corrupt the streaming to android devices. \nThis char is invisible in Netbeens or any other IDE. File has to be edited with command line vimdiff to spot the absence of the delimiter.. ",
    "alviscure": "@mjneil thanks for the shared instruction, how can I modify the bitrate of the ouput? Thank you again, it has helped me a lot.. ",
    "blacksail29": "hi guys,\ntrying the same fallback from hls to dash without success. Dash fails on android , my live streams get latency with dash. All is pefect with hls ....\nis there a sense to do that ? perhaps i have to choise from hls to dash ?\nthanks for help,\neric\n. ",
    "shatico": "I prepared another test page (JSBin).\nI include videojs-flash.js and videojs-contrib-hls.js for HLS streaming on IE11 on Win7.\nPlease click [Jump to 2:00] button several times in this page.\nThe video head jumps to 2:10 or 2:20 or some wrong point after several clickings:\nhttp://jsbin.com/winuweg/2/edit?html,output\nDoes this this problem caused by Flash or IE11?\nPlease try this.. ",
    "ccrsky": "I got the similar issue,but video not  able to play on Safari, videojs @6.2.7 videojs-contrib-hl@5.11.0. i need use beforeRequest to transform ts filePath,but mobile device  has  only one soucehandler (native soucehandler), beforeRequest not work,how to fix it ?. ",
    "dannyxu2015": "found same issue on chrome(v61.0.3163.100), videojs@6.2.8, videojs-contrib-hls@5.12.2. ",
    "gaxunil": "Thanks yeah I don't have a great consistent way to reproduce this yet and we are continuing our investigations across the stack, thanks so much for the info @gesinger !!\nI will let you know if I see something valid in our findings that indicates a bug.. ",
    "stevenviola": "@mjneil, thanks for looking into this so quickly. Is there a better range I should specify from the source file that's not working? I'm using ffmpeg to iterate through the packets of the video file to find the video keyframe that is nearest to the desirable time. This has been working well so far and this was the first time I've had an issue with videojs not loading a video. @mjneil Thanks a lot. This looks like it fixed my issue!. ",
    "zhuyeqing5828": "I tried with the live demo (address is http://jsbin.com/vokipos/8/edit?html,output ) ,but no issue.. ",
    "barhom": "+1. Lets assume the following;\n\nYou are playing a live stream\nWhilst fetching the playlist after playback time of X minutes you suddenly get a 40x/50x.\nWe want to catch that 40x/50x and then do whatever we want. For example, reload the video, maybe play another video, or simply outputting to console.log(\"40x/50x happened\"). +1. \n",
    "morangil": "@squarebracket,\ncorrect. let's say the token is set to 10 minutes but someone clicked on pause for 12 minutes and try to watch the movie.. ",
    "nicolaslevy": "I need this feature too.\nMaybe i'm looking at the wrong place but the only thing that worked for me was listen to 'retryplayist' events. Something like this:\nplayer.tech_.on('retryplaylist', () => {\n      do_something()\n  })\nDoes anyone has a better solution? \n. ",
    "d3x7r0": "Sorry, I've changed the stream to one that's available outside the country but apparently restarting out stream actually made the problem go away.\nSorry. I guess I'll close this one then. I'm guessing there is some sort of issue with out software when running for a large enough period of time that breaks something but its a bit hard to reproduce.. ",
    "auditoryhallucination88": "It's working now. Found out that i have no flash installed on ie.. ",
    "matt-iakhno": "I updated the JSbin with proper syntax - when running in Safari 11 the player throws error, but Chrome and FF play fine\nhttp://jsbin.com/yizuyenulu/edit?html,console,output. ",
    "skzap": "I'm pretty sure this relies on them knowing the filesize / bitrate of videos playing. ",
    "sdahdaah": "Hello,\nauto in preload is limited to 1 TS file in case of VOD and to no TS file in case of live. What he is referring to is similar to the behavior of hls.js that keeps preloading segments with no limit.\ni have suggested a method for that i am not sure if feasible:\nto have 3 different preload features currently 2 are supported correctly:\n1- none does nothing (already supported)\n2- metadata has similar behavior to the current auto\n3- auto preload for both live and vod unlimited number of chunk and ts similar to the behavior of hls.js\ni believe contrib-hls has a lack in the auto that needs to be worked out.. We also have another issue happening on iOS devices, while watching a VOD sometimes the video goes backward in time and the playback continue to work. This is persisting with the latest version of the player.. Yes, i am moving to hlsjs as it could succeed the preload of live streaming. By the way it doesn\u2019t need a test file i checked the .js file of contrib-hls and you are limiting preload to video on demand stream.\nI will keep you this link for testing: http://player.l1vetv.com/videojs626a/sd2.php\n. Hello,\nYou can let it start at the edge if we keep loading the segments and chunklist similar to JWPlayer and hls.js.\ni think it is a good idea to create 3 types of preload:\nnone does nothing (already supported)\nmetadata (supported but same as auto) here we use the current preload method\nauto we define a new state similar to JWPlayer preload and hlsjs have a look at the preload in this example (http://player.l1vetv.com/ktv1/) it keeps retrieving the m3u8 and ts\nit will be really appreciated if we can reach this point with live and vod, for live metada won't do any effect.\nRegards, . ",
    "menkveldj": "love this! any chance it will be merged into master soon?. Yes, i spent hours trying to make my own branch and build this out. It would be a huge help for certain types of projects.. ",
    "vercha": "hello , I encountered same question. where to put the object.assign() code?Thanks very much!. ",
    "cadalt": "i am also getting this error, but only on windows 7 ie 11. ",
    "kshitij0392": "@mjneil That's exactly what I am doing now, just curious whether we could support different formats in one type. \n<source  data-bind=\"attr:{src:URLToPlay, type: isAkamaiUrl() ? 'application/vnd.apple.mpegURL' : 'video/mp4'}\" id=\"video-source\" >\nHere's what I am doing !. ",
    "syagawa": "Thank you for your reply.\nI looked at this page (https://videojs.github.io/videojs-contrib-hls/) again.\nOf course it's in Android emulated mode on Chrome(Windows 7).\nThen, no error appears.\nChrome was able to play video.\nAfter checking the version of videojs, it was displayed as 6.7.3.\nThe videojs version when I posted this issue was 6.4.0.\nChecking the changelog of video.js, we found a commit https://github.com/videojs/video.js/commit/f03ac5e .\nI have not confirmed the details, but probably the issue was fixed with this commit.\nThank you.. ",
    "eklimas": "Do you need to wait till after the loadstart event before accessing?  I've been noticing with some issues I've been having that hls isn't initialized (it seems) till you hit that point.. ",
    "vkulov": "How did you solve the issue? We are getting the exact same error.. ",
    "juninhocruzg3": "How did you solve the issue?. ",
    "raditya-ab": "I experienced the same issue, chrome version 63.0.3239.84 (Official Build) (64-bit) on Mac High Sierra. ",
    "dimitrove": "Yes, it works when on a web server (Tomcat). When on the file system Chrome says something like \"crossdomain access not allowed for file:\". I don't understand what is \"crossdomain\" if everything is on the file system.... Thank you for the explanation. At least it is clear this is not a videojs problem. I will close this issue.. ",
    "dainiusgliebus": "Is there a way to handle combined? like splitting or something?. ",
    "robov": "Thanks.. I am new on encrypted hls, and have a hard time finding working examples. Especially with providing the descryption keys to the player. Thanks. that article indeed gave some valuable insights. So the player requests the key by calling the supplied URI in the manifest. Is there a description of what is in that call ?\nMeaning how can I protect that key calling url from being called by unauthorized people. it looks like I need to send a session/encryption/auth stuff with the request for the key so the key software knows if this is a valid request or not. I am searching for what information I can pass with videojs and how I pass that to the site that hosts the key. AES encryption\nThe manifest pulls the key from the server and in the chome console I can see this pulling and see the actual base64 encrypted key\nI am using : videojs-contrib-hls\n. @gesinger .. If I know where your code gets pulls they key from the manifest url, then I can handle the encryption myself. Adding this is an important security feature..\nps. flowplayers implementation has the same leak : https://flowplayer.blacktrash.org/hls-crypt/ \nexposes their encryption key in base64. @nampdn ... no... If I knew I could fix this issue by decrypting the key (and encrypting it on the key store)\nbut I have not looked into this yet... please update when you know where they key is fetched... or even better.. how we can edit the key before it is used by the player itself. The content is encrypted. could that be the reason why it fails in videojs ?. https://tests1.yormy.com/vid/. ... thanks for your assistance..... @gesinger , did you see the issue in safari, and the working file in chrome ?\nAny ideas how to fix this ?. I just got a not that it could not be played on an iphone7 (i cannot test, as I do not have an iphone). On that iphone the flowplayer encrypted hls works : https://flowplayer.blacktrash.org/hls-crypt/ (worked). Any ideas why the videojs is not yet working ?. My friend reported that the flowplayer worked on her iphone, however on my windows desktop running safari, the flowplayer also doe not work.\nOn safari I also cannot see the pulling of the m3u8 in the network tab (while I can in chrome). Or another solution could be to force safari to use your code instead of native... would that resolve the issue... and how to do that ?. @gesinger .. ps opera also works nicely, only safari F @#%#@ cks up. Yes, just confirmed again. Flowplayer works, videojs does not work... I rather use videojs (pricing and open source), but I might have to switch if I cannot get it to work properly on a macoc. OR it could be that my encoding on elastic transcoder is set wrong.... what is the best settings to be able to play on ios ? HLS. I am using this elastic preset : \nHLS v3 (Apple HTTP Live Streaming), 1 megabit/second | 1351620000001-200030\nCould that be the issue?\nIf so what prefix should I use instead\n. ",
    "vespoli": "Updated example with no success. Added a clickable button to try to \"jump\" to the end:\nplayer.currentTime(player.seekable().end(0));\n        player.play();\nAgain, works in other browsers but Android starts from the beginning.. I apologize. As the live streams end I have to update the video or it will attempt to load the VOD version. Please take a look now. That worked! Came down to a misconfiguration. Thanks so much @mjneil ! Please point me in the direction of your tip jar.. ",
    "Timsonrobl": "@alex2844 assuming you are talking about adding custom headers to XHR requests - it is impossible due to security limitations hard-coded in all modern browsers.\nYou can see forbidden headers here.. ",
    "lgyytm": "thank you. ",
    "bevikram": "This is probably due to the loaders in the webpack, try to install a file-loader and add json under test.. ",
    "vitalimold": "As a workaround - turn off Hardware acceleration. . ",
    "satanupup": "Summary \u2013 How to disable hardware acceleration in Google Chrome\nOpen Google Chrome.\nClick the menu button (It says Customize and control Google Chrome when you hover over it) at the top-right corner of the window.\nClick Settings.\nScroll down and click the Show advanced settings link at the bottom of the window.\nScroll down to the System section and uncheck the box to the left of Use hardware acceleration when available.. vitalimold \nhttps://www.bountysource.com/teams/videojs has paid 5 US. mp4 original video is 640 * 480\nBut converted m3u8 video is 854 * 480\nSo the right side of the image is cut off\nTurned out to 640 * 480 on the right will not be cut off. ",
    "marcusfrenkel": "Not really, here is contents from sample playlist:\nEXTM3U\nEXT-X-VERSION:3\nEXT-X-STREAM-INF:BANDWIDTH=604892,CODECS=\"avc1.77.30,mp4a.40.2\",RESOLUTION=854x480\nchunk.m3u8?nimblesessionid=5399956. OK, thanks a lot for letting me know.. ",
    "avenchen": "We have the same problem, even \"Version 66.0.3346.9 (Official Build) dev (64-bit)\" show the same error \"audio error during playing, status: PIPELINE_ERROR_DECODE\". ",
    "chanwaiyu": "We have to same problem. ",
    "OlegBose": "I have the same problem STILL with just only audio .mp3 stream playback:\n03-28 13:25:36.070: E/chromium(17073): [ERROR:render_media_log.cc(30)] MediaEvent: MEDIA_ERROR_LOG_ENTRY {\"error\":\"Failed to send audio packet for decoding: timestamp=253805714 duration=26122 size=340 side_data_size=0 is_key_frame=1 encrypted=0 discard_padding (ms)=(0, 0)\"}\n03-28 13:25:36.073: E/chromium(17073): [ERROR:render_media_log.cc(30)] MediaEvent: MEDIA_ERROR_LOG_ENTRY {\"error\":\"audio decode error\"}\n03-28 13:25:36.073: E/chromium(17073): [ERROR:render_media_log.cc(30)] MediaEvent: MEDIA_ERROR_LOG_ENTRY {\"error\":\"audio error during playing, status: PIPELINE_ERROR_DECODE\"}\n03-28 13:25:36.074: E/chromium(17073): [ERROR:render_media_log.cc(30)] MediaEvent: MEDIA_ERROR_LOG_ENTRY {\"error\":\"audio error during playing, status: PIPELINE_ERROR_DECODE\"}\n03-28 13:25:36.076: E/chromium(17073): [ERROR:render_media_log.cc(30)] MediaEvent: PIPELINE_ERROR PIPELINE_ERROR_DECODE. ",
    "liamtarpey": "Unrelated to this library but I have the same error playing an mp3 on Chrome occasionally using Media API > \nPIPELINE_ERROR_DECODE: Failed to send audio packet for decoding: timestamp=2114640 duration=36000 size=106 side_data_size=0 is_key_frame=1 encrypted=0 discard_padding (ms)=(0, 0)\n. ",
    "kieferaguilar": "I encountered this issue on Chrome 67 on a Mac. The issue was that Chrome was attempting to autoupdate, but needed to relaunch.\nGo to Chrome -> About Google Chrome, and see if Chrome is trying to update. A \"Relaunch\" button appeared for me, which resolved the problem.\nI suppose end users could run into the same issue. I have no idea how they would know how to fix the issue, and it's not exactly clear to me whether this poor experience is something videojs or developers who use videojs can resolve or whether it is an issue with Chrome itself.. ",
    "Xesme": "Is there a status update or work around for this merge? . ",
    "trailofdad": "This is Issue still alive? I'm trying to solve this.... ",
    "edoudou": "It seems to be doing the job, thanks you I will try it and close the issue if it's okay.. Exactly what I was looking for, thanks you for the help.. ",
    "halm0291": "How do you know when the video resumes the playback?. ",
    "nampdn": "@robov Have you get the idea where the fetch key is written in this project?. ",
    "grobolom": "@gesinger all fixed up \ud83d\udc4d . @gesinger hey man, just wondering - is there an approximate timeline for when PRs get merged in these repositories? I understand it's not a high-traffic area, but it would be cool for to try this out in our code (and avoid some errors). No rush though, just asking :). @gesinger no sweat - thanks for adding this in! We really appreciate it :). @gesinger cool! I'll update later today.. aaaah. I see. My bad, I'll fix that up!. ",
    "Nickman87": "It's pretty straightforward.\nYou need to install two dependencies:\nnpm install --save video.js videojs-contrib-hls\nAnd then you can use it as follows:\n```\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport videojs from 'video.js';\nimport 'video.js/dist/video-js.css';\n//import 'videojs-contrib-hls/dist/videojs-contrib-hls.js';\n// Workaround for webworkify not working with webpack\nwindow.videojs = videojs;\nrequire('videojs-contrib-hls/dist/videojs-contrib-hls.js');\nclass VideoPlayer extends Component {\n    startVideo(video) {\n        videojs(video);\n    }\nrender() {\n    return (\n            <video ref={this.startVideo} width={this.props.width} height={this.props.height} className=\"video-js vjs-default-skin\" controls>\n                <source src={this.props.source} type=\"application/x-mpegURL\" />\n            </video>\n    );\n}\n\n}\nVideoPlayer.propTypes = {\n    width: PropTypes.string.isRequired,\n    height: PropTypes.string.isRequired,\n    source: PropTypes.string.isRequired,\n};\nexport default VideoPlayer;\n```. Both should give you the same result :). ",
    "Nagaraj-Prabhu": "HI @gesinger, as the video.js is not getting variant m3u8 and ts segments, it is throwing that error I checked it in Network tab in Google Chrome. This error comes when a video master file(index.m3u8) loaded from disk cache and it will not request other files from the server. . Hi @gkatsev, I tried with 'disable cache' and the video played fine so I am thinking the problem may because of disk caching of files.. ",
    "varadarajana": "Thank you @gesinger. I have been to get the cue loaded from the player.ads.cueTextTracks.processMetadataTracks(player, processMetadataTrack);. @gesinger \nThank you, I added Sequence tag in that start of every playlist, pointing to the sequence number that is the first in the file. Now it works fine.\nI have another question. I am using EXT-X-CUE tags while creating the playlist.\nAm I correct in assuming that that CUE-OUT and CUE-IN tags have to be in a single live playlist, can there be CUE-OUT in previous list and CUE-IN in current. The reason I ask this question is that I am forced to wait for CUE-OUT and CUE-IN in a single playlist so this induces a latency in refresh.\n. ",
    "lahbib": "import { videojs } from \"video.js\"; \nis the simplest way  :)\n. ",
    "greenkeeper[bot]": "Version 3.3.13 just got published.\nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv3.3.13\n\u00a0\n\n\nCommits\nThe new version differs by 15 commits.\n\n951d87c v3.3.13\n798fc21 improve test/run-test.js performance (#2971)\na75a046 compress arguments[index] (#2967)\n38f2b45 fix value reference caching in evaluate (#2969)\n56e2a36 enhance conditionals (#2966)\n0daa199 migrate safe transformations out of unsafe_comps (#2962)\n73e98dc drop side_effects-free return values (#2965)\n36bca69 enhance collapse_vars (#2952)\nace5811 drop lone \"use strict\" in function body (#2963)\nba7bad0 show benchmark subtotal (#2960)\nb8b2ac5 improve fix for #2954 (#2958)\nea23593 fix collapse_vars on nested exception (#2955)\n52de64c deduplicate parenthesis around object and function literals (#2953)\n4557902 minor clean-ups (#2951)\nf40f5eb improve mangle (#2948)\n\nSee the full diff\n\n. ## Version 4.4.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 9 commits.\n\nc105a46 Update docs/changelog.md and set new release id in docs/_config.yml\n432a284 Add release documentation for v4.4.1\n9b4870e 4.4.1\na14d96f Update History.md and AUTHORS for new release\nae22a33 merge doc changes to released versions\n4cf8a83 correct eslint statements\n7380a03 add tests to verify asserts on spyCalls\n6e7e71f Update docs\ncbc5667 Document that it is allowed to assert on dedicated spy calls.\n\nSee the full diff\n\n. ## Version 4.4.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 5 commits.\n\n99ef3fa Update docs/changelog.md and set new release id in docs/_config.yml\n2075fda Add release documentation for v4.4.2\n5ac4eae 4.4.2\ne0bfd43 Update History.md and AUTHORS for new release\n5a2f19f Add descriptive error message on attempt to call argument that is not a function\n\nSee the full diff\n\n. ## Version 4.0.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv4.0.1\nFeatures\n\nadd version property to webpack exports\n\nBugfixes\n\nimport() with CJS now gives correct exports\nModule concatenation bailout messages now point to correct module\n\n\n\nCommits\nThe new version differs by 8 commits.\n\n5044762 4.0.1\n7fd5c6f Merge pull request #6585 from webpack/bugfix/bailout-messages\n8e592bf Merge pull request #6575 from nveenjain/addVersion\ne7aba18 fix incorrect optimization bailout messages\n9f9c3d1 Merge pull request #6583 from webpack/bugfix/import-cjs\n8bf1574 CJS fake namespace object contains exports now\nd50fa68 add newlines\n05174ae Added version to webpack's export property\n\nSee the full diff\n\n. ## Version 4.1.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv4.1.0\nFeatures\n\nadd filename option to optimization.splitChunks to modify the filename template for splitted chunks\nallow modules which doesn't emit code into the bundle\n\nBugfixes\n\nwatchpack updated to 1.5.0\nperformance fix for Module Concatenation (v8 bug)\nfix using this.xxx in ProvidePlugin\n\n\n\nCommits\nThe new version differs by 73 commits.\n\nf916fc0 4.1.0\n8eba694 Merge pull request #6650 from webpack/bump_watchpack\n00f70fc Merge pull request #6645 from zacanger/fix/6644\n2e3d319 Merge pull request #6648 from cheapsteak/patch-1\n01c18cc Merge pull request #6651 from webpack/feature/split-chunks-filename\n2e687d0 Merge pull request #6613 from brentwilton/improve-performance-of-module-concatenation-plugin\n3c5b104 Merge pull request #6663 from webpack/feature/support-non-js\n2c8ea60 expose stuff and all non-bundle modules\nb0e14df Set optimization.splitChunks to false in test webpack config.\necb65aa allow to configure filename for splitted chunks\n325038d Update watchpack to 1.5.0\na2fd80e Update downloads badge to point to graph of downloads\n3a41ca4 Fix #6644\n39095ef add todo for ModuleConcatenationPlugin for loop bugfix\nf6e366b Merge pull request #6611 from kvrlk/patch-1\n\nThere are 73 commits in total.\nSee the full diff\n\n. ## Version 4.1.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv4.1.1\nFeatures\n\nStats now displays the number of assets of a module\n\nBugfixes\n\nsourceMap option of the default UglifyJsPlugin now defaults to true when the SourceMapDevToolPlugin is used\nmodule.assets is now working again in the Stats\nchunk ids are not stringified on target node\ndevtoolNamespace default works now also for arrays passed to output.library\nFormat date with 2 digits in Stats for Build At\nfix a bug renaming classes incorrectly\nfix a bug where modules ignore the chunks option of optimization.splitChunks\n\n\n\nCommits\nThe new version differs by 27 commits.\n\n41bb63a 4.1.1\n37f7681 Merge pull request #6697 from webpack/bugfix/split-chunks\n4d68350 fix bug where modules are put into the wrong chunk\n8a59ef7 Merge pull request #6689 from webpack/bugfix/issue-6688\nedbb6f6 Merge pull request #6670 from SimenB/patch-1\n800e7f9 fix #6688\nc54df36 Merge pull request #6609 from marcalexiei/configuration-version-error\n4f39932 Merge pull request #6641 from tmilloff/master\n6879ab7 Merge pull request #6685 from webpack/bugfix/node_chunks\n71eff5d Merge pull request #6686 from webpack/bugfix/ccp-readme\n9eb4daa Remove CCP link\nf9e7a17 Escape module names\n1181c0e Remove accidental filename setting which wasn't needed and was breaking test\n57c6c43 Add requested changes from PR comments\nae2ae4e Merge pull request #6640 from clarkdo/module-assets\n\nThere are 27 commits in total.\nSee the full diff\n\n. ## Version 1.16.1 just got published. \nYour tests are still failing with this version. Compare the changes \ud83d\udea8 \n\nCommits\nThe new version differs by 2 commits.\n\n7ffd545 fix: windows exec resolution (#1274)\n0f39b2e fix: make it possible for windows to checkout (#1270)\n\nSee the full diff\n\n. After pinning to 1.15.1 your tests are passing again. Downgrade this dependency \ud83d\udccc.. ## Version 1.17.0 just got published. \nYour tests are still failing with this version. Compare the changes \ud83d\udea8 \n\nRelease Notes\nv1.17.0\n\n1.17.0 (2018-02-27)\nBug Fixes\n\nmake it possible for windows to checkout (#1270) (0f39b2e), closes #1255\nwindows exec resolution (#1274) (7ffd545), closes #1251\nmake clear where more opts are in help (#1271) (f4391d4)\nput windows drive letter tweak in right place (#1272) (94b526f), closes #1263\n\nFeatures\n\ntry to resolve exec in node_modules/.bin (#1275) (7fb365d), closes #1268\nfeed args to exec when detecting script (#1273) (e41f3c3), closes #1263\n\nNote: due to an oddity in the automated build process, nodemon was bumped two minor versions instead of one. Nothing to worry about though.\n\n\nCommits\nThe new version differs by 1 commits.\n\n7fb365d feat: try to resolve exec in node_modules/.bin (#1275)\n\nSee the full diff\n\n. ## Version 1.17.1 just got published. \nYour tests are still failing with this version. Compare the changes \ud83d\udea8 \n\nRelease Notes\nv1.17.1\n\n1.17.1 (2018-02-27)\nBug Fixes\n\nthrowing exeception on run (85ed19d), closes #1276\n\n\n\nCommits\nThe new version differs by 1 commits.\n\n85ed19d fix: throwing exeception on run\n\nSee the full diff\n\n. ## Version 1.17.2 just got published. \nYour tests are still failing with this version. Compare the changes \ud83d\udea8 \n\nRelease Notes\nv1.17.2\n\n1.17.2 (2018-03-13)\nBug Fixes\n\nprevent throw when args missing (#1288) (89d6062), closes #1286\nwatch count regression (#1287) (372e6b2), closes #1283\n\n\n\nCommits\nThe new version differs by 5 commits.\n\n89d6062 fix: prevent throw when args missing (#1288)\n372e6b2 fix: watch count regression (#1287)\n8637e52 chore: merge branch 'master'\n41f0d42 chore: update issue template\ne16f2fe chore: revert package\n\nSee the full diff\n\n. ## Version 1.17.3 just got published. \nYour tests are passing again with this version. Explicitly upgrade to this version \ud83d\ude80 \n\nRelease Notes\nv1.17.3\n\n1.17.3 (2018-03-31)\nBug Fixes\n\ndon't throw when required in the repl (aa18c80), closes #1292\n\n\n\nCommits\nThe new version differs by 1 commits.\n\naa18c80 fix: don't throw when required in the repl\n\nSee the full diff\n\n. ## Version 1.17.5 just got published. \nYour tests are passing again with this version. Explicitly upgrade to this version \ud83d\ude80 \n\nRelease Notes\nv1.17.5\n\n1.17.5 (2018-05-23)\nBug Fixes\n\nin watch, use fully filtered ignore rules (b3fc3a9), closes #1348\n\n\n\nCommits\nThe new version differs by 10 commits.\n\nb3fc3a9 fix: in watch, use fully filtered ignore rules\nff79835 chore: update stalebot\nee2aac1 fix: support env.SUPPRESS_SUPPORT (#1334)\n58b82f2 fix: increase perf of watching large file count\nf616258 fix: {{filename}} is only replaced once\n97f8d0a  fix: node_modules watched off relative path (#1328)\n9bbc219 fix: only hook SIGINT on boot - not at require\nd53a244 chore: mildly reduce npm package size\n6925494 docs: use consistent ext example\naa18c80 fix: don't throw when required in the repl\n\nSee the full diff\n\n. After pinning to 3.10.0 your tests are passing again. Downgrade this dependency \ud83d\udccc.. ## Version 2.0.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 5 commits.\n\n1eb95ee chore: release v2.0.1\nfc9afd2 chore: update contributors\nb3773d9 fix: look for qunit instead of qunitjs\n28f739f Update the path to QUnit css\n8a0c0d0 Looking for qunit instead of qunitjs\n\nSee the full diff\n\n. ## Version 2.0.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits.\n\n7bbb633 chore: release v2.0.2\n2b91cc6 chore: update contributors\n7d8c138 fix(adapter): add timeout before starting qunit\n8b45e4f test: add unit test for lib and an integration test\n\nSee the full diff\n\n. ## Version 2.1.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits.\n\na431d39 chore: release v2.1.0\na5a211c chore: update contributors\n84bbe00 chore: update yarn.lock\n604525a fix (adapter): save and reset qunit-fixture properly\n\nSee the full diff\n\n. ## Version 0.1.5 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\n3cf43a3 0.1.5\n1e9dead ignore: use JSON.stringify instead of String.replace to escape quotes (#5)\n\nSee the full diff\n\n. ## Version 5.0.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv5.0.1\n\nFix occasional overlap and hang in d3.packSiblings. Thanks, @robinhouston!\n\n\n\nCommits\nThe new version differs by 11 commits.\n\nbbd0cb4 5.0.1\nb707ed5 Update d3-hierarchy.\n4a7cc9f Update API.md\n409ee40 Update CHANGES.md\n932a66d Update CHANGES.md\ncfe28d8 Update CHANGES.\n2b8ba30 Update CHANGES.\n9bd8e37 Update CHANGES.\n5f1e8bc Update CHANGES.\n811ff50 Update API.\nb7e3516 Update CHANGES.\n\nSee the full diff\n\n. ## Version 5.0.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv5.0.2\n\nSwitch from D65 to D50 for Lab and HCL color spaces. Thanks, @danburzo!\nFix Lab and HCL representation of achromatic colors.\n\n\n\nCommits\nThe new version differs by 2 commits.\n\n7a7e13e 5.0.2\n2ff6e84 Update d3-color.\n\nSee the full diff\n\n. ## Version 5.1.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv5.1.0\n\nAdd d3.lch.\nAdd d3.gray.\nSwitch from D65 to D50 for Lab and HCL color spaces. Thanks, @danburzo!\nFix Lab and HCL representation of achromatic colors.\n\n\n\nCommits\nThe new version differs by 2 commits.\n\n18e77c2 5.1.0\n8a0140d Update d3-color.\n\nSee the full diff\n\n. ## Version 5.2.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 5.3.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv5.3.0\n\nAdd ~ option to d3.format to trim insignificant zeros. Thanks, @vasturiano!\nFix d3.formatSpecifier to not bake shorthand aliases.\n\n\n. ## Version 5.4.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv5.4.0\n\nAdd d3.interpolateSinebow.\n\n\n. ## Version 5.5.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv5.5.0\n\nAdd d3.scaleDiverging.\nFix treatment of degenerate domains in d3.scaleSequential.\n\n\n. ## Version 2.0.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv2.0.3\nBug Fixes\n\nBaseReporter: log message correctly with just one browser (#3045) (c1eb236)\nbrowser: don't add already active socket again on reconnect (37a7958)\nbrowser: filter browser logging by level  (35965d9), closes #2228\nbrowser: nicer \"disconnect\" - no more \"Disconnectedundefined\" (a987d63)\nbuild: pin npm version in appveyor to v3, compat with node 4 (#2983) (bc1453e)\nci: Repaired AppVeyor for Node.js@0.12 (cbfd98c)\ncli: override if an arg is defined multiple times (31eb2c2), closes #1192\ncli: print UserAgent string verbatim if from an unknown browser (9d97226)\ncli: restore shell completion in the npm package (f56b5a5), closes #2351\ncli: Use bin field in package.json (6823926), closes #1351\nclient: add ES5 shim (14c30b7), closes #1529\nclient: add proxy support to stringify (be10116)\nclient: does not throws an error for non DOM object that has tagName property (ba55afb), closes #2139\nclient: don't crash if receive array-like results (e095411), closes #2061\nclient: dynamic protocol for socket.io (c986eef), closes #1400\nclient: Fix stringify serializing objects (0d0972a)\nclient: Revert back to old reloading detection (f1c22d6), closes #1656\nclient: serialise DOM objects (1f73be4), closes #1106\nclient: Update location detection for socket.io (7a23fa5)\nclient: Use supported shim path. (184f12e)\nclient: Wait for childwindow to load (c1bb15a)\nclient: Wait for iframe to be loaded (1631474), closes #1652\nclient.html: always open debug.html in a new browser process (d176bcf)\ncommon: fix AppVeyor build (6c5e7d0)\ncommon: more detailed info about error (424aacc)\ncommon: Proxy function toString does not contain Proxy. (4fb3484)\ncommon: stringify error on 'Cannot convert a Symbol value to a string' (#2990) (65b658a), closes #2856\nconfig: #1113 Watching is not working properly on linux (c91ffbc)\nconfig: add crossOriginAttribute config option (1e465b1)\nconfig: Call debug log methods after setting the loglevel based upon config/cli-options. (a340dae)\nconfig: Call debug log methods after setting the loglevel based upon config/cli-options. (99fd3f0)\nconfig: corrects spelling in example config template (9fafc60)\nconfig: Default remaining client options if any are set (632dd5e), closes #961\nconfig: Error when browers option isn't array (b695460)\nconfig: Log the final config just before use. (#3041) (05dd09a)\nconfig: Retry install with appveyor-retry.   (17d5791)\nconfig: Workaround npm 5.4 windows bug (ec47d81)\ncontext: Updated postMessage listener to stop validating non-Karma messages (306e565)\ndebug-runner: support asynchronous tests in the debug runner (a36f3eb), closes #2811\ndeps: freeze socket.io version (73e300d)\ndeps: Update dependencies (b9a4ce9), closes #1410\ndeps: Update log4js in package.json (#2996) (667b47e)\ndeps: update socket.io to version 2.0.3. (3b7b019), closes #2821 #2777\ndeps: Upgrade connect 3. (b490985), closes #1410\ndocs: fix stopper.stop wrong variable name. closes #2244 (0745a00)\ndocs: Remove mention of pre 1.0.0 version (#3010) (6847ca0)\neslint: Fix formatting for the new ESLint 1.8.0 (dc1bbab)\nexecutor: ensure run_complete is emitted last (9c894f9), closes #2210\nfile_list: follow symlinks (ee26748)\nfile_list: Incorrect response after remove and add file (0dbc020)\nfile-list: always use file from first matcher (74bfdf3)\nfile-list: Ensure autowatchDelay is working (0f33268), closes #1520\nfile-list: Ensure autowatchDelay is working. (655599a), closes #1520\nfile-list: Ensure files are sorted and unique (9dc5f8b), closes #1498 #1499\nfile-list: ensure patterns are comparable (4d1bf3e), closes #2194\nfile-list: Normalize glob patterns (fb841a7), closes #1494\nfile-list: refresh resolves before 'file_list_modified' event (65f1eca), closes #1550\nfile-list: Stop polluting global environment with core-js (0988022)\nfile-list: Use correct find function (4cfaae9)\nfile-list: use lodash find() (3bd15a7), closes #1533\nfile-list: Use modified throttle instead of debounce (cb2aafb), closes #1545\nfiles: Ignore included:false pattern (db42a7f), closes #1530\nflaky-test: Add time to beforeEach() to allow plugins to load on first pass. (#3025) (31d9a08)\nhelper: Ensure browser detection is handled in the unkown case (9328f67)\nhelper: Patched replaceWinPath from choking on null values (caa4d21)\ninit: fix test-main.(js/coffee) generation (d8521ef), closes #1120 #896\ninit: Make the requirejs config template normalize paths (54dcce3), closes /github.com/karma-runner/karma/issues/513#issuecomment-48616784\nkarma: Escape quotes for file names. This fixes issue #1876. (9dff3f3)\nlauncher: Allow dynamic browser launches (2b7d703)\nlauncher: Continue with exit when SIGKILL fails (1eaccb4)\nlauncher: exclude concurrent browser on launcher restart (96f8f14), closes #2280\nlauncher: send sigkill on timeout when force killing (c615c1f)\nlaunchers: Listen to the correct error event. (45a6922)\nlint: exempt built files (#3024) (bc9acd3)\nlogging: Summarize SKIPPED tests in debug.html. (a01100f), closes #1111\nlogging: Upgrade to log4js 2.x API. (#2868) (f6f8707), closes #2858\nmiddleware: Actually serve the favicon. (f12db63)\nmiddleware: add file type to absolute urls  (bd1f799)\nmiddleware: avoid using deprecated Buffer API (018e6be), closes /nodejs.org/api/deprecations.html#deprecations_dep0005\nmiddleware: change to use vanilla for loop (ac62cc0), closes #2671\nmiddleware: Correct spelling of middleware logger name (9e9e7e6)\nmiddleware: does not work with mootools (#2591) (2685e13)\nmiddleware: ensure Range headers adhere more closely to RFC 2616 (8b1b4b1), closes #2310\nmiddleware: fix WARN log when passing undefined error handler to promise.then (20b87de), closes #2227\nmiddleware: Inject config.urlRoot. (569ca0e), closes #1516\nmiddleware: update Buffer usage (3d94b8c)\npackage.json: sinon-chai 2.13 is not compatible with sinon 4.x (#2977) (e095b05)\npreprocessor: Better handling of failing preprocessors (a2376b8), closes #1521\npreprocessor: calculate sha1 on content returned from a preprocessor (6cf7955), closes #1204\npreprocessor: Directory names with dots (4b5e094)\npreprocessor: Improve handling of failed preprocessors (e726d1c), closes #1521\npreprocessor: Lookup patterns once invoked (00a2781), closes #1340\npreprocessor: renamed handeFile to readFileCallback (92a8c81)\npreprocessor: retry if fs.readFile fails (4b60513)\npreprocessor: Throw error if can't open file (bb4edde)\npreprocessor: throw if retry fails (2789bf5)\npreprocessor: treat *.gz files as binary (1b56932)\npreprocessor: treat *.swf files as binary (62d7d38)\npreprocessor: treat *.tgz, *.tbz2, *.txz & *.xz as binary (7b64244)\nproxy: More useful proxyError log message (96640a7)\nproxy: Pass protocol in target object to enable https requests (142db90)\nproxy: Port mixup and infinite loop (05616a2), closes #1987\nproxy: proxy to correct port (a483636)\nreporter: Better handling of non string error (82f1c12), closes #1969 #1988\nreporter: Disable source maps for URLs without line number (2080221), closes #1274\nreporter: do not allow URL domains to span new lines (2c13404)\nreporter: Enable sourcemaps for errors that without column # (086a542)\nreporter: Ensure errors use the source map. (0407a22), closes #1495\nreporter: Fix issue causing error stack not to be parsed correctly (ac4e1a9), closes #2930\nreporter: inject correct config option (80bd726)\nreporter: keep users exact formatError result (17c2c43)\nreporter: preserve base/absolute word in error (b3798df)\nreporter: remove console.log (b4e3694)\nreporter: show file path correctly when urlRoot specified (34dc7d3), closes #2897\nreporter: sourcemap not working in windows (a9516af), closes #1200\nreporter: strip only hostname/port (fbbeccf), closes #2209\nreporters:  cannot read property map of undefined  (305df2c), closes #1662\nreporters: Fix results not being reported (6303566)\nreporters: Revert the backwards-incompatible log priority order changes (316b944), closes #2582\nreporters: Throwing error without loosing stack trace (8a515ae)\nrunner: Fix typo in CSS class name for .idle (fc5a7ce)\nrunner: Make process kill timeout configurable (ffaa054), closes #2447\nrunner: Make process kill timeout configurable - Fix Build (a128e5c), closes #2447\nrunner: Merge config.client.args with client.args provided by run (91de383), closes #1746\nrunner: Remove null characters from terminal output (3481500), closes #1343\nrunner: Test process kill timeout config (99a1d48), closes #2447\nrunner: Wait for file list refresh to finish before running (94cddc0)\nserver: check available port before start server (fix #1476, fix #3011) (a19b8d4)\nserver: complete acknowledgment (f4144b0)\nserver: exit with code 1 when failing due to missing browser (86e2ef2), closes #2403\nserver: Force clients disconnect on Windows (28239f4), closes #1109\nserver: Handle new socket.io internal format. (3ab78d6), closes #1782\nserver: log browser messages to the terminal (d1f924c), closes #2187\nserver: Remove Socket.IO listeners (c3f05ef), closes #2980\nserver: Start webserver and browsers after preprocessing completed (e0d2d23)\nserver: switch to sync write (6ec74ee)\nserver: Update timers for limited execution environments (9cfc1cd), closes #1519\nsocket.io: Force 0.9.16 which works with Chrome (840ee5f)\nstringify: guard Symobl from IE (#3023) (538081c)\ninvalid characters in the headers on Node 5.6.0 (152337d)\ntest: locale in Expire header (db04cf0), closes #1741\ntest: update bundleResource test timeout (#3038) (d6060d4)\ntravis_ci: converted node versions as string (25ee6fc)\nfilter browser logging by level of LOG (89a7a1c), closes #2228\nupdater: Fix time unit on screen display from 'ms' to 'seconds'. (f39dd04)\na missed argument in a debug message (#3009) (af8c6e4)\nAdd crossorigin attribute to script HTML tags (5690ffe)\nadd emscripten memory image as binary suffix (f6b2b56)\ncall .resume to prevent browser output streams filling up (107cd02)\ncatch exceptions from SourceMapConsumer (5d42e64)\nChange timing on test (0cb6204)\nignore jsVersion configuration property in Firefox 59+  (2694d54), closes #2957\nmake window.parent.karma available in debugged context (3e7eaeb)\nMerge config child nodes on config.set() (65b688a), closes karma-runner/grunt-karma#165 karma-runner/grunt-karma#166\nRemove inadvertently added dependency to mock-fs (ad5f6b5)\nremove support of jsVersion configuration property (#3002) (2bb4e36), closes #2911\nrestore backward compatibility for karma@0.13 (648b357)\nSafeguard IE against console.log (0b5ff8f), closes #1209\nSetting default value for config in runner and stopper (414db89)\nSwitch all requires from fs to graceful-fs (1e21aaa)\nupgrade http-proxy module for bug fixes (09c75fe)\nUpgrade socket.io to 1.4.5 (2f51a9f)\nUTs: Correct proxy listeners expectation (af9c84a)\nwatcher: Close file watchers on exit event (7181025)\nwatcher: handle paths on Windows (6164d86)\nweb-server: Allow karma to run in project which path contains HTML URL encoded characters. Karma fails on Jenkins when it checks out branches containing '/' as it converts it to '%2F'. Fixes  errors seen on #1751, #61. (da1930f)\nWrap url.parse to always return an object for query property (72452e9), closes #1182\nweb-server: cache static files (eb5bd53)\nweb-server: Correctly update filesPromise on files updated (32eec8d)\nweb-server: Ensure filesPromise is always resolvable (892fa89), closes #1544\nweb-server: Restart disconnected browser in non-singleRun mode. (f6587dc)\nweb-server: Update config on every request (8ef475f), closes #1972\n\nCode Refactoring\n\ncontext: Future-proofed context.html and debug.html for modularity (43f6a1a), closes #1984\n\nFeatures\n\nAdd stopper to the public API (3d4fa00)\nadd an option to run the tests by dynamically loading test scripts without iframe (aa42c41)\nAdd engine support for iojs@3. (eb1c8d2)\nAdd possibility to stop a karma server (66ae80b)\nadd support for node 6 (0b8dc2c)\nadd support for node@7 (eb407ab), closes #2559\nadding support for before middleware (51b4206)\nAllow custom browser names (60ba85f)\nallow frameworks to add preprocessors (f6f5eec)\nAllow frameworks to inject middleware (d972f3d)\nbetter string representation of errors (c9e1ca9)\ndeprecate helper._ (5c6b151), closes #1812\nDo not fail on empty test suite (8004763), closes #926\ndrop core-js and babel where possible (60dfc5c)\nFail on launcher-, reporter-, plugin-, or preprocessor-load errors. (fca930e), closes #855\nserve ePub as binary files (82ed0c6)\napi: add constants to the public api (ee10977), closes #2361\napi: expose config.parseConfig on the public api (7d2c1ae)\nbrowser: add browser_info event (09ac7d7), closes #2192\nbrowser: Emit a browser error when a disconnect occurs. (e36ba6c)\nci: disable testing of node versions below 4 (ec92ea9)\ncli: Add .config/karma.conf.js to the default lookup path (49bf1aa), closes #1387\ncli: Better CLI args validation (73d31c2), closes #603\ncli: Warn on commands with underscores. (0801a7f)\nclient: capture confirm & prompt  (3a618b3), closes #694\nclient: log global error stack trace  (523d608), closes #2812\nconfig: Add forceJSONP option (8627d67)\nconfig: Add a clearContext config to prevent clearing of context. (5fc8ee7)\nconfig: Add configuration for adding javascript version. (0239c75), closes #1719\nconfig: add nocache option for file patterns (6ef7e7b)\nconfig: add restartOnFileChange option (1082f35)\nconfig: add support for TypeScript (6445310)\nconfig: allow config to be a default export (9976dce)\nconfig: Allow custom context and debug files, with feature test and some specs. (225c0e5)\nconfig: allow to use newer versions of CoffeeScript (c1fcf42)\nconfig: mime config option support (d562383), closes #1735\nconfig: Pass CLI arguments to karma.config.js. (70cf903), closes #1561\nconfig: remove polling usage (b0f41c7), closes #2669\ndeps: add support for node@8 (ea32194), closes #2754\ndeps: add support for node@8 (7feaee3), closes #2754\ndeps: update socket.io to 1.7.4 to avoid issue with ws@1.1.2 (264442b), closes #2593\nfile-list: Upgrade bluebird to v.3 (f5c252f)\nfile-list: Use glob.sync for better speed (1b65cde)\ngrunt: run check_clean before starting release. (#2978) (a3ff6c8)\ninit: install coffee-script automatically (e876db6), closes #1152\nlauncher: Add concurrency limit (1741deb), closes #1465\nlauncher: Enable specification of retry-limit (cc5547c), closes #1126\nlauncher: output stderr for failing launchers (7d33398)\nlauncher: trim whitespace in browser name (334f9fb)\nlauncher: trim whitespace in browser name (871d46f)\nlogger: Add date/time stamp to log output (4a59443)\nlogger: Add date/time stamp to log output (a4b5cdd)\nlogging: Add colors and log-level options to run-command (9d4e234), closes #1067\nlogging: Add colors and log-level options to run-command (2d29165), closes #1067\nlogging: Add logging-setup function (d14bd62)\nlogging: Send color option to server (486c4f3), closes #1067\nlogging: Send color option to server (287d0db), closes #1067\nmiddleware: added manual file type option (0330cd1), closes #2824\npreprocessor: add 'mp3' and 'ogg' as binary formats to avoid media corruption in the browser. (65a0767)\npreprocessor: Capital letters in binary files extenstions (1688689), closes #1508\npreprocessor: Instantiate preprocessors early to avoid race conditions (8a9c8c7)\npreprocessors: if a file matches multiple preprocessor patterns, intelligently merge the list of preprocessors, deduping and trying to preserve the order (59642a6)\nproxy: add proxy events to config  (f5d99fb)\nproxy: Allow proxies configuration to be an object (ad94356)\nproxy: Allow to configure changeOrigin option of http-proxy (ae05ea4), closes #1729\nreporter: add config formatError function  (98a4fbf), closes #2119\nreporter: cache SourceMapConsumer (fe6ed7e)\nreporter: improve source map handling and reporting. (cf0be47)\nreporter: Replace way-too-big memoizee with a trivial solution. (58340b1)\nreporter: Replace way-too-big memoizee with a trivial solution. (d926fe3)\nreporters: Look for color-reporter (fd9262d)\nrunner: Buffer stdout and stderr for output when errors occur (460d423), closes karma-runner/karma#2663\nrunner: provide error code on 'ECONNREFUSED' callback (439bddb)\nrunner: serve context in JSON format for JS-only environments (189feff)\nrunner: Use favicon in static runner pages (6cded4f)\nserver: add 'listening' event with port number (82cd0df)\nserver: add listen address option so that IPv6 and loopback interfaces can be used (8e5bee6), closes #2477\nserver: Add public api to force a file list refresh. (b3c462a)\nserver: improve public api (82cbbad), closes #1037 #1482 #1467\nstatic: Support media queries (94e7b50)\nstopper: Enable programically detached server (f10fd81)\nwatcher: Allow using braces in watcher (e046379), closes #1249\nwatcher: Debounce autoWatchBatchDelay (2f8c049), closes #2331\nweb-server: add support for custom headers in files served (4301bea)\nweb-server: allow injection of custom middleware. (2e963c3), closes #1612\nupdate of supported node versions (e79463b)\nupgrade dependencies to their latest versions (08242a0)\nweb-server: allow overriding of default http module (1e7514d), closes #2424\nweb-server: Allow Range headers in web server. (a567b6f), closes #2140\nweb-server: Allow running on https (1696c78)\nUpgrade to socket.io 1.3 (603872c), closes #1257 #1258 #1220\nupstreamProxy config option to deal with proxies that adjust the base path, etc (55755e4)\nweb-server: Serve all files under urlRoot (1319b32)\nweb-server: Use isbinaryfile for binary file detection (f938a8e), closes #1070\n\nReverts\n\n\"Merge pull request #1791 from budde377/feature-adding-no-colors-to-run-command\" (96ebdc4), closes #1894 #1895\n\nBREAKING CHANGES\n\ncontext: Our context.html and debug.html structures have changed to lean on context.js and debug.js.\nserver: The public api interface has changed to a constructor form. To upgrade\nchange\n\nvar server = require(\u2018karma\u2019).server\nserver.start(config, done)\nto\nvar Server = require(\u2018karma\u2019).Server\nvar server = new Server(config, done)\nserver.start()\n\n\nCommits\nThe new version differs by 55 commits.\n\n333e7d4 chore: release v2.0.3\ne0377d0 chore: update contributors\na32ba27 refactor(server): Provide file-service handlers in the root injector. (#3042)\nc1eb236 fix(BaseReporter): log message correctly with just one browser (#3045)\na19b8d4 fix(server): check available port before start server (fix #1476, fix #3011)\n05dd09a fix(config): Log the final config just before use. (#3041)\n0dc8ea4 refactor: unify style of functions declarations\n5272aa3 refactor(web-server): refactor lib/web-server to be more ES6 (#3034)\nf47d901 refactor(middleware): update lib/middleware/source_files to ES6\nd6060d4 fix(test): update bundleResource test timeout (#3038)\n558e2f0 refactor: update lib/plugin.js to ES6 (#3036)\ne8ca4ec refactor: update lib/runner to ES6 (#3033)\n011a90c refactor(server): refactor bundleResource in lib/server.js (#3029)\nc1a9567 refactor(middleware): update middleware/common to ES6 (#3028)\n31d9a08 fix(flaky-test): Add time to beforeEach() to allow plugins to load on first pass. (#3025)\n\nThere are 55 commits in total.\nSee the full diff\n\n. ## Version 2.0.4 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv2.0.4\nBug Fixes\n\ndeps: remove babel-core and babel call in wallaby. (#3044) (7da8ca0)\nevents: bind emitters with for..in. (#3059) (b99f03f), closes #3057\nlauncher: Only markCaptured browsers that are launched. (#3047) (f8f3ebc)\nserver: actually call stert(). (#3062) (40d836a)\nserver: Resurrect static function Server.start() lost in 2.0.3 (#3055) (c88ebc6)\n\n\n\nCommits\nThe new version differs by 9 commits.\n\ndee3615 chore: release v2.0.4\nf61c936 chore: update contributors\n40d836a fix(server): actually call stert(). (#3062)\n414b84c refactor(file-list): clean lib/file-list.js\n7da8ca0 fix(deps): remove babel-core and babel call in wallaby. (#3044)\nc88ebc6 fix(server): Resurrect static function Server.start() lost in 2.0.3 (#3055)\nb99f03f fix(events): bind emitters with for..in. (#3059)\nab3c0e3 refactor(temp-dir): update lib/temp_dir.js to ES6 (#3049)\nf8f3ebc fix(launcher): Only markCaptured browsers that are launched. (#3047)\n\nSee the full diff\n\n. After pinning to 6.9.0 your tests are still failing. The reported issue might not affect your project. These imprecisions are caused by inconsistent test results.. ## Version 6.9.0 just got published. \nYour tests are still failing with this version. Compare the changes \ud83d\udea8 \n\nRelease Notes\nv6.9.0\n\n6.9.0 (2018-04-20)\nFeatures\n\nQueue playback events when the playback rate is zero and we are seeking (#5061) (eaf3c98), closes #5024\n\nBug Fixes\n\nfire sourceset on initial source append (#5038) (#5072) (00e7f7b)\nlet the tech preload auto on its own (#4861) (#5065) (c04dac4), closes #4660\noptions.id is now applied correctly to the player dom element (#5090) (dd45dc0), closes #5088\nwait till play event to listen for user activity (#5093) (9f8ce2d), closes #5076\ntime-display: Use formatTime for a consistent default instead of hardcoded string (#5055) (363af84)\n\nCode Refactoring\n\nmove seekbar event handler bindings into a function (#5097) (7c3213c)\nmove sourceset code out of tech (#5049) (e2b9d58)\n\nDocumentation\n\ndebugging: fix markup typo (#5086) (8c77aa0)\nguides: add debugging section to index (#5100) (20546d3)\n\nTests\n\nfix queue playing events test for ie8 (for real this time) (#5110) (5dec1a0)\nfix queued events test with playbackrate in IE8 (#5105) (c4a05eb)\n\n\n\nCommits\nThe new version differs by 13 commits.\n\n0f1268e 6.9.0\n363af84 fix(time-display): Use formatTime for a consistent default instead of hardcoded string (#5055)\n8c77aa0 docs(debugging): fix markup typo (#5086)\n20546d3 docs(guides): add debugging section to index (#5100)\n9f8ce2d fix: wait till play event to listen for user activity (#5093)\n7c3213c refactor: move seekbar event handler bindings into a function (#5097)\ndd45dc0 fix: options.id is now applied correctly to the player dom element (#5090)\n5dec1a0 test: fix queue playing events test for ie8 (for real this time) (#5110)\nc4a05eb test: fix queued events test with playbackrate in IE8 (#5105)\neaf3c98 feat: Queue playback events when the playback rate is zero and we are seeking (#5061)\n00e7f7b fix: fire sourceset on initial source append (#5038) (#5072)\nc04dac4 fix: let the tech preload auto on its own (#4861) (#5065)\ne2b9d58 refactor: move sourceset code out of tech (#5049)\n\nSee the full diff\n\n. ## Version 6.10.1 just got published. \nYour tests are passing again with this version. Explicitly upgrade to this version \ud83d\ude80 \n\nRelease Notes\nv6.10.1\n\n6.10.1 (2018-05-17)\nBug Fixes\n\ncheck for el before resetSourceSet (#5177) (7746bae)\n\n\n\nCommits\nThe new version differs by 12 commits.\n\n869d607 6.10.1\n2d0c7ee tests: do not throw on tech/player dispose (#5180)\n7746bae fix: check for el before resetSourceSet (#5177)\n9450216 6.10.0\ne1d26d8 fix: sourceset and browser behavior inconsistencies from (#5054) as (#5162)\n592c255 feat: add 'autoSetup' option (#5123)\n79fed25 fix: Reduce the multiple-announcement by screen readers of the new name of a button when its text label changes. (#5158)\nbaa6b56 fix(time-display): restore hidden label text for screen readers. (#5157)\n9607712 fix: Remove unnecessary ARIA role on the Control Bar. (#5154)\ne076cde fix: Remove spaces from element IDs and ARIA attributes in the Captions Settings Dialog (#5153)\nc654c7d feat: copy properties from  to the media el from (#5039) as (#5163)\n72f84d5 feat: update the players source cache on sourceset from (#5040) as (#5156)\n\nSee the full diff\n\n. ## Version 7.0.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv7.0.3\n\n7.0.3 (2018-05-23)\nBug Fixes\n\nplayer: video-js embed missing video-js class (#5194) (954f3d9), closes #5041 videojs/http-streaming#100\n\n\n\nCommits\nThe new version differs by 2 commits.\n\n6f8597f 7.0.3\n954f3d9 fix(player): video-js embed missing video-js class (#5194)\n\nSee the full diff\n\n. ",
    "marsalRBX": "I have same issue, any thought?. ",
    "int618": "see #600 . ",
    "iseed12": "In addition:\nBy an experienced test, I found out that the UglifyJsPlugin shutdown is working on the production server.\nhttp://joxi.ru/L21v9g6f8Q8x5A. ",
    "daliwell": "Anyone any idea with this?\nAs far as I can tell, this is a problem with contrib-hls.\nThe fact this is on Safari and Edge makes me think that this issue reported against Edge might actually be a problem with contrib-hls, not the Edge browser: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/14600417/. Hey @gesinger - thanks for looking into this. Anything I can do to help, please give me a yell. You can also reach me on the Video.js slack.. ",
    "ecraven": "Same problem with v5.14.0, this prevents me from upgrading :-/. ",
    "earl3s": "Thank you.  Very appreciated.. @gesinger wondering if you have an update on the bug?. Hey guys, checking back one more time.  This is causing some pretty wide spread problems across many players that use VideoJS.  Hoping you might have an update.. We'll look at this.  We had consistent playback problems with those id3 headers at the beginning of each segment.  It was causing audio blips in VLC player.  This stream also plays back without error in JWPlayer.  We will check on this though and get back to you.  \nThanks for looking!. ",
    "dotungvp1994": "@gesinger: I have same problem with combined segment type? How to fix error?. ",
    "damianxd": "I can confirm, I have the same problem. Yeah, that's because I gave up on videojs-contrib-hls, I'm not using it anymore, so it works without it.. ",
    "mksasi": "It works when I specify the source of the stream hardcoded. But it fails when setting the withCredentials and dynamically setting the src.\nWorking\n<video id=\"clipaudio\" crossorigin=\"anonymous\" class=\"video-js vjs-default-skin vjs-big-play-centered vjs-16-9\" preload=\"auto\" controls></video>\n<source src=\"https://xxxxxxxxxxxx.amazonaws.com/test-audio/aa10a5e5-0d88-dac7-400f-f20a7dce6841.m3u8\" type=\"application/x-mpegURL\">\nNot working\n<video id=\"clipaudio\" class=\"video-js vjs-default-skin vjs-big-play-centered vjs-16-9\" preload=\"auto\" controls>\n</video>\nWhen setting the source dynamically it fails, but the XHR request gets succeeded. . Finally, got it working. It was an configuration issue at AWS S3 where I have to add the CORS configuration. This fixed the issue and I can play stream with subtitle in Angular 5.2.8.. ",
    "Hirbod": "I would also appreciate a clean communication on this. Catching Errorevents on HLS its a pain... @gkatsev thanks for your answer. Do I have to set this option inside { html: hls{} } ?. ",
    "miyakoj": "We decided to create a native desktop solution (using C# and Vlc.DotNet) because both Chrome and Firefox continuously crashed when playing multiple videos simultaneously. Thank you for following up anyway.. ",
    "benwilber": "I'm happy to submit a PR to correct this issue, I just want confirmation that it would be welcome since it looks like the last PR that addressed this issue was declined in favor of deferring to the browser cache (which is incorrect). @forbesjo Yes I am still interested in implementing this fix.  Unfortunately I'm not very familiar with this tech stack and have been having trouble updating the tests so that this case is properly covered.  If anybody could provide any assistance, or point me in the right direction I would appreciate it.\nThanks!. ",
    "blacktrash": "It's a showstopper for me. videojs-http-streaming unfortunately has the same issue.. ",
    "magikstm": "The suggested change in the referenced issue does make that message disappear.\nI think this issue can be closed.. ",
    "hector": "Thanks for the suggestion!\nStill, it does not make it work :(\nhttp://jsbin.com/rijezonira/1/edit?html,output. Could someone at least tell me if this is a problem of my m3u8 or videojs-contrib-hls behaviour? If it is the latter I can try to dig into the code.. I have been able to make this work with the new version 7 of video.js which uses https://github.com/videojs/http-streaming instead of videojs-contrib-hls.. I do it like this:\njavascript\n// Change audio track\nconst audioTrack = player.audioTracks().tracks_.find(track => track.language === language);\nif (audioTrack) audioTrack.enabled = true;\nI suggest you first pause the video in case it is playing, then play it again.. This issue was about having videojs play multiple audios (e.g. with different languages) without a video. Not about different qualities for the same audio. That's a different thing, I don't know how to do what you ask because I use a single quality in my audios.. ",
    "murtaz53": "@hector : can you share the solution here (i.e jsfiddle)? how you have switch audio quality using default/autoselect? I have written as below, but it's not working. \nplayer.tech_.hls.masterPlaylistController_.mediaTypes_.AUDIO.groups[name][0].autoselect=true\nplayer.tech_.hls.masterPlaylistController_.mediaTypes_.AUDIO.groups[name][0].default=true\n. @hector : I am asking about audio quality not audio track. I have 2 audio quality/group i.e stereo and surround. how to switch quality stereo/surround. I have already handled audio track switch i.e english and dubbing.\nsee the below link there is audio quality option. I am talking about it.\nhttps://bitmovin.com/demos/stream-test?format=hls&manifest=https%3A%2F%2Fbitdash-a.akamaihd.net%2Fcontent%2Fsintel%2Fhls%2Fplaylist.m3u8\n. ok thanks hector. @heff : can you help?\n. @gkatsev : I have open a new detailed issue about the problem #1450 . @gesinger : I already have implemented above for audio tracks. I am searching about switching audio quality/group (for example stereo, surround).. @gkatsev : can you help please?\n. ok thanks for reply.\n. ",
    "savroff": "@cf23318 hey if you tried to load new src dynamically, then you should do player.reset() first.  Then this error will not appear again. ",
    "wowcut": "I am getting this error not with setting a new src dynamically, so I am not replacing an old src, but with the initial use of player.src.\nI have basically just this code:\nvar video = videojs(player_element, player_options).ready(function(){\n  player = this;\n  player.src([array with multiple sources...]);\n }); // player ready\nand this error is triggered. \nI would like to ask for reopening this issue, as this is not resolved. \nQuestion: where should I put the player.reset() call? I put it just before player.src but the error still occurs. \nSome more details: \nThis error occurs not with this url:\nhttp://d2zihajmogu5jn.cloudfront.net/bipbop-advanced/bipbop_16x9_variant.m3u8\nBut it happens with a live stream url - in this case generated by a wowza server. The stream plays fine in VLC and Chromium, even with IE11 - this error only shows up in Firefox. \nBTW the stream sometimes plays and sometimes not (just Firefox) - the error is printed to console every time, but the stream does not play always - not playing the stream we see the spinner and no chunks are loaded. There seems to be some randomness involved - however, the error is always there, even when the stream is playing.\n. This same error also happens with videojs-7.3.0 I just checked. . ",
    "Snowbell92": "I am getting the same error too, in live streams. The only difference is that I have a pre-roll ad, and the stream does not autoplay if ad is skipped or finished. the error is present in the console every time, but my stream also plays just fine. \nMy code is almost identical to @wowcut , so not posting it here. \nNote: I am using the updated videojs-http-streaming plugin and videojs 6.8.0. . ",
    "ldayananda": "These are just initial questions to help me understand the chosen strategy a little better:\n\nMake goalBufferLength, maxGoalBufferLength, and backBufferLength getters+setters on the master playlist controller, and pass them through to the segment loaders\n\nRather than have this be getters/setters on the master playlist controller, these could just be settings/options passed into the master playlist controller, then passed down to and modified on the segment loaders. \n\nSet the aforementioned values when we get a QuotaExceededError based on the amount of time and data in the buffers when it occurs\n\nWhy does the time matter if we are also using the amount of data in the buffer?\n\ncheckBuffer_ checks to see if we might bust the buffer, and trims the back buffer and returns null if that's the case\n\nSeems like trimming the back buffer should be done in another method outside checkBuffer_\n\nSlice up the segment into 5MB chunks if we get a QuotaExceededError on the first append\n\nIf I understood correctly, we are appending and removing whole segments in this PR right? Why is it needed to split up the segment into chunks?\n\nAdd functions for calculating the min and max bytes in the buffer based on segment metadata cues (playhead is rarely at a segment boundary so we need both min and max functions for maximum safety)\n\nIs there a specific use for the min bytes in the buffer? Would the ideal be to play it safe and always assume the max is in the buffer?\n\nAdd function for removing non-buffered segment metadata cues\n\nI thought this exists in contrib-media-sources?\n\nIn the SourceUpdater, when we get a QuotaExceededError, move the pendingCallback to another variable (deferredCallback) and null out pendingCallback so that we can process a remove() and try to reappend the segment that caused the error\n\nReading this naively, it seems like the remove and reappend attempt can be done before the original pendingCallback is run. Is there something preventing this?. >If I understand correctly, you're saying that they could be static for a single playback? If so, then maxGoalBufferLength could be a statically configured value (and essentially is that), but goalBufferLength and backBufferLength must be dynamic to support dynamic buffer sizes.\nheh, sorry I definitely was not being specific enough in my last comment. I think we're on the same page in so far as the need to dynamically change the buffer sizes. What I meant was that instead of have getters/setters for the goalBufferLength, maxGoalBufferLength, and backBufferLength at the masterPlaylistController level, they could be getters/setters at the segmentLoader level. That would allow different values for different loader types, though admittedly I don't see an immediate need for that level of flexibility. \n\nThat's true that data is the important factor here, but the underlying MSE functions (like removing from the buffer) work with time, not data. So we need at least rough estimations of the equivalent time.\n\nOh interesting, didn't actually realize that remove used times \ud83e\udd14 I suppose a potential alternative would be to try and match a TimeRanges object returned from buffered(). Not sure if that would make a significant difference though, depending on how remove actually goes about removing data from a sourceBuffer. \n\nIt is. checkBuffer_ is simply an algorithm to see whether or not a new segment should be downloaded, based on what is currently in the buffer. In this case, the answer is no, but it also tries to free up stuff in the back buffer since the check for \"do we have more than goalBufferLength in the buffer?\" returns false.\n\nWhat I meant was that the order of execution could be:\n- trim back buffer if needed and adjust other buffers to match\n- checkBuffer_ to see if we need to download the next segment\nIn this scenario the functions of (i) trimming the back buffer and (ii) checking if we should download the next segment are clearly separated. \n\nAs you'll see in the code, the way things work out, in certain situations the safest thing to do is take the max, and in other situations the safest thing to do is take the min.\n\nInteresting \ud83d\udd0d \n\nIt removes all cues within a time range. removeNonBufferedSegmentCues loops through the buffers and removes cues wholly outside the buffered data. It could use removeCuesFromTrack for the actual removal, but you would still need to determine the time ranges to remove.\n\nGotcha\n\nCan you clarify what you mean? Every append has a callback that needs to be run after the append succeeds. If the buffer is full, we need to remove data from the buffer, then append the original data to the buffer, then run the original callback. However, since the SourceUpdater needs to act like an abstraction of a native SourceBuffer, the SegmentLoader needs to make sure that sourceBuffer.updating === false, otherwise any remove or append operations will fail. In SourceUpdater, updating will be true if pendingCallback_ is not null. I experimented with other ways of having updating be false, but I could never get them working.\n\nInteresting \ud83e\udd14 Sounds like you hit a wall with how the code is currently setup. I'll have to take a more in-depth look today to see if there's another way to do this that doesn't involve nulling out pendingCallback_. I'll let you know if I come up with something half-usable \ud83d\ude04 . > If you'd like I can try pushing them down to the SegmentLoader. This code did go through several heavy rewrites and redesigns, so it's entirely possible that the requirements at the time are no longer needed.\nLet's hold off until we get some of the comments around the getter/setter methods resolved, maybe there's just confusion on my part on how this all connects together \ud83d\udc4d \n\nIt's annoying, but everything uses time, except for the error which is triggered by bytes.\n\nYeah, now that I've seen the rest of the code it wouldn't make sense to do things differently just for this part of the code \ud83d\udc4d \n\nThere is kind of an open question to me, here, which is how we should prioritize the various goals (and thus how/when we should trim/not download). For instance, say you've got a back buffer goal of 10, a forward buffer goal of 30s, and GOPs are every 2s. Imagine that your forward buffer falls below 30s, but you see that the next segment will burst your buffer. Should slice a couple GOPs off your back buffer, even if it brings it down to 6s? Or should you just wait until you can download that segment and not trim off any more than 10s?\n\nHmm, this is a good question. Typically, I would say that we'd want to prioritize the forward buffer(to allow smoother rendition switches) but that choice could be potentially harmful when working with very large segments. Going to bring this to other maintainers on Monday too!\n\nThat is 100% how I would describe it, yes \ud83d\ude05\n\n\ud83d\ude06 . So I noticed a few things while testing this:\n1\ufe0f\u20e3  safeBackBufferTrimTime can return negative numbers \ud83d\ude2d \n  - the else case can be negative when currentTime is less than backBufferLength. \n2\ufe0f\u20e3  Should timeupdateHandler be turned off once we call remove? That's the earliest point that we can do it, we don't want to run remove multiple times for the same values. Currently it's possible that we'll call remove while a remove is in process.\n3\ufe0f\u20e3 It would be nice to have helpers in MPC for forwardBufferLength (separate from goalBL) and backBufferLength that just tell you exactly how many seconds are in the buffer ahead of and behind the playhead(it returns a static value and is a general convenience method)\nforwardBufferLength = () => buffered.end(last) - currentTime\nbackBufferLength = () => currentTime - buffered.start(first)\n4\ufe0f\u20e3 A couple different observations on adjustBuffers():\n\nFor the usage of adjustBuffers in checkBuffer_ I think that this is actually not useful as trimBackBuffer should be ensuring that the forwardBuffer is prioritized. If it is not doing that, then we have an issue with how we are calculating safeBackBufferTrimTime. It's likely that we are \"seeing more back buffer than forward buffer\" because we are using the old backBuffered time and we should wait for trimming to be complete via updateend before checking the buffered times again anyway.\nWhen we adjustBuffers we don't actually look at how much is actually in the backBuffer. As far as I understand, backBufferLength is an actual value in the buffer rather than a goal so this doesn't seem correct. backBufferLength should reflect the time in the buffer behind the playhead.\nHaving the adjustBuffers event seems undesirable since I believe we want to adjust buffers after removing the appropriate amount of back buffer?  Either way, having adjustBuffers() be called more clearly either before or after handleBufferMaxed would be good.\n\n5\ufe0f\u20e3 For minBufferedBytes at least, it seems to be used in 2 ways:\ni. to calculate the min possible bytes in the buffer\nii. to figure out how many bytes might be in a range of buffered time: https://github.com/squarebracket/videojs-contrib-hls/blob/79f53fed214a241df7e02801fb52deb1ca662ce1/src/segment-loader.js#L1369. \nI think it would be much cleaner if there two purposes were split out into two separate methods. minBufferedBytes would be for purpose i. and another method to calculate the bytes for a time range. Maybe bytesInTimeRange(start, end).\n6\ufe0f\u20e3 This series of things happens twice in handleBufferMaxed: https://github.com/squarebracket/videojs-contrib-hls/blob/79f53fed214a241df7e02801fb52deb1ca662ce1/src/segment-loader.js#L1387-L1394\nsafeBackBufferTrimTime\nminBufferedBytes\nif you can trim off more than the segment that caused an error then\n  removeWholeSegments\nIt would be great to pull that out into another method to make it easier to read and debug.\n\nAfter looking at the code for a bit, I think that the code has portions of a couple different solutions in it(undefined browser behavior is fun!) and they just need to be unified. Here's a bit of pseudocode with a slightly different alternative to how you have things set up: \nWhen a QuotaExceededError happens:\n\nMake note of the full size of the buffer. This is the whole buffer length, not the forward buffer length or back buffer length.\nNotify the master playlist controller that the error happened, with the full number of bytes in the buffer (maxNumberOfBytes) and seconds in the buffer (maxNumberOfSeconds) so we can use this to determine the new caps for the buffer.\nTrim off as much as possible from the buffer to append the first offending segment. If that's not possible, error.\nif we were able to append the segment, continue with notifying the MPC of the maxNumberOfBytes and maxNumberOfSeconds.\nuse the maxNumberOfSeconds to determine whether we need to set a new goalBufferLength value and maxGoalBufferLength value (prioritizing having more seconds for the forward buffer than the back buffer). We only need to set a new one if the maxNumberOfSeconds is very close to or less than the current goalBufferLength value. However, we could make the goalBufferLength method return a static value of the config goalBufferLength value to ensure we don't grow over that value.\n\nWhen checking the buffer to see whether to download the next segment:\n\nif we are approaching the maxNumberOfBytes, then we need to trim more from the buffer and wait to download a new segment.\ndon't change the goalBufferLength after this if the maxNumberOfSeconds does not change.\nif we are unable to remove enough from the buffer to download a new segment, we must error, we cannot recover as the segment sizes are too large.. 2\ufe0f\u20e3 Do you know if an InvalidStateError would be bubbled up to the player?\n\n3\ufe0f\u20e3 I believe backBufferLength is new in this PR. From talking to the rest of the contributors, we should be able to rename goalBufferLength() as well since it's an internal API. It was suggested that the configuration values GOAL_BUFFER_LENGTH and MAX_GOAL_BUFFER_LENGTH not be changed for backwards compatibility. Maybe we could add deprecation warnings to the getter/setters for those values and create an issue to remind us to change them on the next major(this can be moved to VHS once contrib-hls is merged in).\n4\ufe0f\u20e3  In the case where we have a fixed buffer length(after a QuotaExceededError) I would expect that we could remove enough from the back buffer until we get larger sized segments and cannot safely remove more from the back buffer. Is that your understanding as well? Perhaps the buffer lengths need to be adjusted immediately after we detect this scenario then, to group the logic in one place.\n\nI find this extremely unlikely. In my experience the problem comes from not being able to set the back buffer less than a target duration (which is of course done since we aren't slicing on GOPs).\n\nWould be cool to get a usage event for this case.\n\nThat is actually exactly what is done, see source-updater.js. It triggers adjustBuffers then it triggers event (which is bufferMaxed).\n\nWhat I actually meant to just call adjustBuffers() in handleBufferMaxed_. The event seems to not be useful outside the bufferMaxed usecase, unless I missed another scenario.\n5\ufe0f\u20e3 I agree that this portion of the spec seems to imply that the frame eviction will occur during the execution of an append on the source buffer. If we can remove some of the buffer bounds modifications, that would be great!\nIf not, I think it would be clearer if this was removed and the contract for the function is:\njs\nminBufferedBytes(start = 0, end = Infinity) {\nwhich would set the default values, or alternatively replace with:\njs\n    if (start === undefined) {\n      start = 0;\n    }\n    if (end === undefined) {\n      end = Infinity;\n    }\njust so it's absolutely clear what case is being handled.\n6\ufe0f\u20e3 I was suggesting restructuring that bit of code so you could reuse a function:\njs\nfunction trimSegmentsForSeconds(removeToTime, bytesTried) {\n  bytesTrimmable = this.minBufferedBytes(0, removeToTime);\n  if (bytesTrimmable >= bytesTried) {\n    this.removeWholeSegments(removeToTime);\n    return true;\n   }\n   return false;\n}\nand then restructure this as:\n```js\nif (safeRemovePoint) {\n  removeToTime = safeRemovePoint;\n} else {\n  removeToTime = safeBackBufferTrimTime(this.seekable_(),\n                                         this.currentTime_(),\n                                         this.playlist_.targetDuration || 10,\n                                         this.backBufferLength_());\n}\nvar removedWholeSegment = trimSegmentsForSeconds(removeToTime, bytesTried);\nif (!removedWholeSegment) {\n  let passedSegmentBoundary = this.currentTime_() + this.playlist_.targetDuration;\n  let buffered = this.buffered_();\n  let tooCloseToBufferEnd = buffered.end(buffered.length - 1) - 2;\ntimeupdateHandler = () => {\n    let currentTime = this.currentTime_();\nif (currentTime < passedSegmentBoundary) {\n   return;\n} else if (currentTime > tooCloseToBufferEnd) {\n   this.removeWholeSegments(currentTime - this.playlist_.targetDuration);\n   return;\n}\nremoveToTime = safeBackBufferTrimTime(this.seekable_(),\n                                       currentTime,\n                                       this.playlist_.targetDuration || 10,\n                                       this.backBufferLength_());\ntrimSegmentsForSeconds(removeToTime, bytesTried);\n\n```\nwhich makes the intention of the code a little clearer. (the **whatever** is just because I changed those variable names)\n\nI think we discussed the majority of differences between my suggested algorithm and the PR out-of-band, so I'll just address some of the ones we didn't.\n\nWhy would trimming the back buffer cause maxNumberOfSeconds to change? Unless you're saying, just remove the buffer readjustment that I am doing.\n\nI think, as I mentioned earlier in this comment, the specific case that would actually require changing the goal values after making the buffer goal a static value(after QuotaExceededError) would be if the segment sizes/quality increase to a point that it requires the forward goal buffer value to decrease. I think I'm not 100% convinced yet that a back buffer goal is needed as a separate concept from \"remove x amount from the buffer\". \nThat would require some redesigning of the solution, however, and retesting so it's mostly up to you. The change you suggested in your last comment, continuing to use forwardBufferGoal as the newForwardGoal and then reducing the backBufferGoal based on what the total available buffer is, is similar to what I was trying to go for.\n\nWe only know we're screwed for sure if we've stalled AND the next segment will bust the buffer, since any advancement of the playhead may result in us being able to trim some more back buffer. We do know, though, that if we try to readjust the back buffer, and we're already at a target duration, then we're in danger.\n\nIf we aren't able to download the next segment and we're close to running out of buffer, haven't we stalled? For example if we can only fit one segment in the buffer because the segment sizes are that large.\n\nSomething I didn't express very clearly in my last comment was that there seems to be 3 strategies employed at the moment in this PR:\n\ni. break up a segment into small chucks and append the chunks. Only used as a workaround for Firefox throwing QuotaExceededErrors when the buffer won't actually be busted by the first segment.\nii. Listen to QuotaExceededErrors and remove from the back buffer to allow the segment that caused the error to be appended. \niii. Try and predict if the buffer will be busted and pre-trim the back buffer to avoid another QuotaExceededError.\n\nI wonder if we could simplify the code by whittling this down into 2 strategies, perhaps i and ii or ii and iii (where iii would be used to prevent the Firefox error). . I feel like \"next version\" isn't clear enough to say that we're deprecating this project. We should probably say something like \"Notice: this project will be deprecated and is succeeded by videojs-http-streaming\". Then also update the Status section to be deprecated rather than Stable. does this mean we'll have a total buffer length of 60? (GOAL_BUFFER_LENGTH being the forward buffer)?. Should this just be {Number}?. I think this should technically remain the same as the intention was to allow rendition switching on shorter videos (those shorter than the max low water line). Also, we should remove this TODO since we didn't actually change the value. shouldn't this be the max? Further, why is the maxGoalBufferLength changing at all?. This is part nit-pick and part functional: we should return the chosen value for this.goalBufferLength_ when setting a value because:\ni. the value input isn't necessarily the value that is being set\nii. the contract is not being fulfilled currently when passing in a value   . Similar feedback as goalBufferLength, we should return the backBufferLength_ value after we set it. is there a specific reason for this? I understood the intention of the low water line to always be less than the goalBufferLength. hmm. Ok, curious if we should consider tweaking these values, but that's just curiosity... \ud83d\ude43 . I guess there's a few ways of doing this:\n- preserve the current goal buffer length\n- preserve a specific amount of buffer  (a.k.a what you are doing)\n- remove as much as possible given the current buffer length\nIs there an advantage of the method you chose over removing (potentially) more from the buffer?. this could potentially leave us with a buffer greater than the backBufferLength passed in though, right?. seems like this is a misleading name for a time \ud83d\ude04 . Is there a way to log a warning in Safari too? I suppose it'll be more difficult to tell that the reason why frames are being dropped is due to the browser buffer though \ud83e\udd14 . if there's a reset method for the segment loaders, we should remove the event handlers there. Just in case you forgot. Should this be an ||?. I'm not sure whether the variable name bufferedBytes is misleading or the maxBufferedBytes is misleading here. Is this intended to be the largest count of bytes that we have buffered currently?. Also this means we can never increase the backBufferLength value and maxGoalBufferLength values?. this seems like a change from potentially removing partial segments to removing only whole segments. Is that accurate?. I think this is technically Closure complier syntax rather than plain JsDoc syntax. According to the docs, the way to indicate optional params with jsdoc is with [] i.e [setByteLimit]. also if this is optional, we should probably set a default value i.e setByteLimit=false. I think out of context, we might want to rephrase \"failed\" here since we're likely to forget what this means over time. why do we do this?. wouldn't forward buffer be maxGoalBufferLength - currentTime?. what do you mean by config in this variable name?. technically wouldn't this be the max of the forward buffer(already downloaded) in seconds versus the max duration in seconds for a segment(not already downloaded)? Is that a fair comparison to make for maxForwardBuffer? . why are we getting the min for a max value?. so you can never increase maxBytes?. definitely feels like we should rename goalBufferLength to be maybe something like goalForwardBufferLength. I think you should be able to use template literals  to make your life easier, but you might want to double check that gets built correctly to a string for IE support. It's a bit weird that we refer to this as backBuffer in other places but reverseBuffer here. I think consistency will help \ud83d\udc4d . We should probably rephrase this to explain what the handler does in this scenario. I don't see event.done passed along when bufferMaxed is triggered anywhere, do we still need this?. might be worth making 5000000 a constant variable. Typo QuotaExceededError. Haven't we already gotten a QuotaExceededError at this point? Why would we try to append the whole segment again?. bytesTried is initialized as the length of the segment that caused the QuotaExceededError, how is this possible?. Really need a more descriptive name here \ud83d\ude06 . this just removes the segment behind currentTime?. some of this should already be happening in the resetEverything method, I would advise moving anything that explicitly needs to be reset to there . wouldn't this just be NaN if nextSegmentSize_ is null?. I'm not sure what we are trying to do in these two lines \ud83d\ude15 . I'm not sure this name is quite accurate in terms of what it returns when you pass in arguments. Would something like getCurrentlyBufferedBytes be more accurate? . I find this sort of confusing. How/why are we adjusting the start cmpStart and cmpEnd variables here?. How is this possible?. why cue.startTime >= cmpStart - 0.1 ? Could this just be cue.startTime > cmpStart. couldn't you just call remove each cue as you decide to remove it? I think the keep flag is a bit confusing  . couldn't you just find the first cue that is outside the buffer and call remove from 0 to that cue instead of repeatedly removing from 0?. backBufferStart might work. I would be ok with backBufferTime too. \ud83d\udc4d probably fine for now . Yep, exactly . Hah, didn't realize closure-style was already being used. Ah, right that makes sense for the QuotaExceededError and maxGoalBufferLength. I do think someone naively calling goalBufferLength() will have no idea what is happening so maybe it's worth breaking this out into a separate setter for maxGoalBufferLength.  \nWhat exactly does this.goalBufferLength_ + currentTime * rate calculate? Shouldn't currentTime * rate be included in this.goalBufferLength_? And if not, maybe we should have another name for the getter portion since we're not actually returning the currently set goalBufferLength.\nA theoretical question I have is what happens if the value we pass in is less than the current goalBufferLength? Does that mean that both the goalBufferLength and maxGoalBufferLength are exactly the same? Is that ideal?. I think it's a problem in the sense that these are setters that might be used for another purpose in the future, though I agree it makes sense in the context of the QuotaExceededErrors.. So this is just a safety measure?. Gotcha, that makes sense. I'm ok with leaving things simple in this PR.\nHmm, that's a good question. I think in the past we've tried to prioritize them evenly to handle the most scenarios. Having a decent amount of back buffer helps if users are seeking backwards, and forward buffer is helpful for seeking forwards and to allow a smooth rendition switch.. I think the seekable range only really comes into play when you have a live stream with a sliding window (in other words you might be disallowed from seeking to the beginning of the live stream). To be fair, it seems unlikely that you'll have a 4K live stream \ud83d\ude06 . (bufferedBytes + this.nextSegmentSize_) >= this.maxBytes_\nSo in the above we're saying \"I'm guessing we were able to fit the whole last segment in the buffer\"(bufferedBytes) \"now see if we can fit the next one in without going over the maxBytes\"?\nIf so, I would comment over this line explaining that we're playing it safe and assuming the buffer is full to the upper bound . Right, in the context of large content it makes sense. I was just wondering if it will negatively affect smaller content that doesn't need to be conservative when removing from the back buffer \ud83e\udd14 . Ahhh, ok. I would suggest renaming maxForwardBuffer(the RHS of the min) to be networkIdealMaxForwardBuffer and maxReverseBuffer to be networkIdealMaxReverseBuffer so it's clear what choice we are making here. hehe, that's probably just because we haven't changed it yet \ud83d\ude04 . Looking at how bytesInBuffer is used in this method, I would actually name it something like lowBufferedBytesLimit. Yeah, I do think we technically want to make a distinction between forwardBuffer(what we actually have buffered ahead of currentTime) and goalForwardBuffer (the number of seconds ahead of current time we are trying to get to). Right, but tryAppend gets called afterupdateend which could be the result of appendBuffer right? Maybe this'll make sense after I look at source-updater \ud83d\udc7b . I guess I mean \"how can you trim more bytes than what you tried\" but I might have been thrown off by the variable name. I suppose what we're checking is whether we're going to fill up the whole buffer with bytesTried right? . Maybe safeDistanceFromEnd? It's a bit off though \ud83d\ude13 . Well, I guess I'd want to know why the state needs to be set to READY? That sounds like it would break other playback scenarios. What scenarios involve pendingAppend being defined but needing to be reset?\nAlso as an aside, timeupdate handlers are kind of sensitive though I haven't yet come up with a good way to do what you are trying to do \ud83e\udd14 I think I'll bring this up with the rest of the maintainers on Monday since they'll likely have suggestions. true, yeah. I assume this was for safety?. I guess we should double check that the error type is correct here right? Just in case it isn't actually a QuotaExceededError. Alternatively, I'm not sure we need to catch the error here since it's already handled in media-sources. Naive alternative suggestion(I still need to think this through again once I get to the end of the PR):\nCouldn't you pass in the pendingCallback alone(rather than done)? Then call pendingCallback after resolving the failed append? onUpdateendCallback_ would then resolve anything else in the queue?. Or another alternative would be to add a flag to onUpdateendCallback_ that would fail fast(not actually run the rest of the callbacks) while we are resolving the failed append. Then once we successfully resolve that append, we can turn the flag off and allow the onUpdateendCallback_ to continue to run normally. This might be a bit more complicated in practice though, since we're not 100% sure our next attempt to append after trimming the back buffer will work.. Going to return to reviewing the tests once the code comments are resolved \ud83d\ude04 . Agreed. Yeah, that would reduce confusion and is probably enough. Oh, I only said the last segment since we're appending full segments in here and we're using segment level info to guess how much we have in the buffer(referencing your explanation of minBufferedBytes and maxBufferedBytes).\nStill, it would be useful to have a comment over the declaration of bufferedBytes explaining that \"we're assuming the worst case amount of bytes in the buffer\" . I suppose it depends on whether the difference is noticeable \ud83e\udd14 I'll make a note to test with smaller segments with captions and seeking around a lot.. oh yes, renaming to be closer to what each variable is used for would help a lot \ud83d\udc4d . \ud83d\udcaf . I think this was me continuing to be confused by the variable names \ud83d\ude04 A comment above secondsInBuffer explaining that there's that many seconds in the buffer when a QuotaExceededError happened would help a lot . newForwardBufferGoal does the trick \ud83d\udc4d . My question to answer your question would be: is that the number of seconds we currently have buffered or what we're getting close to?. Also note to self: I should double check we can actually rename this since it's publicly facing. Ah, so we're trimming at least as much as the size of the segment that caused the QuotaExceededError. Gotcha. I wonder if this log would be a little inaccurate if we end up staying at the original maxBytes_ value. Was there are reason for using different strategies here? If the error happens after the first segment, couldn't we remove from the back buffer and then append small pieces of the next segment instead of waiting for enough space to append the whole segment?. The?. After discussing this out-of-band:\n- goalBufferLength() will return a growing number for the forward buffer goal until a QuotaExceededError is seen, at which point we'll dynamically change the forward buffer goal and max forward buffer goal to take into account the browser's max source buffer allowance\n- we can't rename goalBufferLength for backwards compatibility \n. I believe that only goalBufferLength() already exists in master and backBufferLength() is new in this PR, right? If so, then we could probably rename backBufferLength() to be closer to its purpose? . \ud83e\udd14 I do think we want to avoid making breaking changes if we can, but a deprecation warning might be a good compromise. Definitely will talk to the rest of the team soon. . Probably fine \ud83d\ude04 . That does mean that users can change the value, though. Does that concern you?. Ah, I think I meant to say couldn't you push a cue onto removeCues at this line?. Copying over gesinger's suggestion from Slack:\n\nSince pendingCallback_ should only be referenced internal to this class, it may make sense to have an additional property like waitingToAppend, and the code paths which normally rely on pendingCallback_ for determining whether something is updating/etc. also consider if we\u2019re waitingToAppend or not before basing the status on pendingCallback_ and/or the updateend.\n\nWhich, if we follow, would involve adding waitingToAppend to that method. . The state should be set to ready by the call to abort which is triggered from any calls to resetEverything(). Perhaps there is something else blocking the state change back to READY from occurring? It's worth revisiting these changes when updating the other portions of this PR to ensure we are only doing what is necessary in this handler.\nOnce source-updater.js is updated to use a new variable instead of nulling out pendingCallback_, I'm fairly sure you won't need pendingAppend anymore? Would be good to double check again.. ",
    "tonowoe": "Hopefully this will be looked more into in the future. Can't play 1080p videos. After 30 minutes of playing the video I get an error:\nvideo.js:128 VIDEOJS: ERROR: (CODE:-3 undefined) Failed to execute 'appendBuffer' on 'SourceBuffer': The SourceBuffer is full, and cannot free space to append additional buffers. MediaError\nlogByType @ video.js:128\n.ts files about 20-30 MB each.. ",
    "crf19920623": "\u6211\u4e5f\u9047\u5230\u4e86\u8fd9\u4e2a\u95ee\u9898\uff0cm3u8\u683c\u5f0f\u7684\u89c6\u9891\u5728WIN7\u7684IE11\u4e0a\u65e0\u6cd5\u64ad\u653e\uff0c\u5728win10\u7684IE11\u4e0a\u53ef\u4ee5\u64ad\u653e\uff0c\u9879\u76ee\u6025\u7740\u4e0a\u7ebf\uff0c\u6709\u6ca1\u6709\u4ec0\u4e48\u89e3\u51b3\u529e\u6cd5. ",
    "longlivelance": "Hi @gesinger \u2014 That does help. A lot. I suspected it may have been something with our encoding profiles. I will go that route. Thank you very much for the suggestions & information. Very helpful.. ",
    "hpate-omicron": "Oops, missed that, I've updated the comment and rebased :). ",
    "diegoje": "I get the same warning here. Appeared after videoJS updated to 7.. ",
    "ChaplinWang": "Same issue here:\n\"dependencies\": {\n    \"requirejs\": \"^2.3.5\",\n    \"videojs\": \"^1.0.0\",\n    \"videojs-contrib-ads\": \"^6.3.0\",\n    \"videojs-contrib-hls\": \"^5.14.1\",\n    \"videojs-flash\": \"^2.1.0\",\n    \"videojs-ima\": \"^1.3.0\",\n    \"webpack\": \"^4.8.3\",\n    \"video.js\": \"^7.0.2\"\n  },. ",
    "femtasy": "+1 on Chrome 66 MacOS 10.13.4. ",
    "plainheart": "Yes, I have the same problem with you.. ",
    "saPhil": "Same issue here.. ",
    "giantninja": "I've been seeing the same warning after updating Videojs and videojs-contrib-hls to their latest:\nVIDEOJS: WARN: A plugin named \"reloadSourceOnError\" already exists. You may want to avoid re-registering plugins!\nand just in case it's relevant, here's the scripts I'm using:\n<script src=\"https://vjs.zencdn.net/7.0.3/video.js\"></script>\n<script src=\"https://unpkg.com/videojs-contrib-hls/dist/videojs-contrib-hls.js\"></script>\nand screenshot of the warning:\nhttps://imgur.com/CHk8IYQ\n. I was not aware of that, so thank you for that . ",
    "yoko10000": "use the main Video.js 7.0.3, IOS11.4 ,don't play m3u8 . ",
    "svrakata": "Hello, \nThank you for your reply. \nUnfortunately the stream no longer exist and I can't provide sample for debugging.\nCheers . ",
    "wrasmann": "Thanks a lot for your reply. I have corrected my test case. \nI have tested it with the two URLs again:\nURL 1: https://devstreaming-cdn.apple.com/videos/streaming/examples/bipbop_4x3/bipbop_4x3_variant.m3u8\nURL 2: https://devstreaming-cdn.apple.com/videos/streaming/examples/img_bipbop_adv_example_ts/master.m3u8\nUnfortunately the problem still persists. The result now seems to be that the video is played back natively in case of the first URL despite the \"overrideNative\" and is played back correctly in case of the second URL. \nWhen I play back the second URL I can see the video and audio segments loading (ts and aac) in the network view of DevTools. When I play back the first URL I can't see the ts segments load.\nWhen I was testing before I had set the overrideNative, nativeAudioTracks and nativeVideoTracks options in all the possible places, because I didn't understand from the documentation that the full path of the overrideNative option was videojs.options.html5.hls.overrideNative.\nHere is the new test case URL: https://output.jsbin.com/rojecoyiwu\nand the source: https://jsbin.com/rojecoyiwu/edit?html,output. Hi forbesjo, thanks a lot for your help! Setting \"overrideNative\" in the proper way AND loading the video source with \"player.src(sourceObj)\" fixed the problem.. ",
    "swaraasolutions": "Hi @gesinger below links for v6 and v7\nV6 = http://jsbin.com/lirogavoni/edit?html,output\nV7 = http://jsbin.com/qihojaluho/edit?html,output\nWe have identified that when we disable hardware acceleration from google chrome it seems to be working correctly.. ",
    "fatelei": "@forbesjo I fix the review issue. Great suggest. ",
    "mzxjhx": "\n@gesinger thanks for your replay.\nmy project is only in chrome. I just find that VLC media player can play it ,no other video player can no it . \n",
    "rart": "Oops. Wrong repo for this ticket! Moved to https://github.com/videojs/videojs-contrib-dash/issues/296. ",
    "rdabreo": "The documentation for parameters is not consistent. Need to specify the return type (e.g. {object} )\n. @seniorflexdeveloper: In rest of the document, it looks like @param playlist {object}. \n. ",
    "rajkosto": "How would you have a Uint32Array in json then ? I just made changes untill it passed all your automated tests, change it to fit your style however you like.\n. entry.attributes.IV is there and was working, other than the whole 0x prefix thing, but it needs to propagate to the decryptor somehow, and key seems to be the best place for that ?\n. I just made it pass your test, if you want, you can remove the iv test completely, but then you have a missing test. The way you test is deep-comparing objects parsed from the m3u8 with the ones from the json file, i cannot nor should i rename the json file. I don't know of how you would have a byte/int array in a json file with it remaining JSON compliant either. You usually base64 encode binary data in JSON but then the deep-compare would fail.\n. ",
    "ESPNMichaelKidd": "typo wroker -> worker. ",
    "shahlabs": "The values do change for segmentInfo cues,  So I used let..But I did change the 3 lines code into 1 line and updated the comment above the code changes as you suggested. It should be audio and video. If I switch from audio only to audio/video rendition it gives me error as VIDEOJS: ERROR: DOMException: Failed to set the 'duration' property on 'MediaSource': The 'updating' attribute is true on one or more of this MediaSource's SourceBuffers.. "
}