{
    "rt2zz": "Added try/catch, thanks. \nI am still trying to figure out a decent api for persisting state. One function with 4 (mostly optional) arguments is clumsy. Also having to add a rehydrate action handler per reducer can be tedious and error prone.\n. @gaearon a few things:\n- support async storage api's (e.g. react-native)\n- allow for performance optimizations in the future, perhaps web workers for parsing\n- reducers can conditionally or partially rehydrate. E.G. a reducer might refuse data based on an expiry date.\n- All of the other fluxy benefits, e.g. make debugging easy and explicit. If a rehydration is causing problems one can easily trace it back to the action.\nI implemented pluggable storage last night in order to support react-native. New API:\njs\nconst config = {\n  blacklist: ['someReducer'], \n  actionCreator:rehydrate,\n  storage: AsyncStorage,\n}\npersistStore(store, config, () => {\n  console.log('restored')\n})\n. I do not have a good solution for cases where one needs to get all of the persisted state before rending the app. One possibility would look something like:\n``` js\nlet persist = persistStore(store)\nexport default class App extends Component {\n  getInitialState(){\n    persist.afterRehydration(() => this.setState({rehydrated: true})\n    return {rehydrated: false}\n  }\n  render() {\n    if(!this.state.rehydrated){ \n      return Loading... \n    }\n    return (\n      \n        {() => }\n      \n    )\n  }\n}\n```\nI realize that is a lot of boilerplate though...\n. FWIW if you need this and if you are building a web app your best bet is to probably write a synchronous rehydrator much like https://github.com/gaearon/redux-devtools/blob/master/src/persistState.js\nIn my use case I am ok with getting the data asynchronously (potentially after the first App render). Also I need react-native support which is async storage.\n. Or a simpler approach that works with the current API is to call persist in componentWillMount:\njs\nexport default class App extends Component {\n  componentWillMount() {\n    persistStore(store, {}, () => {\n      this.setState({rehydrated: true})\n    })\n  },\n  render() {\n    if(!this.state.rehydrated){ \n      return <LoadingView /> \n    }\n    return (\n      <Provider store={store}>\n        {() => <TheApp />}\n      </Provider>\n    )\n  }\n}\n. Just released 0.2.3 with experimentalAutoRehydrate. I suspect it will need much improvement, but I believe this is the right API (a higher order reducer):\n``` js\nimport { createStore, applyMiddleware, combineReducers } from 'redux'\nimport persistStore, { experimentalAutoRehydrate } from 'redux-persist-store'\nimport * as reducers from '../reducers'\nconst reducer = experimentalAutoRehydrate(combineReducers(reducers))\nconst store = createStore(reducer)\npersistStore(store)\n```\n. Ok I am starting to feel decent about this. \nRenamed project to redux-persist\nRenamed experimentalAutoRehydrate to autoRehydrate\nIt now auto rehydrates only keys that have not been modified by it's child reducers. That means if a reducer handlers its own rehydrate action, autoRehydrate will skip that reducer.\nI am however still unsure how to allow for custom actionCreators in autoRehydrate.\n. persistStore optionally takes a custom action creator in the config argument which may be useful if you want to supply your own action type constant or trigger conditional logic/api calls based on rehydration.\nFor example I have a custom action creator to detects if my AccessToken is being rehydrated, and if so checks with the server to make sure it is valid. \n. I am fairly satisfied. Closing until there is clarity on https://github.com/gaearon/redux/issues/350\n. it JSON.stringifys the state before calling storage.setItem, so it should be able to store any variable.\nCan you paste in the error you are seeing? \n. Looking at it, I realize I need to wrap that JSON.stringify in a try catch. It is possible some things cannot be stringifies. Still seeing your error would help, as most cases should work as is.\n. No longer relevant. Using action meta to trigger autoRehydrate now, and if somone wants a custom action constant, they can implement a custom action creator.\n. thanks :)\nI have not figured out how to test redux-persist yet. I think maybe we need a testing middleware to invoke callbacks when actiosn come through or something?\n. thanks!\n. just published .4.4 with the fix, although it just occured to me this will need to be done for warnIfRemoveError as well\n. This is something I have been wanting to do. The underlying mechanism should be fairly trivial using the window storage event but I am not sure about best practices for merging conflict such as when seperate changes occur on both tabs simultaneously.\nMaybe instead of syncing state we should sync/replay actions?\nAlso I am wondering if we can generalize this to work cross device using webrtc.\nLet me know if you have any thoughts, or make a pull request if you have a working implementation.\n. https://github.com/rt2zz/redux-persist-crosstab\ntook about 20 lines :D \nIt is not well tested, so please let me know how it goes.\n. closing for now. I think there is work to do to further abstract this, but I imagine https://github.com/rt2zz/redux-persist-crosstab will cover a larger portion of the use cases.\n. yes, and the code for this would be trivial. My hesitation is that I have yet to see an app that would whitelist more than it would blacklist.\nHave you run into this situation? can you explain more about your use case?\n. Makes sense. I just added whitelist to to 0.5.8\nLet me know how that goes\n. @zalmoxisus yes, there would no longer be a reducer key on the action. \nBy less noise, do you mean you would prefer it was consolidated to one action?\n. Will most likely make the switch in 2.0. This creates better symmetry with the getStoredState api and reduces log noise.\nWill deal with the \"debugability\" question with a debug option.\n. Woops, I forgot to update the recipes: I renamed it to rehydrateAction\njs\npersistStore(store, { rehydrateAction: rehydrateAction })\nNote: your rehydrateAction must use the import { REHYDRATE } from 'redux-persist/constants' action type if you want autoRehydrate to pick it up.\nI also removed it from the docs because I am not yet sure if this is the best api for taking action during rehydration. Are you making server calls within your custom rehydrate action? Let me know if it works well for you.\n. awesome, let me know how it goes, or if you need any additional integration points into redux-persist to make it work.\n. not sure I fully understand your architechture, but you might consider calling persistor.rehydrate to keep things in sync between tabs\njs\nconst persistor = persistStore(store)\n//...\npersistor.rehydrate(someReducerKey, newState, () => {})\n. that looks awesome.\nRegarding serialization, redux-persist serializes the data before calling the storage api. I did add an undocumented escape hatch where you can specify a serialize and deserialize function in the config:\njs\npersistStore(store, { serialize: (data) => data, deserialize: (data) => data })\n. haha, well strictly speaking it is working with redux-devtools, I have successfully run them both together.\nThat said I think there is probably more investigation required, e.g. what happens if you are rehydrating immutable data. If you run into any issues let me know, I will be happy to figure out fixes.\n. Good catch. I agree, if the sub state is an array lets just take it as is. \nI think this can be easily done with a bit of conditional Array.isArray around https://github.com/rt2zz/redux-persist/blob/master/src/autoRehydrate.js#L45\nLet me know if you get it working. I have been meaning to do a bit of cleanup and code beautification in autoRehydrate anyway..\n. I just pushed an update that fixes this issue. Will release a new version soon.\n. thanks for pointing this out!\n. I will have to take a look, the goal is to define localStorage so that if it is undefined (e.g. in node) it does not throw an error.\n. Agreed. Thanks for the PR!\n. I thought about this, and am definitely interested in supporting this, but upon initial inspection I found two issues:\n1. If you are using async storage, you then have to create the store in your callback, which means (in react) you have to delay rendering the redux Provider component. Achieving which is much more complex than simple syncronous intialization.\n2. Some rehydrations require processing, such as immutabljs transforms or access token validation. In these cases I like having an explicit debuggable action to understand how the state went from initial -> rehydrated. Furthermore I think it is valuable that reducer's can opt in to their own rehydration.\nIt would seem the key to supporting this use case of initialState rehydration would be to provide a lower level getStoredState function that can be used in lieue of autoRehydrate.\nWhat do you think? \nI think the value of redux-persist is that it provides a common extensible interface for rehydration, and in that vein / the spirit of redux, I would like to support the maximum use cases with the minimum api surface.\n. I have only partially formed thoughts on these very good points you raise:\n1. For specifically the sync localStorage case, we could avoid UI Flickering by calling the localStorage getItem syncronously invoking the localStorage callbacks syncronously (instead of using setImmediate as it currently does). I wrote this assuming async storage API's, but maybe it was a mistake to force asyncronicity with setImmediate. \n2. Initial state should never be stored regardless of debounce. The action buffer in autoRehydrate should ensure that rehydrate runs first before any other actions that might trigger a storage. That said I just realized action buffer was broken because of the change in compose behaivor in redux@2, I just published a fix for that in 1.2.0.\nI also added a debounce config parameter (in in versions >=1.1.0). From my initial test debounce: false works great.\nIt has occured to me that crosstab-sync implicitly depends on the fact that string equality exists in the serialized state post-rehydration. This may not be the case in chrome.storage since it stores unserialized objects. I have not fully thought this through, but we may need to abandon shallow merge in autoRehydrate in order to preserve post-rehydration object equality.\n. Also regarding the question at hand or initialState, one possible api for this could be\n``` js\nimport { getStoredState, storeStateOnChange }\n//...\nconst store = createStore(reducer, getStoredState())\nstoreStateOnChange(store)\n```\nThe problem is, getStoredState would only work as described with a sync api, namely localStorage. I am not sure any elegant way to do this with an async storage api.\n. Would the above snippet (react rendering in an async callback) not also cause selenium testing issues?\nI definitely like where you are going with this, and I think there are a (minority) of projects that will find this approach better suited. Code wise implementation will be trivial, just need to expose existing functionality via two new methods.\nSince this has turned into a full blown api review I have a few questions:\n1. storeStateOnChange is wordy, I would like something more elegant. Unfortunately persistStore is already taken :)\n2. Should debounce default to false (currently defaults to 33ms)\n3. Should serialization be the responsibility of the storage engine? Or should it be a boolean serialize: false. It seems obtuse to have to set serialize and deserialize to () => {}.\n. 1. That saves the need to pass in config twice which is great. Still I need to think on this a bit more.\n2. Debounce is necessary for performance sesitive tasks, such as writing to storage while scrolling. Nevertheless I agree, this is the minority case, so lets default false.\n. Ok just pushed an update with a new getStoredState method. I will publish npm in the future after adding more tests and doing some code cleanup.\nHere is the gist:\n``` js\nimport { getStoredState, persistStore } from 'redux-persist'\nconst config = {\n  skipRehydrate: true\n}\ngetStoredState(config, (err, initialState) => {\n  const store = createStore(reducer, initialState)\n  persistStore(store, config)\n  render(\n      ,\n         document.getElementById('root')\n      \n  )\n})\n```\nOf course this can be split up essentially the same as in your comment, except with an error first callback and shouldRehydrate: false in config.\nOverall I am pretty happy with this approach, and the symmetric config makes things easy. Also interestingly it opens up the possibility for secondary persistence schemes. e.g.\njs\n// main persistor using localForage\nlet mainPersistor = persistStore(store)\nlet remotePersistor = persistStore(store, {storage: secondaryServerStorage, shouldRehydrate: false})\nThis could trivially enable cool features like observing user sessions - just hook up an instance of your app to the remotePersistor (identified by some user id).\n. @zalmoxisus ah yes, that was an oversight. A lot of ambiguous terms floating around, if you have suggestions for more explicit naming I am all ears. \nFor now I will change skipRehydrate -> skipRestore, and then allow ad hoc rehydration through (e.g. crosstab sync). Also I will add a couple more tests and likely publish npm.\n. renamed config to skipRestore, now works with adhoc rehydration (read: crosstab sync).\nhttps://github.com/rt2zz/redux-persist#semi-secret-advanced-apis\n. facepalm I added tests on the persistStore side, forgot about autoRehydrate. Will fix asap\n. persistStore now emits REHYDRATE_COMPLETE even if skipRestore:true\nWhile inelegant, this is the only non-error prone way I can see to preserve the action buffer (which is very useful in a naive implementation). Actually emiting a completion action is useful, the problem is it should be renamed to something more accurate, since no rehydration occured.\n. note there is still one gotcha, if you do not call persistStore, the autoRehydrate actionBuffer will never be released. I will try to address this in 2.0.\n. :+1: \nI have not used redux-devtools much as I am mostly in react-native atm.\n. @zalmoxisus yes, in fact it is preferable not to use autoRehydrate in this case. \n. This is by design, autorehydrate checks for object equality.\nDo you have a reducer that makes this behaivor problematic?\n. I will leave this open for a bit to see if anyone else wants to weigh in. \nThe rationalization is, if the reducer handles the the REHYDRATE action, it implies custom rehydration and based on this assumption autoRehydrate will skip that reducer. This also is nice because it prevents conflicts where autoRehydrate might overwrite something the reducer wanted.\n. @IanVS yes that matters, autoRehydrate only looks at the first level of state. So in this case you have a few options:\n1) dont use autoRehydrate and have all of your reducers implement REHYDRATE\n2) have none of your sub reducer handle REHYDRATE (then autorehydrate will work as expected)\n3) write a custom version of autoRehydrate that does exactly what you need.\n. @askmatey I have thought about this, and this is more in line with e.g. how redux-localstorage works\nThe reasoning for the configuration based approach is that it is simple. IMO the alternative is actually not inherently more \"functional\", it just moves configuration from being an object to being implicit in what you choose to require. It still suffers from limitations of preconceived design.\nThat said I am entirely open to a more functional pattern, and any api suggestions would be appreciated.\n. Just pushed a first cut at 2.0 to master. Key changes:\nOnly one REHYDRATE action which now contains the entire stored state tree. No REHYDRATE_COMPLETE action is needed since, REHYDRATE implicitly means rehydration is complete.\nAll api's are updated accordingly so e.g. persistor.rehydrate now looks like this: persistor.rehydrate(serialState). \nI will continue to mess with the api over the next few days. In particular I want to spend some time thinking over the way transforms and serialization happen.\nAs far as functional composition, I am open to suggestions for how to improve this. I suspect we will always need a configuration object to keep certain basic use cases dead simple e.g. setting the storage engine. That said I suspect there may be some way to expose a functional primitive around transforms and serialization.\n. looks good :+1: \n. I will cut a new release after I have a chance to manually test (there are no immutablejs tests currently)\n. released 1.4.3\n. :+1: \n. yes this is a relatively easy fix\nquestion though: how do you expect redux-persist to work on the server? are you expecting a noop?\n. just released 1.4.5\nno localStorage now console.errors with a useful message. In production it is a noop.\n@zalmoxisus I do not think process.env.isServer is defined in most node environments. AFAIK the tyipical albeit indirect way to check if in node is https://gist.github.com/rt2zz/ac9eb396793f95ff3c3b\n. x.x :+1: \n. no worry, just a few style changes I fixed\n. thanks, just release 1.4.10 with analogous changes\n. This looks good, but I want to add a test for this before cutting a new release. Feel free to write one, or I will later this week.\n:+1: \n. just release v1.5.0 with your patch & a test :+1: \n. This is an idea I have pondered, but not yet tried. The short answer is yes, redux-persist could be useful for this. The longer answer depends on how your application works:\nIf your state is identical for all users:\nredux-persist should work out of the box, you just need to wrap your database in a compatible api. Make sure you are not recreating your store on every request, either by making it a singleton or storing a reference to it in your server.\nIf your state is different per user:\nYou will need to do some extra work to make this work. Off the top of my head, lets assume you have a id for each user that you can parse out of a token or cookie. Using that id you can create a Storage engine per user. Something like:\n``` js\nrouteHandler = (request, reply)  => {\n  let uid = getUidFromRequest(request)\n  let UserStorage = createUserStorage(uid)\n  let store = createReduxStore()\n  persistState(store, {storage: UserStorage})\n  // ...\n}\nfunction createUserStorage (uid) {\n  return {\n    setItem: (key, value, cb) => {\n      dbClient.insert({uid: uid, key: key, value: value}, cb)\n    },\n    getItem: (key, cb) => {\n      dbClient.find({uid: uid, key: key}, cb)\n    }\n  }\n}\n```\nObviously this leaves much to the imagination and will need to be changed depending on the workings of your database driver, but hopefully the general approach makes sense.\nLet me know how that works out for you, I would be happy to support changes needed to make this use case more comfortable.\n. interesting concept,\nYou should also give some serious thought to how you would handle deploying updates that require state shape changes. In typical client side redux you just blow out the old state and build it fresh, but if using redux as your source of truth database, you will likely need a well thought out mechanism to migrate state between versions.\nredux-persist essentially solves the problem of \"after updates how do I store my state as quickly and efficiently as reasonable?\". It may or may not be useful for your endeavor. \nA naive data migration strategy could be: version your data, and use getStoredState to get the state and run upgrade scripts prior to rehydration.\n. @RichardForrester did you ever figure out a solution? Curious to hear your thoughts and if any modifications were required. \n. closing for now, feel free to reopen if still relevant!\n. Interesting. I love the idea of server side redux in lieu of a db, but you are probably right the tooling will need to develop a lot before that can be a reality.\n. I need to think about this. Initially the concept behind redux-persist was to simplify the persistence model by allowing reducer scoped blacklist/whitelist. That said I do not want to be overly prescriptive and I can definitely envision scenarios where more selective filtering is needed.\n. @Pajn I think this makes sense. what do you think about using the same api as redux-logger and having a predicate option?\n. regarding filtering actions it looks like we would need to add some extra wrapper around the subscribe since by default subscribe is action unaware.\nIf you do decide to work on this, it is best to develop against v3 branch as that is where the latest code is.\n. closing due to inactivity, feel free to PR! \nAlso note: because this would require non-trivial extension to subscribe to be action aware, I am wary to add this to the core redux-persist lib, perhaps there is a clever way to implement this as a dependent module.\n. good catch. it was renamed to skipRestore. There are multiple options for delaying the rendering, and this is in fact the reason skipRestore was added.\nOption 1: getStoredState w/ callback\nOption 2: App.js lifecycle hooks\nOption 3: Set a piece of state rehydrated: true in response to REHYDRATE_COMPLETE action.\nNot sure the best option for your use case. I typically like option 3 but it does require wiring up your reducer appropriately\n. btw just updated the readme with skipRestore\n. @af its a new api that honestly I am uncertain about right now. Let me know how it feels for you - it could potentially become the recommended usage.\n. hm yes no super elegant way to export persistor in this scenario. I will think about it. I would say option 3 will always give you the most optionality albeit at a certain effort to implement.\n. This definitely looks like a bug introduced by some for in changes we made. I would prefer to stay away from munging the proto. Perhaps if we detect the object is not plain we can just wholesale set the substate instead of doing for in?\n. how about: https://github.com/rt2zz/redux-persist/blob/master/src/autoRehydrate.js#L38\nWith isPlainObject check, immutable objects would be wholesale copied instead of shallow merged\n. ok I pushed the isPlainObject change to master let me know if that solves the issue\n. After messing with this more and working on 2.0, I think this is the correct approach. Thanks for reporting!\n. @arilitan this should work for you: https://github.com/rt2zz/redux-persist-transform-immutable\n. Basically as in this code chunk: https://github.com/rt2zz/redux-persist#initialstate-rehydration\njs\ngetStoredState({skipRestore: true}, (err, initialState) => {\n  const store = finalCreateStore(reducer, initialState)\n  persistStore(store, persistConfig)\n  ReactDOM.render(\n    <Provider store={store}>\n    <div>\n      <Router history={history}>\n        <Route path=\"/\" component={App}>\n          <IndexRoute component={Home} />\n          <Route path=\"login\" component={Login} />\n          <Route path=\"register\" component={Register} />\n          <Route path=\"about\" component={About} />\n        </Route>\n      </Router>\n    </div>\n  </Provider>,\n  document.getElementById('app')\n  );\n})\n. Ah yes exactly. That is actually more of the recommended flow at this point in time. Is it working for you?\n. @Icehunter I am working on 2.0 right now which will simplify the usage a little bit and I think make this problem easier to troubleshoot. Are you still stuck?\n. @Icehunter did you ever get this sorted? If not let me know the latest and we can dig deeper. \n. The easiest way to do this is to call persistStore inside of your application.jsx componentWillMount and then when it is complete setState({initialized: true})\n. Ah I did not notice that, ya I would recommend adding a class component called App so something like:\n``` js\nclass App extends Component {\n  state = {\n    initialized: false\n  }\ncomponentWillMount() {\n    persistStore(store, {}, (err, restoredState) => {\n      this.setState({initialized: true})\n    })\n  render() {\n    if (!this.state.initialized) return Loading...\n    return (\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  )}\n}\nReactDOM.render(\n  ,\n  document.getElementById('app')\n)\n``\n. that code might not be perfect (be sure to check close parens etc.) but it should point you in the right direction\n. :+1:   \n. accepted (with some modification) can you test on master to see if it is working as anticipated:npm install rt2zz/redux-persist. looks good. I need to figure out why travis is complaining about the unused var. I should be able to merge this tomorrow.\n. This is currently not possible (in any elegant way). We could expose another option:storeInitialState` but I am wary of adding any more options. \nStoring initial state is actually the safe & logical thing to do, but I am concerned about adding any cpu load during the already impacted bootstrap process of a web app. Thoughts?\n. @fabiosussetto this seems like the correct approach.\nIn the meantime I am working on 2.0 which has some semi-significant api changes. https://github.com/rt2zz/redux-persist/issues/35#issuecomment-182596103\nIn 2.0 I am leaning toward making storing initial state the default behavior since this is more intuitive. \n. redux-persist now stores the initial state, relevant lines: https://github.com/rt2zz/redux-persist/blob/master/src/createPersistor.js#L21-L40\nAre you experiencing some issues?\n. Ah, this was not a breaking change, but rather a bug. \nI just pushed 1.5.3, but I will need to do further testing to confirm all potentially related issues are resolved.\n. @lcoderre @technicallyjosh thanks for reporting & testing!\nI am working on a 2.0 which will make things a little simpler, and time permitting have actual browser tests not just mocha tests.\n. Thanks for catching that. The old size check was ugly, I prefer redux-storage's method of checking for mergeDeep.\nUpdated in 1.5.5 :+1: : https://github.com/rt2zz/redux-persist/commit/dae5b1b58ae4b9b598e6bd5f421d136f1a0399a6\n. @namxam my mistake, just released the analogous fix in 2.0.1: https://github.com/rt2zz/redux-persist/commit/8059972d5af168af4830c8b5c0c311ebf0573c24\nI am not personally using immutable, so if you can verify it working that would be much appreciated!\n. more specifically I think what you are asking is how to use it with applyMiddleware. both applyMiddleware and autoRehydrate are store enhancers so you can compose them as follows:\njs\nconst store = createStore(\n  combineReducers(reducers),\n  {},\n  compose(\n    autoRehydrate(),\n    applyMiddleware(thunk)\n  )\n)\nThis is using the new redux enhancer as a third argument api, so make sure your redux is up to date. :+1: \n. I should note you will need to import all of those methods and also run persistStore:\n``` js\nimport {autoRehydrate, persistStore} from 'redux-persist'\n// ...\npersistStore(store)\n```\n. :+1: ty\n. I will cut a new release later today \n. Out in v1.5.6 and also 2.0.0-rc3\nIf you are interested in trying v2 npm install redux-persist@next\nThe main difference is there is one big REHYDRATE action instead of one per reducer.\n. You can do this a few different ways. Basically the crux is you need to get a handle on the persistor object that is returned by persistStore. If this UI button lives deep inside your app, you will either need to \n1) expose persistor via context similar to how react-redux Provider works\n2) pass the persistor down via props\n3) create persistor as a singleton which can be required in your other components.\nCan you explain more about your use case? purge clears the local storage but does not reset state. I suspect what you actually are looking for is an action that resets state to initialState. To do this I would not worry about the persistor at all, and instead create your own action called \"RESET_STATE\" which each reducer is responsible for implementing.\nLet me know if any of those work for you.\n. Got it. I do not have a good solution to number 1. Generally I write custom code to handle this kind of situation on a per reducer basis and store version string on my \"app\" reducer. But I do not feel this is an ideal solution and am curious what other strategies might ease migrations.\nAs for 2, you might consider sending the persistor down via context. Again it is not something I have done, and I am curious to hear how it works out for you. Good luck!\n. After using redux more, my recommendation for getting access to purge is to expose the persistor via context. Then you can call this.context.persistor.purgeAll from anywhere in your application. \nThe behavior of purge is to clear the storage but not reset state, so a page reload or a RESET action will still be required.\nThere are other approaches possible such as a custom action creator that has the persistor in scope.\nIf changes are needed in the redux-persist lib to support specific use cases let me know and we can evaluate feature additions.\n. note for posterity there is now a purgeStoredState top level export that can help purge state without having access to the persistor. Resetting redux state is still out of scope of this module, but IIRC there are a couple of other packages that solve that very problem.. I am interested in supporting top level immutable state. You can JSON.stringify a immutable Map to a plain JSON string correct? In this case all we have to worry about is transforming the raw object back to a Map on rehydrate and also how to take the entire state and map it out into per-reducer chunks.\nI believe this will require a new option mapStateToPartials or something like that. There will probably need to be corresponding changes throughout the code base.\nAfter typing this out, I believe it is possible to implement with no impact on performance, but it will take some work so no ETA at this time, although PR's are appreciated. If you are short on time I would probably recommend looking at https://github.com/michaelcontento/redux-storage which deals which avoids dealing with state partials and hence has a much simpler story around immutable support.\n. that works very well for rehydration, but there is still an outstanding problem where persistStore expects the state object returned from getState to be a plain object. A trivial albeit non-ideal performance solution would be to call Immutable.toJS(store.getState()) inside of our store subscriber.\n. @zalmoxisus interesting to hear you are moving your sub reducers to immutable, what spurred this change? Is it a performance optimization or that the api is preferable?\nYes if you go with the approach in https://github.com/rt2zz/redux-persist/issues/64#issuecomment-188184873 that example should work without modification. I agree with @zalmoxisus that in a typical redux app there is no benefit to top level immutable state. Keeping things an object at the top level helps with interoperability.\nAn alternative and simpler option to the getStoredState approach is to use https://github.com/rt2zz/redux-persist-immutable. Which approach is best will be application specific.\n. in the forthcoming v3 release the createPersistor and getStoredState methods are sufficiently abstracted that I believe we could easily create a redux-persist-immutable module that reimplments persistStore with top level immutable support.\nThe following extra config/extension will be needed:\nautoRehydrate: state iterator, state setter\ncreatePersistor: state iterator\ngetStoredState: final state transform (js -> Map)\nIn order to accept these changes in redux-persist however we would need some benchmarks to ensure we are not introducing performance regressions.\n. Ok tentative immutable support now available at https://github.com/rt2zz/redux-persist-immutable\nnote I have not actually run this in an app, but the tests pass ;)\ncc/ @rufman if you have a moment to check out my PR on your repo, it would be great to make that the main repo and get you added to the npm module as well\n. tentative support via https://github.com/rt2zz/redux-persist-immutable v4.0.0-alpha3\nredux-persist-immutable is a drop in replacement for redux-persist that has immutable support\n. What do you currently use rehydrateAction for? The recommendation is currently to do any custom rehydration processing in your reducer, or if you need to do async validation in a saga. \nIt was removed because in an attempt to keep the overall api and complexity limited. If you have a use case that cannot be satisfactorily handled elsewise, I would be happy to readd support.\n. also fwiw in the short term you should probably stick to 1.5.3 until we have time to think over how this fits into 2.0\n. Ah, ok refreshing/expiring auth tokens is exactly why I added rehydrateAction in the first place! Since then however we changed how we handle auth tokens. \nMy recommendation is you do auth token validation in the persistStore callback:\njs\npersistStore(store, config, (err, state) => {\n  if(state.auth.token) processToken(state.auth.token)\n})\nThoughts?\n. It does not currently, but it could be added. the REHYDRATE action has no requirement to be complete, so we can potentially split the restoration process into 2+ actions. Do you have any api's in mind?\nThe one thing to consider is that we cannot start persisting until all state has been rehydrated, otherwise we risk overwriting the yet loaded state.\n. @romanenko generally redux-persist should be disabled on server since the model does not usually make sense for single use stores. That said I would like to best and most generically support all use cases. It may make sense to either turn off bufferActions or at least make it a configurable option. \nBecause at the point that bufferActions has a chance to work is typically before other middleware has operated, we have no way to return the actual expected return value.\n. Ok, having thought more about this I am going to remove bufferActions in v3. I will cut a preliminary release soon. \n. v3 is available sans the action buffer via npm i --save redux-persist@next warning: may be highly unstable\n. Good to hear. If there is a crash from having bad state though I think we would want to try and detect that and bail without throwing an exception. I will try to recreate.\n. Awesome. So this will use localForage if it exists, and if not default to localStorage? I am unclear how this is achieved, does localForage monkey patch localStorage?\n. @Klathmon sure, I am going to make some other changes and cut a v3 prerelease later today. In the meantime you can always point your npm to github i.e. rt2zz/redux-persist\n. ah that is annoying :/ ill keep you updated\n. just cut v3.0.0-prealpha npm i redux-persist@next\nThis includes a modified version of this PR, removes the action buffer which was too automagical and  sometimes caused problems, and now uses json-stringify-safe to prevent errors on cyclic objects.\n. @marvinhagemeister definitely not a requirement :) I will turn off circle and we can keep rolling with travis.\n. overall looks great! I made a few comments, but the main thing is if you can squash it down I will get this merged asap.\n. awesome stuff and much needed!\n. Ah those recipes were out of date, I just updated them. \nYour alternate method is perfect, but one note is you might want to be careful to make sure the keys are defined i.e.\njs\nif (action.payload.forms && action.payload.forms.newAppointmentForm) {\n  const startedMoment = moment(action.payload.forms.newAppointmentForm.startedMoment)\n}\n. Ok this is what I am thinking for migrations:\nIt can be done via a transform. It might look something like this:\n``` js\nconst migrationManifest = {\n  0.1: {\n    reducerA: (state) => {...state, somethingStale: undefined} \n  },\n  0.2: {\n    // ...\n  }\n}\nlet migrator = createMigration(migrationManifest)\npersistStore(store, { preloaders: [migrator.preloader], transforms: [migrator.transform] })\n```\nSo basically the manifest is an object with state \"versions\" as keys and objects which map per-reducer state as values. \nNotes:\n- I wish we could get semver for state versions, but since we want fast comparisons (i.e. v1 > v2) I think decimals will be more performant\n- migrations will need to be nearly idempotent, since there is a chance we will lose track of the version and need to rerun all migrations on top already migrated state.\n- migrator transform will need to be placed at the top of the stack so it happens after all transforms\nAnother issue is how to store the state version. I am thinking migrator can store it in a separate storage key reduxPersist:_stateVersion. If we go this route we need the ability to delay transforms until the state version is loaded out of storage. This can probably be achieved via a preloaders config on persistStore.\nThese are just early thoughts. I am thinking of releasing this as a contrib module first and if it goes well we can look at direct integration.\ncc/ @corbt   \n. initial implementation: https://github.com/wildlifela/redux-persist-migration\n. ah, so the current implementation is basically a minimal implementation using current functionality (well aside from the small addition of preloaders). I definitely like the whole-state approach you outline above, but it may require some larger api additions.\nRegarding running multiple times, the issue boils down to, how do we know the version of the stored state? If storage fails for some reason, the store will end up with initialState and no known version. The migrator will then apply all of it's migrations on the next rehydrate since the version is null. There may very well be a more elegant solution to this, but I have not thought of it yet :)\nAnyway, I will keep thinking it over. Let me know if you have any ideas for exactly what the api should look like.\n. :+1: let us know how that goes. Getting the version number is the biggest challenge in the api design, perhaps keeping it in redux state is the way to go. \n. That does solve the re-running migrations issue, but the issue I see is as follows:\n| has stored state | state version | result |\n| --- | --- | --- |\n| yes | number | run migrations |\n| yes | null | ? |\n| no | number | do nothing |\n| no | null | do nothing |\nThere are two ways we can get to the second scenario:\n1) migrations were just added to the config\n2) version key storage failed\nfor 1) I would say since there was no pre-existing implementation it should be out of scope for migrations to handle this. If needed a developer can write an special custom migration in their reducer.\nfor 2) I am not sure. Is it better to rerun all migrations and assume they are idempotent, or would it be better to skip migrations and hope there is no conflict. It seems to me that rerun is the safer option.\n. after struggling with the api a bit, I am pretty convinced migration functionality is better of living inside of a store enhancer, similar to autoRehydrate.\nHere is a untested poc implementation of a createMigration store enhancer:\nPros:\n1. better manifest api as suggested by corbt\n2. simpler implementation\n3. completely predictable and synchronous as there is no storage interaction\n4. no extra api required in redux-persist\nCons:\n1. requires adding a version key to redux state (? could also be a pro)\n2. api is a bit heavy with specifying a versionSelector and versionSetter\n3. requires proper ordering of store enhancers (i.e. things will fail silently if it is placed after autoRehydrate)\n4. mutates rehydrate action\nAs for the cons, 1 & 2 I am ok with, and 3 & 4 can be solved later if need be by adding a simple integration point in persistStore.\nOverall I am pretty happy with this approach and will publish a release after doing some testing.\n. released \ud83d\udc4d \ud83d\udce6 \ud83c\udf89   \n. Great idea. Probably would want the ability to toggle compression on a per reducer basis. I have not thought about this much but an open to suggestion \n. \ud83d\udc4d   https://github.com/rt2zz/redux-persist-transform-compress\nrequires redux-persist@3\n. Ah yes that is unfortunate. I will not be in a place to publish a release until Monday, but I will asap\n. Ya redux persist is react agnostic. Specifically for react native it works with all versions, just make sure to pass in AsyncStorage as the storage engine\n. :+1:\n. :+1:\n. AsyncStorage keeps everything as strings. However Redux persist handles deserialization for you so you should never need to touch the raw string output. \nCan you paste the code where you are observing a string value and maybe I can better understand the context. \n. are you using redux-persist-crosstab?\nI am glad you got it working but this is unexpected behavior and hopefully we can figure out what is going on.\n. Ah, i have a pretty good idea what is going on here. Tldr; try redux-persist v3 npm i redux-persist@next\nIt removes the action buffer\n. Hm, sounds like there may be some issue/conflict with the AsyncStorage implementation in react-web.\nTo debug further the relevant code is in src/getStoredState.js. Possibly getAllKeys or getItem is failing...\n. fix: https://github.com/taobaofed/react-web/pull/96\n. \ud83d\udc4d  https://github.com/rt2zz/redux-persist/commit/5dbe16d1aff7d7d62827b68d55616a7e2c8919ea\ngreat idea. To go along with it I created a new createTransform method and also published redux-persist-transform-compress\nLet me know how that goes \n. one thing that is not entirely solved by this api though is the ability to run certain transforms before serialization and others after...\n. Do you know why redux does not use babel-lodash? I based my implementation on that. \n. :+1:\n. ya, for the reasons outline above, I usually store my dates as ms integers, and convert to Date/moment as needed in the application (but outside of redux).\nIn so far as redux-persist goes, I think a transform is the right way to handle this, probably something like https://github.com/cognitect/transit-js which is performant and will handle dates as well as maps and symbols.\n. for reference creating a transit transform would look almost exactly like: https://github.com/rt2zz/redux-persist-transform-immutable/blob/master/index.js except instead of transit-immutable-js use plain transit and instead of toJSON and fromJSON use read/write.\n. Having x many more months of redux experience, I think the best practice is to store your dates as integers (or other serializable format). \ud83d\udc4d \n. I definitely like the idea of checking for Date objects (in dev) and logging if found. \ud83d\udc4d \nAdditionally I think a good solution for people who want to store date objects in redux state would be to have a transform that implements https://github.com/cognitect/transit-js. It would be almost identical to https://github.com/rt2zz/redux-persist-transform-immutable except using plain transit-js.\n. @you-fail-me plain transit-js deals with plain js objects, transit-js-immutable adds the Map etc.\njson-literal is just as well (maybe better?). I do not want to increase the lib size by making that default, but I am open to suggestions for how to work this into the api / core lib in a way that is opt-in and does not affect bundle size.. That would be great. I have not used realm but the project looks exciting.\nDoes realm require schemas are defined up front?\n. note redux-persist v5 now has a simpler / more flexible storage model. It also no longer requires getAllKeys, so I think a realm storage engine would be trivial aside from the need to write a well defined schema.\nJust three methods required: setItem, getItem, removeItem. \ud83d\udc4d I assume that means it is working? to be clear: yes you only need to call persistStore once, and under the hood it will monitor changes via store.subscribe.\n. 1. the return value from persistStore is persistor not store. So your code should look more like:\njs\nimport createStore from './redux/configureStore'\nimport {persistStore} from 'redux-persist'\nconst store = createStore()\nconst persistor =  persistStore(store, {storage: AsyncStorage})\n1. You can pass in a whitelist of reducer keys like so:\n   const persistor =  persistStore(store, {storage: AsyncStorage, whitelist: ['reducerA', 'reducerB']})\n. no need to pass persistor to provider. I would recommend reading up more on how react-redux works. Basically if you want access to state you use should using connect. redux-persist will not affect anything about react-redux.\n. \ud83d\udc4d \n. persistor is paused until getStoredState is complete otherwise there could potentially be a race condition where state is stored via the persistor before the old state is retrieved, thus overwriting the state that was intended for rehydration.\nYour particular case is pretty interesting, we should definitely account for it. One option which I have no fully considered the consequences of would be to set lastState to be the value of the restoredState. This would presumably need to be done when resume() is called.\nAs a short term workaround you might consider cloning your initialState on logout, so instead of \n``` js\nmyReducer (state = initialState, action) {\n// ... old way\ncase 'LOGOUT'\n  return initialState\n// ... new way\ncase 'LOGOUT'\n  return {...initialState}\n```\n. @felipemartim I forgot to update here, we now set initialState to an empty object, so state will always persist after the first load, thus solving your issue and also enabling https://github.com/wildlifela/redux-persist-migrate\n@gullitmiranda that is true, but in idiomatic redux if you do not modify state you return the object as is with referential equality. e.g.\njs\nlet a ={}\nlet b = {}\na === b // false\na === a // true\n. I would be open to this. Something like what react-redux does:\njs\ncreateTransform(null, outbound)\nI would definitely accept a PR to that affect\n. included in latest release\n. I believe although am not entirely sure, that this is an artifact of the way babel transpiles the code. Either way I just cut a new release that solves said issue. Thanks!\n. Two actions simultaneously should be no problem. Could this be related to the debounce issue you reported earlier?\nThe only other thing I can think of is that redux-persist only stores state which changes, i.e. does not have reference eqaulity. So make sure you are not mutating your state for uploadDone, and are rather copying it, typically with a return {...newState} in your reducer.\n. @jburich fantastic, I just released 3.0.3 to solve the debounce issue, and I guess this solved collaterally \ud83c\udf89 (or I guess more accurately this simply the same issue)  \n. \ud83d\udc4d \u2764\ufe0f \nA SQLLite storage engine for redux-persist doesnt sound like a bad idea... \n. \ud83d\udc4d and agreed about the readme\n. closing, feel free to PR with readme update :D\n. \ud83d\udc4d  Feel free to contribute more examples as well.    \nHere is one really simple example: https://github.com/philipshurpik/react-native-starter-kit/blob/master/app/store.js\n. Yes persistStore does both persist and restore. It retrieves the stored state, rehydrates said state, and dispatches a REHYDRATE action. It also sets up a listener that will continuously saves newly changed state to storage.\nThe only thing it does not do is merge the rehydrated state into your reducer. For that you will want to use autoRehydrate.\n. right REHYDRATE is only called once, as soon as all state is retrieved from the storage. After that there will be no more actions, unless you call persistor.rehydrate() yourself.\n. @incleaf is this your top level reducer? that is correct redux-persist only works with state that is an object. Most people use combineReducers hence this is usually the case. \nSupporting top level non-object state is actually non-trivial because a lot of redux-persist works on a per-sub-reducer basis (e.g. transforms). \n. we should definitely warn/error if state is not plain\n. persistor will now warn when incompatible state: https://github.com/rt2zz/redux-persist/blob/master/src/createPersistor.js#L32 \ud83d\udc4d \n. I highly prefer the class property syntax, although I realize not everyone has that set up in there transpiler\n\ud83d\udc4d \n. yes! \ud83d\udd25 \n. what version of redux-persist are you using? Can you debug that the removeItem calls are being made properly?\n. \ud83d\udc4d all good, hopefully things worked out. A lot of the lib has been updated since last year so I am pretty sure we are \ud83d\udc4c . @damamsrinivas in most cases the \"simplest usage\" will work. \nCan you explain more about what you are looking for? are you building a web app?\n. @Anthonyzou autoRehydrate is a store enhancer, not a middleware, so your code should look more like:\njs\nconst middleware = [thunkMiddleware];\nlet store = compose(\n  applyMiddleware(...middleware),\n  autoRehydrate()\n)(createStore)(reducers);\npersistStore(store, {storage: AsyncStorage})\n. \ud83d\udc4d If you have a chance to PR adding in a note regarding this in the README that would be awesome \ud83c\udf89 \n. I am all for making the docs better, what about it do you feel is to general? It sounds like it might need more concrete examples?. @Andarist that memory fallback is great and some variant of that should definitely be the default storage we ship with. I think most non-trivial applications have implemented something similar so would be great to standardize.. Right now redux-persist assumes all sub states are a plain object. The todo example has visibilityFilter as a string hence the issue. I would like to update redux-persist to remove this assumption.. fix for this is available in redux-persist@5.3.0-rc.2, available via npm i redux-persist@next. \ud83d\udc4d thanks! \n. thanks for this! it looks like you are working off of an older version of redux-persist though.\nIn v3 we support non-serialized state by default, and if you want to pass in serial state that requires {serial: true}\nso e.g.:\njs\npersistor.rehydrate({foo: 'bar'})\npersistor.rehydrate(JSON.stringify({foo: 'bar'}), {serial: true})\nhttps://github.com/rt2zz/redux-persist/blob/master/src/createPersistor.js#L63-L80\nThere is no longer a cb argument. If you can update the PR accordingly I will merge asap. Thanks!\n. :heart:\n. gah! npm!\nLet me know if there is anything we can do to avoid this but from what it sounds like this is more npm bugs.\n. We could do some sanity checks in dev, e.g. on first storage, immediately get the stored key and verify the data is correct...\n. it is expected reducedState and state have the same shape. In this case though it might actually make more sense to spread reducedState instead of state...\nLet me think this over\n. This is correct, we start with the oldest unsaved key, but we continue to process the queue every debounce interval (FIFO) until there are no more unsaved keys. If there is a crash/exit before the queue is finished processing you can end up with partially saved state.\nAny thoughts on how this can be remedied or reduced?\n. AFAIK redux-storage and redux-persist are the only two reasonable options right now. \nI doubt that most redux applications would have an issue with the substate of each reducer being out of sync in practice. If the state is so strongly linked it would probably make sense to keep it within the same reducer.\nI am definitely open to supporting transactions. In my naive imagination I expect the biggest challenge will be: how to decide when to store old state in order to complete a transaction versus when to store new state and effectively begin a new transaction before the old one is complete. e.g.\n1) state changes {a: 1, b: 1}\n2) persist reduxPersist:a = 1 (b still in persist queue)\n3) state changes {a: 2, b: 2}\n4) ? do we store b: 1 and complete the transaction or begin a new transaction and store b: 2.\nFor simplicity I expect we should store b: 1 (i.e. the old state) and finish the transaction. In the worst case this would result in twice as many save operations, but it would avoid the potential for never ending transactions and keep the mental model simple.\n. @igrayson agreed that is simplest, but would fail pretty horribly if an application has repeated state updates that occur faster than the total transaction completion time, as no transaction will ever be completed.\n. Long story short: currently we do not support top level immutable state, only immutable sub-reducers.\nThere is an open issue to support top level immutable state. It is possible, the biggest hold up is how to design a simple elegant API. e.g. we could allow a configurable \"state iterator\" and \"state setter\", but that api feels clunky. Open to suggestions\n. Ok tentative immutable support now available at https://github.com/rt2zz/redux-persist-immutable\nnote I have not actually run this in an app, but the tests pass ;)\nFeedback welcome!\n. On cursory inspection, I suspect what is happening is that you started without the blacklist, state was saved, and then after adding it to the blacklist the old saved value continues to be rehydrated even though no new state is being written over it.\nThe short fix would be to call persistor.purgeAll() to clear your state and then it should begin to function as expected.\nThe more sustainable solution is for us to think about having getStoredState respect the whitelist & blacklist. Right now it just restores everything it can find.\n. K just implemented blacklist in getStoredState: https://github.com/rt2zz/redux-persist/blob/master/src/getStoredState.js#L22\nThis should help avoid confusion in the future. Thanks! Will cut a release soon.\n. what version of redux-persist are you using?. are you setting up two persistors, one with session storage and one with local storage?\nIf you do this you will need to blacklist routing in both. seeing the full configureStore setup might help me understand.. @irvingv8 nice! glad to hear its sorted. :+1:\n. So if I understand: you want to use this module to persist component state?\nThat is a very interesting idea. Currently it is not possible but I am open to suggestions for how to implement this.\n. closing due to inactivity, feel free to reopen\n. Most likely you are modifying state in your reducers, so autoRehydrate is skipping your reducers.\nIn order for autoRehydrate to work, you need dataReducer to by default return state unmodified.\njs\nswitch action.type:\n// ...\ndefault: return state\nYour other option is to not use autoRehydrate and instead handle the rehydrate manually:\njs\nswitch action.type:\n  case REHYDRATE: \n    return {...state, ...action.payload.dataReducer}\n// ...\nI wrote this on my phone so let me know if anything is broken or confusing\n. actually upon further inspection I think your createStore call is wrong, It only takes 3 arguments so it should look more like:\njs\nlet enhancer = autoRehydrate()(devtools())\ncreateStoreWithMiddleware(rootReducer, initialState, enhancer)\n. \ud83d\udc4d \n. Ya that is correct, autoRehydrate simply handles the REHYDRATE action. all of the heavy lifting is done in persistStore.\nI think the original question is about how to syncronously load state before rendering the app. This is not possible, I would recommend either showing a temporary loading screen, or completely delaying the rendering of the react tree until persistence is complete.\nIf you need more control over when and how things fire you can use getStoredState and createPersistor.\n. \ud83d\udc4d \n. awesome \ud83d\udc4d \nI like this general approach, but want to wait for some resolution to https://github.com/reactjs/redux/issues/1792 before committing to a specific api.\n. @dpereira411 redux-persist-immutable is deprecated, as redux-persist-transform-immutable works with redux-persist v3+\n. @ntucker yikes good catch \ud83d\ude4c \n. @tigerohuang it looks like you got it solved?\nOne option is to use https://github.com/rt2zz/redux-action-buffer to buffer all actions until rehydrate is complete. Another option is to run your business logic in the onComplete handler which it looks like you may have ended up doing.\n. It should be possible, it simply needs a wrapper that conforms to the AsyncStorage api, e.g. https://github.com/rt2zz/redux-persist/blob/master/src/defaults/asyncLocalStorage.js#L37-L81\nThis would make a great npm module for other cordova users to consume.\n. closing due to inactivity, feel free to reopen to discuss further or release a module!\n. did you possibly leave .purgeAll() in your code? \nRedux persist is generally designed to persist whole sub-reducers, you may want to consider restructuring your reducers to put that deeply nested state near the top. Another option is you can write a transform to filter out only the state you care about:\n. \ud83d\udc4d  glad you got it sorted. Did it requires a fresh npm install?\n. Yes I think a version number is the correct approach. I would recommend redux-persist-migrate, this is the solution I came up with for the same problem after much tinkering. Feedback welcome!\n. This is definitely desired functionality.\nConcerns:\n1) should also support callbacks\n2) I dont think the purgeAll implementation works as it relies on getAllKeys returning a promise\n. @eclifford thanks for the work! I adapted it and applied it to the coming v4 PR. \nRegarding my comments, I have decided callbacks is a feature that can be added later, and I updated the default getAllKeys implementation to support promises.\n. not currently, but I would be open to ideas for what this would look like\n. @KarlPurk can you elaborate on why you want to manual trigger persist? If performance is an issue you can set a debounce on the persist, or also blacklist expensive reducers.\n. @simonacca clever. The api is not exposed for this currently, but I am open to suggestions. persistor.persist() seems ambiguous (ie. it is already persisting). Some ideas:\npersistor.flush()\npersistor.persistImmediate()\nThis method would probably need to return a promise as persistence is typically (depending on storage engine) not sync.\n. flush is now part of the api, persistor.flush() which returns a promise that resolves when the flush is complete.. \ud83d\udc4d \nThis makes sense, but should probably return regardless of NODE_ENV. Also tests are failing because of standard style.\n. I do not have a comprehensive comparison, but I would recommend either redux-persist or redux-storage. Persist works per reducer and I think is generally more performant while redux-storage works on the entire state.\n. The challenge is, sometimes it is nice to get the persistor synchronously, e.g. if you want to call .purge()\nI would want to think hard about any other possible use cases for having the persistor immediately before making this change. Open to more thoughts on the matter..\n. you can purge the persistor at any time with either purgeStoredState(config) or persistor.purge().\nNot starting the persistor by default is an interesting idea.. @chrisblossom are you still seeing this? I believe this was fixed in later versions.\n. @mobitar ya that works, you can alternatively handle the regular rehydrate action to set a rehydrated: true value in your redux state.\ne.g.\n```\nimport { REHYDRATE } from 'redux-persist/constants'\nfunction myReducer(state, action){\n//...\ncase REHYDRATE:\n   return {...state, ...action.payload.myReducer, rehydrated: true}\n//...\n``\n. @tomprogers interesting. I think I understand what is happening but can you clarify: the reducer from your code sample is the top level reducer (i.e. you are not usingcombineReducers`)?\nI suspect the logic in autoRehydrate relies on certain assumptions that combineReducer provides (like initial state being set from initialization). I will need to look into this more.\n. @tomprogers we have since made some improvements to the assumptions made in the stateReconciler in autoRehydrate. I suspect we should be \ud83d\udc4d  now\n. @ronanamsterdam thats not unreasonable but Ill share some additional context:\n1. in order to support async storage engines we cannot rehydrate as part of initial state. If you only want to use localStorage, then this simplifies the problem which is \ud83d\udc4d \n2. redux-persist@5 changes the model a bit, and while it still uses an async REHYDRATE action, there is a PersistGate component that handles the work of delaying render so integration is much simpler (although still not as simple as using sync localStorage).. this is available in the 4.0.0-alpha1 release \ud83c\udf88 \n. note: it is exported as purgeStoredState\npurgeStoredState(config) is the equivalent to \"purgeAll\"\n. what do you want to blacklist exactly? Blacklist only applies to the first tier of reducer, so in your example you can blacklist leads or locale. If you need more fine grained blacklisting you could implement a custom transform.\n. I believe this transform will work for you: https://github.com/edy/redux-persist-transform-filter\n. Can you point me to an example of how to lift replaceReducer?\nI am hesitant to do a breaking api change of switching to a reducer enhancer.\n. @mattkrick thanks for the reference now i understand what you mean by lifted reducer :) \nI believe we can classify this as a bug, and fix by lifting the reducer in v3. For v4 I will reconsider the higher order reducer option.\nredux-storage is a great choice as well, I am glad that worked out. Redux persist does a lot to be performant out of the box, hopefully after we get all of this sorted you can give it another try \ud83d\udc4d \n. the latest version now lifts the reducer. I am using it in a HMR environment and it works. If there are outstanding issues please reopen!\n. I am unfamiliar with this problem and have not done server side rendering myself. One possible fix would be to instead of delaying rendering entirely you render immediately with initial state but put a loader up until persist completes.\n. Hm, can you log out the actual error\ni.e. replace the console.warn with console.warn('Error in storage.getAllKeys', err);\n. @omichelsen @muratgozel sounds like an upstream localForage issue? localForage is great, but if needed you can always switch back to the asyncLocalStorage provided by redux-persist\n. @robclouth sorry for the delayed response. As you noted the transforms only work on the reducer level, and so will not maintain immutable top level state. There is an open issue and PR to address this but I want to make sure we get the api right before committing. In the meantime you can always use a custom rehydration reducer or apply the seamless transformation in conjunction wth getStoredState\n. This is not available out of the box but it should be trivial to write a transform that does that. It would look something like\njs\nlet blacklistTransform = createTransform(\n  (inboundState, key) => {\n      if (key !== 'data') return inboundState\n      else return {\n        ...inboundState,\n        data: undefined,\n       }\n  }\n)\n. while I have not personally used it, this project aims to solve this problem: https://github.com/edy/redux-persist-transform-filter\n. are you installing via npm? index.js is in src, but in the package delivered by npm you should see index.js in lib. If you install directly from github then you will need to build the project to get the built lib dir.\n. I am not familiar with typescript but I am open to adding support. I believe redux now ships with typescript annotations.\n. glad you got it solved! Not sure why import syntax would not work, but let me know if any changes to the lib would help.\n. @dannymy autoRehydrate is a store enhancer, not a middlware. try like this:\njs\nconst store = createStore(\n  rootReducer,\n  compose(\n    autoRehydrate(),\n    applyMiddleware(thunk, logger)\n  )\n);\nwhere compose is imported from redux. did you resolve the issue?\n. We might consider using setTimeout 0 instead of setImmediate.\n. Why do you want to change the key prefix? I think this will be a very rare use case, and your solution works.\n. thanks for the input, sounds like we definitely need configurable keyPrefix :)\nThis would be trivial to implement as a config option keyPrefix\n. I will cut a release soon, hopefully tomorrow \ud83d\udc4d \n. It would be good to add this to the config options in the docs. PR appreciated!\n. I am handling this scenario with https://github.com/wildlifela/redux-persist-migrate\nredux-persist-migrate requires manually specifying migration functions. If you want to do it automatically you @tomprogers has a great suggestion.\n. my bad for not reviewing this sooner. Is there a reason for closing? it is no longer applicable?\nIf you still think this is valuable can you explain why the PERSISTED action is useful? Could you instead rely on REHYDRATE as a proxy for PERSISTED?\n. I have seen this before although the specifics elude my memory. \nI believe it has something to do with the fact that AsyncStorage uses a json file store under the hood. Wild guess: you probably have either a packager issue or memory leak in your websocket dubgger. Make sure watchman is updated to the latest and that you are on a stable version of react-native.\n. @varungupta85 it looks like something bad is going on in your application that is opening to many files. In my experience it was the infinite creation of websocket connections. In your case it could be some other process. You might want to think through all of your functionality and figure out if you might have any recursive functions that open files or write logs. \nAnother possibility if you have the time is to look at an alternative storage backend for redux-persist. For example you could back redux-persist by SQLlite or Realm.\n. there is no way to persist data in incognito mode. In this case I think we need to detect this and not log these warnings. PR's greatly appreciated!\n. @jschr thanks for digging in. This is a conundrum. Is the warning chrome gives a console.warn? I am open to breaking changes in a v4 release, but want to better understand how we can solve this without sacrificing using localStorage as a default storage backend. \nI suspect we should lazily create the asyncLocalStorage backend only if a storage is not provided in the persistStore config.\n. redux-persist actually deals entirely with the front-end and has no concept of the network or offline/online.\nIf you wanted to write a custom storage engine that syncs to your backend when available that would be possible with redux-persist, but is not handled out of the box.\n. agreed. Here is a PR towards that affect https://github.com/rt2zz/redux-persist/pull/119 but I believe the purgeAll implementation needs work. If we go this route I would like to support both callback and promises.\nIf you have a chance to implement this please open a PR (or add to #119) and I will gladly merge!\n. This is done on master, will cut a new release in the next week or so\n. @Andarist I agree a simple window.localStorage check is probably best\nAlso good call on handling getAllKeys, I will get this merged asap\n. ya I had that version hidden behind a tag for testing. just released 3.3.2, should resolve this issue \ud83d\udc4d \n. I think this is a good idea. I would recommend releasing a new module called redux-persist-node-storage which could look roughly like:\n``` js\nvar storage = require('node-localstorage')\nmodule.exports = {\n    getItem: function (key, cb) {\n      try {\n        var s = storage.getItem(key)\n        nextTick(() => {\n          cb(null, s)\n        })\n      } catch (e) {\n        cb(e)\n      }\n    },\n    setItem: function (key, string, cb) {\n      try {\n        storage.setItem(key, string)\n        nextTick(() => {\n          cb(null)\n        })\n      } catch (e) {\n        cb(e)\n      }\n    },\n    removeItem: function (key, cb) {\n      try {\n        storage.removeItem(key)\n        nextTick(() => {\n          cb(null)\n        })\n      } catch (e) {\n        cb(e)\n      }\n    },\n    getAllKeys: function (cb) {\n      try {\n        var keys = []\n        for (var i = 0; i < storage.length; i++) {\n          keys.push(storage.key(i))\n        }\n        nextTick(() => {\n          cb(null, keys)\n        })\n      } catch (e) {\n        cb(e)\n      }\n    }\n  }\n```\nand could then be plugged directly into redux-persist as a storage backend. persistStore(store, {storage: reduxPersistNodeStorage})\n. while the code is duplicate it is also trivial and unlikely to change. IMO this is cleaner and easier to reason about from the outside.\nIf you do publish said module let me know, and I will add a link to the readme to try and get some extra eyes on it :)\n. \ud83d\udc4d \n. Thanks!\none note: it second argument to the transform functions is not action but rather reducer key. I will fix in a follow up commit\n. @laurmurclar this is a unique case I have not heard of before. I am not super keen on adding complexity to the core lib, but I wonder if there are clever ways we can accomplish this without modification.\ne.g.\n``` js\nimport { createTransform, persistStore } from 'redux-persist'\nlet store = createStore(...)\nlet customTransform= createTransform((subState, key) => {\n  // no-op if not reducer B \n  if (key !== 'B') return subState\n// get latest state\n  const state = store.getState()\n// build modified state for reducer B\n  const newSubState = { items: {} }\n  newSubState.items[state.A.id] = state.B.items[state.A.id];\n  return newSubState\n})\npersistStore(store, {transforms: [customTransform]})\n```\n. \u2764\ufe0f  thanks for the cleanup to boot!\n. I think https://github.com/rt2zz/redux-persist-crosstab is what you are looking for. I know a handful of people have used it successfully in the past, but we could definitely use more eyes and feedback. Let me know how that goes.\n. any idea why? we use babel-plugin-lodash during out build step, but I dont think that would be related...\n. his comment is suggesting that the issue is unlikely to be related to LodashModuleReplacementPlugin. \nAre you getting any exceptions thrown?\n. @gilbarbara I am not sure what is going on here. If you can take some time to dig in and debug that would be greatly appreciated.\nFWIW in the next release we will be switching the way we import lodash and removing babel-lodash plugin.\n. wow this was a weird bug, the lodash import was being convered to an array iterator and would not work on the collection (read: object) we have for state.\nAs a work around I converted code from lodash forEach to es6 keys -> foreach, working now in 4.0.0-alpha7\n. the lodash author weighed in, and basically are only two options a) do not use lodash functions on collections or b) bundle our code. I am inclined towards a for now.\n. is your top level state an immutablejs Map? this is currently an unsupported data structure, you can either\na) help contribute to the discussion for supporting immutable in redux-persist\nb) switch to redux-storage which does a similar thing and has immutable support\n. now in alpha: https://github.com/rt2zz/redux-persist-immutable\nthat package is a drop in replacement for redux-persist with full immutablejs support!\n. added error key\n. Also this adds promise support for purge #119 and static purgeStoredState export #127 \n. \ud83c\udf89\n. \ud83c\udf88 \n. Thanks! \u2764\ufe0f \n. \ud83d\udc4d \n. @mayankrungta are you using redux-persist? if its not persisting you might not have autoRehydrate configured correctly. Please post you configureStore code.. localForage is an opinionated external dependency, so while in most cases it is the preferred backend for web, it is not worth including as a baked in dependency which would be useless to non-web users (namely react-native, electron, or node)\n. In most cases I recommend delaying rendering your entire app until state is rehydrated. This can be done a few different ways, the easiest of which is described here.\nRehydration only takes a few ms (depending of course on some details like how large your state is), so usually this will cause an imperceptible change to app start time, but buys you a lot of certainty around how state is loaded and prevents accidental tricky race conditions.\n. @jasan-s we need help figuring out how best to use redux-persist in conjunction with code splitting. When a new chunk is resolved should we rehydrate any newly added reducers? \nThe safest default implementation is to blacklist any reducers that are view / chunk specific, and simply persist your core reducers (e.g. auth, dictionaries, etc.). Going to close this out, but if you want to chat more about integrating redux-persist-migrate and also code splitting I am happy to continue in a new issue.\n. Afaik redux-persist-immutable-state is not yet compatible with redux-persist. You can use redux-persist2 in the meantime or wait until we launch support, hopefully next week\n. Ok tentative immutable support now available at https://github.com/rt2zz/redux-persist-immutable\nnote I have not actually run this in an app, but the tests pass ;)\n. to answer your question, it was merged with amendments. The main difference is that redux-persist-immutable wraps redux-persist rather than requiring you set the config options explicitly.\n. closing as alpha version of redux-persist-immutable is now released \ud83c\udf89 \n. The second arg to createStore should be initialState not middleware. \nAs far as run 0.31, this lib was working for me and others. Might be something specific to your implementation. What version of redux-persist are you using?\n. Haha ya 31 has a bug where android promises do not resolve when debugger is on. Might be worth upgrading to run 32 if you can\n. You can set keyPrefix in configure object. Eg {keyPrefix: ''}\n. Ah sounds like bad programming ;)\nMind submitting a PR to specifically check if keyPrefix is undefined?\n. fix in 4.0.0-alpha4\n. I think this may be due to us not \"lifting\" the replaceReducer method in autoRehydrate.  I believe the solution is to re-apply autoRehydrate inside of replaceReducer.\nedit: to be clear, this is functionality we will need to add to redux-persist\n. @jasan-s more details here: https://github.com/rt2zz/redux-persist/issues/130\nI am not using this in a hot reloading env and had not had time to implement it yet. But I think the fix would need to change the way we enhance the store here: https://github.com/rt2zz/redux-persist/blob/master/src/autoRehydrate.js#L8\nSomething like:\njs\nlet store =  next(createRehydrationReducer(reducer), initialState, enhancer)\nreturn {\n  ...store\n  replaceReducer: (reducer) => {\n    return store.replaceReducer(createRehydrationReducer(reducer))\n  }\n}\nIf you can give that a try and make it work please let me know! I know many in the community would be greatly benefitted.\n. @jasan-s I released a tentative version of this in 4.0.0-alpha3, if you have a chance please give it a try and let me know how that goes.\n. https://github.com/rt2zz/redux-persist/blob/master/src/autoRehydrate.js#L11-L13\n. I am open to this if you can PR / provide directions\n. @marvinhagemeister probably because I removed the babel-plugin-lodash in favor of redux style import something from 'lodash/something'\nSimplest solution might be to add webpack-lodash-plugin into the mix, but I defer to you on best implementation there.\n. also ! awesome \ud83c\udf88 \n. also in order to play nicely with https://unpkg.com/#/ I think we need to add\n\"browser\": \"./dist/redux-persist.min.js\" to package.json\nand add ./dist to package.json \"files\" array\n. awesome! I am curious, you mentioned rollup & webpack 2, but I only see webpack 1, did you mean in the future we can consider switching?\n. nice \ud83c\udf88  LGTM, is this ready to ship?\n. sick money https://unpkg.com/redux-persist@4.0.0-alpha5/dist/redux-persist.min.js\n. this is a but in react-native 0.32. I highly recommend upgrading to react-native@0.33 \ud83d\udc4d \n. Do you want to disable the persistor and re-enable at a later time? Or do you want to essentially destroy the persistor? \nIn the former case, I think the existing pause functionality is sufficient. There will only ever be 1 subscription per persistor, and the performance cost of unsubscribing and resubscribing is negligible / not necessarily more performant depending on the circumstance.\n. for sure, \na) I agree lets add a \"destroy\" method. Not sure about naming, since it is technically more than just unsubscribing.\nb) Curious what your use case is? This sounds interesting, are you doing something unorthodox like hot swapping apps?\n. sounds interesting and highly doable with redux. I will not be in a position to implement a destroy method anytime soon, but will gladly merge a pr that adds it to the persistor.\n. @Rashhh you need to pass the storage in to redux-persist:\njs\n      componentWillMount(){\n        persistStore(store, {storage: AsyncStorage}, () => {\n          this.setState({ rehydrated: true })\n        });\n      //.... it will not be rehydrated immediately as that is an async process, the callback on persistStore happens immediately after rehydration so is the ideal place for it.. agreed, both ways are a little messy but this is a better approach.\n. just released 4.0.0-alpha6\nno great workflow for working off master, due to the build requirement. Open to ideas for how to improve this workflow.\n. @marvinhagemeister the challenge I have found is you still need to manually \"npm run build\" the project after it is installed from github since /lib is not checked in.\n. Did you try autoRehydrate? Did it not suit your use case for some reason? It does something very similar except in the form of a store enhancer instead of reducer enhancers.\n. yes it is intelligent in that regard.\nBasically it checks object equality on the reducers which are going to be persisted and only saves those which change. So e.g. if you use a blacklist, changes to any reducers in that blacklist will not trigger a storage event and will cost nothing in performance.\n. \ud83d\udc4d \nOpen to suggestion / PR for how to detect this scenario and display better error messages. In the meantime I believe this is solved.\n. @NeXTs I am not with good internet at the moment, but I can hopefully point you in the right direction:\ncreatePersistor will create a persistor, but not fire off any rehydrate action. You can then pass this persistor into redux-persist-crosstab to start receiving crosstab rehydration, without ever receiving the initial rehydration action.\nI have never used this flow before, so there may be some nuances that need exploring, but I suspect this general approach could work for you. Let me know.\nedit: to be clear, I am suggesting you might use createPersistor instead of persistStore\n. Agree with @marvinhagemeister \nAlso to elaborate on the error, it means json-stringify-safe failed to serialize the state. I would check out convListSortedByUpdatedTimeList() and IMClient to make sure these do not have any circuclar data.\n. if you want to serialize cyclic state (and somehow have a parser that know how to do that) you can implement it via a custom transform (createTransform)\n. closing due to staleness. The redux-persist code base is much more stable now, so I suspect adding a destroy method to the persistor could work.. What you are trying to do I suspect will always be somewhat expensive since you want to put all articles into a single Map. This is not a case that redux-persist handles particularly well out of the box. \nOff the top of my head, you might consider is storing each article under a separate key, possibly outside of redux entirely. Then in redux you can store a List with your article ids. Then whenever you need to fetch an article(s) you have an async get method that loads from storage.\nHopefully that helps. Let me know what you ultimately end up figuring out, and if there is a clean way for redux-persist to help support this use case I am all ears.\n. @JulianKingman sceario A is workable in some scenarios, but I think there are ways to get scenario B to work for you as well. e.g. \n1. if you set debounce: 1000 in config it will write to disk at most once every second. \n2. Another option if you are batch loading these documents at specific times, you can call persistor.pause() until you document sync is complete.. \ud83d\udc4d \n. afaict this is unrelated.\nedit @octaviogb that is, without a reproduction it is hard to follow up on. Feel free to reopen with more info!. I agree the naming is ambiguous. From redux-persist's perspective I think of it as owning the state in storage, whereas redux owns the application state, hence the in/out mapping you currently see. \nI agree with @marvinhagemeister rather than flipping it and making it confusing for the other half of users, lets make the terms explicit: outboundStateFromStorage / inboundStateFromRedux ?\n. If I am not mistaken this PR is just to update readme. \nSide note. 1000 stars! thanks @marvinhagemeister, we made it ;)\n. Just updated readme with explanatory comments \ud83d\udc4d \n. Hm, this sounds like a bug in autoRehydrate. Can you try adding autoRehdyrate({log: true}) and then report the log output here? Also what version of redux-persist are you on?\n. that message logs when https://github.com/rt2zz/redux-persist/blob/master/src/autoRehydrate.js#L55 hits, meaning the inbound state is either null undefined or false. Is questions the only reducer which is failing to rehydrate?\n. interesting. in the former case, how did you construct initialState? did the shape of that value look exactly like the shape of the resulting reducer tree?\n. @leguma I am open to having redux-persist always rehydrate, or at least exposing this behavior somehow. It is definitely a source of confusion. I hate to add more config options though, so perhaps this should be a separate stateReconciler?\nFWIW we do warn when this happens while debug: true...\nIt is unfortunate because the underlying complexity around this is actually quite low, it is just an issue with communication / api ergonomics. Even persistReducer vs persistCombineReducers I think leads to confusion. We need a new naming scheme.. Do you suggest that we always store state when the persistor is created? This probably makes sense, but I would have to think about if there are any possible consequences to this change.\n. possibly related to #189  ?\n. generally the simplest/best solution to this problem is to delay rendering your App until rehydrate completes. Typically this is only a few ms.\n. @dsernst glad you got it working. Yes redux-persist assumes immutable state which is crucial for performance reasons (serialization is not cheap). Open to suggestions for making this requirement more obvious.. @katopz if redux-undo is mutating is modifying its state on every action, that will indeed break autoRehydrate. The only realistic solution that comes to mind is to have add a force option to autoRehydrate that would force rehydration of reducers even if state was modified. . clear will remove all keys, where as purge removes only redux-persist keys. We need to preserve non redux-persist keys.\nIs the slowness of purge problematic for your use case?\n. ya :( I agree its slow. Open to suggestions.\n. @zhuangya as most users do not depend on fast purge, I think use cases that require this would be best served implementing purge themselves. i.e. calling localStorage.clear() directly. AsyncStorage stores everything in one JSON file, so while I have never hit the limit, I can imagine bad things happen when you do. Two possible options off the top of my head:\n- implement a SQLLite or similar storage backend\n- we can detect if the storage save errors and if so resave the previous state (this seems brittle however.\nOpen to others ideas\n. @ksegla have you tried one of the fs storage adapters for react-native? There are a couple of options here: https://github.com/rt2zz/redux-persist/blob/v5/README.md#storage-engines\nThe underlying problem here is that redux-persist does not have any elegant way to deal with storage limit max. This is not an easy problem because even if we know you are hitting the storage limit, there is no remediation that we can take automatically which is safe.\nAt present the best options are\n1. use a storage engine with a larger limit\n2. have your app check storage size and clear out lower priority data as needed\n3. store more data on the server\nThat is it as far as I know, as the problem is not specific to redux-persist, but moreso an inherent limitation of the platform. Open to suggestions for how the lib can help mitigate the problem of course.. @ksegla sorry for the churn, it looks like redux-persist-filesystem-storage does not yet support the promise api which v5 requires. I created a pull request to add support here https://github.com/robwalkerco/redux-persist-filesystem-storage/pull/4 but note I have never run this code and it may not work.. :) imo all js times should be ms unless otherwise specified\ntyty\n. how do you get this view? are you using localStorage or a custom storage?\nOpen to suggestions. we could switch to - but that would be a breaking change.\n. persistStore(store, { keyPrefix: 'anyString' })\ndefaults to redux-persist: \ud83d\udc4d \n. not sure what it takes to be a part of cdnjs, fwiw we already support unpkg (https://unpkg.com/redux-persist@4.0.0-alpha7/dist/redux-persist.js).\n. interesting. Can we simplify the check to simply running a localStorage.getItem('test key') call? I would assume that would throw and there is no need to also test set and remove?\n. also does sessionStorage suffer from the same quirk?\n. \ud83d\udc4d I decided to simplify the check to just getItem for now. This module is very sensitive to startup time and I want to be conservative with anything that could impact this.\n. I would like to support this case better, but for now there is an escape hatch by passing { serialize: (data) => data, deserialize: (data) => data } as config.\n. @marvinhagemeister I agree, I always prefer simple serializable state. I will say however that I have seen a couple of large projects successfully rely on the transit serialization from transform-immutable which handles Date objects well enough. Perhaps we should make that the suggested solution for people who want js dates in state.\nSounds like you agree custom serializer function is overkill \ud83d\udc4d \n. Agreed, we do nothing with the storage other than call the provided methods.\n. ah sorry, the readme is for v4, changing the import is one of the breaking changes we made to help with dead code elimination. \nYour syntax is correct for v3 \ud83d\udc4d \n. this is the v3 syntax, docs are for v4. I plan to cut v4.0.0 within the week.\n. thank you for looking into this and the PR! However I am actually quite suprised, I would expect the required order to be transforms: [ immutableTransform(), createCompressor() ] since we reduce left the transforms and it would not make sense to run transit-immutable on top of something the is already a string (the output of createCompressor).\nI have a suspicion that there is actually a bug in redux-persist-trasnform-compress which is causing this. I will have to follow up tomorrow.\n. just published bugfix where compress was inconsistently applying serialization. Perhaps this fixes the issue for you? https://github.com/rt2zz/redux-persist-transform-compress/releases/tag/v4.1.0\n. yes. since the transforms apply left to right when storing state, it would be best to first immutable and then compress. In the other order I would not expect immutable to work, although please correct me if I am wrong.\n. \ud83d\udc4d thanks for bearing with and reporting!. anyone know if we can do anything about this on our end? I am happy to cut a new release etc.\n. https://github.com/npm/registry/issues/85#issuecomment-261339504\ncan someone try again?\n. \ud83c\udf89 \n. @asciiman redux persist assumes state is a plain object (or really any type of Map as long as the correct config is provided). This assumption is useful for making persistence performant (store one keyspace at a time) and for making rehydration convenient (shallow-merge autorehydrate). \nWhile we do not have a test case for this scenario, an inspection of getStoredState leads me to believe your observation is correct, it would indeed return an object for your case (https://github.com/rt2zz/redux-persist/blob/master/src/getStoredState.js#L33).\nAny ideas on how we can improve this? One option would be to detect that the state is non-map and  act accordingly. This is such an edge case however I wonder if you might be better served with https://github.com/michaelcontento/redux-storage which while a heavier api, should handle your use case out of the box.\n. can you try again on v5.3+, we now detect if the substate is an array and if so skip shallow merging state. i.e. this issue should be resolved.. indeed \ud83d\ude80 . @simonacca ty for PR. The time iterator is actually important for the performance of redux-persist. Essentially what is happening is we create a queue of stores that need processing and then pull out of that queue every so often (every config.debounce).\nI think your PR has the right idea, but it actually needs to override a different level of the process. Something like: https://gist.github.com/rt2zz/950c4323a1e8b8eb9368aae973a325fa (untested, but I think close to where it needs to be). building the queue is quite cheap (object equality on old state vs new state). We could break this up accordingly to the debounce as well, but in practice that makes negligible impact on performance.\nAll of the expensive work happens in serializing and writing the string to storage, so that is the portion we want to break up and avoid doing all at once (except in the case of flush). closing due to inactivity. Key issue here is making sure default perf is unchanged by breaking up the serilaization calls.. Hm, I will have to look into this. The check in autoRehydrate is if state[key] !== reducedState[key]\nso as long as your reducer does not handle REHYDRATE that equality should be false.\nAre you using combineReducers from redux?. @adambene @Grmiade sorry for the delay I would like to get to the bottom of this. I just added a test for what I thought you were describing (rehydrate fails with initial state) but the test passes. Can you share more details or some code from your implementation? \nEven better if you can write a failing test!\nLet me know, hoping to knock this out this week.. @jeffreycrow this leads me to believe to that you are mutating state by default in your reducer.\ne.g. if you use switch statements the default case should always return state unmodified, i.e.\njs\n//...\ndefault: \n  return state\nThis will preserve object equality without requiring deep compares. @damianobarbati ahah, so your problem is const state = _.cloneDeep(previousState);\nI would rewrite your reducer as such:\n```js\nconst authState = {\n    loading: false,\n    success: false,\n    error: false,\nuser: null,\ngroup: null,\n\n};\nconst authReducer = (previousState = authState, action) => {\n    const state = _.cloneDeep(previousState);\nlet type = action.type;\nlet payload = action.payload;\nlet key = action.key;\nlet value = action.value;\n\nswitch(type) {\n    case SET:\n        state[key] = value;\n                return state;\n        break;\n    case SIGN_IN:\n        state.user = value;\n                return state;\n        break;\n    case SIGN_OUT:\n        state.user = null;\n                return state;\n        break;\n    default:\n                    return previousState\n        break;\n}\n\n};\nexport default authReducer;\n```\nBasically you need to preserve object equality in the default case where state is not modified.\nLet me know if that works.. \ud83d\udc4d . \ud83d\udc4d this is much better than those arbitrary set timeouts\nYou mentioned race condition, were you getting sporadic fails before?. @kevmannn apologize, this dropped off my radar. I am fully onboard with rewriting this poorly written test. Going to close this due to inactivity, but feel free to reopen\n. I am open to ideas here. The REHYDRATE action fires from persistStore, so perhaps the simplest solution here is to not call persistStore when debug session key is defined.. This is be a great storage engine. A cursory look at the docs https://pouchdb.com/api.html#fetch_document makes me think this will not be hard to implement, just need to conform to the expected storage api a la https://github.com/pellejacobs/redux-persist-node-storage/blob/master/src/index.ts. This could make for some really awesome features with syncing user session to a remote db or coordinating session across two remote peers . redux-persist@5 no longer relies on getAllKeys which leads me to believe writing an adapter for pouchdb would be trivial, just need getItem, setItem, and removeItem.. yes redux-persist-transform-immutable uses transitjs under the hood. You will have to double check that transit supports Map and Set. If it does, I would recommend making a new module redux-persist-transform-transit which skips the immutable part and simply applies transit.. closing, if you decide to make sure a module let me know! otherwise redux-persist-transform-immutable should work just as well.. Yes, whitelist and blacklist are mutually exclusive, you can technically define both but whitelist always wins and adding a blacklist would be redundant. \nbtw what is ignite?. @martinfilliau the REHYDRATE action fires with an error property. Could you consider implementing the error handling in either a middleware or reducer?\nActually thinking about it a bit, I suspect we might want to add an explicit error handler to autoRehydrate which already handles the rehydrate action, and seems like an intuitive place to handler custom fallback functionality.. If this is not sufficient I am certainly open to ideas for better error handling.. @Traverse can you explain what you mean by, \"the actions are fired with the initial state\". Are the actions in question thunks? If so this is true, the thunk will run before rehydrate and getState will return initial state.\nI can see three resolutions here:\n- update action buffer with thunk support (for delayed execution)\n- rewrite your thunks to not depend on getState (if possible)\n- go with @vovkasm solution of deferring calling the thunks altogether\nLet me know if that helps, I will gladly accept a pr to the action buffer for thunk support since that seems like a common enough use case, although we should probably hide it behind a deferThunks option so as not to break the other valid use case which is firing the think asap and only deferring the result.. @Traverse understood, in this case you are better going with what I think is the more stable solution and what I personally do which is defer loading the router until after persistence has completed. In most cases this is a trivial amount of time.. I just fixed the bad logic in the warning to ignore the @@INIT action \ud83d\udc4d \nAs for firing actions I still think it is best to delay rendering the router until rehydration is complete, but if this does not work for you, as @Traverse mentioned you can use redux-action-buffer + thunks to achieve more complicated logic. Just be careful not to introduce any accidental race conditions!\n. localStorage.clear() probably failed because after clearing it, it was refilled. You should use persistor.purge() to ensure redux-persist respects the purge.. docs are for v4. v4 beta was published as it is the only \"supported\" version, and had no breaking changes to documented features.\nI plan to release v4 this week along with a change log for said undocumented features.. There are actually 7 newer tags, they are just collapsed by default. Nevertheless, I just added release notes. Thanks!. \ud83d\udc4d. how are you accessing the action? You have a few options here:\n\nuse a effect handler like redux-saga for redux-observable to listen and act on the REHYDRATE event.\nuse getStoredState and createPersistor individually instead of persistStore to gain more fine grained control.\n\nThat said I am not sure why accessing the action would stop persistence as you mentioned. Are you getting errors?. are you using react-redux-router? blacklisting routing should work, is it possible you have the wrong key?\nOne way you can check is see if the REHYDRATE payload has routing data in it, and also verify the the transition happens after rehydration or not.. as you have observed the async nature of AsyncStorage (and localForage on web) make this something of a challenge, however I think this is a good thing, as async access is the only sane way to read from disk for large quantities of data.\nIn this case you are going to want to defer loading Router until after state has persisted. The simplest way to do this is as follows:\n```js\nclass App extends Component {\n  componentWillMount(){\n    persistStore(store, config, () => {\n      this.setState({ rehydrated: true })\n    })\n  }\n  render() {\n    if (!this.state.rehydrate) return Loading...\n    return (\n      \n\n\n    );\n  }\n}\nexport default App;. persistStore + autoRehydrate will handle all of that for you. In your case config should probably be { storage: AsyncStorage }\n```js\n// @NOTE make sure autoRehydrate needs to be set up in configureStore\nclass App extends Component {\n  componentWillMount(){\n    persistStore(store, { storage: AsyncStorage }, () => {\n      this.setState({ rehydrated: true })\n    })\n  }\n  render() {\n    if (!this.state.rehydrate) return Loading...\n    return (\n      \n\n\n    );\n  }\n}\nexport default App;\n```. @StephenMayeux great! fwiw I think your approach works great, but you can also use autoRehydrate to automatically achieve the same thing for all reducers \ud83d\udc4d . awesome! looking forward to merging this. See my question about how that dep works though ^. thank you! I went ahead and moved it to devDeps just because that feels more comfortable. @morlay I just updated the location and build step for types: https://github.com/rt2zz/redux-persist/commit/ff42d2f00c4148b9daf1669b22ec64a575731d4c\nDo you mind giving that a look over and make sure it still works for the ts case?. we follow the redux pattern, with the assumption the end user will implement https://www.npmjs.com/package/babel-plugin-lodash or es6 tree shaking.\nIf you think there is a better way I am all ears.. @unindented wow thanks for digging in. Yes as a starting point I agree omit can be removed, in this particular case we are reassigning the output to the original variable, so I think it is safe to do this mutatively and save some perf from not having to object copy.. while suprising, you may be correct about omit causing havoc. I see the compiled source does include directly out of lodash modules lodash/forEach etc.\n@unindented what tool are you using to create those visualizations?. I have not run analysis yet, but I removed two lodash methods omit and forEach: https://github.com/rt2zz/redux-persist/pull/236. \ud83d\udc4d . purgeStoredState simply purges the state from storage, does not affect the state in redux itself. It sounds like what you want to do actually is reset redux to initial state. If you do this redux-persist will automatically store the reset state, and no purege will be necessary.\nThere are multiple ways to reset state in redux, the simplest of which is to make an action called RESET and implement it in your reducer(s). Another option if you do not want to have to toy with your reducers is to store initial state when the app loads, and then send a custom REHYDRATE action with the initial state. Something like:\njs\nconst { REHYDRATE } . = require('redux-persist/constants')\n//...\nlet initialState = reducer(undefined, { type: 'noop' })\n//... sometime later\nstore.dispatch({\n  type: REHYDRATE,\n  payload: initialState\n})\nHope that helps. There are a few options, really depends on the rest of your set up which is best!. awesome, @morlay do you mind giving this a look over as well?. @morlay @LKay not 100% sure best path forward here (not having used ts myself). If we can get away with a single .d.ts file I would greatly prefer that. Let me know if I can do anything here to help.. Transit cannot serialize Error objects (this is true as well for functions). \n1. I would recommend only putting serializable state in redux, making this small sacrifice gains you a ton of interoperability\n2. yes you are right we should absolutely be more defensive about this. It appears we either need a try catch here: https://github.com/rt2zz/redux-persist-transform-immutable/blob/master/index.js#L14 or perhaps redux-persist should try catch all transform at the createTransform level. I will need to think about this. PR's welcome. . can you add log: true to autoRehydrate:\nStore = createStore(reducers, undefined, autoRehydrate({ log: true }));\nautoRehydrate will skip rehydration if you handle the action in your reducer. Double check that you are not modifying state in your default action handler in your reducers. The log on autoRehydrate may give us some hints here.. @JulianKingman sorry for the delay in getting back to you. The log warning you mentioned here: https://github.com/rt2zz/redux-persist/issues/244#issuecomment-270191582 was actually a false alarm in the debug logic, that has now been fixed.\nYes _.update would result in state being modified and hence autoRehydrate skipping. In this case I think your solution is reasonable.\nI am working on a way to make this immutability implementation detail more apparent to consumers, but for now I think things have to be dealt with on a case by case basis.. unfortunately JSON.stringify is expensive. We assume immutability and thus do reference equality as most redux reducers are immutable (if you need to change a value, make it a new object). \nIf your application specifically needs it to behave this way, I would recommend making a custom auto rehydrate that you store and consume locally which has this behavior.. wow good catch, sorry I did not see this sooner. Just released v4.2.0 with fix https://github.com/rt2zz/redux-persist/commit/5c20ec5f17e006d4a2e21af8144ff96811b22013. I dont think there is consensus yet on how best to handle this. If you use something like redux-saga or redux-observable it is easy to wait for 2 REHYDRATE actions and then fire a BOOTSTRAP_COMPLETE action which starts everything else.\nIf you are using plain thunks you might consider keeping the logic close to configureStore, and implement BOOTSTRAP_COMPLETE after both persistStore callbacks are completed.\nI am actually not sure what yo mean by buffering further REHYDRATE actions and unshift()ing, how does that work? . There is not presently a way to do this. a flush option has been discussed.\nIs there a reason you want to reload the app as opposed to sending out some kind of RESET action that resets state to initial state?. in practice I have not observed unsaved state to be an issue. That said I do like the idea of having a flush method which write all keys simultaneously and returns a promise. As long as this could be implemented cleanly and without adding a many bytes of code.. Thinking about this more, I would be favor of a flush method on the persistor which immediately writes all pending storage operations and returns a promise.. just landed in v5 redux-persist@5.0.0-beta.13\nawait persistor.flush()\nFeedback appreciated. Another option is to use the pause method of the persistor. Or you can use the value of remember me to decide whether or not to accept the rehydrate payload (using custom rehydration, not autoRehydrate). ty. done https://github.com/rt2zz/redux-persist/commit/676e68b930057f62cb4e7501ae3d764386a41928. @SleeplessByte indeed good catch. PR greatly appreciated!. hm, agreed keyA is more semantically correct. Yes redux-persist assumes the state shape is a map of some kind, typically an object as output by combineReducers. I tried to write the docs in a way that will be friendly to new users. If this is causing confusion I am open to amending them but would appreciate feedback from others first.. @jnishiyama sorry for the delay in taking a look. Yes I think you bring up a very valid shortcoming of the current approach. The upside is that bad state is less likely to stick around. \nI am working on a new form of autoRehydrate https://github.com/rt2zz/redux-persist-state-manager which among other things I has support for migrations built in which makes me more comfortable being more aggressive in taking persisted data.\nIts early, but if you are open to switching, I would gladly accept this PR over there. I will try to put up a readme this week.. note: my hesitance to merging this is because this project is used by many people and this would technically be a breaking change.. @jnishiyama I just updated redux-persist-state-manager with this change. It now only logs a warning (when log: true) but does not skip the value. I also updated the docs. Let me know if that works for your case.\nhttps://github.com/rt2zz/redux-persist-state-manager/blob/master/src/index.js#L72. @jnishiyama it is a higher order reducer, and hence should play nicer with hot reloading.\nMain breaking change is that it hard sets incoming state instead of shallow merging.. I think the recommendation here is to go with redux-persist-state-manager\nWe will make that approach the default in v5, but I think that is still a ways off \ud83d\udc4d . can you elaborate?. personally I think callbacks are the core async primitive of js, and react-native-web should definitely support it. I would be open to switching to promise based consumption in redux-persist, but only if it coincided with PR's to get the ecosystem switched over as well (e.g. https://github.com/abersager/redux-persist-cookie-storage/blob/master/src/redux-persist-cookie-storage.js).\nLet me know what you think, or if perhaps there is a clever way we can support both without any performance overhead.. ty!. done \ud83d\udc4d . I have not seen this, and have been running redux-persist 4.x against rn 0.40 for some time now.\nIf this continues to be an issue I am open to removing the use of reflect here: https://github.com/rt2zz/redux-persist/blob/1cd5d29ab49b96be1026e8bab67aaeae1699e9d9/src/persistStore.js#L27\n. @wachunei perhaps, but I doubt the benefits of Reflect.delete are worth the costs of polyfilling. delete should work just as well in this case.. you can also use something like https://www.npmjs.com/package/redux-persist-cookie-storage to store cookies which do not cause errors or warning.\nIn the future we will probably ship a recommended redux-persist-storage-web that rolls localforage + cookie fallback into one. If you find such approach works, feel free to release said module \ud83c\udf88 . @zalmoxisus good idea. I wish there was a clear way to distinguish \"storage not allowed\" from \"storage error\". Perhaps we should just be conservative in our fallback and warn in dev.. @gemma-ferreras did you figure out the issue?\nAre you running in a browser or in nodejs?. @isaachinman I am very apprehensive about making such a change. While I agree it is a very valid use case, that api reduces net compatability, makes other tools like typing more difficult, and also adds some complexity overhead. Also generally omitting values from an object is slow compared to picking. \nI think the solution here is to either write a transform a la https://github.com/rt2zz/redux-persist/issues/266#issuecomment-276628951 or perhaps we can come up with a better lighter weight module that provides sugar around said transform.\nOpen to further discussion, but I am unlikely to merge anything non-standard into the main module.\n. @wellyshen I am not sure, in the past I have not enabled hot reload for reducers, only component tree. That said it should work, but I think may be complicated by the abstraction level that was chosen for autoRehydrate (a store enhancer). In reality a higher order reducer is sufficient and simpler.\nTowards that effect, I would recommend you give https://github.com/rt2zz/redux-persist-state-manager a try. It is a higher order reducer which plays the same role as autoRehydrate and will soon be the recommended solution. . @marvinhagemeister I think so but still some open questions:\n- is shallow merge (autoRehydrate) or hard set (stateManager) better? the latter is simpler, but may lead to more runtime errors due to accidentally missing values that were present in initialState but overwritten by REHYDRATE.\n- is the api around migrations correct? One thing that smells bad is the dictionary of string integer keys { '1': firstMigration, ... }.\nHopefully we can get some early adopters to help feel out the answers to these questions, and presumably move over to redux-persist core in v5.. yes I will update to not warn on the init action. resolved in 4.2.0 ty!. @jephjohnson axios would not be the issue here. If you are using autoRehydrate, you should not need to have \njs  \n case \"persist/REHYDRATE\": {\n        const incoming = action.payload.tweets; // Carts is the name of the reducer\n        if (incoming) return {...state, ...incoming}\n      } \nin your reducer, autoRehydrate does this automatically. You can ignore the 1 action warning for now, that is autoRehydrate seeing the init action from redux which is expected.\n. Ah, so state is rehydrated, the only issue is the warning? I just published v4.1.2 which includes https://github.com/rt2zz/redux-persist/commit/de76cb9c6fd58a4735cbd6f196e86163b2887ff1\nBasically there was a bug in the warning logic, that should now be resolved.. FETCH_TWEETS_FULFILLED is presumably tied to the result of the fetch, which means in most cases it will resolve after rehydrate. Why would you want FETCH_TWEETS_FULFILLED before rehydrate?. \ud83d\udc4d . @Dante-101 I do not use typescript, but my guess is this should be solved by making sure localForage is typed correctly. Open to suggestions. ah ok so the actual type for Storage should be has either getAllKeys or keys. If it possible to model that in typescript?. Just released v4.3.1 (this appears to be a backwards compatible bugfix to typings, correct me if I am wrong). @marklawlor indeed, will resolve asap. @marklawlor can you confirm this is the correct fix: https://github.com/rt2zz/redux-persist/pull/285/files\nI am not a TS user. @marklawlor v4.4.1 out now with fix for Noop and getAllKeys optional. Let me know if that works \ud83d\udc4d . @marklawlor I believe this has now been resolved: https://github.com/rt2zz/redux-persist/blob/master/type-definitions/index.d.ts#L8\nv4.4.2 is out, as before let me know if any issues. I think this can be achieved today using https://github.com/maxdeviant/redux-persist-transform-encrypt, although that uses crypto-js not crypt.io.\nLooking at crypt.io it I think could work with some adaptation, but the one method it is missing is getAllKeys. This could theoretically be achieved by saving a separate known key which stores all other keys, but that would require some adaptation in redux-persist core. Open to PRs!. @robmoorman wow very interested in your implementation. is it materially different from https://github.com/maxdeviant/redux-persist-transform-encrypt ? \nAs for lock/reboot locking the keychain is there a workaround? do you keep the data you need in the background in a non-encrypted store?. Ah thank you much! purgeAll was deprecated in v3 and removed in v4. not exporting internal methods sounds great to me \ud83c\udf88 . right now to achieve said functionality you would need to implement a custom transform, or use a package like https://github.com/edy/redux-persist-transform-filter\nThe reason for this is we want to keep redux-persist as simple as possible and preserve our ability to do type checking with typescript and flow.\nI think more exploration needs to be done to figure out how to flexibly enable granular dynamic filtration in a performant way. e.g. omit is a costly operation, especially when applied to dynamic content.\nIf you figure out a good solution please let us know. A few possible solutions without creating a new module:\n- move loading states into its own reducer which is not persisted. This sounds weird at first but can actually work really well, especially for dynamic content. reselect should make it easy and efficient to recombine the loading state with its content.\n- write a custom REHYDRATE action handler in your reducer that only picks the state you want to persist.\n. @bulby97 is your top level reducer immutable? autoRehydrate does a shallow merge specifically to avoid this issue. That said it is still possible to have a situation where shallow merge is not sufficient and you will receive a crash (e.g. value was previously null, now expected to be object).\nYou probably have two decent options to fix this:\n- write a custom REHYDRATE action handler in your reducer. In this you can ensure whatever keys need to exist do exists, and do any other data manipulation required\n- use https://github.com/rt2zz/redux-persist-state-manager which supports migrations. then write a migration to default values appropriately for whatever keys are added.. @LKay done, released 4.4 and 4.2 respectively \ud83c\udf88 . @LKay can you double check this is an acceptable change: https://github.com/rt2zz/redux-persist/pull/285/files\ncontext: https://github.com/rt2zz/redux-persist/issues/273#issuecomment-280825763. \ud83d\udc4d . There is some additional discussion around android limits here: https://github.com/rt2zz/redux-persist/issues/199#issuecomment-277128093\nI do not have any solves off the top of my head, but I am open to ways we can be more resilient to storage limits.. @jamesisaac interesting, that could definitely be related. Do you have control over expanding the limit? Or possibly using other native modules like https://github.com/sriraman/react-native-shared-preferences. @joanrodriguez getAllKeys needs to be optional in order for localforage to type. perhaps the correct syntax is getAllKeys?<Result>(onComplete?: OnComplete<Result>): Promise<Result>;? . :(\nAgreed about adding typings tests. I am really wanting typings to come from the community, specifically users of said type systems. Perhaps we make type tests a requirement for the next typings PR to come through.. \ud83d\udc4d \nthere are two solutions \n1) is action buffer as mentioned above.\n2) is to delay your app from rendering until rehydration is complete: https://github.com/rt2zz/redux-persist/blob/master/docs/recipes.md#delay-render-until-rehydration-complete. @nicolabortignon yes that is one strategy, redux-persist-transform-filter would help you do something similar also.\nSeparately though, I generally recommend waiting for rehydrate to complete before starting any side effects, otherwise you run the risk of race conditions and hard to debug scenarios.. ty!. fwiw transitjs might have infinity support and would be trivial to implement as a custom transform a la https://github.com/rt2zz/redux-persist-transform-immutable/blob/master/index.js\n. thank you very much!. \ud83d\udc4d glad it worked out. good catch, that is definitely a redundant line. PR welcome!. for your example, I would still expect the return value of the reducer REHYDRATE handler to be valid. I think the more conservative approach is to always accept the reducedState and then simply remove line 64: https://github.com/rt2zz/redux-persist/blob/master/src/autoRehydrate.js#L64. null will go to the second side of the ternary here: inbound ? inbound(state, key) : state so this functionality should be unaffected by your PR. \nI see nothing wrong with the function check, but is it needed? we have TypeScript and flow type support if it is an underlying typing issue.. closing due to inactivity, let me know if you think this is still necessary. the rehydrate payload is null probably because after you deleted localStorage, it was never re-persisted. if you reload the app again do you see the payload?. ah, it looks like you are missing autoRehydrate, see the example usage here: https://github.com/rt2zz/redux-persist#basic-usage. If you delete localstorage, then the store will not persist on the next load because localstorage is where redux-persist keeps state between reloads. If you need better sandboxing of the storage values you can use localForage instead of localStorage.. Interesting, I have not heard of others having this issue. We do access process.nextTick, but only conditional on process existing https://github.com/rt2zz/redux-persist/blob/master/src/defaults/asyncLocalStorage.js#L4\nI could entertain an argument that we should simply use setImmediate, and skip the whole process.nextTick business which is mainly a node.js construct.. @scic @zerefel we made a few changes to simply the process usage, now the only reference to process is for process.env.NODE_ENV, which with a typical envify solution will compile down to a string literal.\nPlease let me know if the changes cause any issues for your builds.. that looks like an issue with your code, you need to assign keys to any components that are rendered in an array. yes you can persist todos and nextTodoId no problem, I would recommend setting up with the vanilla instructions in the readme.. closing as no longer relevant for v5. Thanks!. can you clarify what you mean by \"drop intermediate dispatches\"\nredux-persist will not affect the action dispatch at all, what it will do is queue any chunks of changed state to be written to disk.\nAre you noticing performance issues? I would recommend setting a small debounce like 16ms {debounce: 16}. This will trigger the writing of each chunk of changed state every 16ms and avoid unnecessary work.. thank you, I am considering getting rid of the process check entirely and always using setImmediate. @cascornelissen sorry for the delay. Currently async transforms are not supported. I am open to the idea but we would need to be very careful around performance and also error handling.\nWhat is the specific need that is async? Is it possible you can bake the async portion into the storage engine (which is already async, namely getItem and setItem). nice, approach seems reasonable. I am still not sure how this feature fits in, given that this complicates the common case. I am working on some lower level refactor atm, so for the time being I think the best options are either\n- keep rolling with your fork\n- implement the async encrpytion in the storage engine. appears to have just started: https://travis-ci.org/rt2zz/redux-persist/jobs/213698277\nif only we had yarned. Thank you for pointing this out. Yes PR would be greatly appreciated, IIRC we recently switched to the process check because users without webpack were getting a process is undefined error. \nWhat is the best way to restore this functionality while still shipping a working UMD build?. Great detailed post! This is fantastic - and yes this is way to easy to break! \nFeel free to PR, else I will likely get this in myself this weekend.. PR was here: https://github.com/rt2zz/redux-persist/pull/281\n@LKay In this thread we are discussing removing the env.js implementation you added and going back to plain process.env.NODE_ENV in order to allows envify to work, and remove the need for process polyfill.\nAs far as how to tackle this with other bundlers, I would imagine every bundler has a envify capability. I know at least webpack, browserify and rollup do. Short of that I would default to using gulp-envify.. resolved in v4.6. I am not familiar with onesignal, but it sounds like delaying rendering is causing the events to be lost until REHYDRATE is complete. You can work around this in a few ways. One suggestion is to put your one signal listeners outside of the rehydrate listener, and then buffer any received actions. e.g.\njs\n  <OneSignalController>\n    <App />\n  </OneSignalController>\nIf your onesignal data does not need to be persisted, you can simply add the corresponding reducer to the redux persist blacklist and then no need to buffer the events at all!. Implementation depends on your use case, i.e. why do you want to skip restore?\nIf for example you want to use the stored state as initialState rather than relying on REHYDRATE action you can do this:\n```js\nimport {getStoredState, createPersistor} from 'redux-persist'\ngetStoredState(persistConfig, (err, restoredState) => {\n  const store = createStore(reducer, restoredState)\n  const persistor = createPersistor(store, persistConfig)\n})\n```\ngetStoredState: finds all redux-persist keys, and then fetches them and reconstructs the state object.\ncreatePersistor: creates a stateful object that listens for changes to redux state and efficiently writes said state to storage.. getStoredState is always async, which means the closest we could get to something like being sync is to wrap it in an async function and await the result.\nAs for conditional persistence you can do something like\n```js\nimport {getStoredState, createPersistor} from 'redux-persist'\nasync function bootstrap () {\nlet restoredState = await getStoredState(persistConfig)\n  let initialState = restoredState.something ? restoredState : undefined\n  const store = createStore(reducer, initialState)\n  const persistor = createPersistor(store, persistConfig)\nReactDOM.render(\n    ,\n    document.getElementById('root')\n  )\n}\nbootstrap()\n. at this point skipRestore is an undocumented feature - its just hanging around because I am not keen on breaking backwards. I think at this point a deprecation message is the way to go.\nFor sure, I am working hard to keep this lib light an robust, and hopefully easy enough to use that there is no need to roll your own (simple as that may be). redux persist ideally obviates the need to each dev to think about things like handling safari private mode, inefficient serialize etc.\nI have some things planned for the future that should make the most common use cases much simpler \ud83d\udc4d Thanks for all the great feedback, its always welcome!. well, I suppose there may be a few ways to handle this - including possibly an api update. What is the condition you are deciding on? I have two thoughts:\n\npersistStore is fairly simple under the hood and could be replicated custom in your app easily enough. The key lines you care about are https://github.com/rt2zz/redux-persist/blob/master/src/persistStore.js#L23-L32 which basically does 3 things . \ngetStoredState\n\n\nfire REHYDRATE (should be easy enough to roll in some condition logic)\ncreatePersistor\n\n\nUsing https://github.com/rt2zz/redux-persist-state-manager instead of autoRehydrate, we could easily add a predicate config that would decide wether or not to handle the incoming REHYDRATE action.. Good call \ud83d\udc4d . interesting idea. A change like this might not be so trivial, for example when rehydrating, before we have grabbed the user state, how do we know which keys to rehydrate?. It looks like the flow definitions need work. TransformIn, TransformOut, TransformConfig and Transform all appear missing, and the type for Store seems to be causing issues as well. PR welcome!. https://github.com/rt2zz/redux-persist/pull/319. this is on v5 branch. Just added notes for v4.6\n\nWill try to be better about this in the future \ud83c\udf88 . Currently there are three ways to achieve this:\n- implement a custom REHYDRATE handler in your reducer which skips the keys you dont want to persist\n- use https://github.com/edy/redux-persist-transform-filter to achieve the same effect ^\n- refactor your reducer to store non-persisted state in different reducer than persisted state\nBest solution I think depends on the specifics of your app.. Apologize for the long delay, I have been working on getting v5 ready to go, and it is just about ready for primetime. I think v5 may solve the issue out of the box, or possibly some small modifications are required, lets discuss:\nPlease note, in v5 only one key/value is stored per persistReducer, so the solution is not directly analogous to the one in this PR.\nIf I understand the problem fully, the the basic goal is to have some portion of state partitioned based on some variable, in this case lets say its the user reducer, partitioned by userId. in v5 this can be modeled by only adding the user reducer once we know what the partition key is. so e.g.\n``js\n// event: user logs in\nconst persistConfig = { key:user:${userId}`, storage }\nconst persistedUserReducer = persistReducer(persistConfig, userReducer)\nstore.replaceReducer(combineReducers({\n  ...baseReducers,\n  user: persistedUserReducer,\n})\npersistor.persist() // @NOTE this method does not yet exist.\n```\nIf we want to go with this we need to add the persist method to the persistor which I have been thinking about doing regardless. \nErgonomically I think the challenge here is that the partition key need to come from presumably other state. Which means we would always need to first persist the primary reducer, then persist again for the partitioned reducer. I do not see a way around this, but we might be able to make the external api simpler, e.g. avoid store.replaceReducer. That might look something like:\n```js\nlet userReducer = persistReducer({ key, storage, persistKey: PERSIST_USER})\n// ...\nlet persistor = persistStore(store, undefined, () => {\n  let userId = store.getState().userId\n  if (userId) {\n    userReducer.replacePersistConfig({ key: user:${userId}, storage })\n    persistor.persist(PERSIST_USER)\n  }\n})\n```\nI am not sure which approach I like more, the idea of adding a replacePersistConfig method to the reducer is not particularly appealing.\nThoughts?. woo, ok sorry it took half a year to finish this off. Thank you @nevir for your patience, I apologize for taking so long to getting around to it. \nIn order to reduce the maintenance burden I applied this against v5, and is now included in 5.0.0-beta.13. The api is await persistor.flush() which will trigger all persisted reducers to flush their queue and immediately write to disk.. going to move forward with this as a v5 feature, 5.0.0 will be out next week.. nice \ud83d\udc4d . @ronnin why did you close? I have been busy and did not have a chance to late a look at this. Would it make sense to instead allow blacklist/whitelist to be a function, which would make it trivial to allow any match pattern including regex?. did you resolve the issue? I have never heard of this problem, and there is nothing in redux-persist that would cause a freeze. \ud83c\udf88 \n. What is the problem with calling global.setImmediate?\nIIRC this was the safest way to retrieve setImmediate from non-browser environments like react-native. It is also found in other places like this polyfill: https://github.com/davidmarkclements/setImmediate-min/blob/master/index.js\nI am very interested in resolving this, but do not fully understand the issue. Let me know! I would prefer to not introduce a new dep.. I do not know - if anyone else can weight in that would be great.\nIt occurs to me however, there may be a much simpler solution, we can remove setImmediate calls from all of the default localStorage implementation and we can replaced the use in persistStore as folllows\nconst genericSetImmediate = typeof setImmediate === 'undefined' ? global.setImmediate || function (fn) { return setTimeout(fn, 0) } : setImmediate\n->\nconst genericSetImmediate = typeof setImmediate === 'undefined' ? (fn) => setTimeout(fn, 0) : setImmediate. great, I will still mull over these potential changes but maybe with a little less urgency :D. @toranb in order to reduce the bundle size (and avoid setImmediate polyfill for babel users) we ended up going in a different direction: https://github.com/rt2zz/redux-persist/pull/334\nI am not sure how to make this compatible for people without global polyfilled (although that is a tiny polyfill). I think this needs more discussion.. could it make sense to do a tiny local scoping:\njs\nlet global = typeof global !== 'undefined' ? global : {}\ncc @Andarist @toranb . @MichaelMure glad you got it working. I think having two stores is reasonable, and quite possible the right solution. Additionally in redux-persist v5 there is another option, you can have multiple persistReducers. \nGoing with multiple persistReducers will require a bit more work, as you will need to \"add\" the user reducer dynamically. So something like\n```js\n// after user just logged in\nlet updatedRootReducer = combineReducers({\n  ...baseReducers,\n  user: persistReducer(config, userReducer),\n})\nstore.replaceReducer(updatedRootReducer)\npersistor.persist()\n```\nPerhaps there is yet a simpler solution - this is just what comes to mind. nice, we came to pretty much the same conclusion here: https://github.com/rt2zz/redux-persist/issues/329\nSeems clear then, that we should make the update.. My (limited) understanding is that we need to use global to be compatible across all environments (as setImmediate is not always in scope).\nIf there is an alternative I am all ears.. Turns out I had it backwards, non-babel users (e.g. ember) have an issue because they have no global polyfill. Continuing discussion in #329 \n. ya thats unfortunate. Fortunately we have setTimeout as a reasonable fallback, but this seems like a fundamental compatibility bug in webpack :( . Thanks, I will need to try this out. Can you clarify my understanding:\nimport constants from 'redux-persist/constants' will resolve to redux-persist/es/constants\nwhile\nconst constants = requre('redux-persist/constants') will resolve to redux-persist/lib/constants\n?. need to update the standard script not to process these files. Or it you want to wait, I think I will be landing prettier in the near future.. ha ok this makes more sense, I thought there was some weird module resolution rules that I did not know about \ud83d\udc4d . @guoliang1206 did you resolve the issue? the recommended approach is to show a loading indicator on your app until REHYDRATE is complete, and then render your navigator.. Sorry will fix asap, I think some files need to be whitelisted. In the meantime I would recommend 4.6\n. can you give 4.7.1 a shot \ud83d\udc4d . thank you!. just released 4.8 \ud83d\udc4d . awesome, crazy that we can get a full ~25% savings. ill cut a new release later today. @braco  its a hard problem, if we reconcile deeper, you can easily end up with incorrect state (unless you always write migrations). If we dont reconcile at all then, similarly you end up writing more migrations to make sure initial state is preserved. \nThe choice was to go with the solution that would work out of the box for the most people, in this case that is to shallow merge 1 level deep. I agree we can do more here to enable customizing the behavior. IMO the default should now be to do a hard set (make no assumptions) but there should be easy opt-in for shallow, and custom merge strategies.\nThis would not I think be done at the transform level however, and instead in the higher order reducer. I have some ideas for how to do this, although I suspect will not be ready for at least a couple of weeks.. couple of options:\n\nif your config is statically defined, you can use purgeStoredState as follows\n```js\nimport { purgeStoredState } from 'redux-persist'\nimport { persistConfig } from 'somewhere you defined it'\n\n// ...\npurgeStoredState(persistConfig)\n```\n\nexpose persistor via context, much like react-redux does for store\n\nI would recommend option 1 when possible. @deldreth did you resolve this issue? I have used it sucessfully with webpack 2+, wondering why the difference. I wonder if https://github.com/debitoor/safe-json-stringify could be a better alternative?. can you clarify the issue? I do not see props.user being used in that component. What is the expected behavior?. thanks!. nice, I think we should deprecate asyncLocalStorage in v5.\ntry/catch might still be useful to catch errors such as when quota is exceeded.. afaik setItem is the only call that errors under normal circumstances, but that would probably warrant more research before committing to dropping try/catch.\nCorrect we need to keep callback api for the general case, e.g. localforage and AsyncStorage (react-native) are both callback based.\n. v5 incorporated this into it, default storages are sync.\nThe rehydration process however is still async, and now there is a PersistGate component that helps manage delaying of rendering until rehydration is complete. Thanks all \ud83d\udc4d . nice! npm finally adding proper git install support!!\nthanks @Andarist . @CharlieHess sorry for the delay on getting back here. I like the implementation but am concerned by the raw amount of code, and also the possible support burden. I have been working on redux-persist v5 lately and there might be an opportunity to make some more drastic changes there.\nSome options\n1. support async transforms out of the box, change the time iterator to no longer use setInterval and instead wait for the result of each transform before continuing to the next piece of state (potentially with a setTimeout in between)\n2. in v5 while we serialize in chunks, we aggregate the results and only write to disk once. With this, instead of trying to do async at the transform level, we could consider a new hook to pre/post process the aggregated state just before writing to disk and just after reading from disk.\nOf course the challenge with option 2 is the variations are endless: some use cases might prefer to process the state before serialization, and other after. Some might require that the async process is blocking while others can run in parallel.\nSince this current solution is working for you I encourage you to keep using it for the time being (redux-persist@4 is not going to change much at all, so keeping up to date should not be difficult) while we take more time to think through how the api should work in v5.. @redgenie that is very concerning. I have not observed this and am not sure what could cause it. We are currently close to shipping redux-persist v5, which takes a different approach to autoRehydrate. \nhopefully you can debug and figure out what is going on, but short of that I think updating to v5 might be a reasonable alternative https://github.com/rt2zz/redux-persist/tree/v5. @bradennapier we took great care to update things to keep bundle sizes small and prevent unnecessary polyfills. In this case I am unaware why setImmediate is an illegal invocation.\nI see your comment on the webpack issue, it is not clear to me however is the issue that webpack is not processing files with module field? Also what was the change in webpack 3 that caused this breakage? . @THernandez03 what do you recommend as resolution? do you believe this to be a webpack bug?\nI would suggest if it is the es build causing issue you could import from lib import { persistStore } from 'redux-persist/lib'. \ud83d\ude4c @Andarist . @muscaiu did you get this resolved? Code looks ok so I am not sure what is happening. For simplicity and readability I would recommend adding autoRehydrate to the original compose, i.e.\njs\nconst enhancer = composeEnhancers(\n    applyMiddleware(thunk, router),\n    autoRehydrate()\n);\nI am not too familiar with  window.REDUX_DEVTOOLS_EXTENSION_COMPOSE but perhaps it breaks to reapply further enhancers on top of it?. hm, keys can be strings or symbols. I wonder if there is a way to typecast $Keys<typeof topLevelReducers> into strings?\nThat said I am not sure it would resolve the error. Perhaps type casting at the whitelist definition site would work:\njs\nconst persistConfig = { whitelist: ( x: Array<string> ) }\n. smart \ud83c\udf6a . @rkurbatov can you explain how this works in more detail? I thought flow always did subtype checking (except where a property is contravariant)\nI am fuzzy on all of this though. I believe it should be Promise<State>?. ah ya I was mistaken, at least in flow we would have no good way to parameterize that. Perhaps Promise<any> was in fact correct? I am not a TS user :/. in v4 purgeAll was removed, instead use purge().\nThere is also now a static method import { purgeStoredState } from 'redux-persist' if you prefer.. odd, I have never seen the behavior. Its possible your state object has a ton of properties you are not aware of?\nI would recommend a few things\n1. check your state, sounds like there is something unexpected on it\n2. use a whitelist, this is generally not a bad approach\n3. use localForage as your storage engine\nYou can also check the size of your localStorage usage, if the number is 2+ mb this could definitely cause perf issues, depending on the data shape.. it registers store.subscribe, then on every state change it does a shallow compare of the state, and updates any keys that have changed. Typically this is very performant, but it does depend on your exact implementation. You can always set debounce on persist config if it becomes an issue.. are you certain the issue is waiting for the response from the server and not that you have a very large payload that needs to be read from localStorage (which is sync)?\nI would try turning off thunk and see if its still locks. My guess is your state is large and switching to localForage (https://github.com/localForage/localForage) would help\njs\npersistStore(store, { storage: localForage }). more discussion https://github.com/rt2zz/redux-persist/issues/366\nopen to PR's, I am not currently using webpack 3 and cannot weigh in on the specifics. \u2764\ufe0f release going out now. that was v4, use import storage from 'redux-persist/lib/storage'for v5. ty!. ty! . @arvinsim I would recommend trying redux-persist@5 npm i redux-persist@next which has migrations built in. See the readme for basic docs: https://github.com/rt2zz/redux-persist/tree/v5. Myself and at least a handful of others are using v5 in production. It works great for the standard usage, I would only caution that there may be potential issues at the edges. For example there is not yet top level immutablejs support.. @piranna purge only purges stored state, leaves the redux state unaffected. If you want to reset redux state that is outside of the scope of this module. There are multiple ways to go about this, but in general I find most redux applications implement a RESET action.. @piranna not that I know of. In order for redux-persist to do something like that it would need to make some assumptions about initial state that I do not think would be fair. That said it could probably be done with something like:\njs\nlet initialState = reducer(undefined, { type: 'INITIAL_STATE_PROBE' })\nstore.dispatch({\n  type: REHYDRATE,\n  key: yourPersistKey,\n  payload: initialState,\n})\nThis could probably be pulled out into its own module, something like\n```js\nimport reduxPersistReset from 'redux-persist-reset'\nreduxPersistReset(store, persistConfig)\n```\n. go for it, I think it could be useful functionality for sure its a common use case!. hah fantastic! We will have to add that as a footnote to the purge docs.. \ud83d\udc4d @4.9.0 just released. nice!. @iRoachie done, v4.8.3 out now. yes this was an oversight on my part, it should be exported. The transform api has not changed at all so it should continue to work as before once exported.\nAs discussed on twitter I am still hesitant to implement top level immutable support until the api is finalized.. can you clarify what babysitting was required? redux-persist-transform-immutable should be compatible with v5 now that I added the createTransform export.\n. ya this is a bit confusing and should be documented. in v5 the callback does not receive any arguments so it will no longer be an issue. In v5 you will either call store.getState() if needed or if you need the intermediary state you can implement a migration.. Right the docs should be improved here. so basically the intended usage is with createMigrate which is a part of redux-persist.\ni.e.\n```js\nimport { createMigrate } from 'redux-persist'\nconst stateMigrations = {\n  '1': (state) => ({}), // remove everything from stored state (fresh start)\n  '2': (state) => .pick(state, ['reducerA']), // keep only reducerA\n  '3': (state) => .omit(state, ['reducerB']), // remove reducerB from state\n}\nconst config = {\n  ...\n  migrate: createMigrate(stateMigrations)\n}\n```\nwhere the underlying code is pretty much a straight copy of https://github.com/rt2zz/redux-persist-state-manager which was been working well in production for a while now.\nAs far as your specific questions:\n1. Yes it is a hook to process state after it is read from disk but before it is dispatched for rehydration. Technically it does not have to be a \"migration\" it could be any post-getStoredState processing desired. I named it migrate only for clarity about its intention, if its use as a generalized hook is popular we might need to rename it.\n2. It gets called every run, i.e. just before dispatching rehydration. The createMigrate factory that ships with redux-persist will noop if the version has not changed, but you could implement a custom migrate that functions otherwise.\n3. the migrate method needs to return a promise that resolves to the final state which will be rehydrated. So the simplest noop implementation would be migrate: (state) => Promise.resolve(state)\nHopefully that clarifies! I get this is not intuitive just yet and am open to suggestion about a) how to improve the docs and b) if any api or terminology changes are required.. if migrate returns undefined null or empty object then the reconciler will not have anything to merge and you will be left with your reducer's initialState. This will then be written to disk, so yes effectively it will act as a purge.. this is now handled via PersistGate in v5. The idea behind that is a component that can go around your app (right along side Provider):\njs\n  <Provider store={store}>\n    <PersistGate persistor={persistor} loading={<div>Loading...</div>}>. I think thats a good idea, although the actual action would probably have to be persist/BOOTSTRAPPED. Because now that we support code split reducers, the idea is being \"rehydrated\" is a little more fluid, however bootstrapped means: all of the initial reducers are now rehydrated.\nI would like to think about how this action is dispatched. It is not clear to me if it should be automatically dispatched always, or if it should be handled by a config option or integration point.. ok I want to think on it longer before adding a BOOTSTRAPPED action (need to consider performance and long term api). \nbut what might make a lot of sense is to add a third argument to persistStore which is a callback that will be invoked once bootstrapped. It would then be trivial to dispatch your own action which a saga can act upon. This is nice because there would be 0 performance implication for users who do not supply the argument, and would actually improve backwards compatibility with v4 persistStore.\nLet me know what you think, if agreed it will be a quick addition.. added to alpha.4\nThere is a test, although I have not run this code in an actual app. Please lmk if any issue.. also please note the error does not take any arguments as we do not have restored state or any error in scope at that point. If you need state the best option is to simply call store.getState() . I know for yarn yarn upgrade redux-persist@next will not work, I have been doing yarn remove redux-persist && yarn upgrade redux-persist@next although probably a cleaner solution exists. non relative path:\nimport { REHYDRATE } from 'redux-persist/lib/constants'\nSo to recap: the recommended methods to know when the persistor is fully bootstrapped are:\n1. in react: use PersistGate\n2. in general / for integration with redux-sage: use the bootstrapped callback argument to persistStore. From their you can dispatch a custom action as needed, something like:\njs\npersistStore(store, {}, () => {\n  store.dispatch({ type: BOOTSTRAPPED })\n})\nStill need to figure out the bes we avoid the rarely used {} second argument to persist store? For now the empty object I think is required.\n. right, v5 is written in flow, I am hoping someone will be kind enough to contribute TS declarations :)\nWith v5 the types are extracted into the build dirs 1-1 with each file, so hopefully porting those definitions to TS should not be too painful.. @openscript awesome!\nWith typescript does it make sense to get these type in early before they are complete, or is it better to wait for comprehensive definitions?. agreed lets get this going, in my experience once the ball is rolling further incremental improvements will come quickly!. just published the latest v5.5 - including several TS updates \ud83d\udc4d . I just updated with package.json: \"types\": \"./src/index.d.ts\" in v5.6.1\nfurther discussion around the types is ongoing in the PR #676 - feedback appreciated. right, storage is part of the config which is the second argument. Do you have any suggestions for how to avoid this?. I am not familiar with react-snapshot but it sounds like there are two options:\n1. use react-snapshot snapshotDelay option, maybe 500ms would be more than sufficient.\n2. use redux-persist getStoredState api, and do not call render until store is created. the fact that a snapshot delay of 1200 does not resolve the issue leads me to believe something else is blocking the resolution. How did action buffer solve the problem?. :/ im not familiar with react-snapshot, sorry not much help here. If anyone else has experience related to this please weigh in.. thanks, that was definitely an error. Putting purge below default will simply cause purge never to be called, I think rather what we need is to explicitly call the default action when the key does not match. Simplest code would probably be to switch to if statements instead of a switch.. ya, actually how about this for a clean solution: lets just move default out of the switch entirely:\nhttps://gist.github.com/rt2zz/2eddff64ddf258412760a5328bc0c99a. thanks for catching this, big oversight on my part! Do you mind updating the PR accordingly?. all good \ud83d\udc4d just published alpha.3. my bad, needed a break in there :(\nI rewrote it with if/else as I think that will prevent confusion in the future at the cost of a tiny bit of readability. https://github.com/rt2zz/redux-persist/blob/v5/src/persistReducer.js#L54\nLastly added tests and published as alpha 5. Thanks for help working through this.. assuming there is no tricky code hidden in your route components, this should not be happening. It sounds like you are getting a new page load when you navigate between routes. I am not sure why this would be the case, but one thing to check is that you use Link from react-router rather than simple  links.. @MichaelRazum why are you calling persistStore inside of the Banner component? typically you would only call persistStore once in your root module, like you have in your OP. Removing persistStore from Banner should resolve it issue.. wow ya I do not know what I was thinking. Thanks for you help and patience!. just published redux-persist@5.0.0-alpha.7. right so the issue is in store.js. the fix:\n```js\nimport thunk from 'redux-thunk'\nimport { persistStore } from 'redux-persist'\nimport { check } from 'src/utils'\nimport reducers from 'src/reducers'\nconst reduxDevTools = window.REDUX_DEVTOOLS_EXTENSION && window.REDUX_DEVTOOLS_EXTENSION()\nconst applyReduxDevTools = check.isDevAndDebugging && reduxDevTools\nconst store = createStore(\n  reducers,\n  applyReduxDevTools\n    ? compose(applyMiddleware(thunk), applyReduxDevTools)\n    : compose(applyMiddleware(thunk))\n)\nconst persistor = persistStore(store)\nexport default { store, persistor }\n```\ni.e. persistStore returns a persistor not the original store. I recommend you export both so you can pass store to Provider and pass persistor to PersistGate (a component to delay rendering until the rehydration is complete).\nLMK If you have suggestions for how to improve the docs to avoid this confusion in the future.. no need to use getStoredState. I would update configureStore as follows:\n```js\nexport default function configureStore () {\n  const store = createStore(\n    reducers,\n    undefined,\n    check.isDevAndDebugging\n      ? compose(applyMiddleware(thunk), check.isDevAndDebugging)\n      : applyMiddleware(thunk)\n  )\n// @NOTE not sure what this does, assuming listeners is defined outside of this method?\n  listeners(store)\nconst persistor = persistStore(store)\nreturn { store, persistor }\n}\n. also note: the reason you had a promise was that async functions always return promises. Make sure you remove the async flag on configureStore. no you should not need to manually do `persistor.dispatch({ type: REHYDRATE })` that happens under the hood. I think maybe you still need to wrap your reducer in persistReducer, e.g.js\nimport { persistStore, persistReducer } from 'redux-persist'\n//...\nexport default function configureStore () {\n  const persistedReducer = persistReducer(reducers)\n  const store = createStore(\n    persistedReducer,\n    undefined,\n    check.isDevAndDebugging\n      ? compose(applyMiddleware(thunk), check.isDevAndDebugging)\n      : applyMiddleware(thunk)\n  )\n// @NOTE not sure what this does, assuming listeners is defined outside of this method?\n  listeners(store)\nconst persistor = persistStore(store)\nreturn { store, persistor }\n}\n```. :/ my bad, there was a bug beta.1, just released @5.0.0-beta.2 which I have confirmed resolves the not persisting bug.. do you have a global error handler set up or any other special configuration? its possible an error is throwing and causing the app to reload. \nOn way to debug is to put a breakpoint in redux-persist/lib/persistStore.js at https://github.com/rt2zz/redux-persist/blob/master/src/persistStore.js#L32 and step through to see if the rehydration completes without error.\nFWIW I have never heard of this behavior before, definitely strange.. sounds like a bug in componentDidMount (Home.js:280), can you paste the code in Home.js here?\nPerhaps try commenting out componentDidMount and see if the issues goes away? If so we know its definitely a bad interaction there and hopefully that will help narrow it down.. thank you!. just released v4.9.1 with this. Note: v5 is around the corner, but we do not have typescript definitions for v5 yet. \nShould not be too hard to figure out though as the new code base is now written in flow which should be mostly compatible type wise (nothing fancy). :/ tyty. thank you!. v5 will be out hopefully next week. We are using it in production already, so while there is some risk of instability, I would encourage you to upgrade now!. There have been a steady amount of minor issues. My plan is to release v5 once we get through a whole week of 0 bugs \ud83d\udde1 \nNevertheless, I still encourage you to use v5, as mentioned we are already using it in production, and the more people who use it the faster we can get to stable release.. right, the logic to operate first order keys is pretty hard baked: https://github.com/rt2zz/redux-persist/blob/master/src/createPersistor.js#L39-L63\nI have been thinking in v5 about adding some concept of \"partition keys\" which could solve what you are describing but to date it is only a thought.\nTo answer your question directly I think you have three options:\n1. write a custom persistence solution for your app\n2. put your files in an entirely separate redux store, then redux-persist@4 will work as you desire out of the box\n3. upgrade to redux-persist@5, write custom getStoredState and createPersistoid implementations that store/fetch based on partition rules, and update persistReducer to take these methods as custom config options (https://github.com/rt2zz/redux-persist/blob/v5/src/persistReducer.js#L23)\nThe reason (3) would be best implemented as a config override is because it will require the storage engine have a getAllKeys method, and furthermore take a non-trivial amount of code that we do not want to burden simpler implementations with.. right the closest thing we have right now is config.migrate which allows for async transformation of state as it is being restored. No way to do async on the way to serialization atm.\nMainly concerned with performance and code size. We may reconsider its inclusion again in the future but I think it would be too risky at the moment.. I am not against this, but I am concerned by a few things: \n1. is async await support prevalent enough to include at this point?\n2. what happens if the async transforms return out of order. You might stagedWrite an old state over a newer one. We probably need some sort of nonce to protect against this\n3. is there a perf cost to the IIFE? any reason not to simply make the parent callback async?\n4. do we need a timeout based write state trigger. Right now staged write waits for all keys to drain before actually writing out state, but async transforms create a risk that the pending key pool infrequently gets fully drained. This is the most performance critical and difficult to debug piece of redux-persist so I want to make sure we get this right.. :) I still want to figure this out, it does seem to have a lot of value, but also a lot of risk. Once the first release of v5 is out and stable I think will be easier to re-evaluate. As for this PR, I say we leave it open as a reminder to follow up.. purgeStoredState only returns storage.removeItem as a convenience so the callsite can \"wait\" for the purge to complete if need be. It sounds like your requirements are pretty specific so it may make sense for you to maintain some custom logic here. The only issue I see is that getStorageKey is currently internal to redux-persist, perhaps that method needs to be exported.\nThat said, if you simply want to purge all files, I think the simpler solution is to put files in their own persistor and then purge the entire persistor.. @Noitidart purge is never called by redux-persist, so really you are in control of when that happens. Rather than having a pre-purge callback, I would think you could implement this logic by calling this custom files handling just before calling purge in your application code. Would that work?. ya good catch, this was recently broken while trying to optimize persistReducer.\nI am thinking maybe the logic is actually to have a more strict passthrough case (at the end of persistReducer). This seems to make sense since all of these lines https://github.com/rt2zz/redux-persist/blob/v5/src/persistReducer.js#L116-L120 are irrelevant if PERSIST has not yet been handled.\n```js\n// if we have not already handled PERSIST or state is undefined, straight passthrough\nif (!_persist || !state) return baseReducer(state, action)\n// otherwise, pull off _persist, run the reducer, and update the persistoid\nlet newState = {\n  ...baseReducer(restState, action),\n  _persist,\n}\n_persistoid && _persistoid.update(newState)\nreturn newState\n```\n. fix is out in 5.0.0-beta.3 \ud83d\udc4d . blacklist should work, can you share your configureStore setup?. ah I see, I realize this is confusing. In v5 all config has moved onto persistReducer, so you should take blacklist off of persistStore and put it on your \"storeConfig\".\nI will add some validation to help catch these issues in the future. why do you want to pause the persistor during async calls? \nIf you want to do this, I think you will have to maintain some registry of \"async\" calls, and only unpause when the registry is empty.\nIn redux-persist@5, there is currently no pause method. The architecture supports it, but I would want to better understand the use case first.. @leethree ya this is unfortunate, we should really be using Map here, which we could perhaps do with object to map conversion as a fallback:\njs\nconst migrations = new Map([\n  [1, () => {}]\n])\nWhat I would recommend in the meantime is to make your keys strings like so:\njs\nconst migrations = {\n  '0': (state) => ({}),\n};\nLet me know if you have opinions about the api / using Map instead.. @leethree Map is not yet supported, I was suggesting that as a possible api change that redux-persist could make. \nI think we at a minimum need to update the type on MigrationManifest to accept string keys: https://github.com/rt2zz/redux-persist/blob/v5/src/types.js#L37. @leethree updated to accept string keys in #436 and cut new beta.11 release\nlmk if that works. there is not currently a way to migrate state from v4 to v5.\nI think the way to solve this would be for redux-persist to ship with a pluggable \"getStoredState\":\n```js\nimport { getStoredState } from 'redux-persist'\nimport { getStoredStateV4 } from 'redux-persist/lib/integration'\nconst v4Config = { / whatever the old config was / }\nconst config = {\n  key,\n  storage,\n  getStoredState: async (persistConfig) => {\n    let storedState = getStoredState(persistConfig)\n    if (!storedState) storedState = getStoredStateV4(v4Config)\n    return storedState\n  }\n}\npersistReducer(config, baseReducer)\n```\nIts not the prettiest api, but the pattern would be generally useful, could be used to move from one storage engine to another for example.\nNOTE this is not currently possible, we would need to add getStoredState option to config for this to work.\n. the implementation would be trivial, I just would want to take some time first to make sure this is the right api. In abstract I would like to call the config option: \"migrate\" or something, but unfortunately \"migrate\" is a loaded word, we already use that for migrating state between app state versions.\n. I just took a first stab at it: https://github.com/rt2zz/redux-persist/tree/v5#experimental-v4-to-v5-state-migration\nI have not run this code at all so it likely requires some tweaking, but it should be generally a good approach.. I just tested it and it works as expected (new changes after the purge are persisted). Are you on web or native?. agreed it is ambiguous. Serialize I dont like because transforms may do other things.\nWhat if we just make it clearly ambiguous state and rely on the comment to guide people?\njs\nlet myTransform = createTransform(\n  // transform state coming from redux on its way to being serialized and stored\n  (state, key) => specialSerialize(inboundState, key),\n  // transform state coming from storage, on its way to be rehydrated into redux\n  (state, key) => specialDeserialize(storedState, key),\n  // configuration options\n  {whitelist: ['specialKey']}\n)\nOpen to other suggestions. gotcha, ya good idea. Right from the docs all I swapped was inboundState -> state\nCouple other options might be preTransformState / postTransformState or changed createTransform to take an object of the shape { applyTransform, unapplyTransform, config }\nFor now I will simply add comments to source \ud83d\udc4d \n. that means that your reducer for myKey is modifying state. Typically this is solve by making sure your default case for the reducer returns plain state\ni.e.\ndefault:\n  return state\n. @leethree good catch, that dev check has now been updated to skip _persist key: https://github.com/rt2zz/redux-persist/blob/v5/src/stateReconciler.js#L60. great, I still need to get around to applying a rollup umd build to v5. are you referring to uninstalling your app or uninstalling redux-persist?\nThe former I believe will reset state. . this might be relevant: https://stackoverflow.com/a/44065166\nI am not certain under what scenarios it will be cleared vs kept, please post back if you figure out the conditions.. the code\njs\ncase REHYDRATE: var incoming = action.payload.user if (incoming) return {...state, ...incoming, userData: processSpecial(incoming.userData)} return state\nis sample code from the docs. You should not need to copy it verbatim into your code base. In fact in most cases you should not need to add case REHYDRATE to your reducer at all. I would recommend removing that code.. got it, then ya you will want something custom. e.g. to get all state for the given reducer:\njs\n// yourReducer.js\ncase REHYDRATE: \n  return { ...state, ...action.payload.yourReducer }\nyou can implement whatever custom code you want in here to conditionally restore bits and pieces of your state. Are you using v4 of v5?. @burrack that is correct, whitelist will only work on top level keys. so e.g. of the state has shape:\njs\n{\n  login: loginState,\n  otherThing: otherThingState,\n}\nadding whitelist: ['login'] will cause only login to be persisted, not otherThing. @Elena2016 what issue are you having? whitelist should work, make sure you have it applied to the persistConfig, not passed to persist store. I am not a TS user, but this looks good to me. If anyone finds issue please open.. I am leaning towards registering purge when the reducer first sets up so that we can await the promises. Should be a relatively small and safe refactor. ok this just landed in 5.0.0-beta.13\npersistor.purge() now returns a promise that will resolve once all persisted reducers declare purge complete. \nThanks for discussion \ud83d\udc4d . also please test and LMK if it works as expected.. The code is there: https://github.com/rt2zz/redux-persist/blob/v5/src/persistStore.js#L74 that said, I wrote a test for flush but not purge (https://github.com/rt2zz/redux-persist/blob/v5/tests/flush.spec.js). I think the next step is to write a test for this.. woah, this looks like a bug. I am leaning towards lets be consistent across all env, I am just not sure is it better to throw or return null?. closing as no longer relevant in v5, thanks!. v5 is a bit more complicated, roughly the flow looks like this:\n\n\nserialize each piece of substate so the working state looks like this:\njs\n{\n  foo: serializedFoo,\n  bar: serailizedBar,\n} \n\n\nonce all substates are serialized, serialize the entire thing and write to disk. in pseudo code:\njs\nlet final = serialize(workingState)\nstorage.set(key, final)\nIn this case we have already serialized all substates so workingState is simply an object of strings for which serialization is super fast.  \n\n\nfoo changes, redux-persist detects this and re-serializes only foo, and then again proceeds to step 2.\n\n\nSo All in all it is pretty performant for most use cases. The one additional cost as compared to v4 is that we set the entire serialized state into storage all at once. In my observation serialization is much more costly than storage sets. Additionally this choice was made for two reasons:\n1. now we can guarantee consistent state.\n2. its easier to coordinate the single state write to happen in idle time than it was to coordinate lots of little writes.. Also I should note::\n1. you can add throttle to the persistReducer config to force a delay between the serialization of each sub state\n2. in v5 one can apply persistReducer to each sub-reducer rather than the root. This allows for more control over state (e.g. a large throttle on one and not antoher). \nRedux persist strives to be both performant and consistent out of the box. Of course this still needs to be tuned per the specific needs of each app and there may be special cases where the defaults are not ideal. FWIW in most of my production apps the default set up has been great.. thank you for sharing this, mind if we ship this utility in redux-persist? im thinking it could live at import storageCallbackAdapter from 'redux-persist/lib/integration/storageCallbackAdapter'. awesome! added to the readme https://github.com/rt2zz/redux-persist/tree/v5 . you might be doing something like \n```js\n//bad\nconst store = persistStore(createStore(...))\n//good\nconst store = createStore(...)\nconst persistor = persistStore(store)\n```\nShort of that, it might be some bad mocks?. can you post your failing test here, there might be something wrong with the setup. can you explain your use case for calling pause? in v5 there is currently no pause method, and depending on the use cases I am trying to figure out what the best api will be.. the goal here is to prevent further save operations after pause is called?. nm just saw the issue, responding there.. as noted this will need to be rethought for v5, but for v4 \ud83d\udc4d . can you elaborate on the need for this? what action do you plan on taking upon storage write? I am wondering if this should be generalized for all storage operations, or if perhaps this should be a feature of the storage engine itself.. combineReducers is the standard usage. Are you using redux-persist@4? If so, adding autoRehydrate as a store enhancer should make it work out of the box, with no need for custom rehydrate handling. See the usage in the readme.. The thought was that in a node SSR environment you would not persist. Is there a reason you need to or want to persist during SSR?\nTwo thoughts\n1. If you do skip persistStore during SSR, you also need to not render PersistGate\n2. if you do want to persist during SSR, then yes removing _persist is a workaround.\nI am open to making adjustments. At a minimum it sounds like we need a simpler way to make PersistGate a passthrough component during ssr. maybing something like a disabled prop.\n. ok now I better understand. So there is a problem in the code, in these lines: https://github.com/rt2zz/redux-persist/blob/v5/src/persistReducer.js#L56-L70\nwe noop if persist state already exists. I think the fix may be as simple as adding one line before line 58:\njs\nif (!_persistoid) _persistoid = createPersistoid(config)\nIts not clear to me however, in this case where the server has already rehydrated the state, do you want the frontend to rehydrate again? My guess is no in which case that one line above I think fixes the issue. \nLet me think on this a bit longer before I make the change to the lib.\n. just published rc.2 with this: https://github.com/rt2zz/redux-persist/blob/v5/src/persistReducer.js#L57-L58\nI think that solves the problem. @joturako I have never done SSR but I have a suspicion that if you are using redux persist cookie storage then you actualy do not want the FE to rehydrate at all. Instead you want initial redux state to be initialized with whatever the backend rehydrated from cookies.\nPerhaps this is more of a question for SSR in general with redux: how does the server set initial state for redux on the client? I think if I better understood that then we could make it work with the redux-persist api. E.G. one option is to not have redux-persist rehydrate at all, but still write state updates. That would look roughly like:\n```js\nimport { createPersistoid } from 'redux-persist'\n// later with store in scope\nlet persistoid = createPersistoid(persistConfig)\nstore.subscribe(() => persistoid.update(store.getState())\n``. ah nice - we should add this to the docs. hm, there is no way to \"destroy\" persistence, but you can pause the persistoid viapersistor.pause()` I wonder if that might solve your issue? \nStill it seems to me that if you are still getting updates after sending the response thats means the store and the persistor are both still in memory on your server which would cause memory to grow forever?. just released 4.10.1 with TS fix. what storage engine are you using? Is it plain react-native AsyncStorage?. that definitely could be an issue with the storage adapter. I might recommend taking a look at upgrading to v5 which does not rely on getAllKeys. sorry about that, @5.0.0-beta.16 removes the remaining errant logs. Thanks for bringing this up. async usage was removed in 5.0.0-rc.1 in favor of simple promises \ud83d\udc4d  so polyfill should no longer be required.\n. ty, I updated the labels slightly \ud83d\udc4d . glad you got it working, I just added some basic docs around PersistGate \ud83d\udc4d . adding release notes for v5.4 - will begin doing regular release notes with releases. redux-persist relies on serializing the state, i.e. really only works with plain objects / primitives. If you want to persist a User class, you will need some serialization and / or rehydration handler. The simplest way to do this would be to customize your REHYDRATE case in your reducer, something like\njs\ncase REHYDRATE\n  if (!action.payload) return state\n  let user = new User(action.payload.auth.user)\n  return {\n    ...state,\n    ...action.payload.auth,\n    user,\n   }. is your top level state immutable or just the sub reducers?\nEither way I would expect this to work, redux-persist does an equality check on the substate to decide if it should persist, and if nothing changed, strict equality should be preserved . I generally agree, but I do think that the redux ecosystem has a strong convention around object equality <> immutability.\nMaking isStateEqual or shouldUpdate pluggable would be fairly simple implementation wise, but I worry it will make maintenance and code size marginally worse. Also there are many pieces that may be desired to be pluggable, e.g. we need to also consider making state getter, setter, and iterator pluggable as well for immutable support.\nOpen to more discussion on the topic.\n. persisting happens all the time, is there a reason you want to be notified? Also v5 has a flush method that returns a promise which when resolved means \"persist is complete\", perhaps that can work for your use case?. added some notes the the usage section: https://github.com/rt2zz/redux-persist/tree/v5#usage\nfeel free to propose further improvements \ud83d\udc4d . This is the first report I have heard of this. Which storage are you using? Is it possible there is some other exception being thrown during rehydration, perhaps from within one of your reducers that is causing the rehydration to fail?. Redux persist only updates when the page loads. If you want tabs to sync you will need a helper like redux-persist-crosstab.. This was a small oversight: I added the ability to nest persisted reducers, but I forgot that combine reducers yells if it finds unexpected state. Now fixed in rc.5 https://github.com/rt2zz/redux-persist/commit/42766d246442ce3328505741d1308ed87a99ec4d\nI would say that the present api is unlikely to change, but\n1. small bugs and edge cases are likely to be found and be fixed\n2. likely to add a persistor.pause() method\n3. currently considering support for async transforms\nThank you for helping test. We just added autoRehydrate config boolean to support the case where the default state reconciliation is not appropriate. I am not yet sure if in this case there should be an option to provide an alternate state reconciler via config or if instead the suggested usage will be as you have it where you implement a custom case REHYDRATE statement. LMK if you have opinions.\n. is now \ud83d\udc4d . so redux-persist can only persist serializable data, i.e. no functions. based on state.data.fb.auth().signOut(). it looks like you have both auth and signOut as functions stored in redux state. Is this setup custom to your app or is that provided by firebase?\nMy assumption is you need to pull auth / signOut out of redux state and put them into redux actions.. Are you certain you have installed v5, i.e. npm i redux-persist@next? It seems persistReducer is undefined.  Also below where you call let persistor = persistStore(store, {storage: AsyncStorage}) you do not need to pass config to persistStore, simply calling\nlet persistor = persistStore(store)\nshould suffice\n. thank you, looks like this is likely a dupe of https://github.com/leethree/redux-persist-fs-storage\nNothing wrong with that, although for the sake of the docs I think we will need to settle on just one to include in the readme.. You should not need to do any manual persistence or flush calls. Really using redux-persist should be as simple as adding persistReducer around your root reducer + persistStore around your store.\nCan you elaborate on what you mean by sometimes it is not auto saved? If you add debug to the persistReducer config you may get some helpful logs that may illuminate what is going on.\nkey is used by redux-persist to distringuish persistors (if there are multiple). It is required just because that seemed safest for forward compatibility of possible future features, in and of itself it does not do much.. I am finding there are many possible desired state reconciliation strategies, including this one should state inherit from pre-rehydrate state? But actually the problem is further complicated because this actually creates two levels of \"shallow merge\", i.e. in the standard combineReducers case where persistReducer is applied to the root reducer:\n1. reconcile each sub-reducer that we have incoming state for\n2. shallow merge the state for each of these sub reducers\nWhere this starts to get really tricky is when persistReducer is not applied at the root, but lets say e.g. on just the \"auth\" reducer. if auth has the shape: { user: {...} } We will end up shallow merging the user object which I think is not desired.\nI need to think about this more. Not sure how to fully capture this useful logic without restricting the number of use cases for which reconciliation is useful.\n. you need to give PersistGate a loading prop, e.g.\njs\n<PersistGate\n     loading={<div />}\n     persistor={persistore}>. that looks like a react router issue, I would recommend opening there. You are probably using window.history rather than react router history.. You might look at / try https://github.com/rt2zz/redux-persist-crosstab\nIt uses the exact event to sync between tabs.. right, I have been hesitant only because I have not used it in prod / do not know what limitations exist. but I know others have used it in prod successfully.\nNext step is to figure out how it would work with the forthcoming redux-persist@5. persistor as a singleton is one option. In general singletons are discouraged but the persistor typically only makes sense as 1 persistor per process, and is not typically used during SSR, so in this case singleton might just work.  Your other option is I think to send persistor along with whatever calls your action - but that requires more work to expose persistor via context.. yes purge should be removing basedate. Perhaps basedate is getting changed to null immedaitely after purge which cases persist to occur for this key? Do you have any code that sets basedate to null explicitly and if so can you try and trace out if it is being called after purge?. how are you installing v5? the recommended way is via the next tag which is a compiled release npm i redux-persist@next. this was old, pre-v5. now you can just install per normal npm i redux-persist. not sure what is going on,\n1. I recall a while back, AsyncStorage was broken on android with debug enabled. Obviously not the same issue, but it is possible this is an upstream bug.\n2. perhaps more likely something is erroring out. Can you add debug: true to your persist config and see if any errors are logged.\n3. is if (typeof self === 'object') before persisting the store to make sure it does not persist in SSR? that check may have broken in more recent versions of react-native which could explain why it works in the browser (with remote debug) but not on device.. the es build is intended to have es6 imports, primarily because that allows for tree shaking. I expect that webpack should handle the es6 modules without any custom configuration, so the fact that you are getting this error I would say is unexpected. What version of webpack are you using?\nA short term fix is to import from the lib dir (all commonjs modules). I am not a webpack expert, but I suspect the issue is somewhere in the webpack config or version. FWIW redux-persist works out of the box with webpack with no custom includes for me on multiple projects.. honestly I am not sure, from what I am reading webpack should understand es6 modules. But if your goal is simply to get babel to transform away the es6 modules, you are better off using the lib build which has already taken care of that.. @mauron85 thanks for the feedback. Ill explain the logic behind it, but yes there is probably room for further optimization, I am very open to new ideas on the matter.\nWhy v5 works like it does\nBy using just 1 key, we get a couple of big benefits: \n 1. no longer need getAllKeys in storage adapter. This means rehydrate is faster, and makes the lib more compatible with storage libraries that lack a decent version of this method.\n 2. state is stored all at once so you can never end up with inconsistent state atoms (e.g. if there is an implicit dependency between two sub reducers, it could be problematic if one updated and the other fails or is interrupted.\n3. v5 supports nested persisted reducers. This means we can no longer reasonably assume we are persisting the top level combineReducers reducer - and in turn for handing this power back to the implementor, it is less clear how to automatically break up the persistence.\nPerformance:\nThe double stringify comes from a performance \"optimization\" we have, which is that we serialize each key separately over time. Stringify is typically the most costly part of persistence (and is all on the main thread) so we want to make sure to break that up as much as possible. Saving to disk however is typically on another thread and async so, saving a giant combined value all at once is not so scary.\nThe double stringify then comes from the fact that we have a bunch of sub-states serialized, that we need to combine and serialize again before we can save to disk. I have done some very basic benchmarking - JSON.stringify of a stringified object is 100% - 150% faster than JSON.stringify of the original object. IMO worth the the tradeoffs.\nThat said there is probably room for further optimization. e.g. since we know we are always storing an object of strings at the top level, perhaps there is a more compact and custom way to do the final serialization that does not require escaping the quotes in the sub state strings.\n. in v5 this would work:\njs\nlet rootReducer = combineReducer({\n  a: persistReducer(persistConfigA, a),\n  b: persistReducer(persistConfigB, b),\n})\nso e.g. you might persist one set of state to sessionStorage and another to localForage. Or you might configure special rules in one to expire stored state on rehydration etc.. Right, this is not well documented currently nor have I actually done this myself. I think Instead of creating a new persistor, you want to call persistor.persist() on the existing persistor.\nFrom there what should happen:\n1. a new persistoid gets created inside of the persisted reducer https://github.com/rt2zz/redux-persist/blob/v5/src/persistReducer.js#L70\n2. the next time state updates, this conditional passes and triggers persistoid.update https://github.com/rt2zz/redux-persist/blob/v5/src/persistReducer.js#L156-L159\nIf either of those things is not happening then there is certainly a bug. lmk, I dont have time to set it up right now but will doe my best to review any issues that arise and am open to making changes required to fix this / make it easier.. ya this whole area needs more exploration. The api was designed to handle this conceptually, but actually the not in the way @rskaar is doing it.\nI was thinking codesplit reducers would work as follows:\n1. add persistReducer around just the codesplit reducer (if needed blacklist this reducer in your root persist config)\n2. then call persistor.persist()\nWhen the nested persisted reducer gets the persist action, it will take care of rehydrating itself thus avoiding the getStoredState call.\nLets reopen this and keep the conversation going.. great! that is pretty much how I was hoping it might work. Let me know if you find any issues with the approach, if this proves itself out over the next couple weeks Ill look to add explicit instructions to the docs.. options:\n1. do not nest messages, bring it up either to the top level of the reducer, or as its own reducer\n2. implement a custom REHYDRATE handler in your reducer. In there you can do whatever custom deep merge you like and then autoRehydrate will simply ignore that substate when it sees the state has been modified during rehydration.\n3. propose a PR to make state reconcilers pluggable. I think we want to go in this direction, because there are too many possible use cases to cover all with one reconciler. Some useful reconcilers that we can ship with are hardSet, shallowMerge, deepMerge, mergeLevel2. Not 100% on the naming but thats the idea.. hm, this is a difficult issue, because there are some cases where you want the removed reducer state to stay in storage, e.g. if you are adding / removing reducers dynamically (e.g. code splitting).\nIs it possible to have redux-form nested one level deeper, i.e. \njs\nstate = {\n  form: { \n    form1: {...},\n  },\n}\nIf it needs to be top level state, then I think we need to think about an api change or addition that will make deleting state possible without making it impossible to have dynamically loaded persisted reducers.. I see, and is your persistReducer wrapped around the root reducer or the form reducer?\nAssuming persistReducer is around the root reducer, it should be storing the updated state without the removed keys. i.e. it should work like you expected it to work. If that is not the case then I think we will need to work up a test case and figure out what is going on.\nIn the case that you want to wrap just the form reducer with persistReducer, then yes it sounds like we need to think about how to add this feature without disrupting support for code splitting / lazy loaded reducers.\nIll start thinking on this a bit.. ok I think I was mistaken earlier, the code split case is handled via second persistedReducer, so we should in fact be removing removed keys when they are removed from state. We will need to double check that no known use cases are impacted by this change, but assuming not I think we should do this change on v5.\nIn the short term, you might consider pulling your form persistReducer up to the top level with whitelist: ['form'] in config. Note however: if you do go this route short term, there will be no easy state migration to get back to the nested persistReducer form.. @Zycon42 this may have been resolved in 5.1.0. Right, so it looks like we just have a bad proxy for the Store type: https://github.com/rt2zz/redux-persist/blob/v5/src/types.js#L80\nMaybe we just loosen that up and make it return any. sorry I linked to the flow type, but I think there is something similar on the v4 typescript type. \ud83d\udc4d  lmk, I am not using typescript myself, but am committed to keeping up to date definitions in the lib.. Right, purge returns a promise, not the persistor. I think you want\njs\nconst persistor = persistStore(store)\npersistor.purge(). What data is missing when it persists? is it inconsistent or always the same set of data?. Are you using code splitting or hmr?. decided to go with stateReconciler over autoRehydrate. @jirikolarik can you clarify, the latest version for v5 or v4? what is the flowtype error?. \ud83d\udc4d  ill publish a new v4 release as well. released v4.10.2. @eaponiente the basic strategy is to listen for when persistor is bootstrapped, and delay rendering until bootstrapped is true. I have no knowledge of angular, but there should be some way to show a loading indicator while a process is occurring. You can see in the react integration we set up a listener for when persistorState.bootstrapped === true. https://github.com/rt2zz/redux-persist/blob/master/src/integration/react.js\nIf you get a good working example I would love to include the integration into the lib and the example into the docs.. @maplion that can be a good strategy for simple cases. This lib will help with a number of things that you may need now or down the road:\n\nbetter perf by default (splits up the serialization work)\nstored state migrations\nknowing when rehydration is complete\npause / flush / purge\nsupport code splitting reducers\n\nAll told the trade off is basically 5kb for a robust persistence solution.. I am not familiar with nativescript, but custom storage engines are quite simple, just requires three methods with a simple promise interface: https://github.com/rt2zz/redux-persist/blob/v5/src/storage/createWebStorage.js. tyty. I have not used redux-loop, does it add functions to each sub reducer?\nAlso what is the specific error you are getting? the default serialization is JSON.serialize so it should just omit any methods and does not necessarily need to result in error.. ah I see. we store state in _persist as a peer to the other keys, which is a big reason we need it to be a plain object. It seems like redux-loop perhaps only temporarily changes the state shape? Im not 100% sure what integration would look like, but I would be open to reviewing a PR. \nNote we are unlikely to take on any changes that will impact performance or have a large scope.. ya, it may be that v4 is better fit for this case since it doesnt store any persist state. Will require more investigation to know for certain what the options are \ud83d\udc4d . is it possible util reducer is modifying its state? If any piece of sub state is modified, then state reconciler will skip rehydration for the sub state.\nIf that is not the case then I am not positive what is happening. I am thinking about adding a new stateReconciler that can be plugged in which does not do the state mutation check, so would always cause incoming state to be rehydrated. If mutation is indeed the source of the problem then I think this new state reconciler is the best option to fix the issue.. nice! ya I have long considered removing that \"skip if modified\" logic, but it has stuck around for legacy reasons (don't want to break everyones code needlessly!). Glad you got it working \ud83d\udc4d . also fyi in v5 you can know everything is done rehydrating by checking persistor.getState().bootstrapped, which is how the provided react integration component PersistGate works.. thanks!. the problem is that you are returning persistor from configureStore, you probably either want to return store or return both { store, persistor }. Make sure you give store to react-redux Provider, as well as anything else that needs redux store. Persistor will only be used for purging and PersistGate.. I am assuming you have persistReducer at the top level and are using combineReducers? The basic problem here is that you are expecting rehydration to merge 2 levels deep of your state tree, while redux-persist by default only shallow merges 1 level deep. The plan is to make this extensible via the stateReconciler config. Here is for example the default 1 level deep reconciler: https://github.com/rt2zz/redux-persist/blob/master/src/stateReconciler/autoMergeLevel1.js\nNote most of that is just dev sanity checks, the real reconciliation is just these lines https://github.com/rt2zz/redux-persist/blob/master/src/stateReconciler/autoMergeLevel1.js#L61-L79\nSo ya, I think a hypothetical autoMergeLevel2 stateReconciler would solve your use case. Question is, is there some cleaner way to expose this? e.g. this is typically the desired behavior when used with combineReducers, but not otherwise. So we could ship something like combineAndPersistReducers.\nOpen to thoughts on how to best solve this problem.. @reblws I apologize for not reviewing this sooner. Is there a reason you closed it other than age? this seems like the right approach to me and fwiw I prefer this implementation to https://github.com/rt2zz/redux-persist/pull/572 for aesthetic reasons. thanks for looking out :D \nI was hesitant at first on this PR only because I wanted to make sure serialize as a boolean made sense, vs say allowing it to be a custom function or other. But I think this is the right call, if a custom serializer is required that can be done as a transform. as the error says, you need transforms on the persistReducer config, not the persistStore config. The redux-persist-transform-expire are probably not updated for redux-persist v5 yet.. options:\n1. update redux-persist-transform-expire to work with v5 (not sure why it would break)\n2. upon rehydration check if the access token is still valid and act accordingly. This can be done either\n    - in PersistGate onBeforeLift\n    - in persist config migrate method\n. Would it be cleaner to make it optional? we can default it to null although that wont work for react 15.... I would strongly recommend you use PersistGate, otherwise weird things might happen when your app mounts without the rehydrated state.. I agree it should be optional, and probably return the less opinionated null rather than <div>loading</div> among other reasons because we might be running outside of dom and not have div. \nI suppose if someone is using react 15 they will be forced to provide a value, which is likely something we can put a dev helper check for.\nThanks for the feedback \ud83d\udc4d . why do you think that is a serialized promise? I believe promise will serialize to nothing.\nI am not sure if #506 could somehow be related, but I do plan to solve that issue in the near future so we can see if that helps.. If anyone has thoughts on the method name please weigh in. I chose persistCombineReducers for it familiarity but am open to alternatives.. thanks quick catch :D. I absolutely would like to remove that and not just for constants but all deep imports. The only question is what is the best alternative pattern? I know @Andarist has been thinking about this issue for some time.\nOpen to suggestions, hopefully one that does not involve maintaining a separate es5 constant file outside of src.\n. cool, sounds like proxy modules is probably the way to go for now then. We might export all constants out of the main module (i.e. import { REHYDRATE } from 'redux-persist) and then provide proxy modules for integration and storage.. constants are now available from the root module. Still open because we need to add proxy modules for storage and state reconcilers. @Andarist open to suggestion, but I will list the files that I think are considered to be part of the public api:\n- ./storage/index.js (although perhaps we should rename this to local.js\n- ./storage/session.js\n- ./stateReconciler/hardSet.js\n- ./stateReconciler/autoMergeLevel1.js\n- ./stateReconciler/autoMergeLevel2.js\n- ./integration/react.js (or should we expose this top level as just 'redux-persist/react'?)\n. @Andarist with scoped packages, we would need to publish separate npm modules for each correct?\nAs I understand it, there are two reasons we use proxy modules:\n1. in the case of integration/react to avoid issues with the \"undeclared\" dependency of react. Of course even having the undeclared dependency at all is bad smell, but I hate to publish a separate module for what is an extremely common use case.\n2. in the case of stateReconciler and storage, it is in order to avoid possible module bloat in the case that the consumer does not have tree shaking.\nI could be easily convinced that 2 is not a valid reason - I just dont know the numbers. How many users have tree shaking bundlers? under what circumstances might tree shaking fail? etc.\nWhat do you recommend @Andarist ?. wow I had no idea how deep this went! great reads.\nSo I am 100% onboard with going flat bundle conceptually. \nI am concerned that this line in storage will cause issues (dynamic property access of window). Maybe integration/react and storage are simply two exceptions that do not get flat bundled? This also mirrors the fact that most users do not need to import from storage as AsyncStorage for native and localForage for web are recommended.. we are going to move back to recommending persistReducer over persistCombineReducers - the latter of which was an attempt to simplify things but actually seems to have added to the confusion. \nThanks! \nThat said v5 afaik still does not have full immutable support, open to PR's to add immutable support similar to how we had it in v4 with a stateOperators config. perhaps the docs did not make this clear, but you should not need combineReducers that is handled by persistCombineReducers, so simply change reducers/index.js to be \n```js\nimport { combineReducers } from 'redux'\nconst initialReducer = (state = [], action) => return state\nexport default {\n  initialReducer \n}\n```\nOpen to suggestions for how to improve the docs around this.. this sounds reasonable and should be fairly straightforward to implement. right this was added recently \ud83d\udc4d . v5 does things a bit different, the entire state get stored in one key, so doing a blacklist check on read doesnt do much. If you are getting blacklisted state it sounds like there may be a bug in the createPersistoid method.\nPerhaps related to https://github.com/rt2zz/redux-persist/pull/521. Ok I think I better understand now there was a related issue that was recently fixed where we did not clear removed state: https://github.com/rt2zz/redux-persist/commit/e9549a8f3764b13b7acb8a7068396cf6df18abcd\nPerhaps stateReconciler should additionally respect the blacklist during reconcilliation. I like this, however am worried about react 15 support. Is there any way to check what version of react is being used and throw a helpful error accordingly?. TIL lol :D \nthanks. I agree this is a pain right now, clever workaround though. \nIts not a trivial problem and I am all ears for how to make this doable without workarounds. A few things we might consider:\n1. part of the \"plain object\" assumption is so that we can colocate _persist state in the state tree. however this is not strictly required, we could just as well store the persist state either in memory or in the persistor. This change could be made without any external api changes, but it would be fairly extensive and would need to be well teted.\n2. stateReconciler is pluggable so supporting immutable there should be no problem (as you have demonstrated)\n3. persistoid.update assumes the incoming state is an object so it can achieve a higher level of performance by breaking up work per sub-key. I am not sure how to elegantly workaround this. in v4 we simply made configurable the concepts of state getter / setter / iterator but this felt heavy and I am reluctant to reintroduce this pattern.. what do you mean by \"click the link to launch the application with a populated storage, the application never starts\" which link are you referring to?\nI know many instances of redux-persist working in ie11 / edge, so my thought is this is a nuance with your set up although it is not clear what (the code pated looks good).\nCan you check two things\n1. the state of the store, does the _persist state show rehydrated: true?\n2. the state of the persistor (call persistor.getState()) does it have an empty registry and bootstrapped should be true.. also I have not personall used HMR w/ reducers, but I think after calling store.replaceReducer you need to then call persistor.persist() in order to get the replaced reducer kicked into action.. hmm that is odd. so the code in PersistGate is pretty straight forward: https://github.com/rt2zz/redux-persist/blob/master/src/integration/react.js\nIs it possible that the PERSIST action is not being fired at all (in the link navigation case)? This should be observable using redux-devools (I recommend https://github.com/zalmoxisus/remote-redux-devtools). I dont think this is the issue, but looks like to do need to switch the order of these calls: https://github.com/rt2zz/redux-persist/blob/master/src/integration/react.js#L28-L29. just updated in 5.2.2, again I dont think this is the issue but worth updating regardless :/. \ud83d\ude13  \ud83d\udc4d \nDid the fact that the REHYDRATE action was being somehow swallowed complicate the debugging?. right, so es folder means es modules build meaning you need the necessary transforms to make that work. Webpack likely handles that for you during bundling, but not so during tests.\nI would say your best bet is just to use lib, the alternative is to use a es modules transform against all node modules.. the docs now use lib everywhere \ud83d\udc4d . @Pajn in redux-persist@5 you can do\njs\nawait persistor.flush()\nOf course that means you need access to your persistor in the action, which can be done either by manually stringing it together and providing it as an argument (e.g. via context) or via singleton.\nUsually singleton would be a no go because of SSR, but since most people do not use redux-persist during SSR there can be ways to make this work, and if you dont use SSR then there is pretty much no issue.. \ud83d\udc4d . two issue top of head:\n1. you need a loading prop for PersistGate, can be null <PersistGate persistor={persistor} loading={null}>\n2. you need to replace combineReducers with persistCombineReducers. in the next release loading will be optional, so will no longer be an issue :). O I just realized readme i already up to date, ill cut a release soon. tyty. hm I have not used epicMiddleware but I will comment on how redux-persist work and hopefully that narrows things down a bit:\n1. PERSIST action goes out with a register and rehydrate function attached\n2. persisted reducer picks up the action and starts rehydrating, this includes calling rehydrate which triggers a dispatch on the main store.\n3. REHYDRATE is handled to restore state, and then everything marks itself of rehydrated / bootstrapped at which point the gate is lifted.\nIf observable swallows PERSIST or REHYDRATE actions for any reason this flow will be short circuited. One thing that might help with debugging is to step through each action using redux-devtools and see where the hang happens.. ah excellent point, this is in fact a bug - or at least not intended. I suppose we should always persist _persist since the whole versioning design does not work without it. This can probably be an easy 1 line change to createPersistoid. thank you \ud83d\udc4d . that is correct, right now reducer state needs to be objects. I plan to update this in the near future to  support non-objects.. actually just cut redux-persist@5.3.0-rc which hopefully resolves this. npm i redux-persist@next to test. if you have non-object state then you will want to use persistReducer rather than persistCombineReducers.\njs\nlet rootReducer = combineReducers(reducers)\nlet persistedReducer = persistReducer(config, rootReducer). ya to elaborate a little bit, persistReducer only shallow merges 1 level or state, while persistCombineReducers merges 2. \nStill looking for how to surface these options in a developer friendly way... but ya for now persistReducer should be the way to go for your case \ud83d\udc4d . @chrisbull are you using immutablejs?. this has been fixed in 5.3.4 \ud83d\udc4d . im do not believe its a fair assumption that process.env.NODE_ENV === 'test' means localstorage cannot exist. I would rather explicitly use memoryStorage in our tests, which I think is doable we just need to export memoryStorage.. I chose instead to do it explicitly by using memory storage directly in the tests which should achieve the same effect \ud83d\udc4d . right now any of your 3 options will work, and yes in the future the plan is to make it importable from the root module.. no lets leave this open as a reminder, will probably reexport them from root in the next release. This is one of the biggest challenges with persistence. There are two approaches\n1. write custom tests which test the rehydration of old state snapshots and ensure the app still loads\n2. reset redux state when there is an uncaught error.\nBoth of these solutions can be tricky to implement, so if others have alternates suggestions please share.. Yes I think there is some confusion and I am all ears for how to clear it up. If you use persistCombineReducers you should not need to also use persistReducer. They basically do the same thing under the hood, just with slightly different reconciliation strategies.. @levsero interesting, glad you are testing out the v4->v5 state migration! Is it working otherwise?\nI think agree with defaulting state version here. Since the code relies on version existing, if it were to not exist for any reason (even though this should never happen) we want the migration to still make sense.. actually I just realized the this default to default version if state version === 0 which i incorrect. Will need to update. updated to include an undefined check \ud83d\udc4d . I cut a release under the next tag (5.3.0-rc) with this change as well as a change to support non-object substate. I would say the changes are fairly safe so if you are able to give it a go and confirm we are \ud83d\udc4d I will cut 5.3.0 proper.. ya, check the readme for v5 upgrade instructions, or otherwise feel free to stick on v4 it works well for most use cases. you replace it with persistReducer, but its not 1-1. not interested in maintaining two modules that do the same basic thing. The data migration path is only experimental because it has not been tested, but please by all means do test it, if we get several reports of it working we will drop the \"experimental\" bit.\nThere is also nothing wrong with sticking to v4, thats the benefit of semver!. ah I recently removed this from the readme thinking it had been long enough. migration guide still lives here: https://github.com/rt2zz/redux-persist/blob/master/docs/MigrationGuide-v5.md\nWe should probably add a link back to the readme.. for one thing, persistCombineReducers needs to take two arguments persistCombineReducers(persistConfig, {a, b}). you should not need to listen for the action, and you should also not need to pass persistConfig to persistStore. What happens is persistCombineReducers is a higher order reducer that will handle rehydration for you.\nI am not sure why it was not working for you originally but I would try again (without handling the action and without persistConfig), it should work.. How do you know during rehydration if user has changed? \nI do not understand your exact use case, but in general there may be a few options:\n1. use PersistGate like you are\n2. use persistStore callback, detect the state and conditionally purge / reset if needed\n3. implement a custom migrate that checks the state and clears it before rehydration happens if desired.\nFor 3 basically migrate is a method that takes in incoming state and returns a promise for updated state. i.e. (State) => Promise<State>. This should be fixed in the next release, 5.2 had a implicit requirement that all substate be objects. Will let you know when released. 5.3 is out now, and should now support your use case out of the box. looks like you do not support es6 modules on your server, in which case you should import out of lib instead of es\nAlso you probably do not want to use persist during SSR unless you are using cookie storage.. crosstab relies on the storage change event, everything else about it is pretty trivial. I would recommend starting by debugging whether the change event is firing. https vs http would affect this.. thanks!. I am +1 on this conceptually. \nI do however think it is probably to early to introduce async await. Open to discussion on the topic, but IIRC that basically means users will require the regenerator runtime which I think is an unfair burden. I recall we momentarily added async in the default storage engine which caused some consternation.\nIf anyone feels that async await should be standard now please chime in - I would love to start using it in the codebase.. wow, never knew :o\ntyty. Great, really excited to hear about alternative usage like this! With v5 comes a lot more power, and unfortunately that also means more choice. I tried to make it so that the default implementation was still dead simple, but that there were enough extension points to do clever and creative things while still benefiting from the underlying architecture and ecosystem.\nSo... with that said I think using persistReducer + autoMergeLevel2 is completely reasonable. Right now that can be done via a deep import import autoMergeLevel2 from 'redux-persist/lib/stateReconciler/autoMergeLevel2. Your suggestion it seems is to export this from the main module as well. I will have to think about this - I do not want to complicate the api for what is an implementation detail to most users, nor do I want to make your usecase less ergonomic.. correct, persistor.persist() is the new resume - persist method was required for codeplitting, and since the implementation would be identical we decided to simply omit resume. Agreed this should be in the docs.. this cannot be done on v4, but on v5 you can call persistor.flush(). right, that is a valid usage. The goal of this message is to help guide developers who may be unwittingly persisting old data, but at this point I am inclined to remove it, or put it behind the debug flag. We could add a debug check to the conditional here: https://github.com/rt2zz/redux-persist/blob/master/src/stateReconciler/autoMergeLevel2.js#L19. right the problem here is that redux-persist calls stringify which does not support blobs (afaik). We should probably have a way to turn off serialization - I think that would likely solve your case.. Open to others weighing in here - I prefer the minimal change which is serialize as boolean, but if there are many valid use cases for custom serialize then it may make sense to discuss an alternative implementation. \nIf we do go that route I would like to factor in how this my interplay with async transforms which has been a long standing request from many.. the simplest implementation would be to setup a localstorage listener (a la redux-persist-crosstab), then when change is detected, do something like \njs\nlet state = await getStoredState(persistConfig)\nstore.dispatch({\n  type: REHYDRATE,\n  key: persistConfig.key,\n  payload: state,\n})\nIn order to make this full functional and released in redux-persist-crosstab@5 I think we would need to do the following:\n1. check the changed key to make sure it matches the persistConfig\n1. implement some sort of locking / cancellation so that multiple syncs do not compete\n2. ensure that this will not trigger a infinite loop of rehydrates\n3. add rehydrate method to persistor, so as to avoid manually creating the action shape\nThere might be other approaches as well but this seems to be the most comprehensive approach.. my understanding is that react-native will import index.native.js over index.js when importing import storage from \"redux-persist/es/storage\". The pattern was taken from redux-offline, but there they do not use it for index.js so maybe that is the problem. Instead we could consider renaming it to src/defaults/storage.js which might solve the problem?. I ended up going with https://github.com/rt2zz/redux-persist/pull/507/ which has the same api but a slightly different implementation, thanks for spurring action here \ud83c\udf88 . ah I just saw about allowing customer serialize / deserialize. I am pretty conservative with changes at this point so I would prefer to go with the simple serialize as boolean option for now. If the need for this grows we can continue the discussion. two entry points I can think of:\n1. callback on persistStore:\njs\nlet persistor = persistStore(store, null, () => {\n  // this will be invoked after rehydration is complete\n}\n\nonBeforeLift of PersistGate\njs\n<PersistGate \n  onBeforeLift={this.doSomething}. redux-persist \"shallow merges\" 2 levels by default. This usually works pretty well as most redux apps use combineReducers, with each sub-reducer being a record with initial state. I would guess that for react-router-redux you would want to add that to the persist blacklist since router state is not something you typically want to persist (as it can be derived from the url instead).\n. Yes, assuming you mean nested persistReducer's, that works out of the box.\n\nThe basic logic is this:\n1. the persistor is considered to be \"bootstrapped\" once all persistoids that were present upon the initial render are rehydrated.\n2. PersistGate lifts once the persistor is bootstrapped\nThe idea is that on initial render most apps will want to wait for all state to rehydrate, but if a reducer is later added (e.g. via code splitting) even though a new rehydrate is pending, the gate should remain lifted.. I expect other have more experience with SSR than I, but generally I would recommend not using PersistGate if you are using SSR. redux-persist-cookie-storage might help here, since it allows you have identical state server side and client side during rehydration.. persist relies on serialization, which will not work on functions and classes out of the box. If you need class rehydration, you will need to right a custom serializer transform. This is for example how redux-persist-transform-immutable works. one strategy if you just have one or two classes you want rehydrated, you can implement a custom REHYDRATE handler in your reducer that does the \"class instantiation\". e.g.\njs\n// yourReducer\ncase REHYDRATE:\n  if (action.payload && action.payload.yourReducer) return { \n    ...state, \n    ...action.payload.yourReducer,\n    someClassInstance: new SomeClass(action.payload.yourReducer.someClassInstance),\n  }\nhopefully that helps! there is no simple answer but usually depending on your use case there is a way to make it work.. Nice, in that case you can probably use that StorageHelper as your storage engine for this reducer. For that usage you probably want to use persistReducer on just the cognito reducer, so something like\njs\nlet reducer = combinReducer({\n  cognito: persistReducer({ key: 'cognito', storage: CongnitoStorageHelper }, cognitoReducer). this is what createMigrate is intended for. It should only run migrations against older versions of state. You were observing the same migration running every time?. @outaTiME @dziamid yes this should be handled by the library. I think this was inadvertently broken when simplifying some of the persistReducer code. I will have to take a look later this week - hopefully something we can add a test for in the future.. @landpy apologize for taking so long to get around to this. There are a few approaches here depending on your needs.\n1. You can use purgeStoredState to purge state. import { purgeStoredState } from 'redux-persist'\n2. You can use persistor.purge() in order to purge state. This is nice because it does not require config as an argument.\n3. if you also want to do a state reset which it sounds like is the case you can either use an existing module for that (a few exist I believe) or you can do @testlump suggestion here: implement a custom handler for PURGE which does state reset. It should integrate easily per the instructions in the readme. are you using v5? v5 does not call getAllKeys, so if that is the source of the bug, upgrading from to v5 may resolve it.\nAlso I recall there have been similar bugs in react-native android in the past (AsyncStorage not working with debugger on). I agree with you assessment, this is likely an upstream issue.. this could be a great addition to persistStore config. Something like timeout: number which after the timeout is exceeded causes a console.error + immediately bootstrap all persistoids without waiting for state to finish.\njs\npersistStore(store, { timeout: 1000 }, (err) => {\n  if (err) {\n    // handle error\n  }\n}). FYI currently contemplating adding timeout in this PR: https://github.com/rt2zz/redux-persist/pull/702. redux persist v4 did it more or less how you describe. There were a few reasons this was changed to be a single entry in v5:\n1. get rid of non-deterministic keys (and the need for getAllKeys method in storage)\n2. eliminate the possibility for out of sync issues between different pieces of state\n3. most of the \"work\" is in serializing the state which we still do broken up per reducer, writing it to the db is very fast is async / optimized at the db level.\n. this has been added \ud83d\udc4d . This is not well documented atm, but in short persistReducer can be wrapped around any reducer. Meaning say you have a content reducer, you can actually wrap the reducer with persistReducer before exporting it:\n```js\n// reducers/content.js\nfunction content(state, action) {\n  // ...\n}\nconst persistConfig = {\n  key: 'content',\n  // ...\n}\nexport default persistReducer(persistConfig, content) . @thenewt15 exactly! thanks for PRing the readme updates - definitely want to get this more visible. \ud83d\udc4d \n. thanks for doing this, definitely going to take a lot of these changes. The one that I am uncertain about is recommending persistReducer over persistCombineReducers. The main difference therein is the merge strategy, persistCombineReducers applies two levels of shallow merge whereas persistReducer only does 1 level shallow merge. Need to think on this a bit longer... @thenewt15 correct, persistCombineReducers is really no more than defaulting to autoMergeLevel2 and applying combineReducers. Those can be done separately if desired. We put them together in one method actually in an attempt to reduce confusion, since \"autoMergeLevelX\" is not a very user friendly name. Generally speaking the intent of autoMergeLevel2 is to work at the top level, whereas autoMergeLevel1 is intended for use when nested within your reducer tree.\nThe only difference between the two reconcilers is how many levels of state they shallow merge. If you want initialState merged in with incoming rehydrated state then you need level 2, otherwise level 1 is perfect.\nSorry for confusion and slow response. I know right now stateReconciler is the biggest pain point around understanding and implementing redux persist. I am looking for ways to improve the api around this!\ntldr; yes using persistReducer (which is default autoMergeLevel1) is quite fine, just be aware that your sub reducer initial state's will not be shallow merged in during rehydrate.. going to get this in now, will do a second revision pass after. thanks @thenewt15 !. _persist needs to exist at the level that the persistReducer is applied. This is the only safe way to track state versioning. What issue are you having with it?. Do you have a suggestion for where else to store that state?. that is possible and something we might be open to, but we need to consider a couple thing:\n1. will the extra read per persistoid add meaningfully to startup time?\n2. will the extra code to store this state outside of the reducer state add to code size?\n3. will the risk of out of sync issues (where state is written but _persist fails or vice versa) going to be problematic?. no this is not possible, unless you model each document as a separate reducer (but that has its own set of challenges). You might be able to toy with redux-persist's internals to get this functionality, but tbh I think this is a pretty specific use case and probably a custom solution. \nOne big question: during rehydration, how do you know which documents you want to restore?. Edit woops answered on wrong issue, moved answer here: https://github.com/rt2zz/redux-persist/issues/589#issuecomment-348333268\n. I am guessing you are using the readme docs which have es imports in them - they currently assume an es modules compatible environment.\nJust update the import to be from lib instead of es, i.e.:\nimport storage from 'redux-persist/lib/storage'\n . @stolinski I am not sure in that case but it seems like a packaging issue. The es imports work fine in both a react-native and a webpack project I am running. FWIW importing from lib in this case has almost no downside, and in the future we will likely make it so you can import from redux-persist/storage. I have not used next.js so I may not have full context on this, but I wanted to weigh in on a couple of things:\n1. to get notified when state is rehydrated, you can pass a callback to persistStore:\n```js\npersistStore(store, null, () => {\n})\n2. configureStore does not need to return `{ persistor, store }`. There are a number of ways to work around this, such as calling persistStore in a separate method, i.e.js\nlet store = configureStore()\nlet persistor = configurePersistor(store)\n```\nHope that helps, if changes are needed in redux-persist to support next.js please let me know and we can evaluate their inclusion.. awesome, added basic api docs here: https://github.com/rt2zz/redux-persist/blob/master/README.md#persiststorestore-config-callback\nIf you think it could use further clarification please PR!. if all you want is to reset state, you should be able to simple dispatch your resetStore action, then redux-persist will store the reset state as soon as it can.\npurge is meant for clearing state explicitly, usually done as part of development when state gets into a bad place.\nflush is designed to force the writing of all pending state asap, and to provide a promise to wait for the writes resolution. This can be handy for example if you need to ensure latest state is written before navigating away.. Does it still warn if you use persistCombineReducers instead of combineReducers?. @ScreamZ thanks, I modified your PR to be a little more inline with standard setup / simplify.\nI apologize I lost the attribution on the squashed commit. . updated https://github.com/rt2zz/redux-persist/releases/tag/v5.4.0\nthanks. REHYDRATE will be called by the persisted reducer after it gets state.\nSome things to help debug:\n1. you can add debug: true to persist config for extra logging\n2. put a breakpoint in the persistReducer.js handling of PERSIST action, make sure it is coming and and that getStoredState is being called.. I am not clear what exactly the issue is can you restate the entirety of the problem?\n@henrytao-me you are saying you see rehydrated === false even after rehydration completes ocassionally?. So given the issue is in the underlying storage layer, I think the only remedy redux-persist can offer is a timeout config that will set a max time for rehydration before giving up.\nAlso I would recommend considering an alternative storage adapter, e.g. https://github.com/robwalkerco/redux-persist-filesystem-storage. FYI we are currently contemplating adding timeout in this PR #702\nThat would at least give users some recourse (without the need to switch storage adapters). why are you calling await persistor.flush() during your dispatch and getStates?\n\nI think flush is not needed here and can be removed\nit looks like you are calling user update before rehydrate completes. Best to wait until rehydration is complete so there is no \"overwrite\" issues. thank you!. usually this will not be a problem if you use top level persistCombineReducers but I think we need to solve this for the nested case as well.\n\nThis is being worked on here: https://github.com/rt2zz/redux-persist/pull/610. incorporated, thanks!. crap I forgot about this PR and reimplemented it: https://github.com/rt2zz/redux-persist/pull/689\nthanks nevertheless!. AsyncStorage.clear() will still clear v5 - but be warned it will clear all state, even that which does not belong to redux-persist.\nI would definitely recommend using purge, it is well tested and both #63 and #579 were questions not bugs.\nBasically you can either do \n```js\n// method 1\nimport { purgeStoredState } from 'redux-persist'\npurgeStoredState(persistConfig)\n// method 2\npersistor.purge()\n``. that is not required, rather what you can do is usepersistReducer`. We need to figure out how to get this into the docs better but for now I will explain it as such:\npersistCombineReducers is intended as a replacement around combineReducers from redux, and is really just a helper method for applying combineReducers + persistReducer (with some \"default config\").\npersistReducer is the actual logical method here, it is a higher order reducer. You can wrap persistReducer around any reducer and it should just work. \nSo based on what I understand about your setup, you should be able to\n1. get rid of persistCombineReducers\n2. stop nesting the state under clubsApp\n3. add persistReducer (around your reducer)\n4. remove the case REHYDRATE from your reducer. This is handled automatically.\n. awesome, will getting this in break anything for existing TS users that may have shimmed this or otherwise?\nIf not I prefer to merge this asap and get as many eyes on it as possible. Putting this on master now, but will wait before release.. thank you \ud83d\udca5 . yes I think storage is the other big one. Of course if one uses localForage or AsyncStorage then this is moot as these work out the box (and I am assuming both have accessible TS defs?)\nI do not believe this requires react-native specific testing, as the required storage api is identical for all environments.\nBeyond that there are the stateReconcilers (https://github.com/rt2zz/redux-persist/tree/master/src/stateReconciler) but very few people will consume these directly so are much less urgent.\n. woo nice \nI like having them split out per file, will make maintenance easier I think, and help when comparing with flow defs.\ncc @rodrigoelp. I went ahead and merged https://github.com/rt2zz/redux-persist/pull/624 as it looks good to me and @rodrigoelp did the initial implementation.\nThat said, I am not a typescript user and would love to continue to improve the types. Any TS users please weigh in on best way to move forward. Is it idiomatic to keep all types in one file, or split out into separate?. we merged the follow up PR. If anyone feels strongly a reorg is needed please reopen or comment. Thanks!. updated: https://github.com/rt2zz/redux-persist/commit/8a6c6924f5d09739f96e571199bf57f384f0d791\nthanks. @SaltedBlowfish @sunweiyang that works, or the second more formal but slightly more involved method is to add a migration. You can explicitly delete keys in the migration.\nThat said this is a common enough use case that I could entertain the idea that the state reconciler should handle this automatically as proposed in this PR: https://github.com/rt2zz/redux-persist/pull/621 - my hesitation there is that it is an opinionated, breaking change and I am not sure how to communicate it to users.\nOne idea I have thought about is to have a configurable stateReconciler:\nstateReconciler: createStateReconciler({ level: 2, auto: true, knownKeys: true })\nor something like that.\n. is there any way to unseal an object? We could I think spread it, but that seems an unnecessary cost just for the sake of appeasing flow.. also I am confused because I have redux-persist in use in a react-native project using flow 0.57.3 but am not seeing this error. Is there some confounding factor here that I am not aware of?. hm, this could go both ways. I like this pattern but it basically means users are required to maintain accurate initialState in their reducer which is an opinionated change.\nI have been seeing over time most of the opinionated pieces in redux-persist are in the stateReconciler, so I am wondering what we might be able to do to accommodate these needs without allowing complexity to explode. . sorry this took a while, definitely an important fix. \nproposed solution here: https://github.com/rt2zz/redux-persist/pull/689\nfeedback appreciated, I will get this into a beta release shortly. This is concerning, I will look into it. \n@micimize you do not need to call persistCombineReducers and persistReducer - one or the other. I recommend keep the exact same code and simply remove persistCombineReducers. @JosephDuffy so I wrote a little test for this: https://github.com/rt2zz/redux-persist/pull/711\nBut it passes. I am not sure what might be going on, can you reproduce this either with a test or a demo project that I can clone?. ah got it. So redux persist relies on an assumption of immutability in a few places, as does the greater redux ecosystem to a large extent. I am not sure we can do anything about this other than better communicate this in the docs.. awesome! thank you!. done . agreed, we need to understand why it is failing for v5 otherwise this will lead to unexpected behavior. If the framework throws a FileNotFoundError anytime we try to access a non-existent key, then the storage engine will need to be updated to not rethrow that error and instead just return undefined state.. docs now only mention persistReducer\npersistCombineReducers will continue to work, but it ended up being more confusion than solution. \ud83d\udc4d note in redux-persist there should be no logs, unless you pass in debug: true via config. I went ahead and made the docs always use lib: https://github.com/rt2zz/redux-persist/commit/d238b7f02b4e55eee198e518c86f8aa7e8384104 since this seems to be a common hangup.\nin the near future I would like to allow importing without lib/es so something like import storage from 'redux-persist/storage' then the module system can decide for itself lib vs es. hm, I am not sure how best to deal with this. React is not really a dep nor peer dep of redux-persist. \nWe simply ship react integration as a convenience. Perhaps we should also publish a redux-persist-react module?. I see so I suspect we need to move the react type defs out of src/index.d.ts and into integration/react. We already have a proxy module there so I think we can add a react specific type definition in that folder w a reference in integration/react/package.json. @luchianenco ya this was causing confusion. Docs now recommend persistReducer in all cases. Thanks \ud83d\udc4d . right if you want to animate loading away that is probably going to require some custom connections (ala https://github.com/rt2zz/redux-persist/issues/655#issuecomment-357700158). Anything that was possible in v4 is certainly achievable in v5 - PersistGate is just a convenience.\nI dont want to make PersistGate more complex but its possible we could do one of the following:\n1. create a new module PersistGateAnimated or something like that\n2. expose an alternate api where instead of having a loading prop, it uses function children a la:\njs\n<PersistGate persistor={persistor}>\n  {(bootstrapped) => {\n    // return fancy animation components here based on the value of bootstrapped\n  }}\n</PersistGate>\nOpen to suggestions, but it seems like 2 could be a good option that mirrors how react-router works.. @wachunei well again taking the react router analogy option 2 would work like this:\njs\n<PersistGate persistor={persistor}>\n  {(bootstrapped) => {\n     return [\n        <AnimatedLoader visible={!bootstrapped} />,\n        bootstrapped && <MyAppGoesHere />\n     ]\n  }}\n</PersistGate>\ni.e. it puts the responsibility for rendering the loader and main app into the hands of the implementor, but the common pattern would be basically bootstrapped && <MyAppGoesHere />\nThe approach you describe here: https://github.com/rt2zz/redux-persist/issues/655#issuecomment-362416964 is problematic to me because a) it does not solve as many use cases and b) it overloads the meaning of loading prop which may confuse users.\nIf I can elaborate on (a) consider this use case where you want to initialize a component to get some heavy lifting done immediately but still need to know when boostrap is complete to do additional work:\njs\n<PersistGate persistor={persistor}>\n  {(bootstrapped) => {\n    return <MyAppGoesHere bootstrapped={bootstrapped} />\n  }}\n</PersistGate>\nOf course this is all somewhat straight forward to replicate using a custom component which listens to the persistor, but I like that this pattern preserves the onBeforeLift pattern.. @wachunei there are a few ways to do it. In my case with react native I always do one of the following (depending on the scale of changes):\n1. in your app import from src (e.g. import { persistStore } from 'redux-persisit/src') then edit the files in place and when you are done you copy the files back into your local git repo. \n2. use wml for create a \"hardlink\" alternative to yarn link.\nBoth options are a bit tedious :/\nOr if you use create-react-app then yarn link should work but you need to be sure to build after every change. i.e. literally run yarn build. You can run the build in watch mode for convenience: yarn build:es --watch but be sure to run the right build for your environment (i.e. es vs lib)\nNow that I write this out I realize how frustratingly complex it is!. > Would it work to have an entry point that imports from src or lib depending on dev environment variable?\nI am not sure how that would work - but open to suggestion. We use package.json module field to opt es users into the es build: https://github.com/rt2zz/redux-persist/blob/master/package.json#L6. awesome, that looks perfect - mind opening a PR?\n. right storages was a typo, I just updated it\nimport storageSession from 'redux-persist/es/storage/session' should work. I suspect you are passing it into the wrong config or as the wrong key.\nyour code should look roughly like:\n```js\nimport storageSession from 'redux-persist/es/storage/session'\n// ...\nlet persistConfig = {\n  storage: storageSession,\n  // ...\n}\nlet reducer = persistReducer(persistConfig, rootReducer)\n```. good call, will update readme now. also yes this was certainly the issue, naming things is hard!. \ud83d\udc4d \nDocs have been improved a bit in the last couple weeks. @DJTB how are you clearing state? like with an action or via persistor.purge or something else?\n. @DavitVosk can you elaborate on what the issue exactly is?. ah ok so I am fairly certain there is an issue with setting state to undefined. We should add a test for this, I am not sure what the behavior will be.\nIn general redux persist assumes state is an object, ie not undefined. you might try something like setting state to an empty object on logout instead of undefined.. @DJTB ah thanks for clarity. So yes it probably does confuse the persist if you blow out state from the top. I would like to allow this however.\nOne probable solution is to store _persist state outside of the reducer. This seemingly opens up a few more use cases. There is an open issue for this somewhere that I cannot find atm. Not without challenges though, we would need to be very careful about out of sync state issues and possible performance impact. \nNot sure what the timeline for such a change might be.. thanks! just merged an identical PR. thank you, will cut a new release soon. I think you are correct, and I think we will make level2 the default (although that is breaking and will require v6.\nThe only requirement before we make that switch is we need to tests to ensure that things behave as expected when substate is: a primitive, null, undefined, or non-plain object.\n. yes theoretically we could create level 3+, or even deepMerge although I am not sure in what usage that would be useful?\nIf anyone has suggestions for a better api to expose this I am all ears. It would be nice to do something like \nlet persistorConfig = {\n  mergeLevel: 2\n}\nbut then we lose the ability for tree shaking to reduce bundle size by avoiding inclusion of unnecessary reconciler code.. tyty. you can access it from the browser console by exposing it as a window variable\ni.e.\njs\nwindow.persistor = persistor. this could be done with a clever storage adapter that updates / reads out of the query string.\nv5 supports this theoretical use case fairly well because it is easy to have many persistedReducers, so you can potentially target just one or two reducers to persist to the query string. \n. I just updated the docs to be loading={null} with a note below about usage. @eduduardo thanks! I actually just updated the docs to set loading to null. Trying to keep the initial usage as simple as possible (also react-native agnostic). I think null is the best starting point for people to get up and running without worrying about non-essential logic.. we now have v5 TS definitions, and included the reference in package.json \nthanks!. yes, unfortunately the state is stored in a different format so you have two options:\n1. do nothing and all users will effectively have their state reset\n2. use a v4 -> v5 migration. A rough explanation of how that works is here: https://github.com/rt2zz/redux-persist/blob/master/docs/MigrationGuide-v5.md#experimental-v4-to-v5-state-migration - I know at least a few users have implemented this successfully but YMMV. hm, if you are using blacklist that conditional should never fire since whitelist will always be undefined. Are you sure that commit introduced this issue? Also is there a reason why you are blacklisting _persist, we need _persist to be persisted in order to track the state version.. can you paste your HMR specific reducer code?\nI am thinking something about that is causing this.\nThe other option we have is we could export our own combineReducers that skips the unexpected key check.. right, I think https://github.com/rt2zz/redux-persist/issues/672#issuecomment-361287820 is the recommended usage with HMR\nOtherwise state will not continue to persist after the hot replacement.\nSounds like a docs issue.... you have a few options.\n\nmove your dispatch into the persistStore callback:\njs\nconst persistor = persistStore(store, null, () => {\n  store.dispatch(myActionCreator())\n})\nmove your dispatch to be triggered somewhere inside of your component tree, inside of PersistGate\nuse something like redux-action-buffer to capture the actions and delay their application\n\nI would recommend them in that order, but of course it depends on your specific needs. just published v5.9.1 \ud83d\udc4d ty. cc @LKay @rodrigoelp\nthese changes look good to me but Ill defer to TS users. did you resolve the issue?\nreact-redux is definitely not required. Hopefully you got it worked out!. this looks great / correct! Unfortunately this approach only works for v4, but very similar code can be adapted for a v4 -> v5 upgrade.\nBasically in v5 the approach is to have a custom config.getStoredState that does a fallback check for v4: https://github.com/rt2zz/redux-persist/blob/master/docs/MigrationGuide-v5.md#experimental-v4-to-v5-state-migration\nOpen to suggestion on how to make these types of migrations more painless. I am contemplating something like createGetStoredStateChain([getStoredStateA, getStoredStateFallback]) which basically will go down the chain until it finds usable stored state. . I think this is a \"bug\" in hardSet reconciler. Basically it is hard setting the state to undefined, but in redux persist undefined is supposed to mean \"there was no state found\" and no reconciliation should occur. PR forthcoming. look like we can resolve most of those by creating an intersection type for Persistor ie\ntype Persist = Store & { flush: Flush, purge: Purge }. just merged https://github.com/rt2zz/redux-persist/pull/692\nplz reopen if any further issues arise!. The original intended usage of transforms are for more low level state agnostic things like encryption / serialization / immutable transform. However they are also used for app logic transforms. I am open to suggestions for how to resolve this but I do not think changing the order is the solution. \nOne option is to make the transform pipeline more generalized (and async) and incorporate migrations. That way each implementation has full control over execution order.. that would be fairly easy to achieve, we would simply need to call persistoid.update(state) before we return the rehydrated state here: https://github.com/rt2zz/redux-persist/blob/master/src/persistReducer.js#L131\nwith typical migrations this would never really matter since they are deterministic and would be safe to rerun. but technically a migration can do anything so perhaps your suggestion is the more conservative behavior.. this should be resolved by: https://github.com/rt2zz/redux-persist/pull/688. @deecewan we might change this in v6 - but its definitely not a cut and dry issue from my perspective. Here is some context:\npros:\n1. keeping _persist in the reducer state makes everything atomic, we can never have state be out of sync with its persistence state (namely version). \n2. it preserves the redux concept of a \"single state atom\" -> everything stateful is inspectable in one place.\n3. it keeps the code simple, since a store may have multiple persisted reducers, storing it along side state makes it dead simple to find the persist state for each persistoid.\ncons:\n1. changes state typings\n2. we have to workaround combineReducers unexpected state warning\n3. its unexpected for users\n4. it prevents mounting multiple persists onto the same reducer (i.e. at the same mount point)\nCon 4 is a big issue for me and I would definitely like to explore options for how we can resolve this. Perhaps storing _persist state in the persistor is the way to go, but then we have to worry about syncing it and persisting it.\nWhile I am open to suggestion I think this is unlikely to change in the near future. \nIn the meantime I would recommend you add the _persist state to your State type. We export the PersistState shape so you can do something like\n```js\nimport { type PersistState } from 'redux-persist/src/types'\ntype State = {\n  //... your state shape\n  _persist: PersistState\n}\n```\n. hm, nm not sure what is going on with prettier here. this is now on master. that is concerning. It could certainly be size related - possibly a bug in rn. \nHave you tried alternative storage adapters, e.g. https://github.com/robwalkerco/redux-persist-filesystem-storage\nFor context I have been running redux persist in production for over a year (also with sentry) and have not seen these crashes. Can you log or estimate how large your storage is in a long running production install?. @grebenyuksv-preply sorry this has not been a straight forward integration for you! we are constantly working to improve the docs but it is a tough challenge.\nI am glad you got it working. persistReducer should work as expected whether you apply it to the rootReducer or a nested reducer. There are a couple of things to look out for:\n1. any state changes dispatched before REHYDRATE will most likely be overwritten by the REHYDRATE action. Usually people use PersistGate or redux-action-buffer or custom strategies to delay firing actions.\n2. if you reducer updates state during REHYDRATE, then the state reconciler will skip rehydration for that reducer. This is done so that reducers can opt-in to custom rehydration handling as needed. Unfortunately it does cause confusion as in your case.\n3. it is true that you can only persist reducers which have object like state. This may change in the future but it is the case for now.\nIf you have suggestions for how to further improve the docs please share. I think (2) is the biggest gotcha that we are looking for ways to better communicate.. I like this change, but if I am not mistaken register and rehydrate will be broken in this case as they both depend on the store. I will try to take a look today.. ah ok I had to read up on hoisting to understand how this works \ud83d\udc4d . note: I reworked it a bit to not rely on hoisting - perf should be identical but this seems like a more conservative setup:  https://github.com/rt2zz/redux-persist/commit/c090a323edaca664fce1137351e795ba4183341c\nAlso updated IntervalId to any for now for backwards flow compat. @ch1ll0ut1 is the issue that our types are not complete or that with deep imports TS does not know where to look for the definitions? FWIW a short term fix would be to use localforage as your storage.. got it, I think we were just missing the lib exports for these files (we had them for es), this should resolve: https://github.com/rt2zz/redux-persist/commit/4a00ed8274018d540cbd4e803216c60f94e58d92. @yordis I am not sure about these errors - does #706 resolve the first?\nFor the second it seems like maybe we need to move the type definitions for react integration out of index.d.ts and into the proxy module: https://github.com/rt2zz/redux-persist/tree/master/integration/react\nAgain I am not a TS user so I can only speculate, but will gladly merge fixes and cut a new release.. ahhh now I understand the error in https://github.com/rt2zz/redux-persist/issues/700#issuecomment-363008955 thanks\nadding this to new release now\n. @i8wu can you try 5.6.11\nand change your import from redux-persist/lib/integration/react to redux-persist/integration/react (i.e. drop the lib). redux-persist v5 does not have a autoRehydrate method. Also it ships with its own type definitions so you should not need to install them from a different source.. \ud83d\udc4d ok I think I agree, lets add this and default the timeout. I still want to evaluate if timeout would better live in persistReducer or here (persistStore). Will look to merge this is something comparable this week.. this landed via https://github.com/rt2zz/redux-persist/pull/713 - applied to persistReducer instead of persistStore \ud83d\udc4d . yes the data will be lost if timeout is ever reached. I forgot we had an open discussion about this going on here: https://github.com/rt2zz/redux-persist/issues/514#issuecomment-362869310\nreverted for now until we get some clarity. Going to open a more conservative version of the same thing that only splits out integration/react + readme updates. crap my bad forgot to checkin the new files. importing from lib will continue to work, but want to encourage using the proxy module moving forward: https://github.com/rt2zz/redux-persist/commit/f2cc14f7bfc930abb56293b2c2aec5d0fb78d358. responded. \nI think the only two considerations I have moving forward are:\n1. How does this look if we want to provide a umd build? The umd bundle will have a few extra bytes from the state reconcilers which I think is acceptable. Are there any other concerns?\n2. How do we get flow types to work? I am pretty sure this can be done by doing a build without transform-flow-strip-types, and writing that to redux-persist.flow.js. \n3. because of the breaking changes, will definitely want to land this along-side other breaking changes that I am mulling over around how we store _persist, and async transforms.. that is not an error, those are methods we attach to enable persistence. \ud83d\udc4d . my devtools are auto collapsed, maybe there is a setting for that for the plugin. https://github.com/zalmoxisus/remote-redux-devtools\nI highly recommend this \ud83d\udc4d . are you already resetting state on logout?\nif so the reset state will be written over the old state and you should be good, no purge required.\nif you are not then I recommend you look into it. that is out of scope for this project, but fwiw I usually do state resets via a custom action.. purge is mostly used for clearing storage during dev. There could be some valid use in prod but it would be something specific like purge old state after a migration.. well off the bat it seems a very strange pattern to do \nconst persistor = applyMiddleware(\n  ReduxThunk \n)(persistStore)(store);\nI would replace that with\nconst persistor = persistStore(store);\nno need for thunks in the persistor!\nNot sure if that is the problem but I think it might solve the issue.. \ud83d\udc4d . note: this adds about 200 bytes to the lib. I believe these . apologize for the churn here, v5.7.2 resolves the issue.\ntests missed the issue on 5.7.1 as it was a console.error, not an actual exception. tests would be awesome\nI will add some basic docs, and also a dev only validation\nNo need to generate build files, that is done automatically upon release.\nThanks!. are you using android? react native AsyncStorage has a bug with android when the debugger is open causing this to happen. As you can see the persist is timing out (check the error on the REHYDRATE action).\nThe only workaround for this is to use a different storage engine: https://github.com/rt2zz/redux-persist#storage-engines. hm, then possibly a bug with storageSession? You could try using localForage (https://github.com/localForage/localForage) and see if that works?. ah interesting, so session storage is failing - that explains the behavior. We need to figure out why. \nThat means this line is failing: https://github.com/rt2zz/redux-persist/blob/master/src/storage/getStorage.js#L35\nare you running this in a standard browser? Is it a private browsing session perhaps?. Ok I see REHYDRATE is being called twice, can you make sure you are on the latest version of redux persist? I believe 5.7.x may have had a bug causing this. @atav32 you are seeing persist dispatched twice when there is no prior storage? That is definitely a bug, but I dont see how that can happen as we only allow rehydrate to be called once (per persistReducer): https://github.com/rt2zz/redux-persist/blob/master/src/persistReducer.js#L71-L86. This should not be the case. The delay should be something like a few ms.\nHow many reducers do you have? Also have you set a throttle value in the persistReducer config?. so I am guessing you are importing storage from redux-persist/es/storage, but your testing environment does not support es modules. In that case the quickest fix is going to be to import from lib redux-persist/lib/storage.. nice, thank you for this.\nAre there any possible complications with using self? browser compatibility issues?. \ud83d\udc4d \nI do consider pulling storage out of redux-persist since it is browser specific and comes with some additional overhead that not all users need (e.g. private browsing fallback). \nGenerally I recommend using localForage (which plugs in without any modification) but that is a non trivially sized package.\nAnyway thanks again!. just released in v5.9.0. all the setup looks great, I suspect the issue is the lessons reducer mutating state, so the persistor never knows to update it.\nCan you share your lessons reducer?. thanks!. key is used to set the storage key and keep track of which persists have completed (the the case of multiple persistoids)\nWe could give it a default, but making it explicit seemed like it would avoid confusion in the future.. that is not possible, we have explored things to expose deep filtering, but settled on nested persists as being the best generic approach that preserves performance. \nhttps://github.com/edy/redux-persist-transform-filter allows for deep filtering however. @diegolaciar it looks like you are using redux-persist v4, but somehow also getting PersistGate which is only available in (and compatible with) v5.\nYou can read about the upgrade here: https://github.com/rt2zz/redux-persist/blob/master/docs/MigrationGuide-v5.md\nHowever please note there is no top level immutable support in v5. If you need top level immutable you will need to stick to v4 and not use PersistGate. There is a decent amount of code that goes into timeout and delay: https://github.com/jamiebuilds/react-loadable/blob/master/src/index.js\nI wonder if this could be abstracted into another module that is generally applicable, so the composition with PersistGate might look something like\n```js\n}\n\n. @anhphuongbn94 `import {store, persistor} from 'your-store-module'` is definitely the right import syntax. I would double check your export statements and paths.. thanks!. thanks!. you can use the currently undocumented render function form of PersistGate for more control:js\n\n  {(bootstrapped) => {\n    // do whatever you need here e.g.\n    // if (bootstrapped && this.state.animationComplete) return \n```. resolved in https://github.com/rt2zz/redux-persist/pull/812. thanks! good catch. thanks @osdiab ! I have been away but getting back to things now.. yes it is still maintained, yes there has been no activity for 3 months. Will take a looks at PRs now!. awesome! haha tab wrangler looks cool. \n\nThis is what I am working with atm\n\n. @myrjola  this looks great. I just resolve the merge conflict. Can you double check everything still checks out (see my inline comment)? The logic makes sense and I am planning to merge this soon.. This looks great. Thanks Ailrun. \nI am going to take this in, any other typescript users please weigh in if you have any concerns.. perhaps we should rewrite things in typescript \ud83e\udd14  . gonna go with this in a prerelease, I have a ts project I can try this out in as well. available in redux-persist@5.11.0-alpha via npm i --save redux-persist@next. awesome, many thanks. thank you!. Hi all, sorry about the neglect, I have not been keeping up on the issues. Please reach out if you are interested in maintaining, and additionally ill take a look at open PRs next week.. New pre-release: redux-persist@5.11.0-alpha available via npm i --save redux-persist@next\n\nimprove deleted key handling https://github.com/rt2zz/redux-persist/pull/928\nimprove typescript types https://github.com/rt2zz/redux-persist/pull/919\n\nWill take some time before I work through the entire backlog of PRs but if something is urgent please ping me directly.\n. thanks! been excited about a realm storage for a while. Is stage-0 needed?\n. What does loose do? If we need to change some code to be more \"by the book\" I am open to that.\n. :+1: \n. we should switch these to imports\n. does modules: false not break based on the fact that we use es modules in the src/? Also I am curious why is modules: false necessary to get the umd build working?\n. I am not familiar with typescript, how does this dep work?. I am concerned about the bytes that the redux typings will add. Shouldnt the typings field be sufficient and we can may @types/redux a devDependency for the sake of development?. having to colocate type files is a messy unforeseen consequence of putting storages and constants in root :(\nIn particular for storages we do it to help with dead code elimination for projects that do not use the default storage.\nis there no other way to tell typescript where to look for these definitions?. why is babel-polyfill needed?. redux should be a devDependency.. why do we need to store lastWritten? that is more or less what lastState tries to track.. would be more performant to just write the existing keys that are pending (everything else is gauranteed to be up to date)\ni.e.\njs\nkeys.forEach((key) => {\n  persistCurrentStateForKey(state, key)\n})\nkeys = []. having not used rollup before, I like it as cli argument - makes it clear what is happening.. do you have an alternate recommendation for how to implement prettier? I would like to ensure all code PRed is prettier'ified, wether that is via CI or lint-staged or other.. lets remove the console.log. this middle argument needs to exist actually in order for the callback to work. It can just be a empty object {}, although perhaps we should update the src so as it can be an optional?. I am going to move constants into the root in the next release. actually we should do this like redux, allow it to be null. ok its up v5.3.3, so this line can be\nimport { REHYDRATE, PURGE } from 'redux-persist'\nThe old format still works but this is I think preferred now.. this can now be null, but still needs to exist so these lines can be\ndiff\n-  config,\n+ null,. lets put all of the redux-persist imports on the same line. how about we only check undefined: \nconfig.stateReconciler = config.stateReconciler === undefined ? autoMergeLevel2 : config.stateReconciler. I think this should be if (reducedState === restState) return state\n. that seems to be the better path per http://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html\nI will update that separate from this PR since I am still not clear how we want to move forward with the interface type + type formatting. I agree, redux-persist/react is probably best. No issues with breaking changes, although I do have a couple of breaking changes in mind, so we can stack these together for a v6. lib and es will go away with this correct?. I am not sure either. gen-flow-files may work, last I tried it was buggy but that was maybe a year ago.\nFiguring this out will be a big concern however, having types is important and maintaining separate flow types is not desirable obviously (maintaining .ts declarations is already a big burden).\nIs it possible to bundle w/o stripping flow types? then we could basically ship a mirrored redux-persist.flow.js bundle, which is basically all flow-copy-source does anyway.. cant say I understand. So how would src be restructured?\nHow would babel helpers get deduped?. \ud83d\udc4d I think so, but definitely want to get other opinions here. Are there any cases where we cannot rely on code splitting? Will this negatively impact any use cases?. this check makes sense. Can you double check how this will interact with the recently merged: https://github.com/rt2zz/redux-persist/pull/928/files\nYour tests look good, and run and pass. So my guess is we can simply add lastState[key] !== undefined as one more item in the conditional.. ",
    "gaearon": "Why not rehydrate by providing the initial state? For example that's how persistState works.\n. > Thanks, but I still get an error. Says \"compose is not defined\" \nYes, it is not a global. It is exported from redux, just like applyMiddleware. Modern libraries usually don\u2019t export globals, so if you see something that wasn\u2019t declared, it\u2019s very likely that it needs to be imported from somewhere.\njs\nimport { createStore, applyMiddleware, compose } from 'redux'\n. ",
    "ksairi": "@rt2zz how can I catch an error, i.e of no space in disk, while the persist action is happening in a react native app?. +1 @phuihock 's approach worked for me!. Actually, after a day, timeout error appeared again :(. ",
    "xenophilicibex": ":+1: \nDefinitely would like these. Passing the rehydrated state to initialState is exactly what I need for app launch.\nI'm willing to help out with this project if I can!\n. I'm using react-native with AsyncStorage\n. Great progress! I'm not sure I follow- what do you mean by custom actionCreators?\n. Aha! I'm actually going to need to implement the exact same with my access tokens.\n. @rt2zz, I'm not getting an error with persistStore, but I did get errors before I switched to it, and I was curious how to do it. The answer was much simpler than I thought! Thanks!\n. ",
    "pascience": "Closed because I confused PR title and commit title. See https://github.com/rt2zz/redux-persist/pull/6\n. ",
    "joeybaker": "Any chance you can publish a new version?\n. ",
    "jeremejevs": "Unfortunately, I'm on a very tight schedule with my project, and I can't let myself sink extra time into this right now (it's not a game-breaking problem, since everybody is used to getting \"your token has expired\" from regular websites, and I'm not persisting any cached data yet). However, I'll gladly revisit this once I'm done with the first phase.\nOtherwise, maybe not caring about conflicts and overwriting, like it's done right now, is sufficient? Unless somebody is trying to persist user-modifiable data (but in that case they probably shouldn't be using a convenience lib in the first place, and roll their own). If the app persists a lot of frequently changing stuff (which it shouldn't), something like reselect could probably alleviate most of the extra overhead?\nSyncing/replaying actions is actually a good idea, but I can see it conflicting with routing (e.g. two tabs with different pages open sending redundant or even potentially harmful actions to each other; unless I'm missing something, and this can't actually make any harm) and other redux-incompatible things. However, maybe some kind of an action filter could help with that? E.g. \"I want to sync only auth- and sidebar-related actions, but not the rest\".\n. Sorry for not getting back to you earlier, thanks for implementing this! Works like a charm. Certainly sufficient for something like auth token synchronization (which doesn't update very often nor isn't likely to be overwritten from multiple tabs simultaneously).\n. I see that there was a check, removed in 1.5.1.\n. Much appreciated :+1: \n. ",
    "grabbou": "Well, in my case, the React app data depends on the user location meaning that even a small change of location requires full data reload (location change loads places, there are pubs in places etc.) hence there's no point in persisting the whole tree since in 99% it will need to reload anyway. The only thing that needs to be serialised at this point is the user profile and its token. \nAnyway, it might be just a matter of personal preference, but usually I prefer whitelisting than blacklisting to be explicit about the serialisation.\n. ",
    "zalmoxisus": "Does it mean that the rehydration key will not match the reducer key anymore? It is not a big problem I guess, we may just catch them by payload parameters. I'd opt for less noise.\n. Yes, having a lot of reducers could generate a lot of rehydate actions in the devtool, making it difficult for debuging.\nAlso REHYDRATE_COMPLETE is a bit ambiguous as it is invoked only after the initial rehydratations. If we use something like persist-crosstab, one would expect to have REHYDRATE_COMPLETE when new rehydratations occur  as well.\nThough I agree that dealing with nested data can be error prone in custom rehydration handlers.\n. It works now. Thanks a lot!\nJust testing so far. Trying to replace browser extension messaging with just rehydratations. As the result we get a crossbrowser (only the Storage Backend will be different) extension with just redux actions. It seems to be pretty suitable for Chrome, but still have to implement some hacks for Firefox and to check how stable it will be. Maybe it is a crazy idea, but worth to try :)\n. Sure, If it is stable. Yes, as in redux-persist-crosstabs. Thanks for your help!\n. @rt2zz, as I promised, here are the results of this \"experiment\": https://github.com/zalmoxisus/browser-redux.\nIt uses chrome.store as described in your documentation. Synchronisation is made as in persist-croostab.\nIt seems to work pretty well. The only differences from using redux-persist on web apps are:\n1. Unlike window.addEventListener('storage'), chrome.storage.onChanged is triggered on local changes as well, which is reported as a bug. But it can be managed trivially.\n2. chrome.storage.local can store objects, so we don't need to serialize the data (in order to boost the performance), though we still need it to fix 1.\n. That's exactly what I need. Thanks a lot!\n. Yes, I also found having initial -> rehydrated state transformation very useful for debugging and do want to use it for access token validation as well, but it has some drawbacks:\n1. UI flickering, as we render according to the initial state, and then rerender with rehydrated state.\n2. We still need a big bounce, otherwise the initial states are stored before rehydratation.\n3. Tests with selenium webdriver on CI often fail as they catch initial values instead of rehydrated ones.\nHaving an asynchronous lower level getStoredState function for the initialState would be a solution, but we should avoid repeated rehydratation after initialization in this case.\n. Well, those issues can be solved by just returning the store asynchroniously in the persistStore callback.\nAlso crosstabSync should be called after the persistStore is completed, otherwise the initial value is synced (I'll do a pull request with this change in the README).\nThe downsides of this approach are that the rendering is slower (but with getStoredState it would be almost the same) and the states are still stored in the storage again (because they are changed from the initialState). A solution to the latter could be to move store.subscribe to the rehydrationComplete, but I'm not sure how it suits #12. What do you think?\n. Thanks a lot for the changes! I'll look into it.\nI like the current approach of using async storage API, and see 2 big advantages for a web app:\n1. Easy to extend to React Native or to a Chrome extension.\n2. We can use localForage, which will increase the performance a lot by replacing localStorage with IndexedDB/WebSQL where it is possible.\nRegarding initialState, we shouldn't enforce any promise library, so it would be only one solution - to get the store in a callback:\njavascript\nexport default function configureStore(callback) {\n  getStoredState(initialState => {\n    const store = createStore(reducer, initialState)\n    storeStateOnChange(store)\n    callback(store)\n  })\n}\nAnd then use it like that:\n``` javascript\nimport React from 'react'\nimport { render } from 'react-dom'\nimport Root from '../containers/Root'\nimport configureStore from '../store/configureStore'\nconfigureStore(store => {\n  render(\n    ,\n    document.getElementById('root')\n  );\n});\n```\nI'm still not sure whether we need it if the previous issues are solved. \n. It suits well selenium tests as we already wait till the page is loaded/rendered. Actually, it was possible before to add an additional waiting while we get the necessary value, but if it fails, it would be difficult to figure out what caused the issue.\n1. Maybe we can improve persistStore instead of adding another function. If getStoredState was called, it should act as storeStateOnChange was intended to act.\n2. What is the purpose of adding a debounce interval?\n3. A solution would be to use localForage by default instead of localStorage, which does the serialization if it is needed. Honestly, I didn't try it, but it seems to increase the productivity, and I do not see any drawbacks (if we specify another storage, it should be removed by Webpack as a dead code).\n   I created a library which adds those obtuse parameters and storage, they are used only when we have chrome.storage, otherwise we use default values along with persist-crosstabs. I added you as a coauthor BTW :)\n. Just tested, that's awesome!\nThe only problem I see, if we have skipRehydrate: true, crosstab-sync wouldn't be able to rehydrate as well. Or am I doing something wrong?\nI guess you meant this parameter in the second gist for the secondary persistence schemes.\n. @rt2zz, thanks a lot for the changes, but it still doesn't work. Adding autoRehydrate store enhancer in this scenario, blocks action dispatching at all. Removing the condition here helps, though we do not need a REHYDRATE_COMPLETE action dispatching here.\n. Thanks a lot!\nAnother advantage of this new approach is that now redux-persist is compatible with redux-devtools' persistState (before the history was reset on the initial rehydratation). It is the only case where having REHYDRATE_COMPLETE is not preferable as it appears in history on every page reload, and it could be ambiguous, as rehydratation didn't happen in this case (the storage value could be different as the initialization didn't happen).  Since it is just for debugging and not so many people use debug_session, we could leave it as an enhancement request.\n. @rt2zz, is it ok to not include autoRehydrate store enhancer at all if I use the current scenario and don't have hydratations from such libraries as redux-persist-crosstab?\n. Unless you do not store states on the server side, you don't need  Redux Persist there. A solution could be to move store persisting in a separate module and import it only on the client side or to have 2 different implementations depending on the side. Like here. \n. In that example, I just add the environment flag to the second parameter of configureStore, but in case of an universal (\"isomorphic\") app it's even easier, you may just use, for example, process.env.isServer.\nUsing redux-persist as a noop wouldn't be a good solution, as it tries to persist new state on every action.\n. If we omit autorehydrate, it should be easy implemented with Alternate Usage \njs\ngetStoredState(persistConfig, (err, initialState) => {\n  const store = createStore(reducer, Immutable.fromJS(initialState))\n  persistStore(store, persistConfig)\n  // ...\n})\n. I guess if we do toJS every time, then we lose the performance gained by Immutable.js, and better not use it at all, unless we persist only some reducers. \n. @peterlazar1993, I think no signifiant value. Better to use the standard Redux combineReducers and use Immutable.js on the reducer basis.\nThen we'll have something like \njs\ngetStoredState(persistConfig, (err, initialState) => {\n  const initialImmutableState = {};\n  Object.keys(initialState).forEach(function(key) {\n   initialImmutableState[key] = fromJS(obj[key]);\n  });\n  const store = createStore(reducer, initialImmutableState)\n  persistStore(store, persistConfig)\n  // ...\n})\n@rt2zz, I guess in this case we don't need any changes in redux-persist. The condition will work and JSON.stringify will transform the state. I'll test it later as I'm still on the way on converting an app to Immutable.js.\n. @peterlazar1993, it shouldn't matter there even if we don't use Immutable.js at all. Just make sure not to mutate the state, so the references of the state object are different (prevStoreState !== storeState).\n. @rt2zz, you remember I was against it before :)\nI am still convinced that for most of cases we don't need it, but it gains performance for react components when having lots of sub-instances. Also worth to mention that I persist only few reducers, so serializations will not have signifiant impact on the performance.\n. Just an update, in case someone will use the snippet I provided above.\nSince getStoredState doesn't take whitelist/blacklist into consideration, you should use the following if don't want to persist all reducers:\n``` js\nimport { fromJS } from 'immutable';\nimport { getStoredState, persistStore } from 'redux-persist';\nconst whitelist = ['reducerName'];\nconst persistConfig = {\n    skipRestore: true,\n    whitelist\n};\ngetStoredState(persistConfig, (err, initialState) => {\n    const initialImmutableState = {};\n    whitelist.forEach((key) => {\n      if (initialState[key]) initialImmutableState[key] = fromJS(initialState[key]);\n    });\n    const store = createStore(reducer, initialImmutableState)\n    persistStore(store, persistConfig)\n   // ...\n});\n. @rufman, wouldn't this shallow convert affect the performance? I still don't get what could be the advantage of having the root state in ImmutableJS.\n. Note that [cookies also can be disabled](https://www.chromium.org/for-testers/bug-reporting-guidelines/uncaught-securityerror-failed-to-read-the-localstorage-property-from-window-access-is-denied-for-this-document). So, I guess we should just not store anything if the user opted not to. Not sure it is `redux-devtools` problem, but you can disable recomputing actions there by setting `shouldHotReload` to `false`:js\nconst composeEnhancers = composeWithDevTools({ shouldHotReload: false });\n  const store = createStore(rootReducer, composeEnhancers(\n    applyMiddleware(thunk),\n    autoRehydrate(),\n  ));\n```\nSee more details in the devtools API.. I see. Then it's not Redux DevTools issue, seems like autoRehydrate overwrites the state after recomputing occurs.. ",
    "lexun": "Great, I will probably be rehydrating immutable data soon so I'll let you know if there are issues. Thanks!\n. ",
    "pianohacker": "Wow. Fantastic! I already loved this module except for this niggling edge case (as it exactly matched what I was doing but was much cleaner), and this was a super fast response. Thanks!\n. ",
    "doxxx": "I think that would be better done by having a no-op storage implementation that is selected instead of the asyncLocalStorage implementation.\n. I was able to fix my reducers that were causing the problem, but I filed\nthis in case it was unintended. Since it's by design, feel free to close it.\nOn Sat, 31 Oct 2015 at 14:38 Zack notifications@github.com wrote:\n\nThis is by design, autorehydrate checks for object equality.\nDo you have a reducer that makes this behaivor problematic?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/rt2zz/redux-persist/issues/34#issuecomment-152761332.\n. Sounds reasonable to me.\n\nOn Tue, 3 Nov 2015 at 12:34 Zack notifications@github.com wrote:\n\nI will leave this open for a bit to see if anyone else wants to weigh in.\nThe rationalization is, if the reducer handles the the REHYDRATE action,\nit implies custom rehydration and based on this assumption autoRehydrate\nwill skip that reducer. This also is nice because it prevents conflicts\nwhere autoRehydrate might overwrite something the reducer wanted.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/rt2zz/redux-persist/issues/34#issuecomment-153427230.\n. \n",
    "ufukomer": "@rt2zz What is the solution for immutable.js type states? I'm trying this solution with redux-persist-transform-immutable but it gives error about type mismatch. https://github.com/rt2zz/redux-persist/issues/21#issuecomment-152688028. ",
    "IanVS": "If a nested reducer handles the REHYDRATE action, is that entire reducer skipped?  For example:\n``` js\nfunction subReducer1(state = initialState, action) {\n  switch (action.type) {\n  case 'ITEMS_UPDATED':\n    return {...state, items: actions.payload};\n  default:\n    return state;\n}\nfunction subReducer2(state = initialState, action) {\n  switch (action.type) {\n  case REHYDRATE:\n    return {...state};  // presumably something more complicated here\n  default:\n    return state;\n}\nconst topReducer = combineReducers({\n    subReducer1,\n    subReducer2,\n});\n```\nIn the above example, will subReducer1 still be auto-rehydrated?  In my testing so far, it does not seem to be.\n. Actually, in my case I have one more level of combineReducers, so it's more like:\njs\nconst topReducer = combineReducers({\n    anotherReducer,\n    midReducer: combineReducers({\n        subReducer1,\n        subReducer2,\n    });\n});\nNot sure if that makes any difference.\n. > you can alternatively handle the regular rehydrate action to set a rehydrated: true value in your redux state.\nHow would one then prevent that rehydrated key from being persisted along with the rest of the store, so that on page refresh it's reset back to false until REHYDRATE happens again?\n. Hm, nevermind.  It seems that adding rehydrated: false to the default state of the reducer is enough.\n. > Can we simplify the check to simply running a localStorage.getItem('test key')\nThat would handle this particular case, yes.  But, it does not save us if localStorage is at capacity and cannot be written to, which is where the setItem is useful.\n\ndoes sessionStorage suffer from the same quirk?\n\nHonestly I don't know.  I don't think I've been seeing any sessionStorage errors, so I wouldn't know how to test it.  I'd say leave it alone unless it's determined to be a problem.\n. This is a pretty good thread with different options for checking localStorage: https://mathiasbynens.be/notes/localstorage-pattern#comment-9\n. It seems that https://github.com/rt2zz/redux-persist/releases is still pointing to 3.0.0 as the latest release, and I cannot find any changelog for 4.0.0, although the npm badge indicates that latest is 4.0.1. \n237 is helpful, but is there a formal changelog anywhere as well?\n. ",
    "84564221": "The persistStore configuration API should be removed, since it is a pure functional programming anti-pattern. \nYou don't use configuration to construct your store, you use composition. In that way, you aren't limited to solely the mechanisms thought out ahead of time.\n. ",
    "coffenbacher": "Just a matter of applying compose correctly\n_configureStore.js_\n```\n  if (debug) {\n    createStoreWithMiddleware = compose(\n      autoRehydrate(),\n      middleware,\n      reduxReactRouter({ routes, createHistory }),\n      DevTools.instrument()\n    );\n  } else {\n    createStoreWithMiddleware = compose(\n      autoRehydrate(),\n      middleware,\n      reduxReactRouter({ routes, createHistory })\n    );\n  }\nconst store = (createStoreWithMiddleware(createStore)(\n    rootReducer, initialState\n  ));\n  persistStore(store)\n```\n. ",
    "thisiskylierose": "Ok then. Thank you. Let me know if there are any breaking issues. I have to integrate this with production code so it's tested but would be good to get feedback... just in case. \n. Thanks very much. \n. ",
    "af": "Thanks, I'm just getting started with redux-persist, but so far it's super slick! :+1: \n. Super fast, thanks!\n. Left some extraneous braces in my first commit, just force-pushed a fixed version\n. Cool, I'll look into that. Thanks!\n. Awesome, thanks! \n. Thanks! Not sure how I missed getStoredState()\n. One potential issue with it for me is that I export my persister (the output of persistStore()) so I can purge the store elsewhere. AFAIK having persistStore() in a callback means I can't export it anymore using ES6 modules. I haven't tried any workarounds for this yet, but one of your other two approaches may work for me anyways.\n. Yeah I've gone with option 3, was very easy and seems to do what I need. Thanks again for your suggestions!\n. Thanks! Any chance you could push a point release for this? I can't install from git since the ES5 source is generated in a prepublish script\n. No problem, thanks!\n. ",
    "jinaymehta25": "@rt2zz : Yes something like noop. @zalmoxisus: I saw your solution, exactly how do you decide where is the app running?\n. thanks @rt2zz and @zalmoxisus !!\n. ",
    "andreaspsson": "Missed to pass all the tests I see. Will update the pull request tonight \n. cool, thanks!\n. ",
    "RichardForrester": "I'm going to give it a shot over the next few weeks. Basically, persistence is the last piece of the puzzle for me and it's all very conceptual right now, but this is a basic overview of how I see it working:\nThe server-side redux store is the source of truth for all state that needs to be persisted and will be the database for the entire app. The client-side redux stores will contain a subset of what is contained in the server-side store as well as any state specific to that user that does not need to be persisted.\nExample:\n\nThe server-side store will contain usernames and hashed passwords for all users, however, an authenticated user's client-side store would not contain information on other users but would contain data specific to the browser state like current route, etc.\n\nWhen a client makes changes to state that is shared with the server, it will emit a socket.io event which will be handled by server-side redux which will emit an event to all clients updating their state. \nBefore The server emits the event to all clients, some persistence mechanism should guard against potential data loss. It could be as simple as a logging all actions into a MongoDB document so that when the server is restarted they could be reduced to pull the server-side store up to it's latest state. This approach would have the benefit of being able to roll back the server-side store to some previous state. The alternative approach would be to keep the server-side state as a MongoDB document which would simply be reloaded in the case of a server crash or restart.\nIt all seems possible but with many potential hurtles. That tutorial I linked to earlier gets me 90% there so we'll see.\n. @rt2zz Ya, I struggled with it for a bit but eventually scratched redux on the server and went RethinkDB + socket.io with Redux on the client. I still think the idea of using redux on the server is interesting, but getting away from a database entirely just turned out to be more change than I can handle.\n. ",
    "drop-dan": "+1\n. ",
    "Pajn": "Sounds great.\nIf you want a PR I should have some time next week but otherwise just go on and implement it :)\n. I know, and I later even created a little middleware for doing it but I thought that it would be a nice thing to have inside redux-persist directly. But that's just a proposal so you may do what you want.\nAnyway, here is the middleware. Might come to use to someone\n```ts\nexport const flushPersistorAction = 'flushPersistor/flush'\nexport const flushPersistor = (callback: () => void) => ({type: flushPersistorAction, callback})\nexport const flushPersistorMiddleware = (getPersistor: () => Persistor): Middleware => _ => next => (action: any) => {\n  if (action && action.type === flushPersistorAction) {\n    return getPersistor()\n      .flush()\n      .then(action.callback)\n  }\n  return next(action)\n}\n```. ",
    "christopherdro": "Sorry I managed to accidentally open this.\n. ",
    "baabgai": "Maybe instead of hacking with proto we could just use Object.create instead of the object literal initialization of subState.\nAssuming reducedState, subState and data are both objects of the same type the code could look like\njavascript\n...\nvar subState = Object.create(Object.getPrototypeOf(data))\nfor (var subkey in reducedState[key]) {\n    if (reducedState[key].hasOwnProperty(subkey)) subState[subkey] = reducedState[key][subkey]\n}\nfor (var datakey in data) {\n    if (data.hasOwnProperty(datakey)) subState[datakey] = data[datakey]\n}\nautoReducedState[key] = subState\n...\nThis should equally work for immutable and plain objects and might be a cleaner and more official way to do it I guess.\n. ok. \nAfter a few more tests I figured that's actually a much better idea since no data is saved on the first level anyhow for immutables, so a shallow merge done like I suggested would actually always overwrite one immutable object with the other one and not merge anything.\n. ",
    "arilitan": "I'm running into an issue where one of my reducers is storing state as immutable objects. When I rehydrate the store however, it is saving as a plain object not an immutable one. Any ideas how to fix?\n. ",
    "Icehunter": "I saw that but the one I was interesting in was the following code example:\n``` jsx\nimport { createStore, combineReducers } from 'redux'\nimport { persistStore, autoRehydrate } from 'redux-persist'\nimport reducer from '../reducers'\nconst store = compose(autoRehydrate())(createStore)(reducer)\nexport default class AppProvider extends Component {\ncomponentWillMount(){\n    persistStore(store, {}, () => {\n      this.setState({ rehydrated: true })\n    })\n  }\nrender() {\n    if(!this.state.rehydrated){\n      return Loading...\n    }\n    return (\n      \n        {() => }\n      \n    )\n  }\n}\n```\nDoes that flow along the same lines as well?\n. I can't get it working with my application.jsx right now actually.  You can see my code here:  https://github.com/awsbb/awsbb\n. I've left out the loading screen while refresh for now so not stuck at all; but really looking forward to your updates.\nThanks!\n. Hi! Not with the code sample that I had linked before:\nhttps://github.com/awsbb/awsbb/blob/master/webpack/application.jsx and the code snippet above.\nI want to make it so that while rehydrating a loader appears but I'm not sure where to place the code or if it's supported in the new version.\nUsing this package however works perfectly fine; I just don't know how to do the loader. :)\n. I'm still new to react for the most part, because I don't use a \"class\" in my application.jsx am I doing it the wrong way?\n. Works like a charm. Thanks so much!\n. ",
    "chrylis": "I needed to add one level of indirection with render-if to get transitions tracking for my hierarchy, but that example above gave me exactly what I needed to get the preload working. Thanks!\n. At a minimum, the persistor needs to log a warning when saving a date object. This is a really nasty gotcha that violates the general API promise of getting back what you put in, and even if it's unquestionably better to store the integer, the user shouldn't have to spend an hour tracking down  undefined is not a function errors because the object that was a Date is now a string with no warning.\n. ",
    "goodhyun": "Well, l didn't know that within a certain framework setImmediate is not automatically provided by global.setImmediate(). \nI sent a PR. \n. Works like a charm. \nHad to do npm run buildat the folder though.\n@noma4i the setImmediate shim was only effective when you don't have global.setImmediate already. ?\n. I'd also like to make sure that every bits are persisted when the app is shutting down.\nHow's the progress of #217 by @simonacca ?. ",
    "noma4i": "Doesn't work. Solution was to \nnpm install setimmediate \nand use \nimport setimmediate from 'setimmediate';\n. ",
    "neurosnap": "On a fresh install I ran into this issue, it might be a good idea to mention this in the docs.\nThe fix:\nbash\nnpm install setimmediate\njs\nimport 'setimmediate';\nimport { persistStore } from 'redux-persist';\n. ",
    "fabiosussetto": "I ended up extending your delayed rendering recipe here\nOn rehydration completed, I dispatch a normal action (say 'INITIAL_DATA_RESTORED') with the window.INITIAL_STATE data that I get from the server. My reducers catch the action as normal and they update their data accordingly. That triggers the normal redux-persist functionality so after I update the state with the server side data everything is persisted.\nIt seems to be working ok for now, what do you think of this possibile solution?\n. ",
    "RajnishDashora": "Hey @rt2zz, I am using 3.2.2, is their a cleaner way to achieve this now? That is, how to persist to local storage the initial state being passed to createStore, given the scenario the local storage does not have anything. \n. about persist/REHYDRATE getting fired even when you don't call autoRehydrate : as far as I understand it happens internally with persistStore(); function call. \n. AFAIK, autoRehydrate is just another enhancer to the store which helps you by saving some Extra lines of code to handle REHYDRATE action per reducer . need to explore more about the compose.\n. ",
    "technicallyjosh": "I can confirm that 1.5.3 fixes the storage.getItem is not a function issue. Things in my app seem to be back to normal.\n. ",
    "namxam": "I get the same in 2.0.0. Are you planning a fix for that too?\n. Checked it and the warning is gone. Thanks!\n. ",
    "skizzo": "Thanks, but I still get an error. Says \"compose is not defined\" at the line #4 of your code snippet before. package.json says I run v4.4.0 of react-redux and v1.5.5 of redux-persist, in the same file i added the line\nimport { autoRehydrate, persistStore } from 'redux-persist';\nbefore. \n. Works like a charm now, many thanks.\n. ",
    "roadev": "Thank you very much @rt2zz !. ",
    "taime": "I've got an error 'redux-persist' does not contain an export named 'autoRehydrate'.. ",
    "lxblvs": "Same as the poster above. Maybe this should be added to the documentation.. ",
    "jsaya01": "Was anyone able to solve the autoRehydrate issue?. ",
    "jaruesink": "autoRehydrate was taken out in v5 from what I could tell, still looking for how this works with the latest version of persist.. store/index.js\n```\nimport { createStore, applyMiddleware, compose } from 'redux';\nimport { persistStore, persistReducer } from 'redux-persist';\nimport storage from 'redux-persist/lib/storage';\nimport thunk from 'redux-thunk';\nimport createHistory from 'history/createBrowserHistory';\nimport rootReducer from '../reducers';\nimport initialState from './initialState';\nimport { isDevelopmentEnvironment } from '../environment';\nexport const history = createHistory();\nconst enhancers = [];\nconst middleware = [thunk];\nconst persistConfig = {\n  key: 'root',\n  storage\n};\nconst persistedReducer = persistReducer(persistConfig, rootReducer);\nif (isDevelopmentEnvironment()) {\n  const devToolsExtension = window.REDUX_DEVTOOLS_EXTENSION;\nif (typeof devToolsExtension === 'function') {\n    enhancers.push(devToolsExtension());\n  }\n}\nconst composedEnhancers = compose(\n  applyMiddleware(...middleware),\n  ...enhancers\n);\nexport default () => {\n  const store = createStore(persistedReducer, initialState, composedEnhancers);\n  return { store, persistor: persistStore(store) };\n};\n```\nApp.js\n```\n//@flow\n// Vendors\nimport React from 'react';\nimport { Provider } from 'react-redux';\nimport { PersistGate } from 'redux-persist/integration/react';\n// Layouts\nimport { LayoutGlobal } from './layouts';\n// Store\nimport configureStore from './store';\nconst { persistor, store } = configureStore();\nconst App = () => (\n  \n\n\n\n\n);\nexport default App;\n```. ",
    "ericlau-solid": "Thanks for the quick reply - there are 2 use cases:\n- one is for production. Say I have version 1.2 on PROD, and I want to deploy 1.3. Version 1.3 has some state-shape changes which make it incompatible with 1.2. How do I go about clearing out local storage redux state data that is incompatible, and ensure a smooth experience when user hits the site (at 1.3), with a local storage state which is fine in 1.2, but not 1.3.\n- one is for development -- we often find ourselves needing a quick button to clear out local storage. We have a workaround where we simply clear the localStorage itself (not using purge), and trigger a location.reload(). --- this is also useful in case there's a bug with the last use case and end-user needs a way to clear all the local storage and refresh.\n. ",
    "pke": "As for resetting the state to initial, isn't there a standard redux way to do that? After all, redux does get a fresh state on app start, by sending an internal INIT action to the store, which results in a call to reducers with state set to undefined. That causes all reducers to send back their initial state.\nSee here: http://stackoverflow.com/questions/35622588/how-to-reset-the-state-of-a-redux-store/35641992#35641992\n. ",
    "lucianomlima": "@rt2zz in V4 with purgeStoredState is possible to select store to purge or in a deep way, a data to be purged in a store?. ",
    "Sphinxs": "@lucianomlima , it probably can be done with PURGE. Have you cleared your store, please share how did you do this.. Thanks @tkow , return a copy works well:\n``javascript\nconst rootReducers = (state, action) => {\n  if (action.type === RESET_STORE) {\n    Object.keys(state).forEach(key => {\n      storage.removeItem(persist:${key}`);\n    });\nstate = Object.assign({}, initialState);\n\n}\nreturn reducers(state, action);\n};\n```. ",
    "peterlazar1993": "I see, not entirely related to this issue but does using an immutable structure as the top level state provide any value? \n. connect from react-redux implements a shouldComponentUpdate, I think there might be some value in having a top level immutable state. For now, I've decided to use Immutable structures on a per reducer basis.\n. @zalmoxisus Sure. Thank you :)\n. @rt2zz I've used https://github.com/rt2zz/redux-persist-immutable, neat little library :)\n. The last block of code looks same as your initial setup, that is parent whitelists 'auth', child blacklists 'error' in effect blacklisting 'auth.error'. But you said this is not working for you. \nSo which is it, does the last code block work or not?\nI am also facing a similar problem, I'm trying to blacklist a key of one of my reducers, the parent persistConfig blacklists 2 other reducers, I want my child persistConfig to blacklist a key which does not work. Which leads me to question if the nested persisters work? Is there an example I can run to test this?. ",
    "rufman": "https://github.com/rufman/redux-persist/tree/feature/hacked-immutable adds a config option to deal with any random kind of root state. I use it to shallow convert an ImmutableJS state i.e. store.getState().toObject(), so that the root state is a JS object that the rest of the library can deal with. The subStates are still Immutable objects, so I use redux-persist-immutable for actual de/serialization.\n. It's not as bad as doing toJS and I haven't seen a huge effect on performance yet. I use redux-immutablejs, using it's combineReducers which creates an Immutable iterable. I haven't yet come across a real good use case for a global immutable state, but I just started that way, so I would need to refactor a lot of stuff. I just started using immutablejs, so I just decided to go all immutable instead of picking and choosing where to use it. But that's more due to my ignorance/lazyness then an actual argument for or against an immutable root state. Honestly, I think the form of the root state shouldn't matter in terms of middleware/store enhancers being able to work with it.\n. @rt2zz I'll look into creating an immutable module and doing some benchmark testing, when I get some free time.\n. I've pushed an initial implementation for this issue here: https://github.com/rufman/redux-persist/tree/master any feedback would be nice. I'll open a PR one I've created benchmark tests.\nhttps://www.npmjs.com/package/redux-persist-immutable-state is a new npm-module I published that implements all the config hooks added above for ImmutableJS.\nUsage: \n```\nimport { stateIterator, stateGetter, stateSetter, \n         stateReconciler, lastStateInit } from 'redux-persist-immutable-state';\npersistStore(state, {\n  transforms: [reduxPersistImmutable], \n  stateIterator: stateIterator,\n  stateGetter: stateGetter, stateSetter: stateSetter,\n  lastStateInit: lastStateInit\n})\n``\n. @kachkaev check out https://github.com/rt2zz/redux-persist/pull/113 and see if that suits your needs.\n. @rt2zz I'm planning on doing that this weekend\n. OK, cool. In the mean time I have published this PR as [redux-persist-2](https://www.npmjs.com/package/redux-persist-2) for anyone that already wants to use it.\n.reduxPersistImmutableis from [redux-persist-immutable](https://www.npmjs.com/package/redux-persist-immutable), which serializes ImmutableJS substates. If your root level state is an ImmutableJS object you'll need to useredux-persist-immutable-state, but if it's a plain object and just your sub states are Immutable objectsredux-persist-immutablewill be all you need.\n.transform: [immutableTransform]should betransforms: [immutableTransform]`\n. Yeah, I guess I need to go over the docs and add that. My bad.\n. @rt2zz Yeah I think not exposing any of those options directly is a good idea. I'll look at starting an implementation of a \"higher order library\" this week.\n. ",
    "kachkaev": "Would be really nice if the library supported to-level immutable object. This is being used in mxstbr/react-boilerplate, which is one of the most popular boilerplates in React community today. What are the current plans on resolving this issue?\n. Ah, I wish I saw your PR this morning! Ended up with some clumsy solution based on the original library instead and spent so much time on this! I'll try your modified version of the module in the next project and actually hope that your PR will be finally merged by then!\n. @rt2zz why have you closed this issue? Has there been a PR that solves it?\n. It's probably a bit more difficult than that. When you just start a debugging session, you'd want REHYDRATE to dispatch. But when the session continues, there's no more need for that. How about not triggering REHYDRATE when there is not just @@INIT in the log?\nActually, there can be something but @@INIT, e.g. @@router/LOCATION_CHANGE. Maybe persistStore can just get some boolean option that disables rehydration? One may still want to persist the following changes of the store and see the state of the interface restored after removing ?debug_session=xyz.. ",
    "totallymike": "The use case that came to mind was triggering a refresh of an authentication token if the prior had expired.\n. I did end up just keeping our dependency at 1.5.3.  The addition of the rehydrateAction to handle this scenario has the odd effect of persist/COMPLETE firing before the persist/REHYDRATE events, though :)\nI'm rather unfamiliar with how sagas work (or what they are, in this context), but I'll do some digging.  It's clear that some rearranging needs to be done.\n. That makes sense to me.  I'm thinking I'm going to pull the whole auth flow out into a middleware, actually.  There I can schedule the next token refresh and so on in a reasonable manner.\nThanks for all your help!\n. ",
    "aguynamedben": "This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.. This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.\n@chrylis you mentioned\n\nAt a minimum, the persistor needs to log a warning when saving a date object. This is a really nasty gotcha that violates the general API promise of getting back what you put in\n\nThat suggestion has 31 upvotes. Would you help the redux-persist project by contributing a PR that does that? I'd be happy to review it and merge it.. @fungilation Would you still be willing to take a shot at implementing this? I was going to mark this issue as stale and close it, but it has a ton of upvotes (10 upvotes on the original question, 23 upvotes on a comment asking if there are any updates). It seems a lot of people would like to use Realm.js with redux-persist.. This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.. This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.. This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.. This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.. This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.. This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.. This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.. This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.\n@ColinEberhardt @ankit90anand Docs PRs welcome... I'll review them and merge them.. This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.. This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.. This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.. This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.. This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.. This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.\n@TanninOne @martinfilliau I'd really appreciate if you could submit a PR to help the project out. A similar error handling PR was recently submitted and merged: https://github.com/rt2zz/redux-persist/pull/949. This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.. This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.. This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.. This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.\nAlso, the PR was closed by the author.. This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.. This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.. This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.\n@SCLeoX I'd appreciate if you submitted a PR helping improve the docs on this. I'd be happy to review it if there's a specific proposal to improve the docs.. This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.. This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.. Related issues:\n https://github.com/rt2zz/redux-persist/issues/330\n https://github.com/rt2zz/redux-persist/issues/318, specifically note this comment: https://github.com/rt2zz/redux-persist/issues/318#issuecomment-291008227\n. This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.. This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.. This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.. This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.. @CharlieHess I was going to mark this issue stale since the issue hasn't been updated in a long time, but it looks like your PR is still outstanding and you're still seeking feedback now that v5 is out.\nDiscussion in here: https://github.com/rt2zz/redux-persist/pull/360\nIs this still something you'd like a resolution on? Thanks for submitting your PR to the project. @rt2zz seemed somewhat concerned about the support burden of this PR, and he's already stretched in supporting this project. It would help the project immensely if we could get a commitment that you'd help support this feature and address any issues that come up with it.. Tagging a few of the other people who seem interested in this feature from PR comments: @antondomratchev, @cascornelissen, @jstaab, @mnquintana, @sebastian-schlecht. @dahannes, @dhruvparmar372, and @mairi17 also seems interested in the PR based on \ud83d\udc4d's. My project also stores things in keytar (async) that I wish would be blacklisted and rehydrated. So there seems to be around 9-10 people wanting this, including people who work at Slack and legit companies.\nThat is @CharlieHess stated use case:\n\nIn my case I wanted to store secrets securely (say, in the keychain) and have them excluded from the persisted shape. Then, on rehydrate, I wanted to read the secrets from the keychain and apply them to the state as if they were there all along.. This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.\n\nAlso related, Flow issues still need work: https://github.com/rt2zz/redux-persist/issues/953#issuecomment-449545453 @juanolon if you're still using redux-persist, could you help out the project and try to sort out some of these Flow issues? See the comment linked above for what the current issues are.. Related https://github.com/rt2zz/redux-persist/issues/330. This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.. This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.. This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.. This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.. This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.. The PR was merged: https://github.com/rt2zz/redux-persist/pull/321\nThe API is .flush() and is documented in the README here. It's available in redux-persist v5.. This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.. See this comment: https://github.com/rt2zz/redux-persist/issues/318#issuecomment-291008227. This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.. This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.\n@redgenie Did you end up trying v5 out?. This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.\n@ghostec You may want to take a look at the PersistGate features in the project's README to prevent React component rendering until redux-persist rehydration has completed. I'm not sure, but that feature may have been added after you posted this issue.. This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.\n@raould I'm not sure if it solves your exact issue but you might want to take a look at the blacklist features documented in the project's README. Keys in the blacklist (i.e. reducer names) will not be persisted.. This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.\n@rkurbatov There are a number of Flow issues with redux-persist that we'd like help sorting out. If you'd be open to contributing improvements to this and other Flow issues, we'd really appreciate that and it'd help the project out a ton. Other Flow issues are aggregated in https://github.com/rt2zz/redux-persist/issues/953#issuecomment-449545453. This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.\n@jasan-s I'm not sure if it solves your exact issue, but have you taken a look at the PersistGate feature documented in the project's README? It's aims to stall React component rendering until after redux-persist has rehydrated.. This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.. This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.\n@voidrealms Please note that some helpful blog tutorials were recently added to the README: https://github.com/rt2zz/redux-persist#blog-articles-from-the-community I've found those helpful in getting redux-persist up and running.\n. This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.\nI'm not sure, but I think for better or worse, redux-persist may have some built-in assumptions around state/defaultState being an empty object (not undefined or null). Potentially related: https://github.com/rt2zz/redux-persist/issues/817. This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.. This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.. This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.. This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.. This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.. This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.\nI think I've had this issue bite me pretty hard before with other JS libraries. I view it as a weakness in JavaScript the language. I think there are ways to catch this if we knew it was very common in a certain area.\nThe other way to avoid user from having this problem is to change the API to accept only a params object. i.e.\njs\npersistStore({\n  store: store,\n  blacklist: ['route'],\n  storage: localForage,\n});\nbut I'm not sure it's worth this project implementing a change like this to work around a weakness in the JavaScript language.. This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.. This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.\n@Noitidart Note there is an outstanding PR for async transforms being considered:\nPR: https://github.com/rt2zz/redux-persist/pull/360\nIssue: https://github.com/rt2zz/redux-persist/issues/303. Tracking in this issue: https://github.com/rt2zz/redux-persist/issues/303\nand this PR: https://github.com/rt2zz/redux-persist/pull/360. This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.. Tracking in this issue: https://github.com/rt2zz/redux-persist/issues/303\nAnd this PR: https://github.com/rt2zz/redux-persist/pull/360. @levsero Did you get end up getting this working? Thanks for taking the time to submit that fix. I'm going to try the experimental feature in the next few days, after I implement the upgrade from v4 to v5.\nFWIW my situation: I built a new feature assuming I could run async code during a redux migration, but redux-persist-migrate v4.x doesn't support async code in migrations. redux-persist v5 has first-class support for migrations and allows a Promise to be returned to run a migration (\ud83d\udc4d!!!). But the pain level of clearing local state is very high, as my users invest a lot in configuration that is stored locally for a good reason.\n@rt2zz thanks so much for the time you put into redux-persist and redux-persist-migrate before v5. \ud83d\udc4f\ud83d\udc4f\ud83d\udc4f. Looks like this was done here: https://github.com/rt2zz/redux-persist/commit/867317cf0a4a19cd8a51b8048589c893d18a9fa2. @rt2zz As you probably see I'm digging through old issues (i.e. older than 12 months) to try to figure out what is stale/irrelevant. Is this a high enough priority to keep open or should we just close it?. This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.. This hasn't been responded to in a long while, so I'm going to mark it as stale. Please feel free to continue the conversation and I'll reopen.. Maybe related to https://github.com/rt2zz/redux-persist/issues/780 which also mentions (slightly different) flow errors with dispatch, getState, and subscribe.. @SteveMellross Thanks for the info on persistCombineReducers.\nAlso, if it's not too late, take a look at https://github.com/rt2zz/redux-persist/issues/434, I'm about to try that method for v4->v5. Someone verified they got it working.. It is a mess. If anybody wants to help with development, bug fixes, or organizing the issues, help would surely be very welcome. I'm trying to at least organize and prioritize the issues with labels, and work through all the old ones. I think @rt2zz has very limited time to spend working on redux-persist, but maybe he could chime in.. This seems to be a gotcha with Jest and async components that was sorted out. I'm happy to merge a PR or docs update if appropriate for the project, but closing this for now.. Looks like this is an upstream limitation with AsyncStorage.. Thank you for contributing. All help is very welcome. Merging!. To deal with this, I'm copying this project's createMigrate.js and modifying it in my project to this: https://gist.github.com/aguynamedben/ee5ef358856f1543129265fd3cf8b732\nSee the tests for how to use it...\njs\n      const asyncMigrations = {\n        1: async (state) => {\n          return {\n            ...state,\n            foo: 'different',\n          };\n        },\n        2: async (state) => {\n          return {\n            ...state,\n            baz: 'bang',\n          };\n        },\n        3: async (state) => {\n          return {\n            ...state,\n            cool: 'beans',\n          };\n        },\n      };\nconfigureStore.dev.js\n```js\n  const persistConfig = {\n    key: 'root',\n    storage: storage,\n    debug: true,\nmigrate: customCreateMigrate(asyncMigrations, {\n  debug: true,\n  asyncMigrations: true,\n}),\nversion: 8,\n\n};\n```\nWe use the same logic in customCreate.js to figure out which migrations to run. For async migrations, we use this technique to dynamically build a promise chain using Array.reduce(). This means the async migrations are run in sequence, one after another.\nWith the current code, you must provide the option { asyncMigrations: true } or else the old logic is used, which will screw up if you have async migrations.\nIf #929 gets resolved I'd happily submit a PR to add this. I think we could even detect if the migration function is async and resolve automatically so that specifying the asyncMigrations option isn't necessary.. I need to submit my gist as a PR.. I'm not sure if this is also related to feature requests for async transforms. https://github.com/rt2zz/redux-persist/issues/303 I need to figure that out. It seems like they might be separate per this comment: https://github.com/rt2zz/redux-persist/issues/426#issuecomment-325262469\nAlso maybe related: https://github.com/rt2zz/redux-persist/issues/426. Does this fix it? https://github.com/rt2zz/redux-persist/pull/961/files. Waiting on new release, tracking new release in #980.. Can you provide a test repo that demonstrates the issue and I'll help look into it?\nI think it might be because your OnBeforeLift argument is a function that is simply firing, then PersistGate moves on, without waiting for the Promise to resolve. Can you try...\njs\nreturn (\n  <PersistGate\n    onBeforeLift={ async () => { await this.loadSettings() } }\n    persistor={persistor}\n  />\n);\nor maybe just\njs\nreturn (\n  <PersistGate\n    onBeforeLift={this.loadSettings()}\n    persistor={persistor}\n  />\n);\nI believe onBeforeLift can take a function or a Promise to resolve.. @mzafer Let me know if you still are having a hard time with this and I'll re-open.. I don't think there is a low-level API for doing this in a special way with redux-persist. You should load your store. Once it's rehydrated, you can use normal Redux methods (i.e. store.getState()) to access a specific key.\n```js\n// using redux-persist when generating your Redux store...\nexport default () => {\n  let store = createStore(persistedReducer)\n  let persistor = persistStore(store)\n  return { store, persistor }\n}\n// getting a value from the store...\nconsole.log(store.getState().xxxx);\n```\nDoes that make sense?. @sachinKumarGautam Could you provide a test repo demonstrating the problem? Based on @rafael-garcia's description it sounds like it might be a bug with PersistGate not continuing past the loading stage.\n@rafael-garcia are you also using nextJS?\nI'm new to helping with this repo, I haven't tested redux-persist with nextJS or with JavaScript not available, but I'm happy to help look into the root cause.. @rafael-garcia Are you still dealing with this?. @rt2zz Thank you so much. I will do my best to help contribute and merge starting this week.. The goal of redux-persist is to store Redux data somewhere durable, rather than just keeping Redux data in memory. There are many storage engines you could use, and most of them focus on storing Redux state on the client in some sort of local disk storage (i.e. localStorage) to persist data between page loads, app restarts, etc.\nFor your app, I think you have some design things to sort out...i.e. When should data be passed back from the client to the server? And how? Using an API? GraphQL?\nI think it's an experimental (and possibly bad?) idea, but theoretically you could probably build a custom storage engine for redux-persist that stores Redux data on a server somewhere, but I don't think that's the main way people are using this project. Most people are using it to store data locally.\nI'm going to close this issue but feel free to keep the discussion going. I'm new to helping organize redux-persist, but I'll help as much as I can.. I think this might be fixed in a recently merged PR: https://github.com/rt2zz/redux-persist/pull/919/files#diff-13437120c94446e7f7325a148bcc9694R105\nTo try the new version out follow the instructions in this comment: https://github.com/rt2zz/redux-persist/pull/919#issuecomment-445576500\nCan you try out 5.11.0-alpha and let me know if that solves the issue you found @hadigoh?. @hadigoh I haven't heard back from you. Let me know if you find this is not fixed with the PR I referenced that's included in 5.11.0-alpha.. I'm not well-versed in this codebase, but could you explain why this PR is so massive? There are tons of new, large files added. Did you reorganize the project?. @lao9 Ah okay cool, thanks haha. Yeah we use redux-persist and I noticed this project was seems abandoned, and was browsing some PRs to size up how much work it'd be to help maintain it in some meaningful way.. @kreba Would you be willing to help out and submit a PR with the appropriate changes to the README so we can improve the docs for the project?. Ah good catch @kreba. Looks like that PR was merged. Either of you should feel free to submit a PR for any improvements to these docs and I will review and merge.. Closing this for now. @kreba feel free to submit a PR to update the README.\nI added a Community section to the README that links to tutorials including the one you mentioned. https://github.com/rt2zz/redux-persist#blog-articles-from-the-community. Does the blacklist feature not do what you need it to do? Keys in the blacklist will not be persisted.\nhttps://github.com/rt2zz/redux-persist#blacklist--whitelist. Sorry, I misunderstood your question when I originally answered/closed.\nSo this seems like a feature request, right? Would you recommend the API to be an argument to .purge()? Want to provide an example? I personally don't use .purge() in my project so feel free to provide more details on what you'd like to see.. > I believe it was possible before\nWas this in v4? Looking at the API.... What storage engine are you using? Can you please provide a test repo that demonstrates the issue and I'll take a look?. @vishalTechnoFreek I haven't heard back from you. Let me know if you're still having issues with this and I'll re-open and help you look at an example project.. Can you please provide an example repo demonstrating the issue and I will help inspect it?. Cool, glad you figured it out.. > I am not sure if this change will cause other bugs. I want to know if there is a problem with the usage or a bug in the project itself.\nI'm not sure either. @rt2zz might be able to help when he has time.. @augusto-altman I'm new understanding redux-persist and its internals, but I'm trying to help triage issues. Do you have an example GitHub repo I can clone and inspect? It looks like playing with this test might be helpful.\nWhich storage engine are you using? You mention your using React Native so I presume you're using the default storage engine (AsyncStorage)?. @augusto-altman I just came across this issue that I think could help you out: https://github.com/rt2zz/redux-persist/issues/377#issuecomment-309340678\nIt looks like using localStorage as your storage engine with massive state will cause a long startup time (I know you asked more about flush, I'm still not sure about that). It seems worth investigating localForage as your storage engine with redux-persist if you have very large state.\nAgain, if you'd want to try out the flush message with very large state, or dig into the flush code, it'd be helpful if you could benchmark and document what you find when pushing the limits of state size. That would probably be very useful to future people managing large state.. @nevir Would you mind answering this question since you implemented the .flush() logic? https://github.com/rt2zz/redux-persist/pull/321. @dereknelson I created a Discord channel for #redux-persist: https://github.com/rt2zz/redux-persist#chat-room I'd appreciate if you'd join and help me get the ball rolling!. @rt2zz Can you install this stale bot for redux-persist? https://github.com/apps/stale\nNothing will happen until the file .github/stale.yml is created. I'll dig into the settings and configure appropriately. Probably 30 or 60 days after an issue has gone dormant, the bot will comment, then 7 days after that if nobody has replied, the issue will be closed with wontfix. Issues are auto-reopened if somebody replies.\nThey currently use this at electron-react-boilerplate and it seems efficient. I think it will be a good way for us to whittle the 304 issues down to the \"real\" remaining issues.. I have not use custom transforms in a project, but it seems:\n whitelist as an option for persistReducer (i.e. PersistConfig): \"only persist these keys\" (documented with comment here)\n whitelist as an option for createTransform (i.e. TransformConfig): \"define which reducers this transform gets called for\" (documented with comment here)\nIt seems like we should document TransformConfig in the Full API doc. Would you be willing to take a stab at that if the differentiation above make sense? Maybe you could include a comment like \"not to be confused with PersistConfig.whitelist\" as well.. @customcommander I haven't heard back from you. Let me know if you still have questions around this and I'll re-open.. Note: There is also https://github.com/rt2zz/redux-persist/blob/master/docs/api.md, I missed the \"Full API\" link in the README at first.. I'm not sure how to to do that, but I'm curious about your use case... why do you want to stall rehydration until there is internet? Are you using a custom storage that requires internet? My app just uses localStorage, so I don't care if there is internet during rehydration.\nAlso, note the v4->v5 updates for autoRehydrate: https://github.com/rt2zz/redux-persist/blob/208c6b112ead87b3701dfacaae2cdbe78377775a/docs/MigrationGuide-v5.md#migration-from-v4-to-v5 Maybe something in there will help you figure out what to do here.. Potentially related Flow issues:\n https://github.com/rt2zz/redux-persist/issues/690 was closed, but users subsequently raised credible issues/challenges making Flow happy\n https://github.com/rt2zz/redux-persist/issues/780 (18 upvotes)\n https://github.com/rt2zz/redux-persist/issues/763 (7 upvotes)\n https://github.com/rt2zz/redux-persist/issues/842 (1 upvote)\nA recent PR that fixed some Flow issues:\n* https://github.com/rt2zz/redux-persist/pull/697\nAn important comment from the author about Flow usage (@rt2zz):\n* https://github.com/rt2zz/redux-persist/issues/690#issuecomment-362420951 (should this be added to docs/README?)\n@baransu You recently submitted Flow improvements (thank you \ud83d\ude4f), would you mind helping the project by looking at some of these issues and sizing up the root cause?\n@kareemsalah227 Would you mind spending a little time to create a small test project that replicates these issues so we can look into them better? Also, you mention:\n\nAlso when integrating with React and using \nDid you mean...\nAlso when integrating with React and using Flow\n\nI haven't experienced these Flow issues myself but we should definitely get them resolved. Any help in doing so or contributing a fix to the project would be appreciated.. @erksch's PR has been merged to master. We'll need @rt2zz to release a new version for the fix to be in npm (I don't have the power to do so).. I've been trying to help this project, which needs a lot of help if anybody is interested. I can merge this, doing now. I don't have the power to cut a new release, but you can link your package.json to the right sha1 hash.. @mattlubner Thank you for the contribution. Merging now. \ud83d\ude4f. Thank you, merging!. I also don't see this anywhere in redux-persist... are you sure you don't have a line that is checking your own Redux state for something? (i.e. state.filterNot, is that state you manage?). Thank you @kreba! \ud83d\ude4f. I'm new to redux-persist and trying to help manage the project (it needs a lot more help if either of you is interested in helping). Thanks for both of your PRs.\nSo, if I'm following the discussion correctly does that mean https://github.com/rt2zz/redux-persist/pull/974 should be merged over https://github.com/rt2zz/redux-persist/pull/975?\n\nI just merged this other PR to add a CHANGELOG to this project. Can one of you update the PR by merging in master (to get the CHANGELOG on your branch), then add a changelog entry describing this change? Does that make sense? Then I can merge it.\n\nThanks again for your contribution. If either of you wants to become a redux-persist expert we need more of those in the community! :). Whoops, here's the changelog PR I mentioned: https://github.com/rt2zz/redux-persist/pull/954. Cool, I'll give @kareemsalah227 a few days to alter the PR with the object destructuring. No rush from my end. Thanks again, let me know when it's ready!. We merged https://github.com/rt2zz/redux-persist/pull/974 after discussion with @kareemsalah227 and @erksch, closing this PR.. Should this be written a little bit differently so it's not deciding a value then immediately overwriting it? Something like:\njs\nlet serialize;\nif (config.serialize === true) {\n  serialize = defaultSerialize;\n} else if (config.serialize === false) {\n  serialize = x => x;\n} else if (typeof config.serialize === 'function') {\n  serialize = config.serialize;\n} else {\n  throw Error('config.serialize must be true, false, or a function');\n}. (same here re: comment above). Shouldn't deserialize? and serialize? have the same value here?. I guess there is no config.serialize === true, people can just pass false or function, so maybe...\njs\nlet serialize;\nif (config.serialize === false) {\n  serialize = x => x;\n} else if (typeof config.serialize === 'function') {\n  serialize = config.serialize;\n} else {\n  serialize = defaultSerialize;\n}. I think this would be clear if you just move import { store, persistor } from './configureStore' to right under the PersistGate import above. If you do that I think we can remove line 47, then I'll merge it.. I suggested that for readability, not performance. Overwriting serialize after it's set by some other logic seems like it could lead to misunderstandings about what's going on with serialize (i.e. someone reading the code might not realize we're going to change the value after setting it).\nThanks for the contribution!. ",
    "romanenko": "After some investigation I began to get issue a bit better now. Return value from dispatch(action) calls are undefined because actions aren't dispatched immediately during store rehydration \u2014 they are getting queued by bufferActions(). \nI was implementing isomorphic app, and this behaviour caused problems, when I tried to wait for data-fetching from async actions to be done before rendering. I omitted redux-persist initialization in node environment and now my issues are gone.\nBut, still, maybe, we should return action from dispatch() after queueing its actual dispatching?\n. ",
    "danielbuechele": "I found my mistake. I had an invalid object in my store. I stored a required image in the store which crashed the rehydration. Sorry! Great project!\n. My faulty reducer looked like this, what caused the crash (using react-native):\nconst initialState = {\n    a: require('../image.png')\n};\nexport default function reducer(state = initialState, action = {}) { ...\n. ",
    "Klathmon": "You pass in a reference to the 'localforage' variable/global as the 'storage' value in redux-persists config.\nIt's basically exactly the same as using AsyncStorage from react.\nI was actually thinking about adding an example to the readme, but it was almost identical to the AsyncStorage one:\njs\nimport localforage from 'localforage'\npersistStore(store, {storage: localforage})\nlocalForage's API was almost identical except for that one function that i modified in the change.\n. Hey I hate to be a pain but would you be able to cut another release (or prerelease) for this?\n. Thanks, I appreciate it. Don't rush, I just wanted to know if it would happen within the next week or so.\nAnd I'd point it at the repo but the lib dir isn't published, so I'd need to compile to es5 myself which would be more work than its worth at this point.\n. It's not a long-term solution, but I've got a \"hack\" that can let you at the very least get confirmation that your store was persisted before doing anything that requires it (like a page refresh).\nIn my case I'm using localforage as my store, so I just \"proxy\" the setItem key on the localforage object to be my own function which I can then use to run whatever I want once the setItem in localforage is complete. Here's the snippet that hopefully explains what I'm doing better than my gibberish:\n```\nconst localforageSetItem = localforage.setItem.bind(localforage)\nlocalforage.setItem = (key, value, callback) => {\n  return localforageSetItem(key, value, (...args) => {\n    console.log('Done persisting!')\n    callback(...args)\n  })\n}\n```\nI'm going to use it to fire custom events so I can attach a listener to get notified when a store is fully persisted and it's safe to move on. It's not a particularly good solution, but it will work until either a manual persist gets implemented, or someone comes up with something much less horrible.\n. Ugh... I just noticed #321 which has tests and better documentation, so I'm just going to close this PR.. ",
    "marvinhagemeister": "I'll squash the commits into one, once I fix the CircleCI errors.\n. Seems like this is a problem with older node versions (pre v4). Looking at the log of CircleCI npm always installs babel v5 which is the root cause.\nIs compatibility with node v.0.10.X still a requirement?\n. Glad I could help!\n. Date objects will be converted to string by  JSON.stringify() which is used in the default serializer.\nOne great advantage of redux is that everything only has to deal with plain objects, not with functions. Here is a great answer by redux's creator to a similar question on Stackoverflow\n. @chrylis That's a great ux suggestion. We could print a warning in dev mode for the default persistor. I'll have to check how that would work with immutablejs (haven't touched it in a while), but I'm all for helpful warning messages.\n. @rt2zz awesome debugging!\n. My vote goes for a) too. The more we can use native JavaScript functions, the better.\n. @rt2zz I think you had the right intuition! It is indeed caused by lodash.\nI'll try to build the umd with rollup tomorrow. The tree-shaking should automatically take care of that. At work we have quite a few projects where that alone cut down the bundle size noticeably. We could even provide an es build via js:next for easier tree-shaking (only works with es6 syntax.\nThat is a great idea with unpkg! Should be easily doable \ud83d\udc4d \n. got the es6 build working (for rollup or webpack2) but it's still a mystery why there is so much lodash stuff. Will investigate further in the coming days\n. Found the issue! The root cause is lodash/forEach:\n| build option | size minified (no gzip) |\n| --- | --- |\n| with lodash/forEach | 41kb |\n| without lodash/forEach | 29kb |\n| with lodash-webpack-plugin | 20kb |\n@rt2zz Thanks for the tip with lodash-webpack-plugin:+1: \nunpkg should be working out of the box. Both redux and redux-saga don't have an extra browserkey in package.json\n. You're right that the umd-bundles are created with webpack 1. What I mean with webpack 2 and rollup support is that they need to operate on import statements for tree-shaking to have any effect.\n. @rt2zz yep, this is ready to ship \ud83c\udf89 \n. @rt2zz sweet! \ud83c\udf89 \n. @rt2zz LGTM, but you are way more familiar with this part.\n. @willmcclellan Installing an npm package from a github repository is supported by npm.\n. @rt2zz oh I see, didn't think of that! Perhaps we could run our build step as a post-install script. What do you think?\n. Seems like there is something strange passed to Object.assign. Does the error come from the persistStore call or is it related to one of your reducers?\nI'd love to get to the root of this issue.\n. @petervavro Due to work constraints, I haven't the time to create a reproducible test-case yet. Is there any chance that you could create a minimal reproducible example?\n. Your state tree needs to be serializeable. That's basically the whole idea behind redux, that you can easily swap out the state tree because it is serializable. In your case it seems like you have a function inside your store.\nThere is a great discussion about what to put into redux's state tree here: https://github.com/reactjs/redux/issues/1385\n. @octaviogb  Thanks for reporting this bug. I'm unsure at which part of the stack the problem appears. Could be the webpack config, could be a problem with our setup, or it could be something entirely else. I'd love to help you track down the root cause.\nCan you post your webpack config or if you can a tiny sample repository where we can reproduce this behaviour?\n. Thanks a lot for your PR! Are you sure if this is not an error in your client code? The documentation is consistent with our code:\n``` js\nfunction createTransform (inbound, outbound, config = {}) {\n  let whitelist = config.whitelist || null\n  let blacklist = config.blacklist || null\nfunction whitelistBlacklistCheck (key) {\n    if (whitelist && whitelist.indexOf(key) === -1) return true\n    if (blacklist && blacklist.indexOf(key) !== -1) return true\n    return false\n  }\nreturn {\n    in: (state, key) => !whitelistBlacklistCheck(key) && inbound ? inbound(state, key) : state,\n    out: (state, key) => !whitelistBlacklistCheck(key) && outbound ? outbound(state, key) : state\n  }\n}\nexport default createTransform\n```\ntaken from https://github.com/rt2zz/redux-persist/blob/master/src/createTransform.js#L11\n. @saberking Thanks for your explanation. I see where the confusion comes from. I think just flipping the names would not suffice, because there are likely others who'd expected it the way it is. Perhaps we can find a more meaningful name that signals where the data is flowing to.\nI like both toReduxStore or just toStore and toPersistentStorage/ toStorage or something similar. What are your thoughts about this @rt2zz ?\n. After thinking about it the only thing that I'm afraid of is the resulting API breakage. We just passed 1000 stars here on github and there is probably a lot if code out there which relies on the current behaviour. We could leave the current methods intact and print a deprecation warning whenever they are called. \n. That is curious. Are you sure that the problem is caused by redux-persist? We only use either localStorage or SessionStorage with the default persistor that's shipped with redux-persist. Do you use a custom persistor? At work I noticed similar errors and they were caused by tracking scripts.\n. Right, feel free to reopen it once the issue comes up again.\n. It's hard to tell what is wrong because the error happens somewhere higher on the stack tree. The marked comparison fails because action is undefined. Could it be that somewhere in your code your dispatching undefined inserted of an action object?\n. @jasan-s I'm happy to hear that you found a solution. \ud83d\udc4d \nFor reference: You can delete the contents of IndexedDB right from the firefox devtools: https://developer.mozilla.org/en-US/docs/Tools/Storage_Inspector\n. Thanks!\n. Awesome, thanks a lot for the PR!\n. I'm all for simplifying code but I must admit that I haven't used them myself yet. The default json serializer may be enough for most people. I'm a bit afraid though when people try to put none serializeable objects in their store. Things like date objects, etc.\n. @rt2zz That sounds great \ud83d\udc4d  I must admit that I haven't really worked with immutablejs yet.\n. I can't thing of any place where we use indexedDB in redux-persist. This is very likely an issue with localForage.\n. @rt2zz We have tagged 4.0.0 and 4.1.0 as stable here in github. We should update the packages on npm.\n. This seems to be a current issue with the npm registry. npm/npm#14646 contains more information\n. Agree, I'm closing this in favor of #212 \n. Closing because this is a duplicate of #212 .\n. That is quite curious. I can't reproduce it locally with a simple test case. Can you check if the problem exists when writing or restoring the store in your app? Most likely you are using the LocalStorage backend and the contents can be easily inspected in the chrome or firefox devtools.\n. @rt2zz  LGTM. Thanks!. @morlay Awesome stuff! I've been meaning to add typings for a while now, but haven't had the time to do so. That's what I love about open source \ud83d\udc4d  Thanks for contributing \ud83d\udcaf . @ucarion Thanks a lot for your PR. Sorry, for not merging this sooner \ud83c\udf89 . @hoofman We'd love to help you with any issues or questions you might have on redux persist. I'll close this issue for now, but feel free to add more information to your report.. @orlando Awesome, thanks for spotting that!. At the time the main bulk of code for redux-persist was written Promises weren't that widely used in client-side code. A promise-based API is a great idea! Would you love to make a first draft?. @rt2zz That looks awesome! Would it make sense to replace autoRehydrate with the solution in your new repo in the future?. I'm sorry to hear that you redux-persist doesn't seem to be working as expected. It seems like the code examples contains more code than necessary to trigger the issue. Would you please be so kind to create a minimal sample repository with the code above (or better with a minimal reproducible setup)? That'd be really awesome and saves us maintainers a lot of time \ud83d\udcaf . Sorry for taking so long! Our code checks for both getAllKeys and keys, with the latter being localforage. The Storage interface needs to treat both as optional parameters to support both use cases:\nts\ninterface Storage {\n    setItem: Function;\n    getItem: Function;\n    removeItem: Function;\n    getAllKeys?: Function;\n    keys?: Function;\n  }\n@Dante-101 This PR should fix this https://github.com/rt2zz/redux-persist/pull/276 Could you give it a quick look if it works for you? If it does I'll hit the green merge button \ud83d\udcaf . Awesome, thanks for having a quick look at it! I just merged the PR and the next release will contain the updated typings \ud83d\udc4d . yep, completely backwards compatible :). Oops, found two missing semicolons. I'll leave it open for 1-2 days to gather feedback in #273, but I think it's save to merge.. Thanks!. @LKay awesome! Much appreciated!. Can you rebase against current master and squash some commits? There seem to be some commits of your last PR included in this one.. Thanks for the fix. Sorry that this issue got through.. @rt2zz Sorry for merging this too quickly. The previous typings in master where invalid and wouldn't compile at all. Just looked at the source and you're right that getAllKeys needs to be optional.\nNonetheless we really need to add tests for our typings. There are further errors with the Storage and the get/setItem signature, I'm afraid :/. Yep, that's exactly the case. Infinity is unfortunately not part of the JSON spec.. Awesome! Thanks for your contribution \ud83d\udc4d \nI took the liberty of squashing the commits down to a single one.. Really great insight and an awesome writeup @Andarist ! \ud83d\udcaf \nFrom my experience uglify works best if it can do a simple search and replace inside if statements. If it has to follow the program flow it seems to be more defensive of dropping code. So I'm all for using process.env.NODE_ENV directly. \ud83d\udc4d \n. Awesome!. Yay, for smaller bundles \ud83d\udc4d . Awesome! Prettier is a relief for the js community \ud83d\udcaf . That's a neat size improvement. Thanks for tackling this one \ud83d\udc4d  I made a few (really) minor comments, but really it's a huge improvement. Great work!. @Andarist I think it makes more sense to make a separate PR for that. I was hoping to fix the unpkg link which points the the package.json's main field. But that is a different issue. Wasn't right of me to put that in the same PR.. Yeah, rollup really does wonders. A nice bonus is that the output is very human readable compared to webpack \ud83c\udf89  Thanks again @Andarist for putting in the necessary research and making this PR \ud83d\udcaf . Whoops, closing in favor of #341 . Didn't saw that one. Thanks for reporting this issue. Do you have a test case or code snippet, that we can use to reproduce this?. @cbayram Thanks for your PR \ud83c\udf89  Using generics (the State in) Promise<State> is the right way to do it.. I can check if loose mode is still needed. It was included in the babel5 config as well. In a nutshell: output generated with loose mode can potentially be faster, but may lead to compatibility problems when transpiling won't be necessary in the future. More info: http://www.2ality.com/2015/12/babel6-loose-mode.html\n. Will check tomorrow\n. This is necessary for the es-build. Tree shaking only works with es2015 import statements because they are statically structured unlike commonjs where you can require modules inside an if-statement for example.\nFor our commonjs build I did use the normal es2015 preset scoped to the BABEL_ENV=commonjs environment variable. That way we can easily switch between different build outputs.\nOriginally i had put the modules: false setting under the es env-var, but somehow babel throws an exception there. This smells like a bug in the config parser of babel itself.\n. Can you remove the spaces around counterTransform here? That'd make it consistent with the rest of the docs :)\n. Let's use const here, to be consistent. same as above. We could add the entry field in rollup.config.js itself. That would make this line a bit tidier:\njs\n// rollup.config.js\nexport default {\n  entry: \"es/index.js\",\n  // ..\n}. yeah, I guess it's more a personal preference. You're right that it should point to src/ \ud83d\udc4d  We'll wait for @rt2zz's call on wether we prefer the entry passed via the config or as cli argument.. Do we actually need the prepare script? The docs says that this will run both before publishing and npm install. The latter seems to be not necessary because the package already includes the compiled lib/ folder.. Oh I see, I didn't know about that use case. Makes sense \ud83d\udc4d . ",
    "authentik8": "Very true, well spotted! \nThanks for getting back to me, docs look fine now. Love the library! \n. ",
    "corbt": "Big +1 on migrations, as I mentioned earlier. I'm about to do a backwards-incompatible restructuring of my app state and it's pretty painful as things are right now.\n. I don't think semver would help with migration versions. Monotonically increasing integers would actually work just fine, the only important thing is that there's a stable total ordering.\nI may not be totally understanding the implementation, but does each reducer inside a migration only get access to its own state? How do you deal with combining/splitting two reducers? For example, I just migrated data in my app from Recordings nested inside Albums to having separate reducers for both. Would this migration strategy support that?\nWhat if you tweaked the API to just look like:\njs\nconst migrationManifest = {\n  0.1: (state) => ({...state, staleReducer: undefined} ),\n  0.2: // ...\n}\nI think it's ok if the implementation is slightly less performant, the migration code should only be called once per device in normal cases.\nAlso good to know that the migrations may be called multiple times, but I'm curious why that's the case? Might be worth using multiSet in the AsyncStorage implementation which, while probably not totally transactional, makes it likely that the data will stay in sync.\n. ",
    "danfo": "Migrations, nice one! I like the API.\nMy approach until now was to have a schema version as the top-level state key, and have my app deal with noticing existing data which needs to be migrated. I tried replacing this in my project today \ud83d\udc4d \nWhen you have state and no known version number, that is certainly a challenge... The current behaviour is running all migrations, even against initialState... This is good for existing users, but seems it will break unless initialState remains in a pre-migrated state.\nSince I want initialState to be the latest state shape, I guess I want it to just set the latest version number and move on if there is no persisted state. I'll try that for myself now and see how it goes.\n. hmm... well, here's my humble preloader:\njs\nfunction setInitialStateMigrationVersionPreloader({ storage }) {\n  return new Promise((resolve, reject) => {\n    storage.getItem(storageKey).then((persistedState) => {\n      if (persistedState === null) {\n        storage.setItem(versionKey, latestVersionKey).then(resolve).catch(reject);\n      } else {\n        resolve();\n      }\n    }).catch(reject);\n  });\n}\nNew users with no persisted state and no migration version: No migrations run\nExisting users with persisted state and no migration version: All migrations run\n(no migrations run for new users because I'm ensuring they don't end up having persisted state and no migration version)\nSo end behaviour seems to be ok, but I wonder how we could get this into the lib. I wonder how it would work if we checked migration version on rehydrate transform, and set migration version when state is persisted. Maybe having migration version in redux state would allow something like that.\n. ",
    "mochacoder": "Awesome, I hadn't got around to implementing it myself, thanks for knocking this out.\n. ",
    "willks": "Thanks for that - I had an issue with deps which I fixed. Integrated redux-persist and now happily restoring state to my reducers.\nThanks!!\n. ",
    "deju": "And i do not want to change the data struct.\n. @rt2zz \nreducers:\nimport userReducer from './user';\nmodule.exports = combineReducers({\n    userStore: userReducer,\n})\nin './user.js' file:\nconst initialState = {\n    duty: null,\n    isLoggedIn: false,\n    user: {'name': 'guest'},\n    loginStatus: null,\n    loginError: null,\n};\nThat is the initialState.\nI run the app, close it, and restart the app. I got the value of user is \"{\"name\":\"guest\"}\" in console. It is just a string, not a object.\n. I write the code:    \ncase REHYDRATE:\n            // restore from localstorage\n            let userStore = action.payload.userStore;\n           let user = action.payload.userStore.user;\n        if(_.isString(user)){\n            user = JSON.parse(action.payload.userStore.user);\n        }\n        //console.log(action);\n        return {\n            ...state,\n            duty: userStore.duty,\n            isLoggedIn: userStore.isLoggedIn,\n            user: user,\n        }\n        break;\nIt is ok now. Thx. @rt2zz \n. @rt2zz No, i was not used redux-persist-crosstab. I think that is a plugin for browser. But my app is a react-native app. I used the code above and everything is fine. Thank you.  :)\n. Close the issue. I will let you know if i got any problems.\n. ",
    "Tiagojdferreira": "That seems to partially solve the problem, but now I don't seem to persist the data in between sessions. It now works for mobile (ios Simulator), but not in browser. (creates new empty state).\n. Thanks for your quick reaction. I will try this out this weekend.\n. ",
    "Kim-Andersen": "@rt2zz Thanks for adding this. Finally got to apply your solution, and it works like a charm.\n. ",
    "ratson": "Because the author avoided import _ from 'lodash, by importing used functions directly, e.g. import isPlainObject from 'lodash/isPlainObject', see https://github.com/reactjs/redux/blob/master/src/createStore.js\n. ",
    "jorilallo": "Thanks for making the change, it has a pretty significant effect on the bundle size. Would be nice to get a release as lib isn't part of the repo.\n. ",
    "JonesN3": "Don't know if this is best practice but: converting a date to string with built in methods, and then creating a new Date with that string, will give you the correct date object. So one could just store the date as a string, and create a new date object when used. Was useful in my case, since I had a lot of date object operations.\nDate now = new Date(Date.now())\nconst dateString = now.toString()\nDate then = new Date(dateString)\n. ",
    "digitalmaster": "I think in principle i agree that what goes in should be what comes back out... or at least that's the expectation. Cases where this is not true should be clearly highlighted (i like the idea of a dev warning here).\nI'm new to redux persist \ud83d\ude48 .. is there some example code you could point me to that shows how to transform strings back to dates on rehydrate?\nUpdate:\nJust took care of the transform in my events reducer. Not bad at all :)\n...\ncase REHYDRATE: {\n        return action.payload.events.map((event) => {\n            return Object.assign({}, event, {\n                startTime: new Date(event.startTime),\n                endTime: new Date(event.endTime)\n            });\n        });\n....\nUpdate II:\nThe above workaround quickly becomes difficult to maintain once your app grows and you have more reducers with dates :(\nEnded up just writing a simple transform:\n```\nconst dateTransform = createTransform(null, (outboundState) => {\n    return traverse(outboundState).map((val) => {\n        if (Time.isISOStringDate(val)) {\n            return new Date(val);\n        }\n    return val;\n});\n\n});\n```\npersistStore(Store, {\n    storage: AsyncStorage,\n    transforms: [dateTransform]\n});. ",
    "you-fail-me": "Hey, @rt2zz , I would like to ask you a bit more about creating a transform for dates. Won't transit-js cause troubles if my code expects plain js objects? AFAIK it returns maps instead. I think having proper dates is pretty important and I'm a bit surprised that there's no built-in solution or a 'default' solution from community yet. Don't mind implementing but need some advice\nUPD: in case, if it might help somebody - looks like using https://www.npmjs.com/package/json-literal in transform solves the issue for now. ",
    "vcarel": "@digitalmaster got the point. However instead of traversing object tree, one may just json-serialize and deserialize objects using replacer and reviver to handle dates.\n\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#Parameters\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse#Syntax\n\nHere the \"codec\":\n```\nconst replacer = (key, value) => date instanceof Date ? value.toISOString() : value\nconst reviver = (key, value) =>\n  (typeof value === 'string' && value.match(/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}/))\n    ? new Date(value)\n    : value\nexport const encode = toDeshydrate => JSON.stringify(toDeshydrate, replacer)\nexport const decode = toRehydrate => JSON.parse(toRehydrate, reviver)\n```\nAnd how to use it:\nconst persistConfig = {\n  key: 'myKey',\n  transforms: [createTransform(encode, decode)]\n}. ",
    "fungilation": "Afaik it's an object store. Like mongo but with a nicer querying interface.\nAnd obviously go beyond just key value store. So I'm thinking this\nintegration would be useful as a drop in for getting the data in initially,\nwhile allowing for a powerful querying interface via Realm for alternate\nviews not directly backed by redux.\nOn Sat, Apr 30, 2016 at 10:13 AM Zack Story notifications@github.com\nwrote:\n\nThat would be great. I have not used realm but the project looks exciting.\nDoes realm require schemas are defined up front?\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly or view it on GitHub\nhttps://github.com/rt2zz/redux-persist/issues/83#issuecomment-215979653\n. Interesting. If no one tackle this in a month or 3 I will, when I think my app will need a secondary local offline storage other than Firebase I'm using currently (which does offline but it's a blackbox regarding the persistence, and I want redux fulltext search capability at some point). Sorry no, my priorities have changed. For those interested in similar use case, I'll likely go with Apollo with https://github.com/apollographql/apollo-cache-persist instead. (which shares code with redux-persist according to their README?). \n",
    "liubiggun": "Are there any new developments about integration with realm?\n. ",
    "JulianKingman": "FYI - Realm requires a schema, so you'd have to know the data structures that you want to persist.. I'm also interested in performance considerations. I am retrieving tasks from the server (up to 10,000 at once), storing them in redux, and then persisting. I'm assuming that the persistence is the slowest part, it takes about 2 minutes to fully load and persist the data. Would changing the storage driver to Realm fix this?. That's cool, good work :)\nI still have the issue with iOS, though.\nPerhaps someone can clarify something for me, which I think may be the root of the problem. It looks here as though only the immediate substate or a redux store is diffed and updated or not, is that correct? If yes, then I believe that means that this:\njavascript\n// Scenario A\n// Store1 === [...manyThings], Store2 === [...manyThings], Store3 === [...manyThings],\npersistStore(Store1);\npersistStore(Store2);\npersistStore(Store3);\nWould perform magnitudes better than this:\njavascript\n// Scenario B\n// Store === {Collection1: [...manyThings],  Collection2: [...manyThings], Collection3: \n// Collection1 === Store1, etc...\n[...manyThings]}\npersistStore(Store)\nIs that correct?\nTo explain, in Scenario A, my collections are separated into a store for each. As documents come flooding in to Store1, it's checking each individual document (...manyThings) in the collection to see if it already exists and was downloaded. Documents are relatively small, so no problem.\nIn Scenario B, as documents are flooding into Store, Collection1 is diff'd against the new incoming Collection1, which won't match because new documents are still coming in (even though documents within do match). As a result, the persistor persists the collection as much as possible until the document collections finally match. In my current use-case, this is around 10,000 records.. So if i create my reducers like this:\njavascript\nconst reducers = (state  = {}, action) => {\n  switch (action.type) {\n    case 'ADDED':\n    ....\n  }\n}\nDoes that state = {} default declaration count as initializing the state? I'm wondering if that's why my store is not rehydrating.. I ended up manually implementing the reducer, and now it works fine, more info here: https://github.com/rt2zz/redux-persist/issues/244#issuecomment-270655356. Good call on the logs, here's what I get from the log, what should I be looking for?\n````bash\n  redux-persist/autoRehydrate: 1 actions were fired before rehydration completed. This can be a symptom of a race\n  condition where the rehydrate action may overwrite the previously affected state. Consider running these actions\n  after rehydration:\n\n. Re: modifying state, does something like a lodash `_.update` function qualify?. BTW, no actions are listed after the above message from redux-persist.. I 'fixed' this by adding my own reducer. Still unsure why it didn't work. Should I close this? The issue still exists...javascript\n  case 'persist/REHYDRATE':\n      // only do this if offline\n      if(typeof Meteor.ddp === undefined || Meteor.ddp.status === \"disconnected\"){\n        return action.payload;\n      }\n`. I was having a problem where I was using the callback to tell my app whether the state had been rehydrated, but if the script ran again and it was already rehydrated (like in the background), it wouldn't fire when I opened it again. It's not perfect, but I set up an interval that checks the persister state and resolves when it's rehydrated, it works pretty well:javascript\nconst awaitPersister = () =>\n  new Promise((resolve) => {\n    let n = 0;\n    const checkState = setInterval(() => {\n      const cacheLoaded = persister.getState().bootstrapped;\n      if (cacheLoaded) {\n        clearInterval(checkState);\n        resolve(true);\n      } else {\n        n += 1;\n        // if 100 seconds have elapsed, something's wrong\n        if (n > 10 * 100) {\n          Alerts.alert('Its taking too darn long');\n          clearInterval(checkState);\n          resolve(false);\n        }\n      }\n    }, 100);\n  });\n```. I like in persistReducer, since other config goes in there as well. However, I think it would be handy to pass the persist status to the persistStore callback (i.e. error or success), that way we can handle timeout cases. I like a default time, because if it's taking too long, something is likely wrong and the dev should know about it.. @majidln any luck with this issue? I'm having some data inconsistencies that I think relate to this issue.. @hammadzz I don't remember exactly how I solved it, but I think it may have been a race condition. Make sure you set up a listener for when state is rehydrated before updating allowing app interactions to update state. Looks like my loading screen navigates to the app after it's rehydrated, but there are other ways to do it.. ",
    "kenma9123": "any progress?. I have the same problem like @jorge627 anyone?. @johnwayner so no way around this rather than reducing the size/data of a key or the reducer?. @robwalkerco wow great idea. I tried it and it works fine. You should create a repo for this and let it grow.. oh okay then, is there a way to hide it on the dev tools at least? Everytime you open the app that's the first thing you see instead of the other reducers and actions. Even just collapse it on load.. I guess there's no such option. I'm using this dock monitor https://github.com/gaearon/redux-devtools-dock-monitor . Every time it loads the app they getting auto expanded at least on that action only. Because on other normal actions they were collapsed. Just this persist/PERSIST action. Could you share your dev tools configuration at least. Anyway thanks for the help. ",
    "Selman555": "Just passing by from google, I really hope there will be a way to ditch AsyncStorage.\nAs far as my understanding goes, a \"universal\" scheme would have to exist. Otherwise there will have to be a lot of cleaning going on to keep things tidy and small in size.\nThis accepted answer convinced me to keep using redux-persist. ",
    "jeroenbourgois": "Nevermind, I was being stupid, the package does everything \ud83d\udc6f \n. Yes it is working! Thank you so much for this package :D\n. ",
    "jamesone": "Great! Would I pass down the store as well as the persistor object to my provider? So basically the persistor object would only persist the keys you put in the whitelist array? @rt2zz \n<Provider store={store} persistor={persistor}>\n. One more thing, Is it possible to pass a persisted store down to my child the  <Provider component?\nThe following store={store} is just parsing down my default reducer, instead of the persisted one? \n<Provider persistor={persistor} store={store}>\n    <Routes store={store} /> // This will parse down my default store\n  </Provider>\n. ",
    "felipemartim": "Thanks for the quick reply!\nI believe that short term workaround wouldn't work for me, due to the fact that my initial state is an Immutable Record. But I'll give it a try later. For now, I'm just returning the initial state with a \"hasSignedOut\" flag set to true, so it will be different than the initial state.\nAnd I also believe setting lastState to the restoredState would solve the issue. :+1: \n. @gullitmiranda, as I'm using Immutable.js Records, this equality check returns true. However, after upgrading to 3.1.0, the issue got solved for me, so I'm closing this.\nThanks @rt2zz !\n. ",
    "gullitmiranda": "the comparison of objects in javascript does not work very well. Thus the state[key] == reducedState[key] (in /src/autoRehydrate.js#L29) will always return false if the content is an object.\ne.g.:\n``` bash\n$ node --version\nv6.0.0\n$ node\n\na = {\"_status\":null,\"data\":null,\"entities\":{},\"model\":{},\"errors\":null,\"error\":null}\n{ _status: null,\n  data: null,\n  entities: {},\n  model: {},\n  errors: null,\n  error: null }\nb = {\"_status\":null,\"data\":null,\"entities\":{},\"model\":{},\"errors\":null,\"error\":null}\n{ _status: null,\n  data: null,\n  entities: {},\n  model: {},\n  errors: null,\n  error: null }\na == b\nfalse\na !== b\ntrue\n```\n. \n",
    "egeriis": "@rt2zz Sounds great. Thank you for being so swift :)\n. Btw., there's no 3.0.3 tag :)\n. @jburich I am not. 3.0.2. Will try to pull 3.0.3 tomorrow and see if it has fixed my issue :)\n. @rt2zz Btw., definitely not state mutation, as I am using ImmutableJS to handle state changes\u2014to ensure that there are no mutations.\nI've experienced that { ... state } does not do a deep clone.\n. Works with 3.1.1. Great!\n. ",
    "jburich": "@egeriis Are you on version 3.0.3? I was having the same problem with very very similiar code and the problem was in createPresistor endState was pulling from a local state variable instead of store.getState() which causes the data to be stale. I just upgraded to 3.0.3 and that fixed the problem.\n. ",
    "lory-lu": "Cannot read property 'asyncSessionStorage' of undefined\n. Cannot find module \"redux-persist/storages\". ",
    "h8rry": "Check these out first https://github.com/rt2zz/redux-persist/blob/master/docs/recipes.md :)\n. ",
    "wiiiim": "Thanks for clarifying. Does it dispatch a REHYDRATE only once (after the persistStore call)? The listener that continuously saves, does it dispatch actions too?\n. ",
    "incleaf": "My reducer is from redux example. and yeah it was my root reducer.\n. ",
    "rahmanusta": "I'm not working on that project right now, sorry.. ",
    "fabarea": "I am also a bit lost, I have to admit. I have implemented as pointed out the \"simplest usage\". But then what? My use case: I want to re-populate a form with values a user may have filled out. I use redux-form as form library where an example is given to set initial values. Well, it might be very specific to redux-form, but I try to retrieve persisted value from the store without success so far.\n. ",
    "Anthonyzou": "I have this but it doesnt work at all\n``` javascript\nimport { createStore, applyMiddleware, compose} from 'redux';\nimport { connect, Provider } from 'react-redux';\nimport reducers from './reducers';\n// create global store...\nimport thunkMiddleware from 'redux-thunk';\nimport {persistStore, autoRehydrate} from 'redux-persist'\nconst middleware = [thunkMiddleware, autoRehydrate() ];\nlet store = compose(\n  applyMiddleware(...middleware)\n)(createStore)(reducers);\npersistStore(store, {storage: AsyncStorage})\n```\n. @rt2zz Thanks! I'm pretty new to redux. That makes more sense now.\n. ",
    "harshithjv": "@rt2zz I tried your suggestion. Its messing up react-router, i.e, if I click any other link it will redirect to first URL page has been loaded. \nE.g.: Loaded react app at '/' then clicking any other page then the page redirects to same page. If in new browser session, any other page is loaded, other than '/', page then that page gets redirected to.\n. Fixed the problem. I am using react-router-redux npm module and so I had to set routing key as blacklist like below:\npersistStore(store, {blacklist: ['routing']});\nThe key was storing URL slug and so was creating problem.\n. ",
    "sealskej": "You can find fully working example here.. ",
    "lamenramen": "Yes, the documentation is too general and not accessible to mere mortals. ",
    "MyTotoro": "Personally - when I first started using this, I was still new to the overall react/react-native/redux ecosystem. I knew the general terms but very specific buzzwords were being thrown around like enhancer vs middleware etc\nI'm slowly starting to understand more as I spend more time looking into things - but that's coming from a mixture of googling / stack overflow etc\nFrom my experience: whenever someone draws a diagram with arrows labeling information flow / actions (not in the redux sense of the word). The most helpful Redux explanations for me came from short youtube videos that explained the information flow and showed specific snippets of code.. ",
    "AienTech": "Hi,\nI've setup the configurations as mentioned in Basic Usage, but there's a thing that makes me confused.\nI used to get the initialState from localStorage with this example code:\nconst initialState = {\n    cart: localStorage.getValue(\"key\") ? localStorage.getValue(\"key\") : []\n};\nso, what should be changed now?\nthis is in one my redux modules which I separate from configs. ",
    "Andarist": "Im using quite custom setup as I wanted to get the initial state synchronously\njs\npersistStore(store, {\n    storage: {\n        getItem: (key, cb) => cb(null, localStorage.getItem(key)),\n        setItem: (key, item) => localStorage.setItem(key, item),\n        getAllKeys: cb => cb(null, Object.keys(localStorage)),\n    },\n})\nand just handle the REHYDRATE action in ur reducers\nKeep in mind that this example uses window.localStorage which is not guarded and may throw in some cases, so its best to use some abstraction which is guarded. Ive written such (and planning to make a package out of it, but hadnt yet have time for this), so you can use it:\n```js\nconst testKey = 'test_storage_support'\nconst isSupported = (storage => {\n    try {\n        storage.setItem(testKey, true)\n        storage.getItem(testKey)\n        storage.removeItem(testKey)\n        return true\n    } catch (err) {\n        return false\n    }\n})(window.localStorage)\nconst memoryStorage = Object.defineProperties(\n    {},\n    {\n        getItem: {\n            value: key => memoryStorage[key] || null,\n        },\n        setItem: {\n            value: (key, value) => {\n                try {\n                    memoryStorage[key] = String(value)\n                } catch (err) {} // eslint-disable-line no-empty\n            },\n        },\n        removeItem: {\n            value: key => {\n                delete memoryStorage[key]\n            },\n        },\n        clear: {\n            value: () => {\n                Object.keys(memoryStorage).forEach(memoryStorage.removeItem)\n            },\n        },\n        key: {\n            value: index => Object.keys(memoryStorage)[index] || null,\n        },\n        length: {\n            get() {\n                return Object.keys(memoryStorage).length\n            },\n        },\n    },\n)\nexport default (isSupported ? window.localStorage : memoryStorage)\n``. what do u have in mind exactly - what variant should we incorporate? I think for theredux-persistfallbacking to noops is just fine. Hm, yeah I've tried to do exactly the same in redux-saga/redux-saga for us, as the same thing got reported but while guarding I've noticed that [this](https://github.com/redux-saga/redux-saga/blob/ab5cd83f8f006c02136061afcbb91b0d270e5bbb/dist/redux-saga.js#L2354-L2532) was added to the dist file, just becauseprocess` alone was referenced in the code.\nTruth to be told I have no idea what to do about this issue for non-webpack/rollup users. You can also check redux's issue about kinda same thing - https://github.com/reactjs/redux/issues/2244 , where process.env.NODE_ENV was cached for a brief moment - not only adding process polyfill but also preventing dead code elimination, and they had to revert the change.\nIt's also totally suprising that such, one would think, irrelevant change causes all of this. This auto-behaviour should be documented better.\nWhat kind of distribution caused problems for u? In general I think just distributing dist files shouldnt be a problem as you are the creator of those and therefore using a webpack to do the work. For me its just other bundler (Aurelia's one) which is causing a problem as users are trying to compile source code by themselves.. I could provide a PR, but probably not in this week as Im leaving for the weekend and I guess I wont have too much time. \nCould u point me to the origina issue/report which caused u to guard the lib against this? Maybe this would provide some additional info. \nAlso any ideas how to tackle this for other bundlers would be appreciated very much :P. @rt2zz thanks for fixing, sorry I couldnt find time to help you out soon enough. I rather would like to listen for REHYDRATE but dispatch (could be implicitly) it conditionally. If possible I would like to keep createStore process sync, as its easier to instantiate other things without wrapping in promises etc.. Thanks for the help, I think I understand now more. I'l look later if there is a place I could add such example in the docs. I've also seen a TODO comment in the code about need to get rid of skipRestore. Should that be done at the same time when I get into it? I mean - I can get rid of it if you want.\nAlthough I seriously consider writing some simple tiny lib for doing all of this myself as my needs are really basic and your lib is quite a robust one. Great work on it anyway \ud83d\udc4f Just feeling a little bit that its an overkill for my use case. Will live in our production env for quite some time though as for sure such refactor is not a pressing issue for us ;). so here I am again :P I wanted to add the snippet as docs example, but now I've realised that it still doesnt cover my desired use case. Basically I would like to skip conditionally dispatching REHYDRATE action. You example focuses on conditional providing of initialState\nany way to achieve this?. My scenario is to read the condition from the query string, which means in general any initial source. I would prefer not to save this info in the store itself to skip rehydration in REHYDRATE's branches of reducer to keep this part of the app agnostic from the fact that rehydration might not happen.\nOption number 1 seems reasonable, however quite a duplication of already implemented stuff, just to do this 1 thing.. I went with first option, but it rly feels like quite a duplication of code. The neat thing is I could rewrite it to sync handling as my target is web only, but it will ofc drive away from original implementation in time which is undesired. \nNot worth documenting I think, but will post here my snippet, maybe somebody will find it useful.\n```javascript\nimport { createPersistor, getStoredState } from 'redux-persist'\nimport { REHYDRATE } from 'redux-persist/constants'\nconst config  = ... // app-specific config\nconst shouldRestore = ... // app-specific logic\nexport default function persistStore(store) {\n    const persistor = createPersistor(store, config)\n    persistor.pause()\nif (shouldRestore) {\n    getStoredState(config, (err, restoredState) => {\n        store.dispatch({\n            type: REHYDRATE,\n            payload: restoredState,\n        })\n        persistor.resume()\n    })\n} else {\n    persistor.resume()\n}\n\nreturn persistor\n\n}\n``. @FilipMessa It's as simple as just handlingREHYDRATEaction in ur reducer which you can import from'redux-persist/constants'. Ive added a single comment, but truth to be told im not that much involved in the project and Im not making any calls on new features etc, cannot review this properly as Im lacking the context for the feature and the actual codebase.. +1 for function over regexp. hm, no harm in such a check i think - forbabel` users it will still trigger polyfill (i think), but its tiny, so it is a minor issue and at the same time it should allow usage without custom setups for non-babel users. Oh, didnt notice the other issue. Sorry about that.\nProblem with babel (I think) that it implicitly polyfill some stuff (like process, global, setImmediate) and include core-js shims. Have no idea if this is somehow configurable, would like to explore this, but dont have time right now. \nGonna provide a PR for this.. how ember tool chain looks like? im completely unfamiliar with it, so cannot provide any good insight \n\nWhat do you think about getting rid of setImmediate from the asyncLocalStorage entirely? It was originally added to make the api actually async, but I am beginning to think this is irrelevant and moreover it just adds a few bytes for no real gain.\n\nDunno rly, my usage of the lib is pretty basic and only for web, so also - not familiar that much with the codebase and goals to make any opinions on this. No problem, I've noticed this issue by tweaking my build setup in a work project and ive observed that bunch of libraries cause polyfills for setImmediate, process, global etc to get included in the final build, so I've filed issues and helped with few PRs. Even react had this 'issue'.\nThe whole thing is caused by some implicit auto-polyfilling behaviour of webpack's. At the same time rollup and like you have pointed out also the ember tool chain dont cause this.\nThere is no middleground here at the moment I think, as by guarding against such references we cause polyfills for webpack's users and by not guarding against them we prevent usages outside of webpack. . pretty much yes, webpack2 and rollup will go to es/constants, while tools like webpack1 will get contents of lib/constants\nive tried it already in redux-saga package and it worked great, was trying to figure out how to do this correctly for weeks and suddenly somebody popped up and pointed me into right direction :). Damn! i was preparing this PR before sleep and I forgot to add the most important thing - new files ;) gonna update in a minute. Also if u are using webpack2beta, please upgrade. It had bug regarding this\nOn Fri, 28 Apr 2017 at 06:53, Zack Story notifications@github.com wrote:\n\ncan you give 4.7.1 a shot \ud83d\udc4d\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/rt2zz/redux-persist/issues/339#issuecomment-297906698,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AJWMkp7cd5q_u_duwPBZLYm-PUltmQJGks5r0XDTgaJpZM4NK_8y\n.\n. @marvinhagemeister ive seen u have also put \"browser\": \"dist/redux-persist.min.js\", in ur PR, should I do it too? im not familiar with the issue it was fixing so i aint sure\n\n. Not a problem, was kinda copy pasting most of it as I was converting lately some other projects to the rollup too . Seems like a reasonable change anyway, but the reason why serializer throws should be investigated further.\nMerging this in, thanks!. Could u provide an example when complete is called more than once? Your fix might work by accident for sync storages (like localStorage), but the library is supposed to work with async ones too - so by the time you call complete the keys wont be restored yet.. good point on the quota exceeded, although only valid for setItem?\nso do u plan to default to sync web storages + keeping the storage callback API so async ones can get plugged in?. At the moment I supply own localStorage wrapper (similar to the one in the PR) with fallback to self-written memoryStorage (with exact localStorage API). Gonna report back If I get any error reports from sentry regarding this - I've wrapped only setItem with try/catch.. thanks, fixed :). @rt2zz I've recently published this little lib if you'd like to reuse some logic, i.e. storage availability test. Thanks!. module key alone is not at fault. You would have to share the repository with reproduced issue - with ur webpack config and redux-persist versions locked in there, so we could investigate the matter.. This code is completely valid, could u specify in what circumstances (possibly when using with what bundler) do u have issues with this?. thanks for reporting back :). What's the exact issue with setImmediate in IE?. Could u change src/utils/setImmediate.js (in reality u need to change appropriate file which is in lib/ or es/ directory - depending on which bundler do you use) to:\njs\nconst setImmediate = typeof global !== 'undefined' && typeof global.setImmediate !== 'undefined'\n  ? (fn, ms) => global.setImmediate(fn, ms)\n  : (fn, ms) => setTimeout(fn, ms)\nI believe it should fix your issue, would like to get a confirmation, as I cannot check it at the moment myself. If you confirm it's fixed - we are going to incorporate it into the library.. Thanks! Cannot publish it though yet, needs to be done by @rt2zz . @jalkoby just released with a fix, please check it out :). The only (known to me) possibility to have those 'cherry-picked' modules is to create proxy directories with package.json - like redux-persist had in the past.\nI have wanted (and still want to) create a package to automate creation of those packages before publication or build steps. Just hadn't found enough time for this yet. I will try to sit down next weekend and create MVP for this. \nYou can also ofc reexport your constants in the main entry point (src/index.js) so one could just do import { constants } from 'redux-persist'.\nYou could also consider using rollup to build ur package as flat bundle.. @rt2zz could u elaborate on what proxy modules you'd like to have exactly? I might provide a PR for this.. But are there any particular reasons why they need a proxy module and why having them just reexported from the main entry point is problematic?\nMaybe the react one as its optional in a sense (maybe the same thing applies to storage too) deserves a separate entry, but Im not sure about the others (though im not familiar with redux-persist@5). When it comes to separate entries there are also 2 options:\n- proxy modules\n- scoped packages. > @Andarist with scoped packages, we would need to publish separate npm modules for each correct?\nCorrect.\n\nin the case of integration/react to avoid issues with the \"undeclared\" dependency of react. Of course even having the undeclared dependency at all is bad smell, but I hate to publish a separate module for what is an extremely common use case.\n\nYeah, this is unfortunately a downside of using proxy modules - deps/peerDeps are a \"headache\" but as you have mentioned this is really not that much of an issue as this is a common use case AND you make it quite explicit when you force people to use redux-persist/integration/react (although personally I would prefer to have it shortened to redux-persist/react \ud83d\ude09 )\n\nin the case of stateReconciler and storage, it is in order to avoid possible module bloat in the case that the consumer does not have tree shaking.\n\nThere are cases when tree-shakers (mainly webpack, rollup has way better algo) can get penalized by this approach. Personally I wouldn't really care that much about users without tree-shaking. At this moment webpack@4 is already in beta and tree-shaking is here since webpack@2. Can't worry about all releases all life, better to just support newer versions and push people into migrating - that benefits whole ecosystem. That's my personal view though \ud83d\ude05 \n\nunder what circumstances might tree shaking fail? etc.\n\nThis is really hard to demonstrate, especially as it might differ between tools and their versions. I've stumbled once on what I thought was trivially tree-shaken, but it wasn't. You can checkout the issue and simple sample repo here. \nYou can also read this thread if you are interested in seeing what prevents tree-shaking (it's not meant as complete list or anything, but it demonstrates some additional issues).\nMy rule of thumb nowadays is to distribute flat bundles with rollup and let tree-shakers do their job. Flat bundles generally result also in less bytes being included in the application bundles, because things like babel helpers are shared within flat bundle boundary, it's easier to tree shake them, it's easier to minify them and possibly gzip too. Situation will get better (to some extent) when webpack@4 gets released because it will try to scope-hoist (flat bundle is scope hoisted bundle, so its generally the very same thing) in production by default. I suspect though that it might still be better to distribute flat bundles all along, even if only as some kind of pre-done scope hoisting - if we do when distributing the library, then bundlers won't have to do that when compiling (so it may be seen as some form of \"caching\").\nThings are getting more complicated if we want to distribute flat-bundles AND proxy modules. Complexity may vary if proxy modules are completely separate thing from the main entry or are they sharing some code between each other. This can be configured though, especially with hot new experimentalCodeSplitting option of rollup. Can try to achieve this with redux-persist if you want.\n\nWhat do you recommend @Andarist ?\n\nPretty much what I've described before - flat bundling all the things + trying to leverage experimentalCodeSplitting to create proxy modules. I'll try to cook something up and we'll be able to discuss further under the PR. rollup has released new version with the needed bug fix. Gonna play with this PR further in following days, @rt2zz do you have any comments about what was being done so far (or about what was proposed in the comments)?. > How does this look if we want to provide a umd build? The umd bundle will have a few extra bytes from the state reconcilers which I think is acceptable. Are there any other concerns?\nIt depends what it needs to have, i suppose no react & storage in there? Or should storage be available in umd?\n\nHow do we get flow types to work? I am pretty sure this can be done by doing a build without transform-flow-strip-types, and writing that to redux-persist.flow.js.\n\nThat's the only thing I need to experiment with - ain't sure if rollup won't chuck when parsing type nodes.\n\nbecause of the breaking changes, will definitely want to land this along-side other breaking changes that I am mulling over around how we store _persist, and async transforms.\n\ndefinitely, this is a breaking change. Ok, I got everything to work. Just one thing is not updated - typescript typings and unfortunately I won't be able to update them right now. Updating them shouldn't take much time though.\nThis is imho ready for final review and ready to be merged. If you have any questions regarding what I've done - just ask :). Hi! Thanks for the PR but it seems that this is not what we are looking for. From what I see this approach doesn't account for multiple module formats (which proposed proxy modules approach is all about).\nThe goal is to have a single nested \"submodule\" (i.e. redux-persist/storage) resolved to appropriate files, which might be:\n- redux-persist/lib/storage/index.js in node.js, older bundlers like webpack@1 etc\n- redux-persist/es/storage/index.js in modern bundlers like webpack@2+ or rollup. Not sure what do you mean, could you rephrase?. the entry point should be src/index.js, i can add this into the config, but personally prefer having those as input/output options in the command line, can be easily copied and built into somewhere else, dont care about this too much though, so @rt2zz's call :P. if u pass some option in the config, it for sure shouldnt be named like this _createFragmentedKey which indicates something private. According to http://blog.npmjs.org/post/161081169345/v500\n\nGit dependencies with prepare scripts will now have their devDependencies installed, and their prepare script executed as if under npm pack.\n\nIts important as entry points to the lib are .gitignored, so if somebody forks and want to use its fork from git its rly inconvenient now (before npm5 running prepare in such case), because he needs to:\n- probably alter entry points (main)\n- probably unignore es/lib \n- probably run build by himself and push generated files to the git. returned function returns global.setImmediate instead of calling it with provided arguments ;). defaultFragmentKeyToReducerKey and defaultCreateFragmentedKey are the same and also they are just identity function \nconst identity = x => x. you could just make a bundle with redux as external and just check this size locally without network requests. as flat bundling will be a breaking change (no more reaching out to internal directory structure - which is even proposed in the main READMEs on several occasions) I'd go with simple redux-persist/react proxy module, I've attempted to keep both redux-persist/integration/react and redux-persist/react here but there is really no point in that. this is matching first draft of the configs - the ones that are commented out now. im not entirely sure what's proper way of supporting typings after going flat, \"typings\" from flow-copy will stop to work properly, I'd like to explore gen-flow-files tool (its flow builtin, but ive never used it)\nTS will require some work, but at least its a sideway thing (have to be written manually anyway - so it doesnt really matter that much, im concerned about flow because I'd like to generate them automatically and aint sure yet how to do it in a new setup). this part is very much working, although not yet supporting storage and .native.js (they can be easily added, I just havent yet got to it). this version is interesting though, because it uses code splitting feature - this way babel helpers can be deduped between redux-persist, redux-persist/storage and redux-persist/react flat bundles. I've found a bug in rollup while experimenting with this though - https://github.com/rollup/rollup/issues/1943\nIt would also require restructuring redux-persist src directory structure slightly, because rollup maps original input filenames to output names (not including directories) and we need stable mapping between those. from what I understand it's what we have established in the other issue, correct me if im wrong. was unused. I plan to add #__PURE__ annotations with my plugin - https://github.com/Andarist/babel-plugin-annotate-pure-calls . So unused version should get dropped. The goal for me here was to provide a single redux-persist/storage entry. unfortunately aint sure, need to play with those things first . At the moment with this:\njs\ninput: ['src/index.js', 'src/integration/react.js', 'src/storage/index.js']\nIt produces 4 files:\n- index.js (what will be in main/module)\n- index2.js (this should actually be storage for readability, that's why we need to restructure a little bit, so input file names get unique names)\n- react.js \n- chunk1.js - here we have magically deduped babel helpers :). dont think so, I consider this new setup with code-splitting the most \"optimized\". actually not, i thought at first they would, but with code splitting on we do not have control over output file names so we need to output files targeting cjs and esm into 2 separate directories to avoid the file path clash. README gets uploaded to npm by default. ",
    "stevematdavies": "Sorry, but I am not grasping the basics here, its far too verbose, and there are not really any plain and simple examples, they are all convoluted, or assume far too much.\nI'm trying to set this up with my react Redux app to save a simple 'loggedIn' state flag, so I can persist it on page refreshes. However, having spent three hours trying to actually apply the examples in this documentation, I still haven't got anything to work at all LocalStorage is always empty, any getItem returns null.\nIt would be really nice for a change that Redux complimentary modules such as this do not follow with the tradition of overly elaborate and poorly written documentation, from which Redux itself badly suffers\nI've been writing React / Redux  apps for quite a while, now wishing to use storage like this, I simply cannot grasp the basis.  Could some kind soul write some documentation or examples for us mere mortals??\nTaking that the persistedState is an initialState with all flags: my store looks thus: (ES6)\n```\nconst store = createStore(\n       ApplicationReducer,\n       persistedState,\n       compose(\n            applyMiddleware(thunk),\n            autoRehydrate(),\n            window.REDUX_DEVTOOLS_EXTENSION && window.REDUX_DEVTOOLS_EXTENSION()\n       )\n    );\npersistStore(store);\nexport const configureStore =  () => store\n```\nThis seems to have absolutely no effect. Looking in Chrome-dev tools at the LocalStorage its blank, Even adding things to the Redux state has no effect on LocalStorage\nSo have I totally misinterpreted this library, or is there something glaringly obvious I'm missing. Plain English answers and examples are appreciated?. ",
    "csalmeida": "I think a simple setup can be summarised in a few steps:\n\nInstall redux-persist in you project.\nImport persistStore and autoRehydrate form redux-persist.\nAdd autoRehydrate to your store.\nPass your store to persistStore\nListen to the persist/REHYDRATE action on your reducer and populate state accordingly.\n\nHere's a simple example I've put together based on the steps above:\n```javascript\n/ store.js /\n// Store of the application. Reducer will go through here and update app.\nimport { applyMiddleware, createStore, compose } from \"redux\"\nimport logger from \"redux-logger\"\nimport ReduxThunk from 'redux-thunk'\nimport promise from \"redux-promise-middleware\"\nimport { persistStore, autoRehydrate } from 'redux-persist'\nimport reducer from \"./Reducers/\"\nconst middleware = applyMiddleware(promise(), ReduxThunk, logger)\n// The store now uses redux persist.\nconst store = createStore(\n  reducer,\n  { / Initial state if you wish. /  },\n  compose(middleware, autoRehydrate())\n)\n// This line makes store persistent.\npersistStore(store)\nexport default store\n```\nListening to rehydration action in a reducer.\n```javascript\n/ reducer.js /\nexport default function reducer( state=initialState, action ) {\n  switch (action.type) {\n    case \"persist/REHYDRATE\": {\n      return { ...state, ...action.payload }\n    }\n    default: {\n      return state;\n    }\n  } // Switch\n}\n```\nIf you still find it difficult to understand, Clark Sanford wrote a tutorial on Medium on how to set this module up!. @aswinalapati Actually, it should work without the reducer, you can check if it's working by setting a redux logger as middleware up, it will show if the persist/REHYDRATE was dispatched. You could also run window.localStorage in your console and it will show if you have any data stored there.\nYou could setup the reducer as a way to control what parts of the store you want to be passed into localStorage as the default behaviour is to pull the whole store. You can set it up just once and reuse it as needed of course. :). ",
    "aswinalapati": "@csalmeida Should we write the rehydration action in every reducer or is there a single place?. ",
    "Wiklem": "Is it possible to get a example on redux-persist v5? Cant get it working correct. ",
    "phuna": "@Zwirc This is how I setup my store with v5, hope it helps:\n```js\nimport { createStore, compose, applyMiddleware } from 'redux';\nimport thunk from 'redux-thunk';\nimport {\n  persistStore,\n  persistCombineReducers,\n} from 'redux-persist';\nimport { AsyncStorage } from 'react-native';\nimport { composeWithDevTools } from 'redux-devtools-extension';\nimport todos from './reducers/todos';\nconst config = {\n  key: 'root',\n  storage: AsyncStorage,\n};\nconst reducers = persistCombineReducers(config, {\n  todos,\n});\nexport const configureStore = () => {\n  const store = createStore(\n    reducers,\n    compose(\n      applyMiddleware(thunk),\n      composeWithDevTools()\n    )\n  );\n  const persistor = persistStore(store);\nreturn { persistor, store };\n};\n``\nThen in yourApp.js` use store as sample code in PersistGate\n. ",
    "joelash": "I'm following the v5 example closely combined with the Redux Todo Example and I've noticed that as soon as I add the visibilityFilter reducer in and complete a todo; I get this error on next load of the app. Any thoughts? \nUnhandled Promise rejection: TypeError: In this environment the sources for assign MUST be an object.This error is a performance optimization and not spec compliant.\n. @ranggarifqi I have not found a solution, I was early in my needs to I've just ignored this for now. By chance have you seen redux-storage? It seems to solve many of the same issues.\n@Shhzdmrz thanks for the example repo; I'll take a look this week when I get a chance. ",
    "ranggarifqi": "@joelash i'm facing the same problem too\nany solution to this ?. i ended up using v4 though\nbecause of my deadline\nBefore i decided to use v4,\ni think this error came from PersistGate\ni tried to remove PersistGate and i didnt see the error. But, idk somehow it didnt rehydrate\nWell, i'll try to tweak this again if i have time.. ",
    "Shhzdmrz": "Hello guys,\nI have this example repo with react native for redux-persist v5. Please have a look on it give me your review if anything is missing or some other need to be add.\nPS: handling persisted data is new for me so in that area I need more assistance. \nThanks. @rt2zz thank you.\nI'll wait for your response once you try again and the repo that I linked in my issue please consider it for testing.. @rahkumar2 have a look on this example repo. @rahkumar2 did you tried onBeforeLift? as mentioned in this example. ",
    "thenewt15": "For anyone looking to implement v5 of redux persist, here's a detailed write-up on medium.\nhttps://medium.com/@thenewt15/the-definitive-guide-to-redux-persist-84738167975. Wow, this is a great feature and provides a solution to Issues 134 and 266.\nI'd like to elaborate on this for others...\nLet's say your state object has an auth key and that you want to persist auth.currentUser but NOT auth.isLoggingIn. \nWhat you can do is wrap your AuthReducer with the redux-persist PersistReducer, and then blacklist the isLoggingIn key.\n```\n// AuthReducer.js\nimport storage from 'redux-persist/lib/storage';\nimport { persistReducer } from 'redux-persist';\nconst INITIAL_STATE = {\n  currentUser: null,\n  isLoggingIn: false\n};\nconst AuthReducer = (state = INITIAL_STATE, action) => {\n  // reducer implementation\n};\nconst persistConfig = {\n  key: 'auth',\n  storage: storage,\n  blacklist: ['isLoggingIn']\n};\nexport default persistReducer(persistConfig, AuthReducer);\n```\n. Would using persistReducer with this config result in the exact same thing as using persistCombineReducers?\nconst persistConfig = {\n  key: 'root',\n  storage: storage,\n  stateReconciler: autoMergeLevel2\n}\nIs there a benefit to using persistCombineReducers other than its merge level?\nI'm trying to sort out why persistCombineReducers exists at all. It seems to do two things:\n1. Defaults stateReconciler to autoMergeLevel2, which you could set explicitly with persistReducer.\n2. Calls combineReducers for you. Is there a benefit to this though? People will likely already have combineReducers set up when they start implementing this library. What do they gain by passing all their reducers into persistCombineReducers rather than creating this root reducer themselves with combineReducers?. @rt2zz a follow-up question for you...\nI'm trying to finalize my data store on my current project and ultimately just trying to figure out whether I should be using autoMergeLevel2 for my top-level PersistReducer (i.e. the PersistReducer that wraps my root reducer returned from combineReducers).\nI noticed that the persistCombineReducers function does this for you (uses autoMergeLevel2), but I can't wrap my head around why this is needed. autoMergeLevel1 looks like it makes a copy of state, which should successfully notify all my container components via mapStateToProps. What additional benefit would I get by having copies made two levels deep?. @rt2zz I can add something to my PR on how merging works. I'd like to clarify a couple things about it though. Are these statements true?\n\nOnce the persisted state is retrieved from storage on app launch, redux-persist dispatches a REHYDRATE action. After the REHYDRATE action is sent to all your reducers, the merging process begins. \nThe term \"rehydrated state\" refers to the situation where you catch the REHYDRATE action in a reducer and update the state object. The state returned from this REHYDRATE case is the \"rehydrated state.\"\nThe merging process checks whether you changed the state object when the REHYDRATE action was dispatched (i.e. whether the rehydrated state is equal to the initial redux state). If it was changed, then the initial redux state is updated with this rehydrated state. If it was not changed, the initial redux state is updated with whatever was persisted (i.e. inboundState). \nredux-persist v5 introduced auto-merging, which means you no longer need to catch the REHYDRATE action within your reducers. Without catching this action, the initial redux state will simply be updated with any persisted state.\n\nOk, so regarding the two merge levels, I'm still confused about when you'd want to use autoMergeLevel2. Let's say I have a state object like this.\n{\n  auth: { currentUser: { firstName: 'Sally' }, isLoggingIn: false },\n  otherStateKey: { ... }\n}\nWith autoMergeLevel1, I've noticed that my restored redux state will include any changes I make to isLoggingIn, or even to currentUser.firstName, if I update these from the REHYDRATE action in my Auth Reducer.\ncase REHYDRATE: \n    return {\n      ...state,\n      isLoggingIn: true,\n      currentUser: { ...state.currentUser, firstName: 'Bob' }\n    };\nBecause I'm always returning a copy of state (like you always should), it doesn't matter how deep or shallow these changes go. I actually haven't been able to find a case where autoMergeLevel1 didn't pick up a change I made to state. Can you provide an example of a state change that wouldn't be detected?. thank you @levsero, I misunderstood what the merge process was trying to handle. After looking at the code, I'm seeing that its meant to handle changes to your initial redux state. So if your auth state had its initial state set like this.\nconst INITIAL_STATE = {\n  currentUser: null,\n  isLoggingIn: false,\n};\nAnd then you released a new version of your app that set it like this.\nconst INITIAL_STATE = {\n  currentUser: null,\n  isLoggingIn: false,\n  error: ''\n};\nYou'd obviously want your reconciled state object to include this new error key. But autoMergeLevel1 would cause it to not be included, because it would just override this initial state with whatever was persisted.\nautoMergeLevel2 overcomes this problem, because it would first make a copy of the initial state, and then only override the keys within the auth object that were persisted. Since 'error' wouldn't be persisted yet, it would be left alone.\n@rt2zz I played around with using both merge levels with nested and non-nested reducers. I didn't see any problems with using autoMergeLevel2 in all cases. Is there a reason this isn't the default merge level for the PersistReducer?. Thanks @rvirani1 I may move this to a blog post if it remains here getting no love. There's actually a lot I'd like to clean up with the docs, but I prefer to see outstanding PRs merged in before I submit new ones.. @rvirani1 @ScreamZ I put this on medium, with an additional writeup on the merge process. Still hoping this gets merged at some point, but in the meantime I think this will help some people.\nhttps://medium.com/@thenewt15/the-definitive-guide-to-redux-persist-84738167975. The loading prop takes either null or a component. . @kreba feel free to contribute anything you think is helpful!\nOn Tue, Dec 11, 2018 at 12:23 PM Ben Standefer notifications@github.com\nwrote:\n\nAh good catch @kreba https://github.com/kreba. Looks like that PR was\nmerged. Either of you should feel free to submit a PR for any improvements\nto these docs and I will review and merge.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/rt2zz/redux-persist/issues/933#issuecomment-446348570,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ADOHgBoQ7ctxdIMmjT-uDDXR1Be6EuuCks5u4BQrgaJpZM4Y16qH\n.\n. \n",
    "Moharu": "I also ended up using the \"getStoredState\" method that is available in the API. It was really easy to understand and use, but a mention in the docs would be useful\n. Oops, you are right, I was using v2.\nUpdating the PR :smile: \n. ",
    "MichaelDanielTom": "@sscaff1 For some reason this kept happening to me on Android too, usually whenever I upgraded React-Native. The solution was usually to nuke node_modules, so hopefully that works for you too!\nrm -rf node_modules/ && npm install\n. @rt2zz Yea :/ a ton of random stuff has been breaking when upgrading react version, although I will say that sadly redux persist seems to be the only library that fails silently for me :(\nBTW thanks for making this great library, it's definitely helped me a ton!\n. Quick question @robwalkerco, is performance in your library better, worse, or the same as vanilla redux-persist that uses AsyncStorage on Android?. ",
    "sscaff1": "works thanks!\n. ",
    "igrayson": "At this line, reducedState === state, so this proposed change cannot change behavior.\nIt simply reads more easily to see us predicate on state, which the subsequent spread consumes, than reducedState.\n. I believe we'd have the same vulnerability, even if we didn't debounce, and saved each [modified] sub-hash, on each store update -- simply because saving to the store is asynchronous and not guaranteed to succeed.\nOne way to guarantee consistency, while also allowing the store to be saved in sub-hashes for performance, is to support storage backends that implement transactions. Some non-trivial refactoring could be done to createPersister to support an expanded interface for our storage backend.\nI believe unexpected crashes, or unexpected (by the application) exits will be more common for react-native mobile applications, which are more frequently and randomly force-stopped by the OS.\nAs an aside, do you know of any other similar projects? After reading through this repo and redux-storage, I think we prefer the abstractions of this one. \nOnce/if we hit up against inconsistencies due to this race condition, we'd be looking to provide transactionality to createPersister, along with a sqlite storage backend.\n. The simplest model might be to flush the entire storesToProcess queue, if the backend supports transactions, on each interval.\n. Not sure I agree. Depending on the store, and our configuration, we could see different behaviors:\n1. Large debounce, high completion time: transaction1 finishes before transaction2 begins. Correct behavior.\n2. No/small debounce, high completion time: transaction1 doesn't finish until after transaction2 begins. The debounce mechanism could detect this and wait until the next 'bounce' to attempt transaction2. This indicates that the app should increase debounce configuration. We could also let this pass through, if the application expected \"bursty\" behavior and still wanted a small debounce (sqlite as a backend, for example, could correctly serialize this backlog).\nRef (2) above: I've had an engineer tell me that RN asyncstorage always introduces a ~200ms delay (to reinforce the 'async' idea? ;). Given this, it's possible for our transactionless persistence today is already hitting this behavior when we use a small debounce.\nAnother simple condition that might cause write latency > debounced writes, for any disk-backed storage backend: heavy I/O happening concurrently. Transactions that flush the queue could make this event more likely, because we're writing more, but as long as we give visibility into that issue, it has the trivial solution of increasing the debounce interval.\n. ",
    "francisbeaudoin": "My bad. Forgot to put configs in getStoredState... sorry about that :)\n. ",
    "richtier": "perhaps createPersistor could first check if a function called something like getStateForReduxPersist, or getNativeObjectState and if that does not exist fall back to getState.\nThis will allow devs to add getStateForReduxPersist function to the store and return the state in the way Redux Persist can interact with.\n. ",
    "Crphang": "Oh blur me. That worked haha!\nHaha yes, possibly it can read the config everytime and purge whatever keys that are necessary as the application doesn't really function properly when the persistorObject runs purgeAll each time.\n. ",
    "irvingv8": "Hello there! I'm facing this problem too, currently my persistor looks like this:\npersistStore(store, {blacklist: ['routing']})\nMy reducer looks like :\nconst rootReducer = combineReducers({\n    routing: routerReducer,\n    auth: AuthenticationReducer,\n    competition: CompetitionReducer,\n    form: formReducer,\n    status: StatusReducer,\n    user: UserReducer\n});\nI tried using persistor.purge() and clearing localStorage, but it is still coming back (the routing key).\n. @rt2zz Ty for your assistance!\nI'm using \"redux-persist\": \"^4.0.0-beta1\"\n. I'm not really sure what went wrong but, im using session storage now, so my persistor looks like:\nconst persistor = persistStore(store, {storage: asyncSessionStorage, blacklist: ['routing']});\nand my sessionStorage is actually working, but it is still also saving to my localStorage (where it doesn't read my blacklist), also it is rehydrating from the localStorage. @rt2zz No, I'm just using 1 persistor, however im using redux devtools, dunno if it could be something with it...\nthis is how I'm setting it up ATM:\n```\nconst composeEnhancers = window.REDUX_DEVTOOLS_EXTENSION_COMPOSE || compose;\nconst enhancer = composeEnhancers(\n    applyMiddleware(promise,ReduxThunk),\n    autoRehydrate()\n);\nexport const store = createStore(reducers, enhancer);\nconst persistor = persistStore(store, {storage: asyncSessionStorage, blacklist: ['routing']});\n```. @rt2zz I found the problem! It was just me being dumb, I started trying this out using the \"Simplest Usage\", then I started using the \"Delay Render Until Rehydration Complete\" approach and well, I ended up with 2 persistors... so my bad, sorry for the troubles, Great work! TY for this tool, it's awesome, keep it up! . @karna41317 Glad to hear this was useful for someone else! \nKeepOnHacking!.",
    "karna41317": "@irvingv8 Thanks man, had same issue, solved . ",
    "biboukat": "don't remaining token of activation\n`const clearTokenActivation = createTransform(\n  (inboundState) => {\n    console.log('inboundState', inboundState);\n    return {\n      ...inboundState,\n      activatedToken: undefined,\n    };\n  },\n);\npersistStore(store,\n  { storage: AsyncStorage,\n    blacklist: ['auth{activatedToken}'],\n    transforms: [\n      clearTokenActivation,\n    ],\n  },\n  () => {`. ",
    "r1cebank": "Thanks for the quick reply, I do have dataReducer and return state unmodified by default. Could it be caused by something else? It does work when I use manual hydration.\n. Man, I am so careless. Thanks for all the help. \n. ",
    "sattaman": "This just helped me. My issue was I had autoRehydrate last in the enhancer chain, after devTools. \n```\nconst configureStore = (initialState) => {\n  const enhancer = compose(\n    applyMiddleware(thunk, createLogger()),\n    devTools(),  \n    autoRehydrate(),\n  );\n  return createStore(rootReducer, initialState, enhancer);\n};\n```\nSwapping to \nconst configureStore = (initialState) => {\n  const enhancer = compose(\n    applyMiddleware(thunk, createLogger()),\n    autoRehydrate(),\n    devTools(),\n  );\n  return createStore(rootReducer, initialState, enhancer);\n};\nFixed for me.\n. ",
    "madc": "I'm having a similar setup and the same issue.\nStore Setup\n```\nconst router = routerMiddleware(hashHistory);\nconst sagaMiddleware = createSagaMiddleware();\nconst enhancer = compose(\n    autoRehydrate(),\n    applyMiddleware(sagaMiddleware, router, logger),\n    devTools(),\n    persistState(\n        window.location.href.match(\n            /[?&]debug_session=([^&]+)\\b/\n        )\n    )\n);\nexport default function configureStore(initialState) {\n    const store = createStore(rootReducer, initialState, enhancer);\n    persistStore(store, {\n        whitelist: ['settings']\n    });\n    sagaMiddleware.run(rootSaga);\n    if (module.hot) {\n        module.hot.accept('../reducers', () =>\n            store.replaceReducer(require('../reducers'))\n        );\n    }\n    return store;\n}\n```\nReducer\n```\nconst initialState = {\n    recentProjectsPath: ''\n};\nexport default function settings(state = initialState, action) {\n    switch (action.type) {\n    case SET_PROJECT_DIR_PATH:\n        return { ...state, recentProjectsPath: action.payload.path };\n    default:\n        return state;\n    }\n}\n```\nThe information is persisted correctly, but when the persist/REHYDRATE action fires (after @@router/LOCATION_CHANGE), the next state is set with the initialState value.  The payload itself contains the persist data.\nBtw, I noticed, that persist/REHYDRATE fires, even if I don't call autoRehydrate. Does that make sense?\nIf I listen to REHYDRATE in my reducer, the payload has already been set to the initialState..\n. That would mean, that autoRehydrate, implemented like above, would not fire. Any ideas on how to call it with compose?\n. I will dig into it and report back on any new findings.\n. My issue is solved. It was partly the delayed loading of the re-hydrated state and partly some issue with my code that worked well together. I feel like I hijacked this issue, sorry about that and thanks for your help.\n. ",
    "gausie": "@vdzundza it looks like you're using the react-boilerplate. I'm using the same boilerplate and similarly struggling with getting redux-persist to work properly.\n. ",
    "fforres": "@vdzundza @gausie\nDid you guys manage to implement it? \nI'm a little bit lost on how the asyncronous injection of reducers handles the stores\n. Do you have an example of a reducerEnhancer @mattkrick ?\nI've been battling with this, (And with async injection of reducers) I'd love to submit a PR :) \n. ",
    "Kinjeiro": "For example, there is recipe \"Delay Render Until Rehydration Complete\"\nhttps://github.com/rt2zz/redux-persist/blob/master/docs/recipes.md#delay-render-until-rehydration-complete\n. ",
    "funwithtriangles": "For anyone struggling with this, just call persistStore again after injecting the new reducers.. ",
    "stevemao": "Is this still a issue in v5? https://github.com/rt2zz/redux-persist/issues/490 looks like a good solution.. Would be great if docs is updated\nTBH persist() and REHYDRATE part looks more like a workaround for me. I'd like to know why such boilerplate is needed.. Any comments on this one @rt2zz?. conflict resolved. yeah, since you mention \"1. remove config argument\". Depends on how fast you'll make a new major release I guess. We can always change this again when you make a new release \ud83d\ude04 . I can change this in a different PR.. ",
    "omichelsen": "It seems that Firefox only works with LZ (and localStorage) if you use UTF16. I have created an issue on redux-persist-transform-compress.\nBut the question stands: how to handle if a transform is not able to restore state, and use default state instead?\n. Another update: I tried validating the rehydrated state in my reducer on the REHYDRATE event, but because of autoHydrate.js#L37 my (fixed) reducer state is always overwritten by the incoming garbage from the corrupted stored state.\nI finally ended up writing middleware, that will modify the REHYDRATE payload if it is invalid. Don't know if this is the \"correct\" way to do it, but here is the code:\n``` js\nimport { REHYDRATE } from 'redux-persist/constants';\nfunction validate(state, value) {\n  return state\n    && typeof state === typeof value\n    && Object.keys(state).every((key) => key in value);\n}\nconst validateRehydrateMiddleware = store => next => action => {\n  switch (action.type) {\n    case REHYDRATE:\n      if (action.payload && typeof action.payload === 'object') {\n        const newPayload = {};\n        const state = store.getState();\n    Object.keys(action.payload).forEach((key) => {\n      if (validate(state[key], action.payload[key])) {\n        newPayload[key] = action.payload[key];\n      }\n    });\n\n    action.payload = newPayload;\n  }\n  break;\n\n}\nreturn next(action);\n};\nexport default validateRehydrateMiddleware;\n```\n. Yes, it has been working well for us so far.\n. Did you figure this one out? I have the same problem, but only in Safari. It breaks my whole app though.\n. ",
    "Jbarget": "@omichelsen im going to need to invalidate the persisted state based on a timestamp on the state. Have you stuck with this custom middleware approach?\n. thanks man\n. @rufman @marcellosachs\nif anyone could cast an eye at the issue below i'd be very grateful! I'm having some issues with my set up\nhttps://github.com/rt2zz/redux-persist-transform-immutable/issues/15\n. ",
    "dpereira411": "where is reduxPersistImmutable coming from? from redux-persist-transform-immutable? can I have an example?\n. thanks, so whats the difference between redux-persist-imutable and redux-persist-transform-immutable? github redirects redux-persist-immutable to redux-persist-transform-immutable \n. shouldn't that be  transforms: [immutableTransform()] ?\n. ",
    "mattkrick": "Could i get a little help on this API?\nStill not getting it to persist from localStorage:\n```\nimport {persistStore, autoRehydrate} from 'redux-persist-2';\nimport immutableTransform from 'redux-persist-transform-immutable';\nimport { stateIterator, stateGetter, stateSetter,\n  stateReconciler, lastStateInit } from 'redux-persist-immutable-state';\npersistStore(store, {\n    transform: [immutableTransform],\n    stateIterator: stateIterator,\n    stateGetter: stateGetter,\n    stateSetter: stateSetter,\n    lastStateInit: lastStateInit\n  });\n``\n. that'll do it, thanks!\n. I completely agreepurgeis a great method, my only thought is that you'd never callpurgebeforerehydrate` completed, right? Otherwise it's possible that you continue to rehydrate after a purge (assuming the rehydration is done in multiple async chunks).\nIf it's a promise, it guarantees there's no race condition between rehydrate and purge.\n. Cancel that, it was my dumb code i was working on for a fork.\n. oh shoot, sorry i let this go dormant.\n@rt2zz probably the easiest example I can think of is for something I wrote awhile back: https://github.com/mattkrick/redux-operations/blob/master/src/index.js#L257-L259\n@fforres There are, to my knowledge, 3 reducer enhancers in the ecosystem: redux-storage, redux-optimistic-ui, and redux-undo\nUltimately, I went with redux-storage. I certainly can appreciate that breaking changes absolutely suck (going through react 15.2 woes right now \ud83d\ude12 ). I also know full well storeEnhancers make for a nicer developer experience than reducerEnhancers, but there's a high price to pay for that convenience, and I've had to defend redux-optimistic-ui from 2 PRs that wanted to do the same thing. For more discussion on the general topic, see https://github.com/mattkrick/redux-optimistic-ui/pull/12, and in the words of our almighty leader Dan: https://github.com/mattkrick/redux-optimistic-ui/pull/8#issuecomment-225016186\n. ",
    "ntucker": "autoRehydrate doesn't seem to be working\n```\nimport { persistStore, autoRehydrate } from 'redux-persist-2'\nimport immutableTransform from 'redux-persist-transform-immutable'\nimport { stateIterator, stateGetter, stateSetter,\n         stateReconciler, lastStateInit } from 'redux-persist-immutable-state'\nlet enhancer = compose(\n    autoRehydrate(),\n    applyMiddleware(\n      ...middleware,\n    ),\n  )\nconst store = createStore(rootReducer, Map(), enhancer)\n  persistStore(store, {\n    whitelist: ['counter'],\n    debounce: 500,\n    storage: localforage,\n    transforms: [immutableTransform({})],\n    stateIterator,\n    stateGetter, stateSetter,\n    lastStateInit, stateReconciler,\n  })\n```\nIt saves state fine (I checked the store), but it won't initialize. It creates an action properly with all the data, but that doesn't update the state for some reason. I put some console.log in the autorehydrate enhancer and I noticed its reducer is only called once on the @@INIT action, then never again. It's not called on the persist/REHYDRATE or anything else. Anyone know why that might be?\n. Thanks @marcellosachs !\n. FYI @rt2zz : #158 still has the redux-persist-2 stuff in the README\n\n+# What about redux-persist?\n+This is a fork of redux-persist published as redux-persist-2 until the PR https://github.com/rt2zz/redux-persist/pull/113 gets merged.\n. The reconciler problem wasn't my issue. The problem is the reducer from createRehydrationReducer is only run once from the @@INIT action.\n\nstateReconciler only matters INSIDE that reducer, but it doesn't even get the chance to run.\nMaybe this is because I'm not using Action Buffers?\nPS) I'm using \"redux-persist\": \"3.6.0-alpha1\",\n. But it was merged.... https://github.com/rt2zz/redux-persist/pull/158\nhttps://github.com/rt2zz/redux-persist/pull/113#issuecomment-243931005\nWith that merged, what is the diff from redux-persist-2?\n. Still not working for me...\n. ",
    "marcellosachs": "@ntucker I ran into a similar issue - basically you have to pass stateReconciler as a config option to autoRehydrate instead of to persistStore : \n```\nimport { persistStore, autoRehydrate } from 'redux-persist-2'\nimport immutableTransform from 'redux-persist-transform-immutable'\nimport { stateIterator, stateGetter, stateSetter,\n         stateReconciler, lastStateInit } from 'redux-persist-immutable-state'\nlet enhancer = compose(\n    autoRehydrate({stateReconciler}),\n    applyMiddleware(\n      ...middleware,\n    ),\n  )\nconst store = createStore(rootReducer, Map(), enhancer)\n  persistStore(store, {\n    whitelist: ['counter'],\n    debounce: 500,\n    storage: localforage,\n    transforms: [immutableTransform({})],\n    stateIterator,\n    stateGetter, stateSetter,\n    lastStateInit, \n  })\n```\n@rufman may be helpful to add this note to your original comment. Thanks for making this btw! \n. ",
    "tigerohuang": "I think REHYDRATE should execute before any business logic\n. export default function configureStore(onComplete: ?() => void) {\n  const store = autoRehydrate()(createStoreWithMiddleware)(reducers);\n  persistor = persistStore(store, {storage: AsyncStorage}, onComplete);\n  // persistor = persistStore(store, {blacklist: ['reducers'],storage: AsyncStorage}, onComplete);\n  // persistor = persistStore(store, {skipRestore: true,storage: AsyncStorage}, onComplete);\n  if (isDebuggingInChrome) {\n    window.store = store;\n  }\n  return store;\n}\n. ",
    "prsn": "Anyone looking for SQLite store adaptor to use with redux-persist, here is the one\nhttps://www.npmjs.com/package/redux-persist-sqlite-storage. ",
    "dudeinthemirror": "It looks like it was a weird caching issue on my side. \nFixed now, will close the issue.\nThanks again for a great library.\n. ",
    "prithsharma": "@antoinerey Thanks for the example above. I was thinking through similar use cases for my app when I stumbled upon this issue. I have a basic doubt on this discussion about when is a change in state shape really an issue.\nConsidering your example above, let's assume the old and new states were as follows:-\noldState = {\n  users: Array<User>,\n  posts: Array<Post>,\n};\nnewState = {\n  users: Array<User>,\n  pages: Array<Page>,\n};\nI think it is safe to assume that the reducers above would have initialStates defined. Let those be:-\noldInitialState = {\n  users: [],\n  posts: [],\n};\nnewInitialState = {\n  users: [],\n  pages: [],\n};\nNow considering the case when there is no migration logic and the basic autoRehydrate method is used to rehydrate from localStorage. After the update, when the REHYDRATE action is dispatched for the first time, it would shallow merge the localState onto the initialState which would give the following state\nrehydratedState = {\n  users: Array<User>,\n  posts: Array<Post>, # this is stale\n  pages: [],\n}\nAny code that would be accessing state.pages would be written in a way that it can work with the initiateState(since the cache isn't available always, it must have been written that way). Any code that was using state.posts doesn't exist now. So in most cases, this would work as if the posts store was purged, or as if this is the first time app is opened. As long as that is the case and one doesn't need anything advanced like maintaining cache across store shape changes, why do we really need a migration strategy?\nOne way I can think of is that for example if the Post object was internally changed and the code is expecting it to be of certain shape without placing appropriate checks - then you would want that the posts store is migrated well.\nJust wanted to know if my understanding is correct. I am almost sure that I must be missing something here and the need for something like redux-persist-migrate is much more than what I wrote above - please correct me if that's the case, just want to understand the right use case. \n@rt2zz @antoinerey any ideas?. ",
    "KarlPurk": "For development purposes.  Manually persisting state is useful when debugging issues where the application has to be in a particular state in order to reproduce the bug.  You can setup the application in the desired state and manually persist the state to storage - you're then in a position where you can make code changes and refresh the application to return to the same state quickly, allowing for easier debugging.\n. ",
    "simonacca": "@KarlPurk Maybe you can try solving this problem with hot reloading.\n@rt2zz : A possible production use case for this feature is the following: I have set a rather long debounce for performance reasons and would like to be sure that the state is persisted when the user exits my app.\nThe ideal interface, I think, would be something like this:\n``` javascript\nconst persistor = persistStore(store, { debounce: 5000 });\nwindow.onbeforeunload = function(){\n  persistor.persist();\n};\n``\n. Agreed,.flush()or.persistImmediate()` is a much better API.\nI am trying to implement this in #217 , let me know what you think.. Ok, I get how the queue works, but I don't understand why it would be better performance-wise.\nWith the implementation in master, you check which stores need processing every time store.subscribe produces an event.\nIsn't it more efficient to limit ourselves to the setup of timeIterator within store.subscribe, to then check which substates of the stores need persisting just once, when the timer expires?\nSuppose you set debounce to 1000, then you update the store 100 times within 10 ms:\nwith the code in the pr, the persistor would do nothing at all (except for checking whether a timer is set) for every store.subscribe call.\nAnd finally check which substates to persist, and persist them just once, altogether, when the timer expires.. ",
    "fresk-nc": "it would be cool if I could persist the state even though it has not changed. ",
    "wwwdata": "Another use case that we are currently having:\nWe have a native app which also has a react native app. So certain parts of the app are implemented with react native and are using redux-persist. Before shutting down the react native part of the app, we want to make sure all the redux state got persisted and we don't kill of the react native (in terms of Android) activity too early before the state could be persisted.. ",
    "darsain": "\ud83d\udc4d the current API is awkward to use and makes the code ugly. I see no reason why I'd want to purge the store while it's loading. I would assume that would break something.\nWhat actually might be useful is a way to only purge with no loading (i.e. purge previously saved state). That is not supported right now as far as I'm aware. The API would look something like this:\n```js\nconst persistor = persistStore(store, config); // drop the callback, and don't auto-load\n// explicit load\npersistor.load(callback); // calls the callback\npersistor.load();         // returns promise\n// fully controlled purge, can be called before or after loading\npersistor.purge();. ",
    "mobitar": "I ended up doing this:\npersistStore(store, {}, () => {\n  store.dispatch(rehydrationComplete())\n})\nand then subscribing to this action in the component, and re-rendering then. Do you see any issues with going this route?\n. ",
    "tomprogers": "@rt2zz \nI've been using the same strategy: I defined initialState.storeReady = false, then implemented my own custom reducer for persist/REHYDRATE that explicitly writes storeReady: true to app state. My default route (I'm using react-native-router-flux) waits until it receives this.props.storeReady === true, and then navigates to the first screen of the app. All of that seems to work great.\nHowever, I'm trying to reset to their defaults several additional store properties that I don't want to persist across sessions, and for whatever reason only some of them are effective. That is, some store properties are successfully overwritten with hardcoded values and downstream components see the default values, and other store properties retain their persisted values and downstream components see the undesirable values from the last session. I don't understand how this is even possible, and I suspect some kind of bug in either react-redux or redux-persist.\nHere's my reducer:\n```\n// at top\nimport { initialState } from './store';\n// ...\n'persist/REHYDRATE': (state, action) => {\n    return Object.assign({}, state, action.payload, {\n        storeIsReady: true,\n    // -- here, reset to their initial values any store keys we don't wish to persist across sessions -- //\n\n    // can change session to session (e.g. iOS update)\n    deviceToken: initialState.deviceToken,\n\n    // \"names\" vs \"hex\"; the former should be selected by default\n    colorFormat: initialState.colorFormat,\n\n    // a list of colors, in either name or hex format\n    colors: initialState.colors,\n\n    // boolean; pushing a button sets it to true, and I want to reset it to false every session -- resetting it fails, and all components see this prop as true once redux-persist is done\n    warnAboutIncomingKittens: initialState.warnAboutIncomingKittens\n});\n\n}\n```\nWhat is bizarre to me is that some of those lines are effective, and others are not. Consider colors for example. The default set of colors is the ROYGBIV color names. There's a button in the app that makes an API call to fetch additional colors. When that call returns, a reducer replaces the short, default color list with the much-longer list from the web. If I comment out the color-reset code in the REHYDRATE reducer, the long list is waiting for me when I reboot the app. If I let the color-reset code execute, the short list is waiting for me when I reboot the app.\nI've confirmed via logging that the state object I'm returning has the desired warnAboutIncomingKittens: false, so I'm convinced it's not a logical error inside this reducer.\nAny help trapping this bug is appreciated. It's really got me stuck, and if I can't work past it, I'll have to remove redux-persist from our application stack for the time being. I don't want to go back to marshalling my own data into AsyncStorage. 8)\n. Note: it started working correctly when I changed warnAboutIncomingKittens from a scalar to a one-element array that holds the same data. That should be unnecessary, and suggests a bug in the way state updates are being handled in the middleware. Devs shouldn't have to wrap scalars in unwanted objects to get the correct behavior.\n. @rt2zz you're correct, this is the top-level reducer, and I'm not using combineReducers. I believe my root reducer does return the initial state at first call:\n```\n// my store file is 10% middleware setup, and 90% POJO describing initialState\nimport { initialState } from './store';\nexport default function(oldState = initialState, action) {\n    let operation = Reducers[action.type];\n    if(!operation) return oldState;\nreturn operation(clone(oldState), action);\n\n};\n// just above that...\nlet Reducers = {\n    'persist/REHYDRATE': (state, action) => {\n        return Object.assign({}, state, action.payload, {\n            storeIsReady: true,\n        // -- here, reset to their initial values any store keys we don't wish to persist across sessions -- //\n\n        // can change session to session (e.g. iOS update)\n        deviceToken: initialState.deviceToken,\n\n        // \"names\" vs \"hex\"; the former should be selected by default\n        colorFormat: initialState.colorFormat,\n\n        // a list of colors, in either name or hex format\n        colors: initialState.colors,\n\n        // boolean; pushing a button sets it to true, and I want to reset it to false every session -- resetting it fails, and all components see this prop as true once redux-persist is done\n        warnAboutIncomingKittens: initialState.warnAboutIncomingKittens\n    });\n}\n\n};\n``\n. Here's how I handle it:\n1. I construct an \"app version string\" from data found in Info.plist: specifically, the \"marketing version\" and the build number. A version string looks like this:v2.19b311. These values are managed by Xcode command-line tools, which execute as part of my production-build script:\n-xcrun agvtool new-marketing-version 2.19sets what we might call the major and minor version numbers\n-xcrun agvtool next-version -allincrements the build number\n1. I expose the version string to the application as a prop of the root component. This requires changes to the obj-c in AppDelegate.m; the relevant properties from Info.plist are:CFBundleShortVersionString(major + minor) &CFBundleVersion(build number).\n2. The app saves theappVersionString` to the redux store; if it notices that the value has changed, it resets the store to the (current) default state as part of the save operation.\nWARNING: sometimes this prop comes through as an empty string, so the check cannot simply be this.props.appVersionString !== store.appVersionString -- that would cause the app to wipe the store when the component lifecycle experiences a hiccup. Instead, you must check for a non-empty value that differs from the current value.\n. ",
    "Andreyco": "Here is my approach to delay render until store is rehydrated.  \nI am not keeping track of rehydrated flag or anything similar. Simply I don't render until data is loaded.\n```js\n// configureStore.js\nimport { createStore, applyMiddleware, compose } from 'redux';\nimport { autoRehydrate, persistStore } from 'redux-persist';\nimport { localStorage } from 'redux-persist/storages';\nimport { rootReducer } from '../reducers';\nexport default function configureStore() {\n  // use desired middlewares\n  const middlewares = [];\nreturn new Promise((resolve, reject) => {\n    try {\n      const store = createStore(\n        rootReducer,\n        undefined,\n        compose(\n          autoRehydrate(),\n          applyMiddleware(...middlewares),\n        ),\n      );\n  persistStore(\n    store,\n    { storage: localStorage },\n    () => resolve(store)\n  );\n} catch (e) {\n  reject(e);\n}\n\n});\n}\n// application entry file\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux';\nimport Router from './routes';\nimport configureStore from './configureStore';\nasync function init() {\n  const store = await configureStore();\n  ReactDOM.render(\n    \n\n,\n    document.getElementById('root')\n  );\n}\ninit();\n```. @sidmitra depends on your use case, of course. If you need more functionality (redux reducers, sagas, ...), then probably not.\n@joanrodriguez Thanks for you input, edited the snippet. Regarding exporting store for reuse, it's already \"exported\". Not directly, since it's resolved async and not know immediately. Promise either resolves with store of fails. In awaiting call site you can do whatever with resolved store.\n@RobertSheaO having configureStore.js above, create following component which would hold resolved store. When store is initiated, render app wrapped in redux provider. Hope, there are no mistakes in snippet, expect missing imports ;)\n```js\nimport React, { Component } from 'react'\nimport { Provider } from 'react-redux';\nimport configureStore from './configureStore';\nclass Bootloader extends Component {\n  state = {\n    store: null\n  }\nasync componentWillMount () {\n    const store = await configureStore();\n    this.setState({ store });\n  }\nrender () {\n    if (this.state.store === null) {\n      return (\n        \n          Booting...\n        \n      )\n    }\nreturn (\n  <Provider store={this.state.store}>\n    <App />\n  </Provider>\n)\n\n}\n}\nexport default Bootloader\n``. Here is my solution forv5`. Very similar to yours.\nstore.js\n```js\n// @flow\nimport { AsyncStorage } from 'react-native';\nimport { applyMiddleware, compose, createStore } from 'redux';\nimport { persistStore, persistReducer } from 'redux-persist';\nimport createSagaMiddleware from 'redux-saga';\nimport rootReducer from './reducers';\nimport rootSaga from './sagas';\nexport function initStore() {\n  const sagaMiddleware = createSagaMiddleware();\nconst persistedReducer = persistReducer(\n    {\n      key: 'redux-state',\n      version: 1,\n      storage: AsyncStorage,\n      whitelist: ['user'],\n    },\n    rootReducer\n  );\nconst store = createStore(\n    persistedReducer,\n    rootReducer(undefined, {}),\n    compose(applyMiddleware(sagaMiddleware))\n  );\npersistStore(store);\nsagaMiddleware.run(rootSaga);\nreturn store;\n}\n```\nBootloader.js - application entry point. Renders Bootscreen while loading, Application otherwise\n```js\n// @flow\nimport React from 'react';\nimport { type Persistor } from 'redux-persist';\nimport { AppRegistry } from 'react-native';\nimport { Provider } from 'react-redux';\nimport { initStore } from './redux/store';\nimport { BootScreen } from './screens';\nimport Application from './Application';\nimport { selectApplicationIsReady } from './redux/selectors';\ntype Props = {\n  persistor: Persistor,\n  render: (persistor: Persistor, ready: boolean) => React$Element<*>,\n};\ntype State = {\n  ready: boolean,\n};\nexport default class Bootloader extends React.PureComponent<*, Props, State> {\n  state = {\n    ready: false,\n  };\nunsubscribeFromPersistorUpdates: ?() => void;\ncomponentDidMount() {\n    const { persistor } = this.props;\n    this.unsubscribeFromPersistorUpdates = persistor.subscribe(() => {\n      if (selectApplicationIsReady(persistor.getState())) {\n        this.setState({ ready: true });\n        this.unsubscribeFromPersistorUpdates &&\n          this.unsubscribeFromPersistorUpdates();\n      }\n    });\n  }\ncomponentWillUnmount() {\n    this.unsubscribeFromPersistorUpdates &&\n      this.unsubscribeFromPersistorUpdates();\n  }\nrender() {\n    return this.props.render(this.props.persistor, this.state.ready);\n  }\n}\nAppRegistry.registerComponent('app', () => () =>\n  \n      ready\n        ? \n\n\n        : }\n  />\n);\n```\nApplication.js - application itself\n```js\n// @flow\nimport React from 'react';\nimport { connect, type Connector } from 'react-redux';\nimport { API } from './services';\nimport { selectAccessToken, selectUser } from './redux/selectors';\nimport { LoginRouter, MainRouter } from './routers';\nimport type { Store, User } from './Types';\ntype Props = {\n  accessToken: ?string,\n  user: ?User,\n};\nclass Application extends React.PureComponent {\n  componentDidMount() {\n    API._transport.interceptors.request.use(config => {\n      config.headers = {\n        Authorization: this.props.accessToken\n          ? Bearer ${this.props.accessToken}\n          : '',\n        ...config.headers,\n      };\n      return config;\n    });\n  }\nrender = () => {\n    const { user } = this.props;\n    return user ?  : ;\n  };\n}\nexport default (connect((state: Store) => ({\n  accessToken: selectAccessToken(state),\n  user: selectUser(state),\n})): Connector<{}, Props>)(Application);\n```. ",
    "joanrodriguez": "Great trick, worked a charm for me.\nCouple of remarks:\n\nI think you meant either // store.js on top of your first snippet or import configureStore from './store/configureStore'; in the second snippet\nYou are missing import { localStorage } from 'redux-persist/storages'on the first snippet\nIt wouldn't hurt to export the store in your first snippet to be able to reuse it in other components. \n",
    "ghost": "@Andreyco Any idea on how to adapt this for React Native? I tried and it complains when I wrap AppRegistry in an async function.. ",
    "sidmitra": "Is this the preferred way to do this now?\nhttps://github.com/rt2zz/redux-persist/blob/master/docs/recipes.md#delay-render-until-rehydration-complete\n. ",
    "leoskyrocker": "@Andreyco I don't think the code solves what the problem was: waiting the rehydration to be done in a component which doesn't configure the store. For example, if you want to wait in a page component before rendering anything. Reading from the redux state solves the problem.. ",
    "buckhx": "How is this pattern covered in v5? I'm currently subscribing to the store to monitor when _persist.rehydrated is true, but it feels pretty hacky.\ncomponentWillMount() {\n        persistStore(store);\n        store.subscribe(() => {\n            const { loading } = this.state;\n            if (loading && store.getState()._persist.rehydrated) {\n                this.setState({ loading: false }); \n            }   \n        }); \n    }. ",
    "MichaelRazum": "I had a Issue with some of the solutions above: https://github.com/rt2zz/redux-persist/issues/415\nEnded up with very simple code. In my case it was a banner, so in this case its ok to delay for a \nsecond. I think its a simple solution that doesn't make the code and the store setup more complicated then it should be.\n````javascript\n    constructor(props) {\n        super(props);\n        this.state = { rehydrated: false }\n}\n\ncomponentWillMount(){\n    setTimeout(() => {\n        this.setState({ rehydrated: true }); }, 1000);\n}\n\n````. I don't think there is any tricky code inside the routes components. That is strage.\nTo go to \"/suche\" where results are searched I'm using:\njavascript \nbrowserHistory.push('/suche'); \nand to navigate to the static parts of the site just \njavascript\nimport {Link} from 'react-router'\n<Link to=\"/Impressum\" className={styles.a}>Impressum</Link> \nEach time the 'persist/REHYDRATE' event is fired. Is there a way to find out what triggers this event? . OK I guess I found a component which was causing the trouble. It was a cookie banner, it is in the footer so actually in each component and should save the state whether it has been clicked. Is it obvious that this code can make trouble?\n```javascript \nimport React, {Component} from 'react';\nimport styles from './styles.css';\nimport {Button} from 'react-bootstrap';\nimport {Link} from 'react-router';\nimport {setAcceptedCookie} from \"../../actions/index\"\nimport {connect} from 'react-redux';\nimport {bindActionCreators} from 'redux';\nimport { persistStore, autoRehydrate } from 'redux-persist'\nimport {store} from '../../index';\nclass Banner extends Component {\nconstructor(props) {\n    super(props);\n    this.onClick = this.onClick.bind(this);\n    this.state = { rehydrated: false }\n\n}\n\ncomponentWillMount(){\n    persistStore(store, {}, () => {\n        this.setState({ rehydrated: true })\n    })\n}\n\nonClick() {\n    this.props.setAcceptedCookie();\n}\n\n\nrender() {\n    if (this.props.acceptedCookie || this.state.rehydrated===false) {\n        return <div></div>\n    } else {\n        return (\n            <div\n                className={`${styles.ccWindow} ${styles.ccBanner} ${styles.ccTypeInfo} ${styles.ccBottom} ${styles.ccBackground}`}>\n            <span className={styles.ccMessage}>\n                genowu.de verwendet Cookies, um Ihnen den bestm\u00f6glichen Service zu gew\u00e4hrleisten.\n                Mit der Nutzung unserer Website stimmen Sie der Verwendung von Cookies zu.\n                <Link to=\"/Datenschutz\"> Mehr erfahren</Link> </span>\n                <Button bsSize=\"small\" onClick={this.onClick}\n                >\n                    <i className={styles.btnText}></i>\n                </Button>\n\n            </div>\n        );\n    }\n\n}\n\n}\nfunction mapStateToProps(state) {\n    return {\n        acceptedCookie: state.acceptedCookie\n    };\n}\nfunction mapDispatchToProps(dispatch) {\n    return bindActionCreators({setAcceptedCookie: setAcceptedCookie}, dispatch);\n}\nexport default connect(mapStateToProps, mapDispatchToProps)(Banner);\n``` \n. @rt2zz Thanks a lot for the help. I was not that familiar with the framework and copy and pasted a solution where the component waits till render is finished. Since only the banner should wait before it renders I placed that part of the code to the banner. Wasn't aware that that can cause problems.. ",
    "stvkoch": "Hi, You can create a personal rootReducer to inject when REHYDRATE is completed\n```javascript\nimport { REHYDRATE } from 'redux-persist/constants';\nconst reducers = combineReducers({\n...\n});\nconst createRehydrateRootReducer = reducer => (state, action) => {\n  if (action.type === REHYDRATE) {\n    return { ...state, ...action.payload, rehidrate: true };\n  }\n  return reducer(state, action);\n};\nexport default createRehydrateRootReducer(reducers);\n```. ",
    "harrisrobin": "Or, if you are using it with seamless-immutable and redux-sauce, this worked for me : \n```js\nimport Immutable from \"seamless-immutable\"\nimport { createReducer, createActions } from \"reduxsauce\"\nimport { REHYDRATE } from \"redux-persist/constants\"\nexport const INITIAL_STATE = Immutable({\n  complete: false\n})\nconst rehydrationCompleteSuccess = state => state.merge({ complete: true })\nexport const reducer = createReducer(INITIAL_STATE, {\n})\n```\nEDIT:\nAnd in my app.js, if using react-router 4 I like to do this:\n```js\nimport React from \"react\"\nimport { compose } from \"recompose\"\nimport { connect } from \"react-redux\"\nimport { withRouter, Route } from \"react-router-dom\"\nimport Home from \"./containers/Home\"\nimport Landing from \"./containers/Landing\"\nconst App = props =>\n  \n    {props.rehydrateComplete\n      ? \n\n\n\n      : null}\n  \nconst mapStateToProps = state => ({\n  rehydrateComplete: state.rehydration.complete\n})\nconst mapDispatchToProps = () => ({})\nexport default compose(\n  withRouter,\n  connect(mapStateToProps, mapDispatchToProps)\n)(App)\n```. There is 2 things I did to solve this without having to resort to an opt-in per reducer rehydrate.\n\n~Initially, in my store i was exporting a create function rather than the store and creating the store in my entry index.js. Simply exporting my store instead of a function worked.~\nAdded undefined as the initial state in my reducer.\n\nKeep in mind that doing 2 alone did not work, I had to do 1 as well.\nEDIT: only point 2 is necessary. ",
    "ronanamsterdam": "Just gonna put IMFO which nobody asked for here,\nBut this Rehydration... is bad. The fact that you need to jump through all sorts of hoops because of this thing and WAIT for store to load -> is nonsense. It should happen on @@INIT in the first place.\nSwitching back to redux-localstorage because of this... feature . ",
    "jasan-s": "@Andreyco I can't seem to get registerServiceWorker()to work with your solution. I'm using createReactApp. \n. I did not come across this issue, has this been fixed? \n. @ichagas  did you ever find a solution or implement one yourself? I am in the same boat while developing a PWA app\n. I believe this is the lib for me :) \n. @rt2zz  that was definitely helpful . I got it fully functional. One last thing i want to integrate is the Redux persist migrate. I looked at its Readme and still unclear how to implement it.  I'm using webpack to generate an app.[chunkhash].js & vendor.[chunkhash]. How would i detect this change in chunkhash and rebuild the local indexeddb database? \n. I'm wondering if i can use process.env.NODE_ENV in my main index.js file to detect build environment and do a conditional If based on that?\n. can you elaborate how to do that?  or point me in the right direction. \n. I will give it a shot :) and let you know. what changes did you make? \n. Yes Sir, that fixed the issue :+1: \n. used redux-persist-transform-filter . Awesome. \n. Update:    I think it was an error because my redux store change(maybe). the indexDb in firefox was showing a store 10+ version old.  I mainly use chrome for development.  I coudn't find a a way to delete the indexdb in firefox. thus i reinstalled firefox and everything works. \n. I will have to give getStoredState a try because currently I'm doing the following: \nrender () {\n       if (!this.state.rehydrated) {\n         return <Loading />\n       }\n       return (\n        <div>\n       <App />\n       </div>\n      )\n     }\nAnd with a snapshotDelay of  1200 The html static markup contains only the Loading component not the main App component.\n. Tried using getStoredState getting error: Cannot read property 'dispatch' of undefined.  I'm passing the persistorState to the Redux Provider instead of original store state. like so:\n``\nexport const persistedStore = getStoredState(persistConfig, (err, restoredState) => {\n  // // Add the reducer to your store on therouter` key\n  // // Also apply our middleware for navigating\n  const store = createStore(\n  rootReducer,\n  restoredState,\n  compose(migration, applyMiddleware(reduxThunk, historyMiddleware),\n  window.devToolsExtension && process.env.NODE_ENV !== 'production' ? window.devToolsExtension() : f => f))\nconst persistor = createPersistor(store, persistConfig)\n  return persistor\n})\n```\nUpdate: I'm using Action Buffer, It seems to solve the problem\n. I was initially conditionally rendering the App post rehydration, removing the conditional and rendering the App right away solved it. . I was mistaken , the issue was never solved. Action buffer just buffers the actions , the app still renders before rehydration is complete.  I am not sure why snapshot delay is not working. . I now am using async store render like so:\nasync function init() {\n  const store = await configureStore()\n  snapshotRender( \n  <Provider store={store}>\n    {/* ConnectedRouter will use the store from Provider automatically */}\n    <ConnectedRouter history={history}>\n      <App />\n    </ConnectedRouter>\n  </Provider>,\n  document.getElementById('root')\n)\n}\ninit()\nregisterServiceWorker()\nI dont think this isn't redux-persist related but I now keep getting the following error:\n'render' from react-snapshot was never called. Did you replace the call to ReactDOM.render()?\n I posted this on Stackoverflow and react-snapshot issue but been nearly a month yet no reply: \n. I switched to using react-snap for prerendering and it works with it. . ",
    "nevir": "Sweet, thanks!\n. Yeah; totally missed that - I'll switch it over to that\nOn Mon, Apr 3, 2017, 22:48 Zack Story notifications@github.com wrote:\n\n@rt2zz commented on this pull request.\nIn src/createPersistor.js\nhttps://github.com/rt2zz/redux-persist/pull/321#discussion_r109580995:\n\n@@ -27,6 +27,7 @@ export default function createPersistor (store, config) {\n\n// initialize stateful values\n   let lastState = stateInit\n+  let lastWritten = {} // Last written value, per key\nwhy do we need to store lastWritten? that is more or less what lastState\ntries to track.\n\nIn src/createPersistor.js\nhttps://github.com/rt2zz/redux-persist/pull/321#discussion_r109581184:\n\n\nkeys.push(key)\n})\n+\nreturn keys\n}\n+\nfunction persistCurrentStateForKey (state, key) {\nlet storageKey = createStorageKey(key)\nlet currentState = stateGetter(state, key)\nlastWritten[key] = currentState\nlet endState = transforms.reduce((subState, transformer) => transformer.in(subState, key), currentState)\nif (typeof endState === 'undefined') return null\nreturn storage.setItem(storageKey, serializer(endState), warnIfSetError(key))\n}\n+\nfunction persistCurrentState () {\n\n\nwould be more performant to just write the existing keys that are pending\n(everything else is gauranteed to be up to date)\ni.e.\nkeys.forEach((key) => {\n  persistCurrentStateForKey(state, key)\n})\nkeys = []\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/rt2zz/redux-persist/pull/321#pullrequestreview-30691019,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAChnUKeiFXckBop1R-cM_H5YEFkkIqqks5rsdmXgaJpZM4MyRg8\n.\n. PTAL. \n",
    "ayoola-solomon": "I want to blacklist leads. Can you show me examples of the customs transform you are talking about.\n. ",
    "jnishiyama": "@rt2zz I may be misunderstanding something, but I'm not sure this issue is fixed. While it does work in a normal HMR env, it does not work when I am incognito mode and the network is throttled. By the same token, it doesn't work when I deploy my static site.\nIt seems to me that the reason is that there is a delay in the injection of the async reducer I am using (because of the network) and so the key is not present in the initial Redux state when autoRehydrate is called. Line 68 of autoRehydrate, if (!state.hasOwnProperty(key)) return; makes sure that the injected reducer is not hydrated, although, at least in this case, it should be. By removing this line, everything works as expected (rather as I expected, this may be intended).\nIs there a specific reason why this line has to be called (by the way seems to be introduced in this commit)? If not I'll gladly make a PR!\nBy the way, love the package! Thank you!. @rt2zz Hey, it should work for my case, is there a large difference between the new form of AutoRehydrate and the old form?. ",
    "teameh": "\nI am unfamiliar with this problem and have not done server side rendering myself. One possible fix would be to instead of delaying rendering entirely you render immediately with initial state but put a loader up until persist completes.\n\nWhich apart from fixing the checksum error will also give you an quicker 'time to first paint' :) . Thanks for the example \ud83d\ude01. Would indeed be a nice addition to the readme! . ",
    "muratgozel": "Yes. \nlocalforage.js:694 Uncaught (in promise) TypeError: Cannot read property 'name' of null(\u2026)\nlocalforage.js:694:\n`` javascript\n...\n// Specialize the defaultready()` function by making it dependent\n// on the current database operations. Thus, the driver will be actually\n// ready when it's been initialized (default) and there are no pending\n// operations on the database (initiated by some other instances).\nfunction _fullyReady(callback) {\n    var self = this;\nvar promise = self._initReady().then(function () {\n\n/ LINE 694 / var dbContext = dbContexts[self._dbInfo.name];\n    if (dbContext && dbContext.dbReady) {\n        return dbContext.dbReady;\n    }\n});\n\npromise.then(callback, callback);\nreturn promise;\n\n}\n...\n```\nIt says _dbInfo has no name property. So i also log the self object:\n\nIt looks like _dbInfo is null.\n. I have restructured my module by removing getStoredState function. The problem was occur in all browsers for me. \n. ",
    "robclouth": "Can anyone comment on this?\n. Seamless immutable is a popular alternative to immutable.js and a quick how-to would benefit the community.\n. It seems like the above transform is actually fine, just remember that the initial state must be immutable too or when you merge the persisted state with it problems arise.\n. ",
    "josev55": "I know this is closed but if you implement a transformer like this (view the attached code) it works really well.\n```\nimport R from 'ramda'\nimport Immutable from 'seamless-immutable'\nconst isImmutable = R.has('asMutable')\nconst convertToJs = (state) => state.asMutable({deep: true})\nconst fromImmutable = R.when(isImmutable, convertToJs)\nconst toImmutable = (raw) => Immutable(raw)\nexport default {\n  out: (state) => {\n    state.mergeDeep = R.identity\n    return toImmutable(state)\n  },\n  in: (raw) => {\n    return fromImmutable(raw)\n  }\n}\n```. ",
    "hilkeheremans": "For those of you using v5 and having trouble, I grabbed these transformers + whipped up a custom stateReconciler that helps you use seamless-immutable and avoid the dreaded state.merge is not a function error you get when processing actions after rehydration.\nThanks to @josev55 and @robclouth for the original transforms, a variant of which is also included in this lib!\nhttps://github.com/hilkeheremans/redux-persist-seamless-immutable. @leonardoanalista Thanks for the repro, I'll take a look over the next few days -- let's discuss this further in the issue on my repo.. @Ewocker That issue is caused by the default state reconciler stripping the seamless-immutable methods.\nBased on the input in this thread I built a quick lib that should let you use seamless-immutable with v5, with the same caveat that you cannot use an immutable at the top-level. Per-reducer is fine. It specifically fixes the bug you get with state.merge is not a function.\nhttps://github.com/hilkeheremans/redux-persist-seamless-immutable. ",
    "leonardoanalista": "It seems to be broken now and I am having the same problem merge is not a function even using redux-persist-seamless-immutable. I put a sand box to reproduce: \nhttps://codesandbox.io/s/k5vjmvmpkv\n. It seems like the problem is with any nested ImmutableSeamless reducer slices. If you make the authReducer a plain javascript, it works. Basically ReduxPersist is trying to add _persist property in a object which has been previously sealed. . ",
    "JeromeFranco": "@hilkeheremans thanks for the custom stateReconciler. Helped a lot. . ",
    "emaLorenzo": "For anyone with this problem this is how i solved it:\nIn your persistConfig add a custom transform\n```\n  import ImmutablePersistenceTransform from './ImmutablePersistenceTransform'\nconst persistConfig = {\n    key: 'root',\n    storage,\n    whitelist: ['account'],\n    transforms: [ImmutablePersistenceTransform]\n  }\nImmutablePersistenceTransform.js\nimport R from 'ramda'\nimport Immutable from 'seamless-immutable'\n// this is a transform in order to make redux-persist work with seamless-immutable\n// is this object already Immutable?\nconst isImmutable = R.has('asMutable')\n// change this Immutable object into a JS object\nconst convertToJs = state => state.asMutable({deep: true})\n// optionally convert this object into a JS object if it is Immutable\nconst fromImmutable = R.when(isImmutable, convertToJs)\n// convert this JS object into an Immutable object\nconst toImmutable = raw => Immutable(raw)\n// the transform interface that redux-persist is expecting\nexport default {\n  out: (state) => toImmutable(state),\n  in: (raw) => fromImmutable(raw)\n}\nnote that you will need to install ramda npm i --save ramda ```. ",
    "brunolemos": "@rt2zz lodash accept nested paths, so you could use pick for whitelist and omit for blacklist.. I'm having this warning on v5 and the reducers already returns the state on case default.\n``\nredux-persist/stateReconciler: sub state for keyadminmodified, skipping.\nredux-persist/stateReconciler: sub state for keyauthmodified, skipping.\nredux-persist/stateReconciler: sub state for keymatchesmodified, skipping.\nredux-persist/stateReconciler: sub state for keypremiummodified, skipping.\nredux-persist/stateReconciler: sub state for keyswipes` modified, skipping.\nautoMergeLevel1.js:21\nredux-persist/stateReconciler: rehydrated keys 'admin, albums, auth, deepLink, matches, permissions, premium, profiles, review, swipes, _persist'\nautoMergeLevel1.js:29\n```\nIt seems to be because I'm handling the REHYDRATE action type:\njs\nswitch (action.type) {\n  case REHYDRATE:\n    return {\n      ...initialState,\n      ..._.omit((action.payload || {}).admin, ['loading']),\n    }\nCan this cause issue? What's the alternative implementation?. > you replace it with persistReducer, but its not 1-1\n@rt2zz where can I read about the differences?\nJust migrated from v4 to v5, had some difficulties (apparently .subscribe() doesn't have an initial dispatch) but seems to be working fine. Not sure what autoRehydrate has that v5 doesn't have. ",
    "ankit90anand": "There is one more way. Store a getter function in place of nested key which needs to be blacklisted. \nlet nestedKey = \"blacklisted\";\nlet getNestedKey = ()=>nestedKey;\n...\n{\n     case REHYDRATE : return  {...state,\n           nestedKey:getNestedKey\n      };\n}\nIn storage getter function will always be null.\nWhen passing as props call the getter function to get the actual value.. Yes it must be documented.\nThough for self confirmation i did check store.subscribe added by the library and yes it maintains lastState to compare with newState and persists only the changed reducer state.\n. There is one more way. Store a getter function in place of nested key which needs to be blacklisted.\nlet nestedKey = \"blacklisted\";\nlet getNestedKey = ()=>nestedKey;\n...\n{\ncase REHYDRATE : return {...state,\nnestedKey:getNestedKey\n};\n}\nIn storage getter function will always be null.\nWhen passing as props call the getter function to get the actual value.\n. You should sync your server data in rehydration callback.\nThis will ensure your store are updated with the localy stored data.. ",
    "gyosifov": "As @brunolemos  and @rt2zz have suggested the code looks something like this:\n```\nimport omit from 'lodash/omit'\nlet blacklistTransform = createTransform(\n    (inboundState, key) => {\n        if (key === 'data') {\n            return omit(inboundState, ['search']);\n        } else {\n            return inboundState;\n        }\n    }\n)\n...\nconst persistConfig = {\n    key: 'root',\n    storage,\n    transforms: [blacklistTransform],\n}\n```. ",
    "Venryx": "Here's a slightly more modular version of @gyosifov's solution above:\n```\nimport omit from 'lodash/omit';\nconst blacklistPaths = ['prop1', 'prop2', 'prop3.nestedProp'];\nconst persistConfig = {\n    [...]\n    blacklist: blacklistPaths.filter(a => !a.includes('.')),\n    transforms: [\n        // nested blacklist-paths require a custom transform to be applied\n        createTransform((inboundState, key) => {\n            const blacklistPaths_forKey = blacklistPaths.filter(path => path.startsWith(${key}.)).map(path => path.substr(key.length + 1));\n            return omit(inboundState, ...blacklistPaths_forKey);\n        }, null),\n    ],\n};\n. Just wanted to mention an alternative to `redux-persist-transform-filter` that I use, for nested blacklisting: https://github.com/rt2zz/redux-persist/issues/134#issuecomment-457565879. For now, I'm brute-forcing a fix by just manually changing that line in the node_modules/.../index.d.ts file to:\nexport function persistReducer(config: PersistConfig, baseReducer: Reducer): Reducer;\n```\nNot a real solution since manual node_modules changes can't be cleanly tracked by git, but a stop-gap fix for the moment.. ",
    "nandorojo": "Has anyone come up with a better solution so far?. ",
    "1STi": "Hi,\nYes, installed via npm. I think the issue is the absence of typescript bindings for angular2...\nSome thoughts?\n. ",
    "bladerunner41": "I've got the same issue.  Never had a problem with using other npm modules with angular 2.\nNot sure how to fix it.\nThis article talks about how to build an angular 2 library.  It seems the tsconfig.json file is key to get the correct commonJS module export.  But that is for typescript which this project doesn't use.\nhttps://medium.com/@OCombe/how-to-publish-a-library-for-angular-2-on-npm-5f48cdabf435#.me99m3i2p\n. Figured it out.\nUse require instead of import:\nconst persistStore = require('redux-persist').persistStore;\nconst autoRehydrate = require('redux-persist').autoRehydrate;\n. @dannymy what was the exception?\nIt should work.. @dannymy hrmm not sure exactly.\nI would first make sure the autoRehydrate function is defined and imported correctly by going console.log(autoRehydrate)\nShort of that no idea.. To get it working I simply changed the two references to the function genericSetImmediate with setTimeout in persistStore.js\n. ",
    "dmylian": "As import works with the provided solution, I can not properly configure store in the Angular2:\n```\n// 1.\nconst store = createStore(\n  rootReducer,\n  applyMiddleware(autoRehydrate, thunk, logger)\n);\n// 2.\nconst store = applyMiddleware(\n   autoRehydrate,\n   thunk,\n   logger\n)(createStore)(rootReducer, {});\nthis.ngRedux.provideStore(store);\n``\nBoth throw an exception (without autoRehydrate configuration is ok and everything works). Am I doing something completely wrong?. @murraybauerreducer is not a function, where rootReducer is a combined reducer function.. @murraybauer looks like it's correctly imported, as it's the right function that returnsfunction (next) { ...`\nCould you tell, if you are configuring store the same way? Anyway, thanks for looking into. Will solve somehow. . ",
    "xeno": "I'm getting this same error on a fresh install, using the react-slingshot boilerplate. I'm also using reduxThunk, so I have to pass autoRehydrate into compose() on the third param of createStore, and persistStore(store) is in a separate file.\n. I've tracked it down to line 18 of persistStore.js\nI'm using Chrome 52.0.2743.82 m on windows. \n. I ran the code used in the definition at the top of the file, and I'm getting a function returned. Seems like it may be a scope issue.\n. ",
    "scriperdj": "same issue..can u pls post the working code\n. ",
    "iroy2000": "Ok, answering my own questions, you actually can do that in your application before you configure your store\nrequire('redux-persist/constants').keyPrefix = 'something_else';\nAnd your key will be changed.\n. \ud83d\udc4d   But is that mentioned in the doc ?\n. Ok @rt2zz , PR is here  https://github.com/rt2zz/redux-persist/pull/160\n. ",
    "benlangfeld": "One common use case is to store (non-sensitive) data for multiple users of the app. I would use a user ID as the key prefix.\nAnother is to serve multiple Redux apps on a single domain, with their persisted state namespaced.\nI think it's important to have a first-class API for this.\n. \u2764\ufe0f\n. ",
    "jschr": "+1 for this feature as well. Ideally you wouldn't set this globally but could set it on store creation (perhaps as input to a store enhancer?). My specific use case is in my app I create multiple redux stores for managing state (a single global store for db/auth state + local component stores for ui state). I'm only persisting global state at the moment but I could see adding the ability to persist certain parts of ui state as well.\nStrictly for aesthetics, it would also be nice to just remove the prefix altogether. I'm using redux-persist in a chrome packaged app and wrote a small storage adapter to persist to chrome.storage.local where the key prefix isn't really necessary. This is definitely a minor nit-pick. \nThat's my 2 cents, thanks for the great lib regardless! \n. Unfortunately just accessing window.localStorage will show an error in the console, app still works fine though. Lazy loading sounds like it good solution without breaking existing behaviour.\n. ",
    "jonathan-stone": "It would be great to mention this in the docs. \n. ",
    "damianobarbati": "Very useful indeed.\n@rt2zz I found this by accident and it was a luck: I have two different apps running on subpath /user and /admin and I'm using crosstabsync as well.\nWhen both were opened in the browser they were endlessly \"rehydrating\" each other.\nThanks to prefix everything is fine (y). @rt2zz sorry to keep bothering you but i like this module :(\nI keep getting this error as well but:\n1) state is always cloned and never muted directly\n2) state is always initialised\n3) just routing is correctly rehyrdrated (even if not needed)\nConsole warning:\n``\nredux-persist/autoRehydrate: sub state for keyauthmodified, skipping autoRehydrate.\nautoRehydrate.js:66 redux-persist/autoRehydrate: sub state for keyhomemodified, skipping autoRehydrate.\nautoRehydrate.js:66 redux-persist/autoRehydrate: sub state for keyitemmodified, skipping autoRehydrate.\nautoRehydrate.js:66 redux-persist/autoRehydrate: sub state for keylist` modified, skipping autoRehydrate.\n**store.js**\nconst reducers = {\n    routing: routerReducer,\n    auth: authReducer,\n    home: homeReducer,\n    item: itemReducer,\n    list: listReducer,\n};\nconst finalReducer = combineReducers(reducers);\nconst loggerMiddleware = createLogger();\nconst finalMiddleware = applyMiddleware(\n    thunkMiddleware,\n    promiseMiddleware,\n    loggerMiddleware,\n    routerMiddleware(browserHistory),\n    createActionBuffer(REHYDRATE),\n);\nconst store = createStore(finalReducer, composeWithDevTools(\n    finalMiddleware,\n    autoRehydrate({ log: true }),\n));\nexport default store;\n```\nauth.reducer.js\n```\nconst authState = {\n    loading: false,\n    success: false,\n    error: false,\nuser: null,\ngroup: null,\n\n};\nconst authReducer = (previousState = authState, action) => {\n    const state = _.cloneDeep(previousState);\nlet type = action.type;\nlet payload = action.payload;\nlet key = action.key;\nlet value = action.value;\n\nswitch(type) {\n    case SET:\n        state[key] = value;\n        break;\n    case SIGN_IN:\n        state.user = value;\n        break;\n    case SIGN_OUT:\n        state.user = null;\n        break;\n    default:\n        break;\n}\n\nreturn state;\n\n};\nexport default authReducer;\n```. @rt2zz solved doing as you said, thanks.. @Traverse did you find solution to this? \nWhen using react-router-redux \"@@router/LOCATION_CHANGE\" is automatically fired to sync history with current opened link at store/app bootstrap.\nUsing the \"delay method\" wrapping the app doesn't work because the action is fired non-caring about rendering.\nSo I get:\nredux-persist/autoRehydrate: 2 actions were fired before rehydration completed. This can be a symptom of a race\n      condition where the rehydrate action may overwrite the previously affected state. Consider running these actions\n      after rehydration:\nWhat could I do? Anybody else using react-router-redux?. @Traverse how do you wait to load the router? I don't know how :(\nStore.js\n```\nconst reducers = {\n    routing: routerReducer,\n    auth: authReducer,\n    home: homeReducer,\n    item: itemReducer,\n    list: listReducer,\n};\nconst finalReducer = combineReducers(reducers);\nconst loggerMiddleware = createLogger();\nconst finalMiddleware = applyMiddleware(routerMiddleware(browserHistory), thunkMiddleware, promiseMiddleware, loggerMiddleware);\nconst store = createStore(finalReducer, undefined, composeWithDevTools(\n    finalMiddleware,\n    autoRehydrate({ log: true }),\n));\n```\nApp.js\n```\nexport default class App extends React.Component {\n    constructor() {\n        super();\n        this.state = { rehydrated: false }\n    }\ncomponentWillMount() {\n    persistStore(store, {}, () => {\n        this.setState({ rehydrated: true })\n    });\n}\n\nrender() {\n    if(!this.state.rehydrated)\n        return <div>loading...</div>;\n\n    return (\n        <Provider store={store}>\n            <Router history={history}>\n                <Route path=\"/admin\" component={Layout}>\n                    <IndexRedirect to=\"/admin/home\" />\n                    <Route path=\"/admin/home\" component={Home} />\n                    <Route path=\"/admin/auth\" component={Auth} />\n                    <Route path=\"/admin/list/:model/:filter\" component={List} />\n                    <Route path=\"/admin/list/:model\" component={List} />\n                    <Route path=\"/admin/item/:model/:id\" component={Item} />\n                    <Route path=\"/admin/item/:model\" component={Item} />\n                    <Route path=\"/admin/*\" component={NotFound} />\n                </Route>\n            </Router>\n        </Provider>\n    );\n}\n\n}\n```. @Traverse that's what I'm doing: react-router-redux fires the action before the rehydrate anyway. I opened an issue on that as well: https://github.com/rt2zz/redux-action-buffer/issues/7\nMy only action firing before the HYDRATE is @@INIT but it complains anyway!. Yes @gocard, would you mind making a PR or share current code you used you achieve the feature? \nNot sure if @TSMMark did ever get a chance to give a stab at this?\nAnd Thanks for the effort guys!. Same happened to me.. ",
    "nwwells": "See #92 \n. ",
    "mrgodhani": "I am interested in knowing about this too. Is there any example of updating data and purging existing one effectively?\n. ",
    "caiobalthazar": "Hey there, the reason I closed was because I realized the persistor blacklist was meant for store keys and I had used it thinking that it was meant for action types. I would have to remove those 3 lines and submit a new request.\nIn my case, the optional PERSISTED action would be useful for two main things:\n  1- To update any user interface widget telling the user that there are no pending changes to be persisted;\n  2- To allow the application to sync its (debounced) persisted state with debug tools.\n. ",
    "varungupta85": "I will do the above things and report back with my findings. Thanks!\n. Updating just the watchman didn't help. I am currently in the process of updating react-native to latest but that would take a couple of days as there have been many breaking changes since 0.24. I am also persisting some images encoded as base64 in the storage. Could that have something to do with the errors? Is there some upper limit that you have observed w.r.t. to storing data using this library?\n. @rt2zz I have updated to the latest react-native 0.31 and although I didn't see the error for a few days but I started to see the problem again. Below is the call stack\nError storing data for key: contacts Error: Failed to write value.Error Domain=NSCocoaErrorDomain Code=512 \"(null)\" UserInfo={NSFilePath=/Users/abc/Library/Developer/CoreSimulator/Devices/1BC0FBB2-F8CD-4972-9C33-15D7FB969B38/data/Containers/Data/Application/0A7778C1-8F76-482F-9F80-59C2EB77A749/Documents/RCTAsyncLocalStorage_V1/90eb5e54838e5b2f33b011f232b016dd, NSUserStringVariant=Folder, NSUnderlyingError=0x7f9f78d78cf0 {Error Domain=NSPOSIXErrorDomain Code=24 \"Too many open files\"}}\n    at convertError (http://localhost:8081/index.ios.bundle?platform=ios&dev=true:62565:9)\n    at http://localhost:8081/index.ios.bundle?platform=ios&dev=true:62558:64\n    at Array.map (native)\n    at convertErrors (http://localhost:8081/index.ios.bundle?platform=ios&dev=true:62558:41)\n    at http://localhost:8081/index.ios.bundle?platform=ios&dev=true:62175:10\n    at MessageQueue.__invokeCallback (http://localhost:8081/index.ios.bundle?platform=ios&dev=true:7262:10)\n    at http://localhost:8081/index.ios.bundle?platform=ios&dev=true:7133:8\n    at guard (http://localhost:8081/index.ios.bundle?platform=ios&dev=true:7060:1)\n    at MessageQueue.invokeCallbackAndReturnFlushedQueue (http://localhost:8081/index.ios.bundle?platform=ios&dev=true:7132:1)\n    at DedicatedWorkerGlobalScope.onmessage (http://localhost:8081/debuggerWorker.js:39:56)\nCould you please explain what you meant by a packager issue? If you have any inputs on how to debug this problem, could you please share those? Thanks!\n. @rt2zz Thanks for responding. I am using firebase as the backend for the react-native application. So, it is possible that I may also have similar websocket problem, although I am not sure if I can really control the creation and closing of websockets by firebase. I see that AsyncStorage is backed by json files. I guess I should first check when AsyncStorage closes the files after a read/write. I am thinking AsyncStorage must be caching the open file handles for quick read/write access and we probably end up writing in separate json files after each persist causing the too many files open error.\nI have been thinking about adding an alternate storage backend backed by SQLite or Realm if I don't get to fix the problems as you have suggested.\n. I think the AsyncStorage should be imported from react-native instead of redux. Try\nimport {AsyncStorage} from 'react-native'\n. ",
    "ichagas": "No, I am using PouchDB for offline first but it is too much for my requirements. I don\u2019t need to actually have a DB + Indexes in the client side.\nI would prefer a much simpler scenario using Parse Server + react-persist for basic offline sync (ie.: user insert/update/delete during offline). In my project, Server is always right and if device change something during offline I would like to just dispatch the action as soon as it get back online, only that.\nAnyway, I\u2019ve never tested the react-redux solution to figure out how \u201crehydration\u201d concept work if it is only Server to Device direction OR both way.\n\nEm 5 de set de 2016, \u00e0(s) 15:00, jasan-s notifications@github.com escreveu:\n@ichagas https://github.com/ichagas did you ever find a solution or implement one yourself? I am in the same boat while developing a PWA app\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub https://github.com/rt2zz/redux-persist/issues/144#issuecomment-244793367, or mute the thread https://github.com/notifications/unsubscribe-auth/APXumvainykim6vR7hxYtbm0nrTR5MQFks5qnFiugaJpZM4JdtQo.\n. \n",
    "cseelus": "http://rationalappdev.com/offline-first-apps-with-react-native-and-redux\nBased on that article we created an app that fetches some Objects via JSON after login and stores them locally, so the User can create new Objects based on the stored ones and sync them when a network connection is available again. . ",
    "pellejacobs": "Not a bad idea. My only conservation is that we are duplicating code: what you just wrote is almost exactly the same as https://github.com/rt2zz/redux-persist/blob/master/src/defaults/asyncLocalStorage.js#L35-L82. What do you think?\n. @rt2zz Here is the repo: https://github.com/pellejacobs/redux-persist-node-storage. \n. ",
    "laurmurclar": "@rt2zz Thanks for getting back to me so quickly. The solution you mentioned above is pretty much the solution I came up with initially. However, we need more than just a custom transform in this case. It doesn't work (with the code above) because the steps are as follows:\nInitial state: \nA: {}\nB: {items: {}}\nB updates first (but since A.id is undefined, our persisted state is still B: {items: {}})\n```\nRedux state: \n\nA: {}\nB: {items: { 123: {etc..}, 124: {etc...}}\n\nPersisted:\nA: {}\nB: {items: {}}\n```\nThen A updates (but since the state of B has not changed, B is not added to storesToProcess and therefore key !== 'B')\n```\nRedux state: \n\nA: {id: 123}\nB: {items: { 123: {etc..}, 124: {etc...}}\n\nPersisted:\nA: {id: 123}\nB: {items: {}}\n```\nThe desired behaviour is that the update of A will also trigger an update of the persisted state for B, resulting in:\n```\nPersisted:\n\nA: {id: 123}\nB: {items: { 123: {etc..}}\n```\n. I can show you the working solution tomorrow, I just need to tidy it up a little first\n. ",
    "FarhadG": "Works like a charm! Thank you!\n. ",
    "creage": "Please, see comment of John-David Dalton here. Could it somehow cause some of lodash modules you use in your plugin, are not properly included?\n. No, no errors at all. State is not written to localStorage, otherwise everything is fine.\n. ",
    "gilbarbara": "Same problem here.\nthe forEach method in createPersistor doesn't iterate at all..\n. ",
    "renganatha10": "How about redux-persist-transform-immutable and redux-persist-immutable-state ? Will these packages will be helpful ?\n. ",
    "mayankrungta": "Sorry which is the lib for this? I need to do the same for an Ionic 3 app. The data is not persisting across a hard reset.. ",
    "tijs": "redux-persist@3.5.0\nGood catch on the middleware argument btw. i have no idea how that has been working correctly but it was. Just changed it to the correct setup, which also works fine on 0.30. \nconst middleware = applyMiddleware(generatorMiddleware, thunk, promiseMiddleware, logger);\nconst store = createStore(\n  rootReducer,\n  {},\n  compose(autoRehydrate(), middleware)\n);\npersistStore(store, { storage: AsyncStorage });\nI'll also check if that by any chance fixes the issue in 0.31\n. @rt2zz awesome that was also causing my issue in 0.31. no idea why 0.30 and lower even worked but thanks for spotting it!\n. @rt2zz strangely enough i still see the issue on android but only with remote debugging turned on; when i turn remote debugging off REHYDRATE works fine and the app loads. When i have remote debugging on REHYDRATE never fires. I assume this is also something in my configuration then since you said people are running 0.31 without issues but i just wanted to double check if that rings any bells for you..\n. ha! ok thats very helpful. thanks for saving me some hours this weekend most likely \ud83d\udcaf \n. yes it did! simple upgrade fixed it.\n. ",
    "pablopi": "Did this update work?\n. ",
    "ivadenis": "@rt2zz if keyPrefix is falsey, then it defaults to 'reduxPersist:', and !'' === true. So, this won't work unfortunately. \n. ",
    "TanninOne": "It's the latter, I want to completely remove/destroy the persistor. I'm not that worried about performance, it just feels 'dirty' to leave subscribers with no functionality hanging around.\n. Not exactly hot-swapping apps but part of it. My app has (will have) a \"mode\" switch. In each mode (could be a few dozen but each user will probably only ever use a few) the app works with a different set of data and about half my application state refers to the current mode.\nI don't want to holding the state of all modes in available all the time for various reasons (i.e. it would be harder to access the right one), instead I have one subtree for the current mode state and most of the code would be oblivious to the fact the mode can be changed. For that part of the state I want to use a second persistor (using whitelisting).\nWhen the user changes the mode I would \"detach\" the persistor and activate a new one, replacing the whole mode-specific subtree, while the remaining state (window layout, language and so on) remains the same.\nThis operation doesn't have to be instantaneous, the user knows stuff is going to happen when he clicks the button.\nI hope this is not a stupid approach, I'm fairly new to redux.\n. Will do a PR, give me a few days.\n. sorry, will fix code style\n. getStoredState will also silently fail if data can't be deserialized.\nSuppressing such a fundamental error is pretty horrible to be honest.\n. ",
    "EricPKerr": "Sigh. Thanks!\n. @rt2zz you'd likely need to always have approach 2 in place as a catch-all even with tests in place (server response shape changing and not being accounted for in the client, etc).  Are you aware of any solutions for either?. @rt2zz Totally understand the opinionated change aspect of this and wanting to avoid that if possible.  Are there any scenarios where you'd want keys maintained that aren't in the initialState?  Presumably the rest of your app codebase would be referencing that, but it's the persisted older reducedState that's out of sync.  Any other ways to get around this?\nOpen to discussion though - where are there more opinonated pieces in the stateReconciler?. @AliaMYH The storage engine (AsyncStorage, SQLite, etc) would be sandboxed to the app, so other apps can't maliciously change/override data or in your case share data.  I don't believe it's possible to share data between apps without using a cloud service.. ",
    "Rashhh": "I am getting the same error even after importing AsyncStorage\n import React, {Component} from 'react'\n import { createStore, applyMiddleware } from 'redux'\n import { Provider } from 'react-redux'\n import thunk from 'redux-thunk'\n import {AsyncStorage} from 'react-native';\n import {persistStore, autoRehydrate} from 'redux-persist';\n import appReducers from './Reducers/CombineReducers'\n import AppContainerWithCardStack from './Containers/AppContainerWithCardStack';\n import Splash from './Splash';\n\n  const createStoreWithMiddleware = applyMiddleware(thunk)(createStore);\n  const store = createStore(appReducers, undefined, autoRehydrate());\n  console.log('before persister store.getState():',store.getState());\n  const persister=persistStore(store, {blacklist: ['navigationState'],storage: AsyncStorage});\n  console.log('after persister store.getState():',store.getState());\n\n  export default class App extends Component {\n     constructor() {\n        super()\n        this.state = { rehydrated: false }\n         }\n\n      componentWillMount(){\n        persistStore(store, {}, () => {\n        this.setState({ rehydrated: true })\n         });\n  console.log('In componentWillMount:',this.state.rehydrated);\n  console.log('after persister store.getState():',store.getState());\n          }\n      render() {\n    if(!this.state.rehydrated)\n    return <Splash />\n    else\n        return <Provider store={store} persister={persister}>\n        <AppContainerWithCardStack />\n           </Provider>\n\n      }\n        }\n\n```. ",
    "mountainstar": "you should not have to pass \"this.setState\" as an invoked function inside \"persistStore\"\nyou can run this.setState({ rehydrated: true }) outside like this:\ncomponentWilllMount() {\npresistStore(store, { storage: AsyncStorage });\nthis.setState({ rehydrated: true });\n}. ",
    "willmcclellan": "Thanks for merging :) Any idea when this will be published to npm?\n. Also, do you guys have a workflow for installing from github? Currently can't deploy the fix off this branch because it requires npm prerelease workflow.\n. ",
    "ColinEberhardt": "Very nice - thanks. There are one or two aspects of this library that would benefit from a bit more documentation. I'll see if I can find the time to add some more detail. \nNice job :-)\n. ",
    "petervavro": "Thank you @marvinhagemeister > autoRehydrate() causing the error message,  by commenting out : \"// autoRehydrate()\" the message disappear. What could be wrong ?\n. ",
    "bernardn98": "If you're using immutable.js like me for your store, try swapping redux-persist to redux-persist-immutable, that fixed it for me.\nimport {persistStore, autoRehydrate} from 'redux-persist-immutable'\nhttps://github.com/rt2zz/redux-persist-immutable \n. ",
    "NeXTs": "Hi,\njust tried createPersistor instead of persistStore but it doesn't work for me\nIt doesn't restore state from localstorage\nMoreover it broke syncing across tabs :(\nI am suprised that I am only one who needs such behaviour.\nProbably I am creating issue in project which in idea isn't fully related to my needs, but it's closer to it than any other module on the market\n. ",
    "raphaelrk": "I was storing my react-navigation current navigation state in the redux store and that was somehow causing a cycle. Changed it to only store the current route name. Our android users' apps have been crashing + logging out and after a week of debugging it seems this is the cause.\nFixed it by setting a whitelist as we only really needed to save a couple kilobytes of text (vs ~6MB). Would be nice as a dev to have some more visibility when running into this issue, like a console.log that redux persist crashed, or that the store is getting too large. Had a tough time figuring out what was going on.. ",
    "leticiacostadias": "I've been having basically the same issue, I'm having the log that follows:\nredux-persist: cannot process cyclical state.\n      Consider changing your state structure to have no cycles.\n      Alternatively blacklist the corresponding reducer key.\n      Cycle encounted at key \"0\" with value \"5978ab989c24c60015f1a81c\".\nWhere 0 is the first position of an array and 5978ab989c24c60015f1a81c is a id from my mongodb. This is being stored like this:\n\"data\": {\n     ...,\n      \"wallets\": [\n        {\n          \"label\": String,\n          \"operational_settings\": {\n            \"automatic_balance\": Boolean\n          },\n          \"user_id\": userId,\n          \"accounts\": [\n            \"5978ab989c24c60015f1a81c\"\n          ],\n          \"created_at\": ISODate\n        }\n      ]\n}\nAny idea of what I may be doing wrong?. ",
    "OsamaOso2026": "any thing new with this issue @leticiacostadias . ",
    "nhayfield": "i found that redux-persist and async storage works fine for large amounts of data on ios but chokes in android. i have begun working on a solution but haven't fully integrated it yet: sriraman/react-native-shared-preferences#5\nand\nhttps://github.com/nhayfield/react-native-shared-preferences\ni may continue but i'm going to attempt to up the storage limit for asyncstorage in android first based on this:\nhttps://github.com/facebook/react-native/pull/11656/files. i started building a new store but haven't been able to integrate it yet:  https://github.com/sriraman/react-native-shared-preferences/pull/5\nand\nhttps://github.com/nhayfield/react-native-shared-preferences\ni may continue but i'm going to attempt to up the storage limit for asyncstorage first based on this: \nhttps://github.com/facebook/react-native/pull/11656/files. @nitkuk  I set it to 8gb and now it works pretty good lol. ",
    "cbfranca": "@Thorbenandresen , how did you solved this?. ",
    "Dante-101": "I am also interested in potential solutions. \nMy state has few large objects at 1st level (4-7 MB in total) which don't update much. Since the state is persisted under one key in v5, I am worried that it will be a big performance impact and battery drain for the device even when I change a boolean in some other key of the state.\nI tried using nested reducers for the large objects but unfortunately, I could not get them to persist at all! It will be great if someone can help out with an example.. Do you know the person who is responsible for typescript definitions of redux-persist? \nTo explain the error, the typescript definition of PersistorConfig requires that any storage that is used by redux-persist implement getAllKeys() function. LocalForage's definition doesn't have getAllKeys() which causes this error. I believe it should not be a necessity because even localStorage doesn't have getAllKeys().. Good to go. Thank you!. @chawax I had the same issue. I edited the code and it works fine for my case now. See if this helps you too - https://github.com/rt2zz/redux-persist/issues/811#issuecomment-384983586. I found throttle's implementation to be different from what the documentation states. Throttle actually slows down the processing of modified keys in the state rather than throttling the write.\nI found this code in createPersistoid.js - setInterval(processNextKey, throttle). processNextKey only processes the key and stages the values for writing. The write happens when there are no more keys to be processed. So the throttle technically delays state persistence by throttle * numModifiedKeys ms.\nSo if you have large throttle value and if the state keeps updating, I believe it may even lead to starvation. For the current implementation, I suggest keeping throttle to a really low value like 5 or 10 ms.\n@rt2zz How about having a synchronous function to process the modified keys, and then trigger the write to the storage. We should throttle this function. Ideally, it should be a mix of throttle and debounce. Keep calling this function once every X ms (throttle) on state update and if there are any modified keys since the last persist and more than some Y ms (debounce) has passed, call the function again. The idea is similar to lodash.throttle with leading and trailing set to true.. @ozzyogkush: There are few bugs around persistence. I found two and fixed them but this project is running late with merging pull requests. See https://github.com/rt2zz/redux-persist/issues/811.. I had similar issues. See if this helps - https://github.com/rt2zz/redux-persist/issues/811#issuecomment-384983586. I needed the fix urgently so I created a branch with the compiled distributable dirs. Get the fix by:\nnpm install -S github:Dante-101/redux-persist#state-update-fixes-dist. I had the same issue. See if this helps you. https://github.com/rt2zz/redux-persist/issues/811\nI fixed the code and created a pull request. Since the project is running slow with merging pull requests, I created a distributable branch for it. I am currently running the fixed code in production and it works great.\nnpm install -S github:Dante-101/redux-persist#state-update-fixes-dist. You can use persistor.flush() and on promise resolve, the UI can show a successful change.\nHaving studied the code, I am pretty sure that currently there is no other direct mechanism to run a callback on persistence.. ",
    "nhhockeyplayer": "guys\ni am using redux... ngrx\ndeleting 1000+ objects is way slow\ni put async on the methods\nany ideas on how to speed this up or make it spin off in its own thread... async isnt cutting it\n. ",
    "saberking": "I just checked the code:\n```\nfunction rehydrate (key, serialized) {\n  let state = null\ntry {\n    let data = deserialize(serialized)\n    state = transforms.reduceRight((subState, transformer) => {\n      return transformer.out(subState, key)\n    }, data)\n  } catch (err) {\n    if (process.env.NODE_ENV !== 'production') console.warn('redux-persist/getStoredState: Error restoring data for key:', key, err)\n  }\nreturn state\n}\n```\nShould this be transformer.in? It seems to make sense to me that rehydrating the store is 'in' and persisting it is 'out'. I guess this is just my misunderstanding the sense of inbound and outbound, where you have used 'in' to mean into persistent storage as opposed to into the redux store. Maybe this could be renamed then, such as 'toReduxStore' and 'toPersistentStorage', in and out are a bit vague and I assumed the opposite of what they are actually being used to mean\n. Another option would be simply to make it explicit in the readme\n. Should I close this? From our discussion the change to the readme should certainly not be the one I have proposed in this PR\n. ",
    "AymericG": "I have the same experience. Trying to figure out what is wrong.\n. When passing undefined as initial state, I can see the REHYDRATE event being raised, and I can see the payload looking correct, but the next state is totally wrong (missing stuff like with @eneskaya).\nIf I don't pass undefined as initial state, the REHYDRATE event is raised but nothing is done to the state, although the payload is correct.\n. @eneskaya In the console, I use redux-logger.\n. ",
    "eneskaya": "What I found out so far is, that it partially works when I pass undefined as the initial state, when calling createStore\njs\nconst store = createStore(reducersCombined, undefined, compose(...enhancers))\npersistStore(store, { storage: AsyncStorage })\nMy initial state looks something like the following:\njs\nconst initialState = {\n    user: {\n        logged_in: false\n    },\n    questions: [\n        { question_title: 'First question title', another_attribute: '...' },\n        { question_title: 'Second question title', another_attribute: '...' }\n    ]\n}\nWhat happens here is, that when I change the primitive value logged_in it gets persisted. Only the array questions is not being persisted. Is this the intended behaviour? \n. @AymericG where/how do you see the REHYDRATE event being raised?\n. @rt2zz I'm on 4.0.0-alpha6 and the output is as follows:\n```\nredux-persist/autoRehydrate: 1 actions were fired before rehydration completed. \nThis can be a symptom of a race condition where the rehydrate action may \noverwrite the previously affected state. \nConsider running these actions after rehydration:\nredux-persist/autoRehydrate: sub state for key questions is falsy but initial state is an object, skipping autoRehydrate.\n```\nWhat does sub state for key 'questions' is falsy mean?\nEdit:\n\"react\": \"15.3.2\",\n\"react-native\": \"0.33.0\",\n. ",
    "ainesophaur": "I'm noticing the same behavior. Would you like me to provide the logs?\nEdit: Now that I think of it, I believe this would be the expected behavior when using multiple reducers and combineReducers. Each of my reducers has an initialState and the rootReducer also has an initialState. Previously, I would also set the initialState when creating the store, which would cause rehydrate to not update nested states/objects. \nHowever, by setting createStore(rootReducer, initialState, compose())  to createStore(rootReducer, undefined, compose()) , redux-persist is now able to rehydrate the state properly and I still have an initialState for first-time run.\n. @rt2zz I used default params to construct it\nPreviously I had\njavascript\nconfigureStore(initialState = {}) {\n  const store = createStore(\n    rootReducer,\n    initialState,\n    compose(\n      autoRehydrate(),\n      applyMiddleware(\n          thunk,\n          ...middleware,\n          createActionBuffer(REHYDRATE)\n      )\n    )\n  );\nI have an isomorphic app and I was providing an actual initialState to configureStore when the app is mounted client side (after SSR).. Im not sure why I thought I had to provide a default empty object initialState when calling configureStore without an actual state to restore.\n. TL;DR: provide undefined as the second param to createStore.\nI've only noticed the behavior when I provide an initial state as the second param to createStore. If you pass undefined or null then it rehydrates correctly. I haven't reviewed the code in depth, but I'd imagine it doesn't restore state objects where a value already exists in the store state during creation.\nWhen you have multiple reducers and you provide an initial state to them, then your first run state will shape correctly. Then subsequent launches will restore the state from redux-persist. No that's fine.. That's how I do it. You just cannot pass a default initial\nstate to the createStore function\nOn Jan 5, 2017 8:52 AM, \"JulianKingman\" notifications@github.com wrote:\n\nSo if i create my reducers like this:\nconst reducers = (state  = {}, action) => {\n  switch (action.type) {\n    case 'ADDED':\n    ....\n  }\n}\nDoes that state = {} default declaration count as initializing the state?\nI'm wondering if that's why my store is not rehydrating.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/rt2zz/redux-persist/issues/189#issuecomment-270648388,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AEeBdpqdSzs0WM7y2E0pCmQlwsm4f2XFks5rPPWEgaJpZM4KR1gi\n.\n. \n",
    "Roilan": "Same issue here with SSR. Doesn't seem to dispatch the initial state coming from the server. Also, I'm whitelisting one reducer.\n. ",
    "mbifulco": "I believe I'm running into this, too.  Currently testing on react-native using an ios app.\nPackages are as follows:\n\"react\": \"15.4.1\",\n    \"react-native\": \"0.39.0\",\n    \"react-redux\": \"4.4.5\",\n    \"redux\": \"3.5.2\",. I'm also unable to get any logs to print, despite having used \nautoRehydrate({log:true}) in the compose function for the middleware I'm using (which consists of this package and thunk.. Strangely enough, that's what I'm doing. Here's a simplified snippet:\n```javascript\nimport { createStore, applyMiddleware, combineReducers, compose } from 'redux';\nimport thunk from 'redux-thunk';\nimport {AsyncStorage} from 'react-native'\nimport {persistStore, autoRehydrate} from 'redux-persist'\nimport { app } from './modules'\nimport { login} from './modules'\nconst middleware = compose(\n  applyMiddleware(thunk),\n  autoRehydrate({log:true}),\n);\nexport default (data = {}) => {\n  const rootReducer = combineReducers({\n    //every module's reducer defined here\n    [app.NAME]: app.reducer,\n    [login.NAME]: login.reducer\n  })\nreturn createStore(rootReducer, undefined, middleware)\npersistStore(store, {storage: AsyncStorage})\n}\n``. Shoot.persistStore` happens after return? Good idea, self.. ",
    "DonovanCharpin": "@JulianKingman same as you. Everything looks fine, I just see that the autoRehydrate is skipped because an action is triggered. I don't know where because even the redux-logger doesn't say anything before this log from autoRehydrate..\n```\nconst app = combineReducers({\n ...\n  carts\n});\nconst enhancers = compose(\n    applyMiddleware(\n        thunk, \n        loadedSoundsMiddleware, \n        redux-logger, \n        createActionBuffer(\"persist/REHYDRATE\")\n    ),\n    autoRehydrate({log: true})\n);\n// Create and persist the store to the local storage\nconst store = createStore(app, undefined, enhancers);\n// We store only the checkout process with cart etc.\nconst persistConfig = {\n  whitelist : [\"carts\"]\n};\npersistStore(store, persistConfig);\nexport default store;\n```\nAnd my carts store looks like that : \n```\nconst initialState = {\n  all: {}\n};\nconst planReducer = (state, action) => {\n  if (typeof state === 'undefined') {\n    return initialState;\n  }\n  switch (action.type) {\n    case ...:\n     ...\n  }\n};\nexport default planReducer\n```\nThis is my log from the autoRehydrate\n\nredux-persist/autoRehydrate: 1 actions were fired before rehydration completed. This can be a symptom of a race\n      condition where the rehydrate action may overwrite the previously affected state. Consider running these actions\n      after rehydration:\nredux-persist/autoRehydrate: sub state for key carts modified, skipping autoRehydrate.\n. Thanks @JulianKingman, I fixed on my side adding this piece of code in my reducer. It's extracted from the READ_ME, that's not great to add a case in the switch but it works : \n\n```\nimport {REHYDRATE} from 'redux-persist/constants'\ncase REHYDRATE:\n      var incoming = action.payload.carts; // Carts is the name of the reducer\n      if (incoming) return {...state, ...incoming};\n      return state;\n```. Hi @gogoku, already had this issue when I had a mutation in one of my reducer. You could plug a mutation detector in redux middleware to be sure nothing mutate.. ",
    "andrefox333": "@HarrisRobin can you show a code snippet of what you mentioned above?\n. ",
    "TheoMer": "@HarrisRobin I too would be interested in seeing any code snippets you can share.. Thanks to he wonderment that is logger the following two images show exactly what I'm experiencing. Note: in addition to store.js, specified in my initial question, I have also added the following code to each reducer:\nimport {REHYDRATE} from 'redux-persist/constants';\n    case REHYDRATE:\n      var incoming = action.payload.logOut\n      if (incoming) return {...state, ...incoming, specialKey: processSpecial(incoming.specialKey)}\n      return state\nThe first image reflects state directly after login and the users authToken has been captured:\n\nThe next image reflects state directly after a reload has occurred, clearly showing that authToken no longer exists:\n\nHow do I retain state as it existed prior to the reload?. @glowind Solution found.\nRehydration was not working due to the order of autoRehydrate() in my enhancers in store.js. It MUST appear before devTools!\nconst enhancers = compose(\n    applyMiddleware(...middlewares),\n    autoRehydrate(),\n    (typeof window.__REDUX_DEVTOOLS_EXTENSION__ !== 'undefined' || process.env.NODE_ENV !== 'production') ? window.__REDUX_DEVTOOLS_EXTENSION__() : (f) => f,\n);\nI was able to then remove all of the rehydrate code from my main component (router), so it reads as follows:\n```\nclass MainApp extends React.Component {\n  constructor(props) {\n    super(props);\n  }\nrender () {\n    return (\n      \n\n\n\n\n\n\n\n\n    )\n  }\n}\nexport default MainApp;\n```\nAnd all works as expected now.. ",
    "bhavyanth7777": "I was able to correct this without having to use undefined as the initial state. Here's the code\nIn index.android.js\n```\nexport default class AppName extends Component {\n  constructor(){\n    super();\n    this.state = {rehydrated: false}\n  }\n  componentWillMount(){\n      persistStore(store,{storage: AsyncStorage},()=> {\n        console.log(\"rehydrated\");\n        this.setState({rehydrated:true});\n      });\n  }\n  render() {\n    if(this.state.rehydrated){\n      console.log(store.getState());\n        return (\n            \n        )\n    }\n    else {\n      return(\n          \nSetting up...\n\n          )\n    }\n  }\n}\nAppRegistry.registerComponent('AppName', () => AppName);\n```\nI'm making sure that the rehydration is complete in componentWillMount() and then passing the store to the provider as a prop. While it rehydrates, I'm displaying a text \"Setting up..\" on the screen.\nStore configuration\nfunction configureStore(initialState) {\n    const enhancer = compose(\n        applyMiddleware(\n            thunkMiddleWare,\n            loggerMiddleWare\n        ),\n        autoRehydrate()\n    );\n    return createStore(reducer, initialState, enhancer);\n}. ",
    "Nualiian": "I'll share my experience here:\nA combination of @bhavyanth7777  and @JulianKingman solution worked for me.\nI had to make use of the callback after rehydration to load my main component, but also implement the persist/REHYDRATE in my reducer manually. It looks kinda hacky, but it works and, most importantly, I can still make use of initialState, which is cool.. ",
    "dmexs": "Struggled with this issue tonight. Finally figured out I had an error in my reducer. In my reducer I was writing:\nObject.assign(state, {new_value: 'blah blah'})\nas oppososed to:\nObject.assign({}, state, {new_value: 'blah blah'})\nSee this SO post for more detail: https://stackoverflow.com/questions/33828267/why-do-redux-examples-pass-empty-object-as-first-object-assign-argument. ",
    "leguma": "I'm using v5 and am seeing the problem as well. I noticed this issue can occur if you have state mutations triggered on app load (before rehydration is complete).\nExample:\n```\nexport default (state = defaultState, action) => {\n    // Standard switch handler\n    let newState = handleAction(state, action)\n    // This always runs *AFTER* the reducer's other state changes. E.g. some flag setting any time a redux event fires\nreturn someMutation(newState);\n\n}\n```\nThe above somehow causes the rehydrate to be aborted, despite having the same state shape (in my case) before & after the mutation. It's probably checking to see if the reference object has changed.\nThere are a few ways to fix it:\n1. Make your \"global\" mutation only fire when the input object is a different object from the one returned by handleAction.\n```\nexport default (state = defaultState, action) => {\n    let newState = handleAction(state, action)\n// handleAction default action handler returns false or null. Could check obj equivalence instead if you'd rather return the passed-in state as the default handler.\nif (!newState) {\n    return state\n}\n\nreturn someMutation(newState);\n\n}\n```\n\n\nDon't make your mutation global. Either thunk all your desired action creators with this \"global\" action, or wrap the mutation on each handler you want it on. This could also make it a bit more performant (at the cost of being uglier).\nexport default (state = defaultState, action) => {\n    switch (action.type) {\n        case 'ACTION_A': return someMutation(\n            // Your standard handler for this action\n        )\n        case 'ACTION_B': return someMutation(\n            // Your standard handler for this action\n        )\n        case default:\n            // If you touch put a mutation here, it will break rehydration.\n            return state\n}\n\n\nAs mentioned by others in the thread, add a rehydrate handler that purposefully doesn't touch state:\n```\nimport { REHYDRATE } from 'redux-persist'\n\n\nexport default (state = defaultState, action) => {\n    // Workaround to prevent interruption of rehydration\n    if (action.type === REHYDRATE) {\n        return state\n    }\nreturn someMutation(handleAction(state, action));\n\n}\n```\nAll of these options feel a bit hacky. Maybe we could tell redux-persist to force rehydrate regardless of the incoming state?\nEDIT: Note an alternative to the above is by creating middleware, which is perhaps a better cross-cutting approach to this sort of behavior. I use the above as examples of where rehydration can be aborted.. Check out my earlier comments regarding changing state during REHYDRATE events. If you've determined that you're definitely not doing that, then check to see if @gogoku's issue is related.\nFor me, my issue was that I had a default reducer handler that was changing some state (setting an expiresAt property and some other things). The REHYDRATE event, therefore, was causing a state mutation. In this case, redux-persist aborts (or perhaps there's a race condition), resulting in the rehydrated state being lost.\nMy solution was simply to prevent any state changes during the REHYDRATE event:\n```\nexport default (state = defaultState, action) => {\n    // do not mutate state during REHYDRATE!\n    if (action.type === REHYDRATE) {\n        return state\n    }\n// handleAction is where the guts of this reducer lives. \n// wrapperMutation happens AFTER the reducer logic; it _always_ mutates state (in this case, updating my expiresAt property). \n// This would break rehydration if not for the above if statement.\nreturn wrapperMutation(handleAction(state, action));\n\n}\n```. ",
    "galcivar": "I have been struggling with this for weeks, see: https://stackoverflow.com/questions/47971918/using-connect-with-react-redux-and-redux-persist\nTried @leguma 3 ways without avail. Please anyone can help me on this?\n. ",
    "Baka9k": "I had to pass config from server to app in initial state (I use SSR), but redux-persist worked only if i pass {} in initial state in configure-store.js. I fixed this by blacklisting state field I needed to pass from server with initial state, and passing state only with this field as initial state:\njavascript\nfunction configureStore(isHotLoaderRequired = false) {\n    return (initState = {}, history = null) => {\n        const store = createStore(\n            persistedReducer,\n            { settings: initState.settings }, // <- here! If I pass here initState, redux-persist not works\n            applyMiddleware(\n                routerMiddleware(history),\n                thunk\n            )\n        );\n. . .\n}. @karimone and what is the solution?. ",
    "yasserzubair": "this is how i create my store\n```\nconst persistConfig = {\n key: 'root',\n storage: storage,\n stateReconciler: autoMergeLevel2 // see \"Merge Process\" section for details.\n};\nconst pReducer = persistReducer(persistConfig, rootReducer);\nexport function configureStore(history) {\n  const middleWares = [thunk];\n    middleWares.push(createLogger());\n  const middleware = applyMiddleware(...middleWares);\nreturn createStore(pReducer, middleware);\n}\nexport  const persistor = persistStore(configureStore());\n```\nThis is how I initialize my app\n```\nimport { PersistGate } from 'redux-persist/lib/integration/react';\nimport { persistor, configureStore } from './store';\n\nLoading} persistor={persistor}>\n    \n\n\n\n\n```\nChecked by passing undefined as the second argument. Still no luck. Please tell me what I'm doing wrong.. ",
    "Johncy1997": "I created my store like this..\nconfigureStore.js:\n\nimport { createStore, compose, applyMiddleware } from 'redux';\nimport thunk from 'redux-thunk';\n  import {logger} from 'redux-logger';\n\n import allReducers from '../reducers';\n\n const middleware = [\n   thunk,\n     logger\n   ];\n  const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;\n\n   export default function configureStore(){\n   let store = createStore(\n       allReducers,\n         {},\n        composeEnhancers(applyMiddleware(...middleware))\n );\n    console.log(\"Store created here\"+store);\n    return store;\n  }\n\nreducers/index.js:\n\n import {persistCombineReducers} from 'redux-persist';\n  import storage from 'redux-persist/es/storage';\n  import autoMergeLevel2 from 'redux-persist/es/stateReconciler/autoMergeLevel2';\n     import autoMergeLevel from 'redux-persist/es/stateReconciler/autoMergeLevel1';\n\n\n  import Authentication from './Authentication';\n  import Homeworks from './Homeworks';\n      import ClassConfig from './ClassConfig';\n\n  const config = {\n  key :'root',\n  storage,\n  stateReconciler: autoMergeLevel2,\n // stateReconciler: autoMergeLevel,\n  whitelist:['authentication'],\n blacklist:['homeworks','classconfig']\n}\n\n  const allReducers =  persistCombineReducers(config,{\n   authentication: Authentication,\n   homeworks: Homeworks,\n   classconfig: ClassConfig\n});\n\n     export default allReducers;\n\nAuthentication.js:\n\n  import { LOGIN, LOGOUT, GET_USER_DETAILS,REQUEST_FAIL } from '../actions/actionTypes';\n  // import { REHYDRATE } from 'redux-persist';\n\n const DEFAULT_AUTHENTICATION = {\n     email: null,\n   name: null,\n  token: null,\n    signedIn: false,\n   error: null,\n   userDetail:{},\n     logoutmessage:null\n   }\n\n  const Authentication = (state = DEFAULT_AUTHENTICATION, action) =>{\n    switch(action.type){\n      case LOGIN:\n        console.log(\"reducers/Authentication/LOGIN called\"+state);debugger\n        return{\n            ...state,\n            token: action.response.success.token,\n            name: action.response.success.name,\n            signedIn: true\n        }\n    case LOGOUT: \n        console.log(\"reducers/Authentication/LOGOUT called\");\n        return{\n            ...state,\n            logoutmessage:action.response.success,\n            token : null,\n            name : null,\n            signedIn : false\n        }\n    case GET_USER_DETAILS:\n        console.log(\"reducers/Authentication/GET_USER_DETAILS called\");\n        return{\n            ...state,\n            userDetail: action.response.success,\n            email: action.response.success.email,\n            name : action.response.success.name\n        }\n    case REQUEST_FAIL:\n        console.log(\"reducers/Authentication/REQUEST_FAIL called\");\n        return{\n            ...state,\n            error: action.error,\n        }\n     case \"persist/REHYDRATE\": \n             const data = action.payload;\n            if (data) \n                return {\n                    ...state,\n                     ...data.authentication\n                    } //Should I compulsorily write this case?If i dont write it,the payload is not replacing the next state while rehydrating the store(i.e store gets only initial state).Here my doubt is for each whitelist state should i include the line as ...data.whitelist1 , ...data.whitelist2, ...data.whitelist3...?\n\n     default:\n        console.log(\"default/reducers/Authentication called\");\n        return {\n            ...state\n        }\n        }\n   }\n\n      export default Authentication;\n\nLogin.js:\n\n //import stmts\n\n     const mapStateToProps = (state) =>{\n    return{\n      authentication :state.authentication,\n     }\n      }\n      const mapDispatchToProps = (dispatch) => {\n       return{\n          onSubmit : (credentials) => {\n      dispatch(login(credentials));\n         }\n       }\n          }\n\n  class Login extends Component {\n    constructor(props){\n      super(props);\n        this.state = {\n       email:null,\n        password:null,\n         otp:null\n    }\n  }\ncomponentDidMount(){\nToast.show('Welcome to Edfish', Toast.LONG);\n}\n\n submit(callback){\n    let credentials={};\n   credentials.email=this.state.email,\n    credentials.password=this.state.password,\n    this.props.onSubmit(credentials);\n    callback();\n    }\n render() {\n  return (\n     <Container >\n      <StatusBar backgroundColor={styles.mystatusbar} barStyle='dark-content'/>\n        <Content contentContainerStyle={{ justifyContent: 'center', flex: 1,marginLeft:15,marginRight:15 \n          }}>\n              <Text style={{alignSelf:\"center\"}}>EDFISH</Text>\n              <Label style={{paddingTop:25,paddingBottom:15,fontWeight:'800'}}>Enter email id:</Label>\n              <View style={[styles.loginInput,styles.h_50]}>\n                <Input  placeholder=\"myemail@gmail.com\" onChangeText={(email)=>{\n                  this.setState({\n                    email:email\n                  });\n                }} \n          onSubmitEditing={()=>{\n                  this.refs.password._root.focus();\n                }}\n           blurOnSubmit={false}/>\n              </View>\n              <Label style={[styles.pad_top_25,styles.pad_bot_15,styles.font_w8_800]}>Enter your password: \n             </Label>\n              <View style={[styles.loginInput,styles.h_50]}>\n                <Input  placeholder=\"your password\" secureTextEntry={true} onChangeText={(password)=> \n                         {\n                  this.setState({\n                    password:password\n                  });\n                }} \n                 onSubmitEditing={(event)=>{\n                  this.submit(function() {\n                    console.log('huzzah, I\\'m done!');\n                });//The if stmt gets checked before my reducers/LOGIN gets completed the changes in the store\n                  if(this.props.authentication.error !== null){\n                    this.props.navigation.navigate('Home')\n                  }\n                  else{\n                    Toast.show('Incorrect username or password');\n                  }\n                }}  ref=\"password\"/>\n              </View>\n              <View style={{paddingTop:25,paddingBottom:15,}}>\n              <Button  block onPress={ ()=>{\n                this.submit(function() {\n                  console.log('huzzah, I\\'m done!');\n              });debugger\n                if(this.props.authentication.error !== null){\n                  this.props.navigation.navigate('Home')\n                }\n                else{\n                  Toast.show('Incorrect username or password');\n                }\n              }} style={{\n                height:50,\n                borderRadius:5,\n                backgroundColor:'#3883c0'\n                }}>\n                <Text style={{alignSelf:'center',\n                color:'white',\n                fontSize:18,\n                fontWeight:'500',\n                paddingTop:10,\n                paddingBottom:10}}>Login</Text>\n              </Button>\n              </View>\n\n\n        </Content>\n     </Container> \n   );\n     }\n    }\n\n       export default connect(mapStateToProps,mapDispatchToProps)(Login);\n\nApp.js/render method:\n\n  const store = configureStore();\n     store.subscribe(() =>\n      console.log('Store State: ', store.getState())\n      );\n       const persistor = persistStore(\n          store,\n          {},\n      ()=>{\n             console.log('rehydration completed!!!!', store.getState());\n    }\n  );//I have checked by passing undefined also!\n render() {\n   return (\n   <Provider store={store}>\n    <PersistGate loading={null} persistor={persistor} >\n      <MyRoot/>\n    </PersistGate>\n  </Provider>\n    );\n  }\n\nNow here my all confusion is that .. when i close the app and simple opens store state is persisted.If i reload the app store gets initial state.I am struggling to figure out the problem.Please someone tell me the solution for the comments i mentioned in the code.\nThanks in advance.\n. It's working fine in React Native App.But i used it for reactjs. I am getting this issue now.I imported correctly.Please tell me what should i do in my case... I am facing the same issue for 2days..Please tell me what is solution for this. > @Johncy1997 is your webpack server running? I had the same issue and noticed I forgot to start it up again.\n\nI removed the PersistGate component and manually rehydrated my whitelist reducers.:( still i dont know the exact problems.. ",
    "UmaMoiseenko": "\nreturn createStore(pReducer, middleware);\n\n@yasserzubair \nsecond argument in this call should be an initial state (you can also pass undefined or empty object) return createStore(pReducer, undefined, middleware); \nI hope this works :). ",
    "gogoku": "Hi,\nIam using redux-offline,\nI am facing same issue as @Johncy1997 \nBelow is how i am creating my store\n```\nlet customConfig = {\n    ...offlineConfig,\n    persistOptions:{\n        key: 'root',\n        transforms: [immutableTransform()],\n    },\n    returnPromises : false,\n    persistCallback : () => {this.setState({rehydrated : true})},\n};\nconst { middleware, enhanceReducer, enhanceStore } = createOffline(customConfig);\nlet middlewares = applyMiddleware(offlineCommitHandler,thunk,middleware,);\nstore = createStore(enhanceReducer(IndexReducer),undefined,compose(enhanceStore,middlewares,persistAutoRehydrate({log:true})));\n```\nI have multiple reducers \nThe issue occurs only in one reducer, \nI placed a debugger in autoRehydrate, when opening the app first time it merges the data for that reducer,\nWhen opening the app second time inbound state for that reducer is null.\n . Hi @DonovanCharpin , I checked for mutations using the library redux-immutable-state-invariant.\nAlso i manually wen through the code for the reducer and i couldn't find any mutations occurring.. Thanks @DonovanCharpin \nActually my issue was that the data was hitting the storage limit for asyncStorage in android and the data was being deleted.\nDetails can be found at this issue #199\nSolved this using file system storage instead of asyncStorage\nhttps://github.com/robwalkerco/redux-persist-filesystem-storage \n . ",
    "OlegPanfyorov": "Same for me, any help here?. @leguma Thanks, yep the problem was in my reducer. My mistake was in \"default: return { ... state }\" not \"return state\". ",
    "zerostyle": "I'm using SessionStorage, but the issue has gone away. I'm going to close for now and keep an eye on it.\n. ",
    "guns2410": "Facing similar problems...\n. ",
    "dsernst": "I'm having a similar issue, although it has nothing to do with redux-undo:\nOne of the properties in my state is an array of objects, and if I modify only a single property on one of these nested objects, redux-persist + autoRehydrate() ignores it. If I refresh, it looks like the state never changed.\nHere's the old state:\n{\n  people: [\n    {\n      name: 'John Doe',\n      score: 42,\n    }\n  ],\n}\nAnd here's what I change it to:\ndiff\n{\n  people: [\n    {\n      name: 'John Doe',\n-     score: 42,\n+     score: 67,\n    }\n  ],\n}\n\n~~Like OP says in initial post, https://github.com/rt2zz/redux-persist/blob/25f2f0648ba34c85283d2e5051232c83f996d056/src/autoRehydrate.js#L60 seems to be the relevant line.~~\n~~One solution looks like passing autoRehydrate a modified defaultStateReconciler function as config.stateReconciler. Haven't tried this yet.~~\nUpdate: This wasn't quite right, because this stateReconciler function is only getting called when the app starts back up, and the issue is that the changes aren't being persisted in the first place. This stateReconciler function gets passed bad data as its 2nd arg inboundState, and so there's no way to solve the issue from within this function.. I was able to get around this problem by adjusting my reducer to clone the array, instead of just directly modifying its values.\nThis reducer was being ignored by autoRehydrate:\n```js\n    case 'ADJUST_SCORE': {\n      const updatedPeople = state.people\n      updatedPeople[action.rowIndex].score = action.score\n  return { ...state,\n    people: updatedPeople,\n  }\n}\n\n```\nFixed:\n```diff\n    case 'ADJUST_SCORE': {\n-     const updatedPeople = state.people\n+     const updatedPeople = [...state.people]\n      updatedPeople[action.rowIndex].score = action.score\n  return { ...state,\n    people: updatedPeople,\n  }\n}\n\n```\nHope this helps \u270c\ufe0f\ud83d\udc4d\n. I see here https://github.com/rt2zz/redux-persist/blob/25f2f0648ba34c85283d2e5051232c83f996d056/src/autoRehydrate.js#L22 it looks like this just takes passing in {log: true} to autoRehydrate.. Created PR #230 to document this.. ",
    "zhuangya": "\nwhere as purge removes only redux-persist keys\n\nhmm, didn't manage to think about that.\ncurrently purge need \n- get all keys(with or without pattern)\n- remove all keys in step one.\nthat's something like O(n^2)\nso, that's kind of slow :(\n. maybe create something like plugin to do this?\nusers can clear() the storage with their own awareness in this way.\n. for what to resolve here, i think we need some discussion.\n. ",
    "HaNdTriX": "jep no problem. Done\n. ",
    "ksegla": "Obviously Option 1 is better and would be great but even Option 2 would be vastly better than the state's wipe out. As I understood it, Option 1 would do more than just fix the problem I had. In my specific case, may be there could be some kind of quick check on the new information size and a verification on whether it could hit the size limit. Note that the limit  for AsyncStorage can be changed in the MainApplication.java (it can be more than 6MB)\n. So unfortunately, the problem is still there, even with redux-persist-filesystem-storage :-(\nAny possible lead on where to start in the source code if I wanted to fix the issue myself?\nThanks. Hi @robwalkerco \nThanks for the answer. I still have at least 10 GB left so I don't think it's the problem. I now think the bug is not solely due to AsyncStorage limitations. The bug is probably somewhere in the core code of redux-persist (or possibly react-native itself). The thing is the behavior (\"when in doubt, wipe everything\" :-D)  is really the worst possible for what seem to be just hiccups. I now have a cloud save of the data so when the problem happens, I download all the data back and can actually continue adding data (lots of data) for days before another incident. So it does not seem to be just a matter of hitting a hard ceiling. \n(And I have the problem on different devices : S6 and S8, different Android versions: 5 and 7, as well as different React Navive versions)\nIt is clear that the bug appears only above a certain amount of data (> 10 MB, I'd estimate) saved to the store. I'm saying that because I have an alpha tester using my yet-to-be-released app for months now. He has about a fifth of my data and never had the problem.\n@rt2zz Is it possible that even if the data is persisted in and restored from files, there is some communication with AsyncStorage in the source code? And again, any idea where to start if I wanted to fix the bug myself?. @robwalkerco \nThanks for the very insighful and helpful comments.\nYeah, I was planning to try v5 short term. Pretty sure too the bug is indeed linked to some bad event during a write. may be app being closed at the \"wrong\" time. The bug is really the worst possible for my app (heavy on user generated/bookmarked data) so before release, I'll make sure to hunt it down systematically like you proposed.\nFinally, your information about how each reducer goes to a separate storage is really significant for me. I knew I had a dis-proportionally large reducer and I even strongly suspected, without giving it much thought and investigation, that the only data getting erased was coming from there. This is probably what I'll take a hard look at first. I can certainly spread around a bit more the data being handled by that reducer. Thanks very much for that hint.. Follow-up: for what it's worth, v5 seems way way worse (with default AsyncStorage) for the problem and even deletes very small stored data. Either that or I'm doing a terrible job updating from v4 (I have way more crashes and after each of those, data is gone). I did check that the data is persisted through restarts (app and device) and all but I don't know: it may very well be me. I'm reporting anyway in case it could help.\nWill try with files, then downgrade to v4. will spread data through a bunch of reducers and see.. @rt2zz\nOk. Thanks. Will try the alternatives. Will update with news. . @rt2zz \nI may be doing something wrong but while v4 works with redux-persist-filesystem-storage, v5 doesn't seem to.\nAs reported, v5 does work with AsyncStorage (with more severe wipe-out problem). However, there is no persistence at all when I just replace \nimport storage from 'redux-persist/lib/storage'\nby\nimport storage from 'redux-persist-filesystem-storage'\n@robwalkerco Have you tested v5 with your module? No reason it shouldn't work (same required api as v4) but somehow it doesn't. Feeling pretty lost right now.. ",
    "nitkuk": "Even after changing maximum database size limit to 50 MB, it is wiping the state.\nHere is how I did it:\nIn Main Application, inside getPackages(), I wrote this code..\nlong size = 50L * 1024L * 1024L; // 50 MB com.facebook.react.modules.storage.ReactDatabaseSupplier.getInstance(getApplicationContext()).setMaximumSize(size);\nOnly difference I find is app is not showing disk full warning in debug.\nCan someone give some pointer?\n. ",
    "ptomasroos": "Thanks. I will look into this in a while. Currently shipping a release. I will let you know later this week.. ",
    "frostney": "@nitkuk If you increase the database size inside of getPackages(), it might not have the desired effect. At least that was the case for me.\nPutting the call inside of onCreate of MainApplication, as outlined in https://github.com/facebook/react-native/pull/11656 worked for me.\nEdit: After testing this again, it turns out it didn't have any effect on where the piece of code was placed and I have the same exact issue.. ",
    "robwalkerco": "I've just worked around this issue by writing my own storage implementation for Android that uses the file system rather than AsyncStorage.\nDetails at - https://github.com/rt2zz/redux-persist/issues/284#issuecomment-291874254. I've just published an npm module specifically to fix this issue.\nCheck out https://www.npmjs.com/package/redux-persist-filesystem-storage. I've not benchmarked it @MichaelDanielTom, but I'm using it in production and haven't noticed any issues or slowness, though I have also been using the debounce option in redux-persist to reduce the number of writes. Think I set it to 50ms. \nPlease do share any benchmark results though, if you run any. . @ksegla, redux-persist used AsyncStorage by default, which on Android uses sqlite, which imposes a storage limit. redux-persist-filesystem-storage gets around this by using the filesystem instead of AsyncStorage, and so does not have a limit on the storage size (as far as I understand).\nIt therefor leads to me wonder if you are hitting the actual physical storage limit of your device? i.e. The device is refusing to store any more data in any location, as its run out of space. Could this be your issue?. @ksegla just trying to think about potential causes of this issue. \nAs you say it seems like you are not hitting a hard limit, perhaps the error is occurring when the app is closed during a write or something?\nWhen I had this issue originally, I was getting the same error consistently when hitting the hard limit, so the fact that that is not happening for you is suggesting to me that it's a different problem. \nIf you can find a way to consistently replicate the error it will be much easier for you to fix. Perhaps get the app to continually increase the amount of data being stored while logging out the progress so that you can keep running until the error occurrs to see if you get as far each time etc. \nSomething else that may perhaps help. Each reducer is persisted to a separate storage location, so whenever a reducer changes, redux-persist only needs to write the data for that reducer rather then for the whole app. That makes for smaller, faster writes, so perhaps could help you in some way?\nThere is also a new version https://github.com/rt2zz/redux-persist/blob/v5/README.md on the way. Perhaps worth a look?\n. @pedrosimao there has not been any benchmarks done as far as I know. \nWe are actually using Realm together with a fork or \u2018redux-persist-realm\u2019 \nhttps://github.com/papertrailio/redux-persist-realm/tree/always-update which is working in for us at the moment. . @ItsNoHax I've been using https://github.com/papertrailio/redux-persist-realm/tree/always-update on a project that's persisting a lot of data, and just AsyncStorage on a very small project. I've not worked on trying to improve Android startup time. Let me know if you find a solution that helps with that!. @kenma9123 I've worked around this issue by creating my own storage for Android that uses the filesystem rather that AsyncStorage.\nHopefully that will help others with this same issue.\nPerhaps there would be a way to integrate the storage implementation back into redux-persist so as to provide a more robust React Native Android storage solution? \n\nExpand to see the code\n\n```\n/**\n* @flow\n*/\n\nimport RNFetchBlob from 'react-native-fetch-blob'\n\nconst DocumentDir = RNFetchBlob.fs.dirs.DocumentDir\nconst storagePath = `${DocumentDir}/persistStore`\nconst encoding = 'utf8'\n\nconst toFileName = (name: string) => name.split(':').join('-')\nconst fromFileName = (name: string) => name.split('-').join(':')\n\nconst pathForKey = (key: string) => `${storagePath}/${toFileName(key)}`\n\nconst AndroidFileStorage = {\n  setItem: (\n    key: string,\n    value: string,\n    callback?: ?(error: ?Error) => void,\n  ) =>\n    new Promise((resolve, reject) =>\n      RNFetchBlob.fs.writeFile(pathForKey(key), value, encoding)\n        .then(() => {\n          if (callback) {\n            callback()\n          }\n          resolve()\n        })\n        .catch(error => {\n          if (callback) {\n            callback(error && error)\n          }\n          reject(error)\n        })\n  ),\n  getItem: (\n    key: string,\n    callback?: ?(error: ?Error, result: ?string) => void\n  ) =>\n    new Promise((resolve, reject) =>\n      RNFetchBlob.fs.readFile(pathForKey(toFileName(key)), encoding)\n        .then(data => {\n          if (callback) {\n            callback(null, data)\n          }\n          resolve(data)\n        })\n        .catch(error => {\n          if (callback) {\n            callback(error)\n          }\n          reject(error)\n        })\n  ),\n  removeItem: (\n    key: string,\n    callback?: ?(error: ?Error) => void,\n  ) =>\n    new Promise((resolve, reject) =>\n      RNFetchBlob.fs.unlink(pathForKey(toFileName(key)))\n        .then(() => {\n          if (callback) {\n            callback()\n          }\n          resolve()\n        })\n        .catch(error => {\n          if (callback) {\n            callback(error)\n          }\n          reject(error)\n        })\n  ),\n  getAllKeys: (\n    callback?: ?(error: ?Error, keys: ?Array) => void,\n  ) =>\n    new Promise((resolve, reject) =>\n      RNFetchBlob.fs.exists(storagePath)\n      .then(exists =>\n        exists ? Promise.resolve() : RNFetchBlob.fs.mkdir(storagePath)\n      )\n      .then(() =>\n        RNFetchBlob.fs.ls(storagePath)\n          .then(files => files.map(file => fromFileName(file)))\n          .then(files => {\n            if (callback) {\n              callback(null, files)\n            }\n            resolve(files)\n          })\n      )\n      .catch(error => {\n        if (callback) {\n          callback(error)\n        }\n        reject(error)\n      })\n  ),\n}\n\nexport default AndroidFileStorage\n```\n\n\n. @kenma9123 I've created a project on npm with a cleaned up version of the above code. Check out https://www.npmjs.com/package/redux-persist-filesystem-storage. ",
    "pedrosimao": "@robwalkerco Did anyone benchmark redux-filesystem-storage?\nI wonder how it compares to Db solutions like Realm.\nI have a project that might need to store large quantity of historical data. I am trying to use Realm, but it is way too buggy. I am facing several issues with it.\nI wonder if redux-persist with filesystem-storage, instead of asyncStorage would be too slow for me.. @aguynamedben I am also looking for executing an async function inside onBeofreLift. So this will be really helpful!. ",
    "ItsNoHax": "@robwalkerco What are you using nowadays then? We tried to use redux-persist with react-native-fs storage and it gave Android a severe start up time since we wait for the store to persist.. I looked into that @robwalkerco but it seems that it is written for Redux-Persist V4. I changed it to work for V5 but i'm running into some errors.. ",
    "hariDasu": "@robwalkerco can you provide a link to or snippet of your usage of debounce in redux-persist? I have a concern on the data being persisted too often on redux-form onChange's, but don\u2019t mean to hijack this thread...this android file size limitation is a bug on our android app I am attempting to debug as well. ",
    "CharlieHess": "@rt2zz I'm using AsyncNodeStorage in an Electron app, so it writes to the file system.\n. @rt2zz one easy workaround would be a config option so we can override the string format.\n. Aha--didn't even see that one. Thanks!\n. @cascornelissen I actually need the same thing; did you keep rolling with your fork (and is it published anywhere?). @rt2zz I went ahead and implemented it in https://github.com/rt2zz/redux-persist/pull/360. I have a pretty well-defined use case (a reducer that is used very infrequently, but needs to imbue state with passwords from https://github.com/atom/node-keytar) and in my testing there is no perf impact.. @aguynamedben sooo, at slack we've pretty much stuck with my fork for the time being, but eventually we'll have to upgrade from v4 => v5 and then I'll come back to this. I can't see that happening in the near-term though. \ud83d\ude14. In my case I wanted to store secrets securely (say, in the keychain) and have them excluded from the persisted shape. Then, on rehydrate, I wanted to read the secrets from the keychain and apply them to the state as if they were there all along. . @rt2zz any thoughts on this one?. We haven't needed to update to v5 yet and thus our fork (based off this branch) is still serving us for the time being. I won't be able to get back to this anytime soon but I bet Zack would consider a pull request!. ",
    "ian4hu": "I'll try to import it to the cdnjs, and sometimes I prefer use a prebuilt version from cdn in my app.\n. ",
    "jakeseaton": "Problem had to do with using devtool:\"source-map\" in the staging bundle. I changed to \"eval\" and it works.\n. ",
    "njlg": "Awesome! Thanks for the tidbit. \n. ",
    "jonathanfoster": "I found the solution in a closed issue https://github.com/rt2zz/redux-persist/issues/92. The closed issue has a PR https://github.com/rt2zz/redux-persist/pull/138 that updated the README, but it looks like it may have been overwritten at some point.\n. Submitted PR https://github.com/rt2zz/redux-persist/pull/210 to update README.\n. ",
    "swernerx": "What exactly should I test now? Putting immutable before compressor?\n. Seems to work now correctly. Thanks.\nUsage:\n```js\n      persistStore(this.props.store, {\n        storage: localforage,\n    // Order is important. Immutable has to be the first!\n    transforms: [\n      immutableTransform(),\n      createCompressor()\n    ],\n    blacklist: [\n      \"apollo\"\n    ]\n  }\n\n```. ",
    "jgkim": "@rt2zz It seems like the issue has been fixed. It works now for me.\n. ",
    "po-jo": "\ud83d\udc4d \n. This is a duplicate of : https://github.com/rt2zz/redux-persist/issues/212, isn't it ?\n. same as https://github.com/rt2zz/redux-persist/issues/212\n. ",
    "hugohow": "+1\n. ",
    "asciiman": "It only seems to be an issue if the empty array is the root state of the reducer.\nIf the initial state is:\nconst initialState = { data: []};\nThen it rehydrates correctly as an array.\n. I'm using AsyncStorage with RN.  How can I debug it there?\n. ",
    "Uysim": "I also meet this problem. any update?. ",
    "adambene": "It seems that if the reducer returns the initial state then it does not get rehydrated.\nWhen I pass the initial state to the redux createStore function instead of the reducer, rehydration works.\nIs this the expected behaviour?. @rt2zz Yes, I am.. ",
    "Grmiade": "I have the same problem :/. ",
    "jeffreycrow": "If my understanding is correct (and I'm basing it off this), !== doesn't work for comparing objects and so the test will always be true if the substate is an object. \nAll my substates are objects, so I got this to work by swapping out !== for a comparison using JSON.stringify. This post describes that and one other method for deep comparison of objects. I submitted a pull request (#245) with the change I made, but I have no idea if it's the best way to compare objects.\n. ",
    "purplepeng": "Your Recommended Additions(set config.debug = true to get useful logging ) is very useful. I could not find my issue until open debug mode. Thanks, it's great.. ",
    "nonnontrivial": "Yep - now the test is passing consistently on my machine (though not w/ travis, as you can see).\nDo you think this is more or less the correct approach?. Aren't whitelist and blacklist mutually exclusive?\nAlso - appears that in your case c is ignored because whitelist is defined (and does not include it).. @rt2zz This assertion would be a way of implicitly testing the outbound transform.\nProvided I can get this test to pass, do you think it makes sense to remove the other test in this file?\nThe flow of expected inbound / outbound state seems slightly more explicitly shown this way (imo).. ",
    "alburdette619": "Has any work been done on this?  There is a library called redux-pouchdb but it seems to be unmaintained and not currently even working.. I'm also experiencing this issue and am using redux-persist v5.0.7. ",
    "brandonmp": "Just looking into this myself & figured I'd share this relatively new project: https://github.com/medihack/redux-pouchdb-plus\nHaven't used it but seems to take advantage of some of the synergies b/t pouch and redux . ",
    "selipso": "The most developed PouchDB library for RN seems to be https://github.com/stockulus/pouchdb-react-native but it doesn't use redux. It already handles syncing, though, with work being done on enabling attachments. Could be a good package to collaborate as it seems to have an easier API to work with.. ",
    "yanick": "There might be one hard thing involved in a pouchdb adapter. When a document is saved, pouchDb returns back a new copy of the doc with a new _rev (so that it'll detect if one tries to update the docs from an outdated version). But setItem has no direct way to add something to the main state.... ",
    "MuraraAllan": "Any upgrade on that? I'm starting a project that involves pouchDB + Redux and I'm highly interested in contribute with this awesome library! \nI'm working on it, as the project evolves. \n. //WORK IN PROGRESS FUNCTION\n```\nimport PouchDB from 'pouchdb';\nfunction PouchDBAdapter () {\n  const db = new PouchDB('anyNameYoudWant);\n  const getItem = async (key) => {\n    try {\n      const test = await db.get(key);\n      return test;\n    } catch (err) {\n      throw err;\n    }\n  };\n  const setItem = async (key, value) => {\n    try {\n      const pouchDocument = await getItem(key);\n      const localValue = { ...value };\n      localValue._rev = pouchDocument._rev;\n      localValue._id = pouchDocument._id;\n      delete localValue._persist;\n      try {\n        const update = await db.put(localValue);\n        localValue._rev = update.rev;\n        return localValue;\n      } catch(err) {\n        console.log('ERROR ON UPDATE IS : ', err)\n        throw err;\n      }\n    } catch (err) {\n      const localValue = { ...value };\n      localValue._id = key;\n      delete localValue._persist;\n      try {\n        const insertRow = await db.put(localValue);\n        return insertRow;\n      } catch(err) {\n        throw err;\n      }\n    }\n  };\n  return { getItem, setItem };\n};\n```\n//WORK IN PROGRESS FUNCTION\n//USAGE\nconst storage = new PouchDBAdapter();\nconst rootPersistConfig = {\n  key: 'root',\n  storage: storage,\n  serialize : false,\n  debug : true\n};\n. I need some help.\nRehydrate -\nwhenever a state is being rehydrated, a set item in Storage is being dispatched, it leads to a revision bug on PouchDB, as in : \n\nToughts?\ndelete localValue._persist;\n._persist is invalid for PouchDB i got to delete it each time. \nTaking that pouchDB is intended to store documents classified by indexes , there is an abstraction decision to be taken related to Key and PrefixKey;\nWhat is the expected Storage Behaviour?\n1 - Abstracting PouchDB and putting it as a dependency for redux-persist-pouchdb;\nconst persistCompanyConfig = {\n  key: 'usersSession',\n  storage: pouchDbPlugin,\n  debug : true,\n  prefixKey : 'https://couchDBserver.com.br',\n  stateReconciler : autoMergeLevel2,\n  sync : () => {\n    pouchDbSyncFunctionNormallyDeclared()\n  }\n};\nconstructor() {\n  storage.dbs[key] = new PouchDB(`${keyPrefix}${key}`);\n  storage.dbs[key].sync(config.sync); \n}\n2 - Not abstracting PouchDB, actually receiving a generated PouchDB from config;\nconst db = new pouchDB('anyNameUserDefined');\ndb.sync(() => {});\nconst persistAppStateConfig = {\n  key: 'appState',\n  storage: storageConstructor(db),\n  debug : true,\n};\nstorage.db = parm;\n. @rt2zz . ",
    "chrise86": "@adrienjt did you come up with a solution? I'm facing the same issue; I need to transform some Map objects within various reducers, but it seems to be trying to transform everything, which is causing issues.\nI'm using redux-offline, and this is the transform that is passed to the persist options:\n```\nimport transit from 'transit-js'\nimport { createTransform } from 'redux-persist'\ncreateTransform((state, key) => {\n  const writer = transit.writer('json')\n  return writer.write(state)\n}, (raw, key) => {\n  const reader = transit.reader('json')\n  return reader.read(raw)\n})\n```. ",
    "adrienjt": "No, but I didn't try hard. Instead I switched to plain JavaScript objects, which are more idiomatic in Redux. But because I still like to think in terms of sets and maps, I wrote redux-data-structures, a library of reducer factory functions for common data structures like sets and maps, among others.. ",
    "pvinis": "so should I use only one or only the other, then?\nok that makes sense. ignite has a vague comment so I couldn't understand and I came to the source project to ask.. ok good to know. thanks.\nhere is ignite.\nhttps://github.com/infinitered/ignite. ",
    "martinfilliau": "@rt2zz REHYDRATE is an intesting option however we would need to catch errors earlier, as soon as it happens ideally. In our use case, we'd like to be able to warn users of a potential loss of data as soon as possible. Gonna propose a PR.. ",
    "vovkasm": "May be you need something as this: https://github.com/rt2zz/redux-persist/blob/master/docs/recipes.md#delay-render-until-rehydration-complete\nI successfully use this method to show kind of \"splash screen\" until initial loading done.. But you can use the same method to:\n1. Do not do any things, that can generate \"actions\" until rehydration process end (In react this most often leads to not instantiate some components).\n2. If \"actions\" come from \"external world\" (network or other sources), you can postpone subscriptions to this \"actions\" until state fully loaded or create some sort of \"buffer\" to collect this events and send \"actions\" later.. 1. promises can contain null values because persistCurrentStateForKey can return nulls. Is it desired behaviour? What if user will do Primise.all(persistor.flush()).then(...)?\n\nMay be better api for user will be to return single Promise object?\n\nMay be do something like:\njs\nconst promises = storesToProcess.map(k => persistCurrentStateForKey(state, k))\nreturn Promise.all(promises.filter(v => v != null)). ",
    "traverse": "Thanks for your reply. The problem I'm having however isn't the rendering part, basically actions are being fired that are related to updating data and or redirecting based on that data which is going awry because they're being fired with the initial state instead of the rehydrated state.. That's what I thought the action buffer would do, save up the actions and fire them after rehydration is completed or am I mistaken? Because using the devtools it shows the actions being fired after rehydration is complete but just using console logs I can see that it's using the wrong state.\nIf this isn't the way the action buffer is supposed to be used I'll try out the example you linked earlier \ud83d\udc4d \nThanks a lot!. The actions in question were automatically being fired by react-router-redux but I was checking if certain conditions were met using a middleware. In the middleware getState would return the initial state even if it showed the actions being fired after the rehydrate. \nAfter what you mentioned about thunks I went ahead and had a look at react-router-redux's code and the actions fired by it is a thunk so that is probably why it wouldn't work as I expected it to.\nUpdating action buffer to support thunks seems like the ideal solution but I sadly do not have time for it at the moment but I might do in the future however.. @damianobarbati By \"delay method\" you mean waiting with loading the router till hydration is complete? Because that should work.. ~~There is an example in the docs that shows it which you can find here, I hope this helps!~~\nEdit: I just noticed you're already applying it, it's weird that it's  not working for you then... You could always use an action buffer depending on what exactly you need.. @damianobarbati the only thing I can suggest then is what @rt2zz suggested me to do and that's updating the action buffer to support thunks, unless someone else has any other insights.. ",
    "hyperh": "Thanks this worked for me\nhttps://github.com/rt2zz/redux-persist/blob/master/docs/recipes.md#delay-render-until-rehydration-complete. ",
    "hugows": "For the record, the recipe for \"delayed render\" is now at the frontpage (https://github.com/rt2zz/redux-persist) and it magically works ;). Me too. Any tips?. ",
    "dziamid": "localStorage.clear();location.reload(). @outaTiME \njs\nconst migrations = {\n  1: ({_persist}) => {\n    return {_persist}; // reset all state, except version\n  }\n}\nconst config = {\n  key: 'root',\n  storage: storage,\n  version: 1,\n  whitelist: ['user', 'roadmaps', '_persist'], // persist state version\n  transforms: [\n    encryptor\n  ],\n  debug: __DEV__,\n  migrate: createMigrate(migrations, { debug: __DEV__ }),\n}\nSee https://github.com/rt2zz/redux-persist/issues/584 for more info. ",
    "dijonkitchen": "Official issue here: #237 . It's downloading stable now! I'm looking forward to the doc updates!. Think this can be closed with the updates to the releases? https://github.com/rt2zz/redux-persist/releases. ",
    "th0th": "@noisegrrrl, can you be trying to handle REHYDRATE action in one of your reducers that needs to be updated the very same action? I tried the same then came across this issue when looking for a solution my problem.. ",
    "StephenMayeux": "thanks @rt2zz for the suggestion. I understand your example at a high level, but I am unsure how I should construct my config object. I suppose I should whitelist my auth reducer and set storage to AsyncStorage, but where do I actually use AsyncStorage.getItem('getUserProfile') so that I can initialize the state?. Thanks for the follow up @rt2zz. I worked it through with a friend, and we discovered that we had to also call in the REHYDRATE action.type constant in our auth reducer, and then return a new state with its payload. Works like a charm now, and I am really happy that this straightforward package solved my particular issue!. ",
    "nativedone": "@rt2zz Works perfectly with autoRehydrate() option.\nThanks for addressing that key point :1st_place_medal:  . ",
    "zainozzaini": "Thanks for the issue.. Before,I only get this reference -  https://medium.com/@sumitkushwaha/syncing-redux-store-with-asyncstorage-in-react-native-2b8b890b9ca1 to get an idea how to get initialize value from redux store (AsyncStorage) but this thread is exactly clear up me everything.. ",
    "morlay": "Cool. but forgot to put it in files of package.json. Thanks, we could added the keyPrefix. sorry for my mistake.\nAnd the types of transform, may not really necessary, but want to keep it same as flow types.\nthe interfaces will be useful to create plugin, it will not be transformed to Javascript.\nand multiple files use same interfaces, so i put them in an interface file.\nThe \"old\" style just want to keep all definitions in one file, and make it could be partial imported.\nBTW, I don't like publishing to @types,  which will make maintain hard. when some changes, it will take too much time to upgrade the definitions. \nCould we merge yours back to this repo?. Cool. we may wait a minute.\nthe keyPrefix is missing in type version.\nhttps://github.com/rt2zz/redux-persist/blob/master/type-definitions/index.js.flow#L18\nShould we need to added it both? @rt2zz . In TypeScript, @types/redux's exports will be assign to redux.\nBut we don't need redux itself but have to need its interfaces, like Store and StoreEnhancer. \nWhen we use redux with this package, it will be regarded as same, otherwise, if we declare it, the type checker will be show warnings, the Store we declared  is not the Store of redux.\nThis package be published on https://github.com/DefinitelyTyped/DefinitelyTyped\n. This is the first way to provide type definitions\nand typings field on package.json, it is second way to provide type definitions. this why i added it.\n. It will not, there are no js file under @types/xxx.\nHowever, it is fine to move it to devDeps, for end user, @types/redux will be added with redux.. I am not sure the module declaration will be deprecated, at lease they will be useful for patching, when some issues in origin one. (example, working by the declaration-merging rule)  . BTW. I prefer to keep module declaration and with in single one file, it is more friendly for project which is not wrote by TypeScript (TypeScript could auto generate declarations by compiler).. ",
    "unindented": "Yeah, the pattern somehow works well for redux but not well for redux-persist. If I look at source-map-explorer, redux-persist is adding ~130KB to my build.\nBefore:\n\nAfter:\n\nI'm guessing we're bringing in clone or something that depends on it, and those are huge functions. If I had to bet, I'd put my money on omit: https://github.com/rt2zz/redux-persist/blob/4849ea2cba554203658fba2eb855e0bdd07492f7/src/persistStore.js#L4\nIf I write a PR with a lighter-weight alternative, would you be open to reviewing and accepting it? People are getting super aggressive about library sizes, and I love this library, so I want to be able to use it.. I am not running tree-shaking on my side though (I use TypeScript instead of Babel, and I was waiting for webpack 2 stable), so I should look into that before doing anything else.. Weird, using webpack 2.2.0-rc.0 didn't shake out any lodash bits:\n. Awesome, thanks @rt2zz! The tool I'm using is source-map-explorer:\n$ source-map-explorer dist/index.js dist/index.js.map. @rt2zz any chance we get a 4.1.1 release with these changes?. Awesome, thank you!. ",
    "compojoom": "@rt2zz thanks Zack! You saved me a lot of head scratching :)\nI implemented a root reducer as suggested here http://stackoverflow.com/a/35641992 and that works great. . I followed this guide over here: https://github.com/prescottprue/react-redux-firebase/blob/master/docs/integrations/redux-persist.md and modified it to work for firestore.. ",
    "LKay": "I'm not really big fan of @types either but since the definitions are already in the project's repo I'll make some changes and raise a PR soon. Then I'll also remove typings form DefinitelyTyped. . @morlay The PR is up.. Sorry for late reply, I missed the notifications for the repo completely. Since the version of the library updated and definitions have changed significantly I will close this. I will need to make few fixes to the existing ones definitions but will address these in separate PR.. @rt2zz Any chance it (and the update for compress package) will be merged and released soon?. @marvinhagemeister @rt2zz Made a squash few days ago. If it's fine now could it be merged and released any soon?. Looks ok \ud83d\udc4d . I totally missed that similar PR was already up. I also made some improvements to the current types definitions. Maybe something will be useful to add/modify in this PR? https://github.com/LKay/redux-persist/blob/lkay/typings/src/index.d.ts. @rt2zz You can go both ways, either will work. More clean version, imo would be to store types definitions the same way as you did with flow types in separate files as it's better to maintain but i don't mind having them in one file. I also saw some things that should be fixed or be of more proper type. Will make some changes and bring up PR on Monday. . I don't see the point of replacing double quotes with single quotes which is 99% of all changes here. Basically there is only one line that matters here.. Not really, I'm afraid, if you want to be fully compatible with typescript 2.x definitions. It is possible to use it now as single bundle file of the structure that @morlay created but it is now discouraged and likely will be deprecated in some future versions of typescript.. @morlay I'm quite busy today with some other work so can you make a single file out of these I made or should I do it myself tomorrow?. Babel core slightly changed and is not injecting runtimeGenerator for async functionality by default. It is necessary to either use babel-polyfill or babel-plugin-transform-runtime to inject proper polyfill. https://babeljs.io/docs/plugins/transform-runtime/\nThis is required to ava run tests asynchronously. . Id rather define this as generic Transform<State, Raw> the same way as it was in the v4. At least we won't break types for depending libraries such as redux-persist-transform-filter etc. . ",
    "ypyang237": "In case anybody was wondering, I got my isomorphic react app (using Next.js) working with an enhancer this way \n```javascript\nimport { createStore, applyMiddleware, compose } from 'redux'\nimport reducers from './reducers'\nimport thunkMiddleware from 'redux-thunk'\nimport { persistStore, autoRehydrate } from 'redux-persist'\nconst enhancer = compose(\n  autoRehydrate(),\n  applyMiddleware(thunkMiddleware)\n)\n// initStore\nexport default (reducers, initialState, isServer) => {\n  if (isServer && typeof window === 'undefined') {\n    return createStore(reducers, initialState || {}, applyMiddleware(thunkMiddleware));\n  } else {\n    if (!window.store) {\n      window.store = createStore(reducers, initialState || {}, enhancer)\n    }\n    persistStore(store)\n    return window.store\n  }\n}\n```\nHope this helps someone!. ",
    "purnawirman": "@ypyang237 you helped me, i love you!. ",
    "ddaaggeett": "@ypyang237 - awesome putting autoRehydrate() inside compose()!\n@ucarion - nice issue - and should this be closed now?. ",
    "Phredward": "Hi.  I would like to restart my react-native app to apply a code-push update.  Right before I do this, I store state in redux, and it is not persisted (unless I wait, which is an acceptable workaround for now).\nI would be happy to check a variable in redux, call a method that tells me if my store is persisted, or have an alternative restart method that redux provides that finishes syncing and then restarts.\nThis raises another concern, what prevents a user from killing the app quickly after state is updated (besides the limits of human finger speed)?\n. ",
    "laclance": "I am experiencing some parts of state not getting perstsited. ",
    "priyesh9875": "One way is to create two reducers, say A(remember me) and B(temp).\nIf remember me is selected, then dispatch actions of reducer A, else dispatch actions of reducer B.\nAlso mention reducer B as blacklist in store config, so that it wont be persisted. ",
    "dwjohnston": "@priyesh9875  That's the solution I ended up going for. . If anyone is interested - here is Dan Abramov's solution - though it's not specific to redux-persist: \nhttps://stackoverflow.com/questions/35622588/how-to-reset-the-state-of-a-redux-store/35641992#35641992. ",
    "domlazic": "np, glad to help. Do you maybe have an idea when will you update the npm package to include this change? thanks!. ",
    "SleeplessByte": "@rt2zz cc @domlazic type definitions are not updated to reflect this change.. ",
    "wachunei": "@rt2zz It has still been happening. I'm guessing that API may be not available in every production environment and we can't rely on expecting that to be true, maybe can we use a polyfill as a dependency? . closed by #291 . @klasver I did exactly the same, in that case it seems like the best alternative is to not use PersistGate and render a component that renders a splash screen before hydration (checking state._persist.rehydrated) and then animate and render main navigation component. Have not tried to implement that yet though.. I kinda like the idea of option 2, but in that case, where the main components of the app go? I think is a little bit confusing.\nIn the same direction, we could achieve something like loading but with a render prop.\njsx\n  <Provider store={store}>\n    <PersistGate\n      persistor={persistor}\n      loading={({ hydrated, liftGate, ...otherProps }) => <MyAnimatedComponent hydrated={...} liftGate={...} />}\n    >\n      <MyAppGoesHere />\n    </PersistGate>\n  </Provider>\nI this case MyAnimatedComponent can start an animation on hydration and lift gate as it ends.\nPS: I really have no deep understanding of how possible to do is this, but I can dive in if this goes through. I get it now, I'd like to contribute on this . @rt2zz I'm sorry to bother with this question, but I was going to begin working on this when I ran into Metro Bundler does not support symlinks inside ./node_modules (I was using yarn link to link my local branch of redux-persist to a RN test app). \nSo I've decided to move on to a create-react-app app. After linking the package I realized it has an entry point that only works after build (lib), but I started working on src files. What's your development setup? Am I doing something wrong or missing something in order to grab modules from src instead of built files?\nThanks!\n. I will try with those options, thanks!\nWould it work to have an entry point that imports from src or lib depending on dev environment variable?\nOn Feb 4, 2018, 2:35 PM -0300, Zack Story notifications@github.com, wrote:\n\n@wachunei there are a few ways to do it. In my case with react native I always do one of the following (depending on the scale of changes):\n\nin your app import from src (e.g. import { persistStore } from 'redux-persisit/src') then edit the files in place and when you are done you copy the files back into your local git repo.\nuse wml for create a \"hardlink\" alternative to yarn link.\n\nBoth options are a bit tedious :/\nOr if you use create-react-app then yarn link should work but you need to be sure to build after every change. i.e. literally run yarn build. You can run the build in watch mode for convenience: yarn build:es --watch but be sure to run the right build for your environment (i.e. es vs lib)\nNow that I write this out I realize how frustratingly complex it is!\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub, or mute the thread.\n. I spent last few hours trying to make this work, this is what I got: \n\n\nThe code for the end user would be basically changing this\njsx\n<Provider store={store}>\n  <PersistGate loading={ /* loading component */ } persistor={persistor}>\n    <App />\n  </PersistGate>\n</Provider>\nto\njsx\n<Provider store={store}>\n  <PersistGate persistor={persistor}>\n    {bootstraped => (\n      // custom component \n    )}\n  </PersistGate>\n</Provider>\nin the previous gif case it was:\njsx\n<Provider store={store}>\n  <PersistGate persistor={persistor}>\n    {bootstraped => (\n      <AnimatedGate bootstraped={bootstraped}>\n        <App />\n      </AnimatedGate>\n    )}\n  </PersistGate>\n</Provider>\nOn the source the changes are 5 lines in PersistGate component, what do you think?\nhttps://github.com/wachunei/redux-persist/commit/608c4ea46ce6bf06fc7a88c9cc18a6046746c286. Things missing in this PR that I'd like to include:\n\nTest: this feature is not tested, maybe a render test should be enough?\nUpdate docs of PersistGate\nGenerate build files: is this needed to be done? I don't know what's the workflow for releasing\n\nAnd as a general feedback: It was not easy to find out the best way to set up a dev environment, maybe I could work on documentation on how to make it, as a little guide for other users, most importantly mentioning yarn link won't work on RN. \nLet me know any about these, I'm happy to help.. ",
    "marcinkornek": "The same happened for me with react-native 0.42.0. When I tried to purge array of keys it showed me Cant find variable: Reflect error.\n. ",
    "modosc": "i wrote a fake local storage implementation that can be passed in as config.storage if enableLocalForage is false - this at least avoids all the errors / warnings that get spewed out. . we're using both localForage and redux-persist-cookie-storage - things that are required for SSR go into cookies, everything else goes into localForage. our localForage stores are 10x the size of our cookie stores - automatically adding those to cookies may not be ideal (and may also quickly hit the cookie size limit). . update: i published https://github.com/modosc/redux-persist-memory-storage as  a general purpose solution - we've had to use this pattern for clients with cookies or localstorage disabled. . ",
    "c-h-": "@modosc awesome thanks for sharing!!. ",
    "dviry": "Just wondering - looking one step back - wouldn't localForage by itself fail when localStorage is not available and simply go to the next driver? Wouldn't just defining memoryStorage as the fallback driver solve those issues (and still be within localForage functionality)?\nPS: we could also simply extend isLocalStorageValid to actually try to call .setItem() and thus invalidate localStorage in case of Safari (or any other) errors.. ",
    "gemma-ferreras": "@rt2zz yes I figured up. It mas my mistake, I was using the persistStore wrong. thanks :) . ",
    "StevenConnors": "@gemma-ferreras Could you explain how you were using it incorrectly? I'm stuck on the same issue.. Just re-read the docs - I guess for ReactNative we need to specify which storage engine we're going to be using; in my case AsyncStorage. So I just changed my \npersistStore(store)\nto \npersistStore(store, {storage: AsyncStorage})\nthen its all good.. ",
    "brascene": "Thanks!\nJust quick tip, check if you've imported AsyncStorage or AsynchStorage :D. ",
    "lokhmakov": "At now only way I see to use transforms and pass to it store.getStore, because in outbound part of transform u dont have current store state.\nMay be ask PR extend transform outbound call to (outboundState, key, state) => {}. @isaachinman U write that ability to blacklist nested reducers need to be available out of the box, without external deps. But it's available without external deps - using transforms.\nAnd in previous message I describe limitation of this method. . I want this functionality too.\nAt now I use something like this:\ncreateTransform(\n  (inboundState, key) => {\n    return {\n      ...inboundState,\n      SessionLogin: {\n        values: {\n          username: _.get(inboundState, `SessionLogin.values.username`)\n        }\n      },\n    }\n  },\n  (outboundState, key) => {\n    return _.merge({ ...store.getState().form }, outboundState)\n  },\n  { whitelist: [`form`] }\n)\n. I can implement external module for this functionality. But I need:\n\nAccess to current state in outbound transformation. This issue I currently resolve taking from store, but redux best practice said dont do it! )\nAccess to storage in inbound transform, for understand which nested keys present and dont destroy them. And how I understand this is more complicated, because access to storage is async, but outbound transformation is sync. \n",
    "isaachinman": "@lokhmakov Sorry, I don't understand what you mean at all. Blacklisting should happen at the time of calling persistStore in your store creation. There's no need to do things conditionally on store state... state does not matter and the architecture is (presumably) predictable.. If the store's architecture is predictable, I would think it'd be trivial to support stuff like:\npersistStore(store, { blacklist: ['something.nested_reducer'] })\n\nIf you think so, I can look into a PR. Otherwise I'll find another way for my personal use case.. Okay, let's see if @rt2zz would accept a PR.. @rt2zz Since time is limited in my current build, I've bitten the bullet and simply split my store into two objects, persistable and non_persistable at the top-most level. If someone wrote an easy-to-use transform that doesn't depend on Lodash, I'd probably use it.. ",
    "braco": "Agree this module needs more support for the reducer.key format, but there's another problem with ['something.nested_reducer']: . is a valid key name:  { \"foo.bar\": \"value\" }\n. Set the store's value to {}?\n. ",
    "wellyshen": "@zalmoxisus I have tried to use the following types of code, the result is wired.\nType 1 : If I remove the autoRehydrate(), hot reloading can work\n```javascript\n/ @flow /\nimport { AsyncStorage } from 'react-native';\nimport { createStore, applyMiddleware } from 'redux';\nimport { composeWithDevTools } from 'remote-redux-devtools';\nimport thunk from 'redux-thunk';\nimport { persistStore, autoRehydrate } from 'redux-persist';\nimport rootReducer from '../reducers';\nexport default (onComplete?: () => void): any => {\n  // const composeEnhancers = composeWithDevTools({ shouldHotReload: false });\n  const store = createStore(rootReducer, composeWithDevTools(\n    applyMiddleware(thunk),\n    autoRehydrate(),\n  ));\nif (module.hot) {\n    // $FlowFixMe\n    module.hot.accept(() => {\n      const nextRootReducer = require('../reducers').default;\n      store.replaceReducer(nextRootReducer);\n    });\n  }\npersistStore(store, { storage: AsyncStorage }, onComplete);\nreturn store;\n};\n```\nType 2 : Hot reloading totally can't work, even I remove the autoRehydrate(). And I press cmd + R the redux state won't be updated on iOS simulator\n```javascript\n/ @flow /\nimport { AsyncStorage } from 'react-native';\nimport { createStore, applyMiddleware } from 'redux';\nimport { composeWithDevTools } from 'remote-redux-devtools';\nimport thunk from 'redux-thunk';\nimport { persistStore, autoRehydrate } from 'redux-persist';\nimport rootReducer from '../reducers';\nexport default (onComplete?: () => void): any => {\n  const composeEnhancers = composeWithDevTools({ shouldHotReload: false });\n  const store = createStore(rootReducer, composeEnhancers(\n    applyMiddleware(thunk),\n    autoRehydrate(),\n  ));\nif (module.hot) {\n    // $FlowFixMe\n    module.hot.accept(() => {\n      const nextRootReducer = require('../reducers').default;\n      store.replaceReducer(nextRootReducer);\n    });\n  }\npersistStore(store, { storage: AsyncStorage }, onComplete);\nreturn store;\n};\n```\nType 3 : Hot reloading can't work and I press cmd + R the redux state won't be updated on iOS simulator\n```javascript\n/ @flow /\nimport { AsyncStorage } from 'react-native';\nimport { createStore, applyMiddleware } from 'redux';\nimport thunk from 'redux-thunk';\nimport { persistStore, autoRehydrate } from 'redux-persist';\nimport rootReducer from '../reducers';\nexport default (onComplete?: () => void): any => {\n  const store = createStore(rootReducer, applyMiddleware(thunk), autoRehydrate());\nif (module.hot) {\n    // $FlowFixMe\n    module.hot.accept(() => {\n      const nextRootReducer = require('../reducers').default;\n      store.replaceReducer(nextRootReducer);\n    });\n  }\npersistStore(store, { storage: AsyncStorage }, onComplete);\nreturn store;\n};\n```\nType 4 : Hot reloading can't work and I press cmd + R the redux state can be updated on iOS simulator\n```javascript\n/ @flow /\nimport { AsyncStorage } from 'react-native';\nimport { createStore, applyMiddleware } from 'redux';\nimport thunk from 'redux-thunk';\nimport { persistStore } from 'redux-persist';\nimport rootReducer from '../reducers';\nexport default (onComplete?: () => void): any => {\n  const store = createStore(rootReducer, applyMiddleware(thunk));\nif (module.hot) {\n    // $FlowFixMe\n    module.hot.accept(() => {\n      const nextRootReducer = require('../reducers').default;\n      store.replaceReducer(nextRootReducer);\n    });\n  }\npersistStore(store, { storage: AsyncStorage }, onComplete);\nreturn store;\n};\n```. Any suggestion for this issue?. @rt2zz Nice Man ;). ",
    "martinezguillaume": "I have this problem too !\nWhen I'm using hot reload, my redux state is not save, any solution ?. ",
    "jephjohnson": "Thanks, @rt2zz - I removed the action, however I am still receiving the same error. I changed \" componentWillMount()\" to \"componentDidMount()\" However I am receiving the same issue.\n\n. Solid! That solved the warning. The \"persist/REHYDRATE\" action is being fired before my \"FETCH_TWEETS_FULFILLED\" actions still. Any thoughts? I've been racking my head on this for the last 24hours.. Oh my, solved it. Sorry to clog up with an issue not related :/\n in my \"case \"FETCH_TWEETS_FULFILLED\"\nI had \"tweets: action.payload\" when it should be \"tweets: [...state.tweets, action.payload]\". ",
    "atasmohammadi": "Thanks for your reply. I'm sorry i forgot to close this as the problem was not the redux-persist. . In my case, the problem was from my side.. @franrios it was about Loops. the loop was skipping to next item in the loop, before the operations on the last item finishes.. ",
    "sroze": "@ataomega what was it? :). ",
    "marklawlor": "This bug was reintroduced again in v4.4.0\nhttps://github.com/rt2zz/redux-persist/commit/dbbb132d0dfca96d3a114b7bae05bf4bc0be7da2#diff-c627ce0fe5832d82e77118c76c47f8f2R8\nAlso I don't think Noop is the correct type definition for keys. But I'm very new to redux-persist and unsure what it should be.. ",
    "robmoorman": "I've implemented the idea @rt2zz earlier and it's working quite well (it passes security audits). For iOS we use a passphrase stored in the KeyChain on Android on KeyStore. With that passphrase we encrypt/decrypt data via redux-persist.\nTwo things to keep in mind\n crypto-js is slow, especially with huge data sets stored on device, a off js thread will be cool to have\n lock/reboot iOS locks the keychain, you need to adjust settings to make the keychain available on any time (otherwise your app won't be able to decrypt the data on the background (e.g. via a geofence event or background-fetch execution time process)\nPlanning to make this mechanism open-source, as it's battle tested for some months now in different production apps.\n. Hi @rt2zz it's an addition to https://github.com/maxdeviant/redux-persist-transform-encrypt as the secretKey comes from the KeyChain/KeyStore (auto-generated by the device), so it's not stored in the JS bundle on device.\nThere is a setting for iOS, yes. To adjust that the keychain can be accessed in this case.\nI used this, but you can see what the settings is like: https://github.com/oblador/react-native-keychain/blob/master/RNKeychainManager/RNKeychainManager.m#L85\nMore info here: https://developer.apple.com/reference/security/ksecattraccessiblealways\nI'll inform you when this package is ready (need it for a project right now, so planning to make it open-source).\n. He @patrickkempff haven't got the time (yet) to work on this. You can watch my eact-native-redux-secure-storage repo, I'll place it over there.. ",
    "enahum": "@robmoorman any progress on your project?. Yes I also have a multi-level tree like\njs\nentities: {\n   users: {},\n   posts: {},\n   typing:{},\n   ...\n},\nrequests: {...}\nHow can I just blacklist entities.typing?. Yeah I think im going to go with the filter. Thanks. ",
    "patrickkempff": "@robmoorman i am also interested in your approach. Any possibilies you can share some more information? \ud83d\udc4d  . Here is a very simple implementation using react-native-keychain:\nhttps://gist.github.com/patrickkempff/86f44f017568a973f5c041b205e4365c. ",
    "phillbaker": "I missed it the first time I read the readme, but if you're on react native redux-persist-sensitive-storage also looks like a good candidate.. ",
    "taranda": "@robmoorman Have you had a chance to open source your react-native-redux-secure-storage?. ",
    "vidhyeshpatil": "I need to encrypt all my reducers using redux-persist (in that I am using persist-store) in which all my data is stored in browser local-storage. When I see my browser local-storage, I should able to see my data encrypted, once it gets passed from persist-store and stored into local-storage.\nCan you please help me with some examples.. ",
    "dwilt": "@rt2zz thanks for the feedback. I ended up using the redux-persist-transform-filter and followed the advice that the creator gave and ended up with this:\n``js\nconst persitingReducers = createFilter(purchases.list`\n);\npersistStore(store, {\n    storage: AsyncStorage,\n    transforms: [\n        persitingReducers\n    ]\n});\n```. @icesyc \n\nmove loading states into its own reducer which is not persisted. This sounds weird at first but can actually work really well, especially for dynamic content. reselect should make it easy and efficient to recombine the loading state with its content.\n\nThis is what i've been doing and it's been working really well for me in my projects. It keeps the UI state separate from the business data and allows for a better organization. ",
    "icesyc": "@dwilt it does not work for me.. ",
    "elquimista": "@dwilt @icesyc \nWith redux-persist v5, transforms should be passed to persistConfig parameter of either persistCombineReducers or persistReducer. Like this:\n```js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux';\nimport { persistStore, persistCombineReducers } from 'redux-persist';\nimport { createWhitelistFilter } from 'redux-persist-transform-filter';\nimport { PersistGate } from 'redux-persist/es/integration/react';\nimport storage from 'redux-persist/es/storage';\nimport reducers from './reducers';\nimport Router from './Router';\nconst persistConfig = {\n  storage,\n  key: 'root',\n  transforms: [\n    createWhitelistFilter('router', []),\n    createWhitelistFilter('form', [])\n  ]\n};\nconst reducer = persistCombineReducers(persistConfig, reducers);\nconst store = createStore(reducer);\nconst persistor = persistStore(store);\nconst App = () => (\n  \n\n\n\n\n);\nReactDOM.render(, document.getElementById('root'));\n```. ",
    "bulby97": "@rt2zz Awesome ! \nMy top level reducer was not immutable at all. I did it and now everything works, thank you !. ",
    "MaxiSantos": "@bulby97 how did you fix the issue? I didn't understand.. I think you should. Similar behaviour I've seen in a react-native library to store data. If lastest version is 3 and user has version 1, then when user update the app he will have version 3 and that library will execute the migration... from 1 to 2 and then from 2 to 3 (the latest version)\nI think that would happen here too.. @mohammad1990 where does the createpersistor comes from? I've found that depending on the library it may return different persistor without the subscribe method. ",
    "jamesisaac": "Hmm, I thought it might not be due to the size limit, as from my (limited) understanding, if JSON.stringify(payload).length gives 2368916, then the size being stored is about 2.4MB (1 byte per char?), so under Android's limit of 6MB?\nBut if this sounds exactly like the storage limit problem, no worries, I will look into some of the solutions specific to that limitation.. Ahhh, I've just realised that it might be to do with the development platform I'm using (Exponent) running multiple apps from the same host app.  So I guess that 6MB storage limit might be shared among all of their saved data.  Will investigate further.. ",
    "jorge627": "Hi\nI have exactly the same problem, I'm trying to store a lot of data from a server locally in device.\nredux-persist/getStoredState: Error restoring data for key: pos Error: Couldn't read row 0, col 0 from CursorWindow.  Make sure the Cursor is initialized correctly before accessing data from it.\nCouldn't read row 0, col 0 from CursorWindow.  Make sure the Cursor is initialized correctly before accessing data from it.\nError: Couldn't read row 0, col 0 from CursorWindow.  Make sure the Cursor is initialized correctly before accessing data from it.\nI've tried things like this in MainApplication.java - onCreate method:\n long size = 50L * 1024L * 1024L; // 50 MB \n com.facebook.react.modules.storage.ReactDatabaseSupplier.getInstance(getApplicationContext()).setMaximumSize(size)\nbut it doesn't work for me\n@jamesisaac could you solve it ??\nthanks in advance . ",
    "johnwayner": "I'm having a similar issue.  I suspect we are hitting the max sqlite cursor window size on Android which is 2MB:  http://stackoverflow.com/questions/21432556/android-java-lang-illegalstateexception-couldnt-read-row-0-col-0-from-cursorw\n. @kenma9123 That's the assumption I'm working under. I have a data dump from a user that clearly demonstrates that the limit ( at least on their device) is 2MB. \nI'll be adding code to delete old data. If that doesn't keep key data under the limit, then I'll be splitting up my larger keys. It will result in more cross talk between reducers, which is unfortunate.. ",
    "kelset": "I just had the same issue and @robwalkerco 's lib fixed it - thanks a lot man!\n(btw I think this issue can be closed..?). Hi folks, can I revive this issue by asking if there is any update on how to migrate?\nBecause it looks like the migration guide that was present in the README and linked by @rt2zz earlier is now 404 \ud83d\ude05. Duplicate of https://github.com/rt2zz/redux-persist/issues/434 IMHO. ",
    "pjb3": "I'm running into the same problem that I believe @zuzuviewer is trying to describe, which is that I'd like to find a way make sure authRehydrate completes before my app is first rendered. Is that possible?. ",
    "zuzuviewer": "Yeah,it's what I want to say.Thank you very much @pjb3 .And I found a way to solve it,https://github.com/rt2zz/redux-action-buffer/blob/master/README.md#redux-persist-example.But I don't use it .Import a start page without any custom action which is my way  . ",
    "wZi": "Thank you, friend. This solve my problem.. ",
    "nicolabortignon": "Ok, let me see if I got this, \nwith autoRehydrate() the store is always rehydrated,\nto handle exclusion you can intercept the action 'REHYDRATE' on the reducer.\nif my reducer is called authentication, and the field I want to exclude is isAuthed, I should do something like**\n```\n    case REHYDRATE:\n      var incoming = action.payload.authentication // change here the name of your reducer\n      if (incoming) return {\n        ...state, \n        ...incoming, \n        isAuthed : state.isAuthed  // this is the important line.\n      }\n      return state\n```\nnoting that I do \nisAuthed : state.isAuthed\ninstead of \nisAuthed : false\nbecause I have no control on the sequence of other actions (and an authentication may have started before the rehydration is finished)\n. ",
    "rmevans9": "I think you could achieve this with this library: https://github.com/edy/redux-persist-transform-filter. ",
    "raarts": "The reducer should actually wait for 'persist/REHYDRATE'.. ",
    "HUIZHENG940722": "thanks\n. ",
    "designbyadrian": "What the heck, it seems I needed to troubleshoot for more than 30 minutes. This might be an invalid ticket. I'll get back to you when I'm sure. Sorry.. Stupid dev is stupid. Entirely my fault creating an infinite loop. It's very difficult detecting in tests, let alone output console logs from Jest's web workers!. ",
    "vjancik": "That (https://github.com/rt2zz/redux-persist/pull/300) makes it correct I believe.\nThe difference in behavior now is, that if there isn't a key in the inbound state for which the corresponding reducer mutated the state, that mutation will be discarded and instead the initial state will be used.\nWhich could happen if you added a new reducer to your store, along with a REHYDRATE action handler, but that reducer hasn't been persisted before.\n. The REHYDRATE reducer is supposed to implement a custom transform for the incoming serialized data.\nHowever, the way this reconciler is written, first come the conditions which \"skip\" rehydration for some reducers.\nThe first if, if true, skips rehydration.\nIf the REHYDRATE reducer took the incoming serialized state, and modified it, and inserted into the state, and we'd merge that into the new state by default, there would be no way to \"skip\" rehydration, and the first if would be rendered useless.\nEdit: First and second if\nhttps://github.com/rt2zz/redux-persist/blob/master/src/autoRehydrate.js#L53\nhttps://github.com/rt2zz/redux-persist/blob/master/src/autoRehydrate.js#L56\nThough this concern may not apply for the first if, you can imagine extra ifs like that could be added for additional invalidation logic, like versioning.. ",
    "Suresh-R-S": "@rt2zz  No even after reloading the app the status is same :(. @rt2zz I have tried with autoRehydrate too..\nautoRehydrate is to rehydrate the persisted store back right??\nWhen I include autoRehydrate the store seems to be persisted. But again, when I delete the localStorage values manually & the app reloads, the store seems to be not persisted. Not sure what is going wrong.. ",
    "scic": "I have the same error on a webpack production build. Minifying will rewrite that code as follows\nc=process\nwhich leads to a reference error (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Not_defined).\nThis access needs to be rewritten as:\ntypeof process !== 'undefined'. At the moment I provide the fake typings for react manually as a workaround:\n```\ndeclare var React;\n/ tslint:disable /\ndeclare module 'react' {\n  export interface ReactNode {}\n  export interface PureComponent {}\n}\n```. ",
    "phpsmarter": "Thank you , I found the problem,in Action ,nextTodoId isn't storage,when  I reopen the browser, nextTodoId  always is 0 ,there must have  two todos with same id.Can I solve this problem  with redux-persist?\nlet nextTodoId = 0 //how to restore this variable  when I reopen brower;\nexport const addTodo = (text) => ({\n  type: 'ADD_TODO',\n  id: nextTodoId++,\n  text\n}). And I change  method of  get ids.Seems solved problem?\nexport const addTodo = (text) => ({\n  type: 'ADD_TODO',\n  id: new Date().getTime().toString(),\n  text\n})\n. ",
    "cascornelissen": "@rt2zz, I would love an answer on this as I will have to write my own storage solution or submit a PR if this isn't supported in redux-persist. Thanks in advance!. @rt2zz, I'm trying to transform data via SubtleCrypto before storing it.\nI started working on something but haven't had the time to dive into it any deeper. You might want to give me some pointers/tips though, I've only implemented a working inbound transform so far: https://github.com/rt2zz/redux-persist/compare/master...cascornelissen:master. Given the fact that I want to use multiple storage engines based on the environment later on I'll go with option 1 for now. Could you let me know when this refactor is finished (and do you have any ETA)? I might want to submit a PR at that time to implement the Promise-based transforms if anyone's interested.\nFor the argument saying that it complicates the common case: I agree, maybe we could make this configurable behind a flag? But we'll see once your refactor is finished.. @CharlieHess, unfortunately not, some more important work came in but I love what you've been working on so far!. ",
    "vaukalak": "@rt2zz I think, that developer that uses that feature, will need to load data, he'll load just a part of the state. and yep, no persist actions to fragmented reducers should before user logins, or logout (which is logical). But I think, all that stuff should be considered on the application level. . Sorry, I'll rephrase. I mean it's a task of developer, who will use the lib to take care, that there no writes to reducer fragmented by user, and to load those reducers later.. @rt2zz did you have a chance to have a thought on that?. @rt2zz is there any chance, this will be reviewed?. @Andarist updated PR, removed _ in config keys.. @rt2zz @Andarist sorry for bumping, but do you have any questions / notes on that?. @ScreamZ I think this PR is good to close. @rt2zz can you please post duplicate your post in #637 . So we can discuss the desired api? thanks.. ",
    "ScreamZ": "Any news on that ?\nOr close it for #637 ?. @Andarist @vaukalak Any news on that people ? Now we are on V5 #637 among others need something like that ?. Hello @rt2zz , looks like it work nice on device.. Dunno really how, i'll make a PR in order to improve doc soon.\nI just got one problem now, when the app hot reload, or i just press \"Reload\" on my emulator, the app is stuck on the loader component of the PersistGate. The only thing I found to dodge the issue is cleaning the app from started apps and start it again... Any idea why ?\nDo you confirm me this is correct ?\n```js\n// ...\n  const store = createAppropriateStore(\n    persistReducer(ReduxPersistConfig, rootReducer),\n    compose(...enhancers)\n  );\n// kick off root saga\n  sagaMiddleware.run(rootSaga);\nexport default { persistor: persistStore(store), store };\n```\n```js\nimport{ persistor, store } from './thepreviousfile';\nclass App extends Component {\n  render() {\n    return (\n      \nLOADING} persistor={persistor}>\n          \n\n\n    );\n  }\n}\n```\nMy provider receive the store not updated, and persistgate receive the persited store .???. persistCombineReducers should, yes..... Nice explanations, really loved that.\nIt could go a little deep in a concept though, like the key that can be used to make a \"Vary\" on userId per example.\nAlso detailing each config props a bit further but also especially the api https://github.com/rt2zz/redux-persist/blob/master/docs/api.md : stateReconciler, throttle, keyPrefix, ...\nThanks anyway.\nSpread the love <3. @rt2zz Seems to work boss ! \nI have to adapt my code, I'll make a PR to share with the community too.. I'm encountering new issues, can we talk about it in the above PR ? Thanks. It should works, true :) Bug it could be nice to use the built-in method (see my PR #607) . @blackLearning\nI'll try your solution and will update my PR accordingly if it works for me :)\nThanks for the explanation :)\n. @blackLearning @rt2zz \nSeems good now, I updated readme accordingly to @blackLearning proposal.\nBest regards. By using different storage config i think it is: see Nested Persist or look the \"new doc\" with the PR #588 \nLooks also close to #637 that is still pending. Hello,\nit is not clear, I've already reported that.\nThis is the key used for the key/value storage in AsyncStorage.\nBy default if you let root you storage key will be persist:rootyou can change it to avoid conflicts for any case.. That's strange, I think it's because you've a corrupted storage, try to desinstall et reinstall the application (remove it, do not update). My bad, I'm used to think in the React Native way\u2026\nHappy to hear that's working again. I'm facing the EXACT same issue, i'm also looking for an answer... @rt2zz ? Any idea ?\nBest regards. @rt2zz @vaukalak\nCan we discuss about the API for that next to #320 ?. @piotr-cz This is not a solution because sometimes you're not online, you could also store offline data that serve as online cache purpose, there is no way to achieve that using backend.. It's a solution yes @piotr-cz, the thing is that my architecture was not thought such that way and i would like to avoid the heavy refactor... :p. @rt2zz Sorry for the poke but I think it's a real problem for a large number of apps that share sessions with user data. We just reset the cache using resettable reducers --' That's kind of workaround. ",
    "LuisRizo": "Same issue here. After logging in to my app, if I log out and refresh the app, I am still logged in. Maybe the persistStore doesn't update when we delete data?. ",
    "xiongxiong": "Same issue here. Only result of the first action is persisted, others not. Both in simulator and iPhone.. ",
    "Diwei-Chen": "Please see the discussion here:\nhttps://github.com/DesignmanIO/react-native-meteor-offline/issues/29. ",
    "smmoosavi": "please be better about this :D . ",
    "haukurk": "+1\n. ",
    "FilipMessa": "is there some example of custom REHYDRATE hadnler? . ",
    "Faolain": "@rt2zz any shot you can duplicate your post on #637 as vaukalak mentioned?\n. @demoran23 or @ScreamZ did you guys ever find a way around this? . @twhitacre how did you go about dynamically setting a different prefix-key?. ",
    "dreisel": "hey.\nany updates or estimation when it's going to be merged?\nare there any issues you need help with? I'll be happy to take a look.. ",
    "iamawebgeek": "@rt2zz please merge this one, if you agree this is a correct solution. I also need this. I think it would be nice to add it to persistor as a save() method. @drhorse please request for merge this PR. ",
    "doniyor2109": "+1. ",
    "drhorse": "Can we merge? I really need this feature. Thx. When user changes app display language, i can use this flush() and restart the app after it is done. As a short-term solution, I now write this language option separately to AsyncStorage, and restart the app. When app restarts, if this separate item exists, I user reducer again to update the store.... After user changes the language option, I'd like to wait till the language option is saved to store before I restart the app. So yes, I need it too.. ",
    "pgambling": "Any chance this will be merged soon?. ",
    "shirbr510": "so it seems that by using react-boilerplate the state was modified externally (they use immutable.js)\nyou can give it a short read here:\nhttps://github.com/react-boilerplate/react-boilerplate/issues/1492. ",
    "louis-pvs": "was hoping to have this as well, to filter dynamic sensitive keys in reducers.. ",
    "Tae69": "Sorry, problem is in my prop that is too large\nblacklisting fixed the problem. ",
    "toranb": "Fair question :) \nI'd like to improve this for browser only dev (like I'm facing today w/ emberJS). I've worked around it by doing a simple patch but wanted to see if we could ES6-ify this import to improve the experience for non react devs (assuming that is an option?). \njs\nvar global = {\n    setImmediate: window.setTimeout\n  }\nI'm open to be educated here - just curious how I can go about using this w/out hacks like you see above ^^. @rt2zz I've been able to work around this (to avoid the global hack mentioned above). So for now I'd say \"ignore me\" and I'll do my best to learn more about react native/ other (non ember) envs that the community is using this great library in :)\nIf you still want to hash out the change above I'm all ears - curious if others would find that useful. @rt2zz absolutely (no rush) - I hope the big take away here was \"someone not in the react/node ecosystem found a global that we assumed everyone already had by way of webpack\".\nThanks again! I'm really looking forward to using this library more as I learn \"how to offline\". @Andarist thanks for making the decision to support users w/out global.setimmediate. Just a quick update about the ember tool chain\nember-cli does use babel under the hood but without an explicit opt in this global was not working in my experience. I was also trying to keep the config minimal for ember users who adopt this + redux offline (so likely my fault for making that explicit decision).\nAll that said, I was able to work around the global issue by doing a rewrite at build time using broccoli (the file system build tool primitive underlying ember-cli)\nIt seems that when the next version is published I can throw this out because you \"fall back\" to setTimeout gracefully (given PR #336). Again, thanks for choosing to support users who are not on the usual React /Webpack tech stack :) I've really enjoyed using persist (and redux offline). Without great community libraries like this I'd be writing a lot more of the foundational code myself and very likely getting it wrong. Thank you !!!. ",
    "martinblampied": "Get an answer to this?. Thanks, will have a play. Also found: https://github.com/edy/redux-persist-transform-filter. ",
    "elado": "Yes. I reconfigured some parts and it works nicely:\n```js\n// reduxPersist.js\nimport _ from 'lodash'\nimport {\n  getStoredState as origGetStoredState,\n  createPersistor as origCreatePersistor,\n  createTransform,\n} from 'redux-persist'\n// define which keys to persist in local storage\nconst PERSIST_KEYS = [\n  'app.ui.filters',\n  'app.ui.currentBlah',\n]\nconst CONFIG = {\n  transforms: [createTransform(\n    (inboundState, key) => {\n      // pick only keys that are needed for persistence\n      const keys = PERSIST_KEYS.map(k => k.replace(new RegExp(^${_.escapeRegExp(key)}\\\\.), ''))\n      return _.pick(inboundState, keys)\n    }\n  )],\n  keyPrefix: reduxStore-v1:,\n}\nconst getStoredStatePromise = () => (\n  new Promise((resolve, reject) => {\n    origGetStoredState(CONFIG, (err, restoredState) => {\n      if (err) reject(err)\n      else resolve(restoredState)\n    })\n  })\n)\nexport const getStoredState = async () => {\n  const restoredState = await getStoredStatePromise()\n  return _.pick(restoredState, PERSIST_KEYS)\n}\nexport const createPersistor = store => origCreatePersistor(store, CONFIG)\n```\n```js\n// createStore.js\nimport { getStoredState, createPersistor } from './reduxPersist'\nexport default async function createCustomStore() {\n  // ...\n  const restoredState = await getStoredState()\n  _.merge(initialState, restoredState)\nconst store = createStore(..., initialState)\n  createPersistor(store)\nreturn store\n}\n```. ",
    "MichaelMure": "So ...\nI ended up doing this thing:\n``` javascript\n// @flow\nimport type { Storage } from 'redux-persist'\nexport default class LoginStorage {\n  _storage: Storage\n  _commonPrefix: string\n  _commonKeys: [string]\n  _dynPrefix: ?string\nconstructor(storage: Storage, commonKeys: [string], dynPrefix: string = '@garbage') {\n    this._storage = storage\n    this._commonPrefix = 'common:'\n    this._commonKeys = commonKeys\n    this._dynPrefix = '@' + dynPrefix + ':'\n  }\nset dynPrefix(dynPrefix: string) {\n    this._dynPrefix = '@' + dynPrefix + ':'\n  }\nsetItem (key: string, value: any, onComplete) {\n    return this._storage.setItem(this._mapKey(key), value, onComplete)\n  }\ngetItem (key: string, onComplete) {\n    return this._storage.getItem(this._mapKey(key), onComplete)\n  }\nremoveItem (key: string, onComplete) {\n    return this._storage.removeItem(this._mapKey(key), onComplete)\n  }\ngetAllKeys (onComplete) {\n    return this._storage.getAllKeys()\n      .then(keys => keys.map(\n          key => this._unmapKey(key)\n        ).filter(val => val !== null)\n      )\n      .then(results => {\n        if(onComplete) {\n          onComplete(null, results)\n        }\n      })\n  }\n_mapKey(key: string) : string {\n    return this._commonKeys.includes(key) ?\n      this._commonPrefix + key :\n      this._dynPrefix + key\n  }\n_unmapKey(key: string) : ?string {\n    if(key.startsWith(this._commonPrefix)) {\n      return key.slice(this._commonPrefix.length)\n    } else if(key.startsWith(this._dynPrefix)) {\n      return key.slice(this._dynPrefix.length)\n    }\n// Ignore other keys\nreturn null\n\n}\n}\n```\nIt wraps a storage to change on the fly the keys. It's used like this:\n``` javascript\nimport { asyncLocalStorage } from 'redux-persist/storages'\nexport default function configureStore(prefix) {\n  const store = createStore(rootReducer, undefined, enhancer);\nconst storage = new LoginStorage(\n    asyncLocalStorage,\n    ['identityList'],\n    prefix\n  )\npersistStore(store, {\n    blacklist: ['ui'],\n    transforms: [immutableTransform({records: allModels})],\n    storage: storage,\n    keyPrefix: ''\n  })\nreturn store\n}\n```\nThen you need a way to reload the store. It's king of brutal.\njavascript\nexport const changeStorePrefix = (prefix: string) => {\n  store = configureStore(prefix)\n  render(\n    <AppContainer key={prefix}>\n      <Root store={store}/>\n    </AppContainer>,\n    document.getElementById('root')\n  );\n}\nIt does work, but if someone has a better option .... Well ... not so strangely, creating another store has some weird side-effect, especially in react.\nWhat I really need is a way to force redux-persist to reload from the storage. Is there way to do that ?. I finally forked redux-persist to implement what I needed there.\nYou can have a look here: https://github.com/rt2zz/redux-persist/compare/master...MichaelMure:master\nThis is how I used it: https://github.com/MichaelMure/TotallyNotArbore/commit/9141bf6486e39fb206bf2140abb29ac4a0cc5ffa\n\u26a0 It's hacky, ugly and partially tested, and also break some parts of redux-persist because I didn't need them.\nBut maybe it's useful for someone ..... For the next person that deal with this problem: I found a much cleaner solution and dropped my fork entirely. I now have two redux store. One for the login screen and one for the application data, with some tricks in the react root to load the second store on demand. The login store is available when update are needed via a singleton. For more details, have a look here: https://github.com/MichaelMure/TotallyNotArbore/. ",
    "guoliang1206": "@rt2zz yes, I did. I have catch the action \"REHYDRATE\", and then I re-render the screen, show the home screen.  . ",
    "shaunrfield": "Cheers.  We have changed out package.json to specifically target 4.6.0 for now. . ",
    "bruno-barbosa": "@rt2zz 4.7.1 has solved the issue, thank you!. ",
    "Ashoat": "Awesome! When we can expect to see a new NPM package pushed? I'm getting Flow errors without this patch.. The \"in\" and \"out\" issues reported above have since been fixed, but there are extant Flow errors, discussed in #619. Seeing this issue too. @leggomuhgreggo the short of it is that you just need to make sure the REHYDRATE action is not in your list of actions.\nThe JSON file you're importing has an object with a preloadedState property that has your Redux state at the \"start\", and a payload property that has a list of actions that get applied to get the Redux store to the \"current\" state. But preloadedState doesn't have to be the initial Redux state, and in practice the full list of actions can be prohibitively long.\nThe solution here is simply to make sure your list of actions doesn't include a REHYDRATE action. Have your preloadedState start after the REHYDRATE action. Here is how I do it.. ",
    "Kliton": "Up.. ",
    "zacacollier": "@jorexe componentWillReceiveProps could be useful here. I was troubleshooting an issue where one of my components rendered before redux-persist had finished rehydrating the store.\nAssuming you're syncing the server with data from your component's props (via mapStateToProps), you could do something like what I did:\njavascript\n  ...\n  componentWillReceiveProps(nextProps) {\n    nextProps && (this.props = { ...nextProps });\n  }\n  ...\nIf you need even more fine-grained control, then you can leverage componentWillMount(), since it will fire immediately before render() is called.. ",
    "LuckyMona": "Do you find the solution? it occurred to me also. Can you please make it clearer about this part\uff1amoving all local state updating to componentWillReceiveProps function\uff1fI add the code below in my reducer.js as what rt2zz says in #126\uff0cbut it doesn't work\n```\nimport { REHYDRATE } from 'redux-persist/constants'\nfunction myReducer(state, action){\n//...\ncase REHYDRATE:\n   return {...state, ...action.payload.myReducer, rehydrated: true}\n//...\n```. Thanks very much for your detailed guidance\uff01 By the way, Could your web app work normal if you refreshed the page with \u201dF5\u201c ? Mine would get the initial state rather than the updated state\uff0cwhich rather confuse me.\n. ",
    "natashache": "@LuckyMona Yes mine is working now. The problem seems to be that some components get rendered before the state is rehydrated. So they are not receiving the props. I followed the solution in #126 and moved all local state updating to componentWillReceiveProps function and it worked.. @LuckyMona Here's my root component. It shows \"loading\" on page until rehydration is complete. That's what did the trick for me.\n```\nconst store = createStore(\n  rootReducer,\n  {},\n  compose(\n    applyMiddleware(thunkMiddleware),\n    autoRehydrate()\n  )\n)\nexport default class App extends Component {\n  constructor() {\n    super()\n    this.state = {\n      rehydrated: false\n    }\n  }\ncomponentWillMount(){\n    const persistor = persistStore(store, {storage: localForage}, () => {\n      this.setState({ rehydrated: true })\n    })\n  }\nrender() {\n    if(!this.state.rehydrated) {\n      return Loading...\n    }\n    return (\n      \n\n\n    )\n  }\n}\n```\n. ",
    "Viral-Inc": "I'm basically wondering the same thing / having a hard time ):\nedit: i used context.store and it worked. @FoxxMD me using context is kind of shameful too, but, basically I declared store as a contextType on a Purge class component:\n```\nimport React, {Component} from 'react'\nimport {persistStore} from 'redux-persist'\nimport './purge.css'\nimport PropTypes from 'prop-types'\nclass Purge extends Component {\nhandleSubmit = (e) => {\n    e.preventDefault();\n    persistStore(this.context.store).purge()\n  };\nrender() {\n    return (\n      \n\n\n\n\n\n\n    )\n  };\n}\nPurge.contextTypes = {\n  store: PropTypes.object\n};\nexport default Purge\n```. ",
    "FoxxMD": "@Viral-Inc can you expand on that please? Right now I'm setting the persistor as a global variable on window and it feels shameful.. @sincerekamal version 4 of redux-persist works with react-boilerplate. For my build\n using redux-persist@4.10.2 (documentation)\n using immutable store so redux-persist-immutable@4.3.1\nRelevant code in store.js\n```js\nimport { persistStore, autoRehydrate } from 'redux-persist-immutable';\nimport localForage from 'localforage';\n// ...\nconst enhancers = [\n  applyMiddleware(...middlewares),\n  autoRehydrate(),\n ];\n// ...\nconst store = createStore(\n    createReducer(),\n    fromJS(initialState),\n    composeEnhancers(...enhancers)\n  );\nwindow.persistor = persistStore(store, { storage: localForage, whitelist: [/app-specific keys/] }, (a, b) => {\n     console.log('Redux-Persist loaded state');\n   });\nstore.runSaga = sagaMiddleware.run;\n store.injectedReducers = {};\n store.injectedSagas = {};\n// ...\n```\nI have more related code but its app-specific. That should be enough to get it working.\nEDIT: I assign it to windows.persistor because I want to stop persisting/purge based on user actions later in the app and I couldn't find an easier way to access the persistor. works fine when assigned to window. localforage was my choice for storage engine yes, but any of the options from the docs can be used.\nRedux Persist 5 is a mess. The majority of issues on this repo were created after the release of v5. And no real commits addressing issues have been made since at least June 2018. I tried migrating to v5 on release it was never worked.\nI would suggest you stick to the version I mentioned in my comment unless there is something specific you need with v5.. Here's documentation for 4.10.2. ",
    "franrios": "Same issue here. @ataomega could you please tell us more about your problem?. ",
    "Lucretiel": "Ah, I didn't realize that getAllKeys could be async. . ",
    "deldreth": "I can confirm that this affects all of webpack 2+. ",
    "jmeiss": "Hi,\nI'm facing the same issue. Have you found any solution?\nThanks. ",
    "AleXzpm": "Also facing this issue.. ",
    "OlegBrazhnichenko": "After mapStateToProps your user should be in props\nIn render function you can get your user by :\nconst {user} = this.props; \nand than just use it like :\nuser ? ( <Redirect to=\"/dashboard\"/> ) : ( <LoginPage/> ). ",
    "jonatansberg": "What's the status on this? Would love to see sync storage support soon as it would eliminate most of my hard to solve rehydration headache :) \nAlso, seems that a comma is missing on line 14 in syncStorage.js.. ",
    "fsarachu": "Same issue here! By now I solve this handling the REHYDRATE action type in the nested reducers that I wanna blacklist. In the action handler I just return the received state, ignoring the rehydration.\nEDIT: Seems to be that this filter transform does the trick. However, it would be cool to support nested white/blacklists using something like dot notation or something.... \nWriting whitelist: ['appReducers.jobs', ...] would be awesome.. ",
    "antondomratchev": "@rt2zz We have the exact same use case for this feature, this would be very nice to have in the package.. ",
    "mnquintana": "@rt2zz \ud83d\udc4b  Just checking in - now that v5's out, what do you think would be the best approach for supporting async transforms now?. ",
    "sebastian-schlecht": "any progress on this?. ",
    "n-sviridenko": "Any news on this? We want to use it this way: https://github.com/maxdeviant/redux-persist-transform-encrypt/issues/33. ",
    "pitops": "Guys I really need this, any progress on merging?. ",
    "RemeJuan": "@redgenie I was having that same issue now myself, and fortunately my application is quite simple. I managed to resolve it using the more manual approach of using the 'per reducer' method to rehydrate.. ",
    "glowind": "Hi TheoMer, I had a similar issue when refreshing the browser. It was because the component render before the rehydratation was complete. Maybe you need to delay the render:\nhttps://github.com/rt2zz/redux-persist/blob/master/docs/recipes.md\nThis helped me with that, I put the persistStore in my main component:\ncomponentWillMount() {\n        persistStore(store, {}, () => {\n            this.setState({rehydrated: true})\n        })\n    }\nThis will ensure that the component re render when the store is rehydrated.. ```\nAnd do I need to do something like the following in each of my components to ensure that state is persisted, or is persistStore(store, {storage: localForage}); specified in my store.js enough?:\ncomponentWillMount () {\n    persistStore(this.props.store, {storage: Localforage}, () => {\n      this.setState({ rehydrated: true })\n    })\n  }\n```\nI only put that in my main component, the router:\n```\ncomponentWillMount() {\n        persistStore(store, {}, () => {\n            this.setState({rehydrated: true})\n        })\n    }\nrender() {\n        if (!this.state.rehydrated) {\n            return Loading...\n        }\n        return ( \n            \n\n\n\n\n\n\n\n\n        );\n    }\n```. I guess it's because the asynchro nature of the Rehydration. The component render before the Rehydration is complete.\nhttps://github.com/rt2zz/redux-persist/blob/master/docs/recipes.md. ",
    "abser": "For me below works fine.\n\nConfigure store\nimport store before in ReactDom.Render\npersist the store, after rehydration I am rendering dom.\n\n```\n...................\nimport configureStore from './store';\nimport {persistStore, autoRehydrate} from 'redux-persist'\nconst store =  configureStore();\npersistStore(store, {}, () => {\n  ReactDOM.render((\n    \n\n\n\n\n  ), document.getElementById('root'));\n  registerServiceWorker();\n})\n```. ",
    "ghostec": "@glowind Sorry, I forgot to mention. I'm handling rehydration issues. My main component is some sort of a router where I postpone any rendering if props.storage.rehydration is false (a reducer as you might guess). So, when my componentDidMount calls a dispatch, I know for sure that my store was rehydrated. (Or for some reason a race condition might happen??). ",
    "bradennapier": "You added a \"module\" key to the package.json which breaks it in the browser as it does not have all the es6 functionality.. Ugh - please remove the module key from package.json - it breaks everythign with illegal invocation... every time i install something it breaks again.. json\n  \"typings\": \"lib/index.d.ts\",\n  \"module\": \"es/index.js\",\nthe es/index.js breaks the entire process . ",
    "THernandez03": "Same here... after Webpack3 release,. Digging into the problem i see the following code using eval as webpack.devtool\n\nI ran the following code and get the same error.\njavascript\nfoo = { bar: setTimeout }\nfoo.bar(function(){ console.log('baz'); })\n// Throws: Uncaught TypeError: Illegal invocation at <anonymous>:3:5\nSo if you give it a context like window or null even undefined it works.  But if you leave the context of an object it fails. . Also could be related to this\nhttps://github.com/webpack/webpack/issues/5074. I think is a webpack bug, because following the TC39 spec, the top level context should be undefined\n. check this out... its a new issue with a more information\nhttps://github.com/webpack/webpack/issues/5111. To make it work and stick to the spec, you should put module.strictThisContextOnImports: true on your webpack config.\nI think could be a great idea, adjust the code to this repo to make it compatible without this option. thanks a lot. ",
    "evestraw": "this is the file es/defaults/asyncLocalStorage;\nin the bundle the export default gets exported without an identifier. \n```var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\nimport setImmediate from '../utils/setImmediate';\nvar noStorage = function noStorage() {\n  / noop /return null;\n};\nif (process.env.NODE_ENV !== 'production') {\n  noStorage = function noStorage() {\n    console.error('redux-persist asyncLocalStorage requires a global localStorage object. Either use a different storage backend or if this is a universal redux application you probably should conditionally persist like so: https://gist.github.com/rt2zz/ac9eb396793f95ff3c3b');\n    return null;\n  };\n}\nfunction _hasStorage(storageType) {\n  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || !(storageType in window)) {\n    return false;\n  }\ntry {\n    var storage = window[storageType];\n    var testKey = 'redux-persist ' + storageType + ' test';\n    storage.setItem(testKey, 'test');\n    storage.getItem(testKey);\n    storage.removeItem(testKey);\n  } catch (e) {\n    if (process.env.NODE_ENV !== 'production') console.warn('redux-persist ' + storageType + ' test failed, persistence will be disabled.');\n    return false;\n  }\n  return true;\n}\nfunction hasLocalStorage() {\n  return _hasStorage('localStorage');\n}\nfunction hasSessionStorage() {\n  return _hasStorage('sessionStorage');\n}\nfunction getStorage(type) {\n  if (type === 'local') {\n    return hasLocalStorage() ? window.localStorage : { getItem: noStorage, setItem: noStorage, removeItem: noStorage, getAllKeys: noStorage };\n  }\n  if (type === 'session') {\n    return hasSessionStorage() ? window.sessionStorage : { getItem: noStorage, setItem: noStorage, removeItem: noStorage, getAllKeys: noStorage };\n  }\n}\nexport default function (type, config) {\n  var storage = getStorage(type);\n  return {\n    getAllKeys: function getAllKeys(cb) {\n      return new Promise(function (resolve, reject) {\n        try {\n          var keys = [];\n          for (var i = 0; i < storage.length; i++) {\n            keys.push(storage.key(i));\n          }\n          setImmediate(function () {\n            cb && cb(null, keys);\n            resolve(keys);\n          });\n        } catch (e) {\n          cb && cb(e);\n          reject(e);\n        }\n      });\n    },\n    getItem: function getItem(key, cb) {\n      return new Promise(function (resolve, reject) {\n        try {\n          var s = storage.getItem(key);\n          setImmediate(function () {\n            cb && cb(null, s);\n            resolve(s);\n          });\n        } catch (e) {\n          cb && cb(e);\n          reject(e);\n        }\n      });\n    },\n    setItem: function setItem(key, string, cb) {\n      return new Promise(function (resolve, reject) {\n        try {\n          storage.setItem(key, string);\n          setImmediate(function () {\n            cb && cb(null);\n            resolve();\n          });\n        } catch (e) {\n          cb && cb(e);\n          reject(e);\n        }\n      });\n    },\n    removeItem: function removeItem(key, cb) {\n      return new Promise(function (resolve, reject) {\n        try {\n          storage.removeItem(key);\n          setImmediate(function () {\n            cb && cb(null);\n            resolve();\n          });\n        } catch (e) {\n          cb && cb(e);\n          reject(e);\n        }\n      });\n    }\n  };\n}. i am using webpack, the module generated from this file looksl ike this\n/ 480 /\n/***/ (function(module, webpack_exports, webpack_require) {\n\"use strict\";\n/ WEBPACK VAR INJECTION /(function(process) {/ harmony import / var WEBPACK_IMPORTED_MODULE_0__utils_setImmediate = webpack_require(483);\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\nvar noStorage = function noStorage() {\n  / noop /return null;\n};\nif (process.env.NODE_ENV !== 'production') {\n  noStorage = function noStorage() {\n    console.error('redux-persist asyncLocalStorage requires a global localStorage object. Either use a different storage backend or if this is a universal redux application you probably should conditionally persist like so: https://gist.github.com/rt2zz/ac9eb396793f95ff3c3b');\n    return null;\n  };\n}\nfunction _hasStorage(storageType) {\n  if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== 'object' || !(storageType in window)) {\n    return false;\n  }\ntry {\n    var storage = window[storageType];\n    var testKey = 'redux-persist ' + storageType + ' test';\n    storage.setItem(testKey, 'test');\n    storage.getItem(testKey);\n    storage.removeItem(testKey);\n  } catch (e) {\n    if (process.env.NODE_ENV !== 'production') console.warn('redux-persist ' + storageType + ' test failed, persistence will be disabled.');\n    return false;\n  }\n  return true;\n}\nfunction hasLocalStorage() {\n  return _hasStorage('localStorage');\n}\nfunction hasSessionStorage() {\n  return _hasStorage('sessionStorage');\n}\nfunction getStorage(type) {\n  if (type === 'local') {\n    return hasLocalStorage() ? window.localStorage : { getItem: noStorage, setItem: noStorage, removeItem: noStorage, getAllKeys: noStorage };\n  }\n  if (type === 'session') {\n    return hasSessionStorage() ? window.sessionStorage : { getItem: noStorage, setItem: noStorage, removeItem: noStorage, getAllKeys: noStorage };\n  }\n}\nfunction (type, config) {\n  var storage = getStorage(type);\n  return {\n    getAllKeys: function getAllKeys(cb) {\n      return new Promise(function (resolve, reject) {\n        try {\n          var keys = [];\n          for (var i = 0; i < storage.length; i++) {\n            keys.push(storage.key(i));\n          }\n          webpack_require.i(WEBPACK_IMPORTED_MODULE_0__utils_setImmediate[\"a\" / default /])(function () {\n            cb && cb(null, keys);\n            resolve(keys);\n          });\n        } catch (e) {\n          cb && cb(e);\n          reject(e);\n        }\n      });\n    },\n    getItem: function getItem(key, cb) {\n      return new Promise(function (resolve, reject) {\n        try {\n          var s = storage.getItem(key);\n          webpack_require.i(WEBPACK_IMPORTED_MODULE_0__utils_setImmediate[\"a\" / default /])(function () {\n            cb && cb(null, s);\n            resolve(s);\n          });\n        } catch (e) {\n          cb && cb(e);\n          reject(e);\n        }\n      });\n    },\n    setItem: function setItem(key, string, cb) {\n      return new Promise(function (resolve, reject) {\n        try {\n          storage.setItem(key, string);\n          webpack_require.i(WEBPACK_IMPORTED_MODULE_0__utils_setImmediate[\"a\" / default /])(function () {\n            cb && cb(null);\n            resolve();\n          });\n        } catch (e) {\n          cb && cb(e);\n          reject(e);\n        }\n      });\n    },\n    removeItem: function removeItem(key, cb) {\n      return new Promise(function (resolve, reject) {\n        try {\n          storage.removeItem(key);\n          webpack_require.i(WEBPACK_IMPORTED_MODULE_0__utils_setImmediate[\"a\" / default /])(function () {\n            cb && cb(null);\n            resolve();\n          });\n        } catch (e) {\n          cb && cb(e);\n          reject(e);\n        }\n      });\n    }\n  };\n}\n```. i gues maybe i need the babel loader? i only use a typescript loader right now. . after deleting all my node_modules it is working again,\nmight have been a wrong babel version or something can't reproduce right now\n2017-06-08 10:29 GMT+02:00 Mateusz Burzy\u0144ski notifications@github.com:\n\nThis code is completely valid, could u specify in what circumstances\n(possibly when using with what bundler) do u have issues with this?\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/rt2zz/redux-persist/issues/367#issuecomment-307036107,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AOQKN0JOoxP5mK_78x8uYE6q8A1sn9CKks5sB7DrgaJpZM4Ny46k\n.\n\n\n-- \nTEL\n+31640892448\n. ",
    "rkurbatov": "I don't know how exactly, it just works. Will ask in flow repo about details.\nhttps://github.com/facebook/flow/issues/4124. ",
    "cbayram": "export function getStoredState<State>(persistorConfig?: PersistorConfig, onComplete?: OnComplete<any>): Promise<State>;\nSomething like this perhaps?. ",
    "qborreda": "Check your store.js\nYou are returning the store before calling persistStore on it. . Shameless bump .. can you offer some advice, please?. Furthermore, if I set it to storage: localStorage it's not working either. It's only working when I don't pass any storage value on the config when I can get those two whitelisted nodes to persist.. Thanks @rrivem - will try that, although I made it work finally, with just the whitelist config part.\nSo, would it be \npersistStore(store, {\n    whitelist: ['locale', 'auth'],\n    storage: asyncSessionStorage\n  });\nlike this? \n(Probably missed a version update here). Try setting initialState to an empty object {} .. \nThen again, returning both initialState and loadingMessage in different scenarios doesn't make a lot of sense .. plus the REHYDRATE action has a payload taken from the storage you have set, and you are not getting it back into the redux state .. . I have one, if you let me. \nWe have a dashboard with it's own authentication and the persisted auth reducer has all the info on the logged user, including a jwt token for the API calls. But we should let our admin clients from the main application to log into the dashboard with a jwt token written in a cookie (domain wise)\nI'm having problems when the cookie is found, as the REHYDRATE event is fired after I send a logWithToken action with the cookie value .. \nIf the persistor had a pause/cancel rehydrate method, it would be awesome in this case .. . A different approach is to write conditions on the different reducers where the REHYDRATE is going to change state, when needed, but it's very manual .. \nexport default function reducer(state = initialState.auth, action) {\n  switch (action.type) {\n    case REHYDRATE:\n      // conditional check if you need it\n      return action.payload.auth ? { ...state, ...action.payload.auth } : state;\n...\n. ",
    "DannyvanderJagt": "@rt2zz Just stumbled on this issue, but I guess this one can be closed.. ",
    "smattt": "It's interesting that if I just pass in a whitelist with every reducer specified - the hang goes not occur! If I omit the whitelist and let every reducer get automatically included, then I see a 15-20 second hang. I'm unblocked for now but a fix would still be very appreciated, I'd imagine other folks must be hitting this as well.. You are 100% correct, I root caused the issue to two instances where I was caching JSX.Elements in the Redux store. The working whitelist was misleading because the problematic reducer was accidentally omitted from the whitelist - it was not working if the whitelist included all reducers.\nDo you accept bitcoin? I'd like to send you some beer money for the help.\nThank you for producing such a useful library!. ",
    "ccuilla": "Perfect. Thanks for the details.. ",
    "pensierinmusica": "@rt2zz I think this info is very useful, can we add it to the docs? If you like I can create a PR for it. Thx, cheers!. ",
    "tybro0103": "I second @pensierinmusica.\nIn the readme it just \"periodically\", which is concerning in say iOS - if the user were to kill the app before something was persisted that could be a problem.\nGlad to hear it works the way @rt2zz explained above as that seems ideal.. ",
    "rrivem": "@qborreda, you need to use import { asyncLocalStorage, asyncSessionStorage } from \"redux-persist/storages\". ",
    "PavanKumarHRao": "is redux-persist session storage possible??\n. ",
    "jamesmfriedman": "Setting the initial state of a reducer to null should be perfectly valid. This is a bug located here:\n\n\nThe if statement on line 23 needs to check if its an object, and if it's truthy.. A little more exploration, setting undefined as the default throws an error as well, but false is acceptable. Null seems like the appropriate value I should use for my reducer, but i'm ok with the workaround for the time being.. ",
    "L337LUKE": "Found the solution, I have no idea how this impacts React but it was.\nI'm using react to build a micro app in Magento and when I registered a second route, there is a \"\" in a config.xml file to specify what layout to load, and appropriate JS/CSS/Layout files etc, altering this fixed the issue.\nIncredibly bizarre but hey, Magento!. ",
    "jalkoby": "It raises \"Invalid calling object\"  in: \n```js\nsrc/persistStore.js\nif (shouldRestore) {\n    setImmediate(() => {\n```\nOne of possible reasons is https://github.com/facebook/draft-js/issues/1230. @Andarist yep, wrapping helped to fix it - here is the PR. Sorry - rush fixing (without running test suite at the end) is not a good idea . thanks. ",
    "arvinsim": "I also have the same problem. I have to clear my cache in order for new state to be reflected on the state tree.\nEDIT: Will try it redux-persist-migrate. @rt2zz \nSo v5 is already production ready? Only reason I picked v4 is that there is lots of support for it.. @rt2zz Thanks for confirming that. I am not using immutablejs so I guess I could give it a go ahead.. ",
    "piranna": "I think I have the same problem that @guymorita, when I call to persistor.purge() the data on localStorage is being removed but the props still have the old values until I refresh the web page. I have searched the full code and didn't find anything that lead me to thing removal is being notified to redux core so it can be able to clean up its internal structures, and that's the reason why props are still being filled...\nIf it's of interes, I'm using redux-persist under redux-offline under react-native-web.. > I find most redux applications implement a RESET action\nIsn't there a native action for that, the same way redux-persist has persist/PURGE? I find it a somewhat basic functionality, and so I though redux-persist was already calling it... It's said, do I need to reset myself the redux state?. I though that since it's being defined the initialState of each reducer redux was already conscious of it...\nYour code seems interesting, if I understood it, it's executing the reducer without state to fetch the initial state and storing it elsewhere, and later using REHYDRATE to force setting the value of the internal redux state, isn't it? When you said that I would need to reset it myself I was thinking about adding a new persists/PURGE case on the diferent reducers and set the returned value to the default one, although I would need then to define it outside the default attribute. Definitely your approach is better than mine :-) Would you like to give it a go or do you preffer I try it first?. Well, I'vo fpund that the redux-reset package already does the job, and in fsct it does it the way you proposed! :-P. > hah fantastic! We will have to add that as a footnote to the purge docs.\nDone :-). ",
    "pavoni": "@rt2zz If this looks OK are you happy to merge?. @rt2zz Thanks for merging. \nCan see you're busy working on v5 - but would love another release of 4 when you get a moment - so I can drop my fork.. Perfect - thanks very much.. ",
    "Noitidart": "It copies the data from async storage to redux, where the key matches reduxPersist:[store_key]. Then everytime it changes, it updates AsyncStorage (you can debounce/delay this save but by default it tries immediately).\nI personally never have the need to mess with AsyncStorage,if you are using redux-persist, redux-persist handles everything for us.\nIf this answers your question, please close this issue.. @sibelius by defaulted the reducer of _persist contains a key called rehydrated. So you don't need an action, just wait for that. But you can wait for the action of REHYDRATE:\nimport { REHYDRATE } from '../redux-persist/constants'. Ohh, localStorage only works with strings. My mistake, I'll convert the blob to a dataUrl with FileReader then.. Thank you sir for such a in-depth reply!! I will start researching v5 now. Would you like to close this topic?. So i have been working with v5 today and I found that all data is saved as a serialized string in `persist:primary`.\n\nSo now whenever anything changes, even outside of the files key, it will end up serializing/unserializing all the base64 data of the files which can be a lot. Is there anyway to make it do it like v4, where it was seperate entry per key, like { reduxPersist:counter:3 } a file per key? (then i would break up the files entry into sub keys/values). Crap struggled with this for awhile. I'm getting issues. I can give a solution with async transform, if transform gives me argument (storage). Will try that direction now.. Actually, becuase in v5, storage is mandatory, we don't need to pass storage as arg to transforms, they can just export from their store file, and import it into their transform.. Thanks, I'm not sure about that IIFE perf cost. Doesn't this async await get transpiled out?\nYeah I totally am newbie at redux-persist, my implementation of async transforms is probably wrong, but I thought I covered it so that they don't return out of order.. As I have been using this over the last couple weeks, I think async transforms are super useful. It solves all my cases without me needing to modify the actual core. But I couldn't do it right and am not sure how to fix it up. Pretending if async transforms was done from scratch by someone who knows what they are doing, do you think async transforms will make it into v5 one day?\nShould I close this PR as this for sure won't make it in? I wouldn't accept this PR that's why I'm saying :P. Thanks for that awesomely positive and hopeful comment!!. Thanks very much @rt2zz for the reply.\n\nIt sounds like your requirements are pretty specific\n\nI am creating a PWA where they download and work with files, but the files cannot go onto the hard drive without involving file dialogs for the user, which is a bumpy experience. So to keep a smooth experience all PWAs I have seen use local storage, then offer \"file save to hard drive\" options which involve file dialogs.. Should I close this issue out? pre-purge callbacks seem out of scope no? if they are purging they can just get the reference to storage somehow, then do storage.removeItem(NAME_OF_KEY_HERE)? . Ah very interesting! So if the key didn't change, that thing is not re-serialized. Thanks sir very much for putting up with me and my questions in your issues topic! And leaving this open for me to close, much respect!\n\nIn my observation serialization is much more costly than storage sets. \n\nI strongly agree, I was seeing this as well and then was questioning the perf of v5 because I saw it was doing a lot of it. But wasn't sure till your comment now. Thank you for sharing this note!. @Altiano - I had the same situation. I see a lot of us are making PWA's these days and are hitting that problem. Where there are entries of large sizes. I had to modify redux-persist v5, I used async transforms. \nWhenever it tries to save it, it turns it into an id, and if that id has not yet been written, it writes to disk using AsyncStroage.set. Opposite is followed for reading. This way, a large entry (anything in files key) is never read or written unless modified or not yet read.\nThis is my async trasnform - https://github.com/Noitidart/Chrome-Store-Foxified/blob/master/src/webext/flow-control/filesTransform.js. Oh wow thanks very much for that awesome reply!! Those linked issues are super helpful. It's ok I don't want to move to a seperate storage engine just for dev mode. This only happens in dev mode correct? (from my experience it seems so). If its not \"just in dev mode\" then for sure ill switch engine. . Sincerest thanks @jamsch for your replies!! Should I close this topic out do you think? I thought it would be helpful for people searching in redux-persist repo first as thats where the error is happening. But after seeing those issues it makes total sense to be in react-native repo's. Haha good idea. Thanks again!! And major thanks to package maintainer for such a superb lib that is redux-persist!!. @kopax  yeah it works perfectly on react-native. Just ignore the dev issue. Any issue that is easy to bear with can be overlooked. Simple restart of the app when it hangs is all it takes to fix dev. And its perfect in production.. ",
    "brownbl1": "You could always use localStorage, but also store the rememberMe selection. If rememberMe is false when your app loads, just clear the stored user data. . I think that's probably how you'd want to do it. If you're using the v5 beta branch, there is support for specifying different storage for different reducers (might also be in the current release) so it shouldn't be too hard to specify a flag like firstLoad: true. If firstLoad is true, dispatch an action that clears the token in localStorage (you would also need to check if rememberMe is true/false) and sets firstLoad to false in sessionStorage. \nIt does seem messy but I don't see any real problems with that approach.. I also think this would be a very useful feature.. Yeah, I don't see any reason to have both. This is probably the simplest implementation. If you wanted to fire your own BOOTSTRAPPED action from this hook, that would be your choice as the consumer.. I tried npm upgrade redux-persist@next but I'm not seeing the new code locally. I'll try linking my local repo for now... Just tested it locally, yep it's working for me! Only fires after all REHYDRATE actions are sent.. I ended up doing he equivalent with npm.. Okay, I think I'm following. But if we just returned the default action (something like below maybe?) wouldn't we still never be falling through to PURGE? I guess I assumed that the PURGE action was fired explicitly, and if that was the case, I would have expected it to catch even if default comes before in the switch statement. Correct me if I'm wrong.\n```js\ncase REHYDRATE:\n  // noop if purging\n  if (_purge) return state\n// @NOTE if key does not match, will continue to default case\n  if (action.key === config.key) {\n    let reducedState = baseReducer(restState, action)\n    let inboundState = action.payload\n    let reconciledRest: State = stateReconciler(\n      state,\n      inboundState,\n      reducedState,\n      config\n    )\nreturn {\n  ...reconciledRest,\n  _persist: { ..._persist, rehydrated: true }\n}\n\n} else {\n    return defaultAction()\n  }\ncase PURGE:\n  _purge = true\n  purgeStoredState(config)\n  return state\ndefault:\n  return defaultAction()\n``. That's way better. :). Not at all!. Sorry.. was just about to get to it now. Looks like we're all set!. You know what.. I've just got around to testing this, and it's still failing in the same way. I may not fully understand what you're doing here withPURGE. It's still falling through to PURGE for the second reducer becauseaction.key === config.key` is false. It would have matched the second time through but purge was set so we do the noop. \nDoes that make sense? I guess I didn't look at the change closely enough. Sorry about the merry-go-round on this. :)\nThis fixed it for me. It's basically the same thing I did before, but I realize I'm not sure it's the right solution. \nhttps://github.com/itslittlejohn/redux-persist/commit/d70368d8fc5177a62c2187116030e95e0a2f6ea4. That should do it! I'll try it out tonight for redundancy.. Great! Glad I could help.. ",
    "daniloprates": "@itslittlejohn sounds good. just don't know how to detect is it's a simple reload or a new session, without using any other resource, like saving a flag in the sessionStorage.... @itslittlejohn great, I'll give it a go.\nthanks!. ",
    "mim-Armand": "Hey @AlmogRnD,\nI believe you can choose the way you want to rehydrate your store (have a look at the root Readme.md and it's all explained clearly):\n\nIf you import autoRehydrate from the package and pass it as an enhancer it will rehydrate the store automatically and you don't have to worry about it, you can also let it know which components you want to persist with blacklist and whitelist options (one or the other)\nif you opt to do it in per container basis you have to trigger it yourself and handle the logic (to when)\n\n\nAlso is there a way to see what data is being saved to the local storage to make sure it's working?\n\nSure, There are different ways, to start with, depending on the storage engine you use, you can use the developer-tools to inspect them and even change them on the fly!\nFor the default engine ( LocalStorage ), Go to the local-storage\nHope it helps, :+1:\n. @farhanmannan autoRehydrate I believe automatically rehydrate the store and doesn't affect the frequency in which the storage is updated, persistStore is what's taking care of that part and you can call it whenever you want or have it update the storage whenever there is a change in the tracking stores, you can also provide a callback function to it and get notified whenever it updates the storage to find out how frequent it does it in your code.\nLook at the docs to find out more.. When on file:// protocol, I get the following error which makes me think the json payload is already parsed and it's attempting to parse it again, I'm for sure sending a serialized json string tho, and it doesn't happen when being served from a server:\nUncaught SyntaxError: Unexpected token o in JSON at position 1\n    at JSON.parse (<anonymous>)\n    at createStore.js:149\n    at t (persistStore.js:46)\n    at persistStore.js:39\n    at l (getStoredState.js:62)\n    at getStoredState.js:41\n    at Object.getItem (createStore.js:121)\n    at getStoredState.js:38\n    at Array.forEach (<anonymous>)\n    at getStoredState.js:37. Actually, the localStorage does work in file:// system in the recent versions of Chrome! So I really don't know what could be causing the problem!\nI can easily set and get items in the local storage during different sessions manually and it behaves exactly the same as it would otherwise (Except perhaps it is not as secure) but Redux-Persist behaves differently depending on the location.origin!\nAny idea why this is happening? :/\n. I think the problem was that getState() returns the actual state and not the immutable state clone that can be used to update the actual state in an action, ( in contrary to what I was expecting or maybe it has been changed recently.. ? ), or maybe always returns the same instance of the state that Redux-Persist is using too, but anyway, I was mutating the object returned from getState and passing back to reducer to update at which point the state was already mutated ( or atleast the instance that was usied by Redux-Persist ) hence the reason behind the confusion..\nAnyway, I think it issue is not related to Redux-Persist, so I'll close it,\nThanks, :)\n. Don't remember really which project I was working on when I had this issue! But I think I ended up implementing the functionality myself and decided to not use the library ( as I didn't even need to persist the whole state, just a portion of it ).. ",
    "f6m6": "@mim-Armand how frequently does autoRehydrate persist the store? . ",
    "jaycanty": "Yes, I am getting this error too with persistStore(store, {storage: AsyncStorage})\nI've tried to wrap AsyncStore but cannot figure out to return a string type (returned from AsyncStore.getItem callback as the generic  type required in Storage interface.\npublic getItem<Result>(key: string, onComplete?: OnComplete<Result>): Promise<Result> {\n        const callBack = (error?: Error, result?: string) => {\n            onComplete(error, result as Result)  // <= Cannot cast string to Result\n        }\nHope this explain it.  I am new to react....\n. ",
    "sdiaz": "\ud83d\udc4d got the same issue.\nWe should add Result|string to the typings for this special case. Anyway for those just using AsyncStorage I modified the definitions to\nexport interface Storage {\n    setItem(key: string, value: any, onComplete?: OnComplete<any>): Promise<any>;\n    getItem<Result>(key: string, onComplete?: OnComplete<Result|string>): Promise<Result|string>;\n    removeItem(key: string, onComplete?: OnComplete<any>): Promise<any>;\n    getAllKeys?<Result>(callback?: (error?: Error, keys?: string[]) => void): Promise<string[]>;\n    keys?: (...args: any[]) => any;\n    [key: string]: any; // In case Storage object has some other (private?) methods and properties.\n}.\n",
    "iRoachie": "Sent PR to fix #399 . Fixed by #399 . @rt2zz Can you push a patch with this update? Or would you prefer if I publish the typings on DefinitelyTyped so you wouldn't have to manage them yourself?. Thanks!. Good job mate, I was meaning to do it at the time. Just by looking at it, it looks good . Closing, just saw message regarding v5.5 not yet having typescript definitions. Sweet! One question, if I update to v5 will the persisted store on the client be affected in anyway?. Ahh :\\, alrighty then I'll hold it off to a next major release for my app. Thanks. ",
    "dharmawankenny": "Closing this, just a simple if on configureStore when passing down enhancer should work.. ",
    "rochapablo": "No one?. I tried to change to \n// const reducer = persistCombineReducers(config, reducers)\nlet rootReducer = combineReducers(reducers)\nlet reducer = persistReducer(config, rootReducer)\nbut it keeps getting \nExceptionsManager.js:73 Notification handler err TypeError: In this environment the sources for assign MUST be an object.This error is a performance optimization and not spec compliant.\n    at Object.assign (Object.es6.js:42)\n\"react-redux\": \"^5.0.6\"\n\"redux-persist\": \"^5.4.0\"\nUPDATE\nI believe have fix the problem; I was getting something like { store: { 'user: { name: 'Fox' }' } } a cup of coffee and JSON.parse solved my case.. ",
    "isabelleaubron": "Do you still have the issue ? \nI'm using store.getState() and it's ok for me (redux v3.7.2; redux-persist v5.9.1)\nMaybe you have an error in the structure of your store ?. ",
    "bm-software": "@isabelleaubron I've just tried and now with redux v3.7.2 and redux-persist v4.10.1 (I've not tried v5 yet) it works without problems. Maybe updating redux solves the problem.\nThank you. ",
    "dwelch2344": "Gotcha. Yeah, we got our implementation working with immutable, but it takes considerable babysitting so we've scrapped it. Thanks for feedback. ",
    "ArthurBugan": "Hey. Did u find something?? I'm trying to check if my store has some login data about my client if so redirect the client to some route, but when I do   console.log(getState().client); my state is empty but when I go to the redux dev tools I see that REHYDRATE changed the stated and I have my data there persisted, how to acess the store from my app?. Ok, I find that I possible solution is to implement a wait function that will only render when the REHYDRATE is done. ^4.8.3. +1\n. ",
    "ceres629": "In the end I just handled the REHYDRATE action myself in a reducer, merging the stored state with the app state manually instead of using the autorehydrate functionality.. ",
    "melkayam92": "If still relevant, you can use:\nimport autoMergeLevel2 from 'redux-persist/lib/stateReconciler/autoMergeLevel2';\nwhich will merge 2 level state.. ",
    "ms88privat": "Same problem here. This solves the problem:\njs\nconst renderAppAfterRehydrate = () => {\n    persistStore(store, { whitelist: [ 'auth' ] }, () => {\n        const history = syncHistoryWithStore(browserHistory, store);\n        ...\n. ",
    "tianguanghui": "@ms88privat\n@nikita-malyschkin \n Hi,I have the same problem.This is how I create my store:\n```\nimport { createStore, compose, combineReducers, applyMiddleware } from 'redux';\nimport createHistory from 'history/createBrowserHistory';\nimport { routerReducer, routerMiddleware, push, LOCATION_CHANGE } from 'react-router-redux';\nimport { composeWithDevTools } from 'redux-devtools-extension';\nimport thunkMiddleware from 'redux-thunk';\nimport logger from 'redux-logger';\nimport axiosMiddleware from 'redux-axios-middleware';\nimport { persistStore, autoRehydrate } from 'redux-persist';\nimport { REHYDRATE } from 'redux-persist/lib/constants';\nimport createActionBuffer from 'redux-action-buffer'\nimport httpClient from '../utils/HttpUtils';\nimport rootReducer from '../reducers/index';\nimport initialState from '../models/index';\nlet reducer = combineReducers({\n    ...rootReducer,\n    router: routerReducer\n});\nlet history = createHistory();\nlet debugware = [];\nif (process.env.NODE_ENV !== 'production') {\n    debugware.push(logger);\n}\nlet enhancer = composeWithDevTools(\n    autoRehydrate({log: false}),\n    applyMiddleware(\n        thunkMiddleware,\n        createActionBuffer(REHYDRATE),\n        axiosMiddleware(httpClient),\n        routerMiddleware(history),\n        ...debugware\n    )\n);\nconst store = createStore(reducer, initialState, enhancer);\npersistStore(store, {}, () => {\n    console.log('persistStore complete');\n});\nexport { history, store, push };\n```\ni have use the 'redux-action-buffer' Middleware, and place 'createActionBuffer(REHYDRATE)' behind the 'thunkMiddleware' and before all the others.\nthen i get the right store that recovery from the localStage when the app init.. ",
    "orenfromberg": "I also took advantage of the optional callback parameter on persistStore() as @ms88privat did above. I used it to dispatch an action that lets the app know that we are ready to render since at that point the state has been rehydrated.\n```javascript\nconst setIsReady = () => ({\n    type: SET_IS_READY,\n    payload: true\n})\npersistStore(store, { blacklist: ['isReady']}, () => {\n    store.dispatch(setIsReady());\n});\n``\nNote that I've addedisReady` to the blacklist.\nHere is the reducer:\njavascript\nexport default (state = false, action) => {\n    switch(action.type) {\n        case SET_IS_READY:\n            return action.payload;\n        default:\n            return state;\n    }\n}\nFinally, in my App root component I have this render logic:\n```javascript\n  render() {\n    if (!this.props.isReady)\n      return ;\n// render the app as normal\nreturn (\n  <div>...\n\n```    . ",
    "sparameshwar": "Any resolution on this issue? I have the same problem. Actions I dispatch before the store is rehydrated are executed immediately instead of being queued up behind the rehydration.. ",
    "kormang": "Seems that callback's state is plain state from storage, and on first run there is nothing in storage. Store's state is then initialized with initial state for each reducer. So if it works for you consider that it is first run if state is empty. If it does not work for your use case, then use Stare's state in callback or somewhere later if possible.. However, I think this should at least be mentioned in the docs if not fixed otherwise.. Thanks for telling me, I'm on my way to change my code to make it future proof :D. ",
    "dharik": "Thanks!. ",
    "vuongngo": "@rt2zz I'm wondering what would happen if migration return undefined, null or empty object, will persist state reset or I have to use purge to reset state?. ",
    "abi": "Hey @joshhornby I spent a bit of time struggling with this today. What you probably need to do is add a REHYRDATE action to your reducer. Check this out: https://github.com/brentvatne/chain-react-conf/blob/6175110aa2c0a4e819f1ac2d05c066fba3a297ff/state/Store.js. ",
    "jbrodriguez": "Sounds great !. That's how I'm doing it right now on v4.\nI suggested the action, because you were removing the callback.\nIf you leave it there, it would almost be api compatible.\nFine by me \ud83d\udc4d . Glad it helped.\nI don't have strong opinions about autoRehydrate, what I have found is you do need some manual handling as your state evolves and you start adding fields over time, so each reducer has the best notion of what to do, when rehydrating (that's why I use the REHYDRATE action to set this up).. ",
    "sibelius": "so, is there any guide for v5 to handle this?\nshould we dispatch an action on bootstrap callback?. @rt2zz you can close this\nfollow migration guide https://github.com/rt2zz/redux-persist/blob/master/docs/MigrationGuide-v5.md. nevermind\nit was multiple keys, now it is just one. ",
    "svachmic": "Hi @rt2zz any news on this matter?. ",
    "openscript": "Hi all\nI've started to add Typescript definitions in here:\nhttps://github.com/openscript/redux-persist\nFeedback is appreciated! /ping @rt2zz \nRobin. Yes, I'm using v5 with partial type definitions right now.\nFor a while I also used this type definitions, but you will lose type safety for the interaction with redux-persist:\nAdd to typings.d.ts:\ndeclare module 'redux-persist';\ndeclare module 'redux-persist/es/integration/react';\ndeclare module 'redux-persist/es/storage';. I've created an issue (#674) and a pull request (#676) for this. . According to https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html it should be types.. Was fixed with #725.. I can revert these if you want, but I suggest to have something like tslint, to keep the code clean and organized. \nI'm glad to contribute a tslint configuration with another pr.. @yordis I agree. :)\nOkay, so I will create a separate PR for #675 or is this issue already addressed?. @yordis Yes, please check out #725 . I've closed this pull-request because it became obsolete.. ",
    "codepunkt": "@openscript Awesome! Whats prevents you from opening a PR?\n. ",
    "rodrigoelp": "Hey guys, joining the conversation. I've been checking the @openscript repo and did a minor fix to the persistCombineReducers(...) exported function as Reducer cannot be expressed without its generic parameter (trying to get a hang on how to create and define the type definition).\nDo you guys know what is going on?. Ok guys, I have created my type definition (which is working on react-native) and created the following pull request #615 at least the scenario I am using. If you have other scenarios to test the port is working I would love to see it.\nCouldn't use the type definition created by @openscript as it was not compiling, so basically wrote it from scratch\n. Good news people, my pull request has been merged into master. Still waiting for feedback if any of you have anything to request.\nCheers. Hi @deanmoses, I don't think the change has been published in npm yet.\nIf you want to add the type support right now, follow these steps:\n\nDownload the type definition file locally to your computer.\nCreate a folder where you have your typescript code called typedefs (or whatever you want to call it) and store the file there.\nIn the tsconfig.json file, add under compilerOptions the following line: \"typeRoots\": [ \"[relative_path_to_folder_containing_code]/typedefs\" ]. Add commas as required.\n\nNow your type definitions should work.\nHere is an example of my tsconfig.json file in case you needed\njavascript\n{\n  \"compilerOptions\": {\n    \"target\": \"es2017\",\n    \"module\": \"commonjs\",\n    \"jsx\": \"react\",\n    \"sourceMap\": true, \n    \"outDir\": \"./lib/\", \n    \"strict\": true, \n    \"typeRoots\": [ \"./typedefs\" ],\n  },\n  \"include\": [\n    \"./src/\"\n  ]\n}. I got no idea if @rt2zz has published that version yet (haven't checked...) so... first, go to your node_modules/redux-persist folder and check the type def is there... If it is there, then I messed something up...\nIf the file is there, then please reply to this message so I can check this as soon as possible to push a fix and copy the typedef into your project (under a typedef folder) and edit your tsconfig.json file to include the typedef project while I work this out.\nHere is an example of this working.\nhttps://github.com/rodrigoelp/reactnative-typescript-exercise-14/tree/49ed00d1d65f3775d78a1f2d97d612259fe47510\nUnfortunately, I have not checked this myself as I was waiting for the module to be published (did not know how to test the node module directly, I copied that file into my redux-persist folder and it worked... . Hi @razagill, I decided to import AsyncStorage as for that particular exercise I did not want people reading the code to think there some other special storage mechanism. But importing storage from the redux-persist should be the same thing. Good news is @rt2zz published the library already :). Hi @razagill, I thought the project was going to pick up the type definition as package.json includes the src directory.\nI've seen different projects including the type definition as part of the package.json as \njson\n{\n  \"name\": \"...\",\n  \"version\": \"...\",\n   \"description\": \"...\",\n   \"main\": \"...\",\n   \"types\": \"./src/index.d.ts\"\n   ...\n}\nCould you try that on your local version? If that is the fix, let's create a pull request to fix this issue.\nIn regards to \"redux-persist/lib/storage\" module, I can't say that I've tested that part, as I mentioned above, I just included the asyncStorage from react-native.. Hi @rt2zz, master (v5) is broken for any ts user... this will allow people to use typescript.. By the way @rt2zz, which other area is pressing to get in the type definition? I basically exposed what's needed to use PersistGate, should I get the redux-persist/es/storage module next?\nIf so, do you know how to test it with react-native? If you don't, do you have a set of steps I can follow to test it in my dev env (web)?. Hi, I will get it to a point it works, we can then split it into multiple files. I know is messy like this but I am trying to get my head around the library as well as producing the type definition. Hi @rt2zz, do you have examples that I can use to test the integration with typescript?\nI've been creating the type definitions for these and I want to be able to test some of the other functions that I have not used before.. Hi @inakianduaga,\nThanks for the comment, I will definitely include it in the next commit as I have been trying to create the type definition as separate files as mentioned by @ethan605. Haven't finished the definition because I have hit a wall doing that activity as I am sort of new to typescript and have been learning this part of the code generation.\nI got the storage part already done (although the module I got exposed is redux-persist/es/storage instead). Once the request is accepted we can generate the variants for lib as well.. Hi guys, In this pull request you will find a single file with all the type definitions segregated by modules. I still haven't pulled things on separate files as I had issues doing that (and the default exports for local storage, session and native storage gave me issues as well, I have not tested any of these yet)\nI have not tested every declaration as I do not have an example for migration or state reconcilers.\nIt does not have any breaking in comparison to the previous commit.. No worries :) glad I've been useful :) . By the way, should we update Readme.md file to remove the comment Additionally v5 does not yet have typescript bindings.?. Great, you are quick ;) . Hi @LKay, I have created a pull request today which has the entire definition for redux-persist though is not split into multiple files.\nIn this pull request, the transformer is a generic definition, do check it here: #624. ",
    "deanmoses": "Should I be able to redux-persist 5.4.0 with TypeScript yet?\nWhen I attempt to import like this...\nimport { persistStore, persistCombineReducers } from 'redux-persist';\n... I get the following TypeScript error:  \n\nCould not find a declaration file for module 'redux-persist'. . \n",
    "razagill": "@rodrigoelp Thanks for the type defs. However, I'm having a problem importing the react-native storage like so:\nimport storage from 'redux-persist/lib/storage';\nI am using the type definition file you mentioned above but getting an error Could not find declaration file for module 'redux-persist/lib/storage', looks like there aren't any typings for this. How are you using that in react-native?. @rodrigoelp I don't see any typedef there in the node_modules/redux_persist, also I think they are in the repo here but like you said probably haven't been published yet.\nI'm following your repo now to set it up as I got the same error. I guess I need to import AsyncStorage instead of storage.. @rt2zz Tried the new version and although I can see the index.d.ts file in src, after installation TS compiler still complains that no type definitions are available (for now I've copied that file to my typedefs folder manually). Also not sure @rodrigoelp but even after importing the file I still can't do the following import\nimport storage from 'redux-persist/lib/storage';\nI have to import AsyncStorage directly from react-native and pass it to persistConfig\n. One thing to note is that since the typescript definitions are partial at this time for v5 and I couldn't find any for redux-persist/lib/storage from https://github.com/rt2zz/redux-persist/blob/master/src/index.d.ts I added declare module \"redux-persist/lib/storage\"; in my typings manually.. ",
    "yordis": "@rt2zz by any updates on the PRs?. @rt2zz it was working before, no?! Just do whatever you were doing \ud83d\ude04 . @Andarist what would be the downside of rollup, it seems that a lot of people use it for this.\nP.S: has been a long time without being involve in the JS so, what would happen if I use rollup on using your rollup version. Will rollup bundle just the piece of the app that I used? I forgot the name of that \ud83d\ude2d . @rt2zz is this still valid?. @rt2zz @Andarist check the PR, hopefully you will no need to do any proxy package anymore.. node_modules/redux-persist/src/index.d.ts(69,46): error TS2307: Cannot find module 'react'.\nnode_modules/redux-persist/src/index.d.ts(91,38): error TS2304: Cannot find name 'React'.\nRelated to Typescript ....\n. Could you reverse the single quote back? Let\u2019s keep it clean on what this PR is actually doing for fix the issues\nBecause you modify your TS configuration your editor probably is complaining. \nThis is not a TS repo so no needs for any tslint. . @openscript any updates?. error TS4050: Return type of public static method from exported class has or is using name 'Persistor' from external module \"redux-persist/es/types\" but cannot be named.\n@rt2zz I am guessing that this error is related to this,\nIf so, any date for publishing the fix?. @rt2zz this one as well\nnode_modules/redux-persist/src/index.d.ts(348,46): error TS2307: Cannot find module 'react'.\nMaybe we should add React as peerDeps? No quite sure what is the fix but I am getting this one as well. > @yordis I am not sure about these errors - does #706 resolve the first?\nI have \"redux-persist\": \"^5.6.10\", is #706  on it?\n\nFor the second it seems like maybe we need to move the type definitions for react integration out of index.d.ts and into the proxy module: https://github.com/rt2zz/redux-persist/tree/master/integration/react\n\nI think this issue is related to that you do not have React as peer or direct dependency so, I am not quite sure what should be the right move here.. Yeah this one, you will need to give up to one of them \ud83e\udd14\ud83e\udd14\ud83e\udd14. @Andarist the commonjs one do not need to have the dist on the path because it is flatted out.\nSorry for the inconvenience, I thought this may help. . cc: @rt2zz this should fix the issue with the types, hopefully.. @rt2zz Could we get this in?. ",
    "sanjeevraolade": "If still not working, \nJust add below to your module declarations.\ncreate index.d.ts @YourApp/index.d.ts (anywhere but preferably here) and add below line to it\ndeclare module 'redux-persist/*';. ",
    "piotr-cz": "@jasan-s \nI'm having exactly same issue with react-snap: The PersistGate is stuck at loading and never renders it's child. Seems that CHANGELOG.md file has been left behind with the v4 branch and isn't available in v5 releases anymore.\nThis very inconvenient when upgrading package, I have to compare changes manually before very upgrade.. Why do you think there could be problems in react v15?\nIt always was possible to return null from a render method, it's not something that have been introduced in v16.\nOn contrary returning undefined from render just as when the loading param is not defined throws an error A valid React element (or null) must be returned.\nSee https://codesandbox.io/s/7y91pm9q70. I have similar situation but when thinking about it, I think the solution is to persist user specific state on the server:\n- read state from API when user logs in\n- update state using API on the go or when user logs out\n- at most keep the username of last logged user for the login form\nbecause usually there is only one user currently logged in and it doesn't seem right to keep state of other users in frontend app. Then why not store all users' data in one place by ID of current user?\njson\n{\n  \"users\": {\n    \"\": { \"color\": \"red\" },\n    \"1\": { \"color\": \"green\" },\n    \"2\": { \"color\": \"blue\" }\n  }\n}\n. ",
    "flyinghawker": "```\nconst rootPersistConfig = {\n   key: 'root',\n   storage: storage,\n   blacklist: ['notification', 'switchLang', 'countDown', 'loadQuestion']\n };\nconst logInPersistConfig = {\n   key: 'logIn',\n   storage: storage,\n   blacklist: ['loading', 'editingItems']\n };\nconst chatListPersistConfig = {\n   key: 'chatList',\n   storage: storage,\n   blacklist: ['currentReceiverId']\n };\nconst rootReducer =  combineReducers({\n     notification: notification,\n     switchLang: switchLang,\n     countDown: countDown,\n     logIn: persistReducer(logInPersistConfig, logIn),\n     chatList: persistReducer(chatListPersistConfig, chatList),\n     loadQuestion: loadQuestion\n });\n export default persistReducer(rootPersistConfig, rootReducer);\n```\nthe second persistReducer seems not working, 'currentReceiverId' is blacklisted but persited, others in chatlist are gone after reopening app. ",
    "imflavio": "Awesome, I think that worked, I'm getting some import errors now, but I'm pretty sure it's unrelated to redux-persist.\nJust more information about persistor vs store would be great, also a complete demo example, so people can follow the setup flow.\nThanks @rt2zz . Didn't want to open a new issue, so I did what you said, and I also looked in the docs more:\n```js\n// store.js - (Btw you should add the async keyword in the docs)\nexport default async function configureStore () {\n  const initState = await getStoredState(reducerConfig)\nconst store = createStore(\n    reducers,\n    initState,\n    check.isDevAndDebugging\n      ? compose(applyMiddleware(thunk), check.isDevAndDebugging)\n      : applyMiddleware(thunk)\n  )\nlisteners(store)\nconst persistor = persistStore(store)\nreturn { store, persistor }\n}\n```\nthen in my entry point:\n```js\nimport configureStore from 'src/store'\nconst { store, persistor } = configureStore()\nconsole.log(configureStore(), 'configureStore')\n// One of those have the store and persistor objects I'm looking for\n// Promise {_40: 0, _65: 0, _55: null, _72: null}\nconsole.log(store, 'store')\n// undefined\nconst App = () => (\n  \n}\n      onBeforeLift={() => console.log('lifted')}\n    >\n      \n\n    <ScreenRoot />\n  </Container>\n</PersistGate>\n\n\n)\nexport default App\n```\nAm I supposed to handle this promise with a class component and react cycles? I feel that it would be a hacky fix, thoughts on this @rt2zz ?. Got it, I thought I had to add that initial state, also to clarify I do need to update my redux store manually if a local version has been found right? I had to dispatch this in order for the PersistGate component to show the root component instead of the loading one:\njs\npersistor.dispatch({ type: REHYDRATE })\nProblem I'm having now is all my other actions are not working as before, maybe something to do with the async initial state I was doing? need to try it tomorrow.. I'm already doing that:\n```js\n// src/reducers.js\nexport const reducerConfig = {\n  version: VERSION,\n  key: 'root',\n  storage: AsyncStorage,\n  debug: check.isDevAndDebugging\n}\nconst rootReducer = combineReducers({\n  a,\n  b\n})\nexport default persistReducer(reducerConfig, rootReducer)\n```. Awesome, it works now, thank you so much @rt2zz :) Great work. ",
    "pongponglau": "@rt2zz, thank you for your advice.\nI have tried to debug your said function and the chrome debugger does not catch any exception (i.e. pause on caught exceptions). Does it mean that there is no error?\nI have copied the following stack trace for your reference which happens repeatedly and repeatedly, ended up in repeated calls of componentDidMount of my home component. May i ask if you have any idea for that? Or what else i can check?\nOne more info, i am using Android 6 with SDK 23 with React Native 0.47.1. Due to permission issue of Android 6?\nThank you very much.\ncomponentDidMount (Home.js:280)\n(anonymous) (ReactNativeStack-dev.js:1658)\nmeasureLifeCyclePerf (ReactNativeStack-dev.js:1610)\n(anonymous) (ReactNativeStack-dev.js:1657)\nCallbackQueue.notifyAll (ReactNativeStack-dev.js:2121)\nclose (ReactNativeStack-dev.js:2138)\ncloseAll (ReactNativeStack-dev.js:1412)\nperform (ReactNativeStack-dev.js:1388)\nperform (ReactNativeStack-dev.js:1382)\nperform (ReactNativeStack-dev.js:1451)\nflushBatchedUpdates (ReactNativeStack-dev.js:1476)\nclose (ReactNativeStack-dev.js:1434)\ncloseAll (ReactNativeStack-dev.js:1412)\nperform (ReactNativeStack-dev.js:1388)\nperform (ReactNativeStack-dev.js:1451)\nflushBatchedUpdates (ReactNativeStack-dev.js:1476)\nclose (ReactNativeStack-dev.js:1434)\ncloseAll (ReactNativeStack-dev.js:1412)\nperform (ReactNativeStack-dev.js:1388)\nperform (ReactNativeStack-dev.js:1451)\nflushBatchedUpdates (ReactNativeStack-dev.js:1476)\nclose (ReactNativeStack-dev.js:1434)\ncloseAll (ReactNativeStack-dev.js:1412)\nperform (ReactNativeStack-dev.js:1388)\nperform (ReactNativeStack-dev.js:1451)\nflushBatchedUpdates (ReactNativeStack-dev.js:1476)\nclose (ReactNativeStack-dev.js:1434)\ncloseAll (ReactNativeStack-dev.js:1412)\nperform (ReactNativeStack-dev.js:1388)\nperform (ReactNativeStack-dev.js:1451)\nflushBatchedUpdates (ReactNativeStack-dev.js:1476)\nclose (ReactNativeStack-dev.js:1434)\ncloseAll (ReactNativeStack-dev.js:1412)\nperform (ReactNativeStack-dev.js:1388)\nperform (ReactNativeStack-dev.js:1451)\nflushBatchedUpdates (ReactNativeStack-dev.js:1476)\nclose (ReactNativeStack-dev.js:1434)\ncloseAll (ReactNativeStack-dev.js:1412)\nperform (ReactNativeStack-dev.js:1388)\nperform (ReactNativeStack-dev.js:1451)\nflushBatchedUpdates (ReactNativeStack-dev.js:1476)\nclose (ReactNativeStack-dev.js:1434)\ncloseAll (ReactNativeStack-dev.js:1412)\nperform (ReactNativeStack-dev.js:1388)\nperform (ReactNativeStack-dev.js:1451)\nflushBatchedUpdates (ReactNativeStack-dev.js:1476)\nclose (ReactNativeStack-dev.js:1434)\ncloseAll (ReactNativeStack-dev.js:1412)\nperform (ReactNativeStack-dev.js:1388)\nperform (ReactNativeStack-dev.js:1451)\nflushBatchedUpdates (ReactNativeStack-dev.js:1476)\nclose (ReactNativeStack-dev.js:1434)\ncloseAll (ReactNativeStack-dev.js:1412)\nperform (ReactNativeStack-dev.js:1388)\nperform (ReactNativeStack-dev.js:1451)\nflushBatchedUpdates (ReactNativeStack-dev.js:1476)\nclose (ReactNativeStack-dev.js:1434)\ncloseAll (ReactNativeStack-dev.js:1412)\nperform (ReactNativeStack-dev.js:1388)\nperform (ReactNativeStack-dev.js:1451)\nflushBatchedUpdates (ReactNativeStack-dev.js:1476)\nclose (ReactNativeStack-dev.js:1434)\ncloseAll (ReactNativeStack-dev.js:1412)\nperform (ReactNativeStack-dev.js:1388)\nperform (ReactNativeStack-dev.js:1451)\nflushBatchedUpdates (ReactNativeStack-dev.js:1476)\nclose (ReactNativeStack-dev.js:1434)\ncloseAll (ReactNativeStack-dev.js:1412)\nperform (ReactNativeStack-dev.js:1388)\nperform (ReactNativeStack-dev.js:1451)\nflushBatchedUpdates (ReactNativeStack-dev.js:1476)\ncloseAll (ReactNativeStack-dev.js:1412)\nperform (ReactNativeStack-dev.js:1388)\nbatchedUpdates (ReactNativeStack-dev.js:2077)\nenqueueUpdate$1 (ReactNativeStack-dev.js:1481)\nenqueueUpdate (ReactNativeStack-dev.js:1510)\nenqueueSetState (ReactNativeStack-dev.js:1556)\nReactComponent.setState (react.development.js:167)\nonStateChange (connectAdvanced.js:222)\ndispatch (createStore.js:186)\n(anonymous) (middleware.js:72)\n(anonymous) (persistStore.js:55)\ncomplete (getStoredState.js:73)\n(anonymous) (getStoredState.js:52)\n(anonymous) (AsyncStorage.js:86)\n__invokeCallback (MessageQueue.js:307)\n(anonymous) (MessageQueue.js:120)\n__guard (MessageQueue.js:231)\ninvokeCallbackAndReturnFlushedQueue (MessageQueue.js:119)\n(anonymous) (debuggerWorker.js:72). I have the same problem even with the following componentDidMount in Home.js.\ncomponentDidMount() {\nconsole.log('home componentdidmount called')\n }\nThank you for your advice. ",
    "cwhenderson20": "My pleasure. Thank you for the module! It's invaluable.. ",
    "irrigator": "@rt2zz Thanks for your reply! . ",
    "sheldonrong": "@rt2zz  any roadmap as to when v5 will be released?. ",
    "chmanie": "\nI am thinking maybe the logic is actually to have a more strict passthrough case\n\nI agree, my proposed solution was rather a quick fix for me. Let me know if you need help :). ",
    "githubdoramon": "Shure... here is the important code (i guess):\n```\nimport { createStore, applyMiddleware, compose } from 'redux'\nimport thunk from 'redux-thunk'\nimport rootReducer from '../reducers/combined'\nimport { persistStore, persistReducer } from 'redux-persist'\nimport storage from 'redux-persist/es/storage'\nimport transit from 'transit-immutable-js';\nconst createStoreInternal = (reducer, middleware, initialState) => {\nlet store\n// Add dehydrated state if any - only on client side\n  if (initialState) {\n    // Remove if you are not using server rendering\n    store = createStore(\n      reducer,\n      initialState,\n      middleware\n    );\n  } else {\n    store = createStore(\n      reducer,\n      middleware\n    );\n  }\n}\nreturn store\n}\n// Creating store\nlet store = null;\nconst storeConfig = {\n  key: 'rootStore', // key is required\n  storage,\n}\nconst reducer = persistReducer(storeConfig, rootReducer)\nlet INIT_STATE = null;\ntry {\n  INIT_STATE = _DEHYDRATED_STATE; // eslint-disable-line no-undef\n} catch (e) {\n  //console.log('No dehydrated state'); // eslint-disable-line no-console\n}\nif (INIT_STATE) {\n  INIT_STATE = transit.fromJSON(INIT_STATE);\n}\nlet middleware;\nmiddleware =\napplyMiddleware(thunk)\n// Enable DevTools if browser extension is installed\nif (window.REDUX_DEVTOOLS_EXTENSION) { // eslint-disable-line\n  middleware = compose(\n    middleware,\n    window.REDUX_DEVTOOLS_EXTENSION() // eslint-disable-line\n  );\n}\n}\nstore = createStoreInternal(reducer, middleware, INIT_STATE)\nif (module.hot) {\n  // Enable Webpack hot module replacement for reducers\n  module.hot.accept('../reducers/combined', () => {\n    const nextRootReducer = require('../reducers/combined').default; // eslint-disable-line global-require\n    const reducer2 = persistReducer(storeConfig, nextRootReducer)\n    store.replaceReducer(reducer2);\n  });\n}\nlet persistor = null\npersistor = persistStore(store)  , {\n  blacklist: ['ListViewReducer']\n})\npersistor.purge()\nexport {store, persistor}\n```\nThe combined Reducers:\n```\nimport { combineReducers } from 'redux';\nimport ProductEditionState from './ProductEditionState';\nimport MainAppState from './MainAppState';\nimport ListViewReducer from './ListViewReducer';\nexport default combineReducers({\n  ProductEditionState,\n  MainAppState,\n  ListViewReducer\n});\n```\nThe reducer that should not be persisted, rehydrated, or anything else.\n```\nimport {UPDATE_LIST_BASIC_INFO} from 'actions/ListViewActions';\nconst initialState = {\n  list: null,\n};\nexport default (state = initialState, action) => {\n  switch (action.type) {\n    case UPDATE_LIST_BASIC_INFO:\n    return {\n      ...state,\n      list: action.list\n    }\n    default:\n    return state\n  }\n}\n```\nThe purge action dos not clean the ListViewState... even when I remove it from blacklist.\nAny idea what I might be doing wrong?\nThanks\n. I feel so stupid!!!!!! Thanks, It seems that I got it to work now!. ",
    "skyshader": "Sorry for responding late.\nMy use case is that I I want to sync the storage across tabs for which I am using redux-persist-crosstab.\nNow the async calls I have, also result in async state dispatches to redux which results in multiple updates in the localstorage.\nI have 2 scenarios:\n1. Multiple dispatches at the same time. Say setting authenticated to true, and also setting a global notification on the app for welcoming the user.\n2. Dispatches occurring in 2 diff async calls, one after other.\nThe first dispatch and localstorage update triggers storage event to other tabs. When redux-persist-crosstab updates the localstorage on that specific tab, again storage event triggers. This creates an echo across tabs which does not create a problem if there are gaps between storage updates, otherwise creates inconsistency in the storage data if there are dispatches occurring simultaneously.\nHence I wanted to pause the persistor until I have updated all the necessary updates and then resume it to sync with storage only once.\nI hope I explained my case clearly.\nThanks.. I understood that it was me who had to handle it in the REHYDRATE case of the reducer. Not a problem with the library.. ",
    "leethree": "Using string keys would still cause Flow error. The only workaround I found without using Map is to use computed keys like:\njs\nconst migrations = {\n  [0]: (state) => ({}),\n};\nBut it will trigger ESlint error no-useless-computed-key.\nI guess I'll go with Map if it makes both ESlint and Flow happy.\n. Should be working now. Thanks a lot!. I'm using it on native. I think I found the problem. I'm using persistReducer on sub reducers, and I need to clear the entire store when the user logged out. \nWhen the root reducer is cleared, the _persist keys in the sub reducers are cleared too. And the persistReducer function will refuse to persist store when _persist is missing. (persistReducer.js line 121)\nShould the reducer reconstruct the _persist key when it's reset? Or is there any suggested way to handle this use case? Thanks!. I solved the issue by calling persistStore() again after the entire store is cleared (_persist is missing). Here's my code:\njs\nasync () => {\n  // this action will clear everything in the store\n  store.dispatch(storeReset());\n  // purge persisted data\n  persistor.purge();\n  // re-persist store\n  await new Promise(resolve => persistStore(store, {}, resolve));\n};\nBut the purge function is no longer async, which might cause issue in persistStore because the purge might still in progress. I'll open another issue for that.\n. @laksh1010 you can use something like redux-reset or implement your own.. Not sure if it's related or totally different issue. I'm getting this warning:\nredux-persist/stateReconciler: sub state for key `_persist` modified, skipping.\nSee persistReducer.js L104-L111, it looks like state and inboundState has _persist key but reducedState doesn't. Is this intended?. @rt2zz awesome, thanks!. Awesome! thanks a lot!. Hi @rt2zz , I just upgraded to 5.0.0-beta.13 but I'm not seeing the async purge changes in the package. Are the new changes published to NPM?. @rt2zz just tested out 5.0.0-rc.2 in out project. Async purge works great! \nBesides, flush is very useful for making sure data is cleared when user logs out. Thanks a lot!\n. I just wrote a storage engine based on react-native-fs that supports both Promise and callback. Would love to hear your feedback:\nhttps://github.com/leethree/redux-persist-fs-storage. ",
    "williamoliveira": "Just checked the storage now, I see the keys are different, everything is under the root key, so is there a easy way to migrate data from v4? or should I just keep on v4?. I dont know how the internals work, is it easy to do? do you plan to implement it?. I made a little adapter to keep using old callback based storage engines before they update\n```js\nconst promisefy = fn => (...args) => new Promise((resolve, reject) => {\n  fn(...args, (err, result) => (err ? reject(err) : resolve(result)))\n})\nconst storageAdapter = storage => ({\n  getItem: promisefy(storage.getItem),\n  setItem: promisefy(storage.setItem),\n  removeItem: promisefy(storage.removeItem),\n  getAllKeys: promisefy(storage.getAllKeys),\n})\n``. Sure, just one thing, I actually had to bind every method for a class based storage because I was getting an error in a place it was usingthis`, not sure if it is the correct thing to do tho, my js abilities only go so far\n```js\n// ...\nconst storageAdapter = storage => ({\n  getItem: promisefy(storage.getItem.bind(storage)),\n  setItem: promisefy(storage.setItem.bind(storage)),\n  removeItem: promisefy(storage.removeItem.bind(storage)),\n  getAllKeys: promisefy(storage.getAllKeys.bind(storage)),\n})\n``. Wont skippersistStore` disable redux-persist altogether or the hydration part works independently?\nCause I need the hydration to happen on the server so I can get the data from cookies. I dont need redux-persist to rehydrate again on the client because I am already rehydrating redux directly with initialState, the problem is it doesn't persists changes to state anymore on the client\nso the problem is: if _persist is there, further state persisting is disabled. Oh, I see what you mean now, in my case _persistoid is null at https://github.com/rt2zz/redux-persist/blob/v5/src/persistReducer.js#L132, your proposed change seems to be enough . Thanks!. @wootencl did you update redux-persist to 5.0.0-rc.2 ?. ",
    "levsero": "@rt2zz I'm trying to migrate from v4 to v5 using the experimental migration. It works fine for extracting the data, but if I try and add a migration at the same time it errors because _persist does not exist. I assume this has to do with it not expecting the state to be persisted without also having an _persist but since it's pulling it from v4 that is the case.\nAny thoughts or workarounds would be great.\nUpdate\nI've put up a pr with a potential fix, if there are comments or suggestions for a more desired fix can  update it.. @kelset https://github.com/rt2zz/redux-persist/blob/master/docs/MigrationGuide-v5.md. @aguynamedben yep all worked as expected once the fix was in.. Good catch on the === 0 \ud83d\udc4d \nHaven't come across any other issues in the v4 -> v5 migration, seems to work as intended.\n\ud83d\udcaf on all the work you've done here.. @rt2zz wondering how soon do you plan on cutting another release? (Would like to make use of this asap in production and would prefer not having to fork anything.). @rt2zz can confirm that on 5.3.0 the migrations (both from v4-v5 as well as the state migration) all appear to be working correctly \ud83d\ude47 . @rt2zz I don't have the most context on how the babel/js build process works so I may be missing something. \nBut the regenerator-runtime is already included in the package dependencies (package-lock.json) and running npm run build locally does properly compile the async/await to the lib and es directories with _asyncToGenerator, so I'm not totally clear on what this would be adding to the project?. Closing until such time can use async await.. @thenewt15 how would it work if you don't want to manually listen for case REHYDRATE in all your reducers? I assume this is what the deep merge is for, because the rehydrated state is not going to === the default state, so you need to deep merge the keys to merge them.  . @StefanWegener Are you using the v4->v5 migration as described in https://github.com/rt2zz/redux-persist#experimental-v4-to-v5-state-migration? I assume redux-persist-filesystem-storage is still supported in v5 so don't see why it should cause an error.  \n(Should this be opened as an issue for discussion about what the cause is?). ",
    "laksh1010": "hi can i know how u defined storeReset at store.dispatch(storeReset());. ",
    "skoob13": "One more solution is to call persistor.persist() after purging.. ",
    "abonander": "Sure, that's already in the README (which I'm sure you're alluding to), but if someone hits goto-definition or quick-documentation in their IDE, there's no documentation or comments to speak of. So if you're happy with the terminology, maybe just document it in the source.. ",
    "rrichardson": "My preferred bikeshed paint: \n I think that the variables should indicate that they're state, but in different forms.. one is the live, and in mem state, and the other is persisted. \njavascript\n  (liveState, key) => specialSerialize(liveState, key),\n  (persistedState, key) => specialDeserialize(persistedState, key),\nthe source vars should be something like : \nfunction createTransform (serializeFn, deserializeFn, config = {})\nor if you don't like serialize/deserialize .. \nfunction createTransform (toStorageFn, fromStorageFn, config = {})\nIf we all like a set of words for the readme and source docs and params I am happy to put in a PR. . ",
    "SpadarShut": "@rt2zz thanks, changed my reducer and now all's working!. ",
    "cs1717c": "To add to this.... (since I was stuck on this forever):\nIf you're reducer uses \ncase default:\n     return {...state}\nthis will not work for redux-persist. Change it to return state;. ",
    "luqmanrom": "Oh sorry. I mean uninstalling the application. Updated to avoid confusion. ",
    "zacharybrady": "I don't particularly want to use authRehydrate() ( which does work of course ). So if I do want to rehydrate specific parts of my state, which is what case REHYDRATE let's me do, how would I do that?. ",
    "ahmb84": "Same error too\nhttps://github.com/rauliyohmc/react-native-offline/issues/35. @MarkGalloway Many thanks it's working! :100: . ",
    "richardvclam": "I wrote a workaround https://github.com/rauliyohmc/react-native-offline/issues/35#issuecomment-375802151. Hope this helps!. ",
    "nolan-m": "Also having this problem on 4.9.1. ",
    "burrack": "+1 basically, right now it seems like only top level redux store keys can be treated by whitelist . @dchersey - where is 'persistCombineReducers' function coming from ?\n. ",
    "Elena2016": "+1 the same issue is in 5.4.3. Zack, thank you very much for your help!\npersistStore(store, { storage: AsyncStorage, whitelist: ['something'] });\nErrors:\n1. redux-persist: invalid option passed to persistStore: \"whitelist\". You may be incorrectly passing persistConfig into persistStore, whereas it should be passed into persistReducer.\n\nredux-persist: invalid option passed to persistStore: \"storage\". You may be incorrectly passing persistConfig into persistStore, whereas it should be passed into persistReducer.\nnode_modules/redux-persist/lib/persistStore.js:50:38 in \nnode_modules/redux-persist/lib/persistStore.js:49:23 in persistStore\n\n\n@rt2zz  - Sorry, it's my bad!  I've just fixed it.\nI haven't noticed that combineReducers was replaced with persistCombineReducers.\n. ",
    "dchersey": "I am also having this issue: \n```javascript\nconst channelPersistConfig = {\n  key: 'channel',\n  storage,\n  stateReconciler: autoMergeLevel1,\n  blacklist: ['messages']\n}\nconst metaPersistConfig = {\n  key: 'meta',\n  storage,\n  stateReconciler: autoMergeLevel1,\n  whitelist: ['channel']\n}\nconst channelReducer = persistCombineReducers(channelPersistConfig, {\n  messages: messagesReducer,\n  meta: persistReducer(metaPersistConfig, metaReducer)})\nexport default channelReducer;\nis my reducer, combined into my rootReducer usingjavascript\nconst rootPersistConfig = {\n  key: 'root',\n  storage,\n  stateReconciler: autoMergeLevel1\n};\nconst reducers = {\n  auth,\n  nav: navReducer,\n  channel: channelReducer\n};\nconst rootReducer = persistCombineReducers(rootPersistConfig, reducers);\n```\nDespite the white/black list nested configs, the entire state is persisted from all reducers, as I can see by inspecting action.payload in my 'persist/REHYDRATE' state listener.\nAm I using this correctly?. I'm following the docs in the Migration guide that say to \nreplace combineReducers with persistCombineReducers\ne.g. let reducer = persistCombineReducers(config, reducers)\nThis is inconsistent with the info in the README under nested persists ... but it seemed pretty clear and I thought it would supercede it. But that is confusing ... maybe it should go back to combineReducers?. ",
    "assyme": "@dchersey , I am trying to do something similar with having a combination of whitelist and blacklist to cherry pick what I want to persist in redux. Have you managed to solve this? Any leads for me (and anyone who land up here).. ",
    "cliffkoh": "I took a closer look at the type definitions and noticed that there was a bit of a hack added to make it work with AsyncStorage (I was using an older version where I also hit the same problem as @iRoachie). I cleaned that up and also make the signatures compatible with some of the variants of StorageAPIs.\n@iRoachie it would be great if you can review the change. I tested it and it works fine with AsyncStorage for me (pass in String to the generic).. @rt2zz any chance you can release a new patch build to npm which picks up this change? :). This is not needed for an interface - the concrete Storage object would be of the right type (e.g. AsyncStorage) and able to access those other methods and properties, while redux-persist does not care for the existence of those other methods and properties for it only relies on the methods/properties defined here in the interface.. ",
    "Altiano": "I'm still using v4,\nYou said, \n\nThe one additional cost as compared to v4 is that we set the entire serialized state into storage all at once\n\nAnd from the docs\n\nPerformant out of the box (uses a time iterator and operates on state partials)\n\nFirst, just want to ask for confirmation that another term of the state partial is substate, right? And in v4, when changes occur in a substate, only that one will be evaluated (persisted) to the storage?\nIf I have a really big substate, let say one that has array of 50 items, with each item has about 6 KB of characters (JSON.stringified), that state is changing frequently, how can the persistence process still be performant when I have all still data?\nOr do you think It is not really a problem if I have that 50 * 6 = 300KB write to disk so frequent (especially on mobile)?\nIs there any recommended limit you would give? . @Noitidart Oh I see.. It's a good solution to manually save (edited) individual item in its own key rather than to bundle it all together in a single key of subState.\nIt is more to programming/engineering concept than the API of this library to make performant persistence process.. What I want is to only evaluate based on certain sub-subreducer not the whole subreducer. @rt2zz \nJust a friendly ping for this issue.\nI think this is an important feature to have..\nin addition to the previous requirement (sub-subreducer or sub-substate in your own word, (yours is correct)), consider this:\nimport { Map, is } from 'immutable' \nconst a = new Map({a: 1, b: 2})\nconst b = new Map({a: 1, b: 2})\na === b // false\nis(a, b) // true\nhaven't try the v5, but I think it should have a way to debug whether state is persisting to the drive (not just transforming) and have the option to create our own equalityCheck.\nIt is better to give the user the freedom as structuring state is also like an art (hope you know what I mean) which mean assumptions/conventions probably is not always good. I seem to forget why I was asking this.\nI think it is because I need to synchronize the state between two opened tabs.\nChanging the state on one tab will trigger persisting, but the other wouldn't know and you'll end up with diff state between the two tabs.\nSo, what I think would solve the problem is to have a listener on every persisting completion.\nWith that, I could notify the other tab to load again from the storage. . ",
    "khoaanh2212": "same problem and @rt2zz's solution can not solve it. this is my code on store.js\n```javascript\n/*\n * Create the store with asynchronously loaded reducers\n /\nimport { createStore, applyMiddleware, compose } from 'redux';\nimport { fromJS } from 'immutable';\nimport { routerMiddleware } from 'react-router-redux';\nimport createSagaMiddleware from 'redux-saga';\nimport { persistStore, autoRehydrate } from 'redux-persist-immutable';\nimport createReducer from './reducers';\nconst sagaMiddleware = createSagaMiddleware();\nexport default function configureStore(initialState = {}, history) {\n  // Create the store with two middlewares\n  // 1. sagaMiddleware: Makes redux-sagas work\n  // 2. routerMiddleware: Syncs the location/URL path to the state\n  const middlewares = [\n    sagaMiddleware,\n    routerMiddleware(history),\n  ];\nconst enhancers = [\n    applyMiddleware(...middlewares),\n  ];\n// If Redux DevTools Extension is installed use it, otherwise use Redux compose\n  / eslint-disable no-underscore-dangle /\n  const composeEnhancers =\n    process.env.NODE_ENV !== 'production' &&\n    typeof window === 'object' &&\n    window.REDUX_DEVTOOLS_EXTENSION_COMPOSE ?\n      window.REDUX_DEVTOOLS_EXTENSION_COMPOSE : compose;\n  / eslint-enable /\nconst store = createStore(\n    createReducer(),\n    fromJS(initialState),\n    composeEnhancers(...enhancers, autoRehydrate())\n  );\n// Extensions\n  store.runSaga = sagaMiddleware.run;\n  store.asyncReducers = {}; // Async reducer registry\npersistStore(store, { whitelist: ['global', 'language'] });\n// Make reducers hot reloadable, see http://mxs.is/googmo\n  / istanbul ignore next /\n  if (module.hot) {\n    module.hot.accept('./reducers', () => {\n      import('./reducers').then((reducerModule) => {\n        const createReducers = reducerModule.default;\n        const nextReducers = createReducers(store.asyncReducers);\n    store.replaceReducer(nextReducers);\n  });\n});\n\n}\nreturn store;\n}\n```. ",
    "vesteinn": "Ran into the same issue when imports were not fixed, i.e. should have been import {store } instead ofimport store after also exporting a persistor in my file.. ",
    "sospedra": "That's usually a problem with redux-mock-store\nRemember that:\nimport configureStore from 'redux-mock-store'\nThe function configureStore does not return a valid store, but a factory.\nMeaning that you have to call the factory to get the store:\nconst store = configureStore([])(). ",
    "Morriz": "I just created pull request #454.. I fixed it in my branch (v4) with the proposed solution. You can try installing from morriz/redux-persist and see if it works. If you use yarn you have to do an extra npm install morriz/redux-persist to make it build.\nSo yes, we should be able to stop persisting state, as in case of errors: we would like to be able to erase state from storage and not have to worry about the lib storing it back.. Too manual. We need to be able to say STOP. sorry, somehow the github editor was clumsy and left unwanted spaces :|. I never liked the way purge works, as it tries to empty all my localStorage slots (keys), and does not offer a way to select only some keys. And I keep my app settings in a different slot, and don't want to lose those.\nI made a gist showing my setup (includes some React Native stuff): https://gist.github.com/Morriz/9f1e23b368331c057dea6f9ae63a00ee\nI am using onBeforeLift now, which comes in alpha with npm install -S redux-persist@next.. Have a look at this thread: https://github.com/rt2zz/redux-persist/issues/892. No, I mean to exclude some keys from purging, not from storing.... I did manage to give the reducer I wanted to NOT be flushed it's own key and blacklisted it from the main reducer, which made the storage go proper, but then when I do a purge on the store, it still purges everything. Which makes sense since it's a store purge. Maybe offer a reducer purge?\nNow I purge directly via storage.removeItem. Feels dirty ;]. Why did you close this? It\u2019s still valid. Maybe I am mistaken, but in my code I was actually doing that. I just started upgrading a year+ old project, so it was from end 2017.\nSo yes, if it's not in there now, it would be nice if purge would not be store wide, but instead scoped to a reducer. Since we are stuck with this discussion and I don't see my suggestion for configuration realized anytime soon, I added my insights to this discussion here: https://github.com/rt2zz/redux-persist/issues/892. I see that npm install redux-persist@next works, but will keep this open as it is still a valid request.. ",
    "Froelund": "Travis build is failing, but I believe that to be caused by a flaky test.. ",
    "wootencl": "As this issue is still open I seem to be having the same problem of setItem not being called and figured I would raise it here. Fairly new to redux so definitely possible I've configured something wrong. I'm also using custom cookie based storage via universal-cookie (instead of redux-persist-cookie-storage as I had already used it elsewhere in my project).  Here are the relevant files:\n\nconfigureStore.js\n```\nimport { persistStore, persistReducer } from 'redux-persist';\nimport { createStore, applyMiddleware, compose } from 'redux';\nimport thunk from 'redux-thunk';\nimport { CookieStorage } from '../utils';\nimport rootReducer from '../reducers';\nimport createHelpers from './createHelpers';\nimport createLogger from './logger';\nexport default function configureStore(initialState, helpersConfig, initialCookies = undefined) {\n  const helpers = createHelpers(helpersConfig);\n  const middleware = [thunk.withExtraArgument(helpers)];\n  const persistConfig = {\n    key: 'root',\n    storage: CookieStorage(initialCookies),\n    debug: DEV\n  };\nconst reducer = persistReducer(persistConfig, rootReducer);\nlet enhancer;\nif (DEV) {\n    middleware.push(createLogger());\n// https://github.com/zalmoxisus/redux-devtools-extension#redux-devtools-extension\nlet devToolsExtension = f => f;\nif (process.env.BROWSER && window.devToolsExtension) {\n  devToolsExtension = window.devToolsExtension();\n}\n\nenhancer = compose(applyMiddleware(...middleware), devToolsExtension);\n\n} else {\n    enhancer = applyMiddleware(...middleware);\n  }\n  // See https://github.com/rackt/redux/releases/tag/v3.1.0\n  const store = createStore(reducer, initialState, enhancer);\n  // eslint-disable-next-line\n  const persistor = persistStore(store);\n// Hot reload reducers (requires Webpack or Browserify HMR to be enabled)\n  if (DEV && module.hot) {\n    module.hot.accept('../reducers', () =>\n      // eslint-disable-next-line global-require\n      store.replaceReducer(require('../reducers').default),\n    );\n  }\nreturn store;\n}\n```\n\nCookieStorage.js\n```\nimport Cookies from 'universal-cookie';\nimport moment from 'moment';\nimport Promise from 'bluebird';\nexport default function (initialCookies = undefined) {\n  const cookies = new Cookies(initialCookies);\n  return {\n    getItem: (key) => (new Promise((resolve, reject) => {\n        try {\n          const s = cookies.get(key);\n          resolve(s);\n        } catch (e) {\n          reject(e);\n        }\n      })\n    ),\n    setItem: (key, data) => (new Promise((resolve, reject) => {\n        try {\n          // TODO Set httpOnly:true + secure:true\n          cookies.set(key, data, { \n            path: '/',\n            expires: moment().add(3, 'd').toDate()\n          });\n          resolve();\n        } catch (e) {\n          reject(e);\n        }\n      })\n    ),\n    removeItem: (key) => (new Promise((resolve, reject) => {\n        try {\n          cookies.remove(key);\n          resolve();\n        } catch (e) {\n          reject(e);\n        }\n      })\n    )\n  }\n}\nStore creation in `server.js`\n...\nconst store = configureStore(initialState, {\n      axios: createAxios(config.api.url),\n    }, req.headers.cookie);\n...\n```. I did. Still no luck sadly \ud83d\ude1e . ",
    "joturako": "Is this issue still relevant?\nI happened to have SSR rehydrate working, that is, when curl with an appropriate cookie, the response is hydrated (for example, the counter number changed). Using cookie as storage js-cookie on client-side and cookies with NodeCookiesWrapper on server-side.\nThere's just another issue with this: on client side, the ReactDOMServer.hydrate call will complain about unmatched data because that on the first call, persistStore haven't run yet and not have the same data from cookie.\nBut when I delay the hydrate call by putting it in the persistStore callback, it then won't attach the event handlers correctly.\nI think it's expected because when the page is loaded, the hydrate event wont happen until persistStore finished its run, and of course if you tried to hydrate before you have the same data from cookie, it will be unmatched data.\nSo as opposed to official ReactDOMServer recommendation, I used renderToStaticMarkup then use render (outside persistStore callback) and it worked well (no complain about unmatched data).\nAm I doing it wrong?. @rt2zz my general flow is: when you request (for example curl) with cookie to the server, it then will parse the cookie -> rehydrate from said cookie -> render from rehydrated state -> client receive the page. Then client-side script run, redux-persist get called and rehydrate from the same cookie because that's the cookie get sent to the server, so the final render is the same.\nThe problem I described in my previous comment, there's one factor caused that trouble: the cookie set by the server is httpOnly, which mean even after client-side booted & redux-persist kicked in and rehydrated, it does nothing because it can't read the cookie at all.\nThis is my working bits\n```\nimport { CookieStorage } from 'redux-persist-cookie-storage'\nconst orgCS = new CookieStorage(cookies, {\n    setCookieOptions: { httpOnly: false }\n  })\nconst config = {\n...\n  storage: orgCS\n... \n}\npersistCombineReducers(config, {todoReducers})\n```\nFor server-side that cookies is this cookieJar\nimport { NodeCookiesWrapper } from 'redux-persist-cookie-storage'\nimport Cookies from 'cookies'\n const cookieJar = new NodeCookiesWrapper(\n    new Cookies(req, res, {\n      // secure: false,\n      httpOnly: false\n    })\n)\nFor client-side that cookies is this Cookies\nimport Cookies from 'js-cookie'\nThen you call persistStore and wait to hydrate/response after it's finished. It will not complain about un-matched data afterward. . Hey there, just want to add some gotcha here:\nyour v5.4.0 work with no problem.\nbut recently I ran into a crash with a newer version.\neven after await store.flush() =>res.send, the store on the server-side never stop listen to update and thus trigger another cookie write (by setting header on res variable) and make the server crash: 'Can\\'t set headers after they're sent'.\nI guess  that's because of this line\n+    if (whitelist && whitelist.indexOf(key) === -1 && key !== '_persist') return false\n-    if (whitelist && whitelist.indexOf(key) === -1) return false\nSo if anybody ran into a sudden crash with the same error please check the version. I'm thinking of a fix, probably a flag/function to stop the persist<->update cycle on the server-side, because it will not make sense after we already call res.send.. ah, now that you mention it, this could be a potential memory leak if everything is not destroyed after we handle the request and send the response back. I will investigate next week and see if it grows like you said. In any case I just want to keep the flow work like on the client-side, that is: fetch from storage, populate the store, read from store and render. But on the server-side I guess there's one more step: tearing down everything after we sent a response.\nHave a nice weekend.. ",
    "pheromonez": "It looks like the type Storage was deleted and replaced with AsyncStorage, WebStorage, and LocalForageStorage. However, a small chunk of code at the bottom of the type definitions still referes to the deleted Storage type.. ",
    "actra-gschuster": "Any idea when the fixed master will be released to NPM?. I faced the same problems last week when implementing my store with immutables and ended in re-implementing most of the redux-persist parts.\nAs spread operators and plain object initializers are spread all over the code maybe it's best to create an immutable branch or a fork?\nI'd be happy to assist as needed whenever my daily business allows me to, just drop me a line.. Hope it's OK to mention it here...\nAs I wasn't happy with the mess I created when trying to \"hack\" redux-persist to support immutables all down the road I decided to create a new implementation as \"store enhancer\".\nIt's pre-pre-pre-alpha stage right now but as far as I could test right now it seems to work OK.\nMore docs will follow, I'll just add some \"first steps\" right now.\nHere we go: https://github.com/actra-development-oss/redux-persistable. What you're doing is changing the state (assigning to a new object) albeit it didn't change.\nWhen a reducer doesn't modify the state (read: create a new object from prev state merged with changes) one should always return the exact same state object as received, otherwise equality checks don't match - as you're experiencing right now.. ",
    "peterdev6": "+1. ",
    "ccoeder": "nevermind, i figured it out.. I solved the problem by examining the source code of the package.\nYou need to add a key to the reducer where you want to use redux-persist. The default is 'persistExpiresAt', so I use it.\nI use the moment package to set persistExpiresAt after 5 minutes.\nHere is my reducer. \n```\nimport moment from 'moment';\nimport {\n  FETCHING_USER_BY_YEAR_TO_DATE,\n  FETCHING_USER_BY_YEAR_TO_DATE_SUCCESS,\n  FETCHING_USER_BY_YEAR_TO_DATE_FAILURE,\n} from '../../../../../actions/constants';\nconst initialState = {\n  payload: [],\n  isLoading: false,\n  error: false,\n  persistExpiresAt: moment()\n    .add(5, 'm')\n    .format(),\n};\n```\nI hope this helps you.\n. just change this line\npersistStore(store, {}, () => {\n       this.setState({ rehydrated: true })\n      })\nwith this\npersistStore(store, { storage: AsyncStorage }, () => {\n       this.setState({ rehydrated: true })\n      })\nand top of your file add this line: \nimport { AsyncStorage } from 'react-native';. ",
    "alshdotme": "What was your solution? Currently trying to integrate redux-persist-transform-expire myself without much luck so far, using v5 of redux-persist.. I ended up doing the same thing and also downgrading to v4 of redux-persist. The author of redux-persist-transform-expire is looking into implementing support for v5.\nThanks for getting back though!. ",
    "kamranahmedse": "I ended up publishing redux-persist-expire for the similar usecase. Have a look if it may help.. ",
    "nihlton": "i solved this with a couple utility functions, and a simple config like:\njavascript\nconst reduxStorageWhiteList = [\n  { key: 'user', lifeSpan: ONE_YEAR },\n  { key: 'siteConfig', lifeSpan: ONE_DAY },\n  { key: 'siteContent', lifeSpan: ONE_MINUTE * 5 }\n]\nI have a gist up here:  https://gist.github.com/nihlton/b5a32b641eb84e115a7a137bc38780d9. ",
    "SupriyaKalghatgi": "I deleted the device with UDID E6E55D19-F00A-4AB8-8155-8BC80DA4BC99\nand it worked. ",
    "lsunsi": "I'm getting a similar issue in test environment. \nconsole.warn node_modules/redux-persist/lib/getStoredState.js:35\n      redux-persist/getStoredState: Error in storage.getAllKeys\nI think it has something to do with sensitive-storage adapter, but since it's coming from this package I thought it'd be better to start from here.\nAm I missing something?. @rt2zz Upgrading isn't an option since I'm using redux-loop. (':\n@booleanBoy I'm using it with sensitive-storage, yeah. What exactly did you do to fix it?. Yeah I was so happy about the update and then I got less happy. (: . @rt2zz @ercpereda @bdwain About not knowing what the integration would look like, what if redux-persist took the state getter/setter argument in some way? Instead of assuming it'll be an object and getting and setting to it, it could take the functions that take the state as parameters or something.\n```javascript\n// defaults that allow current behaviour\n{ get: state => state._persist,\n, set: (state, _persist) => ({...state, ._persist})\n}\n//\n{ get: state => state[1]._persist,\n  set: (state, _persist) => [{...state[0], _persist}, state[1]]\n} \n```\nThis would allow for any kind of customised state shape to be compatible with persist, not only about redux-loop.. ",
    "booleanBoy": "@lsunsi Did you ever get it to work with sensitive-storage and, I assume, redux-persist-sensitive-storage?\nEdit: sensitive-storage hadn't linked properly. After going through the manual android setup processes and rebuilding, everything worked fine.. ",
    "jakelazaroff": "Whoops, didn't see https://github.com/rt2zz/redux-persist/pull/459. Closing. Sorry about that!. ",
    "harshsrivastavaglobussoft": "yeah it worked \nthanks. ",
    "Hauuguu": "I'm also getting the \"update\" console.log in 5.0.0-beta.15 on line 25 in createPersistoid.js\nconsole.log('update', state);. Silly mistake with redux-saga. I was able to get around this by doing something along the lines of\nsagas.js\njsx\nconst flushData = persistor => persistor.flush();\nconst persistor = yield call(getPersistor);\nyield call(flushData, persistor);. ",
    "clodal": "Sorry found out this was a SSR issue, will check my config.. I fixed this issue by following the answer provided in this Stackoverflow question. @rt2zz Nice, you're already one step ahead!. ",
    "MarkGalloway": "Loading requires a react component.\n<PersistGate loading={<div>I'm loading</div>} ...>. ",
    "oferRounds": "This is my User class definition (the problem happens when I try to call photoURL()):\n```\nimport { Type, Expose } from 'class-transformer'\nimport 'reflect-metadata'\nexport class User {\n  readonly id: string\n  readonly firstName: string\n@Expose({ name: 'surname' })\n  readonly lastName: string\n@Type(() => Date)\n  readonly creationDate: Date\nreadonly about: any\n  readonly personal: any\nphotoURL(): string {\n    return this.about.avatar || ''\n  }\n}. @rt2zz got you, thanks!. ",
    "dbvt10": "same on V5. problem: components don't refreshing after rehydration, but the state changes. Components showing only initialState after dispatching action.\nResolved by adding handler to my rootReducer, as in the example. \nyou can implement same on childReducers for optimization, selecting correct reducer in action.payload.\n```js\nconst appReducer = combineReducers({\n  nav: navReducer,\n  data: dataReducer,\n  services: servicesReducer,\n  // components: componentsReducer,\n});\nlet nextState;\nconst rootReducer = (state, action) => {\n  switch (action.type) {\n    case action.type === 'SET_APP_RESET':\n      nextState = undefined;\n      return appReducer(nextState, action);\n // added this\ncase action.type === REHYDRATE:\n  nextState = { ...state, ...action.payload };\n  return appReducer(nextState, action);\n\ndefault:\n  return appReducer(nextState || state, action);\n\n}\n};```. ",
    "irisSchaffer": "We have the opposite problem: for us persist/REHYDRATE is firing uncontrollably sometimes. It also seems to be a timing issue, sometimes it works fine, other times IE11 keeps rehydrating in an endless loop.\n\nWe use both local storage and session storage, but the one that keeps re-firing is the session storage one, which we also sync across tabs with redux-persist-crosstab, which might also be the source of the problem (not tested yet).. Alright, yeah, removing redux-persist-crosstab solved the problem, will open an issue there instead.. ",
    "jonasgrunert": "Thanks a lot. I did not install v5 properly. But I did now and another error came instead. I did not change any code except for your advised changes, but got an error, which looks the following:\nundefined is not a function (evaluating 'baseReducer(undefined, {type: 'redux-persist/default-state-probe'})') and the error log points towards node_modules\\redux-persist\\lib\\persistReducer.js:55:35.\nThanks for your help. Do you have any further advise?. Ok that was an error in my code. Thank you very much.. I am unfortunately unable to tell you what I did, because it was so trivial I forgot it. But it is something in the code. So maybe you can provide your code and error and I try to help out?. ",
    "jawadulhassan": "What exactly was the error you fixed? Because I am facing the some sort of same error? . ",
    "mauron85": "Ok. I understand the problem. But what is the best way to merge incoming state with initial state?\nThis is actually problem when using filters.\nLet say state atom looks like this:\nSTATE = {\n  entities: {\n    deliveries: {},\n    rooms: {...},\n    ...\n  }\n}\nThen we filter entities.deliveries to be the only one persisted.\nconst entitiesSubsetFilter = createFilter(\n  'entities',\n  ['deliveries']\n);\nCurrent behaviour:\nAfter rehydration is completed entities.rooms will be undefined, which cause problems in selectors.\nExpected behaviour:\nAfter rehydration entities.room (which is in initial state) is merged with entities.deliveries.\nI see that there are now two actions: persist/PERSIST and persist/REHYDRATE in use,\nAfter action persist/PERSIST state atom is initial state and two function are passed (register and rehydrate).\nAfter action persist/REHYDRATE state is restored from storage overwriting initial state.\n\nIs is possible to merge those entites? @martin-rueegg mentioned transform function. Can it be used for merging? If so how?. Not 100% but I found some interesting behavior.\nI've tried to restore state to initial after REHYDRATE action in filtered reducer (see previous comment).\nexport default function roomsReducer(state = {}, action) {\n  if (action.type === REHYDRATE) {\n    return {};\n  }\n  return state;\n}\nThe interesting fact (for me) is that I have to return new empty state object. Only then entities.rooms will be added to state.\nIt seems like redux-persist is somehow aware of old state even though it's not present in state atom.. I managed to reproduce this scenario:\nTwo reducers R1 a R2. Only one of them is persisted (using t.com/mauron85/2eb37e2e3e5de6d).\nR1 is hydrated from localStorage. R2 should be initialized as empty object. There are two React components displaying data from both reducers. It works fine when localStorage is empty (first run). But when data are persisted and app restarted. R2 is not present state atom, causing error when selecting data from state.\nHow to reproduce:\n1. open https://jsfiddle.net/mauron85/v6tf9xma/\n2. Click on \"Add\" button to store some data in localStorage\n3. Refresh Browser (or hit Run)\n4. Open developer console. There will be error message:\nUncaught (in promise) TypeError: Cannot read property 'trackingNr:undefined' of undefined\n    at Function.mapStateToProps2 [as mapToProps] (<anonymous>:116:30)\n    at r (react-redux.min.js:1)\n    at p (react-redux.min.js:1)\n    at a (react-redux.min.js:1)\n    at react-redux.min.js:1\n    at Object.run (react-redux.min.js:1)\n    at p.onStateChange (react-redux.min.js:1)\n    at Object.a [as dispatch] (redux.min.js:1)\n    at Object.rehydrate (redux-persist.js:997)\n    at redux-persist.js:338\nUncomenting line 62: //return {};\nin roomsReducer seems to remove the problem, but it doesn't make sense to me.. @rt2zz \nIn that particular project I'm using ancient webpack 1.5.\nEdit: Can try with webpack 2 or 3, but I guess the result will be same. I have webpack babel-loader setup that is ignoring processing files from /node_modules/ folder to make build faster. As result those files from node_modules/redux-persist/es will have unresolved imports statements (basically those files will be used untouched with all those import statements).. lib build is exactly what I'm looking for. I was not seeing it somehow.. Ok, it make sense to me now. Specially point 2. about state inconsistency. Also I think double stringify is not problem for now (but maybe can be improved like you said).\nWhat I don't understand is point 3. - nested persisted reducers. Can you give me some example what are those?. That is actually pretty cool. In my react-native project I actually need to use two stores. One for small data and another one for quite large data.. ",
    "zhangwei900808": "it my fault! I had resolve it \nstore.js\n```\nimport {createStore, combineReducers, applyMiddleware} from 'redux'\nimport thunkMiddleware from 'redux-thunk'\nimport logger from 'redux-logger'\nimport {routerReducer, routerMiddleware, push} from 'react-router-redux'\nimport createHistory from 'history/createBrowserHistory'\nimport { persistStore, persistReducer } from 'redux-persist'\nimport storage from 'redux-persist/es/storage' // default: localStorage if web, AsyncStorage if react-native\nimport reducers from '../reducers'\nconst history = createHistory();\nconst historyRouterMiddleware = routerMiddleware(history);\nconst middleWares = [thunkMiddleware, historyRouterMiddleware,logger];\nconst config = {\n    key: 'root', // key is required\n    storage, // storage is now required\n};\nlet comReducers = combineReducers({\n    ...reducers,\n    router: routerReducer\n});\nconst persistReducers = persistReducer(config, comReducers);\nexport default function configureStore () {\n    let store = createStore(persistReducers, applyMiddleware(...middleWares));\n    let persistor = persistStore(store);\nreturn { persistor, store }\n\n}\n```\nbut there is a new error \n\n. thanks a lot. it resolve my problem,but there is a new error!\nconst App = () => (\n    <Provider store={store}>\n        <PersistGate\n            loading={<div />}\n            persistor={persistor}>\n            <ConnectedRouter history={history}>\n                <Switch>\n                    {renderRoutes(routes)}\n                </Switch>\n            </ConnectedRouter>\n        </PersistGate>\n    </Provider>\n);\n\n. ```\nimport React from 'react'\nimport {Provider} from 'react-redux'\nimport {ConnectedRouter} from 'react-router-redux'\nimport {matchRoutes, renderRoutes} from 'react-router-config'\nimport {Switch} from 'react-router-dom'\nimport { PersistGate } from 'redux-persist/es/integration/react'\nimport configureStore from './store'\nimport routes from './router'\nconst { persistor, store } = configureStore();\nconst onBeforeLift = () => {\n    // take some action before the gate lifts\n};\nconst App = () => (\n    \n}\n            persistor={persistor}>\n            \n\n                    {renderRoutes(routes)}\n                \n\n\n\n);\nexport default App\nthere is my app.js and we cant resovle the problem?. I had resolve my problem ,is my bad .\nimport React from 'react'\nimport {Provider} from 'react-redux'\nimport {ConnectedRouter} from 'react-router-redux'\nimport {matchRoutes, renderRoutes} from 'react-router-config'\nimport {Switch} from 'react-router-dom'\nimport { PersistGate } from 'redux-persist/es/integration/react'\nimport createHistory from 'history/createBrowserHistory'\nconst history = createHistory();\nimport configureStore from './store'\nimport routes from './router'\nconst { persistor, store } = configureStore();\nconst onBeforeLift = () => {\n    // take some action before the gate lifts\n};\nconst App = () => (\n    \n}\n            persistor={persistor}>\n            \n\n                    {renderRoutes(routes)}\n                \n\n\n\n);\nexport default App\n```\nwhen I add const history = createHistory(); in app.js it worked! :). ",
    "mezod": "thank you!\nMaybe it would be a good idea to add a link to it on the docs for this repo! :)\n. I can't help you with that right now, still struggling to fully understand how to get redux-persist to work :P but if it does, there'll be another instance of redux-persist-crosstab in production :). Hey, just wanted to let you know that both libs work wonderfully!\nI googled what \"out of wack\" means and is it possible that you meant \"out of whack\" (in the purge section)? (I didn't know this phrase in any case). What do you mean with that anyways? I hope it doesn't go out of whack!!\nI understand purge is to remove all the keys from localStorage. I need to do so when the user logs out. Since log out takes place in an action creator, which do you think would be the best way to have access to the store from there to be able to persistStore(store).purge()? I used to use getState() but it seems persistStore requires the store. Importing the singleton doesn't sound like a good idea either, right?\n. thank you @rt2zz! feel free to close this :-). hey @rt2zz one last doubt, I promise! When I use persistor.purge() it successfully removes all the keys from the localStorage except \nStorage {reduxPersist:basedate: \"null\", length: 1}\nbasedate is just a stringified date. When I purge it, it becomes null, but the key isn't removed from the localStorage. Why is it so?\nI'm not sure if it's related to this but I am trying redux-persist-crosstab and when 2 < tabs are open, and I log out from one (persistor.purge()) the current tab behaves as expected. However, in other tabs their redux state gets PARTIALLY rehydrated (actually, only the basedate gets overwritten), and thus the app keeps displaying some of the info. Shouldn't crosstab autrehydrate the whole state with a purge too?. Your reasoning made a lot of sense, but I never set this key to null in my app.\nIt's either initialized with:\nconst initialState = moment().toISOString();\nor set by a redux action in\ndispatch(fetchDatesSuccess(dates, moment().toISOString()));\nAlso, from redux dev tools I can see it's persist/REHYDRATE that sets it to null\n\nThis is the first action that redux dev tools inspector shows after purging from another tab.. ",
    "claykohut": "Also everything works when I download the library and use it directly / without npm.. ",
    "reblws": "I think I'm running into the same thing. The problem with installing from v5 is the source still needs to be compiled so the modules can be accessed from the es/ folder.  You can check if we're having the same issue if you don't see an es/ or lib/ folder in node_modules/redux-persist when you install the v5 branch.\nI've set up a a fork here with the files built so you can install from npm. Just set \"redux-persist\": \"reblws/redux-persist#v5\" in package.json.\n. Ah, just thought it would make it easier for you if you had to review less PRs. . I also made a PR regarding this in #507 . I considered that before but decided against it because it seemed like it would be duplicating the functionality of the transforms option in PersistConfig.. ",
    "colinramsay": "@rt2zz can I ask what the rationale is for having to use the next tag for a compiled release? It's currently pointing at 5.3.0-rc.2.. ",
    "jimji1005": "Hi\nI don't think its an asyncstorage issue, i have a different function that haven't been migrated to redux yet which still uses asyncstorage to store a string. that is working and the data persists from remote debut to remote debug off.\nI am going to test with debug true to see if it works as well as removing the object check. remove typeof self check fixed the issue. self seems to be undefined when remote debug is OFF.. ",
    "rskaar": "Of course! Sorry, I should have tried that! It works as expected with HMR and code splitted reducers.\nI've added a manual rehydrate action to my callback to cover the scenarios when I add new reducers (through code splitting).\n```javascript\nimport getStoredState from 'redux-persist/es/getStoredState';\n...\nconst onUpdateReducers(newRootReducer) => {\n  const newPersistedReducer = persistReducer(persistConfig, newRootReducer);\n  store.replaceReducer(newPersistedReducer);\n  persistor.persist();\n// Rehydrate state to make sure code splitted reducers get stored values\n  getStoredState(persistConfig).then((storedState) => {\n    store.dispatch({\n      type: REHYDRATE,\n      key: persistConfig.key,\n      err: undefined,\n      payload: storedState,\n    });\n  });\n}\n```\nI will then handle migrations \"outside of\" the redux-persist configuration.\nThank you very much for both the module and your reply!. (or even better, each code splitted module/reducers have their own redux-persist initiation and config...). This issue started when I was testing out ideas for a large scale react/redux app with a lot of codesplit modules using react-universal-component. I wanted to add persisted reducers on both the root-app, and for each module who needed it. When a module is requested, it's reducers (if any) would be added and rehydrated if they have any persisted data. HMR for both the core app, reducers and codesplit modules was also a 'requirement'.\nI'm using ReducerRegistry inspired from this example, and the change listener is what is described above as onUpdateReducers.\nI started it thinking I needed to use blacklist/whitelist to filter which reducers to persist. This kind of worked, but the rehydrate action then only rehydrated the persisted keys, and did not set the defaults on the keys that was not persisted. I found workarounds on this, but it did not feel 'right'.\nThen it hit me that I was doing it wrong, and finally figured out the way @rt2zz describes. I have dedicated (multiple) persisted reducers nested inside the \"rootReducer\".\njavascript\n{\n  'core/user': {\n    'persisted': {<initiate redux-persist here and add data to persist>},\n    '...': '<other non-persisted keys>',\n  },\n  'module/some-codesplit-module': {\n    'persisted': {<initiate redux-persist here and add data to persist>},\n    '...': '<other non-persisted keys>',\n  },\n}\nThis is in my opinion a cleaner way, then using blacklist/whitelist-magic. And each module have the possibility to define migrations and other configurations for its own data.\nMy change listener:\njavascript\nreducerRegistry.setChangeListener((reducers) => {\n  const newRootReducer = configureReducers(reducers)\n  store.replaceReducer(newRootReducer)\n  persistor.persist()\n})\nWorks with codesplit, HMR and even HMR on codesplit reducers.. ",
    "djeeg": "Thanks for the tips in this thread! \nMy state was only fully persisting on the first page render.\nPreloading code split reducers (eg hover over links to sub routes) would lose state after reducer rebind and then route change\nI also seem to need to flush before rebinding the reducers, is that expected?\nstore.isrebindingreducers = true;\n    store.persistor.flush()\n        .then(function() {\n            store.replaceReducer(\n                makeRootReducer(\n                    {} //initialState\n                ));\n            store.persistor.persist();\n            store.isrebindingreducers = false;\n        });\n. ",
    "umairfarooq44": "Can you please elaborate how to add reducer because after adding reducer new object with reducer name is created in the state and it have state from the local storage in that reducer and state updation of \"intl\" object in the above state is not affected by my reducer.. ",
    "veharrison": "Isn't there a way we can write our own reconcilers or mention merge levels in configuration.. ",
    "Zycon42": "I'm not sure if I made it clear but I don't have redux-form reducer as top level reducer it's mounted in state.form already where state is redux root. Changing default location of redux-form from state.form is supported but that makes usage very cumbersome. In v4 diffing is made for the whole state tree so it doesn't intervene with redux-form.\nWould it be possible to add some flag to persistReducer config that will turn this behaviour off to allow deleting reducer keys?. Yes I have formReducer wrapped with persistReducer. I have it like this to use different storages for different reducers (auth keys go to keychain, rest to AsyncStorage).\nThank you very much for your assistance.. ",
    "chawax": "I had exactly the same problem as @Zycon42 with 5.9.1 so it looks like it has not been solved.\nI solved it by purging manually the persisted state :\nexport const formPersistConfig = {\n  key: 'form',\n  storage: AsyncStorage,\n  whitelist: ['subscriptionForm']\n}\nimport { purgeStoredState } from 'redux-persist'\nimport { formPersistConfig } from '../../../ReduxPersistConfig'\npurgeStoredState(formPersistConfig)\nIt works because I have only one form in my whitelist, but not sure how it will work if I have more forms.. ",
    "dawidzq": "I'm wondering if the issue could lie in ng-redux, actually. ng-redux declares the return type of \"subscribe\" as Function when Unsubscribe seems like it would be more appropriate. I opened a PR here: https://github.com/angular-redux/ng-redux/pull/173.\nI wouldn't be able to do this in production, but changing the return type of subscribe to Unsubscribe did not break anything and also resolved the Typescript issue mentioned above. . ",
    "mazing": "Yes! Thanks for the quick reply! :-D. ",
    "14520582": "my store has 3 states: userinfo, car, cardetail\nmy code:\n fetch data userinfo (from server) -> dispatch action to change state\n next -> car\n finally -> cardetail\nuserinfo always is persisted\ncar sometime isn't persisted\ncardetail often isn't persisted\ndata of states is JSON array  and cardetail is quite long \nI'm sure the data is complete after fetching.\nand I'm sure rehydration is not the problem because data always is the same after rehydration. ",
    "jirikolarik": "I didn't even noticed, that there is a v5 version. I'll upgrade to that one..\nI don't know the error right now, I can get it later this day, but this commit fixed it. Great! Thanks :). ",
    "maplion": "@rt2zz without some good examples or proper documentation, I am finding it difficult to wire this up in such a way that I actually get the redux action to even fire. (especially with the recent changes using persistReducer and doing this in angular).  What does this tool give me that would be beyond installing something like localForage and just having some exit actions store locally and some on-load actions rehydrate [right now, this seems like it may be a more straight-forward path]?. @rt2zz Thank you for the response and information.  I would like to try to utilize it and will attempt to provide an angular example if I get it working.. ",
    "feimosi": "I've just successfully connected redux-persist with Angular 5 and ngredux.\nBasically, you have to create a store with plain redux and then provide it to the ngredux. I haven't implemented PersistGate counterpart in Angular yet but it works fine without it. Here's the code:\n```ts\nconst persistConfig = {\n  key: 'root',\n  storage,\n};\nconst persistedReducer = persistReducer(persistConfig, rootReducer);\nconst store = createStore(\n  persistedReducer,\n  rehydratedState,\n  compose(\n    applyMiddleware(...middleware),\n    ...enhancers,\n  ),\n);\nconst persistor = persistStore(store);\nthis.ngRedux.provideStore(store);\n```\n. ",
    "arkD": "@feimosi This is incredibly helpful! now i can use this powerful library, thank you so much!. ",
    "cnoter": "@rt2zz \nthanks for your help :). ",
    "ercpereda": "@rt2zz The problem is with this check https://github.com/rt2zz/redux-persist/blob/master/src/persistReducer.js#L59\nUsing redux-loop the defaultState is an array, with the actual defaultState object in the first element and some Effects in the second one.\nLet me know if you need some help to make a redux-loop integration.. @rt2zz thanks for taking care of this. I understand that changes that impact in performance would be a problem.\nJust like a note, redux-loop works excellent with redux-persist in the previous version.. ",
    "NathHorrigan": "Hi @rt2zz \nThanks for the quick response. Your first statement tipped me off to the problem; \nI'll expand on my problem/solution for anyone passing by:\nI had a 'rehydrated' value in my util reducer state that would allow me to know when state had been hydrated. What was happening was that when state was rehydrated it would return initial state with 'rehydrated' value as true (hence the problem, also see code example). My solution was to remove 'rehydrated' value/action case and use the one supplied by V5 of redux-persist under state._persist.rehydrated.\nThanks again!!\n```\n// Reducer Code\nconst initial = {\n  showOnboarding: true,\n  rehydrated: false\n}\nexport default (state = initial, action) => {\n  switch (action.type) {\n    case SHOW_ONBOARDING:\n      return Object.assign({}, state, {\n        showOnboarding: action.payload\n      })\n    case REHYDRATE:\n      return Object.assign({}, state, {\n        rehydrated: true\n      })\n    default:\n      return state\n  }\n}\n```. ",
    "mania25": "okay, thank you for your answer, it solved now, i didn't know that persistor was not a must to export, because it was not explained in documentation, i just only see the example without knowing why there is persistor variable declared in the example. ",
    "chen-fang-1992": "I've tried to put transforms into persistReducer config, while it still doesn't work. It seems redux-persist-transform-expire is only compatible with v4.\nMy situation is that I need to persist users login state in my web app, otherwise it will be lost when refresh page. However, if I use redux-persist, the state will be persist locally like forever. If users forget to click logout, the session will expire at server anyway while the client-side won't expire.\nAny kind advice is appreciated. Thanks.. I've tried sessionStorage instead of localStorage. Here is another problem, if I close browser tab, the session will be ended by redux-persist while the session at server is still alive.. ",
    "ninechung": "\nas the error says, you need transforms on the persistReducer config, not the persistStore config. The redux-persist-transform-expire are probably not updated for redux-persist v5 yet.\n\nbut it's ur example, i also encountered the same problem.. ",
    "gabeweaver": "@brave-merida - the loading prop is required. If you don't want to return a loader, you still have to specify loading={null}. It's not specified as a required prop, but that's what was broken for me at first. Hope it helps - https://github.com/rt2zz/redux-persist/blob/master/docs/PersistGate.md. @rt2zz I dunno...some other packages make a loader required (like https://github.com/thejameskyle/react-loadable), others don't. Personally I feel like it should not be required...because at that point, redux-persist is now enforcing a UX decision which i don't think packages should do necessarily. \nThat being said, to maintain react 15 compat, this seems to work based on the rudimentary example:\n```\ninterface Props {\n  children: any,\n  loading?: React.ReactNode\n}\nclass PersistGate extends React.Component {\n  public render () {\n    const rehydrated = false\n    const loading = false\nswitch (true) {\n  case loading && !rehydrated:\n    return <div>loading...</div>\n  case !loading && !rehydrated:\n    return false\n  default:\n    return rehydrated && this.props.children\n}\n\n}\n}\n```\nthat yields: \n<div id=\"root\"><!-- react-empty: 1 --></div>\nin the example, if you flip rehydrated to true, the children will then render...if you flip rehydrated to false and loading to true, you'll get the loading node. if you flip both to true, children render. I think you could take something like that and apply it the current PersistGate but replace rehydrated with this.state.bootstrapped and loading with this.props.loading. You could try not making your reducer a promise - as in remove the \u2018async\u2019 from the function. You\u2019re making your reducer a promise which is why you\u2019re having issues. Also you\u2019re mutating your state in the reset store reducer.... ",
    "brave-merida": "Thanks,\nI've tried without PersistGate. used only above code to create store!\nFirst, it's ok, but if I refresh the page then state.auth is null.  why and how to?. ",
    "SkyzohKey": "@rt2zz What the hell is the issue if not the one I guess it is so ? :/\nWhat makes me think it's a promise is the following: https://stackoverflow.com/questions/45944709/calling-async-function-return-promise-object-with-numbers-for-property-names. @rt2zz This can also be related to issue #179 as the same error message is thrown.\n. @gabeweaver You saved my day!! 3 days on this \"issue\" that was just a typo issue... Fresh eyes is cool sometimes, thanks!. ",
    "micnil": "I'm so glad that I found this. Using persistReducer(persistConfig, rootReducer) does not work if you are using the filter transform like redux-persist-transform-filter. The initial state of the values that were not saved, were overwritten to undefined. \nA suggestion is to put this in to the API docs. persistCombineReducers is not mentioned there and it doesn't say it is the recommended way to create to root reducer. \nIn any case, thank you for this awesome module! . ",
    "Hongbo-Miao": "Haha, thank you for the awwwwesome package!. @rt2zz thanks, I will leave it here. If you want to close, just go ahead and close. Thanks!. ",
    "therise3107": "Thank you @rt2zz. I'm closing this. Docs are fine just needs some more clarification on usage. I am just starting with redux-persist so I will gladly create PR's in coming days.. ",
    "thenameisflic": "I also need this, to check whether API tokens are still valid. As a workaround, i'm checking it after the user home page loads, but that's suboptimal.. ",
    "supercamilo": "This would be very useful to have.. You can actually call an async function with onBeforeLift.\nThis is what I have to use PersitGate to wait for the server sync before hiding a Splash screen:\nRoot component\nconst Root = function (): React$Element<Provider> {\n    return (\n        <Provider store={store}>\n                <PersistGate\n                    loading={<Splash />}\n                    persistor={persistor}\n                    onBeforeLift={() => StoreProvider.serverSync(store)}\n                >\n                        <RootComponent />\n                </PersistGate>\n        </Provider>\n    );\n}\nStoreProvider\nclass StoreProvider {\n   ....\n    static async serverSync(store: Store) {\n        const state = store.getState();\n        if (!state.questions || state.questions.length < 1) {\n           // Call the server when no questions on the storage\n            return api.fetchQuestions().then((questions) => {\n                store.dispatch({\n                    type: actions.Questions.REFRESH_QUESTIONS,\n                    questions,\n                });\n            });\n        }\n        return true;\n    }\n}\nI'm using v5.2.2 BTW.. ",
    "sam-vdp": "I am only getting blacklisted state if the blacklist was changed after the persist step. I was just slightly surprised by the change of behavior to v4 and thought maybe it should be mentioned in the docs, but it's probably too much of an implementation detail. Please feel free to close this.. ",
    "DavideDaniel": "Yeah.... this almost bit us with jwts getting stored... what needs to be done? Maybe we can move this along.. Can confirm that we are seeing this as well. I was looking for information about why only the first persistoid was working, and came across this. The last change that went in along with multiple nested reducers was us fixing hot module replacement.... ",
    "jamieparkinson": "Certainly agreed that this isn't a trivial problem! Also agreed on your first 2 points - regarding 1., I do like the simplicity of colocating _persist (ie redux can do the work for us) but, as we can see, it does introduce a bit of coupling to the data structures used...\n3 is tricky - I agree that providing a configurable interface between state and persistoid is a bit heavy although tbh wouldn't be totally averse to it. Have been mulling it over when I've had time over the past couple of days and an idea that I kind of like (albeit without being familiar with the codebase) is to make createPersistoid pluggable in some sense.\nI then envisage some kind of redux-persist-immutable-plugin which provides the necessary reconcilers, serializers, persistoids and so on (and a utility function to insert them all at once, perhaps). It would be a shame to significantly modify the code here just to support Immutable - but on the other hand it would be a shame to couple the library to having to use native objects. . ",
    "akread": "I am creating a react-native app now that is running v4.x successfully; however, we have not released it and I'd like to upgrade to v5.x before we do so we don't run into migration issues. We are not using immutable-js and are instead using seamless-immutable but I am running into similar issues with immutability.\nOn v4.x I was able to easily get it up and running using the stateReconciler to convert state to an immutable object. It is a little sad that it seems to be a step backwards (in this one specific regard) that this library is now so tied to the data type when it wasn't previously. From my experience it is pretty common for engineers to be using immutable objects when using redux for obvious reasons.\nI wanted to upgrade so we don't end up with stale library in our code-base (v4.x) as well has having built in migration/version support per reducer which was a huge plus for the project.\nAny further thoughts on the matter?\nI was liking the v5.x API though! Per reducer config makes much more sense in my opinion and should make migration, data management, and version control easier.. @Ewocker, that problem could be unrelated. Ignite doesn't come with the state fully immutable, only each substate (reducer) is Immutable. Check out redux-seamless-immutable. I'm not guaranteeing it will fix anything but I ran into a similar issue using ignite. If you have any questions about redux-seamless-immutable feel free to reach out to me since it is really unrelated to this bug. I don't want to clog up this issue.. ",
    "Ewocker": "Hi, I just start using redux-persist and I started off from ignite boilerplate.\nThey were using v4, which I change to use v5 instead now.\nEverything works perfect except when Immutable Transform.\nSo basically when every time after rehydration, it does a ImmutableTransform and I verify that the object is transformed into a Immutable object yet when reducer update the state, it will say state.merge is not a function because it is not an Immutable object. I am not sure if this is the same problem as above because I am still kind of new to the community but is certain that this is at least a related problem and somehow after transformation the data is transformed back into a JS Object.\nAnd Thanks 200% to the above work around, it saves up lots of my time. Looking forward to see the issue being resolved. (BTW, I am using seamless-immutable). ",
    "tuanluu-agilityio": "Hi @here,\nI got same issue with error: Unhandled Rejection (TypeError): state.merge is not a function when try apply redux-persist with seamless-immutable. Have any solution to resolved this issue don't use third-party like redux-persist-immutable-plugin???\n. ",
    "ZeroMcMuffin": "The 'link' comment was a little vague.  This SPA lives inside of another multi-page site.  Navigating to it from the link that launches the app vs hitting refresh on the browser produces different behavior.  \nI've removed the HMR code.  That isn't necessary for this.  I created a component to wrap the provider/router so I can tie into the life cycle methods and read the persistor/store state as you requested.   This was illuminating.  The persist gate is not rendering its child component after the REHYDRATE action unless we have empty storage or we hit refresh on the browser.  With empty storage or when hitting refresh, I see exactly what you describe:  empty registry and bootstrapped == true.  In the other scenario (link navigation), the loading component is perpetually displayed.. Strangely, if I have the developer console open in Edge...it also loads.  . The default-state-probe, PERSIST, and REHYDRATE actions are firing in all scenarios.  \nIn a normal scenario, it looks like PersistGate gets two events in handlePersistorState.  One with a bootstrapped of false, next a bootstrapped of true.    In the scenarios where this is failing, the second event of bootstrapped = true never arrives which is causing the perpetual loading component.. That didn't fix it, but I'm thankful either way.  . I've chipped away at this a little more.  The store dispatches the REHYDRATE action, but execution hangs around this point in redux-persist, preventing the PersistGate from giving the 'all clear' signal. \nhttps://github.com/rt2zz/redux-persist/blob/master/src/persistStore.js#L109-#L109\nAt some point the REHYDRATE dispatch is freezing.  I created a vanilla middleware to try and get some insight, but next(action) just freezes.  Hitting refresh fails....hitting refresh with Edge dev tools...success.  Bizarre... If I can't get people to not use edge...maybe they will just use it with developer tools enabled.  \ud83d\ude04 \n. This was unrelated to redux-persist, just as I'm guessing @rt2zz suspected.  It looks like another library was choking silently.  Sorry for the trouble!\n. Yeah.  We have a singleton wrapper around json-rules-engine that we populate with REHYDRATE'd data.  Passing it an empty array was blocking.  That dispatch would stall.  It looked like REHYDRATE was completing until I started debugging redux persist.  Thanks again!\n. ",
    "jeremie-stratumn": "Ok, thanks for that. Might be worth adding a line on the PersistGate doc as other users may have the same issue... ",
    "ahmad2smile": "I had the same issue. Got a bit hacky solution, recommended by official jest docs here. The solution by official docs here. ",
    "fredp96": "Solving both of these issues did the trick.\nI think it would be a good idea to precise which part of the PersistGate Component are required for it to work properly, I misunderstood the example it seems.\nThanks a lot for your help!. ",
    "jamieallen59": "That's exactly it. I was listening to the REHYDRATE action to check authentication.\nApologies. Didn't think this would affect the persistence! Thanks.\n. accidentally*. ",
    "uiii": "To get my point, the version is stored under that key, so it looks it's needed for a migrations to work. As I see in the code, createMigrate depends on it: https://github.com/rt2zz/redux-persist/blob/87c4dd2ca0702db7df3866a19a55c15013cd24cd/src/createMigrate.js#L22. ",
    "cheneywan": "The same problem... ",
    "Cariosvertel": "Same problem too. FYI, you can customize blank screen by modifying this line loading={<View />}. I know it's something trivial because it's detailed on doc, but I known it could be helpful for someone who read this post.. according to this line where error is fired, it should accept an object as payload, and seems that just stored data isn't being provided as it.\n . @sun2rise I tried this line: \nwatchman watch-del-all && rm -rf $TMPDIR/react-* && rm -rf node_modules/ && npm cache clean && npm install && npm start -- --reset-cache \nin order to reset my project but no success.\n. ",
    "sun2rise": "Same issue here.. the only difference is that I use AsyncStorage (that should be the proper choice with RN) and i see the component assigned to loading but then I'm stuck too\n```js\nimport { AsyncStorage } from 'react-native';\nconst config = {\n  key: 'root',\n  storage: AsyncStorage\n};\n``. @ranggarifqi , @Cariosvertel .. it all started working after a complete uninstall of the app and a new deploy withreact-native run-android`.\nMaybe the store was sill there but in a v4 fashion and everything, that's why you need to migrate or completely reinstall the app. ",
    "jmcol": "I'm having the same problem, as well. I reinstalled my client simulator and wiped all my cache. That helped the simulator start working again; however, once I attempted to persist data, I got the error again.. ",
    "rkleine": "I was having the same issue. This maybe is because you have a state with a root key that the value is not an object, for example:\njs\n{\n  posts: [], // this is ok, is an object\n  agreeToC: false // this is causing the issue because false can be deserialized\n}\nWhen trying to deserialized the above object will throw the error. Try to change to something like this\njs\n{\n  posts: [], // this is ok, is an object.\n  agreeToC: { accept: false } // this will fix the issue\n}\nIf you already have a persiste store with the error:\n\nAdd this line persistor.purge(); after const persistor = persistStore(store);\nReload the app so the store is purged, \nRemove/comment the line persistor.purge();\nReload the app and see if the issue is fixed\n\n@rt2zz can you validate this comment, thanks!. @ranggarifqi do you try my suggestion?. ",
    "sachin-sable": "@rt2zz I have combination of objects and non-objects. I am planning to update to v5 but this is the only thing that is stopping me as I am getting the same error stated above. I am using v5.4.0. Is there something I am missing to add or is my approach correct? Please help.. @rt2zz Thank you so much for help. I ended up converting all non object state to objects by grouping related items together. For e.g. globalLoading, error, isConnected, etc are grouped under object called \"networkState\". Thanks.. ",
    "DalalAbadi": "I am using firebase and react-redux and I solved this issue by adding this line \nimport _ from 'lodash';\n. ",
    "chrisbull": "I get this error with redux-persist@5.7.2 when I import autoMergeLevel2: \nimport autoMergeLevel2 from 'redux-persist/lib/stateReconciler/autoMergeLevel2'. ",
    "KDederichs": "Any chance we can get a fix for that in v4?. ",
    "nnnoel": "Yeah, I didn't mean to prevent any other test cases from using an accessible global storage type. The aim was to prevent the fallback error during tests, which occurs a lot when you're testing a big application. I could move the conditional to process.env.NODE_ENV !== 'production' && process.env.NODE_ENV !== 'test' before falling back on memory storage, but if you're suggesting otherwise, then feel free let me know. @rt2zz @jozsi should be good now \ud83d\udc4d \n. ",
    "jozsi": "I am also facing this issue.\n@rt2zz - your proposed alternative would be to use memoryStorage from the test utils for tests?\nThe problem is that I can't reall find that file in the published npm package.. @rt2zz - I noticed your new storage-memory package, thanks for it! I guess it worths mentioning it here.\nAs an alternative for those who don't want to configure a different type of storage for the tests, jest-localstorage-mock gets the job done.. ",
    "NotTooReact89": "thanks rt2zz but those instructions just says remove autoRehydrate and nothing mentioned about what would autoRehydrate replace? . still an issue for me. when i try to use storage in my reactjs app I get the following error \n\n./src/Config/ReduxPersist.js\nModule not found: Can't resolve 'redux-persist/lib/storage'\n\nUsing redux-persist 4.1.0. ",
    "allenmanning": "I just hit this too.  I'm now debating if I should stick with V4, which makes me wonder what the future is with this project.  Maybe you should consider making a new project if you only have an experimental migration path.  This may be good food for thought on breaking changes such as this:\nhttps://www.youtube.com/watch?v=oyLBGkS5ICk. Fair enough, thanks for the response.  It is a cool project thanks for maintaining it.. ",
    "corysimmons": "@rt2zz Agree with not maintaining multiple APIs/etc. But it would be nice to have some official upgrade docs (on the repo Wiki?) from v4 to v5.\nThanks for your hard work!. It's up to you. tbh I wrote that before I even tried to implement (just as a \"good housekeeping\" kinda chore), but when I actually implemented it couldn't have been easier.\nThe only bit of docs I think could use work is with https://github.com/wix/react-native-navigation\nI found the GH Issue and the SO comment, but still had to do some tinkering to get it to work right. Clean docs on that would be great.. Thanks for clearing that up. =). ",
    "ElvisChiang": "fixed in #556 . ",
    "inv2004": "I just checked my change:\nconst reducer = persistCombineReducers(config, reducers)\nSo, I had two arguments for it.\nupdated initial issue.. ",
    "rahkumar2": "Hi rt2zz,\nI am trying to use PersistGate (using V5 redux-persist) to delay rendering, but it's not working as expected.\nI even tried without PersistGate, I am able to see state available after rehydration, but component is getting rendered before state gets available.\nI am waiting for your reply. Thank you.\n  . Hi Shhzdmrz,\n    Actually I am working from last 4 days on redux state persistence, but still not done. I think you have already been working on this. Can you please share the sample working code for reducer (for multiple reducer), store, routes, and connected component (just rehydration part of code) ?\nThank you.. Thanks Shhzdmrz.\nI already have taken a look into that. I have similar logic, but it's not working.\nDo you know any custom logic to delay the render until rehydration ?. No, I did not use that as I don't know the usage of it. But it's working now, actually there was problem with our customized form .js file itself.. ",
    "raphkr": "@rengarima Have you solved your problem statement ? If yes, is it possible to share your solution, as I am looking at a similar use case. \n. Just for consideration, as an alternative way with redux-reset, here is what I am doing.\nconst onBeforeLift = async () => {\n  try {\n    const key = await AsyncStorage.getItem('@keyStore');\n    if (!key && key !== 'installed') {\n      persistor.purge();\n      await AsyncStorage.setItem('@keyStore', 'installed');\n      store.dispatch({\n        type: 'RESET',\n      });\n    }\n  } catch (error) {\n    persistor.purge();\n    await AsyncStorage.setItem('@keyStore', 'installed');\n    store.dispatch({\n      type: 'RESET',\n    });\n  }\n};. ",
    "tvorogme": "Let me check, and then I'll close the issue.. All works fine. \nThanks!\n\n. ",
    "veeramarni": "I was able to get rid of that error after using lib\nIs there anything additional step I need to take care to run as SSR. I'm not expecting to save anything in redux-persist until the app opens in the browser. Or by leaving as it is won't harm anything?\n. ",
    "yugantar7": "@pedropeixoto I am also using the same libraries and have the same issue between Chrome and Firefox. Did you find any solution to it?. ",
    "echoes221": "@rt2zz The flexibility is great that's for sure. \nI don't mind doing a deep import - you mention it in the docs for hardSet too. Just worried if that ends up a little bit brittle going forwards. Anything that can be used alongside the setup/config in redux-persist, even auxiliary pieces (a la constants) should possibly be exported as an object (e.g. reconcilers {}. Just my two cents anyway.\nHappy enough to do the deep import which will allow mimicking the normal behaviour anyway :). Closing, thanks for the help.. ",
    "momosh": "Thanks for a quick answer. Well either is fine, and I really don't mind it, since now I'm sure it won't show in production. And if you want my opinion, I think that debug flag is nice \ud83d\ude42 . ",
    "alexgurr": "Any chance we could achieve this soon? I'm happy to help. I'm just thinking about current project deadlines and whether I need to start looking for alternatives :)\nI know indexed DB supports direct insertion of objects without serialising first. (That's how I tested blobs). Should just be a case of propagating some prop.. Good shout. My implementation supports custom serialise/deserialise functions though (including turning them off), rather than just on or off.. Serialising is not the same as transforming though. Transforming allows us to manipulate state before storage, whereas serialising is determining the format of the data in state.. Exposing serialize/deserialize allows us to pass an empty function and turn them off effectively.. ",
    "gocard": "That worked.  Thanks, and thanks for your work on this library!. ",
    "TSMMark": "@gocard I'm glad you got it working! Do you still have that code and would you mind contributing it? https://github.com/rt2zz/redux-persist-crosstab/issues/15#issuecomment-347390657\nIf you don't have time for a formal PR I might take a shot at it later this week, but anything you could share in the meantime would be fantastic . @damianobarbati \n\n@TSMMark referenced this issue in rt2zz/redux-persist-crosstab on Dec 13, 2017\nv5 compat https://github.com/rt2zz/redux-persist-crosstab/pull/17. Any problems with this or can we get a merge? \ud83d\ude04 . \n",
    "kevinleeTCA": "@rt2zz thank you for your reply, I am not sure whether renaming will fix it or not. \nI put my storeBuilder in a shared project, which is shared by both web and mobile, this might be the problem, if I put \nimport storage from \"redux-persist/es/storage\";\nin the react-native project, it fixed the problem.  So even our persistConfig is in the shared project, we have to provide storage separately in both react and react-native project, and merge the persistConfig with the default config, as follows:\nshared project: \n```\nconst defaultPersistConfig = {\n  key: \"root\",\n  transforms: [immutableTransform()]\n};\nconst storeBuilder = (persistConfig: {\n  storage: Object\n}): AiloStoreBuilderReturnType => {\n  const reducer = persistReducer(\n    { ...defaultPersistConfig, ...persistConfig },\n    rootReducer\n  );\n  let store = createStore(reducer);\n  let persistor = persistStore(store);\n  return { persistor, store };\n};\n```\nboth react and react-native have to do:\nimport storage from \"redux-persist/es/storage\";\n...\nconst { persistor, store } = storeWithMockData({ storage });\nthen it will work.\nThank you for your help. :). ",
    "programmer-RN": "Hi @kevinleeTCA , where I can find the storeWithMockData? I am new in redux persist and first time implement redux persist v5.. Hi, I am new in redux persist, I am facing the error of redux-persist failed to create sync storage, falling back to memory storage, may I know which part am I missing? . ",
    "daramasala": "When you setup your store you can do the following:\n```JS\nlet rehydrationComplete\nlet rehydrationFailed\nconst rehydrationPromise = new Promise((resolve, reject) => {\n  rehydrationComplete = resolve\n  rehydrationFailed = reject\n})\nexport function rehydration () {\n  return rehydrationPromise\n}\nexport default (initialState = {}) => {\n  // ... setup middleware and all the other boiler plate\n  const persistor = persistStore(store)\n  sagaMiddleware.run(rootSaga)\nrehydrationComplete() // if you detect that an error occurred during rehydration you can call rehydrationFailed\n  return { store, client, persistor }\n}\n```\nYou're exporting a function that returns a promise that resolves when the store is rehydrated.\nYou can then use it anywhere, incl. in background jobs, like this:\n```JS\nimport {rehydration} from '...'\nawait rehydration() // this will continue when rehydration is complete. If the store is already rehydrated, it will continue immediately because the promise is already resolved. If rehydration failed, it will throw an exception\n```. ",
    "Vict0rSch": "using @rt2zz's 1. method, I got an error: \n```\nTypeError: Cannot read property 'skipRestore' of null\n// defaults\n  13 | // @TODO remove shouldRestore\n\n14 | var shouldRestore = !config.skipRestore;\n  15 | if (process.env.NODE_ENV !== 'production' && config.skipRestore) console.warn('redux-persist: config.skipRestore has been deprecated. If you want to skip restoration use createPersistor instead');\n  16 | \n  17 | var purgeKeys = null;\n```\n\nAnyone has a clue what to put instead of null then?. ",
    "Jacse": "I'm currently just doing the following in store.js:\n```js\nconst persistedReducer = persistReducer(persistConfig, rootReducer);\nconst store = createStore(persistedReducer, composeEnhancers(applyMiddleware(thunk)));\nexport default (cb) => {\n  const persistor = persistStore(store, null, cb);\n  return { store, persistor };\n};\n```\nBut I run into an issue where the store in the background isn't persisted to the foreground.... ",
    "mark-slepkov": "Hey, guys. I solved this problem using code like this.\n```\nimport {PersistGate as PersistGateClient} from 'redux-persist/integration/react';\nclass PersistGateServer extends React.Component {\n    render() {\n        return this.props.children\n    }\n}\nclass App extends React.Component {\n    render() {\n        let runtime = process.env.RUNTIME;\n        let PersistGate = PersistGateServer;\n        if (runtime === 'browser') {\n             PersistGate = PersistGateClient\n        }\n        return (\n                \n\n\n        )\n    }\n```\nI hope it is helpful for you.. same thing happens for me. I have found the reason and solution. I was using next webpack settings\n\nremove'./' from your setting and it will solve the trouble.\nP.S. Make sure you replaced all import 'source_file_from_same_directory' with import './source_file_from_same_directory' in all your source code. ",
    "DBosley": "@mark-slepkov: How did you mock out or load the persistor server side? I'm using the localstorage option for redux-persist, so you can't really load the persistor when server side rendering.. ",
    "awwong1": "I came across this issue when running my own SSR React application.\nI'm currently seeing no issues just stubbing in PersistGate with no props defined:\n```ts\n// client.ts\nconst appLayout = createElement(ApplicationLayout);\nconst withRouter = createElement(BrowserRouter, undefined, appLayout);\nconst withRedux = createElement(ReduxProvider, {store}, withRouter);\nconst withPersist = createElement(PersistGate, {loading: null, persistor}, withRedux);\nconst withHelmet = createElement(HelmetProvider, undefined, withPersist);\n// server.ts\nconst appLayout = createElement(ApplicationLayout);\nconst withRouter = createElement(StaticRouter, { context: {}, location: req.url }, appLayout);\nconst withRedux = createElement(Provider, { store }, withRouter);\nconst withPlaceholderPersistor = createElement(PersistGate, null, withRedux); // no persistor! just for structure\nconst withHelmet = createElement(HelmetProvider, { context: helmetContext }, withPlaceholderPersistor);\n``\n. Read the source code, saw that I did not understand the logic properly, decided to use thehardSet` state reconciler instead. Sorry! Thanks again for such a great library.. ",
    "vshy108": "okay, will read how redux-persist-transform-immutable works. thanks. Unfortunately, the object class I tried to rehydrate is CognitoUser class that has many different classes as its object value. So the suggested method is somehow very complex to implemented in my case. But no worry, the package has a helper to restore the class from AsyncStorage in React Native somehow. Redux persist is not restrict to React-Native hence maybe harder to solve this problem?\nThe helper code from\nreact-native-aws-cognito-js/src/StorageHelper.js. ",
    "outaTiME": "(for now) To solve this what I did  was to change the configuration key to force fresh start to 0.2.1 version, but it would be ideal to execute purge (one time) to remove all the data saved previously, here the code:\njs\nconst config = {\n  key: 'root-v0.2.1',\n  storage: storage,\n  version: 1,\n  whitelist: ['user', 'roadmaps'],\n  transforms: [\n    encryptor\n  ],\n  debug: __DEV__,\n  // migrate: createMigrate(migrations, { debug: __DEV__ }),\n}\nconst reducer = persistCombineReducers(config, reducers). Hi @rt2zz, I need to clean my storage for a specific version and only once.\nI\u2019m using the following code:\njs\nconst migrations = {\n  1: (state) => {\n    return {};\n  }\n}\nconst config = {\n  key: 'root',\n  storage: storage,\n  version: 1,\n  whitelist: ['user', 'roadmaps'],\n  transforms: [\n    encryptor\n  ],\n  debug: __DEV__,\n  migrate: createMigrate(migrations, { debug: __DEV__ }),\n}\nThe problem is this is executed every time and I need to clean my storage only once (note I try with version 0 and the same effect).. Great @dziamid, but @rt2zz what about this? this should not be handled automatically by the migrator?. @rt2zz any way to deal with that? it could be possible? i need to achive that using @dziamid way?\nthanks !!!. Same \ud83d\ude21. @jarvisluong yup im switch back to ~5.6.0. ",
    "mzafer": "Hi @landpy, did you figure this out ?\n. ",
    "testlump": "You should be able to dispatch a PURGE action to the store and this will invoke the purgeStoredState method. Rough example below:\nReducer: \n```\nimport { PURGE, REHYDRATE } from 'redux-persist';\nfunction myReducer(state = {}, action) { \n     switch(action.type) { \n          // [....Your other reducer actions...]\n           REHYDRATE:    // This added just to show that this action type also exists, can be omitted. \n                  console.log(\"REHYDRATING!!!!\");  \n                  return state;\n           PURGE: \n                  console.log(\"PURGING!!!!\"); \n                  return {};    // Return the initial state of this reducer to 'reset' the app \n     }\n}\n```\nTest Component: \n```\nimport React from \"react\";\nimport { PURGE } from 'redux-persist';\n// Generate  with a button that will purge the persisted store\nclass TestComponent extends React.Component { \n      constructor(props) { \n         super(props);\n      }    \n  onPurgeStoredState(e) { \n        e.PreventDefault();\n\n         const { dispatch } = this.props;   // Grab a ref to the mapped dispatch method\n\n         // Create and dispatch the action which will cause redux-persist to purge\n         dispatch({ \n              type: PURGE,\n              key: \"myStorageKey\",    // Whatever you chose for the \"key\" value when initialising redux-persist in the **persistCombineReducers** method - e.g. \"root\"\n             result: () => null              // Func expected on the submitted action. \n          });        \n   }\n\n   render() { \n         return(<button onClick={this.onPurgeStoredState.bind(this)}></button>);\n    }\n\n}\nfunction mapStateToProps(\n    state,\n    ownProps\n) { \n    return state;\n}\nfunction mapDispatchToProps( \n    dispatch\n) {\n   return { dispatch };     // Map dispatch method to this.props.dispatch\n}\nexport default connect(mapStateToProps, mapDispatchToProps)(TestComponent);\n```\nWire in the reducer and test component into your app and you should (hopefully) find when you click the button, the store is cleared and messages are logged to the console. \n. ",
    "tommyalvarez": "@rt2zz i landed here accidentally after hours of google searching on why redux-persist wasn't persisting to my local storage a state change in session reducer after user was logged out. During logged out i just cleared the session to the initial state (without mutating of course), but redux-persist didn't appear to persist the newly blank values into local storage and hence... on a refresh the auto rehydrate would bring back the values as if the user was still logged in. \nI can of course confirm that persisting was working because inspecting the local storage, the values were there saved. Do you know why this happens ? Version 5. I was expecting all changes on the reducer to be persisted immediately. Of course i ended up using your alternative 2 solution, but i'm curious anyway\nRegards. @Kevin-Do Yup, that did the trick. Everything's working like a charm now. I clean the session in redux + purge, because purge will only clean the localstorage. . After more googling and checking the redux-persist documentation (on v5), i updated my project following strictly how to initiaize this library and i did not have to manually purge nothing else anymore. It's now working out of the box for me. So guideline rule: If you are manually calling purge or persist, or triggering action creators of the lib by hand... you're doing something wrong setting it up.. @bruno-edo sure, here it goes:\nmain.js => Where all starts in my client-side app\n```\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport createStore from './store/createStore'\nimport { hot } from 'react-hot-loader'\nimport AppContainer from './containers/AppContainer'\nimport { persistStore } from 'redux-persist'\n// ========================================================\n// Store Instantiation\n// ========================================================\nconst initialState = window.INITIALSTATE\nconst { history, store } = createStore(initialState) // => Magic configuration of redux-persist happens inside here, check out below in createStore.js\n// begin periodically persisting the store\nlet persistor = persistStore(store)\nstore.persistor = persistor\n// code ommited for brevity... here goes the initialization of the AppContainer with the ReactDom.render seen in every react-create-app tutorial\n```\ncreateStore.js: \n```\nimport { applyMiddleware, compose, combineReducers, createStore } from 'redux'\nimport thunk from 'redux-thunk'\nimport { apiMiddleware } from 'redux-api-middleware'\nimport { createLogger } from 'redux-logger'\nimport makeRootReducer from './reducers'\nimport { routerMiddleware } from 'react-router-redux'\n// I18n\nimport { syncTranslationWithStore, loadTranslations, setLocale } from 'react-redux-i18n'\nimport { translationsObject } from 'translations/index'\n// Router history\nimport createHistory from 'history/createBrowserHistory'\n// Raven for Sentry\nimport Raven from 'raven-js'\nimport createRavenMiddleware from 'raven-for-redux'\nimport { persistReducer } from 'redux-persist'\nimport storage from 'redux-persist/lib/storage'\nimport { createBlacklistFilter } from 'redux-persist-transform-filter'\nimport immutableTransform from 'redux-persist-transform-immutable'\n// Do not persist unauthorized param of session state, this is custom for my project not needed\nexport const saveSubsetBlacklistFilter = createBlacklistFilter(\n  'session',\n  ['unauthorized', 'loading']\n)\nexport const persistConfig = {\n  key: 'root_key',\n  storage,\n  whitelist: ['session'],\n  transforms: [saveSubsetBlacklistFilter, immutableTransform()], // Im using immutable in sub reducers so... need this\n  debug: true\n}\nexport default (initialState = {}) => {\n// ... unrelated code ommited for brevity, middlewares and such.\n//  check makeRootReducer also! has more redux-persist config \nconst persistedReducer = persistReducer(persistConfig, combineReducers(makeRootReducer()))\n// =====================================================\n  // Store Instantiation and HMR Setup\n  // =====================================================\n  const store = createStore(\n    persistedReducer,\n    initialState,\n    composeEnhancers(\n      applyMiddleware(...middleware),\n      ...enhancers\n    )\n  )\nstore.asyncReducers = {}\n// DEPRECATED in react-router v4: To unsubscribe, invoke store.unsubscribeHistory() anytime\n  // store.unsubscribeHistory = browserHistory.listen(updateLocation(store))\n// Critical if you have react-hot-loader and webpack v4.\n  if (module.hot) {\n    module.hot.accept('./reducers', () => {\n      const nextRootReducer = makeRootReducer(store.asyncReducers)\n      store.replaceReducer(persistReducer(persistConfig, combineReducers(nextRootReducer)))\n    })\n  }\nsyncTranslationWithStore(store)\n  store.dispatch(loadTranslations(translationsObject))\n  store.dispatch(setLocale('es-AR'))\nreturn { history, store }\n}\n```\nreducers.js:\n```\nimport { combineReducers } from 'redux'\nimport { persistReducer } from 'redux-persist'\nimport session from '../modules/sessions/session'\nimport { routerReducer } from 'react-router-redux'\nimport { i18nReducer } from 'react-redux-i18n'\nimport { reducer as toastrReducer } from 'react-redux-toastr'\nimport { reducer as formReducer } from 'redux-form/immutable'\nimport { persistConfig } from './createStore'\nexport const makeRootReducer = (asyncReducers) => {\n  return {\n    i18n: i18nReducer,\n    toastr: toastrReducer,\n    session,\n    router: routerReducer,\n    form: formReducer,\n    ...asyncReducers\n  }\n}\n// This is needed if you use reducer code split (you don't put ALL your reducers in the makeRootReducer function...). \nexport const injectReducer = (store, { key, reducer }) => {\n  if (Object.hasOwnProperty.call(store.asyncReducers, key)) return\nstore.asyncReducers[key] = reducer\n  store.replaceReducer(persistReducer(persistConfig, combineReducers(makeRootReducer(store.asyncReducers))))\n  store.persistor.persist() // => I think this is not needed anymore, i left it here when i was trying to make all this work together...\n}\n```\nHope it helps you!. Happened to me also with the latest version v5.10.0 on web version. @PaliwalSparsh downgrade to 5.6.12 it will work, until a solution is merged. @ajaymore please reopen the issue. @ejbp you can't use combineReducers and persistCombineReducers in combination since persistCombineReducers uses combineReducers under the hood. It says it in the documentation. Im surprised that browser console didn't throw an error. @ChrisJVoss shouldn't you be using persistCombineReducers instead of persistReducers? . @kg912 you shouldn't need to manually call persistor.flush(). On redux state change, if the reducer key is whitelisted, it should automagically store in localStorage the reducer state. \nDid you check using redux dev tools that the ui user state actually change after dispatching an action in the reducer ?. @kg912 No, if you want to persist all your reducers states you should not specify either whitelist nor blacklist arguments. However, i would recommend whitelisting so only the parts of the state that you really need persisted, are actually persisted. Otherwise you could end up with a heavy persisted state into localStorage. That aside, after state change, go check in your chrome console Application tab, if in the localStorage your data is correctly persisted.\nNOTICE: I'm seeing in your code that you are using combineReducers. In redux-persist v5, you need to use persistCombineReducers, though it's a little bit hidden, i think it's not in the docs but i read it up on a blog on medium or don't remember quite well but if you google persisteCombineReducers you will see...\nSo, it should be something like this:\nimport { persistCombineReducers } from 'redux-persist'\nconst persistedReducer = persistCombineReducers(persistConfig, {\n   your_reducers,\n   ...asyncReducers\n}));\nIf  not working, the probable causes are:\n- This Library misconfiguration\n- For some reason state is mutating, which i think is impossible since you are using immutable\n- You're not using correctly perhaps in RootComponent (i mean the first component of your app)  the <PersistGate> component ? That component with the argument persistor is what prevents rendering the app until the store is rehydrated with data coming from the localStorage.\nBut in conclusion you should neither call persistor.flush() nor manually dispatch any redux-persist reducers actions like persist/REHYDRATE, persist/PERSIST, etc... it works out of the box when correctly setup.\nAnd to your last question, i don't have experience with redux-persist and immutable transforms because i don't use the immutable lib, so i don't know what to answer to that. If you're still banging your head against the wall, try persisting just one of your reducers state without using immutable, make it work and start from there.\n. @EgidioCaprino Maybe by chance you're mutating state somehow? . @EgidioCaprino  By principle in redux you should never mutate reducers state. You should\nalways return new objects with the contents also being new objects. That\u2019s\nwhy the immutable lib is so popular in react-redux app but well, you can do\nit manually.\nRedux-persist fails to persist state if its mutated because it doesn\u2019t\nrecognize it as a change if the new state is not a new object\nOn Tue, 14 Aug 2018 at 13:49 Egidio Caprino notifications@github.com\nwrote:\n\n@tommyalvarez https://github.com/tommyalvarez what do you mean exactly?\nYes, I'm mutating state through the reducer I've posted above.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/rt2zz/redux-persist/issues/879#issuecomment-412939911,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ACKsx5gN93WrCX_ULPYmsFQRYZiCAgmqks5uQv-ggaJpZM4VvaK1\n.\n. @gastonmorixe You shouldn't be calling purge manually. There's something wrong on how you're setting up this library and that's why it's not working consistently. For me it's working perfectly fine and i'm not purging or persisting nothing by hand. Check: https://github.com/rt2zz/redux-persist/issues/579#issuecomment-412571169 , i uploaded my example source code for someone with similar issue. @gastonmorixe in that case i can't help you much and maybe you should open an issue in that github repository. Nonetheless, i eye peaked that framework and seems that redux-persist comes as a plugin, that is documented and should work out of the box. You don't need to purge anything because when you sign out, you \"clear\" your session/auth whatever you call it reducer state. That \"cleanup\" of the session reducer state should end up persisted and hence, the user should not be able to visit authenticable views any more.\n\nYou should see in your browser's localstorage console tab, that when you access your app for the first time, you have an initial persisted state under the root key you configured in the plugin. That state is the serialized version initial state of each reducer that is whitelisted for persistance. So... if you reset your session reducer state back to its initialState on log out, everything should be ok  . @waynebloss The persistor.purge method uses a reducer under the hood to clear the state (it actually clears the localStorage and on rehydrate it loads the new 'cleared' state depending on how you set up stateReconciler.\nI was just pointing out the general intended way of using this library for the particular use case of sign out and proposing a common used solution, which is clearing your store session state and let redux-persist handle the rest by itself. Anyway, it's impossible to figure out why it's not persisting the state anymore when using purge without seeing initialization code example and the localStorage value after purge. We need more info. @gastonmorixe if you be so kind to provide it :). @Tackgnol i managed to partially do it with some hacky method that i uncovered deeply from stackoverflow. But this is definetely not the way\n```\nimport { reducer as formReducer } from 'redux-form/immutable'\nimport { persistConfig } from './createStore'\n// Only way to 'blacklist' particular redux forms\nconst ignoreRehydrate = (state, action) => {\n  switch (action.type) {\n      case REHYDRATE:\n        return state\n      default:\n        return state\n  }\n}\nconst formPlugin = {\n  addProduct: ignoreRehydrate,\n  addSupplierForBiddingItemBid: ignoreRehydrate,\n  closed_biddings_filter_form: ignoreRehydrate,\n  editApprovedBidding: ignoreRehydrate,\n  editPendingBidding: ignoreRehydrate,\n  editUser: ignoreRehydrate,\n  newComment: ignoreRehydrate,\n  newUser: ignoreRehydrate\n}\nconst reduxFormReducer = formReducer.plugin(formPlugin)\nexport const makeRootReducer = (asyncReducers) => {\n  return {\n    i18n: i18nReducer,\n    toastr: toastrReducer,\n    session,\n    router: routerReducer,\n    form: reduxFormReducer,\n    ...asyncReducers\n  }\n}\n```. ",
    "Kevin-Do": "@tommyalvarez Hi Tommy, I'm facing the same situation as you. I'm clearing the session on log out. Did you end up just calling persistor.purge() on log out? . @tommyalvarez Awesome, thanks!. ",
    "moahammadalt": "you can use this:\nimport { persistStore } from 'redux-persist';\nand anywhere you want:\npersistStore(this.props).purge();. ",
    "bruno-edo": "@tommyalvarez could you provide an example showing how you're setting up everything?\nCurrently I'm facing the exact same issue you were having and I thought calling the persistor.purge() method was an ok alternative.. I'm having the exact same issue that @peterlazar1993 described. I wish to blacklist only one key from one of my reducers.\nCan confirm that it doesn't work for me either.. Okay, think I figured it out. So, in @cymen code his configs look like this:\n```javascript\nconst rootPersistConfig = {\n  key: 'root',\n  storage: storage,\n  whitelist: ['auth']\n}\nconst authPersistConfig = {\n  key: 'auth',\n  storage: storage,\n  blacklist: ['error']\n}\n```\nWhich don't work and are the same thing I'm using in my project. \nIf we add a blacklist key to  rootPersistConfig things should work as intended (I tested it in my app and was able to stop persisting one specific key from my reducer).\nThis should work:\n```javascript\nconst rootPersistConfig = {\n  key: 'root',\n  storage: storage,\n  whitelist: ['auth'],\n  blacklist: ['auth'],\n}\nconst authPersistConfig = {\n  key: 'auth',\n  storage: storage,\n  blacklist: ['error']\n}\n```\nThis behaviour is really weird and I believe a better explanation about how nested persist work (and how to implement them) should be added to the docs, the example in the README is really vague and leads to confusion when using the feature.. ",
    "namklabs": "\nyou can use this:\nimport { persistStore } from 'redux-persist';\nand anywhere you want:\npersistStore(this.props).purge();\n\nI'm using this before my app is rendered for debugging purposes. If something gets messed up in my localStorage, I can reset it by visiting /?debug\nif( window.location.search === '?debug' ){\n    persistor.purge();\n}\nrender(\n    <Provider store={store}>\n        <PersistGate loading={null} persistor={persistor}>\n            <Router history={history}>\n                <App/>\n            </Router>\n        </PersistGate>\n    </Provider>,\n    document.getElementById('root')\n);.\n",
    "mouthzipper": "Integration with react-boilerplate:\n1: edit reducers.js something like this:\nimport { persistCombineReducers } from 'redux-persist';\nimport session from 'redux-persist/lib/storage/session';\nconst config = {\n  key: 'root',\n  storage: session,\n};\nexport default function createReducer(injectedReducers) {\n  return persistCombineReducers(config, {\n    route: routeReducer,\n    global: globalReducer,\n    language: languageProviderReducer,\n    ...injectedReducers,\n  });\n}\n2: edit configureStore.js something like this:\nimport { persistStore } from 'redux-persist';\nconst persistor = persistStore(store);\nreturn { persistor, store };\n3: edit app.js\nimport { PersistGate } from 'redux-persist/es/integration/react';\nconst { persistor, store } = configureStore(initialState, history);\nconst render = (messages) => {\n ReactDOM.render(\n    <Provider store={store}>\n      <PersistGate persistor={persistor}>\n        <LanguageProvider messages={messages}>\n          <ConnectedRouter history={history}>\n            <App />\n          </ConnectedRouter>\n        </LanguageProvider>\n      </PersistGate>\n    </Provider>,\n    MOUNT_NODE\n );\n};. @shekhardesigner I forgot to mention that I'm using v4.10.2,\nI think my solution won't work on the new version anymore. Need to check the docs in migrating to v5.X. @shekhardesigner you are correct, if you decided to use 4.10.2\n-- add/edit below codes in configureStore.js\nimport { persistStore, autoRehydrate } from 'redux-persist';\n...\n  const enhancers = [\n    applyMiddleware(...middlewares),\n    autoRehydrate(),\n  ];\n....\n  persistStore(store);\n return store;. ",
    "shekhardesigner": "@mouthzipper I followed exact steps above, here is the problem I ran into:\n\n. @billgo Haven't tried this yet!. @mouthzipper You sure about the version you were using? 4.10.2 doesn't have session lib or PersistGate. I have been trying to integrate V5 of this redux-persist 5.9.1 with react boilerplate 3.4.0. \nHere is what I have done so far:\n1. Install NPM\nnpm i -S redux-persist redux-persist-transform-immutable\npackage.json\n\"redux-persist\": \"^5.9.1\",\n    \"redux-persist-transform-immutable\": \"^5.0.0\",\n2.  Setup Redux Persist in store.js\n```\n//store.js\nimport .... (other usual stuff)\nimport { persistStore, persistReducer  } from 'redux-persist';\nimport storageSession from 'redux-persist/lib/storage/session';\nimport immutableTransform from 'redux-persist-transform-immutable';\nconst persistConfig = {\n  transforms: [immutableTransform()],\n  key: 'root',\n  storage: storageSession,\n}\nconst rootReducers = createReducer();\n// Using persistReducer not persistCombineReducer because the rootReducer is already returned by combinedReducer from redux-immutable.\nconst persistedReducer = persistReducer (persistConfig, rootReducers)\nexport default function configureStore (initialState = {}, history) {\n   // other usual stuffs ... \n// I modified how store is created using persistedReducer\nconst store = createStore(\n      persistedReducer, // this line used to use createReducer() method\n      fromJS(initialState),\n      composeEnhancers(...enhancers),\n   );\nconst persistor = persistStore(store);\nreturn { persistor, store };\n// Please note, I have commented out hot reloading of reducers for now.\n}\n```\n3. No change in reducers.js\n4. Update App.js\n```\nimport 'babel-polyfill';\nimport React from 'react';\n// Added below\nimport { PersistGate } from 'redux-persist/es/integration/react';\n// other usual setup\n// Line below used to define just store but now we are defining persistor and store\nconst { persistor, store } = configureStore(initialState, browserHistory);\n// Finally, update the render method:\nconst render = () => {\n  ReactDOM.render(\n    \n\n\n\n,\n    document.getElementById('app')\n  );\n};\n```\nAnd still no luck:\nError:\n\nI think I do not have immutable maps configured right. Any help? \n. @tilakz Take a look at this - https://github.com/hendrathings/react-boilerplate-redux-persist-sample. I agree with @JonathanLehner here, I too didn't implement redux-persist. Classic way of sessionStorage helped me do a custom implementation. ",
    "billgo": "@shekhardesigner How do you solve this problem?. ",
    "JonathanLehner": ":(. I couldn't find a solution. However, I realised redux persist might not be necessary (better do not rely on something with so little documentation). On egghead.io there is an example of Dan Abramov. You can just subscribe to the store and use lodash throttle to save to local storage.. I mean here are literally 234 open issues.. https://egghead.io/lessons/javascript-redux-persisting-the-state-to-the-local-storage it takes like 5 minutes to setup. Redux persist is a nightmare of complexity and lacks documentation, so if it is not really crucial to save the whole state you might save a lot of time with subscribe.. ",
    "tilakz": "@shekhardesigner  have you find any solution? I am having the same issue, please help if you have solved this issue. Thanks in advance. . @shekhardesigner @JonathanLehner Thanks guys for your help, the example of Dan Abramov worked out for me. . I implemented redux persist with this: \nhttps://egghead.io/lessons/javascript-redux-persisting-the-state-to-the-local-storage. ",
    "rimzici": "As I debugged I could see \nstorage.getAllKeys inside getStoredState.js file never executes the callback.\nI am using AsyncStorage from react-native.\nMight be related to 9319 and 9436. Okay. Will have to wait till then :)\nAnd reg v5 I have tried that too. In that case\nstorage.getItem(storageKey).then(function (serialized) {\n         ..........................\n         ..........................\n}) \ninside getStoredState file.\nit never goes inside the promise neither a catch block. So it is again frozen there!\nIssue with Asynstorage while debug seem to have fixed in some RN version, now back again!\nAs you said got to be an upstream issue :)\nThanks.. Any Updates on this?. I see, thank you.\nA small confirmation, by this fix the issue of app being infinitely hung is solved, but the data is lost after the default timeout of 5000ms ?. ",
    "renthobo": "Any Update on this one ? still getting a single entry in indexedb. ",
    "rvirani1": "Just a note, I've had two developers on my team struggle with implementing v5. It was only after we found this PR did we really get a sense of how v5 worked. The current docs on the main README are still inadequate in our opinion. Would love for a version of this PR to get merged in.. A blog post would be great.. ",
    "adeelshahid": "@rt2zz \nI divided my reducer's with a separate config for each for extensibility. Upon rehydration I get back.\n_persist: {}\n_props: {}\nI think redux-persist should not amend internal reducer structure by adding props/_persist to it, that's just my opinion.. may be storing it internally inside some object which takes care of persist true/false flag.. @rt2zz \n\n\nwill the extra read per persistoid add meaningfully to startup time?\nThis only comes into effect if we need to do an extra read. e.g. if configuration specifies that a particular Object is going to be stored per key. Otherwise we can do a direct read, just like configuration per reducer.\n\n\nwill the extra code to store this state outside of the reducer state add to code size?\nStore object keys inside _docs: []\nStorage.get/set on keys inside the _docs reducer with a counter to know when all the keys have been resolved. Set then to a Map/Object and send it back on rehydrate.\n\n\nwill the risk of out of sync issues (where state is written but _persist fails or vice versa) going to be problematic?\n\n\nSync is a difficult problem when too much is happening in a single place, current model of redux-persist with [fetch and restore] on load while [set and save] on modification works well.. @rt2zz we can have a reserved reducer with a prefix _, like _persist.\ne.g.\n_docs: [documents ids]\n_docs:doc_id (contains the meta)\nlater on rehydrate we merge all _docs:parts into docs\nThis can be used for extensibility in any decent size application, which will have a similar model.. @ethanroday no I had a server based solution to remove the complexity from the reducer. Now anything in the app that relates to preferences, progress etc. are synced from the server side.. ",
    "rohozhnikoff": "same wishes\ni made fabric of nested reducers, and often initial state isnt the {} type\nnew redux-persist api is incredible, and fit good with our composition of reducers\nbut with _persist we got another constraints\nnow we should put persistReducer only to 'plain-object Reducer type'\n\"token\" or phone, i have to group them in some needless key and only then persist. it's also a huge problem, if reducer is objectOf(shape({})) type\nnormalized collections, which manage by own reducer\nit makes me filter _persist key from collection on .map, on connect, etc. internally, persistReducer run spread and assign at every action\nspread is not cheap, particularly in normalized collections with thousands of items\nmost of the js implementations, constructing new {} with loop\nassign work in same, wrong for perfomance way\nand it makes another leak, cause return always new {}, even if nothing was changed\nin current solution, we do them every time, in every action-fire\nand we have to create some better solution. > and it makes another leak, cause return always new {}, even if nothing was changed\n...which mark all the tree-branch like \"dirty\", and don't give combineReducer to make this https://github.com/reactjs/redux/blob/e6463f2da9020185c6461c5975700f756e506015/src/combineReducers.js#L160\nit is wrong input for connect(), who make only shallowEqual diff and think that your unchanged, but 'spread > assign' piece of data is dirty, which cause needless .render() and diff-s\nyou don't see it, if use only flat version of reducers\nbut if you like to use hierarchy of your state, and serve piece of data closer to branches that have changes - you will use combination of combineReducers (example https://github.com/reactjs/redux/issues/738). basically we could, at least, dont create new {...baseReducer(state, action), _persist} if _persist || baseReducer(state, action), _persist} didn't changed\nchanges of _persist we could see in code\nchanges of state we could look from reference by state !== newState (usually redux docs recommend to return state, if no action to be handled in reducer). another issues require removing _persist from state\ndo you have any demand-list, for what cases we use _persist ?\ni would to think about another way. ",
    "naivehhr": "@victorileaf I have the same problem. How did you solve it? Thanks. @victorileaf Thank you very much! \ud83d\ude01. ",
    "victorileaf": "@naivehhr I uninstalled the app an d reinstalled it . It supposed to work without uninstalling.. . ",
    "ethanroday": "@rt2zz Curious about this as well. To expand on @adeelshahid's example, let's say I have an application where users can create and edit documents. Some slice of my state looks like this:\njavascript\n{\n  docIds: ['a', 'b', 'c', ...],\n  docs: {\n    a: { title: 'Document A', text: 'Lorem ipsum ...' },\n    b: { title: 'Document B', text: 'Lorem ipsum ...' },\n    c: { title: 'Document C', text: 'Lorem ipsum ...' },\n    ...\n  }\n}\nLet's say documents can get fairly large, and that there can be a lot of them. I wouldn't want the entire document state to be stored under one key. Rather, I'd likely want something like this:\nKey | Value\n------------ | -------------\ndoc_ids|\"['a', 'b', 'c', ...]\"\ndoc_a|\"{ 'title': 'Document A', 'text': 'Lorem ipsum ...' }\"\ndoc_b|\"{ 'title': 'Document B', 'text': 'Lorem ipsum ...' }\"\ndoc_c|\"{ 'title': 'Document C', 'text': 'Lorem ipsum ...' }\"\nThat way, editing one document doesn't result in the whole state getting stringified and persisted.. @adeelshahid Why the close? Were you able to find a suitable workaround?. I believe @darewreck54 is correct. The type definitions for 5.10.0 assume Redux ^4.0.0, in which the type signature for reducers changed, but that is not reflected anywhere in package.json.\n@rt2zz, Not sure if the correct course of action is to change the peer dependency version or to bump a major version here, but I think some check does need to be put in place.\n@Venryx, you can also change the redux-persist version in your project's package.json to 5.9.1 instead of ^5.X.X to enforce the correct version until this is resolved.. ",
    "stolinski": "I'm seeing the same thing here.. I'm using it in an es modules environment with many other packages importing without issue. . No worries. I've moved on to another Redux local storage package that installed and imported without issue.. redux-localstorage-simple\nAs the name suggests, it's super simple to get started.. Ah, that's def why mine wasn't working. I'm also sharing imports between client & server even though the file I was using in was client side only.. ",
    "fifyrio": "thank you,buddy\ud83d\ude00. ",
    "jeco123": "I got the same problem using the redux-persist/es/storage. :-(\nIn addition, using the /lib/storage i have the following error: \nredux-persist failed to create sync storage. falling back to memory storage.\n@stolinski which local storage package have you imported?. Ok i found y it did not work. My import was shared between a server (for server side rendering) and a client. the import is correct for my client using webpack but not for the server which is not built with webpack and the lib was needed. In addition the error came from the server execution which import the storage file which try to create the local storage on the server... !!\nIt works now, separation has been done correctly :-). Ho ho ho ;-). ",
    "MacKentoch": "With redux-persist v4 it is pretty straightforward: example.\nNow with redux-persist 5+ it is a nightmare...\nAny help or advice is welcomed.. @phuihock solution is nice: that makes sense to extend timeout value.. ",
    "amaidah": "Yup, it looks like I am running into an issue with integrating withRedux and redux-persist 5.\nwithRedux expects configureStore fn to return store whereas redux-persist wants to output { store, persistor }.\nTried all kinds of things including exporting { persistor } separately outside the configureStore function, but nothing really seems to work properly.. ",
    "nickmarca": "Integrating withRedux with redux-persist doesn't seem to be very difficult. The problem is to get notified when persisted stated is loaded. \nOfficially, the easiest way to get aware of loaded stated is through PersistGate which requires persistor and there's where the problems begin.\nNot only Next.js or withRedux, but every server side rendering approach will try to render this PersistGate component on server side, however persistor it will not be present at that point. \nSo, it would be necessary to treat both render attempt methods, which I think IT'S A TERRIBLE IDEIA. Something like that: \nPS: I'm not recommending this approach at all. \n```javascript\nclass App extends Component {\n  static getInitialProps({ req, res, store }) {\n    //this method may or may not be called on client\n    //!res means this code is running on client\n    if(!res) {\n      loadPersistedState(store);\n    }\nreturn {};\n\n}\ncomponentDidMount() {\n    //this method is only called on client\n    //save store to global window object\n    this.persistor = window.store && loadPersistedState(window.store);\n  }\nrender() {\n    return(\n      \n        {\n          this.persistor ? (\n            //on browser render\n            \n\n\n          ) : (\n            //on  server render\n            \n          )\n        }\n      \n    )\n  }\n}\nreturn withRedux(initStore, null, null)(App);\n```\n```javascript\nconst loadPersistedState = store => {\n  return persistStore(store);\n};\n//store\nconst initStore = (_initialState = {}, {isServer, req}) => {\n  let store;\nif (isServer) {\n    store = createStore(reducers, _initialState);\n  } else {\n    const persistedReducer = persistReducer(persistConfig, reducers);\n    store = createStore(persistedReducer, _initialState);\nwindow.store = store;\n\n}\nreturn store;\n}\n```\nMy conclusion is that It will be very welcome some alternative way (Perhaps It already exists) to get components notified when persisted state is loaded besides PersistGate, something like the npm module redux-storage does.. @rt2zz There it is ! I think that would be very time saving if you expose this method on read.md.\nI've done a step forward and created a repo with a demo app which shows Next.JS working pretty nice with redux-persist. \nhttps://github.com/nickmarca/examples-redux-persist-next\nUnfortunately, People have to download it and yarn install to see it working. But I try to point out the main parts of this integration: \n```javascript\n//#store/serverStore.js\nimport { createStore } from 'redux';\nimport reducers from \"../reducers/index\";\nexport default (initialState, {isServer}) => {\n  return createStore(reducers, initialState);\n}\n//#store/clientStore.js\nimport { createStore } from 'redux';\nimport reducers from \"../reducers/index\";\nimport storage from \"localforage\";\nimport {persistStore, persistReducer} from \"redux-persist\";\nimport {loadSuccess} from \"../actions\";\nconst persistConfig = {\n  key: 'root',\n  storage: storage,\n};\nconst persistedReducer = persistReducer(persistConfig, reducers);\nexport default (initialState) => {\n  const store = createStore(persistedReducer, initialState);\n//You don't need to delay it, I did because I wish to show how to get notified \n  //when state is rehydrated\n  setTimeout(() => {\n    persistStore(store, null, () => {\n      store.dispatch(loadSuccess());\n    });\npersistStore(store);\n\n}, 3000);\nreturn store;\n}\n//#store/index.js\nimport createStoreFromServer from \"./serverStore\";\nimport createStoreFromClient from \"./clientStore\";\nconst _initialState = {\n  myData: {},\n  status: {loaded: false, err: false}\n};\nexport default (initialState = _initialState, props) => {\n  if(props.isServer) {\n    return createStoreFromServer(initialState, props)\n  } else {\n    return createStoreFromClient(initialState, props);\n  }\n}\n//#reducers/statusReducer.js\nimport {actionTypes} from \"../actions\";\nexport default (state = {loaded: false}, action) => {\n  switch (action.type) {\n    case actionTypes.DATA_LOAD_SUCCESS:\n      return {loaded: true};\ndefault:\n  return state;\n\n}\n}\n``` . ",
    "element6": "Base on both redux-persist and next-redux-wrapper docs, I ended up with this solution:\n```\nlet _persistor;\nexport default Page => withRedux(\n    (initialState, { isServer }) => {\n        const { persistor, store } = makeStore(initialState, { isServer })\n        _persistor = persistor\n        return store\n    }, mapStateToProps, mapDispatchToProps\n)(class DefaultPage extends React.Component {\nrender() {\n            if (!_persistor) return <Loading/>\n\n    return (\n        <PersistGate loading={<Loading/>} persistor={_persistor}>\n            <App />\n        </PersistGate>\n    )\n}\n\n}\n```\n```\n//store.js\nimport { createStore } from \"redux\";\nimport rootReducer from \"./reducer\";\nimport storage from 'redux-persist/lib/storage'\nfunction clientStore(initialState) {\n    const { persistStore, persistReducer } = require('redux-persist')\nconst persistConfig = {\n    key: 'root',\n    storage,\n}\nconst persistedReducer = persistReducer(persistConfig, rootReducer)\nconst store = createStore(persistedReducer, initialState)\nconst persistor = persistStore(store)\nreturn { store, persistor }\n\n}\nexport const makeStore = (initialState, { isServer }) => {\nconst { store, persistor } = isServer ? { store: createStore(rootReducer, initialState) } : clientStore(initialState);\n\nif (module.hot) {\n    module.hot.accept('./reducer', () => {\n        console.log('Replacing reducer');\n        store.replaceReducer(require('./reducer').default);\n    });\n}\n\nreturn { store, persistor };\n\n};\n```\nNot the prettiest solution, but at least I could use PersistGate element to handle the rehydration loading. So far, it seems to work, but if you see any issue with this approach, please let me know. Thanks.\n. @agraebe yes, I've updated my solution :)\nadded if (!_persistor) return <Loading/> to render() to make sure _persistor is loaded before rendering <PersistGate ... />. @agraebe I didn't change my store solution. Which redux event are you referring to? I thought everything happens automatically as PersistGate re-hydrates and connect middleware subscribes the component to the store.. ",
    "agraebe": "@element6 thanks for posting your approach. It works for server-side routing but when I use Router.push() for client-side routing, nextjs seems to lose access to _persistor and I get the error below. Refreshing the page manually for server-side fetching actually loads up the page... Did anyone solve this issue?\nCannot read property 'subscribe' of undefined\nTypeError: Cannot read property 'subscribe' of undefined\n    at ProxyComponent.componentDidMount (http://localhost:8000/_next/-/page/register.js:29782:48)\n    at ProxyComponent.wrappedMethod (http://localhost:8000/_next/-/main.js:27589:123)\n    at commitLifeCycles (http://localhost:8000/_next/-/main.js:20465:24)\n    at commitAllLifeCycles (http://localhost:8000/_next/-/main.js:21641:9)\n    at HTMLUnknownElement.callCallback (http://localhost:8000/_next/-/main.js:12237:14)\n    at Object.invokeGuardedCallbackDev (http://localhost:8000/_next/-/main.js:12276:16)\n    at invokeGuardedCallback (http://localhost:8000/_next/-/main.js:12133:27)\n    at commitRoot (http://localhost:8000/_next/-/main.js:21745:9)\n    at performWorkOnRoot (http://localhost:8000/_next/-/main.js:22712:42)\n    at performWork (http://localhost:8000/_next/-/main.js:22662:7). @element6 Am I assuming correctly that you have an update store solution as well that dispatches a redux event and your component is subscribed to that so it updates as soon as _persistor available?. My mistake, I didnt subscribe correctly. Works for me now! Thanks for your help, guys!. @kirill-konshin This is perfect, thanks! Quick question - how would I purge the store e.g. on logout from within a page component?. ",
    "kirill-konshin": "Author of next-redux-wrapper here.\nHonestly, I think that putting a persistence gate is not necessary because server can already send some HTML with some state, so it's better to show it right away and then wait for REHYDRATE action to happen to show additional delta coming from persistence storage. That's why we use Server Side Rendering in a first place.\nBut, for those who actually want to block the UI while rehydration is happening, here is the solution (still hacky though): https://github.com/kirill-konshin/next-redux-wrapper/blob/master/README.md#usage-with-redux-persist. @agraebe You need to create an action for that, dispatch it and clean whatever you want in reducers, the same way as usual. Persistor will remember cleaned up state.. ",
    "danscrima": "I have a working example with nextJS + next-redux-wrapper and the latest redux-persist in case this helps anyone. \nHere are the relevant files. I'm still new to this, so can't explain in detail too much about the inner workings, just that my state is now fully rehydrated when I do a page refresh, where before it would reset my state to the initialState when I refresh the browser and would only show data again if I changed the schema of the state temporarily so that it detected a change. If I'm doing something that is a super bad idea, I'd certainly appreciate any feedback! \nCheers!\nredux/store.js\n```javascript\nimport { createStore, applyMiddleware } from 'redux';\nimport thunkMiddleware from 'redux-thunk';\nimport loggerMiddleware from './middleware/logger';\nimport { composeWithDevTools } from 'redux-devtools-extension';\nimport { persistReducer } from 'redux-persist';\nimport storage from 'redux-persist/lib/storage';\nimport rootReducer from './reducers';\nconst persistConfig = {\n  key: 'root',\n  storage,\n};\nconst persistedReducer = persistReducer(persistConfig, rootReducer);\nexport default () => {\n  return createStore(persistedReducer,\n    composeWithDevTools(\n      applyMiddleware(\n        loggerMiddleware,\n        thunkMiddleware\n      )\n    ));\n};\n```\npages/_app.js\n```javascript\nimport { Component } from 'react';\nimport { Provider } from 'react-redux';\nimport App, { Container } from 'next/app';\nimport withRedux from 'next-redux-wrapper';\nimport { PersistGate } from 'redux-persist/integration/react';\nimport { persistStore } from 'redux-persist';\nimport store from '../redux/store';\nclass MyApp extends App {\n  static async getInitialProps ({Component, ctx}) {\n    return {\n      pageProps: (Component.getInitialProps ? await Component.getInitialProps(ctx) : {})\n    };\n  }\nrender () {\n    const {Component, pageProps, store} = this.props;\n    const persistor = persistStore(store);\n    return (\n      \n\n\n\n\n\n\n    );\n  };\n}\nexport default withRedux(store, {debug: true})(MyApp);\n```\nredux/reducers/index.js\n```javascript\nimport { combineReducers } from 'redux';\nimport userReducer from './user';\nexport default combineReducers({\n  user: userReducer\n});\n```. ",
    "revskill10": "I use PersistGate in _document.js and it works nicely.\nIn getInitialProps, you could use\n```js\nMyDocument.getInitialProps = ctx => {\nlet pageContext;\n  let persistor;\n  const sheet = new ServerStyleSheet()\nconst page = ctx.renderPage(Component => {\n    const WrappedComponent = props => {\n      pageContext = props.pageContext;\n      persistor = props.persistor;\n  return sheet.collectStyles(\n    <PersistGate loading={null} persistor={persistor}>\n      <Component {...props} />\n    </PersistGate>\n  );\n};\n\nWrappedComponent.propTypes = {\n  pageContext: PropTypes.object.isRequired,\n};\n\nreturn WrappedComponent;\n\n});\n  ...\n}\n```\nTo inject persistor to props, in _app.js, you just do\njs\nconstructor(props) {\n    super(props);\n    this.pageContext = getPageContext();\n    this.persistor = persistStore(props.store);\n  }\n. @karolisgrinkevicius As i see, you can make a hook in the componentDidMount to dispatch a redux action with payload {mounted: true}, then you can use it to dispatch further action after hydration.. ",
    "karolisgrinkevicius": "I would like to reset the topic regarding PersistGate. My actual use case is the following: \nI'm using redux-persist@5.10.0 with next-redux-wrapper@2.0.0 and next-redux-saga@3.0.0. I have a page /pages/home.tsx:\n```tsx\nexport default class HomePage extends React.PureComponent {\n  static getInitialProps({ store }) {\n    store.dispatch(someAction());\n  }\nrender() {\n    return (\n      \n\n\n    );\n  }\n}\n```\nI need to wait for REHYDRATE action to be dispatched and right after to dispatch someAction. I don't really want to block UI in all other pages therefore I'm quite certain that PersistGate doesn't fit here. Someone has any proposition what could be the way to achieve that?. Thanks @revskill10. The following code is how I have ended this up:\n```jsx\nexport default class HomePage extends React.Component {\n  static async getInitialProps({ isServer, store }) {\n    // below I use imported helper function to dispatch an action\n    // asynchronously and wait for selector to return value of true\n    // for making sure rehydration is already done before we dispatch further action\n    await dispatchAsync(store, someAction(), selectRehydrationIsDone); \n    if (!isServer) {\n      store.dispatch(actionNeededAfterRehydration());\n    }\n  }\nrender() {\n    return (\n      \n\n\n    );\n  }\n}\n```. ",
    "dextermb": "\nAuthor of next-redux-wrapper here.\nHonestly, I think that putting a persistence gate is not necessary because server can already send some HTML with some state, so it's better to show it right away and then wait for REHYDRATE action to happen to show additional delta coming from persistence storage. That's why we use Server Side Rendering in a first place.\nBut, for those who actually want to block the UI while rehydration is happening, here is the solution (still hacky though): https://github.com/kirill-konshin/next-redux-wrapper/blob/master/README.md#usage-with-redux-persist\n\nI'm still having issues with this. Currently getting:\nreact.js:53 Uncaught TypeError: Cannot read property 'subscribe' of undefined. ",
    "ShintaroNippon": "HI there... First of all thank by the plugin.\nI'm trying to implement this feature in Next js\nAnd I have this code...\n_app.js\nimport { Provider } from \"react-redux\";\n import { appWithTranslation } from \"../../i18n\";\n import withRedux from \"next-redux-wrapper\";\n import { makeStore } from \"../lib/redux\";\nimport { PersistGate } from \"redux-persist/integration/react\";\nexport default withRedux(makeStore, { debug: true })(appWithTranslation(MyApp))\nand in page/index.js I have\nexport default connect(\n      (state) => state,\n      {setClientState}\n  )(({fromClient, setClientState}))(withNamespaces('landing')(Index))\nbut IM getting an error of setClientState not defined.\nCan you help me, please?\nThanks in advance\nCarlos Vieira. HI there I already did it, I have created an action and a reducer,\nMy doubt was calling this.props.dispatch(savemydata(data))\nFor now it's working but the info is spread into this props...\nany help to set it in one variable ?\nthanks\n. problem solve\nyou can close. ",
    "ChrisLahaye": "@rt2zz I encounter the same problem. After performing my redux-reset action, my actual redux store reflects the right information. However, after explicitly flushing the persistor and restarting the app, the redux store has the information from before the reset.. I encounter the same problem, even after awaiting a flush.. You can use the functions persistor.flush() to enforce writing the latest redux data to local storage, or persistor.purge() to clear the local storage (note that it leaves the redux data intact).\nIn order to get access to the persistor we the persistor to the appropriate component from the router.. https://github.com/rt2zz/redux-persist/issues/612  @giacomocerquone. ",
    "luhui": "Hi, @choenden have you found a workaround? I have the same issue after upgrade from v4 to v5. ",
    "shunmian": "Hi, @choenden, I have the same issue as you. Have you made it work?. ",
    "blooddrunk": "I'm stuck with similar store structure,  after persist/PERSIST and persist/REHYDRATE dispatched upon app start, my immutable slice of store turns from Map to an object with a size key.  persistReducer with redux-persist-transform-immutable config doesn't seem to help. Am I missing something?. ",
    "appelstroop": "This is probably an issue with state reconciler that can't handle immutable store. You can apply a custom function in persistConfig: \nconst persistConfig = {\n  key: 'root',\n  storage,\n  stateReconciler: autoMergeLevel2Immutable,\n  transforms: [immutableTransform()]\n}\nSee this gist for a custom function\n. @Macstyg What error or warning is logged to the console?. ",
    "Macstyg": "I've faced the same problem. After state rehydration, some of my Map structures are broken. I've try the @appelstroop solution, but it didn't help me at all :(. I have an error from my internal function. In general my state before the closing app is something like that:\nitemA: {\n    itemB: Immutable.Map(),\n    itemC: Immutable.Map(objectId, {...}),\n}\nand after the rehydration it became: \nitemA: {\n    itemB: {\n        0: 'itemB',\n        1: []\n    },\n    itemC: {\n       0: 'itemC',\n       1: ['objectId', {...}]\n    }\n}\nBut I find out that this happens only after some specific user interactions in my application. Network interruption during the messages exchanging through the WebSockets between client and server. I get the warning from the android, and I think that violates the storage. \n. ",
    "cogell": "@Macstyg wild guess, I had trouble initially using autoMergeLevel2Immutable because I had a mix of immutable and plain objects on the first level of my store \ud83d\ude05. Thanks for the good gist @appelstroop . ",
    "ortonomy": "@appelstroop -- YAS. This is kickass, the only thing that solved my issue.. Holy crap, this issue saved my bacon! I was getting soooooo frustrated why my Jest tests were failing.. ",
    "blackLearning": "For me, persist reducer in replaceReducer solves the problem.\n```\nexport const store = createStore(\n  persistReducer(config, rootReducer),\n  compose(applyMiddleware(...middlewares), ...enhancers)\n);\nif (module.hot) {\n  module.hot.accept(() => {\n    const nextRootReducer = require('../reducer/index').default; // eslint-disable-line\n    store.replaceReducer(persistReducer(config, nextRootReducer))\n  })\n}\n```. It seems you're still tring to use the original reducer to replace the persisted reducer, you sure this will work for HMR? \nI'm using the seamless-immutable too, here is my setup, it works fine to me.\n```\nconst myTransform = createTransform(\n  // transform state coming from redux on its way to being serialized and stored\n  state => (Immutable.isImmutable(state) ? Immutable.asMutable(state) : state),\n  // transform state coming from storage, on its way to be rehydrated into redux\n  state => Immutable(state)\n)\nconst config = {\n  key: 'root',\n  debug: true,\n  blacklist: ['nav', '_persist'],\n  transforms: [myTransform],\n  storage,\n};\nexport const store = createStore(\n  persistReducer(config, rootReducer),\n  compose(applyMiddleware(...middlewares), ...enhancers)\n);\nstore.runSaga = sagaMiddleware.run;\nstore.close = () => store.dispatch(END);\nexport const persistor = persistStore(store, null);\n// clear storage when app is reloaded.\n// if (DEV) persistor.purge();\nif (module.hot) {\n  module.hot.accept(() => {\n    const nextRootReducer = require('../reducer/index').default; // eslint-disable-line\n    store.replaceReducer(persistReducer(config, nextRootReducer))\n  })\n}\n```. ",
    "henrytao-me": "I have the same problem. Can you look into it @rt2zz ?. I found the issue. AsyncStorage.getItem was broken on react-native@0.50.x https://github.com/facebook/react-native/issues/14101. Upgrading to react-native@0.51.x fixed this issue. @millermatt . Sometime, I do get this issue, rehydrated === false. I have to kill the app and restart. It is quite annoying. It is good to know that persistor.purge will work. . As I know, this is not a problem from redux-persist. AsyncStorage.getItem does not trigger some time during on reload that cause redux-persist does not rehydrated. The only way to fix it is killing the app. . @nenti There is an issue here for your reference. https://github.com/facebook/react-native/issues/14101\nI haven't encounter this issue (at least as often as I notice) since I use this\n\"react\": \"16.0.0\",\n    \"react-native\": \"0.51.0\",\n    \"react-redux\": \"5.0.6\",. ",
    "rystraum": "Just wanted to add here that upgrading to react-native@0.51.x isn't an option for those using expo at the moment. Latest expo version available on the app store only supports 0.50.4.. ",
    "giacomocerquone": "I've updated react native but still got the same problem! It works only if I call persistor.purge() on didmount, anyone knows why?\nOnbeforelift is working too and attaching a reducer to \"REHYDRATE\" works . Actually I have even a stranger behaviour. If I don't use persistor.purge() the component inside PersistGate call an action creator but then this component will not update e componentwillreceiveprops is not called, if I put that persistor.purge (or completely remove persistgate) it works... guys I'm going nuts with this, what could it be? @rt2zz . ",
    "nenti": "This is a really ugly issue that I had in v4 already and now I upgraded to v5 and it is still the case. Easy way to reproduce:\n1. Put a debugger breakpoint in your main App.js render function.\n2. Reload after PERSIST and before REHYDRATE action\n3. REHYDRATE wille never be called again until you kill the app an restart it. Thank you for the info. I will try dropping Redux persist and get my items directly.\n1. Is there a related issue open in react-native?\n2. Is there a way to handle missing response programmatically? Or another storage I can use?\n3. Does this happen in production aswell? \nThis bug makes usage a pain, especially when you use react - native auto reload function. . @henrytao-me I have almost the same versioning as you. From my research it is an android issue with debugger connected and for hot- and live-reloading.\n\"react-native\": \"0.52.1\",\n  \"react-redux\": \"5.0.6\",\nIt is totally annoying because ofc when you develop debugger is connected and you use reload functions. And the worst part is when you work in a team and your team does not know about this issue.. ",
    "costagolub": "In my case updating to the latest versions didn't help me. The app stops working at some moment, rehydrade/persist action never calls, nothing helps except killing the emulator and re-start the react-native. Is it possible to call rehydrate action without PersistGate? Or any other solutions would be good. Thanks!. @j-o-d-o The issue is closed but I think it's not fixed completely. Maybe it makes sense to open it again. \nObserving the same issue. The rehydate action doesn't emit after navigating to some page or just after refreshing the app several times I got the infinite loader on PersistGate and doesn't call rehydrate ever. I have to kill the process and restart the android emulator to make it work again. \nI tried solutions from this topic and some related ones but nothing works for me. Is anyone continue to struggle with the same issue? Any ideas what can be wrong? \n. ",
    "ali-sao": "Try to define your persistor inside component constructor :\n```\nimport store from './store';\nclass App extends Component {\n  constructor() {\n    super();\n    this.persistor = persistStore(store);\n  }\n  render() {\nreturn (\n  <Provider store={store}>\n    <PersistGate persistor={this.persistor} loading={null}>\n      <RootRouter />\n    </PersistGate>\n  </Provider>\n)\n\n}\n}\n```. I simply fixed this by creating the persistor inside the constructor :\n```\nclass App extends Component {\n  constructor() {\n    super();\n    this.persistor = persistStore(store);\n  }\n  render() {\nreturn (\n  <Provider store={store}>\n    <PersistGate persistor={this.persistor} loading={null}>\n      <RootRouter />\n    </PersistGate>\n  </Provider>\n)\n\n}\n}\n```. ",
    "joshimbriani": "Switching the default redux-persist store to redux-persist-filesystem-storage fixed this issue for me!. ",
    "meatwallace": "Haven't looked at source but can confirm that all migrations run on every app start.. ",
    "kg912": "Hi I'm facing the same problem with the same setup (Using immutable maps for different state records and having stale state persisted on refresh). Can you tell me how exactly you solved it? I have tried everything at this point. Thanks in advance.. Hi tommyalvarez, I have verified that the component level state does change as I update my application level (Redux) state. My problem is that the initial state is being persisted on refresh instead of the newer application state. My root reducer takes in the following differrent reducers\n````\nimport Auth from './auth/reducer';\nimport App from './app/reducer';\nimport Mails from './mail/reducer';\nimport Course from './course/reducer';\nexport default {\n  Auth,\n  App,\n  Mails,\n  Course\n};\n````\nand each reducer stores its state in an immutable map like this:\n````\nimport courseActions from './actions';\nimport { Map } from 'immutable';\nconst course_data = {};\nconst { COURSE_DATA, COURSE_UPDATE, COURSE_MAT_UPDATE, REMOVED_MATERIAL, RETRIEVE_COURSE, COURSE_ASSIGN_UPDATE} = courseActions;\nconst initState = new Map({\n    course_data,\n});\nexport default function(state = initState, action) {\n    switch(action.type) {\n        case COURSE_UPDATE:\n            const { courseId, newCourse } = action.payload;\n            let data = state.get('course_data');\n            data[courseId] = newCourse;\n            state.set('course_data', data);\n            return state.set('course_data', data);\n            break;\n    case COURSE_DATA:\n        const { course, id } = action;\n        let old_state = state.get('course_data');\n        return state.set('course_data', { ...old_state, [id]: course});\n        break;\n\n    case COURSE_MAT_UPDATE:\n        const { materials, cId} = action;\n        let courseData = state.get('course_data');\n        courseData[cId].materials = materials;\n        return state.set('course_data', courseData);\n           }\n }\n\n````\nDo I need to explicitly whitelist all of these reducers? also do I need to pass anything at all to the immutableTransform function? . ",
    "tgdn": "Having same problem with latest version using example from README. Has anyone encountered the problem and was able to solve it? Thank you in advance.. ",
    "DJTB": "[redacted] - my comment was actually unrelated.. Googling \"rehydrate state\" found an answer pretty quickly.\nhttps://stackoverflow.com/questions/29824908/what-does-dehydrate-and-rehydrate-stand-for-in-fluxible#answer-33790716. Very similar setup for me as regards app, configureStore, and rootReducer - the only exception being that I have nested persistReducers.\nSame problem, I clear the state on a logout action, see it cleared by the action, but the cleared state isn't persisted. Logging in as a different user or refreshing/re-opening the page rehydrates the pre-cleared state.. I had an inkling I might have to clear explicitly within each nested reducer, though that's kind of a pain even with a reducer decorator. Thanks for the info - I'll give it a shot.. I've tried various combinations of clearing state, and I often still get back stale state / or new state isn't persisted. \nI see that clearing from the top level removes the _persist info from the state inside my nested reducers, and that completely messes up redux-persist?. The eventual solution I settled on (less than ideal) was to remove top level persistence and use nested persistors only, which seems to work for my case.\njavascript\nconst rootReducer = combineReducers({\n  notPersisted: someReducer,\n  nestedPersisted: persistReducer(specificNestedPersistConfig, nestedReducer),\n  /* more nested / unpersisted reducers */\n});\nEach nested persisted reducer shares a basic persist config ({ storage, version, debounce }), but merges its own specific key and whitelist.\nThe nested reducers all have their own initialState declared within the file.\nAnd they all have a final switch case for USER_LOGOUT : (state) => initialState\nSometimes initialState has keys/values, sometimes it's just {} but never undefined.\nLocalforage indexedDB ends up with:\n\nI'd prefer a single USER_LOGOUT at the top level (and a single DB entry / key), but I could never get it to work properly since it seemed to mess with the _persist entries in redux state which I think is what was causing the problems. @rt2zz I was clearing state at the top level exactly the same as the OP before changing to nested with their own initialStates.. ",
    "xempie": "I found the issue. the reason was I used combined reducers twice. Once in reducers and once in persistCombineReducers in store. \nso need to change this in reucers:\nexport default combineReducers({\n    rehydrated,\n    user\n});\nto \nexport default {\n    rehydrated,\n    user\n};\n. ",
    "ethan605": "@rt2zz yeah except simple functions (like createPersistoid, getStoredState, purgeStoredState are placed in index.d.ts), another are split into individual files which reflects to current flow files. ",
    "inakianduaga": "@rodrigoelp \nI think the signature of persistCombineReducers should be\nts\n  /**\n   * It provides a way of combining the reducers, replacing redux's @see combineReducers\n   */\n  export function persistCombineReducers<S>(\n    config: PersistConfig,\n    reducers: ReducersMapObject\n  ): Reducer<S & PersistedState>\nsince the real root state will have the added keys from _persist? \nWe should also add a \nts\ndeclare module 'redux-persist/lib/storage'\nso typescript is happy when the ES5 version gets imported (my Jest config doesn't like this particular import) . that looks like redux logger middleware you're running in the tests, make sure to disable that middleware during the tests. @rt2zz BTW, is there any way to suppress a console.error message that I'm getting while running a persist store during a test? Where it says it defaults to memory storage?. @LKay \nts\n   export function persistCombinedReducers<State>(config: PersistConfig, reducers: ReducersMapObject): Reducer<State>;\nshould include the state coming from redux_persist itself, so it should be\nts\n   export function persistCombinedReducers<State>(config: PersistConfig, reducers: ReducersMapObject): Reducer<State & PersistedState>;. ",
    "debrice": "according to \nhttps://github.com/rt2zz/redux-persist/blob/e92def2bfd819218cce4e0e03c0dbd149c56afc8/src/createPersistoid.js#L38\nthrottle should be in milliseconds. ",
    "SaltedBlowfish": "@sunweiyang I'm sure you figured this out by now but one way to \"deprecate keys\" is by adding the key to the blacklist:\nconst persistConfig = {\n  key: 'root',\n  whitelist: ['foo', 'bar'],\n  blacklist: ['biz']\n}\nThat will prevent redux-persist from trying to rehydrate the key. Of course, if you're developing locally and get the error, you can just blacklist, reload the app, then remove the blacklist entry and the error will stop showing up.. ",
    "kevinEsherick": "How does one delete keys in a migration? @rt2zz I don't see any indication for how to do so in the example. Key: undefined does not have this effect, nor did I expect it to. \nEdit: Using delete stateCopy['key'] works. Please let me know if this is the recommended solution. ",
    "ssorallen": "@rt2zz Sorry, I'm no longer working on the project where I saw this error.\n\nYou can't unseal an object, that's a one-way operation. I wouldn't be too concerned about one \nnew object spread/creation, it happens rarely compared to something like re-rendering a component.\nDo you maybe have generated stubs for 'redux-persist' in your flow-typed/ directory? Flow will look there for definitions first and skip looking in node_modules/ if a library definition is found there.. If no one has a way to easily reproduce this, I'm fine closing it.. I increased the timeout in my app to 60s, but in my environment that sort of timeout is still possible. If hitting the timeout actually means \"delete the whole state\", it'd be nice to have a way to gracefully handle that timeout in my app. Show the PersistGate while retrieving the state and then show a big \"Something went wrong, reload the app\" if the timeout is hit.. A workaround I've discovered for my own use: kill redux-persist's timeout functionality. If the timeout hits, your store is rehydrated with the initial state and then persisted again to kill the state that is likely still loading.\n\nIn your persist config, prevent the timeout setup (persistReducer.js#L88-99):\nconst persistConfig: {\n   ...\n   timeout: 0, // The code base checks for falsy, so 0 disables\n};\nA complete solution for redux-persist would be to add a timeout component to PersistGate that would render if your timeout is hit and stop the rehydration work. What it shouldn't do is then rehydrate your store with initialState, which is the current functionality.. @andrewzey Using an error boundary makes sense, but I can't understand a case where you would actually want catastrophic data loss (i.e. replacing the state with initial state after a timeout is reached). With the worst case you mentioned, \"users will be stuck in a state where the app can't ever start again\", you can push an update to your app to fix the hydration exception and those users can update the app to get going again without losing any data.. @andrewzey Cool, I do like your approach handling real errors. Thanks for the Error Boundary suggestion.\nWhat about the case where your app hits the timeout but without any exception being thrown. Cases like network connectivity problems, the user goes into a tunnel, turns on airplane mode, or something like that, and your app never throws an exception. Would Error Boundaries be able to solve that?. @Shanie1331 If you set timeout: 0, the code that replaces the state with the default state will never run. The exception in the title of this issue will never occur. It won't affect your stored data at all.\nIf it's possible for your storage to take a long time to respond, redux-persist will simply wait until the storage responds. The PersistGate will stay visible until your storage ultimately responds.. I was able to reproduce the issue by setting timeout to something incredibly low like 10ms. The store was consistently overwritten by initialState. That's when I tested a few weeks ago, and I didn't write a test. I'd like to write a test to reproduce it, but I wanted to mention that in case anyone else is able to investigate further.\ntimeout is a key in the persist config, but it is not yet documented in the README.. redux-persist's timeout functionality definitely wipes out the store and rehydrates it with initial state. I don't know if that's the only issue here, but I have confirmed locally and in my own app that it does wipe out my store.\nYou can disable the timeout functionality entirely by passing timeout: 0 in your persistConfig. If your store takes a while to rehydrate then the PersistGate will continue to show the loading state. If your store never rehydrates then the PersistGate will never go away. However, it won't ever hit the timeout functionality and wipe your store. Your users can refresh the app or whatever it takes in case that slow rehydration was transient.\nIn your persist config, prevent the timeout setup (persistReducer.js#L88-99) (the default timeout value is 5000):\nconst persistConfig: {\n   ...\n   timeout: 0, // The code base checks for falsy, so 0 disables\n};\nA complete solution for redux-persist would be to add a timeout component to PersistGate that would render if your timeout is hit and stop the rehydration work. What it shouldn't do is then rehydrate your store with initialState, which is the current functionality.. There are a bunch of tab management extensions out there, but the Tab Wrangler model works best for me: let it automatically close everything. I realized I don't need most of those tabs!. This might be related to #809 and/or #717?. @carlomazzaferro redux-offline is dependent on redux-persist though: https://github.com/redux-offline/redux-offline/blob/c11e27940a935a891197e5c86a43e036b4569d74/package.json#L61. ",
    "Keethanjan": "Currently we are also having the same issues. Due to this reselect is not memorizing the values.\nCould you guys answer if this is intended?\nThanks in advance! \n. This is also happening for me. When I use an empty string ('') instead of undefined it is automatically updated though. . ",
    "hockeylagu": "747 .",
    "micimize": "I'm having the same issue, without any custom transformations: \n```typescript\nlet persist = (key: string, reducer: Reducer) => persistReducer({\n  key,\n  storage,\n  blacklist: ['actionHistory']\n}, reducer)\nconst reducer = persistCombineReducers({\n  key: 'root',\n  storage,\n  blacklist: ['foo', 'bar']\n}, {\n  router: routerReducer,\n  foo: persist('foo', fooReducer),\n  bar: persist('bar', barReducer),\n})\n``. @rt2zz figured out thatObject.assignis the culprit in my code, probably the same for @JosephDuffy , given his transform returns the same state object, but mutated. It seems that changing an object without replacing it results at any level of the state results inredux-persist` not picking up the change.\nI made the test in #711 fail by changing it to incorporate mutation\njavascript\n  let reducer = (state = { counter: 0 }, action) => Object.assign(state, {\n    counter: action.type === INCREMENT ? state.counter + 1 : state.counter,\n  }). ",
    "JosephDuffy": "The comment above is correct -- I must have been mutating the object directly somewhere. I have since moved to Immutable.js and rechecked this issue to find it is no longer present, so it was not an issue with redux-persist!. ",
    "zacholas": "I think this is a problem with either expo or genymotion. Seems to get fixed when I close the android emulator window and re-launch from genymotion.. ",
    "kaym0": "I have the same problem occasionally. Sometimes when I restart the emulator it still doesn't work, or I get stuff that was edited/deleted by me a while ago reappearing while newer stuff doesn't. I think it just cuts out at a certain point. It would be nice to find out exactly when that is so someone could pinpoint the exact cause.. ",
    "clems36": "I had a similar problem and I think I found a solution (can't be 100% sure). I had about 30 actions being handled by the same reducer which somehow caused the reducer to use defaultState values. My solution was to split the action types in multiple reducers. . ",
    "053steve": "Hi @Goolzzi, I'm currently having the exact same problem. componentsWillRecieveProps not working after adding redux-persist. Can u please share how u manage to fix the problem. Thanks you :D. Hi @Goolzzi , thanks for the reply! From ur answer I was able to narrow down the source of my problem. As it turns out it wasn't redux-persist at all but it was my setup that was incorrect. My reducer was already combined using redux's \"combineReducers\". I had to use \"persistReducer\" instead of \"persistCombineReducers\". Thanks a lot mate.. ",
    "goldentwinbrain": "Hi, @053steve \nIt wasn't redux-persist problem. In my project, I have used react-native-router-flux and coded some actions in router component.\nWhen reducer updated, router component re-rendered so every Scene should be re-located in memory that was called componentDidMount in every components. . ",
    "runeogod": "Any chance you can help me ? i have same issue as u have..\nhttps://github.com/rt2zz/redux-persist/issues/649\nThanks. Had the same problem as you, personally i didnt need to add a dispatch in my didMount.\nTry replacing your AsyncStorage in your store by storage\nimport storage from 'redux-persist/es/storage'; // default: localStorage if web, AsyncStorage if react-native\nAlso , check that your export reducer does not have combineReducer, because here you are using persistCombineReducers that already do the job .. If you have same issue as me and success to resolve it , could you answer to my post ? \nhttps://github.com/rt2zz/redux-persist/issues/649\nThanks !. ",
    "Base2526": "componentWillReceiveProps(nextProps){\n      console.log('componentWillReceiveProps : auth')\n      console.log(nextProps)\n    }\nyou forgot nextProps\nthx.. ",
    "antoniofull": "It turned out that it was indeed working. The problem is that I was not listening to the \"persist/REHYDRATE\" action in my reducer. . ",
    "nwabdou85": "@rt2zz , can you help please ?\nI also provide more cleaner code on this page https://paste.ofcode.org/nJQc2ZkzL22grXEurUh2Cq. ",
    "gkrinc": "Same for me as well, but I'm importing a rootReducer into my store.js file. This approach worked for me using persistReducer.\n```\n/ root reducer /\nimport { combineReducers } from 'redux';\nimport ExampleReducer from './example-reducer';\nconst reducers = {\n  example: ExampleReducer,\n}\nconst appReducer = combineReducers(reducers);\nconst rootReducer = (state, action) => {\n  // Global logic goes here...\n// Individual reducers\n  return appReducer(state, action)\n}\nexport default rootReducer;\n```\n```\n/ store.js /\nimport { applyMiddleware, createStore } from 'redux';\nimport thunk from 'redux-thunk';\nimport promise from 'redux-promise-middleware';\nimport { persistStore, persistReducer } from 'redux-persist'\nimport storage from 'redux-persist/lib/storage' // default: localStorage if web, AsyncStorage if react-native\nimport { composeWithDevTools } from 'redux-devtools-extension/developmentOnly';\nimport rootReducer from './reducers';\nimport defaultState from './defaultState';\nimport freeze from 'redux-freeze';\nconst config = {\n  key: 'root',\n  storage,\n}\nconst reducer = persistReducer(config, rootReducer);\nexport function configureStore () {\n  let store = createStore(\n    reducer,\n    defaultState,\n    composeWithDevTools(\n      applyMiddleware(\n        promise(),\n        thunk,\n        freeze\n      ),\n    )\n  );\nlet persistor = persistStore(store)\nreturn { persistor, store }\n}\n```\n  . ",
    "thinkocapo": "I'm still not clear on the difference,\nbut a dev on my team couldn't get our app to run even though it ran fine on my machine (i.e. same exact git branch and code), so we changed primary to root here and now it works:\nconst config = {\n  key: 'root',\n  storage,\n};\nat one point I read that 'root' was for 'v4', it was a comment I had left in there. I removed it.\nHowever, on my machine, my app only runs if I put primary\nconst config = {\n  key: 'primary',\n  storage,\n};\nCan anyone explain that?\nThe reason why I tried changing primary to root for my co-worker: pure guess :)\nThe error we we get if we use the incorrect value is like can't read property payload of undefined meaning on action.payload and its caused by:\ncase 'persist/REHYDRATE':\n            return Object.assign({}, state, {...action.payload.newClaim}). Hmm I don't completely follow you. You mean to delete npm_modules and re-install them? Or delete the entire project directory and do git clone... again?\nWe looked at Chrome tools > Application tab > Local Storage > localhost:3000 > and he deleted all the key/value pairs in there (one of which was primary:root) and now he can't get the app to run again.\nHe's trying both root and primary as the value, we're having no luck. Something we're not understanding here about how it works. Hmmm.\nUpdate this works:\nif(!action.payload){\n     return Object.assign({}, state, {initialState})\n}\nreturn Object.assign({}, state, {...action.payload.newClaim}). ",
    "eagsalazar": "Aha yes my bad!  Thanks!!\nOn Wed, Jan 3, 2018 at 10:20 AM, Inaki Anduaga notifications@github.com\nwrote:\n\nthat looks like redux logger middleware you're running in the tests, make\nsure to disable that middleware during the tests\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/rt2zz/redux-persist/issues/638#issuecomment-354978259,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAL1XjBX4G1knr_nP9f3qRUDXjiAkbbOks5tG1SEgaJpZM4RLi0Y\n.\n. \n",
    "kulor": "@ProductOfAmerica there's a chance I'm wrong but are you looking for PURGE to remove the stored state?. ",
    "jamaljeantobias": "I get this as well . ",
    "marionorato77": "I had the same issue because I was saving the response I was getting from a Firestore query into the state. The Firestore query response contains cyclic data (ref parameter) that is not possible to JSON.stringify hence the error from Redux-Persist. In my case I just had to remove the 'ref' parameter containing the cyclic data and the issue got solved.. ",
    "MukeshSinghBisht": "I resolved this issue but still i am not sure how that thing is working. Actually I was saving e.target in a redux state  and i was getting that error. So i used local state of the component (this.state) and error was resolved. Can anyone explain this behaviour?. ",
    "zxl634": "@marionorato77 where exactly did you remove the ref parameter? I have the following action getting some data that I suspect is the cause of the error mentioned above, but not sure where to remove 'ref'.\nexport const getSomeData = () => {\n  return (dispatch) => {\n    firebase.database().ref('/data/subdata').on('value', (snapshot) => {\n      dispatch({\n        type: SOMETYPE,\n        payload: snapshot.val(),\n      })\n    })\n  }\n}\nUPDATE: Found out that that passed a \"user\" object from a Firebase query that I think had the same problem.\n . ",
    "vladp": "I also need this kind of capability.\nWhere you able to establish a working prototype? Does it automatically work with rocksdb and sqlite ?\nthx. ",
    "pocesar": "yeah, I guess. since the primary usage isn't for React, would make sense to be a separate module. ",
    "lestard": "We are using redux with angular and this prevents us from using redux-persist.\nIt would be great to have a UI-agnostic version of redux-persist.. ",
    "rooque": "See https://medium.com/@thenewt15/the-definitive-guide-to-redux-persist-84738167975\nI think it's a WIP\nhttps://github.com/rt2zz/redux-persist/pull/588. ",
    "ZackLeonardo": "createTransform. ",
    "luchianenco": "Found the issue, if you already used combineReducers\n```\nconst reducers = combineReducers({\n    profile,\n    events\n});\n``\nthen you should useconst reducer = persistReducer(config, reducers);instead ofconst reducer = persistCombineReducers(config, reducers);`. ",
    "j-o-d-o": "Probably same issue as here: #603 . Adding this to app.js fixes it:\njavascript\n    componentDidMount() {\n        this.persistor.dispatch({ type: REHYDRATE });\n    }\nRehydrate action is never dispatched by react-persist. Is this intended? If yes, it would be nice to have it in the documentation (at least I could not find anything).. using combineReducer throws an error (I was stuck there before for a while too ; ) ). \nI will try to import storage from redux-persists. Thx for the hint. . @runeogod has take a while sry. But using import storage from 'redux-persist/es/storage'; worked. Now i don't need to rehydrate on componentDidMount(), thanks ; ). ",
    "DeepaSriramRR": "If the issue is only seen while refreshing app, try this in configureStore:\nexport const store = createStore(persistedReducer)\nexport const persistor = persistStore(store)\nexport default () => {\n  return { store, persistor }\n}\nThis way the store and persistor are created exactly once.. ",
    "freshcoat": "Did you find yourself already a solution to this ? I am searching for something similar. I did an application fade in on reHydrated = true in v4 but searching for something similar with v5 persistGate.. @wachunei Thanks, did the same trick, works great! \ud83d\udc4d . ",
    "isurugajasinghe": "@wachunei I used your code animatedgate.js but Image do not transparent(background color visible as light blue color). why is that  ?\n\n. \n. can you pls type sample code here. ",
    "4external": "Ok. i need use Object.assign. for reducers/index.js\n```\nlet reducers = Object.assign(\n    authReducer,\n    navReducer\n);\nexport default reducers\n```. ",
    "bmueller-sykes": "I get the same issue. Something seems amiss here. Some details:\nIf I try any of the following:\nimport storageLocal from 'redux-persist/es/storage/session';\nimport storageLocal from 'redux-persist/es/storage/'\nimport storageLocal from 'redux-persist/lib/storage/'\nimport storageLocal from 'redux-persist/lib/storage/index'\n...then I get a React error that says Error: redux-persist: config.storage is required. Try using import storageLocal from 'redux-persist/es/storages/local'\nThen, in the following cases:\nimport storageLocal from 'redux-persist/es/storages/local'\nimport storageLocal from 'redux-persist/es/storages/session'\nimport storageLocal from 'redux-persist/lib/storages/local'\nimport storageLocal from 'redux-persist/lib/storages/session'\n...I get a JS import error saying the module cannot be found:\nModule not found: Can't resolve 'redux-persist/specific/path/from/above'\nDigging through the redux-persist library, I see both an es/storage folder and a lib/storage folder. Nowhere do I see a storages folder or sub-folder. I don't know if that means the error message is wrong (it says storages in the error message) or I'm importing the wrong way.\n[EDIT: I should note that I want to use the browser's sessionStorage as opposed to localStorage]. Thanks for the reply!\nTypo makes sense. Here's what I was doing for config:\nconst config = {\n  key: 'myKey',\n  sessionStorage\n}\n...because that's what the example shows. The fact that the example just shows storage and not storage: [some storage object] threw me off, but I thought maybe you were doing something clever with JS that I just didn't understand. If the proper format is:\nconst config = {\n  key: 'root',\n  storage: sessionStorage\n}\n...then that makes way more sense. I'll try again and report back (though it may not be until tomorrow). Meantime, I might suggest updating the docs to be more explicit there for dopes like me who need our hands held. (-;. Thanks! One more small note: the v4 to v5 migration section of the docs should be updated as well (that's where I was looking, as I'm an upgrader).. This particular thread is just about v5 of redux-persist. There was a big API change from 4 to 5, so if you try to invoke redux persist in the manner detailed above using a version of the library prior to 5.x.x, it will break.. In case it's helpful, here's a somewhat stripped-down version of how I'm invoking redux-persist:\n```\nimport { persistCombineReducers, persistStore } from 'redux-persist';\nimport sessionStorage from 'redux-persist/es/storage/session';\nconst persistConfig = {\n    key: 'myPersistKeyword',\n    storage: sessionStorage\n}\nconst reducers = persistCombineReducers(persistConfig, allMyReducersWhichAreDefinedOutsideThisExample);\nexport default function configureStore() {\nconst store = createStore (\n reducers,\n     ...whatever else you pass to createStore()\n)\n\nconst persistor = persistStore (store)\nreturn { persistor, store }\n\n}\n```. ",
    "drydenwilliams": "I just did an instal of redux-persist and I'm still getting: Can't resolve 'redux-persist/lib/storage'. ",
    "connercms": "@DJTB As a workaround, inside my action creator I dispatch an object with type 'LOG_OUT', then in every single reducer file I have a case for 'LOG_OUT' and set state: initialState. It seems to persist this just fine. I used the code I posted above before I updated redux persist versions and it worked fine - not sure what changed. ",
    "DavitVosk": "I have the same problem here. Does anybody solve an issue?. @rt2zz Thanks for your response. So when I press Logout button, I call 2 actions with respective types: USER_LOGOUT and RESET. Based on the first type I return state=undefined in appReducer (as mentioned in this issue raise description). The second type RESET I use to reset the state (I use redux-reset). The outcome: when Logout is pressed, the app navigates to the welcome screen of the app (as it should be), BUT when I reload the app it goes to the first page of the app, namely I could not somehow nullify the redux state when logged out.\n. @rt2zz I tried with setting empty object to state when action type is USER_LOGOUT, but unfortunately no success.. @DJTB yes I could not though find a way to handle logout at the top level and without making each reducer to listening to my \"USER_LOGOUT\" action type. I also tried your above-mentioned structure with nestedPersisted reducers, but it was not working from my side. I just make sure all reducers listen to my USER_LOGOUT action type and nullify themself to their initial state. It works like a charm. @DJTB and @rt2zz Guys thanks for being ready to discuss and help :)\n. But I think this issue should not be closed since the bug is still there. We just found an alternative solution. . ",
    "navata": "I have this issues as below:\nIn Android, I listening event AppState for updating data.\n```\ncomponentWillUnmount(){\n    AppState.removeEventListener('change', this.handleAppStateChange.bind(this));\n}\nhandleAppStateChange (nextAppState) {\n    if(nextAppState == 'background') {\n      session.logout().then(() => {});\n    }\n}\n```\nsession.logout(): it will remove data in store\nI have 2 case:\n1. I press home and close app (kill) => When I reopen app, data don't remove and store will restore old data.\n2. I press home and not close app (background) => When I reopen app, data will remove in store.\n=> when you update data in store and close app => it don't work.. ",
    "anguyen1817": "Just ran into this today. Is there any other solution other than each reducer listening to the log out action?. ",
    "mhkhung": "Can we also have autoMergeLevel3? . ",
    "icaroponce": "@ChrisLahaye thank you for your reply. \nI'll try to export the persistor object someway to get access to it into the browser console and be able to call both methods. . ",
    "eduduardo": "@rt2zz cool!. ",
    "Amurmurmur": "@rt2zz Thank you for your quick response first of all!\nHere is the HMR code:\n```\n  if (module.hot) {\n    module.hot.accept(() => {\n      const nextRootReducer = require('./').reducers\n      store.replaceReducer(nextRootReducer)\n  const newYieldedSagas = require('../Sagas').default\n  sagasManager.cancel()\n  sagasManager.done.then(() => {\n    sagasManager = sagaMiddleware.run(newYieldedSagas)\n  })\n})\n\n}\n```. Fixed with the suggested code above.\nThank you so much for such a quick response @aselhid and @rt2zz !!\n. Same story here :/. ",
    "aselhid": "@Amurmurmur i was able to fix the problem in my project by adding the persist reducer to the nextRootReducer \n```javascript\n  if (module.hot) {\n    module.hot.accept(() => {\n      let nextRootReducer = require(\"./\").reducers;\n      if (REDUX_PERSIST.active) { \n        const persistConfig = REDUX_PERSIST.storeConfig;\n        nextRootReducer = persistReducer(persistConfig, reducers);\n      }\n  store.replaceReducer(nextRootReducer);\n\n  const newYieldedSagas = require(\"../Sagas\").default;\n  sagasManager.cancel();\n  sagasManager.done.then(() => {\n    sagasManager = sagaMiddleware.run(newYieldedSagas);\n  });\n});\n\n}\n```. ",
    "justrag": "Option 1 worked great, big thanks!. ",
    "BeaveArony": "I think it should be \"typings\" instead of \"types\". At least that's what is working for me.. ",
    "Hamabama": "Yes, I did! It was an issue on my side. Thank you!. ",
    "sadi304": "@Hamabama  can you tell me what was the solution? i am facing similar problem here. . see #734 . you will find the solution there . there was a problem in the structure. I actually forgot what the issue was. but it was not a bug definitely. the problem was from my side. . oh i remembered. the objects were not exported correctly. persist store and the store. . @anhphuongbn94 , look at your codes, how you are exportng or importing. the problem is there. as persistor was undefined . . de structure your import . use { } . default should be ommited for that case\nwhen you export default you cant destructure . you have to import as a default. import MS from .......\nMS.store \nMS.persistor \nPS: please use stack overflow for these questions. report bugs or feature requests here . this is a closed topic already. . ",
    "maxvilchez": "@Hamabama what was the solution?. ",
    "shamanking": "I have same issue, this is my code:\nconfigStore.js:\n```\nimport { createStore, compose, applyMiddleware } from 'redux';\nimport thunk from 'redux-thunk';\nimport { persistStore, persistReducer } from 'redux-persist';\nimport storage from 'redux-persist/lib/storage';\nimport { AsyncStorage } from 'react-native';\nimport reducers from '../reducers';\nconst persistConfig = {\n  key: 'root',\n  storage,\n  whitelist: ['likedJobs'],\n};\nconst persistedReducer = persistReducer(persistConfig, reducers);\nexport default () => {\n  let store = createStore(\n    persistedReducer,\n    {},\n    compose(\n      applyMiddleware(thunk),\n    )\n  )\n  let persistor = persistStore(store);\n  return { store, persistor }\n};\n```\nApp.js\nreturn (\n      <Provider store={store}>\n        <PersistGate loading={null} persistor={persistor}>\n          <View style={styles.container}>\n            <MainNavigator />\n          </View>\n        </PersistGate>\n      </Provider>\n    );. Thanks @sadi304 \nmy solution:\nApp.js\nimport configureStore from './store';\nconst { persistor, store } = configureStore();. ",
    "maxkomarychev": "another version with promises (1st message updated)\njs\nconst fsPersistor = persistStore(\n    this.store,\n    { storage: FilesystemStorage },\n    async (fsError, fsResult) => {\n        if (_.isEmpty(fsResult)) {\n            try {\n                const asyncState = await getStoredState({\n                    storage: AsyncStorage,\n                })\n                if (!_.isEmpty(asyncState)) {\n                    fsPersistor.rehydrate(asyncState, {\n                        serial: false,\n                    })\n                }\n            } catch (getStateError) {\n                console.warn('getStoredState error', getStateError)\n            }\n        }\n    },\n). > this looks great / correct! Unfortunately this approach only works for v4\nthat is true, I updated 1st post\n. ",
    "alanlanglois": "I'm a little confuse, any place where I can find an example of AsyncStorage to redux-persist-filesystem-storage migration using V5?. Working on it\nI can get previously stored data using AsyncStorage: \n```\nlet persistor = persistStore(store, persistConfig, async () => {\n      try {\n          console.log(\"Get Async State\")\n          const asyncState = await getStoredState({\n              key: 'root',\n              storage: AsyncStorage,\n          })\n      console.log(\"Async State: \" + asyncState )\n      if (asyncState) {\n          console.log(\"Stored Async Data\" + JSON.stringify(asyncState));\n      }\n  } catch (error) {\n      console.warn('Get Async State error', error)\n  }\n\n```\nbut I can't really see how rehydrate the file storage store with these data, as fsPersistor.rehydrate doesn't exists anymore in v5.\nShould I use Transform? or is there a method replacing .rehydrate in v5?. @jrmurad I moved from AsyncStorage to FSStorage (based on react-native-fs) and the issue seem to appear way less often, but it still occurs from time to time on some Android devices.\nAn appropriate fix would be to have a way to detect and display they error and stop the rehydrate process. . Anyone found a solution @jrmurad @jesperlndk @alexmngn?. @lukebrandonfarrell \nFew mounths ago I gave it a try, unfortunatly it wasn't working with an expo detached project.  (rn-fetch-blob wasn't at least). \nI then changed a little the lib to use react-native-fs instead of rn-fetch-blob. \nIt fixed the problem in most cases, but I still have the issue from time to time (way less often). \nDo you have a large audience are you sure it totally fixed your problem? (I got like 10K+ install on Android)\n. @ssorallen  It seems to be talked here: https://github.com/rt2zz/redux-persist/issues/717. ",
    "hutchy2570": "See https://github.com/rt2zz/redux-persist/issues/806#issuecomment-425838924. Hi,\nI've managed to get this to work using v5's migrate feature.\nisStateEmpty is a function which you craft to determine whether the state is empty for your use case.\nconst migrate = async state => {\n  // Migrate from async storage to fs https://github.com/robwalkerco/redux-persist-filesystem-storage#migration-from-previous-storage\n  __DEV__ && console.log('Attempting migration');\n  if (isStateEmpty(state)) {\n    // if state from fs storage is empty try to read state from previous storage\n    __DEV__ && console.log('FS state empty');\n    try {\n      const asyncState = await getStoredState({\n        key: 'root',\n        storage: AsyncStorage,\n      });\n      if (!isStateEmpty(asyncState)) {\n        __DEV__ && console.log('Async state not empty. Attempting migration.');\n        // if data exists in `AsyncStorage` - rehydrate fs persistor with it\n        return asyncState;\n      }\n    } catch (getStateError) {\n      __DEV__ && console.warn('getStoredState error', getStateError);\n    }\n  }\n  __DEV__ && console.log('FS state not empty');\n  return state;\n};\nYou then just include this function as the migrate property of the PersistConfig passed to persistReducer. ",
    "nhducit": "You can follow this issue: https://github.com/rt2zz/redux-persist-immutable/issues/33. ",
    "Alver23": "Hi, I have the same problem, any solution for this?\n\n. ",
    "sylflo": "It seems except fixing the issue or downgrading there is no other solutions.\nIs downgrading to the version 4 of redux persist is enough ? I know it's a temporary solution. ",
    "jpshelley": "I have an issue currently with full state marked here - https://github.com/rt2zz/redux-persist/issues/871. ",
    "baransu": "I've experienced the same error. But I also have more errors than only this. I'm using flow in version 0.63.1.\nWhole error message: https://gist.github.com/Baransu/8067a88c06f9d5593cadc982da06aba3\n. First fix error was fixed. Thanks. I still have a problem with\ntype Persist = Store & { flush: Flush, purge: Purge }\nHere is full error:\n``\nError: node_modules/redux-persist/lib/persistStore.js.flow:65\n                                  v-----------\n 65:   let persistor: Persistor = createStore(\n 66:     persistorReducer,\n 67:     undefined,\n 68:     options.enhancer\n 69:   )\n       ^ Store. This type is incompatible with\n 65:   let persistor: Persistor = createStore(\n                      ^^^^^^^^^ Persistor\n  Propertyflushis incompatible:\n     65:   let persistor: Persistor = createStore(\n                          ^^^^^^^^^ propertyflush`. Property not found in\n                                      v-----------\n     65:   let persistor: Persistor = createStore(\n     66:     persistorReducer,\n     67:     undefined,\n     68:     options.enhancer\n     69:   )\n           ^ Store\nError: node_modules/redux-persist/lib/persistStore.js.flow:65\n                                  v-----------\n 65:   let persistor: Persistor = createStore(\n 66:     persistorReducer,\n 67:     undefined,\n 68:     options.enhancer\n 69:   )\n       ^ Store. This type is incompatible with\n 65:   let persistor: Persistor = createStore(\n                      ^^^^^^^^^ Persistor\n  Property pause is incompatible:\n     65:   let persistor: Persistor = createStore(\n                          ^^^^^^^^^ property pause. Property not found in\n                                      v-----------\n     65:   let persistor: Persistor = createStore(\n     66:     persistorReducer,\n     67:     undefined,\n     68:     options.enhancer\n     69:   )\n           ^ Store\nError: node_modules/redux-persist/lib/persistStore.js.flow:65\n                                  v-----------\n 65:   let persistor: Persistor = createStore(\n 66:     persistorReducer,\n 67:     undefined,\n 68:     options.enhancer\n 69:   )\n       ^ Store. This type is incompatible with\n 65:   let persistor: Persistor = createStore(\n                      ^^^^^^^^^ Persistor\n  Property persist is incompatible:\n     65:   let persistor: Persistor = createStore(\n                          ^^^^^^^^^ property persist. Property not found in\n                                      v-----------\n     65:   let persistor: Persistor = createStore(\n     66:     persistorReducer,\n     67:     undefined,\n     68:     options.enhancer\n     69:   )\n           ^ Store\nError: node_modules/redux-persist/lib/persistStore.js.flow:65\n                                  v-----------\n 65:   let persistor: Persistor = createStore(\n 66:     persistorReducer,\n 67:     undefined,\n 68:     options.enhancer\n 69:   )\n       ^ Store. This type is incompatible with\n 65:   let persistor: Persistor = createStore(\n                      ^^^^^^^^^ Persistor\n  Property purge is incompatible:\n     65:   let persistor: Persistor = createStore(\n                          ^^^^^^^^^ property purge. Property not found in\n                                      v-----------\n     65:   let persistor: Persistor = createStore(\n     66:     persistorReducer,\n     67:     undefined,\n     68:     options.enhancer\n     69:   )\n           ^ Store\nError: node_modules/redux-persist/lib/persistStore.js.flow:67\n 67:     undefined,\n         ^^^^^^^^^ undefined. This type is incompatible with the expected param type of\n 83:   +getState: () => PersistorState,\n                        ^^^^^^^^^^^^^^ PersistorState. See: node_modules/redux-persist/lib/types.js.flow:83\nI think that above type won't work because createStore returns Store and later on we're adding `flush` and `purge`. I'll try to look into. My problem may be having redux flow-typed definitions which is conflicting with `redux-persist`.. It would work if your reducers are not nested. Here is official documentation about this:\nhttps://github.com/rt2zz/redux-persist#state-reconciler\nWhat I'm doing in my application is persisting store only for one branch of reducer (auth in my case). If you want to persist whole state you have to change merging strategy..js\nconst reducers = combineReducers({\n  / auth is just a simple (state, action) => state function reducer /\n  auth: persistReducer({ key: 'my-key', storage }, auth), \n  router: routerReducer\n});\nI don't care about other parts of the state to be persisted so I'm applying `persistReducer` only to this one key.js\n/ I want ReduxDevTools connected to I'm adding this here. /\nconst composeEnhancers = window.REDUX_DEVTOOLS_EXTENSION_COMPOSE || compose;\nconst store = createStore(\n  reducer,\n  composeEnhancers(applyMiddleware(thunkMiddleware, routerMiddleware(history)))\n);\nexport const persistor = persistStore(store);\nexport default store;\n``\nI'm passingstoreto myand thenpersistorto`. It's exactly the same as in this part of documentation: https://github.com/rt2zz/redux-persist#quickstart.\nI hope this will help you.\n. Tests seems to work fine and in my basic setup its working. I\u2019ll be glad if you could look into it :). ",
    "Cretezy": "I do like the idea of more a pipeline. This wouldn't a breaking chance since we could add a loadTransformations and saveTransformations keys to the PersistConfig. It would allow something like:\njs\nloadTransformations: [\n    decrypt,\n    decompress\n    migrate,\n    someImplementationSpecificLoadTransform\n],\nsaveTransformation: [\n    someImplementationSpecificSaveTransform,\n    compress,\n    encrypt\n]\nThis seems like a great use of (chaining) Promises. How would handling errors me? Each transformation would be able to throw errors, but should it stop loading (like it currently does if there's an error in a transformation, which is what I was hitting)?\nHow should the API be? transformation(state): Promise seems like the obvious easiest answer, however this removes the \"key\" option from the previous transformation API.\n. ",
    "vujevits": "I just ran into this issue, because I'm trying to do a migration which is about leaving immutable-js behind. If this change is not implemented yet, is there some kind of work-around suggested?. ",
    "chadmoller": "Awesome. Thanks for the fast response!!. ",
    "deecewan": "@rt2zz I think #697 will fix the majority of the flow errors, but still curious around why _persist is stored in the user's store rather than the store created with persistStore?\nDoing this messes with my State type, because instead of being as expected, it's got an extra property on it, which I'm not too keen on adding manually because it looks like it's private.. @rt2zz thanks so much for the detailed response. I figured that you had probably looked at this, and was mostly just curious as to why this decision was made.\nI'm interested to see what the eventual solution is, but for now I'm happy to go back to manually adding the key.. For anyone else who stumbles in here, I could not get my setup to play nicely with\n```\nimport { type PersistState } from 'redux-persist/src/types'\ntype State = {\n  //... your state shape\n  _persist: PersistState\n}\n```\nI got errors from some middleware, etc, and I didn't have time to diagnose.\nI ended up just casting the persistReducer call and essentially ignoring the _persist key. I don't want that key used in the application itself, so this works out well.\nMy code looks like:\n```js\nimport type { State, Actions } from '../types/store';\nconst persistedReducer: (State, Actions) => State = persistReducer(config, reducer);\n```\nNow, flow is happy and I am happy.. Is there a fix happening here? I'm not really sure why this lib shouldn't just follow the redux API.. ",
    "maxammann": "I'm having similar problems and can not get it working. This is my store config:\n```\n  const baseReducer: Reducer = combineReducers({\n    uiDirection: uiDirectionReducer,\n    language: languageReducer,\n    darkMode: toggleDarkModeReducer,\n    network: reactNativeOfflineReducer,\n    data: combineReducers({\n      cities: citiesReducer,\n      categories: categoriesReducer\n    })\n  })\nconst rootReducer: Reducer = persistReducer(persistConfig, baseReducer)\nconst middleware = applyMiddleware(createNetworkMiddleware(), sagaMiddleware, createLogger())\nconst store: Store = createStore(rootReducer, middleware)\n```\nThe type of my store is:\n```\nexport type StateType = {\n  uiDirection: string,\n  language: string,\n  darkMode: boolean,\n  network: { isConnected: boolean, actionQueue: Array },\n  data: {\n    cities: any,\n    categories: any\n  }\n}\nexport type PersistedStateType = {\n  uiDirection: string,\n  language: string,\n  darkMode: boolean,\n  network: { isConnected: boolean, actionQueue: Array },\n  data: {\n    cities: any,\n    categories: any\n  },\n  _persist: PersistState\n}\n```\nBut I get the following error:\n```\nError \u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508 src/modules/app/createReduxStore.js:91:69\nCannot assign persistReducer(...) to rootReducer because:\n \u2022 object type [1] is incompatible with undefined [2] in the first argument.\n \u2022 property darkMode is missing in PersistPartial [3] but exists in PersistedStateType [4] in the return value.\n \u2022 property data is missing in PersistPartial [3] but exists in PersistedStateType [4] in the return value.\n \u2022 property language is missing in PersistPartial [3] but exists in PersistedStateType [4] in the return value.\n \u2022 property network is missing in PersistPartial [3] but exists in PersistedStateType [4] in the return value.\n \u2022 property uiDirection is missing in PersistPartial [3] but exists in PersistedStateType [4] in the return value.\n src/modules/app/createReduxStore.js\n 88\u2502     })\n 89\u2502   })\n 90\u2502\n\n[4] 91\u2502   const rootReducer: Reducer = persistReducer(persistConfig, baseReducer)\n     92\u2502\n     93\u2502   const middleware = applyMiddleware(createNetworkMiddleware(), sagaMiddleware, createLogger())\n     94\u2502\n flow-typed/npm/redux_v4.x.x.js\n\n[2] 30\u2502   declare export type Reducer = (state: S | void, action: A) => S;\n node_modules/redux-persist/lib/persistReducer.js.flow\n\n[1] 30\u2502 export default function persistReducer(\n     31\u2502   config: PersistConfig,\n     32\u2502   baseReducer: (State, Action) => State\n [3] 33\u2502 ): (State, Action) => State & PersistPartial {\n. The main problem is this:\nError \u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508 src/modules/app/createReduxStore.js:86:64\nCannot call createStore because StateType [1] is incompatible with undefined [2] in the first argument.\n src/modules/app/createReduxStore.js\n\n[1]  82\u2502   const rootReducer: (state: StateType, action: StoreActionType) => StateType = baseReducer\n      83\u2502\n      84\u2502   const middleware = applyMiddleware(createNetworkMiddleware(), sagaMiddleware, createLogger())\n      85\u2502\n      86\u2502   const store: Store = createStore(rootReducer, {\n      87\u2502     uiDirection: uiDirectionReducer,\n      88\u2502     language: '',\n      89\u2502     darkMode: false,\n      90\u2502     network: {isConnected: false, actionQueue: []},\n      91\u2502     data: {\n      92\u2502       cities: {},\n      93\u2502       categories: {}\n      94\u2502     },\n      95\u2502     _persist: {\n      96\u2502       version: 0,\n      97\u2502       rehydrated: false\n      98\u2502     }\n      99\u2502   }, middleware)\n     100\u2502\n     101\u2502   sagaMiddleware.run(rootSaga)\n     102\u2502\n flow-typed/npm/redux_v4.x.x.js\n\n[2]  30\u2502   declare export type Reducer = (state: S | void, action: A) => S;\nThe redux Reducer type uses `S | void` as type for the state. But redux-persist uses an `Object` in the reducer definition.\nI got it working by handling the `void case separately`:\n  const persistConfig = {\n    key: 'network',\n    storage: AsyncStorage\n  }\nconst initialState = {\n    uiDirection: uiDirectionReducer,\n    language: '',\n    darkMode: false,\n    network: {isConnected: false, actionQueue: []},\n    data: {\n      cities: {},\n      categories: {}\n    },\n    _persist: {\n      version: 0,\n      rehydrated: false\n    }\n  }\nconst baseReducer: (state: StateType | void, action: StoreActionType) => StateType = (state, action) => {\n    if (!state) {\n      return initialState\n    }\nreturn persistCombineReducers(persistConfig, {\n  uiDirection: uiDirectionReducer,\n  language: languageReducer,\n  darkMode: toggleDarkModeReducer,\n  network: reactNativeOfflineReducer,\n  data: combineReducers({\n    cities: citiesReducer,\n    categories: categoriesReducer\n  })\n})(state, action)\n\n}\nconst middleware: StoreEnhancer = applyMiddleware(createNetworkMiddleware(), sagaMiddleware, createLogger())\nconst store: Store = createStore(baseReducer, initialState, middleware)\n``. Having the same problem on 5.10.0 with react-native and AsyncStorage . Weird that it persists though all these versions.. I upgraded to react-native 0.57.0 and removed the_persist` key from my initial state (I had is there because of flow typing issues).\nSo probably the removal of the _persist key solved it for me.. Is there already a solution to this?. Hm, I'm not sure how I exactly fixed this, but here is my redux configuration: https://github.com/Integreat/integreat-react-native-app/blob/develop/src/modules/app/createReduxStore.js#L94. ",
    "adamvert": "That's a good idea - I'm now testing a new build using redux-persist-filesystem-storage. No issues so far, but I'll keep using it and report back.\nThe storage is not really that huge: the RCTAsyncLocalStorage_V1 directory on an instance that has shown this crashing behaviour contains a file that is 35MB.. Occurrences of this bug have been dramatically reduced since I started using the filesystem adapter, and based on conversations with the author of that, I'm ready to assume that this is an out of memory error based on a reducer with too much data. It looks like the native implementation of Async Storage crashes when preparing the string to write to file if the JSON is too large.. ",
    "grebenyuksv-preply": "Thanks for your kind answer @Baransu , I did make it write smth into localStorage by wrapping both my root reducer and a nested reducer into persistReducer, but now it only saves the root state to localStorage, and rehydrates in a weird way. I've already spent several hours on trying to make it work, and I honestly think I won't try anymore until someone helps me with an example. This lib was my first choice because of 4k+ stars. \nAm I having an unlucky day? Could you somehow share exactly what you did to make it work, step by step?. Thank you so much @Baransu , I did do this all before, but you inspired me for one more try. My setup didn't seem to work for a combination of reasons:\n\nmy reducer was returning a Number, not an Object;\nI still find it a bit weird that const double = (state, { type }) => ({ value: Math.random() }) does not get persisted even if there are actions before the series of persist/REHYDRATE;\nWhen it does persist, no more actions are dispatched;\nI was misunderstanding the action names persist/PERSIST and persist/REHYDRATE.\n\nApparently, everything actually works, I think I'll close this \u2014\u00a0but still, an example could save me a day. Maybe I'll think of creating one.. ",
    "aaesis": "Hi, I have also the same problem with @grebenyuksv-preply. \"When does persist no more actions are dispatched\". I also inspired with this guide. I search all the possibilities and tried several times, but still it does not work for me. \nOverview of my code (ConfigureStore):\n```\nconst persistConfig = {\n  key: \"root\",\n  storage: storage\n};\nfunction configureStore(): Store {\n  const sagaMiddleware = createSagaMiddleware();\n  const middlewares = [sagaMiddleware];\n  const enhancer =\n    process.env.NODE_ENV === \"development\"\n      ? composeWithDevTools(applyMiddleware(...middlewares))\n      : applyMiddleware(...middlewares);\n  const persistedReducer = persistReducer(persistConfig, createGlobalReducer());\n// create store\n  const store = createStore(persistedReducer, enhancer)\n  // running saga\n  sagaMiddleware.run(rootSaga);\n  return store;\n}\nexport const persistor = persistStore(configureStore());\nexport default configureStore;\n```\nI already put my persistor in my index. What I also I want is to have good example and will help me.. ",
    "wearefridayhutber": "A RL example would still be good tbh. ",
    "ch1ll0ut1": "@rt2zz i would guess its missing typings, but cant be sure. From googling it seems it should be possible doing \njavascript\ndeclare module 'redux-persist/lib/storage' {\n...\n}\nBut on the other side, wouldnt it be better exporting the full api on the root module?. ",
    "i8wu": "Getting an error with lib/integration/react as well. Adding this to index.d.ts fixes it.\ndeclare module \"redux-persist/lib/integration/react\" {\n    export * from \"redux-persist/es/integration/react\";   \n}. @rt2zz  Seems like PersistGate works now...but import storage from \"redux-persist/lib/storage\" is complaining about \"redux-persist/lib/storage\" has no default export. still an issue on \"redux-persist\": \"5.9.1\". Trying to test this out, but when installing from your branch I getModule not found: Can't resolve 'redux-persist'`\nEdit: nvm, ran npm run build. Are you sure this is right? I tested this branch and needed to change it to ./src/index.d.ts to work.. ",
    "initFabian": "Running: \nversion: 5.7.2\n@types: 4.3.1\nWhen trying to import autoRehydrate: \nimport { autoRehydrate } from 'redux-persist'\nI get the following error:\nModule '\"redux-persist\"' has no exported member 'autoRehydrate'.. ",
    "riaadh": "Hi there ,i have the same problem \nv5.6.0\ni am using redux-persist in angular5 app, does it work only with react?\nthanks for your help\n. ",
    "frankbardon": "npm i --save @types/react clears up the build error.. ",
    "samhunta": "Re: \n\nWorth it, would have saved me time debugging this AsyncStorage bug\nA timeout of even less (3s) would be nice for my use cases. \nI think it fits here well since the functionality doesn't change depending on the storage adapter. \n",
    "nico1510": "Hmm but is that really the better alternative ? I mean for my use case I would rather have the user restart the app if it doesn't render than losing all the data and continuing... Can we avoid this new logic by e.g. setting the timeout to -1 in the config or should I just pass a large number in there ?. ",
    "heymaddieh": "@rt2zz  So what is the purpose of purge? Where would it be used?. ",
    "hpelitebook745G2": "@heymaddieh have you figured out how to do this?\n. ",
    "Azmeer-crescent": "Thank you very much for your quick response, I got it working. Had to play with Actions and Reducers. ",
    "leonchabbey": "Same here.\nSeems related to these recent commits: https://github.com/rt2zz/redux-persist/commit/436050044d5ea6483d084c67820cd3fd9466eb38 and https://github.com/rt2zz/redux-persist/commit/98a78d9aa39d6634a39bd81c776d3ce91e0e7192. ",
    "JanithaR": "The same happens to me after upgrading to v5.7.1. How to downgrade? Uninstall and re-install?. Thanks @NichAga I figured it out. Just downgrade and keep working for the moment guys.. I ran into this issue a couple of hours ago. Now everything is perfectly fine. In the hopes of helping what happened in my case here it is.\nI was working in the project and when ran outta battery in my mac so I just closed it and set aside yesterday. Today I just resumed working. And I remember the Android time mismatch warning was visible on my emulator. So lazy me just changed the clock setting and continued to work and that's when the issue popped up and I found this issue. I just ignored for the time being and kept working and when tired just shutdown my mac. \nNow again I started working everything fresh and the issue is no longer there. So I guess just restart app, emulator, bundler or PC and it'll just go away.. ",
    "noelyoo": "I just downgraded version to 5.6.12 and still not working. @NichAga Yes, it should work. I was using Remote JS debugging. I stopped it and hence naturally it's working now.\n. ",
    "NichAga": "@avid21 Reverting back to 5.6.12 worked for me.. @JanithaR npm install redux-persist@5.6.12\n@avid21 good :D. ",
    "krzysztof-miemiec": "Use semver ~5.6.0 instead of ^5.6.0. I forgot about it at first.. ",
    "diegorodriguesvieira": "Same here! =( . ",
    "rohanx96": "Yes, getting the same error. Reverting to 5.6.12 worked. ",
    "l3lackcurtains": "Worked after switching back to redux-persist@5.6.12. ",
    "jarvisluong": "Switch back to 5.6.12 works!. ",
    "RodolfoSilva": "@rt2zz I still have the same error after update to v5.7.2.. @sytolk, Yes, I'm use the latest version and still have the error. This error only happens when I use the debug in the first time.\n\"redux-persist\": {\n      \"version\": \"5.7.2\",\n      \"resolved\": \"https://registry.npmjs.org/redux-persist/-/redux-persist-5.7.2.tgz\",\n      \"integrity\": \"sha512-NgkSoPA3o6vAo09U5hnzO8CgHNhnBIcZyZBr+tRa/pDDeQqtcsP/zru9b2vz5tIpK6GCYGEsEjSzWUU/vxfRQA==\"\n    },. ",
    "sytolk": "I don't have this error with v.5.7.2. @RodolfoSilva are you sure that you upgrade version? You can check this in npm.lock or yarn.lock file.. ",
    "ajaymore": "I can confirm it's working with 5.7.2.. ",
    "patlux": "~~For me it was the short 'debounce' time which caused the error:~~\n```\nconst persistOptions = {\n  storage,\n  debounce: 100, // <-- not working in 'Debug JS' mode\n  key: DeviceInfo.getBundleId(),\n  transforms: [compressor],\n};\npersistReducer(persistOptions, rootReducer)\n```\n~~I increased the time to 500 and now it's working fine.~~\nreact-native: v0.53.0\nredux-persist: 5.9.1\n\nOk, that fixed not the error. I downgraded to ~~v5.7.2~~ v5.6.12 and now it's working.. ",
    "challme28": "I have to say I've been stuck in this problem for a while now and it was my fault. I forgot to return an action on an Epic. I hope this helps anyone. I have to say I've been stuck in this problem for a while now and it was my fault. I forgot to return an action on an Epic. I hope this helps anyone. @tonykawa \nI had it like this:\nexport function rehydrateEpic(action$: ActionsObservable<RehydrateAction>) {\n  return action$.ofType(REHYDRATE)\n    .mergeMap(({ payload }) => {\n        const { authenticated } = payload.auth;\n        if (authenticated) {\n          return Observable.of(HomeAction)\n        }\n    });\n}\nIf the user is not authenticated it does not return anything so Rehydrated is called again \n\nOk I see REHYDRATE is being called twice\n\nSo i had to add a else return Observable.of(notAuthenticated());. This stopped the second call on REHYDRATE\n. ",
    "calanti": "I am stuck with this issue on my recently expo detached project. My state is never persisted regardless of remote debugging, and occasionally I get the error like the OP.\nExpo: 24.0.0\nreact: 16.0.0\nRN: Expo 24.0.0 fork\nreact-redux: 5.0.7\nredux: 3.7.2\nredux-persist: 5.9.1\nOn an up note, thank you very much for your work!. Thanks for the insight and yes I am whitelisting, but blacklisting is not really a maintainable solution for me, too many recuders and I only need 2 whitelisted. Hopefully this can help the devs identify the issue though!. ",
    "droegier": "Same as @calanti \n\"expo\": \"25.0.0\",\n\"native-base\": \"2.3.1\",\n\"react\": \"16.2.0\",\n\"react-native\": \"0.52.0\",\n\"react-navigation\": \"^1.4.0\",\n\"react-redux\": \"5.0.7\",\n\"redux\": \"3.7.2\",\n\"redux-persist\": \"5.9.1\". ",
    "kapobajza": "I was getting the same error on redux-persist version 5.9.1.\nIt was working fine until I put the whitelist prop into rootPersistConfig:\nconst rootPersistConfig = {\n    key: 'root',\n    ... ,\n    whitelist: ['auth']\n};\nBut then I switched back to using the blacklist property and everything works fine now.\nconst rootPersistConfig = {\n    key: 'root',\n    ... ,\n    blacklist: ['navigation', 'isLoading', 'hasErrored']\n};. ",
    "baba43": "I have just created a new project with Expo and can not get this work either. . ",
    "ChristienGuy": "I get this issue with 5.9.1.\nFor me it only occurs when remote debugging.\nPotentially related to this issue with setTimeout in React Native https://github.com/facebook/react-native/issues/4470. ",
    "augusto-altman": "Same as @ChristienGuy, only get the issue when remote debugging.. ",
    "tarikhagustia": "same here @ChristienGuy  error when remote debugging :3. ",
    "jamessawyer": "some issue with redux-persist V5.9.2 when debugger is open.. some issue, so I have to reset some field to initial value.\n```\nconst initState = {\n  isLoading: false,\n  message: null,\n  siteInfo: {\n    current_page: 1,\n    total_pages: 1,\n    total_count: 0,\n    websites: [],\n  },\n};\nexport default function siteReducer(state = initState, action) {\n  switch (action.type) {\n    case types.GET_SITE:\n      return {\n        ...state,\n        isLoading: true,\n        message: null, // have to reset message to null\n      };\n    case types.GET_SITE_SUCCESS:\n      return {\n        ...state,\n        isLoading: false,\n        message: action.message,\n        siteInfo: action.data,\n      };\n    case types.GET_SITE_FAIL:\n      return {\n        ...state,\n        isLoading: false,\n        message: action.message,\n      };\n    default:\n      return state;\n  }\n}\n```. ",
    "seanfar": "Running into this issue with redux-persist@latest on Android only (tested on API 27 and API 23). Seems to work fine on iOS.\nHappens regardless of whether the debugger is attached or not, and I tried using both AsyncStorage and FilesystemStorage.\nRolling back to 5.6.12 and 5.7.2 have both yielded positive results for me, and seem to work just fine. \n. ",
    "kenkotch": "After trying a few different versions to no avail, I restarted my computer like I would have on Windows98. Everything is back to normal and working again. It's not a good solution, but may be worth a try if you are still stuck...(I was only getting the error in debug mode)\n. ",
    "nickofthyme": "Appears to be working on 5.7.2 with remote JS Debugger.\n\nUpdate: Error still occurs intermittently on 5.7.2. But much less than 5.9.2.. Close to use major versions for all migrations.. \n",
    "xliank": "I'm using version 5.9.1 , only show error when enable Remote JS Debugging. \nStill no solution?. ",
    "jgfidelis": "Same issue: Android with Remote debugging on 5.9.1. Will try version 5.7.2.\nEdit: 5.7.2 did not work, 5.6.12 looks ok.. ",
    "Dmitrylolo": "same\n\"axios\": \"^0.18.0\",\n\"expo\": \"^27.0.2\",\n\"qs\": \"^6.5.2\",\n\"react\": \"16.3.1\",\n\"react-native\": \"https://github.com/expo/react-native/archive/sdk-27.0.0.tar.gz\",\n\"react-native-elements\": \"^0.19.1\",\n\"react-navigation\": \"^2.0.1\",\n\"react-redux\": \"^5.0.7\",\n\"redux\": \"^4.0.0\",\n\"redux-persist\": \"^5.9.1\",\n\"redux-thunk\": \"^2.2.0\"\nundefined is not an object (evaluating 'action.payload.search')\nsearch in whitelist. const store = createStore(\npersistedReducer,\n{},\napplyMiddleware(thunk));. sometimes it calls error with key in persistConfig. try key: 'primary'. ",
    "FMdigit": "using Redux Persist version  5.9.1 ... same issue\n. ",
    "altenorjr": "5.10 idem. ",
    "wmlutz": "\"redux-persist\": \"^5.9.1\"\nI'm having the same issues. Still no fix? Or hints? Or clues?. ",
    "ilovett": "@wmlutz restarting the android emulator and/or wiping the data of the device image via AVD Manager. I don't necessarily think this is an issue with redux-persist -- I use React Native Debugger, which has an option to Log AsyncStorage content to console.\nWhen I first cold boot an emulator and run the project, and start debugging remotely, I can see rehydrate works immediately for a while.  During this time if I Log AsyncStorage content then it will output the content to console immediately.\nOnce rehydrate starts timing out, if I Log AsyncStorage content then I get nothing in my console... which makes me think this is more of an android emulator issue or asyncstorage issue...\n. see: https://github.com/facebook/react-native/pull/18522. ",
    "MattJakeman": "Same issue for me on 5.10.0 - It's working correctly until I switch on remote debugging.. ",
    "nilscox": "I also do encounter this error with redux-persist@5.10.0.\nThe error message I'm getting during the persist/REHYDRATE action is redux-persist: persist timed out for persist key \"root\".\nAs far as I understand, redux-persist internally uses RN's AsyncStorage in order to store the state. Also, there is an issue when using AsyncStorage when debugging remotly, which makes the promise hang indefinitely (and may cause a timeout).\nCould it be the reason why redux-persist fails to load the state?. @Arjith-Natarajan I am using redux-logger. I will investigate if removing it can solve the problem.\n@ilovett this is defenetly not a redux-persist related error, but it has a side effect that makes redux-persist timeout. It happens to me on a real device on Android, so I'm pretty sure it's not related to the emulator environment.\nFor now, I am using this workaround. I created this tool that allow to access a storage on my computer from my device. I am using it with a networkStorage adapter that I give to redux-persist.. ",
    "arjithn": "@nilscox are you using any middlewares like redux-logger? I faced the exact same issues as yours while Debugging JS remotely\n\nredux-persist was not working, threw err : persist timed out for persist key \"root\"\nAsyncStorage promises never got resolved - issue\n\nAnd however when I tried to run with remote debugger it threw an error saying TypeError: undefined is not an object (evaluating self.fetch) -  issue\neven tried to fix it based on this snippet provided here\nand once I removed redux-logger the app started to behave in expected manner. Promises got resolved without timeout. Somehow made me feel all were connected! :confused: \nHope it helps someone! :raised_hands: \nCheers!. :+1 @phuihock that's definitely a fix. I used to get error messages in middle of development, saying Store rehydrated after time out , some 20 mins after I had started.\nSo we still need to figure out what max timeout to set as it varies for everyone.\nStill a mystery .... ",
    "jjercx": "\n\"react-redux\": \"5.0.7\"\n\"redux\": \"4.0.0\"\n\"redux-logger\": \"3.0.6\"\n\"redux-persist\": \"^5.9.1\"\n\"redux-saga\": \"0.16.0\"\n\nFor me happens debugging and on android device.. ",
    "IOsonoTAN": "I used \"redux-persist\": \"^5.10.0\" on Next.js, first i got the same error, i tried to not set initialState or set to object empty {} like this:\n\nconst store = createStore(persistedReducer, {})\n\nIt persisted and works fine.. @aguynamedben I thought i found something about this it may be a bug.\nReproduce steps\n1. Create _app.js with this code:\n<Container>\n  <Provider store={reduxStore}>\n    <PersistGate loading={<Loading visibility='visible' />} persistor={persistor}>\n      <Component {...pageProps} />\n    </PersistGate>\n  </Provider>\n</Container>\n2. You have to use Head from next/head to insert some data into <head>.\n3. Go to open a browser with your project url and then open page source.\n4. You will not see any tag in <head>.\n6. Get back to _app.js and try to remove PersistGate as this code:\n<Container>\n  <Provider store={reduxStore}>\n    <Component {...pageProps} />\n  </Provider>\n</Container>\n7. Go to a browser and try to open page source again.\n8. Every data in <head> will appears.\n\"next\": \"^7.0.2\"\n\"redux-persist\": \"^5.10.0\"\n\"react\": \"^16.6.3\"\n\"redux\": \"^4.0.1\"\nActually this problem appears on next 6 also, It effect to SEO of website directly.. ",
    "phuihock": "I have the same problem. Setting timeout > 5s seems to fix it. timeout defaults to 5s. I set mine to 10s.\n```\nconst persistConfig = {\n    timeout: 10000,\n    key: 'root',\n    storage,\n};\nconst persistedReducer = persistReducer(persistConfig, reducers);\n```\nUsing redux-persist@5.9.1. ",
    "wd": "As @ChristienGuy said, anyone meet this problem only in remote debugging, should check this comment https://github.com/facebook/react-native/issues/4470#issuecomment-302869193 , try to set the device time is exactly the same as your computer, or set the timeout more lager like 20 min (caution: set the timeout lager like this may have side effects, only use it when you know what it is ). ",
    "PaliwalSparsh": "Same here I am also getting the same error in \"redux-persist\": \"^5.10.0\" in react-native. Please can someone help.. ",
    "Nyadesune": "still happening with 5.10.0, it's a bit weird because it happened after few mins working without issues. ",
    "kevupton": "Delete the App\nReinstall the App\nWorks for me.. ",
    "adam-buckley": "For me I noticed that the console was spamming an endless amount of errors complaining that the my laptop and Android device times had diverged by more than 60 seconds.\nBecause I dual boot with Linux and Windows, the time on Windows is constantly incorrect. The app was debugging fine and this error seemed to have come out of nowhere. Updating my Windows clock to be the same as my Android device fixed this issue... not really sure why it was a problem in the first place though.\nI expect this won't be the solution for anyone at all but still posting just in case.\nRedux bits from my package-lock.json, using react-native 0.55.4:\njs\n\"redux\": {\n      \"version\": \"4.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/redux/-/redux-4.0.0.tgz\",\n      \"integrity\": \"sha512-NnnHF0h0WVE/hXyrB6OlX67LYRuaf/rJcbWvnHHEPCF/Xa/AZpwhs/20WyqzQae5x4SD2F9nPObgBh2rxAgLiA==\",\n      \"requires\": {\n        \"loose-envify\": \"^1.1.0\",\n        \"symbol-observable\": \"^1.2.0\"\n      }\n    },\n    \"redux-axios-middleware\": {\n      \"version\": \"4.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/redux-axios-middleware/-/redux-axios-middleware-4.0.0.tgz\",\n      \"integrity\": \"sha1-gZUcPZrc5vg++JL9FWhXHOvkozY=\"\n    },\n    \"redux-logger\": {\n      \"version\": \"3.0.6\",\n      \"resolved\": \"https://registry.npmjs.org/redux-logger/-/redux-logger-3.0.6.tgz\",\n      \"integrity\": \"sha1-91VZZvMJjzyIYExEnPC69XeCdL8=\",\n      \"requires\": {\n        \"deep-diff\": \"^0.3.5\"\n      }\n    },\n    \"redux-persist\": {\n      \"version\": \"5.10.0\",\n      \"resolved\": \"https://registry.npmjs.org/redux-persist/-/redux-persist-5.10.0.tgz\",\n      \"integrity\": \"sha512-sSJAzNq7zka3qVHKce1hbvqf0Vf5DuTVm7dr4GtsqQVOexnrvbV47RWFiPxQ8fscnyiuWyD2O92DOxPl0tGCRg==\"\n    }. ",
    "cmedinadeveloper": "Adding timeout time of 10 seconds will work if you are using Debugger\nconst persistConfig = {\n    timeout: 10000,\n    key: 'root',\n    storage,\n};\nTested on redux-persist: 5.10.0. ",
    "andrewzey": "So a good workaround for this is to use React Error Boundaries.\nIf there is an error thrown during the initial render that happens after rehydrate, then the timeout will be reached, and an additional rehydrate will fire that replaces all state with initial state. This results in catastrophic data loss, so doubtful that this is what you want. In a react-native environment, however, NOT doing this means your users will be stuck in a state where the app can't ever start again.\nBy wrapping the component tree within PersistGate in an error boundary, you can prevent this from occurring by catching and handling the error, and presenting a fallback UI. It's up to you what to do about the defective state tree that results in a crash on the initial render. In my case, I've elected to log the error and provide the user with a choice of submitting feedback and exiting the app (re-throwing an error) and waiting for help, or to clear their data and start from a fresh state. How this should be handled will be highly dependent on the particulars of your application.\nI'll provide a code snippet a bit later once I've finalized my own implementation of this, but that should help unblock folks.\n. @ssorallen I tend to agree with you for the vast majority of cases, but there are some cases where having a \"Reset state\" button would be fine. I often build little test sandboxes where I rely on error boundaries that have \"reset\" buttons in them. I agree that for most customer-facing scenarios, it doesn't make sense. TBD on whether my suggested \"Reset\" button will even make it in our app or not.\nBut the Error Boundary Solution does seem to work well, and it even presents an opportunity to show a feedback form where a user can describe what they were doing when the crash was encountered. That can really help debugging. To be fair though, that's true of Error Boundaries in general, and has nothing to do with redux-persist.\n\nWhat it shouldn't do is then rehydrate your store with initialState, which is the current functionality.\n\nI couldn't agree more.. @ssorallen touche!\nI don't think Error Boundaries could solve for timeouts that get hit when no exception is thrown. So it's probably best to both disable timeout altogether as you suggested (because of it's crazy default behavior that destroys all data) and do an error boundary (if handling render errors separately / outside of any global error handler is desired). \nHowever, I don't think react apps should wait to render for any kind of network call. That should always happen after initial render in componentDidMount, so I'm honestly having a little trouble imagining a scenario where the timeout could get exceeded because of network connectivity problems. Do you have an example in mind?\nEDIT Do you have a [real-world] example in mind (other than the stupid React Native Remote Debugger that loves to drag its feet - though that's another good reason to follow your suggestion of disabling the timeout). @alexandrecanuto See @ssorallen's workaround to disable the timeout functionality altogether: \nhttps://github.com/rt2zz/redux-persist/issues/717#issuecomment-437589374\nYou can also see my reply suggesting using a React Error Boundary which seems to stop the issue as well.. ",
    "Shanie1331": "@ssorallen , it works but what will be effected in store ?\nplease guide. ",
    "akiwarheit": "This may sound stupid but after uninstall, reinstalling, resetting metro, deleting artifacts (typescript), it still doesnt work on Android emulator.\nSolution was to wipe the emulator data and start all over again. Emulator is butter smooth after wiping data as well. I think its a timeout/sync issue; the emulator bogs down after running for awhile.. ",
    "rodrigofbm": "Same here:\nstore config:\n```js\nimport { applyMiddleware, createStore, compose } from 'redux';\nimport { offline } from '@redux-offline/redux-offline';\nimport offlineConfig from '@redux-offline/redux-offline/lib/defaults';\nimport thunk from 'redux-thunk';\nimport { persistStore, persistReducer } from 'redux-persist'\nimport storage from 'redux-persist/lib/storage'\nimport rootReducer from './Reducers';\nconst persistConfig = {\n  key: 'root',\n  storage,\n};\nconst persistedReducer = persistReducer(persistConfig, rootReducer)\nconst store = createStore(\n  persistedReducer,\n  {},\n  compose(\n    applyMiddleware(thunk),\n    offline(offlineConfig)\n  )\n);\nconst persistor = persistStore(store);\nexport { persistor, store };\n```\nThe problem happens the first time we open the app, if we gave a Reload it works and the error does not come back anymore. But I do not like the first time the user downloads the app it does not run at first.\n\"@redux-offline/redux-offline\": \"2.4.0\",\n\"react-redux\": \"^6.0.1\",  \n\"redux\": \"^4.0.1\",\n\"redux-persist\": \"^5.10.0\",\nI tried with version 5.6.12 but the error persisted.. ",
    "tonykawa": "No, i am writing website using react. [13:12:54] Finished 'server' compilation after 15634 ms\n[13:12:54] Launching server...\nredux-persist failed to create sync storage. falling back to memory storage.\n...\npersist/REHYDRATE: { type: 'persist/REHYDRATE',\n  payload: undefined,\n  err: undefined,\n  key: 'root' }\nThis is the error message when i yarn start my project.\n. I run in the latest chrome and tried localstorage & LOCALFORAGE, but also fail.\nI move PersistGate from client.js to App.js and create persist reducer to show all persist action.\nexport default function persist(state = null, action) {\nconsole.warn(action);\nswitch (action.type) {\ncase 'persist/REHYDRATE':\nreturn {\n...state,\npersistedState: action.payload,\n};\ndefault:\nreturn state;}}\nThis is the result.\nI can get the previous result (user), before execute the persist/REHYDRATE.\n\nAfter executed the persist/REHYDRATE, the result was set to null (user).. yes, the redux persist version in my project is 5.8.0. however, the result is same as 5.7.2.. ",
    "atav32": "@challme28 could you explain a little more? maybe a code snippet?. @tonykawa you can use ``` code in here ``` for multi-line code fragments. It gets rendered nicely, for example\n``` javascript\n// configureStore.js\nconst authPersistConfig = {\n  key: 'root',\n  storage: storageSession,\n};\nexport default function configureStore(initialState, helpersConfig) {\n  const helpers = createHelpers(helpersConfig);\n  const middleware = [thunk.withExtraArgument(helpers)];\n  let enhancer;\n  if (DEV) {\n    middleware.push(createLogger());\n    let devToolsExtension = f => f;\n    if (process.env.BROWSER && window.devToolsExtension) {\n      devToolsExtension = window.devToolsExtension();\n    }\n    enhancer = compose(applyMiddleware(...middleware), devToolsExtension);\n  } else {\n    enhancer = applyMiddleware(...middleware);\n  }\n  const rootReducer = createRootReducer();\n  const persistedReducer = persistReducer(authPersistConfig, rootReducer);\n  const store = createStore(persistedReducer, initialState, enhancer);\n  if (DEV && module.hot) {\n    module.hot.accept('../reducers', () =>\n      // if you change reducers back to normal\n      rootReducer.store.replaceReducer(require('../reducers').default()),\n    );\n  }\n  const persistor = persistStore(store);\n  return {\n    store,\n    persistor\n  };\n}\n```\nMarkdown:\n\n. @rt2zz is dispatching REHYDRATE twice a bug?. only happening when the storage is empty, so there's nothing to hydrate from?\n@rt2zz tried the different storage engines (localStorage, sessionStorage, localForage), but all of them are showing the same error:\n\n. Temporary workaround is to check if action.payload is defined\n``` javascript\nexport const app = (state = appDefaultState, action) => {\n  switch (action.type) {\n    case REHYDRATE:\n      if (action.payload) { // <- I guess this works, but it's kinda ugly\n        return {\n          ...state,\n          user: action.payload.user,\n        };\n      } else {\n        return state;\n      }\n...\n\n``. @mattmcdonald-uk I just ended up doing this, https://egghead.io/lessons/javascript-redux-persisting-the-state-to-the-local-storage. @anhphuongbn94 what do your app and reducer files look like? might be importing thestoreandpersistor` wrong?. ",
    "mattmcdonald-uk": "I have the same issue. \nUsing version 5.9.1 I get an undefined payload if there's nothing in localstorage (same with localForage). . ",
    "alexmngn": "I've only persisted a single reducer using persistReducer as I only need to cache a single reducer. \nI don't have any throttle value. My store isn't very big and looks like this:\n```\n  const appReducer = combineReducers({\n    reducer1: myReducer1,\n    reducer2: myReducer2,\n    reducer3: persistReducer(\n      { storage, key: 'reducer3', transforms: [persistFilter] },\n      myReducer3,\n    ),\n    reducer4: myReducer4,\n  });\nconst store = createStore(appReducer, compose(...enhancers));\n  const persistor = persistStore(store);\n```\nIn the enhancers I mostly have dev tools and saga middleware.. We're actually having the exact same problem in my company. We are just using AsyncStorage though.  @jesperlndk did you find a solution? Or a different way to store the data?\nI've also noticed sometimes we get the following error:\n```\n{\n  err: Error: redux-persist: persist timed out for persist key \"myKey\" at blob:http://localhost:8081/d0182199-b2a0-4806-ad16-47af460661d8:18512:45,\n  key: \"myKey\"\n  payload: undefined\n  type: \"persist/REHYDRATE\"\n}. ",
    "stanislav-grin": "@alexmngn did you resolve this issue?\nI have the same problem. It takes ~10s before redux-persist stored in the storage. I have throttle set to 1000ms, but I noticed that if I reduce this value, redux-persist writes data much faster, but I don't want to have such small throttle value due to performance issues.. ",
    "alexey-m-ukolov": "I also have this issue. I'm not setting throttle in the config, so redux-persist uses default value of 0.\nOn my emulator I consistently see a 3 seconds delay between update and processNextKey + stagedWrite. On real devices in production build delay is also present, but it's hard to quantify it.\n\nI have about a dozen persisted reducers with not much data that gets saved to storage, so I don't think it's because of some heavy load.\nI don't see where this delay may come from in the redux-persist code though. Maybe it's more related to how setInterval works in react-native itself? I've tried setting throttle to 10 ms (maybe setInterval and 0 delay in react-native don't play nice with each other), but nothing changed.. ",
    "ozzyogkush": "Just a note but I do not believe this is limited to AsyncStorage. Trying to use a throttle of any value on a regular web app with localStorage causes updated state to be ignored in persistence, even after manually calling persistor.flush().. ",
    "peteroid": "Just a friendly reminder that I realized that the state hasn't changed as I was doing something like:\nACTION: {\n  const { someObject } = state\n  someObject.key = 'updated'\n  return {\n    someObject\n  }\n}\nAs the persistReducer would only do a shallow compare, the above case would be missed out for persistence. I was too stupid to spend many days thinking this is the problem with the library. But yeah, double check the code.. ",
    "j33n": "I actually switched to using redux-persist/lib/storage after seeing issue #488 but the output was the same.. ",
    "zacharygolba": "No problem! Great work with this library. \ud83d\ude03 \nFrom the looks of this compatibility table self is supported in all major browsers (including IE11).\nIf a case comes up where compatibility is an issue for a user, they could naively polyfill self with something along these lines:\njavascript\n(function (ctx) {\n  if (!('self' in ctx)) {\n    ctx.self = ctx;\n  }\n})(this);. That makes sense. Happy to help!. ",
    "tastycode": "\nthe issue is the lessons reducer mutating state, so the persistor never knows to update it.\n\nI'm so confused. I thought the way redux-persist worked was to apply an enhancer over the middleware so that redux-persist always knows when anything changes? Don't all reducers mutate state? Is there something we need to do to let redux-persist know that it needs to remember to persist the state?\n. ",
    "whathejoe": "@tastycode As for\n\nDon't all reducers mutate state?\n\nThey don't, they (should) return new object instances.\nSee: https://github.com/reactjs/redux/issues/585#issuecomment-132865158\nWhich is what redux uses for pinging changes in the store. And maybe what redux-persist uses to determine incoming state, too.\nIt would be enlightening if that really is the case @rt2zz . ",
    "nighttiger1990": "i have same issue.\nMy \"countReducer\" is saved and loaded but my \"authReducer\" is not working\n```javascript\n//countReducers\nimport TYPES from '../constants'\nconst initialState = 0\nconst countReducers = (state = initialState, action) => {\n    switch (action.type) {\n        case TYPES.INCREMENT:\n            return ++state\n        case TYPES.DECREMENT:\n            return --state\n        default:\n            return state\n    }\n}\nexport default countReducers\n```\n```javascript\n//authReducers\nimport TYPES from '../constants'\nconst initialState = { isCheckingAuth: false, isCheckedAuth: false, signedInfo: null, err: null }\nconst initialActions = { type: \"\", payload: null }\nexport default function (state = initialState, action = initialActions) {\n    switch (action.type) {\n        case TYPES.FETCH_AUTH: \n            return { ...state, isCheckingAuth: true }\n        case TYPES.FETCH_AUTH_SUCCESS:\n            return { ...state, isCheckingAuth: false, isCheckedAuth: true, signedInfo: action.payload }\n        case TYPES.FETCH_AUTH_FAIL:\n            return { ...state, isCheckingAuth: false, isCheckedAuth: true, err: action.payload }\n        default:\n            return state\n    }\n}\n```\n```javascript\n//rootReducers\nimport { combineReducers } from 'redux'\nimport authReducers from './auth'\nimport countReducers from './count';\nconst rootReducers = combineReducers({\n    auth: authReducers,\n    count: countReducers\n})\nexport default rootReducers\n```\n```javascript\n//store.js\nimport { AsyncStorage } from 'react-native'\nimport { createStore, applyMiddleware, compose } from 'redux'\nimport logger, { createLogger } from 'redux-logger'\nimport rootReducers from '../reducers'\nimport { persistStore, persistReducer } from 'redux-persist'\nconst middlewares = []\nconsole.log(\"DEV\", DEV)\nif (DEV) {\n    middlewares.push(logger)\n}\nconst persistConfig = {\n    key: 'root',\n    storage: AsyncStorage,\n}\nconst persistReducers = persistReducer({...persistConfig}, rootReducers)\nconst composeEnhancers = typeof window !== 'undefined' && window.REDUX_DEVTOOLS_EXTENSION_COMPOSE\n    ? window.REDUX_DEVTOOLS_EXTENSION_COMPOSE\n    : compose\nexport default function (initialState) {\n    return createStore(persistReducers, initialState, composeEnhancers(applyMiddleware(...middlewares)))\n}\n```\nMy last state:\n\nMy state after reloading:\n\n. Same issue.\nWhen i'm in debug mode, it show \nconsole.error: \"redux-persist: rehydrate for \"root\" called after timeout.\", {....}, undefined. ",
    "zi6xuan": "persistReducers replace to persistCombineReducers it's work for me. ",
    "serhiipalash": "\nthat is not possible\n\nOk, I understand. \nIn my case I have a very big reducer imported from react-redux-firebase package and it has data child with local copy of database collections. I just don't want to persist all data as it is very big.\nThanks anyway.. ",
    "pdoggi": "@gusgard I am getting this error with redux-persist: ^5.9.1 and react-native: 0.55.4. Were you able to fix the error?. Thanks @gusgard! Turns out for me, I am using redux-offline and it rolls with a copy of redux-persist ^4.5.0, and I still had the error. I had to patched this line with a try/catch wrapper in autoRehydrate.js. ",
    "gusgard": "We switch to version 4, is more a workaround than a fix.. ",
    "xbrad831x": "I don't even have that modules: [] line in my webpack config file. Only extensions. ",
    "HawiCaesar": "I have the same problem. I don't have modules: [] but I get the Uncaught TypeError: Super expression ... error when I simply import PersistGate. What could be the problem ?. It seems when I remove the import { PersistGate } from 'redux-persist/integration/react' my code still works and the hydration works as well. Its looks like PersistGate could be the problem.\nI imported the store without PersistGate.\njavascript\nconst { store } = storeFunctionality();\nReactDOM.render(\n  <Provider store={store}>\n      <App />\n  </Provider>,\n  document.getElementById('app')\n);\nmy store\n```javascript\nimport { persistStore, persistReducer } from 'redux-persist';\nimport storage from 'redux-persist/lib/storage';\nimport allReducers from './reducers/index';\nconst persistConfig = {\n  key: 'root',\n  storage\n};\nconst middleware = applyMiddleware(promise, thunk, createLogger());\nconst persistedReducer = persistReducer(persistConfig, allReducers);\nexport default () => {\n  let store = createStore(persistedReducer, middleware);\n  let persistor = persistStore(store);\n  return { store, persistor };\n};\n```. ",
    "lesansley": "I am also experiencing this error. Please could you advise.. I had to change to use redux-saga.. ",
    "Li357": "See https://github.com/rt2zz/redux-persist/issues/796. To anyone who is looking for a fix, the problem is most likely your React version. PersistGate uses React.PureComponent, only available in React v15.3+. See https://stackoverflow.com/questions/51317610/can-not-import-persistgate-from-redux-persist-super-expression-must-either-be/51317754#51317754\nUpgrade your React to v15.3+ to fix the issue.. ",
    "martakielpinska": "I'm having similar issue\n. To anyone who might be facing similiar issues it was cause due to the use of timer in my app. The debugger drifted away in time and was causing this issue. After a restart all goes back to normal. . ",
    "diegolaciar": "Thanks @thenewt15, but already changed that, the error persist. Write a component or null don' t fix this issue.. Also note that the Uncaught TypeError expect a subscribe function, as the \".subscribe(listener)\" that redux Store have. https://redux.js.org/api-reference/store \nPersistor do not have that function.. ",
    "fntneves": "I am experiencing the same issue as @diegolaciar.. ",
    "Kannnnng": "Do you have a plan to support immutable in V5? Thanks to your awesome work : ) @rt2zz . ",
    "SrujithPoondla": "I am also experiencing the same issue with redux-persist@5.10.0. ",
    "dgaitsgo": "idem redux-persist@5.10.0. ",
    "TySol": "same - redux-persist@5.10.0\n. ",
    "heresmyinfo": "+1  redux-persist@5.10.0. ",
    "whydna": "same issue 5.10. ",
    "sebasegura97": "same issue redux-persist@5.10.0. I recently fixed the same problem. I was wrong exporting my store and my persistor, like @anhphuongbn94 in his store/index.js, i used \"export default {store, persistor}\" instead just \"export {store, persistor}\". ",
    "heygrady": "That's fair enough. Adding delay like that will work and will avoid you having to add extra code into this library. I was seeing if there was a way to adopt a common loading interface that I've encountered with other libraries.\nFWIW, the code for actually managing the two timeouts isn't very much to add. I notice that a major difference between redux-persist and react-loadable is that you ask for a <Loading /> (a rendered component) while react-loadable asks for Loading (a component reference). With your model I could create a simple withTimers HOC and pass a wrapped loading component into redux-persist to accomplish the same thing.. ",
    "tomelsner": "@sadi304 How did you solve the problem? I'm facing the same issue..... Thanks for the quick reply, you where right about the objects, all working now\n. @anhphuongbn94 https://github.com/anhphuongbn94 my problem was in the\nimport, your store file looks fine\nOn 1 March 2018 at 21:54, Brian Zhang notifications@github.com wrote:\n\n@anhphuongbn94 https://github.com/anhphuongbn94 what do your app and\nreducer files look like? might be importing the store and persistor wrong?\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/rt2zz/redux-persist/issues/734#issuecomment-369744279,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AKv12yXs43GMnDSCeCBuhLbWmr9OBdVqks5taG4qgaJpZM4SR1eD\n.\n. import {store, persistor} from 'your-store-module' didn't work for me,\nI used import Store from 'your-store-module'\nand then used: Store.store and Store.persistor\n\nOn 2 March 2018 at 18:17, Zack Story notifications@github.com wrote:\n\n@anhphuongbn94 https://github.com/anhphuongbn94 import {store,\npersistor} from 'your-store-module' is definitely the right import\nsyntax. I would double check your export statements and paths.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/rt2zz/redux-persist/issues/734#issuecomment-370005918,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AKv129tNSgHK_wlroTaPyW3A6648FV27ks5taYzUgaJpZM4SR1eD\n.\n. \n",
    "anhphuongbn94": "I have the same issue, please support me resolve issue,\nThis is my store.js file: \nconst persistConfig = {\n    key: 'root',\n    storage,\n};\nconst persistedReducer = persistReducer(persistConfig, rootReducer);\nconst store = createStore(\n    persistedReducer,\n    applyMiddleware(thunkMiddleware, axiosMiddleware(baseUrl), logger),\n);\nconst persistor = persistStore(store);\nexport default { store, persistor };. Thanks and sorry reply late, This is my file config redux: \n+ store/index.js: \n\n+ app.js: \n\n+ reducers/index.js:\n\n. you mean: import {store, persistor} from './redux/store';\ni tried but store is undefined . @rt2zz thank for your help\n@tomelsner I changed the code as you said and resolve issue but i don't understand why resolve issue, you can explain me.\nThanks.. I understand, thank for your help \ud83d\udc4d . @jpainam  you need change: \nimport Store from \"./store/configureStore\"; \nuse  Store.store, Store.persistor \nyou can log store for better understanding.. ",
    "jpainam": "@anhphuongbn94 pls can u show me how you did? Have the same problem; but not working\nin configureStore I have \n.....\nlet store = createStore(persistedReducer);\nlet persistor = persistStore(store);\nexport default { store, persistor };\nand i call it in app.js\nimport { store, persistor } from \"./store/configureStore\";\n    <Provider store={store}>\n          <PersistGate loading={null} persistor={store.persistor}>. ",
    "offaxis": "+1\nSame error .... ",
    "jonascript": "+1 Seeing this error as well on web.. ",
    "digitalillusion": "+1 but I'd rather like to see redux-persist use a library like JSOG in order to allow to persist and restore circular objects\nIt turns out this can be done using a transform:\n```\nimport { createTransform } from 'redux-persist';\nimport JSOG from 'jsog'\nexport const JSOGTransform = createTransform(\n    (inboundState, key) => JSOG.encode(inboundState),\n    (outboundState, key) => JSOG.decode(outboundState),\n)\nconst persistConfig = {\n    key: 'myapp',\n    storage : storage,\n    transforms: [JSOGTransform]\n}\n```\n. ",
    "mitchpatterson": "Not sure the specifics of the issue but switching to a whitelist opposed to a blacklist resolved it.. ",
    "dlahish": "Try Ramda's dissoc/dissocPath instead. ",
    "tindn": "+1\nI'm having the same issue. Is there something I'm missing, like an API call to manually persist?. ",
    "alanwielguszewski": "ok i managed to fix it with :\nif (this.unsubscribe)\n      this.unsubscribe()\n    if (TRON_ENABLED) {\n      this.unsubscribe = this.props.store.subscribe(() =>\n        console.tron.display({\n          name: 'STORE',\n          value: this.props.store.getState(),\n          important: true\n        })\n      )\n    }. ",
    "SephiL1nk": "Nvm, it was due to an error in the persist config, the reducers were not using the correct function\nconst persistedReducer = persistCombineReducers(persistConfig, reducer) is the good answer here\nas well as export without the usage of combineReducers the reducers : \nexport default {\n  user: userReducer,\n  groups: groupReducer\n}. ",
    "leggomuhgreggo": "@Ashoat encountering the same issue. Can you elaborate on the work around you mentioned? Thanks!. ",
    "m-oscartong": "@Ashoat the \"how I do it\" link is 404. I believe you've moved the file to /lib/utils/redux-logger.js. ",
    "BaggersIO": "Same problem here .... ",
    "vanyathetank": "Well, same problem, I will have to get rid of Immer then I guess. ",
    "ColeMorton": "It would be great if we could support Immer in the future.. ",
    "mweststrate": "Simple work around could be:\nimport { setAutoFreeze } from \"immer\"\nsetAutoFreeze(false). ",
    "lukasikora": "@hockeylagu taking into account current version of persistStore, I mean states equality check:\nif (newState === restState) return state\nYour solution provide Immer support without errors and setAutoFreeze(false). Maybe it's not optimal solution but at least we modify already modified state without using Immer inside library. \n// run base reducer:\n    // is state modified ? return original : return updated\n    let newState = baseReducer(restState, action)\n    if (newState === restState) return state\n    else {\n      newState = {\n        ...newState,\n        _persist: _persist\n      }\n      return conditionalUpdate(newState)\n    }. ",
    "nguquen": "It's a bug, i guess? persistReducer inject _persist key to the state. When you return empty object, you will remove _persist key and break redux-persist functions. There're some workaround, like:\ncase 'CLEAR_USER_INFO': {\n      return {\n       _persist: state._persist\n     };\n    }\nOr if you want to clear all storage, can call persistor.persist() & persistor.purge() in your action after dispatched CLEAR_USER_INFO:\n+    // must call persist() first to construct _persist state\n+    getPersistor().persist()\n+    await getPersistor().purge()\nNot sure if re-call persist() here will lead to some unexpected bugs or not?. ",
    "pdimitratos": "My team encountered an issue similar to this when trying to clear specific keys from an object. Looking into the redux-persist code, we found that the library identifies changes on a per-key basis, and seems to schedule keys for updates only when those keys have a final value other than undefined: https://github.com/rt2zz/redux-persist/blob/master/src/createPersistoid.js#L57\nWe ended up setting the values to null (a change which does get persisted), but we don't know a good way to remove the keys from persistence entirely in a single-step operation. It would be nice to have some guidance on how that should be done (if it's possible).\n. ",
    "strand": "@pdimitratos it sounds like the API is under-documented. It makes sense that there is a special case for deleting keys from the persisted storage, and I think this issue might be something which could be resolved (for now) with a documentation change indicating the current behavior.\n@rt2zz would you accept a PR which improves the documentation indicating the preferred manner of deleting keys from the persisted storage?\n@pdimitratos did our team use a persistReducer in a way that is similar to @TungAng's approach? Scanning over the API, I would have guessed that the correct API to document would be persistStore, but I don't have a strong understanding of reducers. I think I can draft a documentation PR if you can link me to our code which workaround this small piece of undocumented API implementation.. @rt2zz Would you be interested in a doc change or a code change to resolve this issue?. ",
    "DimitryDushkin": "I have the very same problem with persisting user-related info. I did something like:\ncase 'CLEAR_USER_INFO': {\n      return {\n       _persist: state._persist\n     };\n    }\nfrom @nguquen  response, but with no luck.\nI've fixed issue by reseting state to object where just one field is present and it's null, like:\ncase FEED_RESERVED_FLUSH: {\n            return {ttl: 0};\n        }. ",
    "fernandes": "I had the same behavior here, and when I disable redux-dev-tools, everything goes ok (checked with debug: true on redux-persist). ",
    "nishtacular": "@ejbp were you able to resolve this issue? I'm encountering the same issue.. ",
    "ejbp": "@nishtacular the problem was what @tommyalvarez described. After I corrected it, it started to work.\nHere is my store.js file. I hope it helps:\n```\nimport { createStore, applyMiddleware, compose } from 'redux';\nimport { persistStore, persistCombineReducers } from 'redux-persist'\nimport storage from 'redux-persist/lib/storage' // defaults to localStorage for web and AsyncStorage for react-native\nimport { connectRouter, routerMiddleware } from 'connected-react-router'\nimport middlewares from \"./middlewares\";\nimport reducers from \"./reducers\";\nimport actions from \"./actions\";\nconst composeEnhancers =\n  (window && window.REDUX_DEVTOOLS_EXTENSION_COMPOSE) || compose;\nconst persistConfig = {\n  key: 'root',\n  storage,\n  blacklist: [\"ui\", \"router\"]\n}\nexport default ( {history, extraReducers={}, extraMiddlewares=[] } ) => {\nconst rootReducer = {\n    ...reducers,\n    ...extraReducers\n  };\nconst historyMiddleware = routerMiddleware(history); // Build the middleware for intercepting and dispatching navigation actions\n  const persistCombinedReducers = persistCombineReducers(persistConfig, rootReducer);\nconst store = createStore(\n    connectRouter(history)(persistCombinedReducers),\n    composeEnhancers(\n      applyMiddleware(\n        ...middlewares,\n        historyMiddleware,\n        ...extraMiddlewares\n      )\n    )\n  );\nconst persistor = persistStore(store);\nreturn {store, persistor};\n};\n```\n. ",
    "dawnmist": "The same issue occurs with the definition of persistReducer. The reducer function returned is missing the | undefined for the state, so redux 4.0 rejects the persistedReducer when you try to create the store from it.\nSince you already have a pull request for updating this bit, do you want to add the fix for the persistReducer function too?\njavascript\n    export function persistReducer<S, A>(config: PersistConfig, baseReducer: BaseReducer<S, A>): (s: S | undefined, a: A) => S & PersistPartial;. I think this should probably be (state: S | undefined, action: A) => S in order to match up with the redux 4.0 types. After all, the reducer is initialized by passing undefined into the reducer function.. ",
    "kogai": "Due to it does not seems to be reviewed, I'll close the PR.. ",
    "troylutton": "Here is a complete example. Works pretty well\n```\nclass MyApp extends React.Component {\nconstructor(props) {\n    super(props)\n\n    this.state = {\n        splashFinished: false\n    }\n}\n\ncomponentDidMount() {\n\n    // show the splash for 2 seconds\n    setTimeout(() => {\n        this.setState({\n            splashFinished: true\n        })\n    }, 2000)\n\n}\n\nrender() {\n    return (\n        <Provider store={store}>\n            <PersistGate\n                //loading={<SplashLoader />}\n                persistor={persistor}                   \n            >\n                {(bootstrapped) => {\n\n                    if (bootstrapped && this.state.splashFinished) {\n\n                        return (<AppStack />)                            \n                    }\n                    else {\n                        return <SplashLoader />\n                    }\n                }}\n\n            </PersistGate>\n        </Provider>);\n}\n\n}\n```. ",
    "ramosquito5": "So sorry, found my mistake, it was that i forgot to place () after promiseMiddleware when adding to the middleware. ",
    "antoniomelendez": "real problem was in configureStore.js had to export const store and export const persistor. instead of export default { store, persistor }. ",
    "ltankey": "Argh I'm having the opposite - works fine on iOS simulator but not on a connected Android device! Hopefully it's a related issue and someone can respond.... I managed to get this working, but not by doing anything special. It turns out that while in debug mode in expo, it fails to run the rehydrate action and therefore any subsequent persist resets the state of the app.\nYou can fix this by turning off debug and reloading the app. Things will then go back to working normally. I find this only happens if I try to reload the app while still in debug mode. . ",
    "sarathvad1811": "yeah :(\n. ",
    "jamsch": "Currently am using redux-persist@5.9.1 in a large production app right now on Android and it's great, no problems besides the RN remote debugging AsyncStorage bug. About to release an iOS app however testing on a real device has had it stuck at the persist gate a few times while testing the app. When it gets stuck the only way to fix it is to reinstall because subsequent launches wouldn't persist either. I just can't pinpoint why it would not persist either and am hesitant to release an app utilising this library right now.\nIt doesn't seem to matter whether you're using the default RN filesystem import or redux-persist-filesystem-storage. It also doesn't seem to matter what kind of transforms your app is doing when reading/writing data. The persist timeout config doesn't seem to have any effect either.. Type adb shell date && date to figure out time discrepancies between the device and the computer. If the device is an emulator, reboot the emulator by holding the power button and re-opening the emulator. \nAsyncStorage.get() often never resolves, especially after the first time you reload. This issue specifically has been ongoing for React Native -- https://github.com/facebook/react-native/issues/14101 https://github.com/facebook/react-native/issues/18372 https://github.com/facebook/react-native/issues/12830\nOne thing you may want to try is changing the storage engine to redux-persist-filesystem-storage which may fix this issue. . In my experience it only occurs in remote debugging mode. I have quite a large production app running with the latest version of redux-persist using AsyncStorage on Android and there's been no problems so far besides not being able to effectively debug it while using the remote debugger.. We can just leave the package maintainer to decide ;). ",
    "evertonco": "Little late, but, I noticed redux persist REHYDRATE action was executing before main component be mounted. So, just checking prop _persist.rehydrated on componentWillMount method of main component was enough to me.. App.js\nexport default class App extends React.Component {\n  render() {\n    return (\n      <ApolloProvider client={client} store={store}>\n        <AppNavigator {...this.props} />\n      </ApolloProvider>\n    );\n  }\n}\nnavigator.js\nexport const AppNavigator = createSwitchNavigator(\n  {\n    AppLoading,\n    App,\n    Auth,\n  },\n);\napp-loading.js\n```\nclass AppLoading extends Component {\nstoreReady = false;\n  // other variable definitions\nstate = {};\ncomponentWillMount() {\nconst { _persist } = this.props;\n\n// set flag (expected be true)\nthis.storeReady = _persist.rehydrated;\n...\n\n}\ncomponentWillReceiveProps({ _persist }) {\n// check for REHYDRATE event (On IOS, this event is not fired. On android, works correctly)\nif (!this.props._persist.rehydrated && _persist.rehydrated) {\n\n  this.storeReady = true;\n  ...\n}\n\n}\n// I'm using Expo. So, I check if this.storeReady flag is true to allow app to go to next screen:\n  handleFinishLoading = () => {\n    if(this.storeReady) {\n      // logic to check if user is authenticated or other stuff and redirect to correct screen\n      this.props.navigation.navigate('NextScreen');\n    } else {\n       // redirect to error screen?!\n    }\n  }\nrender() {\n    return (\n      \n    );\n  }\n}\n// redux mapping to get access to _persist prop\nconst mapStateToProps = ({ _persist }) => ({ _persist });\nexport default connect(mapStateToProps)(AppLoading);\n```\n. whatever... persistCombineReducers is a combination of redux combineReducers and persistReducer:\npersistCombineReducers source code\nI use:\n```\nimport { auth, user } from './reducers';\nconst persistConfig = {\n  key: 'app',\n  storage,\n};\nconst combinedReducers = combineReducers({ auth, user });\nconst persistedReducers = persistReducer(persistConfig, combinedReducers);\nconst store = createStore(persistedReducers);\nexport const persistor = persistStore(store);\nexport default store;\n```\n. ",
    "yasso1am": "\nLittle late, but, I noticed redux persist REHYDRATE action was executing before main component be mounted. So, just checking prop _persist.rehydrated on componentWillMount method of main component was enough to me.\n\nCould you elaborate on the function you wrote to check this, and where you implemented it?. ",
    "lusan": "@rt2zz can you please review it. ",
    "elzup": "It's not guaranteed.\n\njs\n  const persistor = persistStore(store, {}, () => {\n    console.log('persistStore callback')\n  }). I do this\nconst persistedReducer = persistReducer(persistConfig, reducer)\n  const store = createStore(persistedReducer, composer)\n  const persistor = persistStore(store, {}, () => {\n    const state = store.getState()\n  }). ",
    "Bessonov": "tested. it work.. ",
    "williamliangwl": "After doing some tests and check, I found the following:\n\nthe purge() seems really not clearing any data, even at the storage itself.\n\nI am using AsyncStorage and the way I check the data is following the guide here \nSo after a crash happens, I am sure that the purge() is called as I log something in the callback of it ( I am trying to purge 3 keys, it returns 3 nulls in callback ). \nHowever, when I check the AsyncStorage, the content of the storage is still the same. If I try to execute AsyncStorage.clear(), then all keys are deleted and the storage is indeed empty.\nIs it a problem of using the AsyncStorage ? I haven't test with other storage type and only tested in Android device. I finally found out the problem!\nTo make things simple, let's make some assumptions:\n\nThe redux state has several keys: auth and nav\nThere exists a component with its componentWillUnmount is to dispatch change on the nav state\nThere also exists a global error handler which will purge all keys in the AsyncStorage\n\nWhen an error happens, the order of call is:\n\ncomponentWillUnmount\nglobal error handler\n\nSince both calls above will trigger promise / async actions, we cannot make sure who will finish first. However, most of the time, the purge will finish first, while the nav state change second.\nThis scenario will lead to:\n\nBefore error -> The redux state is { auth: \"something\", nav: \"something\" }. Same value exists in the Async storage\nOn error -> the purge finishes first -> The redux state remains the same as no 1, but Async storage is empty\nOn error -> the nav state change finishes -> The redux state becomes { auth: \"something\", nav: \"\" }. Then this change will write to the AsyncStorage again.\n\nThat's why it creates \"illusion\" that the purge is not working ( for auth key ). \nTo handle this situation, just need to reset the redux state in the global error handler.\nSorry for the confusion in this issue, this can be closed now :). @ronnierios to reset all my redux states, I simply use the redux-reset here.\nActually I am still new in React Native and Redux, so I don't really understand what the following code does\n```\nconst rootReducer = (state, action) => {\n  console.log(\"STATE\", state)\n  if (action.type === 'RESET') {\n    state = undefined\n  }\nreturn appReducer(state, action)\n}\n```\nHowever, I think if we just want to reset all redux states to its initial state, we can simply use the redux-reset. \nIf we only want to reset some of them, then may be it's better to implement the reset in each reducers, by \"listening\" to the same action.type. Another way to do this, you can also use the redux-reset, but on those reducers that don't want to be reset, just return the current state.. ",
    "ronnierios": "@williamliangwl I have the same problem. I try to reset my state from a custom action, but only works for some reducers.\n```\nconst appReducer = combineReducers({\n  plans,\n  contracts,\n  user,\n  appState\n})\nconst rootReducer = (state, action) => {\n  console.log(\"STATE\", state)\n  if (action.type === 'RESET') {\n    state = undefined\n  }\nreturn appReducer(state, action)\n}\nexport default rootReducer\n```\nI also tried to reset the state passing the default values, without exit\n```\n//Action\nexport const clearPlans = function () {\n        return {\n            type: CLEAR_PLANS,\n            payload: []\n        }\n}\n//Reducer\nconst initialState = {\n  plans: [],\n  persistExpiresAt: DATA_EXPIRES_AT,\n};\nconst plans = (state = initialState, action) => {\n    switch(action.type) {\n        case FETCH_PLANS:\n            console.log(action.payload)\n            return {...state,\n              plans: action.payload\n            }\n        case CLEAR_PLANS:\n            console.log(action.payload)\n            return {...state,\n              plans: action.payload\n            }\n        default:\n            return state\n    }\n}\n```\nHow did you handle the redux state? Thank you in advance. ",
    "andreawyss": "More of a documentation issue.\nI was assuming that the second argument of the 'migrate' callback was the 'persistedVersion' but it is actually the 'currentVersion'.\nSuggestion: pass the 'persistedVersion' to the 'migrate' callback as the third argument so that we don't have to write code that reads from the private state slice '_persist'. This is brittle in case a future release will change the name of this private state slice.\nThis is my current solution to this issue:\nmigrate: (persistedState, currentVersion) => {\n  const persistedVersion =\n    persistedState &&\n    persistedState._persist &&\n    persistedState._persist.version\n      ? persistedState._persist.version\n      : -1;\n  if (persistedVersion === -1) {\n    console.log('no previous version with given key');\n    return Promise.resolve(undefined);\n  }\n  if (persistedVersion === currentVersion) {\n    console.log('same version; use persistedState');\n    return Promise.resolve(persistedState);\n  }\n  console.log(\n    'version changed; migrating from:',\n    persistedVersion,\n    'to:',\n    currentVersion,\n    persistedState\n  );\n  return Promise.resolve({});\n},\n\n. ",
    "Aleksandern": "https://github.com/rt2zz/redux-persist/blob/master/docs/MigrationGuide-v5.md. ",
    "jamessessford": "Hey @AliaMYH \nI'm using this at the moment although only for one app! From what I took from the documentation and reading the ReactNative Async Storage docs, the store is simply one large key value store shared by all your React Native apps.\nI haven't gone through the source code but have you tried setting a different root key in the config for each app, perhaps namespacing it to that app as I think this will provide the separation that you're looking for!\nI would be wary of launching the purge command (or clear from the default AsyncStorage) as this looks like it would clear everything regardless of what app launched the command.\nHave a great day. ",
    "osdiab": "Anything holding this up?. @dawnmist requesting you since you were on the previous pull.. Closes https://github.com/rt2zz/redux-persist/issues/753.. Tested works in my code.. Cool, what\u2019s the process for getting things merged and deployed? I\u2019d love to make use of this code.. @rt2zz . ",
    "jMoulis": "Ok I checked, I have the error when I import PresistGate from 'redux-persist/es/integration/react'. ",
    "ManuelJF": "@ChrisJVoss you're prices reducer persisted?. ",
    "ChrisJVoss": "@ManuelJF No, I blacklisted prices. My understanding is that 'auth', 'search', 'setPrice', and 'catalog' should all be persisted. However, only 'auth' is persisted.. @tommyalvarez persistCombineReducers isn't listed on the API guide, but I'll give it a shot. https://github.com/rt2zz/redux-persist/blob/master/docs/api.md\nI'm also passing reducers to persistReducers() which is the result of calling redux's combineReducers() on all my reducers.. ",
    "kopax": "@Noitidart Does it work well on react-native ? (iOS/Android) I can see many open issues regarding native, I am just not sure if it is that superb.\nThanks. ",
    "sinkovsky": "Looks like I'm getting the same error, but it nothing is stored in the store.\nWere you able to solve it?. Upon further investigation looks like state is persisted only after timeout action is fired.\nThen persisted state is updated with changes in redux, but after page reload it gets reset to initialState after timeout again. \nUsing react-boilerplate with switched off injected reducers and sagas and root Reducer state converted to simple object with Immutable  in branches.\nSetup is the same as in the documentation.\nCould you please advise, @rt2zz ?\n. ",
    "lindslev": "Update from me @sinkovsky - I noticed it's the size of my restoredState that I pass as a second argument to createStoreWithMiddleware that affects whether or not this timeout error is thrown. . ",
    "MaxInMoon": "I re-installed the app and the problem did not came back yet (for how long?). ",
    "damathryx": "I'm having the same problem in Android. @bluenex i'm using redux-logger. ",
    "xiongcaichang": "I'm having the same problem on Android too. ",
    "luiscl32": "i'm having the same problem in android. ",
    "ozalexo": "setTimeout is started in persistReducer method, but I did not found clearTimeout...\nHere: https://github.com/rt2zz/redux-persist/commit/436050044d5ea6483d084c67820cd3fd9466eb38#diff-78c77d9b1c28b6777a1c3ec40164bb64R83\nSo, I just disabled timeout in my configs\nconst persistConfig = {\n  key: 'keyOfStore',\n  storage: storage,\n  // There is an issue in the source code of redux-persist (default setTimeout does not cleaning)\n  timeout: null,\n}\nconst appReducer = combineReducers({\n  ...otherReducers,\n  keyOfStore: persistReducer(persistConfig, keyOfStoreRedfucer),\n}). ",
    "gorokhovich": "We have the same issue with React Native and AsyncStorage and setting timeout to null helps.\nThanks @ozalexo. ",
    "karimone": "Here a screenshot of the logger. I'm sure something is wrong in the configuration, what can make the hydrate running after the `persist? Do I miss something in the config?\n\n. Was my fault. I had some calls running outside the PersistGate. Bad design. Mea culpa.. ",
    "kevinho": "removing calls outsite persisitgate will make it work? rehydrte before persist?. ",
    "tovesson": "The issue was that I mutated the state in the action. ",
    "samscha": "I know this is a bit late, but for people in the future having similar problems..\nI am assuming what's happening is (this was the case for me at least) is upon refresh, redux-logger shows the correct payload to set during rehydrate, but the next state in logger is showing the reducer's initial state. I noticed this was only happening when I had nested objects (for example, when I was trying to persist strings, it worked fine.\nThe solution (which is now in the docs, maybe not at the time of the original post) is to use nested persists. I noticed in OP's code:\njavascript\nconst persistedReducer = persistReducer(persistConfig, combineReducers({\n    ...reducers,\n    router: routerReducer\n}));\nwhich is similar to what I was doing. I had to explicitly use persistReducer on each reducer in my combineReducers (or at least the ones I was going to persist, such as user object).\nSo I would propose either doing this programmatically or just manually doing it for each reducer in before combining them. For me, this was:\nfrom\njavascript\nconst rootReducer = combineReducers({\n  form: formReducer,\n  user: userReducer,\n});\nto\njavascript\nconst rootReducer = combineReducers({\n  form: formReducer,\n  user: persistReducer(persistConfig, userReducer),\n});\nSimilar to OP's code, I had:\njavascript\nconst persistedReducer = persistReducer(persistConfig, reducer); \n// this won't work with nested objects in reducers (or at least I don't think)!\nwhere reducer was the rootReducer from my reducer file.\nI had to change some imports around but now my user object persists properly! And I didn't have to use hardSet (which was persisting properly, but wouldn't have allowed me to add more \"whitelist\"/reducers in the future without checking storage somehow or force rewriting storage)!\nHere are some snippets of my working code for reference (with some helpful comments). Also my repo:\nreduxPersist.js\n```javascript\nimport storage from 'redux-persist/lib/storage';\nconst KEY = 'storage-key-here';\nexport const persistConfig = {\n  key: KEY,\n  storage,\n};\n```\nreducers.js\n```javascript\nimport { combineReducers } from 'redux';\nimport { persistReducer } from 'redux-persist';\nimport { persistConfig } from '../pkgs/reduxPersist';\n// had to move this here from reduxPersist.js, which is where it was originally\nimport formReducer from './form';\nimport userReducer from './user';\nconst rootReducer = combineReducers({\n  form: formReducer,\n  user: persistReducer(persistConfig, userReducer), // put persistReducer here\n  // you can also add custom configs for each reducer (e.g. in the nested persists doc)\n});\nexport default rootReducer;\n```\n_store.js\n```javascript\nimport { createStore, applyMiddleware } from 'redux';\nimport thunk from 'redux-thunk';\nimport logger from 'redux-logger';\nimport reducer from './reducers'; // import rootReducer here\nconst devMiddleware = [];\nconst middleware = [];\nif (process.env.NODE_ENV === 'development') {\n  devMiddleware.push(logger);\n  // add more dev middleware here\n}\nmiddleware.push(thunk);\n// add more middleware here\nconst store = createStore(\n  reducer, // don't put persistReducer here\n  applyMiddleware(...middleware.concat(devMiddleware)),\n);\nexport default store;\n```\nApp.js\n```javascript\n// other import statements\nimport { PersistGate } from 'redux-persist/integration/react';\nimport { persistStore } from 'redux-persist';\n// some code\nimport store from '../_store';\n// more code\nclass App extends Component {\n  render() {\n    return (\n      \n\n          {/ more code\n        /}\n        \n\n    );\n  }\n}\nexport default App;\n```\nhope this helped!. ",
    "ailinca": "I am also facing a similar situation:\nI have a React-Native app distributed via Fabric and whenever a new version that contains changes to the store structure is released, the app tries to use previous store state format. Basically, the app needs a clean reinstall at every update to function properly. \nI should mention that I only persist a few entries using whitelist and those entries were not modified between app updates. \nThis behavior replicates both on Android and iOS. . ",
    "AmyNgithub": "I solved it by force updating to 5.6.9 (had 4.10.2 before) where I could see that the path integration/react existed. I chose to update to bare minimum version (what I could find) instead of the latest because Im working in react-native 0.49 and wanted to avoid and update of react-native if I could.. ",
    "hammadzz": "@majidln @JulianKingman has anyone come up with a correct implementation of redux-persist with redux-saga?. @klis87 any boilerplate? I am using the example above not sure if it will work properly. Trying it out once I fix something else breaking my app.\nI am migrating from redux-storage, it had an action to watch for when data is persisted so you could subscribe to it with a watcher. Is that possible in redux-persist?\nI had a sagas/init.js that was the very first saga that let you do neat stuff like so:\n```javascript\nimport { take, fork, put, call } from 'redux-saga/effects'\nimport { LOAD } from 'redux-storage'; // LOAD - action type when redux persists data\nfunction *watchReduxLoadFromDisk() {\n  while(true) {\n    const { payload } = yield take(LOAD);  //Subscribe to when app finishes loading\n    try {\n      if (payload.user.token) {\n        // set Authorization header to loggedin user token\n        yield call(api.setHeader, 'Authorization', JWT ${payload.user.token})\n        // Calls to refresh logged in user's profiles\n    yield put({type: actions.FETCH_ME})\n        // request for chat token\n        yield put({type: actions.CHAT_GET_TOKEN})\n      } else {\n        // remove authorization header\n        yield call(api.deleteHeader, 'Authorization')\n      }\n    } catch (err) {\n      // remove authorization header\n      yield call(api.deleteHeader, 'Authorization')\n    }\n    yield call(SplashScreen.hide)\n  }\n}\n. I think I found that actionjavascript\nimport { REHYDRATE } from 'redux-persist/lib/constants'\n```. ",
    "klis87": "@hammadzz I use both libraries extensively, but I am not sure why they could conflict each other? I dont have any issues despite the fact I use them both. @hammadzz I dont really have a boilerplate as I used much more stuff that those 2 libs, but generally I just used readme of both projects as a start and it worked out, as those libraries don't get into each other's way.\nProbably people have bugs because they didn't wait for REHYDRATE action, like you did. Personally I didn't do this though, as I persist only data which are used by React component, and this is what PersistGate is for, my components won't get rendered until rehydration is ready so I dont have any race condition bugs this way. @jerryzlau you can wrap any nested reducer in persistReducer independently, because persistReducer is higher order reducer:\njs\nreturn {\n  ...state,\n  business: persistReducer(\n    { storage, key: 'business' },\n    businessReducer(state.business, action),\n  ),\n}. @jerryzlau actually above snippet probably won't work, it would be better to use it together with nested combineReducers,  or to assign wrapped reducer to const otherwise it would be recreated on every state update, like:\n```js\nconst persistedBusinessReducer = persistReducer(\n    { storage, key: 'business' },\n    businessReducer,\n);\n...\nreturn {\n  ...state,\n  business: persistedBusinessReducer(state.business, action),\n}\n```. ",
    "majidln": "\n@majidln @JulianKingman has anyone come up with a correct implementation of redux-persist with redux-saga?\n\nI do it, there is not a problem and it works fine. ",
    "Slapbox": "Just to spell it out for anyone confused on this:\n```js\nimport { all, fork, take } from 'redux-saga/effects';\nimport { REHYDRATE } from 'redux-persist/lib/constants';\nimport { mySagaA, mySagaB, mySagaC } from './mySagas';\nfunction* rootSaga() {\n  console.log(\"Waiting for rehydration\")\n  yield take(REHYDRATE); // Wait for rehydrate to prevent sagas from running with empty store\n  console.log(\"Rehydrated\")\n  yield all([\n    fork(mySagaA),\n    fork(mySagaB),\n    fork(mySagaC),\n  ]);\n}\n```. Seems like yes unfortunately. There's plenty of forks though. Hopefully one takes over where @rt2zz left off.. @rt2zz thanks so much for the updates and the great work on this library!. @a1992012015 how did you solve this?. It seems that the state will persist if the amount of data is small (less than 10kb?) and the amount of time between closing and re-opening is enough, maybe 10 seconds?\nUnfortunately at 1-2mb on Android no amount of waiting results in persisted data. It's always reset.. I've now tried blacklist, whitelist and excluding both options and simply saving everything, but the problem persists.\nOn a Pixel 2 running Android 9 it looks like 1800kb is about the limit for what Redux-Persist will restore with any amount of waiting. At 2000kb the data is lost 100% of the time.. Unfortunately nothing else is compatible with Expo so I had to ditch Redux-Persist. I'd love to know why this is an issue though.. ",
    "fsalata": "Same problem here.. ",
    "andela-mallan": "Same problem, any solution found?\n. ",
    "vincentvella": "You should be able to take the constructor out and just render it. There typically won't be any props passed into the initial component that you've registered.. ",
    "appjitsu": "+1. ",
    "Lerosen": "As far as I know that is not a use case covered by redux-persist. A solution that provides such functionality is https://github.com/JumboInteractiveLimited/redux-cache#readme which should work well with redux-persist. . ",
    "saeedtabrizi": "Hi @kevindavee \nI have same issue with v5 too .  but when i remove node_module directory and uninstall app from my device the problem was resolved .\n. ",
    "vitto-moz": "React-native / AsyncStorage / \"redux-persist\": \"^5.9.1\",\nI suppose I have the same issue. \nIt seems I had state persisted once and then I get the same copy every time app loaded. \nFor example, I've authorized with certain credentials(1) -> then logout -> authorized with certain credentials(2) -> close app -> open app again -> get logged in state with credentials(1) . ",
    "matiattack": "Hello, I come from the future and I present the same problem, could you solve it?. ",
    "ZhangYiJiang": "Yes, it looks like the module has side effects - storage/index.js exports the result of calling createWebStorage. Another way around it other than using conditional import  with require is to import getStorage directly, and wrap it in, say, lodash's memoize so we get the same storage instance every time it is called. \n```\nimport getWebStorage from 'redux-persist/lib/storage/getStorage';\nimport { memoize } from 'lodash';\nconst getStorage = memoize(getStorage);\n``` \nIf you just need to silence the error in unit tests, just mock the module to do nothing using eg. Jest's manual mock https://facebook.github.io/jest/docs/en/manual-mocks.html \n. @tomaswitek Run your app in NODE_ENV=production. This will suppress the error, and enable some optimizations in React if you're using that. \n@tje3d What I did was to write a wrapper around persistReducer, and imported storage in the same file. In test I just mocked the file so redux-persist/lib/storage is never imported \n```\n// persistReducer.js\nimport { persistReducer as basePersistReducer } from 'redux-persist';\nimport storage from 'redux-persist/lib/storage';\nexport default function persistReducer(key, reducer, options = {}) {\n  return basePersistReducer(\n    {\n      key,\n      storage,\n      ...options,\n    },\n    reducer,\n  );\n}\n```\nI'm using Jest, but other mocking libraries should have similar functionality \n// In tests - this has to be at the root so that Jest can hoist it so this runs before the import \njest.mock('./persistReducer', () => (key, reducer) => reducer); . ",
    "tje3d": "@ZhangYiJiang i still can't get it working using mocks :(. ",
    "tomaswitek": "I am also getting this error on a server when working with Next.js + Redux persist:\nredux-persist failed to create sync storage. falling back to memory storage.\nUsing:\n\"react\": \"^16.2.0\",\n    \"redux\": \"^3.7.2\",\n    \"redux-persist\": \"^5.9.1\",\n    \"next\": \"^5.1.0\",\nMy workaround:\n```\n  const getReducers = isServer => {\n    if (isServer) {\n      return reducers.serverReducers;\n    } else {\n      const storage = require('redux-persist/lib/storage');\n  const persistConfig = {\n    ...config,\n    storage: storage.default,\n  };\n\n  return persistReducer(persistConfig, reducers.clientReducers);\n}\n\n};\n```. Thx @ZhangYiJiang . ",
    "SteveMellross": "Yeah, I also found the migration documentation a bit confusing. I've got it mostly sorted now, but clearing it up could help if other people are still migrating.\npersistCombineReducers is used in the migration document but is nowhere to be found in the normal documentation. Pretty straight forward but slightly confusing.\nMigration now seems to store the version in state._persist.version when before (in redux-migrate-persist) it was stored in a user-defined location via a custom reducer and selector. I was hoping this might work while upgrading from version 4 using getStoredStateMigrateV4 if I got everything in the right order, but redux-migrate-persist no longer seems to work with redux-migrate v5, so... \ud83e\udd37\u200d\u2642\ufe0f \nI'd like to avoid having to reset users state in the future...\n. ",
    "forster-thomas": "@hutchy2570 where I put this code? . ",
    "felixus95": "+1 !. ",
    "jrmurad": "Same here. I started looking into it and I think what's happening is the getItem() Promise on app load rejects with an error. That error is passed to the REHYDRATE action. The action does not consider the error and just writes undefined to the store, causing the setItem middleware to run (because it detected a \"change\") and \"erasing\" the data.\nI am currently looking for issues with a suggested fix or a PR. Might make my own PR but I'm not sure what correct behavior should be. Probably just to not write anything to local store if getItem failed. And I might need to add a new error handler to the config so consumer can handle when a rehydration error occurs.. ",
    "lilosir": "Same issue, any updates?. ",
    "lukebrandonfarrell": "I can confirm that this still happens when using FSStorage. It happens of both v5 & v4. Seems to have something to do with the autoRehydrate which is not getting logged and data not persisted in some cases.. After more testing it seems to be working with redux-persist-filesystem-storage without erasing data randomly. It could be something to do with AsyncStorage. @lilosir . @alanlanglois Using redux-persist-filesystem-storage worked for me. Using in production.. ",
    "erkrapide": "I would like to see @Dante-101's fix in a new version release. Is that possible?. ",
    "zarv1k": "The PR causes issues with processing blacklisted keys. I've prepared fix for that in #928. Seems it will be fixed in #928. ",
    "someden": "I have found some solution:\nconst PersistGateWithRouter = withRouter(PersistGate);\nBut maybe PersistGate doesn't need to be a pure?. ",
    "knpwrs": "PersistGate and Provider need to go outside of ReactRouter:\njsx\nexport default () => (\n  <Provider store={store}>\n    <PersistGate loading={null} persistor={persistor}>\n      <Router history={history}>\n        <App />\n      </Router>\n    </PersistGate>\n  </Provider>\n);. ",
    "Gyvastis": "Yeah, I'm struggling with this as well. I think it has something to do with ImmutableJS. In previous redux-persist versions we used to have redux-persist-immutable library to persistStore but now it's not usable in this version.. @Farrukhameen ended up using version 4. At least it works as expected.. ",
    "Farrukhameen": "Any updates on this issue I am facing the same issue. any solution?. ",
    "sincerekamal": "@Gyvastis version 4 of redux-persist or what ?. Is there any documentation for that specifically ? because I failed to do it correctly. It would be great to just integrating this into react-boilerplate. ",
    "Macilias": "obviously you use also https://www.npmjs.com/package/localforage. Anyway I\u00b4m new to react/redux and don\u00b4t see how to merge this with https://www.npmjs.com/package/redux-persist. The docu on https://www.npmjs.com/package/redux-persist-immutable says it`s a wrapper so some of the original redux-persist need still to be applied, but seams to be incompatible. For eg: \nconst persistedReducer = persistReducer(persistConfig, rootReducer)\nI\u00b4m also not sure weather or not once can use the window.persistor like that: \nconst App = () => {\n  return (\n    <Provider store={store}>\n      <PersistGate loading={null} persistor={window.persistor}>\n        <RootComponent />\n      </PersistGate>\n    </Provider>\n  );\n};\nWhen it try this I get the exception:\n```\nreact.js?28cc:53 Uncaught TypeError: this.props.persistor.subscribe is not a function\n    at PersistGate.componentDidMount (react.js?28cc:53)\n    at commitLifeCycles (react-dom.development.js:14361)\n    at commitAllLifeCycles (react-dom.development.js:15462)\n    at HTMLUnknownElement.callCallback (react-dom.development.js:100)\n    at Object.invokeGuardedCallbackDev (react-dom.development.js:138)\n    at invokeGuardedCallback (react-dom.development.js:187)\n    at commitRoot (react-dom.development.js:15603)\n    at completeRoot (react-dom.development.js:16618)\n    at performWorkOnRoot (react-dom.development.js:16563)\n    at performWork (react-dom.development.js:16482)\n```\nand I\u00b4m not the only one: https://github.com/rt2zz/redux-persist/issues/731\nA working full example would be great.. you are damn right its a mess, just look at this: https://github.com/rt2zz/redux-persist/issues/64\nThanks for the fast reply, I\u00b4ll try to find some old documentation for v4 and stick to that.. Thx!. ",
    "workostap": "I faced the same issue\n. ",
    "oleole90": "@adhenrique how did you resolved this issue?. ",
    "waclock": "Having the same problem. Could anyone pinpoint to a solution?. ",
    "co2-git": "it returns null because null is the value you specified as the property loading of your PersistGate component. renderer.create() sends you the element at the mount time, and not through eventual updates. Here, at mount time, PersistGate will show you the loading. Maybe use mount from enzyme, or mock PersistGate, something like this:\njsx\nrenderer.create(\n  <App />,\n  {\n    createNodeMock: (element) => {\n      if (element.type === PersistGate) { return element.props.children }\n      return null;\n   }\n). ",
    "Jekiwijaya": "Me too. \nyou could do this too.\njest.mock('redux-persist/integration/react', () => ({\n  PersistGate: props => props.children,\n}));\n. ",
    "atlanteh": "I can confirm this doesn't work for me either. ",
    "microcipcip": "I have the same problem but without the whitelist key....it doesn't work at all. @uuau99999 I had so many problems with this that I ditched this lib and wrote my own.. @uuau99999 Yeah, it is strange that a 6K stars project doesn't handle basic blacklist properly.. ",
    "uuau99999": "Same issue here. A more detailed explanation about the nested persist config is expected in doc.. @microcipcip That's awesome. I now use the work around offered by @bruno-edo now and it dose work. But it's a little bit weird. . ",
    "herarya": "same issue. ",
    "vicky-blr": "Thanks @Dmitrylolo , I will try this later. In the meantime, I went ahead with another library redux-storage which is working perfectly for me. Closing it for now. ",
    "basudz365": "@Dmitrylolo I had the same issue as the OP and after changing the key from 'root' to 'primary', it seems to be working properly now. Not sure why this is or if it's only an issue when inside the Expo environment but either way, thanks for the suggestion!. ",
    "rodrigo-fonseca": "I'm having the same issue, here is my code:\n```\nimport { createStore, applyMiddleware } from 'redux'\nimport promiseMiddleware from 'redux-promise-middleware'\nimport reducer from 'redux/reducers'\nimport createReduxListen from 'redux-listen'\nimport { persistStore, persistReducer } from 'redux-persist'\nimport storage from 'redux-persist/lib/storage'\nconst persistConfig = {\n  key: 'primary',\n  storage,\n}\nconst persistedReducer = persistReducer(persistConfig, reducer)\nconst listenStore = createReduxListen()\nconst middleware = applyMiddleware(promiseMiddleware(), listenStore.middleware)\nconst store = createStore(\n  persistedReducer,\n  window.REDUX_DEVTOOLS_EXTENSION && window.REDUX_DEVTOOLS_EXTENSION(),\n  middleware,\n)\nconst persistor = persistStore(store)\nexport { store, listenStore, persistor }\n```\n. it simply doesn't work like it should. ",
    "gabrielhpugliese": "Hey guys, did you manage to find out what was wrong? I am struggling right now too.... ",
    "hackrit": "Hi guys,\nI found a solution to this problem. (might not apply to all the cases, but worked for me).\nThe problem was caused by my default return in my reducer, which I returned {...state}.\nOnce I changed the default return to just return state, everything work as expected.. ",
    "theonlyjohnny": "Was banging my head against this for longer than I want to say... thanks @hackrit ! that fixed it for me. ",
    "MartinJHItInstituttet": "@hackrit I hardly can't believe this was the solution... I could see my outbound state being correct, but somehow it wasn't being reflected in my state. And sure enough, I returned a clone of my state in the default, instead of the original state.\nThanks so much for the help!. ",
    "andrewmartin": "Really wish the docs were a bit more clear in naming primary as the required value for the config key key instead of root...very confusing. works well now though. \ud83d\udc4d . ",
    "jerryzlau": "How would I be able to deal with nested reducers then? \nI have a nested reducer: \ndefault:\n      return {\n        ...state,\n        business: businessReducer(state.business, action)\n      }\n. ",
    "ragozin-n": "Same issue on Android. I figured out that the problem occurs when you save an array of data more than 6 megabytes, which is the default size of AsyncStorage @k3ith-fowl3r . ",
    "harishbelamkar": "Same problem for me too but happening in both iOS and android.. It's happening every time when apps launches, this is happened after adding redux-persist.\n\nany advice ?. ",
    "marcin-solvenet": "I got this issue when my redux state was too big. By too big I meant +10k items each with couple of properties. you can override a 6M limit for asyc storage on Android,  but depending on your database it might not to be a good option (i had performance issues when rehydrate state when I was close to 6M limit), I ended with sqlite storage . ",
    "moneynguyen0o0": "how can we fix this issue guys?. Thanks @marcin-solvenet I just follow this https://github.com/bigsassy/react-native/commit/7f766b8bfdcef86f17b28bf9482c4399084bd729 and it works. ",
    "AnimaWolf": "@tarang9211 I've had the same issues, the following seems to work for me.\n```js\n// The transformer\nconst mapTransformer = config =>\n  createTransform(\n    map => JSON.stringify(Array.from(map)),\n    arrayString => new Map(JSON.parse(arrayString)),\n    config,\n  );\n// Config\nconst mapStatePersistConfig = {\n  key: 'mapState',\n  storage,\n  transforms: [mapTransformer({ whitelist: 'map' })],\n};\n```. ",
    "kilgarenone": "I'm having this issue too. For now I will resort to the primitive method to persist state... https://egghead.io/lessons/javascript-redux-persisting-the-state-to-the-local-storage. ",
    "Burgomehl": "you could delete app data?. As i understand, you started the app and created a wrong state and now the rehydrate keeps this state. At the emulator is a icon called apps there you can find your app and reset the cache or you may use this command: \"adb shell pm clear com.yourappname\" where you have to set the name of your app at \"yourappname\".  . ",
    "joelGarcia93": "@Burgomehl how can I do it? im new in redux, I need to restart my initialState to the beginning, like I created a new react native project.\nin wich file do I have to do that? I think I have to create my own function in some files to fire the function when the app is running.\n. ",
    "arnaudambro": "I agree, especially when you create branches with new features in the app impacting the state, and that you want to dump afterwards.. ",
    "coringham": "bump.\n@scic thank you so much for the workaround.. ",
    "hassanabbas9": "The problem persists somehow in Angular 7 at least in version 5.10.0. Here are my project dependencies:\n\"dependencies\": {\n    \"@angular-redux/form\": \"^9.0.1\",\n    \"@angular-redux/store\": \"^9.0.0\",\n    \"@angular/animations\": \"~7.2.0\",\n    \"@angular/common\": \"~7.2.0\",\n    \"@angular/compiler\": \"~7.2.0\",\n    \"@angular/core\": \"~7.2.0\",\n    \"@angular/forms\": \"~7.2.0\",\n    \"@angular/platform-browser\": \"~7.2.0\",\n    \"@angular/platform-browser-dynamic\": \"~7.2.0\",\n    \"@angular/router\": \"~7.2.0\",\n    \"core-js\": \"^2.5.4\",\n    \"flux-standard-action\": \"^2.0.3\",\n    \"redux\": \"^4.0.1\",\n    \"redux-persist\": \"^5.10.0\",\n    \"rxjs\": \"~6.3.3\",\n    \"tslib\": \"^1.9.0\",\n    \"zone.js\": \"~0.8.26\"\n  },\n\nERROR in node_modules/redux-persist/src/index.d.ts(70,46): error TS2307: Cannot find module 'react'.\nnode_modules/redux-persist/src/index.d.ts(92,38): error TS2304: Cannot find name 'React'.\n\nIs someone else facing the same problem with the latest version ?. ",
    "mfpiccolo": "I was about to open the same thing.  We just opened a PR that we really need to go through and it would be better in the main repo than maintaining a fork. . ",
    "emilany": "I'm also encountering this problem. Did you manage to resolve this? . ",
    "askpatrickw": "I do not see in your code you calling getState so not sure if this is same thing, but hit this as well. The issue in my case was an improper import.\nBefore redux-persist export default createStore(rootReducer, applyMiddleware(thunk)); so you could 'import store from ./src/store.js' \nBut if you follow the examples in this repo you need to import {store} from './src/store.js because you have no default export if you have the supplied sample code of:\nexport const store = createStore(pReducer);\nexport const storePersisted = persistStore(store);. ",
    "thorakmedichi": "\nI'm also encountering this problem. Did you manage to resolve this?\n\nNo. I gave up on the library.. ",
    "dillonfromdallas": "+1. Logging out Object.keys(store) returns dispatch,subscribe,getState,replaceReducer\nNot sure what to do here. I've sent an email out to @rt2zz. Will report back if I get a response. . ",
    "code-freakz": "+1. ",
    "darewreck54": "I'm experiencing the same issue.  I just installed 5.10.0, and getting the same error but i'm using   \"redux\": \"3.7.2\" not the \"4.0.0\".  When I downgrade to 5.9.1, it seems to address the issue.  Perhaps the 5.10 is tied to a specific redux version?. ",
    "lao9": "Agreed! Noticed this today while trying to flow type a file that uses createTransform. Thanks for pointing that out @aguynamedben - I meant to change one file in this particular PR! \nI don't think that this repo is maintained anymore, so to ensure flow was passing on my current project I ran through the build steps on my forked repo so I could use my fork on my own project. Just going to close this PR I think for now.. ",
    "tylermurry": "I have this exact same scenario. We're you able to find a solution?. ",
    "larissathasdefar": "I am using a workaround with dissoc from ramda, manually removing _persist from my object.\n```js\nconst formatInitialState = () => dissoc('_persist', initialState)\nexport default (state = initialState, action) => appReducer(\n    action.type === 'RESET_STORE'\n        ? formatInitialState()\n        : state,\n    action\n)\n```. ",
    "tkow": "We have met same problem.I wonder why we success reset state only at first.\nI have trouble to comprehend how this occur.. I found redux-persist add _persist prop to returned object.So when we return initialState as reducer return value, initialState is mutated and their prop info is cached because it has ref. we can also avoid this by returning copy of initialState.. ",
    "shirakaba": "I'll admit that I was lost at what to do here. However, your import of \"storeConfig\" needs clarification, too!\nShould <Provider> really be the parent of <PersistGate>? Thought it would be the other way round, from the docs.. ",
    "linux08": "Hi , I noticed this is an issue so I updated the readme.\nI just made a PR https://github.com/rt2zz/redux-persist/pull/917. Just did that, kindly check.. ",
    "aaronisme": "seems like the jest is not compile the library, try to add the config on the jest config file? you can refer  jest documents. ",
    "ggsjyoon": "Same issue here.\nI'm trying to write tests using ...\n\"devDependencies\": {\n    \"@types/enzyme\": \"^3.1.11\",\n    \"@types/enzyme-adapter-react-16\": \"^1.0.2\",\n    \"@types/faker\": \"^4.1.2\",\n    \"@types/fetch-mock\": \"^6.0.3\",\n    \"@types/jest\": \"^23.1.3\",\n    \"@types/react-test-renderer\": \"^16.0.1\",\n    \"@types/redux-mock-store\": \"^1.0.0\",\n    \"enzyme\": \"^3.3.0\",\n    \"enzyme-adapter-react-16\": \"^1.1.1\",\n    \"faker\": \"^4.1.0\",\n    \"fetch-mock\": \"^6.4.4\",\n    \"react-scripts-ts\": \"^2.16.0\",\n    \"react-test-renderer\": \"^16.4.1\",\n    \"redux-mock-store\": \"^1.5.3\",\n    \"typescript\": \"2.9.2\"\n  }\nbut I'm getting the below error when import storage from \"redux-persist/lib/storage\";\n$ yarn test\nyarn run v1.7.0\n$ react-scripts-ts test --env=jsdom\n  console.error node_modules\\redux-persist\\lib\\storage\\getStorage.js:40\n    redux-persist failed to create sync storage. falling back to memory storage.\nand same error as @HeratPatel1 's when import storage from \"redux-persist/es/storage\";. ",
    "marcandrews": "You must call persist() after calling store.replaceReducer.\nYou can do this conveniently if you expose the persistor on your created store. Then, in injectReducer:\nstore.replaceReducer(createRootReducer());\nstore.persistor.persist();. When you create your store, just add persistor to it before you export it:\n```js\nconst store = createStore(\n  createReducer(),\n  {},\n  composeEnhancers(...enhancers)\n)\nconst persistor = persistStore(store)\nstore.persistor = persistor\nexport default store\n```. ",
    "mobinni": "@marcandrews We're using the persist-gate to wrap around the persistor, so on our actual store object, persistor is not available. \nUpdate:\npersistor.persist() apparently does the same thing internally that I've hardcoded as a dispatch, i.e: \npersist: () => {\n      store.dispatch({ type: PERSIST, register, rehydrate })\n    },\nbut it does pass along the register and rehydrate which may solve the the error that's invoked irregularly\naction.rehydrate is not a function. That solves my issue, thanks @marcandrews!. ",
    "ttruongatl": "The callback in persistStore is called in my react-native project with/without a debugger. \npersistStore(store, {}, () => {\n            console.log('OK');\n        });\nI'm using the same packages version you posted.\n. ",
    "cesarm16": "its happening to me, any solution? It's only on Android. ",
    "schneck": "It appears that it only happens when the remote debugger is used. I'm not sure where to start investigating, because it's unpredictable when it happens.. Another observation: If the application is stuck within the circumstances described, you can make it work again by switching apps on the emulator to something else, and then switch back. After that, persist/REHYDRATE is called.. ",
    "jannikbuschke": "I think I have the same problem. While debugger attached I only get a persist/PERSIST and after some 30 secs a timeout action. When not using the debugger I get an persist/REHYDRATE and state is populated. Using a real Android device\nAlso I can fix it for some time by disabling remote debugging and enabling it again.\npossibly related https://github.com/rt2zz/redux-persist/issues/717. ",
    "gaultierq": "This problem has been here since I have started using this library. It may be quite easy to find a work-around but with a downside: I end up developing my apps using the ios simulator, and therefore they are optimised for ios. If this bug was fixed, I would use android dev env a lot more.. ",
    "vitorreis": "This also happens in my project... no solution so far.\n\n. An update, I have users that reported this bug with the release build. :(\nI am considering stopping using this library.... ",
    "kaiiserni": "I have had a similar issue, apparently also with release builds, I think my issue had something to do with how android restores activities and RN.\nAnyhow adding a simple key check like so did the trick for me:\nif (store.getState()._persist) {\n  _restore();\n} else {\n  persistStore(store, null, _restore);\n}\n. ",
    "pacozaa": "@kaiiserni Would you mind share the your full code?\nI am following.. ",
    "c-goettert": "Closing this issues because I could figure out my mistake.\nFor anyone interested: I didn't recognize that the callback function takes 2 arguments, the first one being an error. So I needed to change my code like this: \n...\n        callback && callback(null, JSON.stringify(debugState[propName]))\n        resolve(JSON.stringify(debugState[propName]))\n.... ",
    "gavin-gmlab": "Realized that the problem is caused by the transform process.\nNeed to pass the intial state and merge with the persisted objects in the outbound transform filter.. ",
    "jstayton": "See https://github.com/rt2zz/redux-persist/issues/618.. ",
    "neutrous": "Analogous to #637 and #320 . @twhitacre No...  Finally, I've switched to use Realm. It works great.. ",
    "twhitacre": "@neutrous did you ever figure out a solution for this? I'm experience the same problem.\nI've figured out how to dynamically set a different prefix-key, which is working great, but I need to rehydrate the data upon login/logout.. @Faolain I ended up just setting a different prefix-key and reloading the app when the user changed. For me it's only on login and logout. It kicks the user to a loading screen while I wipe the persisted data from the store and then load it back in using the prefix of the user id (or guest). \nThat said, it works, but is not scaleable, especially if I end up with more than a few local users. I'm actually in the process of switching to Realm as well. It seems like the way to go for this type of application.\nHope that helps some!. ",
    "rbsl-rimjhim": "I have migrated and fixed it as per version 5 . Those who need this fix, can see here\n. ",
    "cbetta": "Currently I have this in place, but it ends up refreshing the page and instead I'd rather refresh the store.\njs\ndocument.addEventListener('visibilitychange', () => {\n  if (document.hasFocus()) {\n    document.location.reload()\n  }\n}). ",
    "pmk1c": "I'd really need this feature. I.e. for doing a clean migration from AsyncStorage to FilesystemStorage on Android.. ",
    "jqn": "Any traction on this. I'm not finding any answers anywhere\n. ",
    "mattlubner": "I'm seeing the same thing, were you able to resolve this?\nI'm on webpack@4.12.0 and think it's probably because module.hot.accept() accepts an error-handling callback when no dependencies are specified (according to their docs: https://webpack.js.org/api/hot-module-replacement/#accept-self-). I'm not sure, but maybe this is a behavioral change from webpack v3?. I was able to work past my issue. For anyone else that happens to find this thread, here's the fix:\njs\n  module.hot.accept('./app/reducers', () => {\n    const nextAppReducer = require('./app/reducers').default;\n    store.replaceReducer(\n      persistReducer(persistConfig, nextAppReducer)\n    );\n  });. Hey @rt2zz, who's the right person to ask about getting this PR merged?. ",
    "rikur": "Hmm.. Maybe it's timing out altogether -- the store is not properly persisted or restored at all on Android. Will debug.. Ah. It was the same old Android AsyncStorage issue. This PR is working around it:\nhttps://github.com/facebook/react-native/pull/18522. ",
    "simondell": "Migrations run only once: as the data comes out of the storage, before rehydrating the redux store. It might have happened already e.g. if you have some kind of \"refresh on save\" process in your development environment and you saved the file with a version number update, and then wrote the migration.. From my experiments, I find:\n- the keys in your migrations spec must match a version used in persistConfig. I only tried integers. I assume strings work too because integer keys on objects seem to get cast to strings anyway.\n- once a store or key has upgraded to the version specified in the persistConfig, it now has that version. Running the same code again will not cause the migration to run again.\n- you can't \"downgrade\" a version (to do this, you'd have to branch your code, make all the changes in in branch, and to reset, clear your development browsers' stored data, run the app in the old branch, then switch back to the new branch)\n- you can't add new keys to your store unless you also add a reducer for the new key, or perhaps add a 'whitelist' entry into the config\nSo, to run your migrations[1]...\n``\nimport { createMigrate, persistStore, persistReducer } from 'redux-persist';\nimport thunk from 'redux-thunk';\nimport rootReducer from './reducers/index'; // this must export a store with aclaudio` key\nimport storage from 'redux-persist/lib/storage';\nconst migrations = {\n    0: (state) => ({\n        ...state,\n        claudio: {}\n    }),\n    1: (state) => ({\n        claudio: state.favorites.moves.claudio,\n    })\n};\nconst persistConfig = {\n    key: 'root',\n    version: 1, // version must match the migrations keys\n    storage,\n    migrate: createMigrate(migrations, { debug: true }),\n    whitelist: [\n        'settings',\n        'favorites',\n        'claudio', // if you whitelist reducers, you must include your new reducer in your list\n    ],\n};\n//... the rest of your code looked fine\n```\n. ",
    "MilllerTime": "You can type localStorage and hit enter in your browser console. Alternatively you can view the Local Storage section of the \"Application\" tab in Chrome dev tools. Both methods will reveal the entirety of what is being held in localStorage for the current domain.. ",
    "dhwrwm": "I got this same error.\n\n. ",
    "naisargparmar": "I am also getting same error..How to clear local storage data programatically.?. ",
    "pgrzesik": "+1, is anyone by chance working on that ? I'm using Jest for tests. ",
    "seeker105": "+1 I'm having the same error. . Thanks! The solution at the link didn't work for me, but this one from StackOverflow did:\nin src/setupTests.js file add\n```\nclass LocalStorageMock {\n  constructor() {\n    this.store = {};\n  }\nclear() {\n    this.store = {};\n  }\ngetItem(key) {\n    return this.store[key] || null;\n  }\nsetItem(key, value) {\n    this.store[key] = value.toString();\n  }\nremoveItem(key) {\n    delete this.store[key];\n  }\n};\nglobal.localStorage = new LocalStorageMock;\n``\nI'm using the create-react-app utility which has a script that causes mysrc/setupTests.js` file to run automatically when testing starts. If you have a different setup you might need to put this code somewhere else. Just make sure it runs before your tests start.. ",
    "achan": "This is not the proper solution, but a workaround would be to mock localStorage.. ",
    "kirushi": "Thanks @seeker105  - stubbing it worked!. ",
    "azolson": "for those of you who have implemented something apart from localStorage, don't forget to change your class accordingly. I wasted 10 minutes on trying to figure why the mock wasn't working!\nExample below is for those using sessionStorage(based on @seeker105 's comment above):\n```\nclass SessionStorageMock {\n    constructor() {\n      this.store = {};\n    }\nclear() {\n  this.store = {};\n}\n\ngetItem(key) {\n  return this.store[key] || null;\n}\n\nsetItem(key, value) {\n  this.store[key] = value.toString();\n}\n\nremoveItem(key) {\n  delete this.store[key];\n}\n\n};\nglobal.sessionStorage = new SessionStorageMock;\n```. ",
    "bruno-gama": "I wanna +1 and bump this, I know the getStorage function already checks if NODE_ENV !== production, so it could also check if the env is test too.\nIt's easy to open a PR for this change, I just don't know if it is something you're interested in.. ",
    "reallistic": "Looks like the fix for this is to import it from the root:\nimport { createTransform } from 'redux-persist';\nHowever I am now running into a react error.. ",
    "razvan-tudosa": "Anybody has an idea on what goes wrong there? I'm having almost the same set-up and exactly the same problem.\nLE: for the time being I downgraded to 5.6.12 and seems to be working fine.. ",
    "patrickcze": "Also having the same issue . ",
    "JaceHensley": "Also having the same issue but I'm also on v4.10.2. I can see that values get written to localStorage and they are updated when they should be. But on page reload it seems like the values do not get read/set in the redux store. ",
    "codejamninja": "If you want this fix immediately, you can add the following to the dependencies section of your package.json file.\njs\n\"redux-persist\": \"git+https://github.com/codejamninja/redux-persist.git#npm\". If you want this fix immediately, you can add the following to the dependencies section of your package.json file.\njs\n\"redux-persist\": \"git+https://github.com/codejamninja/redux-persist.git#npm\". ",
    "maysam": "I have similar problem with \nlet initialState = Immutable.Map({\n  a: 1\n})\nnot getting persisted, after page reload, the state is an object and not an Immutable anymore. ",
    "EgidioCaprino": "@maysam that's a different issue. Look at the Transforms section.. @tommyalvarez what do you mean exactly? Yes, I'm mutating state through the reducer I've posted above.. @tommyalvarez I see what you mean. I'd like to introduce Observable in a next release of our app.\nAnyway, I can't say where we're mutating the state. We always do return { ...state, something: value }.. ",
    "chenzezhang": "\nwhy\uff1f. ",
    "ifyapishore": "Make sure that you use proper import\nCORRECT\nimport { persistStore, persistReducer } from 'redux-persist'\nimport storage from 'redux-persist/lib/storage'\nINCORRECT\nimport { persistStore, persistReducer } from 'redux-persist/something suggested by webstorm'\nimport storage from 'redux-persist/lib/storage'\n. ",
    "rodalmeida": "As far as I know, iCloud will do it for you automatically. Actually a problem I had was to stop iCloud from backing up the app state.. ",
    "gastonmorixe": "@tommyalvarez I am using https://github.com/rematch/rematch persistor plugin which uses redux-persist under the hood. If you see how they encourage to do this in their tests it's exactly as I am doing, calling purge() after log-out. \nI have little control over their configuration.. I will make a demo soon. Or you might see rematch tests how they purge storage and that\u2019s when it stops working. \nBest,\nGaston \n323 642 7866\nSent from my iPhone\n\nOn Aug 29, 2018, at 1:06 PM, Tomas notifications@github.com wrote:\n@waynebloss The persistor.purge method uses a reducer under the hood to clear the state (it actually clears the localStorage and on rehydrate it loads the new 'cleared' state depending on how you set up stateReconciler.\nI was just pointing out the general intended way of using this library for the particular use case of sign out and proposing a common used solution, which is clearing your store session state and let redux-persist handle the rest by itself. Anyway, it's impossible to figure out why it's not persisting the state anymore when using purge without seeing initialization code example and the localStorage value after purge. We need more info. @gastonmorixe if you be so kind to provide it :)\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub, or mute the thread.\n. \n",
    "waynebloss": "What if I don't want to clear state using a reducer? It's a lot more work to do that instead of just purging the storage.. @tommyalvarez Thank you! Much appreciate the explanation.. ",
    "prcbass": "Thanks @tommyalvarez for your explanation above as well. I opted to use purgeStoredState(config) along with setting reducer state back to initialState to clear state as part of logout.. ",
    "Tackgnol": "This is greatly needed... I see people around the web doing this but no examples :/. ",
    "dtschust": "Here's an proof of concept commit for my first option: https://github.com/dtschust/redux-persist/commit/2861a2180c179675503b86a66b9d0b02db557cfc. And here's a proof of concept commit for option number 2: https://github.com/dtschust/redux-persist/commit/62e90c9cd84434b81e068308c3bc2fc1b28c8365. ",
    "riq": "https://github.com/Nohac/redux-persist-expo-fs-storage. ",
    "antonsivogrivov": "+1, struggling with this.. ",
    "abenhamdine": "set up several configs, each on a different key, see https://github.com/rt2zz/redux-persist#nested-persists. ",
    "rajatvijay": "Any progress on this, facing a similar issue. \nPresist gate is rendering the loader prop instead of the children and thus affecting SEO.\nI can't even move the Persist gate to a child.\nIs there some way to avoid this?. ",
    "Frikster": "@Johncy1997 is your webpack server running? I had the same issue and noticed I forgot to start it up again.. ",
    "SinaKarimi7": "Same, I'm facing too! \nMy app contains of redux-saga, immutablejs and redux-persist.\n\nthis.props.persistor.subscribe is not a function. same\nbut not solved yet. \n",
    "jonathangreco": "Can you please provide the code you use into your reducer to update your nested state ?. ",
    "dominikbulaj": "Also can confirm it. \nI have store where user reducer contains several nested reducers e.g. state, friends, profile. State is where I store current user state - logged in/out, username, token, etc.\nIf I whitelist whole user reducer in PersistConfig so e.g.\nconst persistConfig = {\n    key: 'root',\n    storage,\n    whitelist: ['router', 'cms', 'user'],\n    blacklist: ['form'],\n    debug: (config.env === 'development'),\n  } \nand then call SIGN_OUT action which basically resets user.state it works. Reseted data is saved in persist storage and later on reused.\nBut with this I store whole user store section which in some cases might be large. \nSo recently I switched to nested persisting and right now my main config looks like this:\nconst persistConfig = {\n    key: 'root',\n    storage,\n    whitelist: ['router', 'cms'],\n    blacklist: ['form'],\n    debug: (config.env === 'development'),\n  }\nin rootReducer I switched use nested persist configuration as follows:\nconst appReducer = combineReducers({\n  // ...some other reducers\n  // user, // <-- old way\n  user: persistReducer(userPersistConfig, user), // <-- new way/setup\n})\nwhere my userPersistConfig is as follows: \nconst userPersistConfig = {\n  key: 'user',\n  storage: storage,\n  whitelist: ['state'],\n  stateReconciler: hardSet,\n}\nMy root reducer has this kind of solution for signing user out:\n```\nconst rootReducer = (state, action) => {\n  switch (action.type) {\n    case 'SIGN_OUT':\n      return appReducer(undefined, action)\ndefault:\n\n}\nreturn appReducer(state, action)\n}\n```\nAnd now whatever I would set to stateReconciler (in userPersistConfig)  it just doesn't save to persist storage. After page refresh redux-persist rehydrates user.state with old data (prior SIGN_OUT). I see persist/REHYDRATE is executed twice:\n\nonce for root object (in this case it only contains defaultStates for router and cms (those are whitelisted))\nthan for user nested object (in this case it rehydrates with old data - prior to changes caused by SIGN_OUT)\n\nIs it possible to force nested persist to save data always?\n. ",
    "iqqmuT": "@rezaerami Maybe you are updating existing basket objects in the basket reducer? Make sure that when you are updating basket count, you are not mutating existing objects but you create new objects. You can test it quickly by var newState = JSON.parse(JSON.stringify(state)); and then updating newState and returning it in the basket reducer.\nhttps://redux.js.org/recipes/structuring-reducers/immutable-update-patterns. Try some other storage engine, for example https://github.com/robwalkerco/redux-persist-filesystem-storage\nSee #199 and #284. . ",
    "pavliha": "I used  \njavascript\n if(!action){ \n     return state\n }\n. ",
    "zry754331875": "l have same issue. ",
    "InfiniteCode": "Yeah, had the same issue when tried to bootstrap a project. Weird bug.. @Infonautica Have you figured out the cause for it?. ",
    "Infonautica": "\n@Infonautica Have you figured out the cause for it?\n\nNo i didn't. But for now i assume better option is migrate to Create-React-App v2 if any problems occur. ",
    "lautaro-osacar": "@perevezencev \nPurge storage and try with whitelist instead of whiteList.. @perevezencev \nDon't you get {\"users\":\"{}\",\"_persist\":\"{\\\"version\\\":-1,\\\"rehydrated\\\":true}\"} as response with the last codesandbox?. ",
    "perevezencev": "@lautaro-osacar This does not work.\n. @lautaro-osacar, not at first, but then I cleared localStorage =) Thanks. ",
    "bluenex": "I've also faced this. There is a closed issue pointing that it was npm bug. But that doesn't seem to be my case.\nHow do I log just like your?. ",
    "Blackfaded": "I am facing the same issue. App is starting, but state is not persisted.\n\"react-native\": \"~0.55.2\",\n\"react-native-navigation\": \"^1.1.471\",\n\"react-redux\": \"^5.0.7\",\n\"redux\": \"^4.0.0\",\n\"redux-persist\": \"^5.10.0\".\n",
    "andrewmarmion": "I was having a similar problem with my set up. iOS was working but Android was not. I resolved it by adding keyPrefix: '' to the persist config. \nhttps://github.com/leethree/redux-persist-fs-storage/issues/5#issuecomment-409962329. ",
    "CptFabulouso": "Any workaround for this? I am not that familiar with flow, I would appreciate any help or hint with what can I do with an issue like this.. ",
    "sregg": "I'm seeing the same thing with the same setup.\nI don't think we're doing anything wrong though.. ",
    "evertbouw": "I ran into this as well, you have to blacklist users from root, not whitelist. In this example you can even remove the entire root persistor.. ",
    "lucasriondel": "@evertbouw @sregg i only want availableUsers to be rehydrated, not the other properties. \nas you've said @evertbouw , i have removed the root persistor, and i've changed it to : \n```\nconst usersPersistConfig = {\n  key: 'users',\n  storage,\n  whitelist: ['availableUsers']\n}\nexport default combineReducers({\n  users: persistReducer(usersPersistConfig, users),\n  error,\n  patient,\n  survey,\n  score\n})\n```\n. ",
    "tonmanayo": "Also getting rehydrate twice, different setup. ",
    "myrjola": "Looks good!. Looks good! Thanks for resolving the conflicts!. ",
    "PepijnSenders": "@rt2zz wdyt?. ",
    "prescottprue": "I am also seeing this without using immutable, just using hardSet.. ",
    "mariogillazaro": "I get the following  inside the fields args and caller of the register inside the persist/PERSIST action:\nException: TypeError: 'caller', 'callee', and 'arguments' properties may not be accessed on strict mode functions or the arguments objects for calls to them at Function.remoteFunction (<anonymous>:2:14)\nI had to blacklist the reducers using ImmutableJS\n. ",
    "Unforgiven-wanda": "@mariogillazaro I find myself in the same situation. Mind explaining how you fixed it?\nThank you. ",
    "mustafamagdy": "Any idea how to fix this issue?\nI even remove ImmutableJS, and I got this error \nAttempted to assign to readonly property.\n. Will this be available in npm installable version or just from this repo?. Is there a roadmap or a schedule when the new release will be pushed to npm, even in alpha, because of this still a big issue in dealing with the state?. @JustinLivi  I think the PR is cleaner, so instead of spreading the object in each reducer it is fixed in the persisted state update . ",
    "essensx": "Should be already resolved with this commit, 13 days ago. This is resolved with https://github.com/rt2zz/redux-persist/commit/c6b9772d27d58b51a7e6bf027049e439da3b1df6. ",
    "Anahkiasen": "Having the same issue with immer as well but doing the splat on my end does solve it in the meantime (ie {...produce(...)}). ",
    "sanjaypojo": "@Anahkiasen can you elaborate on how you're getting it to work with immer? I'm facing the same issue.. ",
    "JustinLivi": "@sanjaypojo you can just spread the resulting immer state into an empty object, which won't be frozen.. ",
    "erksch": "Since you call createStore with rootReducer I assume you did not wrap your rootReducer in a persistedReducer. \nTry this:\n```\nconst rootReducer = combineReducers({ ... });\nconst persistedReducer = persistReducer(persistConfig, rootReducer);\nconst store = createStore(persistedReducer);\nconst persistor = persistStore(store);\n```. I created a pull request to fix this issue with the changes proposed by @kareemsalah227.\nI added some more information about where the problem comes from.. What do you mean by 'not found in the cache'?\nI think you can store and persist File objects in your store and persist them.\nIf you want to display the image of that file again just extract the data URL (e.g. with blobToDataUrl of the blob-util package]) and display it via an <img src={dataUrl} /> or a CSS background image.\nIf storing and persistng File objects does not work somehow maybe consider storing the data URL directly since it's only a string.. As far as I know, there is no such call in the entire code base of redux-persist.\nSo please recheck your code.. Is it working without redux-persist (using the normal store and reducer)?\nAlso maybe try to wrap store creation in a function like proposed in the README in this section:\nexport default () => {\n  let store = createStore(persistedReducer)\n  let persistor = persistStore(store)\n  return { store, persistor }\n}\nand set everything up with\nimport configureStore from './configureStore'\nconst { store, persistor } = configureStore();\n... rendering and stuff. I guess you forgot to import setClientState in your page/index.js.\nAnyway, your error does not seem to be related to redux-persist.. Removing the ? is okay here because flow will mark them as optional automatically when defaultProps are defined. You can read about it here: https://github.com/facebook/flow/issues/1660#issuecomment-386619834. And there seems to be no other option than removing the optional flag :/. @aguynamedben Hey what's your status? I'd like to get this merged. I think many people can not update their flow version properly if this is not fixed.  . I like the destructuring though :D much cleaner to me.. > since this.props can't actually be set in the component code\nWhy not? This is what defaultProps are for. It overrides the optional props if they are not passed to the component.. No problem!\nI did some further digging in https://github.com/facebook/flow/issues/1660 and found this really good comment https://github.com/facebook/flow/issues/1660#issuecomment-323898823.\nThe main argument is that looking at props from the components internal perspective, props that have a defaultProp are kind of not optional anymore (again from an internal perspective), because they always have a value and you don't have to recheck if they are set or not. Little bit weird but I get the point.\nSo removing optional flags seems to be the way to go.\n. > So, if I'm following the discussion correctly does that mean #974 should be merged over #975?\nYep that's correct.\nI'll follow your greatly numbered instructions! ;). @aguynamedben My PR is ready now :). @kareemsalah227 If the change isn't too small for @aguynamedben I would encourage you to also contribute the object destructuring clean up.. A few days ago (31.01.), I published an npm package of the (at that time) current master build.\nI'm using this version in my projects which fixes my problems.\nhttps://www.npmjs.com/package/redux-persist-erksch\nIf you need stuff from the current master I can update the package. . #982 is related. We wouldn't have to rely on fork packages if getting the package from GitHub directly would work.. @Morriz do you have some sort of article how to do this properly? I would like to get this started.. Okay I did some investigation about this. \nI guess the npm script prepare is what we are looking for since it runs before publishing the package and before installing it with npm install.\nSo adding prepare: npm run build should do the trick, am I right?. > For now it's working but the info is spread into this props... any help to set it in one variable ?\nWhat exactly do you mean by that?\nTo use state from your store you can inject it in to your components props via \nconst mapStateToProps = state => ({ \n  targetProp: state.someParticularState,\n});\nexport default connect(mapStateToProps)(MyComponent);\nPlease check the react-redux docs for more information about this.\nBut the problems you are facing do not seem to be related to redux-persist.. I think you can already do this.\nWhen you take a look at the storages supported by redux-persist they only need the following things:\n\ngetItem: (key: string): Promise<string>\nsetItem: (key: string, item: string): Promise<void>\nremoveItem: (key: string): Promise<void>\n\nYou can check the webstorage implementation for reference.\nSo why not write your own storage by implementing these functions in an object or as static methods in a class. Then you should be able to import it and set it as the storage.\n```\nimport storage from './myStorage';\nconst persistConfig = { \n  ...\n  storage, \n};\n```. Ups I just rechecked the readme and it's already in there! Please take a look.\nhttps://github.com/rt2zz/redux-persist#storage-engines\nThere seems to exist a storage for your use case already here.. I don't really get what you are trying to do? \nWhat does the dashboard action dispatch to the store? \nWhat do you want to persist and what not?. True using a hook there could be really cool.\nYou could do a pull request with a refactoring!\nI would be happy to review it.. This surely works! But in my opinion, this is what defaultProps should be used for.\nYou get around removing the ? but it feels just like another workaround :D \nBut the way flow handles defaultProps is to blame in the end.. ",
    "Ailrun": "You should not install @types/redux-persist, since redux-persist already bundle its own typing.. @rt2zz Any opinion??. @rt2zz Could you review/merge this?. ",
    "avendiart": "Please add the types directory to the files property in package.json as the type definitions are not being included in the distributed package anymore.. Nice, that should do the trick :). ",
    "tnagorra": "Looks like types directory has been added in https://github.com/rt2zz/redux-persist/commit/8d58d1ee7759d1c7209705c0b342ae20f2954f3e, but it's not included in the latest release. :crying_cat_face: . ",
    "alexandrecanuto": "Second this, I have the same problem. Usually when reloading the app quickly in succession. . ",
    "gbahamondezc": "Same here.\nI already tried with timeout:0 and seems to have no effect at all.\nI get the state returning to the previous state (time traveling) in the rehydratation process randomly when I make a change to the state and then kill the app multiple times.\nThis happens only on android and I have tried with versions 5.6, 5.9 and  5.10.\nAny suggestions?. ",
    "veigastom": "May be your initial returning state is null where as it must be a object or your reducers are passing a null value instead a object. could you show your reducer and action structure else it is hard to figure out.. yeah it depends on your code flow basically middlewares are supporters which are  made to write code easy and short. and your dispatch(addcustomer) suppose to be in  mainapp.js inside render method for your code structure . ",
    "Arjun-Aggarwal": "I am kind of new to this, so can you explain how I might resolve the error. Thanks a lot. Can a persistor be used without using middleware? Because I'm not using any middleware.. This is my reducer code:\n```\nimport {combineReducers} from 'redux'\nimport {ADD_CUSTOMER, ADD_TRANSACTION} from './actions'\nconst merge = (prev, next) => Object.assign({}, prev, next)\nconst customerReducer = (state = [], action) => {\n  switch(action.type){\n    case ADD_CUSTOMER: \n      return [...state, action.payload]\n    case ADD_TRANSACTION:\n      return state.forEach(customer => {\n        if (customer.name === action.payload.name)\n        {\n          customer.amount += action.payload.amount\n        }\n      })\n    default:\n      return state\n    }\n}\nconst transactionReducer = (state = [], action) => {\n  switch(action.type){\n    case ADD_CUSTOMER: \n      return [...state, action.payload]\n    case ADD_TRANSACTION:\n      return merge(state, action.payload)\n    default:\n      return state\n  }\n}\nconst reducer = combineReducers({\n  customers: customerReducer,\n  transactions: transactionReducer,\n})\nexport default reducer\nand these are my actions:\n//action types\nexport const ADD_STORE_DETAILS = 'ADD_STORE_DETAILS';\n//action creators\nexport const addStoreDetails = details => ({\n  type: ADD_STORE_DETAILS,\n  payload: details,\n});\nThanks for the help. sorry I posted the wrong actions code. The correct one is this:\n// action types\nexport const ADD_CUSTOMER = 'ADD_CUSTOMER'\nexport const ADD_TRANSACTION = 'ADD_TRANSACTION'\n// action creators\nexport const addCustomer = newCustomer =>({\n  type: ADD_CUSTOMER,\n  payload: newCustomer\n})\n```. Yeah, I was using snack.expo to work on my app, which does not support react persist. I switched to expo-cli and it started working. ",
    "iigorg": "Hi! Did you resolve the issue? I have the same problem(((. thank you very much. ",
    "rafael-garcia": "Any news on this issue?\nI've got a pretty similar stack and when I disable Javascript, to test SEO on my landing page, PersistGate keeps the component I pass as the loading props on screen at all times:\n<PersistGate persistor={getPersistor()} loading={loadingComponent}>\nThe persistor is set in another class that just deals with Redux, thus the getPersistor().\nI'd expect that when JS isn't available, the PersistGate would only be bypassed.. @aguynamedben Sorry for the delay.\nYes, I'm also using Next.JS, currently version 7.0.x.\nWhat I've tried to do was a check @ getInitialProps if it's a client or server request, and then avoid PersistGate rendering if the latter case.\nBut that ended up messing my navigation through the pages in some specific cases, and I've dropped that and the investigation itself.\nSorry if I couldn't help with lots of details, it's been a month and we decided to proceed even without SSR fully working with JS disabled.. ",
    "bmtdh": "I have this problem as well with the same setup. SSR doesn't work at all when using Redux persist. As soon as you take the  out it works as expected.\nIs there a way to use redux-persist and keep SSR?. ",
    "carlomazzaferro": "Probably this is the current best bet: https://github.com/redux-offline/redux-offline. ",
    "mefjuu": "Glad to hear it, rt2zz. Can't wait for repository revival :). ",
    "hadigoh": "@aguynamedben Yes that should fix this issue :+1: . ",
    "kreba": "@thenewt15 I realize that you added the relevant bits in the README with a PR that you reference from said blog post. Is it ok for you if I continue the work on this topic or would you prefer to do it yourself? I'll gladly do it but I don't want to steal the show.. ",
    "farskid": "Any updates on this? can I help to review this in order to speed it up?. ",
    "ducanh2110": "IThanks for your support @aguynamedben but it's a private repo. But I have figure the problem I had. First, I think's the data I save to storage is too big that make the browser lag. Second, I dispatched so many actions every time 1 image uploaded temporarily. At this time I need to do something like persistore.flush(() =>> {...}) but it still can save some small thumbUrl with base64 to storage. With some big image (> 2MB) can't save.. ",
    "sandinosaso": "Can confirm this. I am seeing this exact behavior using 5.10.0. ",
    "dereknelson": "I would love a #redux-persist reactiflux channel!\nMaybe we we could highlight known issues? I spent a while combing through documentation trying to figure out why my state refused to persist on android - it was only after reading through a number of different open issues was I made aware that persisting stores larger than a certain size just won't cooperate with AsyncStorage on android. If I'd read that somewhere I would've either\nA. been way more careful with what I persist\nB. fixed it by using one of the workarounds out there way sooner \nbut it was the kind of error that fails silently in a way. ",
    "ninjacarr": "For anyone searching error messages: this provides a way to deal with the Error storing data message seen in console.. ",
    "schallerala": "Did you try it out by disabling the local storage in Google Chrome for example? (Going into its settings and disabling cookies (therefore local storage) for that particular site, what will throw an error when trying to access window.localStorage)\nBecause, when I tried using writeFailHandler, it didn't do anything.\nThe reason is because the getStorage returns a noopStorage when hasStorage fails. noopStorage that will never fail when used inside the Promise.. ",
    "enisinanaj": "strange how this example I made https://github.com/enisinanaj/rn-sample-app works perfectly as expected... \nwas actually using const persistedReducer = persistReducer(persistConfig, AllReducers) instead of const persistedReducer = persistCombineReducers(persistConfig, AllReducers) but even after changing that it doesn't work.. So I added a simple reducer / action and attached it to my app, the same App described above. I got this code from another standalone project I created earlier which was working fine.\nThis part, the FriendReducer continued to work fine while my reducers described above were still not working.\nFinally I added the following case in the reducer to restore my application state. For some reason it was not doing it on its own.\ncase 'persist/REHYDRATE':\n   //rehydrating userStore to app\n   newState = { ...action.payload.userStore\u00a0}\n   return newState\n",
    "bohdan145": "Because in my application(chatting app) i store messages locally, but what if messages was changed when i was offline ? (like deleted or changed text). How do i know that i need to delete my local message or change it to be the same as server version?. ",
    "cvanem": "@bohdan145 It might not be the best way, but I believe you can just intercept the 'persist/REHYDRATE' action for your desired store(s).  In your store's reducer you can either return the hydrated payload or your original state.  Inside your desired reducer you would add something like this:\ncase 'persist/REHYDRATE':\n  const payload = (action as any).payload;\n  const shouldHydrate = false; //or true\n  const newState = shouldHydrate ? payload.myStore : state;      \n  return {\n    ...newState,\n  };\n\nThat would at least allow you to prevent hydration based on your internet connection.  I'm sure there is a way to re-trigger the hydration logic once the internet is restored although I am not sure how.  Maybe you can dispatch the REHYDRATE action or re-initialize the persistor to accomplish this.\n. @leoek I think you can accomplish what you need by ignoring the initial hydration and then manually re-hydrating using getStoredState.  \nOnce you have the state you can dispatch the necessary actions to update your app state as needed.  If you use my example above you could dispatch 'persist/REHYDRATE' with shouldHydrate set to true and include the data from getStoredState in the dispatched action.\nIf that doesn't work for whatever reason, another idea would be to delay the persistor initialization and adding the persistedReducer to your store until your storage is initialized.  That seems like it should work in theory, but might get messy.. ",
    "leoek": "Hi I am interested in this as well. I need to stall the rehydration until my storage is initialized, which can only be done after the user entered a password which will be used for file level decryption in the implementation of the storage.. @aguynamedben Do you have any ideas whether this is possible or not, or who might now?. @cvanem Thank you for the suggestion. This seems like a viable option. In theory I only need to encrypt parts of the state i am persisting and I should be able to use multiple persistors. One configured like this:\nconst persistConfig = {\n  key: \"root\",\n  storage: FSStorage(),\n  whitelist: [\"some\", \"key\"],\n  transforms: []\n};\nand one for each encrypted reducer which is initialized later, configured like this:\nconst encryptedPersistConfig = {\n  key: \"encryptPart\",\n  storage: FSStorage(<credentials which are not available at startup>),\n  transforms: []\n};\nAre there any cave hats with the usage of multiple persistors, you know of? . @aguynamedben Can we get this merged please? There are no compatibility issues with previous version. . ",
    "kareemsalah227": "@aguynamedben Sure thing sir, I'll prepare it and share with you the links shortly, so sorry for the long time not replying you.. @aguynamedben I'm back, sorry for the delay again, here's a link to a mini-project and a small brief to reproduce the issue, it's not that complicated.\nhttps://github.com/kareemsalah227/redux-persist-issue\nThe code inside might look a bit weird, it's because I'm working on a highly configurable, mono-repo project, I borrowed some stuff from there to make things faster.\nPlease let me know if you need anything else, I'm happy to help.. I only have a quick comment, correct me if I'm wrong please.\nYou can provide a loading component or you can ignore it, so it's kind of \"optional\", I think this might be the reason it was set optional in the flow type? If that is the case, is there another solution to make it optional and get rid of the flow error? (maybe by providing a default value or something).\nPlease let me know what do you think.. Actually there is, I'll create a quick PR for that.... Ops, looks like I don't have permissions to push a branch to the repo, what should I do? @erksch . Nevermind, I've never contributed to an open source repo before, pardon my ignorance.\nI forked the repo and created a cross-repo PR.\nhttps://github.com/rt2zz/redux-persist/pull/975\nThere's a decent description in there, let me know what do you think @erksch .. Good to hear, I'm happy to help :). You're right, I take that back.\nI just thought for a moment that this should be the parent component's responsibility to pass in default values for props, but that contradicts with the \"optional props\" concept.\nYou're right, ma bad, I owe you a :beer:. Agreed :). @erksch Sure thing, I'm currently out of home, will be back in a day or so, I hope this is not time critical.. Yes I totally agree with you, I did mention that in the important comment section on the description, this should be Facebook's Flow work, not to be done here.\nI'll try to take a look on Facebook's Flow repo and I might be able to make a good contribution.. ",
    "bluebill1049": "Hi @rt2zz , could we please release another version to fix the flowtype? thanks. ",
    "jamievicary": "Thanks Elzup.. ",
    "ndejesus1227": "Still having issues with this. I don't think the functions inside the migrations object are being called at all. ",
    "scott1028": "Sometime I want to persist function in store of redux even if I reload the browser, so I modified the config object to accept customizing serializer/deserializer, such as using serialize-javascript. How about this? It also supports default value when user didn't pass anything. also I will do in config.deserialize.\njs\nlet serialize;\nif (!config.serialize) {\n  serialize = defaultSerialize;\n} else if (typeof config.serialize === 'function') {\n  serialize = config.serialize;\n} else {\n  serialize = x => x;\n}\nBut I don't know the cause why multiple condition if-statement is better than two if-statement. If you can tell me I will appreciate it. I guess maybe performance or compile optimization.. Also same as above.\njs\nlet deserialize;\nif (!config.deserialize) {\n  deserialize = defaultDeserialize;\n} else if (typeof config.deserialize === 'function') {\n  deserialize = config.deserialize;\n} else {\n  deserialize = x => x;\n}\n. OK, It should be exactly same.\n. ",
    "Deadarius": "Please, desperately need this in. ",
    "jakubdrabik": "I've ended up using the nested persistence without the root one because I wasn't able to make the migrations work and I don't really understand what's the root one for - it's just duplicating data in the storage. Am I missing something? . ",
    "gooddaddy": "@saadpasta Did you resolved it?. ",
    "saadpasta": "it was wrong from my end I was pushing something in redux and clearing storage that's why it was not clearing local storage.. ",
    "Bradzer": "@erksch\n I followed what you said and the error is gone.\nHowever, when the state is changed the screen doesn't render again.\nIt's only when I reload the app that I can see the changes.\nAny way to fix that ?. ",
    "SDxBacon": "Key _65 looks very similar when you are trying to access a unresolved promise object. I always get an object with value:{\"_40\": 0, \"_65\":0, \"_56\":null, \"_72\": null} if I forgot to use await or .then to wait the asynchronous function be resolved.\ni.e. \nlet resp = fetch('https://newsapi.org/v1/articles?source=cnn&apiKey=c39a26d9c12f48dba2a5c00e35684ecc');\nconsole.warn(resp); // then my device will log {\"_40\": 0, \"_65\":0, \"_56\":null, \"_72\": null}. ",
    "nwaughachukwuma": "Thanks @SDxBacon, after closely monitoring my code, I discovered I had declared  persistStore(store) after a store.subscribe observer which has setTimeout within it.\nAfter adjusting the declarations, the issue was taken care of.. ",
    "isaaclem": "My bad, the problem is with the import statement at App.js\nWrong\nimport { store, persistor } from './configureStore'\nCorrect\n```\nimport Store from './configureStore';\n\n...\n```. ",
    "km-tr": "redux-persist - npm\n@Andarist You are a collaborator, can you publish?. ",
    "Christopotamus": "Thanks @erksch your version works for me as well.\n @rt2zz \nHope we can get a new release soon.. ",
    "Genuifx": "thank you very much:smile:. ",
    "ZechyW": "Are you using redux-starter-kit?  It looks like the message is caused by the included serializable-state-invariant-middleware (https://redux-starter-kit.js.org/api/getdefaultmiddleware).\nAs far as I can tell, passing the register and rehydrate functions in the action is central to how redux-persist currently works, but the message can be suppressed by modifying the store configuration to not include that particular middleware function.. ",
    "rseemann": "That is exactly what is going on. Further investigating I noticed this in the default middleware. I'll just remove the middleware, since it's not really essential to what I'm doing.\nCheers!. @SeedyROM I removed the getDefaultMiddleware from the list of middlewares. There is no real fix there, it is a problem between opinions. The serializable-state-invariant-middleware complains when it sees a non-serializable object, a function in this case, being passed as an action; redux-persist needs to do so. Sometimes you just have to pick a side \ud83e\udd37\u200d\u2640\ufe0f .\nAnyway, here's my configureStore.\nconst store = configureStore({\n  reducer: rootReducer,\n  middleware: [thunk, logger]\n}). @SeedyROM I'm using them as they come, no custom config.\nimport logger from 'redux-logger'\nimport thunk from 'redux-thunk'\nYou might have to install those yourself, although I believe redux-starter-kit will have them already, I think it is better to have more atomic dependencies.\nAbout the PersistGate error you mentioned, I never saw this, I'm sorry. Also, don't code while sleepy, man! hahaha. ",
    "SeedyROM": "@rseemann How exactly did you solve this? Please post your configureStore function.. @rseemann Where exactly are you getting thunk and logger from, I saw that in the documentation but I was a little bit lost. Did you manually configure them both? \nStill a redux noob! Sorry!. @rseemann I was also having issues with PersistGate never rendering, did you run into anything of the sort? I know this probably isn't the place to ask this, but I'm sleepy and desperate.. @rseemann I figured that was what was needed, but I wanted to make sure instead of battling against some configuration misunderstanding.\nYeah the PersistGate issue is strange, I'll figure it out in the morning. I don't normally do professional work this late, but dead lines my dude. lol (Don't worry, I'm quarantined in a feature branch haha)\n:rocket: Thanks for the help. .",
    "jrmartinez96": "It finally works. Just to give a little bit of context, I am using Redux, Redux-saga, and React-router-dom. I found out that it didn't \"saved\" the new state when a  redirected to another route. At the end I used persistor.flush() in a saga and it started to work fine.. ",
    "joalpeca1": "React since version 16.3.0 is recommending to use this static function  \"getDerivedStateFromProps\" instead of  \"componentWillReceiveProps\", I made that change and start working as I want it.. ",
    "retyui": "example:\njs\nredux-persist/createPersistoid: Data value(s) will serialize to string:\n{\n    .articles.id_1.createTime: \"Wed Feb 27 2019 18:01:00 GMT+0300 (\u041c\u043e\u0441\u043a\u0432\u0430, \u0441\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u043d\u043e\u0435 \u0432\u0440\u0435\u043c\u044f)\",\n    .articles.id_2.createTime: \"Wed Feb 27 2019 18:01:00 GMT+0300 (\u041c\u043e\u0441\u043a\u0432\u0430, \u0441\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u043d\u043e\u0435 \u0432\u0440\u0435\u043c\u044f)\"\n}. ",
    "IlyaRepo": "Realized it's in data/data/[app]/databases/RKStorage. ",
    "Xyzor": "I solved this issue.\nDetails can be found here. ",
    "matheus-rosin": "I tried something based on this and got this thing working. Here is how it looks like:\n```javascript\n// store.js\nimport { createStore, applyMiddleware } from 'redux';\nimport thunk from 'redux-thunk';\nimport { createLogger } from 'redux-logger';\nimport rootReducer from './reducers';\nimport * as initialState from './initialState';\nconst middlewares = [thunk];\nif (process.env.NODE_ENV !== 'production') {\n  middlewares.push(createLogger());\n}\nfunction makeConfiguredStore(reducer, initialState) {\n  return createStore(\n    reducer,\n    initialState,\n    applyMiddleware(...middlewares),\n  );\n}\nexport function initializeStore(initial = initialState, isServer) {\n  if (isServer) {\n    // if is server, return just store -- not even import redux-persist stuff\n    return {\n      store: makeConfiguredStore(rootReducer, initial),\n    };\n  }\nconst { persistReducer, persistStore } = require('redux-persist');\n  const createEncryptor = require('redux-persist-transform-encrypt').default;\n  const storage = require('localforage');\nconst encryptor = createEncryptor({\n    secretKey: process.env.reduxPersistEncryptorSecretKey,\n  });\nconst persistedReducer = persistReducer({\n    key: 'some-key',\n    storage,\n    transforms: [encryptor],\n    blacklist: ['_persist'],\n  }, rootReducer);\nlet store = makeConfiguredStore(persistedReducer, initial);\n  let persistor = persistStore(store);\nreturn { store, persistor };\n}\n```\n```javascript\n// stateHOC.js\nimport { Component } from 'react';\nimport { initializeStore } from './store';\nconst isServer = typeof window === 'undefined';\nconst NEXT_REDUX = 'NEXT_REDUX';\nfunction getOrCreateStore(state) {\n  // note line below\n  if (isServer) return initializeStore(state, isServer);\nif (!window[NEXT_REDUX]) {\n    // note line below\n    window[NEXT_REDUX] = initializeStore(state, isServer);\n  }\n  return window[NEXT_REDUX];\n}\nexport default (App) => {\n  return class extends Component {\n    static async getInitialProps(appContext) {\n      const { store, persistor } = getOrCreateStore();\n      appContext.ctx.reduxStore = store;\n      appContext.ctx.reduxPersistor = persistor;\n  let appProps = {};\n  if (App.getInitialProps) {\n    appProps = await App.getInitialProps(appContext);\n  }\n\n  return {\n    ...appProps,\n    initialState: store.getState(),\n  };\n}\n\nconstructor(props) {\n  super(props);\n  let { store, persistor } = getOrCreateStore(props.initialState);\n  this.reduxStore = store;\n  this.reduxPersistor = persistor;\n}\n\nrender() {\n  return (\n    <App\n      {...this.props}\n      reduxStore={this.reduxStore}\n      reduxPersistor={this.reduxPersistor}\n    />\n  );\n}\n\n}\n};\n```\nThis skips redux-persist on server; and somehow, it just works.. ",
    "davidjbradshaw": "Why not just use <Suspense />?. ",
    "reinierv4": "Nice I need this. Anyway to pass just the action as an additional argument to the persistStore instead? So store.dispatch(myAction) and pass myAction on as a third argument to the persistStore. Which is then dispatched after the rehydration has finished. ",
    "FibreFoX": "You might want to have some kind of \"loading\"-scene as part of loading=. Did you try using anything else than null?\n```jsx\nimport React from 'react';\nimport { View, ActivityIndicator, SafeAreaView } from 'react-native';\nexport class ApplicationLoadingScreen extends React.Component {\n    render() {\n        return (\n                \n\n\n        );\n    }\n}\n```\nWe are using react-navigation and are managing that \"already logged in\"-switch as part of the onBeforeLift-method. As the first scene inside a SwitchNavigator-stack we included that same loading-scene as initialRouteName. This makes the app starting with the loading-scene (shown through the PersistGate), then being shown as part of the SwitchNavigator-stack, then switched to the login-screen or the \"inside\"-part afterwards.\nMaybe this helps a bit.. ",
    "rajatbarman": "To those looking for solution.\nDon't use <PersistGate /> wrapper, instead wrap this logic over ReactDOM.hydrate\n```\npersistor.subscribe(() => {\n          / Hydrate React components when persistor has synced with redux store /\n          const { bootstrapped } = persistor.getState();\n      if (bootstrapped) {\n          ReactDOM.hydrate(\n              <MyEntireApp />,\n              document.getElementById(\"appOrWhatever\")\n        );\n      }\n    });\n\n```. ",
    "scotchapman": "I had issues with let currentState = stateGetter(state, key) getting a stale state.\nThis worked for me: let currentState = stateGetter(store.getState(), key)\nI'm not sure if it was because of this or something else:\n\nThe listener should not expect to see all state changes, as the state might have been updated multiple times during a nested dispatch() before the listener is called. It is, however, guaranteed that all subscribers registered before the dispatch() started will be called with the latest state by the time it exits.\n\nhttp://redux.js.org/docs/api/Store.html#subscribe. ",
    "randycoulman": "I love Prettier, and using lint-staged here is super handy for contributors.  But be aware that this recipe can be very surprising if someone has used git add -p: any file that gets reformatted will become part of the commit, even if it was only partially staged.  See https://github.com/okonet/lint-staged/pull/75 for details.. For now, I'm living with doing prettier --list-different in my pre-commit hook to fail the commit on unformatted files and then adding a format script to actually do the formatting. Not ideal, but better than surprising people IMO.. ",
    "robonaut": "Yes that\u2019s perfectly fine!. ",
    "GantMan": "Is this check for undefined coming in?. ",
    "sunnylqm": "This should at least return a copy of x to avoid breaking immutable objects? @rt2zz . ",
    "robinpokorny": "If it is never used, I'd just remove it.. "
}