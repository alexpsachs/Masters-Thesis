{
    "VojtechVitek": "Closing this PR -- I don't think we need this anymore, since Timeout and CloseNotify close their contexts in defer functions, which is imho the correct behavior.\n. LGTM. Thanks for your contribution!\n. Even though I really like Makefiles for larger projects, I don't think it's necessary for project like chi. Is there any other simple router out there with Makefile?\nWe can run go build, go test or go fmt directly in the single directory. There's no hidden magic that'd require us to run make. Thoughts?\n. This is very useful, thanks for your contribution!\nLet's see what others think of #7 first. Can you reference CONTRIBUTING.md from README.md as well?\n. LGTM, besides the minor comments. Thanks for your contribution!\n. @pkieltyka btw: I can't think of any reason why we'd need ctx inside of NotFound handler. Is there any?\n. @pkieltyka I'm not 100% convinced that ctx is useful here. If the router doesn't find any matching route -- then there's no context whatsoever, is it? This 404 handler represents \"route not found\", which is a different thing than end-handler's \"resource not found\" (which has ctx of course). We're not trying to solve the latter one.\nI think that all the sub-routers should inherit their parent's NotFound handler. Thinking of it... I'd actually prefer doing pkg-wide global variable instead of putting the NotFound handler into every Mux. This would be very close to stdlib's http.NotFound - lightweight, but configurable.\nSomething like:\nchi.go:\ngo\nvar NotFound func(w http.ResponseWriter, r *http.Request) = http.NotFound // defaults to stdlib's NotFound\nusers-end-handler.go:\ngo\nchi.NotFound = MyNotFoundHandler // router 404 will serve this handler instead\n. @utrack can you change it to panic() instead?\n. LGTM. Thanks for your contribution!\n. @gdm85 @GeertJohan Logger should be used before Recoverer -- Recoverer responds with HTTP 500 and Logger should be able to pick this value up. If you reverse the order, Logger won't know the status code.\nLogger logs requests and responses. Recoverer prints panic+stack, as it is a critical error. I think of it as Apache's Access Log vs. Error Log.\n. Nice, this is so much better now. Thanks!\n. LGTM\n. Since I'm not overwriting the parent /foo path in the subrouter, I'd expect it to be matched and served anyways. Consider applying different middlewares for anonymous and auth'd routes from the parent router:\n``` go\nfunc main() {\n    r := chi.NewRouter()\nr.Group(func(r chi.Router) {\n    r.Use(InjectAnonymousToken)\n\n    r.Get(\"/\", PublicRoutes())\n})\n\nr.Group(func(r chi.Router) {\n    r.Use(TokenRefresh)\n    r.Use(Authenticator)\n\n    r.Mount(\"/\", AuthRoutes())\n})\n\nhttp.ListenAndServe(\":3333\", r)\n\n}\n```\nIt would be nice to be able to \"merge\" subrouters having a common root path.\n. Another example:\n1. THIS WORKS (subrouter first, GetHandler route merges into the routes):\n``` go\nfunc main() {\n    r := chi.NewRouter()\n// Auth'd routes\nr.Group(func(r chi.Router) {\n    r.Use(TokenRefresh)\n    r.Use(Authenticator)\n\n    r.Mount(\"/\", AuthRoutes())\n})\n\n// Public routes\nr.Group(func(r chi.Router) {\n    r.Use(InjectAnonymousToken)\n\n    r.Get(\"/\", GetHandler)\n})\n\nhttp.ListenAndServe(\":3333\", r)\n\n}\n```\n2) THIS DOESN'T WORK (subrouter second, it overrides the GetHandler route w/o merge):\n``` go\nfunc main() {\n    r := chi.NewRouter()\n// Public routes\nr.Group(func(r chi.Router) {\n    r.Use(InjectAnonymousToken)\n\n    r.Get(\"/\", GetHandler)\n})\n\n// Auth'd routes\nr.Group(func(r chi.Router) {\n    r.Use(TokenRefresh)\n    r.Use(Authenticator)\n\n    r.Mount(\"/\", AuthRoutes())\n})\n\nhttp.ListenAndServe(\":3333\", r)\n\n}\n```\n. @hmgle thanks for the investigation and really interesting benchmarks!\nI think having fork for fasthttp would be the best option here right now, though.\nWe're really excited about Go 1.7's built-in context, which will allow us to simplify chi, remove interface{} args and use the standard http.Handler signatures:\ngo\nfunc Handler(w http.ResponseWriter, r *http.Request) {\n   user, ok := r.Context().Value(\"user\")\n   // do something\n})\nPlease, check out https://github.com/pressly/chi/tree/v2 branch.\n\nIf we were to support fasthttp and its custom signatures func(ctx context.Context, fctx *fasthttp.RequestCtx), we'd have to maintain a lot more again.\nFasthttp seems to be really fast, but I wonder about missing HTTP 2 support and Go 1.7's request context.\nWe may have fasthttp as a chi subpkg one day. But I doubt it could happen anytime soon because of maintainability issues.\n``` go\nimport \"github.com/pressly/chi/fasthttp\nfunc main() {\n  r := chi.NewRouter()\nr.Get(\"/\", func(ctx context.Context, fctx *fasthttp.RequestCtx) {\n    w.Write([]byte(\"hi\"))\n  })\nhttp.ListenAndServe(\":3333\", r)\n}\n```\n. Let's discuss in #48.\n. Closing this PR and will open new one against v2.\n. @Vektah thanks for the interesting benchmark results!\n. @november-eleven I reviewed this PR too. There is some really good code!\nHowever, after some considerations, I also feel like we should keep the default logger middleware as simple as possible and it should just write to STDOUT in respect to Docker, syslog etc. Even though multiple backend is certainly good idea, I don't think that LogEntry struct would be flexible enough, since one cannot store custom values into it - for example data from the Context chain (go1.7's r.Context()), ie. session, user_id and other app-specific data/metrics.\ngoware Org would be a perfect place for this :)\nAnyway, thank you again for your PR, we really appreciate it!\n. We should discuss the Graceful Shutdown workflow:\nOn SIGINT/SIGTERM (or any other registered signal):\n1a. Close listening socket and refuse any incoming connections.\n1b. or .. Start responding with HTTP 503.\n2. Disable keep-alive connections (how about http2?).\n3. Start time.After(softTimeout) to let active requests finish.\n4. When softTimeout expires, close the root context. Start time.After(hardTimeout).\n5. Wait for all active requests to finish (middleware adding/removing value from channel or atomic.Uint64)\n6. When hardTimeout expires, exit program.\n- softTimeout lets active requests finish their work without closing the context chain\nI think all of the above except for 1a and 2 can be solved by middleware.\n. @pkieltyka gonna work on streaming right now :) io.Reader, channel etc.\n. @nhooyr it lets you present objects in a desired format (based on Accept header) and let's you version API responses. Check this example: https://github.com/pressly/chi/tree/v2_presenter/_examples/render\nDoes this answer your Q?\n. \ud83d\udc4d \n. can we panic()?. test case:\nhttps://github.com/pressly/chi/pull/64/commits/baa2aaa23447b035875e066e7e7bdcdc9838e183\n. LGTM\n. @msaron nice. I'd be interested in tag-based validator. There might be some projects like this out there, but I don't know them.\nFor example:\ngo\ntype UserRequest struct {\n    Name      string `validate:\"maxlen=50\"`\n    Username  string `validate:\"maxlen=20\" validate:\"regexp=^[a-z0-9]+$\"`\n    Email     string `validate:\"email\"`\n    AvatarURL string `validate:\"url\"`\n    Age       int    `validate:\"min=13\" validate:\"max=120\"`\n}. @msaron anything with third party dependency (like github.com/gocarina/gocsv above) can't make it into chi.. @msaron I see. Well, we accept Pull Requests. But one thing to be aware of: We tend to keep chi very minimal. And imho, CSV dependency is pretty big, even for render pkg.. @zbindenren I'll finish this PR in the upcoming days.. Update: We're still discussing the internals, since the Walk() function, as proposed in this PR, is quite similar to walk() function used internally in the mux.. Superseded by https://github.com/go-chi/chi/pull/222 and a subsequent work in https://github.com/go-chi/docgen. I was thinking about custom context types:\ngo\nctx := &MyCustomAppContext{} // implements context.Context interface\nrouter := chi.NewRouter(ctx)\n``` go\nfunc Handler(w http.ResponseWriter, r http.Request) {\n  ctx := r.Context().(MyCustomAppContext)\n// I can use custom methods/helpers defined on the *MyCustomAppContext type now..\n  // this means... saving a lot of boiler plate and type conversions \n  sessionUser := ctx.SessionUser()\nsession := ctx.Session() // instead of session, ok := ctx.Value(\"session\").(*Session)\ndb := ctx.DBSession() // DB connection assigned from a middleware?\nw.Write([]byte(\"yay\"))\n}\n```\n. This is awesome. \ud83d\udc4d \nBut before we merge, I'd like to discuss the LogFormatter interface. I will take a closer look later today / tmrw.\n. https://github.com/GoogleCloudPlatform/google-cloud-go/issues/312\n. Actually, I just realized that this PR reimplements Negroni middleware func signatures. Lol.\nSo all of these middlewares come for free:\nhttps://github.com/urfave/negroni#third-party-middleware\n. I see, I didn't test this properly without the Logger middleware applied when I was writing this middleware a year ago.\nWhat happens:\nWhen the handler writes some headers and body to the response writer and then the client closes the connection, this middleware tries to write the header again, which is wrong. The Logger middleware used to catch the extra header write (I'm not sure if it still does that after the recent Logger middleware changes) and also prints [disconnected] at https://github.com/pressly/chi/blob/badf07aee0a9a24f6cffe7acb5c76b2a3bcbdf35/middleware/logger.go#L103 based on the status code. \nLet's just remove this line \nhttps://github.com/pressly/chi/blob/master/middleware/closenotify.go#L32 and also make it // +build go1.7, since it won't work properly in go 1.8 anyway since the stdlib started to close the context when client disconnects.. Just to clarify: The underlying log prints the timestamps. See https://golang.org/pkg/log/#pkg-constants. @EmielM yes, you should use either groups or sub-routers.. You can even pass multiple middlewares to r.Use().\n```go\nr.Group(func(r chi.Router) {\n    r.Use(Level0Ctx)\n    r.Post(\"/level0\", Level0POST)\n})\nr.Group(func(r chi.Router) {\n    r.Use(Level0Ctx, Level1Ctx)\n    r.Post(\"/level1\", Level1POST)\n})\nr.Group(func(r chi.Router) {\n    r.Use(Level0Ctx, Level1Ctx, Level2Ctx)\n    r.Post(\"/level2\", Level2POST)\n})\n```. @jutkko it'd be confusing.\ngo\nr.Use(Mw1)\nr.Get(\"/\", Handler1)\nr.Use(Mw2)\n..now, is the Mw2 middleware applied to Handler1 or not?\nWe prefer being explicit.. @EmielM you could use chi's With() method where Group() doesn't look readable:\n```go\nr.Get(\"/login\", Login)\nr.With(WithUser).Get(\"/x\", HandleX)\nr.Group(func(r chi.Router) {\n    r.Use(WithPlayer)\n    r.Get(\"/player/:playerID/details\", x)\n    r.Get(\"/player/:playerID/info\", x)\n})\nr.With(WithAdmin).Get(\"/stats\", HandleStats)\n```. See https://github.com/pressly/chi/issues/125#issuecomment-270416138 for ACL-middleware approach.. @pkieltyka I think we can release v2.0.0 after HTTP2 fixes.. Very nice catch! LGTM\nSeems like the lines 118 and 121 store more and more data into baseCtx on each run, since it was a local variable in the parent function scope.. btw: Same pattern is used in the Throttler middleware (see https://github.com/pressly/chi/blob/master/middleware/throttler.go#L36)\nI just wrote a simple use case, explaining the behavior, if you're interested: https://play.golang.org/p/wQXiuUgUKI. 1. func(next http.Handler) http.Handler is middleware type to be used in r.Use()\n2. http.Handler is handler type to be used in r.Get() etc.\n\nWhat's wrong with\ngo\nr.Use(middleware.Logger)\nr.Use(middleware.Timeout(time.Second))\n?. Sorry, we can't support Go 1.6, since the http.Request doesn't have Context at all.. Do you guys have full reproducer?. ReverseProxy is just a handler. It works.\nTry:\n```\nfunc ProxyHandler(w http.ResponseWriter, r *http.Request) {\n    url, _ := url.Parse(\"http://example.com/path/\")\nproxy := httputil.ReverseProxy{Director: func(r *http.Request) {\n    r.URL.Scheme = url.Scheme\n    r.URL.Host = url.Host\n    r.URL.Path = url.Path + r.URL.Path\n    r.Host = url.Host\n}}\nproxy.ServeHTTP(w, r)\n\n}\n``.{id}` works for me. @mvdan This Pull Request is low priority, since it doesn't really change chi functionality. Please, be patient.. > Change param syntax from /articles/:id to /articles/{id} which improves expressiveness and delimiting (#167)\nThis one is breaking change, that's why v3.. > Add support for regexp\n\n\nHow about adding an option to register a \"converter\" #167 (comment) and let people extend this?\n\n\nit's indeed interesting to have types defined in the route\n... but maybe we just need helpers like bookID, err := chi.URLParamInt64(r, \"bookID\"). @wutaizeng thanks for reporting this issue. Are you going to submit a PR?. middleware.Timeout(2 * time.Second) sets timeout on r.Context(). After the timeout is reached, the context is canceled. You need to pass this context to the underlying logic to leverage the cancelation functionality.\nSome examples:\n- select on multiple channels, if you can receive processed data via channel, as in example code\n- HTTP request https://golang.org/pkg/net/http/#Request.WithContext\n- SQL query https://golang.org/pkg/database/sql/#DB.QueryContext\n- pass the ctx as a first argument to the underlying functions, so you can listen on ctx.Done()\n     func HeavyWork(ctx context.Context, ...). Try to get the filename from r.URL.Path request path.\nhttp.FileServer() doesn't implement anything that would give you better hints on the route/file itself.. Imho, you can still use custom handler's http.HandlerFunc explicitly:\ngo\nr := chi.NewRouter()\nr.Get(\"/\", appHandler{context, IndexHandler}.ServeHTTP). Try r.Use(middleware.DefaultCompress). Pls provide full example code. r.Use(middleware.DefaultCompress) should work.. @pkieltyka sounds good to me, we can remove it for v3.0 and provide an example instead.\n\n@kuronyago you'd have to set Content-Type header, so the Compress middleware knows whether it can compress the payload or not.\ngo\nfunc mainpage(w http.ResponseWriter, r *http.Request) {\n    w.Header().Set(\"Content-Type\", \"text/html\") // will be compressed, since it's in https://github.com/pressly/chi/blob/5b7406a71dbb35d4f59b0b48e68cd9f9256f5262/middleware/compress.go#L22-L32\n    tpl.ExecuteTemplate(w, \"mainpage.tpl\", nil)\n}\nAnd same for the r.FileServer(), it would have to set the Content-Type header accordingly. Not sure what happens under the hood by default.. SGTM. Warning: I plan to break the API in the new docgen pkg.. TestWalker walks bigMux() router and prints method+route for each entry.\n=== RUN   TestWalker\n--- PASS: TestWalker (0.00s)\n    tree_test.go:433: GET /\n    tree_test.go:433: GET /favicon.ico\n    tree_test.go:433: GET /folders/*/\n    tree_test.go:433: GET /folders/*/public\n    tree_test.go:433: GET /hubs/{hubID}/view\n    tree_test.go:433: GET /hubs/{hubID}/view/*\n    tree_test.go:433: POST /hubs/{hubSlug}/view/*\n    tree_test.go:433: GET /hubs/*/{hubID}/*/\n    tree_test.go:433: GET /hubs/*/{hubID}/*/posts/*/\n    tree_test.go:433: GET /hubs/*/{hubID}/*/touch\n    tree_test.go:433: PATCH /hubs/*/{hubID}/*/webhooks/*\n    tree_test.go:433: POST /hubs/*/{hubID}/*/webhooks/*\n    tree_test.go:433: HEAD /hubs/*/{hubID}/*/webhooks/*\n    tree_test.go:433: GET /hubs/*/{hubID}/*/webhooks/*\n    tree_test.go:433: LINK /hubs/*/{hubID}/*/webhooks/*\n    tree_test.go:433: DELETE /hubs/*/{hubID}/*/webhooks/*\n    tree_test.go:433: UNLINK /hubs/*/{hubID}/*/webhooks/*\n    tree_test.go:433: TRACE /hubs/*/{hubID}/*/webhooks/*\n    tree_test.go:433: PUT /hubs/*/{hubID}/*/webhooks/*\n    tree_test.go:433: CONNECT /hubs/*/{hubID}/*/webhooks/*\n    tree_test.go:433: OPTIONS /hubs/*/{hubID}/*/webhooks/*\n    tree_test.go:433: GET /suggestions\n    tree_test.go:433: GET /woot/{wootID}/*\nPASS\nok      github.com/go-chi/chi   0.011s. The asterisk most likely represents a subrouter.. Work in progress ;). I'm working on RAML docgen right now for https://github.com/go-chi/docgen. Please open a new issue in the new project.\nSwagger/OpenAPI format is very similar, it shouldn't be that hard to tweak the code once I have it working.. we can't help you if you don't provide full reproducers. @mrbanzai nice catch! We'll be happy to accept Pull Request based on https://github.com/mrbanzai/chi/commit/9936a163a79d1ea4c634554c97bf38833fb403cf. If we do the automatic HEAD response, should we also think of having something similar for OPTIONS?. Another approach:\ngo\nr := chi.NewRouter()\nr.Use(HeadForceEmptyBody)\nr.GetHead(\"/handler\", MyHandler) // both HEAD and GET\ngo\nfunc HeadForceEmptyBody(next http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n                if r.Method == \"HEAD\" {\n                    w = middleware.NewWrapResponseWriter(ioutil.Discard, 1)\n                }\n        next.ServeHTTP(w, r)\n    })\n}. The code was just off top of my head, sorry. This should work, tho:\n```go\ntype discardResponseWriter struct {\n    http.ResponseWriter\n    discard io.Writer\n}\nfunc (w *discardResponseWriter) Write(p []byte) (int, error) { return w.discard.Write(p) }\nfunc NewDiscardResponseWriter(w http.ResponseWriter) http.ResponseWriter {\n    drw := &discardResponseWriter{\n        ResponseWriter: w,\n        discard:        ioutil.Discard,\n    }\n    return middleware.NewWrapResponseWriter(drw, 1)\n}\nfunc HeadForceEmptyBody(next http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        if r.Method == \"HEAD\" {\n            next.ServeHTTP(NewDiscardResponseWriter(w), r)\n            return\n        }\n        next.ServeHTTP(w, r)\n    })\n}\n```. > It doesn't work by default either. You still have to have defined .Head() route. \nOf course, that's why I used r.GetHead(), as a prototype.\n\nBut if you have it, Go's standard library do all necessary work for trimming Body.\n\nReally? That's great, I didn't know that.. I like both #248 and #249 solutions. But imho, I'm leaning towards the Middleware approach.\n#248 - Middleware approach\nFindHandler() is something that might be very powerful for lot more use cases, where you can change the route dynamically based on request and/or context. However, it can introduce endless routing loop if used incorrectly. Do you guys have any more use cases where this could be useful?\ngo\nfunc FindHandler(rctx *Context, method, path string) http.Handler\nDo we need to pass context into the function? And why?\nI'm thinking of another use case that could be useful in tests and/or docgen. Take a look at this signature:\ngo\nfunc Find(method, route string) (http.Handler, ...func(http.Handler) http.Handler)\nit would be more consistent with chi.Walk() and you could for example use it in your tests to get list of middlewares for a specific endpoint, ie. to check if you applied some ACL middleware. That could be very handy.\n#249 - Config approach\nThe Config approach is very simple and elegant in this context. However, once we introduce Config, we'd probably end up adding more and more setting fields into it, effectively making the API more complex with each such release. I like the simplicity of chi at this moment and I'm asking myself a question - do we need Config in the long run - or can we live without it and keep making strict decisions?\nHow would Config work with sub-routers, by the way? Would we need to pass the same Config when initializing the sub-routers? Or is the root Config propagated down the chain somehow automatically?. @KenjiTakahashi I suggest parsing any slashes in a handler.\nie. route /{bucket}/* to a handler.. and parse the {key} inside of the handler function. Slashes are the main separator character in REST APIs. By design.\nMatching multiple/path/parts into a single variable is an anti-pattern, and I don't think we should ever support it as a first class feature, since chi is meant to be as simple REST router as possible (chi: lightweight, idiomatic and composable router for building Go HTTP services).\nI think we should close this issue, unless someone comes up with a super simple and clean solution. But in my opinion, r.Handle(\"/{bucket}/*\", handleMultipleSlashesHandler) is the only solution we can really come up with. Maybe we can document it better in the README.md?. Imho you should have two chi routers, one for each API version.\nAnd then, have a simple multiplexer handler that routes to that specific router:\n```go\nfunc APIVersionRouter(w http.ResponseWriter, r *http.Request) {\n    switch  {\n        case strings.HasPrefix(r.Header.Get(\"Version\"), \"1.\"):\n             APIVersion1.ServeHTTP(w, r)\n    default:\n         APIVersion2.ServeHTTP(w, r)\n}\n\n}\n. Right on! \ud83d\udc4d . 1. Method receiver, as you just pointed out\n2. Pass the reference in the request Context\n3. Global reference. See https://github.com/go-chi/chi/issues/199#issuecomment-303135420.go\npackage main\nimport (\n    \"net/http\"\n\"github.com/go-chi/chi\"\n\n)\nfunc main() {\n    http.ListenAndServe(\":9876\", MyRouter())\n}\nfunc MyRouter() http.Handler {\n    r := chi.NewRouter()\nr.Get(\"/*\", func(w http.ResponseWriter, r *http.Request) {\n    w.Write([]byte(\"smt is here\"))\n})\n\nreturn r\n\n}\n```\n$ curl localhost:9876/path\nsmt is here\n$ curl localhost:9876/path/\nsmt is here\n$ curl localhost:9876/path/hey\nsmt is here. @hovhannest actually, I think I found your use-case with the sub-router:\nhttps://github.com/go-chi/chi/issues/260\nLet's follow up in this issue. Thanks!. @inancgumus you can see yourself in #259. Check Travis to see why.. Thanks for your time and guidance @ustrajunior!. \"cors middleware doesn't work with subgroup\" - does it work without subgroup for you?\nIf not, can you please submit issue at https://github.com/go-chi/cors instead?. @zet4 ping, this is still marked as [WIP]. Are you planning to finish this PR, or should we close?. As long, as it doesn't break anything for non-appengine users, I don't see reason why not ;). @polds wanna submit a PR?. Thanks for the report. Do you have a reproducer code?\nDo you plan to open a PR and provide a fix?. It's not necessary, but it's explicit :). @ehmo needs rebase.. Good catch. Thanks for the contribution!. I'm down. What do you think @pkieltyka?. So, as far as I understand, we need to stick with v3.x+incompatible version for now. We can't release go.mod and thus release a new github.com/go-chi/chi/v3 import path, until we're comfortable with breaking builds on Go versions that are not aware of Go modules (pre- 1.9.7 and 1.10.3).\nPersonally, I'm fine with that for a while.. Ref. #346 \nWe will add go.mod file eventually in v4.x.x version.\nWe don't want to add it to v3.x.x, since we don't want to break existing import paths (an extra /v3 suffix in both chi and middleware pkgs).\nFor now, chi will live on v3.x.x+incompatible versions.. We're going to add go.mod in chi v4 at #378.. #302 was rejected by the main chi author. He doesn't like the idea of changing the import paths because of Go modules support (ie. github.com/go-chi/chi/v4) and become a tech support for the confused chi users. So we're keeping it simple and chi stays on +incompatible flag for now.. What payload do you mean? Request or Response payload?\nWould be nice to have this configurable somehow. So one could toggle this on a specific route for example.. @pkieltyka I wouldn't mind filtering out /*/ paths in the Walk() func itself, since the star * is an implementation detail of the chi sub-routers. And Walk() is rather user-facing thing meant for documentation purposes etc. Thoughts?. This is indeed handy and we use something similar internally. I think this could be a nice standalone package, ie. https://github.com/go-chi/param.\n```go\n// import \"github.com/go-chi/param\"\ni, _ := param.Int64(r, \"id\")\nstr, _ := param.String(r, \"hash\")\n```\nThoughts?. yeah, it can rely on chi's context, why not. @lansana pls go ahead and hack on it on your Github profile\nI'd fork it to go-chi if it's MIT licensed and in a good shape after you're done :) Thanks!. Sure, go ahead, assuming @lansana is OK with that.\nI'd suggest having explicit\ni, _ := param.Int64(r, \"id\") and i, _ := param.QueryInt64(r, \"id\") rather than doing any magic.\nI don't think it's common to have the same key on both path route and query param anyway.. Hi, I'm back from vacation. I'll try to check out & test this PR in the upcoming week or two.. Sorry for delaying this. This is very good work! Thanks @polyfloyd\n\ud83c\udf89 LGTM too. I will test in production next week and report back.. @cskr I don't think we want to bump to v4.0 just because of vgo :) we gotta figure this out, or let the Go authors know that vgo sucks\nI tried a while ago.. see https://github.com/golang/go/issues/25967\nbtw: We can't assume people upgraded to go 1.10.3 and 1.9.7 .. we have to be backward compatible with older versions.. > Yeap, pre-go1.9.7 versions can use the project \"as is\", if they are on Unix, as commented above. I don't see a quick-win way for Windows users though.\nI don't think so. Afaik, the Unix users would have to switch to \"/v3\" suffix everywhere too, since the middleware package imports the \"suffixed\" github.com/go-chi/chi/v3. Without this change, this PR wouldn't really work \"as is\" in older versions than go 1.10.3 or go 1.9.7.\nSince this situation is very uncomfortable for both v2.0+ pkg authors and consumers, I suggest not to release a go.mod file, unless Go authors change their mind / figure this out .. or until we're comfortable supporting go 1.10.3+ or go 1.9.7+ only (I guess we'd have to wait at least for a stable go 1.12) or when we release v4.0.0 (which is not likely in the near future).\nFor now... vgo pioneers (including myself) will have to stick to the v0.0.0-DATE-HASH versions, since vgo is not friendly to Github packages that already released v2.0.0+ tags (see https://github.com/golang/go/issues/25967) :-(\ngo\nrequire(\n    \"github.com/go-chi/chi\" v0.0.0-20180202194135-e223a795a06a\n)\n(as suggested by @nicpottier in #302). From https://github.com/golang/go/issues/25967#issuecomment-403544533\n\nmvdan commented 4 hours ago\n@VojtechVitek how many Go versions do you need to support? With 1.9.7 and 1.10.3 now out, any project supporting up to the two last Go versions (which I think is a majority) should be able to switch to Go modules soon.\nThe only potential problem I see is people still using old minor releases like 1.10.2. This is why I'm holding off for a few weeks before porting my v2+ projects to Go modules. I'll probably do the switch once 1.11 is out, at which point backported support will have been out for two full months.\nIf you need to support the latest three major Go versions, waiting until 1.11 is out should also do the trick. This obviously doesn't scale past three major Go versions, but hopefully the set of v2+ packages with that constraint is very small.\nmyitcv commented 2 hours ago\n@VojtechVitek as @mvdan points out, if you are happy only supporting Go 1.9.7 (or later) and 1.10.3 (or later) from the 1.9.x and 1.10.x series respectively, and of course Go 1.11 and later, and your project is v >= 2, then you can safely convert your project to be a Go module. Otherwise you will hit issues with older Go versions not being able to handle the /vX in import paths.\nVojtechVitek commented a minute ago\nI'm not happy dropping support for Go <=1.10.2, <=1.9.6 and 1.8.x for a long long time. I'm talking year+, maybe until 1.12 is out.\nGo was always about backwards compatibility ... and now we just break stuff because vgo can't support the existing git tags properly .. and requires new \"module\" notation instead :(. https://github.com/go-chi/render exists. Your vgo is probably pulling chi v1.0.0 instead of latest v3.3.2. This is vgo problem.. See https://github.com/go-chi/chi/pull/327 and https://github.com/golang/go/issues/25967. note that v2.0.0 is old version that is not maintained anymore :). Try chi.Walk():\n\n```go\nwalkFunc := func(method string, route string, handler http.Handler, middlewares ...func(http.Handler) http.Handler) error {\n    fmt.Printf(\"%s %s\\n\", method, route)\n    return nil\n}\nif err := chi.Walk(r, walkFunc); err != nil {\n    fmt.Printf(\"Logging err: %s\\n\", err.Error())\n}\n```. Thanks! Can you please provide reproducer example and a diff or a Pull Request?. https://golang.org/pkg/text/template/ and https://golang.org/pkg/html/template/.\nI also highly recommend https://github.com/CloudyKit/jet, a super fast replacement for Handlebars in Go.. Duplicate of #307.. If you want to use older chi and its built-in chi/render (ie v2.x) but use newer chi/middleware (v3.x) at the same time, I suggest you create a fork from the old chi commit. No dependency manager can do this for you automatically.\nHowever, I strongly suggest to use the latest github.com/go-chi/chi and latest github.com/go-chi/render together. Is there anything in particular, that prevents you from switching?\nAlso, I'd recommend using go modules (introduced in go1.11), they work much better than dep.\n\nIt seems to me that some dependencies hasn't been fixed properly after separation\n\nWhat do you mean? Afaik, all dependencies work well.. POST and GET are the only two supported methods in HTML forms, afaik. I don't see what do you want us to document, can you elaborate?\nI recommend not changing the request method in your middleware chain. You might see some side effects eventually. Why don't you handle POST method instead?. > Ah, Vojtech you have a bit more to learn then.\n\ud83d\ude15 I'm confused about your tone.\n\nTo implement a PUT method in a form you specify the form\u2019s method as POST and then create a hidden input variable to indicate that the form data should be handled as a PUT operation. Here\u2019s an example\n\nIn your example, the browser sends a POST request via a <form> submission. So, from the REST perspective, this is POST request. The server just need to handle POST method, ie. via r.POST() in case of chi router.\nI repeat, PUT method is not supported in <form> HTML element by any major browsers, see https://www.w3schools.com/tags/att_form_method.asp\nHowever, your approach mimics the unsupported PUT method by adding some hidden input fields into the <form>, that must be in return handled by some extra logic on the backend side.\n\n// This is the convention for how to establish a PUT method for form submission in a restful API.\n\nIs this approach standardized by any RFC?. I recommend creating a new repo with the func putConversion(next http.Handler) http.Handler { middleware, motivation and bunch of examples. We can link it back from this conversation.\nThanks. Can you share the version of chi you're using and a full trace of the panic error?. @MetalBreaker the version matters actually, the new go get with Go modules support might download v1.x version instead of v3.x. You can check the git log in your $GOPATH/src/github.com/go-chi/chi directory.. yes it is.\nnow make sure you use\nr.Use(middleware.Logger)\n r.Use(middleware.Recoverer)\nand pls report back the actual error / panic.. hmm, I see .. so this error is coming from\n```\nfs := http.FileServer(http.Dir(\"static\"))\nr.Handle(\"/*\", fs)\n```\nSo this is not a chi returning the HTTP 500 - it's the stdlib's http.FileServer.. Why don't you add a 404 handler in your skeleton app's code?\nI'm not sure if this is the right call. The panic might be useful for some folks that forget to mount the handlers correctly.\nLet's poll the community for their opinions:\n\ud83d\udc4d for HTTP 404; \ud83d\udc4e for keeping the panic as is; \ud83c\udf89  for panicking at the startup time. @makhov that's a good point, thanks. Let me add it as a third option to the poll.. @SamWhited You are assuming that chi will support Go 1.9.7+ and Go 1.10.3+ only from now on .. and that we'll silently drop support for 1.7, 1.8, 1.9.0, 1.10.0. We need community consensus on this -- please create an issue for this. This PR is indeed breaking backward compatibility.\nRE: Import paths .. thanks for the explanation. So even if we don't add the /v3 suffix, the import paths will work just fine? So why add the suffix in the first place, should this PR avoid adding it then?. Use different Timeout middleware for each of these routes.\nTake a look at examples:\nhttps://github.com/go-chi/chi/blob/master/_examples/limits/main.go\n. That's because you need to listen on the <-ctx.Done() in your \"worker\" logic. time.Sleep() doesn't respect it the context deadline.\nYou'd have to use\ngo\nselect {\n    case <-ctx.Done():\n        // force timeout\n    case <- time.After():\n        // this is the heavy work\n        // in real world, you'd pass the ctx to the worker functions\n}\nFor further questions about Go, please consult Gopher Slack or community forums.. @SamWhited Well, Go modules were not \"hard\" to implement. See the working prototype for v4.0.0-rc1 tag at https://github.com/go-chi/chi/pull/379.\nHowever, @pkieltyka didn't like that this release would would be suddenly forcing all the chi users to change the import path to the /v4 suffix everywhere. The worry was about the amount of support tickets this could generate; and also the additional complexity thrown at chi users.\nChi v4 doesn't differ from v3 very much. In fact, it's backward compatible from the API perspective and backward compatible functionally for 99% of use cases too. However, we dropped support for Go 1.7 and Go 1.8 and we consider that a breaking change; and that's why we preferred releasing v4.0 over v3.4.\n\nWe have several tools in the same codebase that may not all be updated at once. Without the import compatibility rule we have to update them all at the same time to a single version of Chi instead of having one import chi and one import chi/v4, for example. TL;DR \u2014 Modules make incremental updates much easier.\n\nThis is a fair point and Go modules would be \"technically\" the only right choice for you if you really wanted to have both chi v3 and chi v4 side by side in a single codebase. But as I mentioned previously, we didn't really break the API in the v4 release. So, you should be able to update all of your tools at once without any trouble, either if it's a large monorepo, or if it's a bunch of small repos. Please, correct me if I'm wrong.\nAs Peter mentioned before, the chi router doesn't have any external dependencies. So, technically, we don't need to define any minimal versions in a go.mod file at all. So, I think this is strictly a choice of taste and simplicity, since the +incompatible flag will work just fine for now.. @SamWhited That feels like a concern of your deployment strategy rather than of a Go pkg dependency to me.\nAnyway, I think you'd have to fork either chi v3 or chi v4 to make a gradual change to your codebase. There's no other way around for now.. This PR was rejected by the main chi author. He doesn't like the idea of changing the import paths because of Go modules support (ie. github.com/go-chi/chi/v4) and become a tech support for the confused chi users. So we're keeping it simple and chi stays on +incompatible flag for now.. Released in https://github.com/go-chi/chi/tree/v4.0.1.. Please, provide reproducer code. Do you use middleware.RedirectSlashes?. FYI, https://github.com/go-chi/chi/tree/v4.0.1 released.. @tomocy sounds good. You can also reference that repo from our main README.md file if you want :) Cheers. Chi is a router. It doesn't parse any structs at all.. Please, submit a new issue (bug report) with description of what's broken. Any reproducers are much appreciated. We'll accept a new PR with the fix for this. Thanks!\nEDIT: I guess you have created #409 already :)\nTo suggest a breaking API change for next major release, please submit a new issue with v4 label.. Prerequisites\n. Did you run go fmt?\n. Just a nit: Can you use w instead of rw, as in the rest of the codebase?\n. Maybe we could call this just NotFound(handler http.HandlerFunc), as goji or httprouter do.\n@pkieltyka what do you think about the API?\n. > ../../middleware/logger.go:54: undefined: fmt in fmt.Sprintf\nCan you run goimports?\nAlso, what's the [1:] slice for?\n. you can use the prefix variable directly inside of defer\n. I'm thinking of\ngo\nfunc Compress(levelFunc func(r *http.Request) int, types ...string) func(next http.Handler) http.Handler {\nso we could let users change the compression level based on the request -- eg. depending on User-Agent (mobile usually needs better compression but desktop needs faster compression).\n. Since there are not so many Content-Types, I'm thinking that slice []string with a predefined order would be better. Haven't decided yet.\n. Maybe in the future. But since these encodings are supposed to be faster/better and will have browser support, I wanted to leave the boilerplate in the code.\n. I believe we do. I'm not able to \"change\" the underlying Writer otherwise.\n. I'm thinking of exposing the compress writers via API, so users could inject \nhttps://github.com/klauspost/compress or https://github.com/klauspost/pgzip\n. Empty structs are more memory-efficient than bools.\n. typo in comment\n. You need to add headers before w.WriteHeader(405)\n. check resp.Code instead\n. use http.Error() instead.\n. So far, it looks good! But before we merge this PR, I'd like to leave the original Throttle API backward-compatible. Backlog+timeout should be optional.\n``` go\nr.Use(middleware.Timeout(10 * time.Second)) // hard timeout for all endpoints\nr.Use(middleware.Throttle(10)) // hard limit on number of processed requests at a time\n// vs.\nr.Use(middleware.Timeout(10 * time.Second)) // hard timeout for all endpoints\nr.Use(middleware.Throttle(10, middleware.Backlog(1000, time.Second))) // use backlog with timeout\n```\nFor functional options, see http://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis\n@xiam @pkieltyka thoughts?\n. @pkieltyka what was wrong with throttler variable name?\n. go\nif ctx.Err() == context.DeadlineExceeded {\n    httpStatus(w, http.StatusGatewayTimeout)\n    return\n}\n. There are several places such like this. I think that all timeouts should trigger http.StatusGatewayTimeout instead of http.StatusServiceUnavailable -- objections?\n. Thinking of the behavior...\nImho, if the backlog is full, we should return Service Unavailable response as soon as possible. Only if the request can fit into the backlog, then we should start the timeout -- while waiting for the throttle token.\nSo, I'd remove timer from this select and move the initialization down:\ndiff\n- case btok := <-t.backlogtokens:\n+ case btok := <-t.backlogtokens:\n+    timer := time.NewTimer(t.timeout)\n      // ... case for timer.C, ctx.Done() and t.tokens\n+ default:\n+    httpStatus(w, http.StatusServiceUnavailable)\n+    return\n. Or we could simply have two middlewares:\ngo\nmiddleware.Throttle(N)\nmiddleware.ThrottleBacklog(N, M, T)\n. I don't even think we need a default value.\n. Since it's a convention to use \"-er\" type names in Go (writer, reader, encoder, scanner, replacer etc.), I'd prefer throttler.\n. for both interfaces and structs ... https://golang.org/src/strings/replace.go?s=305:341#L1,  https://golang.org/src/net/http/server.go?s=2094:2100#L2094, https://golang.org/src/bufio/scan.go?s=1184:1728#L20 etc.\n. Personally, I'd panic() on nil. \n. This copies Presenter conversion functions from other presenters.. Should we call it .Copy()?\nor maybe pass it to NewPresenter() func:\nversion1 := NewPresenter(version2, versionLatest)\n. > pkieltyka commented 6 days ago\n\nbtw, what do you guys think about 3c613e2 ? for chi v2, I believe the names Group() and Stack() reflect better the intention of the methods. That is, to group routes by a routing pattern and to stack one router ontop of another without a pattern.\n. To be honest, I like the original r.Route(\"/route\", subrouter) and r.Group(subrouter) better. Stack() sounds confusing to me, since it doesn't really trigger \"custom middleware stack\" in my head. And I'm not huge fan of changing .Group() logic either.\n. btw: How about removing .Route(), changing .Mount()'s signature (so it's not like .Handle()) and keep .Group() only?\n\n``` go\ntype Router interface {\n    http.Handler\nGroup(fn func(r Router)) Router\nMount(pattern string, r Router)\nHandle(pattern string, h http.Handler)\n//...\n\n}\n// --------\nr := chi.NewRouter()\nr.Use(ForAllCtx)\nr.Group(func(r chi.Router) {\n    r.Use(SpecialCtx)\n    r.Get(\"/\", handler)\n})\nr.Mount(\"/ping\", subrouter)\nr.Mount(\"/:articleID\", r.Group(func(r chi.Router) {\n    r.Use(ArticleCtx)\n    r.Get(\"/\", getArticle)\n}))\n``\n. We can remove this mw for good if we start passing*http.Request` to render.Respond:\ngo\nrender.Respond(w, r, Object)\n--- render would have access to r.Context(), r.URL, r.Host etc.\n. good point\n. Why do you call it Metrics? This is just a Logger, isn't it?\n. I feel like Metrics is more specific word for the application data/metrics (where data would contain session, user_id, ip, referer, user_agent, context etc.), not just the Request/Response data.\n@pkieltyka thoughts?\n. btw: We need to keep the old Logger interface the same. For stable API.\ngo\nfunc Logger(next http.Handler) http.Handler\n. @pkieltyka Good pattern, I like it. Putting Header name into the struct, as Maciej suggested would make it easier to debug.\n@c2h5oh when you define private type and put its instance into a context, noone else can override it from outside. Interesting feature of context.\n. It's tricky -- for example if someone passes map[string]string{...} or another complex object into the responder, how do you want to render it into HTML or TXT? It's not really possible, unless you accept only string type, which I did:\nrender.HTML(string)\nrender.String(string) // actually I'd like render.PlainText(string) better\nHTML and PlainText is not really something that could be passed into render.Respond() which accepts interface{}.\n. @pkieltyka @c2h5oh would you like render.PlainText() instead of render.String()?\n. I think I can remove this completely -- there's a new function in go1.7 to replace these characters by default :)\n. I agree\n. We can have certain defaults that we feel are right for REST responder.\nI think instead of responding with nil for array type, [] makes perfect sense and simplifies life of API consumers. But never mind -- if you guys overvote me, we can always put this outside of render pkg into custom Render() function that we're gonna use anyway. What do you think? \n. Currently, I support:\ngo\nrender.Respond(render.Status(ctx, 409), \"Conflict!!\")\nright now -- do you like it?\n. I may change the signatures a bit for chi v2 -- maybe it can be nicer at the end:\n``` go\nrender.Respond(w, r, \"Success by default\")\n// Custom 409:\nr = render.Status(r, 409)\nrender.Respond(w, r, \"Conflict!\")\n// or:\nrender.Respond(w, render.Status(r, 409), \"Conflict!\")\n```\n. I check the limit max depth on runtime Present() -- your suggestion sounds better, let me try to improve it\nmutex = yes\n. true :)\n. https://tip.golang.org/pkg/encoding/json/#Encoder.SetEscapeHTML\n. On\ngo\nrender.XML(w, \"<nothing></nothing>\")\nThis would respond with\nxml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<nothing></nothing>\n. yea -- custom StatusCode can be stored in ctx --- so any middleware can change the default behavior, which is 200 for GET/PUT, 201 for POST and 204 for DELETE :)\nFor chi v2, I'm in favor of passing whole request to the Responder.\ngo\nrender.Respond(w, r, \"hey\")\nthis way, we can grab Content-Type from r.Header, context from r.Context() etc.\n. +1\n. I don't agree.\nI definitely don't want to store Body into context (pointer to an extra []byte buffer?) in any way. I want the render pkg to be able to stream data directly from io.Reader to ResponseWriter without any performance penalty.\nThe only header that we need to postpone is the last one - StatusCode. There's no need of postponing any other headers, since you can write them directly to ResponseWriter.\nTo your point: You can always set any headers in the // before code part of each middleware. After you .Write() to the ResponseWriter, you can't set any headers anymore -- that's how stdlib works too because of HTTP design.\n. makes sense, will do\n. ### 1\nit's not about size of the buffer/pointer in ctx -- it's more about when you're ready to start sending first bytes to ResponseWriter and thus to the client\nI want to support this for example:\ngo\nrender.Respond(r, w, slowS3FileIOReader) // io.Reader\nrender.Respond(r, w, slowChannelOfData) // chan Data\n- this should start streaming bytes to the client right away\n- and most importantly, it should block the handler, so you can use defer in the handler for clean-up\n- if you don't, you'll end up buffering lot of data in the context, or you'll loose defer functionality in handlers\n2\ngeneric pager code can live in our custom Respond() function logic - there's no need to wait for a middleware layer down the chain on a way back from the handler to do the same thing.\n3\nThis is how stdlib works too. Imho, no need to be more fancy. I don't see any problem with overriding the headers:\ngo\nw.Header().Set(\"Header\", \"first value\")\nw.Header().Set(\"Header\", \"no, sorry, this is the right value\")\n. Added TODO, will enable streaming+SetEscapeHTML in chi v2 only.\n. Getting rid of it right now\n. sure\n. I'm gonna change this signature to\ngo\nfunc(r *http.Request, from *v2.Article) (*Article, error) {}\nso we can use r.Host, r.URL, r.RequestURI, r.RemoteAddr, r.Tls etc. in the presenter funcs\n. definitely\n. w.Write(nil) is not needed, is it?\n. vojtech [4:54 PM]\nbtw: I kind of think that we shouldn't add more methods to the router, we should keep it minimalistic and simple\nie. can't we go with Mount(\"/\", ...chi.Router) instead of Append()?\n. Thinking of renaming this func to WithStatus() so it's clear it only changes request context\n. render.Respond() is not a variable anymore\n-- I like render.ModifyResponse() better, since it gives users ability to modify response data only\n. hm.... thinking of it, the signature might be the same as for Presenter conversion funcs, let me check if I can improve the API one step further\n. @pkieltyka Instead of this chi photo, we should show a simple usage example or benchmarks.\n. Yup :)\n. @pkieltyka I'd like to get rid of '*' routes that are generated by r.Mount(). \n. @pkieltyka route.Pattern returns route ending with slash, even though there are no other subroutes. I'd like to change this, if there's no reason behind it.\n. @pkieltyka Walk() uses native stdlib signatures only.\nIf anyone needs extra info about a handler or middleware, they can call chi.GetFuncInfo(handler).\n. This can become table driven test with expected routes/middlewares for MuxBig.\n. Walk() gives you:\n- full expanded flat routes with their middleware stack (with chi.Routes, developer would have to traverse all the nested routes himself and build the full path and middleware stack via recursion/loop -- which would be duplicated work)\n- is very convenient for 1. custom docgen generation; 2. writing automatic tests (eg. testing all /admin/users endpoints and making sure that there's a certain middleware applied)\n- gives more power to developers, since they can customize docgen generation process easily... for example they can filter out routes that are not public, remove TODOs from comments etc. on the fly -- they can even create two different docs: 1. Internal Developer Docs (with details about Handlers, Middlewares and file structure) and 2. Public API Docs (with less info for the API consumers)\n- the signature is very similar to stdlib's filepath.Walk() https://golang.org/pkg/path/filepath/#Walk, which is also provided mainly for developer convenience, since you could traverse the file system manuallly with recursion/loop too\nbtw: I used to have Walk() func in a separate walker pkg in the beginning. But it makes a lot of sense to me that it should be part of the core.\n. Agreed, makes sense\n. Example - print all routes in the following simple format:\nPOST /users\nGET /users\nGET /users/:id\nPUT /users/:id\nGET /users/:id/books\nWith Walk() fn, it's as simple as:\ngo\nchi.Walk(r, func(method string, route string, handler http.Handler) error {\n    fmt.Printf(\"%v %v\\n\", method, route)\n})\n. Hehe, well done! \ud83d\udc4d \nReminds me my first prototype:\nhttps://github.com/pressly/chi/commit/fd607faf81f8b5cb6a7c1f60ff51beeaabc72991#diff-728925539a533b6e1ec9af73e3039fccR13\n. makes sense, the nil check is not necessary\nhttps://play.golang.org/p/rj8xKahgRx\n. can we comment out these unused vars instead of removing them?\n. why do you call it ctx? that's rather confusing, since ctx := r.Context() is commonly used for request context\n. Why do we need both FormatRequest and FormatResponse methods? Can't we just call one method only, on a way back from the underlying handlers? I don't see the reason why we'd need to store the intermediate log into a bytes.Buffer.\nWhat's the reason for Log() and Recover()? Can't we live without them too?\n. Since this package imports 3rd party pkg, it can't be part of chi/middleware pkg. We could move it to a separate pkg, though. Like github.com/pressly/chi/middleware/casbin or to a different repo github.com/pressly/middleware/casl. @pkieltyka thoughts?. @pkieltyka I believe that each directory in github.com/pressly/middleware could have its own vendor/ deps.. I see you pass chi.NewRouteContext() as rctx into the FindHandler() method.\n\nDo we ever need to pass real Context into it? And why?\nI'm thinking if we could remove the rctx parameter from this method signature and pass the Context down to tree.FindRoute() from the FindHandler() method itself.\nie.\n```go\nh, _ := rctx.FindHandler(\"HEAD\", rctx.RoutePath)\n// the FindHandler() method could pass the rctx itself\n// or chi.NewRouteContext()\n// down to the mx.tree.FindRoute() method\n```. Can we return middlewares as a second argument? Would that be possible?\n```go\nfunc (mx *Mux) Find(ctx, method, path) (http.Handler, ...func(http.Handler) http.Handler)\n// ie.\nhandler, middlewares := r.Find(ctx, method, path)\n``. Just thinking out loud -- if this method finds a correspondinghandler`, how can we invoke it?\nAnd how about its middleware chain?. I agree. rctx.Routes.Exists(tctx, method, type) bool sounds good to me, since we can't use the handler anyway.. ```go\ntctx := chi.NewRouteContext()\ntctx.RouteMethod = \"HEAD\"\ntctx.RoutePath = routePath\nh := rctx.Routes.Find(tctx, tctx.RouteMethod, tctx.RoutePath)\n```\nSeems like the tctx has both Method and Route defined. But these two values are passed to the .Find() method as arguments again.\nThat leads to a question:\n1. Can we create tctx within the .Find() method? (ie. h := rctx.Routes.Find(\"HEAD\", routePath))\n2. Or can we just pass the context and not the two duplicated tctx.RouteMethod, tctx.RoutePath arguments? (ie. h := rctx.Routes.Find(tctx)). Initially, I was thinking about different use cases:\n\n\nBeing able to change the routes dynamically. (ie. Call a different handler with some middleware stack applied, based on request/context). But this would much more complex and probably not a good idea.\n\n\nBeing able to query Router/Mux for specific route and get the Handler and full Middleware stack. (ie. for documentation purposes: handler, middlewares := r.Find(method, path) - with this, I could easily verify that a specific route has some middleware applied). But this is something than can be done in Walk() anyway, so probably not a good idea either.. Does Match() need three parameters? Seems like RouteMethod and RoutePath are already stored in tctx and thus are available in the method.\n\n\nIs there any use case where the tctx values would be different from method arguments?. How is this extra condition helping the codebase? The one liner does the very same thing, if I'm not wrong.. got it .. you can do this:\ngo\nrouteCtx, _ := ctx.Value(RouteCtxKey).(*Context)\nreturn routeCtx. You might wanna print the routes in the following format instead?\nGET /\nGET /ping. I don't think it gets compiled into the same machine code, since there is an extra condition when dealing with ok, and thus an extra jump in assembly, if I'm not wrong.\nNo big difference, though. I'm just used to omitting ok condition, if I'm fine with the zero value (both when type casting or when accessing non-existing map key).. I don't think escape analysis can eliminate the jump. No one knows the type of ctx.Value(RouteCtxKey) until the condition is executed in the runtime.. This change would hide all these endpoints from docgen. Can we instead be more explicit and add the missing handlers?. I think GET /accounts/admin should work for sure, being handled by GET / in the subrouter.\nDo we need to support /accounts/admin/ too? I think it doesn't really hurt, and makes sense ... since \"\" and \"/\" from the sub-router perspective should be the same.. docgen is not a subpkg anymore\ndiff\n- by the `docgen` subpackage\n+ by github.com/go-chi/docgen package. why func() []byte?. is this a symlink, right?\nit's a nice hack .. but does this work outside of Unix at all?. Where do we use golang.org/x/text ?. Thanks, that sounds good to me.. Can we provide a SetReqID() function, instead of hardcoding the X-Request-Id header name?. Would be nice to provide and example for #368 as part of this PR.. You know what.. I think it's not a bad idea to use the X-Request-ID header directly after all. This middleware is opinionated anyway.\nImho, the is the desired lifecycle of \"tracing\" the request-id across multiple services is as follows:\n\nbrowser request\n\n->\n\noptionally, an external service, creates reqID and passes it as X-Request-ID header\n\n->\n\nour program reads the header and sets the context value, ie.\n```go\nr.Use(middleware.RequestID)\n\n// which behind the scenes does this:\nreqID := r.Header.Get(\"X-Request-ID\")\nif reqID == \"\" {\n  reqID = generateReqId()\n}\nsetReqId(ctx, reqID)\n```\n->\n\n\nmiddlewares/handlers use the reqID value (from ctx) and pass it to logger or to external HTTP calls as X-Request-ID header\nwe just provide a getter for this:\n```go\nreqID := middleware.GetReqId(ctx)\n\n\n// log.With().String(\"requestId\", reqID) // zerolog structured log example\n// req.Header.Set(\"X-Request-ID\", reqID) // HTTP calls to other services that should be aware of this request ID\n```. I noticed you changed \ndiff\n- w.ResponseWriter.Header()\n+ w.Header()\nBut I see the other form in this function in other places. Can you fix it all?. ",
    "pkieltyka": "@utrack thanks for the report. I noticed the same thing the other day. I'll be pushing a fix shortly.\n. resolved in fffe601cb0dece53671b9332886a6a0028d2dae4\n. @vladdy thanks for the PR, but we'd like to keep things as lean as possible.\n. nice, let's update and merge\n. I still see make in the file\n. @VojtechVitek yea, I sort of feel the NotFound handler should be a chi.Handler to provide the context in case you want to output to the user some context, ... even url param... anything really, and its there so why not\n. @vladdy @VojtechVitek - what should we do about the notfound handler for mounted routers...?\n. @VojtechVitek cool ideas. A package level handler is interesting and does simply the case where there is a single service powered by a stack of routers. But if for some reason someone wanted to have multiple \"services\" running defined by a few indepdent chi.Router's .. then they're screwed because they are all using the same notfound handler. So I tend to think thats not ideal in the end.\nBtw, the ctx is passed to even routes that aren't matched.\nfor example..\ngo\nr := chi.NewRouter()\nr.Use(a)\nr.Use(b)\nr.Get(\"/dontmatchthis\", ...)\n.. for any not-found route, the request will run through the \"a\" and \"b\" middlewares. This is supported, by design. Remember we came across this for other things? ... so meaning, there could be a ctx passed down to NotFound ..\n. @edigu have a look at https://github.com/pressly/chi/pull/30 and let me know what you think. Let's move the discussion to that PR. \n. Closed in b9ba24fa6c5ac5b949cc7beaea5f80e4c5c5d3a0\n. thanks for this, however, I'd like to require that at a minimum \"/\" is specified for the routing pattern.\n. yea, I think if len(pattern) == 0 || pattern[0] != '/' { is good\n. Hey @GeertJohan - a shorthand would be nice, but it would only save a bit of typing.. as so..\ngo\nfunc NewSomethingCtx(stuff *Stuff)  chi.Middleware  {\n    return chi.Middleware(func(next chi.Handler) chi.Handler {\n        // stuff can be used here to set something up (should be done once, as mentioned in #10).\n        return chi.HandlerFunc(func(ctx context.Context, w http.ResponseWriter, r *http.Request) {\n            // stuff can also be used here, on each request.\n            // actual middleware.\n        })\n    })\n}\nIm not convinced thats much better. Do you see another way? if so, it would be great to see a quick PR for the discussion.\n. I'd like to keep the middleware signature as close to the standard http.Handler middlewares. I'm going to close this ticket, but if you find an elegant approach please submit a PR. Thanks for the feedback!\n. thanks @yudppp :) the RESTy was intentional though\n. thank you for this! it inspired me to make a full benchmark suite at https://github.com/pkieltyka/go-http-routing-benchmark and posted the results at https://github.com/pressly/chi#benchmarks\n. @gdm85 cool, the single log line is definitely cleaner.\nThe only upside to 2 lines is you can see when the initial request came in and then the request response. In case of a request+panic, one wouldn't see when the initial request and its details came in. What do you think?\n. @gdm85 thanks, I'm going to merge this and make some small changes after it. Great addition!\n. @alinz well, chi's router implements http.Handler, so you can use any third party graceful shutdown package like https://github.com/tylerb/graceful or like we do in the Pressly API using goji's graceful package with chi: https://github.com/zenazn/goji/tree/master/graceful\nonce nice thing to trigger a ctx.Done via the cancelFunc from a context when a shutdown is called. I have a trick in imgry where I do this..\nhttps://github.com/pressly/imgry/blob/master/cmd/imgry-server/main.go#L38-L41\nhttps://github.com/pressly/imgry/blob/master/server/server.go#L95\nhttps://github.com/pressly/imgry/blob/master/server/middleware.go#L16-L26\nthe above example works by having a server-wide context, and replace the context in the chain with this one by copying the urlparams first. I thought, maybe we could have a parent ctx on the router itself, but, didn't think of an elegant enough solution for it and too busy to find one since this works. \n. no prob. let's keep it open for a bit in case others have the same question.\n. Hmm. I don't see why this is useful. The logger works fine. And full path is in r.URL.Path\n\nOn Nov 13, 2015, at 5:54 AM, Nikita K notifications@github.com wrote:\nAdded fullPath param to the tree node, which contains full path for\nthis node. Each time request is processed, full non-interpolated path is put \nto ctx's const MatchedPathCtxKey key, which can be retrieved by logging\nmiddlewares.\nYou can view, comment on, or merge this pull request online at:\nhttps://github.com/pressly/chi/pull/20\nCommit Summary\nNow saving matched router's path to the context\nFile Changes\nM mux.go (5)\nM tree.go (37)\nM tree_test.go (72)\nPatch Links:\nhttps://github.com/pressly/chi/pull/20.patch\nhttps://github.com/pressly/chi/pull/20.diff\n\u2014\nReply to this email directly or view it on GitHub.\n. I see, that's a narrow use case I don't plan to support in the core. \n\nAn option you have is to implement the chi.Router interface with your own mux where you can make it send those stats or automatically attach a middleware for the same path, etc. You'd make a struct, embed chi.Mux, and change it how you like.\nThanks for the submission tho. \n\nOn Nov 13, 2015, at 7:37 AM, Nikita K notifications@github.com wrote:\n@pkieltyka It's useful for logging endpoints' metrics. Say, request timings and counts per endpoint.\nFor endpoint /users/:id r.URL.Path contains\n/users/1\n/users/2\n/users/3\nand so on. If you'd export stats outside (with Prometheus or similar software) all these would be viewed as separate endpoints, while using path from MatchedPathCtxKey would present a single path per endpoint, so all these requests will be exported as calls to /user/:id.\n\u2014\nReply to this email directly or view it on GitHub.\n. test request can return resp headers.. or, make another method similar that also returns header. \n. hi @hmgle I'd prefer to keep chi as just a router. If you need a responder, I suggest to use https://github.com/unrolled/render which works just fine with chi.\n\nyour code will look like:\n``` go\nimport renderPkg \"github.com/unrolled/render\"\nvar render *render.Render\nfunc init() {\n  render = renderPkg.New() // pass options if you want\n}\nfunc x() http.Handler {\n  r := chi.New()\n  r.Get(\"/\", handler)\n}\nfunc handler(ctx context.Context, w http.ResponseWriter, r *http.Request) {\n  // processing..\n  render.JSON(w, 200, responseObj)\n}\n```\nanother suggestion, is wrap the unrolled/render package by making your own \"render\" package that is a part of your project, and set defaults there so its setup to use across packages.\n. The goals of chi are to stay minimal, allow full control without limitation of possibility or productivity. I guess the gap right now is that chi doesn't provide every library out of the box, you're expected to make your own choices for something like the responder. I will update the example to show how to wrap your own render responder.\n. @hmgle here you go https://github.com/pressly/chi/blob/master/_examples/rest/main.go\nand\nhttps://github.com/pressly/chi/blob/master/_examples/rest/render/render.go\n. @hugows yes exactly. Its now at: https://github.com/go-chi/chi/blob/master/_examples/rest/main.go. Solved in b9ba24fa6c5ac5b949cc7beaea5f80e4c5c5d3a0\n. This implementation is alright, but it would be nice if the NotFound() handler could cascade upwards back up the chain.\nie.\n``` go\nsub := chi.NewRouter()\nsub.Get(\"/hello\", ...)\nroot := chi.NewRouter()\nroot.Get(\"/\", ...)\nroot.NotFound(func(ctx context.Context, w http.ResponseWriter, r *http.Request) {\n  w.WriteHeader(404)\n  w.Write([]byte(\"custom 404 page\"))\n})\nroot.Mount(\"/subrouter\", sub)\n```\na 404 on root render the custom error, but in the subrouter it will be the standard http.NotFound(), unless you define it again on that router.\nThis should be solvable. Options:\n1. Check end handler in handle() or Mux and apply the NotFound() method on the subrouter, but, we dont want to override it if someone set their own on the subrouter, so we'd have to check if its the default and thats not possible without another interface method that I'd rather not have.\n2. Go with a middleware.PageNotFound middleware as middlewares will go back up the chain naturally. This could work, and to trigger a 404, a handler would just return and the middleware would see no status was returned, so return a 404.\n3. Go with a package-level chi.NotFoundHandler = chi.HandlerFunc(func(ctx, w, r) { ... })\n4. Any other ideas?\n. This PR completes the NotFound() handler support, along with cascading up the tree looking for a not found handler.\n. What should it do?\nCuz the r.Mount() route is the same as the get request, and overwrites it. You should define the / route in the subrouter if it's using the same name, since that is its domain \n\nOn Jan 25, 2016, at 9:11 PM, Vojtech Vitek notifications@github.com wrote:\npackage main\nimport (\n    \"log\"\n    \"net/http\"\n\"github.com/pressly/chi\"\n)\nfunc main() {\n    r := chi.NewRouter()\n```\n// Parent route -- /foo\nr.Get(\"/foo\", func(w http.ResponseWriter, r *http.Request) {\n    log.Println(\"/foo\")\n})\n// Subrouter -- /foo/bar\nr.Mount(\"/foo\", subrouter())\nhttp.ListenAndServe(\":3333\", r)\n```\n}\nfunc subrouter() http.Handler {\n    r := chi.NewRouter()\n    r.Get(\"/bar\", func(w http.ResponseWriter, r *http.Request) {\n        log.Println(\"/foo/bar\")\n    })\n    return r\n}\n$ curl -v localhost:3333/foo\n\nGET /foo HTTP/1.1\n< HTTP/1.1 404 Not Found\nNot Found\n* Not found? I defined this route -- and none path should rewrite it. *\n\n$ curl -v localhost:3333/foo/\n\nGET /foo/ HTTP/1.1\n< HTTP/1.1 404 Not Found\n404 page not found\n* btw: Why's the body different compared to the previous request? Different NotFound handler?*\n\n$ curl -v localhost:3333/foo/bar\n\nGET /foo/bar HTTP/1.1\n< HTTP/1.1 200 OK\n/foo/bar\n* OK *\n\n\u2014\nReply to this email directly or view it on GitHub.\n. btw.. for fun I ran the benchmarks on Go-tip (1.7)\n\nshell\nBenchmarkChi_Param                  10000000           143 ns/op           0 B/op          0 allocs/op\nBenchmarkChi_Param5                  5000000           368 ns/op           0 B/op          0 allocs/op\nBenchmarkChi_Param20                 1000000          1336 ns/op           0 B/op          0 allocs/op\nBenchmarkChi_ParamWrite             10000000           196 ns/op           0 B/op          0 allocs/op\nBenchmarkChi_GithubStatic           10000000           220 ns/op           0 B/op          0 allocs/op\nBenchmarkChi_GithubParam             3000000           445 ns/op           0 B/op          0 allocs/op\nBenchmarkChi_GithubAll                 20000         75896 ns/op           0 B/op          0 allocs/op\nBenchmarkChi_GPlusStatic            10000000           140 ns/op           0 B/op          0 allocs/op\nBenchmarkChi_GPlusParam             10000000           200 ns/op           0 B/op          0 allocs/op\nBenchmarkChi_GPlus2Params            5000000           287 ns/op           0 B/op          0 allocs/op\nBenchmarkChi_GPlusAll                 500000          3036 ns/op           0 B/op          0 allocs/op\nBenchmarkChi_ParseStatic            10000000           145 ns/op           0 B/op          0 allocs/op\nBenchmarkChi_ParseParam             10000000           180 ns/op           0 B/op          0 allocs/op\nBenchmarkChi_Parse2Params           10000000           234 ns/op           0 B/op          0 allocs/op\nBenchmarkChi_ParseAll                 300000          5351 ns/op           0 B/op          0 allocs/op\nBenchmarkChi_StaticAll                 30000         47330 ns/op           0 B/op          0 allocs/op\n. @netsharec I see what you mean. I'll add this function later today.\n. @fiorix good call\n. Merged in #36 - see new mux.FileServer(path string, root http.FileSystem) method.. example usage: https://github.com/pressly/chi/blob/master/mux_test.go#L734-L743\n. yep, thats correct . thanks @lxfontes for this! I'm going to merge and make a small addition.. that is to remove the _static folder and just use a in-memory http.FileSystem fixture in the mux_test\n. @mrcpvn thanks for the PR! just wondering, did you run into this because of a bug..?\n. this PR is interesting, but I'll probably go with a different approach to solving it.\n. Thanks for the PR @mrcpvn .. I've closed it with 79fa9188c5d924a6408a8b8ef4f267acec735a84\n. hey @mrcpvn. Definitely, I agree the incoming context should be handled by the router and it is, but by ServeHTTP instead of ServeHTTPC like you suggested in the PR. The typical connection point of a chi.Mux is as an http.Handler, passed to http.ListenAndServe(). \nWhen would you call mux.ServeHTTPC()? I suppose one example could be if you're writing tests and testing specific handlers via httptest.NewRecorder(). I've been writing my http tests with httptest.NewServer(mux). If the reason is for tests, one way I could do it is export the newContext() method in chi so someone could make a new routing context for purposes of tests. Let me know if you have other reasons to call ServeHTTPC directly on a mux object. In order to support both methods, it just makes the code a bit messy and I'd rather avoid it by convention. If there are specific needs for it, please let me know and there might be a different way to solve it.\nSecond and most importantly, chi v2.0 will be ready for Go 1.7, which no longer needs the ServeHTTPC() method because http.Request now has a Context field of its own :) yeay... so again, this problem goes away. See https://github.com/pressly/chi/blob/v2 -- this version is going to be a major step forward, still very minimal in philosophy but static checking everywhere in the router, and I'm going to add a few more perks now that I can lean on context.Context even further. At that point chi v1 will go into a stable branch where < 1.7 users can still use it until they upgrade. But still, v1 should be stable an very refined.\nThird, in relation to your PR specifically, the defer statement does have a cost, and I'd rather not use it per request. \n. Can you show example of middleware / router? I'll get a proper fix for this to make sure v1 is stable \n\nOn May 9, 2016, at 10:22 AM, mrcpvn notifications@github.com wrote:\nThank you for the explanation @pkieltyka. I found the issue with mux.ServeHTTPC because I was calling the method from a middleware handler that is context aware and will pass a context.Context to the chi.Router (calling directly the ServeHTTPC method). This is probably an edge case but should not be ignored. \nI know that with Go 1.7 this problem will go away but for the moment I need to support a context in the ServeHTTPC method.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly or view it on GitHub\n. @mrcpvn @VojtechVitek let me know what you guys think of https://github.com/pressly/chi/pull/40\n\nAll tests pass and benchmarks remain the same. \n. I think it would be better as a goware/debugmw package\n. I also think you can r.Mount(\"/blog\", blogRouter) and r.Get(\"/blog/\", ...) where ... Can be a redirect to drop the trailing slash (which is best option IMO) or set it to the list handler\nLet me know if that works\n\nOn May 21, 2016, at 9:10 AM, Mgen notifications@github.com wrote:\nJust solved this after a few minutes. this works fine now:\n// r is a Router variable\nblogRouter := chi.NewRouter()\nblogRouter.Get(\"/\",  blogWithTrailingSlashHandler)\nblogRouter.Get(\"/list\", blogListHandler)\n// mount this router for a URL with trailing slashes\nr.Mount(\"/blog/\", blogRouter)\nr.Get(\"/blog\", blogHandler)\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub\n. Good tip, I'll see about adding a nicer panic message, cuz it will still have to panic without an err check\nOn May 21, 2016, at 4:34 PM, Mgen notifications@github.com wrote:\nI accidentally mounted an empty router, I didn't realise it, and it was hard to find out the problem due to the weird error message.\nCode to reproduce this issue\npackage main\nimport (\n    \"net/http\"\n    \"github.com/pressly/chi\"\n)\nfunc main() {\n    r := chi.NewRouter()\n```\napiRouter := chi.NewRouter()\nr.Handle(\"/api\", apiRouter)\nhttp.ListenAndServe(\":3000\", r)\n```\n}\n127.0.0.1:3000/abc: 404 page.\n127.0.0.1:3000/api: panics.\n127.0.0.1:3000/api/abc: panics.\nFull error log:\n2016/05/21 23:18:24 http: panic serving 127.0.0.1:49239: runtime error: invalid memory address or nil pointer dereference\ngoroutine 8 [running]:\nnet/http.(_conn).serve.func1(0xc82005e980)\n    /usr/local/Cellar/go/1.6/libexec/src/net/http/server.go:1389 +0xc1\npanic(0x325240, 0xc82000a1a0)\n    /usr/local/Cellar/go/1.6/libexec/src/runtime/panic.go:426 +0x4e9\ngithub.com/pressly/chi.(_Mux).ServeHTTPC(0xc8200125a0, 0x1a55910, 0xc820010cc0, 0x1a55858, 0xc8200f41a0, 0xc8200c2380)\n    /Users/Mgen/go/src/github.com/pressly/chi/mux.go:283 +0x648\ngithub.com/pressly/chi.treeRouter.ServeHTTPC(0xc820014e40, 0x0, 0x1a55910, 0xc820010cc0, 0x1a55858, 0xc8200f41a0, 0xc8200c2380)\n    /Users/Mgen/go/src/github.com/pressly/chi/mux.go:352 +0x324\ngithub.com/pressly/chi.(_treeRouter).ServeHTTPC(0xc82000af80, 0x1a55910, 0xc820010cc0, 0x1a55858, 0xc8200f41a0, 0xc8200c2380)\n    :18 +0xca\ngithub.com/pressly/chi.(_Mux).ServeHTTPC(0xc820012550, 0x0, 0x0, 0x1a55858, 0xc8200f41a0, 0xc8200c2380)\n    /Users/Mgen/go/src/github.com/pressly/chi/mux.go:266 +0x112\ngithub.com/pressly/chi.(_Mux).ServeHTTP(0xc820012550, 0x1a55858, 0xc8200f41a0, 0xc8200c2380)\n    /Users/Mgen/go/src/github.com/pressly/chi/mux.go:258 +0x4b\nnet/http.serverHandler.ServeHTTP(0xc82005e080, 0x1a55858, 0xc8200f41a0, 0xc8200c2380)\n    /usr/local/Cellar/go/1.6/libexec/src/net/http/server.go:2081 +0x19e\nnet/http.(_conn).serve(0xc82005e980)\n    /usr/local/Cellar/go/1.6/libexec/src/net/http/server.go:1472 +0xf2e\ncreated by net/http.(*Server).Serve\n    /usr/local/Cellar/go/1.6/libexec/src/net/http/server.go:2137 +0x44e\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub\n. It's already done in v2 branch :) this was my entire all along and even messaging Go core team nudging them to add context to stdlib! It all worked out\nOn May 27, 2016, at 11:21 PM, Anmol Sethi notifications@github.com wrote:\nInstead of an additional parameter of type context.Context with a new handler type, an alternative approach was favoured in the standard library.\nSee: golang/go@c1c7547\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Thanks Luke :) Can you give me an example of some pseudo code for the named routes? \nIt's likely chi can already do it with either Handle, Route, or Mount, but maybe there's a case I'm missing.\nOn Jun 1, 2016, at 11:49 PM, Luke Cawood notifications@github.com wrote:\nLove chi, it's fast becoming my default router choice for golang. The 1.7 compatibility branch is beginning to look like the perfect router for go.\nIf we're talking about a version 2.0 with breaking changes to the API, could I please ask you to consider introducing the notion of names for the routes? Named routes are handy for reverse lookups in templates etc, and also in monitoring tools such as Datadog and New Relic.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub, or mute the thread.\n. ah, railzzz, ..... shoot myself in the face :) my suggestion if you want this is to write your own helpers. Chi's philosophy is to stay minimal and build-your-own-adventure, besides a robust way to nest routes and manage context.\n\nhowever, this is also why I've made chi.Router an interface.\nYou can most certainly enhance the interface, or implement this ability yourself.\n``` go\npackage nmux // aka named-mux\ntype Mux struct {\n  *chi.Mux\n}\nvar _ chi.Router = &Mux{} // ensures the chi router interface is met by Mux struct\n// some example code I pulled from an ACL router that is built by enhancing chi's mux.. you'll have to update it slightly to remove resourcecontrol and Route()\nfunc (r *Mux) Use(middlewares ...interface{}) {\n    r.Mux.Use(middlewares...)\n}\nfunc (r *Mux) Handle(pattern string, handlers ...interface{}) {\n    h := append([]interface{}{Route(pattern), ResourceControl}, handlers...)\n    r.Mux.Handle(pattern, h...)\n}\nfunc (r *Mux) Connect(pattern string, handlers ...interface{}) {\n    h := append([]interface{}{Route(pattern), ResourceControl}, handlers...)\n    r.Mux.Connect(pattern, h...)\n}\nfunc (r *Mux) Head(pattern string, handlers ...interface{}) {\n    h := append([]interface{}{Route(pattern), ResourceControl}, handlers...)\n    r.Mux.Head(pattern, h...)\n}\nfunc (r *Mux) Get(pattern string, handlers ...interface{}) {\n    h := append([]interface{}{Route(pattern), ResourceControl}, handlers...)\n    r.Mux.Get(pattern, h...)\n}\nfunc (r *Mux) Post(pattern string, handlers ...interface{}) {\n    h := append([]interface{}{Route(pattern), ResourceControl}, handlers...)\n    r.Mux.Post(pattern, h...)\n}\nfunc (r *Mux) Put(pattern string, handlers ...interface{}) {\n    h := append([]interface{}{Route(pattern), ResourceControl}, handlers...)\n    r.Mux.Put(pattern, h...)\n}\nfunc (r *Mux) Patch(pattern string, handlers ...interface{}) {\n    h := append([]interface{}{Route(pattern), ResourceControl}, handlers...)\n    r.Mux.Patch(pattern, h...)\n}\nfunc (r *Mux) Delete(pattern string, handlers ...interface{}) {\n    h := append([]interface{}{Route(pattern), ResourceControl}, handlers...)\n    r.Mux.Delete(pattern, h...)\n}\nfunc (r *Mux) Trace(pattern string, handlers ...interface{}) {\n    h := append([]interface{}{Route(pattern), ResourceControl}, handlers...)\n    r.Mux.Trace(pattern, h...)\n}\nfunc (r *Mux) Options(pattern string, handlers ...interface{}) {\n    h := append([]interface{}{Route(pattern), ResourceControl}, handlers...)\n    r.Mux.Options(pattern, h...)\n}\nfunc (r *Mux) Group(fn func(r chi.Router)) chi.Router {\n    return r.Mux.Group(fn)\n}\nfunc (r *Mux) Mount(path string, handlers ...interface{}) {\n    r.Mux.Mount(path, handlers...)\n}\nfunc (r *Mux) URLFor(key string, params map[string]interface{}) string {\n  // TODO\n}\nfunc NewRouter() *Mux {\n    r := &Mux{chi.NewRouter()}\n    return r\n}\n// EOF\n// ... now... you can use your own mux\napp := nmux.NewRouter()\napp.Post(\"/users\", func(ctx context.Context, w http.ResponseWriter, r *http.Request) {\n   http.Redirect(w, r, app.URLFor(\"users\", map[string]interface{}{\"id\", user.ID()}\n})\n```\nyou'll have to implement your own named route registry into the custom Mux{}, but it will work with all of chi and be passed throughout. \nA simpler, but a bit more verbose approach is just to write some explicit helper functions that generate urls based on some scheme... URLFor(\"users/:id\", Params{\"id\", user.ID()}) which could implement your own conventions that adhere to REST for example.\nHaving said that though, I'm not sure why you need to redirect to these resources after making a new object, its better to just return the object itself on Post(), the same presenter function pretendDisplayUser(w, userID) used in Get() should be used to return in Post(), no redirection.. better.\n. either way, named routes (as defined by above examples) are not the concern of core chi, but would need to be a router enhancer that is outside of the core lib.\n. @c2h5oh the middleware approach could work as well, but it would have to register the path's when the middleware is mounted, and the handler itself would just next.ServeHTTP(w,r) and nothing more.\n. btw, what do you guys think about https://github.com/pressly/chi/commit/3c613e2cdf70c0dbd4350eb7accf91dd3175b092 ? for chi v2, I believe the names Group() and Stack() reflect better the intention of the methods. That is, to group routes by a routing pattern and to stack one router ontop of another without a pattern.\n. Closing to move discussion to #48 and #49\n. @mrcpvn yea, with 404, it lets you mount the NotFound() handler and response to the user. I'm open to just returning a 405, but then theres no control to the app developer here. I'll think about this some more for chi v2\n. @mrcpvn how come you've closed it...? have you solved this in a different way?\n. makes sense, thanks for the followup!\n. Done in v2 branch\n. Awesome!! Let me know how you use the tracking patterns to achieve what you're planning\n\nOn Jul 27, 2016, at 3:40 AM, Luke Cawood notifications@github.com wrote:\n\ud83c\udf89 this pretty much satisfies my requirement here: #43 (comment) \ud83c\udf89 \ud83d\udc4d\n\u2014\nYou are receiving this because you modified the open/close state.\nReply to this email directly, view it on GitHub, or mute the thread.\n. its an interesting point to normalize all request times to a single unit, but, visually its nicer to read the unit of time as us, ms, s. @mrcpvn is this for instrumentation..? perhaps you should check the elapsed time and have a middleware that emits the data? .. or, perhaps we should have a formatter for the Logger to make this configurable\n. @november-eleven thanks man, that was the goal :)\n\nahh yes.. the logger interface, I agree this would be a good addition and if you want to take a stab at a prototype+PR, go for it. The simpler the better. I'll add it to the v2 roadmap as well.\n. @november-eleven btw, I don't know if you've seen but I added a pretty sweet Logger interface and logging example for structure logging last week.. https://github.com/pressly/chi/releases/tag/v2.0.0. @nhooyr thanks for the note, but, whats the use case? I'd also like to avoid any external dependencies for any of chi's packages/subpackages\nthe middleware.Logger already has some nice colors.\n. right on, it looks like a very nice library, but I dont want to introduce external libraries to the core. perhaps, we could make a separate middleware logger outside of chi that uses plain-jane \"context\" for go1.7, using your lib, and it will just work in chi\n. or if you want to submit an update to https://github.com/pressly/chi/blob/master/middleware/terminal.go to improve support, that would be awesome too\n. @lofcek thanks for the questions. There's been a lot of thought put into the design, but I am still not completely settled on the zero-alloc router implementation but I will certainly have it nailed down in the v2 branch once I figure it out.\n1. The Mux.pool is a pool for chi.Context's like you said, the chi.Context is the routing context where we store params and other routing-related details on the request context. Chi is designed to handle a nesting of Mux's as subrouters mounted together (as I'm sure you know). However, its just the first Mux that will either get/set a routing context from the pool, just the single time. The other Mux's are just passed down the value so they dont need to use their pools, unless they are somehow mounted independently and its they are the top-level mux.\n2. Yes, I make a new mux per Group, the memory is allocated just once when the routes are built, the memory footprint is small, and it wouldnt make a new routing context since it would receive it from the top level. Btw, I am still trying to figure out the right name for the Group() method (I'm planning to rename it), because as you can see this is really used to define a new inline mux that starts a new middleware chain for a group of routes. It's very close to Route(), although Route() accepts a pattern as the first argument, whereas Group() mounts the router inline. Other names that come to mind for Group() could be.. Inline(),  Attach(), MiddlewareGroup(), UseInline(), ... \n3. Yea, I really don't like this code, but I personally don't see a better way, If you can produce a test case that causes this to fail let me know. In v2 there is no more ServeHTTPC method, so the problem changes \n. 1. :) \n2. I'll ask the other guys too, good idea. I have been thinking and leaning towards the method Inline(), but lets see where the consensus lands\n3. Defer has a cost, and the current code works, so I'd rather not change it. In v2, this becomes different which is my primary focus aside from bugs in v1\n. hey @lofcek, it's a good point and the trailing slash has been a bit of a pain. I added a test case https://github.com/pressly/chi/commit/53adbc4e11d956b350ba39aed51801f2dd42a17d that can show you how to do it now. The reason this works is because routes are layered on top of each other when build the routing tree.\nI do agree I should build something standard into the mux. However, there are usually two options, many people will want to redirect /accounts/123/ to /accounts/123 and others will want the trailing slash to be treated to the same handler.\none idea is instead of changing the Mux{} object, because, its more of an underlying struct and its best to use the Router interface, and we don't really support configuration options (not that we couldn't), but it limits extensibility..\nI think instead... I could update the test code to support something like..\n``` go\nfunc TestMuxTrailingSlash(t testing.T) {\n    r := NewRouter()\n    r.NotFound(func(ctx context.Context, w http.ResponseWriter, r http.Request) {\n        w.WriteHeader(404)\n        w.Write([]byte(\"nothing here\"))\n    })\nsubRoutes := NewRouter()\nindexHandler := func(ctx context.Context, w http.ResponseWriter, r *http.Request) {\n    accountID := URLParam(ctx, \"accountID\")\n    w.Write([]byte(accountID))\n}\nsubRoutes.Get(\"/\", indexHandler)\n\n// ***NOTE*** the middleware before the mount\nr.Mount(\"/accounts/:accountID\", middleware.StripSlashes, subRoutes)\n\n// or..\n// r.Mount(\"/accounts/:accountID\", middleware.RedirectSlashes, subRoutes)\n\nts := httptest.NewServer(r)\ndefer ts.Close()\n\nif resp := testRequest(t, ts, \"GET\", \"/accounts/admin\", nil); resp != \"admin\" {\n    t.Fatalf(resp)\n}\nif resp := testRequest(t, ts, \"GET\", \"/accounts/admin/\", nil); resp != \"admin\" {\n    t.Fatalf(resp)\n}\nif resp := testRequest(t, ts, \"GET\", \"/nothing-here\", nil); resp != \"nothing here\" {\n    t.Fatalf(resp)\n}\n\n}\n```\nso, the introduction is to add middleware.StripSlashes and middleware.RedirectSlashes\n...alternatively, there could be an option on the chi routing Context, and a middleware could be used to flip the flags on the routing context, and pass along the request\n. btw.. this works..\ngo\nfunc StripSlashes(next Handler) Handler {\n    fn := func(ctx context.Context, w http.ResponseWriter, r *http.Request) {\n        path := r.URL.Path\n        if path[len(path)-1] == '/' {\n            rctx := RouteContext(ctx)\n            rctx.RoutePath = path[:len(path)-1]\n        }\n        next.ServeHTTPC(ctx, w, r)\n    }\n    return HandlerFunc(fn)\n}\nI'll be packaging this into middleware pkg soon enuf once I write the RedirectSlashes middleware, but I gotta head out for now\n. Thanks for the thoughts but I don't fully agree. You're right about the root path, I'll make a check but if you have other opinions, please submit a PR or a breaking test case. Ie. rctx is a pointer and doesn't need to set to ctx again, since it already on the context chain, and we don't need a new chi.Context\n\nOn Jun 20, 2016, at 7:30 AM, lofcek notifications@github.com wrote:\nAnd I also didn't realize it immediately- I think change data inside Context during execution is a bit confusing. I think it should be better to create a new chi.Context, don't change previous one.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub, or mute the thread.\n. thanks for the feedback. I've added support with https://github.com/pressly/chi/commit/b74aedb047b9ee86e7f0c0154101b65fe255fd9a \n. thanks for the PR @november-eleven, there is definitely some good stuff in here and I feel we're close.\n\nI'd like to find a different name than Metric, more like LogBackend etc., or LogPipe .. something like that. \nBut first, can you give a quick example how this could be used with different backends? ie. is it like ..\n``` golang\n// something that comes to mind\nfunc router() http.Handler {\n  logger := middleware.NewLogger(\n    middleware.DefaultLoggerBackend,\n    myCustomPrometheusLoggerBackend{},\n  )\nr := chi.NewRouter()\n  r.Use(logger)\n  r.Get(\"/\", ...)\n}\n```\n. @november-eleven yea, I was also thinking about the performance implications. For some, the trade-off may be negligible, but we should still consider the API design in regards to performance. It's pretty easy to support multiple backends in a single call..\nfunc NewLogger(logAppenders ...LogAppender) { ... } it would return a single middleware that captures the data and calls out to a slice of appenders\n. if someone felt so inclined, they could split the logger middlewares like in your example, which I think looks a bit cleaner, but has some performance penalties that aren't worth it. \n. Sure, submit another PR and we can always reference the discussion here as needed. Also, boom tests are good, but it's also important to write go bench tests to determine number of allocs and ops to figure out memory and cpu pressure of the code \n. @november-eleven this is awesome, thank you. I'm going to dive in deeper on this as I get to the final details and step of v2\n. @november-eleven thanks so much for your work on this! What's great about the new context support in net/http, this logger is framework-agnostic and will technically work as any stdlib net/lib http middleware. After giving it some thought, I think the first version of chi v2, I'd like to keep super minimal and it would be better if you move this PR into its own middleware package. For example, github.com/november-eleven/logpiper or in the github.com/goware org which we put a lot of other middleware's if you'd like. Let me know if you do it, and I'll link to it from our README.\n. done!\n. it's also likely someone will solve this outside of chi using Go 1.7's request context and it will \"just work\" with chi since we only depend on the stdlib net/http and context.\n. @cyx btw, this is what I was thinking https://github.com/goware/valve/blob/master/_example/main.go\nits agnostic to chi, but of course works well with it\n. @cyx yea exactly, it's important to preempt certain code blocks properly and that is where the valve package comes in. I'm going to update it's README soon, but the thought is its designed as an extension to context.Context, that adds an additional valve signal that when stopped will tell non-preemptive code blocks to stop processing and finish up, aka, the taps are turning off, stop what you\u2019re doing.\nit's already first-class to chi since it just relies on context.Context. It's not specific to just http servers, its useful for any kind of server. I have however moved the valve package to https://github.com/pressly/valve\nI thought to write something like github.com/tylerb/graceful from scratch and having it right as a part of chi/graceful - but there is no point, I'd just be ripping their code for what does a very fine job. The missing part was signaling the shutdown and having proper code to let non-preemptable code finish. At this present time, I recommend the approach https://github.com/pressly/chi/blob/master/_examples/graceful/main.go but I'm always open to feedback and future ideas. Let me know how it works for all :) \n. btw, is there a way to stream the resp body?\n. its solved in latest v2\n. done in ffaa9a31d8e31fff720276885048d779ff0ccfaf\n. done in ffaa9a31d8e31fff720276885048d779ff0ccfaf\n. See https://github.com/pressly/chi/pull/69\n. Thanks for the PR and report, I've gone in this direction which is a bit more efficient: https://github.com/pressly/chi/pull/69\n. hey @chenjie4255 - yea, we support go 1.6 with chi branch v1 at https://github.com/pressly/chi/tree/v1\nbut I highly recommend you upgrade to go 1.7 since the final will be released next week.\n. hey @buro9 - this can definitely be done, its just a matter of the approach. There isn't a way to opt out of a parent middleware stack, but that isn't quite necessary either.\nI suggest something like..\n``` go\nfunc ListenAndServe() error {\n    r := chi.NewRouter()\nr.Use(middleware.RequestID)\nr.Use(middleware.Logger)\nr.Use(middleware.Recoverer)\nr.Use(middleware.RedirectSlashes)\n\n// Protected routes.\n// This works by starting a new middleware stack for these routes.\nr.Group(func(r chi.Router) {\n  r.Use(session)\n  r.Get(\"/\", homeGet)\n})\n\nr.Mount(\"/static\", staticFiles())\n\nreturn http.ListenAndServeTLS(fmt.Sprintf(\":%d\", *listenPort), *certFile, *keyFile, r)\n\n}\n```\n. or..\n``` go\nfunc ListenAndServe() error {\n    r := chi.NewRouter()\nr.Use(middleware.RequestID)\nr.Use(middleware.Logger)\nr.Use(middleware.Recoverer)\nr.Use(middleware.RedirectSlashes)\n\n// or..\nr.Mount(\"/\", appRoutes())\n\n// or.. which is effectively the same as r.Mount(\"/\", anotherR),\n// Route() is just an inline definition\nr.Route(\"/\", func(r chi.Router) {\n  r.Use(session)\n  r.Get(\"/\", homeGet)\n})\n\n\nr.Mount(\"/static\", staticFiles())\n\nreturn http.ListenAndServeTLS(fmt.Sprintf(\":%d\", *listenPort), *certFile, *keyFile, r)\n\n}\nfunc appRoutes() http.Handler {\n  r := chi.NewRouter()\n  r.Use(session)\n  r.Get(\"/\", h)\n  r.Get(\"/etc\", h2)\n  r.Mount(\"/other\", r2) // which will nest the paths\n  return r\n}\n```\n. :) \n. @Vektah thanks for the report and test case! I'll give this a bit more thought to consider the best way approach to solve this in chi. If you have other ideas please let me know too.\n. I'll see if we can maintain RouteContext pooling, and instead storing it as a value in the context instead of as a context.Context type, like you suggested.\n. @lwc for sure, the current code doesn't reuse request context objects, it just reused the routing object, but clearly the way its adding itself to the context value chain is being problematic. I could get rid of the pool entirely, and I might.. I'm just trying a few things right now but I've been at a conference all day. Will get this in soon.\n. Let me know what you guys think of https://github.com/pressly/chi/pull/75 -- this does the job, and it maintains pooling of the route context, which isn't really a context object, its just the routing details. The benefit is the benchmarks are better than removing the pool altogether.\n. thanks @Vektah for the original PR at https://github.com/pressly/chi/pull/74\n. @gpopovic can you show me the test code for that handler?\nit's possible to go about it a few ways, but if you're testing just a single handler that is trying to fetch URLParams from a request, then you need to make sure the URLParams object is available on the request chain. Have a look at https://github.com/pressly/chi/blob/master/mux_test.go#L810-L829\n. @gpopovic hey there, hmmm.. did you read the README or look at the examples? A huge design goal of chi is to join routers together, via r.Mount .. of course it can do this.\nPlease keep the issues about bugs and not Q&A. I will be working on some better docs with examples, but its all there if you look closely and learn how to use the framework.\n. @CaptainCodeman thanks man! this is definitely a bug and I know why it's happening. Thanks for the report, I'll fix it soon.\n. hey @CaptainCodeman - I was looking to solve this problem when I realized its logically difficult. Did you say other routers can support this?\nThe reason I ask is, I can make the particular case you're describing work..\n/items/:category => categoryHandler (urlParams: category)\n/items/:year/:month => yearMonthHandler (urlParams: year, month)\nbut, imagine the routes now look like\n/items/:category => categoryHandler\n/items/:year/:month => yearMonthHandler\n/items/:x/:y => xyHandler\n.. for a request to /items/2016/09 would we expect to reach the yearMonthHandler or the xyHandler? the answer is, the /items/:x/:y route will overwrite the route and handler to xyHandler where the last one takes precedence. \nThe best we could, from someone definging those three routes is ending up with..\n/items/:category => categoryHandler (urlParams: category)\n/items/:x/:y => xyHandler (urlParams: x, y)\nlet me know what you think. but I'm still not convinced which is better / less confusing\n. can you show me some sample code of your main use case like you mentioned with the suffix..? I don't fully understand that part yet.\nalso, any chance you can show me a gist of how echo works for these cases too..? I'm just on the road for the rest of the week but I'd like to come to the best possible solution\n. @jhngrant yea, I don't see that getting implemented soon by me, I'm quite busy with work on our actual platform, but hopefully someone submits a PR for that one day. I have some stubbed in code for regexp matching in the tree already\n. @jhngrant :) https://github.com/pressly/chi/blob/master/tree.go#L47 and https://github.com/pressly/chi/blob/master/tree.go#L326-L327\nfor url param syntax, I was thinking either /:id([0-9]+) or #id^[0-9]+$ or /#id([0-9]+) .. I think the first or last one is best. example would be ... /users/#id([0-9]+) and /users/#username([a-z]+)\n. if you get any success tho, perhaps open a new issue where we can discuss it\n. well, for you to just get by, I recommend just keep the same name for the url param and keep going. like /:year_id/:month/:id/thumb.jpg and /:year_id/thumb.jpg`.\nno need for test case, I have it already, Im just trying to still figure out if its worth supporting the edge case. I'll try out echo to see how they'd work with the /:x/:y case we talked about above\n. Awesome \n\nOn Aug 25, 2016, at 9:50 AM, Simon Green notifications@github.com wrote:\nyeah, that's what I'm doing ... just figured it may save someone the same initial confusion when just one route param didn't seem to work (esp. as it could be adding another route, someplace else that breaks it).\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub, or mute the thread.\n. solved by v3 release 02e6bbdfd14640d8c1beb15ec3a38140400fb5c2\n\nSee complete CHANGELOG for v3: https://github.com/go-chi/chi/blob/master/CHANGELOG.md. hey @didip - yea you can do:chi.NewRouter().Get(yourHander.ServeHTTP) \n. @didip yea, I'd rather not do that.. I want to keep Router interface simpler/smaller. \n. hey @chenjie4255 - the reason is because the r.Options(\"/*\", h) will route will match everything other than \"/foo\", that is a wildcard route path that will match routes that don't match any other static routes like \"/foo\". Give it a try on a path like /blahafsd and you'll see the OPTIONS request will return 200.\nif you are trying to capture every OPTIONS request then I recommend you instead create a middleware such as..\ngo\nfunc AllOptions(next http.Handler) http.Handler {\n  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n    if r.Method == \"OPTIONS\" {\n      // your logic..\n      // w.Write(yourResponse)\n      return // we return because likely we want to finish the request here.\n    }\n    next.ServeHTTP(w, r) // keep processing for non-OPTIONS methods\n  })\n}\nthen r.Use(AllOptions) after the Recoverer\nare you trying to do some cors stuff..? have a look at https://github.com/goware/cors\n. solved by v3 release. hey @elithrar @VojtechVitek and others, I did a bit of work on the render subpkg today. Ive written request body decoding to be a bit nicer and I introduced render.Bind() as a middleware to automatically bind a request body to a struct value/object.\nhttps://github.com/pressly/chi/pull/85/files\nlook at CreateArticle and CreateArticle2 for both versions and check the router definition too. After doing it though, I like the Decode() stuff, but I'm probably going to remove the auto-binding stuff since it doesnt help that much.\n. @elithrar thanks a lot - check again when you have some time, I've made further improvements to the render API that I'm pretty happy with. I did remove the Bind() trick. As well, I added a few todos for me to complete writing some methods in render that easily build response payloads from a data type and a response type.\n. Yea it's there, just check in the branch's commits\n\nOn Oct 14, 2016, at 12:31 AM, Matt Silverlock notifications@github.com wrote:\n@pkieltyka Do you have the diff between the current HEAD on that branch and the prior?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub, or mute the thread.\n. btw, I believe with this new language change in Go 1.8 that allows struct objects to be easily converted to another type with the same columns but differing struct tags could be a very useful way to implement some of the ideas in this issue/PR\n\nhttps://beta.golang.org/doc/go1.8#language for more details. I don't believe it belongs in the chi core libs, but could be a very useful project to be used together. @msaron stay tuned. I have something non-tag based and veryyyy simple for request and response paylods for chi/render.. Yea, sorry I dont understand the need for a CSV renderer inside of chi. However, please do create a separate project/pkg and tell us about it. I think we should start a list for projects that are made to work with chi. Perhaps a separate PKGS.md in the repo. @msaron Keep in mind, a nice pattern would be for you to make your own render package, and just use chi/render behind the scenes - kind of like pkg composition. Take a look at https://github.com/goware/lg/blob/master/lg.go for an example in how we get in front of the logrus package. I believe this is the best approach and lets you take control for all your renderering needs. This is also my intention with chi -- to always give control to the dev, no framework lock-in, and we do that by design.. btw - I've pushed a new version here: https://github.com/pressly/chi/pull/173 and a complete example: https://github.com/pressly/chi/blob/render/_examples/rest/main.go. completed + merged in https://github.com/pressly/chi/tree/v2.1.0. Closing this branch, replacing it with newer work.. thanks for the PR! I agree we don't need the panic(\"unreachable\"), this project only works with Go 1.7+ anyways.\n. if you're looking at the render subpkg, I'd love your opinions on #84. I plan to revise render in parts to better consider well-defined request and response payload types. #84 would also likely change some of the Presenter stuff as well.\n. @zbindenren what are you trying to achieve?\nbtw, chi has https://github.com/pressly/chi/blob/master/chi.go#L82-L90 for very simple walking, you can see example use in docgen package.\n. @cyx yea I've gone back and forth with this one myself. I've implemented it, then removed it, then thought perhaps we should bring it back.\ncan you describe your use case for a base context? what would you use it for?\n. @cyx that isn't actually a reliable solution to a graceful shutdown of your servers. A cancelation signal will cancel all in-process goroutines. What is actually necessary is a signal on the context that tells the listeners to stop any further processing, but to finish up their work. See https://github.com/pressly/chi/issues/58\n. @cyx let me know if you get any success or some other ideas on how to approach it though\n. @cyx id love to get into it, but I'm under a pile of work onboarding a bunch of customers this week\n. btw, here is a PR to add this functionality https://github.com/pressly/chi/pull/92\nI'll be adding a _examples/graceful example too to this PR that uses the new https://github.com/goware/valve package to manage graceful shutdowns, utilizing a base context\n. done in a526d0cd90dc44b65a6cbde23b0bf34718eddc59\n. Pressly.com is of course using chi :) \n. cc`ing a few contributors and devs I spoke with previously: @cyx @ustrajunior @Vektah @xiam @kanocz @november-eleven @mrcpvn @elithrar @ChrisHines @lxfontes @lwc @abh1nav \nif you guys have some feedback please let me know as I prepare a blog post about chi and how to write RESTful services in Go.\n. thanks everyone for letting us know :) this is great and makes us want to make chi even better\n. @kanocz thanks a lot for the PR! I think though these sort of helper functions belong in the application code, or in an app subpkg.\n\"Perfection is finally attained not when there is no longer anything to add, but when there is no longer anything to take away.\" -Antoine de St. Exupery \n. @lwc thanks for the references.\n@kevinconway yea it's been talked about a few times and I've spent a lot of time thinking and iterating to try to get the cleanest design of the chi Router. \nHere were the options..\n1. For each routing method function, we have variations accepting a http.Handler or http.HandlerFunc - as described in this issue: Get(string, http.Handler) and GetF(string, http.HandlerFunc)\n2. Single routing methods that accept handler argument of type http.Handler\n3. Single routing methods that accept handler argument of type http.HandlerFunc\n\nOption 1 isn't ideal because it makes the chi.Router interface huge, by adding another 9 functions to the interface. The simplicity and surface of the Router is important to me to stay as minimal as possible. Btw, I was initially thinking to support Get(string, http.HandlerFunc) and GetH(string, http.Handler).\nOption 2 is what I had originally in chi v1 until I realized option 3 is a bit more elegant because it offers a cleaner API. Under option 2, you'd have to wrap endpoints such as..\ngo\nfunc myHandler(w http.ResponseWriter, r *http.Request) {\n  // ...\n}\nwith http.HandlerFunc(myHandler), such as r.Get(\"/\", http.HandlerFunc(myHandler)). This would be quite common and isn't ideal.\nOption 3 (the current implementation) accepts func(http.ResponseWriter, *http.Request) to the routing methods as its the underlying type of http.HandlerFunc, which I believe is the most common case for passing to routing methods. The downside is for http.Handler's that are passed, they must call .ServeHTTP to make it a HandlerFunc signature. I believe if I'm foregoing option 1, then this becomes to best choice.\n. @kevinconway good point about having Handle() and HandleFunc() the same in chi as in http.ServeMux - and in fact I checked and its matches up in the current version. \nInteresting idea to pass the http method, perhaps we'll do that sometime. For now, yea let's stick to option 3 and we can leave this ticket open for a bit for others to offer some feedback too.\n. hey @rossnanop - hmm, you can definitely wrap the chi router, and I encourage it as necessary to compose additional logic, but in the small example you already have this out of the box:\ngo\nr := chi.NewRouter()\nr.Get(\"/\", myHandler)\nhttp.ListenAndServe(\":3000\", r)\n. hey @mvdan thanks man, we've worked hard to keep middleware lean and robust. \nI agree the middleware logger doesn't fit all needs, especially lacking structured logging. The nice thing about chi is that its fully compatible with the stdlib, and any other handler or middleware in the ecosystem that as well uses just the stdlib, that is http.Handler or func(http.Handler) http.Handler and r.Context() from *http.Request. Therefore you could write a logger in any repo, and it would 'just work' in chi, as well work perfectly well for any other Go project that uses vanilla http.Handler's :) \nSo far, we have used https://github.com/goware as our \"contrib\" for chi, since its really not chi specific, nothing is chi specific, its Go net/http specific\n. Ok cool, thanks for the feedback, I'll make sure to clarify in the README\n. @mvdan https://github.com/pressly/chi/commit/2fb5424b313fbe427e2e337f20f2b45535ca3e0a -- please let me know if thats better and if there are other parts in the docs that could be better or parts you feel are missing or under-represented. thanks!\n. I think its good to run chi through a linter, but I'd like it to be the standard one, but one author's version of it, it's a whack-a-mole game\n. Done! chi's middleware.Logger now supports quite well logging customization. Here is an example structured logger that can be adapted to any other backend: https://github.com/pressly/chi/blob/master/_examples/logging/main.go. @yargevad thanks for this PR! looks good, I am going to dive into it and put some brain power behind it before I merge it. Can you also provide an example format you use that drove the reason for the addition to customize the output?\n. @yargevad nice, this is awesome! exactly what we need\n. @yargevad btw, https://github.com/yargevad/dengo/blob/master/201610/routes.go#L10 you can return http.Handler or chi.Router instead of a *chi.Mux\n. Yea I've been prototyping some slight changes on the side too. The LogFormatter is a good idea and I've made a few improvements, I'll be done hopefully next week but I'm pretty busy with normal work too. In the mean time you could make your zap logger outside of chi/middleware\n\nOn Oct 26, 2016, at 6:58 PM, Dave Gray notifications@github.com wrote:\nThere are a few improvements I should still make here, for example defaultLogFormatter doesn't really need to be a struct, and Recoverer calls debug.PrintStack() which doesn't have a chance to use the customized logger.\nLet me know what other changes you have in mind and I'll work on those too.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub, or mute the thread.\n. @yargevad thanks for inspiring a lot of ideas! I've just pushed https://github.com/pressly/chi/commit/b228440f3ccdc3cc4a4f528fc4ed6700e705ade2 and https://github.com/pressly/chi/commit/7c51c558b51f5740cec86b1b69634f72f17ae72f. please show some example code, I dont understand the issue yet\n. dupe https://github.com/pressly/chi/issues/100\n. Looks similar to https://github.com/pressly/chi/issues/78\n. solved by v3 release 02e6bbdfd14640d8c1beb15ec3a38140400fb5c2 \n\nSee complete CHANGELOG for v3: https://github.com/go-chi/chi/blob/master/CHANGELOG.md. hey @ivoszz I see, potentially I can put a MethodNotAllowedHandler http.Handler on the chi.Mux and let you set it there. That will work but I need to check the interaction with subrouters.\n. @ivoszz I was just checking into this, and it seems the current methodNotAllowedHandler just returns 405 with an empty body, so it should be valid to the response of your json handler\n. got it, good points\n. :) no prob. I'm not a fan of either gopkg.in or glide. I prefer just normal vendoring (ie. govendor).\nI can make a v2 branch that mirrors master if it helps others though. What is required? (can you give me the debrief before I say yes/no), thanks.\n. @Scapal a group that is part core and part community is working on a dependency management tool -- here is the draft: https://docs.google.com/document/d/1qnmjwfMmvSCDaY4jxPmLAccaaUI5FfySNE90gB0pTKQ/edit \nsince Go 1.7, the go cli will recognize packages in a ./vendor folder first then search $GOPATH for depedencies. Look up \"go vendoring\". The missing part today which the draft above covers and tools like glide and govendor implement is actually fetching and managing the files in ./vendor/\na good approach (like govendor does), is store the lock file in ./vendor/vendor.json\nand yes absolutely commit your vendor tree to git. it's actually a very nice experience.\ngovendor is great, except the cli is kind of awkward because its so powerful. hopefully the guys working on the dep tool above will achieve something very smooth (im confident they will).\n. yea definitely we can improve this if is preventing you in gitlab. I can try to remove them as long as everything continues to link up, otherwise we'll have to add an option like you suggested.\n. @clinta can you be specific about what you have in mind to resolve this and whats the issue? id like to resolve/close\n. thanks for the PR @clinta \n. @nhooyr this is how we can keep routers completely independent, and when mounted, we have a middleware that changing the routing path at runtime for what the subrouter expects. Another approach would be to have a single large tree, but there are more downsides to that approach (I wrote a version like that too and scrapped it).\nis there something you're running into where the current implementation is problematic?\n. @nhooyr whats happening in https://github.com/pressly/chi/blob/master/mux.go#L229-L233 is that after a call to r.Mount(\"/articles\", ArticlesRouter) and ArticlesRouter is an http.Handler (say a chi.Router specifically), the r router actually matches on /articles* pattern and the Mount() function will set the endpoint handler for the /articles* pattern to a handlerfunc that modifies the routing Path and called the subrouter ArticlesRouter as you can see in https://github.com/pressly/chi/blob/master/mux.go#L232\nthen, the main http.Handler of the router method, routeHTTP, we look at the context RoutePath or r.URL.Path for the path to search for a matching handler: https://github.com/pressly/chi/blob/master/mux.go#L330-L333 and https://github.com/pressly/chi/blob/master/mux.go#L343-L347 \na large tree didn't work because it would require cloning the nodes from one instance to another, and given its a radix tree with different types of branches at any level, it broke subrouting semantics at certain levels. As I was writing it in a TDD approach, I found certain cases were more complex to solve versus attaching subrouters as implemented in the release.\nbtw, the \"/\" is there just because that is what r.URL.Path returns always as the first character, so we keep it consistent when routing as a subrouter. It's a recursive algorithm.\n. because that doesn't make sense, the tree is independent of http routing, and the mux uses the tree to keep track of its patterns with associated handlers, but the mux does the routing and serving handlers\n. hope that clears it up. \n. Perhaps you should look elsewhere if you're so unhappy?\n. this would have been solved by the 1.8 alias feature, which may come in 1.9.\nI have thought about this, but this problem you speak of, isn't up to chi. Chi uses standard net/http which uses \"context\", and so we depend on the same \"context\" thats now part of the http.Request object.\n. well, let me know if you come up with something.. I agree this isn't ideal. I'm pretty sure if I made a branch of chi that used \"golang.org/x/net/context\" it wouldn't help anyways because of net/http's use of \"context\". \n. well you can use https://github.com/pressly/chi/tree/v1 which is almost identical and is compatible with \"golang.org/x/net/context\"\n. Thanks @VojtechVitek for the work! I'm also interested to hear the opinion of others for this kind of PR. The pros/cons as I see it are that, pro: middleware signatures are easier to remember, con: it is never the less non-standard and breaks interoperability with stdlib. The premise of chi is to be completely interoperable with the stdlib and any other handlers/middlewares that are built with it. But maybe this middleware signature is common too, so let's have it sit and see what the community thinks. \n. going to close this, as its best to keep it completely standard. good question, its also the convention, but someone can choose to use a method however they would like. \n. hey guys, yea, @pxue called it. It's the mix up between x/net/context and context which are not compatible with eachother, they are technically different types. Perhaps in 1.9 when they figure out aliasing this will get smoothed out.. that is a while from now. I bet there would be a way to make some pkg that allowed you to use both because it would translate between the types, perhaps I'll write that one day.\n. @smacker a PR would be great, at a minimum it will help understand possible situations better.\n. perhaps write a quick one to hack it, see how you can make it work as you expect, and we can iterate/refine from there\n. nicely done. thanks for the PR!\n. yes, true it definitely can be. feel free to submit a PR for this if you like. closing as this isn't an issue, but if you want to submit a PR sometime, go for it. @nhooyr for a little bit of performance, but primarily reasons of allocation and reusing the url params dictionary. hey @dbudworth thanks for the report, I've reproduced the issue, I'll fix it by tomm.. @jiop thanks for this, but a part of me would rather keep Router small, even though the Mux has a few extra methods that are available to it. In that case, one could assert to a Mux to use it, and in actuality, chi.NewRouter() returns a Mux. Let me know what you think.. @jiop yea I agree with that rationale. I felt MethodNotAllowed won't be used as commonly as NotFound, so thats why I kept it a little bit lower level. I'll leave this PR open and see what other contributors think too.. Hey Jeremie, I'm going to hold off for now. @umputun interesting, I tested this a bunch of times and it was fine. I'll add a test case for this -- however, something to note is that in Go 1.8, this will be standard functionality and won't even be necessary, so I'll probably check for just Go 1.7 and do nothing above that.. btw, if other users are having this same issue, please report. Cool. I'll fix it soon, but once 1.8 hits this middleware won't be necessary and every request will have this behavior.\n\nOn Dec 8, 2016, at 5:52 PM, LE ROUX Thomas notifications@github.com wrote:\n@pkieltyka I had the same issue while using hey load generator with go 1.7.3.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub, or mute the thread.\n. @umputun @november-eleven Im unable to reproduce the bug on 1.7.3 or 1.8b1\n\nI wrote this program https://gist.github.com/pkieltyka/8be94802255ea023cb1cc59327d44670 to try to simulate the bug, but no luck. If you guys can send back a gist with the bug (or even better a test case), I'll be happy to fix it. Here is the start of a test case as well for CloseNotify: https://gist.github.com/pkieltyka/a4bbf38318b321c3dd21504d26c73821 .. which is also passing, however, it may need a custom ResponseWriter and check the writeHeader doesn't happen twice, but still Im unable to trigger the warning.. btw, I don't think we're simulating the problem correctly, the client needs to close early to trigger the problem. Some browsers will do this on refresh to a request. \nhowever, even in Chrome which closes a running connection with a refresh, the server's output looks like..\n\"GET http://localhost:3333/ HTTP/1.1\" from [::1]:59724 - 200 11B in 2.002588196s\n\"GET http://localhost:3333/ HTTP/1.1\" from [::1]:59724 - [disconnected] 11B in 2.003083784s\n\"GET http://localhost:3333/ HTTP/1.1\" from [::1]:59725 - 200 11B in 2.003003779s\n\"GET http://localhost:3333/ HTTP/1.1\" from [::1]:59725 - 200 11B in 2.0049129s\n\"GET http://localhost:3333/ HTTP/1.1\" from [::1]:59726 - 200 11B in 2.000145561s\n\"GET http://localhost:3333/ HTTP/1.1\" from [::1]:59726 - [disconnected] 11B in 2.004778573s\n\"GET http://localhost:3333/ HTTP/1.1\" from [::1]:59727 - 200 11B in 2.000354583s\n\"GET http://localhost:3333/ HTTP/1.1\" from [::1]:59727 - 200 11B in 2.002733109s\n\"GET http://localhost:3333/ HTTP/1.1\" from [::1]:59727 - [disconnected] 11B in 2.003348645s\n\"GET http://localhost:3333/ HTTP/1.1\" from [::1]:59732 - 200 11B in 2.000938948s. @umputun no errors on go 1.8b1 with that code and ab command. I'll have someone try it on 1.7 in a minute. What exact go version and OS are you running?. interesting. thanks. @umputun confirmed on 1.7 on osx it does have this error, but there is no error on 1.8b1. @chenjie4255 thanks for bringing this to my attention, there has certainly been a regression here. I will fix it in a few minutes.. fixed by 18893e620db10241dd2066014f5b8ef60b2d413e. @NikosEfthias can you explain some more please? \nhowever, I have just committed 46d56496c539ad41168671a6b6503f0bacb30a78 which will let you set your own middleware.DefaultLogger = etc... and you can change the logger that you pass to it, so you can specify a file or whatever else you like.\ncheers, happy NY. @NikosEfthias thats not something to really document, and middleware is a package, not an unexported keyword. \nsomething like so is what you want..\n```go\n// from within your program\n// adjust the customLogger as you want, to a file or however you want\ncustomLogger := log.New(os.Stdout, \"\", log.LstdFlags)\nmiddleware.DefaultLogger = middleware.RequestLogger(&middleware.DefaultLogFormatter{logger: customLogger})\n```. @NikosEfthias indeed you are right.. this will fix it: 076deb80de4f344b761681f2afadf708430cfd41. all good :) thanks for bringing it to my attention, but yes PRs are definitely welcome too!. Where does it import net/context? You might be on an older version before context was in stdlib\n\nOn Dec 29, 2016, at 3:33 PM, Rob van der Linde notifications@github.com wrote:\nChi advertises itself as a Go 1.7+ framework that has 0 dependencies, yet it still imports \"golang.org/x/net/context\" instead of just \"context\".\nThis has the side effect of adding all of golang.org/x/net into my vendor directory when it isn't really necessary.\nI have tried changing over the imports in Chi to \"context\" and everything works fine. Is there any reason this isn't done already? Or is it for < Go 1.7 support.\nIs there a roadmap of changing this over to \"context\" and dropping older Go versions?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Yea. Use master, it's very stable . @smacker I see, so you want these ID's to be consistent between http requests and other actions? yes, I can move https://github.com/pressly/chi/blob/master/middleware/request_id.go#L65 to a public function to generate the next request id, thats okay with me. @smacker I've added middleware.NextRequestID() for you :). PR's are welcome :)\nOn Dec 31, 2016, at 10:34 AM, Laurie Clark-Michalek notifications@github.com wrote:\nhttps://github.com/felixge/httpsnoop/blob/master/wrap.go#L52 although maybe one could just implement all the different combinations..\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. I think http and http2 fancy writers make sense too. @lclarkmichalek yes probably. I'll give it a closer look but I don't know when I'll have a chance to dive in. . @lclarkmichalek thanks for the PR. So from the looks of it, you've made two fancyWriters, for go<1.8 and go>=1.8, to account for the new http.Pusher interface. As well, depending on the protocol version you remove http.Hijakcer from http2 because its unsupported/incompatible with HTTP2. Does this take care of other http2 interfaces on the ResponseWriter? \n\nis there anything else or any other considerations we should make?. nice work btw, this looks good. @lclarkmichalek I appreciate the work for sure! I need to get my head into this again the properly evaluate it. Sometimes when things get too complex, we need to revisit the approach and purpose. @lclarkmichalek what do you think of this? https://github.com/pressly/chi/pull/126 \nThe way I've seen it, the current WrapWriter fails to support the cases:\n\nHTTP2 does not support http.Hijacker\nGo1.8 introduces new http.Pusher support for HTTP2\n\nthis PR will smooth that out, for 1.8+ it adds implementation of http.Pusher() to the http2FancyWriter. thanks for the help @VojtechVitek . closing this PR for a few minutes. I will open a new one that includes the original commits from #124. @mpholcomb I see what you mean. You'd like to see URLParams initialized and at the very top of the routing path. Unfortunately this won't work by the design of chi's tree. It might be possible to do a first-pass through the routing tree just to determine the urlparams, and then again to actually route to the handler, but I don't like that solution. I'll keep it in mind when I'm solving #78 - but think it would be quite a stretch because the URLParams might best stay built on the execution path.\nIm not sure if using param key is a good way to be supporting rule signatures. We've implemented an ACL router on top of chi.Router internally at Pressly (which I'd like to polish and open source someday), it looks like this: https://gist.github.com/pkieltyka/ac40ab917470e6d0c8e951b49b22d497\nThat implementation is incomplete but might give you some ideas. What it does is build an acl path according to the structure of the tree by injecting middlewares that set a acl.route value on the context.\nin the end it looks like..\n```go\nr := acl.NewRouter(\"hubs\")\nr.Get(\"/\", ListHubs)\nr.Post(\"/\", CreateHub)\nr.Get(\"/following\", ListFollowedHubs)\nr.Route(\"/:hubId\", func(r chi.Router) {\n    r.Use(HubCtx)\n    r.Use(PublicHubPermissions)\n    r.Use(SecretHubPermissions)\nr.Get(\"/\", GetHub)\nr.Put(\"/\", UpdateHub)\nr.Delete(\"/\", DeleteHub)\nr.Post(\"/upgrade\", UpgradeHub)\nr.Get(\"/tags\", ListHubTags)\n\nr.Route(\"/users\", func(r chi.Router) {\n    r.Use(acl.Route(\"users\"))\n    r.Mount(\"/\", access.Routes())\n    r.Get(\"/\", ListUsers)\n    r.Post(\"/\", JoinHub)\n})\n\n// ...etc..\n\n})\n```\nas request path, the ResourceControl make sure to check a user permissions context value and tests the acl routing path and either keeps going, on stops. A short rule list would be: [\"hubs:r\",\"hubs.users:r\"]\nWe thought a lot of this as permissions in a filesystem.. Yea it's still missing support for compress18\nI realize it makes sense for chi to support the current and one back version going forward. So 18 and 17 now, and eventually just 19 and 18, which should reduce these nuances as http2 will be mature by then\n\nOn Jan 5, 2017, at 6:00 PM, Laurie Clark-Michalek notifications@github.com wrote:\n@lclarkmichalek commented on this pull request.\nLooks good, I like the changes to reduce the amount of stuff in the 1.8 specific files. I've added a couple of comments. This doesn't handle the compression middleware atm I think?\nIn middleware/wrap_writer17.go:\n\n+package middleware\n+\n+import (\n+ \"io\"\n+ \"net/http\"\n+)\n+\n+// NewWrapResponseWriter wraps an http.ResponseWriter, returning a proxy that allows you to\n+// hook into various parts of the response process.\n+func NewWrapResponseWriter(w http.ResponseWriter, protoMajor int) WrapResponseWriter {\n+ , cn := w.(http.CloseNotifier)\n+ , fl := w.(http.Flusher)\n+ _, rf := w.(io.ReaderFrom)\n+\n+ bw := basicWriter{ResponseWriter: w}\n+ if protoMajor == 2 {\nThis is much nicer\n\nIn middleware/wrap_writer18.go:\n\n+import (\n+ \"io\"\n+ \"net/http\"\n+)\n+\n+// NewWrapResponseWriter wraps an http.ResponseWriter, returning a proxy that allows you to\n+// hook into various parts of the response process.\n+func NewWrapResponseWriter(w http.ResponseWriter, protoMajor int) WrapResponseWriter {\n+ , cn := w.(http.CloseNotifier)\n+ , fl := w.(http.Flusher)\n+ , rf := w.(io.ReaderFrom)\n+\n+ bw := basicWriter{ResponseWriter: w}\n+ if protoMajor == 2 {\n+     , ps := w.(http.Pusher)\n+     if cn && fl && ps && rf {\nI don't think HTTP2 requests have ReaderFrom\n\nIn middleware/middleware18_test.go:\n\n\n}\n_, rf := w.(io.ReaderFrom)\nif rf {\nt.Fatal(\"request should not have been a io.ReaderFrom\")\n}\n_, ps := w.(http.Pusher)\nif !ps {\nt.Fatal(\"request should have been a http.Pusher\")\n}\n+\nw.Write([]byte(\"OK\"))\n})\n+\nserver := http.Server{\nAddr:    \":7072\",\nHandler: handler,\nThis handler should be wrapped in a middleware to have this test check that the response writer still has the interfaces expected after wrapping.\n\n\nIn middleware/middleware18_test.go:\n\n\n\"net/http\"\n\"testing\"\n\"time\"\n+\n\"golang.org/x/net/http2\"\n+)\n+\n+// NOTE: we must import golang.org/x/net/http2 in order to explicitly enable\n+// http2 transports for certain tests. The runtime pkg does not have this dependency\n+// though as the transport configuration happens under the hood on go 1.7+.\n+\n+func TestWrapWriterHTTP2(t *testing.T) {\nhandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n_, cn := w.(http.CloseNotifier)\nif !cn {\nt.Fatal(\"request should have been a http.CloseNotifier\")\nNow I think about it, these messages should probably all read ResponseWriter should have been ...\n\n\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. all done. thanks for the feedback. I added a one-liner for it, thanks for the PR anyways. @durdn thanks for the report. we'll fix it :) \n\ncc: @VojtechVitek - whichever one of us gets to it first. I'll try to look at this tomorrow.. fixed in 49a0ea6f6b92d0a7deebc7dd7c7350974e0c70ef. Will do! Thanks for letting me know\n\nOn Jan 5, 2017, at 5:58 PM, Brad Murray notifications@github.com wrote:\nI've found that tools like https://github.com/constabulary/gb don't work nicely with your releases because of a semver issue\nBasically the problem is http://semver.org/#spec-item-9\nA pre-release version MAY be denoted by appending a hyphen and a series of dot separated identifiers immediately following the patch version\nPoint being it needs a hyphen to comply with the spec\nv2.0.0rc1 is not valid, but v2.0.0-rc1 is.\nWould it be too much trouble for you to please push another release with a valid tag? The old one can still exist to as not to break things for other people.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. @VojtechVitek yea, I agree. It's been a long time since the rc. v2 is here! https://github.com/pressly/chi/releases/tag/v2.0.0. @kpurdon thanks for the proposal. I think its a good idea, but I'm always trying to keep the chi project as minimal as possible. I think this along with other common test helpers would make for a good auxiliary testing package for chi.. hey guys, with the recent move to a dedicated org for chi projects to https://github.com/go-chi we can start thinking about a project specific to testing chi APIs. thanks gents. @brycereitano its a good point - I was circling the decision if it makes sense to make URLParams writable, testing is a good example where it is helpful. I'll look into it again thanks. @lclarkmichalek maybe we should set the Content-Length by the actual compressed body?. what is setting Conte-Length in the first place btw?. @kevingo thanks for this . This is very helpful thank you @cyx cc: check this out @VojtechVitek \n. @prettyxw thanks for the PR and kind words :) cheers. @diegobernardes hey there - can you provide a small gist example that shows the problem? Im not sure what chanErr and chanResp are in the first example. I'll give it a review though. I tried this little program\n\ngo\nfunc main() {\n    r := chi.NewRouter()\n    r.Use(middleware.RequestID)\n    r.Use(middleware.Logger)\n    r.Use(middleware.CloseNotify)\n    r.Get(\"/\", func(w http.ResponseWriter, r *http.Request) {\n        time.Sleep(1 * time.Second)\n        w.Write([]byte(\"hello world\"))\n    })\n    http.ListenAndServe(\":3333\", r)\n}\nand likewise in the browser reloaded the page before the request could finish (simulating a disconnect), and I couldnt get a race to occur. Thanks @diegobernardes I'll fix it soon. I believe the fix is very easy, which is to just comment out https://github.com/pressly/chi/blob/master/middleware/closenotify.go#L25 because its really just for internal communication to the logger to print disconnected, its not that useful. I will update the behaviour. From that point, I do believe middleware.CloseNotify() will effectively be a no-op in go 1.8, perhaps panic that it should be be used 1.8+ because the default behaviour is to cancel a context when a client disconnects.. Resolved by 7765b0916fdc6791938554e9d53d39cae059ac8c. Makes sense, I recommend not using them together, based on how the profile sets up its routes. If you must, you can use r.Group() to have a separate middleware chain for a different set of routes along the same point.. nice, but Id like to keep chi very minimal, so best to use this middleware in your packages.. Please review https://github.com/pressly/chi/blob/master/_examples/rest/main.go and https://github.com/pressly/chi/blob/master/_examples/todos-resource/main.go. @dadatawajue for a controllers package / pattern, I think you'd be pleased with: https://github.com/pressly/chi/tree/master/_examples/todos-resource -- check out the approach there. \nAs for lang, you could do it as url param like you've done there and reference \"lang\" from chi.URLParam(r, \"lang\"), or put the lang on the r.Context() through a middleware. Or use a request header and set lang on request context there.. thanks for answering the question @zet4 - I'm going to close this since question is answered. @medyagh chi is just a simple router, you can layer in any technique you'd like. I suggest doing some research on \"http caching\" and \"cache-control\". This is not something I'm willing to fix or change to support \n\nOn Mar 26, 2017, at 8:22 PM, Anders Johnsen notifications@github.com wrote:\nThe fix did not solve the issue presented here. Note that example provided expected the url-decoded result, not the raw value. That means this is a breaking change as all calls to URLParam now returns the raw path. I suggest this is changed such that all users of URLParam don't have to use url.Decode.\n\u2014\nYou are receiving this because you modified the open/close state.\nReply to this email directly, view it on GitHub, or mute the thread.\n. thanks for this PR, I will review it for correctness and performance soon. Hey Eric, I'm just in a short vacation but I'll be back on Sunday and review this PR / merge or otherwise next week! Cheers. Thanks for waiting. \nOn Feb 27, 2017, at 6:11 PM, Eric Meyer notifications@github.com wrote:\nDo you have a timeline for incorporating this patch? I've got a project that currently depends on my fork of chi, and I'd rather reference this repository's official version.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub, or mute the thread.\n. hey @eemeyer - after some benchmarks and thought, I've settled on 822e7b85e22b3f7a573782c3674edf8e732fb427 which resolves your issue, but you will have to unescape the value in the url param in your handlers. Thanks for the PR!. Hey @kpurdon yea definitely something that comes in handy. The support we have is the RoutePattern and RoutePatterns values on the routing context. You'll want to concat the RoutePatterns for the full thing. The only downside with current implementation is we build the pattern as the request passes through the handler chain, so just keep that in mind. \n\nBtw, what are you using it for? I hope it fits for you. yea, exactly, its a good use for metric tracking - we do the same thing at Pressly. it would be awesome to have Bitly on board as well :) good luck and I hope it ends up working out. btw here is an example middleware\n```go\nfunc main() {\n    r := chi.NewRouter()\nr.Use(middleware.RequestID)\nr.Use(middleware.Logger)\nr.Use(middleware.Recoverer)\nr.Use(middleware.TrackRoute)\n\nr.Get(\"/users\", userHandler)\n\nhttp.ListenAndServe(\":3333\", r)\n\n}\nfunc TrackRoute(next http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        next.ServeHTTP(w, r)\n        rctx := chi.RouteContext(r.Context())\n        routePattern := strings.Join(rctx.RoutePatterns, \"\")\n        fmt.Println(\"route:\", routePattern)\n    })\n}\n```. sorry, but no. Im very focused on keeping chi very precise, minimal and focusing on the future.\nif you want a x/net/context compatible version of chi, check out the v1 branch -- https://github.com/pressly/chi/tree/v1 . yea hopefully they upgrade appengine soon. You could always host somewhere else, then later move to appengine as you're closer to prod. @nkovacs what version of Go?. and http1 or http2?. @nkovacs can you try again? PR #154 recently merged should fix this as well. Im unable to reproduce the above issue with the latest master, but if you see it comes up again please re-open the ticket and I'll take a look asap.. @LadyDascalie I've tried to run your example using chi v3.3.1 on go 1.9.2 and couldn't reproduce the issue - the docs generated fine. Would you mind confirming when you have a chance?. @LadyDascalie awesome thanks for confirming!. good question. I believe r.FileServer(\"/\") will make a route on /* which catches every request to its handler. Potentially r.FileServer() impl could be changed to call r.NotFound() if a file is not found. \nYou do have the option to write the file serving handler yourself, the r.FileServer() is just a helper method. Please let me know if you solve it.. thanks for letting me know, but not at this time. But that should let you keep going, just take your own FileServer function to register the handler. thanks @jsadwith . @medyagh can you use the master version? middleware.CloseNotify has been removed.. i've confirmed that with the stack you listed (minus the CloseNotify middleware), everything works as normal. try it without glide, go get -u github.com/pressly/chi and use $GOPATH. if you get the same error, please include gist to your program. Sorry but you'll have to debug your own issues and if you want to report a bug, submit a test case. please submit a gist of a broken program and clear instructions on how to reproduce it. If i can reproduce it, I'll definitely fix it. @medyagh this is an incomplete program and I dont have memcache either. Please provide a minimal example with no dependencies. . Why not let the compiler complain and have people remove it? its a noop middleware. can you provide a gist..? I can't reproduce it. @nkovacs this isn't solvable as they're opposing logic to redirect slashes. If you have different needs, you'll want to use router.Group(...) to split up your middleware stacks. Thanks!. Like this? https://github.com/pressly/chi/issues/150 . ah I see. that isn't something supported by chi directly, but I am sure there would be a way for you to built it yourself by enhancing the chi.Router interface.. Hey Goran, yea this is intended and by design. If you really want it, you could make. Separate chain of middlewares with chi.Chain(mw1, mw2) and pass the request through in NotFound. \nOr try to make a top level subrouter, mount on \"/*\" a new subrouter with your actual routes. I believe the MW in the top router will execute.\n\nOn Mar 1, 2017, at 7:26 AM, Goran Popovic notifications@github.com wrote:\nCurrently, middlewares are not calle when NotFound handler is executed.\nIs this a design choice? and is there a way to achieve that functionality?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Interesting, perhaps they are then. The behavior changed from v1 to v2 so I just don't recall at this time. But given your example it looks like the middleware stack is called, which would be my initially thought it the ticket title threw me off a bit. I'm away this week but let me know.\nOn Mar 1, 2017, at 8:33 AM, Goran Popovic notifications@github.com wrote:\n@pkieltyka are you sure middlewares are not called? I tested now ..and it seems that middlewares ARE called .\nMy router looks like this\n```\napp.Router.NotFound(app.NotFound)\napp.Router.Use(app.WithLogger)\napp.Router.MethodNotAllowed(app.MethodNotAllowed)\napp.Router.Post(\"/\", func(w http.ResponseWriter, r *http.Request) {\n  w.Write([]byte(\"AAAAAAAAAA\"))\n})\nAnd i get logging line on every 404 and 405\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub, or mute the thread.\n. interesting, this must be the same as https://github.com/pressly/chi/issues/169. Fixed by 5b7406a71dbb35d4f59b0b48e68cd9f9256f5262. hi @MrXu - there is no bug here. Please work through the issue yourself, this is not a core concern of the chi library. . @didip this is completely possible, and you're right the only thing that would be necessary is to parse the param key up until one of the param delimiters such as / or .\n\n? isn't really an acceptable delimiter in any case for a url route.\nOne other thought is perhaps we should change the delimiter in generate for params to routes like /articles/{id} instead of /articles/:id this would free up : as a usable delimiter.. cc: @VojtechVitek . @didip btw, I agree we should improve param-key parsing, but I after thinking a bit more about your use-case which is to have the .:mimeType, I don't think it's ideal to add .:mimeType to every single one of your routes. It's probably better to write a middleware that will parse the extension from the RoutePath and directly put it into the URLParams on the routing context.. solved by v3 release 02e6bbdfd14640d8c1beb15ec3a38140400fb5c2\nSee complete CHANGELOG for v3: https://github.com/go-chi/chi/blob/master/CHANGELOG.md. thanks for the PR - but what is the value here? I'd like to keep ntRegexp because I want someone to implement it one day. . I'm going to hold off on this PR at the moment, it doesn't really change anything for now. Feel free to take some time at https://github.com/pressly/chi/issues/167 though :) . @mvdan I am very picky about changes to the chi project to uphold a very high code quality requirement and design. As well, I take a lot of consideration present and future to any PR or suggestion to the project - which can take time. Welcome to open source dev :) . @diegobernardes @gpopovic I have a solution for this and I'll publish it soon. fixed by 5b7406a71dbb35d4f59b0b48e68cd9f9256f5262. hey @sivasiva - absolute, this would work with chi just as:\ngo\nr := chi.NewRouter()\nr.Handle(\"/events/\", b). Please re-open with concrete examples.. hey @gfyrag - I've added support for LINK/UNLINK via 34b58319a8525bc149947d73f2a078462fe4f5aa\nin order to make use of it, you'll have to use Method() or MethodFunc() as in: r.Method(\"LINK\", \"/\", h). why not just use, /my/url/:param1 then?. yea I agree with you.. I think a better solution is to change from :param syntax to {param} which would solve the delimiter problem and you can place them anywhere on the route. . thank you. Solved by 6de63865c67bdd894f399a5b2b80026954546802. hey @dannyvankooten I really appreciate your gentle suggestions, and I finally see the point everyone is requesting. I'll see what I can come up with the support the pattern you described above.. solved by v3 release 02e6bbdfd14640d8c1beb15ec3a38140400fb5c2 - specifically, check out the new r.Method() and r.MethodFunc() routing methods\nSee complete CHANGELOG for v3: https://github.com/go-chi/chi/blob/master/CHANGELOG.md. Hey @daenney this is completely doable with chi today :)\nThe approach I'd suggest based on your description is to create a middleware and put it at the very top of your routing tree, where that middleware parses the request \"Accept\" header and sets on the context the kind of content response type, and the API version number, then you'll need some helper function or various possibilities to use the right render.Renderer to handle payloads for your respective version.. Give it a shot, perhaps in a small example forking from _examples/rest and let me know where you come to. If you give me a gist or some working example I may be able to help. The only part that needs some consideration is the pattern to select the appropriate renderer, but given that it's an interface, you could compose Renderers like you do middlewares -- as in, for each kind of payload type, which would read the r.Context(), check the version and then call its versioned payload Renderer method. I initially left it as an exercise for the reader :) there are lots of possibilities.. btw, the chi/render package has been moved to its own project repo at https://github.com/go-chi/render\nMade a reference here https://github.com/go-chi/render/issues/1. Hey @everdev this is a question for stdlib go, net/http - not really a chi thing.\nCheck out the Fragment on a url.URL and run some examples on how it works. Fragments/anchors are intended for the client-side and aren't something that are processed on the server-side.. Hey Marcel, yep that is on the list. \n. it might also be nice to support (I know others requested it) to offer a helper for building urls from named routes. Such as.\n```golang\nfunc Routes() chi.Router {\n  r := chi.NewRouter()\n  r.Name(\"articles\").Route(\"/articles\", func(r chi.Router) {\n    r.Get(\"/\", ListArticles)\n    r.Route(\"/{id}\", func(r chi.Router) {\n      r.Get(\"/\", GetArticle)\n    })\n  })\narticleUrlExample := r.URLFor(\"articles\", chi.Param{\"id\": \"1\"})\n  fmt.Println(articleUrlExample) // prints: /articles/1\nreturn r\n}\n```. hey @tiriplicamihai thanks for the offer to help! I have been working on a PR as the base for the v3 release which resolves #167 and soon after I'll work out the mechanics for #78 and #100. These are pretty deep into the mechanics of the trie inserting / finding algorithm so its probably best I just finish that off, but certainly it would help to get reviews, write more tests - and as well, would be cool if you could write the regexp support for that branch once its ready. I will try to finish it tomorrow and ping you to look at regexp param support if you're interested. \nOther work that I'd like to incorporate in the v3 release is improving chi/render further by having a full test-suite and considering the work required for #185 . Hey everyone, I just wanted to post an update on the status of v3\u2019s development. I have a local version that implements #78, #100, and #167 - the most challenging issues of the bunch, with all tests passing. I\u2019m pretty excited about this release as it makes chi\u2019s routing even more flexible with support for /articles/{month}-{day}-{year}-{slug} and /articles/{id} on the same router. Once I finish implementing regex support and confirm benchmarks are the same, I\u2019ll push the work and tag the first v3 beta.. hey @alinz - good news is Chi already supports adding routes dynamically / at runtime. Although it does not support removing routes you can either create a middleware that returns a 500 response for when the service isn't available (not online), and toggle it back when it re-registers. It's possible to solve your scenario already with chi. Let me know if you need any help thinking through your approach.. hey all, I've pushed the chi v3 branch here: https://github.com/pressly/chi/tree/v3\nIts been a ton of work, but Im very happy to say it's almost finished, see checklist above for the progress. I've done some benchmarks too and the performance is the exact same as v2. v3 is complete and released! also make sure to update your import paths to github.com/go-chi/chi\n02e6bbdfd14640d8c1beb15ec3a38140400fb5c2. hey @NikosEfthias good question - because of how docgen works, it needs to be compiled with the program that it is generating docs for. As a result, the way to trigger it as a cli flag when starting your server.\nlike here: https://github.com/pressly/chi/blob/master/_examples/rest/main.go#L99-L109. hey @NikosEfthias - docgen isn't made to replace all of your API documentation. Its more designed today as internal documentation to easily see your routing structure. If someone was willing to put more work into it, it could get better, but personally it's not a priority for me nor do I have the availability.. you must be doing something wrong. . check your imports, you're probably importing some other \"render\" package. thanks @MrSpock for weighing in and offering the help.. @stefanprodan thanks - did this work though? I believe you need parts := .... you're right @djui - I'll add it to the v3 list. @djui I just pushed a fix, please let me know if you continue to have issues. Have a look at http://github.com/pressly/imgry. @djui chi.FileServer() is intended as a helper handler, not as something core. I took a slower step with it by first introducing it to the *Mux and not the Router. . @djui that isn't an option, better to add FileServer to Router. My priority is v3 roadmap. @djui I suggest you write your own middlewares as you require. chi is a router at the core with some optional middlewares. Working through all the combinations of middlewares is a whack-a-mole game. chi only supports uses what is defined in the Router interface, otherwise it is a convenience / helper. Hey Yang, I saw casbin and I think it's awesome! Yes I'd love to have a casabin middleware for chi - which really means a standard http middleware :)\n\nOn May 11, 2017, at 9:46 PM, Yang Luo notifications@github.com wrote:\nHi, I'm the author of casbin, a Go library for authorization based on access control policy. casbin supports multiple access control models like ACL, BLP, RBAC. The access control rules can be persisted into files, DB. In fact, It already has some successful stories on web frameworks like Beego, Tango here: https://github.com/hsluoyz/casbin#our-users. And a user of casbin asks me to add the support for chi on the issues.\nI saw chi has a middleware framework. So what do you think by adding casbin as an authorization middleware? Thanks!\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Thanks :) I made a note about your community middleware in 898d761524954def9191dc8bea69191442581385. thanks for the PR but I've fixed it with: f262230f5155fe761ddca49f01f78d8383bcb145. hey @mihai-tiriplica-hs as @VojtechVitek mentioned, the context.Context really just signals to other contexts that the timeout has been reached, you have to stop processing on your own.\n\nSome examples: https://github.com/pressly/chi/blob/master/_examples/limits/main.go#L58-L73\nand for graceful shutdown: https://github.com/pressly/chi/blob/master/_examples/graceful/main.go. hey @Bartuz I chose the word chi as a flow of energy at balance, from the word \"qi\" of Chinese culture.\nphonetically it pronounced: ch-ee\nthanks for asking :) . \ud83d\udc4d thanks @Bartuz! . See chi/docgen source. @zemirco its possible already .. like so:\n```go\nfunc Instrument(next http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        m := httpsnoop.CaptureMetrics(next, w, r)\n        duration := float64(m.Duration / time.Millisecond)\n    rctx := chi.RouteContext(r.Context())\n    routePattern := strings.Join(rctx.RoutePatterns, \"\")\n    routePattern = strings.Replace(routePattern, \"/*/\", \"/\", -1)\n\n    requestDuration.WithLabelValues(\n        r.Method, routePattern, strconv.Itoa(m.Code),\n    ).Observe(duration)\n\n})\n\n}\n```\nplease let me know how it goes .. yeay or nay. I just added rctx.RoutePattern() to master as well.. @zemirco you'll have to build this yourself now :) we just offer support for core features. But what @VojtechVitek suggested makes sense.. @zemirco yea, in your fileserver specific middleware, just grab chi.URLParam(r, \"*\") . thanks @kowalczykp \nand thanks @VojtechVitek for reviewing. hey @keviswang - this isn't really a chi-specific question, please check stackoverflow. hey @carlqt yes I will make this possible in v3 :) and I will provide an example as well. @kuronyago thanks for that. the FileServer is the one exception which is not like any other routing method. \n@vojtechvitek perhaps we should remove the FileServer method as there has been a lot of confusion with it, and instead offer a helper snippet for people to write their own. @PlkMarudny it just hints to the render Responder that the content type should be JSON, the header is set right before the response body is sent back to the client, so long as you use render.Respond(). That's because when you call w.Write() it will send the header implicitly and the call to .Respond() will not then set the header. Remove the Write statement and it'll work.\n\nOn Jun 14, 2017, at 1:53 AM, PlkMarudny notifications@github.com wrote:\nBut when I use:\nr.Use(render.SetContentType(render.ContentTypeJSON))\nand\nr.Get(\"/ping\", func(w http.ResponseWriter, r *http.Request) { w.Write([]byte(\"{ response : pong }\")) render.Respond(w, r, nil) })\nThe headers returned are:\nHTTP/1.1 200 OK Date: Wed, 14 Jun 2017 05:51:18 GMT Content-Length: 24 Content-Type: text/plain; charset=utf-8\n\u2014\nYou are receiving this because you modified the open/close state.\nReply to this email directly, view it on GitHub, or mute the thread.\n. @dqminh thanks for the PR, just wondering why favour Since over Sub?. hey @samwierema thank you for this! since I pushed v3 today and changed its location, I couldn't merge your PR easily, so I just made the commit and provided credit in the log. Thanks again 7c1f98d4428e3642e0a7f8cabba5772a4e32f584. if someone feels like doing some open source work, this could be an excellent ticket to work on and PR :) especially if you're solving it for yourself.\n\nthe recap, the proposed design for a url route builder:\n```golang\nfunc Routes() chi.Router {\n  r := chi.NewRouter()\n  r.Name(\"articles\").Route(\"/articles\", func(r chi.Router) {\n    r.Get(\"/\", ListArticles)\n    r.Route(\"/{id}\", func(r chi.Router) {\n      r.Get(\"/\", GetArticle)\n    })\n  })\narticleUrlExample := r.URLFor(\"articles\", chi.Param{\"id\": \"1\"})\n  fmt.Println(articleUrlExample) // prints: /articles/1\nreturn r\n}\n```\nsimilar, but slightly different design..\n```golang\nfunc Routes() chi.Router {\n  r := chi.NewRouter(\"articles\")\n  r.Route(\"/articles\", func(r chi.Router) {\n    r.Get(\"/\", ListArticles)\n    r.Route(\"/{id}\", func(r chi.Router) {\n      r.Get(\"/\", GetArticle)\n    })\n  })\narticleUrlExample := r.URLFor(\"articles\", chi.Param{\"id\": \"1\"})\n  fmt.Println(articleUrlExample) // prints: /articles/1\nreturn r\n}\n```. hey @hsluoyz - there are many subpkgs id like to include around chi, without bloating the core library, so my thinking was a clear and dedicated org for chi related subpkgs would be an easy way to organize those projects. Soon I will be moving other pkgs to go-chi org for jwt auth, logging, acl, raml-based doc generation, shutdown signaling, etc. For example, as proposed by #212 it also makes sense to move render into its own repo as well under go-chi org. And finally, with the release of v3, I felt it was the right time to do it as v3 introduced other compatibility changes in the routing syntax, so I had done it all in one shot.. Sure I'll look into it soon\n\nOn Jun 25, 2017, at 11:20 AM, Hector Jusforgues notifications@github.com wrote:\nHi \ud83d\ude42 !\nBefore v3, I used to be able to do something like this:\nfor i := range chiContext.URLParams {\n  span.SetTag(\"urlparam.\"+chiContext.URLParams[i].Key, chiContext.URLParams[i].Value)\n}\nBasically a middleware logging every URLParam, no matter the route.\nBut now chi.Context.URLParams is a []routeParams: a slice of unexported struct type with unexported fields.\nIs there a way to range on all URLParams' key, value in v3+ ? Is this something you would consider supporting again?\nThanks\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. hey @hectorj please let me know how this works out for you: 25201e8a886f7ef210501dfa55759d4c1fdf0cce\n\nI've exported the URLParams underlying type so you can traverse it. You'll have to work with the new data structure, but the access is there. . interesting idea, I think this makes sense.. Moved render and docgen to https://github.com/go-chi/\nLinks:\nhttps://github.com/go-chi/render\nhttps://github.com/go-chi/docgen. thanks @kanocz - this is awesome! I will try it out and merge shortly. thanks for this! LGTM. hey @niklasj thanks for the details.\nparameter values in chi cannot contain the trailing character. For example in the routing path\n/articles/{file}.{ext} the \"file\" param cannot contain a \".\" in it, as it considers the \".\" to be the terminating character of the param value. If you're looking for a customized handling of extensions, try out the URLFormat middleware (https://github.com/go-chi/chi/blob/master/middleware/url_format.go) or adapt it to suit your needs. thanks for this, its solved alternatively fixing another bug with PR #224. thanks. updated the reference.. Interesting, something with the method routing is going on. I'll have a peak soon. \n\nOn Jul 1, 2017, at 8:41 AM, Kendell Fabricius notifications@github.com wrote:\nI observed something like this as well. The uri with parameters is sent to the wrong handler, so the parameters are pulled out of the uri incorrectly.\npackage main\nimport (\n\"fmt\"\n\"net/http\"\n\"github.com/go-chi/chi\"\n)\nfunc main() {\nr := chi.NewMux()\nr.Get(\"/comment/{slug}\", func(w http.ResponseWriter, r *http.Request) {\n  slug := chi.URLParam(r, \"slug\")\n  id := chi.URLParam(r, \"id\")\n  fmt.Println(\"SLUG:\", slug, \" ID:\", id)\n  fmt.Fprint(w, \"SLUG:\", slug, \" ID:\", id)\n})\nr.Delete(\"/comment/{id}\", func(w http.ResponseWriter, r *http.Request) {\n  slug := chi.URLParam(r, \"slug\")\n  id := chi.URLParam(r, \"id\")\n  fmt.Println(\"SLUG:\", slug, \" ID:\", id)\n  fmt.Fprint(w, \"SLUG:\", slug, \" ID:\", id)\n})\nhttp.ListenAndServe(\":3000\", r)\n}\nExpected:\nGET /comment/first-page -> SLUG:first-page ID:\nDELETE /comment/first-page -> SLUG: ID:first-page\nActual:\nGET /comment/first-page -> SLUG: ID:first-page\nDELETE /comment/first-page -> SLUG: ID:first-page\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Resolved by https://github.com/go-chi/chi/commit/49e7138cabd9e374dcbf1a3b56d3ba4a459763e2. hey @itsjamie - the syntax changed from :param to {param} - did you have a chance to review the release notes? https://github.com/go-chi/chi/blob/master/CHANGELOG.md#v300-2017-06-21\n\nlet me know . Oh, I see your issue now. Yes, this was a bug fixed in v3 :) see https://github.com/go-chi/chi/issues/179 for list of things fixed. this looks great thank you! A few requests\n\n[x] move walker code to tree.go\n[ ] remove older walk methods to remove code redundancy \n[ ] lets merge this PR once a PR for go-chi/docgen is ready. Cool find. Thanks @beornf for the PR, LGTM. hey @dvic - thanks for the PR on #218. I reviewed it and realized another bug was looming that caused the panic. Because, there should never be a case where a parameter key is present in URLParams, but a matching param value wouldn't be available, so I knew something was wrong there.\n\nI debugged it and found and decided that the router should return a 404 instead of matching the handler with an empty param value, because in the case, it does not correctly match the regexp \\d+ pattern and even if it was just a normal param, it still doesnt make sense to match it. https://github.com/go-chi/chi/blob/7eca4e6882ef07a411ec24e58894a14e4e2ea754/mux_test.go#L1290. please open in docgen repo. Please check releases notes / change log. Yes the repo moved to its own org. Can you elaborate on \"but this is giving me problems\". Thanks for the report. I'll get this supported eventually - PRs are welcome too from anyone interested :). thanks @nicpottier - I believe we could update patNextSegment() method to parse \"/{first:[a-z]{4}}\" without any restriction. As you parse the tokens, if you determine two {'s where one isn't closed, then we skip the second, keep track and look for the outer closing bracket. In case the count is off, panic to inform the expression of the tree is invalid (as we do with other invalid routing paths). thanks @nicpottier for the PR!. The project isn't set to any specific library. It's just the example that uses logrus. Feel free to copy the example and change to your needs. Hey Labutin, chi.Router is an interface and *chi.Mux's implementation adheres to that interface, so in Go you're able to pass objects to interface values that match. . hey @mrbanzai what kind of issue are you running into with resp_bytes_length? have you tried the logging example? would you be able to provide some sample code for your issue?. great work @mrbanzai - thanks for this. Fixed in 54701e3e85d6b453cb5f10cea6f218e4d3e56b7e. It sure can. Have a look at https://github.com/casbin/chi-authz for an example.. Make sure to specify .Get() and .Head() requests separately. 405 measures method is not allowed, which leads me to think you didnt define it.. @alehano I'll give this some more thought. I could add .GetHead() but, if they both point to the same handler then it will be up to the handler to ensure there is no message body returned based on r.Method == \"HEAD\" in the handler. \nI could set an EmptyBodyHandler set as the default for a HEAD in that situation, unless overridden with a .Head(). The changes to logic is why chi settles to do less and leaves it to the developer's choice. \nMy one thought is to offer chi.Options{} as an argument to NewRouter() to set such a behaviour, but it goes against my wishes to keep chi super lean and small.. @alehano it doesnt feel right to me to have GET and HEAD do the same thing as a default. But if others feel that is how it should work, I can make a concession for sure and add that line.. @DmitriyMV if we do implicitly set Head() in Get(), I would still allow users to override the Head handler by another explicit call to .Head() after the .Get(), so that should take care of it.. I think the approach that makes sense is:\n1. Create new chi pkg-level emptyBodyHandler which just executes w.Write(nil) \n2. Implicitly set the HEAD method in the Mux#Get method as so..\ngo\nfunc (mx *Mux) Get(pattern string, handlerFn http.HandlerFunc) {\n    mx.handle(mGET, pattern, handlerFn)\n    mx.handle(mHEAD, pattern, emptyBodyHandler)\n}\nUsers can still explicitly set the HEAD for a route with Mux#Head\nthoughts?. router.MethodNotAllowed(chi.PromoteHeadToGet) is clever way to enable this option but it might be too slick. I'll give this some more thought considering everyone's feedback. Thanks all.. cool. I will do something of this sort and send a PR. let me know what you guys think -- https://github.com/go-chi/chi/pull/247. fixed in 1b51a16ac893c99cc5978fca77249701129eedaf. @DmitriyMV are you referring to the FindRoute() definition change? or the fact that an undefined HEAD route will match its GET route? I believe by the RFC a HEAD should exist for GET routes: https://github.com/go-chi/chi/issues/238#issuecomment-319682229\nYou of course can still explicitly define a Head handler for a route, etc.. I have just released the change under https://github.com/go-chi/chi/tree/v3.2.0\nYou can use https://github.com/go-chi/chi/tree/v3.1.5 for compatibility with your app. . @DmitriyMV custom not found handlers still work as before, perhaps you had some weird logic handling HEAD requests in a custom not found handler? if so, perhaps setup a middleware looking for r.Method == \"HEAD\" and respond that way, which is a better approach (if you're doing some caching stuff)\nagain, we have version control / dependency management for a reason. indeed, that will not work as you've outlined there. But, Im not sure what you're trying to solve. Can you explain the logic you have where you must have a MethodNotAllowed handler that checks for HEAD requests to execute some logic? can you describe your use case. . an alternate approach: https://github.com/go-chi/chi/pull/248 - I do prefer its explicitness in setting this behaviour, as well better than MethodNotAllowed which feels like abusing the API. . one more approach: https://github.com/go-chi/chi/pull/249. @DmitriyMV / others - chi is a project Im obviously passionate about and I've spent a number of years designing and iterating with great care. I do my best to be responsive and take my time with implementations because I care about the architectural integrity of the project. However, like everyone else in OSS, I have tons of other responsibilities outside of this project and for the most part it's maintained by just myself - sometimes, I will make quick judgements and they cannot all be perfect. I should have waited for the feedback of others before merging/making a release, but I was excited to come to a simple solution so I hit the big green \"merge\" button. But guess what, we can iterate forward easily - I've already offered two alternate solutions, and you can lock onto a previous tag until one lands.\nIn after 2 years of working on chi, no one has ever told me they will recommend against it because of a minor commit - thats unfortunate. Sure, recommend against it because theres a better option or a fundamental flaw, but not because you didn't have your way. This is my first OSS project with larger adoption, and its interesting to see the sentiment after a small difference in preference. I can only imagine how hard the cryptocurrency space must have it.\nbtw, side note: depending on what you're building.. I highly recommend checking out gRPC and as well if you're targeting the Web/browsers, check out https://github.com/improbable-eng/grpc-web. gRPC in my opinion is the future for writing APIs and services - and its getting better everyday. . All good man. If you can look at https://github.com/go-chi/chi/pull/248 and let me know what you think - I am leaning towards that solution since it provides most flexibility to users through middleware. It adds a few APIs to deal with the routing during execution. It adds slightly more overhead for HEAD requests that use this middleware, but its negligible in a real-world scenario. \nAlso, check out: https://stackoverflow.com/questions/3854842/content-length-header-with-head-requests. I'll look into what is the correct behaviour of the HEAD later, that can be solved in the middleware impl. But regarding the PR, I will have to re-assign Routes each time to make sure the context state is valid before its routed, it its also just a pointer value so there isn't much overhead. I benchmarked the execution and it has negligible impact.. yea, I think #248 is better too because it keeps the core lean and extends the api slightly to offer more power for people to program their own middlewares to change routing behaviour for their needs. \nbtw, @VojtechVitek - FindHandler requires the *Context because its actually doing routing through the tree, where it stores the url param values during traversal. Perhaps there is a better name than FindHandler, as what its doing is Routing the method and path to a handler. Maybe, Traverse(...) http.Handler or Seek(...) http.Handler or Match(...) http.Handler. please review #248 again when you guys have a sec . merged #248. @NikosEfthias Id have to look into these details sometime. but, did you check the https://github.com/go-chi/chi/blob/master/_examples/fileserver/main.go example?\nit's likely the semantics of Handle() are not identical between chi and http. in that case, http.Handle(\"/assets/*\", http.StripPrefix(\"/assets/\", http.FileServer(rice.MustFindBox(\"assets\").HTTPBox()))) will probably work as well. Show sample program. you are welcome to pronounce it by your own rendition too :) . Im not familiar with how Gorilla's semantics work. Can you some a psuedo code for the handler ? \nwhy isn't r.Get(\"/{someparameter}/genre/{genre}\", GenreHandler) sufficient? perhaps you also need the route r.Get(\"/{someparameter}/genre\", IndexGenreHandler) in addition?. @hahanein you know, Im going to say this is unfortunately a bug. I believe this should be supported as a named parameter, perhaps once I get into the details I'll change my mind about its support though, but I'll give it a look.\nHowever, what you can do right now is:\nr.Get(\"/{someparameter}/genre/*\", GenreHandler)\nand grab the value via: chi.URLParam(r, \"*\"). @KenjiTakahashi feel free to submit a PR too. hey sorry I dont understand the question. Are you saying you want to have dynamic routes depending on header-value of a request? . exactly @VojtechVitek - this is what I was going to suggest. lol, awesome and fast work @nicpottier . @kwojcicki in what context are you trying to get the route of r? from a request handler..? or exactly where your comment is. Can you elaborate on what you're trying to achieve? . Chi doesn't offer that kind of api - if you really want this set a variable above, concat/ keep track and put it into the permission set. There are many ways to maintain a permission set for routes, what we've done at Pressly is made an ACL chi.Router which tracks and maintains the permission set, you should try the same. There is a closed issue in this project with some same code of that ACL router, I'm on my phone so I'll have to check next week. I've renamed FindHandler to just Find now based on @VojtechVitek suggestion - this feels better\nAs well, I realized Mux#Find does not search the subrouters, I've added a test case that proves it doesnt work, and will have to fix the implementation later when I have some time, or if someone wants to help thats cool too.. I pushed an updated to Mux#Find that searches the subroutes as well. Give it another review please. I'm getting close to merge.. @DmitriyMV yea, for sure will add a test for it too. I've updated the PR again based on feedback - renamed the method to Match(*Context, method, path) bool and added a test case in mux_test.go. decidedly this is not the right approach.. hey @hugows - there are many ways you could design it - but its all for personal preference. \nOne idea is to check other open source projects to see how they manage project structure and passing references around to application state. . hey @flimzy it will be too late in the group as the code to find the routing handler from your path executes before that middleware. You will have to move this to the very top, not as an inline middleware like Group(). It's its a problem, just have both routes defined, r.Handle(\"/bundle-{id}\", bundleHandler) and r.Handle(\"/bundle-{id}/\", bundleHandler). hey @tutley what version of chi are you using? we removed FileServer from the core as its too difficult to support, you will have to write your own implementation for routing files.. many issues have been brought up with the FileServer and routing tree - as we can't peak into the fileserver routes, they cannot overlap\ncheck https://github.com/go-chi/chi/issues?utf8=%E2%9C%93&q=is%3Aissue%20is%3Aclosed%20fileserver it might offer some hints for what others experienced and how they solved their issues\nthe best thing to do is write a custom FileServer method for your needs, see https://github.com/go-chi/chi/blob/master/_examples/fileserver/main.go. hey @stelund - yea you'll have to fork it to add PROPFIND. There is a Router.Method() that takes the string of a method name, you can add PROPFIND to the methodMap and it'll just work.. perhaps what I'll do is export the methodMap so people can configure it themselves to add their own custom types.. they would have to specify their own constant too. I quickly took a look, it would be much more work than that as the methods are a bitmap - maybe some other day way into the future.\nWhy do you need PROPFIND? how come you cant use some other method?. Thanks for the offer - but it\u2019s not a standard HTTP method from what I can see so I\u2019d rather it not put it into the core\nJust fork the project for now\nOn Aug 28, 2017, 9:44 AM -0400, Stefan Lundstr\u00f6m notifications@github.com, wrote:\n\nI'm writing a proxy which also need to pass through webdav requests.\nCan I suggest an PR for an support any method that I mentioned?\n\u2014\nYou are receiving this because you modified the open/close state.\nReply to this email directly, view it on GitHub, or mute the thread.\n. please show example usage. thanks for the PR but chi's focus is to be as minimal as possible. Please add these helper functions outside of chi. You can use chi.URLParam() and cast from string to whatever value you'd like as you've done. Thanks, can you include the test case that this solves? . thanks @matematik7 . I\u2019m away on vacation but I will revisit this issue when I return \nOn Sep 30, 2017, at 2:29 AM, Inanc Gumus notifications@github.com wrote:\nWhy is that your request has been denied?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Fixed in https://github.com/go-chi/chi/pull/281. I merged the #281 PR which fixes this. Give master a try and let us know . thanks, but I disagree. I find it to be minimal and easy to follow with some experience with context. what is the error? its just a redirect. hey @joho - I totally see why this is confusing and annoying. Allow me to explain the semantics..\n\nThe underlying data structure of Chi's router is built almost identically to the definitions of the routing handlers with Use(), Get(), Post() etc. It forms into a tree structure that has various paths, each request starts from the root node of the tree and traverses until it finds its terminal leaf node. The algorithm will look ahead for matching paths, but middlewares are able to inject themselves between the branches of the tree which has the power to change the final leaf node. The router is mostly consistent, but there is a nuance with inline middlewares as created with Group(). I'll explain..\nOnce a router has been create (through the routing definitions), it can just sit in memory and used on a read-only basis as a lookup table of sorts.\nWhen a new HTTP request hits the mux, the mux passes the request to the router, which is actually many http.Handler's in a tree structure. Starting from the root node of the router, the router will first pass the request through the attached middlewares, and then after, will search for the handler that matches the request.URL.Path. In the cors example, the cors middleware will execute before searching for /bar, and in fact, it will respond to the OPTIONS request and complete the response right inside of the middleware, and will not go further. Then another GET request to /bar, cors middleware will see it, oh its not an OPTIONS method, go to next http handler, until it reaches our terminal route handler for GET /bar.\nHowever, middlewares defined in a Group() or using With(), are considered inline-middlewares. Instead of a stack of middlewares on the router, these middlewares are inlined to the specific route, and only that route. So, during execution, the cors.Handler middleware will fail to find the http method OPTIONS for /bar, therefore, it will not get executed. It's a subtle nuance and can be annoying, but typically it only comes into play during finding routes, the execution across the handlers is the same.\nrequest -> middlewares(w,r) -> {find handler matching r.URL.Path} -> !found? 405 : inline-middlewares(w,r) -> routeHandler(w,r)\n..so, my question is, why can't you have r.Use(cors.Handler) outside of the group as in your example? \notherwise you could define .Options() for /bar to a noop handler, so it would find the handler, but be handled/served by cors.Handler. Or, you could use Handle() for /bar, which would match any http method. But, theres probably a way to move your cors.Handler to root-level and still meet whatever other functionality you're trying to do. . Hi, I\u2019m on vacation for 2 weeks and won\u2019t be able to help until I return. Just FYI, I have a different solution in mind - specifically in the core I do not want to define unstandard methods like this, however I have a solution that will allow you to add your own methods at runtime. For now just use your fork. solved in https://github.com/go-chi/chi/commit/d806569952e5c14126a155fe66cf102139d11979. outdated, closing. No problem, we\u2019ll add it soon. I\u2019ll return to a terminal on Sunday. Vojtech if you want to do it sooner, go for it. Thanks for the PR . @mvdan welcome aboard :) \ncan you take a look at https://github.com/go-chi/hostrouter and let me know if this helps. The solution is just stacking routers on top based on the Request.URL.Host. this is as you suggested, building the host routing before the chi method/path routing. If it doesn't work, can you provide an example of your use-case that the hostrouter approach fails to support?. great, good luck! and let me know how it goes. cheers. @jutkko the RoutePattern() will only return a value once its determined the final route. You can either access it in the endpoint handler, or after a request responds in the middleware. See the description in https://github.com/go-chi/chi/blob/master/context.go#L80-L93 and example there:\ngolang\nfunc Instrument(next http.Handler) http.Handler {\n  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n    next.ServeHTTP(w, r)\n    routePattern := chi.RouteContext(r.Context()).RoutePattern() // <---<< after\n    measure(w, r, routePattern)\n })\n}\nplease let me know if this works for you guys / other feedback. @jutkko cool - if thats the case, you could use a technique similar in https://github.com/go-chi/chi/blob/master/middleware/get_head.go to pre-process the route and get the RoutePattern() from that context.. Please provide example code of the bug\n\nOn Oct 24, 2017, at 11:18 AM, Jay Nagpaul notifications@github.com wrote:\nWhen using the default middleware logger on requests that get upgraded to websockets using gorilla websockets. It silently fails and throws an error 500.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. thanks. Can you list the project in the table of https://github.com/go-chi/chi#auxiliary-middlewares--packages. btw, its not possible to add fasthttp to chi directly, it would create a dependency and major change which goes against the design of the project. thanks for bringing this up, but I'm wondering what is the case you'll want to send a request to an inline Mux directly?\n\nthe solution I'd go with is:\ngo\nim := &Mux{pool: mx.pool, inline: true, parent: mx, tree: mx.tree, middlewares: mws}. @dcormier thanks, I agree if its an available codepath and returns a type, it should be supported.. Thanks for the report gents. The fix was actually very simple, have a look at the commit.\nHowever, its possible to also build a path cleaning middleware similar to stdlib ServeMux as @cskr pointed out.. thanks @pei0804 - its a reasonable proposal, but the goal is to keep chi's middlewares unopinionated. If someone wants to assign the X-Request-ID header, then they should do so in a separate middleware.. I wonder if this is actually faster? I heard a tight for loop in cases is faster than a map look up. I know it doesn't make sense, but I've never benchmarked it either. please look at the examples. You are setting a new context.Background() but you must use the request context. change the line to:\nctx := context.WithValue(r.Context(), common.TENANTKEY, resLog.DestTenantId). This is awesome! Thank you very much . Thanks @csucu this is great.. roger that . hey @srikrsna - this is neat. One suggestion though is to rename the package path from github.com/srikrsna/security-headers to github.com/srikrsna/secure. The import path should reflect the package name.. The more specific one will win, /recipes/suggestion but of course you could determine the answer by trying it. hey guys, the correct design is to execute the top-level middlewares, as the top-level middlewares have the power to change the request URL Path, to something that could resolve a found handler.\nso... if you're really trying to avoid some particular middleware from executing, you can look ahead and execute the NotFound handler sooner.\nTo get an idea of how to write a middleware how to match a route look at https://github.com/go-chi/chi/blob/master/middleware/get_head.go\nsomething like..\ngo\nfunc CustomNotFound(next http.Handler) http.Handler {\n  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n    tctx := chi.NewRouteContext()\n    if !rctx.Routes.Match(tctx, r.Method, r.URL.Path) {\n       notFound(w, r)\n       return\n    }\n    next.ServeHTTP(w,r)\n  }\n}. hey @jimbojetlag thanks for asking. The future is bright for chi :) \nIn many ways, chi is stable and architecturally hasn't changed a long time. The core library after all is just ~1000 lines of code. We will of course continue to support any bugs that come up.\nFrom a business perspective, Pressly the product/platform still lives on, and the acquirer and team there love Go. But, the fact of the matter is that chi is an independent open source initiative that is beyond any company and belongs to the community under the MIT license.. hey @alexanderattar I modified your example above slightly, give this a try:\n```go\nfunc (rs Resource) Routes() chi.Router {\n  r := chi.NewRouter()\n// Protected routes\n  r.Group(func(r chi.Router) {\n    // Public routes\n    r.Get(\"/\", rs.List)\n    r.Get(\"/{cid}\", rs.Get) // GET /{resource}/{cid} - read a single resource by cid\n// Private routes\n// Handle valid / invalid tokens\n// This can be modified using the Authenticator method in auth.go\nr.Group(func(r chi.Router) {\n  r.Use(jtwauth.Authenticator)\n  r.Post(\"/\", rs.Post) // POST /{resource} - create a new resource and persist it\n\n  r.Route(\"/{cid}\", func(r chi.Router) {\n    r.Put(\"/\", rs.Put)       // PUT /{resource}/{cid} - update a single resource by cid\n    r.Delete(\"/\", rs.Delete) // DELETE /{resource}/{cid} - delete a single resource by cid\n  })\n})\n\n})\nreturn r\n}\n```. closing in 8983e7a9dafa3a7a2f5509e20bf57063cae438eb -- taking your suggestion and skipping check on requests with empty body. closing as its not an issue with chi, just normal behaviour that needs escaping. I\u2019m down too . I think I\u2019ll hold off with chi until I have more time to dive into the subject. I\u2019m a little busy at the moment with another project. I\u2019ll let others take lead on this but since it\u2019s so new I\u2019d recommend to see how other packages adopt these ideas first. @karupanerura thanks for the PR. I'm tight for a deadline at the moment and I'll review the PR when I can. If others in the community can check it out that'd be appreciated too.. hey @lansana - I wrote something similar to add an ACL layer on top of a chi.Router, check out https://gist.github.com/pkieltyka/d4ab2e385febcc195a9cea4ef8e61227 which should help you finish your version. @lansana great! thanks. hey @asydorchuk - the middleware logger interface in chi is designed with the intention that it'd be extended in some way. For production apps, I'd recommend some kind of structured logging:\ncheck out https://github.com/pressly/lg or https://github.com/go-chi/chi/blob/master/_examples/logging/main.go where you can easily add the request payload from any stage of your request/response lifecycle.. Thanks @tmm1 - nice tip. done in latest version of Compress middleware, via https://github.com/go-chi/chi/pull/401. Hey @djui - I checked your example and everything works as expected by design. I agree the description isn't great, but its the best ive come up with, this is correct though.. hey @djui - search other issues about \"slashes\" - https://github.com/go-chi/chi/issues?q=is%3Aissue+slashes+is%3Aclosed for other discussions\nits just a helper middleware, feel free to modify / adapt / write your own and if you get to a better version, please submit a PR. this is just the nature of the raw details of the walker, you can just string+replace /*/ to /\nlet me know if this is still a problem\n.. such as..\n```golang\nwalkFunc := func(method string, route string, handler http.Handler, middlewares ...func(http.Handler) http.Handler) error {\n    route = strings.Replace(route, \"/*/\", \"/\", -1)\n    fmt.Printf(\"%s %s\\n\", method, route)\n    return nil\n}\nif err := chi.Walk(r, walkFunc); err != nil {\n    fmt.Printf(\"Logging err: %s\\n\", err.Error())\n}\n``. @VojtechVitek yea, I agree its an implementation detail we can probably hide. thank you @mvrhov but the chi Router's radix implementation took months to write and many more months to refine. It's pretty set in stone and has been quite optimized. I haven't looked into ozzo, but if you have any application-level benchmarks, we can have a look where to optimize Chi further. Chi is quite fast though as you can tell from the benchmarks on a pure-routing basis. The only slower parts of Chi is how context.Context is treated in http.Request when having to create a new context, but this is unavoidable based on the stdlib's implementation of the 'context' and 'net/http'. And ultimately chi will not be the bottleneck of a Web service compared to the application code. thanks for the note.. presently, the last route definition for a pattern is what registered... previous routes will be overridden. This is made somewhat by design for scenarios to override the route for a mounted subrouter. I'd like to maintain that, but, an option is to wrap the chi.Router interface with your own Router that makes this check.. hey @freb - therestexample is just one particular way to structure a REST API. Other developers have done it quite differently and we encourage you to find the set of patterns that work for you. Therestpackage makes use of github.com/go-chi/render which is a companion package, and I'd probably suggest to use therender.Bind` interface to validate the inputs on the payload object and set an error for invalid input and respond with a proper/contextual HTTP error code and message. This is your option 2. Certainly if you want to update the rest example to fix this, that'd be great. Thank you!. check out https://github.com/go-chi/chi/blob/master/_examples/limits/main.go and other middlewares in the ecosystem . yes, I think the answer is to copy/paste the middleware and build it to suit your needs. @PlkMarudny can you paste a gist of your full example? \n```go\npackage main\nimport (\n    \"net/http\"\n\"github.com/go-chi/chi\"\n\"github.com/go-chi/chi/middleware\"\n\n)\nfunc main() {\n    r := chi.NewRouter()\n    r.Use(middleware.RequestID)\n    r.Use(middleware.Logger)\n    r.Get(\"/\", func(w http.ResponseWriter, r http.Request) {\n        w.Write([]byte(\"hello world\"))\n    })\n    r.Get(\"/media/{mediaID}\", func(w http.ResponseWriter, r http.Request) {\n        w.Write([]byte(\"test \" + chi.URLParam(r, \"mediaID\")))\n    })\n    http.ListenAndServe(\":3333\", r)\n}\n```\ntry that above, the response is \"test a.html\" in a request to /media/a.html. ensure you are using the latest version of chi btw (master). hey guys \u2014 go-chi/chi needs to be kept as simple/lean as possible. However, param helpers are easy things for developers to build on their own. Just make param subpkg that suits your needs and use it. Closing as latest version doesn\u2019t provide FileServer, gotta bring your own setup . Unfortunately the signatures are set. We tried to be close to stdlib but couldn't do so to be flexible to all cases. Can you provide some example code of what you're trying to do?. this will not change in chi.\nBut FYI, for a var of type HandlerFunc, you can call .ServeHTTP which is an http.Handler. nice work @polyfloyd \u2014 could use a review / small iteration but a nice addition. Do you have a separate subpkg somewhere (in another repo) with the Brotli encoder that uses this interface too? if not, we should make one once this interface is settled / merged. LGTM. I haven't been following the vgo specification -- I've been waiting for the dust to settle. I trust @VojtechVitek 's intuition/direction on the matters so will take lead from you guys, but one of the goals of chi is to have no dependencies besides stdlib, so where do the require's for golang.org/x/net and /text come from?\nI do understand the need for versioning of chi and allowing other projects depend on a particular version of chi easily.. personally I was happy with https://github.com/golang/dep but, the Go devs are much smarter than me, so I must be out of the loop on the latest thinking. @jpincas yes, in that block of code it is redundant. It's there for illustrative purposes though in a way to think about how to build a ArticleResponse payload, in case the resp.User set somewhere else. Not so much a mistake, more of redundant/illustrative.. @titpetric have you tried something like https://github.com/go-chi/chi/blob/master/_examples/router-walk/main.go ? there is also https://github.com/go-chi/docgen. @adamwasila yes thats exactly right, both cases should catch. thanks for noticing and reporting this. I've fixed it in v4. fixed in v4 PR #378 . perhaps we set some pkg level options to warn for this case, but there are cases you want to overwrite routes, I don't believe this is a bug, its an edge case. hey @dcormier -- your last example is the correct usage :) \ncan we close this issue?. @vearutop this might help in how to wrap the chi.Router \u2014 https://gist.github.com/pkieltyka/d4ab2e385febcc195a9cea4ef8e61227. I tested this and was unable to reproduce any bugs, closing for now. I've added extra test case for this in v4 as well. done in #378 . done in #378 . @dandee chi/render was moved to github.com/go-chi/render at some point, perhaps this is the issue you're facing. ah, I see, it's nice to see the article .. its helped me understand the issue. It's not ideal, but a result of our routers are joined together... yes its possible. check this issue, it might help clear up how to do this: https://github.com/go-chi/chi/issues/270. just wondering, what's new or improved that this PR provides..?. sounds good, squash + merge is good with me to use stdlib constants instead of strings, cool. hey guys, small oversight.. we've broken support for Go 1.7 and Go 1.8 with this PR -- see https://travis-ci.org/go-chi/chi/builds/445197603. false alarm, the issue was actually with golint pkg on older versions. all good now. https://github.com/go-chi/chi/blob/master/mux.go#L247 is where routes are added to the new inline mux made by Group.\nglad you figured out the other parts. nice work, you did the right thing by writing your own handler for it. chi is not a REST framework. its a router that so happens to be good at writing REST services. @rocanion please learn to use form posts properly, and please do not use these issues as a stackoverflow. good luck to you sir.. the issue might be the way http.FileServer builds path's internally with chi's router. Perhaps I should make a separate middleware that better works with chi for file serving, but unfortunately I don't have the time. I did however check the routing path on a local example and it worked just fine. I suspect the issue is `r.Get(\"/*\", render(...))`` and the paths not being joined correctly. done in https://github.com/go-chi/chi/pull/378 -- in v4, we will return 404 for an empty mux. fixed in #378 . @SamWhited yea, it would be chi v5 when we support go modules. I don't see this happening for another 6+ months until go 1.13 is available, in hope the go modules is standard and robust for packages. We had hopes to use go modules now, but ran into a bunch of complexity that didn't make sense to put onto chi which literally has zero dependencies to run, lol.. done in chi v4 https://github.com/go-chi/chi/pull/378. @husainaloos yea, you can write a middleware to take the request ID and do whatever you'd like with it after the response of sent, or right before... also see, https://github.com/go-chi/chi/issues/302. @frederikhors the best bet is for you to copy and fork the logger middleware for your purposes. Copy+paste it and modify for your own project. thanks @tweenietomatoes -- I quite like the logo, and I will be deprecating older Go versions in v4, see https://github.com/go-chi/chi/pull/378\nas for gitter, that would be fun but unfortunately I don't have the bandwidth to manage such a channel. But Gophers slack is an amazing community with 35k members https://invite.slack.golangbridge.org/. hi there, the context key's are actually a unique object with an underlying string value. This is by design to prevent collisions with other packages, specifically this value: https://github.com/go-chi/chi/blob/master/context.go#L12\nYou'll want to update use .. ctx.Value(chi.RouteCtxKey).(*chi.Context) but even easier is to do .. routeCtx := chi.RouteContext(ctx)\n. the path is cleaned within the http.FileServer handler. as mentioned in other issue with the same question.. but for others who follow commits + PR history, will repeat answer here..\n@SamWhited yea, it would be chi v5 when we support go modules. I don't see this happening for another 6+ months until go 1.13 is available, in hope the go modules is standard and robust for packages. We had hopes to use go modules now, but ran into a bunch of complexity that didn't make sense to put onto chi which literally has zero dependencies to run, lol.. @SamWhited good luck! . try this against master, does not occur. hey guys, I just caught the problem, ive fixed this with jwtauth and docgen -- can you try again. @uRevivals just peg to specific tags/versions via some go dependency manager and you'll be okay\nwe tried to make chi a go module, but it backfired a bit. Go modules need more time in the oven. thx for the tip @5teven but there is no learning a broken system. go modules need more work. the problem should now be resolved with reverts to jwtauth and docgen sub-deps in the examples.\nfurther, chi doesn't even have any dependencies, so install it without -d. the _ in _examples should exclude it from installing those dependencies, but perhaps this has been changed in recent versions of Go? in any case, it was a big mistake for Go core to \"leave modules up to community\" for so long.. now its a mess. Hopefully they improve in Go 1.13+ when they attempt to remove $GOPATH completely. @RXminuS good catch and thx for the report. fixed in https://github.com/go-chi/chi/commit/1a6bb108ccf279c8dac6f9bad857d773b4f9b421 -- thanks for the tip on the fix @RXminuS -- I'm not sure why this works, but I've tested it and resolves the issue. thanks for the report, will look into it. fixed in 85905ae4dd0a60afa490c062913f0c3ae168ac7e. @diegobernardes copy the middleware.Profiler() code play around with it -- perhaps something inside of net/http/pprof is overriding this. @kazukousen thanks, this looks pretty good -- but, I wonder if this method would work too, https://github.com/go-chi/chi/blob/master/context.go#L134 setting the base context with appengine context. yea, if you provide a test case, I can review+fix it. this sort of bug should never happen though if the parser is doing its job correctly. @milesje that is close, but in your test() handler, you are missing the call to render.Render() that will acutally wrote the output,\nsee https://github.com/go-chi/chi/blob/master/_examples/rest/main.go#L168-L169\nas well, render is just a helper pkg, it's not required to use with chi router -- but, the rest example can show you its use. I suggest you try some simpler examples to get a feel for how Go stdlib works, then read the source of the render package. render.Status() just sets the status, it does not write it to the responsewriter. You need to call render.Render(). @milesje it's not my job to be your tech support. I offered the little bit of help I was able, good luck.. if you provide a test case and report a bug, I'm happy to solve that when I find the time, or perhaps another contributor wants to help.\nas well, the http://github.com/go-chi/render package is not core to the chi router, its in a separate repository as a convenience library for a reason. Perhaps try https://github.com/unrolled/render instead. @milesje I've tried out both of your examples above, and both work correctly and return 401 as expected. I'm getting the feeling you might have an old compiled package in $GOPATH/pkg or some other strange linking. Or perhaps outdated deps.\nthe exact program I ran (and variation with http.HandlerFunc also worked..)\n```go\npackage main\nimport (\n    \"net/http\"\n\"github.com/go-chi/chi\"\n\"github.com/go-chi/chi/middleware\"\n\"github.com/go-chi/render\"\n\n)\nfunc main() {\n    r := routes()\n    http.ListenAndServe(\":3333\", r)\n}\nfunc routes() *chi.Mux {\n    router := chi.NewRouter()\n    router.Use(\n        render.SetContentType(render.ContentTypeJSON),\n        middleware.Logger,\n        middleware.DefaultCompress,\n        middleware.RedirectSlashes,\n        middleware.Recoverer,\n        middleware.RealIP,\n    )\n    router.Get(\"/test\", test)\n    return router\n}\nfunc test(w http.ResponseWriter, r *http.Request) {\n    render.Status(r, 401)\n    render.Render(w, r, ErrInvalidRequest())\n}\ntype ErrResponse struct {\n    Err            error json:\"-\" // low-level runtime error\n    HTTPStatusCode int   json:\"-\" // http response status code\nStatusText string `json:\"status\"`          // user-level status message\nAppCode    int64  `json:\"code,omitempty\"`  // application-specific error code\nErrorText  string `json:\"error,omitempty\"` // application-level error message, for debugging\n\n}\nfunc (e ErrResponse) Render(w http.ResponseWriter, r http.Request) error {\n    render.Status(r, e.HTTPStatusCode)\n    return nil\n}\nfunc ErrInvalidRequest() render.Renderer {\n    return &ErrResponse{\n        // Err:            err,\n        HTTPStatusCode: 401,\n        StatusText:     \"Invalid request.\",\n        ErrorText:      \"Invalid request.\",\n    }\n}\n```\nunfortunately I can't help you debug your system, but I can confirm the above code returns 401 in both instances on /test route with the handler as router.Get(\"/test\", test) and router.Get(\"/test\", http.HandlerFunc(test)). ```shell\ncurl --request GET  --url http://localhost:3333/test -i\nHTTP/1.1 401 Unauthorized\nContent-Type: application/json; charset=utf-8\nDate: Mon, 25 Feb 2019 21:30:08 GMT\nContent-Length: 57\n{\"status\":\"Invalid request.\",\"error\":\"Invalid request.\"}\n```\nthis is on a Linux computer wth go1.11.5\nperhaps someone else can run on their Mac's to test..? @VojtechVitek if you have time... lol. that is super weird. I'll try on my Mac when I'm home, but that is a curious one... @milesje sorry dude, I can't reproduce your problem. I just tried on my Mac with go 1.11.4 and the same code above returns a 401 unauth'd code.\nunfortunately I'm quite loaded with other work and won't be able to tend to this problem. good luck though! hope it helps a bit. good to kno! can you confirm you're using the latest (master) versions of all packages? . indeed, I will change it to if e != \"\" .. thank you. thx for report. fixedin 403a33cc14d759085d69fff973da96eefd02cc9c. @awbraunstein thanks buddy :) yes, its all yours. chi issues is not stackoverflow, please direct q&a there and only post actual issues with a test case to chi\u2019s github issues. wow @awbraunstein well done. the code looks very sharp and complete. I will review it in detail this evening. thanks for the quick turnaround . did a review, tested various edge cases manually, and works great. thanks again @awbraunstein . I prefer NotFound() as well.. however, the handler arg should be a http.Handler, chi.Handler or interface{} where we can support various handler types. The other option is to have custom NotFound handlers as a middleware instead.\n. I think that could be interesting. Maybe try that in another commit later with some examples\n. do we need these?\n. Do we need this since we embed http.ResponseWriter ...?\n. I think good idea. You could take a Compressor or something, or use a default one if its not passed\n. thanks for fixing this panic.\nI think we should move this procedure to its own function, like \"writeMethodNotAllowed(w); return\" .\n. is this the backlog timeout? I think then it should be named defaultBacklogTimeout\n. nothing, I am okay with throttler too, but rename the file too if you guys think its better. I consider that \"throttle\" is an action on a request.. and a \"throttler\" is a thing that throttles requests, so, depends on context and what sounds better.. I dunno :P both work\n. lets remove this..\n. I agree. If backlog is full, then 503 immediately.\n. that convention is for interfaces.. not for middlewares. I don't buy that argument :) \n. can we call this defaultBacklogTImeout ..? this is what it is\n. please remove this comment\n. I think we should call it backlogTokens instead of backlogtokens\n. I kind of prefer backlogLimit over backloglimit\n. I think you're right and I'll go back to original Route() and Group() for now\nRoute is like a Mount that accepts a function instead of the router, I like it for building the tree as shorthand \n\nOn Jun 15, 2016, at 11:32 PM, Vojtech Vitek notifications@github.com wrote:\nIn chi.go:\n\n\nConnect(pattern string, handlers ...interface{})\nHead(pattern string, handlers ...interface{})\nGet(pattern string, handlers ...interface{})\nPost(pattern string, handlers ...interface{})\nPut(pattern string, handlers ...interface{})\nPatch(pattern string, handlers ...interface{})\nDelete(pattern string, handlers ...interface{})\nTrace(pattern string, handlers ...interface{})\nOptions(pattern string, handlers ...interface{})\nUse(middlewares ...func(http.Handler) http.Handler)\nStack(fn func(r Router)) Router\nGroup(pattern string, fn func(r Router)) Router\n  btw: How about removing .Route(), changing .Mount() signature (so it's not like .Handle()) and keep .Group() only?\n\n\ntype Router interface {\n    http.Handler\nGroup(fn func(r Router)) Router\nMount(pattern string, r Router)\nHandle(pattern string, h http.Handler)\n//...\n}\n// --------\nr := chi.NewRouter()\nr.Use(ForAllCtx)\nr.Group(func(r chi.Router) {\n    r.Use(SpecialCtx)\n    r.Get(\"/\", handler)\n})\nr.Mount(\"/ping\", subrouter)\nr.Mount(\"/:articleID\", r.Group(func(r chi.Router) {\n    r.Use(ArticleCtx)\n    r.Get(\"/\", getArticle)\n}))\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub, or mute the thread.\n. this is pretty cool, I like the short-hand\n. in the example, I think it would be nice to use a \"real-world\" analogy. this way people reading the example can relate to it some kind of domain .. for example, maybe use the idea of Articles and a simple blog presenting other data\n\npeople may not relate or grasp the RuntimeObject or PresenterObject, and how it fits to their app/mental model\n. I've never been a fan of the ParseContentType middleware, something we should rename or consider differently. \n. I think rename this file to \"presenter.go\" since it better reflects the naming in the code\n. yea, that is true, and perhaps we should.. what do you think? it's a bit verbose, but it is quite helpful.\n. we may want to support render.Status(200) or something, so we can override the status code for a response. the http.ResponseWriter has w.WriteHeader(statusInt), but, this will write the header right then, which isn't what we want.\nthe consideration is, what should be the signature of render.Respond(), I do believe we want to give control\nperhaps we have.. render.Respond(w, r, Object) and render.RespondStatus(w, r, status, Object) \n. yea, I agree with @VojtechVitek that the name Metrics is more about instrumentation metrics and less about application logs going to different backends. \n. Nice, I like these suggestions, LogEntry, NewLogger and I prefer LogAppender/Append -- @VojtechVitek ?\n. do you think we should just leave it as is..? whats your thoughts on why/why not?\n. @c2h5oh actually not. Each constant would be stored as a different value in the context because the type of ctxKey is different than something like an int. The only thing that could overwrite it would be another ctxKey type of the same value\n. however, I think I'm going to move to a slightly different pattern so its easier to debug.. like: https://github.com/pressly/chi/blob/v2/context.go#L12-L22  .. this is what net/http in 1.7 does for its request context keys, the advantage is debugging the values you can see strings, and again, not to worry about being overridden by other string's with the same value cuz the type is different\n. definitely we need those as well. perhaps look to https://github.com/unrolled/render for some ideas\n. @VojtechVitek it's not a feature of context, it's a feature of Go's type system and map[interface{}]interface{}\n. yea, the interface for those methods, HTML and PlainText/String would have to be specific to the kind of data they want to receive \n. hmm.. why message? .. we can use stdlib messages\n. I'm good either way, its def more clear about the ContentType\n. sounds good. lets try to remove it and see how it goes\n. oh cool.. so you put 409 in the ctx and then pick it up when you respond..? that is cool. \none other thing still, is how do we get the request Content-Type to the responder?\n. I think thats a pretty interesting idea. We could even make it a requirement of the responder. \n``` golang\nfunc routes() http.Handler {\n  r := chi.NewRouter()\n  r.Use(middleware.Logger)\n  r.Use(render.Responder)\n  r.Get(....)\n  return r\n}\nfunc h(w http.ResponseWriter, r *http.Request) {\n  // a call to Respond() would just put the response status/body on the r.Context()\n  // and leave it up to the Responder to return..\n  // in fact, Respond() could detect that Responder was set in the chain, because\n  // it could check for a context value, and either respond right there, or defer\n  // to the Responder middleware\n  render.Respond(w, r, 200, \"something\")\n}\n```\n. @VojtechVitek does make a good point about performance and loading far too much data into the context\n. as well.. @c2h5oh middlewares can set headers before they call the next handler, not after. In practice, this has worked just fine\n. yea I think we should remove it, and leave it for someone else to wrap their preference like you're both describing\n. interesting, there we go.. so.. I think, either call that method since this subpackage is for chi v2 which is Go 1.7-only, or copy the tip stdlib code into this function\n. I'd much rather defer something that bold for a second concept in another PR\n. do we still need render.ParseContentType() ..? perhaps we can rename this or do something else to get the requested content-type?\n. this is awesome! very cool\n. perhaps we should do something more like.. https://github.com/pressly/chi/blob/v2/context.go#L9 ? it's still very efficient since its just a pointer, and will make debugging / printing the request context more clear\n. I think a good idea.\n. should we get rid of this, etc...? since we're go 1.7 only?\n. @Vektah great to hear! chi v2 doesn't need mwrap anymore :) \nhttp.HandlerFunc provides us the most flexibility while keeping the chi.Router interface succinct and clean. You can write:\ngo\nr.Get(\"/foo\", handler.ServeHTTP)\n. @mrcpvn thanks for the note, however, chi v2 already breaks a lot of compatibility with v1, so that is okay. the chi.Context is itself a context.Context object, because it implements the context.Context interface, and uses the parent context.Context for behaviour (see implementations of the methods on chi.Context). \n@mrcpvn do you want to do this for testing..? we could export the \"Parent\", but I'd rather not unless we have to... this works https://github.com/pressly/chi/blob/master/mux_test.go#L833  .. is that not enough? let me know\n. yea, this is why I don't like it, and going to delete it from the PR -- but I wanted to show you guys to prototype before I did that\n. I'd prefer to keep these function-introspective functions in the docgen package. \n. as well, remove info.go and move it to docgen/ package, and converge existing logic that is there\n. Cool - btw, I didn't get my head so deep to trace this logic - can you tell me why this walk method is better then just using the chi.Routes interface on a router? just like docgen does.. is there some extra data you're able to reach into?\n. I dont really want to add more logic to the core chi package\n. awesome, this sounds great. perhaps we can replace the existing walk() function in chi with yours then? we can keep it exported too like you've done, but the reason I didn't do that at first and instead provide a chi.Routes interface is because sometimes the underlying chi.Router is not a *chi.Mux - for example in the case of acl.Router, in which case, the docgen would break. Even though chi.Routes means a few more steps, the docgen package shows that it can expose all necessary routing information. LMK what you think.\n. thanks for the PR but Im surprised by this one.. can you send over the linter output in a comment in this PR?\n. yea, I do like the idea that NotFound would be used all the way down from this point in the tree. If another subrouter defined NotFound it would use that one all the way down. Nice work.\nHowever, what would happen in this test func if r.NotFound() was defined at the very top before the Mount(), I think it might fail\n. @VojtechVitek is right, we're not able to include 3rd party imports into chi. \n@VojtechVitek cool idea, we can make pressly/middleware for 3rd party middlewares. Question: if we make pressly/middleware/casabin and say pressly/middleware/ can govendor or other things manage import paths only for the packages actually used by a project and not bloating child deps. thanks @hsluoyz - I've added your pkg to the list in 898d761524954def9191dc8bea69191442581385 cheers!. please move this code to tree.go instead of a new file walker.go. @VojtechVitek I agree that would be nice, except the FindHandler method under the hood is calling mx.tree.FindRoute(rctx, m, path) which is the call to search the routing tree for the matching handler. The tree routing method requires a *Context (route context) where it will store the url params it find during traversal. It's tuned carefully for low gc pressure. In the case that the url params are throw-away (like in this case), then we could add a chi.NoContext, make an interface, and allow tree.FindRoute to skip setting url params during traversal. I dont really want to do this right now. Rather, people can make a pool of route context's in their middleware or whereever instead right now.\nI just realized a different problem though, which is that the FindHandler method does not traverse the subrouter trees, therefore the current implementation is actually incomplete. I will push a breaking test soon.. Currently the handler found is the endpoint handler, not the computed mux handler which contains the middlewares. The online middlewares part of the endpoint handler are the inline handlers which come from With() or Group() middlewares.. It's possible to offer the middlewares from the Mux#middlewares (the middleware stack), but, it wouldn't be very useful because if you stack middlewares from multiple subrouters, it wont represent the clear execution path to the endpoint handler.\nWhat would be the use case to return the execution middleware/handler execution path here?. yea, I had a similar thought. Initially the handler was useful, but after writing the first implementation and realizing the need to traverse subrouters and consider explicit HEAD handlers in the tree for some subrouters and not others, the handler return value isn't very useful. It's possible to reconstruct the discrete path, or a computed path, but Id rather find a real need for that with this method, because that is what ServeHTTP() is for. A bool is better for checking if the path can find a matching route in the tree.. There are advantages to passing the chi.Context yourself, since you can look at the URI parameters that were parsed from the route. But also, you could pool them if you really wanted to. . In the case you're creating a lot of NewRouteContext() objects and finding it to cause memory pressure for whatever reason (which I do not expect to be an issue), you could do something similar as here: https://github.com/go-chi/chi/blob/master/mux.go#L51-L53 - that is, make a bunch of temporary routing contexts and grab them from the pool. But, its not really necessary for just matching. I believe the API is just clearer this way, as the routing context is intended to be read from, but can be manipulated to change logic, but shouldnt be an input in most common uses. . how come you're creating a new server from with here? this line should be: ts := httptest.NewServer(r). minor style thing, can you change this to: pool: &sync.Pool{}. thx. can you fix the indentation here? its breaking the CI due to formatting. ",
    "GeertJohan": "On a related note, can we type func(next chi.Handler) chi.Handler ?\nedit: Created a new issue for this; #11\n. I'd be happy to provide a PR if necessary.\n. I liked it for documentation and readability. However, when trying to implement a quick example I found that it gets messy real quick. Existing func(next chi.Handler) chi.Handler must still need be supported and since router.Use(..) accepts interface{} there can't be any type conversion going on during the call, which means that internally both types must be handled. It's probably not worth the effort without unless doing a breaking change.\n. Didn't mean to close, although this probably can be closed..?\n. @pkieltyka If we can switch the Logger and Recoverer middleware, then the Logger will still print the panic outcome before the Recoverer recovers the request.\n. ",
    "utrack": "Thank you! :+1: \n. @VojtechVitek I tried to fix the panic :) next if threw panic because of index out of range, which was kinda counter-intuitive for an error. @pkieltyka's solution should work though\n@pkieltyka: OK, I'll try to isolate case when it happens with non-empty initial paths and submit a separate issue\n. :+1: \n. Nevermind, forgot I was using CloseNotify middleware somewhere else.\n. @pkieltyka It's useful for logging endpoints' metrics. Say, request timings and counts per endpoint.\nFor endpoint /users/:id r.URL.Path would contain\n/users/1\n/users/2\n/users/3\nand so on for each request. If you'd export stats outside (with Prometheus or similar software) all these would be viewed as separate endpoints, while using path from MatchedPathCtxKey would present a single path per endpoint, so all these requests will be exported as calls to /user/:id.\n. @pkieltyka see the sample @ https://github.com/utrack/chi-322/blob/master/main.go\nchi.Router accepts http.HandlerFunc and std mux accepts func(ResponseWriter, *Request).\nThey're the same, just the name is different - however, since Go doesn't resolve interfaces recursively, we can't use the same interface for chi.Router and std mux.\nI don't think changing the alias in function's sig would cause many problems, since people can't use interfaces right now :)\nAny non-interface interaction would still compile and work, i.e. function would still accept the same concrete params.. Ye, but it won't change in Go 1 :) It is another question if it was a mistake, but different interfaces are certainly a problem. It's not easily possible to write libraries that support both stdlib and chi muxes, for example.. It's not a bug, there's no deep interface conversion by Go 1 spec.. Please try running https://github.com/utrack/chi-322/blob/master/main.go from my 2nd comment to see the problem.. I feel like no one had actually bothered to see an example :) But I've got your point. . ",
    "vladdy": "Yes, we can just use go commands and chi is not that big project (yet), but, for example, \"make\" can be set to default go build && go test && go fmt later when you notice a lot of issues with formatting and it won't be required to update the build instructions or change workflow then. \nAnyway, your point also makes sense, so if you are still not sold for this workflow, just close this pull request and I'll update  #8 with raw go commands.\nThanks for quick response!\n. Updated instructions to use go command and fixed the mistype.\n. Sorry, missed it in one step.\n. I could make the handler to accept interface{} but I'm concerned about providing a context for URL that will be missing which can be confusing.\nAlso, if NotFound is made as a middleware, do you have idea how it will know about non existing addresses for middlewares chained after it?\nAlternatively, I see NotFound handler to be a part of the context. In such case NotFound middleware can change it from some default value. What do you think?\n. ",
    "edigu": "any news on this?\n. ",
    "yudppp": "Oh, sorry...\n. ",
    "gdm85": "@pkieltyka I think the Recoverer middleware should work as much as possible stand-alone without the Logger, maybe the request context could be added to the panic message written by the recoverer as well?\n. @VojtechVitek my bad..I had only built chi and not chi/middleware. I will process your other feedback\n. @VojtechVitek yes I agree with that and in line with that view of Recoverer, I will add request context to the panic message in a separate commit\n. So, when Logger is not added or added after Recoverer:\n2015/11/11 17:47:25 [::1]:42520 [delver/rUYSwm1LYq-000001] \"GET /accounts HTTP/1.1\" panic: test\n/home/gdm85/chi/_gopath/src/github.com/pressly/chi/middleware/recoverer.go:28 (0x4b3ebc)\n    Recoverer.func1.1: debug.PrintStack()\n/usr/local/go/src/runtime/asm_amd64.s:438 (0x45b76e)\n    call64: CALLFN(\u00b7call64, 64)\n/usr/local/go/src/runtime/panic.go:423 (0x42c179)\n[...]\n^Cexit status 2\nWhen Logger is before Recoverer (best practice):\n2015/11/11 17:47:43 [::1]:42526 [delver/71wjK689mh-000001] \"GET /accounts HTTP/1.1\" panic: test\n/home/gdm85/chi/_gopath/src/github.com/pressly/chi/middleware/recoverer.go:28 (0x4b3ebc)\n    Recoverer.func1.1: debug.PrintStack()\n/usr/local/go/src/runtime/asm_amd64.s:438 (0x45b76e)\n    call64: CALLFN(\u00b7call64, 64)\n/usr/local/go/src/runtime/panic.go:423 (0x42c179)\n[...]\n/usr/local/go/src/runtime/asm_amd64.s:1696 (0x45d9f1)\n    goexit: BYTE    $0x90   // NOP\n2015/11/11 17:47:25 [::1]:42520 [delver/rUYSwm1LYq-000001] \"GET /accounts HTTP/1.1\" 500 22B in 9.163817ms\nIt could be argued that the panic line is \"duplicating\" what is later on reported by Logger as 500, but it adds context to the panic message...I think it's okay to have it this way as panics should really be exceptional anyway, and extra context is exactly what you want for them (whether you have or not Logger enabled there).\n. The last commit adds a note to clarify how it's best to use Recoverer together with Logger, it can be dropped or squashed depending on what's decided.\n. The [1:] is to skip the first \" added by the %q formatter. It's a trick to be able to put the URI and the protocol within the same quotation marks, while we're giving the method a different color.\n. ",
    "alinz": "Awesome! thanks!\n. @pkieltyka is there anyway to achieve adding or removing routes dynamically? One good scenario would be in microservice systems. once a service is online it registers its routes to chi and during shutdown down it removes those routes.. ",
    "hmgle": "Got it~ It looks elegant.\n. @VojtechVitek I agree.\nFasthttp had the advantage of a good performance, but at the same time it is incompatible with net/http. It would not benefit from net/http standardization.\n. ",
    "hugows": "Was the example linked in https://github.com/pressly/chi/blob/master/_examples/rest/render/render.go integrated into rest/main.go?. So I'd like to understand if you prefer something like:\n\"render.RenderList(w, r, NewArticleListResponse(articles))\ninstead of something like unrolled/render does, based on interface{}...\nThanks for chi btw! :). Hi @VojtechVitek,\nCould you explain the meaning of the asterisk on the routes pattern? Like, this:\ngo-chi\\chi\\_examples\\router-walk>go run main.go\nGET /\nPUT /ping\nGET /road/*/left\nPOST /road/*/right\nseems to suggest that the router matches /road/something/left instead of /road/left?. Sorry, that was a very basic mistake (C style thinking), I was going to delete the issue.\nSolution is of course to just write TokenCtx as such:\nfunc (api *Api) TokenCtx(next http.Handler) http.Handler {\nThanks for Chi, again.\nHugo. So https://www.youtube.com/watch?v=_dz7CIYQXcg ?. ",
    "fiorix": "Please allow it to take an http.FileSystem instead of directory so we can serve static files from memory. I often do that along with go-bindata.\n. ",
    "philippgille": "@pkieltyka: Is it correct that this functionality doesn't exist anymore, but instead you have to follow this example?. ",
    "ufoscout": "Was this feature removed in last release (i.e. 3.3.2)?\nI am asking this because I have compilation errors when I use it:\nimport (\n    ...\n    \"github.com/go-chi/chi\"\n)\n...\nfunc Start() {\n    chi.NewRouter().FileServer(\"/static\", http.Dir(\"frontend\"))\n}\ncompilation error:\nsrc/core/coreModule.go:56:18: chi.NewRouter().FileServer undefined (type *chi.Mux has no field or method FileServer)\nAm I doing something wrong?\nI see that this is deprecated in 3.0 changelog, it is completely removed now?. ",
    "mrcpvn": "@pkieltyka yes, if the input of the (_Mux).ServeHTTPC function was not a chi.Context there was a panic on the chi.(_treeRouter).ServeHTTPC\npanic: interface conversion: interface {} is nil, not chi.Context [recovered]\n        panic: interface conversion: interface {} is nil, not chi.Context\ngoroutine 41 [running]:\npanic(0x3adc40, 0xc8201228c0)\n        /usr/local/go/src/runtime/panic.go:464 +0x3e6\ntesting.tRunner.func1(0xc820139320)\n        /usr/local/go/src/testing/testing.go:467 +0x192\npanic(0x3adc40, 0xc8201228c0)\n        /usr/local/go/src/runtime/panic.go:426 +0x4e9\ngithub.com/pressly/chi.treeRouter.ServeHTTPC(0xc820103f80, 0xc820104150, 0x14c00e0, 0xc820103fb0, 0x14c0288, 0xc8200feea0, 0xc82012b5e0)\n        /Users/marco/Programmazione/go/src/github.com/pressly/chi/mux.go:329 +0x301\ngithub.com/pressly/chi.(_treeRouter).ServeHTTPC(0xc820120ca0, 0x14c00e0, 0xc820103fb0, 0x14c0288, 0xc8200feea0, 0xc82012b5e0)\n        :18 +0xca\ngithub.com/pressly/chi.(_Mux).ServeHTTPC(0xc820127080, 0x14c00e0, 0xc820103fb0, 0x14c0288, 0xc8200feea0, 0xc82012b5e0)\n        /Users/marco/Programmazione/go/src/github.com/pressly/chi/mux.go:288 +0x6c\ngithub.com/pressly/chi.TestMuxServeHTTPC(0xc820139320)\n        /Users/marco/Programmazione/go/src/github.com/pressly/chi/mux_test.go:325 +0x992\ntesting.tRunner(0xc820139320, 0x6112c8)\n        /usr/local/go/src/testing/testing.go:473 +0x98\ncreated by testing.RunTests\n        /usr/local/go/src/testing/testing.go:582 +0x892\nexit status 2\nFAIL    github.com/pressly/chi  0.052s\n. Hello @pkieltyka. Can you please explain why my implementation was not a good solution for this issue?\nI think that an incoming context should be handled by the router.\n. Thank you for the explanation @pkieltyka. I found the issue with mux.ServeHTTPC because I was calling the method from a middleware handler that is context aware and will pass a context.Context to the chi.Router (calling directly the ServeHTTPC method). This is probably an edge case but should not be ignored. \nI know that with Go 1.7 this problem will go away but for the moment I need to support a context in the ServeHTTPC method.\n. @pkieltyka I pushed the example into this repository:\nhttps://github.com/mrcpvn/chi_middleware\n. @pkieltyka @VojtechVitek the implementation looks good to me.\nI have also done some performance tests and found no issues.\n. I closed the issue because the same feature can be created with a middleware.\nFrom my point of view this is not a bug if the methodNotAllowedHandler is used to handle an http method that is not expected from the chi.Router.\n. The logger will print the time in us, ms, s but it will always report a us measure:\n2016/06/14 16:44:58 [XXXXXXXX/i4yumvPyxk-000001] \"GET http://127.0.0.1:9000/test HTTP/1.1\" from 127.0.0.1:53425 - 400 32B in 59.893\u00b5s (59.893\u00b5s)\n2016/06/14 16:49:27 [XXXXXXXX/sG6zaKx1HG-000001] \"GET http://127.0.0.1:9000/test HTTP/1.1\" from 127.0.0.1:53602 - 400 32B in 6.438466ms (6438.466\u00b5s)\nA formatter for the logger would be a handy solution.\n. @pkieltyka thank you. \nExporting \"Parent\" will resolve the compatibility problem but I agree with you that chi.Context is a context.Context and that is what is needed.\nI used to set the parent context to mock the router but I can solve easily this problem testing with httptest package.\nThe v1 compatibility is not a problem so for me no code change is needed in chi v2.\n. Hi,\nas a workaround you can set up the route like this:\nchi.NewRouter().Get(http.HandlerFunc(yourHandler.ServeHTTP))\n. @pkieltyka \nthis will make Context unexported. \nthe context implementations of the standard library has Context exported and this will also break compatibility with chi v1. For example:\nc := chi.Context{}\nc.Context = context.Background()\nwill not compile.\n. ",
    "mgenware": "Just solved this after a few minutes. this works fine now:\ngo\n// r is a Router variable\nblogRouter := chi.NewRouter()\nblogRouter.Get(\"/\",  blogWithTrailingSlashHandler)\nblogRouter.Get(\"/list\", blogListHandler)\n// mount this router for a URL with trailing slashes\nr.Mount(\"/blog/\", blogRouter)\nr.Get(\"/blog\", blogHandler)\n. @pkieltyka Yes, it works.\n. coldfunction is using chi as the only HTTP router behind nginx, all our code is written in Go.. Hi @mozhata, I don't see anything wrong, if i read correctly, what you meant is why r.URL.Path is different from r.URL.RawPath? I think It's expected and not related to chi.URLParam at all, i can show you a simple example even without chi:\n```go\npackage main\nimport (\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n)\nfunc main() {\n    go func() {\n        http.HandleFunc(\"/Go\", func(w http.ResponseWriter, r *http.Request) {\n            fmt.Printf(\"URL.Path: %s, URL.RawPath: %s\\n\", r.URL.Path, r.URL.RawPath)\n        })\n    log.Fatal(http.ListenAndServe(\":8080\", nil))\n}()\n\nfor _, name := range []string{\"Go\", \"%47%6f\"} {\n    addr := fmt.Sprintf(\"http://127.0.0.1:8080/%v\", name)\n    fmt.Printf(\"Requesting %v\\n\", addr)\n    _, err := http.Get(addr)\n    if err != nil {\n        panic(err)\n    }\n}\n\n}\n```\nPrints:\nRequesting http://127.0.0.1:8080/Go\nURL.Path: /Go, URL.RawPath:\nRequesting http://127.0.0.1:8080/%47%6f\nURL.Path: /Go, URL.RawPath: /%47%6f\nGo and %47%6f are both valid URLs (the latter in encoded form). URL.Path and URL.RawPath are well documented in docs. In general, you don't need to access URL.RawPath, use URL.Path instead, and do remember to escape unicode chars in URL in your code \ud83d\ude03\ndiff\n-addr := fmt.Sprintf(\"http://127.0.0.1:8090/file/%s\", rp)\n+addr := fmt.Sprintf(\"http://127.0.0.1:8090/file/%s\", url.PathEscape(rp)) \nbtw I saw Chinese in your code, feel free to ask(in English or Chinese) if you have any questions.\n. ",
    "lwc": "Love chi, it's fast becoming my default router choice for golang. The 1.7 compatibility branch is beginning to look like the perfect router for go.\nIf we're talking about a version 2.0 with breaking changes to the API, could I please ask you to consider introducing the notion of names for the routes? Named routes are handy for reverse lookups in templates etc, and also in monitoring tools such as Datadog and New Relic.\n. Sure thing, this is what I had in mind:\n``` go\n    app := chi.NewRouter()\napp.Post(\"/users\", \"user_create\", func(w http.ResponseWriter, r *http.Request) {\n    user := pretendUserCreator(r)\n    http.Redirect(w, r, app.URLFor(\"user_view\", map[string]interface{}{\"user_id\": user.ID()}), http.StatusFound)\n})\n\napp.Get(\"/users/:user_id\", \"user_view\", func(ctx context.Context, w http.ResponseWriter, r *http.Request) {\n    userID := chi.URLParam(ctx, \"user_id\")\n    pretendDisplayUser(w, userID)\n})\n\n```\nGives a nice DRY way to generate urls to routes. \n. Haha, I certainly wasn't channeling rails! Also yeah that example was contrived to illustrate my requirement, not adhere to REST best practices \ud83d\ude09 \nIt's a fairly common DRY practice to repurpose your routes & router for url generation, but I can appreciate you keeping it out of scope. Decorating the router is a viable solution.\n. \ud83c\udf89 this pretty much satisfies my requirement here: https://github.com/pressly/chi/issues/43#issuecomment-223188687 \ud83c\udf89 \ud83d\udc4d \n. The context API has been designed to discourage mutating contexts, which seems to contradict any kind of context reuse.\n. Makes sense.\n. Dupe of https://github.com/pressly/chi/issues/79 and was also mentioned in the original PR https://github.com/pressly/chi/pull/48#r72554065\n. The emptyBodyHandler in https://github.com/go-chi/chi/issues/238#issuecomment-319984775 isn't needed, looks like ResponseWriter.Write does nothing for HEAD requests  right in the standard lib.\nAlso, IMO it'd be simpler to update the HEAD request codepath to check for the existence of a GET handler  before returning method not allowed.. Yeah seconded - there is Handle and HandleFunc, should there also be Get and GetFunc? \nTargeting the interface imposes less opinions on usage.\n. ",
    "c2h5oh": "It's not as easy as it looks - how would the named routes work in this example?\n``` go\napp := chi.NewRouter()\nuserRouter := chi.NewRouter()\nuserRouter.Post(\"/\", \"user_create\", UserCreateHandler)\nuserRouter.Get(\"/:id\", \"user_view\", UserViewHandler)\napp.Mount(\"/users\", userRouter)\napp.Mount(\"/admin/users\", adminMiddleware, userRouter)\n``\n. I'd much rather we mapped query params tourl.Values- map[string][]string. Multiple copies of the same param would still work and since []string maintains order you'd know which one is which.. Tested the program above withab -c 1000 -n 10000 http://localhost:3333/` on Linux x86_64 with go 1.7rc2 and 1.7.4 - could not replicate the issue.\nWhat OS are you running?. I quite like typed url parameters Flask has:\n\n<string:param_name> or simply <param_name> - match everything but slashes\n<path:param_name> - match everything, including slashes\n<int:param_name>, <float:param_name> - quite obvious\n<any:enum1,enum2,enum3>\n\nFlask supports variable routes with different converters (the part before \":\"), but that's a bit much for us imo. At the same time supporting at least path would be nice.. > Add support for regexp\nHow about adding an option to register a \"converter\" https://github.com/pressly/chi/issues/167#issuecomment-293592221 and let people extend this?. @pkieltyka he has a point:\nhttps://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html\n\n9.4 HEAD\nThe HEAD method is identical to GET except that the server MUST NOT return a message-body in the response. The metainformation contained in the HTTP headers in response to a HEAD request SHOULD be identical to the information sent in response to a GET request. This method can be used for obtaining metainformation about the entity implied by the request without transferring the entity-body itself. This method is often used for testing hypertext links for validity, accessibility, and recent modification.\nThe response to a HEAD request MAY be cacheable in the sense that the information contained in the response MAY be used to update a previously cached entity from that resource. If the new field values indicate that the cached entity differs from the current entity (as would be indicated by a change in Content-Length, Content-MD5, ETag or Last-Modified), then the cache MUST treat the cache entry as stale.\n\nemphasis mine.. yeah, not provided by testRequest helper. I'll open a new ticket for that one.\n. This should still be a 503 - there is no gateway. 504 should only be returned by proxy if proxied service times out.\n. This needs to be explained. Seeing backlog in a throttler I assumed that backlog is the number of requests that you can queue on top of the limit, but if I correctly understand the code starting here https://github.com/pressly/chi/pull/26/files#diff-31daf09af7ba24641f7fce5bb0918d1dR76 backlog is the part of the limit that is queued (which explains why backlog < limit has to be enforced)\n. In that case return the correct code, but modify the message.\n. Good. :-)\n. IMO it should be \ngo\nHandle(method, pattern string, h http.Handler)\nAll(pattern string, h http.Handler)\nFirst All (or Any) is more self-explanatory, second method set can be extended. Not just \"can be extended in theory\" but this is something that is frequently done when building a protocol on top of HTTP - see WEBDAV for example.\n. Supporting this would also require a change to treeRouter.route to use string as key.\nOR, which I believe is better\nhave a single route on treeRouter & have map[method]http.Handler on node\nBenefits:\n- single route tree, instead of multiple (you are adding chain to ALL method trees on .Route now)\n- extensible method list\n- proper HTTP 405 handling (we're returning 404 when there is a route, just not for current method, which is incorrect - 404 should be returned when there is no route for ANY method)\n- no pointers in the tree -> no indirects -> routing tree as a single object and will often fit entirely in CPU cache (vs cache miss on every routing level - 2-5 CPU cycles vs 200-400 - see the very first table in https://blog.codinghorror.com/the-infinite-space-between-words/ )\n, instead of having a route[method]*treeRouter in a tree \n. This should not be iota - string corresponding to the actual HTTP header would be better. This is too easy to be overwritten by an uninitialized int.\n. HTML, TXT?\n. IMO this is not the right default behavior. \n. This encoding has been added for security reasons and should not be stripped by default.\nAnd even if we do decide we want to strip it by default it definitely should not do it by allocating 3 copies of a possibly large response. Do it with pass-through writer.\n. https://golang.org/pkg/encoding/json/#NewEncoder and stream to w (possibly through the encoding stripping writer - see next comment)\n. StatusCode StatusMessage?\n. Should check for cycles and limit max depth of a chain\nShould be protected by mutex\n. This should not panic - it's too late.\nWe should be checking for cycles and depth of presenter chain on register.\n. When can this happen?\n. Responder should be a middleware and get its body and headers from context.\nThis is go 1.7 middleware with context:\ngo\nfunc someMiddleware(next http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        // before code\n        next.ServeHTTP(w, r)\n        // after code\n    })\n}\nBy having responder write to response writer in handler you prevent all middlewares in chain to set HTTP headers in // after code\nIMO having \"response_headers\": *http.Header and \"response_body\": interface{} in context + responder as a middleware mounted very high (top level by default?) up the chain would be more flexible.\n. See my comment about renderer being a middleware - makes sense together\n. Go array zero value is nil not []type{} for a reason. We rely on that distinction in json for child posts.\n. If you pass a pointer it's going to be 4 bytes - non issue.\nEdit: I want to add body of the response that has not been marshalled yet, not []byte\nMiddlewares being unable to add headers after blocks us from changing the headers in middlewares based on response content (like for example generic pager middleware - which would be super neat :D) \nAnother limitation: right now middlewares are forced to write headers to the response, so a middleware can't override a header set by a previous middleware (or strip the header). \n. ah, good point.\n. I prefer plain text to math ContentType\n. Ad. 1. Matters only for a streaming response of which we have 1 and that could be handled as a special case: you could for example return writer or writers as response in ctx\nAd. 2. Also an option\nAd. 3 This will only work until the 1st byte of the body is written, so it will not work anywhere in middleware chain in the code run after next.ServeHTTP\n. go\nw.Header().Set(\"Header\", \"first value\")\nw.Header().Set(\"Header\", \"no, sorry, this is the right value\")\nequals\nw.Header().Set(\"Header\", []string{\"first value\", \"no, sorry, this is the right value\")}\nand not\nw.Header().Set(\"Header\", \"no, sorry, this is the right value\")\n. If we used  a global map[string]ContentType var we could let people add their own - similar to https://golang.org/pkg/mime/#AddExtensionType. Let's return ContentTypeUnknown instead of silently overwriting it. My reflect knowledge is somewhat lacking: why not simply v = reflect.Indirect(reflect.ValueOf(v)) ?. Being able to set a Decoder per Binder (with fallback to DefaultDecoder) would be super useful for handling forms with something like http://www.gorillatoolkit.org/pkg/schema. See decoder comment. ",
    "srinathilabs": "How the tracking is done? Where can I see the documentation?. ",
    "vektah": "We have a chi based reverse proxy serving ~12M requests a day. It has a lot of http.Handler middleware so there were many layers of 'mwrap' on our requests.\nI updated to golang 1.7 and this branch to see how the benchmarks would look:\n```\ngolang 1.6.3 + chi 1\nPASS\nBenchmarkStack-4                           30000             44042 ns/op            6083 B/op        122 allocs/op\nBenchmarkFullRequest-4                     20000             83779 ns/op           10046 B/op        206 allocs/op\nBenchmarkFullGZIPRequest-4                 20000             84837 ns/op           10323 B/op        207 allocs/op\nBenchmarkFullRequestConcurrently-4            50          23300284 ns/op         6001109 B/op      34279 allocs/op\nBenchmark404PageConcurrently-4                30          50251755 ns/op        15214906 B/op      91058 allocs/op\nBenchmarkGzip-4                              200           6952123 ns/op           54879 B/op        169 allocs/op\ngolang 1.7-rc3 + chi v2\nBenchmarkStack-4                           50000             40403 ns/op            6053 B/op        104 allocs/op\nBenchmarkFullRequest-4                     20000             64660 ns/op            9529 B/op        177 allocs/op\nBenchmarkFullGZIPRequest-4                 20000             65922 ns/op            9802 B/op        178 allocs/op\nBenchmarkFullRequestConcurrently-4           100          19811847 ns/op         6071349 B/op      32629 allocs/op\nBenchmark404PageConcurrently-4                30          38976743 ns/op        15151510 B/op      89831 allocs/op\nBenchmarkGzip-4                              200           6060412 ns/op           47497 B/op        169 allocs/op\n```\nApproaching +30%! I'm excited to see the real-world performance.\n. 99designs uses it as a router in front of our app servers.\nOn 5 Oct. 2016 18:50, \"Cyril David\" notifications@github.com wrote:\n\nHeroku is about to use it -- the branch we have is still being tested in a\nsandbox\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/pressly/chi/issues/91#issuecomment-251732124, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/ACJNLkYPj9AFSwkmEkZ6PjjcIWJXH0i5ks5qw9VtgaJpZM4KO0AL\n.\n. I don't think even:\n/root/:leaf.json will do what you expect. \n\nI think Chi matches prefixes only which means only one wildcard per path segment.. A way to automatically respond to a HEAD request using the GET handler if a HEAD handler hasn't been provided would be nice :+1:. Rather than get setting head, I was thinking more along the lines of a HEAD request falling through to get at request time:\n - If a HEAD handler is defined, use it. This makes optimisation possible / avoiding costly operations.\n - If a GET handler is defined, call it and throw the body away. Its extra work but http compliant without any work.\n - Otherwise send method not allowed\nAdditionally when a HEAD request is made to a GET handler, immediately after the headers are sent the context could be cancelled, avoiding external work and database calls where its supported.. > Please, NO implicit settings. If I want this behavior I will enable it explicitly. \nWhat about something like \ngo\nrouter.MethodNotAllowedHandler = chi.PromoteHeadToGet\n\nI would also like to point out, that HEAD lookup time will increase depending on the size of existing GET routes.\n\nI'm not sure that's true, last I looked the same tree node had all methods on it. Admittedly its changed a bit since regexs were introduced.. Yeah that would work, and it's pretty straightforward. The only thing I dont think like about it is it leaves the solo Get broken from a http perspective. We can catch it with a linter pass, but ideally the default is safe after configuring the router.. I think this kind of shadowing is preferred:\n```go\nr.Group(func(r chi.Router) {\n    r.Use(middleware.CloseNotify)\nr.Get(...)\n\n}\n```\nnot shadowing can lead to bugs like:\n```go\nouterRouter.Group(func(innerRouter chi.Router) {\n    innerRouter.Use(middleware.CloseNotify)\nouterRouter.Get(...)\n\n}\n```\nNow the middleware isnt applying to anything\nThe same logic applies to \"shadowing\" testing t.Run(func(t *testing.T) {}).. I like the idea of minimal version selection and removing the distinction between lock and manifest files is great. \nBut If every library needs to change then perhaps this idea needs more thought?. I cant see a way to mount a GET/POST/PUT only http.Handler, short of wrapping it in a:\ngo\nr.Get(\"/foo\", func(w http.ResponseWriter, r *http.Request) {\n    handler.ServeHttp(w, r)\n})\nPerhaps these should be http.Handler?\n. I think I'm mostly just dragging baggage from gorilla where you need to wrap middleware yourself, and HandlerFunc becomes kinda gross. Not really a problem with chi though.\nUgh, why didn't I think of just passing the func...\n\n. ",
    "novln": "Hello,\nFirst of all, thank you for this amazing router: it's the most elegant and minimalist solution I've found for the moment.\nI have a question however for the v2 release of chi, would it be possible to link a LogHandler (or LogHook) interface with the Logger middleware ?\nWhy I'm asking this ? Because nowadays if you prefer to use logrus with chi (for example), you have to copy/paste (or fork) the Logger middleware in order to override the printRequest function.\nOr, another solution would be to expose a Metrics middleware, which can forward these metrics to a MetricsHandler interface: for exemple, a Logger, a NSQ Producer or a InfluxDB database.\nDepending of your preference, I can submit a pull request in the v2 branch.\n. @pkieltyka Yeah, you've done a terrific job, as always :smile:. Oh, I haven't thought about the \"multiple backends\" use-case.\nIf we assume that the declaration of each routes are defined in the same thread in order to avoid race condition, then (with a little modification) you could use the NewLogger like these two examples:\n``` go\nfunc router() http.Handler {\n  logger := middleware.NewLogger(\n    middleware.DefaultLoggerBackend,\n    myCustomPrometheusLoggerBackend{},\n  )\nr := chi.NewRouter()\n  r.Use(logger)\n  r.Get(\"/\", ...)\n}\n```\nor\ngo\nfunc router() http.Handler {\n  r := chi.NewRouter()\n  r.Use(middleware.NewLogger(middleware.DefaultLoggerBackend))\n  r.Use(middleware.NewLogger(myCustomPrometheusLoggerBackend{}))\n  r.Get(\"/\", ...)\n}\nHowever, if a third Logger is required for a sub group:\n``` go\nr.Group(\"articles\", func(r chi.Router) {\nr.Use(middleware.NewLogger(AnotherLoggerForArticles{}))\n  r.Get(\"/\", paginate, listArticles)\n  r.Post(\"/\", createArticle)\nr.Group(\"/:articleID\", func(r chi.Router) {\n    r.Use(ArticleCtx)\n    r.Get(\"/\", getArticle)\n    r.Put(\"/\", updateArticle)\n    r.Delete(\"/\", deleteArticle)\n  })\n})\n```\nThe implementation I have in mind wouldn't work, and wrapping another writerProxy on top of a writerProxy (and so on...) may induce a great latency, a huge complexity and/or a poor performance. I haven't tested this case but it already seem shaky...\nFor these reasons, I would be inclined to think that this middleware should define only once, one or multiple backend. (So, it would be your example).\n. Hello,\nI've played a little with boom and chi and I think I've found a good trade-off with the API design (which enable the \"split\" use-case defined in my third examples) and performances.\nIf you prefer, I can submit a new pull request with a more appropriate branch name and a squashed commit. However, it will lose this discussion history...\nCheers,\n. Yeah, you're right. I've added some primary benchmark for this purpose, so if you have any feedback: don't hesitate. Also, don't merge it yet, I would like to add some testing too :)\nBesides, I've located two allocations per logger layer. I'll work on it later with a new pull request...\nBenchmarkLoggerWithoutMiddleware-4                   3000000           423 ns/op         352 B/op          3 allocs/op\nBenchmarkLoggerWithOneAppender-4                     2000000           846 ns/op         472 B/op          5 allocs/op\nBenchmarkLoggerWithMultipleAppenders-4               2000000           994 ns/op         472 B/op          5 allocs/op\nBenchmarkLoggerWithMultipleLayers-4                  2000000           806 ns/op         387 B/op          5 allocs/op\nBenchmarkLoggerWithMultipleLayersAndAppenders-4      1000000          1711 ns/op         512 B/op          7 allocs/op\nTo finish on a good note, I've run some benchmark on several router (Echo, Gin and LARS for instance) with and without logger (note: output on stdout was disabled, measuring my terminal has no value). With go1.7-rc1, chi as a pretty good review/ranking.\nBenchmarkChiWithoutLogger-4      5000000           364 ns/op         352 B/op          3 allocs/op\nBenchmarkChiWithLogger-4         2000000           762 ns/op         472 B/op          5 allocs/op\nBenchmarkEchoWithoutLogger-4    20000000            73.1 ns/op         0 B/op          0 allocs/op\nBenchmarkEchoWithLogger-4        2000000           869 ns/op         224 B/op          8 allocs/op\nBenchmarkGinWithoutLogger-4      3000000           569 ns/op         464 B/op          4 allocs/op\nBenchmarkGinWithLogger-4         2000000           779 ns/op         496 B/op          5 allocs/op\nBenchmarkLarsWithoutLogger-4    20000000            98.6 ns/op         0 B/op          0 allocs/op\nBenchmarkLarsWithLogger-4       10000000           156 ns/op           0 B/op          0 allocs/op\nCheers,\n. Hello,\nI think this will be my final commit for this Pull Request because I won't be available for the time being...\nIf it's look good for you, I will create a new pull request with a squashed commit.\nCheers,\n. Hello,\nOk I understand. I would prefer to have access to the goware organizations so others (including you) could contribute more easily to this middleware.\nCheers,\n. @pkieltyka I had the same issue while using hey load generator with go 1.7.3.\n. Hello,\nIt's a terminology choice in order to separate what the data is (a metric) with how it's handled (with a logger).\nFor example, depending of your use case, you may use this middleware to expose these metrics on one of these \"backends\":\n- NSQ Producer\n- RabbitMQ Queue\n- Telegraf (InfluxDB) Plugin\n- Prometheus Exporter\nWith these examples, is Logger still make sense ? I was trying to \"use\" a more generic terms (Metrics) for this purpose. (However, a Logger use these metrics)\nNevertheless, If the contributors team isn't conviced by this opinionated design, I can update this Pull Request with the terminology that you prefer.\n. @VojtechVitek : I'm pretty sure that this line keep the old interface the same for a stable API.\nYou still can use the Logger as a function and maintain compatibility with code such as:\ngo\nr.Use(middleware.Logger)\nhttps://github.com/pressly/chi/pull/56#discussion_r68762567\n. Ok, so for the terminology, do we agree to rename Metric as LogEntry and Metrics as NewLogger ?\nAlso, for the MetricsHandler interface, what do you prefer between:\n- LogAppender with a Append method.\n- LogHandler with a Write method.\nThank you.\n. ",
    "nhooyr": "@pkieltyka well it fully supports terminfo so older terminals will work properly. You won't need to hardcode all of the color escapes.\nAnd using it results in very readable code.\n. What exactly does this PR accomplish? What is render and presenter?\n. No problems, just trying to understand the implementation. I still see no benefit to making the wildcard parameter not always begin with \"/\".\nAlso, what are the downsides with a single large tree?\n. Yea, I know why it is there and how it works. I'll clarify my question. Why make the router prepend \"/\" in https://github.com/pressly/chi/blob/master/mux.go#L231 . Why not make it prepend \"/\" over here https://github.com/pressly/chi/blob/master/tree.go#L367 ? So that line becomes\ngo\nrctx.URLParams.Add(\"*\", \"/\" + xsearch)\nI see no reason why someone would want a catch all parameter without a slash at the front.\n. I'm still not getting it :(\nI'll make an example.\n``` go\npackage main\nimport (\n    \"net/http\"\n\"github.com/pressly/chi\"\n\n)\nfunc main() {\n    r := chi.NewRouter()\n    r.Get(\"/\", func(w http.ResponseWriter, r http.Request) {\n        w.Write([]byte(chi.URLParam(r, \"*\")))\n    })\n    http.ListenAndServe(\":8080\", r)\n}\n```\nIf you run the code and go to localhost:8080/anypath you will see anypath. My question is why is it anypath and not /anypath?\nWhat benefit is there to not having the slash in front of the wildcard parameter?\n. HTTPRouter adds that slash to make it an absolute path too. See https://github.com/julienschmidt/httprouter/pull/116\nI can see why adding it would be a bit confusing though because it's not obvious from the pattern that it would be absolute. I guess that's a good enough reason against it. What do you think?. Actually, since the keys for the context are then just strings and they might cause conflicts, I think it's a bad idea.. I found http://www.darkcoding.net/software/go-slice-search-vs-map-lookup/\nand wrote my own benchmarks:\n```go\npackage slicemap\nimport (\n    \"math/rand\"\n    \"strconv\"\n    \"testing\"\n)\nconst (\n    structureLength = 10\n    keyLength       = 5\n)\nfunc gen() (s string) {\n    for i := 0; i < keyLength; i++ {\n        s += string(rand.Int63n('{'-'a') + 'a')\n    }\n    return\n}\nfunc BenchmarkMap(b testing.B) {\n    m := make(map[string]string)\n    for i := 1; i <= structureLength; i++ {\n        b.Run(strconv.Itoa(i), func(b testing.B) {\n            k := gen()\n            m[k] = gen()\n            b.ResetTimer()\n            for i := 0; i < b.N; i++ {\n                _ = m[k]\n            }\n        })\n    }\n}\nfunc BenchmarkSlice(b testing.B) {\n    type item struct {\n        k string\n        v string\n    }\n    var s []item\n    for i := 1; i <= structureLength; i++ {\n        b.Run(strconv.Itoa(i), func(b testing.B) {\n            s = append(s, item{gen(), gen()})\n            b.ResetTimer()\n            k := s[rand.Int63n(int64(i))].k\n        benchLoop:\n            for i := 0; i < b.N; i++ {\n                for j := 0; j < len(s); j++ {\n                    if s[j].k == k {\n                        continue benchLoop\n                    }\n                }\n            }\n        })\n    }\n}\n```\nOn my laptop, I get (the integer next to each benchmark is the length of the map/slice):\nBenchmarkMap/1-8    100000000           28.2 ns/op\nBenchmarkMap/2-8    100000000           23.0 ns/op\nBenchmarkMap/3-8    100000000           24.8 ns/op\nBenchmarkMap/4-8    50000000            26.9 ns/op\nBenchmarkMap/5-8    50000000            29.4 ns/op\nBenchmarkMap/6-8    50000000            21.4 ns/op\nBenchmarkMap/7-8    100000000           22.0 ns/op\nBenchmarkMap/8-8    50000000            27.1 ns/op\nBenchmarkMap/9-8    50000000            30.0 ns/op\nBenchmarkMap/10-8   100000000           19.3 ns/op\nBenchmarkSlice/1-8  300000000            4.67 ns/op\nBenchmarkSlice/2-8  300000000            9.90 ns/op\nBenchmarkSlice/3-8  100000000           14.4 ns/op\nBenchmarkSlice/4-8  300000000            4.78 ns/op\nBenchmarkSlice/5-8  50000000            21.5 ns/op\nBenchmarkSlice/6-8  50000000            26.8 ns/op\nBenchmarkSlice/7-8  200000000           31.0 ns/op\nBenchmarkSlice/8-8  100000000           19.7 ns/op\nBenchmarkSlice/9-8  300000000           30.7 ns/op\nBenchmarkSlice/10-8             50000000            36.2 ns/op\nPASS\nok      github.com/nhooyr/slicemap  50.972s\nSo, around length 6, the slice becomes as slow as the map.\nWith the above results, I think the difference between the two is negligible and thus chi should just use a map because it is less code.. I'd side with Chi here. Using http.HandlerFunc is just cleaner. It was a mistake by net/http to not use it. And this doesn't really cause any serious issues so it doesn't make sense to change at this point.. Maybe this is a bug in Go and the interface should be considered implemented by Chi.. Given functions autocast to http.HandlerFunc\n. Yea my bad, I guess by bug I meant missing feature. Given you can directly use a func(w http.ResponseWriter, r *http.Request) as a http.HandlerFunc, why not consider the two interfaces equal?. @utrack I see the issue\nThe interface\ntype handler interface {\n    HandleFunc(string, func(http.ResponseWriter, *http.Request))\n}\nIs not equal to\ntype handler interface {\n    HandleFunc(string, http.HandlerFunc)\n}\nI'm saying maybe Go should consider them the same.. @vearutop Out of curiosity, why do you need to do this? Are you trying to wrap them all in middleware?. ",
    "lofcek": "\nOk\nI agree, that Group is bit confusing name, but I think the best from those you mentioned. Can we somehow ask other project participants? My personal favorites will be Group, InlineRoute, MiddlewareGroup, maybe Attach. Inline/UseInline is confusing.\n\nI also saw identifier inline as a flag inside Mux. This is the worst case give the same thing two different names. \n3. Why don't use defer?\n```\n// ServeHTTPC is chi's Handler method that adds a context.Context argument to the\n// standard ServeHTTP handler function.\nfunc (mx Mux) ServeHTTPC(ctx context.Context, w http.ResponseWriter, r http.Request) {\n    returnContext := func(ctx Context) {\n           ctx.reset()\n           mx.pool.Put(rctx)\n    }\n    if ctx == nil {\n        rctx = mx.pool.Get().(Context)\n        defer returnContext(ctx)\n        ctx = rctx\n    } else if rctx, ok := ctx.(Context); !ok {\n        if rctx, ok = ctx.Value(routeCtxKey).(Context); !ok {\n            rctx = mx.pool.Get().(*Context)\n            defer returnContext(rctx)\n            ctx = context.WithValue(ctx, routeCtxKey, rctx)\n        }\n    }\nmx.handler.ServeHTTPC(ctx, w, r)\n\n}\n```\n. If you decide not to use defer, than please close the issue and open new one with better name for Group. I also have a new favorite - GroupHandlers.\n. That is nearly what I had, with few notes.\n- Correct name should be StripTrailingSlash, because is it strips only one slash and only at the of the path.\n- You should not simply use rctx.RoutePath = path[:len(path)-1]. That work correctly on root path, but not if RouteContext was already used (in subrouter after Mount).\n- in if statement you forgot ctx = rctx\n- I'm not sure, but is it correct if path refers to root (path = \"/\")\n. And I also didn't realize it immediately- I think change data inside Context during execution is a bit confusing. I think it should be better to create a new chi.Context, don't change previous one.\n. ",
    "aboukirev": "A better term for what you call Group is Junction, albeit it's a longer name. If you are into biological taxonomy, you could use Clade. \n. ",
    "kanocz": "\"1a\" variant is much better (allows to use SO_REUSEPORT and start second instance)\nP.S.: it's possible just to use https://github.com/tylerb/graceful (or get some inspiration there)\n. I'm using it in few project for the moment... only one (very small, https://github.com/kanocz/minisv) is open source and public, but used on about 20 servers :)\n. if non-open-source project also \"accepted\" than we use it for part of REST (and also non-REST) API for https://homebeat.live (HomeBeat.Live GmbH)\n. In case of just URLParam you also receive \"\" without any errors if param doesn't exists and in many cases (for example: item id) you're expecting positive integer and zero indicates error itself\nand I think that code like\nitem := chi.URLParamUint(r, \"item\")\n  timestamp := chi.URLParamUint(r, \"timestamp\")\n  if 0 == item || 0 == timestamp { /* error */ }\nlooks just readable and simple\nand this makes possible to write simple construction like\nfunc httpGetItem(w http.ResponseWriter, r *http.Request) {\n  data, err := getItem(chi.URLParamUint(r, \"item\"))\n  if nil != err {\n     // ......\n  }\n}\nwhere we really don't need to verify - database doesn't contain \"zero\" item usualy\nP.S.: my opinion is just \"simpler code = less errors\"\n. ",
    "cyx": "Yep, right now we're using goji/graceful, and it appears to work, so I'm curious what @pkieltyka is thinking re: his comment that what we're doing wouldn't work. Maybe subtle race conditions?\n. @pkieltyka nice, I see what you mean now -- you're very precise in the teardown process so I guess the way we're doing it now will be hand-waivy about things at best.\nExcited to see something first class in chi?\n. For our usecase, the most important part is cancellation.\n``` go\n        ctx, cancel := context.WithCancel(context.Background())\n    graceful.AddSignal(syscall.SIGTERM)\n    graceful.PostHook(cancel)\n\n    // more code here that adds on to context.\n\n```\nFWIW we were originally using github.com/guregu/kami. We definitely love a working PR we have moving to chi, and this is the only piece that felt weird to me TBH.\n. @pkieltyka do you sit in any irc / slack channel? Would be interested to talk about this in detail.\n. Heroku is about to use it -- the branch we have is still being tested in a sandbox\n. Heroku is using it for our metrics api\nOn Fri, Mar 3, 2017, 00:15 Aspire notifications@github.com wrote:\n\nQingCloud http://www.qingcloud.com is using pressly/chi in our internal\nservices.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/pressly/chi/issues/91#issuecomment-283893015, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AAAI0YwT7WnDJZ-TsNKCx2t0tEcldmH4ks5rh8wQgaJpZM4KO0AL\n.\n. Perfect thanks for the quick turnaround. I'll get this pulled into our latest release and use it in our prod servers this week.\n. \n",
    "buro9": "Thanks for that, I'll go with the first r.Group method as it reads nicer.\nActually going to take it further and put no middleware at the top level and then define groups for all routes.\ni.e.\n``` go\npackage ui\nimport (\n    \"fmt\"\n    \"net/http\"\n\"github.com/pressly/chi\"\n\"github.com/pressly/chi/middleware\"\n\n)\nfunc ListenAndServe() error {\n    r := chi.NewRouter()\n// Pages group, handles all routes for pages and defines the appropriate\n// middleware for web pages\nr.Group(func(r chi.Router) {\n    r.Use(middleware.RequestID)\n    r.Use(middleware.Logger)\n    r.Use(middleware.RedirectSlashes)\n    r.Use(middleware.Recoverer)\n    r.Use(session)\n\n    r.Get(\"/\", homeGet)\n})\n\n// Static file group, defines minimal middleware\nr.Group(func(r chi.Router) {\n    r.Use(middleware.Logger)\n\n    r.Mount(\"/static\", staticFiles())\n    r.Get(\"/favicon.ico\", favicon)\n    r.Get(\"/robots.txt\", robots)\n})\n\nreturn http.ListenAndServeTLS(\n    fmt.Sprintf(\":%d\", *listenPort),\n    *certFile,\n    *keyFile,\n    r,\n)\n\n}\nfunc staticFiles() http.Handler {\n    r := chi.NewRouter()\n// Do nothing, but implement http.Handler\nr.Use(func(next http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        next.ServeHTTP(w, r)\n    })\n})\n\n// Serve static files\nr.Mount(\"/\",\n    http.StripPrefix(\n        \"/static/\",\n        http.FileServer(http.Dir(*filesPath+\"/static/\")),\n    ),\n)\n\nreturn r\n\n}\n```\n. Cloudflare are using it within a helper package that wraps internal JSON REST services.\n. ",
    "gpopovic": "@pkieltyka exactly what i needed. Thanks\n. @pkieltyka \nNote that Mount() simply sets a wildcard along the pattern that will continue routing at the handler, which in most cases is another chi.Router. As a result, if you define two Mount() routes on the exact same pattern the mount will panic.\nTherefore this is not a solution, because as I said in my first comment, it forces you to use different path for each router.\n. @pkieltyka thanks :+1: . @pkieltyka  are you sure middlewares are not called? I tested now ..and it seems that middlewares ARE called .\nMy router looks like this\n```\napp.Router.NotFound(app.NotFound)\napp.Router.Use(app.WithLogger)\napp.Router.MethodNotAllowed(app.MethodNotAllowed)\napp.Router.Post(\"/\", func(w http.ResponseWriter, r *http.Request) {\n    w.Write([]byte(\"AAAAAAAAAA\"))\n})\n```\nAnd i get logging line on every 404 and 405, which means that middlewares are called. Ok so i can confirm, middlewares are called..but i noticed another bug..I'll open the issue for that . Same goes for MethodNotAllowed. ",
    "christopherdiehl": "@pkieltyka can you please elaborate? I don't understand how to replicate the URLParams in the router context.\nThank you!. ",
    "soedar": "I've recently ran into the same issue. For posterity, this should work: \n```golang\nw := httptest.NewRecorder()\nr := httptest.NewRequest(\"GET\", \"/\", nil)\nrctx := chi.NewRouteContext()\nrctx.URLParams.Add(\"key\", \"value\")\nr = r.WithContext(context.WithValue(r.Context(), chi.RouteCtxKey, rctx))\nhandler := func(w http.ResponseWriter, r *http.Request) {\n    key := chi.URLParam(r, \"key\") // \"value\"\n}\nhandler(w, r)\n```\nAdapted from: https://github.com/go-chi/chi/blob/91a3777c41c3d3493a446f690b572d93a76cba73/mux_test.go#L1143-L1145. ",
    "gonzaloserrano": "@soedar solution works, thanks a lot!\nAnyway I don't think chi should panic if the context is not available like it does with:\npanic: interface conversion: interface {} is nil, not *chi.Context [recovered]\n    panic: interface conversion: interface {} is nil, not *chi.Context\nMaybe if there is no context URLParam() could return empty string instead?. ",
    "CaptainCodeman": "Brilliant, thanks !\n. Yeah, I totally get how things can quickly drift into being ambiguous and unclear. The httprouter and many of it's variants don't handle the suffix differences but Echo especially does a great job of getting the matching right (so can support routes that Gin, for instance, can't). I think if the routes are truly ambiguous as your yearMonth/xy example then all bets are off (without some additional constraint such as regex matches for a param).\nThe main use case I have actually has a static suffix (like /thumb.jpg) which disambiguates the route. I guess that could boil down to having something like:\n/:name/user\n/:id/order\nThat seems to match the type of thing you say could be supported which would be great if that's possible. Like I said, the route did match correctly in terms of getting to the right handler, it just didn't have the right param names set.\nSo yes, if that last example you give could be supported, that would be ideal.\nThanks again for looking into this!\n. @pkieltyka Sure, here's an example. I have some images that are stored in either AWS or GCS. The files in AWS are in a year / month structure and the ones in GCS are just based solely on the id. The routes using Echo (e being the echo router) would be:\ne.Get(\"/:year/:month/:id/thumb.jpg\", awsThumbnailHandler)\ne.Get(\"/:id/thumb.jpg\", gcsThumbnailHandler)\nBoth handlers are correctly called for the different URLs but the gcsThumbnailHandler currently gets a year parameter instead of the id which is confusing.\nThe suffix also comes into play with other handlers for things like ../preview.jpg URLs, tiles etc...\nMaybe I should add a PR with some failing tests? I know, also including the code that then fixes them would be better ...\n. yeah, that's what I'm doing ... just figured it may save someone the same initial confusion when just one route param didn't seem to work (esp. as it could be adding another route, someplace else that breaks it).\n. ",
    "jhngrant": "I appreciate there may be strong opposition to this, but +1 for regular expression matching. I'm finding this essential when migrating legacy code. \n. Good to hear that Chi does not rule out regexp - I wasn't aware. I'll endeavor to make a contribution.\n. IT Jobs Watch uses it for internal applications.\n. ",
    "dbudworth": "for your original example @pkieltyka \n/items/:category => categoryHandler\n/items/:year/:month => yearMonthHandler\n/items/:x/:y => xyHandler\nOther routers like httprouter and httptreemux both panic when registering the xy version as it's an ambiguous match. \nBasically, any method+path pair that doesn't result in a unique mapping generates a panic at setup time. (last I checked)\nI think that's much preferred over last one registered \"wins\"\n. ",
    "ARolek": "I'm having a similar issue. I have two routes:\n/maps/:map_name/:z/:x/:y\n/maps/:map_name/:layer_name/:z/:x/:y\nWhen calling chi.RouteContext(r.Context()) on a request made to /maps/mymap/mylayer/1/2/3.vector.pbf I get the following values (formatted for easier reading):\ngo\n&{\n  URLParams:[\n    {Key:map_name Value:mymap} \n    {Key:z Value:mylayer} // this should be \"1\"\n    {Key:x Value:1} \n    {Key:y Value:2} \n    {Key:y Value:3.vector.pbf} // why a second \"y\" value?\n  ]\n  RoutePath: \n    RoutePattern:/maps/:map_name/:layer_name/:z/:x/:y \n    RoutePatterns:[/maps/:map_name/:layer_name/:z/:x/:y]\n  }\nA few things to note:\n- it looks like a second \"y\" value was generated.\n- the \"layer_name\" parameter has disappeared and been replaced with the \"z\" value\nThis is only problematic when I have both routes defined. \n. ",
    "donutloop": "Any plans to fix that?. I have the same issue . How about adding a method to bind a http.handler to a specific method? For Instance:\nfunc (mx *Mux) Handle(method string, pattern string, handler http.Handler) {\n    mx.handle(Methods.lookup(method), pattern, handler)\n}\nor \nfunc (mx *Mux) Handle(method MethodTyp, pattern string, handler http.Handler) {\n    mx.handle(method, pattern, handler)\n}. ",
    "didip": "Oh, TIL, they can be casted back and forth. This works too: handler.(http.HandlerFunc).\nThanks for taking the time!\nBut that said (I am just opening a discussion here), what do you guys think about having GetFunc and Get as new API? It seems cleaner.\n. This is my mistake, the feature works as expected.\nSorry for wasting your time.\n. Hm, bummer.\nI understand not wanting to have complex parser and slowing the router down.\nBut it would be nice if the URL chunk is tokenized by /, ., and ? at minimum to avoid surprises for people coming from another frameworks or routers.. Thanks all for the response!\nI am down with either {id} or :id. ",
    "nubunto": "Since http.HandlerFunc implements http.Handler, shouldn't all the method functions take an http.Handler instead? This is probably a stretch WRT compatibility, but it would make more sense to structure chi routers around interfaces, rather than around functions.\n. ",
    "elithrar": "Thanks for raising this! Some thoughts:\n- Right now there are two popular libs (amongst many others) that tackle this, with different (but large) APIs: https://github.com/mholt/binding and http://www.gorillatoolkit.org/pkg/schema - thus: what would render do differently here?\n- I like that\u2014from the example\u2014it's integrated with chi, but you will undoubtedly get requests around skipping fields in the request body, up/down-casing fields, etc (take a look at the issues/PRs for gorilla/schema...). \n- reflect is unavoidable if this is going to be plug-and-play.\n. @pkieltyka \nOverall - like it a lot. It's simple, although we should expose decoding errors to make it clear when the POST body was empty vs. we couldn't decode (for whatever reason).\n. @pkieltyka Do you have the diff between the current HEAD on that branch and the prior? \n. Does that belong in chi? Why not improve mholt's lib? or gorilla/schema?\nOn Wed, Jan 25, 2017 at 11:55 AM msaron notifications@github.com wrote:\n\n@VojtechVitek https://github.com/VojtechVitek After reviewing almost\nall of the libraries out there and reviewing their pros and cons, I have\ncome to the conclusion that I would like to merge the following three\nlibraries and we would get something like the Joi library.\n\nbinding library https://github.com/mholt/binding by mholt\nA flexible validation library framework by mccoyst\n   https://github.com/mccoyst/validate\nA simple efficient and robust tag validation library by goburrow\n   https://github.com/goburrow/validator/\n\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/pressly/chi/issues/84#issuecomment-275215049, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AABIcMrBhvwDcPVXaA3efnuK_FVYas7jks5rV6ijgaJpZM4J4Gz2\n.\n. What if it errors?\n. \n",
    "msaron": "I would like to add a suggestion. I am coming from developing apps using  hapijs developed by Walmart for the backend. One really cool feature they have is that they use the Joi library to validate and convert all incoming and outgoing information. I have not seen this in any other library. Once the request reaches your handler, you can rest assured that the data you have received (via request parameters or query or headers) is validated and clean. It also checks all outgoing information is what you wanted it to be. It dramatically reduces developer effort in creating apps. I don't know if this is possible in chi, but I found it to be the most useful library in hapijs.. @VojtechVitek I think I have found a library that is similar to Joi. Here it is go-ozzo. I am going to give it a shot.. The problem is that they all use tag based validation (see example above by @VojtechVitek ). Tag based validation is error prone and is not at all flexible. For example, say I want to determine that a value is in a dynamically generated list of items  and the list depends on the userid of the request. This would be very difficult to do using tag based validation. Another negative of tag based validation is that errors are not caught at compile time.  And for date fields how would I validate the date field to check that it is not greater than the current date? We would be trying to force fit the tags implementation on dynamic values.\nThe go-ozzo library is the closed thing to a flexible library. \nI am going to incorporate the validation rules from goburrow validator into the go-ozzo validator which have been really thought out and powerful. For example goburrow has the \"min\" validation rule, which applies the rule depending upon what has been passed in. If a string is passed in, then it checks for the minimum length. If a slice has been passed in, then it checks for the length of the array. If an integer has been passed in, then it checks if the value is equal to or greater than the min value. And so on...\nI would strongly request that if you do develop a validation library to supplement the chi library, it should not be a tag based library. Please see the example from the Joi library in NodeJS (developed by Walmart) to see how elegant it is. . @pkieltyka  If possible, could you add a CSV renderer also? I have implemented it like so below, but it would be great if it was part of the chi library. \nfunc CSV(w http.ResponseWriter, r *http.Request, v interface{}, filename string) {\n\n  // Get result as CSV bytes using \"github.com/gocarina/gocsv\"\n  csvContent, err := gocsv.MarshalBytes(v)\n\n  if err != nil {\n    http.Error(w, err.Error(), http.StatusInternalServerError)\n    return\n  }\n\n  newfilename := strings.ToLower(filename)\n  ext := filepath.Ext(newfilename)\n\n  if ext == \".csv\" {\n    newfilename = filename\n  } else {\n    newfilename = filename + \".csv\"\n  }\n\n  w.Header().Set(\"Content-Type\", \"text/csv\")\n  w.Header().Set(\"Content-Disposition\", \"attachment; filename=\"+newfilename)\n  w.Write([]byte(csvContent))\n}\n\n. @VojtechVitek   I understand that but what I was suggesting was that chi implement a CSV renderer without using any third-party library.. @pkieltyka Yes, I believe that is the best approach.. ",
    "ChrisHines": "The panic(\"unreachable\") lines were required by Go prior to v1.1, see https://golang.org/doc/go1.1#return.\n. ",
    "zbindenren": "Any news on this? Does that have any chance to get meged?\nBTW: gorilla.mux also provides a walk function.. @pkieltyka I would like to see the RAML generator in docgen. Would be great!. Great! Thanks for sharing this project.. Is there a reason why walk() is not public?. @pkieltyka I have the same issue with the latest releases. I opened the issue with the reproducer for the docgen repo here.. @pkieltyka thanks for the quick response. I know I can traverse the routes with chi.Routes(), but that is not what I want.\nI am trying to get the route context inside a middleware. I tried it with:\ngo\nc := chi.RouteContext(r.Context())\nfmt.Println(c.RoutePattern)\nI wrote a prometheus middleware for chi. Right now i takes as tag, statuscode, url and method.\ngo\nrw.Status()), r.Method, r.URL.Path\nBut with that approach I get a very large tag dimension (because every other option is another url), therefore I wanted to tag by the router pattern.\nIf it is not possible, no problem, I keep it the way I already have it.\n. ",
    "zet4": "It's about 2 months now, any updates on this? Would love to have RAML in my API's too.. Note: I haven't tested this\nTry using r.Mount(\"/echo\", sockjs.NewHandler(\"/\", ...)), I would however suggest using https://github.com/olahol/melody with normal WS connection on client side, instead of sockjs.. @alphahelix00 the issue is closed but I guess I will still answer your question, socket.io/sockjs add additional overhead/costs on top of normal WS (if its even using WS, it might fallback to Polling without you knowing)\nMelody is still using gorilla websockets underneath, its just a nicer wrapper with session handling added.\nI use it for one of my person projects alongside Chi.. Works fine for me in my implementation https://github.com/zet4/disguard/blob/master/reverseproxy.go#L52. Nope, without the explicit check the type cast will cause a panic, found out about this while writing test for it. . ",
    "minoritea": "We, Origami Inc., uses it for our new API server(actually, it is not released yet but coming soon).\n. ",
    "zxr90": "Call levels use it in one of our internal applications. Might plan to use it for our new API server.\n. ",
    "abh1nav": "@pkieltyka CrowdRiff uses it for ~80% of our internal services as well as powering our public API \ud83d\udc4d \n. ",
    "chenjie4255": "contacts.wps.cn is using chi for some of web services, but the product is still developing.. we are using it at https://moreless.io as App Tide 's backend.. @ustrajunior @VojtechVitek  sorry for the inconvenience.\nI retry with package github.com/go-chi/chi and still got an 405 method not allowed error :(\nhere is my curl code:\ncurl -v -X OPTIONS \\\n  http://localhost:3000/ \\\n  -H 'cache-control: no-cache' \\\n  -F Origin=http://www.google.com\nrespone:\n```\n   Trying ::1...\n TCP_NODELAY set\n* Connected to localhost (::1) port 3000 (#0)\n\nOPTIONS / HTTP/1.1\nHost: localhost:3000\nUser-Agent: curl/7.54.0\nAccept: /\ncache-control: no-cache\nContent-Length: 162\nExpect: 100-continue\nContent-Type: multipart/form-data; boundary=------------------------42627caf0fee76ac\n< HTTP/1.1 405 Method Not Allowed\n< Date: Sat, 30 Sep 2017 02:55:17 GMT\n< Content-Length: 0\n< Content-Type: text/plain; charset=utf-8\n< Connection: close\n< \n* Closing connection 0\n```. @ustrajunior, I am quite sure I have already define my handler within the example code. as you can see:\n\n```\n    r.Group(func(r chi.Router) {\n        r.Use(cors.Handler)\n        r.Get(\"/\", func(w http.ResponseWriter, r *http.Request) {\n            w.Write([]byte(\"welcome\"))\n        })\n    })\n```\nonly one different from your code is that I am using the curl command directly to send an OPTIONS request, but this should not make any materially changes.. @ustrajunior unfortunately this issue is reported by my frontend teammate. he told me my API does not work since 405 error.\n@VojtechVitek yes,It works good without subgroup as I said. I think I need to debug a request my self If this issue cannot be reproduced by you.\n. ",
    "mvdan": "I'm using chi for a new project, nothing live yet though.\n. Oh, makes sense. In that case, I think the README should be modified to clarify that any net/http middleware will work with chi. Right now it only mentions chi middleware and lists middlewares developed alongside chi, so this wasn't obvious to me.\nThanks!\n. The standard linter does some things, other linters do others. This PR isn't to always force all the linters. I simply ran some of them and applied some sane improvements and cleanups.\n. Actually, fuck, made one mistake.. The duplicate node parameter wasn't unused - in the recursive call, it's a different value compared to the receiver parameter.\nReverted that bit.. Also, no Travis?. Sure, I'll undo that.. @pkieltyka done, FYI. Bump? I can get that there's no hurry, but this is a bit extreme.. Is this repo in some sort of freeze? If so, could you document it? I'm still confused as to what is going on with contributions to this repo, as the repo is active.. Perhaps I'm being impatient - apologies. I just don't understand why it's being parked. I keep an eye on pull requests that I send, and I worry about old ones because they tend to mean extra work like remembering what changes I made or why, and fixing conflicts.\nIf the repo is in some sort of freeze or prioritization for v3, I'd understand. My point above is that I haven't seen that written anywhere.. Ah I see, I missed that repo (forgot to do an org-wide search).\nYes, that's exactly what I was thinking of building. It should be all that I need. However, the way the project is built, it handles hosts at the sub-router level, not at the top level. So I would have to refactor quite a bit of the code to make it fit hostrouter.\nI'll give it a go and let you know if I hit any wall (i.e. anything that was possible with the other router, but not chi+hostrouter). Feel free to close this issue, and I'll reopen in that case. Thanks!. This was gosimple: https://github.com/dominikh/go-simple\nIn particular:\n\nDon't check if slices, maps or channels are nil before checking their length, it's redundant. len is defined as zero for those nil values.\n. Never a fan of leaving commented out code. I can simply remove the commit from the PR.\n. FYI, the commit is already removed.\n. \n",
    "ustrajunior": "I'm using on https://github.com/ustrajunior/minion and working on a big refactor that will be using chi through minion.\n. Hey, @cescoferraro. The chi.URLParam function receives a *http.Request as parameter but you are passing a context.Context.\nTo fix your code, use \nchi.URLParam(r, \"userID\")\n. Hey, @jutkko. \nYou can check this issue about this: Chi pronunciation?.. @chenjie4255 You are using github.com/pressly/chi that's the older URL for this project. The project change to github.com/go-chi/chi. I tried your code on the correct repository and works fine. . @chenjie4255 I believe you are getting 405 because you are trying to request a handler that was not defined. \nYou have defined an endpoint to a GET method. To archive what you are trying, you must define: \ngo\nr.Options(\"/\",  func(w http.ResponseWriter, r *http.Request) {})\nBut you don't need this when using the cors middleware.\nIf you try to do to an ajax request like:\njs\n$.ajax({\n  url: \"http://localhost:3000/\",\n  context: document.body\n}).done(function() {\n  $( this ).addClass( \"done\" );\n});\njquery will do a options request before the actual get request and the cors middleware will respond with the configured response. \n. @chenjie4255 Yes, I see. I'm not quite sure why with curl does not work. I know that doing a preflight on the browser works great. Maybe @VojtechVitek can have a better explanation.. ",
    "tors": "pocketmath.com is using chi for some internal apps. keep up the good work!\n. ",
    "stefanwuthrich": "wondering, if there is somebody using chi in combination with authboss ( https://github.com/go-authboss/authboss ) ?\n. Resolved based on https://medium.com/@szablowska.patrycja/chi-and-missing-urlparam-in-middleware-9435c48a063b. ",
    "pengsrc": "QingCloud is using pressly/chi in some of our internal services.. \u2764\ufe0f . ",
    "dannyvankooten": "We are using chi for our shop platform & API on https://platform.boxzillaplugin.com. Nothing too crazy, about 80 routes total. Also running behind NGINX. . After  searching through the issue list I see this is brought up more often, so this is probably a duplicate of #79 and #94.. To answer my own question, with chi's current interface it seems that we can do this.\n```go\ntype Handler func(w http.ResponseWriter, r *http.Request) error\nfunc (h Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    if err := h(w, r); err != nil {\n        // handle returned error here.\n    }\n}\nfunc main() {\n   r := chi.NewRouter()\n   r.Get(\"/foo\", http.HandlerFunc(Handler(fooHandler).ServeHTTP))\n} \n```\nI'd like to echo the sentiments in the other two issues about this though, it would make a lot of sense to use an interface instead of func in the router method signatures. Fingers crossed that will make it into a future version of chi! :crossed_fingers: . That is great news @pkieltyka! I've slightly edited my initial message in this issue as I mixed up \"function\" and \"interface\" a few times. . ",
    "rafaeljesus": "We are using at @hellofresh as well cc/ @italolelis. Hi @pkieltyka I didn't understand well the pre-process tip you gave? I tried here having 2 middleware:\n```go\nr.Use(NewRoutePattern)\nr.Use(NewTraceRequest)\n// route goes here\n```\nNewRoutePattern\n```go\n        rctx := chi.RouteContext(r.Context())\n        routePath := rctx.RoutePath\n        if routePath == \"\" {\n            if r.URL.RawPath != \"\" {\n                routePath = r.URL.RawPath\n            } else {\n                routePath = r.URL.Path\n            }\n        }\n    tctx := chi.NewRouteContext()\n\n    if rctx.Routes.Match(tctx, r.Method, routePath) {\n        rctx.RouteMethod = r.Method\n        rctx.RoutePath = routePath\n        next.ServeHTTP(w, r)\n        return\n    }\n\n```\nNewTraceRequest\ngo\nroutePattern := chi.RouteContext(r.Context()).RoutePattern()\n// routePattern does not work\nAny thoughts? Thanks. ",
    "italolelis": "Janus Gateway is also using it: https://github.com/hellofresh/janus/blob/master/Gopkg.toml#L43\nThis is the gateway that powers the @hellofresh architecture.. ",
    "djui": "Betalo is using it for all its backend services.. I am aware of the proverb. Here however to me it is a bit misused, specifically reading the API offered:\ngo\nNewRouter() *Mux // router.go\nNewMux() *Mux // mux.go\nFirstly, there is no need for the function in the first place, as it is just a proxy. Secondly, it has a confusing name as: an interface with the same name as the file name, but also it does not return what its name suggests: a router.\nMaybe this function is kept for backwards-compatibility as https://github.com/pressly/chi/commit/caaa5eebe3be91a41f2dbdd90402cd6374b2043f indicates? You seem to be conscious about the choice given and it would break the current API, so no need to for further arguing.\nPost scriptum: Ironically I found func New() *Mux { // return Router? in the logs https://github.com/pressly/chi/blame/1123f01030bebd4b81f82c2ea96c9cf4233ad9be/chi.go.... Thanks Peter, that works.\nI the meantime I wrote a Content type parser as we started to use vendor namespace resources and there the detecting JSON as suffix (+json) requires a bit more parsing than the split.\nI also wanted to offer all parts (top-level type, subtype, suffix, and paremters) to the client so they can choose.. Or should chi.FileServer() be added to the chi.Router interfaces, which, given that it this feature was likely added after the interface, would now break currently implementations. . @pkieltyka Understood. And for the second half: What do you say about chi.With(), chi.Group(), chi.Route() returning *chi.Mux? That should be backwards compatible, right?. Seems like the default behaviour of http.FileServer.. @pkieltyka Would you say then that the trailing senentrnce part adds anything or could be removed? \n\n// Group adds a new inline-Router along the current routing\n// path, with a fresh middleware stack for the inline-Router.\nGroup(fn func(r Router)) Router\n\nvs \n\n// Group adds a new inline-Router along the current routing\n// path.\nGroup(fn func(r Router)) Router\n\nOtherwise I wonder: what is \u201cfresh\u201d about it? I guess the symbolic impression of \u201cthis one is not inheriting anything, but usually it does.\u201d \nBtw: is there a style of writing that would actually drop all inherited middlewares?. ",
    "alexmironof": "Example for QOR SDK just moved from Gin to Chi. ",
    "shenshouer": "Autohome Inc. using it for the API server.. I did not find any useful example for use gopkg.in/cas.v1 with the chi-authz  and chi.  The chi-authz is authorization and cas  is Authentication, cas need check the request of http handler.. I made a PR for gopkg.in/cas.v1 to support chi at https://github.com/go-cas/cas/pull/13. ",
    "alehano": "Hi. I'm using chi in my web framework https://github.com/alehano/gobootstrap . Yes, I can set .Get() and .Head() method for the same route. But It's duplicate code.\nMaybe you can add .GetHead() method to set GET and HEAD requests for the same route or something like this?\nBut for me it's better to respond for HEAD requests in .Get() directly.\nWeb crawlers and robots may do HEAD requests, so I want always to respond, instead they can think my page is broken.  \nAccording to HTTP/1.1 RFC:\n\n9.4 HEAD\n   The HEAD method is identical to GET except that the server MUST NOT\n   return a message-body in the response. The metainformation contained\n   in the HTTP headers in response to a HEAD request SHOULD be identical\n   to the information sent in response to a GET request. This method can\n   be used for obtaining metainformation about the entity implied by the\n   request without transferring the entity-body itself. This method is\n   often used for testing hypertext links for validity, accessibility,\n   and recent modification.\n\n. I love that chi lean and small.\nNow I made a helper: \ngo\nfunc GetHead(r chi.Router, pattern string, h http.HandlerFunc) {\n    r.Get(pattern, h)\n    r.Head(pattern, h)\n}\nAnd it works as expected. Go http decide return body or not, based on method.  Bit it's doesn't looks nice, as well as adding .GetHead() to the chi.\nWhy not just make .Get() method like this:\ngo\nfunc (mx *Mux) Get(pattern string, handlerFn http.HandlerFunc) {\n    mx.handle(mGET, pattern, handlerFn)\n    mx.handle(mHEAD, pattern, handlerFn)\n}\nMaybe with checking if Head() not already added.. @pkieltyka Ok, I also want to hear other's thoughts. \nFor me, I don't see useful cases to have separate .Head() method. Because it always must be the same as GET, but without body.\nBtw this how Go http package handle this:\nhttps://github.com/golang/gofrontend/blob/master/libgo/go/net/http/transfer.go#L226\nhttps://github.com/golang/gofrontend/blob/master/libgo/go/net/http/transfer.go#L105\nhttps://github.com/golang/gofrontend/blob/master/libgo/go/net/http/transfer.go#L110\n```go\nfunc noResponseBodyExpected(requestMethod string) bool {\n    return requestMethod == \"HEAD\"\n}\n// ...\nt.ResponseToHEAD = noResponseBodyExpected(t.Method)\n// ...\nif t.ResponseToHEAD {\n    t.Body = nil\n    if chunked(t.TransferEncoding) {\n    t.ContentLength = -1\n    }\n} \n. One more reason of uselessness separate .Head(). For example, you want to add handler to .Head() for adding some Header values. But in this case it'll remove Content-Length header. So it's contradicts to RFC. Or you have to calculate Content-Length of correspondent GET method, which is unlikely  somebody will do it..go\nrouter.MethodNotAllowed(chi.PromoteHeadToGet)\n```\nLooks good. If it possible to implement that way. Standard go http (on which chi built), already get rid of body in case HEAD request. So, we dont need to invent bycicle, just need a way to set the same handler for two methods.. >  w = middleware.NewWrapResponseWriter(ioutil.Discard, 1)\nThis code doesn't work (wrong type).. > The code was just off top of my head, sorry. This should work, tho:\nIt doesn't work by default either.  You still have to have defined .Head() route. But if you have it, Go's standard library do all necessary work for trimming Body.. I agree with @VojtechVitek thoughts. I prefer #248 approach.. I like simplicity and straightforward way of enabling HEAD requests. It's a little bit strange to have config with just one parameter, but you might want to add others in the future.. ",
    "egtann": "We're using chi at Abot for our website and our back-end dashboard/APIs. https://www.abotlabs.com. vgo was just accepted: https://github.com/golang/go/issues/24301#issuecomment-390766926\nIt's worth revisiting this issue.. ",
    "maknahar": "We are using chi at Justickets in a couple of services.. ",
    "guiferpa": "@diegobernardes. ",
    "mcastilho": "We are using it at https://www.smsjunk.com\nI wrote an article about using Chi here: https://medium.com/smsjunk/an-in-depth-look-at-our-docker-and-ecs-stack-for-golang-b89dfe7cff5c\n. \ud83d\udc4d\ud83c\udffb. This is good... . ",
    "kinqsley": "@chenjie4255 Your app is awesome, I have using it to focus on my work!. ",
    "cemremengu": "Using it for a BI tool soon going in prod. \nThe selling points of Chi was it's simplicity; doing what it's supposed to do good by focusing on usability and functionality instead of bragging about performance. ",
    "lansana": "Using it for a cryptocurrency payment service. \nWorks really nicely, especially the scoping of routes with Group and the ability to add custom middleware to a particular group. Allows me to be very expressive with my route definitions.\nCan't achieve this with Gin, for instance. At least not the last time I used it, which is why I made the move to Chi.. Hey @pkieltyka - thanks for the good reference, it may be helpful in the future or to someone else. :)\nI managed to solve this. I was doing something wrong when setting up the router in main.go.\nI had:\ngo\nr := router.New().Route(\"/v1\")\nI should have had:\ngo\nr := router.New()\nv1 := r.Route(\"/v1\")\nI should have then passed the v1 router into my controllers, as opposed to the r router. There needed to be a base to work off of, at least that's how I interpret it without reading through the source code fully.. That sounds like a good idea! \nJust one question, though. Would this be handing over control from chi to the other package, or would the package assume chi has already did what it needed to do and set values in the request context? \nIn my example above, you'll notice that r.URL.Query() is never called in my methods because that logic happens once and only once per request in chi internally, and the values are set in the context in the same way the URL params are. This makes it more performant so that every time you call chi.QueryInt or something, it doesn't have to call r.URL.Query() at all and will just use the request context to get the query map.\nLet me know if this wasn't clear enough...sorry.. @VojtechVitek How would I go about creating the param package? I can create it on my end, would you or anyone else be able to create the param package for go-chi and merge in the changes from my own repository? Haven't done this sort of integration before.\nThanks!. I agree with @VojtechVitek on being explicit. Easier to read and predict :)\n@oceanicdev Feel free to get started on this or complete it all together. I am still planning to do it and will do it if you have not done it by the time I start. I just got distracted recently with some events and need to focus on them for a couple of weeks. I would enjoy doing it, but of course it is a free and open world and you can do it as well! :). ",
    "ernsheong": "Netlify is using it at https://github.com/netlify/gotrue\n(I am not affiliated with Netlify). ",
    "anurag": "Render is using it in production for everything: https://render.com. This issue will probably going to cause a lot of people a lot of pain if they upgrade to v4. Perhaps worth pointing out in the release notes until it's fixed?. @kromanow94 are you using Compress middleware? Your issue may be related to https://github.com/go-chi/chi/issues/382.\n@VojtechVitek and @pkieltyka is it worth creating a 4.0.1 with the fix since it's breaking everyone who's using compress?. It should be fixed if you downgrade to the previous major version (3.3.4) or use master.. ",
    "kevinconway": "\nwith http.HandlerFunc(myHandler), such as r.Get(\"/\", http.HandlerFunc(myHandler)). This would be quite common and isn't ideal.\n\nI believe this is consistent with the standard library. The net/http module provides a Handle method that accepts any http.Handler implementation and then a HandleFunc that accepts any http.HandlerFunc implementation. My personal inclination is to match the standard lib so this mux becomes a drop-in replacement if most cases.\n\nit makes the chi.Router interface huge, by adding another 9 functions\n\nFor cases outside of the usual Handle and HandleFunc cases, I think another possible approach is to move the HTTP method to an input string rather than the function name which would only require two new funcs:\ngo\nr.HandleM(\"GET\", \"/\", myHandler)\nr.HandlerFuncM(\"GET\", \"/\", myHandlerFunc)\nIn any case, if you're pretty settled on Option 3 then you can close this issue. I'll keep passing .ServeHTTP around.\n. ",
    "zythosec": "@pkieltyka @kevinconway new to this discussion, and not sure what you mean by passing around ServeHTTP, but one way I've implemented it that may help (and not sure how it can be incorporated into chi or even that it needs to be) is by wrapping the chi.Mux.ServeHTTP method.\nI define a custom Router type that wraps a chi.Mux and defines a ServeHTTP method that wraps the chi.Mux.ServeHTTP method:\n``` go\ntype Router struct {\n    Mux    *chi.Mux\n}\n// ServeHTTP wraps the ServeHTTP of our mux choice\n// This allows us to pass it into http.ListenAndServe and http.ListenAndServeTLS\nfunc (r Router) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    r.Mux.ServeHTTP(w, r)\n}\n```\nAll my handlers get to keep the same standard signature:\ngo\nfunc myHandler(w http.ResponseWriter, r *http.Request) {\n   // ... \n}\nI create a chi.Mux and add middleware, initialize routes, etc. and then initialize the router with the mux:\ngo\nmux := chi.NewRouter()\nmux.Get(\"/\", myHandler) // option 3 syntax\nr := &Router{Mux: mux}\nSo now I can pass it into http.ListenAndServe:\ngo\nhttp.ListenAndServe(\":3000\", r)\nLet me know if I'm completely out in left field, but this pattern has worked for me and has been extremely nice and clean to work with.\n. Yeah I just realized that was what I was doing, and that I wasn't adding anything to the discussion. Sorry for the noise.  I guess my point was option 3 works nicely for me. \ud83d\ude04 \n. ",
    "DeepAnchor": "I know this is an old issue (and closed), but I have to say that I am in agreement with @kevinconway and the \nr.HandleM(\"GET\", \"/\", myHandler)  \nr.HandlerFuncM(\"GET\", \"/\", myHandlerFunc)\nseems like it would be the most elegant way to solve the problem, while still keeping in line with the project's spirit of minimalism. \nThe use-case is when you have complex request handlers with non-standard signatures that simply implement the http.Handler interface. For example in scenarios like this where you have a request handler that returns an error -a pretty common case. \nAnyway, my 2c for future versions is to forego option 1 from above and make http.Handler a first class citizen of Chi.\n. ",
    "yargevad": "The reason was to be able to emit structured logs a la uber-go/zap - here's my zap implementation.\n. There are a few improvements I should still make here, for example defaultLogFormatter doesn't really need to be a struct, and Recoverer calls debug.PrintStack() which doesn't have a chance to use the customized logger.\nLet me know what other changes you have in mind and I'll work on those too.\n. Hi @jiop, I've been using my forked version until we work through any other changes.\n. You're right, this could be simplified down to one method, like:\nFormatLog(r *http.Request, status, bytes int, elapsed time.Duration, err error)\nWith err == nil meaning \"log normal req/res info\", otherwise ignore status, bytes, elapsed and show the error and stack trace.\n. That's fair, it's also being used like a context, so that's why I named it that way. It shouldn't be needed anymore with the simplified interface, in any case.\n. Question: would you prefer one dual-purpose method, or two methods, one called from Recoverer when there's a panic, and one from Logger during normal operation?\n. ",
    "jiop": "Hi, is there any update about this pull request? I'd love to use it ;)\n. @pkieltyka My main concern is about consistency. NotFound handler is available in the Router interface so I thought that MethodNotAllowed should be there as well.. Hi @pkieltyka, any updates on this PR?. ",
    "ivoszz": "hey @pkieltyka you are right. The body is empty but still marked as text/html and this doesn't solve the problem of JSON api. text/html is hard coded and cannot be changed even when there are  Accept: application/json or application/vnd.api+json in request header. The header Allow is also not generated (and cannot be) which is against the spec:\n\"The origin server MUST generate an Allow header field in a 405 response containing a list of the target resource's currently supported methods.\"\nThe possibility of redefining methodNotAllowedHandler will be sufficient.\n. I would like to thank you for your effort.. ",
    "Scapal": "Being a junior Gopher, I'm interested in your point of view.\nDoes using govendor mean that you put the vendor tree in your Git as well?\nThe purpose of a glide.lockis to avoid that.\n. The dep tool in the draft mention:\n\nLockfile and Manifest are two files. Located in the project root.\n\nSo it seems their perspective is to only save those in the git and not the whole vendor tree.\nIt is the same approach used by Composer for PHP and Glide.\nWouldn't it be awkward for an open-source project to include the full dependencies in vendor?\n. ",
    "clinta": "See PR #106\nIf you want to close this and continue the discussion in the PR that's fine by me.\n. ",
    "twiggg": ":) this was not a comment about chi router, but about the fact that community version of golang (by google) and appengine version of the runtime (by google too ...) are tricky to make work together\n. not sure neither ... wctx router seem to work on appengine but I wanted to stick with chi\n. yes thank you Vojtech I have read that they are aware of the mess this fragmentation causes ... but still have not found my way around (appart from not using libraries that import /context and not /x/net/context ... )  net/http.Request.Context() is using a context.Context so even change all imports of /context to /x/net/context in chi and render does not work\n. ",
    "cescoferraro": "@ustrajunior I did not made myself clear\nwith chi.URLParam(r, \"userID\") I get \ncannot use r (type *http.Request) as type \"github.com/cescoferraro/api/vendor/golang.org/x/net/context\".Context in argument to chi.URLParam\nwith userID := chi.URLParam(r.Context(), \"userID\")I get \ninterface conversion: interface {} is nil, not *chi.Context\nshould I be tracking v2?\nI thinnk thats it\nhttps://github.com/pressly/chi/blob/v2.0.0rc1/context.go#L60\n. ",
    "pxue": "probably because your vendored x/net/context is either behind the 1.7 one or ahead (with brad's new 1.8 cancelfunc changes). if you unvendor it should work.\n. ",
    "leeola": "Having the same described problem here, removing my x/net/context did not solve the issue. My solution was as @cescoferraro mentioned, pinning my vendor to v2.0.0rc1 (just fyi for future readings)\n. ",
    "smacker": "Done. Please take a look. If the problem isn't clear from my description - try tests from PR on master branch. Thanks!\n. thank you sir!. I thought it might fail too. So I moved it on the top and rerun. Tests passed. But maybe my test doesn't cover all possible cases. Any suggestions for improvement?\n. ",
    "umputun": "I think it is really easy to reproduce.\n\nMake dummy rest, with a handler sending back anything with custom response code i.e. smth like render.Status(r, http.StatusBadRequest); render.JSON(....)\nMake sure router.Use(middleware.CloseNotify) in place \nHit it a few times and you will see the error (warning) . if you remove middleware.Logger and keep everything else as is you will see these \"multiple response.WriteHeader calls\". If you add some sleep before - you will get even more of these.\n\n```\nfunc main() {\n    r := chi.NewRouter()\n    r.Use(middleware.CloseNotify)\nr.Get(\"/\", func(w http.ResponseWriter, r *http.Request) {\n    time.Sleep(100*time.Millisecond)\n    v := map[string]interface{}{\"x\": 1}\n\n    render.Status(r, http.StatusBadRequest)\n    render.JSON(w, r, v)\n})\nhttp.ListenAndServe(\":3333\", r)\n\n}\n```\nwith ab -n 100 -c 10 127.0.0.1:3333  i got bunch of of these. @pkieltyka go version go1.7.4 darwin/amd64 (mac os 10.12.1) and the same version of go in alpine 3.4 (docker container). Both have the same errors. ",
    "NikosEfthias": "@pkieltyka have you added documentation on how to change that ?  because i have no idea what you mean by middleware.DefaultLogger should i edit the source code? middleware is unexported keyword. just one thing that i don't understand is that i checked the source code theres nothing about stderr how come the messages from logger middleware ends up in the stderr stream. the logger in defaultLogger struct is unexported so its impossible to set it should be exported value i guess . i just capitalized the first letter of logger key in the struct and it works otherwise it gives error because naturally it cannot find such a property of the struct DefaultLogFormatter because logger is not an exported keyword.\nHowever after the last update i dont need this anymore the problem that was the reason that i made this bug report about was solved by this update . . next time for such small things ill open a pr sorry :) . Ah now it makes sense :) Great ill try now @pkieltyka . @pkieltyka I just tried the docs are really not that helpful I must say. It could be cool if there are comments on the functions those are used for routing, to show those comments as godoc does. ",
    "robvdl": "I am on the last stable tag using Glide so v1.0.0 I will try bumping that to v2.0.0rc1 thanks, that's probably it.. ",
    "lclarkmichalek": "https://github.com/felixge/httpsnoop/blob/master/wrap.go#L52 although maybe one could just implement all the different combinations... Yeah, I'm really not a fan of that solution, but after spending half an hour writing a thing to generate the 2^5 individual implementations, I've been convinced that its probably the simpler option.. I can get you a pull request this weekend :) Need to submit something\nsimilar to a load of other projects, so not a problem\nOn Sat, Dec 31, 2016 at 5:26 PM, Peter Kieltyka notifications@github.com\nwrote:\n\n@lclarkmichalek https://github.com/lclarkmichalek yes probably. I'll\ngive it a closer look but I don't know when I'll have a chance to dive in.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/pressly/chi/issues/123#issuecomment-269874539, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AAEyNbXKuN67fI-tjwlBV4E39B12nUTiks5rNpBcgaJpZM4LYkpU\n.\n. Yeah, that's accurate. There aren't any other http2 interfaces, to the best of my knowledge, so we should be ok (until someone adds another!)\n\nI've added support to the Compress middleware, though there's a lot of duplication. I built out a new genericWrapper, with a httpGenericWrapper and http2GenericWrapper, which should allow us to wrap any kind of ResponseWriter. It checks to see if a method (i.e. Flush, CloseNotify) has been implemented by the wrapper, and if not, uses the implementation from the wrapped writer (we require the wrapper to have an Unwrap() method for this. The mkGenericWrapper function uses Unwrap() to get the original ResponseWriter, and then selects the httpGenericWrapper or http2GenericWrapper structs to ensure that the returned ResponseWriter implements the same interfaces as the original ResponseWriter.\nHowever, this new interface isn't compatible with the existing WrapResponseWriter, so there's a lot of duplicated code, as Compress couldn't be implemented in terms of the existing fancyWriters. The functionality of WrapResponseWriter could be, however the function NewWrapResponseWriter would need to change. How important is keeping the existing NewWrapResponseWriter API? I only found one usage on github.\nI've also added a couple of tests to ensure that all the expected interfaces are on the ResponseWriters after being passed through a middleware using mkGenericWriter. \nI'm super sorry this has grown to be a larger PR. This really isn't a high point for Go's type system... The problem is, we haven't seen the body at the point where WriteHeader is called. We could read in the entire body, compress, set the header correctly, send the header, and then send the compressed body, but this would require us to store the whole body in memory, which I don't think is acceptable.\nContent-Length is an optional header, and it isn't simple to add it to this middleware without making some major tradeoffs. If a user insists on having a Content-Length on their compressed response, then they should probably adapt the middleware for their uses.. My handler is using http.ServeFile to serve a binary from disk, which is setting the Content-Length header.. Thanks \ud83d\udc4d . This is much nicer. I don't think HTTP2 requests have ReaderFrom. This handler should be wrapped in a middleware to have this test check that the response writer still has the interfaces expected after wrapping.. Now I think about it, these messages should probably all read ResponseWriter should have been .... ",
    "EmielM": "Right, thanks for the quick reply. To prevent a lot of indentation I could repeat adding the middlewares:\n```go\nr.Group(function(r chi.Router) {\n    r.Use(Level0Ctx);\n    r.Post(\"/level0\", Level0POST);\n});\nr.Group(function(r chi.Router) {\n    r.Use(Level0Ctx);\n    r.Use(Level1Ctx);\n    r.Post(\"/level1\", Level1POST);\n});\nr.Group(function(r chi.Router) {\n    r.Use(Level0Ctx);\n    r.Use(Level1Ctx);\n    r.Use(Level2Ctx);\n    r.Post(\"/level2\", Level2POST);\n});\n```\netc.. I have experienced that it is very often that you incrementally add middlewares, and being explicit is fine, but adding a bunch of needless sugar in the form of .Group wrapping [s]feels stupid[/s] results in less readable code imho.\nSince this ticket was opened, I have switched for my projects to a custom (internal) router that allows this approach, but uses a different method name to make it more clear:\n```golang\nr.Get(\"/login\", Login)\nr.Push(WithUser)\nr.Get(\"/x\", HandleX)\nr.Push(WithPlayer)\nr.Get(\"/player/:playerID/details\", x)\nr.Get(\"/player/:playerID/info\", x)\nr.Pop()\nr.Push(WithAdmin)\nr.Get(\"/stats\", HandleStats)\n```\nCheers. ",
    "jutkko": "Just out of interest, why is the decision made to not allow interleaving definitions of middlewares and routes? It's a nice to have thing in my opinion.. Ok that makes sense. Thanks for the quick response.. Yes that will do the job. But there are some operations (tracing) we want to do before calling next and also want to have the RoutePattern()... \nThanks for the quick response though!. ",
    "mpholcomb": "I should have mentioned, that instead of using the actual variables, I am just using the full req.URL to generate the url roles, which is certainly OK.  I may be creating a synthetic use case here.. Yeah I agree about the double pass through the tree would just slow down the router.  Thanks for the thoughts behind the acl.route.  For now, I am checking the role based on the url, which is really similar to your acl.  I will go ahead and close this.  Thanks again!. ",
    "durdn": "@pkieltyka Amazing responsiveness! Thanks a lot!. ",
    "wyaeld": "No problem, the rapid response is encouraging for considering using your library :-). ",
    "uzarubin": "Disregard this. It ended up being an error in my code. : ). ",
    "kpurdon": "\nI'm always trying to keep the chi project as minimal as possible\n\n\ud83d\udc4d \nThanks for the response. If you have an idea for how you'd like this testing package to look (and a potential name (chi/chitest?)) I'd be happy to drop a first pass PR. Let me know.. Closing since this would be implemented elsewhere and changes with V3 anyway. . @pkieltyka thanks for the response, I'll take a look. We (Bitly) are currently doing some prototyping to determine if we want to switch to chi. This specific feature is used in middleware that publishes API request metrics.\nThanks again. I'll report back if this approach doesn't work out for us.. ",
    "jlovison": "I do think it'd be a big help to people adopting this package to have a \"testing\" section in the readme about how to properly setup chi in tests. @kpurdon's setup in his first code block is not intuitive without seriously looking under the hood at the chi package. Other aspects of integration are pretty easy to pick up from a glance at the readme, but integration in tests is currently a bit of a head scratcher.. ",
    "brycereitano": "With v3 this method of testing won't work since URLParams is an unexported type and has removed Add method. Looking forward to some testing example.. ",
    "kevingo": "@pkieltyka Thanks for reviewed and merged.. @VojtechVitek Thanks for response. I am misunderstanding the returning type and handler type. Thanks again. I will close the issue.. @pkieltyka Please reviewed. Thanks.. @valmirjunior0088 Is that you want ? \n```go\npackage main\nimport (\n    \"net/http\"\n\"github.com/pressly/chi\"\n\"github.com/pressly/chi/middleware\"\n\n)\nfunc main() {\n    r := chi.NewRouter()\n    r.Use(middleware.RequestID)\n    r.Use(middleware.Logger)\nr.Route(\"/\", func(r chi.Router) {\n    r.Get(\"/ping\", func(w http.ResponseWriter, r *http.Request) {\n        w.Write([]byte(\"Hello World\"))\n    })\n})\n\nhttp.ListenAndServe(\":3333\", r)\n\n}\n```. ",
    "diegobernardes": "Forgot the data race message:\n```\nWARNING: DATA RACE\nRead at 0x00c4201a01e8 by goroutine 25:\n  net/http.(response).finishRequest()\n      /home/diego/programs/go/1.8rc2/src/net/http/server.go:1534 +0x57\n  net/http.(conn).serve()\n      /home/diego/programs/go/1.8rc2/src/net/http/server.go:1830 +0x76b\nPrevious write at 0x00c4201a01e8 by goroutine 32:\n  net/http.(*response).WriteHeader()\n      /home/diego/programs/go/1.8rc2/src/net/http/server.go:1056 +0xb9\n  stash.b2w/alpha/omega/vendor/github.com/pressly/chi/middleware.CloseNotify.func1.1()\n      /home/diego/projects/go/1.8rc2/src/stash.b2w/alpha/omega/vendor/github.com/pressly/chi/middleware/closenotify.go:25 +0x6f\nGoroutine 25 (running) created at:\n  net/http.(Server).Serve()\n      /home/diego/programs/go/1.8rc2/src/net/http/server.go:2668 +0x35f\n  net/http.(Server).ListenAndServe()\n      /home/diego/programs/go/1.8rc2/src/net/http/server.go:2585 +0xe0\n  net/http.ListenAndServe()\n      /home/diego/programs/go/1.8rc2/src/net/http/server.go:2787 +0xee\n  stash.b2w/alpha/omega.server()\n      /home/diego/projects/go/1.8rc2/src/stash.b2w/alpha/omega/server.go:96 +0x4bb\n  stash.b2w/alpha/omega.Server()\n      /home/diego/projects/go/1.8rc2/src/stash.b2w/alpha/omega/omega.go:11 +0xca\n  main.main.func1()\n      /home/diego/projects/go/1.8rc2/src/stash.b2w/alpha/omega/cli/omega.go:27 +0xc9\n  stash.b2w/alpha/omega/vendor/github.com/spf13/cobra.(Command).execute()\n      /home/diego/projects/go/1.8rc2/src/stash.b2w/alpha/omega/vendor/github.com/spf13/cobra/command.go:636 +0x85d\n  stash.b2w/alpha/omega/vendor/github.com/spf13/cobra.(Command).ExecuteC()\n      /home/diego/projects/go/1.8rc2/src/stash.b2w/alpha/omega/vendor/github.com/spf13/cobra/command.go:722 +0x46b\n  stash.b2w/alpha/omega/vendor/github.com/spf13/cobra.(*Command).Execute()\n      /home/diego/projects/go/1.8rc2/src/stash.b2w/alpha/omega/vendor/github.com/spf13/cobra/command.go:681 +0x38\n  main.main()\n      /home/diego/projects/go/1.8rc2/src/stash.b2w/alpha/omega/cli/omega.go:44 +0x794\nGoroutine 32 (finished) created at:\n  stash.b2w/alpha/omega/vendor/github.com/pressly/chi/middleware.CloseNotify.func1()\n      /home/diego/projects/go/1.8rc2/src/stash.b2w/alpha/omega/vendor/github.com/pressly/chi/middleware/closenotify.go:28 +0xc5\n  net/http.HandlerFunc.ServeHTTP()\n      /home/diego/programs/go/1.8rc2/src/net/http/server.go:1942 +0x51\n  stash.b2w/alpha/omega/vendor/github.com/pressly/chi.(Mux).ServeHTTP()\n      /home/diego/projects/go/1.8rc2/src/stash.b2w/alpha/omega/vendor/github.com/pressly/chi/mux.go:79 +0x37f\n  net/http.serverHandler.ServeHTTP()\n      /home/diego/programs/go/1.8rc2/src/net/http/server.go:2568 +0xbc\n  net/http.(conn).serve()\n      /home/diego/programs/go/1.8rc2/src/net/http/server.go:1825 +0x716\n==================\n==================\nWARNING: DATA RACE\nRead at 0x00c4201a0230 by goroutine 25:\n  net/http.(chunkWriter).writeHeader()\n      /home/diego/programs/go/1.8rc2/src/net/http/server.go:1200 +0x21c7\n  net/http.(chunkWriter).close()\n      /home/diego/programs/go/1.8rc2/src/net/http/server.go:379 +0x17a\n  net/http.(response).finishRequest()\n      /home/diego/programs/go/1.8rc2/src/net/http/server.go:1540 +0xc1\n  net/http.(conn).serve()\n      /home/diego/programs/go/1.8rc2/src/net/http/server.go:1830 +0x76b\nPrevious write at 0x00c4201a0230 by goroutine 32:\n  net/http.(*response).WriteHeader()\n      /home/diego/programs/go/1.8rc2/src/net/http/server.go:1057 +0xd2\n  stash.b2w/alpha/omega/vendor/github.com/pressly/chi/middleware.CloseNotify.func1.1()\n      /home/diego/projects/go/1.8rc2/src/stash.b2w/alpha/omega/vendor/github.com/pressly/chi/middleware/closenotify.go:25 +0x6f\nGoroutine 25 (running) created at:\n  net/http.(Server).Serve()\n      /home/diego/programs/go/1.8rc2/src/net/http/server.go:2668 +0x35f\n  net/http.(Server).ListenAndServe()\n      /home/diego/programs/go/1.8rc2/src/net/http/server.go:2585 +0xe0\n  net/http.ListenAndServe()\n      /home/diego/programs/go/1.8rc2/src/net/http/server.go:2787 +0xee\n  stash.b2w/alpha/omega.server()\n      /home/diego/projects/go/1.8rc2/src/stash.b2w/alpha/omega/server.go:96 +0x4bb\n  stash.b2w/alpha/omega.Server()\n      /home/diego/projects/go/1.8rc2/src/stash.b2w/alpha/omega/omega.go:11 +0xca\n  main.main.func1()\n      /home/diego/projects/go/1.8rc2/src/stash.b2w/alpha/omega/cli/omega.go:27 +0xc9\n  stash.b2w/alpha/omega/vendor/github.com/spf13/cobra.(Command).execute()\n      /home/diego/projects/go/1.8rc2/src/stash.b2w/alpha/omega/vendor/github.com/spf13/cobra/command.go:636 +0x85d\n  stash.b2w/alpha/omega/vendor/github.com/spf13/cobra.(Command).ExecuteC()\n      /home/diego/projects/go/1.8rc2/src/stash.b2w/alpha/omega/vendor/github.com/spf13/cobra/command.go:722 +0x46b\n  stash.b2w/alpha/omega/vendor/github.com/spf13/cobra.(*Command).Execute()\n      /home/diego/projects/go/1.8rc2/src/stash.b2w/alpha/omega/vendor/github.com/spf13/cobra/command.go:681 +0x38\n  main.main()\n      /home/diego/projects/go/1.8rc2/src/stash.b2w/alpha/omega/cli/omega.go:44 +0x794\nGoroutine 32 (finished) created at:\n  stash.b2w/alpha/omega/vendor/github.com/pressly/chi/middleware.CloseNotify.func1()\n      /home/diego/projects/go/1.8rc2/src/stash.b2w/alpha/omega/vendor/github.com/pressly/chi/middleware/closenotify.go:28 +0xc5\n  net/http.HandlerFunc.ServeHTTP()\n      /home/diego/programs/go/1.8rc2/src/net/http/server.go:1942 +0x51\n  stash.b2w/alpha/omega/vendor/github.com/pressly/chi.(Mux).ServeHTTP()\n      /home/diego/projects/go/1.8rc2/src/stash.b2w/alpha/omega/vendor/github.com/pressly/chi/mux.go:79 +0x37f\n  net/http.serverHandler.ServeHTTP()\n      /home/diego/programs/go/1.8rc2/src/net/http/server.go:2568 +0xbc\n  net/http.(conn).serve()\n      /home/diego/programs/go/1.8rc2/src/net/http/server.go:1825 +0x716\n==================\n```. Yes, your examples does not give any error, but try to comment the logger and the sleep:\n```go\npackage main\nimport (\n    \"net/http\"\n\"github.com/pressly/chi\"\n\"github.com/pressly/chi/middleware\"\n\n)\nfunc main() {\n    r := chi.NewRouter()\n    r.Use(middleware.RequestID)\n    // r.Use(middleware.Logger)\n    r.Use(middleware.CloseNotify)\n    r.Get(\"/\", func(w http.ResponseWriter, r *http.Request) {\n    // time.Sleep(1 * time.Second)\n        w.Write([]byte(\"hello world\"))\n    })\n    http.ListenAndServe(\":3333\", r)\n}\n```\nUsing wrk:\nwrk -c 100 -d 10s http://localhost:3333\nGive this results:\ngo run main.go\n2017/01/23 09:36:21 http: multiple response.WriteHeader calls\n2017/01/23 09:36:21 http: multiple response.WriteHeader calls\n2017/01/23 09:36:21 http: multiple response.WriteHeader calls\n2017/01/23 09:36:21 http: multiple response.WriteHeader calls\n2017/01/23 09:36:21 http: multiple response.WriteHeader calls\n2017/01/23 09:36:21 http: multiple response.WriteHeader calls\n2017/01/23 09:36:21 http: multiple response.WriteHeader calls\n2017/01/23 09:36:21 http: multiple response.WriteHeader calls\n2017/01/23 09:36:21 http: multiple response.WriteHeader calls\n2017/01/23 09:36:21 http: multiple response.WriteHeader calls\n2017/01/23 09:36:21 http: multiple response.WriteHeader calls\n2017/01/23 09:36:21 http: multiple response.WriteHeader calls\n2017/01/23 09:36:21 http: multiple response.WriteHeader calls\nAbout the race condition, don't know why, but i can not reproduce...\nMaybe was the middlewares or the order of then that caused that error.. Didn't know that in 1.8 the CloseNotify cancel the context, good to know.\nThanks!. wow that was fast! thanks @pkieltyka!. Got this problem too. The panic is being generated by this:\nhttps://github.com/go-chi/chi/blob/c82a10ad80a5eab1d6b77ff5e96bdb774757d5a6/context.go#L74\nIt should check the slice size before read or the slice should always be initialized with default values.. ",
    "kvnxiao": "@zet4 Thanks! using Mount() worked with the echo example.\nRegarding your suggestion to use normal WS connection, is there a big reason people prefer a normal WS connection over polyfills like socket.io and sockjs?\nAnd how does melody compare with gorilla websockets?. ",
    "medyagh": "for the record, I ended up using memached.. @pkieltyka I just glide updated with the SHA of the last commit\nhere is my glide block\n- package: github.com/pressly/chi\n  version: c85a5463d6472673cd8ed5d447b6d5e46413f140\n  vcs: git\n  subpackages:\n  - middleware\n  - render\nand here is my glide.lock block\n```\n- name: github.com/pressly/chi\n  version: c85a5463d6472673cd8ed5d447b6d5e46413f140\n  vcs: git\n  subpackages:\n  - middleware\n  - render\n```\nand I got the same error:\n```\npanic: runtime error: invalid memory address or nil pointer dereference\n2017/02/14 03:29:28 goroutine 90 [running]:\nruntime/debug.Stack(0xc4204de2d0, 0x1c59460, 0xc42050cd60)\n    /usr/local/go/src/runtime/debug/stack.go:24 +0x79\nsmasher/vendor/github.com/pressly/chi/middleware.Recoverer.func1.1(0xc4204de2d0, 0x7fc29d63b8c8, 0xc4204a4280)\n    /go/src/smasher/vendor/github.com/pressly/chi/middleware/recoverer.go:23 +0x82\npanic(0x1338f20, 0xc42000a040)\n    /usr/local/go/src/runtime/panic.go:458 +0x243\nmain.start_http_server.func4(0x7fc29d63b8c8, 0xc4204a4280, 0xc4204de4b0)\n    /go/src/smasher/main.go:150 +0x283\n```. I will try without glide and go get, but for what it worth, I like to add, I also removed the throttle thing to make sure it wasn't because of that. and also another thing, the thing fails only on the request that takes longer than 30 seconds. (it won't error on other requests)\n. sure here is a gist of the code https://gist.github.com/medyagh/fd03a85e8eb2443a8dbbb42ed4bb05c6. @pkieltyka update, I found out the source of the problem, in kuberentes the default timeout is 2 mins, and there is no way to change it in google kuberentes. so any request taking more than 1.30 min will throw that error. it will be fine in other places.\nhowever, I think it would be nice that the library would throw a better error. (to test it out , deploy it to google kuberentens and make a request that takes more than 2 minutes to come back). ",
    "eemeyer": "See pull request https://github.com/pressly/chi/pull/149 for fix.. Do you have a timeline for incorporating this patch? I've got a project that currently depends on my fork of chi, and I'd rather reference this repository's official version.. Perfect. Thanks for the update. Enjoy your vacation!. Thanks! Your solution makes good sense. I didn't see a good way to know whether the url path component needed unescaping in findPath, and agree that always unescaping the path was not the correct solution.. ",
    "andersjohnsen": "The fix did not solve the issue presented here. Note that example provided expected the url-decoded result, not the raw value. That means this is a breaking change as all calls to URLParam now returns the raw path. I suggest this is changed such that all users of URLParam don't have to use url.Decode.. ",
    "sgp": "Thanks for weighing in. I'll check out the v1 branch. TBH, by the time I get around to using chi in appengine, it's Go 1.8 will be released and (hopefully) in the default App Engine runtime.. ",
    "nkovacs": "1.7, http1 (but should apply to http2 too).\nI think if I switch the order of the middlewares, it'll work, because CloseNotifier will get the original ResponseWriter (I applied Compress first, then CloseNotifier).. Ok, so doing this causes a panic:\nr.use(middleware.DefaultCompress)\nr.use(middleware.CloseNotify)\nBut this doesn't:\nr.use(middleware.CloseNotify)\nr.use(middleware.DefaultCompress)\nOn a related not, it would be nice to have a dummy middleware.CloseNotify for go 1.8, so that this code also compiles on go 1.8.. Yes, that fixes it, thanks.. If you don't care about backwards compatibility, you could remove middleware.CloseNotify completely, and automatically patch the request's context on go 1.7 somewhere (e.g. here?).\nBut if you want to keep backwards compatibility, you can't remove middleware.CloseNotify.\nHaving it compile on go 1.7 and fail to compile on go 1.8 is even worse than breaking backwards compatibility, because not even vendoring helps there.. ```\npackage main\nimport (\n    \"net/http\"\n\"github.com/pressly/chi\"\n\"github.com/pressly/chi/middleware\"\n\n)\nfunc main() {\n    router := chi.NewRouter()\n    router.Use(middleware.RedirectSlashes)\n    router.Mount(\"/debug\", middleware.Profiler())\n    http.ListenAndServe(\":8080\", router)\n}\n```\nRun this and try to open http://localhost:8080/debug/pprof/. Ah, I see, the links on the index page are relative, they need the slash.\nIt wasn't obvious to me that I can use router.Group like this, but it works. Thanks!\n```\npackage main\nimport (\n    \"fmt\"\n    \"net/http\"\n\"github.com/pressly/chi\"\n\"github.com/pressly/chi/middleware\"\n\n)\nfunc main() {\n    router := chi.NewRouter()\n    router.Mount(\"/debug\", middleware.Profiler())\nrouter.Group(func(router chi.Router) {\n    router.Use(middleware.RedirectSlashes)\n    router.Get(\"/\", func(w http.ResponseWriter, r *http.Request) {\n        fmt.Fprintln(w, \"Hello world\")\n    })\n    router.Get(\"/foo\", func(w http.ResponseWriter, r *http.Request) {\n        fmt.Fprintln(w, \"Foo\")\n    })\n})\n\nhttp.ListenAndServe(\":8080\", router)\n\n}\n```. Wait, no, that doesn't work, the RedirectSlashes middleware isn't executed for /foo/.\nRoute/Mount does work, and it actually applies to /root too (i.e. /root is redirected to /root/)?\n```\npackage main\nimport (\n    \"net/http\"\n\"github.com/pressly/chi\"\n\"github.com/pressly/chi/middleware\"\n\"github.com/pressly/chi/render\"\n\n)\nfunc main() {\n    router := chi.NewRouter()\n    router.Use(middleware.DefaultCompress)\n    router.Mount(\"/debug\", middleware.Profiler())\n    router.Get(\"/root\", func(w http.ResponseWriter, r *http.Request) {\n        render.PlainText(w, r, \"Root\")\n    })\nrouter.Route(\"/\", func(router chi.Router) {\n    router.Use(middleware.RedirectSlashes)\n    router.Get(\"/\", func(w http.ResponseWriter, r *http.Request) {\n        render.PlainText(w, r, \"Hello world\")\n    })\n    router.Get(\"/foo\", func(w http.ResponseWriter, r *http.Request) {\n        render.PlainText(w, r, \"Foo\")\n    })\n})\n\nhttp.ListenAndServe(\":8080\", router)\n\n}\n```\nI'm not sure if this is what I'm supposed to do.. The problem is that these are dynamic, you can add a new one using pprof.NewProfile.. ",
    "ladydascalie": "I have this issue as well on the latest releases. @VojtechVitek the following contrived example shows the exact panic received:\nmain.go: \n```go\npackage main\nimport (\n    \"net/http\"\n\"github.com/go-chi/chi\"\n\"github.com/go-chi/chi/middleware\"\n\"github.com/go-chi/docgen\"\n\n)\nfunc main() {\n    r := chi.NewRouter()\n    r.Mount(\"/debug\", middleware.Profiler())\n    r.Get(\"/bla\", blaHandler)\ndocgen.JSONRoutesDoc(r)\n\nhttp.ListenAndServe(\":8080\", r)\n\n}\nfunc blaHandler(w http.ResponseWriter, r *http.Request) {\n    w.WriteHeader(204)\n}\n`trace`:\npanic: reflect: call of reflect.Value.Pointer on string Value\ngoroutine 1 [running]:\nreflect.Value.Pointer(0x138b5c0, 0xc420010cc0, 0x98, 0xc420010cc0)\n    /usr/local/go/src/reflect/value.go:1276 +0x185\ngithub.com/go-chi/docgen.getCallerFrame(0x138b5c0, 0xc420010cc0, 0x16117a0)\n    /Users/benjamincable/go/src/github.com/go-chi/docgen/funcinfo.go:70 +0x6f\ngithub.com/go-chi/docgen.buildFuncInfo(0x138b5c0, 0xc420010cc0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, ...)\n    /Users/benjamincable/go/src/github.com/go-chi/docgen/builder.go:85 +0x91\ngithub.com/go-chi/docgen.buildDocRouter(0x15e3d20, 0xc4201380e0, 0xc420081b30, 0x0, 0xc420081b30, 0xf)\n    /Users/benjamincable/go/src/github.com/go-chi/docgen/builder.go:71 +0x7f3\ngithub.com/go-chi/docgen.buildDocRouter(0x15e3d20, 0xc420138070, 0xc42001a1a7, 0x17, 0x4, 0x15e0a20)\n    /Users/benjamincable/go/src/github.com/go-chi/docgen/builder.go:45 +0x427\ngithub.com/go-chi/docgen.BuildDoc(0x15e3d20, 0xc420138070, 0x3ff, 0x15e3d20, 0xc4201380e0, 0xc4201380e0, 0xc42012bf28, 0x12ab7ce)\n    /Users/benjamincable/go/src/github.com/go-chi/docgen/builder.go:23 +0xf4\ngithub.com/go-chi/docgen.JSONRoutesDoc(0x15e3d20, 0xc420138070, 0x4, 0x141e7e0)\n    /Users/benjamincable/go/src/github.com/go-chi/docgen/docgen.go:58 +0x42\nmain.main()\n    /Users\n```. Sorry, I missed the notification for this before.\nRunning it on the latest version works properly for me!. ",
    "chuyeow": "\nThe semantics here is that the client never disconnects before the request is processed, and this is as close to the default behavior as we can get (i.e. when CloseNotify() is not even called to check whether the client has disconnected).\n\nHmm this explanation is not very clear. Let me try this again:\nReturning a channel that never returns is closest to the \"default\" behavior. http.Handlers that do not use the http.CloseNotifier interface are effectively saying that they do not care when the client disconnects early, so a channel that never returns models that behavior.. ",
    "jsadwith": "@pkieltyka locally, I just updated the mx.Get() call in r.FileServer() to check to see if the file exists before serving. It may not be the most efficient solution, but it's working as it should...\nmx.Get(path, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n    if _, err := os.Stat(fmt.Sprintf(\"%s\", root) + r.RequestURI); os.IsNotExist(err) {\n        mx.NotFoundHandler().ServeHTTP(w, r)\n    } else {\n        fs.ServeHTTP(w, r)\n    }\n}))\nAny interest in a pull request for it? (I would include tests). Cool. Here's my solution for a FileServer function that incorporates the pressly/chi NotFoundHandler for anyone that's interested...\nworkDir, _ := os.Getwd()\nfilesDir := filepath.Join(workDir, \"public\")\nroot := http.Dir(filesDir)\nfs := http.StripPrefix(\"/\", http.FileServer(root))\nr.Get(\"/*\", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n    if _, err := os.Stat(fmt.Sprintf(\"%s\", root) + r.RequestURI); os.IsNotExist(err) {\n        r.NotFoundHandler().ServeHTTP(w, r)\n    } else {\n        fs.ServeHTTP(w, r)\n    }\n}))\nThanks @pkieltyka . ",
    "mitani": "Just as a comment you would probably want to parse r.RequestURI as it will include the query string as well which you probably don't want when stating the file system. ",
    "Labutin": "No,\nI am looking like this:\n```golang\nfunc handlerPing(w http.ResponseWriter, _ *http.Request) {\n    w.Write([]byte(\"pong\"))\n}\n...\nr.Get(\"/v1/ping\", handlerPing)\n...\n// I am looking this method\nurl := r.UrlFor(handlerPing) // have to return \"/v1/ping\"\nfunc (mx *Mux) UrlFor(handlerFn http.HandlerFunc) string {\n    ......\n}\n```. ",
    "MrXu": "Thanks @VojtechVitek @zet4 . I think it should be the problem with nginx config, instead of golang code. . ",
    "gfyrag": "Hello,\nthis commit will be merged?. @pkieltyka Yeah, it will do the job, thks :). ",
    "dobegor": "i.e. your parameter contains slashes, i.e. it's a storage key:\n/storage/folderID/userID/somekey\nand you don't want to hard-code key format, a wildcard is a nice choice, but there's no way to get the matched parameter other than getting full request path, stripping everything and etc.\nThat would also require handler to know the prefix to strip off, and it somewhat breaks the abstraction of an app.\nNamed wildcard params, if possible, would solve this.\nThe proposed syntax (/*param) is the same in Rails, for example.. If syntax is {param}, then how would these patterns be handled?\nPattern 1: /{param} // can match both /someparam and /someparam/something/something\nPattern 2: /{param}/{param2} // ??\nIMO, wildcards would be simpler to implement and to understand, and many people are used to it in Rails.\n. Turns out it's already implemented here.\nPerhaps it's worth to add it to documentation :). Small program to reproduce:\n```golang\npackage main\nimport (\n    \"fmt\"\n    \"github.com/go-chi/chi\"\n    \"net/http\"\n)\nfunc main() {\n    r := chi.NewRouter()\nr.Get(\"/users/{userId}\", func(w http.ResponseWriter, r *http.Request) {\n    fmt.Println(\"end1\")\n})\n\nr.Put(\"/users/me\", func(w http.ResponseWriter, r *http.Request) {\n    fmt.Println(\"end2\")\n})\n\nhttp.ListenAndServe(\":9999\", r)\n\n}\n```. ",
    "daenney": "Sorry for my lack of response on this! I've gotten the middleware part to work, that was fairly easy. I'm mostly stuck with the Renderer, I'm not quite clear how you mean to compose that like the way you could compose middleware? Do you have a (pseudocode) example of what that could look like?. ",
    "peter-mogensen": "I haven't seen it explicitly mentioned, but...\nWhat about support for custom HTTP methods?\n. ",
    "tiriplicamihai": "Hi @pkieltyka, I would like to help with implementing something from the roadmap. Do you have any suggestions for the first contribution?. Sure thing. For reviews you can cc me and I will look as soon as I can.\nIt's ok for me to write tests (actually I think it's the best way to get an\noverview), again, just ping me or assign me an issue and I'll take care of\nit.\nOn Mon, May 22, 2017 at 2:14 AM, Peter Kieltyka notifications@github.com\nwrote:\n\nhey @tiriplicamihai https://github.com/tiriplicamihai thanks for the\noffer to help! I have been working on a PR as the base for the v3 release\nwhich resolves #167 https://github.com/pressly/chi/issues/167 and soon\nafter I'll work out the mechanics for #78\nhttps://github.com/pressly/chi/issues/78 and #100\nhttps://github.com/pressly/chi/issues/100. These are pretty deep into\nthe mechanics of the trie inserting / finding algorithm so its probably\nbest I just finish that off, but certainly it would help to get reviews,\nwrite more tests - and as well, would be cool if you could write the regexp\nsupport for that branch once its ready. I will try to finish it tomorrow\nand ping you to look at regexp param support if you're interested.\nOther work that I'd like to incorporate in the v3 release is improving\nchi/render further by having a full test-suite and considering the work\nrequired for #185 https://github.com/pressly/chi/issues/185\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/pressly/chi/issues/179#issuecomment-302969944, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/ABFpzJlWlqIrr7xpjkTl2eehvsIAwlIAks5r8MVKgaJpZM4M7ddo\n.\n\n\n-- \nMihai Tiriplic\u0103\n. Coming back to this question (sorry for dual identity, the first one is the work account), I think there can be some improvements for the timeouts. For example, if the timeout is set to 30 seconds and I have an external call that takes 29 seconds and my processing takes 2 seconds then, if I understand correctly, no timeout will be raised even though the request took 31 seconds.\nI read this article: https://blog.cloudflare.com/the-complete-guide-to-golang-net-http-timeouts/ and rewrote the hello world server as:\n```go\npackage main\nimport (\n    \"fmt\"\n    \"net/http\"\n    \"time\"\n\"github.com/pressly/chi\"\n\"github.com/pressly/chi/middleware\"\n\n)\nfunc main() {\n    r := chi.NewRouter()\n    r.Use(middleware.RequestID)\n    r.Use(middleware.Logger)\n    r.Get(\"/\", func(w http.ResponseWriter, r *http.Request) {\n        time.Sleep(10 * time.Second)\n        w.Write([]byte(\"hello world\"))\n    })\nserver := &http.Server{Addr: \":3333\", Handler: r, ReadTimeout: 2 * time.Second, WriteTimeout: 2 * time.Second}\nfmt.Println(server.ListenAndServe())\n\n}\n```\nNow the connection seems to close but the request processing does not stop. I was looking now into using TimeoutHandler too but I'm not sure how it can be used along with chi since I can't really pass a Handler to the \"Get\" method and the \"mux.handle\" method is private. Also, is it a good idea to use it considering it runs the handler in a go routine? I can rewrite it as a middleware if this is the case.\n[LE] Managed to use it by changing the serve line to:\ngo\nserver := &http.Server{Addr: \":3333\", Handler: http.TimeoutHandler(r, 2*time.Second, \"\"), ReadTimeout: 5 * time.Second, WriteTimeout: 5 * time.Second}\nAs expected, the actual handler is not stopped but now an 503 is returned (I would have expected 504 but it's Go's default implementation).\nI can write an example with this if you think it helps.\nThanks again!. ",
    "MrSpock": "Yeah.\nSomehow goimports is imporing other package:\n[I] [0] spock@macspock ~/.g/src \u279e find . -name 'render'\n./github.com/cweill/gotests/internal/render\n./github.com/pressly/chi/render\n[I] [0] spock@macspock ~/.g/src \u279e\n. Double check your import statements. My problem was made by VCS editor code completion tool and fact that I had in my $GOPATH two other packages that had render module :)\nWhen go imports was launched on save it add wrong package to imports.. You don't have to delete any packages. Just add manually proper import statement for chi/render and don't depend  100% on VSC plugin autocompletion for imports.\n. ",
    "Banashek": "I'm currently facing this exact issue. @MrSpock how did you end up fixing the imports?. Yeah I'm using VCS and see the same thing when running find . -name 'render' as you did. So if the other package is being used in another project, do I just need to delete it while I'm working on this project?. Thanks for the help! Still getting used to the tooling.. ",
    "stefanprodan": "I've tested it now, sorry!. Closing since it will be covered by #185 . ",
    "bgv": "Chi's FileServer is just a helper around http.FileServer which does the NotFound check internally.\nIdeally you should check if the file exists and return the desired error yourself before calling ServeHTTP.\nYou can check #155 as starting point for your own implementation.. ",
    "JaCoB1123": "Awesome, thanks. That's all I need.\nI may add a PR to extend the FileServer example if that's in your interest.\nMaybe I could even add another Method ServeStatic or similar?\n// StaticStatic serves static files while taking the NotFoundHandler into account\nfunc (r *chi.Mux) ServeStatic(pattern string, directory string) {\n    workDir, _ := os.Getwd()\n    filesDir := filepath.Join(workDir, directory)\n    root := http.Dir(filesDir)\n    fs := http.StripPrefix(pattern, http.FileServer(root))\n    r.Get(pattern+\"*\", func(w http.ResponseWriter, rq *http.Request) {\n        if _, err := os.Stat(filesDir + rq.RequestURI); os.IsNotExist(err) {\n            r.NotFoundHandler().ServeHTTP(w, rq)\n        } else {\n            fs.ServeHTTP(w, rq)\n        }\n    })\n}. Just noticed that you mentioned that you aren't interested in a PR in #155. Closing this.. ",
    "dsincl12": "Haha, just wasted hours on this one with vue-resource and Axios. nothing got to through to the api, postman worked flawlessly :). ",
    "hsluoyz": "Already sent a PR here: https://github.com/pressly/chi/pull/192. Please advise:). It seems that we are going to make it a separate package. I made one here: https://github.com/casbin/chi-authz\nMaybe you want to put it in your github.com/pressly/middleware, but it seems not been created yet.. ",
    "mihai-tiriplica-hs": "Got it, it was not very clear to me in the first place (not a lot of Go experience). Thank you!. ",
    "aaveidt": "@tiriplicamihai by doing this, we can serve only 2s for one request.\nwhat happen with requests like uploading? Any chance to set timeout for each route?. It was the fault from govendor, i use govendor to fetch package but somehow itsn't the latest version ?!. @VojtechVitek i've read it, i don't understand how it works.\nAfter putting time.Sleep(30 * time.Second) on top of it, it still take 30s to finish the task.\nhow is the way to use TimeoutHandler?\nhttps://github.com/go-chi/chi/issues/198#issuecomment-302954438\n. ",
    "Bartuz": "@pkieltyka nice! Much deeper and thoughtful than rubyist's \"capybara\", \"puma\", \"unicorn\" and \"raptor\". ",
    "zemirco": "I've got the same problem. This is also related to https://github.com/go-chi/chi/pull/20. I'd like to add metrics to Prometheus https://prometheus.io/. It is on the way to becoming the standard monitoring solutions in cloud systems.\nI'm currently using gorilla mux but would like to switch because of the way chi handles subrouters. I've written a custom middleware for mux to deal with monitoring.\n```go\nvar requestDuration = prometheus.NewSummaryVec(prometheus.SummaryOpts{\n    Name: \"request_duration_milliseconds\",\n    Help: \"The HTTP request latencies in milliseconds.\",\n}, []string{\"method\", \"route\", \"status\"})\nfunc init() {\n    prometheus.MustRegister(requestDuration)\n}\nfunc Instrument(router mux.Router) func(http.Handler) http.Handler {\n    return func(handler http.Handler) http.Handler {\n        return http.HandlerFunc(func(w http.ResponseWriter, r http.Request) {\n            m := httpsnoop.CaptureMetrics(handler, w, r)\n            duration := float64(m.Duration / time.Millisecond)\n            var routeMatch mux.RouteMatch\n            route := r.URL.Path\n            if router.Match(r, &routeMatch) {\n                route, _ = routeMatch.Route.GetPathTemplate()\n            }\n            requestDuration.WithLabelValues(\n                r.Method, route, strconv.Itoa(m.Code),\n            ).Observe(duration)\n        })\n    }\n}\n```\nCurrently there no easy way to achieve the same with chi. Any ideas or would you change your mind about adding this feature to the core library?\nCheers!. Looks promising! Cheers, will try.. Just checked the source code cause I wanted to fix the comment indentation here https://github.com/go-chi/chi/blob/master/context.go#L79. How about adding go vet and golint to travis? There are several issues.. Looks good! The solution works. I'm getting URLs like\n/{username}/repositories/{repoID}\n/{username}/followers/{followerID}\nThat's what I wanted.\nOne minor thing \ud83d\ude04 What I do not want for my route handlers is what I want for my file server. I'm getting /public/* for all my files.\nHere is my setup\ngo\nr := chi.NewRouter()\nr.Use(middleware.Instrument)\nr.Method(http.MethodGet, \"/public/*\", http.StripPrefix(\"/public/\", http.FileServer(http.Dir(\"public\"))))\nIs it possible to get more information about the files being served?\ngo\n/public/js/a.js\n/public/js/b.js\n/public/css/styles.css. Ok I thought there is a built in solution since I'm getting the real file /public/javascript/common.js when I'm logging chi.RouteContext(r.Context()).\n2017/07/31 21:54:47 middleware.go:112: /public/*\n2017/07/31 21:54:47 middleware.go:110: &chi.Context{RoutePath:\"\", RoutePatterns:[]string{\"/public/*\"}, URLParams:chi.RouteParams{Keys:[]string{\"*\"}, Values:[]string{\"javascript/common.js\"}}, routePattern:\"/public/*\", routeParams:chi.RouteParams{Keys:[]string{\"*\"}, Values:[]string{\"javascript/common.js\"}}, methodNotAllowed:false}\nI could totally build a simple check that tests for /public/ and use r.URL.Path instead of the pattern.\n\ud83d\udc4d . Here is the go report card https://goreportcard.com/report/github.com/go-chi/chi.\nLet's make chi even stronger :muscle: . Try the following. It works for me serving static files from my /public/ repo.\ngo\nr.Method(http.MethodGet, \"/public/*\", http.StripPrefix(\"/public/\", http.FileServer(http.Dir(\"public\"))))\nIt might just be the missing asterisk *.. ",
    "ghost": "similar result. ```package main\nimport (\n    \"github.com/pressly/chi\"\n    \"github.com/pressly/chi/middleware\"\n    \"html/template\"\n    \"net/http\"\n    \"path\"\n    \"path/filepath\"\n)\nvar tpl = template.Must(template.ParseGlob(\"templates/*\"))\nfunc mainpage(w http.ResponseWriter, r *http.Request) {\n    tpl.ExecuteTemplate(w, \"mainpage.tpl\", nil)\n}\nfunc main() {\n    r := chi.NewRouter()\n    //r.Use(middleware.Compress(6, \"gzip\"))\n        r.Use(middleware.DefaultCompress)\n    r.Get(\"/\", mainpage)\n    workDir, _ := os.Getwd()\n    filesDir := filepath.Join(workDir, \"static\")\n    r.FileServer(\"/static\", http.Dir(filesDir))\n    http.ListenAndServe(\":80\", r)\n}. ",
    "PlkMarudny": "Thank you, got this reading sources.. Indeed, I used URLFormat middleware accidentally. ",
    "dqminh": "I think Since is a bit cleaner since you dont need to declare an explicit variable to use it. Under the hood its the same thing though since it calls Now().Sub(t). ",
    "samwierema": "@pkieltyka great! And congrats on the new release!. ",
    "valsor": "I would take over this work with pleasure. Unfortunately I'm a beginner and don't have enough experience to contribute to such an excellent project.. ",
    "advanderveer": "@pkieltyka I would like to take a shot at this. I do have a question about the design you propose, how would one go about reverse routing a router setup like this:\nGo\nr.Name(\"articles\").Route(\"/articles\", func(r Router) {\n    r.Get(\"/{a}foo{b}.*\", func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \"foo\") })\n    r.Get(\"/{a}bar{b}.*\", func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \"bar\") })\n})\nBy labeling just the router as \"articles\" it doesn't seem possible to just reverse to an url without specifying the actual endpoint? Also, how about the star (*)?\nOne could also think of a design that is more orthogonal, something in the spirit of github.com/alehano/reverse:\n```Go\nr.Name(\"articles\").Route(\"/articles\", func(r chi.Router) {\n    r.Get(\"/{a}foo{b}.\", chi.Label(\"foo\", func(w http.ResponseWriter, r http.Request) { fmt.Fprintf(w, \"foo\") }))\n    r.Get(\"/{a}bar{b}.\", chi.Label(\"bar\", func(w http.ResponseWriter, r http.Request) { fmt.Fprintf(w, \"bar\") }))\n})\nurl1, err := r.URLFor(\"foo\", chi.Params{\"a\": \"a1\", \"b\": \"b1\", \"\": \".html\"}\nurl2, err := r.URLFor(\"bar\", chi.Params{\"a\": \"a2\", \"b\": \"b2, \"\": \".html\"}\n``` \n. ",
    "muei": "\u901a\u4fd7\u6613\u61c2\uff0c\u8bd9\u8c10\u5e7d\u9ed8\uff0c\u53c8\u4e0d\u5931\u5bd3\u610f\uff0c\u65af\u4ee5\u4e3a\u53ef\u4e5f\uff01\n\ud83d\ude06\uff0c\u5176\u5b9e\u6211\u60f3\u8bf4\ngo-chi is nice. \u5927\u800c\u5168 or \u5c0f\u800c\u7f8e\n\u770b\u4e2a\u4eba\u559c\u597d\uff01. ",
    "venliong": "chi\u548cecho/beego\u6bd4\u8d77\u6765\uff0c\u5f00\u53d1\u65f6\u4f1a\u4e0d\u4f1a\u9ebb\u70e6\u5f88\u591a\uff1f\n\u611f\u89c9\u4ece\u5f00\u53d1\u901f\u5ea6\u4e0a\u6bd4\u8f83\u7684\u8bdd\uff0cbeego/macaron>echo/gin>chi/pure\u3002\niris\u5f00\u53d1\u4e5f\u5f88\u65b9\u4fbf\uff0c\u5c31\u662f\u7f16\u8bd1\u51fa\u6765\u7684\u6587\u4ef6\u5927\u5f88\u591a\u3002. ",
    "stelund": "An update after talking to my college. We did not use this pattern for v2 but added the /articles/{id}.json as it was supported per the release notes.. I'm writing a proxy which also need to pass through webdav requests. \nCan I suggest an PR for an support any method that I mentioned?. OK, thanks!. Thanks for the heads up!. ",
    "niklasj": "Here's a patch with tests for a (slightly contrived) scenario that showcases the issue. Routes with different handlers are added to: \n\n/archive/{file}.zip\n/archive/{file}.tar.gz\n/archive/{file}.{ext}\n\nAt the moment filenames containing a dot all end up in the third handler, even when they have a suffix .zip or .tar.gz.. ",
    "dvic": "Force pushed same commit to trigger travis build. Nice catch!. ",
    "kendellfab": "I observed something like this as well.  The uri with parameters is sent to the wrong handler, so the parameters are pulled out of the uri incorrectly.\nExpected:\nGET /comment/first-page -> SLUG:first-page ID:\nDELETE /comment/first-page -> SLUG: ID:first-page\nActual:\nGET /comment/first-page -> SLUG: ID:first-page\nDELETE /comment/first-page -> SLUG: ID:first-page\n```\npackage main\nimport (\n    \"fmt\"\n    \"net/http\"\n    \"github.com/go-chi/chi\"\n)\nfunc main() {\n    r := chi.NewMux()\nr.Get(\"/comment/{slug}\", func(w http.ResponseWriter, r *http.Request) {\n    slug := chi.URLParam(r, \"slug\")\n    id := chi.URLParam(r, \"id\")\n    fmt.Println(\"SLUG:\", slug, \" ID:\", id)\n    fmt.Fprint(w, \"SLUG:\", slug, \" ID:\", id)\n})\n\nr.Delete(\"/comment/{id}\", func(w http.ResponseWriter, r *http.Request) {\n    slug := chi.URLParam(r, \"slug\")\n    id := chi.URLParam(r, \"id\")\n    fmt.Println(\"SLUG:\", slug, \" ID:\", id)\n    fmt.Fprint(w, \"SLUG:\", slug, \" ID:\", id)\n})\n\nhttp.ListenAndServe(\":3000\", r)\n\n}\n```. ",
    "itsjamie": "We've resolved it by switching them both to :resourceID but is there a better way?. I'll update it to use chi v3 and see if we get the same behaviour. Thanks.. @pkieltyka Thank you very much for telling me it was fixed in v3. The change was pretty minimal for us, and it's fixed now!\n\ud83d\udcaf . ",
    "JensRantil": "Closing this. See https://github.com/go-chi/docgen/issues/2 instead.. ",
    "afidegnum": "How far with this? . ",
    "nicpottier": "Ran into this as well and willing to put together a PR. \nHow do we want this to work?\nSeems we have two options, either require \"escaping\" the { and } characters somehow when you are trying to define a regex in a path, or require that variables must being with a non-digit, in which case we can test anything in {} for whether it starts with a digit and if so use it as a variable name and if not use it as a regex.\nRegexes are already a bit nuts when it comes to escaping, so adding another way of escaping in there sounds error prone to me. So my vote would be to disallow names that start with a digit, then treat any {..} block that starts as a digit as something to be part of a regex.\nThoughts?. Easy enough and happy to give back! Thanks for all the work on chi!. After doing some more reading (the dev and nuts golang mailing lists have some interesting conversations) I realize it isn't going to be so easy. (also see latest installment here: https://research.swtch.com/vgo-module)\nAll internal references to go-chi would have to be changed to use a v3 import style.\nIE, from my understanding, everywhere where we currently do:\ngolang\nimport \"github.com/go-chi/chi\"\nWould have to change to:\ngolang\nimport \"github.com/go-chi/v3/chi\"\nThat isn't THAT many places in the codebase, but would break non vgo users. So may make sense to give the paint some time to dry on this proposal to see what the community decides is the best practice for existing non v1 modules.. Having pondered Russ's latest post a few minutes, I think the answer will be, create a /v3 subdirectory in our repo and copy all code in there. We'd have to update both the root and v3 copies until vgo adoption hits critical mass, but that provides a backwards compatible way of having both vgo and go compatible versions as I understand it.. I think this is a bit of a big bet by the go authors that we, the go ecosystem, need to take semantic versioning seriously, and that major version changes that aren't backwards compatible should be thought about carefully. The transition does indeed sound painful but I think there could be something really special to it if, especially if they follow through on their ideas of creating a go release command that helps you figure out what your next version should be. Kind of gofmt it might create a universal culture of excellent versioning moving forward.\nThat said, discussing the pros and cons of vgo belongs on the golang list more than here.. Yep, I think that makes sense.\nFor any brave explorers running in this in the future, you can add a chi dependency in your go.mod and use it as you always have with the below: (update the timestamp and hash to the latest go-chi release commit)\nrequire(\n    \"github.com/go-chi/chi\" v0.0.0-20180202194135-e223a795a06a\n). It does if you want it to work across both go and vgo, because internal dependencies need to use the folder, ie this part:\n  https://github.com/peterbourgon/vtest/blob/master/foo/foo.go. @kron4eg ya that's probably the cleanest way forward.. ",
    "dhax": "when using MarkdownRoutesDoc with chi.Mux it works though, but breaks gorename for the whole project with this error:\ncannot use api (variable of type github.com/go-chi/chi.Mux) as github.com/go-chi/chi.Router value in argument to docgen.MarkdownRoutesDoc: wrong type for method Group\nCan you confirm this please or am I doing something wrong?. ",
    "mrbanzai": "I have tried the logging example.  For most operations, it works without issue.  I, however, encountered an issue when streaming a file through cipher.StreamWriter via io.Copy (for encrypting content to the response writer).  By tracing through the Go 1.8 source, I noticed that it uses ReadFrom if the writer supports it, which led me to the section of code referenced above.  I was able to correct my issue by altering the code to update the bytes value on the basicWriter within the httpFancyWriter.ReadFrom (https://github.com/mrbanzai/chi/commit/9936a163a79d1ea4c634554c97bf38833fb403cf).\nI can try to assemble a short example that would demonstrate resp_bytes_length showing 0 for data streamed via io.Copy.. Ah, good catch @VojtechVitek !  I completely overlooked that section as I was correcting it for my use case.. ",
    "DmitriyMV": "IIRC currently neither gorilla/mux nor julienschmidt/httprouter do that, so the implicit conversion from GET to HEAD doesn't look THAT useful. I may be wrong about that and in no way state that this shouldn't be done. I'm just a bit concerned about additional work that app may need to do, and which is going to be wasted.\nThe standard mux analogy is interesting, but Go default mux have several pain points, so I wouldn't call it a great example.. @alehano \nNot exactly - https://stackoverflow.com/questions/3854842/content-length-header-with-head-requests\nIf our GET method result is dynamically generated - this clause can be averted.. Well - in case our GET request handler has to fetch data from remote sources (such as DB, storages, API) - our \"implicit\" HEAD handler which will be actually a GET handler and it will be forced to get and wait the required data. And then discard it. \nThis is also concerning when we have cache system with complex rules - I can imagine the scenario when the cache gets invalidated two times - on HEAD and then on GET.. Please, NO implicit settings. If I want this behavior I will enable it explicitly. Adding new method is better than redefining behavior of the existing ones.\nI would also like to point out, that HEAD lookup time will increase depending on the size of existing GET routes.. I think it will be router.MethodNotAllowed(chi.PromoteHeadToGet).. That solution will not set the headers which GET handlerFn could set. The problem as I see it currently is that we want the GET handler headers but we do not want GET handler body.. No changing of the default behavior, please.. The middleware approach looks interesting, but it implies that we didn't define any proper HEAD handlers. The MethodNotFound approach is \"pay later\" rather than \"pay upfront\". Personally, I like to \"pay later\".. @pkieltyka Sigh. You just broke the backward compatibility. Can we please have any sort of switch to turn this off or on?\nAlso, please don't do things like that with future minor versions. Reserve them for major ones. I like chi, but with changes like this one, I will be forced to move my company projects away from it. Sorry.. @pkieltyka I mean that I currently have custom defined NotFoundHandler handler and you just broke my code.. @pkieltyka \nThis code:\n```\npackage main\nimport (\n    \"net/http\"\n\"github.com/go-chi/chi\"\n\n)\nfunc main() {\n    r := chi.NewMux()\n    r.Get(\"/hello\", func(w http.ResponseWriter, r http.Request) {\n        println(\"I was called with METHOD\", r.Method)\n        w.Write([]byte(\"Greetings!\"))\n    })\n    r.MethodNotAllowed(func(writer http.ResponseWriter, request http.Request) {\n        if request.Method == \"HEAD\" {\n            println(\"I'm HEAD request! Hurray!\")\n        } else {\n            println(\"I'm \" + request.Method + \" method request\")\n        }\n    })\n    http.ListenAndServe(\":3333\", r)\n}\n``\nBehaves differently after commit1b51a16ac893c99cc5978fca77249701129eedaf`. Now there is no way to define such handler at all.\nI agree about VCS point. But I also think, that inviting people to discuss breaking change, only to accept it unconditionally after two hours and no discussion is not a good way to have any sort of discussion.  Given the fact, that better solutions were proposed without breaking existing code.\nRegardless I thank you for your time and effort and I will show myself out. . CORS requests. I know you can use \"/\" - tho not every case. I also know that your new behavior actually contradicts RFC because we are still returning headers which we do not guarantee to not change between requests. \nAnyway - the deed is done. I see no point in continuing this discussion. I wish you all the luck, but from now I will stay away from chi and advice my colleagues to do the same. . Look, I get it. I got angry too because I spent last 20 days tracking this issue, and searching for the better solution (I actually did look into RFCs and \"headers problems\"), even notifying you in your merge request about explicit switch variable, so you could think about it. Only to find it merged without any sort of answer, tho you yourself invited other people to discuss the proposed solution. So - yes, I got mad.\nThe actual proper solution should remove the set of headers, but the problem is - we cannot change ResponseWriter.Headers after we had called Write or WriteHeader. This is problematic because we should not return Content-Length for HEAD requests if the response will be dynamic. So at this moment, I really don't have a better solution other than proxying ResponseWriter which will get into GET handler for the HEAD request and modify it afterward in our \"middleware\". That, in turn, results in another problem - that ResponseWriter can contain a growing set of interfaces (more here github.com/felixge/httpsnoop). So atm - I really don't have any proper fix.\nAnd this is the main reason why I got angry - how easy it was for you to break the existing behavior, even though the solution doesn't introduce proper fix. I know that breaking changes are sometimes necessary - you can't compromise your clients' security, for example. You may also want to change API because it can be simplified or made more robust. Or just because you think it will be for the better. \nBut you should always remember, that in OSS, other people depend on your code. And the more project matures, the more people use it. They are willing to discuss your ideas. They are willing to help you. They are even willing to migrate if your changes are actually good, and you provided them a \"transition period\". They, essentially, trust you. And when you break this trust, bad things happen...\nI cannot monitor every commit and change individually - because I too have a lot of responsibilities and routine on my day to day job. This is why we have semver - so we collect the things we want to fix and only when we absolutely sure, we break the existing code. I pinned my code to version 3.1.5, but that does not mean others did it too. What is more important - that pin removes my ability to receive code updates - including security ones, if you find and fix a bug in your later versions. \nAgain - I'm not against breaking changes. I know that software evolves. But I'm against breaking it sporadically without really serious considerations or giving people a transition period. This kills any sort of trust, because other people's code has \"just stopped working\" even if they had used it incorrectly from the semantic point of view.. I did - I actually was the one who linked this answer in this issue \ud83d\ude09. There is the even direct answer to the question:\n\nSo the real answer is, you don't need to include Content-Length, but if you do, you should give the correct value.\n\nSo even if your new solution is no longer breaks existing code, it still is incorrect. I only glanced at the code - do you really need to re-assign Routes field variable every time?\nI will look further into it, including the ability to change headers later this or next week. Currently, I tend towards this https://github.com/felixge/httpsnoop/blob/master/wrap_generated_gteq_1.8.go#L66 even tho it looks horrid.\nP.S. Yes - we did look into GRPC - most of our new services are using github.com/grpc-ecosystem/grpc-gateway. Not all of them tho.. Regarding Config - judging from the source code it's done automatically for new sub-routers as long as you use Route method. If you wish to explicitly mount the sub-router - you will have to initialize it correctly.\nWhile Config approach is simpler, the middleware approach is more explicit and doesn't introduce this fix into the core of this router. That alone will allow us to use corrent \"dirty\" fix (documenting the fact,  that headers will not be stripped from the resulting response) and introduce the proper one (once this https://github.com/golang/go/issues/4146 or https://github.com/golang/go/issues/16522 will be resolved) without breaking existing code.That and @VojtechVitek points about dynamic routing.. @lwc  @alehano  @Vektah  @c2h5oh  any thoughts on the matter?. Thanks! :+1: . I think the addition for (*Mux).Find tests would be a good idea - that would explain how it works with middlewares and handlers. As I understand it now - it works like this:\n```\nfunc TestMuxFind(t *testing.T) {\n    result := []string{}\nr := NewRouter()\nr.Use(func(handler http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        result = append(result, \"middleware\")\n        handler.ServeHTTP(w, r)\n    })\n})\nr.Get(\"/handler\", func(w http.ResponseWriter, r *http.Request) {\n    result = append(result, \"handler\")\n})\n\ntctx := NewRouteContext()\ntctx.RouteMethod = \"GET\"\ntctx.RoutePath = \"/handler\"\n\nh := r.Find(tctx, tctx.RouteMethod, tctx.RoutePath)\nh.ServeHTTP(nil, nil)\nt.Log(result)\n\n}\n```\nWhich results in this\nmux_test.go:38: [handler]\nSo basically - no, no middlewares using Find method.. So basically we verify that the combination of RoutePath and RoutheMethod does have an endpoint, but we cannot call it because we are not sure that this route will go through all setted middlewares.\nI have to ask - can we use the returned http.Handler in any meaningful way? If not - maybe we should return bool and rename it to IsExist or something like that.. Since we modify the rctx after we had used both RouteMethod and RoutePath - it may be a good idea just to use rctx. . But, from the API viewpoint - maybe we could add a new private interface type and use it to cleanup API - this way we can achieve the similar performance without mental overhead for the end user. . Something like\n```go\n// Find searches the routing tree for a handler that matches the method/path.\n// It's similar to routing a http request, but without executing the handler\n// thereafter.\nfunc (mx *Mux) Find(method, path string) http.Handler {\n    tctx := NewRouteContext()\n    tctx.RouteMethod = method\n    tctx.RoutePath = path\n    return mx.find(tctx, method, path)\n}\nfunc (mx Mux) find(rctx Context, method, path string) http.Handler {\n    m, ok := methodMap[method]\n    if !ok {\n        return nil\n    }\nnode, _, h := mx.tree.FindRoute(rctx, m, path)\n\nif node != nil && node.subroutes != nil {\n    rctx.RoutePath = mx.nextRoutePath(rctx)\n    if subroute, ok := node.subroutes.(extendedRoutes); ok {\n        // Our type is implementing allocation free find. Use it.\n        return subroute.find(rctx, rctx.RouteMethod, rctx.RoutePath)\n    }\n    // Fallback to the public method\n    return node.subroutes.Find(rctx.RouteMethod, rctx.RoutePath)\n}\n\nreturn h\n\n}\n```\nWhere \n``go\n// Routes interface adds two methods for router traversal, which is also\n// used by thedocgen` subpackage to generation documentation for Routers.\ntype Routes interface {\n    // Routes returns the routing tree in an easily traversable structure.\n    Routes() []Route\n// Middlewares returns the list of middlewares in use by the router.\nMiddlewares() Middlewares\n\n// Find searches the routing tree for a handler that matches\n// the method/path - similar to routing a http request, but without\n// executing the handler thereafter.\nFind(method, path string) http.Handler\n\n}\ntype extendedRoutes interface {\n    Routes\n    find(rctx *Context, method, path string) http.Handler\n}\n```. > But also, you could pool them if you really wanted to.\nSorry - can you elaborate?. ",
    "cardonator": "248 is probably for the best. I think the concern above about starting to rely too much on Config is important. That probably best avoided for as long as possible..",
    "delicb": "I had same problem after upgrading to chi 3, but it turned out that I had imported middleware from github.com/pressly/chi/middleware (which I had in my GOPATH). Problem is that chi sets stuff to context and casts it when it is retrieved, but types are different because path is different, which is fine. \nOnce I fixed all import paths to use github.com/go-chi/chi, everything worked correctly. \n@denyskoch check if same thing happened to you as well.. ",
    "denyskoch": "as @delicb noted, the imports were the issue, thanks!.\nUpdating imports to new repository fixes it. . ",
    "hahanein": "Maybe I'm doing something wrong but these would be possible GET requests:\nlocalhost/en/genre/subgenre\nlocalhost/en/genre/subgenre/subgenre\nlocalhost/fr/genre/subgenre/subgenre/subgenre\netc. pp.\nAs far as I understand it r.Get(\"/{someparameter}/genre/{genre}\", GenreHandler) matches only the first example.\nHere's some pseudocode for the handler:\n```golang\nfunc GenreHandler(w http.ResponseWriter, r *http.Request) {\n        languageCode := chi.URLParam(r, \"someparameter\"))\n    path := strings.Split(chi.URLParam(r, \"genre\"), \"/\")\n\n    var genres GenreRoseTree = GetGenreRosetree(languageCode)\n\n    var genre GenreRoseTree = genres.TraversePath(path)\n\n    Templates.ExecuteTemplate(w, \"genre\", genre)\n\n}\n```. ",
    "KenjiTakahashi": "Any updates on this? I am making a service that kinda mimicks the S3 API. So I'd like to have URLs in form of /{bucket}/{key}?args, where key can have slashes in it. I am currently using your asterisk workaround and it works (thanks!), but feels a bit clumsy.. Yeah, like I wrote, this is what I'm doing right now. But it would be nice to have this better supported.. ",
    "gabiganam": "I'm not sure what you mean by \"dynamic\", but yes.\nFor example I could have;\nr.Header(\"Version\", \"1.2.3\").Get(\"/some/uri/here\", oldHandler)\nr.Header(\"Version\", \"2.0\").Get(\"/some/uri/here\", newHandler)\nNow assume my application has a header called \"Version\", then requests from version \"1.2.3\" will be handled by the \"oldHandler\" function, and version \"2.0\" will be handled by the \"newHandler\".\nIt would obviously be very powerful to have the header value support regex, although that will introduce the problem of overlapping results, so let's put a pin in that for now.\nLet's also define that requests for that URI without the mapped header, or without a mapped header value, will result in a page-not-found error.\nUnless of course I have:\nr.Get(\"/some/uri/here\", defaultHandler)\nIn which case they will get to the \"defaultHandler\".. Sounds like a great solution for what I need :). ",
    "kwojcicki": "@pkieltyka exactly there. I am using casbin (https://github.com/casbin/casbin) and I would like to generate the permissions alongside generating the route. However manually inserting the route makes it harder to maintain/somewhat tedious. So what i am looking to do is replace\nr.Route(\"/test\", func(r chi.Router) {\n            r.Route(\"/123\", func(r chi.Router) {\n                            // need to write path myself\n                            e.AddPermissionForUser(\"dataset1_admin\",\"/test/123/\", \"GET\", \"allow\")\n                            r.Get(\"/\", func(w http.ResponseWriter, r *http.Request) {\n                    w.WriteHeader(200)\n        })\n  })\n})\nwith this:\n```\nr.Route(\"/test\", func(r chi.Router) {\n            r.Route(\"/123\", func(r chi.Router) {\n                            // have chi generate route instead of adding manually\n                            e.AddPermissionForUser(\"dataset1_admin\",r.getFullPath\", \"GET\", \"allow\")\n                            r.Get(\"/\", func(w http.ResponseWriter, r *http.Request) {\n                    w.WriteHeader(200)\n        })\n  })\n})\n```. https://github.com/go-chi/chi/issues/125\nhttps://github.com/go-chi/chi/issues/127\nWere the issues I believe you were referring to. Helped me out thanks :smile: . ",
    "flimzy": "Thanks for the prompt reply!. ",
    "tutley": "I'll check that out. I didn't think the fileserver would cause an issue becuase it has it's own stub ('/dist') but I'll try some things there (like just removing that line and seeing what happens with the API routes)\nI'm using the fileserver that is exported by: https://github.com/elazarl/go-bindata-assetfs\nI'd be open to not using a fileserver but instead using go-bindata to create a variable for each asset if there was some sort of automated way to setup the routing for each asset.\nOh I'm using:\n cat vendor/github.com/pressly/chi/CHANGELOG.md\nChangelog\nv2.1.0 (2017-03-30). Commenting out the r.FileServer doesn't seem to have changed anything. Still 404ing.. OK, I updated to the correct project (go-chi/chi rather than pressly/chi) and implemented your fileserver function then called it like this:\nFileServer(r, \"/dist\", assetFS())\nAnd now url parameters are working. Thanks!\n. ",
    "oliverpool": "If I'm not mistaken, this is now available without fork, using RegisterMethod(\"PROPFIND\") :-). ",
    "beornf": "Overriding the default logger as below works:\nmiddleware.DefaultLogger = middleware.RequestLogger(&middleware.DefaultLogFormatter{\n    Logger: logrus.New(),\n}. ",
    "scrivy": "Shoot. Should have searched. Thanks. ",
    "DisruptiveMind": "@vincentserpoul you can still use request.URL.Query().Get(...). ",
    "matematik7": "@pkieltyka I've added the test.. @piotrkubisa r.Route should be used to group routes with common prefix together. It becomes useless if you have to repeat param in all children.\nAlso I should mention that if you rely on regex for validation and do not check input further before using it in sql, this could be a serius security issue.. ",
    "hovhannest": "Thanks for reply.\nSorry if I have misunderstand.. In Mount you really have smt like\nif pattern == \"\" || pattern[len(pattern)-1] != '/' \nand it understands that r.Mount(\"/path\", ...) and r.Mount(\"/path/\", ...) are the same, but for example in this kind of code\nr.Mount(\"/path\", MyRouter())\n...\nfunc MyRouter() http.Handler {\n    r := chi.NewRouter()\nr.Get(\"/*\", func (w http.ResponseWriter, r *http.Request){\n    w.Write([]byte(\"smt is here\"))\n})\n\nreturn  r\n\n}\nI have 404 \"Page not found\" for localhost/path/\nand for \nr.Mount(\"/path/\", MyRouter())\n...\nfunc MyRouter() http.Handler {\n    r := chi.NewRouter()\nr.Get(\"/*\", func (w http.ResponseWriter, r *http.Request){\n    w.Write([]byte(\"smt is here\"))\n})\n\nreturn  r\n\n}\nI have 404 \"Page not found\" for localhost/path\nI would be appreciated if you'll tell me what is my mistake if there is everything ok with chi.\nThanks,\nHovhannes Tsakanyan. I've changed the \"thee.go\" file line 444 from\nif len(xsearch) == 0 {\nto\nif len(xsearch) == 0  || xsearch == \"/\" {\nand I'm using r.Mount(\"/path\", MyRouter())\nI've suggested this change, but my pull request was denied. May be I'm doing smt. wrong, but it's working for me.. ",
    "olihey": "Any fix for this?\nI just went into the exact same issue and the only way I could fix it was to use\nr.Mount(\"/path/\", MyRouter())\nbut then localhost:9876/path fails, of course \ud83d\ude22 . ",
    "lrstanley": "Any idea on user pushback for merging #281 into master? I've had to use the fix-260 branch for over 5 projects at this time. Haven't ran into any issues, and I personally find that the implementation makes sense. When mounting, one would think that it's treated the same way that the primary/first / is handled.. Agreed -- this completely breaks redirects if I load the compression middleware.. ",
    "inancgumus": "it's not an error as @pkieltyka says, try this:\ncurl -L http://:8889/debug/pprof\n\nThen, curl will follow the redirection.. ",
    "luweimy": "@inancgumus \n$ curl -L http://:8889/debug/pprof\ncurl: (47) Maximum (50) redirects followed\nAnd google chrome open the url http://127.0.0.1:8889/debug/pprof/\nERR_TOO_MANY_REDIRECTS . @kowalczykp thank you very much \nI understand.\nremove middleware StripSlashes is ok\n// router.Use(middleware.StripSlashes)\nrouter.Mount(\"/debug\", middleware.Profiler()). ",
    "kowalczykp": "@luweimy I guess that u are using middleware that redirects the trailing slashes (chi's RedirectSlashes perhaps?)\npprof's handler needs the trailing slash (forces redirect to XXX/), and your additional middleware forces the redirect to XXX - probably that's the problem\nIn my opinion, this falls under the category: misuse. Documenting the middleware's behavior and misuses might help. ",
    "joho": "I ran into this same issue today and I thought I was going crazy. I'm glad a google finally turned this up.\nI can reproduce consistently with a small test case.\n```go\npackage main\nimport (\n    \"net/http\"\n\"github.com/go-chi/chi\"\n\"github.com/go-chi/cors\"\n\n)\nfunc main() {\n    cors := cors.New(cors.Options{\n        AllowedOrigins:   []string{\"*\"},\n        AllowedMethods:   []string{\"GET\", \"POST\", \"PUT\", \"DELETE\", \"OPTIONS\"},\n        AllowedHeaders:   []string{\"Accept\", \"Content-Type\", \"Authorization\"},\n        AllowCredentials: true,\n        Debug:            true,\n    })\nr := chi.NewRouter()\n// r.Use(cors.Handler)\n\nr.Group(func(r chi.Router) {\n    r.Use(cors.Handler)\n    r.Get(\"/foo\", func(w http.ResponseWriter, r *http.Request) {\n        w.Write([]byte(\"foo\"))\n    })\n    r.Post(\"/bar\", func(w http.ResponseWriter, r *http.Request) {\n        w.Write([]byte(\"bar\"))\n    })\n})\n\nhttp.ListenAndServe(\":8080\", r)\n\n}\nIf you run that code as is with the following curl\ncurl -H \"Origin: http://example.com\" \\\n  -H \"Access-Control-Request-Method: POST\" \\\n  -H \"Access-Control-Request-Headers: Authorization\" \\\n  -X OPTIONS --verbose \\\n  http://localhost:8080/bar\nIt will give you this result\n   Trying ::1...\n TCP_NODELAY set\n* Connected to localhost (::1) port 8080 (#0)\n\nOPTIONS /bar HTTP/1.1\nHost: localhost:8080\nUser-Agent: curl/7.55.1\nAccept: /\nOrigin: http://example.com\nAccess-Control-Request-Method: POST\nAccess-Control-Request-Headers: Authorization\n< HTTP/1.1 405 Method Not Allowed\n< Date: Sun, 28 Jan 2018 10:25:18 GMT\n< Content-Length: 0\n< Content-Type: text/plain; charset=utf-8\n< \n* Connection #0 to host localhost left intact\nwith the following in the logs (with debug set on the cors config)\n[cors] 2018/01/28 21:24:23 Handler: Preflight request\n[cors] 2018/01/28 21:24:23 Preflight response headers: map[Access-Control-Allow-Origin:[http://example.com] Access-Control-Allow-Methods:[POST] Access-Control-Allow-Headers:[Authorization] Access-Control-Allow-Credentials:[true] Vary:[Origin Access-Control-Request-Method Access-Control-Request-Headers]]\n```\n\nIf you move the r.Use(cors.Handler) outside of the group (comment it out and uncomment the one I left there) and run the same curl command you get a different result\n```\n   Trying ::1...\n TCP_NODELAY set\n* Connected to localhost (::1) port 8080 (#0)\n\nOPTIONS /bar HTTP/1.1\nHost: localhost:8080\nUser-Agent: curl/7.55.1\nAccept: /\nOrigin: http://example.com\nAccess-Control-Request-Method: POST\nAccess-Control-Request-Headers: Authorization\n< HTTP/1.1 200 OK\n< Access-Control-Allow-Credentials: true\n< Access-Control-Allow-Headers: Authorization\n< Access-Control-Allow-Methods: POST\n< Access-Control-Allow-Origin: http://example.com\n< Vary: Origin\n< Vary: Access-Control-Request-Method\n< Vary: Access-Control-Request-Headers\n< Date: Sun, 28 Jan 2018 10:24:23 GMT\n< Content-Length: 0\n< Content-Type: text/plain; charset=utf-8\n< \n* Connection #0 to host localhost left intact\n```\n\nI'm just speculating at this point, but maybe the group tries to be smart and early 405 methods that don't have handlers registered against them for routes match within the group.\n. Yep. I started diving through the code after I posted to see if I could offer a PR fixing it when I realised it would be impossible.\nThe app i'm working on is kind of like an API gateway kind of thing, with some local responses and some proxied responses from upstream APIs and getting the middleware and some of the proxied responses were not playing well together. I was trying to avoid messing too much with the proxied endpoints and thought grouping might help me get around intercepting/changing CORS headers. I'll figure something out.\nIn the meantime I might make a docs PR over to the cors package to make the inline middleware issue clear and save future devs some time (if they're doing anything as unwise as me). ",
    "tboerger": "For reference, I want to implement this api: https://www.terraform.io/docs/backends/types/http.html. I have already started to use these changes within my tool and it's working good so far.. Yeah currently I'm using my vendored fork for that. These methods are part of a standard, it's part of the Webdav specification, for reference: http://www.webdav.org/specs/rfc2518.html. ",
    "polds": "fwiw I've modified my own local copy of chi and this allows me to deploy to appengine with no issue.. ",
    "jawnsy": "@fate-lovely Would it be possible to add fasthttp support to chi somehow? Otherwise, it might be difficult keeping your fork up-to-date with some of the latest changes in chi. This seems, more generally, to be one of the problems with fasthttp: most libraries and frameworks are written to coexist with the standard net/http, thus severely limiting the ecosystem compatible with fasthttp.. (Random drive-by Internet commenter here)\nWhile the two options are equivalent, I prefer the explicit ok check. It makes it easier to understand the two different possible cases, as well as to add logging or other handling later. The cost is two extra lines of code. Presumably these get compiled the same, so there's no runtime performance impact.. Huh, interesting, you are correct, TIL. There's an extra JNE, MOVQ, and RET instruction: https://gist.github.com/jawnsy/613405bd42eb7f8ffaa6bdde4c372048 - I'm surprised that the Go compiler doesn't optimize it thanks to escape analysis. In practice I don't think it matters (just a style preference), but good to know nonetheless.\nFor reference, I built the files using:\ngo tool compile -S assert-check.go >assert-check.s\nAnd my go version output is (using golang package from Debian unstable): go version go1.9.1 linux/amd64. ",
    "fate-lovely": "@jawnsy There seems to be no easy way to add fasthttp support to chi except replace every http.Handler interface to fasthttp request handler, cause go doesn't have generics. I will keep watching chi and update phi, it seems the only way to go\ud83d\ude04. I really enjoy fasthttp, not for its performance, but its elegant design. A single ctx *fasthttp.RequestCtx is much better and flexible than (w http.ResponseWriter, r *http.Request).. @pkieltyka It's been moved to the table, please check.. ",
    "dcormier": "It was an accident, initially, but it led me to that bug.\nI'll change it to use your solution.. Done.\nI had to change Mux.pool from sync.Pool to *sync.Pool to avoid copying by value.. Just to confirm, you want to log a warning in cases like this? Based on past experience and looking at the code, it seems like the normal thing for chi to do is panic when there's strange route behavior (bad patterns, etc). Is that what you mean?\n\nWhat I'm trying to be able to do is something kind of like this:\n```go\nr := NewRouter()\n// Handlers that do not use middleware\nr.Post(\"/users\", registerUser)\nr.Post(\"/users/confirm\", confirmUser)\nr.Route(\"/things\", func(r Router) {\n    r.Get(\"/things\", getThings)\nr.Route(\"/{thingID}\", func(r Router) {\n    r.Get(\"/\", getThing)\n})\n\n})\nr.Group(func(r Router) {\n    // Everything in this group should use the middleware\n    r.Use(userAuth)\nr.Route(\"/users\", func(r Router) {\n    r.Patch(\"/\", updateUser)\n    r.Get(\"/\", getUsers)\n\n    r.Route(\"/{userID}\", func(r Router) {\n        r.Get(\"/\", getUser)\n        r.Patch(\"/\", updateUser)\n        r.Delete(\"/\", deleteUser)\n\n        r.Route(\"/things\", func(r Router) {\n            // more sub routes...\n        })\n    })\n})\n\nr.Route(\"/things\", func(r Router) {\n    r.Post(\"/\", createThing)\n\n    r.Route(\"/{thingID}\", func(r Router) {\n        r.Patch(\"/\", updateThing)\n        r.Delete(\"/\", deleteThing)\n    })\n})\n\n})\n```\nSince the Route calls will clobber the earlier routes, is there a recommended way to achieve this? The only way I'm seeing is something like this, which seems more clumsy:\n```go\nr := NewRouter()\nr.Route(\"/users\", func(r Router) {\n    // A couple of routes that do not use the middleware\n    r.Post(\"/\", registerUser)\n    r.Post(\"/confirm\", confirmUser)\nr.Group(func(r Router){\n    // All of these are use the middleware\n    r.Use(userAuth)\n\n    r.Patch(\"/\", updateUser)\n    r.Get(\"/\", getUsers)\n\n    r.Route(\"/{userID}\", func(r Router) {\n        r.Get(\"/\", getUser)\n        r.Patch(\"/\", updateUser)\n        r.Delete(\"/\", deleteUser)\n\n        r.Route(\"/things\", func(r Router) {\n            // more sub routes...\n        })\n    })\n})\n\n})\nr.Route(\"/things\", func(r Router) {\n    // A route that does not use the middleware\n    r.Get(\"/\", getThings)\n// A route that does use the middleware\nr.With(userAuth).Post(\"/\", createThing)\n\nr.Route(\"/{thingID}\", func(r Router) {\n    // A route that does not use the middleware\n    r.Get(\"/\", getThing)\n\n    r.Group(func(r Router){\n        // These routes do use the middleware\n        r.Use(userAuth)\n\n        r.Patch(\"/\", updateThing)\n        r.Delete(\"/\", deleteThing)\n    })\n})\n\n})\n```\nIs that the only supported way to do this?\n. I still think something should be tweaked to save people time in the future.. I found this because I accidentally used it as the handler for an http.Server. with is a Router, which implements http.Handler, so why not?\nIt works as expected when *Mux.With properly initializes the *Mux that's being returned as a Router from that method. If that's not intended, should the type returned from *Mux.With be something that doesn't implement http.Handler?. Sure thing.. Done.. ",
    "cskr": "URL should be sanitized, like ServeMux does, before routing.. Agreed.. @VojtechVitek The latest point releases of go (1.10.3 and 1.9.7) can work with /v3 in middleware's import without the symlink. This change describes the details. Will it be reasonable to change the minimum go version required by bumping version to 4.0.0?. ",
    "brknstrngz": "@pkieltyka indeed, I should have run some benchmarks first, I'll wear the pointy hat for a while. Please disregard the noise. The short array (up to 10 elements or so) iteration is 60x faster than the map lookup.. ",
    "zjn1234": "oh\uff0cthanks  . ",
    "ehmo": "Considering that this was committed almost a year ago, I would hope that you guys would merge it by now? Feel free to close this and add it directly to the master. It's a single line, don't care where it came from.. It's very surprising that there is any kind of issue as it ran through go fmt before pushing. Will check it out.. ",
    "srikrsna": "I'll create a new repo and update the README accordingly @pkieltyka . ",
    "mafredri": "@jdelk the strange characters you're seeing are terminal color codes. It seems chi has basic detection for when the program is not running in a TTY and disables colors, but it does not take into account where the program is printing (e.g. a file).\nI made a quick PR (#299), which if merged, will allow you to disable color logging by changing:\ngo\nmiddleware.DefaultLogger = middleware.RequestLogger(&middleware.DefaultLogFormatter{Logger: customLogger})\nto\ngo\nmiddleware.DefaultLogger = middleware.RequestLogger(&middleware.DefaultLogFormatter{Logger: customLogger, NoColor: true}). ",
    "aarondl": "Ran into this, it'd be handy if this was preventable in some way.. Sample program that reproduces the problem. Note that even when navigating to a route that's not handled the output still includes the middleware piece.\n```package main\nimport (\n    \"fmt\"\n    \"io\"\n    \"net/http\"\n\"github.com/go-chi/chi\"\n\n)\nfunc main() {\n    router := chi.NewRouter()\nrouter.Use(func(h http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        fmt.Println(\"middleware\", r.URL.Path)\n        h.ServeHTTP(w, r)\n    })\n})\n\nrouter.NotFound(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n    fmt.Println(\"not found\", r.URL.Path)\n    w.WriteHeader(http.StatusNotFound)\n}))\n\nrouter.Get(\"/\", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n    fmt.Println(\"normal route\")\n    w.WriteHeader(200)\n    io.WriteString(w, \"<!DOCTYPE html>\\n<html><body>rofl</body></html>\")\n}))\n\nhttp.ListenAndServe(\":6423\", router)\n\n}\n```. ",
    "alexanderattar": "Hi @pkieltyka thanks so much for the response! This was really close. The only issue was that a GET request under the /{cid} route still returned a 401, but your example gave me the nudge in the right direction I needed to figure it out :). All I needed to change was to move the /{cid} route out of the 2nd group, but then keep the final group with the reapplied jwtauth middleware above PUT and DELETE. It seems that all middlewares cascade down to subgroups after being included in an outer group. Below is the version with my slight change. Again thanks for your help and for all your contributions to open source Go!\n```\nfunc (rs Resource) Routes() chi.Router {\n    r := chi.NewRouter()\n// Protected routes\nr.Group(func(r chi.Router) {\n    // Public routes\n    r.Get(\"/\", rs.List)\n\n    // Private routes\n    r.Group(func(r chi.Router) {\n        // Handle valid / invalid tokens\n        // This can be modified using the Authenticator method in jwtauth.go\n        r.Use(jwtauth.Authenticator)\n        r.Post(\"/\", rs.Post) // POST /{resource} - create a new resource and persist it\n    })\n\n    r.Route(\"/{cid}\", func(r chi.Router) {\n        // Public routes\n        r.Get(\"/\", rs.Get) // GET /{resource}/{cid} - read a single resource by cid\n\n        // Private routes\n        r.Group(func(r chi.Router) {\n            r.Use(jwtauth.Authenticator)\n            r.Put(\"/\", rs.Put)       // PUT /{resource}/{cid} - update a single resource by cid\n            r.Delete(\"/\", rs.Delete) // DELETE /{resource}/{cid} - delete a single resource by cid\n        })\n    })\n})\n\n```. ",
    "mmatczuk": "Hello @pkieltyka do you have any thoughts on this PR?. @VojtechVitek could this be moved in-house under github.com/go-chi/chi/param as it's needed in almost any case.. ",
    "robxyy": "resolve:\ngo\nr.Mount(\"/users\", NewUserHandler().Mux). ",
    "cryptix": "From looking at https://github.com/peterbourgon/vmain and /vtest, I don't think the actual version folder is needed.. ",
    "kron4eg": "Chi could have new major release v4, which will address this \"1 import path == 1 major version\" requirement.... ",
    "Gyllsdorff": "Just keep in mind that vgo is a proposal, not yet accepted, still changing and a prototype so implementing it now might be kind of premature. If chi decides to go with the \"v3 subfolder in-sync with the rest of the repo\" idea there will be a major risk that the \"/v3\" folder will end-up out of sync with the rest of the code and it will require effort and changes in all incoming PR:s.\nPeople where certain dep would be merged into golang but we all know how that ended up. I would consider waiting until vgo becomes bit more mature.\nhttps://github.com/golang/go/wiki/vgo#current-state\n\nCurrent state\nCurrently vgo is in active development / prototype phase. It has some rough edges, changes will happen at a rapid pace. . \n",
    "mwf": "Hi, guys!\nI was experimenting a bit around vgo this days. I'm also looking forward adopting go.mod and vgo on early stage to collect all possible bugs in advance, before go1.11 is released :)\nI played around the fork of chi and it seems there is a way for both keeping version 3.x and adopting go.mod and new semver imports - just adding a v3 symlink to the project root. Old go versions are happy - they are able to find the \"new\" imports out of box.\nPlease take a look at my fork https://github.com/mwf/chi and a test project https://github.com/mwf/goplay/tree/master/vgo/chi\nThere are two options for users:\n- to use vgo as a vendoring tool (vgo mod -vendor) - vendor folder is populated in a way to make happy old go\n- just use the new version with their existing vendoring tools, symlink will make the magic - you could check it checking-out my master branch in the $GOPATH.\nWhat do you think about it? If it seems OK for you I'll be glad to make a PR :). Opened a PR in case you consider it a good way to go.. golang/go#26238 is closed, and you can try go1.11beta2 - we don't need go.mod to make the go1.11 users happy - old v2+ repos work with new go out-of-box.\n``\ncdmktemp -d`\ngo mod -init -module example.com/hello\ncat <hello.go\npackage main\nimport (\n        \"github.com/go-chi/chi\"\n)\nfunc main() {\n        _ = chi.NewRouter()\n}\nEOD\ngo build\n`go.mod` ends up as:\n$ cat go.mod\nmodule example.com/hello\nrequire github.com/go-chi/chi v3.3.2+incompatible\n```\nSo we can add go.mod in chi v4, just when you decide it's a good time for import path change.. > However, I'm not a big fan of having to change the import paths everywhere to the /v3 suffix. It affects the middleware subpkg too, as seen in the changeset. We need to be VERY careful not to break existing go ecosystem that is not aware of Go modules -- can they still use this project \"as is\" without the \"/v3\" suffix?\nYeap,  pre-go1.9.7 versions can use the project \"as is\", if they are on Unix, as commented above. I don't see a quick-win way for Windows users though.\n\nThe \"v3\" directory symlink hack may not work for everyone. Or is that a recommended approach for the v2+ projects that are adopting vgo?\n\nNo, the only recommended approach I've seen yet is to use go1.9.7+ and go1.10.3+. But this approach works :) \nThere is a possibility, that it can break some opensource toolset (maybe goimports for example?), but only in case if the author didn't think about symlinks resolving. It could be considered a bug in the toolset, not in the project.. > so where do the require's for golang.org/x/net and /text come from?\nhttps://github.com/go-chi/chi/blob/master/middleware/middleware18_test.go#L12\nWe're using golang.org/x/net in tests.\ngo.mod doesn't make a difference between test and regular dependencies.\nActually, it's OK, because it doesn't force anyone to use your particular dependency version, it's just a minimal version.. @VojtechVitek sorry for answering so long, I was terribly busy these days :(\n\nI don't think so. Afaik, the Unix users would have to switch to \"/v3\" suffix everywhere too, since the middleware package imports the \"suffixed\" github.com/go-chi/chi/v3. Without this change, this PR wouldn't really work \"as is\" in older versions than go 1.10.3 or go 1.9.7.\n\nActually, you're not quite right. Old go users on Unix won't have to do anything with their imports if they get this version.\nPlease take a look at this test project https://github.com/mwf/chi-test-go1.8\nI download go1.8 there and my fork to vendor - everything works just fine. You can test the same with any version you want.\nSo the only real stopper for the symlink way are Windows users.. Adding a ref to https://github.com/golang/go/issues/26238\nGo authors seem to understand the pain, so maybe they will start picking latest tagged version in automatic imports.\nSo users won't suffer from missmatched versions after vgo mod -init && vgo mod -sync and we won't need adding go.mod until you decide to drop older go version support and release v4 with Semantic Import Versioning.\nLet's watch where it leads us.. golang/go#26238 is closed, and you can try go1.11beta2 - we don't need go.mod to make the go1.11 users happy - old v2+ repos work with new go out-of-box.. Yeap, it's a symlink.\nUnfortunately, I don't have Windows to check. But I bet it doesn't work on Windows.\nAnyway, the official approach is to use go 1.9.7+ or go 1.10.3+ and drop support of older versions.\nAnd with this symlink we give Unix users with older go versions a chance to keep using it for a while.\nAs you can see, CI with go 1.7.x and 1.8.x passed successfully. It's used in golang.org/x/net undercover, for Unicode support.\ngolang.org/x/net haven't adopted go.mod yet, so golang.org/x/text resolving appears here.\nAs soon as go.mod is introduced in golang.org/x/net and you update it, transitive dependency will go away automatically.. ",
    "thepudds": "FYI, I added a comment https://github.com/golang/go/issues/25967#issuecomment-407567904 to the go issue @VojtechVitek had spawned from this go-chi issue. \nIn that comment I attempted to explain the new (and better!) behavior for a user using modules who needs to go get go-chi now that another related issue golang/go#26238 is resolved (as of last week/go11.1beta2), given go-chi is >= v2 and has not converted to modules itself.\nedit: sorry! I should have refreshed this issue page before adding my comment here. I now see @mwf just wrote a similar comment as mine here.. ",
    "theckman": "The Gofrs are also of the same opinion after we bungled adding modules to one of our packages. \n@VojtechVitek  @pkieltyka  As an FYI, when your package version is greater than 1 you must do a major version bump to add modules support. Meaning it will need to be chi v5. We didn't realize this in the Gofrs and was what the bungled addition. We aren't comfortable forcing a major version bump for a still experimental feature.. ",
    "karupanerura": "@pkieltyka how do you think?. OK. I'm waiting for you. Thank you.. ",
    "asydorchuk": "Hi, I meant request payload.\nNot sure how to make it configurable per route. How about I start with making it configurable per Logger instance?. ",
    "wayneashleyberry": "I just ran into the same issue, here's a simple example:\n```go\npackage main\nimport (\n    \"fmt\"\n    \"net/http\"\n\"github.com/go-chi/chi\"\n\n)\nfunc main() {\n    r := chi.NewRouter()\nr.Route(\"/foo\", func(r chi.Router) {\n    r.Get(\"/bar\", func(w http.ResponseWriter, r *http.Request) {\n        fmt.Fprintf(w, \"Hello, %s!\", \"World\")\n    })\n})\n\nchi.Walk(r, func(method string, route string, handler http.Handler, middlewares ...func(http.Handler) http.Handler) error {\n    fmt.Printf(\"%s: %s\\n\", method, route)\n    return nil\n})\n\nhttp.ListenAndServe(\":3000\", r)\n\n}\n```\nThis programme will output GET: /foo/*/bar which is incorrect. It should be GET: /foo/bar. ",
    "carldunham": "But those are two different route specifications. In my use case (and many, I egocentrically assume), there are cases like the ones I listed where wildcards could be stripped out and others where they should not.. ",
    "yudao": "Sorry, it was the return value which was not set in the endpoints handlers.\nSometimes a break is necessary :). ",
    "dahankzter": "Ok, fine. I find it very strange however. It is a very small patch that covers a lot of use cases.. The caller can create any closure that simply returns the payload that they want. This can be dynamic or static as the user sees fit.\nWe could modify a local copy for our need but if possible evolving the shared repository of middlewares is good imho. . ",
    "oceanicdev": "Hey guys. It is a good idea and I can help with implementation as well.. @VojtechVitek hello, can I take the initiative and implement it today? How do you think of this idea: if the value from path is empty then we try to get value from query string and then we cast that to necessary type. Otherwise, we will have Int64, QueryInt64 and etc.. @lansana, @VojtechVitek thanks guys :) I need it urgently so I will complete that today :). @lansana, @VojtechVitek Let's try to use that :) I will add tests later because now I do not have so much time :) Anyway, we can work on it together.. ",
    "Adirio": "I think this change should not break the API at all as both func(http.ResponseWriter, *http.Request)s and http.HandlerFuncs are admited in both signatures as proven in this playground. I made a registry just to have some struct to hold the functiosn with the different signatures. I included a third kind of signature accepting http.Handlers directly and provided a non-http.HandlerFunc implementation of http.Handler.\nI would then suggest, for consistency's shake and to avoid future missunderstandings, to keep the signature the same as net/http.\nPS: By the way this also applies to methods such as chi.NewRouter().Get(...). ",
    "polyfloyd": "Ah yes, Runtime initialization seems like a good middle way to implement support Brotli until we have a native Go encoder.. Alright, I've added a new patch to support dynamic addition of encoders. Let me know what you think :). @pkieltyka I've added an example in one of the comments on how to set up Brotli compression.. I do not believe it is waiting for me! @VojtechVitek?. ",
    "nicksrandall": "Is this PR waiting on anything before it can be merged?. Is this PR waiting on anything before it can be merged? I would like to use this feature. Thank you!. ",
    "0xbkt": "When this is going to be merged?. Contexts are generally used to carry custom data among handlers. No form or query data should be carried on top of contexts in root handlers, likewise it's not documented anywhere so.\nBesides, if you will not inspect the form data, you can take advantage of FormValue or PostFormValue where ParseForm is run if necessary.\nRender middleware just smooths the way by deserializing and binding the data into structs. It uses the same thing under the hood.. ",
    "myitcv": "@VojtechVitek I commented in https://github.com/golang/go/issues/25967#issuecomment-403544533. ",
    "pswenson": "aha, diff repo.  thanks!. ",
    "Daniel-M": "Could it be that, somehow, vgo rewrites the middleware signature from the expected http.handler to the chi.Handler? the relevant portion of the code which throws the panic is,\n(line 83 of github.com/go-chi/chi@v1.0.0/util.go)\n// Runtime type checking of the middleware signature\nfunc assertMiddleware(middleware interface{}) interface{} {\n    switch t := middleware.(type) {\n    default:\n        panic(fmt.Sprintf(\"chi: unsupported middleware signature: %T\", t))\n    case func(http.Handler) http.Handler:\n    case func(Handler) Handler:\n    }\n    return middleware\n}. @VojtechVitek Actually just found out this by myself and was about to close this issue\nThe solution was to change go.mod as:\nrequire (\n    github.com/go-chi/chi v2.0.0\n    github.com/pressly/chi v2.0.0\n        ...\n). @VojtechVitek Oh, thanks, which version should I use then?. The following worked for me\n``\nrequire (\n    github.com/go-chi/chi v3.3.2\n.... ",
    "titpetric": "Another example in the wild, django in debug mode:\n\nThis one comparatively just prints the routes to the browser, in case you hit a 404 (which usually for APIs is also the root URL / since endpoints are usually prefixed with things like /account, /users, etc.).\nThere are obvious differences between the server-side and the client-side route print in intent, but both are very usable when you're either 1) looking for the implementation of an endpoint, or 2) figuring out which endpoints are available just by opening and navigating the 404 pages.. @pkieltyka no, i'm using pretty much the same code snippet as above, here. I'll take a look at docgen to see if I can use the docgen as the 404 page like django does in the above example. Thanks.. ",
    "rocanion": "Template support in Go is provided by https://golang.org/pkg/text/template/  and https://golang.org/pkg/html/template/\nThe second one builds on the first so for HTML template handling you'll want to use both.\nI believe that the chi Render middleware includes them but I have found that the chi Render is fairly limited and therefore I am using github.com/unrolled/render because it lets me use template helpers, and provides an obvious way to include style sheets, javascript, and images. I could not figure out how to do those things wit the chi Render middleware.\nYour questions about login, authentication and session handling are much more complex. If you have not already written code to do those things in other languages then you first need to learn the basics of how to perform those operations.. I figured it out and as a result will suggest a revision to examples that show a POST operation. The code in the REST example is unclear and is more complex than necessary. Here's the code snippet that works:\nfunc GeneralSearch(w http.ResponseWriter, r *http.Request) {\n    r.ParseForm()\n    query := r.Form.Get(\"query\")\n    if query == \"\" {\n        glog.Error(\"Search query not found!\")\n        return\n    }\n}. I knew that I should not be trying to add my own content into contexts because that data should be request-specific. Somewhere I had thought that I got a hint that form data would be in the context. Clearly I was wrong.\nPerhaps the documentation of how to use he Render middleware is unclear then because I found it very confusing. It seems much simpler to just use the http.Request methods. I could not determine, from docs, precisely what the deserializing and binding would create for a struct. Without knowing that detail the struct that is created is not very useful.. FYI, I found a workaround for now, but strongly feel that this should be in the core code.\nI add this middleware hook:\nrouter.Use(putConversion)\nAnd the putConversion code looks like this:\n// putConversion is a middleware component that checks for the combination of a\n// POST method with a form field named _method having a value of PUT. This is the\n// convention for how to establish a PUT method for form submission in a restful API.\n// It should run early in the middleware stack.\nfunc putConversion(next http.Handler) http.Handler {\n    return http.HandlerFunc(\n        func(w http.ResponseWriter, r *http.Request) {\n            if r.Method == \"POST\" {\n                r.ParseForm()\n                if r.Form[\"_method\"] != nil && r.FormValue(\"_method\") == \"PUT\" {\n                    r.Method = \"PUT\"\n                }\n            }\n            next.ServeHTTP(w, r)\n        })\n}\n. If you don't plan to add this to the code then at least document it so that other people don't encounter the problem and have to figure it out themselves.. Ah, Vojtech you have a bit more to learn then.\nThe REST model is based on the use of various http methods for the different CRUD actions like this:\n- POST is used for Create\n- GET is used for Read\n- PUT is used for Update\n- DELETE is used for Delete\nNow while your observation about only POST and GET being actually used in HTML forms is somewhat accurate (there are browsers that fully support more methods) there are ways that have been devised to support additional http methods such as PUT.\nNOTE: the DELETE method is not allowed in forms.\nTo implement a PUT method in a form you specify the form\u2019s method as POST and then create a hidden input variable to indicate that the form data should be handled as a PUT operation. Here\u2019s an example\n<form action=\"/user/1234\" method=\"POST\">\n<input type=\"hidden\" name=\"_method\" value=\"PUT\">\n... form data tags are here ...\n</form>\nBecause the Chi router is defined as supporting these different methods for creating RESTful code my argument is that proper support for the detection and handling of the PUT method should be part of the Chi core. Otherwise you allow people to define a route using Put() but the code fails to process it correctly. Refer to my earlier comments in this thread for the specific details.\nFrom the perspective of creating a proper REST API you cannot use POST for everything. As an example let's consider the following chi routing rule set that would be typical of a REST API:\nrouter := chi.NewRouter()\nrouter.Get(\"/user\", ListAllUsers)\nrouter.Get(\"/user/{id}\", ShowUser)\nrouter.Post(\"/user\", CreateUser)\nrouter.Put(\"/user/{id}\", UpdateUser)\nrouter.Delete(\"/user/{id}\", DeleteUser)\nYou can see from the above that there is a clear distinction between the creation of a new user and updating an existing user. Using POST for both create and update operation breaks the REST model.\nYou mention that you recommend not changing the method in my middleware. If I do not do that then the chi Put() routing handler is totally useless and may as well be thrown out.\nYou may find these references to be educational:\nhttps://developer.mozilla.org/en-US/docs/Web/HTTP/Methods\nhttps://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods\nDoes this help?. Ah, my apologies for the wrong tone. I'm trying to be helpful here. I love chi and think it is a great set of packages and my goal is to help it to be even better. That's why I'm taking the time to comment on this. There is no intent to have this be a stackoverflow type of discussion.\nYou can see some of the history of how the put handling I implemented came to be in this discussion about the implementation of PUT in HTML forms:\nhttps://www.w3.org/Bugs/Public/show_bug.cgi?id=10671\nIn particular refer to comment 4 by Mike Amundsen\nTo directly answer the question about RFCs for handling a PUT - there are none. This is simply a convention established as a workaround for not having direct support for the PUT method in a form.\nAnyway, I'm really just trying to help improve things, so if I offended then that was not intentional on my part.. Okay, I\u2019ll do that.\n\nOn Oct 30, 2018, at 11:04, Vojtech Vitek notifications@github.com wrote:\nI recommend creating a new repo with the func putConversion(next http.Handler) http.Handler { middleware, motivation and bunch of examples. We can link it back from this conversation.\nThanks\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub https://github.com/go-chi/chi/issues/355#issuecomment-434336644, or mute the thread https://github.com/notifications/unsubscribe-auth/AAADMqHAyUeUD5UK_1q2-rqcZD6dB-ovks5uqGqEgaJpZM4X6kjQ.\n\n\n. ",
    "vearutop": "@nhooyr yes, if the handler implements a specific interface, I want to wrap it with automatic request decoder. \nIt turned out overriding handle() would not help, because of new non-wrapped *chi.Mux instances created along the tree. And wrapping the router for handler pre-processing is not that much of code.\nThis is what I ended up with:\n```go\n// Wrapper wraps chi.Router to pre-process http.Handler and add support for ActionHandler\ntype Wrapper struct {\n    chi.Router\n    PrepareHandler func(handler http.Handler) http.Handler\n}\nvar _ chi.Router = &Wrapper{}\nfunc (r Wrapper) copy(router chi.Router) Wrapper {\n    return &Wrapper{\n        Router:         router,\n        PrepareHandler: r.PrepareHandler,\n    }\n}\n// With adds inline middlewares for an endpoint handler\nfunc (r *Wrapper) With(middlewares ...func(http.Handler) http.Handler) chi.Router {\n    return r.copy(r.Router.With(middlewares...))\n}\n// Group adds a new inline-Router along the current routing\n// path, with a fresh middleware stack for the inline-Router\nfunc (r *Wrapper) Group(fn func(r chi.Router)) chi.Router {\n    im := r.copy(r.With())\n    if fn != nil {\n        fn(im)\n    }\n    return im\n}\n// Route mounts a sub-Router along a `pattern`` string.\nfunc (r *Wrapper) Route(pattern string, fn func(r chi.Router)) chi.Router {\n    subRouter := r.copy(chi.NewRouter())\n    if fn != nil {\n        fn(subRouter)\n    }\n    r.Mount(pattern, subRouter)\n    return subRouter\n}\n// Mount attaches another http.Handler along ./pattern/\nfunc (r Wrapper) Mount(pattern string, h http.Handler) {\n    r.Router.Mount(pattern, r.PrepareHandler(h))\n}\n// Handle adds routes for pattern that matches all HTTP methods\nfunc (r *Wrapper) Handle(pattern string, h http.Handler) {\n    r.Router.Handle(pattern, r.PrepareHandler(h))\n}\n// Method adds routes for pattern that matches the method HTTP method\nfunc (r *Wrapper) Method(method, pattern string, h http.Handler) {\n    r.Router.Method(method, pattern, r.PrepareHandler(h))\n}\n// Action adds one or more HTTPAction for h.Pattern() that matches the h.HTTPMethod() HTTP method\nfunc (r *Wrapper) Action(handlers ...rest.HTTPAction) {\n    for _, h := range handlers {\n        r.Router.Method(h.HTTPMethod(), h.Pattern(), r.PrepareHandler(h))\n    }\n}\n```. ",
    "piotrkubisa": "I don't think it is a bug but a feature. Code in TestReturnFuncMiddleware's handler won't be executed, because your request does not come with Content-Type header with charset specified (i.e. application/json; charset=utf-8) and it will bailout on middleware that you have attached. To fix your tests you only need to specify charset before making a request.\n```go\nfunc TestReturnFuncMiddleware(t testing.T) {\n    r := chi.NewRouter()\n    r.Use(middleware.ContentCharset(\"UTF-8\"))\n    var id string\n    r.Get(\"/items/{id}\", func(w http.ResponseWriter, r http.Request) {\n        id = chi.URLParam(r, \"id\")\n    })\nreq, _ := http.NewRequest(\"GET\", \"/items/1\", nil)\nreq.Header.Set(\"Content-Type\", \"application/json; charset=utf-8\")\nw := httptest.NewRecorder()\nr.ServeHTTP(w, req)\nif id == \"\" {\n    t.Fatal(\"id missing\")\n}\n\n}\n// === RUN   TestReturnFuncMiddleware\n// --- PASS: TestReturnFuncMiddleware (0.00s)\n// PASS\n// ok   github.com/go-chi/chi/middleware    0.009s\n```\nEdit: middleware.ContentCharset is kind of middleware (executed before handler) not a afterware (executed after handler).. I don't know if it is feature or not but I tried to be more pushy and put into param some weird value:\n\nI don't know if it is feature or not, but I'd go with the following code:\n```go\npackage main\nimport (\n    \"fmt\"\n    \"net/http\"\n\"github.com/go-chi/chi\"\n\n)\nfunc main() {\n    r := chi.NewRouter()\n    r.Route(\"/{param:[0-9]+}\", func(r chi.Router) {\n        r.Get(\"/{param}\", func(w http.ResponseWriter, r *http.Request) {\n            w.Write([]byte(fmt.Sprintf(\"Hi: %s\", chi.URLParam(r, \"param\"))))\n        })\n    })\n    http.ListenAndServe(\":3000\", r)\n}\n```\nSome tests:\n\n\n\n\n. > @piotrkubisa r.Route should be used to group routes with common prefix together. It becomes useless if you have to repeat param in all children.\nI know it it quite weird that you need to repeat yourself in any sub-route to pass the same param. In my example I have presented how to initialize param validation on the router side. The {param} in r.Get has the same validation regex as in the r.Route.\nPersonally, I don't know why chi works in this way but I haven't had any complex use-case to find it out the problem. I hope some maintainer will shed some light on this feature :wink: \n\nAlso I should mention that if you rely on regex for validation and do not check input further before using it in sql, this could be a serius security issue.\n\nI partially understand your point. It is clear that sometimes you need to enforce various checks against ownership and generally speaking a correct input  of the HTTP request. In chi and in many packages in various languages there are various types of middlewares or middleware-like-funcs which are included in router or implemented directly in the handler to take care of input validation/sanitization. Could you tell me what do you exactly mean?. The problem arises when you are going to use my implementation in following way:\n```go\nfunc main() {\n    r := chi.NewRouter()\nr.Route(\"/{param:[0-9]+}\", func(r chi.Router) {\n    r.Get(\"/{param}/posts\", func(w http.ResponseWriter, r *http.Request) {\n        w.Write([]byte(fmt.Sprintf(\"Hi: %s\", chi.URLParam(r, \"param\"))))\n    })\n    r.Get(\"/{param}/profile\", func(w http.ResponseWriter, r *http.Request) {\n        w.Write([]byte(fmt.Sprintf(\"Hi: %s\", chi.URLParam(r, \"param\"))))\n    })\n})\nhttp.ListenAndServe(\":3000\", r)\n\n}\n```\nIn that scenario my code does not work as I stated in previous post. \nGET http://localhost:3000/12/posts\n404 page not found\nGET http://localhost:3000/123/12/posts\nHi: 12\n. In chi (like many other Go stdlib compatible routers) you have to memorize the acronym of Header-Status-Payload (HSP) acronym (just like TopRightBottomLeft in CSS). To illustrate the problem take a look at following unit test: https://gist.github.com/piotrkubisa/4b99eab4257f729abce8db853966b155. ",
    "pinzolo": "@piotrkubisa Thanks. I understand my mistake.\nI close this issue.. ",
    "maddie": "I have worked around this problem by appending an extra / to the path (both in chi and front end), i.e.\nr.Get(\"/api/query/{keyword}/\", queryHandler)\nBut I was expecting it to behave like pre-v3 versions (empty URL parameter works without trailing slash).. ",
    "awulkan": "Trie is correct though, and a lot of people call it that.\n\nIn computer science, a radix tree (also radix trie or compact prefix tree) is a data structure that represents a space-optimized trie (prefix tree) in which each node that is the only child is merged with its parent.\n\nhttps://en.wikipedia.org/wiki/Radix_tree. ",
    "dandee": "It seems that it goes back deeper until version 3.1.0:\n(edited Gopkg.toml file to require the following versions of 'chi': \"3.3\", \"3.2\", \"3.1\")\ncd src/prjkt-api && GOPATH=/Users/danielk/Work/prjkt /usr/local/bin/dep ensure\nSolving failure: No versions of github.com/go-chi/chi met constraints:\n    v3.3.3: Could not introduce github.com/go-chi/chi@v3.3.3, as its subpackage github.com/go-chi/chi/render is missing. (Package is required by (root).)\n    v3.3.2: Could not introduce github.com/go-chi/chi@v3.3.2, as its subpackage github.com/go-chi/chi/render is missing. (Package is required by (root).)\n    v3.3.1: Could not introduce github.com/go-chi/chi@v3.3.1, as its subpackage github.com/go-chi/chi/render is missing. (Package is required by (root).)\n    v3.3.0: Could not introduce github.com/go-chi/chi@v3.3.0, as its subpackage github.com/go-chi/chi/render is missing. (Package is required by (root).)\n    v3.2.1: Could not introduce github.com/go-chi/chi@v3.2.1, as it is not allowed by constraint ^3.3.0 from project prjkt-api.\n    v3.2.0: Could not introduce github.com/go-chi/chi@v3.2.0, as it is not allowed by constraint ^3.3.0 from project prjkt-api.\n    v3.1.5: Could not introduce github.com/go-chi/chi@v3.1.5, as it is not allowed by constraint ^3.3.0 from project prjkt-api.\n    v3.1.4: Could not introduce github.com/go-chi/chi@v3.1.4, as it is not allowed by constraint ^3.3.0 from project prjkt-api.\n    v3.1.3: Could not introduce github.com/go-chi/chi@v3.1.3, as it is not allowed by constraint ^3.3.0 from project prjkt-api.\n    v3.1.2: Could not introduce github.com/go-chi/chi@v3.1.2, as it is not allowed by constraint ^3.3.0 from project prjkt-api.\n    v3.1.1: Could not introduce github.com/go-chi/chi@v3.1.1, as it is not allowed by constraint ^3.3.0 from project prjkt-api.\n    v3.1.0: Could not introduce github.com/go-chi/chi@v3.1.0, as it is not allowed by constraint ^3.3.0 from project prjkt-api.\n    v3.0.0: Could not introduce github.com/go-chi/chi@v3.0.0, as it is not allowed by constraint ^3.3.0 from project prjkt-api.\n    v2.1.0: Could not introduce github.com/go-chi/chi@v2.1.0, as it is not allowed by constraint ^3.3.0 from project prjkt-api.\n    v2.0.0: Could not introduce github.com/go-chi/chi@v2.0.0, as it is not allowed by constraint ^3.3.0 from project prjkt-api.\n    v1.0.0: Could not introduce github.com/go-chi/chi@v1.0.0, as it is not allowed by constraint ^3.3.0 from project prjkt-api.\n    v0.9.0: Could not introduce github.com/go-chi/chi@v0.9.0, as it is not allowed by constraint ^3.3.0 from project prjkt-api.\n    master: Could not introduce github.com/go-chi/chi@master, as it is not allowed by constraint ^3.3.0 from project prjkt-api.\n    v1: Could not introduce github.com/go-chi/chi@v1, as it is not allowed by constraint ^3.3.0 from project prjkt-api.\n    v2: Could not introduce github.com/go-chi/chi@v2, as it is not allowed by constraint ^3.3.0 from project prjkt-api.\n    v2.0.0rc1: Could not introduce github.com/go-chi/chi@v2.0.0rc1, as it is not allowed by constraint ^3.3.0 from project prjkt-api.\nmake: *** [src/prjkt-api/Gopkg.lock] Error 1\n\u279c  prjkt \u2717 make build\ncd src/prjkt-api && GOPATH=/Users/danielk/Work/prjkt /usr/local/bin/dep ensure\nSolving failure: No versions of github.com/go-chi/chi met constraints:\n    v3.3.3: Could not introduce github.com/go-chi/chi@v3.3.3, as its subpackage github.com/go-chi/chi/render is missing. (Package is required by (root).)\n    v3.3.2: Could not introduce github.com/go-chi/chi@v3.3.2, as its subpackage github.com/go-chi/chi/render is missing. (Package is required by (root).)\n    v3.3.1: Could not introduce github.com/go-chi/chi@v3.3.1, as its subpackage github.com/go-chi/chi/render is missing. (Package is required by (root).)\n    v3.3.0: Could not introduce github.com/go-chi/chi@v3.3.0, as its subpackage github.com/go-chi/chi/render is missing. (Package is required by (root).)\n    v3.2.1: Could not introduce github.com/go-chi/chi@v3.2.1, as its subpackage github.com/go-chi/chi/render is missing. (Package is required by (root).)\n    v3.2.0: Could not introduce github.com/go-chi/chi@v3.2.0, as its subpackage github.com/go-chi/chi/render is missing. (Package is required by (root).)\n    v3.1.5: Could not introduce github.com/go-chi/chi@v3.1.5, as it is not allowed by constraint ^3.2.0 from project prjkt-api.\n    v3.1.4: Could not introduce github.com/go-chi/chi@v3.1.4, as it is not allowed by constraint ^3.2.0 from project prjkt-api.\n    v3.1.3: Could not introduce github.com/go-chi/chi@v3.1.3, as it is not allowed by constraint ^3.2.0 from project prjkt-api.\n    v3.1.2: Could not introduce github.com/go-chi/chi@v3.1.2, as it is not allowed by constraint ^3.2.0 from project prjkt-api.\n    v3.1.1: Could not introduce github.com/go-chi/chi@v3.1.1, as it is not allowed by constraint ^3.2.0 from project prjkt-api.\n    v3.1.0: Could not introduce github.com/go-chi/chi@v3.1.0, as it is not allowed by constraint ^3.2.0 from project prjkt-api.\n    v3.0.0: Could not introduce github.com/go-chi/chi@v3.0.0, as it is not allowed by constraint ^3.2.0 from project prjkt-api.\n    v2.1.0: Could not introduce github.com/go-chi/chi@v2.1.0, as it is not allowed by constraint ^3.2.0 from project prjkt-api.\n    v2.0.0: Could not introduce github.com/go-chi/chi@v2.0.0, as it is not allowed by constraint ^3.2.0 from project prjkt-api.\n    v1.0.0: Could not introduce github.com/go-chi/chi@v1.0.0, as it is not allowed by constraint ^3.2.0 from project prjkt-api.\n    v0.9.0: Could not introduce github.com/go-chi/chi@v0.9.0, as it is not allowed by constraint ^3.2.0 from project prjkt-api.\n    master: Could not introduce github.com/go-chi/chi@master, as it is not allowed by constraint ^3.2.0 from project prjkt-api.\n    v1: Could not introduce github.com/go-chi/chi@v1, as it is not allowed by constraint ^3.2.0 from project prjkt-api.\n    v2: Could not introduce github.com/go-chi/chi@v2, as it is not allowed by constraint ^3.2.0 from project prjkt-api.\n    v2.0.0rc1: Could not introduce github.com/go-chi/chi@v2.0.0rc1, as it is not allowed by constraint ^3.2.0 from project prjkt-api.\nmake: *** [src/prjkt-api/Gopkg.lock] Error 1\n\u279c  prjkt \u2717 make build\ncd src/prjkt-api && GOPATH=/Users/danielk/Work/prjkt /usr/local/bin/dep ensure\nSolving failure: No versions of github.com/go-chi/chi met constraints:\n    v3.3.3: Could not introduce github.com/go-chi/chi@v3.3.3, as its subpackage github.com/go-chi/chi/render is missing. (Package is required by (root).)\n    v3.3.2: Could not introduce github.com/go-chi/chi@v3.3.2, as its subpackage github.com/go-chi/chi/render is missing. (Package is required by (root).)\n    v3.3.1: Could not introduce github.com/go-chi/chi@v3.3.1, as its subpackage github.com/go-chi/chi/render is missing. (Package is required by (root).)\n    v3.3.0: Could not introduce github.com/go-chi/chi@v3.3.0, as its subpackage github.com/go-chi/chi/render is missing. (Package is required by (root).)\n    v3.2.1: Could not introduce github.com/go-chi/chi@v3.2.1, as its subpackage github.com/go-chi/chi/render is missing. (Package is required by (root).)\n    v3.2.0: Could not introduce github.com/go-chi/chi@v3.2.0, as its subpackage github.com/go-chi/chi/render is missing. (Package is required by (root).)\n    v3.1.5: Could not introduce github.com/go-chi/chi@v3.1.5, as its subpackage github.com/go-chi/chi/render is missing. (Package is required by (root).)\n    v3.1.4: Could not introduce github.com/go-chi/chi@v3.1.4, as its subpackage github.com/go-chi/chi/render is missing. (Package is required by (root).)\n    v3.1.3: Could not introduce github.com/go-chi/chi@v3.1.3, as its subpackage github.com/go-chi/chi/render is missing. (Package is required by (root).)\n    v3.1.2: Could not introduce github.com/go-chi/chi@v3.1.2, as its subpackage github.com/go-chi/chi/render is missing. (Package is required by (root).)\n    v3.1.1: Could not introduce github.com/go-chi/chi@v3.1.1, as its subpackage github.com/go-chi/chi/render is missing. (Package is required by (root).)\n    v3.1.0: Could not introduce github.com/go-chi/chi@v3.1.0, as its subpackage github.com/go-chi/chi/render is missing. (Package is required by (root).)\n    v3.0.0: Could not introduce github.com/go-chi/chi@v3.0.0, as it is not allowed by constraint ^3.1.0 from project prjkt-api.\n    v2.1.0: Could not introduce github.com/go-chi/chi@v2.1.0, as it is not allowed by constraint ^3.1.0 from project prjkt-api.\n    v2.0.0: Could not introduce github.com/go-chi/chi@v2.0.0, as it is not allowed by constraint ^3.1.0 from project prjkt-api.\n    v1.0.0: Could not introduce github.com/go-chi/chi@v1.0.0, as it is not allowed by constraint ^3.1.0 from project prjkt-api.\n    v0.9.0: Could not introduce github.com/go-chi/chi@v0.9.0, as it is not allowed by constraint ^3.1.0 from project prjkt-api.\n    master: Could not introduce github.com/go-chi/chi@master, as it is not allowed by constraint ^3.1.0 from project prjkt-api.\n    v1: Could not introduce github.com/go-chi/chi@v1, as it is not allowed by constraint ^3.1.0 from project prjkt-api.\n    v2: Could not introduce github.com/go-chi/chi@v2, as it is not allowed by constraint ^3.1.0 from project prjkt-api.\n    v2.0.0rc1: Could not introduce github.com/go-chi/chi@v2.0.0rc1, as it is not allowed by constraint ^3.1.0 from project prjkt-api.\nmake: *** [src/prjkt-api/Gopkg.lock] Error 1\n. I know but I don't want to use go-chi/render. I wanted to get access to the most recent middleware so I tried to reference the most recent version of go-chi/chi and dep gives me the above shit. It seems to me that some dependencies hasn't been fixed properly after separation.. All right, so it turned out that it was my fault - there was some obscure file still referencing old renderer and it forced dep to select older packages. Turns out that dep is really smart figuring out all project's dependencies. Apologize for taking so much of your time. Thank you.. ",
    "pdedmon": "I also fixed the golint installation. (I had to do the same thing on some of my own repos this week.). Or maybe the condition is supposed to be if e != \"\"?. ",
    "sudo-suhas": "Thanks!. ",
    "rodney-b": "Agreed. Good to know about those.. Anything else?. Anything else?. ",
    "efarem": "I ran into something similar today using a single Get route resulting in a panic from chi.URLParam, example below.\ngolang\nfunc main() {\n    r := chi.NewRouter();\n    r.Get(\"/{type:(one|two|three)}/something\", func (w http.ResponseWriter, r *http.Request) {\n        w.Write([]byte(fmt.Sprintf(\"Hello %s\", chi.URLParam(r, \"type\"))))\n    })\n        http.ListenAndServe(fmt.Sprintf(\":%d\", 3000), r)\n}\nGET http://localhost:3000/one/something\nHello one\nGET http://localhost:3000//something\nruntime error: index out of range. ",
    "tscheckenbach": "Oh, my fault JSON does not allow new lines in string, so the frontend must convert them to \\n and all is fine.. ",
    "MetalBreaker": "Thanks for taking the time to reply.\nThe server doesn't panic. The only logs (even with \"trace\": \"verbose\") I get are these:\n\n(Using Delve debugger with Visual Studio Code)\nI don't really know the version of Chi, I installed it via go get last night.. \nIs this Chi v3?. I'm already using those, as you can see in the code I posted, and I can't see a panic that actually happens. I feel like I'm missing something. Maybe you misunderstood me; the server continues working after the 500 error like nothing happened (logger just logs a 500 error, posted above), I just find the 500 response a bit weird when for example, google.com/?q=<b> works and the default http handler produces the correct error code.. Ah, okay. Thanks. I appreciate the help :). ",
    "makhov": "I understood your point, but in this case we create a service which can panic at the random moment when someone send any http request. And developer don't know about this behavior. \nMaybe we should panic at service startup. I have no idea why Travis has failed the build. Previous PR also failed with the same error.. ",
    "SamWhited": "I'm sorry, my previous message was unclear and had a statement that was incorrect: Go 1.9.7+ and Go 1.10.3+ (eg. one version before the last supported version, which is 1.10) both support module import paths now. Even if you leave the path off, it will not break things. For example, your example from the documentation builds fine on Go 1.9.7, even with this PR merged.\nThis will NOT break compatibility with existing code.\neg. the following session can be run with this branch:\n```\n$ pwd\n/home/example/go/src/chiexample\n$ cat main.go \npackage main\nimport (\n        \"net/http\"\n    \"github.com/go-chi/chi\"\n    \"github.com/go-chi/chi/middleware\"\n\n)\nfunc main() {\n        r := chi.NewRouter()\n        r.Use(middleware.Logger)\n        r.Use(middleware.Recoverer)\n    r.Get(\"/\", func(w http.ResponseWriter, r *http.Request) {\n            w.Write([]byte(\"root.\"))\n    })\n\n    http.ListenAndServe(\":3333\", r)\n\n}\n$ GO111MODULE=off go get -u golang.org/dl/go1.9.7\n$ go1.9.7 download\n\n$ go1.9.7 build\n$ ls -la chiexample \n-rwxr-xr-x 1 example example 8944294 Nov 26 17:34 chiexample\n```. > You are assuming that chi will support Go 1.9.7+ and Go 1.10.3+ only from now on .. and that we'll silently drop support for 1.7, 1.8, 1.9.0, 1.10.0. We need community consensus on this -- please create an issue for this. This PR is indeed breaking backward compatibility.\nI had assumed those had just been left in the test matrix but weren't actually supported given that the Go team only supports the last two versions of Go. I'll open an issue.\n\nRE: Import paths .. thanks for the explanation. So even if we don't add the /v3 suffix, the import paths will work just fine? So why add the suffix in the first place, should this PR avoid adding it then?\n\nThis is for backwards compatibility, it works this way when using versions that don't have full module support. In go 1.9.7 we know where the library is (because we're looking it up in the GOPATH), and we can't import multiple versions of it without renaming the imports anyways, so it effectively just ignores the version suffix (if it's not an actual package that was named v3 or whatever).\nWith Go 1.11+ however, it doesn't use GOPATH so it uses the version suffix to decide which package to download.. > We don't want to ever break import paths of chi v3.x (by adding /v3 suffix) and break our users.\nThus, we'll stay on +incompatible flag, until v4.x is released (not planned at this point).\nHello,\nChi v4 was released, but it still doesn't have module support. Does this mean modules and the proper import path won't be supported until v5 for compatibility?\n(also asked on #378; sorry, I wasn't sure where the appropriate place to ask was). Since this is present in [a branch], can this PR be closed?\n[a branch]: https://github.com/go-chi/chi/tree/v4-dev-go-mod. Hello,\nChi v4 was released, but it still doesn't have module support. Does this mean modules and the proper import path won't be supported until v5 for compatibility?. Thank you for your answer; in my previous question I was told v4. I will find an alternative to chi for my own projects and for our corporate projects and reevaluate when Chi v5 is released. Thanks for all the hard work you've put in here.\nIf you need any help with module support feel free to ping me; there's really not all that much complexity to deal with and I'd be happy to walk you through it if support in v4 is still an option.. We have several tools in the same codebase that may not all be updated at once. Without the import compatibility rule we have to update them all at the same time to a single version of Chi instead of having one import chi and one import chi/v4, for example. TL;DR \u2014 Modules make incremental updates much easier.. I suspect it will be more overhead to maintain a fork than to just find another router that supports modules, but it's a fair point, we'll have to evaluate both options.. @pkieltyka I meant to say: I don't want to ask you for more work, but if you'd be willing to discuss or write up your thoughts on why modules were hard to implement I'm sure the Go team would really appreciate it. You could stick it on the https://github.com/golang/go/wiki/ExperienceReports page, or submit an issue and I can get it in the right hands and make sure it's seen.. > So, you should be able to update all of your tools at once without any trouble, either if it's a large monorepo, or if it's a bunch of small repos. Please, correct me if I'm wrong.\nIn this case, that is not a risk that we feel is acceptable. I don't know what problems might occur, but that's exactly the point, I don't know. Even if the libraries maintain full API compatibility updating all at once instead of incrementally means there's no time to monitor each component as it comes online for unexpected behavioral changes, panics, or any other bug or minor problem that might have been introduced as part of the upgrade. I'd much rather one service go down than the whole platform.. > That feels like a concern of your deployment strategy rather than of a Go pkg dependency to me.\nThat's correct; previously we were performing gradual updates using vendoring and GOPATH hacks. Now that we've updated to Go Modules this is much simpler, but we have two dependencies outstanding; one of which is Chi. I was waiting on v4, but if Modules are not going to be implemented I'm not sure if we can maintain both upgrade paths, but we'll have to experiment and decide if it's less risky to slowly migrate to something else that uses Modules, or maintain a second way of doing incremental upgrades on top of Modules. Any advice you have on doing this with Chi would be welcome.\n\nAnyway, I think you'd have to fork either chi v3 or chi v4 to make a gradual change to your codebase. There's no other way around for now.\n\nRight.. ",
    "harikb": "travis build is failing with an error https://travis-ci.org/go-chi/chi/jobs/460622264#L479 on Go 1.8 only but this seems unrelated to the changes above . @VojtechVitek please see updated pull request. Thanks.. I thought about this first. However I thought it was more intrusive change. The RequestID is maintained in a context variable keyed by a non-exported variable. Exporting that variable doesn't sound good either. So it would have a SetReqID() method inside the middleware which also takes the context as an explicit parameter, and set the given string as the request-id. Is that what you are looking for?  As for #368 , isn't there already a GetReqID() method available in the middleware?. Item 4 already exists. Please confirm if that is what you meant.\nSo the remaining change is to merge RequestIDFromHeader in to RequestID middleware. I wasn't sure if it would break any existing usage.. ",
    "frederikhors": "Same problem with https://github.com/cortesi/modd.\nIs there a way to force color in shell when chi doesn't detect it?. Thanks, I opened https://github.com/go-chi/chi/wiki/How-to-access-keys-in-Context%3F.. ",
    "cristaloleg": "\nI will find an alternative to chi for my own projects\n\nwhy +incompatible is a problem for you? (just curious).\nIt's the same version pinning AFAIK. Am I missing something?\n. What about forking chi (adding Go modules which is trivial) and using replace keyword in go.mod to use the fork?\n(probably this is out of scope of this issue). ",
    "uRevivals": "Hello,\nWe got the same problem, it's located with other chi like package in go-chi/jwtauth and go-chi/docgen that ref github.com/go-chi/chi/v4 which does not exists.. Works for me thanks for the reactivity! Do you know any way to freeze the package that we can use to avoid this problem in the future?. ",
    "5teven": "Same thing. Check out this page https://github.com/golang/go/wiki/PackageManagementTools . Hope will help to understand go dep management. ",
    "RXminuS": "For instance here: https://github.com/goadesign/goa/blob/4a2fb392efdacbce01a1b5f86826253ca5c3e97c/middleware/gzip/middleware.go#L330. @pkieltyka I posted a quick'n dirty fix :-). ...mmm actually, there seems to be something else going on as well :-/ I need to investigate more. AH! defer w.WriteHeader(code) doesn't work... defer w.ResponseWriter.WriteHeader(code) DOES work...don't quite understand why though, must be something that goes wrong in the encapsulation...\n. My best guess is because of the naming conflict (overloading the WriteHeader method)...similar to what they are discussing here https://stackoverflow.com/questions/38513779/extending-golangs-http-responsewriter-functionality-to-pre-post-process-respons. ",
    "AdamHepner": "Ohhh, this had me going chase my tail for days now! \nIf this is any consolation, here's a minimal reproduction: https://gist.github.com/AdamHepner/03b9addac10c47534bd3392cb0e069e1. ",
    "kromanow94": "Sorry for replaying so late! I'm just in the middle of my project for diploma, not having much time for anything else.\nYes, I do. This is my router:\ngo\nrouter.Use(                                       \n    render.SetContentType(render.ContentTypeJSON),\n    middleware.Logger,\n    middleware.DefaultCompress,\n    middleware.RedirectSlashes,\n    middleware.Recoverer,\n). It does work now with master, thank you! :). ",
    "tomocy": "Thanks for commenting!\nI understand, so I close and will move that middleware in my repo. ",
    "PumpkinSeed": "I will look into where is the best to insert this test and push into the PR.. ",
    "milesje": "@pkieltyka in this test case I'm not wanting to actually render any content. I'm just trying to have it return a 401 status code. I can add a render method but it still always returns a 200 OK status.. Updated the code to include a call to render.Render and it still returns a 200 OK instead of a 401! The problem/question is still the same, how do you get it to return something other than 200 OK!!!!\n```\npackage main\nfunc routes() *chi.Mux {\n    router := chi.NewRouter()\n    router.Use(\n        render.SetContentType(render.ContentTypeJSON),\n        middleware.Logger,\n        middleware.DefaultCompress,\n        middleware.RedirectSlashes,\n        middleware.Recoverer,\n        middleware.RealIP,\n    )\n    router.Get(\"/test\", test)\n    return router\n}\nfunc test(w http.ResponseWriter, r *http.Request) {\n    w.WriteHeader(401)\n    http.Error(w, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)\n    render.Status(r, 401)\n    render.Render(w, r, ErrInvalidRequest())\n    return\n}\ntype ErrResponse struct {\n    Err            error json:\"-\" // low-level runtime error\n    HTTPStatusCode int   json:\"-\" // http response status code\nStatusText string `json:\"status\"`          // user-level status message\nAppCode    int64  `json:\"code,omitempty\"`  // application-specific error code\nErrorText  string `json:\"error,omitempty\"` // application-level error message, for debugging\n\n}\nfunc (e ErrResponse) Render(w http.ResponseWriter, r http.Request) error {\n    render.Status(r, e.HTTPStatusCode)\n    return nil\n}\nfunc ErrInvalidRequest() render.Renderer {\n    return &ErrResponse{\n        // Err:            err,\n        HTTPStatusCode: 401,\n        StatusText:     \"Invalid request.\",\n        ErrorText:      \"Invalid request.\",\n    }\n}\nfunc main() {\n    router := routes()\nwalkFunc := func(method string, route string, handler http.Handler, middlewares ...func(http.Handler) http.Handler) error {\n    log.Printf(\"%s %s\\n\", method, route)\n    return nil\n}\nif err := chi.Walk(router, walkFunc); err != nil {\n    log.Panicf(\"Loggin err: %s\\n\", err.Error())\n}\nlog.Fatal(http.ListenAndServe(fmt.Sprintf(\":%d\", cfg.SrvPort), router))\n\n}\n. @pkieltyka I think I will just move on to a different Router at this point. I don't see how I can make it any simpler than the code posted above. I spent about 10 minutes with Gorilla Mux as well as with just using net/http and both of those work as expected.. @pkieltyka did you even look at my supplied code... I **AM** calling `render.Render()` which is how it renders the plain/text. However `render.Render()` does **NOT** set the actual HTTP Status to what was specified in `render.Status()`, nor does it preserve what is set using `w.WriteHeader(401)`. @pkieltyka \nOK, after looking over the examples and tests I have determined the problem/solution but I'm not 100% sure why it is or if it was intentional or not.\nIf I define my route as follows\nfunc routes() *chi.Mux {\n    router := chi.NewRouter()\n    router.Use(\n        render.SetContentType(render.ContentTypeJSON),\n        middleware.Logger,\n        middleware.DefaultCompress,\n        middleware.RedirectSlashes,\n        middleware.Recoverer,\n        middleware.RealIP,\n    )\n    router.Get(\"/test\", test)\n    return router\n}\nfunc test(w http.ResponseWriter, r http.Request) {\n    render.Status(r, 401)\n    render.Render(w, r, ErrInvalidRequest())\n}\nIt always returns a 200 OK for the responses status code.\nIf I make a simple change...\nfunc routes() chi.Mux {\n    router := chi.NewRouter()\n    router.Use(\n        render.SetContentType(render.ContentTypeJSON),\n        middleware.Logger,\n        middleware.DefaultCompress,\n        middleware.RedirectSlashes,\n        middleware.Recoverer,\n        middleware.RealIP,\n    )\n    router.Get(\"/test\", http.HandlerFunc(test))\n    return router\n}\nfunc test(w http.ResponseWriter, r *http.Request) {\n    render.Status(r, 401)\n    render.Render(w, r, ErrInvalidRequest())\n}\n``\nBy wrapping the call to the test function in ahttp.HandlerFunc` it now returns the specified response statusCode.\nSo my question is... Is this the intended functionality? If so fine I will have to add the wrapping of all of my routes in a http.HanderFunc. If not, you may need to add some test cases to the mux_test.go to check for this scenario. I found this by digging through the mux_test.go where all of the routes have the func to be called wrapped in the http.HanderFunc, but I did not see an documentation stating that this needs to be done.. @pkieltyka I would like to see your output as I installed GO on a completely separate laptop (MacBook Pro) and I'm still getting a 200 OK as the response.\n```\n curl --request GET  --url http://localhost:3333/test -i\nHTTP/1.1 200 OK\nContent-Type: application/json; charset=utf-8\nDate: Mon, 25 Feb 2019 21:22:50 GMT\nContent-Length: 57\n{\"status\":\"Invalid request.\",\"error\":\"Invalid request.\"}\n```\nThe texting being rendered is correct but the actual status code is still 200 OK, unless I use a http.HandlerFunc to wrap the call to the test function.. OK, so I just spun up my Ubuntu VM and ran this there and I do get the 401 status code. But if running the code on Windows or MacOS I get a 200 OK.\n```\ncurl --request GET --url http://172.16.1.34:3333/test -i\nHTTP/1.1 401 Unauthorized\nContent-Type: application/json; charset=utf-8\nDate: Mon, 25 Feb 2019 21:39:25 GMT\nContent-Length: 57\n{\"status\":\"Invalid request.\",\"error\":\"Invalid request.\"}\n``. I'm running these versions.\nWindows: go version go1.11.5 windows/amd64\nLinux: go version go1.11.5 linux/amd64\nMacOS: go version go1.11.4 darwin/amd64. Yes, it is curious! I would have expected all 3 system to behave the same.. @pkieltyka after some testing I have found that if I remove the middleware.DefaultCompress everything works as expected... it returns the 401 on all systems (Windows, Mac, & Linux). If I include the middleware.DefaultCompress than I get a 200 on Windows & Mac and 401 on Linux. I have not looked at the DefaultCompress middleware code to see what it is doing but it somehow appears to be the culprit.. @pkieltyka how do I do that? I deleted my pkg folder and issued ago get` prior to each of my tests.. ",
    "awbraunstein": "I'd like to take a swing at rewriting the compress middleware. Can I take this issue?. ",
    "husainaloos": "This is also related to PR #392 . ",
    "yechuzheng": "Just saw\uff1a\nhttps://github.com/go-chi/chi/blob/master/_examples/fileserver/main.go. ",
    "mvrlin": "Found the answer myself.\n```go\npackage cmd\nimport (\n    \"net/http\"\n    \"os\"\n    \"time\"\n\"github.com/go-chi/chi\"\n\n)\nfunc main() {\n    router := chi.NewRouter()\n    server := &http.Server{\n        Addr:         \":8080\",\n        Handler:      router,\n        ReadTimeout:  10 * time.Second,\n        WriteTimeout: 10 * time.Second,\n    }\n    router.Get(\"/foo\", func(w http.ResponseWriter, r *http.Request) {\n        w.Header().Set(\"Content-Type\", \"application/json\")\n    w.Write([]byte(`{ \"message\": \"bar\" }`))\n})\n\nFileServer(router)\n\npanic(server.ListenAndServe())\n\n}\n// FileServer is serving static files.\nfunc FileServer(router *chi.Mux) {\n    root := \"./website/dist\"\n    fs := http.FileServer(http.Dir(root))\nrouter.Get(\"/*\", func(w http.ResponseWriter, r *http.Request) {\n    if _, err := os.Stat(root + r.RequestURI); os.IsNotExist(err) {\n        http.StripPrefix(r.RequestURI, fs).ServeHTTP(w, r)\n    } else {\n        fs.ServeHTTP(w, r)\n    }\n})\n\n}\n```. ",
    "js02sixty": "I've been struggling with this for days, thank you!. I adapted your snippet to allow SPA to be served from sub path.  In vue cli its the publicPath config\n```\npackage main\nimport (\n    \"fmt\"\n    \"net/http\"\n    \"os\"\n    \"path\"\n    \"path/filepath\"\n    \"strings\"\n    \"time\"\n\"github.com/go-chi/chi\"\n\n)\nconst port = \":3333\"\nfunc main() {\nfmt.Printf(\"Starting Server on Port %v\\n\", port)\nrouter := chi.NewRouter()\nserver := &http.Server{\n    Addr:         port,\n    Handler:      router,\n    ReadTimeout:  10 * time.Second,\n    WriteTimeout: 10 * time.Second,\n}\n\nrouter.Get(\"/foo\", func(w http.ResponseWriter, r *http.Request) {\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    w.Write([]byte(`{ \"message\": \"bar\" }`))\n})\n\nFileServer(router, \"/admin\", \"dist/\")\nFileServer(router, \"/\", \"../admin2/\")\n\npanic(server.ListenAndServe())\n\n}\n// FileServer is serving static files\nfunc FileServer(r chi.Router, public string, static string) {\nif strings.ContainsAny(public, \"{}*\") {\n    panic(\"FileServer does not permit URL parameters.\")\n}\n\nroot, _ := filepath.Abs(static)\nif _, err := os.Stat(root); os.IsNotExist(err) {\n    panic(\"Static Documents Directory Not Found\")\n}\n\nfs := http.StripPrefix(public, http.FileServer(http.Dir(root)))\n\nif public != \"/\" && public[len(public)-1] != '/' {\n    r.Get(public, http.RedirectHandler(public+\"/\", 301).ServeHTTP)\n    public += \"/\"\n}\n\nr.Get(public+\"*\", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n    file := strings.Replace(r.RequestURI, public, \"/\", 1)\n    if _, err := os.Stat(root + file); os.IsNotExist(err) {\n        http.ServeFile(w, r, path.Join(root, \"index.html\"))\n        return\n    }\n    fs.ServeHTTP(w, r)\n}))\n\n}\n```. ",
    "tak1827": "Sorry, This is mistake.. ",
    "abenz1267": "Possible fix:\ngo\n// Is the content type compressable?\nif _, ok := cw.contentTypes[contentType]; !ok {\ncw.w = cw.ResponseWriter\nreturn\n}\nAlthough it would be nice to determine the content-type earlier and see if you can avoid every further computation, if it's not supposed to be compressed and instead just next.ServeHTTP(w,r)\n. Yes, this change would be indeed breaking, due to the change of how default types are added. However it would be good to still add line 278 to the current version, as it fixes the broken middleware. I'm not sure if i should make a new PR for this or if you just wanna add that 1 line.. ",
    "henrikbjorn": "the structs are empty, why not have a map[string]bool instead?\n. ",
    "xiam": "Good point, I think it would be better if I change this part and put the backlog number on top of the limit.\n. If error messages are different clients will be able to debug what's happening by themselves, or a least the will provide more accurate debugging information to a developer. If all errors are the same developers will not know where is their code failing. We can also use custom statuses if the standard ones fail to represent the error accurately.\n. Probably http.StatusGatewayTimeout is not the best choice if we try to be strict, but I rather have an error message that helps us spot a problem easily. In this case the http.StatusGatewayTimeout is associated to operations that take too much time to complete, while http.StatusServiceUnavailable is only associated to capacity problems.\n. ",
    "ffest": "Yes, looks good!. ",
    "tmatias": "@VojtechVitek :+1: will update.. ",
    "thedevsaddam": "Isn't it better to panic, instead of silently skipping?. "
}