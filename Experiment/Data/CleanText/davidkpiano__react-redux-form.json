{
    "davidkpiano": "@markerikson Funny you discovered this, I haven't released it yet. Right now I'm working on unit tests, and I want to write as many unit tests as possible before this gets released. But if you're curious, here's the current state of documentation: http://davidkpiano.github.io/redux-simple-form/\nMy plan is to finalize the unit tests this weekend, and then I'll bump the version on NPM and update the documentation. I most certainly welcome feedback and suggestions, too!\nAlso, this might be moved to a larger organization so it can benefit from many contributors, not just me.\n. So my goals with redux-simple-form are:\n1. Make it conceptually simple (I agree, redux-form is too API-heavy, proprietary, and over-engineered)\n2. Model the way Angular does forms (because, you have to admit, forms in Angular are a breeze)\n3. Performance (only validate changed fields rather than every field, give ability to only change model on blur, debounce, etc.)\n4. Keep your models/stores intact. This is huge - I don't want my models/stores to be mixed into my form data, and I want to take control of my model as much as possible.\nWhat do you think? Anything else you'd like to see in a Redux-form library?\n. @markerikson I'd love to see what your form looks like visually, for reference! I want to add a bunch of examples and dog-food this as much as I can before I release it to the public.\n. @markerikson try it now, I believe the dependencies are working (as tested by TravisCI). Also, I would love it if you played around with this project now - I'm at a state where I'm about ready to publicly release it!\n. Good point, would it make more sense as react-redux-form or react-form-redux do you think?\n. And it's done! Thank you for the suggestion!\nnpm install react-redux-form --save\n. Hey, great question, @webmasterkai! A few months ago, I played around with approaches such as:\n- <input type=\"text\" {...field('foo.bar')} />\n- { field('foo.bar', <input type=\"text\" />) }\n- export default field('foo.bar')(<MyInputComponent />)\nbut ultimately came to the <Field> approach for a few reasons:\n- Reconciliation - because <Field> is a React component, I can manually adjust reconciliation so that the component only re-renders when it needs to\n- Recognition of control components - gives <Field> the ability to treat input, radio boxes, checkboxes, select, etc. differently (an important distinction from Redux Form)\n- Multiple child components - since <Field> recursively goes through its children to figure out what's a control component, it will smartly handle:\njs\n<Field model=\"foo.bar\">\n  <input type=\"radio\" value=\"Option 1\" />\n  <input type=\"radio\" value=\"Option 2\" />\n  <input type=\"radio\" value=\"Option 3\" />\n</Field>\nwithout any extra effort on the developer's part.\nI'm going to be writing some documentation on how exactly <Field> works, but the basic gist is this:\n- It figures out what type of control component(s) it is dealing with, so it knows exactly how to update/apply the model value to it\n- It compose()s a series of actions to each control's event handlers, so that it properly handles validation and updates exactly when you specify (onChange, onBlur, debounced, etc.)\n- It returns all children (wrapped in a <div> if there's more than one) that only rerender when absolutely necessary\nAnd probably the biggest reason for it being a self-contained component: it can live within an unconnected parent component:\njs\n// No need to connect() this!\nexport default class MyForm extends React.Component {\n  render() {\n    return (\n      // <Field> connects itself!\n      <Field model=\"user.foo\">\n        <input type=\"text\" />\n      </Field>\n    )\n  }\n}\nHopefully that answered your question! I'm open to hearing alternative approaches that also provide the previously mentioned solutions!\n. So, what RRF is doing is checking that any of its children either:\n- are a control (such as <input>, etc.)\n- have children, that are a control (recursive)\nWhen <Field> encounters <Options>, it sees that it is neither a control component nor does it have any children, interestingly enough (because it wasn't \"rendered\" yet... I'll have to look deeper into functional components for this nuance).\nThis will work, however:\n``` js\nfunction Options() {\n  const options = [ { value: 'opt1' }, { value: 'opt2' }, { value: 'opt3' } ]\n  return (\n    \n      { options.map((opt, i) => ) }\n    \n  )\n}\nfunction MyRadioField() {\n  return {Options()}\n}\n``\n. @leandroz Here's how you would do it without`:\n``` js\nimport { actions } from 'react-redux-form';\n// in connected render():\nconst colors = [\n  'Red',\n  'Orange',\n  'Yellow',\n  'Green',\n  'Blue',\n  'Purple',\n  'Black',\n  'White',\n];\n dispatch(actions.change('user.color', e))}\n          onNewRequest={e => dispatch(actions.change('user.color', e))}\n        />\n```\n. Got rid of the section, sorry!\n. Thanks, @plandem! I'm still working on fleshing out the documentation, but yes, I will add full examples.\nWhat's a good example full, end-to-end example of a form app that you would like to see coded up? I plan on adding many examples. I'm open to suggestions.\n. How are you using getField()? It's meant to return the field from the form for form states such as focus, blur, valid, errors, etc.\nCan you share your full code in a gist perhaps?\n. Do you have the latest react-redux-form? The getField() function was a recent addition.\n. I just updated it today, npm install the latest minor version. Sorry for the confusion! I didn't want a magic myForm.field('blah') method in the state.\n. Okay, I just confirmed the issue. If you install to the latest version (updated in the docs too), getField will be available.\nnpm install react-redux-form@0.3.1 --save\nHope that works!\n. Hey @plandem - \nSolving this \"the React way\", you can create your own components that have these default validators:\n``` js\nfunction isRequired(val) {\n  return val && val.length;\n}\nclass RequiredField extends React.Component {\n  render() {\n    let { validators } = this.props;\nreturn (\n  <Field {...this.props}\n    validators={[ isRequired, ...validators ]}\n    validateOn=\"blur\">\n    { this.props.children }\n  </Field>\n);\n\n}\n```\nHaving \"default validators\" and other such configuration options for all fields in a form would get really complex and messy, but if there is interest, I'm open to hearing implementation suggestions.\n. Interesting suggestion! So would <Required>...</Required> generate a field that has the required validator in an <input type=\"text\" /> or something like that?\n. I'll look into this. If you have an implementation in mind, I'd be more than happy to review a PR on it! :smile: \n. Yep! Here you go: http://davidkpiano.github.io/react-redux-form/#/recipe/validation-on-submit\nThe basic idea behind submit validation is that you can use the asyncSetValidity function (will document later tonight) to handle validation and submission of the form.\nactions.asyncSetValidity(model, validator) takes two arguments:\n- the model (which can be the form model itself)\n- and the validator(value, done) function, which takes in two arguments:\n  - value - the value of the model\n  - done - a callback to return the validation object.\nIf submission is successful, you can signal that the form has been submitted by dispatching:\njs\ndispatch(actions.submitted('myForm', true));\nafter calling done() in the asyncSetValidity function.\nHopefully that makes sense! I'm writing a ton of documentation tonight on this.\n. Yep, LGTM! Makes sense, since the model reducers can handle deep state paths as well.\nThanks for tackling this!\n. Looks great! I might add a couple extra unit tests and merge it in if everything's fine. Thanks for this!\n. Thanks for the question, @khanghoang. Yep, since RRF just deals with plain JS object/array models, you can just conditionally render the list of cities based on the chosen country. For instance, if you have a <Field model=\"address.country\"> you can just have a custom function that renders the correct cities and call it in a map: { getCities(address.country).map(city => ...) }\n. Hey @fritx, I'm working on the documentation for this! You pretty much nailed the biggest difference, but I'll post a comparison chart soon. Stay tuned!\n. Docs now available here! http://davidkpiano.github.io/react-redux-form/docs/index.html#/api/Guide:-Redux-Form-Comparison\n. Sure, though keep in mind that these docs do not reflect the latest versions of Redux-Form nor React-Redux-Form @tnguyen14: http://davidkpiano.github.io/react-redux-form/docs/index.html#/api/Guide:-Redux-Form-Comparison\n. :airplane: LANDED in react-redux-router@0.4.1: https://github.com/davidkpiano/react-redux-form/commit/95ad41c8199c36b70c08145d5a4cff74e60d4b8f :tada: \n. Hey @joshgeller, thanks for the issue report! Are you on the latest version? I believe this was fixed in 0.3.4 with the latest version being 0.3.6. Check here for a demo; I wasn't able to recreate the issue:\nhttp://esnextb.in/?gist=66b01dd977a6f601259b\n. Fixed here: https://github.com/davidkpiano/react-redux-form/commit/c6f8d8893064134f914a1979a26b935ee427a814\nNow working when both updating form errors and field errors. Just npm install latest: npm i react-redux-form@0.3.8 -s :smile: \n. I believe so; I haven't used react-bootstrap but if the custom components implement an \"onChange\" prop, it should work fine. I'll test it out and write some documentation on integrating RRF with react-bootstrap. \n. Hey @markerikson and @arddor, I will be pushing up a small update shortly that gives full compatibility with any custom element that implements the \"onChange\" prop, so you can use  with those components! Docs coming soon!\n. Working on dogfooding integration with react-bootstrap, and I found that its <Input /> components do not actually have onChange as a prop type, so RRF can't automatically detect those elements.\nThe good news, though, is I have an approach that allows you to explicitly tell RRF which components will be custom components:\n``` js\nimport { Field } from 'react-redux-form';\nimport { Input } from 'react-bootstrap';\n// returns a new class that extends Field\n// and maps the custom controls (keys) by name\n// to the known controls (values) by name\nconst BSField = Field.mapControls({\n  'Input': 'input'\n});\n// in your component's render() method\n\n\n\n```\nWhat do you think of this approach? By being explicit, RRF can easily adapt itself to any 3rd-party component system, and this can be further customizable with a function that takes in the <Field /> props and maps it to props on the custom componoent:\n``` js\nconst MaterialField = Field.mapControls({\n  'TextField': 'input',\n  'RadioButtonGroup': (props) => ({\n    name: props.model,\n    valueSelected: props.modelValue\n  }),\n  'RadioButton': (props) => ({\n    onCheck: props.onChange\n  })\n});\n// ...\n\n\n\n```\nIt would also be pretty simple to just create packages for these, such as react-redux-form-material-ui and react-redux-form-bootstrap.\n. @markerikson There are two ways you can do this, both using <Field /> and manually dispatching actions:\nWith : You can pass in a function to the updateOn prop that takes in the bound change() function internally, making debouncing as easy as this:\njs\n<Field model=\"foo.bar\"\n  updateOn={(change) => debounce(change, 1000)}>\n  <input type=\"text\" />\n</Field>\nWith actions: You can override the change prop:\njs\n<Field model=\"foo.bar\">\n  <input type=\"text\"\n    onChange={(e) => debounce(() => actions.change('foo.bar', e), 1000)} />\n</Field>\nwhich is a little more verbose, but is essentially what updateOn does.\nI'll add a recipe with this soon!\n. @arddor @markerikson Okay, here is the semifinal syntax for creating custom <Field /> components that can handle any 3rd-party library's components. I'll use React Native as an example:\n``` js\nimport React from 'react';\nimport { TextInput } from 'react-native';\n// createFieldClass() dynamically creates a custom  class\nconst NativeField = createFieldClass({\n  'TextInput': (props) => ({\n    ...props,\n    defaultValue: props.modelValue,\n    onChangeText: props.onChange\n  })\n});\n// inside your component's render() method\n\n\n\n```\nNow everything you expect in RRF like validation, focus, blur, change, etc. will be available to <TextInput />, and anything that goes through onChangeText will be sent to the props.onChange method instead.\nHow does this look? I would expect developers to not have to handwrite this every time for common libraries, so this can easily be available as a plugin like react-redux-form-native or react-redux-form-bootstrap, or even available as part of RRF as it's a very small amount of code:\n``` js\nimport NativeField from 'react-redux-form/native';\n\n\n\n```\n. For reference, you'd have to do this manually in Redux-Form, but it's essentially the same concept: https://github.com/erikras/redux-form/issues/334#issuecomment-182442713\n. This will be landing soon! I will write docs/experiments but you can try it out now:\nbash\nnpm install react-redux-form@beta\n. Demos are now up (with material design): docs coming soon: http://davidkpiano.github.io/react-redux-form/#/recipe/custom-components\n. Sorry about that! Just pushed an update to the docs to fix that.\nWith that said, react-redux-form@0.5.1 is out and yes, it can support 3rd-party and custom components!\n. Hey Paul -\nFor Example 1, you just forgot to include the userForm in your selector() function. I'll be pushing up a quick check to better warn you that you forgot to include a valid form state for getField():\ndiff\nconst selector = (state) => ({\n  user: state.user,\n+  userForm: state.userForm\n});\nI'm taking a look at Example 2 now!\n. Thanks for the feedback, Paul! I have a ton of documentation updates coming up and am still working through solutions for integrating React Redux Form with libraries such as react-bootstrap and material-ui. Let me know if it works for you and I can close out this ticket for the first issue! :)\n. Perfect! I'll defer 3rd-party integration discussion here: https://github.com/davidkpiano/react-redux-form/issues/14\n. This is a (small) bug with <Field /> which will be fixed soon. In the meantime, you can forego using <Field /> and add the action manually;\n``` js\n dispatch(actions.change('foo.month', e))}>\n  ...\n\n dispatch(actions.change('foo.day', e))}>\n  { getDaysInMonth(foo.month).map((day) => \n    { day }\n  )}\n\n```\nEDIT: If anyone wants to get to this and make a PR before I do later today, the issue is in src/components/control-component.js:\ndiff\n// line 15: delete as component should always update\n-  shouldComponentUpdate(nextProps) {\n-    return this.props.modelValue !== nextProps.modelValue;\n-  }\n. Unit test added here: https://github.com/davidkpiano/react-redux-form/commit/edfbec65297cbd1cbf5ea63ea0f662f7563e5718\nEverything looks good to go! npm install react-redux-form@0.5.2 --save\n. Thanks! We'll probably want to write unit tests to confirm this fix, but visually it seems to have fixed the issue.\n. Do you have the latest version of react-redux-form? This test seems to pass with the existence of createFieldClass(): https://travis-ci.org/davidkpiano/react-redux-form/jobs/109377535#L610\nLatest version is react-redux-form@0.5.2\n. Sorry @plandem, I can't reproduce this: http://esnextb.in/?gist=c461ad2839e613de42aa\nClick \"Execute\" above and you'll see the result from the test.\n. Ah, right. I recently simplified the API (though not published to NPM yet) that simplifies that so that it's only one argument. I'll write some docs and a few extra tests to show meaningful error messages.\n. Thanks, @lasergoat :goat: \n. Interesting suggestion. The current logic is this:\n- If the <Field> contains only one child, render only that (smartly cloned) child.\n- Else if the <Field> contains more than one child, render a <div> since React can't render multiple children without a parent node (unfortunately).\nSo this will work as expected: \n``` js\n\nTest\n\n\n// renders to...\n\nTest\n\n\n```\nSo we can update the logic so that if a className prop exists on the <Field>, generate a <div> regardless of the number of children. Is that what you're expecting?\nIf so, I'll add it (or feel free to PR). A simple workaround is this:\njs\n<Field model=\"...\">\n  <div className=\"field six wide\">\n    <input type=\"text\" placeholder=\"E-mail\" />\n  </div>\n</Field>\n. Just a thought: what if a component={...} prop was passed in to Field? That seems to be the simplest solution for this.\n``` js\n// Will not render a 'div' wrapper\n\n\n\n// Will render a 'div' wrapper because of 'className'\n\n\n\n// Will also render a 'div' wrapper\n\n\n\n// Will render a View wrapper (useful for React Native)\n\n\n\n``\n. Alright, published as 0.6.1! https://github.com/davidkpiano/react-redux-form/releases/tag/v0.6.1\n. Thanks, @bradleyprice! Fixed the wiki. It should actually beloginForm: createFormReducer('login')because it keeps track of the form state of thelogin` slice of the state.\n. I'm actually working on integrating this feature (for use of any error messages and/or complex values to be used for both validation and errors), but I'm wondering, what is the shape of the data for the custom error messages that you receive from Auth0?\n. So here are the planned ideas I have for this:\nA new actions.setErrors(model, errors) action creator that acts like setValidity, except it can set values of any type directly to the errors property of the field:\n``` js\ndispatch(actions.setErrors('user.email', {\n  length: 'Your email is not long enough',\n  illegal: 'Your email contains illegal characters.'\n});\ngetField(userForm, 'email').errors;\n// => { length: 'Your email is not long enough', illegal: 'Your email contains illegal characters' }\ngetField(userForm, 'email').validity;\n// => { length: false, illegal: false }\n```\nAnd a new actions.submit(model, promise) action thunk creator that takes a promise and does the following:\n- If promise is resolved, setValidity() to the resolved value.\n- If promise is rejected, setErrors() to the rejected value.\nSo to submit a form with validation/errors, it would look like:\n``` js\nconst submitUser = new Promise((resolve, reject) => {\n  fetch('...').then(\n    (response) => {\n      // do whatever with the response\n      resolve(true); // indicate that form is valid\n    },\n    (errors) => {\n      reject(errors); // will set errors of field/form\n    });\n}\ndispatch(actions.submit('user', submitUser));\n``\n. @kid These are released inreact-redux-form@0.6.2, though I still have to write documentation for the new actions. I will close this ticket when the documentation is finished; until then, feel free to play around with the above API and see if it fits your use cases!\n. All the above is now released in0.7.0`, documentation to follow! \nhttps://github.com/davidkpiano/react-redux-form/releases/tag/v0.7.0\n. Weird, I had an extra backtick that was throwing the rendering off. Thanks for noticing this! It should be fixed once the cache is refreshed for Github Pages.\n. Interesting, that probably is a React Native issue rather than a React-Redux-Form issue, since RRF exposes /lib/index.js, which is already pretranspiled into ES5 code, so Babel isn't even necessary.\nLet me know if you have any more issues with React Native and I'll respond as soon as I can!\n. Sure thing, @MiMaMuh. Doing that now.\n. Should be available in 0.9.11 now! @jonlong @MiMaMuh \n. Thanks, @chrisblossom! I have been using it in a production app with complex, multi-page forms for the last month and it has been working well. I'd consider it stable enough to use in production since it is using vanilla Redux for the most part, which itself has a stable API.\nThe library itself is already using semver, and had had no breaking API changes so far, only bug fixes and feature additions. Once enough people are using it and the features and API are satisfactory for any non-trivial use case, I'll bump it to 1.0.0. \nHope that helps!\n. I would say to use it at your own discretion, much like how React was at version 0.x for a while until they finally decided it was already being used widely in production.\nBut know that I don't anticipate the API to change, since this is based on years of working on very complex forms in Angular, React, and plain JS, as well as researching all the available APIs and libraries for handling form state in Angular and React (such as redux-form).\nThe only way there would be major breaking changes is if Redux itself introduces breaking API changes, which is highly, highly unlikely.\n. I completely understand. I do feel that it's stable, but I'd like others to use it extensively before I move it to 1.0.0. I actually wrote this library in response to redux-form in order to provide stability - a lot of the issues (100+) on redux-form are a result of the library trying to handle too much and mix form state with model state, which exponentially adds complexity.\nThis library separates the two, which dramatically decreases complexity (and library size) - the library is simply a collection of actions and reducers, with a few helpful (but optional) additions such as: \n- <Field> component wrappers\n- modeled() reducer enhancer\nand a few action thunk creators that make composing complex actions, like asynchronous validation, easier. It works by using vanilla Redux (and allowing you to use plain Redux) as much as possible, without trying to assume too much control over your form state.\nRedux-Form is v.4.x.x right now, indicating that it already has had many breaking API changes. It also takes control of your form state, in that you have to do most form-related things through the API it provides rather than through Redux yourself (which Redux-Form discourages). This makes it hard to do non-trivial or complicated form actions/updates, but if your form fits in the use-cases outlined in the Redux-Form documentation, and doesn't try to do anything too crazy, Redux-Form should be fine for you.\nIf you are comfortable with Redux and want to know exactly how everything is happening without introducing too much \"magic\", then that's why I built React-Redux-Form :smile: It's best suited for those who already have an application that they want some form control over, or those who want to write minimal code and are comfortable creating their own actions and reducers as well.\n. To validate multiple fields, remember that you can always:\n- Validate any part of the state\n- Validate at any time (via actions)\nAssume you have a model that looks like this:\njs\n{ user: {\n  password: \"\",\n  confirmPassword: \"\",\n  choices: []\n} }\nwith a corresponding userForm from userForm: createFormReducer('user') in your store.\nFor the first part, validation will likely belong to user unless you want to copy the same error for both user.password and user.confirmPassword. Then, it's just a matter of dispatching the setValidity action:\n``` js\nimport { actions } from 'react-redux-form';\n// in your connected component\nconst { user, dispatch } = this.props;\ndispatch(actions.setValidity('user', {\n  passwordsMatch: user.password == user.confirmPassword\n});\n```\nThen you can grab that validation key:\n``` js\n// in your connected component\nconst { userForm } = this.props;\nreturn (\n  // ...\n  { userForm.errors.passwordMatch\n    ? Passwords do not match\n    : Nice! Passwords look great. Not that I can see them but, you know.\n  }\n  // ...\n);\n```\nHopefully that makes sense! You have full control of when you dispatch(actions.setValidity(...)), but if you want to do it inside a <Field> component, take a look at this example with the validators={...} property.\nWith a group of checkboxes, if they're part of the same model, validation works as normal:\njs\n<Field model=\"user.choices[]\"\n  validators={{\n    required: (vals) => vals.length\n  }}>\n  <input type=\"checkbox\" value={1} />\n  <input type=\"checkbox\" value={2} />\n  <input type=\"checkbox\" value={3} />\n</Field>\n{ getField(userForm, 'choices').errors.required\n  ? <span>Please select one value.</span>\n  : null\n}\nLet me know if this all makes sense :)\n. I'd love to add AirBNB's eslint config into RRF and start linting, sure! I'll add it soon.\n. @chrisblossom Would you mind taking a look at the Travis CI build error?\n/home/travis/build/davidkpiano/react-redux-form/node_modules/jsdom/lib/jsdom.js:3\n() => `jsdom 7.x onward only works on Node.js 4 or newer: https://github.com/t\nFails on 2 of the 3 machines. Awesome progress on this so far by the way! Will run it locally and merge it in soon when all the tests pass.\n. Reran the tests! Looks good to merge, much thanks!\n. Can you provide a code example for this: \n\nI have noticed that validation does not fire for fields updated via actions.change\n\nI was not able to replicate it.\nAlso, there is the setValidity action creator (as well as setErrors), are you trying to validate on blur? Or possibly on form submit?\n. Unfortunately, in <Field>, this has to do with how React works in that it won't trigger onChange events when input values are changed programmatically: https://github.com/facebook/react/issues/1152\nIs it feasible to manually do validation, wherever you are dispatching the change action?\n``` js\nfunction doChange(val) {\n  return (dispatch) => {\n    dispatch(actions.change('foo.bar', val));\n    dispatch(actions.setValidity('foo.bar', {\n      required: val && val.length\n    });\n  }\n}\n``\n. I'm experimenting with what the API could look like for this, while using 99% of the existing RRF constructs such assetValidityandsetErrors`:\n``` js\nimport { Form } from 'react-redux-form';\n// somewhere connected in render()...\n user.password == user.confirmPassword,\n      required: (user) => user.username.length && user.password.length\n    },\n// Field validation\n'password': (user) => isValidPassword(user.password),\n\n// Async validation\n'username': (user) => (done) => asyncIsAvailable(user.name).then((res) => done(res))\n\n}}\n  validateOn=\"submit\">\n  \n\n```\nAnd of course, that validation object can live in its own constant, such as const validators = { ... }. Would this approach make sense?\nThe reason that I don't agree with it being in a single function is that the function isn't smart - it has no way of knowing which parts of the validation to run on each change (unless you explicitly tell it when it should validate), meaning that redundant validation for every single field is being run on every single change - this hinders performance and is entirely unnecessary. With the above approach, it can easily be optimized to:\n- only run validation when the respective fields have changed\n- handle both synchronous and asynchronous validation declaratively\n- specify when validation should run (e.g. on submit).\nThoughts?\n. > validation to be triggered by actions.change\nThis is an interesting topic, because it can be active where an action would fire off another action, or passive where something is listening for the change action (not the reducer - doesn't belong there). The active case is a no-go because we don't want to overload the change action with validation logic (or do we... hmm), and the passive case is best solved with custom middleware that can intercept the action.\nHowever, a third solution can be...\n\nform wide validation to be triggered from an action\n\nwhich composes well with the above <Form validators={{...}}> proof of concept, in that it doesn't have to listen for specific actions per se; it just has to know which fields have changed (which can be quickly done, depending on the depth of the model and the number of validators).\nSo, raw value comparison = simplest answer :+1: \n\nability to specify error text from validation\n\nSure, I'm going to document this, but you currently can do this:\n``` js\nimport { actions } from 'react-redux-form';\n// somewhere dispatchable\ndispatch(actions.setErrors('user.email', 'This email address is already registered.'));\n// or as an object...\ndispatch(actions.setErrors('user.email', {\n  required: 'You need to enter an email address.'\n}));\n// or even as an array...\ndispatch(actions.setErrors('user.email', [\n  'Email not long enough', 'Email contains invalid characters'\n]));\n// or as anything else, really.\n```\nwhere any non-falsey value will indicate to RRF that there's an error.\nCurrently, with <Field validators={{...}}>, it's just a map of values that expects a boolean return value so that:\n- validation can be easily composed and checked\n- custom error messages can be placed directly into the UI, instead of returned from something like setErrors\nThe second point is important for <Field> since it assumes that if you're defining your validators directly in the render(), you're also able to define the error messages directly in the render(). This is so that you can quickly add common functions such as { valid: validators.isEmail } instead of { valid: (val) => validators.isEmail(val) ? null : 'Email is not valid' }.\n. @sattaman The <Form> component described above (without the async validators) has been implemented in 0.7.0: https://github.com/davidkpiano/react-redux-form/releases/tag/v0.7.0\nPlease let me know if this fits your use case!\n. > Does form validation run for fields changed via actions?\nYes, it can! Just add validateOn=\"change\" to the <Form> component, and it will run validation on the validators defined in <Form validators={{...}}> whenever the field values change, regardless of if it's from the field change or from an action.\nIf you want to have validators defined inside <Field validators={{...}}> to be run on value change (rather than on physical input change), please open up a separate ticket for that feature request. I think it might be a good feature to have.\n\nIs it possible to trigger the validation from an action?\n\nYes, now it is, with 0.7.1 (just released). Here's the idea:\n- Your validators are defined inside a shared object, perhaps in a file like validators.js\n- You can reference validators from anywhere\n- You call actions.validate(model, validators) from anywhere with dispatch().\n``` js\nimport { actions } from 'react-redux-form';\n// your custom shared validators\nimport validators from '../validators';\n// somewhere with dispatch()\ndispatch(actions.validate('user', validators.user));\n```\n\nIn order to specify error text, do I need to validate inside of an action?\n\nYes, but it makes sense to do so. Validators defined inside <Field> and <Form> only care about the validity (true/false), and it's up to you to map that validity to the error messages, which are primarily a view concern.\nHowever, you can use actions.submit(model, promise) to automatically set the .errors property of the field state to whatever error the promise throws.\n. Sorry about that! This change is now fixed and published in react-redux-form@0.6.3. \nThe issue had to do with how <Field> knew which \"updating\" action to choose for each control. It didn't think that Input was a checkbox, but now it does, as long as it has type=\"checkbox\".\n. Yes, it should be working with checkboxes now. Let me know if you have further issues.\n. Awesome, glad you got it working @muuki88 ! Let me know if there's anything you'd like to see in the docs and I'll be sure to add it.\n. I'll start seeing how we can refactor from top-down. For compatibility and not-reinventing-the-wheel reasons, I'd like to probably keep these:\n- isEqual (unless we find a smaller implementation)\n- get (for its path support)\n- toPath\nWe can probably find a simpler implementation of mapValues since it's only used internally, and not in the public API.\nI'll take a look at what else (besides lodash) can be contributing to the size that we can probably shrink down.\nThanks for taking a look at this!\n. @acidicX Yes, that'll be really helpful, though I anticipate many developers will still be using Webpack 1.\nI am actively working on reducing the bundle size in V1, and you can check out the current work in the v1 branch.\n. Try this:\njs\nimport { createModelReducer } from 'react-redux-form/lib/immutable';\nSorry, must be a typo. I'll update the docs. See this to verify that it works: http://esnextb.in/?gist=2ab8505dfda15d995a7e\n. Hey @sattaman, try doing this:\ndiff\nconst store = compose(applyMiddleware(thunk, createLogger()))(createStore)(combineReducers({\n-  fields: createModelReducer('myModel')\n+  myModel: createModelReducer('myModel')\n}));\nThe model name needs to match the actual key for the slice of state that the model represents.\nProof that that might fix your problem:\n\n. @sattaman Does this solve your issue?\n. Ah, I'm actually still in the process of developing the <Form> component, once we've figured out what exactly we want its API to look like. Sorry, that's supposed to be a private (beta) API for now, but I will be adding it the next release. That's why it's not documented yet.\nStay tuned!\n. Documentation is here! https://davidkpiano.gitbooks.io/react-redux-form/content/form_component.html\n. I'm not sure where you found props.validate but that is not part of the React-Redux-Form API. Validation is done through actions, such as setValidity(), setErrors(), or asyncSetValidity(), etc.\nHere's an example with the submit() action that uses promises:\n``` js\nfunction submitPromise(user) {\n  return new Promise((resolve, reject) => {\n    if (user.password === 'hunter2') {\n      return resolve(true);\n    }\nreturn reject(value.errors);\n\n});\n}\n// ... in your component\nhandleSubmit() {\n  const { user, dispatch } = this.props;\ndispatch(actions.submit('user', submitPromise));\n}\n```\nI'm working on writing up a full example for this.\n. Yep, that action wasn't supposed to be exposed yet, sorry! \nFor now, try sticking to the validation actions in the documentation: http://davidkpiano.github.io/react-redux-form/#/api/Guide:-Validation\n. Yes, coming very soon! See this issue comment for what that will look like: https://github.com/davidkpiano/react-redux-form/issues/31#issuecomment-189468586\nAnd feel free to chime in to see if that looks like an easy-to-understand, intuitive API.\nRemember: validation cannot be baked into the reducer because 1) reducers should be simple and have as little logic as possible, and 2) validation should be able to be asynchronous, and not run all the time (e.g. some validation runs on field changes, some validation runs on blur, some validation runs only on form submit, etc.)\n. @muuki88 The <Form> field with validation on submit has just been released in react-redux-form@0.7.0!\nCheck the release notes for details, and please let me know if this fits your use case: https://github.com/davidkpiano/react-redux-form/releases/tag/v0.7.0\nDocs will be updated soon!\n. Great example! As far as putting all the validators in the correct places, you no longer need to specify validators in the <Field> if you don't need to. Just add:\n``` diff\n<Form model=\"...\"\n  validators={{ ... }}\n+  validateOn=\"change\"\n\n```\n\nto your form, and it will run the validation (for only the changed fields) whenever a field changes.\nSetting validators in <Field> is good when you want to:\n- Validate on something other than change, such as \"blur\"\n- Have async validators (which don't make sense for a form submit, at least not right now)\n. You no longer need to add validateOn=\"change\" to the form. That is the default action. Here are the full docs for the <Form> component: https://davidkpiano.gitbooks.io/react-redux-form/content/form_component.html\n. This might be a React/JavaScript question rather than a specific React-Redux-Form question. You need to somehow get the index of each user inside the <UserDetails> component.\nHere's a couple of approaches:\n``` js\nconst users = ...;\nconst UserDetails = ({ user, index }) => (\n  users[${index}].name}>\n    \n\n);\n// then use it like this:\n{ users.map((user, index) =>\n  \n}\n```\nOr like this, in a mapStateToProps selector or otherwise:\n``` js\nconst users = [{ name: 'Brad Pitt' }, { name: 'Bruce Wayne' }];\nconst indexedUsers = users.map((user, index) => ({ ...user, index }));\n// now if you use indexedUsers instead of users...\nconst UserDetails = ({ user }) => (\n  users[${user.index}].name}>\n    \n\n);\n```\nSo, there's a couple of approaches to this. Hope that helps!\n. > 1) is there a way to clear validation for all fields within given form state?\nYes, using the actions.reset(model) action. However, this will also set the model in the model reducer to its initial state; is this desired?\nIf not, I can see the use for an actions.resetField(model) action that only resets the field's form state, and not the model state.\n\n2) is there a way to enumerate fields?\n\nYou mean like foo.bar[4].baz? Yes, if I'm understanding your question correctly. What use-case are you looking for?\n. Okay, this seems very doable. Would something like actions.resetValidity('createControl.createForm.form')) make sense for that?\nThis actions.resetValidity(model) action would do two things:\n- Reset the .validity and .errors of the model itself\n- Reset the .validity and .errors of any submodels (such as createControl.createForm.data.GivenName, etc.)\nHow does this look? I can add it in 0.7.1\n. @Kukkimonsuta There is now an actions.resetValidity(model) action that you can dispatch that will reset the .validity and .errors of just the model in 0.7.2.\nI'm working on completely revamping documentation so I'll add that in there when I can as well! But you can use this right now in 0.7.2\n. Now present (officially) in 0.8.0! https://github.com/davidkpiano/react-redux-form/releases/tag/v0.8.0\n. Documentation here: https://davidkpiano.gitbooks.io/react-redux-form/content/field_actions.html\n. Sure thing! I'm actually revamping the entire documentation and adding tons of examples right now - it's a work in progress. But I'll get that up.\nAnyway, your initial state (ideally) comes from your original reducer itself:\n``` js\nconst initialState = { bar: 'baz' };\nfunction fooReducer(state = initialState, action) {\n  // do whatever you want to state\n}\nexport default modeled(fooReducer, 'foo');\n```\n. > But I realized - in my own reducer here that I probably don't want to muck with the existing state, since I should not need or require knowledge about how you are actually implementing reduction of the model.\nAbsolutely right. Your existing reducer that you use modeled with doesn't need to know anything about React-Redux-Form, so ideally you can dispatch your own action that \"resets\" the model state to your own default state:\n``` js\nconst initialState = {...};\n// Your special default state\nconst defaultState = {...};\nfunction fooReducer(state = initialState, action) {\n  switch (action.type) {\n    case 'SPECIAL_FOO_RESET':\n      return defaultState;\n    default:\n      return state;\n  }\n}\nexport default modeled(fooReducer, 'foo');\n```\nReact-Redux-Form will always ignore actions that it doesn't recognize, so it'll pass right through RRF and your reducer will do just as you expected.\n. Docs on using existing reducers here: http://davidkpiano.github.io/react-redux-form/docs/guides/models.html\n. Thanks @lasergoat ! Fixed in your PR: https://github.com/davidkpiano/react-redux-form/pull/45\n. Thanks @lasergoat :goat: !\n. Huh, that's weird. I'm wondering if it's a problem with material-ui itself. I'll take a look.\n. Redoing the docs and recipes for upcoming v1.0 - I'll reopen if this problem appears again!\n. Hey @greaber, you're absolutely correct. I'm actually in the process of rewriting (and adding a lot to) the documentation right now, and I will be separating the documentation by chapters, with \"model reducers\" being one of them.\nDo you have any suggestions for a better example where you would want to use an existing reducer with React-Redux-Form?\n. Consolidated here: https://davidkpiano.gitbooks.io/react-redux-form/content/model_reducers.html\n. By any chance do you have a link to the repo using uglify2 with createFieldClass?\n. @kmudrick This looks related to https://github.com/davidkpiano/react-redux-form/issues/65 . The solution/workaround there is to provide a .displayName for the custom component.\n. Excellent! :confetti_ball: \n. Yes, the <Form> component can use <Field> validation.\nWhy would you want both? Simple: you might want validation to occur at different times.\n- For <Form>, validation by default occurs whenever a field changes and on submit.\n- For <Field>, validation by default occurs on change, but can be tweaked so that it only validates on blur, e.g. <Field model=\"foo.bar\" validateOn=\"blur\">.\n- The <Field> component can also call asynchronous validation at any time (on blur by default).\nHope that answers your question!\n. That's correct. I'm going to clarify this in the updated docs, but the cleanest pattern is to put any validation you want on submit in the <Form validators={{...}}> prop.\n``` js\nimport { Form } from 'react-redux-form';\nfunction required(val) {\n  return val && val.length;\n}\n// in render() return block:\n\n  // etc.\n```\nEDIT: In react-redux-form@0.8.1, the validation on <Form> occurs (by default) whenever a field value changes. So for most use cases, you can specify all your validation inside of <Form validators={{...}}>.\n. Okay, let's say you have a foo model that looks like this (with a model reducer, of course):\njs\nconst foo = {\n  numbers: [1, 2, \"blah\", 4, 5]\n};\nIf you want to validate that all the items in foo.numbers are a number, you can add a validator such as this one:\n``` js\nimport every from 'lodash/every';\nfunction isNumber(num) {\n  return Number.isInteger(num);\n}\n// in render():\n every(val, isNumber)\n  }}>\n```\nEach validator in <Form validators=...> will get the exact value of whatever model you're pointing to. From there, it's up to you to validate it however you'd like.\n. Yep! RRF makes no assumptions about your model data structure, so you can go as deep as you want with the path you specify.\njs\n// You can do this!\n<Field model=\"user.phones[3].type.foo.bar.baz\">\n  ...\n</Field>\n. Also, here's helpful documentation on the <Form> component that answers your question as well: https://davidkpiano.gitbooks.io/react-redux-form/content/form_component.html\n. Oh, sorry. Yes, it can. You can do this:\njs\n<Form model=\"foo\"\n  validators={{\n    'numbers.type': isRequired\n  }}>\nNotice how the path to the model inside foo is in quotes. All RRF is doing behind the scenes is concatenating the form's model and each validator key with a period; e.g. foo.numbers.type. That's how it knows where to look.\n. > I was a little confused by the current difference in syntax for representing arrays in models (bracket notation) and arrays in fields (dot notation)? But maybe there is a good reason for that?\nYeah, that's a point of confusion -- it's because you might have an object with a key with spaces and/or dots, so there needs to be bracket as well as dot notation. This proposal somehow tries to resolve that.\nAlso, I was thinking of an alternative syntax that minimally abstracts the .$field accessor:\n``` js\nimport { field } from 'react-redux-form';\n// ...\nlet { userForm } = this.props;\nfield(userForm.contacts[1].phone).valid ? 'Good job' : 'Invalid'\n```\nwhere the field(fieldObject) function grabs the magic $field property from it, so that you don't have to make the model stringly typed. The only difference between this and the existing approach is that it won't be a flat structure for the form shape; it'll be a structure that is congruent to the model shape.\n. Yes @chrisblossom, with one fix:\n``` diff\n- field(userForm.contacts[1].phone).valid === userForm.contacts[1].phone.valid\n+ field(userForm.contacts[1].phone).valid === userForm.contacts[1].phone.$field.valid\nfield(userForm.contacts[1]).valid === userForm.contacts[1].$field.valid\n```\nAlso, field would have the same behavior as getField in that it returns an initial field state if the field does not exist. Maybe.\n. Right, with the way RRF works, field state can be on any part of the state.\n. Closing this - I think it's best if we keep the current form shape for now.\n. Can you post a full code example?\n. Might be a React-Bootstrap issue - have you tried 'Input': controls.radio ?\n. @nickzarate This definitely looks like a react-bootstrap issue. Check this example out - not even using Redux or React-Redux-Form, the console fails to log the \"No\" option: http://esnextb.in/?gist=fff6baa60ddd5e42e4ff\n. Issue here: https://github.com/react-bootstrap/react-bootstrap/issues/1690\n. Yes, if the above code works, then you should be able to do this:\n``` js\nimport React from 'react'\nimport { actions } from 'react-redux-form';\nimport { Input } from 'react-bootstrap'\nconst Foo = connect(s=>s)(class Foo extends React.Component {\n  render() {\n    let { dispatch } = this.props;\n    return (\n      \n dispatch(actions.change('user.email', e))}/>\n         dispatch(actions.change('user.email', e))}/>\n      \n    )\n  }\n});\n```\nAnd for that issue, all custom components should have a .displayName property. I'll open a PR to add it to react-bootstrap if it's missing on some of their components.\n. @nickzarate Please see this gist (click Execute) and check the console upon clicking the text. I am successfully getting the value of survey.isStudent logged. http://esnextb.in/?gist=fdc389057dbb786e5925\nAlso, make sure to return (dispatch, getState) => { to provide getState inside your function body.\n. If you want to keep your original code, you can declare it as so: \njs\nexport default combineReducers({\n  survey: modelReducer('forms.survey', initialSurveyState),\n  surveyForm: formReducer('forms.survey'),\n  ... // other reducers\n})\nI will update the docs to clarify this. :smile: \n. The resetValidity issue is a bug, thanks for finding that.\nAs far as validation firing on load, this is standard behavior - the initial validity state of the form should be calculated, e.g. an empty sign up form that hasn't been touched yet is invalid.\nWhat is your use case for not having validation on load?\n. Ah, that's why there's the .touched property on the field. ;-)\n``` js\n// in render() \nlet { userForm: { fields } } = this.props;\n// displaying the error\n{ fields.email.touched && !fields.email.valid &&\n  Please check your email address.\n}\n```\nLet me know if that makes sense. This is the same way that validation works in Angular. If RRF didn't validate on load, the user would technically be able to submit an empty, untouched form because it's \"valid\", which is definitely not something we want.\n. Good question. Would you expect the form to be \"touched\" if it were submitted (or at least attempted)? If so, I can add that functionality in.\n. Right now, no, touched is only passed to the model that is touched.\nYou can set any of these properties by dispatching actions: https://davidkpiano.gitbooks.io/react-redux-form/content/field_actions.html\n. Yes, it would. I'll add that in.\nEDIT: Actually, probably not. Looking into this.\n. @sattaman Version 0.8.4 includes two changes:\n- Submitting a form now sets its touched state to true.\n- Changing/dirtying a field now sets its touched state to true as well.\nValidation on load is the expected behavior, as explained. I'm thinking of an alternate solution of resetting validity that doesn't force you to call multiple actions, stay tuned!\n. Right, because it's possible that a field could never be touched, but the form could be attempted to be submitted (which would cause it to be touched).\nIf you were just checking that the field were touched, then you'd just need to pass the field.\n. > I think submitting an untouched form should either:\n\n\nset the state of the fields to touched=true or\nset the state of the field to submitted=true\n  So that we can display an error message if the user clicks on submit before having tried to fill in the form\n\n\nThis works as expected in recent versions: https://github.com/davidkpiano/react-redux-form/blob/master/test/form-reducer-spec.js#L263-L285\nThat is, when the formReducer receives actionTypes.SUBMIT_FAILED, it will:\n1. Set the .submitFailed and .touched properties to true on the form, and\n2. Set the .submitFailed and .touched properties to true on all of the form's fields\nWhich version are you on? This was fixed in 0.12.7\n. Should be 0.13.1: https://www.npmjs.com/package/react-redux-form\nTry npm install react-redux-form@latest --save\n. Sorry, can you elaborate?\n. That makes sense. I'd probably want the getField() function to be placed in this file: https://github.com/davidkpiano/react-redux-form/blob/master/src/immutable/index.js if possible?\nThat way, you can use it like so:\n``` js\nimport { getField } from 'react-redux-form/lib/immutable';\n// ...\n```\nWhat do you think about that?\n. Yep, separate getField() function, so that the core of RRF remains unopinionated. :)\n. I would rather avoid having to make it depend on Immutable. Would you want to instead have a decorator function that converts the form state .toJS, and then pass it to the original formReducer function, and convert it to an immutable data structure back out again?\n. So here's the plan so far:\n- Have touched follow Angular's implementation (on blur) as you suggested\n- Remove all \"negative\" redundant fields:\n  - blur\n  - dirty\n  - untouched\n. Planning on getting these changes in within the next couple days, wondering if I should deprecate the redundant properties first though.\n. Deprecation has started for these three fields in 0.9.6:\n- dirty\n- blur\n- untouched\n. Interesting. I don't know the best way to solve this other than for developers to just use your solution (which seems simple enough to do). Honestly, a good React UI package should provide displayName for their custom components anyway.\nReact-Redux-Form looks for the display name in order to map the props correctly.\n. Docs updated here to highlight best practices for components without a displayName: ~~https://davidkpiano.gitbooks.io/react-redux-form/content/react_native_&_custom_components.html#custom-components~~ https://davidkpiano.gitbooks.io/react-redux-form/content/custom_components.html\n. You can always use RRF as simply a collection of actions and reducers to update the relevant state of each of your fields. In this case, you can use RRF with your component defined above like so:\nSuppose your date lives in the user.birthdate model:\n``` js\n// in render():\nconst { user } = this.props;\nreturn (\n dispatch(actions.change('user.birthdate', val))}\n  value={ user.birthdate } />\n);\n```\nThis should work. Does this make sense?\n. If you are doing it like I did it in the code sample above, you don't need <Field>. The <Field> component is just a helper that abstracts all that for convenience; it's definitely optional.\n. Yes - and here's how you can do it:\n``` js\nconst CustomField = createFieldClass({\n  DayAndMonthInput: (props) => ({\n    onChange: props.onChange,\n    value: props.modelValue\n  })\n});\n// Then use it:\n\n\n\n```\nOf course, it's best to give your DayAndMonthInput a .displayName = \"DayAndMonthInput\".\n. Okay, please do! createFieldClass just lets you avoid having to manually map everything every single time.\n. Just pushed react-redux-form@0.8.5 that fixes the propType issue!\nAlso, you can mitigate that issue with <Field> by just adding value to your custom control:\njs\n<CustomField model=\"user.birthdate\">\n  <DayAndMonthInput value={ user.birthdate } />\n</CustomField>\nI'll look into why defaultProps might have the behavior of overwriting the value.\n. > In createFieldControlComponent, there is this code that seems to recursively accumulate props on nested components, which looks wrong to me, but I may be misunderstanding:\nYeah, don't worry - props aren't accumulated recursively. Rather, the component tree is traversed to look for valid controls inside <Field> - if a component is not a control, it is ignored.\nThe defaultValue mapping is for when you have set an initialState in your modelReducer - it properly reflects the value in the <input>. \n\nThat makes me wonder if I am confused about the semantics of defaultValue -- I would have guessed that the text control would map value to props.modelValue, not defaultValue.\n\nIt's important that the components remain uncontrolled - since RRF allows you to update the model value at any time, e.g. on blur or debounced, etc. Which, of course, would be problematic if the components were controlled.\n\nMore generally, it might be useful to have in the docs a recommendation about how to design the props on custom components if one has the luxury of doing so. And the recommended ways should have preset mappings in controls under suitably named keys.\n\nAgreed. I'm thinking for certain components, it's better to manually map them yourself, which isn't difficult at all. The example (from the previous comment) demonstrates this pretty well.\n. Ah, good catch. I'm currently reworking the documentation and will address this.\n. I'll add this to the docs, but thankfully this is not an issue - inputs with values that can be written are not controlled components by default.\nThat means, if you add value={...} below, you'll get your expected result! :smile: \ndiff\nclass Root extends React.Component {\n  render() {\n    return (\n      <div>\n        <Field model=\"test.field\">\n-          <input type=\"text\" />\n+          <input type=\"text\" value={store.getState().test.field} />\n        </Field>\n        <button onClick={(e)=> store.dispatch(actions.reset('test'))}>Click me</button>\n      </div>\n    );\n  }\n}\nLet me know if that makes sense!\n. Thanks! Would you mind fixing these linting errors?\njs\n  139:7  error  Expected an assignment or function call and instead saw an expression  no-unused-expressions\n  140:7  error  Expected an assignment or function call and instead saw an expression  no-unused-expressions\nJust make this change for both expressions:\ndiff\n-  props.validators && dispatch(setValidity(model, getValidity(props.validators, value)));\n+  if (props.validators) {\n+    dispatch(...);\n+  }\n. Thanks @ffxsam ! Fixed the documentation.\n. In normal Redux, you would \"prepopulate\" a model with an initialState in your reducer. React Redux Form works the same way, by providing the initialState as the second argument to the reducer creator:\n``` js\nimport { modelReducer } from 'react-redux-form';\nconst initialUserState = {\n  firstName: '',\n  lastName: ''\n};\nconst userReducer = modelReducer('user', initialUserState);\nexport default userReducer;\n```\nAll the fields will be prepopulated, using defaultValue (if you're using <Field>). Hope that helps!\n. Sure, you can do that with actions.merge(model, object).\n. It's because I'm in the process of rewriting (updating) the documentation for 1.0 and still have a place for the recipes. I'm going to be moving the recipes to a separate location though (ideally a live playground where you can play around with the code).\n. Much thanks, @ffxsam! Feel free to let me know your pain points with creating forms, essential features you'd like to see, etc. as we get this ready for 1.0. (I am already using RRF in production, though)\n. Hm, the only problem with that is that actions.xor can add or remove a value in an array.\n[1, 2, 3] xor 2 = [1, 3]\n[1, 2, 3] xor 4 = [1, 2, 3, 4]\n. > ...because react-select set onChange to undefined by default\nWell that's silly.\nAnyway, I'm not sure how to go about this, because I want to allow developers to override properties that <Field> attaches to controls, e.g.:\njs\n<Field model=\"foo.bar\">\n  <input type=\"text\" onChange={(e) => customChange(e)} />\n</Field>\nDo you think the above is a necessary use-case? Or can we get by with <Field> overriding the props?\n. > Is there any way to detect which props user declare in component yourself, and which come from defaultProps?\nI don't think so. I think that after the fact, it just becomes normal props.\n. I reprioritized the props as you suggested in react-redux-form@0.8.10, mind trying it out and seeing if it fixes your issue?\n. #77 verified that the issue has been resolved with the change! :fireworks: \n. Thank you!\n. Yes you can, and it's actually pretty simple to do. Did you take a look at this recipe? http://davidkpiano.github.io/react-redux-form/#/recipe/dynamic-fields\n. Sure, here you go: http://davidkpiano.github.io/react-redux-form/docs/index.html#/recipe/dynamic-fields\n. @eminaz Yes it has, in preparation for V1. I'll see if I can find the original, but there's no magic to making dynamic forms. It just works:\n``` js\n\n\n\n// will dynamically modify...\n\n\n\n```\nContrived example, but you get the idea \ud83d\ude04 \n. Duplicate of #74, but I've recently pushed a commit that changes the priority of the control's own props in the prop mapping, as suggested in #74: https://github.com/davidkpiano/react-redux-form/commit/a78d19b39f0e6341506115f5b5e0cfa221639233\nCan you do me a favor and try it out with react-redux-form@0.8.9 to see if that fixes the issue?\nEDIT: Actually, that thread suggested the same thing you did. I'll retry with that suggestion.\n. Okay, the change is published under react-redux-form@0.8.10. Try it out! :)\n. Fantastic! Thank you for verifying!\n. This actually looks like the perfect candidate for normalizr, that your data can be normalized per its unique keys into dictionaries:\n``` js\n// from ...\nmapEntry: [\n    {\n        mapKey: 'answer_3',\n        mappedValue: '75'\n    },\n    {\n        mapKey: 'answer_1',\n        mappedValue: '50'\n    }\n]\n// to...\nmapEntry: {\n  answer_3: { mappedValue: 75 },\n  answer_1: { mappedValue: 50 }\n}\n```\nNormalized data is much easier to use in any Redux application, especially React-Redux-Form. Your model can then just become this: <Field model=\"mapEntry.answer_1.mappedValue\"> without the complex (and somewhat fragile) onChange overrides or custom prop mapping.\nIs this a viable solution?\n. Awesome! What do the JSON pointers look like, out of curiosity?\n. Interesting. Still sounds like normalizr might be good, because that can map directly to:\njs\nmapEntry: {\n  3: { mappedValue: 75 },\n  1: { mappedValue: 110 }\n}\n. Yes, every path is referenced using bracket/dot notation, e.g. via icepick and lodash's path() for get(). That means you should be fine, even if a property name contains spaces or dots, because you can just do this: \"foo.bar['prop with spaces']['prop.with.dot'].baz\"\n. Now in 0.8.11, onChange is called when the enter key is pressed on the field. Can you please confirm that this satisfies your use-case?\n. Fixed in 0.9.4! Test case modified to reflect your use case:\ndiff\n    it('should change the model upon pressing Enter', () => {\n      const field = TestUtils.renderIntoDocument(\n        <Provider store={store}>\n          <Field\n            model=\"test.foo\"\n+           updateOn=\"blur\"\n          >\n            <input type=\"text\" />\n          </Field>\n        </Provider>\n      );\n. If your component is a connected component, you already have access to the current state. From there, you can use the parse prop to parse the view value for the model. I'll add this to the documentation - I must have forgotten to put it there (the documentation is still being completed).\n``` js\nfunction parseWeight(value, prev) {\n  let result = parseInt(value);\nif (result > 100) return prev;\nreturn result;\n}\n// in connected component's render() method:\nlet { user } = this.props;\nreturn (\n   parseValue(value, user.weight)}>\n    \n\n);\n``\n. It definitely can, but it would be the exact same as just passing in the value itself. Do you think that would be a good enhancement? To haveparsebe a function take in two arguments:valueandpreviousValue?\n. Ah, no, it's much simpler than that. In order to allow model changes to occur at any time, inputs are _uncontrolled_ components by default. That means, if you want to prevent the input field from actually showing111instead of11`, you can just make it controlled like so:\ndiff\n<Field ...>\n-  <input type=\"text\" />\n+  <input type=\"text\" value={ user.weight } />\n</Field>\n. Labeling this as a wontfix for now, since, from my tests, it seems that it can't reliably reflect an updated value that is not a string. Here's the test:\n``` js\n  describe('with  (complex values)', () => {\n    const store = applyMiddleware(thunk)(createStore)(combineReducers({\n      testForm: formReducer('test'),\n      test: modelReducer('test', {\n        foo: 2,\n      }),\n    }));\nclass CrazyValue {\n  constructor(val) {\n    this.value = val;\n  }\n}\n\nconst field = TestUtils.renderIntoDocument(\n  <Provider store={store}>\n    <Field model=\"test.foo\">\n      <select>\n        <option value={{ one: 1 }} />\n        <option value={2} />\n        <option value=\"three\" />\n        <optgroup>\n          <option value={['four']} />\n          <option value={[5, 'five']} />\n          <option value={new CrazyValue(6)} />\n        </optgroup>\n      </select>\n    </Field>\n  </Provider>\n);\n\nconst select = TestUtils.findRenderedDOMComponentWithTag(field, 'select');\nconst options = TestUtils.scryRenderedDOMComponentsWithTag(field, 'option');\n\nit('should select the option that matches the initial state of the model', () => {\n  assert.isTrue(options[1].selected);\n  assert.isFalse(options[0].selected);\n  assert.equal(select.value, 2);\n});\n\nit('should dispatch a change event when changed', () => {\n  TestUtils.Simulate.change(options[0]);\n\n  assert.deepEqual(\n    store.getState().test.foo,\n    { one: 1 });\n});\n\nit('should select the appropriate <option> when model is externally changed', () => {\n  store.dispatch(actions.change('test.foo', ['four']));\n\n  assert.isTrue(options[3].selected);\n  assert.equal(select.value, 'four');\n  assert.deepEqual(\n    store.getState().test.foo,\n    ['four']);\n});\n\nit('should work with <optgroup>', () => {\n  TestUtils.Simulate.change(options[5]);\n\n  assert.isTrue(options[5].selected);\n  assert.deepEqual(\n    store.getState().test.foo,\n    new CrazyValue(6));\n});\n\n});\n```\nThe last test fails.\n. For the meantime, I'm going to respect the original behavior of the DOM <select> and <option> components and keep the values as strings. I might make an exception for numbers and booleans, however.\n. @Psykar it's difficult because the event emitted by a native <option> is always going to convert the option's value prop into a string. I'll keep trying to explore solutions, perhaps similar to how radio buttons are already behaving (you can have complex values for radio buttons).\n. Closing due to inactivity - this is best done with custom components that can properly handle complex data types in <select> - preferably with some sort of hash map in the component's state.. What does your store setup look like?\n. Ah, so the model argument of the modelReducer and formReducer are expected to be the exact path of your model. In this case, you should change it like so:\ndiff\nconst quote_reducers = {\n  quote: combineReducers({ \n-    quote: modelReducer(\"quote\", defaultQuoteFields),\n-    quoteForm: formReducer(\"quote\", defaultQuoteFields)\n+    quote: modelReducer(\"quote.quote\", defaultQuoteFields),\n+    quoteForm: formReducer(\"quote.quote\", defaultQuoteFields)\n  })\n}\n. Fixed in react-redux-form@0.8.12! Now if you dispatch actions.resetValidity('user') to an entire form (such as user), then all of the form's fields will also have their validities reset.\n. Just added an enhancement for this in 0.8.13: Now the <Field> component can specify a custom changeAction prop. The changeAction is an action creator (function) that takes in two arguments:\nchangeAction={(model, value) => {...}}\n- model - the model that is being changed\n- value - the value that the model is being changed to\nSo, to solve your problem, you can do something like this:\n``` js\nimport { actions } from 'react-redux-form';\nconst submitPromise = ... // a promise\nfunction changeAndSubmit(model, value) {\n  return (dispatch) => {\n    dispatch(actions.change(model, value));\n    dispatch(actions.submit('user', submitPromise));\n  };\n}\n// Then, in your  components...\n\n\n\n```\nRemember: you can always make your custom fields to group together similar props:\n``` js\nclass AutoSubmitField extends React.Component {\n  render() {\n    let { model } = this.props;\nreturn (\n  <Field model={ model }\n    changeAction={ changeAndSubmit }\n    updateOn=\"blur\">\n    { this.props.children }\n  </Field>\n);\n\n}\n// Use anywhere!\n\n\n\n```\n. @enkay Can you outline an example use-case for this? That way I can wire up an example/unit test.\n. Wouldn't this just be something like this?\njs\n<Form model=\"bookSearch\" onSubmit={...}>\n  <Field model=\"bookSearch.query\">\n    <input type=\"search\" />\n  </Field>\n  <Field model=\"bookSearch.genres[]\">\n    <input type=\"checkbox\" value=\"fiction\" />\n    <input type=\"checkbox\" value=\"historical\" />\n  </Field>\n</Form>\n. This might help: https://github.com/davidkpiano/react-redux-form/issues/296#issuecomment-230113569\n~~And then you can do this: <input type=\"search\" onBlur={() => this.handleSubmit()} /> from that instance method.~~ See response below.\n. js\nclass App extends React.Component {\n  attachNode(node) {\n    this._form = findDOMNode(node);\n  }\n  handleBlur() {\n    this._form.submit();\n  }\n  handleSubmit(values) {\n    // you get all the values here\n  }\n  render() {\n    return (\n      <div>\n        <Form\n          model=\"...\"\n          onSubmit={this.handleSubmit.bind(this)}\n          ref={this.attachNode.bind(this)}\n        >\n          <Field\n            model=\"test.foo\"\n          >\n            <input type=\"text\" onBlur={() => this.handleBlur()} />\n          </Field>\n        </Form>\n      </div>\n    );\n  }\n}\n. That's probably a bug. I just need to handle the .remove action in the form reducer as well. I will fix this.\n. Fixed in 0.9.3!\n. Unfortunately it's not as easy as having an ad-hoc { type: actionTypes.REMOVE } action. I'm thinking of a better, more robust solution, similar to Angular 1's track by (and Angular 2's ngForTrackBy.\nWhy? Consider a model that has the elements [0, 1, 2, 3]. If you move, filter, or remove items and RRF handles the actions in a way that maintains field references based on item value, you'll get your expected result.\nBut what if you do an actions.map action that increments each item? Then you'll have [1, 2, 3, 4], which ambiguously looks like some items have shifted, instead of changed, to RRF.\nSo let's consider a syntax similar to this:\n``` js\nimport { Field, track } from 'react-redux-form';\n// consider a state like:\nconst items = [\n  { id: 100, foo: 'bar' },\n  { id: 200, foo: 'baz' },\n  { id: 300, foo: 'etc' }\n];\n// ...\nfunction getID(item) {\n  return item.id;\n}\n// in render() return:\n{ myModel.items.map((item) =>\n\n\n\n}\n```\nIs this too weird? Let me know your thoughts.\n. ^ Oh, forgot to mention, this would mean that there would be a new .key property on the field object, so you'd have something like this:\njs\nmyModel.fields = {\n  'items.0': { key: 100, ... },\n  'items.1': { key: 200, ... },\n  'items.2': { key: 300, ... },\n}\nAnd probably a helper function or a third parameter to the getField() helper function:\njs\n{ getField(myModelForm, 'items', 200).valid\n  ? <div>Valid!</div>\n  : <div>Not valid.</div>\n}\n. > So maybe you are suggesting using the trackby keys as an alternative to array offsets?\nYes, and one good reason for this is that things will get really complicated if we keep track of array offsets rather than keys, and tracking by keys is more robust. Consider this:\n- Data from API: [1, 2, 3, 4]\n- Client data after shuffling: [2, 3, 4, 1]\n- Client maintains array offsets\n- Client saves to API\n- Hard refresh page and grab data from API again: [2, 3, 4, 1]\n- Array offset references are lost.\nIt's better to reference by a unique ID.\n\nOr as @chrisblossom was suggesting maybe, steer clear of arrays in your state as they are trouble? Instead base everything around objects?\n\nYou can do this; RRF is not opinionated and will work perfectly fine if you use something like normalizr.\n. @mdgbayly I'm introducing an enhancement in the next minor version (currently on the master branch) that solves this succinctly, using the track(model, predicate) function, where the predicate can be a:\n- function that returns true for the first valid field, or...\n- a handy Lodash Array, Object, String shorthand: https://lodash.com/docs#findKey\n``` js\nimport { Field, track } from 'react-redux-form';\n// ...\n\n\n\n```\n^ The above code will update the user.name in the team.users array whose id == 1234. This will work as expected even if the array is shuffled, manipulated, mapped, filtered, deleted, etc. :smile: \nComing to 0.10.0!!\n. Can you show me the exact code so I could further diagnose the problem?\nAnyway, when a component is controlled, it means it represents the model value all the time. This is problematic if you want to change on blur, for example - on blur, what you type in an input won't always be the same as what your model value is.\n. The example you showed me: \n```\n|Option 1| x\n|Option 2| x\nand I delete Option 2, the page renders as:\n|Option 1| x\n```\nseems like the expected result, at least to me. What should the expected result be? Any chance you can provide a screenshot/gif of the page?\n. Have you tried adding value to the phones field?\njs\n<Field model={`info.phones[${i}]`} key={i}>\n  <input type=\"text\" value={info.phones[i]} />\n</Field>\n. Hmm... I'm pretty sure we can make it a controlled component when updateOn=\"change\" (which it is, by default). The problem is if you want updateOn to be anything else besides change, like \"blur\".\nFact of the matter is, you can't have change on \"blur\" with a controlled component, because the view value is different than the model value.\nI'll explore some solution for this, because in essence, you might be right - it should be able to accurately show the value all the time.\n. For now, I've added this to the FAQs in the docs. There's nothing stopping you from creating a custom <Field> that does control the value, though. I'd imagine something like this would work:\njs\nconst ControlledField = createFieldClass({\n  text: (props) => ({\n    ...controls.text,\n    value: props.modelValue\n  })\n});\nI might revisit this in the future, or for V1 - there's quite a few reasons where having a controlled input would not be optimal and would case more headaches than not.\n. Can you show me your code so I can see where it is breaking for you?\n. Why not do a simple check for undefined?\njs\nconst standardControl = props => ({\n    onChange: props.onChange\n    , value: typeof props.modelValue === 'undefined' ? props.value : props.modelValue\n})\n. Ideally, the \"right way\" to do it would be to not map value in your prop mappings, and instead do it in your view (if you want the component to be controlled):\njs\n<CustomField model=\"publication.date\">\n  <PublicationDateInput value={ publication.date } />\n</CustomField>\nThis will allow you to use default props for your value still.\n. The values are only flipped for .errors - if you check .validity, they match whatever is returned from each of the validators.\nA validator validates; i.e. it asks the question, is this value valid? Each value gets \"flipped\" for .errors to allow the capability for there to be error messages, even though I strongly do not recommend hardcoding error messages in error validators.\n. To allow for error messages. For .validity, a truthy value means \"valid\", and a falsey value means \"invalid\". Makes sense, right? However, for .errors, a truthy value means \"is an error\" and a falsey value means \"is not an error\", and since strings are truthy, they can represent something that is an error with an error message.\n. Does this make sense? Or should I keep this ticket open? @ffxsam \n. > I get a bunch of deprecation warnings every time I type, even though I'm not using any of the deprecated props.\nSorry about that! Update to 0.9.8 and you won't see the deprecation warnings anymore.\n\nHitting submit without touching any fields still does nothing. The submitFailed property remains false in the form property list.\n\nLooking into that now...\n. Last part fixed just now in 0.9.9! It was just an oversight. I definitely welcome any PRs and contributions! The codebase is very modular/function-based, so hopefully it's easy enough to grok.\n. Glad it works! The behavior of (re)touched is to trigger touched if a field is changed/blurred, not focused, but if that ends up being a bug we can open another ticket for it.\n. > if someone hits the submit button without touching several fields, I'd want those fields to self-check if they're required or not, and then prevent the form from submitting.\nYou can accomplish this by putting the field validators in <Form>. Sorry, the documentation is lacking in examples (I'll add it soon) but you can essentially do this:\n``` js\nfunction isRequired(val) {\n  return val && val.length;\n}\nfunction handleSubmit(data) {\n  //...\n}\n handleSubmit(data)}\n  validators={{\n    title: isRequired,\n    foo: (val) => val == 'bar'\n  }}>\n  \n\n```\nWith this, the validators of the <Form> will run on load, on every change (only for the fields that have changed), and on submit. If invalid, the function passed into onSubmit will not be called.\n. @ffxsam I'm working on simplifying this. A near-future release will accurately prevent onSubmit for an invalid form, no matter where the validation came from (an action, inside <Field>, inside <Form>, etc.)\nAny change in a field state should also change the form state, especially for .valid, .pristine, etc. states.\n. @ffxsam Enhancements in 0.9.2 just landed, which enables onSubmit to be prevented if the form is invalid, no matter where the validation came from (from <Form>, <Field> validators, or even actions).\nAs far as this:\n\nUser clicks submit. All invalid fields display an error. (at this point, they would say \"Field is required.\")\n\nLet's talk about this as an enhancement. How about having a property like submitAttempted or submitFailed?\n. > IMO, I feel like there are already way too many properties on the fields & form. It's difficult to remember and keep track of what they do. Simplification would be awesome.\nYou're absolutely right, which is why I'm strongly considering #60 for version 1.0.\n\nJust brainstorming here: what about a boolean option one can set, so if submit is attempted and some fields are invalid, the error properties will be set for those fields?\n\nWhat would this look like in code? Trying to visualize this.\nI do think a submitFailed flag would be useful, with this logic:\n- If not submitted, submitFailed = false\n- If submitting, submitFailed = false\n- If submit failed, submitFailed = true\n- If resubmitting, submitFailed = false\nWould be good to have a retouched flag as well, that signals if a user has touched the form after a submit, with this logic:\n- If not submitted, retouched = false\n- If submitting and touched, retouched = false\n- If submitted and not touched, retouched = false\n- If submitted then touched, retouched = true\n- If submit failed then touched, retouched = true\n- If resubmitting/pending (regardless of current retouched state), retouched = false\n. The .submitFailed and .retouched states have been added to the form state in 0.9.6! Documentation coming up.\n. Fixed in react-redux-form@0.8.15 ! Now parse will always occur before validation.\n. Thanks! Would you mind fixing the linting errors? (check Travis)\n. Thanks @i4got10! \n. Thanks for this! Merging. :ship: \n. Thanks! And yep, you can do it that way. Are you saying that you want to dynamically initialize values, after the store has been created/initialized already?\n. Sounds great! You're right, would be a good enhancement.\n. Ah sorry, I just refactored this section that solves the same problem! Thank you for your insights, however! :+1: \n. Looks good to me, thanks!\n. If you are implementing the <Field> component, keep in mind that your components will be uncontrolled components. More on that here: https://facebook.github.io/react/docs/forms.html#controlled-components\nWhy? This is to allow for changes to occur at any time; e.g. on blur, debounced, etc.\nHow to bind:\nSimply pass in the value in your connected component:\njs\n<Field model=\"user.email\">\n  <input type=\"text\" value={ user.email } />\n</Field>\nIn the future, I might think about having components be controlled, in that they are in sync with a viewValue rather than the value, but that may cause performance issues (actions occurring every single change, etc.) \n. I added this to the FAQs for now. If anything is going to come from this, it might be something like a <Field controlled={true}> prop, but not likely.\n. No problem! The easiest way to do this is to pass in your own custom action creator into the  changeAction prop on the <Field>, like this:\n``` js\nimport { Field, actions } from 'react-redux-form';\nfunction anotherAsyncAction(model) {\n  // ... your custom async action creator\n}\n// in render() somewhere\n (dispatch) => {\n    dispatch(actions.change(model, value)); // default behavior\n    dispatch(anotherAsyncAction(model)); // your custom async action\n  }}>\n  \n\n``\n. Hey, took a quick look at this and it is fantastic! Would you mind putting it in a PR? I can go ahead and start writing tests for it when I get the time.\n. I'll definitely add this to the main repo soon! Great work and thanks for this, both of you!\n. Merged! Thanks a ton! \ud83c\udf89 \ud83c\udf8a \n. Little bit confused by the code. Can you post a full code example?\n. Thanks! Themodelargument ofmodelReducer(model, initialState)` has to be the absolute path of the model, relative to the entire store. So try this and see if it works:\ndiff\nexport const forms = combineReducers({\n-  customer: modelReducer('fooModel', {}),\n+  customer: modelReducer('forms.fooModel', {})\n});\n. > Thanks for a fantastically useful, lucid, and enjoyable-to-use library.\nGreatly appreciated! :smile: \nYou're right; it would be great if it worked as above. I'll add a test case and see if this is a bug.\n. @joshuarh It was indeed a bug - now validators will be validated on the exact model value instead of the value passed in from the event in 0.9.1 :rocket: \n. Is it possible to post a full working code example? \nMy thinking is that it might not even be necessary to programmatically maintain the focused state of the proper field, with the proper handling of key. For example:\ndiff\n{ myModel.items.map((item, index) => \n  <Field model=\"myModel.items[index]\"\n-    key={ index }>\n+    key={ item.id }>\n    <input type=\"text\" />\n  </Field>\n}\nJust a thought. I'd have a better idea of how best to handle this with a complete (working) code example.\n. Fixed in 0.9.5!\n. This is related to https://github.com/davidkpiano/react-redux-form/issues/97 . I'm starting to think that if the Field updateOn is \"change\", then the component should be a controlled component.\nAgree? :+1:  :-1: @chrisblossom @jekamoroz @andrewQwer \n. @chrisblossom has a good point. The controls being unconnected might be a little annoying (in that you have to pass in the value to make it connected), but it also gives you the ability to format the value however you want without having to learn yet another ad-hoc <Field> property.\njs\n<Field model=\"user.phone\"\n  parser={parsePhone}\n  formatter={unparsePhone}>\n  <input />\n</Field>\nas opposed to just:\njs\n<Field model=\"user.phone\"\n  parser={parsePhone}>\n  <input value={unparsePhone(user.phone)}/>\n</Field>\n. I think the best solution right now is to just pass it into your value. Controls are uncontrolled by default (which is a feature, not a bug :wink: ) to provide lots of flexibility to you, the developer. If we make them controlled, it will become much more complicated to do custom things with the values and the model value updates.\nSo here's the fix:\ndiff\n<Field model=\"editUser.firstName\">\n    <div className=\"flex-row\">\n           <label htmlFor=\"firstName\" className=\"control-label\">First name</label>\n           <input type=\"text\"\n                id='firstName'\n                className=\"form-control width240\"\n                placeholder=\"First name\"\n+               value={editUser.firstName}\n            />\n    </div>          \n</Field>\nHope that helps :smile: \n. Ah, sorry about that. I'll go ahead and write release notes for 0.9.0. \n. Updated here: https://github.com/davidkpiano/react-redux-form/releases/tag/v0.9.4\n. Will be released in the next patch!\n. Fixed in 0.9.6!\n. Seems like a React/JS issue and not a RRF issue. Can you post your full working code?\n. Ah yes, that is a bug. I just need to add a null check. Will fix soon!\n. Fixed in 0.9.6!\n. What does the wrapper look like?\n. Do you have a userForm? http://esnextb.in/?gist=68b03db2ad0182c5915ed2dec1176c85\n. Try it now with react-redux-form@0.9.7 (just published) - the batch validation action has been refactored and a couple more test cases added, which should solve your issue.\n. What doesn't work about <select value={}>? Can you post some working code that demonstrates the issue?\n. Looks good! Merging it in. Thank you!\n. It should be working per this spec: https://github.com/davidkpiano/react-redux-form/blob/master/test/immutable-model-reducer-spec.js\nCan I see a full code example of it not working?\n. Sorry, it should be:\ndiff\n- import { createModelReducer } from 'react-redux-form/immutable';\n+ import { modelReducer } from 'react-redux-form/lib/immutable';\nIs there somewhere in the documentation that has react-redux-form/immutable instead of react-redux-form/lib/immutable?\n. Are you trying to put in more than one child component inside <Field> ?\nFor now, try adding:\n``` js\nimport { View } from 'react-native';\n\n  ...\n\n``\n. Fixed here: https://github.com/davidkpiano/react-redux-form/commit/8f3cbb6d52e9d7e2673b3d802d92234a07e736c3 (ignore the incorrect commit title)\n. This is probably because you don't have a form reducer, although I fixed that check I believe... are you on the latest version?\n. No, it's not a requirement. RRF should check if a form state exists. If it doesn't, that's totally fine -- it'll just calculate the validity from the` validators before submitting.\nCan you see if that works with the latest version?\n. > I'm still seeing this issue if the form does not have any custom validators either. Is this a valid use-case for RRF?\nYes, should be, RRF handles more than just validation. Can you share the code that can demonstrate the issue?\n. @ffxsam and @bkudria, this has been recently fixed in react-redux-form@0.9.14 :smile: \nThe form reducer is not required. See this issue for more info: https://github.com/davidkpiano/react-redux-form/issues/139\n. Can you show me the code that doesn't work?\n. Good feedback @ffxsam! I'll make the title of that section more clear.\nAlso, much thanks @mdgbayly, hope that createFieldClass is working fine for you!\nOff-topic: I was thinking of renaming this function customField() instead of createFieldClass in v1. Thoughts? Just wanted to make things more succinct/easy to remember, such as createModelReducer -> modelReducer, etc.\n. > First thought it seems like it could make styles etc complicated. What about just having a showError true/false state per field?\nI feel like this would make things more complicated, since you'd have to do this for every field and would result in unnecessary rerenders.\n\nEDIT: Also, the ability to store error messages already exists with the errors field (I think also possible with the validity field as well, just more difficult because of the way valid works.\n\nIt's not encouraged, however, because of how validation works. RRF assumes that you won't hard-code error messages in your validation functions, but still gives you the option to have anything truthy (like a string) represented in .errors.\nPer @lasergoat 's suggestion, I'm thinking along the lines of this for styling:\njs\n<Errors model=\"...\"\n  component={(msg) => <span className=\"error\">{msg}</span>}\n/>\nwhich will give a lot of flexibility to how your error messages are displayed.\n. This is now available in react-redux-form@0.10.0!\n. This would be a great addition. Currently, actions.remove is for arrays only, and the behavior should mirror https://lodash.com/docs#remove (which it currently doesn't; I'll fix that.)\nLet's look to https://lodash.com/docs#omit for inspiration, so you can do:\njs\ndispatch(actions.omit('choices', 'answer_1'))\nWhat do you think?\n. This is now available in react-redux-form@0.9.13! You can omit one or many properties at once:\njs\ndispatch(actions.omit('choices', 'answer_1'));\ndispatch(actions.omit('choices', ['answer_1', 'answer_3']));\nWill close when the docs are updated.\n. Now documented here: https://davidkpiano.gitbooks.io/react-redux-form/content/model_actions.html#actionsomitmodel-props\n. Hey @ffxsam, you can do this the vanilla Redux way by just providing an initial state to either your modelReducer() or your existing modeled() reducer:\n``` js\nconst initialState = {\n  firstName: '',\n  lastName: '',\n};\n// creating a store...\n{\n  user: modelReducer(user, initialState),\n  user: modeled(userReducer), // existing user reducer with the initial state\n}\n```\nYou can also use actions.load(model, value) to \"load\" in the value of your model without triggering a \"change\" action. This is good when you want to initialize fields asynchronously.\nI'll add documentation for this soon; it was a recent addition.\n. Oh, it's because the controls are not connected. You can simply connect them yourself by doing something like this:\njs\n<Field model=\"foo.bar\">\n  <input value={foo.bar} />\n</Field>\n. It's a good point that you brought up, though! I'm still debating whether controls inside <Field> should be controlled by default. This might be able to work even if you have this:\njs\n<Field model=\"foo.bar\"\n  updateOn=\"blur\">\n  <input type=\"text\" />\n</Field>\nbecause the value would be mapped to a string viewValue on the formReducer updated on every change, even if the model value on the modelReducer doesn't update on every change.\nOnly caveat: a formReducer for the model would be required for this to work.\n:+1: ? :-1: ?\n. Yes, if you are mapping value: props.modelValue then it is setting the value=... prop of the control, thus controlling it.\n. I'm not sure about using it with Mongo (no experience in that) but you can load initial data (aka autopopulate) like so:\njsx\n// add other props as needed\n<LocalForm initialState={/* your initial state */}>\n  // ...\n</LocalForm>. Try initialState={this.state.scene}. Can you console.log(this.props.scene) - and see if it initially is null or something? If it's not initially null/undefined, it should work as expected.. Right, sorry about that. In 1.0, createFormReducer will be deprecated and it'll just be formReducer. For now (and the future) it's best to use formReducer. So this will be fixed in V1 :relieved: \n. Looks good, and all the tests pass. Thank you!\n. LGTM, thanks!\n. I'll consider this for 1.0, based on our discussions.\n. I'm going to shelve this one for DX reasons, as the code developers would now have to write to prevent Uncaught TypeError: Cannont read property '...' of null errors would have to be more verbose:\ndiff\n-{form.field.errors && form.field.errors.required ? ... }\n+{form.field.errors.required ? ... }\n. Oh, gotcha. In V1, this is supported:\njs\nconst myFormReducer = formReducer('foo', {}, {\n  initialFieldState: { errors: null, validity: null }\n});\nif you want to override the initial field state. The signature is formReducer(model, initialState, options) where options is currently:\njs\n{\n  plugins: [],\n  initialFieldState: {},\n}\n. Sorry about the GitMagic thing! Still working on configuring it.\nAnyway, if you do updateOn=\"blur\" instead of changeOn=\"blur\" (nonexistent prop) then it should work as you have it.\n. @diegodesouza The issue was that <Form> was choking because it couldn't find a formReducer for the model.\nThis has been patched in react-redux-form@0.9.14, so you can just grab the latest to solve your issue! \n. Looks good! The only thing I'm worried about is that this can, in some cases, make onSubmit not behave as expected if the custom component doesn't implement onSubmit.\nThen again, RRF isn't supposed to make assumptions :stuck_out_tongue_winking_eye: \n. Sure, check back again in an hour\n. Should be available now in react-redux-form@0.10.2!\n. Yes, this is intended. This is because a field's validity can be a mapping of validation keys to validity:\njs\n{\n  required: true, // required is valid\n  legalChars: false, // legalChars is invalid, contains illegal characters\n}\nAnd these are not fields, per se. In the future (pretty soon, probably tomorrow), I'll add the setFieldsErrors option, which will allow you to just do this:\njs\ndispatch(actions.setFieldsErrors('signup', payload.error));\nIt will have the same semantics as actions.setFieldsValidity, except for errors instead of validity. Sound good?\n. Okay, expect it tomorrow morning. Sorry for the delay!\n. Now released in ~~v0.10.3~~ v0.10.4 !\n. Hmm interesting, is there anything else hiding behind production variables in your app? It's hard to diagnose this problem without seeing a full code example.\n. Would you mind quickly adding redux-logger https://github.com/fcomb/redux-logger to your middleware and verifying that the state is in fact getting changed?\nMaterial-UI is pretty buggy to work with at the moment - I'll investigate further.\n. Fantastic! In v1.0, I'll be introducing the <Control> component, which is just a lower-level component (<Field> uses it internally, currently).\nThe API would look something like this:\n``` js\nimport { controls, Control } from 'react-redux-form';\nimport TextField from 'material-ui/wherever';\n// render...\n\n``\n. Yes, even thoughcreateFieldClass` will still work (I'll eventually deprecate it).\nThe idea is that createFieldClass enables the custom Field to \"recognize\" custom controls so it can know exactly how to map props/event handlers to it.\nSoon, with <Control>, it will just recognize the Control and map the props according to the Control's props.\nAlthough, in many cases, you won't even need <Field>:\n``` js\n// FUTURE SYNTAX!\nimport { Control } from 'react-redux-form';\n// instead of this...\n\n\n\n// it will look like this...\n\n```\nThis does not mean that <Field> will be deprecated, or that there will be any breaking changes, thankfully :)\n. Just like normal:\n``` js\n doSomething()} // will execute after dispatching actions.blur\n  // ... etc.\n\n```\n. Yep! And ideally there'd be a tiny 3rd-party library for this:\n\n``` js\nimport { MUIControl } from 'rrf-material-ui';\n// render...\n\n```\n. I think this is a good idea - essentially we just need an API for decorating form reducers with the same semantics as the form reducer itself. I'll try to think of something but I'm definitely open to suggestions.\n. @asvetliakov What do you think of this approach?\n``` js\nimport { formReducer, enhanceForm, updateField } from 'react-redux-form';\nconst userFormReducer = formReducer('user', initialState);\nconst fieldIconStatus = (formState, action) => {\n  switch (action.type) {\n    case MY_ACTION:\n      return updateField(formState, { iconStatus: action.status });\n    default:\n      return formState;\n  }\n};\nexport default enhanceForm(userFormReducer, [\n  fieldIconStatus,\n  // ... any other enhancers\n]);\n```\n. How about instead of initial state you think of it as default state?\nAlternatively, I can also make an option available:\njs\nformReducer('user', {\n  initialFieldState: { iconStatus: 'disabled' }\n});\n. Ah, sorry, meant to make that as a third option, as in:\nformReducer(model, initialState, [options = {}])\nSo, it would look like this:\njs\nformReducer('user', initialState, {\n  initialFieldState: { iconStatus: 'disabled' }\n})\n. Just because if we need more options in the future, that would necessitate more arguments, and I want to avoid the parity of the functions being too high. \n. @asvetliakov Just implemented this in the v1 branch for the upcoming version 1.0. The syntax will look like this:\njs\nformReducer('user', initialState, {\n  plugins: [ statusPlugin ],\n  initialFieldState: { iconStatus: 'disabled' }\n})\nwhere statusPlugin can look something like this:\n``` js\nimport updateField from 'react-redux-form/utils/updateField';\nexport default function statusPlugin(state, action, localPath) {\n  if (action.type === 'UPDATE_STATUS') {\n    return updateField(state, localPath, { iconStatus: action.status });\n  }\nreturn state;\n}\n```\nSpecifics: a plugin is like a normal reducer, except it's given a third argument, localPath, which is the path to the field for your form. So if you have a formReducer('test', ...), and an action such as actions.change('test.foo.bar', ...), the localPath will be ['foo', 'bar'] for that reducer.\n. Available in latest beta: 1.0.0-beta.7\n. This looks good but I was thinking about providing a more general (read: flexible) way of enhancing form reducers, especially with many enhancers. I'll comment on the original ticket around the lines of what I'm thinking.\n. Interesting. For sure, I know react, react-redux, and redux do belong in dependencies, and they are already there. I'll have to take a look at react-dom now - that could be the failure point - that's required for it to work as well.\nWhat exactly was the failure?\n. Alright, I'll release a patch with redux-thunk and react-dom as peerDependencies right now. Can you let me know if that works in a couple minutes?\n. Okay, published as react-redux-form@0.10.5. Try it out!\n. devDependencies won't get installed in production builds, so I think we're safe keeping them in there, especially when others are forking the repo. Otherwise, you'd have to manually install them.\n. It's because peerDependencies don't get installed automatically anymore - instead, NPM will just yell at you that they're missing. \ud83d\ude1f \n. I have a feeling this has to do with material-ui itself, and not RRF. See this issue: https://github.com/davidkpiano/react-redux-form/issues/144\nI'm going to investigate material-ui though. It makes things a lot more complicated, to say the least. \n. Can you humor me and try doing it manually? Just to see if this works:\n``` js\nimport { actions } from 'react-redux-form';\n// ... in render\n dispatch(actions.onChange(e))} />\n``\n. Good call, @i4got10! @ffxsam, try adding adisplayName` to the component:\n``` js\nimport TextField from 'material-ui/...';\nTextField.displayName = 'TextField'\n```\nI'll open a PR for this in material-ui if that solves the issue. They should ideally have a displayName property set.\n. Seems like that was the culprit, @ffxsam ! This will be addressed in v1.0 with the <Control> component (details here: https://github.com/davidkpiano/react-redux-form/issues/144#issuecomment-211973693 ), but for now, this workaround is quick and easy:\njs\nTextField.displayName = 'TextField';\n. > Yikes - don't use displayName. It's an extra step that devs don't really want to have to add into their code. If xyz is a React element, use xyz.constructor.name.\n@ffxsam I know. This will be resolved in the upcoming v1.0. This is simply a workaround.\n. @ffxsam Without seeing your code it's a bit hard to tell... But can you try this?\njs\n<TextField onChange={(e) => dispatch(actions.change('foo.bar', e))} />\nand see if that works in production?\n. Okay, then I'm pretty sure that the issue is with the .displayName (or .constructor.name) not being visible in material-ui. It's unfortunate, but hey.\nManually adding the actions is a decent workaround, and all this will be solved with <Control>. It's good to know though that <Control> is basically just mapping the actions the same way that you would do it. It just provides a nicer API for doing so.\n. Okay, I'm going to add the check for control.constructor.name and test this out locally to see if that fixes the problem.\n. Hosting a React hack a thon right now, nothing yet :)\n. What exactly are you looking for?\nThe older docs can be found here: http://davidkpiano.github.io/react-redux-form/\n. Which part of 0.8.4 specifically? Nothing was removed/changed from the documentation since then.\n. Ah sorry about that, it's not deprecated yet. You can just use modelReducer - same thing. Will fix soon!\n. Hey, you're absolutely right. I'll probably end up adding actions to do the not-as-common merge behavior that's currently being exhibited: \n- actions.mergeErrors(model, errors)\n- actions.mergeFieldsErrors(model, errors)\nAnd then do what you're describing for setErrors and setFieldsErrors. Sounds like a good game plan?\n. > Also, you should mention in docs that modelReducer(name) should be mounted exactly in root.name\nGood point, I thought I clarified that, but since others are asking questions, I'll add more clarity around that.\n\nand you don't support immutable states for all action which returns action thunks (such as validate()) since you're calling get(getState(), modelPath) in them :smile:\n\nHmm, mind opening a separate ticket for that? This would be a good enhancement for v1.\n. The funny thing is I can remove that enforcement with some sort of middleware, but I don't want to add that extra bit of boilerplate for the developer.\n. @asvetliakov I did a major refactor that fixed this issue and normalized the behavior between validators and errors, so they can be used in harmony. Published as react-redux-form@0.11.0!\n. Awesome, I'll start working on custom getters/setters for immutable structures for v1. Can you elaborate on this, though?\n\nForm model mounted in root state with same name as given to model reducer\n. > Or provide decorated HOC component and use context?\n\nWhat would this look like, you think?\nAnd I think that this problem with the prefixes can easily be solved with middleware:\n``` js\nimport { formMiddleware } from 'react-redux-form';\nconst store = applyMiddleware(formMiddleware)(createStore)(combineReducers({\n  user: userReducer,\n  foo: fooReducer,\n  bar: barReducer,\n});\n```\nwhere each userReducer, etc. are just plain existing reducers. \n. @asvetliakov This first part:\n\n(only works if) Form model mounted in root state with same name as given to model reducer\n\nshould be fixed in react-redux-form@0.11.3. Can you please verify that it does, or give me code that was failing before?\n. Closing this, I think I have all this covered pre-version 1.0. If there's anything missing, can you please open a separate ticket for it? Thanks!\n. I'm a bit wary about this one because it would probably break updateOn=\"blur\" functionality. I'm trying to think of an alternate solution.\n. So the model is actually located at test in the store, meaning your <Form> should look like this:\n``` js\n<Form model=\"test\"\n  // ... etc.\n\n// ...\n\n```\nThat should work, let me know! \ud83d\ude04 \n. Weird, all of the tests have it all at the same level. Can you share what your store looks like?\n. @fairbairn Take a look at this gist: http://esnextb.in/?gist=37f259673130c6c6ed8076d73ca3afca\nPress Execute, play around with the form, and open your console. Both the <Form> and the <Field> need to have model=\"test\" and model=\"test.name\", respectively.\nI'll look into the checkbox issue.\nEDIT: Added the checkbox into the form. They seem to work perfectly as well.\n. Okay, here is the updated, successfully working gist from your example:\nhttp://esnextb.in/?gist=fefd5b45add579274a9ada5a0ae884b8\nThe issue is that react-redux-form needs to know exactly where the model lives in the root store, for both the <Form> and the <Field>. You were specifying it as living in e.g. model=\"test.name\" even though it really lived in model=\"form.test.name\".\nSame issue with your buildDynamicReducers function:\ndiff\nfunction buildDynamicReducers(sections) {\n  return sections.reduce((combined, section, index) =>{\n    let name = section.form;\n-   combined[name] = modelReducer(name, {});\n+   combined[name] = modelReducer(`form.${name}`, {});\n    combined[`${name}_form`] = formReducer(name);\n    return combined;\n  }, {})\n}\nHope that helps!\n. > It's also a little confusing, because the modelReducer has to be referenced from the root of state, but the formReducer does not?\nRight; every model is based on the modelReducer, and the formReducer can live anywhere.\n\ndo we need to connect at all?\n\nNope! Unless you need to grab a value from the state in your component, each <Field>, <Form>, etc. is already connect()ed on its own. They are each isolated and have no knowledge of their parent component.\n. Thanks! Feel free to propose any enhancements you'd like in separate tickets; I'd love to discuss them further in depth with you.\n. > In your system, each message essentially has to have a key\nNot necessarily; you can setErrors(model, ['error 1', 'error 2']) to an array. RRF is agnostic to this. Have you tried this?\nAnd the reason for validators and errors both coexisting is because they are necessary for different use cases. For example, I can express my validators as this:\njs\n<Field model=\"user.email\"\n  validators={{ isEmail, isRequired, (val) => val.length > 6 }}>\nwhich makes it very concise. I can also set error messages from the API, which returns them as a dict of messages as well.\nAnother good reason for validators is internationalization - I do not want to have i18n logic in my validators, nor do I want hardcoded messages, and I know many developers have the same concerns. A couple of the apps I'm building are working with i18n messages.\n. Hmm, this is a lot to digest, so let's continue the route of demonstrating the use case using esnextb.in , if you can... But I'll answer some of the questions you posed:\n\nform: { ... model: \"test\" }\n\nFirst thing I noticed is this, which should probably be model: \"form.test\". Think of model as saying \"where in my state should I look for this value?\" This alone will solve most (if not all) of your issues.\nI am strongly considering implementing middleware to ease this burden - let me know if you think this is a good idea.\n\nIf we're going to build our own errors handler from the top-level Form, intercepting our submit handler, and we want to iterate through all the fields, and we want to file away an errors array of messages for each field if our validation function detects some failures (or it may not), should we be looking at setErrors or setFieldsErrors?\n\nYou should be looking at setFieldsErrors to set all errors at once, which would look like this:\njs\ndispatch(setFieldsErrors('form.test', {\n  name: ['contains illegal chars', 'is too short'],\n  email: ['is invalid email']\n});\n\nI get a bit confused why there's an errors block under the formReducer section, but there's also an errors block under the fields individually as well - guess the top one are form errors and the fields are field specific?\n\nPrecisely. Just as you would construct your state tree in Redux such that if a state references two leaf-node reducers, it should probably be in a reducer higher up that's common to both reducers, you'd do the same for errors.\nFor example, you might have a \"passwords_match\" validation key that depends on two fields - \"password\" and \"confirm_password\". This would likely be a form-level validation key.\n\nFinally, our validation routine may not have any tripped errors, in which case our array of error messages would be empty []. Do we need to call a resetErrors before we run through our routine to essentially set it back to a valid status before we check? and would that touch the errors under fields or just the form level errors?\n\nNot after I push the patch that fixes #151. Then dispatching setErrors(model, []) would replace the errors of that model with an empty array. which would signify a valid field.\n\nWe can dispatch any number of events when our validation routine runs - just need to know which of the broad array of functions we should really care about depending on desired granularity.\n\nSince you're caring about error messages, you essentially only need to know about one - setErrors(model, errors). The setFieldsErrors(model, fieldsErrorsMap) is a convenience action creator that batch executes setErrors for each key in the fieldsErrorsMap in the reducer. It's a good idea to use setFieldsErrors for performance, as it only triggers a single rerender as opposed to n rerenders for each field.\n. Sorry to hear that. I'm working on getting the errors prop working with <Form>, and that should be landing in a patch soon.\nIt's generally a good practice to keep the state as flat as possible anyway, but there's no reason React Redux Form shouldn't be able to accommodate your use-case, especially since it works well with dynamic forms. I'll admit though, your use case is pretty complex, especially with dealing with hundreds of dynamic forms. If you can simplify your use case in a clear (and concise) way, I may be able to help you out further.\nFor the initial state, a field doesn't exist until it's acted upon, unless it's given in the initialState of the formReducer.\nI'm definitely open to areas where you would like to see the docs improved. I'm working hard to make this v1.0 ready, and don't want to commit to docs until I'm 100% sure a feature in <0.x will see the light of day in v1.0.\n. Thanks for the report! I'll add support for errors today.\n. Actually, did you even try this, regardless of the source? Errors are always validated whenever there is a change, and submitting a form wouldn't change the model, which means that the errors will be properly reflected in the form validity state.\n. Was this issue resolved?\n. Hey, you can do so like this in your render() function:\n``` js\nimport { Field } from 'react-redux-form';\n// in render():\n\n\n\n\n\n\n\n\n\n\n\n\n```\nOr are you talking about react-select? If so, what version are you using, <1.0, or 1.0 beta?\n. Please see the docs on Custom Components.\nThis will become much easier in v1.0! Let me know if you run into any issues doing it the way described in the docs. \ud83d\ude04 \n. This probably has something to do with the absence of displayName on the React Native components: https://github.com/davidkpiano/react-redux-form/issues/65\nIt's possible I can patch this so it works fine with React Native. There's a few short-term workarounds, though:\n- Manually add TextInput.displayName = 'TextInput' to the components you're using (soon you won't need to do this)\n- Manually wire up the actions yourself, which is pretty straightforward:\n``` js\nimport { actions } from 'react-redux-form';\n// ...\n dispatch(actions.change('user.foo', val))} />\n``\n- Wait for the` component to come out in v1.0. The API will be much nicer, and this will be feasible:\n``` js\nimport { Control as NativeControl } from 'react-redux-form/lib/native';\n// in render()\n\n```\nPlease let me know if the displayName workaround fixes your issue!\n. No, this is a bug that you've found. Sorry about that!\nThe issue is in these two functions: https://github.com/davidkpiano/react-redux-form/blob/master/src/utils/index.js#L52-L65 it can find shallow-nested forms just fine, but chokes when it comes to deeper forms. I'll have a fix for this later today, unless you feel like tackling it :)\n. I need to refactor this. Should be a really simple refactor, though.\nHere's the rough draft of the algorithm I want to use:\n- Split the model path (using toPath(model)), take the first segment, get() the state slice from it.\n- Check: is that state slice a form and startsWith(model, form.model) true?\n  - If true, return that state slice, because it's the form we're looking for.\n  - Otherwise, repeat recursively.\n- Memoize finding the key, because the store shape is never going to change.\n. This is fixed and will be released in the next patch @morsdyce !\n. I'm working on writing the documentation for the differences between redux-form v6 and react-redux-form v1 (when it comes out). In short, the biggest difference between the two is:\n- Redux-Form acts like a framework\n- React-Redux-Form is a library\nWhat this means is that you can use as much of or as little of RRF as you want, and it provides you the full flexibility to:\n- use your own reducers\n- use any custom components\n- validate, change, etc. at any time, from anywhere dispatch() is available\nFor sync and async validation, RRF provides many helper action creators for validating one field or many fields at a time. On the other hand, Redux-Form handles validation internally, through the decorator, so everything is validated whenever there is a change, regardless of if fields being validated have even changed. http://redux-form.com/6.0.0-alpha.5/docs/api/ActionCreators.md/\nAlso, RRF eschews the notion of decorating components, in order to give the developer more flexibility and control over the model and the form state. RRF is performance-driven, too, and batches actions into one whenever it can.\nVersion 1.0 of RRF will introduce the <Control> component which will make custom controls much easier.\nAre there any specific questions you have?\n. > I looked at RRF before, but was a bit confused with adding many form elements in the store (2 elements per form) while RF had only one element for all forms.\nThis is for flexibility, though I'm thinking that this can be simplified; it just comes down to finding the right API for it while allowing it to be flexible.\n\nhow stable is RRF now (any api changes to expect before v1)\n\nI've been using it in production apps for months now; the biggest changes since then have been enhancements and edge-case bug fixes; no breaking changes. Even right now, all I've been working on is the stray bugs and performance improvements, as well as adding new features.\nThere is only going to be one major breaking change for v1 (hence the version bump), but it will be for simplification. The form state shape will no longer have all fields nested in .fields with flattened paths, but instead will be more akin to Redux-Form:\n``` js\n// old\nuserForm.fields['phones[3].number'].valid\n// new (tentative)\nuserForm.phones[3].number.$field.valid\n```\nAlso, v1.0 will introduce a couple of big features:\n- The <Control> component (currently used internally)\n- Built-in HTML5 constraint validation integration\nThe second means you'll be able to do things like this:\n``` js\n\n\n\n// or with the new  component:\n\n```\nand validation will automatically be reflected in the field state with the required, pattern, minlength, etc. HTML5 attributes.\n. > First, thanks for making such an awesome forms system! I especially appreciate how well-thought-out the documentation is.\nThanks, I really appreciate it! I fixed the error in the documentation; thank you for pointing that out.\n\nIs that all there is to it? Should we pass in a value prop set to the value of the model? Are there any other ways RRF can integrate with custom components?\n\nThat's the minimal use case for it, as an uncontrolled component. If you want to make it controlled, yes, you can pass in the value. You also have a variety of actions that you can choose to use to connect the controls, such as actions.focus() or actions.blur().\nI was able to get it working here: http://esnextb.in/?gist=9f051a3c78461f89ea20ed5a01268c7e\nPlease compare your code to mine; I made a couple tiny modifications but for the most part both of our code is pretty similar. Seems like having the components be controlled works fine.\n. Also, in version 1.0, I will introduce the <Control> component (nothing new; it is being used internally in RRF) which will allow better integration with custom components:\njs\n<Control mapProps={(props) => ({ customOnChange: props.onChange })}\n  model=\"user.name\"\n  component={FancyTextField} />\n. Correct; it should be formReducer and not createFormReducer. The docs are on GitBook so I just fixed them (not sure if a PR is possible yet). Thanks a lot! \n. Thanks for the report, @bgriffith! Yeah, this is an interesting use-case because React-Native doesn't have the notion of a \"form\" component, but I understand why you might still want to use <Form> in React-Native. I'll clarify this in the docs.\n. I published an addition for this as 0.11.1: https://github.com/davidkpiano/react-redux-form/commit/5cf2044a68a93da415dfb427251412c3f1cc2f8b\nThere is now a more succinct way to grab the <Form> as a rendered <View>:\n``` js\nimport { NativeForm as Form } from 'react-redux-form/lib/native';\n// render():\n\n```\n. @Faulik is right. See the React Native & Custom Components doc for more information.\nIn version 1, this will become much easier, I promise :) It will look something like this:\n``` js\n// Warning: future syntax!\nimport { Control } from 'react-redux-form';\n// render()\n\n``\n. Yes, that is correct. Alternatively you can usecreateFieldClassto create a customclass that _recognizes_ your custom. But you have to make sure thatInput.displayName = 'Input'`.\nLet me know if the custom component solution outlined in the docs works for you!\n. > So does that mean I'd have to create a new field of each of those input types?\nNot necessarily.\nAssuming your custom Input has a type=\"...\" attribute, you can do something like this:\njs\nconst CustomField = createFieldClass({\n  Input: (props) => {\n    switch (props.type) {\n      case 'text': // return ...\n      case 'radio': // return ...\n      default: // return ...\n    }\n  }\n});\nwhere each different type would return their own prop mappings. Again, <Control> will make this a little bit easier. But this approach will work.\n. Yep, absolutely! The mapping function simply returns the mapping given props. So you can do anything in that function.\n. ^ I'll have a patch for that soon. Thanks!\n. @tnguyen14 Can you show me your full code?\n. Hey @tnguyen14 this was just a usage issue - createFieldClass creates a new custom Field that can recognize your custom components. Here's the working NewTransaction.js class:\n``` js\nimport React, { PropTypes } from 'react';\nimport { Button } from 'react-bootstrap';\nimport Input from '../components/Input';\nimport InputTypeahead from '../components/InputTypeahead';\nimport config from 'config';\nimport { connect } from 'react-redux';\nimport { Field, Form, createFieldClass, controls } from 'react-redux-form';\nimport { saveTransaction } from '../actions';\nfunction isNotNull (str) {\n    return typeof str === 'string' && str.length !== 0;\n}\n// make react-redux-form work with custom component\n// https://github.com/davidkpiano/react-redux-form/issues/167\n// this could change in react-redux-form 1.0\nconst CustomField = createFieldClass({\n    Input: (props) => {\n        let type = props.type;\n        switch (props.type) {\n        case 'date':\n        case 'time':\n        case 'number':\n            type = 'text';\n        }\n        return controlstype;\n    },\n    InputTypeahead: controls.text\n});\nfunction NewTransaction (props) {\n    const statuses = [{\n        slug: 'POSTED',\n        value: 'POSTED'\n    }];\nconst { transaction } = props;\nconst submitText = props.editing ? 'Update' : 'Add';\nconst submittingText = props.editing ? 'Updating...' : 'Adding...';\n\nreturn (\n    <Form className=\"new-transaction\" model=\"transaction\" onSubmit={saveTransaction}>\n        <h2>Add a new transaction</h2>\n        <CustomField model=\"transaction.amount\"\n            validators={{\n                required: isNotNull\n            }}>\n            <Input label=\"Amount\" type=\"number\" min=\"0\" step=\"any\" />\n        </CustomField>\n        <CustomField model=\"transaction.merchant\"\n            validators={{\n                required: isNotNull\n            }}>\n            <InputTypeahead source={props.merchants} label=\"Merchant\" />\n        </CustomField>\n        <CustomField model=\"transaction.date\"\n            validators={{\n                required: isNotNull\n            }}>\n            <Input label=\"Date\" type=\"date\" />\n        </CustomField>\n        <CustomField model=\"transaction.time\"\n            validators={{\n                required: isNotNull\n            }}>\n            <Input label=\"Time\" type=\"time\" />\n        </CustomField>\n        <CustomField model=\"transaction.category\"\n            validators={{\n                required: isNotNull\n            }}>\n            <Input label=\"Category\" type=\"select\" options={config.categories} placeholder=\"Select a category\" />\n        </CustomField>\n        <CustomField model=\"transaction.source\"\n            validators={{\n                required: isNotNull\n            }}>\n            <Input label=\"Source\" type=\"select\" options={config.sources} placeholder=\"Select a source\" />\n        </CustomField>\n        <CustomField model=\"transaction.description\">\n            <Input label=\"Description\" type=\"textarea\" />\n        </CustomField>\n        <CustomField model=\"transaction.status\"\n            validators={{\n                required: isNotNull\n            }}>\n            <Input label=\"Status\" type=\"select\" options={statuses} />\n        </CustomField>\n        <CustomField model=\"transaction.id\">\n            <input type=\"hidden\" />\n        </CustomField>\n        <Button bsStyle=\"primary\" className=\"pull-right\" type=\"submit\" disabled={transaction.submitting}>{transaction.submitting ? submittingText : submitText}</Button>\n    </Form>\n);\n\n}\nNewTransaction.propTypes = {\n    editing: PropTypes.bool.isRequired\n};\nfunction mapStateToProps (state) {\n    let merchants = [];\n    if (state.account.merchants_count) {\n        merchants = Object.keys(state.account.merchants_count).reduce(function (merchants, merchant) {\n            return merchants.concat(state.account.merchants_count[merchant].values);\n        }, []);\n    }\n    return {\n        transaction: state.transaction,\n        editing: !!state.transaction.id,\n        merchants: merchants\n    };\n}\nexport default connect(mapStateToProps)(NewTransaction);\n``\n. You're welcome! Sorry if the documentation is confusing around this.in v1.0 will make this easier.\n. There's a couple of RRF-agnostic ways of addressing this problem. One is what you mentioned - using a big validation object foractions.validate- this is the most robust solution because validation onor` will only occur when (of course) those fields and forms are currently rendered on the page.\nThat would look like this:\n``` js\nimport myValidators from '../path/to/my-validators';\n// wherever you are dispatching the change\ndispatch(actions.batch('user.foo', [\n  actions.change('user.foo', 'some value'),\n  actions.setValidity('user.foo', myValidators.user.foo('some value')\n]);\n```\nSo are you requesting that validation occur whenever the <Field> detects a change in the modelValue? That's certainly doable.\n. I'm not sure I follow - though modelValue is meant to be internal.\nHowever, RRF provides actions to allow you to do validation in whichever way, and so if you want validation to be arbitrarily executed, it's best to do it manually via actions. Can you make a sample use-case so I can better understand the problem?\n. Ah right, that's because the inputs are not controlled. Have you tried this:\njs\n<input type=\"text\" value={user.username} />\nI'm strongly considering making inputs controlled (using internal component state) in v1.0. \n. Please look at the documentation for this: https://davidkpiano.gitbooks.io/react-redux-form/content/model_reducers.html#model-reducers-in-stores\nThe model must be the full path to the model reducer in the store, so that RRF knows exactly where to look when both getting and setting the values.\nThis seems like a little bit of boilerplate, and I'm thinking of ways to reduce this boilerplate. Considering an API like this:\n``` js\n// Warning: (potentially) future syntax!\nimport { combineModelReducers } from 'react-redux-form';\nconst store = applyMiddleware(thunk)(createStore)(combineModelReducers({\n  user: modelReducer('can_be_any_name', initialUserState),\n  foo: modelReducer('does.not.matter', initialFooState),\n});\n``\n. Thanks for pointing the confusion out to me, though. I added some documentation in various sections to further emphasize this.\n. Hey, I'll export it once I write a few unit tests for it. Probably later today!\n. Added inv0.12.0`!\n``` js\nimport { utils } from 'react-redux-form';\n// available as...\nutils.getFieldFromState(...)\n``\n. Thinking about the simplest solution to this one - would it make sense forto _always_ generate a wrapper component ()? Which is the current behavior for a` containing more than one child.\n. Also, can you show me a code example where this is failing?\n. This will be published in the next release: 0.11.6!\n. Huge thanks @cbioley! Anyway, @rkrdo I'm (for the most part) always available on the Reactiflux discord chat under davidkpiano. I'll see if we can reuse redux-form or create react-redux-form.\n. Thanks, @sakarit! You can also add it manually:\njs\n<Field ...>\n  <Checkbox type=\"checkbox\" />\n</Field>\n. Hmm, good question! What about something like this?\n``` js\n// Not real API (yet?)\nimport { FieldSet } from 'react-redux-form';\n// render()\n\n ...\n  ...\n\n```\nWould be purely a convenience component that maps over each of its children, and if it finds a <Field> it will prepend its model. Just an idea.\nThe problem comes when you have something like a <CustomFieldGroup> or <SomethingThatContainsAField>... then we'd have to rely on context, which I strongly want to avoid to prevent complexity.\nWhat are your thoughts? What's your ideal API for this?\n. Have you looked into tracking collections for inspiration?\nHaving \"stringly-typed\" models is the most succinct syntax so far, because a string path tells RRF where to retrieve and set the value, all from one versatile string.\nHowever, I can see something like this being useful:\njs\n<Field with={user} model=\"address\">\n// ...\n</Field>\nwhich will work by finding the appropriate path that user lies (which is findable, since user is an object and its path can be found by === reference). The benefit here is the shortcut that, if your user lies in a deep path, such as forms.foo.bar.baz.user, and you're using a custom mapPropsToState function to get const { user } = this.props in render(), you don't need to pass in the full path.\nThoughts on this?\n. @mruhlin If I am going to use context, this API might make more sense:\njs\n<Form model=\"user\" context={true}>\n  <Field model=\"address\"> // 'user.address'\n    // ...\n  </Field>\n</Form>\n. @lennerd I'm going to plan on handling it with only single nesting. This is because DOM structure does not necessarily reflect data structure.\njs\n<Form model=\"user\">\n  <Field model=\".address\"></Field>\n  <Field model=\".address.city\"></Field> // can be outside, shouldn't nest fields\n</Form>\n. The way it's going to work is that <Form> is going to create a context (optional) so that any field inside <Form>, no matter its nesting, can elect to have a shortened model prepended with a dot, which would look in the context and find the correct model.\n. > If I did it that way, I'd still only need one set of reducers in my redux store right, or would I need to create separate form reducers for each address?\nYou can do it under a single userForm and that will work fine. If you wanted to treat user.homeAddress as its own isolated form, you'll have to wait until version 1 for that. But yes, that's how the syntax should work, as you have it.\n. This has been added to the latest @beta! Currently it works if the root model is in <Form> and the partial models are in <Control>. Before 1.0, I plan on supporting <Field>, <Errors>, as well as perhaps adding a <Fieldset> component that will let you add a context without creating a <Form>?\n``` js\n// Object access\n\n\n\n// Array access\n\n\n\n// Parent tracker\n\n\n\n// Child tracker\n\n\n\n// Parent and child tracker\n\n\n\n``\n. Will be in next patch release @cbioley!\n. Of course I won't hate you, thanks for the report! It's the edge cases like this that makes the library more robust and resilient. I'll look into this.\n. Hm, this is an interesting question because,,`, etc. are all assuming that a store exists. I'll play around with this and see if I have a good answer for you.\n. @jmeas If you can, I would mock up RRF like this:\n``` js\nimport React from 'react';\n// React-Redux-Form mock:\nconst rrf = {\n  Field: (props) => ,\n  Form: (props) => ,\n  Errors: (props) => null,\n}\nexport default rrf;\n```\nHopefully that works for your testing use cases!\n. Are you manually adding TextField.displayName = 'TextField'? That's the current workaround.\n. Right, or you can actually do it directly on TextField itself, since it's setting a static property.\n. Ah, I said I'd do that. Issuing a quick patch with that right now.\n. @ffxsam I currently have this:\ndiff\n    let controlDisplayName = control.constructor.displayName\n      || control.type.displayName\n      || control.type.name\n      || control.type\n+      || control.constructor.name;\nnot sure if that was what you were expecting. Placing it as the second clause causes a lot of unit tests to fail, though. \nFeel free to PR; I can review it ASAP.\nBy the way, you can definitely fork it and then just specify the dependency as the link to the git URL.\n. Yeah, those properties are probably just getting minified in production. V1 syntax will make this a lot easier:\n``` js\nimport { Control } from 'react-redux-form';\n// render()\n// ... can be inside  or not\n\n```\n. Hey @ffxsam, this is actually the expected behavior (currently). Check here for more information: https://davidkpiano.gitbooks.io/react-redux-form/content/faqs.html\nIn short, you have to make the inputs controlled yourself (for now):\ndiff\n          <Field model=\"myModel.name\">\n-           <input type=\"text\" />\n+           <input type=\"text\" value={this.props.myModel.name} />\n          </Field>\nI'm strongly considering switching these to controlled in v1.0. What do you think?\n. > So.. a very strong vote for keeping the functionality as it was before :)\nHmm, I'm pretty sure that functionality wasn't there before, since components were always uncontrolled by default, but I understand your concern.\nComponents will be controlled in v1.0, I've decided. It'll be a breaking change (hence 1.0) though it won't affect many forms.\n. You don't have to, don't worry \ud83d\ude0c  the component will work just fine as an uncontrolled component.\nIt's when you want the input to magically update that you'll have to make it controlled.\n. Yeah, these warnings are new as of React 15.0. I'm still looking into them, and in v1.0 the components will be controlled by default anyway.\n. > In other words, I can use createFieldClass to make fully controlled inputs without having to use connect to get the redux state mapped to props, right?\nYes, you have the full ability to do that.\n. Can you show me your full code? Are you trying to create a custom event?\nThere is an internal function called getValue() in RRF:\njs\nfunction getValue(value) {\n  return isEvent(value) ? getEventValue(value) : value;\n}\nSo, { target: {...}} would not be interpreted as an event because it is not an instanceof Event.\nTry providing the actual value (e.g., the string `'my value') instead of a fake event, or you can make it an actual event:\njs\nlet customEvent = new Event('custom');\ncustomEvent.target = { value: 'my value' }\nPlease let me know if that works.\n. Is the above code valid? This JSX is invalid:\njs\n    return (\n      <Input type=\"select\" onChange={ this.onChange.bind(this, 'year') }>\n        <option value=\"\">Select a year</option>\n      </Input>\n      <Input type=\"select\" onChange={ this.onChange.bind(this, 'month') }>\n        <option value=\"\">Select a month</option>\n      </Input>\n      <Input type=\"select\" onChange={ this.onChange.bind(this, 'day') }>\n        <option value=\"\">Select a day</option>\n      </Input>\n    );\nand will throw this error: Adjacent JSX elements must be wrapped in an enclosing tag\n. Hey @morsdyce, please see this esnextb.in for a working example:\nhttp://esnextb.in/?gist=15beae7c68217d593a28cfe256e4c3ce\n. Commit message says it all \ud83d\ude34 \n. @bgriffith Thanks, I appreciate it!\nDo you mean dynamic validation? As in:\n``` js\n// given something like\nrender() {\n  return \n  // ...\n}\n// rendered state 1:\n\n// rendered state 2:\n\n```\n. Quick solution:\nSince your validator depends on 2 or more fields, it's best to move it a higher level; in this case, a form-level validator. Take a look:\njs\n  // Validators for the Form component\n  let validators = {\n    // form-level validation (empty string)\n    '': {\n      bRequired: (val) => val.a !== 'true' || isRequired(val.b)\n    },\n  };\nTwo other helpful tidbits:\n- checked={foo.a === \"true\"} etc. is redundant; RRF does this for you \ud83d\ude09 \n- If you want, you can pass in the actual true value; RRF is smart enough to know the exact value instead of blindly converting it to a string:\njs\n<input type=\"checkbox\" value={true} />\nLet me know if this solution works for you! If not, I'll look further into dynamic validators, which is something I haven't considered yet, because of the ability to do validation at any level in the form.\n. Great question, and thanks for the detailed example.\nFor these usage scenarios, it's best to ask yourself how would you accomplish this in plain Redux.\nThis might be more code, but in plain Redux, you'd probably have a reducer that handles the relationships:\n``` js\nfunction customReducer(state = {a: \"\", b: \"\"}, action) {\n  switch (action.type) {\n    case 'CHANGE_A':\n      if (!action.value) {\n        return {\n          a: \"\",\n          b: \"\",\n        }\n      }\n  return {\n    ...state,\n    a: action.value,\n  };\ndefault:\n  return state;\n\n}\n}\n```\nso something like this: http://esnextb.in/?gist=796d924d52a6a7383bee5066d9471f53\n. > Specify validation information for a field in exactly one place. (preferably near the field specification)\nValidation is done via actions, in order to be completely agnostic and flexible to how you want to do your actions. It's definitely possible to keep all validators in one place; the structure is up to you. A simple example is keeping all validators in <Form validators={{...}}>.\n\nHave all changes validated.\n\nDo you mean that when you dispatch actions.change('foo.bar', '...'), that validation should occur then too?\n. Okay, I'll plan this as a general enhancement, since you're right -- if a <Field> detects that the value has changed externally, it should validate against its validators and update the validity of that field.\n. @dreid Here's the unit test if you're interested: https://github.com/davidkpiano/react-redux-form/commit/8d95837b259d83c79cd398da6e4e95f4ab41a907#diff-b43d85b01204324e63c810644e344418R617 I'm confident this will solve your use-case; please let me know if it doesn't!\nWill be released in the next patch.\n. Fix coming right up! (Was actually just working on this very issue)\n. @daneryl Now, input elements are controlled by default (as long as updateOn=\"change\", which is the default anyway).\nYou'll still get the warning if you don't specify an initial value for each model, which is good practice:\njs\nmodelReducer('user', { email: '', name: '', ...etc })\n. @greaber V1.0 will alleviate this requirement.\n. SET_SUBMIT_FAILED occurs on <Form> when the form state is invalid. If you're using redux-logger, can you check to see what's making the form invalid?\n. Look for attachmentModelForm (or wherever you set up your formReducer for \"attachmentModel\"). Find where it changes from .valid = true to .valid = false\n. Can you make a minimal code example demonstrating the issue on esnextb.in ?\n. In form-component.js there is a few lines of code that should be called since you don't have validators:\n``` js\n    if (!validators && onSubmit && formValid) {\n      onSubmit(modelValue);\n  return modelValue;\n}\n\n```\nso the fact that onSubmit isn't being called means that !validators && onSubmit && formValid is falsey.\nIf you go into lib/components/form-component.js (if you're using Webpack) you can directly console.log() in this file to dig around and see what's going on.\nLet me know if you're able to do so.\n. Weird! It's hard to diagnose the problem without a way to replicate, and there should be no cross-contamination. I'll try to see what I can find.\n. Okay - validators continue to work in <Form> so I'll help try to figure out what's going on. The unit tests should cover all possible edge cases, but I might have missed something.\n. @ffxsam Were you able to work around this? I am still not able to recreate the issue without an isolated code example.\n. Awesome! And no worries, I'm happy to do this for free. This project makes my life easier and (hopefully) other dev's lives easier.\n. Good plan @markoshust, I can do that. Can you open a separate ticket for adding that error message?\n. I ended up just removing memoization for now. Thanks for catching that!\n. What version of RRF are you on? This has been fixed as of 0.12.x.\n. Just pushed out a patch that solves this very issue, as long as your validators are defined on <Field> or <Form>: react-redux-form@0.12.2\nThis patch solved #183 which posits that validation should occur when <Field> detects that the model value has changed, regardless of how it changed (externally, etc.)\nPlease upgrade to the latest and let me know if it solves your issue!\n. Yes, this is intended. In v1, any subsection of the fields (i.e., any node) can be submitted as a \"form\" - that is to say, if you want to submit the entire user or just user.address, you can do so. So the submitFailed only reflects that submission has failed when trying to submit that specific model.\nHope that helps!\n. Can you show me your code that was previously working and is now broken, so I can add it as a test case?\n. @arcticfalcon Fixed! Relevant test case here: https://github.com/davidkpiano/react-redux-form/commit/aa376ba198fe9a14675813b3266d21cc76ab3b62#diff-b43d85b01204324e63c810644e344418R1436\nThis will go out in 0.12.5\n. I got this working. You just have to make sure that the model argument in modelReducer(model, ...) is the exact path to this reducer:\ndiff\n    const store = applyMiddleware(thunk)(createStore)(combineReducers({\n      form: formReducer('test'),\n-     model: modelReducer('test', { foo: [] })\n+     model: modelReducer('model', { foo: [] })\n    }));\nand modify the rest of the test accordingly.\n. This makes sense to me! I'll merge it as soon as tests pass.\n. Oh good call, thanks!\n. @dreid Actually, you already have this ability! It's just not documented (yet). You can do this in createFieldClass(...):\njs\nconst MyField = createFieldClass({\n  'TextField': (props) => ({\n    invalid: !props.fieldValue.valid,\n    dirty: !props.fieldValue.pristine,\n  })\n});\nSo, two important things:\n- The field values, such as valid, pristine, etc. are all available on props.fieldValue\n- Use the affirmative rather than negative prop names, e.g. valid instead of invalid and pristine instead of dirty because the negative prop names are redundant and will be removed in v1. I'd like to keep the size of the field objects down.\nHope that helps!\n. Yeah I'm thinking that dependency isn't common enough to warrant a peer-dependency. cc. @chrisblossom \nI'll add it as a dependency in the next patch.\n. @chrisblossom What are your thoughts on removing React 0.14 support?\n. @ffxsam @chrisblossom Problem solved, I'm now doing this:\ndiff\n- import shallowCompare from 'react-addons-shallow-compare';\n+ import shallowCompare from 'react/lib/shallowCompare';\nwhich will grab the internal module from whichever version of React that is being used. That way, it is not required as an additional peer dependency, which would be redundant anyway, as it is already a part of the React module.\n. Released as 0.12.6!\n. Great catch! Thanks for this.\n. Sure, try this:\njs\n<Field model=\"model.foo.phone\"\n  parser={formatPhone}>\n  <input type=\"text\" />\n</Field>\n. Check out this page for more info (warning: old docs but the code should still work with the latest version of RRF): http://davidkpiano.github.io/react-redux-form/docs/index.html#/recipe/parse-fields\n. This will be officially addressed in V1, but I can patch it. It should propagate down.\n. This will be addressed more elegantly in v1.0; adding type=\"checkbox\" is a sensible (and expected) workaround currently.\nIt has to do with how props are currently mapped for custom components - right now, there is no way of knowing the mapped props until after sequenceEvents, and in V1 the mapping will be made available before sequencing.\n. Available in latest @beta!\njs\n<Control.checkbox component={...} />\n. Done! Thanks for pointing that out. https://davidkpiano.gitbooks.io/react-redux-form/content/react_native_&_custom_components.html#createfieldclasspropsmap-defaultprops\n. Updated docs here: https://davidkpiano.gitbooks.io/react-redux-form/content/custom_components.html\n. Thanks for starting this audit, @etrepum. I plan on addressing the implementation of <Control> and this is extremely helpful. The closures can be mitigated, and there can probably be some optimizations on how we handle props and controlProps. Let me know if you find anything else and we can keep a running list of these things.\n. Fixed with #227 \ud83c\udf89 \n. @etrepum Check out this commit: f3c4a50\nWith no changes outside <Control>, handling the mapping inside the lifecycle methods of <Control> allows this test to pass, as well as all of the others. Any thoughts on this solution?\nI'm thinking we can even further optimize this by doing a shallow comparison here:\n``` js\n  componentWillReceiveProps(nextProps) {\n    const { mapProps } = nextProps;\n// todo: shallow comparison before calling mapProps() ?\nthis.setState({\n  mappedProps: mapProps({\n    ...nextProps,\n    ...nextProps.controlProps,\n    ...sequenceEventActions(nextProps),\n  }),\n});\n\n}\n```\nand even further in shouldComponentUpdate, possibly.\n. Yep! There's more wins to be had, but this is a good start.\n. > Is the recommended approach to do this type of validation in a form reducer enhancer, looking for change action types and mutating the field errors (or whatever i want to call it) directly?\nNah, it's actually much simpler than that! Here's how you would do form-wide validation:\n``` js\n user.selectedComment || (user.comment && user.comment.length)\n    }\n  }}\n\n```\n\nThe empty string in validators for <Form>-level validation means the entire form - it's as if you were validating the \"user.\" model (which resolves to \"user\"), and the value passed into the validator would be the entire user model.\n. Yep! You're right though - I should add more specific documentation for form-wide validation.\n. Can you throw up an example on esnextb.in ?\n. Works fine with the latest RRF 0.13.1:\n\nCan you not use the latest version?\n. Yep! Until v1.0, no major changes are being made, only bug fixes. And even v1.0 won't have huge breaking changes, really. \ud83d\ude04 \n. It does get computed.\n- The .errors prop answers the question \"Is this an error?\" for each of its keys.\n- The .validity prop answers the question \"Is this valid?\" for each of its keys.\n. Yeah, I will be clarifying it. Anyway, with validators in the <Form> component, the key/values of { '': { k: v }} no longer refer to fields; they refer to validation keys.\nIf you want them to refer to fields, they'd be on the first level of the object:\njs\n{\n  '': { /* form level validation */ }\n  firstName: { ... },\n  email: { ... },\n}\n. Just updated to 0.13.0! \ud83c\udf89 \n. Good catch! Thank you for this!\n. I like it! I'll definitely add more styling and examples in the future to this. Thanks for your work on it!\n. This might be fixed by c600e5dcaf8afa6efdff0cadbc148abe3a98f743 for #237, can you please verify?\n. Awesome, closing for now. I'm taking a deeper look into performance for V1, so stay tuned!\n. The initial value is done the exact same way you would set up an initial value in a Redux reducer - by providing it to your initial state:\n``` js\nconst initialState = { foo: 'bar' };\n/.../ modelReducer('myModel', initialState)\n```\nAnd then it would be passed to the value={...} prop of your component. Is this not working, or does this not fit your use case?\n. > Or, alternatively, how you would pass down the value from the form containing component to the custom field component)\nJust like you would in normal Redux. Perhaps I don't fully understand your question. If you have a store that looks like this:\njs\n{\n  user: modelReducer('user', initialUserState)\n}\nand you actions.change('user.foo', 'bar'), you can reference that as expected in your connected component:\n``` js\nconst { user } = this.props;\nreturn (\n  { user.foo }\n);\n```\nSo, are you asking how to set a value to be the initial state that is retrieved asynchronously? That's more of a Redux question, not a RRF question. I suggest having a custom reducer:\njs\nfunction myCustomReducer(state = {}, action) {\n  switch (action.type) {\n    case 'SET_INITIAL_STATE':\n      return {\n        ...state,\n        user: action.user,\n        initialUser: action.user\n      };\n    case 'RESET_USER_STATE':\n      return {\n        ...state,\n        user: state.initialUser,\n      };\n    default:\n      return state;\n  }\n}\nand then you can decorate your existing reducer using modeled(reducer, model).\nSo, I encourage you, think about how you would solve this problem in plain Redux and then you can easily fit it in to RRF.\n. You can populate your form with actions.load():\njs\ndispatch(actions.load('article', data));\nThe articleForm (presumedly from a formReducer contains all of the form information, such as if it's focused, valid, touched, submitted, etc. It doesn't carry any initialValue property (though it probably will in v1.0). \nAre you wanting to have the capability to reset the model to the initial value that you specify in the future? Again, that calls for a custom reducer since RRF's modelReducer() returns a state that is just your model value, without any meta information.\nSo, unless you need to explicitly set the initial state for purposes of resetting the form at some point in time, actions.load() will allow you to do what you need to do.\n. > I think, in this case, we can store fetched data somewhere and on reset - load it again into the form?\nYep, I think this is the best idea, without making things too complicated.\nYou can do this in your model, by having an ad-hoc initialState property and then manually dispatching actions.change('myModel', myModel.initialState) when you want to \"reset\" it.\nThe reason there can't be a mechanism for setting the initial value at any time past store initialization is that if your store looks like this:\njs\n{ foo: 'bar' }\nthere's no way of knowing what the initial value of that was in a pure functional way without adding a meta property such as:\njs\n{ foo: 'bar', initialState: { foo: 'first' } }\n. Fixed, thanks for pointing that out! Oversight on my part. Should be out in the next patch.\n. Do you have a formReducer on the state?\n. Ah sorry, I should have mentioned in the docs that form reducers are required if you're using a Form component (which sorta makes sense). I'll rectify this in the docs and by adding a development warning in the code.\n. I don't believe so! They're all just functions and I think the performance impact would be minimal.\n. Can you set this up in an www.esnextb.in to better demonstrate your issue?\nAlso, important to note that <input type=\"text\" value=\"123\" /> will always have value == \"123\" since it's a controlled component. That might be where the issue lies.\n. Do you want the value to always be 1? The reason this is not part of the model state is because it is set directly to the component, and not set in the Redux store.\nHere's an alternative:\njs\n// ...\ncomponentDidMount() {\n  this.props.dispatch(actions.load('article.priority', 1)); // silently set the value\n}\nrender() {\n  // ...\n  <Field model=\"article.priority\">\n    <input readOnly />\n  </Field>\n}\n// ...\nWill this work for your use case?\n. If you want to use defaultValue you still can - your input just won't be controlled. Have you tried that?\njs\n<Field model=\"article.priority\">\n  <input defaultValue=\"1\" />\n</Field>\n. Checkbox values are considered read-only; that is, their value doesn't ever change. It can only be toggled, such as true/false. What's your use case for checkboxes?\n. In the demo you provided, I submitted the form and got a value for both the input and checkbox once I've added the initial values.\n. Have you tried this?\n``` js\nimport { controls, createFieldClass } from 'react-redux-form';\nconst MaterialField = createFieldClass({\n  'TextField': controls.text,\n});\n```\nThat should work as expected. Inside createFieldClass, the mapping is only meant to be for when props don't share the same common event handler prop names as normal components.\nFor example, if my custom component has onChangeValue instead of onChange, I'd map it like this:\njs\nconst CustomField = createFieldClass({\n  'CustomText': (props) => ({\n    onChangeValue: props.onChange,\n  })\n})\nThis tells the CustomField that whenever something goes through onChangeValue in CustomText, it should go through the normal props.onChange instead.\n. @keown Yep, just fixed it! Will go out in the next patch today.\n. This would make a good enhancement - I'll keep it in mind for V1.0. I'm also planning on only having a single atomic formReducer be the requirement for 1.0, since that way, any part of the \"form tree\" can itself be a form, which would allow for multiple forms (dynamically created/removed, as you mentioned).\n. I'll leave it open until v1.0 hits \ud83d\ude04 \n. @VladShcherbin So after thinking about this, I figured that this would be the ideal API which requires the least amount of typing (in fact, even less typing than if you were to normally combine Redux reducers):\n``` js\n// BEFORE\nimport { createStore, combineReducers } from 'redux';\nimport { modelReducer, formReducer, modeled } from 'react-redux-form';\nimport bazReducer, { initialBaz } from '../path/to/baz-reducer';\nconst initialFoo = ...;\nconst initialBar = ...;\nconst store = createStore(combineReducers({\n  foo: modelReducer('foo', initialFoo),\n  fooForm: formReducer('foo', initialFoo),\n  bar: modelReducer('bar', initialBar),\n  barForm: formReducer('bar', initialBar),\n  baz: modeled(bazReducer, 'baz'),\n  bazForm: formReducer(bazReducer, initialBaz),\n});\n```\n``` js\n// AFTER - v1.0.x\nimport { createStore } from 'redux';\nimport { combineModelReducers } from 'react-redux-form';\nimport bazReducer from '../path/to/baz-reducer';\nconst initialFoo = ...;\nconst initialBar = ...;\nconst store = createStore(combineModelReducers({\n  foo: initialFoo, // not a function!\n  bar: initialBar, // not a function!\n  baz: bazReducer, // function - will be modeled()\n}, 'forms')); // <-- key where the formReducer will live\n```\nThe formReducer will be what significantly changes in v1.0 for simplicity, and because of its atomic/fractal nature, only one is needed - forms can be infinitely nested, and any subtree can itself be a form. So forms will be accessed from the store like this:\n``` js\n// in connected component:\nrender() {\n  const { forms } = this.props;\nconst fooForm = forms.foo;\n  const barForm = forms.bar;\n  const bazForm = forms.baz;\nconst fooAddressForm = fooForm.address;\n  const fooAddressFormValid = fooAddressForm.$form.valid;\n  const fooCityValid = fooAddressForm.city.valid; // foo.address.city is a primitive value, not a form\n// ... etc.\n}\n```\nThoughts on this?\n. @zargold You're in luck because V1 (now in beta) allows for dynamic and infinitely recursive forms. If you have something like this:\njs\nconst store = createStore(combineForms({\n  dynamic: {},\n}));\nand you receive data that you dispatch, such as:\njs\ndispatch(actions.change('dynamic.foo', {\n  bar: 'this is a dynamic field',\n  baz: 'so is this one',\n}));\nThen forms.dynamic.foo becomes a new form state that you can treat like any other form state.\n. Available in latest @beta - feel free to let me know if you are having trouble implementing the above for your use case. I am writing documentation now, which will be available at https://davidkpiano.github.io/react-redux-form.\n. > Thanks for this cool lib btw. \ud83d\udc4d\nI appreciate it, thanks!\nThis is a (non-)issue with validator.js - a recent update to their latest version.\nJust make sure that what you're passing into the function is a string:\njs\nvalidators={{\n  email: (value) => isEmail(value + ''),\n}}\nfor instance. Hope that helps!\n. Thanks, corrected the gitbook!\n. Fixed, thank you!\n. Thanks a ton for this! You'll be glad to know that only a couple things will change in version 1.0, and I'll update them (and ping you) when that happens.\n. Good catch! This is not the intended behavior, but the internal way that onChange, onFocus, etc. are being handled internally will be changed (and greatly improved) in the upcoming v1.0.\nHowever, this might be a bug, so I'll see about patching it.\n. @elodszopos @fromanother Can you look at the above unit test and let me know if it matches your use cases? https://github.com/davidkpiano/react-redux-form/commit/70bd8315e8a1acdfac2252cd2f4ba78d8de8aa2f#diff-b43d85b01204324e63c810644e344418R1319\nThe unit test above is actually passing, though the current code isn't published yet. This problem might already be fixed \ud83d\ude0c \n. Fix confirmed in 0.13.x \ud83d\ude04 \n. It should already work, in that it changes the model's value to the file path.\nExample here: http://davidkpiano.github.io/react-redux-form/docs/index.html#/recipe/various-controls (warning: old version but nothing should be different in the current version)\nLook for the file uploader component there. Does it perform the expected result?\n. Thanks for this! I'll close out #249 \n\nThanks for an awesome tool and for maintaining it this actively! BIG \ud83d\udc4d\n\nGreatly appreciated! \ud83d\ude04 \n. Great question!\nExternal validation via actions was a design decision from the very beginning, because validation can occur at any time, not just when the model value changes. Consider the following common use-cases:\n- Validation on blur\n- Debounced validation\n- Async validation\n- etc.\n\nIt seems awkward that the validators reside only in the view, not in the model.\n\nSort of, until you take asynchronous validators into account. Then it makes sense that the validators are external, and not in the reducer itself.\nDon't think about validators as being view-only, but rather as being external - validation can occur anywhere that you can dispatch() a validation action. Which brings me to my next point...\n\nThis makes more complex validations that rely on the state of two or more components very manual and error-prone\n\nWhat would your ideal API for this look like? Currently, you can validate multiple fields by validating its parent:\njs\n// in <Form>:\n<Form model=\"user\"\n  validators={{\n    '': {\n      passwordsMatch: (value) => value.password === value.confirmPassword\n    }\n  }}\n/>\njs\n// Manual dispatch:\ndispatch(actions.validate('user', {\n  passwordsMatch: (value) => value.password === value.confirmPassword\n});\n\nit makes it awfully tricky to fire off a request to validate a particular field\n\nReact Redux Form at its very core is just actions and reducers. Using <Field> and <Form> is always optional, and there's nothing stopping you from using the provided actions and reducers to create functionality that fits your use case.\nFor instance, let's say you want to validate a specific field at any time, even if it's not rendered. A good pattern would be to store your validators in a shared file, such as validators.js, and then:\n``` js\nimport validators from '../path/to/validators.js';\n// wherever dispatch() is available\ndispatch(actions.validate('user.email', validators.email));\n```\nIt's important to note that React Redux Form, just like Redux, provides the building blocks for you to be completely flexible in the way you build complex forms in Redux (and V1 will make it even more flexible). It's not a library that tries to do everything; it can do a lot, but there are hundreds of different use-cases for forms and being too opinionated about anything will alienate many of those use-cases.\nIt's important that React Redux Form errs on the side of being unopinionated, even if it involves a little more code. If the API allowed the user to define validators directly on the reducer, the following issues may occur:\n- Different mechanisms for sync and async validators instead of treating them equally\n- Inability to conditionally define validation via props\n- Very difficult to validate on blur\n- Impossible to validate on debounce\n- Impossible to validate asynchronously\n- Lack of flexibility in validating at any time\nSo, what would your ideal API that allows the above flexibility look like? I'm always open to suggestions.\n. You bring up some very good points, about having a centralized way to do validation (I agree, having them on <Field> and <Form> is a bit inflexible).\nWith that said, we need to rule out validators being in the reducer - they don't belong there unless we want to completely discount async and non-change-based validators. So we have two options for a cleaner, centralized validation API:\n- Validators as middleware\n- Validators in the action creators\nMiddleware might be the best option - that would allow us to intercept actions and, based on a per-validation config, specify when the validation should occur, and for what fields. And it can be asynchronous!\nThen a V1 validation triggered for a field would be as simple as:\njs\ndispatch(actions.validate('user.email'));\nThoughts on custom middleware?\n. We can continue to discuss here or elsewhere, would love to know your use cases for non-trivial validation!\n. Yeah, this is the perfect use-case for (async because validating zip) validation on <Form>. Keep in mind that if form-wide validators were allowed on <Field>, then <Field> would need to rerender any time any part of the form changes, which is a significant performance hit.\n. Sorry, this is not React-Redux-Form specific. If you try to do this without RRF (or even Redux), you will run into the same issue:\n``` js\nclass App extends React.Component {\n  constructor() {\n    super();\nthis.state = { value: '' };\n\n}\n  handleChange(e) {\n    console.log(e.target.value); // never gets logged\n    this.setState({ value: e.target.value });\n  }\n  render() {\n    return (\n        \nOne\n\n    )\n  }\n}\n```\n. Fixed! In case you were wondering what the issue was:\ndiff\n-   const formValid = form\n+   const formValid = (form && !fieldsValidity.hasOwnProperty(''))\n      ? form.valid\n      : true;\nThe formValid flag was being determined on the existing validity of the form, and not taking into account the new validity. Now it does!\nThis fix also improves performance slightly, as the callback functions for handling valid form submits are no longer recreated each time in render() - they're only created once.\n. Hmm, the formReducer should be acting upon any removed items from an actionTypes.CHANGE action by removing the field completely. This will be more elegantly solved in V1.0 but for now, can you give me steps to reproduce?\nI will definitely welcome any PRs around this.\n. > The only thing that might be nice is to allow the user to do actions.omit('blah.foo.bar')\nThat actually would be a good shorthand enhancement, potentially. There's a couple reasons that it's two arguments right now:\n- omit(model, props) can take in more than one prop, so you can bulk omit properties like:\njs\n// Remove `blah.foo.bar` and `blah.foo.baz`\ndispatch(actions.omit('blah.foo', ['bar', 'baz']));\n- There might be an enhancement in the future where you can pass in a predicate:\n``` js\n// pretend this lives on store.blah\nconst normalizedState = {\n  foo: { id: 1 },\n  bar: { id: 2 },\n  baz: { id: 3 },\n};\n// will remove blah.bar and blah.baz\ndispatch(actions.omit('blah', (val) => val.id > 1));\n``\n. Right, all predicates used throughout the RRF library are of the standard(value, key, collection) => {...}syntax.\n. Not sure I follow; can you please list the following?\n- What are the **steps** to reproduce the issue?\n- What is the **expected** outcome?\n- What is the **actual** outcome?\n. Sorry, I can't reproduce this in the latest RRF (version 0.13.x). Here's a working version: http://esnextb.in/?gist=a697395c0e02a5b68555c6f1691f103b\n. Yep, still worked as expected: http://esnextb.in/?gist=a697395c0e02a5b68555c6f1691f103b\n. Oh, I know what's going on. Making a patch now.\n. Yep, it's usingdisplayName`, which is minified in production mode, unfortunately.\nV1 will solve this issue, but until then, an easy workaround is this:\n``` js\nimport CustomTextInput from '../path/to/custom-text-input';\nCustomTextInput.displayName = 'CustomTextInput';\n// ... do everything else like normal\n```\nFor more info, see:\n- ~~https://davidkpiano.gitbooks.io/react-redux-form/content/react_native_&_custom_components.html#custom-components~~ https://davidkpiano.gitbooks.io/react-redux-form/content/custom_components.html\n- https://github.com/davidkpiano/react-redux-form/issues/224\n- https://github.com/davidkpiano/react-redux-form/issues/176\n- https://github.com/davidkpiano/react-redux-form/issues/161\n- https://github.com/davidkpiano/react-redux-form/issues/65\n. I've actually just introduced a more idiomatic way to do this:\njs\nconst BootstrapTextField = createFieldClass({\n  FormControl: controls.text\n}, {\n  componentMap: {\n    FormControl: FormControl\n  }\n});\nThis allows RRF to recognize the component by its constructor, instead of by its .displayName. Will be available in 0.13.6+\n. Oh, smart idea. I'll update that now.\nEDIT: Unfortunately, plain JS objects coerce their keys to strings, so this won't work.\n. Can you put a sample form on www.esnextb.in ?\nAlso, you can try only updating on blur:\njs\nconst MaterialField = createFieldClass({\n  'TextField': controls.text\n}, {\n  updateOn: 'blur'\n});\nThis should provide a significant performance boost. It's hard to pinpoint exactly where the performance issues are because you're using more libraries on top of RRF (and those might be the bottleneck). V1 will address performance heavily.\n. > will the new API that you describe in this comment solve part of this issue?\nYes it will. However, I'll try to make a patch that improves performance for flatten and findKey, because getFormStateKey should be cached.\n. @keown @compact I just pushed out a commit that refactors getFormStateKey(), with these optimizations:\n- flatten is no longer used in this function\n- findKey (lodash) is no longer used in this function\n- A breadth-first object key traversal is done first, as formReducers are most likely on the top-level of the state, rather than deep in the leaf nodes.\n  - If the formReducer key is found, return early.\n  - If the key represents a state slice that's an object (and not an array/primitive), store it as a candidate for searching.\n- Each candidate key is then searched recursively for the formReducer, which will exit early if it is found.\nCan you please verify that this alleviates performance issues? You can do so by git clone-ing this repo and running npm install && npm link && npm run build:watch or by specifying the git URL in your package.json dependencies for react-redux-form.\n. @keown Really? It shouldn't be... hmm. Anyway, add this:\ndiff\nconst MaterialField = createFieldClass({\n  'TextField': (props) => ({\n    name: props.name,\n    onChange: props.onChange,\n+   onBlur: props.onBlur,\n  }, {\n    updateOn: 'blur'\n  })\n})\n. V1 introduces a ton of performance enhancements, with improved batching strategies, tweaked shouldComponentUpdate for <Form>, <Field>, <Control>, and the ability to ignore certain actions via the ignore={['focus', 'blur']} prop. Now in @beta!\n. Thanks, this will solve part of the problem; dd3c394 addresses performance with this function much more heavily too. Will merge once the tests pass!\n. What props are on your <Form>? Can you create a minimal use-case example on www.esnextb.in ?\nThe <Field> component can already handle validating when an external model change (such as changing the model after an async call, like your use-case) occurs: https://github.com/davidkpiano/react-redux-form/blob/master/test/field-component-spec.js#L652-L682 So, validation shouldn't need to be triggered.\n. @fromanother Just fixed it with the commit above. The issue was that if \"user\" was being changed, it was not unflagging the .validated flag for \"user.email\" and \"user.username\" so RRF was not re-validating those fields.\n. Right, because defaultChecked is for uncontrolled components, and RRF makes radio and checkbox components controlled so that they can be updated externally. \nAre you sure that you want your radio and checkbox components to be uncontrolled components? If you are using Redux, you can accomplish the same behavior by setting an initial state for the models that these radio and checkbox components represent. This is the recommended approach.\nHowever, I will create a patch that lets radio and checkbox components remain uncontrolled if you specify defaultChecked. Just keep in mind that this will remove the ability for RRF to externally check/uncheck these components from outside changes.\n. Ah, gotcha. You can dispatch actions.change(model, value) at any time once you receive the data from the server. Would that work for your use case?\njs\ngetDataFromServer()\n  .then(result => {\n    dispatch(actions.change('user.name', result.name));\n  })\n. And yes, you should try to avoid defaultValue.\n. Yeah, absolutely!\nIf you want to merge parts of the model with the entire model, you can also do this:\njs\ndispatch(actions.merge('user', { name: result.name }))\nwhich is useful if your user model has more fields than just name.\n. > Why can't a Field component updateOn submit ?\nBecause when a <form> is submitted, it is the sole receiver of that event, and there is (currently) no way of letting the <Field> component know that a form is about to be submitted before the <form> handles the event. If you have any ideas on how to accomplish this, feel free to let me know.\n\nIn my case, it would allow big performance improvments...\n\nTry using updateOn=\"blur\".\n\nAlso, about the function we can pass to the updateOn prop: does it take as argument anything that would help us implement a custom behavior (state of the form, etc...) ?\n\nThis behavior is deprecated. Use the changeAction={...} prop instead.\n\nAlso is it normal that a form can be submitted even if the validation rules set at the Field components level do not pass?\n\nNo, if you are using <Form>, then the onSubmit={...} handler will never be called for an invalid form.\n. Are you using a <form> or RRF's <Form> component?\nIf you are using <form> you need to check validity before submitting.\n. I've copy/pasted your example (replaced form_survey with user but otherwise it's the same thing) here: http://esnextb.in/?gist=df6cfa4a49e2a3ecadb6a03dcc07f2a0\n\nIf I do not touch any field and submit, onSubmit is triggered.\n\nI can't reproduce this.\n\nIf I touch one required field but do not fill it, then validation triggers (and do not pass) and submission fails (onSubmit not triggered).\n\nThis is expected, right?\n\nThe first submit will trigger validation on the touched field only (not other fields).\n\nThis is also expected. When you touch a field, only that field is touched.\n\nA second touch on submit will trigger validation on all fields but will not display the validation message on untouched fields.\n\nCan't replicate. All validation messages show.\n\nif I touch a field that has validators, fill it correctly or incorrectly (both gives the same behaviour) and touch another field, then the focus is not set on this other field and I have to touch it again to set focus on it. \n\nI couldn't replicate this either. When I focus on the second field, type anything (or nothing), and press TAB, it properly focuses the following field.\nPlease look at the link at the top and see if you are still getting the same issues. Also, it's best if you isolate each issue into a minimal test case with the least amount of code possible to replicate the error. Otherwise, it's difficult for me to debug the issue in a timely manner.\n. I just updated the gist: http://esnextb.in/?gist=df6cfa4a49e2a3ecadb6a03dcc07f2a0\nThe first issue is not an issue; I accidentally did isRequired() for a number, and since a number doesn't have .length it was always invalid. Changed it to numRequired() and it works.\n\nAlso something odd with the radio and checkbox inputs: if you change their value, it will trigger as many rrf/setErrors actions as there are  tags the the Field. Couldn't it be optimize?\n\nYes, that would make a good enhancement.\n. Yeah, I'm moving away from using validator.js myself, there are other good libraries out there. Thanks for the detailed issue!\n. If an input has updateOn=\"blur\", then it is an uncontrolled component by necessity right now (because a connected input represents the state, and if you are still focused in the input and type a value, the input's value is not the same as the input's state until you blur).\nThis will be solved in v1.0. For now, you might need to remove updateOn=\"blur\" if you want it to update, or have the component be controlled yourself.\nYou also don't have to use <Field>. You can always dispatch the actions directly from your component, such as:\njs\n<input value={this.state.foo}\n  onBlur={(e) => dispatch(actions.change('user.foo', e))}\n/>\n. There is no such thing as a \"half controlled\" component. It is either fully controlled or fully uncontrolled; React will throw a warning if you go from making a component uncontrolled to controlled (and vice versa).\nThis will be fixed in V1 by making the component fully controlled with regard to its viewValue, which may differ from the modelValue in that it is always in sync with the modelValue but not the other way around.\nIf you are not loading data in asynchronously and using the input as a normal text field where values always come from the user, updateOn=\"blur\" does not make the component \"useless\" because it will work as expected.\n. This is fixed in the latest @beta, now that the component is fully controlled regardless of blur/change.\n. Which custom Select component is this? Did you read the docs on Custom Components?\n. The Material-UI TextField example works well:\n``` js\nimport { createFieldClass, controls } from 'react-redux-form';\nimport TextField from 'material-ui/lib/text-field';\nconst MaterialField = createFieldClass({\n  'TextField': controls.text\n}, {\n  componentMap: {\n    TextField: TextField\n  }\n});\n// render():\n\n\n\n``\n. @philippzentner can you share your current problematic code?. Hey! How are you callingomit`? Can you please show me a minimal reproducible test case demonstrating the unexpected result/potential bug?\nEDIT: The way that the formReducer() works in V1.0 is being completely refactored, and the shape of the form state will more closely match the shape of the actual model, meaning that field states will be predictably and reliably added/removed.\n. Closing due to inactivity. This will be refactored in V1.0\n. If possible, can you reproduce the issue inside of www.esnextb.in ?\n. The first thing I noticed was that your <Select> component is inside a <Field> that doesn't know what kind of component that is. Have you read the documentation on custom components?\n. I'll close this for now, since it's a usage question and not an issue. If you encounter any bugs while trying to implement RRF into React-Select, feel free to open another issue.\n. This seems like a specific use-case. Can you show me the code you have for this so far?\nYou can dispatch actions.change('some.other.model', ...) at any time:\njs\n<Field model=\"first.model\">\n  <input onChange={() => dispatch(actions.change('second.model', ...))} />\n</Field>\n. This seems pretty contrived, and I don't see where you are connect()ing your components to make dispatch available in the props. Please break the problem down to the most minimal example possible (that is, without the custom logic) and put it on www.esnextb.in so that I may be able to help you.\n. @MiMaMuh This doesn't seem to be occurring in 0.14.2. Can you please confirm here by looking at this test case (which is pretty much a copy-paste of your implementation)?\nhttps://github.com/davidkpiano/react-redux-form/commit/6d31d97ebc0a7c00c3fff7304d2ebac673f8dd15#diff-ded95f7363bb42a57e08873c85c00260R234\n. I'll continue to investigate events with React Native, that seems strange that it doesn't get that property. Thanks for looking into it!\n. @MiMaMuh: \n\nHm, just considering it: It isn't really an issue.\n\nThis is what I consider as well. Here's my thoughts, assume you have two validators:\n- (sync) required\n- (async) available\nNow consider the following changes:\n1. '' results in { required: false }\n2. 'taken' results in { required: true } and triggers async validation...\n3. 'taken' is not available, so { required: true, available: false }\n4. 'not-taken' executes setValidity which overwrites the validity to { required: true }\nThe fact that the { available: false } validity is overwritten (removed) in 4 makes sense, since { available: false } is a validity that only applies to the value 'taken', and not the value 'not-taken'.\n. This is because updateOn=\"blur\" fields right now are unconnected fields - since they reflect the model value, they can't be connected to the modelValue if they're only updated on blur.\nI'm working on resolving this in V1. The idiomatic way to handle this right now is to control the <input> yourself, using this.setState in the onChange handler.\n. This is fixed in the latest @beta.\n. I'll have a fix for this soon - the issue is that directly calling submit() on the form node will do the default action of submitting the form the HTML5 way.\n. This is now fixed! See here: https://github.com/davidkpiano/react-redux-form/issues/296#issuecomment-230113569\n. Good idea! I'll add that soon as well.\n. Can you put this in an www.esnextb.in so I can better diagnose the issue?\n. @venelin-mihaylov Any updates on this?\n. Closing due to inactivity. If you could, please make an www.esnextb.in with the minimal code necessary to reproduce the issue so I could better diagnose.\n. > Am I supposed to be cleaning up the valid and/or validity keys manually?\nIdeally no, but that's a good workaround currently. I'll investigate this.\n. @cipater Can you please install the latest version (1.0.12) and let me know if you're still experiencing the same issue?\n. @cipater Is forms.order.address an object or a string?\n. Is this still an issue with the latest version? @cipater \n. @cipater: The problem with using setFieldsErrors() with this error structure:\n{\n  address: {\n    first_name: \"can't be empty\",\n    ...\n  },\n  ...\n}\nis that RRF has no way of knowing if 'first_name' is an error key or a model key. As a counterexample, I'm working with an API which returns errors as arrays; e.g.;\n{ credit_card: ['Number is invalid', 'Card is expired'] }\nAnd it would be erroneous for RRF to assume that we were talking about credit_card[0] and credit_card[1].\nYour approach of manually validating is the correct approach; RRF would become severely bloated if it tried to handle every possible API approach to sending back async errors.\nTo make your life easier, I recommend a package such as flat to flatten nested structures. Then, you can pass this directly into setFieldsErrors(model, flattenedErrors).\n. Yes, that is intended. This will be addressed in V1, where you could access it as if it were an array, like so:\n``` js\nconst { userForm } = this.props;\nuserForm.deep.collection[0].five; // => field state\n``\n. It will be the exact same shape as the state, so[0]. Also keep in mind that internally, lodash's.getmethod interpretsfoo[0]andfoo.0the same.\n. Sure, if you're using lodash (which RRF uses internally), you can just useget`:\n``` js\nimport get from 'lodash/get';\n// ...\nexport default connect((state, props) => ({\n  value: get(state, props.model, null),\n}))(PersonField);\n```\nBut this would be a good enhancement to expose it so I'll mark it as an enhancement.\n. Actually it's already available:\n``` js\nimport get from 'react-redux-form/utils/get';\n// ...\nexport default connect((state, props) => ({\n  value: get(state, props.model, null),\n}))(PersonField);\n```\n. Yeah sure, I'll mark it as an enhancement.\n\nI basically want error messages to appear on blur, but to disappear on change.\n\nYou can do this with the <Errors /> component like so:\njs\n<Errors model=\"...\" show={{ focus: true, touched: true, submitFailed: true }} ... />\n. Actually, yeah, because of the event sequencing logic, it's preferred to just have it validate on a certain event, such as \"change\" or \"blur\", and show the errors conditionally like I've demonstrated.\n. Yeah, I'll be creating a temporary workaround for this. It's really not good practice to be attaching ad-hoc methods on the form instance, so we'll have to think of a better way to accomplish this.\n. Now there is!\njs\nclass App extends React.Component {\n  attachNode(node) {\n    this._form = findDOMNode(node);\n  }\n  handleClick() {\n    this._form.submit();\n  }\n  handleSubmit() {\n    // ...\n  }\n  render() {\n    return (\n      <div>\n        <Form\n          model=\"test\"\n          onSubmit={this.handleSubmit.bind(this)}\n          ref={this.attachNode.bind(this)}\n        >\n          <Field\n            model=\"test.foo\"\n          >\n            <input type=\"text\" />\n          </Field>\n        </Form>\n        <button onClick={this.handleClick.bind(this)} />\n      </div>\n    );\n  }\n}\n. @jenyckee Do you have action defined?. Right, because at the point you dispatch that action, the component has not rerendered with the new props yet until it finishes execution of that method. You can't treat dispatching an action as imperative, you have to wait until the component rerenders with new props.\nThis is what's happening:\n- setValidity action dispatched\n- console.log('is valid?' ...)\n- userProfileForm is still valid because changes haven't propagated yet\n- at this point method is completed and component rerenders with new state\n- now userProfileForm is invalid.\n. You can get it from userProfileForm.valid and userProfileForm.validity (which is more detailed).\nAlso, you can get the validity of each field: userProfileForm.fields.foo.validity\n. Can you please post a code example on www.esnextb.in ?\n. Two things:\nFirst, make this change:\ndiff\n- userProfileForm: formReducer('userProfileForm')\n+ userProfileForm: formReducer('userProfile')\nto let RRF know that this userProfileForm is for the userProfile model. (This will be greatly simplified in V1).\nSecondly, since dispatching is not synchronous, you will have to check the validity in componentWillUpdate or a similar method. If you don't enter a value and click submit twice with the modification above, you will get true (because the dispatch happened asynchronously) and then false the second time you clicked it.\n. Add a validator:\njs\n        <Field model=\"userProfile.test\" validators={...}>\n          <label>Test </label>\n          <input type=\"text\" defaultValue=\"\" />\n        </Field>\nIf it's .valid === false by default, and there are no validators, it will never be valid. Validators are run immediately when Field is mounted.\nIn V1.0 there will be the option to let you specify the default initial state, and customize form behavior via plugins.\n. This is available in 0.13.11\n. Have you read the section on custom components? https://davidkpiano.gitbooks.io/react-redux-form/content/custom_components.html\n. Please create an example on www.esnextb.in as well, otherwise I am unable to reproduce this.\n. Sure, give me a couple hours - there might be a couple more tiny patches I'd like to fit in as well.\n. > Also i have performance problems with the TextField :(\nWhat's the issue?\nAlso, try to map dispatching actions directly to the component first: https://davidkpiano.gitbooks.io/react-redux-form/content/custom_components.html\n. Closing this as it is a usage question. Let me know if dispatching actions directly works!\n. Sure, if you have the initial setup already completed, you can do something like this:\n``` js\n// Assuming you have a 'user' modelReducer in your store,\n// with an initial state of .phones = []\nimport { Field, actions } from 'react-redux-form';\n// inside the render() method of your React component:\nrender() {\n  const { user, dispatch }  = this.props;\nreturn (\n    \n      { user.phones.map((phone, i) =>\n        user.phones[${i}]} key={i}>\n          \n\n      }\n       dispatch(actions.push('user.phones', ''))}>\n        Add phone\n      \n\n  );\n}\n```\nDoes this make sense?\n. Thanks for reporting, can you spin up a quick www.esnextb.in if you get the chance to demonstrate the error with your use case so I can create accurate unit tests?\n. @zabojad This should fix the issue. Can you please confirm in 0.14.0?\n. Does it have to be minor, and not a patch? I'd like to include more fixes/enhancements before I bump a minor.\n. Curious, why would a value that's meant for a text field be an object? In order to display the view value, JS has to convert it to a string, which happens to be \"[object Object]\".\n. @zabojad This test case should reproduce your exact bug: https://github.com/davidkpiano/react-redux-form/commit/3537554b9b78a6dc0cc7311c9f7d1a6fcf2d8c6e#diff-55bc9da456e5c128d620d4d263cb75b3R333\nYes, I did confirm it as a bug and it will be released the next patch later today. Can you look over that test case and make sure that it is exactly your use case? I tried to replicate it as much as possible.\n. @zabojad You mean when you update the model externally, it doesn't show in the control? #278 \nV1.0 is nearing completion and that is fixed in there \ud83c\udf89 \n. So the issue here is that track(...) answers the question \"Which item in the collection should we refer to?\" However, you're trying to identify two things at the same time: an unknown collection that contains items which themselves might contain the item you're talking about (nested collections).\nSo, it would be best to identify the outer collection model first (and you can use any method you prefer), and then use track as normal:\n``` js\n// determined somehow\nconst collectionModel = 'groups[3]';\n// ...\n${collectionModel}.values[].value, { id })} >\n``\n. @hgylfason Alltrackis is a function that returns a \"model getter\". That might still sound complicated so read here to see how it's created: https://davidkpiano.gitbooks.io/react-redux-form/content/tracking_collections.html\n. You can use the track function outside`. It is a function that returns a function that, given a state, returns the expected model path. And it's a pure function, so it isn't (nor should it be) context-aware.\njs\nconst tracker = track('group.users[].name', { id: 3 });\nconst path = tracker(state); // something like 'group.users[5].name'\n. I'm working on this! What's going to happen temporarily in 0.x is you'll have to import { Field } from 'react-redux-form/lib/immutable' as well, and then use that.\nIn V1 it'll work the exact same way, importing from 'react-redux-form/immutable' instead however.. @sephi-chan @ottoo Can you do me a huge favor and post a minimally reproducible code sample on www.esnextb.in that shows thatdoesn't work with an immutable model reducer using Immutable.JS? That way I can write accurate unit tests.\n. Here's the fix, just like I mentioned. Now you have to importFieldas well fromreact-redux-form/lib/immutable` (which isn't a huge deal, since you're importing stuff from there anyway).\nIf you're curious to how this was done, it's just this:\njs\nconst ImmutableField = createFieldClass(undefined, {\n  getter: immutableGetFromState,\n});\nwhere immutableGetFromState(state, model) is a function that gets the model from the state, and checks along the way to see if it's an Immutable data structure. If it is, it calls .get() to get the value instead of accessing it directly.\n. @erin-doyle I'm still working on making React-Redux-Form compatible with ImmutableJS. It's a non-trivial task, but I'm halfway done.\n. Thanks @erin-doyle - always willing to accept PRs! Essentially, here's a concept of what I'm doing to make RRF compatible with ImmutableJS.\nFirst, we start with an original function:\n``` js\nimport get from 'lodash/get';\nimport i from 'icepick';\nfunction double(state, prop, value) {\n  const firstValue = get(state, prop); // eg. get(user, 'age') for user.age\n  const doubledValue = firstValue * 2;\n  return i.set(state, prop, doubledValue);\n}\n```\nThen we separate the internal operational functions into \"strategies\":\n``` js\nimport get from 'lodash/get';\nimport i from 'icepick';\nconst strategy = {\n  get: (state, path) => get(state, path),\n  set: (state, path, value) => i.set(state, path, value),\n};\nfunction double(state, prop, value) {\n  const firstValue = strategy.get(state, prop);\n  const doubledValue = firstValue * 2;\n  return strategy.set(state, prop, doubledValue);\n}\n```\nAnd then we create a function that takes in a strategy and returns the original function with the specified strategy:\n``` js\n// ...\nconst defaultStrategy = { ... }; // same as above\nfunction createDoubler(strategy = defaultStrategy) {\n  return function double(state, prop, value) {\n    const firstValue = strategy.get(state, prop);\n    const doubledValue = firstValue * 2;\n    return strategy.set(state, prop, doubledValue);\n  }\n}\nexport default createDoubler();\nexport { createDoubler };\n```\nFrom there, we can import { createDoubler } from ... and use it with an ImmutableJS strategy like:\n``` js\nimport { createDoubler } from 'path/to/doubler';\nfunction immutableGet(state, path) { / ... / }\nfunction immutableSet(state, path, value) { / ... / }\nconst immutableStrategy = {\n  get: immutableGet,\n  set: immutableSet,\n};\nconst doubler = createDoubler(immutableStrategy);\nexport default doubler;\n``\n. Yep! And also a slight refactoring of the unit tests (I got started on this infield-component-spec.js`):\n``` js\n// ...\nconst testContexts = {\n  standard: {\n    Field: _Field,\n    actions: _actions,\n    modelReducer: _modelReducer,\n    formReducer: _formReducer,\n    get: _get,\n    length: (value) => value.length,\n  },\n  immutable: {\n    Field: ImmutableField,\n    actions: immutableActions,\n    modelReducer: (model, initialState) =>\n      immutableModelReducer(model, Immutable.fromJS(initialState)),\n    formReducer: immutableFormReducer,\n    get: (value, path) => {\n      const result = value.getIn(toPath(path));\n      try {\n        return result.toJS();\n      } catch (e) {\n        return result;\n      }\n    },\n    length: (value) => value.size,\n  },\n};\nObject.keys(testContexts).forEach((testKey) => {\n// ... all the tests\n```\n. > if only the models within the store are immutable but the store itself is not, things seem to be working well.\nYep, this is the intention @erin-doyle - if we can keep the formReducer as working with plain JS objects (even if working with immutable models), I think that should still satisfy most use cases.\n. Docs here! http://davidkpiano.github.io/react-redux-form/docs/guides/immutable.html\n. What kind of options would these be? Is it related to the model or the form state?\nIf it's the model, make a custom reducer and wrap it in modeled(...): https://davidkpiano.gitbooks.io/react-redux-form/content/model_reducers.html#using-existing-reducers\n. So you're talking about an array of options such as { makes: ['Ford', 'BMW', 'Audi', 'Tesla'] } etc.? Seems to me like this is a constant that should be referenced in a separate reducer, since the model reducer only cares about what the current value is, and the form reducer only cares about the state of the form, such as focus, pristine, etc.\nI'd set up something like this:\n``` js\nimport { actionTypes } from 'react-redux-form';\nconst makeReducer = (state = [], action) => {\n  switch (action.type) {\n    case actionTypes.CHANGE:\n      if (action.model === 'vehicle.type') {\n        switch (action.value) {\n          case 'car':\n            return ['Ford', 'BMW', 'Audi', 'Tesla'];\n          default:\n            // etc.\n        }\n      }\n    // ... etc. return state\n  }\n}\n``\n. @alexesDev That's a good solution! Since RRF is a library, and not a framework, more than one solution exists and you can use the one that best fits your needs. You can validate directly on the`s, or you can dispatch actions that validate before submitting.\n. See the answer over here: https://github.com/davidkpiano/react-redux-form/issues/313\nHowever, would something like this make sense? \n``` js\n// future? syntax\nimport { trackDeep } from 'react-redux-form';\n// ...\n<Field\n  model={trackDeep('quiz.questions[].choices[].prompt', { id: 12 }, { key: 'a' })}\n\n```\n\ntrackDeep would be a function with the signature (modelPath, predicates...) where each predicate would refer to each collection. So in the above example:\n- the model for the questions with id === 12 would be found...\n- and then the model for the choices with key === 'a' inside that questions model would be found.\nWould this be a good addition to the API? cc. @hgylfason\n. > you could add the new behavior to track without breaking anything, right?\nGood catch, yes I can!\n. Added to @beta here: https://github.com/davidkpiano/react-redux-form/commit/44e0712144e5775aa1f6d0f2d7a39b0a80805ec4\n. Please see the documentation here: https://davidkpiano.gitbooks.io/react-redux-form/content/form_reducers.html\n. In order for RRF to know where to read/update the model, it needs to be provided the exact path (relative to the store state) to the model, so try this:\n``` js\n// reducers/form.js\nimport { modelReducer, formReducer } from 'react-redux-form';\n// this will be accessed in the state as .form.createUser\nexport const createUser = modelReducer('form.createUser', {});\n// same model as the model reducer\nexport const createUserForm = formReducer('form.createUser', {});\nexport default combineReducers({\n  createUser,\n  createUserForm,\n});\n```\nLet me know if the above solution works with your use case.\n. This would be a good enhancement for V1.0. I imagine the syntax would be:\n``` js\n<Field model=\"...\"\n  validateOn={['focus', 'blur']}\n\n``\n. Fixed and will go out in next@beta! The syntax is exactly as above, and can be used in any similar props, such asupdateOn,validateOn,asyncValidateOn`, etc.\n. One of the main design goals of RRF is with flexibility, in that:\n- You can use your own reducers\n- Model reducers can exist without form-related meta information\n\nThe value property was added just to keep track of value equality, whether the value changed from its initial value, and optimize performance - it should be considered an internal property and not used as if it were the actual model value (even though it is).\nDoes that answer your question? I can go more in depth if you'd like.\n. @richardscarrott RRF already uses a batching strategy :) For example, if you had updateOn=\"blur\", then you would dispatch a single batch action:\n[\n  { type: actionTypes.BLUR, model: '...' },\n  { type: actionTypes.CHANGE, model: '...', value: '...' },\n]\n. And @greaber V1 will allow you to specify plugins for the formReducer, which allows you to create a plugin that tells the formReducer to listen for your own actions as if they were RRF change actions. More on this soon - I'm preparing an alpha release for V1!\n. V1 is out! I will have docs for form plugins soon.\n. Still planning this as an enhancement, but as an option - there are use-cases where async validity should run even though sync validity is invalid. As a contrived example, say there's a username field with:\n- sync validity that it cannot be the same as the email field\n- async validity that it cannot be already taken\nIt would be useful to see simultaneous errors that the username is the same as the email field and that it's already taken, so the user can know that simply changing the email won't make it valid.\n. Okay, good point.\n. I really like the idea of functions as children, and am looking to make that a general capability in V1.\nBut for classNames specifically (and this is something I can add right now), I was thinking of adding a classNames prop:\n``` js\n<Field model=\"login.email\"\n  classNames={{\n    focus: 'is-focused',\n    pristine: 'is-pristine',\n    error: 'has-error',\n  }}\n\n// ...\n```\n\nOr maybe even with a function:\n``` js\n field.errors.required ? 'error-required' : ''}\n\n// ...\n```\n. Yeah, with children as function that would become doable:\n\n``` js\nimport classNames from 'classnames';\n// ...\n\n{(field) => }\n\n``\n. Children as function components forare now available in the latest@beta! Just use the pattern [above](https://github.com/davidkpiano/react-redux-form/issues/331#issuecomment-236368118).\n. Can you put the full example on www.esnextb.in ? Hard to tell what's going on without seeing thestore, which reducers you have set up, etc.\n. Done! Look for this one in an upcoming patch!\n. Yes, I'd be open to including that. What did you need to add to get it to work? If you'd like to make a PR, I'd be happy to merge it. Otherwise I can look into it sometime this weekend.\n. This LGTM! I'm fine withReactReduxFormbeing the output name.\n. Yes, I'll do that soon!\n. @djkz @mdgbayly I must have forgotten tonpm publish, because it's now available: https://npmcdn.com/react-redux-form@0.14.4/umd/ReactReduxForm.min.js\n. As Redux suggests,result` is derived data so it's best handled in a selector: http://redux.js.org/docs/recipes/ComputingDerivedData.html\nSo you ideally would have a state that only contains non-derived data:\njs\nstate = {\n  a: 2,\n  b: 3,\n}\nand a selector:\n``` js\nconst MyComponent = // ...\nexport default connect((state) => ({\n  ...state,\n  result: state.a + state.b,\n})(MyComponent);\n``\n. On the`, just add a validator:\n``` js\nimport { Form } from 'react-redux-form';\n// ...\n children.every(child => child.age < 100)\n  }}\n>\n```\n\nDoes that answer your question?\n. Can you put it up on www.esnextb.in so I can reproduce?\n\nAnd are you accessing it via `parentForm.fields['children.0.age'].valid`? That's the current (ugly) way to access a field.\n\nIn V1.0, you can access it more intuitively: `parentForm.children[0].age`.\n. Try adding a validator directly to the field:\n\n``` js\n age < 100\n    }}\n  >\n    \n\n```\n\nI get the expected result in the console when I try this.\n. This would make a good enhancement, but I think we can avoid \"nesting\" the value in the first argument by just providing the `error` in the second argument:\n\n``` js\n// message (as function) API:\n// [key]: (value, error) => message\n\n `${value} is not between ${min} and ${max}`,\n  }}\n>\n```\n\nWhat do you think about that?\n. As far as what's recommended and not recommended, I wouldn't be biased on one approach over another, especially with a complex validity use-case such as this one (which would even be non-trivial with any other validation library).\n\nI'd say the way to go, if we're using this API, is to have it as an `errors={{...}}` validator on the `` (or ``, your preference), where a truthy object, such as `{min, max}` would signify an error.\n\nAlternatively, the easiest way to really accomplish this without any API changes is to have something like this...\n\n``` js\nconst MIN_LENGTH = 3;\nconst MAX_LENGTH = 12;\n\n// ...\n\n `${val} is not between ${MIN_LENGTH} and ${MAX_LENGTH}`\n  }}\n>\n```\n. This is fixed in V1 (beta coming soon - I still have to write migration notes for it) and is due to the fact that `updateOn=\"blur\"` in v0.x is an _uncontrolled_ component: https://github.com/davidkpiano/react-redux-form/issues/278\n. I can make it so that only validity present in the Field's `validators` are reset on unmount, would that make sense?\n. @Psykar after the latest `@beta`, if this issue persists:\n\n> Another thing to note here - if the  component's validators or errors prop changes, the form validation isn't touched. I feel that if either of these properties changes, the entire form should be revalidated.\n\ncan you open up another ticket for it?\n. Looks great to me! Some minor spacing issues but I'll resolve that later.\n. Made a fix for this here: https://github.com/davidkpiano/react-redux-form/commit/b50773fface01b2f4b3c88a43ae96ee9e759ad04\n\nI'll write a unit test to assert that it works as expected soon!\n. @enkay @Psykar Keep in mind that there are a couple breaking changes (although 90% of the API has remained the same), and I will be documenting these today!\n. The latest (in progress) documentation is available here: https://davidkpiano.github.io/react-redux-form - I will be working on finishing this this week.\n\nTo keep up to date with the latest beta versions, just `npm install react-redux-form@beta` \ud83c\udf89 \n. Can you put it up on www.esnextb.in with the minimally reproducible code?\n\nAlso, for reference, here is the unit test for ``: https://github.com/davidkpiano/react-redux-form/blob/master/test/field-component-spec.js#L489-L521\n\nI'm working on the V1 docs right now, and will definitely include this.\n. I can't reproduce this behavior with a normal text input. Are you formatting/masking the text input?\n\nCan you also throw this up on www.esnextb.in ?\n. Yes, go ahead and copy this for v1.0-beta: https://esnextb.in/?gist=15e9350ba0e68fd001436d20502a9c69\n. I now can reproduce this. Fix coming up.\n. This has been fixed, and will be out in the next `@beta`. To confirm, run `npm run examples`.\n. @MrBlenny I'm just finishing docs! The beta is stable (twice as many unit tests as 0.14.x, and it reuses most of the same tests anyway). I just want to test it in a complex production app (dogfooding!) before releasing it.\n. The property `.pending` indicates that a form is submitting, and that property alone should be satisfactory.\n\nFor returning an error with the field names in the object, try `actions.submitFields(promise)` (sorry if this is not documented - I'm working on V1 and that will have a ton of documentation and examples!)\n\nWith both of these in mind, can you make a quick www.esnextb.in that demonstrates the failing code?\n. Well it's just a convenience action. RRF is a library, so you can implement your own submit behavior like this:\n\n``` js\nimport { actions } from 'react-redux-form';\n\n// custom action\nconst submitMyForm = (values) => {\n  return (dispatch, getState) => {\n    dispatch(actions.setPending('myForm'));\n\n    postToAPI(values)\n      .then((result) => {\n        dispatch(actions.setPending('myForm', false));\n\n        // do what you want with the result\n      })\n      .catch((errors) => {\n        dispatch(actions.setSubmitFailed('myForm'));\n        dispatch(actions.setFieldsErrors('myForm', errors));\n      });\n  }\n}\n```\n\nAnd that way you can more granularly control the behavior of submitting your form. You're not required to use the provided `actions.submit()` or `actions.submitFields()`, and (hopefully) it's fairly straightforward to write your own implementations \ud83d\ude04 \n. Hmm... nope, the code should be setting `pending` to `false`:\n\n``` js\n// in form-reducer.js\ncase actionTypes.SET_SUBMITTED: {\n        const submittedState = {\n          pending: false,\n          submitted: !!action.submitted,\n          submitFailed: false,\n          touched: true,\n          untouched: false, // will be deprecated\n        };\n```\n\nOnce the promise is resolved (or rejected) either `setSubmitted` or `setSubmitFailed` will be called, which both set `pending: false`. Also, your `submitPromise` should just be a normal promise, so something like this:\n\n``` js\nhandleSubmit(values) {\n  // ...\n\n  // normal promise\n  const promise = postToAPI(values).then(...);\n\n  dispatch(actions.submitFields('form', promise));\n}\n```\n. Can you put this up on www.esnextb.in ?\n\nFrom what I can see, you should be able to find it under `.inviteManager.form.fields.to.errors`. Is that where you're looking?\n. So currently in v1, since `valid` can be derived from the state, you have to do:\n\n``` js\nimport { utils } from 'react-redux-form';\n\nisValid(fieldValue); // true or false, depending on validity\n```\n\nBut I might consider adding it back, even if it might cause performance issues in very large forms. What do you think? Vote \ud83d\udc4d or \ud83d\udc4e \n. Added it back in `1.0.0-beta.6`!\n. @th3fallen Yep, that's definitely possible... I just need to work out the logic for it. I think that V1 will initially only allow this for string models, and disallow that behavior if the model is a `getter` function, such as `track(...)`. It would look like this:\n\n``` js\n\n // user.name\n\n```\n\nSee #173 for more details.\n. As for the initial issue, I know exactly what the bug is and will fix it soon. \n. Fixed here: 3026bb4\n. I didn't push the version yet though... that'll be later today.\n. Can you share how you're creating the store?\n. See the gist in #366\n. What beta version are you on, and how are you creating your store?\n. Okay, I fixed this; please compare your code to this gist: https://gist.github.com/davidkpiano/ec1d496eb1c67793ccfa5dbad7327ae2\n. Yeah, I still have to document `combineForms()` but you shouldn't be using it as a single reducer - think of it as a combination of many reducers, similar to `combineReducers()`:\n\n``` js\nconst reducer = combineForms({\n  foo: initialFooState, // < this represents the foo model reducer\n  bar: initialBarState, // < this represents the bar model reducer\n}, /* ... */);\n```\n\nSo having `combineReducers({ to: '', message: '' }, ...)` makes no sense because `to` and `message` are part of the `inviteManager` reducer, and _not_ their own reducer. Hopefully that makes sense.\n. Yes, you can do the same as v0.x:\n\n``` js\nconst reducer = combineReducers({\n  foo: modelReducer('path.to.foo', initialFooState),\n  fooForm: formReducer('path.to.foo', initialFooState),\n  bar: modelReducer('path.to.bar', initiaBarState),\n  barForm: formReducer('path.to.bar', initialBarState),\n});\n```\n\nAlso I'm adding back the missing derived values (such as `.valid`, `.touched`, `.pristine`, etc.) in the next `@beta` version, so you won't even need the `form()` selector :)\n. How are you dispatching those actions?\n. Which version of RRF are you using?\n. Unfortunately I'm not able to recreate this, see this esnextb.in for more details and compare your code to mine: https://esnextb.in/?gist=3e2aff9211382a2183d671733973a19c\n\nThis also uses `v1.0.0-beta.6`. Also, you can freely change the `store` like so:\n\n``` js\n// Old way\nconst store = createStore(combineReducers({\n  user: modelReducer('user', initialUser),\n  userForm: formReducer('user', initialUser)\n}), applyMiddleware(createLogger(), thunk));\n\n// New way\nconst store = createStore(combineForms({\n  user: initialUser,\n}), applyMiddleware(createLogger(), thunk));\n```\n. Fixed! Will go out in next `@beta` release.\n. @msteward I noticed this was on `v0.14.4`. Would you mind trying it with `react-redux-form@beta` (which does make all inputs controlled, even blur inputs) and see if it fixes the issue?\n. Since V1 will be directly controlling all components (regardless of update on blur, change, etc.) I'll close this ticket. The issue should not happen in the latest `@beta`, but if it does, feel free to open a new issue.\n. If you install `react-redux-form@latest`, it _should_ be `0.14.4`, please use that version until `v1.0` is out of beta.\n. Ah, my apologies! So it's always at `npm install react-redux-form@beta`, so it would currently be `v1.0.0-beta.6`.\n. Done!\n. The `combineForms()` reducer creator does not need to be at the root, you just have to specify _where_ it is in relation to the store's state as its model:\n\n``` js\n// ...\n  const reducer = combineReducers({\n    something: anotherReducer,\n    deep: combineForms({\n      foo: { bar: 'baz' },\n    }, 'deep'), // <= specify model path here\n  });\n```\n\nCan you try the above pattern and see if it works for your original use case?\n. ``` js\nconst store = applyMiddleware(thunk)(createStore)(combineForms({\n  something: anotherReducer,\n  notDeep: initial,\n});\n```\n\nAnd the form would be accessible in `store.getState().forms.notDeep.$form`. I'm updating the V1 documentation as we speak so all this (and more) will be in there.\n. Yeah it's tricky because the _point_ of models is to tell React Redux Form \"hey, this is my address, this is where I am in the store's state.\" So the deeper you go, the longer your model names will be. Having React Redux Form search deep through all the objects for the models is prohibitive (performance-wise) and nondeterministic since models, by their nature, have no \"signature\" that tells React Redux Form that it came from a `modelReducer`.\n. V1 is out! Please let me know if the documentation is unclear on this topic.\n. @dsomel21 To colocate the form reducers with existing reducers, use `createForms()`: https://davidkpiano.github.io/react-redux-form/docs/api/createForms.html\n. Can you write a unit test (or two) to demonstrate this use case?\n. @Psykar This looks great, and I'll merge it into `0.14`. If you could also add it to `v1`, that would be great!\n. Which version are you using? Dynamic forms are a new feature in v1.0 (currently in beta).\n. Yeah, I'm still working on the docs. Most things are unchanged from v.0.14 however. There's more info in this issue about dynamic forms: https://github.com/davidkpiano/react-redux-form/issues/243#issuecomment-241548472\n. Thanks for the excellent example; that looks idiomatic and correct! In V1, `forms.sites[0]` would be a form, as would `forms.sites[1]`.\n. Published as `0.14.5`!\n. Fixed! This will go out in the next beta release.\n. Can I see the code for this? It looks like editing the first row also affects the text at the end, which could be inadvertently contributing to the slowness.\n\nExcellent reporting, by the way!\n. I've added some performance enhancements and a stress-test example in this commit: 685c845d4e0d869cce88043c80037be14ee9b0c4 FYI. Omitting `propTypes` from the components when not in `NODE_ENV=production` seems to increase performance.\n\nOther things that can be done:\n- `updateOn=\"blur\"` (of course)\n- `ignore={['focus', 'blur']}` if your app doesn't care about those events\n- keeping `map(rows => ...)` in your form's `this.state`, otherwise, that `rows => ...` function will get called on _every render_.\n. I pulled down the repo and tried to recreate, but it seems to be running at a smooth 60fps for all fields:\n\n![recece](https://cloud.githubusercontent.com/assets/1093738/18226808/b683420e-71df-11e6-9aa1-7a9983282fcf.gif)\n. Okay awesome! Please let me know if there are any other performance regressions. Also, do you mean `v1.0.0` as in directly from the `master` branch?\n. @ozum Can you verify that this issue still exists with the latest RRF? #427 should have addressed this holistically.\n. Closing due to inactivity - this should already be fixed. \ud83d\udc4d \n. Instead of using ``, have a handler on your parent component, such as:\n\n``` js\n// ...\nhandleSubmit() {\n  const { userForm, user } = this.props;\n\n  if (userForm.valid) { // userForm.$form.valid in V1\n    // submit user here\n  } else {\n    // show errors\n  }\n}\n```\n\nand have the `onPress={...}` handler of `` call `handleSubmit`.\n. This is fixed now and will be out in the latest `@beta`. You're correct that `'user.lastName'` should be `'lastName'` as the validator key. Here is the fix:\n\n``` diff\n  if (action.type === actionTypes.SET_FIELDS_VALIDITY) {\n    return map(action.fieldsValidity, (fieldValidity, field) =>\n        fieldActions.setValidity(field, fieldValidity, action.options)\n      ).reduce((accState, subAction) => setValidityActionReducer(\n        accState,\n        subAction,\n-       toPath(subAction.model)), state);\n+       localPath.concat(toPath(subAction.model))), state);\n  }\n```\n\nI'll close this once I have unit tests for it!\n. This makes sense, and all tests pass. Thanks! \ud83c\udf89 \n. Thanks again for the detailed report @ozum! I couldn't reproduce the focus/tabbing problems locally (when I pulled the latest from your branch), but I _did_ discover another weird cursor bug.\n\nAlso, I published the latest `1.0.0-beta.9`, can you do me a huge favor and try with that?\n. Awesome! :tada:\n. Thank you! The `removeKeys` property is internally used by RRF to keep track of which array item is being removed.\n\nWhy? Consider if you have an array of 5 of the same items: `[1, 1, 1, 1, 1]`, and you remove an item: `[1, 1, 1, 1]`. How will you know which item was removed? `removeKeys` is how RRF knows.\n\nSo, is `actions.remove(model, i)` giving you an unexpected result in your model?\n. Which version?\n. Can you provide a minimally reproducible code example on www.esnextb.in? You can use this as a starting point: https://esnextb.in/?gist=f0718614d8353e230daea7c6515470e6\n. Closing due to inactivity, and V1 is out which (more likely than not) resolves this issue.\n. Ah alright. I'll continue to look into it to see if it will become a further issue. Thanks!\n. I can't reproduce this in 0.14.x: https://esnextb.in/?gist=3e82d2400f65c5eaedeb7932f42d7b05\n\nPlease look at the above code and see if it matches your use case. I notice you're chaining `.done` to `dispatch` - are you using any other middleware than `redux-thunk`?\n\nAlso, if you want to post a minimal use-case example in www.esnextb.in, that would be really helpful \ud83d\ude04 \n. I confirmed this is a tiny bug in v1.0, and will have a fix for that. By the way, you can use 1.0@beta in the above code without changing any code.\n. Which version of RRF are you using?\n. Unfortunately, although these warnings are harmless, they're a bit annoying because neither `date` nor `onDateChange` are defined in the _initial_ `` component. However, RRF will clone that component and properly add those missing props, making it work as expected. In production mode, you will not see those warnings.\n\n``` js\n\n // missing date and onDateChange\n\n```\n\nBecause of that, this cannot be fixed in < v0.14.x. This **will be fixed** in v1.0, and already works as expected like this:\n\n``` js\n props.modelValue,\n    onDateChange: (props) => props.onChange,\n    onChange: () => null,\n  }}\n/>\n```\n\nWhich will be simplified to this:\n\n``` js\n\n```\n. Fixed in `1.0.2`! The new code is exactly as above:\n\n``` js\n\n```\n. Yes, there is. Consider a store that looks like this:\n\n``` js\n// combineForms comes form RRF v1\nconst store = createStore(combineForms({\n  children: [],\n});\n```\n\nAnd a very simple function that returns a new child:\n\n``` js\nconst createChild = (name) => ({ name, age: 0 });\n```\n\nThen you can add a child by using `actions.push()`:\n\n``` js\n dispatch(actions.push('children', createChild('bob')))}\n>\n  Add bob\n\n```\n\nAnd you can reference that exact child by name (or other unique ID) by using `track()`:\n\n``` js\n// edit only bob's age\n\n\n\n```\n\nHope that helps!\n. What version of RRF are you using? And can you provide a minimal reproducible code sample here? www.esnextb.in\n\nThe `` component doesn't care at all if the form is touched, and it will successfully submit as long as the form is valid.\n. @shubhi-gupta Closing due to inactivity. Please let me know if you can send me a reproducible code example. Also, please let me know if this happens on the `@beta` if you get the chance.\n. What version are you on? And can you show some example code that reproduces the issue?\n. I believe this was fixed in `0.14.6`: #377 \n\nPlease install `0.14.6` and let me know if the problem persists.\n. I cannot recreate this: https://esnextb.in/?gist=1016badcf892285592b773c3750f2e55\n\nCan you post a code example of your minimal use-case where the issue is happening for you?\n. @shubhi-gupta Closing due to inactivity. Please let me know if you can send me a reproducible code example.\n. Thanks @shubhi-gupta, I will update the version of RRF in the example.\n. @max-mykhailenko \n\n``` js\nconst store = createStore(combineReducers({\n  nav: navReducer, // <== here\n  foo: fooReducer,\n  bar: barReducer,\n  deep: combineForms({\n    user: initialUserState,\n    goat: initialGoatState,\n  }, 'deep'),\n}));\n```\n. @romseguy I can add it to the FAQs - would you mind opening a ticket for tracking that addition to the documentation?. Which version are you using? `combineForms` is on `react-redux-form@beta`.\n. ~~Are you on the latest `@beta`? Should be `1.0.0-beta.11`~~ Actually, just fixed it in 4f7732a !\n. Also, to fix this without updating RRF, you can use ``.\n. ``` js\nimport isValid from './is-valid';\nimport isPending from './is-pending';\nimport isTouched from './is-touched';\nimport isRetouched from './is-retouched';\n```\n\nThe paths are correct (otherwise ESLint or Webpack would have yelled at me), but as a general question, should file names match their exports? E.g.; \n\n``` diff\n- import isTouched from './is-touched';\n+ import isTouched from './isTouched';\n```\n. @vegansk What version does it say that you have?\n. That would make for a good enhancement! I'll add it after releasing V1.\n. To avoid adding too much bloat to the library, I feel that this is better solved in userland. Here's the general strategy:\n1. Upon successful submit, save the current form's value to\n   - internal component state\n   - the Redux store state, using a custom reducer\n2. In the function passed to `onSubmit`, you can check the diff:\n\n``` js\nfunction getDiff(previousValues, currentValues) {\n  // either implement this yourself\n  // or use a library\n}\n\nhandleSubmit(values) {\n  const { lastSubmittedValues = {} } = this.state;\n\n  const diff = getDiff(lastSubmittedValues, values);\n\n  const promise = myAPI.patch('user', diff); // some promise\n\n  this.props.dispatch(actions.submit('user', promise));\n}\n```\n\nThe reason for this is that a proper object/array diffing implementation can be significantly verbose and/or opinionated (think: shallow vs. deep nth-level vs. recursive diffs, array order matters/doesn't matter, etc.).\n. Currently, your store has this shape:\n\n``` js\n{\n  foo,\n  bar: {\n    user,\n    userForm,\n  },\n}\n```\n\nThat means that both the `modelReducer` and `formReducer` for the user are actually at the path `\"bar.user\"`, not `\"user\"`. So you would fix it like so:\n\n``` js\nconst bar = combineReducers({\n  user: modelReducer('bar.user', initialUserState),\n  userForm: formReducer('bar.user', initialUserState),\n})\n```\n\nAnd it should work as expected. If you are using `combineForms`:\n\n``` js\nconst bar = combineForms({\n  user: initialUserState\n}, 'bar');\n```\n\nand you can access your user form from `bar.forms.user`.\n\nLet me know if this helps! \ud83d\ude04 \n. > which is the preferred approach and why?\n\nThe preferred approach is `combineForms()` for a couple of reasons:\n- It's much less code and boilerplate that you have to write! \ud83c\udf89 \n- It's a _very_ thin wrapper on top of `combineReducers()`.\n- It consolidates all your forms into a single `.forms` state, instead of having to define all of your forms reducers.\n- There is the _possibility_ in the future that the API for `combineForms()` might be enhanced in the future to let you pass in options/plugins to the created `formReducer`.\n. Are you running `npm install react-redux-form@beta --save`?\n\nThere is nowhere in the beta that is importing that module.\n. That's weird that that happened. Glad that you can no longer reproduce it!\n. Thanks for pointing that out! I went ahead and removed that plugin.\n. Scroll issue should be fixed now!\n. It's absolutely possible. I'll create a recipe soon. Here's an idea of how you can accomplish that:\n\n``` js\n// ...\nconst createNight = () => ({ foo: '', bar: '', baz: '' });\n\nconst store = createStore(combineForms({\n  builder: { numNights: 1 },\n  nights: [createNight()],\n});\n```\n\n``` js\n// ...\nclass Row extends React.Component {\n  render() {\n    const { model } = this.props;\n\n    return (\n      \n\n\n\n\n    );\n}\n\n// this needs to be connect()-ed\nclass Builder extends React.Component {\n  render() {\n    const { builder } = this.props;\n\n    return (\n      \nNumber of nights?\n\n\n        {Array(builder.numNights).fill(null).map((_, i) =>\n          \n        }\n      \n    );\n  }\n}\n```\n\n(some imports, etc. left out for brevity)\n. They're supported in both `0.14.x` and `1.0` (now out of beta)!\n\nEDIT: if you are using `0.14.x`, note that `` and partial models are only v1.0+, so you'd have to do this:\n\n``` diff\n-\n+\n+  \n+\n```\n\nIt _is_ more verbose, which is why I recommend using v1.0.\n. Keep in mind that the default behavior of an HTML5 `` element is to submit a form: http://w3c.github.io/html-reference/button.html\n\nIn order to prevent this default behavior, you must explicitly state its type:\n\n``` html\n\n  Next Step\n\n```\n. @janhenkgerritsen I found the issue, was able to replicate it in a React Native test project, and went ahead and fixed it. Thanks for the report!\n. Just added the ability in fbe3ee8 to extend existing `mapProps` if you define your control like this:\n\n``` diff\n- (!!props.errors), // any kind of mapProps\n    }}\n/>\n```\n\nOtherwise, you have to explicitly map `{ value: (props) => props.viewValue }` in the props, and here's why (updated the docs with the below answer):\n\n---\n\nOne important thing to keep in mind is that there is no single `value` for a ``; rather, there are two types of values (that are equivalent, more often than not):\n- `modelValue` - the exact value of the model in the store's state\n- `viewValue` - the _displayed_ value of the model in the component's state\n\nFor example, if a text control has `updateOn=\"blur\"`, its `viewValue` will represent what is being typed in the input, whereas the `modelValue` will represent the persisted value, once the input is blurred.\n\nBecause of this, you will want to map the `viewValue` to a custom control's `value` if you wish to externally update the value:\n\n``` jsx\nconst CustomInput = (props) => (\n  \n\n\n);\n\nconst CustomInputControl = (props) => (\n   props.viewValue,\n    }}\n    {...props}\n  />\n);\n```\n\nAlternatively, you can just _assign_ existing mapped props to your custom control:\n\n``` jsx\n// the prop mapping of Control.text is used below:\nconst CustomInputControl = (props) => (\n  \n);\n```\n. What does your `store` look like?\n. ``` js\n// ...\nmyForm: modelReducer('example', {\n// ...\n```\n\nMake sure that the `model`, which is the first argument to `modelReducer`, is the _exact_ path to the model's state in the store. So in the above example, it should be `'myForm'` or whatever you named your model.\n. Sorry about that! The fix will be published in an upcoming patch.\n. Thankfully, this was a simple fix. See a347a18 - this will go out in the next patch.\n. How about a combination of `actions.reset('your.initialModel')` and `actions.load('your.initialModel', newValue)`?\n. On second thought, the above proposal is way too magical. I'd rather the developer have control of the local form and model values:\n\n``` js\n this.handleModelChange(value)}\n  onFormChange={(form) => this.handleFormChange(form)}\n>\n  \n\n```\n\nwhere the developer can set up the handlers:\n\n``` js\nclass MyLocalForm extends Component {\n  handleModelChange(value) {\n    // do anything you want here\n    this.setState({ value: value });\n  }\n  handleFormChange(form) {\n    // do anything you want here\n    this.setState({ form: form });\n  }\n  // ...\n}\n```\n. @cipater That's similar to my original idea:\n\n``` jsx\n      \n\n        // ... etc.\n      \n```\n\nalthough your idea is more explicit in that the developer would provide a `storage` API so that many different storage mechanisms can adapt to the form state updates.\n\nHowever, this poses a couple issues:\n- We're ceding control of the parent component's state to an internal component - huge code smell.\n- A magical \"storage\" adapter is usually more opaque than a higher-order component.\n\nI'd like to consider the general use case though - most of the time, if a developer wants a local form, all they care about is the submit value, so a minimal API would look something like this:\n\n``` jsx\nimport { Form, Control, Errors } from 'react-redux-form/local'; // taking @lasergoat's idea\n\n// in render():\n /* do something */}>\n  \n\nSubmit!\n\n```\n\nAnd if the developer wanted to listen to every single form state update, such as when a field is focused or when a validation error occurs, we can add `onUpdate`:\n\n``` jsx\n /* do something */}>\n  // ...\n\n```\n\nSo, the following props will be added to `` (both local and Redux-specific):\n- `onUpdate={(formValue) => ...}`\n- `onSubmitFailed={(formValue) => ...}`\n- `ignore={/* action event(s) to ignore /*}` such as `['focus', 'blur']` (for performance)\n\nSounds good?\n. > or if those components aren't actually been duplicated internally and react-redux-form/local is just some hand-waving with HOCs and exports, then that seems fine.\n\nYep, that's exactly it!\n\n> Is the only difference that actions isn't passed around on the context whereas ...Storage would be? Or am I missing something else?\n\nThat's a good point, though the difference would not be in `actions.change` vs. `someStorage.change`, it would rather be in `store.dispatch` vs. `someStorage.dispatch` being passed around - that makes the code much more portable and reusable (as there is only one access point) and theoretically we can do some sort of custom storage adapter like you're suggesting.\n\nI'll keep this in mind - there is the definite possibility of RRF being able to be used with other state management libraries besides Redux in the future. We just have to figure out the right abstraction.\n. Basic functionality for `` shipped! https://github.com/davidkpiano/react-redux-form/releases/tag/v1.2.0\n. Sure, I can provide a `mapForms` function (I'm sure there's a better name than `\"mapForms\"`, any suggestions?) that would simply give the object that `combineForms` uses in Redux's `combineReducers()`:\n\n``` js\n// Let's come up with a better name than 'mapForms'\nimport { utils: { mapForms } } from 'react-redux-form';\nimport { createStore, combineReducers } from 'redux';\n\nconst store = createStore(combineReducers({\n  existing: existingReducer,\n  nonForm: nonFormReducer,\n  ...mapForms({\n    user: initialUserState,\n    foo: initialFooState,\n  }),\n});\n```\n\nHow does this look? You'd just use the spread operator to assign the `user`, `foo`, and generated `forms` reducers directly on the object passed into `combineReducers`, so that you can access model values by `user.name` and `foo.name`.\n. > Will the Partial Models with just `.name` work as well?\n\nYes, that's independent of this and will continue to work.\n. Should I call this `createForms({ ... })` instead of `mapForms({ ... })` ?\n. Docs here: https://davidkpiano.github.io/react-redux-form/docs/api/createForms.html\n\n``` js\nimport { combineReducers } from 'redux';\nimport { createForms } from 'react-redux-form';\n\nconst initialUserState = {};\nconst initialGoatState = {};\n\nconst reducer = combineReducers({\n  foo: fooReducer,\n  bar: barReducer,\n  ...createForms({\n    user: initialUserState,\n    goat: initialGoatState,\n  }),\n});\n\n// reducer state shape will be:\n// {\n//   foo: fooReducer,\n//   bar: barReducer,\n//   user: modelReducer('user', initialUserState),\n//   goat: modelReducer('goat', initialGoatState),\n//   forms: formReducer(''),\n// }\n```\n. Yes, that would be a good enhancement and I'm sure it's possible without changing the code too much. It would have to be specified in the third argument (`options`) of `formReducer`:\n\n``` js\n// FUTURE API\nconst userFormReducer = formReducer('user', initialUserState, {lazy: true});\n\n// or in combineForms:\nconst forms = combineForms({\n  user: initialUserState,\n  foo: initialFooState,\n  bar: initialBarState,\n}, '', {lazy: true});\n```\n\nThis behavior wouldn't be on by default because that would be a breaking change - the form state is made available throughout the app initially regardless of if the form was physically created or not, and that state can be important for some use cases.\n\nDoes this `{lazy: true}` option look good to you?\n. @VladShcherbin I'll be working on it this weekend - was prioritizing bug fixes first. However, you can easily create a custom form reducer that does this for you:\n\n``` js\nimport { formReducer } from 'react-redux-form';\n\nconst initialState = { ... }; // initial model state\n\nconst activeFormReducer = formReducer(); // form reducer without state\n\nexport default function myFormReducer(state = null, action) {\n  if (!action.model) return state;\n\n  return activeFormReducer(state || initialState, action);\n}\n```\n\nSomething like that (the above code isn't tested yet, but should work in theory. You might need to tweak a couple things.)\n. That's not possible - `combineReducers` comes from Redux.. Sure thing, I'll work on that.. Ah sorry, you found a typo in the docs! That should be:\n\n``` jsx\nimport { connect } from 'react-redux';\nimport { actions } from 'react-redux-form';\n\n// external user data to load\nconst data = { /* ... */ };\n\nconst InitializeFromStateForm = (props) => {\n  const { dispatch } = this.props;\n\n  return (\n    \n dispatch(actions.load('user', data))}>\n        Load Account\n      \n      {/* ... */}\n    \n  );\n}\n\nexport default connect(null)(InitializeFromStateForm);\n```\n\nwhere `actions.load` is called with two arguments: the `model` and the `data` that represents the value of that model.\n\nFor instance, your data shape can look like this:\n\n``` js\nconst userData = {\n  firstName: 'David',\n  lastName: 'Khourshid',\n  email: '...',\n};\n\n// somewhere dispatchable\ndispatch(actions.load('user', userData));\n\n// loading somewhere deeper\ndispatch(actions.load('foo.bar.deep.user', userData));\n```\n\nDoes this help?\n. Yes, I'll add it to the docs - writing them up now!\n\nBasically, any **field** is directly accessible:\n\n``` js\nforms.product.groupID; // gives you the field for product.groupID\n```\n\nThis is for the common case of when you need to see the field value of an individual field. Any **primitive type** is considered a field, such as a JS string, number, or boolean. This closely represents the possible values that a user can enter into a single form control (you can't really type out an object or an array, haha).\n\nFor more complex values, i.e., arrays and objects, the `$form` property is added to represent _all_ of the fields. It's named `$form` to prevent naming conflicts with any other field names.\n\nSo if you wanted to know the form validity state of the entire `product` form, you would access it via:\n\n``` js\nforms.product.$form.valid;\n```\n\nDoes this make sense?\n. Yep, that's exactly right! This also means that you can have nested forms.\n. If you are using [lodash](lodash.com), you can just use lodash's `get` function:\n\n``` js\nimport get from 'lodash/get';\n\nfunction mapStateToProps(state, ownProps) {\n  const model = ownProps.model;\n  const value = get(state, model);\n  // ...\n}\n```\n\nBut I will make available the internal util functions for getting the model value and the field value. I agree; it would make things more convenient.\n. Sure, I'll add this functionality. It makes sense.\n. > This commit refers only field reducer.\n\nCan you open a new issue if it doesn't work form-wide?\n. @jomasti What's your use case for not wanting to reset it to the initial state?\n. > You click edit, it will go to that same form and use actions.load to set the state for that saved form.\n\nYou can use `actions.change` - the use-case for `actions.load` is two-fold:\n- wanting something to be the _new_ initial state of the model\n- wanting to silently change the model\n\nFor most intents and purposes, `actions.change` will be the action you want to use. That way, you will get your expected behavior of having a blank form upon `actions.reset`.\n. Can I see a reproducible example of the code? Also, are you `connect()`-ing your form?\n. > Is there a need to re-render all fields on focus, blur, and on every model change (even if it's not the current field)?\n\nNo, and it shouldn't. I'll investigate this. I am using `shouldComponentUpdate` in the controls.\n\n@max-mykhailenko Can you provide me a reproducible example, so that I can accurately address the performance issue? Is it just 1300 checkboxes?\n. @Maxim-Chugaev That would be great - I'm putting priority on this issue.\n. Also, using something like [react-virtualized](https://github.com/bvaughn/react-virtualized) in your project might be helpful.\n. @VladShcherbin Are you using the latest version? Also, keep in mind that **Trace React Updates** in the devtools does not _only_ trace renders; it traces whether a component _may_ render (that is, if `shouldComponentUpdate` is called) even if it won't render. https://github.com/facebook/react-devtools#does-trace-react-updates-trace-renders\n\nIf your form is large, ideally you should be using `updateOn=\"blur\"` as well. \n. @MioQuispe By any chance, can I see the code for your form?\n. Performance seems to be significantly improved with #755! \ud83c\udf8a \ud83c\udf89 . Hm, I'm confused - the behavior seems correct. Validators are based on the value that the model is about to become rather than what the model is previously, which would be the value toggled by the radio button. Can you clarify the use-case?\n. I'll actually add this as an enhancement - the way you'd do it currently is by something like:\n\n``` js\nObject.keys(deep.forms.trip).every((key) => {\n  if (key === '$form') return true;\n\n  return // check if pristine here\n}\n```\n\nI'll fix that up real quick so that all you have to do is:\n\n``` js\ndeep.forms.trip.$form.pristine;\n// => returns true if every field inside deep.forms.trip is pristine\n```\n. That is correct. The `dispatch`, etc. props are passed into ``, not the outer `` container.\n. Model arrays are (currently) not supported, though you can always do:\n\n``` js\n{['.foo', '.bar'].map((model) =>\n  \n)}\n```\n\nIs this sufficient? I can _look into_ having `model` accept an array, e.g., `model={['.foo', '.bar']}` but that's a little bit more magical than the above approach with the only advantage being a little less code.\n. I'm going to close this in favor of the above approach - don't want to add _too_ much magic to the API! \ud83d\ude05 \n. @VladShcherbin You can do it like so (when the latest patch goes out):\n\n``` diff\n//...\n  mapProps={{\n    customChange: props => props.change\n+   focus: ({fieldValue}) => fieldValue.focus,\n+   touched: ({fieldValue}) => fieldValue.touched,\n  }}\n// ...\n```\n\nas the `fieldValue` will now be provided to the props passed in to `mapProps`, which contains all of the field props:\n- focus\n- pending\n- pristine\n- submitted\n- submitFailed\n- retouched\n- touched\n- valid\n- validating\n- validated\n- validity\n- errors\n. @erin-doyle This is looking really good; I think the CI failures are mostly due to `eslint` - can you do me a huge favor and run `npm run lint:fix` (which will automatically fix whitespace issues, etc.) and then fix any linting errors?\n. Thanks so much @erin-doyle! \ud83d\udcaf \n. Here you go: http://davidkpiano.github.io/react-redux-form/docs/api/Form.html\n. Thanks @erin-doyle! Also, are you doing https://hacktoberfest.digitalocean.com ? This can definitely count towards that.\n. What does your store/form look like? Can I see some example code so I can get a better idea of what the issue is?\n. This is fixed, and will go out in the next patch today!\n. Not a known issue, it's by design. When you do a change in your `` component, _two_ things happen:\n\n- `actions.change`\n- `actions.setValidity` (assuming `validateOn=\"change\"`)\n\nSince you are _manually_ dispatch `actions.change`, you also need to manually dispatch `actions.setValidity` (or `actions.validate` with the validators).\n\nThe reason for this is because it's possible for validation to occur on something other than change, such as `blur`.. Might be a version 2 feature! (still spec-ing it out). @MrBlenny Should be working on it today; I know what the problem is and will have a fix for it soon.\n. Hey! I think #433 is the same issue (solution inside). You are provided `fieldValue` in your props which you can map in `mapProps` and use to check the validity of the form:\n\n``` jsx\n fieldValue.valid\n  }}\n/>\n\n// in MyInput\nconst MyInput = (props) => (\n  \n  // ...\n);\n```\n. Sorry, this was caused by very strict `shouldComponentUpdate` logic in ``, which was only checking if the `fieldValue` or `formValue` (derived props) changed. I've set it to just do a simple `shallowEqual` on the props, which should catch that the `show=\"...\"` has changed.\n\nIn the future (a minor release), if you want to tweak performance, you will be able to do so like this:\n\n``` jsx\n// Only update for derived (Redux) props\n\n\n// Use shallowEqual to compare ALL props\n// This is the default.\n\n\n// Only update for derived props and these props which\n// you specify are expected to change.\n// e.g., this tells Errors \"expect the 'show' prop to change\"\n\n```\n. @erin-doyle I just merged #443, can you merge `master` into this branch? \ud83d\ude4f \n. Merged #447 which fixes this! Thanks!\n. Ah, that's because you're rendering a simple `` element with no handlers! Make sure to explicitly pass the mapped props onto your custom element:\n\n``` diff\n-const Custom = () => ;\n+const Custom = (props) => ;\n```\n\nAnd then it will work. \ud83d\udc4d \n. One way to do it would be to pass callbacks to your `subscribeUser` function:\n\n``` js\nexport function subscribeUser(data, callback, errCallback) {\n\n  // ...\n  .then(res => {\n    dispatch(...);\n    callback && callback(res);\n  })\n  .catch(err => {\n    dispatch(...);\n    errCallback && errCallback(err);\n  });\n}\n```\n\nAnd then calling it like so:\n\n``` js\nclass myForm extends React.Component {\n  handleSubmit(data) {\n    const { dispatch } = this.props;\n\n    const promise = new Promise((resolve, reject) => {\n      dispatch(subscribeUser(data,\n        res => resolve(),\n        err => reject(err)\n      ));\n    });\n\n    dispatch(actions.submit(promise));\n  }\n}\n```\n\nThere might be a cleaner way to do this but this is the first thing that I thought of.\n. @amyiee Yes - [redux-thunk](https://github.com/gaearon/redux-thunk) should do the trick.. > But the form variable passed into the show function is not the form state of the model in question \"signup\" in my example, but is a generic form with model=\"forms\" rather than the expected model=\"forms.signup\".\n\n@KevinBrolly This is probably be fixed with #455. When I release a patch soon (`1.0.9`), can you verify?\n. > How can I get the fields to contain the correct value for \"submitFailed\"?\n\nWould you mind filing a separate issue for this, for tracking purposes? This is a bug that I can quickly fix.\n. I'd love for someone to take the reins on that; I am not familiar with TypeScript (yet) and don't have the time to work on it - I'm more focused on the core functionality of React Redux Form.\n\nMaybe submit a PR with the updated definitions for https://hacktoberfest.digitalocean.com/ ? \ud83d\ude04 \n. @MiMaMuh I cannot reproduce this in the latest RRF version, thankfully. My guess is that it was fixed as a side effect of #440.\n. @MiMaMuh Can you please make a reproducible example? I've done that and still can't reproduce it. Here's a boilerplate: https://esnextb.in/?gist=b31277251f5c24df9b13b2cc95abc00c\n. @MiMaMuh Fixed now! Sorry, here was the issue:\n\n``` diff\n      if ((validators || errors)\n        && fieldValue\n        && !fieldValue.validated\n-       && validateOn === 'change'\n+       && containsEvent(validateOn, 'change')\n      ) {\n        this.validate();\n      }\n```\n. @zach-waggoner I think this is an issue with the internal `getFormStateKey` that returns the FIRST parent form that contains the nested form, instead of the actual nested form itself. Will fix today.\n. Thanks @BrianDGLS! Can you merge master into this real quick? Fixed some lint issues.\n. It might be a bug that `defaultValue` does not initially load the value, though ideally you would have this default value as part of the initial state in your model reducer (or in `combineForms`). RRF does not assume that the first `` is the default value, and I don't believe the W3 spec does either - it assumes that `` is the default. Ideally, you'd have a select that looks like this:\n\n``` html\n\nChoose here\nOne\nTwo\nThree\nFour\nFive\n\n```\n\nSo I'll check on two things:\n- [x] `defaultValue` works as expected (though this should be avoided)\n- [x] `` explicitly specified works as expected _as the default value_\n  - having an initial value for the select's model in the store would override this\n. @ramiel Yes, setting `` will work. Remember that setting it to a static value doesn't allow it to be changed, however (in anything, not just RRF. That's how React works, see controlled components).\n. @ramiel \n\n``` jsx\n...\n```\n\nThe above code, as-is, will never allow the value of `.name` to be changed. See here: https://facebook.github.io/react/docs/forms.html#controlled-components\n. Yes, `defaultValue` works.\n. @ramiel Can you open a separate ticket for that?\n. In the example code for the repo:\n\n``` js\nimport { actions } from 'react-redux-form';\n\n// Assuming your form/app/etc. is connected:\n\n// ...\n  takePicture() {\n    const { dispatch } = this.props;\n\n    this.camera.capture()\n      .then((data) => dispatch(actions.change('user.photo', data)))\n      .catch(err => console.error(err));\n  }\n```\n. Can you copy-paste the code that fully reproduces the issue?\n. You have to `dispatch` the `actions.push()` action:\n\n``` diff\nthis.camera.capture()\n      .then(data => {\n        const fileName = `${Date.now()}.jpg`;\n        const fileData = { uri: data.path, name: fileName, type: 'multipart/form-data' };\n-       actions.push('forms.createListing.photos', fileData);\n+       dispatch(actions.push('forms.createListing.photos', fileData));\n      })\n      .catch(err => console.error(err));\n```\n. I've been using it with redux-saga in a production app - all you have to do is include the `thunk` middleware before passing the action onto redux-saga:\n\n``` js\n// ...\nimport thunk from 'redux-thunk';\nimport createSagaMiddleware from 'redux-saga';\n// ...\n\nconst sagaMiddleware = createSagaMiddleware();\n\nconst store = createStore(combineForms({\n  // ...\n}, applyMiddleware(sagaMiddleware, thunk));\n```\n\nDoes that work with your use case?\n. I think this would be best as a separate package, like `rrf-saga` or something like that. My thinking is that RRF tries to serve as the lowest common denominator for most React + Redux projects, and I don't want to add extra compatibility integrations such as for redux-saga, redux-observable, etc. etc. because that is beyond the scope of this package.\n\nI'm also planning on removing the requirement for `redux-thunk` by refactoring many of the actions used internally by components such as ``, ``, etc. My original plan was to \"require\" `redux-thunk` only as a convenience for directly dispatching the actions yourself.\n\nAs for right now, I'd strongly recommend using both `redux-thunk` and `redux-saga` as they are both middlewares, and redux idiomatically allows multiple middlewares. The usage of `redux-thunk` should just be considered an implementation detail.\n. Thanks! One question - is the use of `redux-immutable` assumed/required by developers using `Immutable.JS` with this?\n. Gotcha, sounds good. By the way, I gave you collaborator access in case you ever need to make quick patches. Thanks so much for all your hard work on this!\n. @jomasti @cesarp What version of RRF are you on?\n. Try in 1.0.13 once I make the patch!\n. @cesarp \n\n> I am having a similar issue, if I add `mapProps` then my custom component never dispatches a change.\n\nCan you share your custom component's code? This sounds like a separate issue.\n. Fixed! This will go out in the next patch.\n. Thanks! Would you mind fixing the lint errors? (run `npm run lint` to see them) It's just missing a trailing comma.\n. Fixed by deleting that page. Here's the most up-to-date comparison: http://davidkpiano.github.io/react-redux-form/docs/guides/compare-redux-form.html\n. This is a known issue - will resolve it by tomorrow!\n. >  will resolve it by tomorrow!\n\nBy tomorrow I mean as soon as I can; currently at a conference! \ud83d\ude04 \n. @cyberwombat \n\n> TypeError: undefined is not an object (evaluating 'form.$form.model')\n\nThe default base path for `createForms` is under `'forms'`, not `'form'`. Maybe that's the issue?\n. @cyberwombat Thanks for checking! I'll close this and we can revisit it _if_ the issue reappears with immutable forms. I'm fairly certain it should be fixed, though.\n. Do you have [redux-logger](https://github.com/evgenyrodionov/redux-logger)? It might come in handy.\n\nHow are you defining your state? If it's something like this:\n\n``` js\nconst store = createStore(combineForms({\n  foo: initialFoo,\n});\n```\n\nthen you can access the forms from your state like so:\n\n``` js\nclass FooForm extends Component { ... }\n\nconst mapStateToProps = (state) =({\n  fooForm: state.forms.foo\n});\n\nexport default connect(mapStateToProps)(FooForm);\n```\n\nAnd then in your component:\n\n``` js\nrender() {\n  const { fooForm } = this.props;\n\n  if (fooForm.$form.pending) {\n    return Loading...\n  }\n\n  // etc.\n}\n```\n. Thanks!\n. Yes, if you're going to use `modelReducer` and `formReducer` directly, I recommend this pattern:\n\n``` js\ncreateStore(combineReducers({\n  login: modelReducer('login', initialState),\n  loginForm: formReducer('login', initialState),\n}, ...);\n```\n\nLet me know if this resolves your issue.\n. Can you post the full code example that reproduces the issue?\n. What does your store look like? It could be that the initial value of your model is `undefined`.\n. This looks invalid:\n\n``` js\n   model={track(`options[].enabled`, {id:   option.id}), 'enabled')}\n```\n\nBut besides that, is the component working? Since your model value is `undefined`, it's going to be passed `undefined` as the second argument to the change action, but for a checkbox, that shouldn't matter - it's falsey so `actions.toggle` will just set the model to `true`.\n. This is because you are passing in all the props here:\n\n``` jsx\n\n```\n\nTry to pass in only the props you need into that component, such as `onChange={props.onChange}`. You can also use Lodash's `omit` or `pluck` functions to help you out in whitelisting/blacklisting props.\n\nI'd recommend against blindly passing in all the props - that is, avoid this pattern: ``.\n. Try this pattern:\n\n``` js\n\n{(fieldValue) => }\n\n```\n. Oh, sorry - that is just a placeholder for you to do whatever you want with the `fieldValue`, such as...\n\n``` jsx\n\n{(fieldValue) => }\n\n```\n\netc.\n. Can you post what you currently have in www.esnextb.in ?\n. Awesome! Would love if you could share your solution here for others to see.\n. I just added a missing dependency, can you merge master into this branch real quick?\n. Thanks very much!!\n. You're missing `initialMember`:\n\n``` js\nconst initialMember = {\n  firstName: '',\n  lastName: ''\n};\n\nconst initialState = { \n  members: [initialMember]\n};\n```\n\nShould work after that \ud83d\udc4d \n. Fixed in #482 as well\n. If you're only passing in one child, this sounds like the perfect use case for ``. Have you tried using that?\n. Anyway, this is fixed, and now behaves just as you described:\n\n``` js\n\n\n\n```\n\nThis will **throw** if there is more than one child.\n. @ramiel I cannot reproduce this issue (at least if I understand correctly).\n\n``` jsx\n        \nPlease choose an option\nFoo!\nBar!\n\n```\n\nThe above code will set both the control's view value to `\"foo\"` and the model in the Redux store to `user.choice = \"foo\"`. Is that what you are expecting?\n. Closing this due to inactivity.\n. @iBasit Can you create a reproducible example?. If you know the probable fix, feel free to open a PR. I can't guarantee when I will be able to have the time to investigate or fix this, but I can guarantee that all good PRs will be merged and released promptly.. Huge thanks for your help on this! I'll eventually dive into TypeScript, I promise \ud83d\ude1d \n. I see a mismatch between the models in dispatching submit here:\n\n``` js\ndispatch(actions.submit('subscriber', subscribeUser))\n```\n\nand here:\n\n``` jsx\n\n        // ...\n      \n    );\n  }\n}\n```\n\nNotice how the `` or `` components with models that _do not exist on the store_, then they will only be instantiated on load if there is a `defaultValue` on the field.\n\nOtherwise, RRF will be **lazy** and not create the field until it is interacted with.\n\nMy recommendation would be to define `model.someFields = []` in your store (in `combineForms()`, etc.). Let me know if this works with your use case.\n. Can you show me a code example where it's not giving you the expected result?\n. If you want to set a flag, then your hobby shouldn't be a plain string, right? It should be an object containing the hobby's value and a `show` flag, like:\n\n``` js\nhobbies[0] = {\n  name: 'windsurfing',\n  show: false\n}\n```\n\nAnd then you can just use that flag like so:\n\n``` js\n{member.hobbies.map((hobby, j) =>\n  \n    {hobby.show && }\n    // etc.\n  \n)}\n```\n\nHope that helps! If you want to show based on other hobbies, you have full access to the hobbies from the Redux store, so just access them like you would access anything else in Redux to conditionally show other hobbies. Nothing magical there.\n. Right. Ideally you shouldn't be nesting forms, whether it's `` or ``. There's a few workarounds:\n- If you want a \"form\" inside a form that doesn't submit, you can set ``\n- Also, you can set `` (not documented yet)\n- If you _do_ want a \"form\" inside a form that does submit, you'll have to submit manually by using `actions.validSubmit(model, promise)`.\n. Fix published as `1.0.14`\n. Are you importing from `react-redux-form/immutable` ?\n. Docs here! http://davidkpiano.github.io/react-redux-form/docs/guides/immutable.html\n. @MixKCet Seems similar to these issues:\n\nhttps://github.com/facebook/react/issues/7781\nhttps://github.com/facebook/react/issues/7253\nhttps://github.com/facebook/react/pull/7359\n\nSo this is unrelated to RRF, but a current issue with React itself.\n\nHere's a simple workaround:\n\n``` jsx\n        \n```\n\nThe above makes the control _uncontrolled_, so it can't be remotely updated, but it also avoids the React issues.\n. Can I see your store code?\n. Can you try this again in the latest version?\n. Closing due to inactivity. I'm fairly certain that many similar issues were fixed around this in the latest versions since 1.0.13, but if it comes up again, I'll reopen.\n. Haha, sure why not! \ud83d\ude1d \n. Sounds good; I'll continue to investigate this.\n\nBasically, when you do `createForms` or `combineForms`, it creates a \"universal\" form reducer that can accommodate all forms.\n. @MrBlenny Can you do two things:\n- Upgrade to the latest patch version of RRF (`1.0.14`)\n- Share your code, if possible?\n\nAt the very least, I'd like to see how your store code is structured.\n. > There is probably no easy fix.\n\nYou're probably right, but I can still try to make it easier for developers. How does this look?\n\n``` jsx\n\n  // ...\n\n```\n\nwhere `theFormState` is the path to the form state. This will allow you, the developer, to tell RRF \"don't bother looking for the form, I already know where it is\" as an enhancement, e.g.:\n\n``` js\nrender() {\n  const { userForm } = this.props; // retrieved from mapStateToProps\n\n  return (\n    \n    // ...\n    \n  );\n}\n```\n\nWould this help, in terms of avoiding calls to `getForm`?\n. I'm not sure of the API for this yet. I'm evaluating if it's redundant with ``.\n. Closing this, as `get-form` has since been completely reimplemented and improved. If this is still a problem, feel free to open a separate issue.. Here's the issue:\n\n``` jsx\n\n```\n\nThe model here is `account.firstName`, however, in the store you defined:\n\n``` js\n\nconst forms = combineForms({\n  account: initialAccountState,\n});\n\nexport default combineReducers({\n  routing: routerReducer,\n  forms,\n});\n```\n\nthat model would actually live under `forms.account.firstName`.\n\nSo here's the fix:\n\n``` diff\n-\n+\n```\n\nHope this helps!\n. Hmm, would you mind opening that up in a separate issue for tracking purposes?\n. @torifat Can you please upgrade to the latest `1.0.15` and let me know if you still get this issue? I strongly believe this was already fixed in a previous patch.\n. Can I see the code that is producing this error?\n. I'm going to need more info to accurately reproduce this - I can't figure out what your code is by just looking at the stack trace \ud83d\ude06 \n. Sounds good, thank you!\n. Can you open a new one with a repro (codepen or codesandbox)?. Right, you have to add it yourself. It is optional, and many developers might not want to use `novalidate`, in order to show errors using the DOM API.\n. Fixed in the docs!\n. Thanks for the report!\n. Are you using React Router? Wherever you would define a hook for navigating out, you can just `dispatch(actions.reset('your.model'))`.\n\nAlso, #420 should solve this naturally when implemented.\n. #420 has shipped: https://github.com/davidkpiano/react-redux-form/releases/tag/v1.2.0 let me know if it works for your use case!\n. I've thought about this a little and figured it's best not to add any extra API for something that's already handled naturally in `mapProps`:\n\n``` jsx\n fieldValue.focus\n      ? 'focused'\n      : ''\n  }}\n/>\n```\n\nThe above is more flexible and will work as expected \ud83d\ude04 \n. Currently, you can only do something like this:\n\n``` jsx\nconst required = (val) => !!val;\n\n numbers.every(required) }\n  }}\n>\n// ... etc.\n```\n\nThe above is not exactly a workaround, just a way to tell the user that they forgot to fill out one of the many phone numbers they have. That's why I'm marking this as an enhancement; ideally you should be able to do this:\n\n``` jsx\nconst required = (val) => !!val;\n\n\n// ... etc.\n```\n\nFor a _real_ workaround, you can always attach `validators={{...}}` to the actual ``.\n. Oops, try `react-redux-form/lib/immutable` instead.\n. Updated in the docs: http://davidkpiano.github.io/react-redux-form/docs/guides/immutable.html\n\n\n. @Neophy7e Now, `import { ... } from 'react-redux-form/immutable'` will work in the next release.\n. @gocamille Yes, these should be under `react-redux-form@1.2.3`. Try clearing your npm cache or `rm -rf node_modules` if you are not able to see the changes.\n. I'm pretty sure the check I added in 7efde9f will fix the issue, can you check when the next release goes out?\n. Hmm, try again?\n\n\n. Paging @erin-doyle - she would know the answer to that \ud83d\ude04 I believe it _is_ supposed to work with `redux-immutablejs`.\n. If you'd like to help out with PRs, I'd gladly get them merged in ASAP. The solution to fixing this is two-fold, so for example:\n\nIn `get-field-from-state.js`:\n\n``` diff\n-const formPath = toPath(form.$form.model);\n+const formPath = toPath(s.get(form, ['$form', 'model']));\n```\n\nAnd then in `src/immutable.js`:\n\n``` diff\nfunction immutableGetFieldFromState(state, modelString) {\n-  return getField(state, modelString, { getForm: immutableGetForm });\n+  return getField(state, modelString, { getForm: immutableGetForm, get: immutableGetFromState });\n}\n```\n\nShould be simple fixes, and since you can recreate the errors, you (or someone who uses Immutable.JS) would be best to diagnose them. \ud83d\ude4f \n\nPersonally, I do _not_ use Immutable.JS (I use icepick.js so that I can work with standard JS types).\n. ![nov-03-2016 13-15-28](https://cloud.githubusercontent.com/assets/1093738/19976825/a9cb2028-a1c7-11e6-9ee3-2eaa4e137976.gif)\n\nThe code as-is works just fine for me (see above).\n\nBut you can also try removing the `value` prop in your checkboxes.\n. > So beginners error. I read the documentation again, and its not 100% clear that the naming changes when you nest combineForms in the state. But maybe i just didn't read it well enough.. :)\n\nI'll try to make this clearer! Think of `combineForms` as expanding to an object. So in theory, you'd end up with something like:\n\n```\n{\n  form: {\n    foo: ...\n    bar: ...\n  }\n}\n```\n\nAnd then your models would be `form.foo` and `form.bar`, respectively.\n. > I guess i just thought i had to omit the part of the path above the combineForms..\n\nYes, that's right but your syntax is a bit off. `combineForms` (like `combineReducers`) returns a `reducer` function, so you want this:\n\n``` js\nconst store = createStore(combineForms({\n  ...\n}));\n```\n. Yep, working on it! The latest `1.2.2` has it removed _for the most part_. I just have to make a note in the docs for all the (optional) actions that do depend on it, such as `actions.filter`, `actions.submit`, etc.\n. Yes, but they're entirely optional to use. Just helper actions.\n. Good point - I was meaning to make this enhancement a while ago, where `actions.submit` should take a callback instead of a promise.\n\n> Also, would it be possible to make the return type of actions.submit one type?\n\nSure, would it make sense for `actions.submit()` to return a promise?\n\nWhat does your ideal code look like for this? Can you post an example?\n. @fingermark Any updates on this?\n. Closing due to inactivity.. Thank you!\n. You can use the `onUpdate={(formValue) => ...}` prop on the `` element, does that help?\n. Also, yes, you can pass in a function-as-children to `` to achieve the same result. See the documentation here for more information on the `onUpdate={...}` prop: http://davidkpiano.github.io/react-redux-form/docs/api/Form.html\n. Does the state arrive asynchronously? That is, when the component is first rendered, could `this.state.patient` be undefined (because it is waiting for an AJAX call, etc.)?\n. Sorry, I can't replicate the issue. Make sure you have the latest version of RRF. The below minimally reproducible use case works as expected:\n\n``` js\nclass App extends React.Component {\n  constructor() {\n    super();\n\n    this.state = { patient: { name: 'bob' } };\n  }\n  render() {\n    return (\n      \n\n\n    );\n  }\n}\n```\n\nPlease compare your code to the above and verify that the input does in fact have `\"bob\"` as the initial state.\n. 1. Have a root form reducer:\n\n``` js\nconst store = createStore(combineReducers({\n  forms: formReducer('forms', {\n    dynamic: {},\n  }),\n});\n\n// alternatively...\nconst store = createStore(combineForms({ dynamic: {} }));\n```\n\n\\2. Now, all forms, dynamic or otherwise, can live under this single `forms` form reducer. So if you dynamically create:\n\n``` jsx\n\n...\n\n```\n\nthen the form state will be created for you under:\n\n``` js\nstore.getState().dynamic.completelyNew;\n```\n\nOr if you `connect()`, just `this.props.dynamic.completelyNew`, of course.\n\nHope that helps!\n. Can you post the link to your modified codepen?\n. I updated my answer above: https://github.com/davidkpiano/react-redux-form/issues/525#issuecomment-259126628\n\nLong story short, it doesn't work if you are missing a model reducer. So you can still do dynamic forms, it just needs to be based on an existing model reducer:\n\n``` js\nconst store = createStore(combineReducers({\n  forms: formReducer('forms', {\n    dynamic: {},\n  }),\n});\n\n// alternatively...\nconst store = createStore(combineForms({ dynamic: {} }));\n```\n\nHopefully that makes sense. **Always have at least one model reducer**.\n. @lnhrdt Can I see your code please? You do _not_ have to declare each form in advance - it can work dynamically.. Try this:\n\n```js\nconst store = createStore(combineForms({\n  dynamic: {}\n});\n```\n\nIdeally, you should never need to use `formReducer` directly.. See here: http://davidkpiano.github.io/react-redux-form/docs/api/createForms.html. > why would my form revert to submitted: false when the user clicks again?\n\nIs there validation on the form?\n. >  What is the reasoning behind requiring a boolean true as opposed to a successful resolve?\n\nIt's initially to set validity but I feel we can get rid of that. I see no use cases for automatically setting validity after a successful promise.\n. > it seems to create a new state object rather than map to my existing reducer store\n\nWhat is your desired store shape?\n. @tiagoefmoraes Fix looks good to me! I can refactor later. Mind making a PR?\n. Huge thanks!\n. > Right now I use redux to toggle some fields based on the status of some radios. \n\nWhat do you mean by toggle? Do you mean that the radio button is toggling some other radio buttons?\n\nIf so, that's a good use-case for a custom reducer. Here's an example:\n\n``` js\nimport { actionTypes } from 'react-redux-form';\n\nfunction toggleReducer(state, action) {\n  if (action.type === actionTypes.CHANGE) {\n    if (action.model === 'toggle.foo') {\n      // toggle.bar and toggle.baz will have the\n      // same value as toggle.foo\n      return {\n        ...state,\n        bar: action.value,\n        baz: action.value,\n      };\n    }\n  }\n\n  return state;\n}\n```\n\nAnd then you can just have that be a modeled reducer:\n\n``` js\nconst store = createStore(combineForms({\n  toggle: toggleReducer,\n}), applyMiddleware(...));\n```\n. Thank you! The error is mine - can you please merge/rebase master into your branch again?\n. Merged! Thank you so much!\n. ``` js\nthis.props.validate();\n```\n\nWhat does this method look like?\n. So the issue here is that you are manually validating the model every time your component receives props, whether the model has changed or not. The standard usage of `` internally has optimizations on when it validates, so that it avoids validating:\n- when the model value hasn't changed\n- when the validity hasn't changed\n\nI would recommend leaving validation to the `` component, or figure out where in your custom code it is creating an infinite loop. I would investigate why the value is infinitely changing, even at times where it should be the same. Perhaps do a `shallowEqual` instead?\n\nSo long story short, avoid handling validation in `componentWillReceiveProps` or `componentWillUpdate` or `componentDidUpdate`, etc.\n. Weird... I'll update lodash and see if I can reproduce it.\n. For now, I replaced `lodash/omit` with a simpler internal implementation.\n. Over here is the problem:\n\n``` js\nactions.submit('register', somePromise)\n```\n\nThe `actions.submit` is an action _thunk_ creator, and it requires `redux-thunk`. With that said, it's easy to recreate this action so that it is suitable for `redux-saga`. This is the core of the action:\n\n``` js\nconst submit = (model, promise) => (dispatch) => {\n  dispatch(actions.setPending(model, true));\n\n  promise.then(response => {\n    dispatch(actions.setSubmitted(model, true));\n  }).catch(error => {\n    dispatch(actions.setSubmitFailed(model));\n  });\n};\n```\n\nThe extra code and code related to validity is removed for clarity. Feel free to use the above as a template for handling submit logic yourself inside a saga.\n. Sorry about that! Published.\n. What does the code for your `` look like?\n. Thanks! I probably need to see the code for `` to further diagnose what's going on.\n. @gocamille I created a simple reproduction that is very close to your use-case, and this seems to work just fine, without issues:\n\n```jsx\nclass App extends React.Component {\n  handleSubmit() {\n    alert('Submitted successfully!');\n  }\n\n  render() {\n    return (\n      \n\n v && !!~v.indexOf('@'),\n            }}\n          />\n          \n\n\n v && v.length > 2,\n            }}\n          />\n          \n\n\nSubmit\n\n\n    );\n  }\n}\n```\n\nCan you please compare your code to what's above? I'm guessing there is an extraneous issue.. Closing due to inactivity - if you are able to provide a fully reproducible code example (similar to above), I will reopen this. Sorry! \ud83d\ude1e \n\nAlso, please recheck with the latest 1.4.x version.. The easiest way to do this right now is to add an `onClick` event handler to each of your buttons that changes the model before it is submitted:\n\n``` jsx\n\n dispatch(actions.change('user.clicked', 'foo'))}>\n    Submit Foo\n  \n dispatch(actions.change('user.clicked', 'bar'))}>\n    Submit Bar\n  \n\n```\n\nNow, when your form is submitted, you can just reference the `'user.clicked'` (feel free to rename) model to see what was clicked to submit the form.\n\nThis is very similar to what you would do with vanilla JS/HTML: http://stackoverflow.com/questions/547821/two-submit-buttons-in-one-form\n\nWhat did you have in mind?\n. Also, I'm going to keep this up as an enhancement, because I'd like to add two new `` components:\n- `` for ``\n- `` for ``\n\nAnd then you can just do the above like:\n\n``` jsx\n\nSubmit Foo\nSubmit Bar\n\n```\n. Hey @dave-clover, hope you don't mind but I went ahead and added the `onSubmitFailed` prop. Here's the docs on it: http://davidkpiano.github.io/react-redux-form/docs/api/Form.html#onsubmitfailed. I'll be adding this to the documentation soon (well, after the holidays)!. Sure, no problem. I'll do that today. For now, I'll answer your questions directly:\n\n> So, `rrf.user` is a model, which values are updated when the form inputs are updated. `rrf.forms.user` is the created form with this model and `rrf.forms.user.$form` object has the form state (errors, etc).\n\nThis is correct.\n\n> If this is correct, why aren't the values in `rrf.forms.user.$form.value` changed on field change?\n\nThey should be - I'll fix this.\n\n> What is the purpose of `rrf.forms.$form`, what are the values `focus, pending`, etc inside of it for? \n\nThe `forms.$form` indicates the _entire form state_, so `focus` would represent if any field in the form is focused, same with `pending`, `touched`, etc.. > is it the state of all forms or just unused props?\n\nThey reflect the state of all fields from this form, and the form itself.. Thank you!\n. Added here: e14782e8a348e8c8fe559cec8e92674f4648dd31 thanks!. The issue is here:\n\n```\ncomponent={(props)=> }\n```\n\nBlindly passing props is usually a recipe for disaster. Instead, try this:\n\n``` jsx\n\n```\n\nHope that helps!\n. Thank you!. Validation across fields being a concern of a parent node solves the problem, \"where will the validation live?\" For example, if the birthdate is invalid (e.g., `oldEnough: false`), where will that `oldEnough` validation state live? On the day, month, year fields? On all three?\n\nThe simplest answer is at a parent node. I recommend having a data structure like this:\n```\n\"user\": {\n  \"birth\": {\n    \"day\": 31,\n    \"month\": 7,\n    \"year\": 1990,\n  },\n  // ... etc.\n}\n```\n\nAnd that way, you can make a sub-form like this:\n\n```jsx\nimport { Form, Control } from 'react-redux-form';\n\nconst isOver18 = (day, month, year) => { ... };\n\nconst BirthDate = ({forModel}) => (\n   isOver18(day, month, year),\n    }}\n  >\n    \n\n\n \n);\n\nexport default BirthDate;\n```\n\nand use it anywhere like this:\n\n```jsx\nimport BirthDate from './path/to/BirthDate';\n\n// in existing form\n\n\n\n\nSubmit!\n\n```\n\nAlternatively, you can just have a custom component that renders all 3 fields as one single value, and then validate it just as you would validate any other individual field.\n\nDoes that solve your use-case?. Ah, unfortunately I overlooked that. At the moment, resolving models is not supported for ``, since it is assumed that the `` is the top-level. The solution to this will probably come in a later version, when `` is finalized (which acts like a form, but without submit/etc.)\n\nFor now, I updated my answer above. You can create a higher-ordered component:\n\n```jsx\nconst BirthDate = ({forModel}) => (\n  ` as ``. It's a _tiny_ bit more verbose, but at least you're using vanilla React to get to your solution rather than an abstraction.. **Update**: As of 1.4.1 you can now use `` which is a much nicer solution to this. Read the docs here: https://davidkpiano.github.io/react-redux-form/docs/api/Fieldset.html. What is the expected result? That the field state is not touched?. For anything beyond basic form functionality, you'll probably want to just use a normal ``. However, if you want to do custom dispatching to a ``, that is still possible if you **create your own store**:\n\n```jsx\nimport { createStore } from 'redux';\nimport { LocalForm, combineForms } from 'react-redux-form';\n\nconst localStore = createStore(combineForms({ ... }));\n\n// then, in your LocalForm:\n\n  // ...\n\n\n// you can then dispatch to the localStore:\nlocalStore.dispatch(someAction);\n```\n\nI haven't tried this yet, but it should work in theory. Can you try it out and see if it works for your use case?. Actually, the `getDispatch` prop solves this much more nicely as of the latest version (1.4.1):\n\n```jsx\n this.formDispatch = dispatch}\n>\n// etc.\n\n```. Thanks, @touqeerkhan11! \ud83d\ude04 \n\nFor the first part, make sure you're dispatching the action:\n\n```jsx\n dispatch(actions.reset('comment'))}\n>\n```\n\nFor your second question, do you have a custom component that's handling an \"un-erasable\" part of the input?. Closing due to inactivity, hope I answered your question!. Thanks, @bgriffith! This has been fixed and will appear in the next patch today.. Almost! I'm doing quick tests today and tomorrow and removing it internally, and then I'll remove the peer dependency when it's 100% ready to be removed. Stay tuned!. Not deliberate, although according to the W3 spec, the default type for `` without a `type=\"...\"` attribute is `\"text\"`. I went ahead and made it explicit though, and it should go out in the next release!. You're welcome! This will go out tomorrow. If you need it today, you can add it manually:\n\n```jsx\n\n```. @sl33kr I am new to TypeScript (though I'm working on adding more strict TypeScript typings to RRF in future versions). Can you show me the code that doesn't work with the current typings?. cc. @tiagoefmoraes @zach-waggoner would any of you know how to remedy this?. Really excellent issue description, thanks so much! Looking into this now.. Hey @bgriffith, that might be a bug - I'll investigate and fix it. In any case, the implementation is small for binding to React Native components:\n\n```jsx\nControl.TextInput = (props) => (\n   onFocus,\n      value: (_props) => ((!_props.defaultValue && !_props.hasOwnProperty('value'))\n        ? getTextValue(_props.viewValue)\n        : _props.value),\n      onChangeText: ({ onChange }) => onChange,\n      onChange: noop,\n      onBlur: ({ onBlur, viewValue }) => () => onBlur(viewValue),\n      onFocus: ({ onFocus }) => onFocus,\n    }}\n    {...props}\n  />\n);\n```\n\nso if you'd like to figure out what's missing, perhaps you can make a quick PR and I can add it in. Also, I believe that for now, this will work:\n\n```jsx\n console.log(input)}} />\n```\n\nbut ideally it should work the way you have it.. Since React doesn't support propagating the `ref` prop through wrapped components (for whatever reason...), I think the solution is for me to add `getRef={(node) => ...}` to the API.\n\nDoes the name `getRef` sound intuitive enough? Or should I name it something different, like `controlRef`? It just can't be named `ref`.. Okay, done! Published as 1.3.2. . Done! Published as 1.3.2\n. Can I see the failing code? At the very least, I'd like to make error messages clear :). Can I see the code for the custom changed field/control?. > If they are not supposed to be used with Field I have to change the typings and the documentation should be updated.\n\nThey can be - they'll just be passed to the underlying created ``. I'll remedy that in a separate update.\n\nThank you for doing this!. Thinking about an API for this... The tricky part is that we need to have a declarative approach for this, not an imperative one. \"Reaching inside\" a component to do something imperatively is definitely an anti-pattern, so I don't want to attach ad-hoc instance methods or anything silly like that.\n\nHow about something like this?\n\n```jsx\n this.formDispatch = dispatch}>\n  // ...\n\n```\n\nwhere `getDispatch` is basically like `getRef` - it runs once, on `componentWillMount`.\n\nThen, in your parent component, you can just call:\n\n```js\nhandleReset() {\n  this.formDispatch(actions.reset('local')); // or whatever model you gave to \n}\n```\n\nDoes this sound like a good solution?\n\n**N.B.** The reason I'm _okay_ with this approach is, if we think about this in a functional reactive sense, a `LocalForm` is not just an `Observable` but also a `PublishSubject` (or just a `Subject`, or `Producer`), so we can send actions to it and also observe form state changes. (talking in terms of RxJS, if you're familiar).. In the short term, I can actually see `resetOnSubmit` being a useful property - its use-case is common enough to warrant it being a standalone prop.. Actually, I'm going to go forward with `getDispatcher` because `resetOnSubmit` is too ambiguous/opinionated...\n\n- What if the initial state of the form is autofilled values and the form needs to be reset to _empty_ values?\n- Should resetting occur at moment when submit is attempted or submit is completed?\n- What about resetting if submit fails?. Does this also occur for you in 1.4.0 by any chance?. @agustingp That should be expected behavior - consider a non-empty array with more than one element. Choosing to reset a single value should result in, e.g., `[undefined, 1, 2, 3, 4]`.. If the array has dynamically loaded values, with `actions.load('model.array[0]', 'something')`, it should naturally reset to that `'something'` as the initial value. If it doesn't, please open a separate ticket and I'll look at it.. Take a look at the example in [the Form documentation:](https://davidkpiano.github.io/react-redux-form/docs/api/Form.html)\n\n```jsx\nimport { Form, Control } from 'react-redux-form';\nimport { isEmail, isNull } from 'validator';\n\nconst required = isNull;\n\nconst passwordsMatch = ({ password, confirmPassword }) => {\n  return password === confirmPassword;\n};\n\n// in render() return block:\n\n\n\n\nSubmit!\n\n```\n\nThis is an example of a **form-level validator** that takes in the entire form value and validates that both the `password` and `confirmPassword` models match.\n\nSo I'd imagine you'd have a `phoneNumberOrEmail` form-level validator that looks something like this:\n\n```\nconst phoneNumberOrEmail = ({ phone, email }) => phone || email;\n\n\n// ...\n```\n\nI'll add a form-level validation example to the docs. Thanks for pointing it out!. > but would prefer to only display it after either of the fields had been touched.\n\nEasy enough! `` ;-)\n\n> is there a way to associate this validation with the field models though?\n\nNot quite yet - I'm going to add support for functions-as-validators in `` soon (they're available on `` right now). That way, you can just do this:\n\n```jsx\n {\n  const phoneEmailValid = hasPhoneOrEmail(values);\n\n  return {\n    phone: { phoneEmailValid }, // associate with just the phone field?\n    // ... other validity\n  };\n}}/>\n```\n\nfor any super-custom behavior. . Thank you!. Awesome, thanks! Fixed by your PR, #563. Looks good to me \ud83d\udc4d . Sure, the general pattern is to make a new component:\n\n(some props removed for brevity - add all necessary props)\n```jsx\nconst MyTextField = (props) => (\n  \n\n\n\n);\n```\n\nAnd then use it:\n\n```jsx\n\n```\n\nLet me know if this works for your use-case. It's the same way you would approach this problem with an other React component.. Looks awesome! Thanks for confirming!. Sure, you can do it like this:\n\n```jsx\nconst firstOptions = ['foo', 'bar', 'baz'];\nconst secondOptions = ['red', 'green', 'blue'];\nconst showColors = true;\n\n// ...\nconst options = showColors ? secondOption : firstOption;\n\n// then, in your render() method:\n\n  {options.map(value =>\n    {value}\n  )}\n\n```\n\nJust as you would dynamically render children in vanilla React.. You can programmatically dispatch `actions.resetValidity('newUser')` at the right time.\n\nI'm working on an enhancement to distinguish between pre-submit and post-submit validity, which should resolve this issue.. @toadle I fixed the issue - now the `` component will only check **sync** validity when determining whether it should submit or not. The existing spec is followed, so this is not a breaking change.\n\nIn retrospect, this makes sense; suppose you have a form that, when initially submitted, returns an error such as \"You've submitted too fast. Please try again in 30 seconds.\" Ideally, you shouldn't need to change anything in the form to be able to submit it again. In other words, we shouldn't assume that an API endpoint for submitting a form is idempotent - we see often that this is _not_ the case.\n\n-----\n\nNow, in order for this to work with _your_ specific use case, please pass `{async: true}` as an option into `setFieldsValidity` - that's the only way RRF will know that the validity is from an async operation:\n\n```js\n      .catch((err) => {\n        dispatch(actions.setFieldsValidity('newUser', err, {async: true}));\n        dispatch(actions.setPending(\"newUser\", false));\n               ...\n      });\n```\n\nThis will automatically be done for you when using action thunk creators such as `actions.asyncSetValidity` or `actions.asyncSetErrors`.. @toadle It's not released yet \ud83d\ude05 will be today, though.. Will do, @peterox !. @toadle Could you post a fully reproducible code example? There is a CodePen template in the README.. @toadle So is it working for you now?. Ah, that looks like a bug. Can you file a separate issue for that? @toadle . I also added a [Quick Reference](http://davidkpiano.github.io/react-redux-form/docs/guides/validation.html#quick-reference) to the validation docs to better find out how to do this. And it's in the FAQs \ud83d\ude09 . Thank you! I'll publish a patch soon.. Published here: https://github.com/davidkpiano/react-redux-form/releases/tag/v1.4.1. Published here: https://github.com/davidkpiano/react-redux-form/releases/tag/v1.4.1. Hey @sl33kr, taking a look at it now! Sorry for the delay.. Would you mind merging in the latest from master and creating a pull request so I can further review? I definitely want to go forward with this.. It's intended, but just curious, what was your use-case? If there's no better way to do it, I can add it back.. Actually, I'm going to add it back in. I realize it is a breaking change, even if it's not documented. Sorry about that!. That's a good use case. Give me a few hours, I'll have the values back by this evening at the latest.. What does your `store` look like?. **EDIT:** Ignore this post, [see this answer](https://github.com/davidkpiano/react-redux-form/issues/574#issuecomment-267078465) instead\n\n---\n\n@CoinGame I believe the issue is here:\n\n```js\nconst forms = combineForms({\n    register: registrationFormState,\n    login: loginFormState,\n    profile: profileFormState\n  })\n\nexport default combineReducers({\n  routing: routerReducer,\n  forms: forms,\n  profile,\n})\n```\n\nSince you're putting your forms in a nested part of your store, instead of at the root of your store (that is, it's at `store.getState().forms` instead of just `store.getState()`), you need to specify _where_ you are putting your forms in `combineForms`:\n\n```diff\nconst forms = combineForms({\n    register: registrationFormState,\n    login: loginFormState,\n    profile: profileFormState\n- })\n+ }, 'forms')\n```\n\nThe above tells RRF \"I'm going to be putting these forms under the `'forms'` key in my store.\"\n\nPlease add that and let me know if it fixes your issue.. So because it's nested, you'd have to change the model here too:\n\n```jsx\n      \n\n\n```\n\nSorry, forgot to mention that.\n\nHere's the general idea:\n\n```js\nconst store = createStore(combineForms({\n  foo: initialFoo,\n  bar: initialBar,\n}));\n```\n\ncreates this store shape:\n\n```\n{\n  foo: ...\n  bar: ...\n  forms: {\n    foo: ...\n    bar: ...\n    $form: ...\n  }\n}\n```\n\n---\nWith nested form state:\n\n```js\nconst store = createStore(combineReducers({\n  something: somethingReducer,\n  forms: combineForms({ foo: initialFoo })\n});\n```\n\nYou now get this shape:\n\n```\n{\n  something: ...\n  forms: {\n    forms: { foo: ..., $form: ... }\n  }\n}\n```\n\n---\n\nI recommend doing something like this: http://davidkpiano.github.io/react-redux-form/docs/api/createForms.html\n\n```js\nimport { combineReducers } from 'redux';\nimport { createForms } from 'react-redux-form';\n\nconst initialUserState = {};\nconst initialGoatState = {};\n\nconst reducer = combineReducers({\n  foo: fooReducer,\n  bar: barReducer,\n  ...createForms({\n    user: initialUserState,\n    goat: initialGoatState,\n  }),\n});\n\n// reducer state shape will be:\n// {\n//   foo: fooReducer,\n//   bar: barReducer,\n//   user: modelReducer('user', initialUserState),\n//   goat: modelReducer('goat', initialGoatState),\n//   forms: formReducer(''),\n// }\n```. No problem! Glad to help, and feel free to open another issue if you're still hung up on some aspects of RRF.. > That conflicted with the controlProps, as radio and checkbox are read-only as per the isReadOnlyValue method in control-component.js.\n\nYeah, I need to refactor that to not use \"duck-typing\" to figure out if a component is an actual input/radio button. Thanks for debugging, though!. See here, from the FAQs: http://davidkpiano.github.io/react-redux-form/docs/guides/faqs.html#how-do-you-add-conditional-class-names-based-on-field-state\n\nIn short, this would be something that you would use `mapProps` for:\n\n```jsx\n cx('input', {\n      'input-error': !fieldValue.valid\n    })\n  }}\n/>\n```. Code looks good to me! I can make the type def update if you want, unless you're already on it.. Thank you! I'll revise the comments.. Hmm, if I understand the problem correctly, the issue lies in taking the existing validity, and _setting_ the validity (with own validator keys removed) on unmount, even if that validity is \"stale\". \n\nI'd like to approach this by instead doing something like this:\n\n```diff\n-dispatch(actions.setValidity(model, omit(fieldValue.validity, keys)));\n+dispatch(actions.resetValidity(model, keys));\n```\n\nand then modify the reducer/action so that instead of setting it to the stale validity without `keys`, it _only resets_ the specified keys, so other parts of the validity are untouched - in this case, the other validity is gone anyway, and will remain that way.. Hmm, interesting - although, is imperatively calling `action.meta.resolve(payload)` \"allowed\" in `redux-saga`? I thought that all side-effects should be captured with `yield call(...)`.\n\nSo the general idea to translate the `submit()` thunk to a saga, if I'm not mistaken, is something like this:\n\n```jsx\nfunction* submitSaga({model, promise}) {\n  yield put(actions.setPending(model, true));\n\n  try {\n    const validity = yield promise;\n    yield put(actions.setSubmitted(model, true));\n    yield put(actions.setValidity(model, validity));\n  } catch(error) {\n    yield put(actions.setSubmitFailed(model));\n    yield put(actions.setValidity(model, error));\n    throw error;\n  }\n}\n```\n\nWould this general structure also apply to your use case? This is just a direct translation from the original `submit` action. In short, this is what happens:\n\n1. `pending = true`\n2. wait for the promise to resolve...\n  - If resolved, `submitted = true` (also sets `pending = false`)\n    - `validity = response` (format however you'd like)\n  - If rejected, `submitFailed = true` (also sets `pending = false`)\n    - `validity = error` (format however you'd like)\n\n. Good catch; this LGTM. Will merge once \ud83c\udf4f, thanks! . Hmm, the simplest solution would be to have some sort of option to _merge_ validity instead of setting it, as you said - otherwise, it's a race condition between form and field validators.\n\nOne of these options should work:\n- New action: `actions.mergeValidity(model, validity)`\n- New option: `actions.setValidity(model, validity, {merge: true})` (I'm leaning towards this one for succinctness and flexibility)\n\nWhat do you think?. > Is `merge: false` basically the current behavior? If so, that should be the default. \n\nYes, this is the current behavior - setting it to `true` would definitely be a breaking change, so I'd like to avoid that.\n\nWith that said, I _think_ it would be safe to internally have `` components merge validity instead of overwriting it. I'll try this.. @sl33kr @dave-clover I was able to fix your failing test by adding a `mergeOrSetErrors` strategy pattern for `Control` - if the control validity is a plain object, it will be merged with the existing validity. Otherwise, it will be set (e.g., if your validity is a boolean/string/etc.)\n\nThis works without any breaking changes! \ud83c\udf89 . Yeah, it would be almost trivial to have something like this API:\n\n```jsx\n\n  ...\n\n```\n\n(or `'blur'` or `'submit'` (default)), but of course it would submit the entire form.\n\nThe tricky part is the whole only-submit-changed-field(s) part. I think there was a previous issue: #409 that discussed this.. @oyeanuj That makes a lot of sense; I didn't even think of that!\n\nBikeshedding time:\n\n```jsx\n !field.pristine}\n/>\n```\n\nAbove is an initial (and probably terrible) idea for the API. What would an ideal submit-only-dirty API look like to you?. @iBasit this is best solved in user-land. You have full access to the values via the Redux store, so you can implement auto-saving yourself.. I decided to ship an MVP API for this that is as simple as humanly possible and covers 97% of use cases:\n\n```jsx\n\n```\n\nThe `viewValue` will always be updated immediately, but the model value will be debounced properly.. @greghawk Can you spin up an example that replicates the issue?. Awesome, want to file another issue? I'll take care of it soon.. Can you point me to the example?. Try to avoid using `createFieldClass` - it's essentially deprecated as of v1.0. See here for a guide on making custom components: http://davidkpiano.github.io/react-redux-form/docs/guides/custom-controls.html\n\nThe above example would instead be:\n\n```jsx\nimport { Control } from 'react-redux-form';\nimport TextField from 'material-ui/lib/text-field';\n\n// ...\n\nconst MaterialField = (props) => (\n  \n);\n```\n\nMuch better, right? \ud83d\ude04 . Looks like it would just be:\n\n```jsx\nimport { Control } from 'react-redux-form';\nimport SelectField from 'material-ui/SelectField';\n\nconst MaterialSelectField = (props) => (\n  \n);\n```\n\nPlease let me know if this works! Haven't played around much with `material-ui`.. I'd need to see a full code example - try putting one up on www.esnextb.in. I can't reproduce it due to this problem: https://github.com/callemall/material-ui/issues/5595. Hm, mind opening up another issue for this? Also, try using plain `` instead of ``.. Oh, awesome! Mind sharing the code for that?. Can you put up a reproduction on www.esnextb.in? You can use this code as a starting point:\n\n```jsx\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { LocalForm, Control } from 'react-redux-form';\nimport Toggle from 'material-ui/Toggle'\nimport MuiThemeProvider from 'material-ui/styles/MuiThemeProvider';\n\nclass MyApp extends React.Component {\n  handleChange(values) { console.log({values}) }\n  handleUpdate(form) { console.log({form}) }\n  render() {\n    return (\n      \n this.handleUpdate(form)}\n          onChange={(values) => this.handleChange(values)}\n        >\n          \n\n\n    );\n  }\n}\n\nReactDOM.render(, document.querySelector('#app'))\n```. Mystery solved - Material-UI's `` component uses `onToggle`, not `onChange` (for whatever reason... :roll_eyes:), so to make `changeAction` work, you need to map `onToggle` to `onChange` like this:\n\n```diff\n           props.onChange}}\n            changeAction={(model, value) => {console.log(model,value)}}\n          />\n```. Yep, there is! Check out the FAQs: http://davidkpiano.github.io/react-redux-form/docs/guides/faqs.html\n\n```jsx\n fieldValue.focus\n      ? 'focused'\n      : ''\n  }}\n/>\n```. Sorry about that! Seems like you're reading outdated documentation from version 0.x. Please read the most up-to-date docs here: http://davidkpiano.github.io/react-redux-form/docs.html. Adding here for reference - apparently this works with React-Redux v4.x but not v5.. @jinty Yeah, this is a current known bug with the latest `react-redux` - https://github.com/reactjs/react-redux/pull/589\n\nI will find a way to work around it.. If you're curious (or would like to help), the main issue is that the `` component in React-Redux v.5.0.x _doesn't_ completely work with taking in `store={myStore}` as a prop, whereas `4.x` did.. Please try this again after upgrading to [React-Redux 5.0.3](https://github.com/reactjs/react-redux/releases/tag/v5.0.3).. Good catch, thank you!. You should now (after the next release) be able to use the `persist` prop to accomplish this:\n\n```jsx\n\n```\n\nThis will prevent the validity from being reset when the component unmounts.. As a workaround, importing `Fieldset` from `react-redux-form` for use in your Immutable app should work fine.. I just published `1.5.1` - can you use that and see if the issue still exists?. A stopgap for now (while I look into this issue) is to do something like this:\n\n```js\ndispatch(actions.resetValidity('your.model', ['available']))\n```\n\nThat will reset the validity _only_ for the specified keys (in this case, `'available'`).. I'll keep this open as I'd like to add an `actions.resetAsyncValidity` action.. On second thought, would it make sense for async validity to automatically be reset when a field changes?. So when you add a form-level validator, such as `'': { hasRecaptcha : ...`, that validator belongs to the form. Try the above code with:\n\n```diff\n\n this.handleSubmit(vals)}\n        >\n          \n            Male\n          \n\n            Female\n          \n\n\n    );\n  }\n}\n\nReactDOM.render(, document.querySelector('#app'))\n```\n\nPlease review the above code and let me know if there are any large discrepancies between the above and your code.. I tried it directly on a local project. I'm not sure why it's going to `react-redux-form/src/immutable.js` - it should instead be hitting `react-redux-form/immutable.js` directly.. Have you tried using the `getDispatch` prop to get the internal dispatch for the ``'s store, in order to dispatch an `actions.change` with the new data?. That is the intended behavior - I'll make the docs clearer on this!. So you're saying it should just be:\n\n```js\nmodule.exports = require('./lib/immutable');\n```\n\nIs that correct?. I wouldn't say it's a hack - it's exactly what's expected. I'll go ahead and push that as a patch and see if it fixes the ESNextBin issue.. RRF needs some way of knowing _when_ a value changed, and _what_ the value changed to, at the very minimum. With your current custom component, there is no way of doing that, because your custom input's `onChange` prop is locked to your own function, so it isn't open to receiving any props.\n\nChanging it to allow for this is trivial:\n\n```diff\nconst MyInput = (props) => {\n  return  {\n      console.log('MyInputOnChange');\n+     return props.onChange(event);\n    }}\n  />;\n};\n```. Thank you! Build error is my fault.. Thanks!. Thank you!. > 1. Is there a better way to display each field error without creating a Error tag for each\n\nCurrently, no, and this is because `messages` has the strict shape of:\n\n```\n{ validatorKey: message }\n```\n\n> 2. Is there a way to display all the field error messages within the Error tag?\n\nNot currently, as well, though it might be a good enhancement to have the `messages={(errors) => ...}` prop accept a function that takes in the `errors` and returns an array of messages. What do you think about that?\n\nFor the first one, I'd have to think of a good solution. Might have to be a separate component, like `` or something like that (naming stuff is hard).. Awesome! Glad they weren't too painful!. Does `myForm.crew` exist upon initialization? Resetting resets the model and form to their initial state, so if they didn't exist at the beginning, they won't exist when reset.. Would it be possible for you to share a link to the repo, or stick it on www.esnextb.in ? This is probably some sort of edge case.. > If new form fields are dynamically added to the model, will actions.reset() work properly?\n\nYes, they should. I'll add a unit test to verify that.. Thank you! I'll take a look at it now.\n\nEDIT: Okay, I think I understand the general issue. Since RRF treats \"forms\" and \"fields\" a tiny bit differently (because it needs to), things get a little weird when something is initially a field (`user.city === null`) and then turns into a form (`user.city === { ... }`) and back to a field (`user.city === null`). Will investigate.. > I know this can be done through the changeAction prop on the Control component by dispatching action.change for that particular car in the array, but is this possible through the reducer? \n\nSure, anything is possible through a custom reducer. http://davidkpiano.github.io/react-redux-form/docs/guides/models.html#using-existing-reducers\n\nIn your use case, you would have to use `lodash.toPath` to separate out the parts of the path from `user.cars[1].type` to `['user', 'cars', '1', 'type']`, and then `path.slice(0, -1)` to get the path without the last subpath. Then, with `['user', 'cars', '1']`, you can use whatever method you're most comfortable with (a library like `icepick`, something similar to Immutable.js, or depth-first search) to update the car in your custom reducer.\n\nDoes that help? I'll try to think of other simpler solutions.. If you're using `redux-thunk` as middleware, you can do this:\n\n```js\n\n```\n\nPretty cool, huh? Might be the simplest solution to your issue.. It might be a bug that has long been fixed in the latest version of React Redux Form.\n\nIs there anything I can help answer in terms of upgrading? v0.x to v1.x is not a huge migration, and there would be relatively few things you'd need to change to get it working.. > The naming of collection items in the model is different than in the form. It's tricky understanding when to use which. I believe x1.x has solved this.\n\nYes, this has been solved.\n\n>  can be added to your JSX without being defined in the model or form. But it won't appear in the state tree until it's touched by the user. _Unless_ you give it a defaultValue, then it appears in the state tree immediately.\n\nYep, this is what setting the `initialState` is beneficial for. In V1.0 it's even simpler:\n\n```\nconst store = createStore(combineForms({\n  foo: initialFoo, // not a reducer\n  bar: initialBar, // not a reducer\n});\n```. What version of RRF are you using? This might be a previously solved issue - in short, the validator has to return a boolean value, but it _should_ still work if truthy/falsey values are returned.. Are you using Babel?. @danilotorrisi @hoangtrucit Is it possible to link me to the repos where you are experiencing the issues?. I'm a little confused - a custom reducer would make sense, especially one that has both the username and password in its state, right?. How about something like this?\n\n```js\nimport { createStore } from 'redux';\nimport { combineForms, actionTypes } from 'react-redux-form';\n\nconst initialUser = { username: 'Bob', password: '' };\n\nconst userReducer = (state = initialUser, action) => {\n  switch (action.type) {\n    case actionTypes.FOCUS:\n      if (action.model === 'user.password') {\n        return { ...state, username: initialUser.username };\n      }\n      return state;\n    default:\n      return state;\n  }\n};\n\nconst store = createStore(combineForms({\n  user: userReducer,\n});\n```. Where does `reduceReducers` come from?. Hmm, you could probably just do this:\n\n```js\nconst counterReducer = (state = {count: 0}, action) => { ... };\nconst quoteRequestReducer = combineReducers({\n  'model': modelReducer('model', {}),\n  'form': formReducer('model', {})\n});\n\nconst reducer = (state = {}, action) => {\n  const finalState = {\n    counter: counterReducer(state.counter, action),\n    ...quoteRequestReducer(state, action),\n  };\n\n  return finalState;\n});\n\nexport default reducer;\n```\n\nThe above (or at least a similar pattern) _should_ work.. Can you put a reproducible example on www.esnextb.in ? With the latest version of react-redux, all unit tests pass, including those for Errors, so this might be an edge-case, but I'd like a fully reproducible example to verify that.. Please try this again after upgrading to [React-Redux 5.0.3](https://github.com/reactjs/react-redux/releases/tag/v5.0.3).. Closing due to inactivity - please let me know if this is still an issue.. Thank you!. Okay, great!. What if you set up an extra custom reducer to listen for `actionTypes.CHANGE` actions and build the changed model from there?\n\nThere's a few reasons that RRF doesn't come with a built-in \"submit-only-changed-fields\" feature, and that's mainly because of ambiguity, complexity, and weight. See here for more context: https://github.com/davidkpiano/react-redux-form/issues/409\n\nAlso, you can do a breadth-first search for fields that are `.touched` when preparing the data for submitting. Let me know what you think - if your general question doesn't fall into the diffing category, I'll reopen this.. Does `lodash.toPath` not work? The package depends only on `lodash.get` and `lodash.toPath`, so it should not depend on lodash as a whole.. Sorry, my main concern with this PR is the number of calls for `.toJS`, which sorta defeats the purpose of Immutable.JS.. Closing this until we can figure out how to do this without `.toJS` calls, sorry \ud83d\ude22 . Sure, I'd be glad to continue discussion. Let's merge master into this and see what we can do to reduce the number of `.toJS` calls.. Sure, I'll do that soon.. Right now, the merge is really complex - lots of things have changed internally. I think it would be best if this were done in a way that allowed for the form state to remain a JavaScript object instead of an Immutable.JS object. Otherwise, RRF is going to get really, really complex. \ud83d\ude1f \n\nHow would you deal with Immutable.JS with other APIs/libraries that don't use Immutable.JS? I'd want to approach RRF the same way. I personally don't use Immutable.JS because I think its benefits are overstated and its buy-in is too expensive for most non-trivial projects.. > The easiest way would possibly be creating a separate store for React-redux-form?\n\nI've had that thought - it makes sense but I'm worried about having two separate sources of truth. Have you seen similar projects do this? Would love to explore this for V2, would make many things much simpler.. @brianleonard15 Can you create a simple reproducible example in www.esnextb.in ? Would be greatly appreciated.. The first issue has most likely been fixed in a previous release and is not reproducible.\nThe second issue was just fixed \ud83c\udf89 . You would just solve this as you would solve any other similar problem in React and Redux. Here's an initial example (with some intermediate code left out for clarity):\n\n```jsx\nimport range from 'lodash/range';\n// ...\n\n// connected component\nclass MyForm extends Component\n  checkLast(firstVal) {\n    const { user, dispatch } = this.props;\n\n    if (user.last < firstVal) {\n      dispatch(actions.change('user.last', firstVal + 1));\n    }\n  }\n\n  render() {\n    const { user } = this.props;\n\n    // in return statement...\n     this.checkLast(val)}\n    >\n      {range(0, 20).map(num => {num})}\n    \n\n      {range(user.first, 21).map(num => {num})}\n    \n    // ...\n  }\n}\n```\n\nThe idea here is whenever the `user.first` value changes, check if `user.last` is less than `user.first`. If it is, set `user.last = user.first + 1`. Or you can set it to `undefined`, depends on your use case.. The above is a good method if you want to do it with just CSS. Otherwise, you can just modify the `wrapper={...}` prop with a functional component:\n\n```jsx\nconst errorWrapper = ({ children }) => (\n  \n    {React.Children.toArray(this.props.children)[0]}\n  \n);\n\n// in render()\n\n```\n\nI believe this will work, but I haven't tested it. Hope that helps!. When `1.5.4` is published (tomorrow) can you please see if you can still recreate this?. This has been fixed in recent versions - please get the latest version and make sure that this is fixed for your use case.. > - react-redux@5.0.1\n\nThis is currently an issue with the latest `react-redux` - more info in this ticket: https://github.com/davidkpiano/react-redux-form/issues/592. Please try this again with the [latest React-Redux](https://github.com/reactjs/react-redux/releases/tag/v5.0.3) version.. Awesome, good catch!. Do you mean as a prop? The problem with passing in a custom prop like `fieldValue` is that it is not a standard prop for any standard HTML5 controls, so React will throw warnings.. Closing due to inactivity and it not making sense to pass a non-standard prop into the standard props mapping. If you can clarify this, I can reopen it.. Good catch. The Redux way of doing this would be to just connect your parent component with the model, and then handle the `onPress` to submit the model's values:\n\n```jsx\nclass MyForm extends Component {\n  handleSubmit() {\n    const { user } = this.props;\n\n    // submit the user however you'd want,\n    // or dispatch(actions.submit('user', somePromise))\n  }\n  render() {\n    return (\n      // ...\n       this.handleSubmit()} />\n      // ...\n    );\n  }\n}\n\nconst mapStateToProps = ({ user }) => ({ user });\n\nexport default connect(mapStateToProps)(MyForm);\n```. Docs updated here: http://davidkpiano.github.io/react-redux-form/docs/guides/react-native.html\n\n----\n\nTo submit a React Native form programmatically:\n1. Ensure that the `` component has an `onSubmit={(values) => ...}` callback.\n2. Dispatch a submit action for the form's model (and no other arguments): `dispatch(actions.submit('foo'))`\n\n```jsx\n console.log(vals)}>\n  \n\n dispatch(actions.submit('user'))} />\n\n```. Can you please expand on this? I'm not exactly sure what you mean.. Gotcha. For most use cases, preventing the default action of an event is preferable, I would think - otherwise, most forms would navigate to a different state/route, which is undesirable.\n\nWith that said, what do you think about `` ?. > Might be a good patch but the I believe a better option is to always leave it up to the developer\n\nThat was my first thought as well. This would probably be a breaking change, however. I will definitely pass the event as-is in V2.. Seems to work just fine here: https://esnextb.in/?gist=8146e128a98291f00623e24a1ecc5345. This looks like a very similar solution: https://github.com/davidkpiano/react-redux-form/issues/620#issuecomment-273768987\n\nIn short, you would solve this the same way you would solve it using just React + Redux. That is, have an `onChange` handler that ensures that the second value is related to the first value.\n\nAlternatively, you can make this special \"two-in-one\" custom component and manage the logic of what is selected in component-specific state. Then, you can just do the custom component pattern of `` or something like that.. > Is that explicitly documented somewhere I missed?\n\nI should probably add that, but you can pass any props that you would normally pass to the component anyway, and they'll be passed to the component.. @slsriehl Would you be able to make a minimally reproducible code example on www.esnextb.in ?. Can you show me a full code example that reproduces the problem?. Which one is line 79?. At any point, is the value undefined?. I'd have to see a fully reproduced example on www.esnextb.in - as-is, the above code example is missing a lot of contextual code (as well as the Parsley.JS validation library) for me to be able to reproduce the problem.. What does your `store` look like? Ideally, you shouldn't even need `defaultValue` because it would be part of the initial state.. @DanielLuu can I see your code as well?. @jgentes Try `1.10.0`. Can you recreate it on Codepen? Fork this template: http://codepen.io/davidkpiano/pen/yJwmEa. As in the warning doesn't occur when trying it in CodePen? If so, upgrade to the latest version. The problem might be with your usage of `defaultValue`, I'd recommend not using it and instead setting it as an initial value in your reducers.. @jgentes If you can replicate it, can you file a bug for that so I can fix it quickly?. Open it in debug mode, or use `redux-logger` (already included).. Have you tried using the `defaultValue` prop in the controls?. I'm still trying to understand what exactly you're trying to accomplish. Do you want to asynchronously set initial values for each field? If so, use [actions.load(model, value)](https://davidkpiano.github.io/react-redux-form/docs/api/actions.html#actionsloadmodel-value):\n\n```js\nsomePromise().then((values) => {\n  // This will set the initial state of foo.bar to the values\n  dispatch(actions.load('foo.bar', values));\n});\n```. Thanks!. Thank you! I've been looking forward to trying this with Preact.. Try `rm -rf ./node_modules` and `npm install` again, if you're having issues with `npm`. Also, try installing via `npm install react-redux-form --save`. Can you set up a working example on www.esnextb.in ?\n\nAlso, does it work if you omit `onChange` and `mapProps` in ``?. At the very least, try `dispatch(actions.change(model, value))` inside the `SelectField`'s `onChange={...}` prop (same with `DropDownMenu`).\n\nRemember: you _don't_ need to use `` - you can dispatch actions and read from the state manually. See if that works first.. @marcandrews Nice! What happens in `handleResolutionChange`?. I'll admit, this was sort of an API design mistake which will be addressed in V2 (see #626), but it's one that can easily be patched for now. It's just a question of what the (temporary) API should be:\n\n- ` ...}>`\n- ` ...}>`\n- Any other suggestions?\n\nIn V2, all event handlers will behave the same as normal event handlers, where the `event` is passed in as the first argument to the handler. Currently, `` has a `withField={true}` prop that passes in the `fieldValue` as the second argument. I'm envisioning the same for `` in the future:\n\n```jsx\nconst handleSubmit = (event, formValue) => { ... };\n\n\n```. Thanks!. Ah, so the issue here is that currently, your state looks like this:\n\n```js\n{\n  thing: { id: 0, name: '' },\n  things: [...], // < RRF only knows about *this*\n}\n```\n\nRRF has no idea about what `thing` is because it wasn't part of `combineForms`. If you simplify this, you'll see that it just works:\n\n```jsx\nconst reducers = combineForms({ things });\n\n// ...\n\n  render () {\n    return (\n       this.handleSubmit(thing)}>\n        Thing:\n\nSave\n\n    )\n  }   \n```\n\nNotice how I moved the `track(...)` to the `` instead of the control. Hope this makes sense!. Thank you!. Remember that thunks have the signature `(...args) => (dispatch, getState) => ...`. And because you have the form state in your component state already, you can \"dispatch\" the thunks like this:\n\n```js\nFormActions.push('message.images', result.filename)(this.messageFormDispatch, this.state.message);\n```\n\nHope that helps!. What does `` look like?. This seems very complicated... your `` is rendering a component that has a `` inside of it. With that, I don't think you even need to wrap your custom component in a ``.\n\nAnyway, the only way I can begin to diagnose this problem is if you reproduce it in something like www.esnextb.in .. Closing due to inactivity.. What version of React-Redux are you using?. @stanleycyang @vlsergey-at-work Can you please make a small reproducible code example? You can [fork this CodePen](http://codepen.io/davidkpiano/pen/2cbfd61bdcff474ca6e40e8ed2221ef9) to get you started.. @vlsergey-at-work Is it working for you too?. Closing due to inactivity, and because it seems to be working after upgrading Redux \ud83d\ude4c . > ...I'd like to cut to the chase and just have the forms Object be a top-level item if possible but have not been successful in trying to do so.\n\nTry using [`createForms`](http://davidkpiano.github.io/react-redux-form/docs/api/createForms.html) instead of `combineForms`. Let's see if that solves the second problem as well.. Yes, `forms` will always be a standard Object. RRF was created to work with most standard use-cases of React and Redux, and making form state an Immutable.JS Map would increase complexity and code size, which is unfavorable. Personally, I don't advocate using Immutable.JS - it's additional complexity and abstraction for very little gain in most use cases.. Can you show me your current code? `combineForms()` is to be used in place of `combineReducers()`.. I don't see React-Redux-Form being used in the above code. Can you show me the relevant code that is failing?. What does `createReducer()` look like?. Yeah, as long as the first argument is a reducer, it should work. Instead of using `combineReducers()`, use `combineForms()`, which returns a reducer.. You would just `dispatch(actions.setErrors('your.model', 'Your string error', { async: true }))`. Does that answer your question?. Hopefully this answered your question! Feel free to follow up if you have further questions.. @danielericlee Do you have a simple code example that can accurately reproduce this issue?\n. Awesome! I'll make a starter CodePen to make it easier for people to recreate issues.. Does `styled-components` not work without this? If so, why not? Just curious.. You're right, it should ideally read from the ES5 version of the code. It worked at one point (since react-native does its own Babel transpilation) but I guess it doesn't work now. Will fix soon.\n. @dfcarpenter How are you importing `react-redux-form`?. You probably don't have `redux-thunk` set up in your middleware. That is required for doing anything besides a simple `actions.change`.. > Ah i see its required for anything besides actions.change\n\nYes, that's correct. And it is pretty clear in the most up-to-date docs here: http://davidkpiano.github.io/react-redux-form/docs/api/actions.html . However, I'll update the quickstart docs.. Can I see your code? Are you `connect()`-ing the entire form?. Also, you can simply `updateOn=\"blur\"` which will immediately give you huge performance benefits.. Some of the performance concerns have been addressed in this commit: bf53863 which include many improvements:\n\n- actions.promise will now treat rejected promise errors as async errors\n- model actions are external by default - only when they are called within a Control event handler are they considered internal.\n- no validation will occur on Controls if there are no validators/errors props.\n- no validation will occur on Form if there are no validators/errors props unless the form is made invalid (async) - then the validity will become valid again on next validation.\n- all validation originating from Form is merged by default with field validation.\n- isValid() correctly handles async simple validation (strings, boolean, etc.)\n- no \u2018validate\u2019 intent will be pushed if change is not external (originated from Control)\n\nIn short, this means that fewer actions are dispatched now, which improves overall performance. More updates to come!. @niphidrema The issue could be that you are `connect()`-ing your entire form. This will, of course, cause the entire thing to update, and is not necessary. Without seeing your code, I cannot know for sure. I'll reopen this if you fixed that and are still having problems.. Your code's a little bit confusing, but why not try this:\n\n```js\nexport default combineForms({\n  user: Immutable.fromJS({ profile: { firstName: '', lastName: '' } })\n});\n```\n\nI'd start there and see if that works for your use case.. Right - `combineForms` will return a plain JS object. The model state _inside_ that object will be whatever you give it (in this case, an Immutable `Map`).\n\nThere's a good reason for this - the form state is always a plain JS object, and RRF needs a way to access that object without jumping back and forth between ImmutableJS and plain JS objects.. After this is released in the next patch, you should be able to extend `mapProps` just as you have it:\n\n```jsx\n {\n      return fieldValue.touched ? !fieldValue.valid : false\n    }\n  }}\n  validators={{\n    isRequired: (value) => {\n      return value && value.length > 0;\n    }\n/>\n```. You can manually submit a form by dispatching `actions.submit(model, promise)` and then get the errors from there, does that help?. Can I see your code?. Over here, try this:\n\n```diff\n      if (error instanceof ApiError) {\n        dispatch(notifyDanger('Der skete en fejl'))\n      }\n      if (error.body.metadata) {\n-       dispatch(FormActions.setFieldsErrors('data.task.current', error.body.metadata))\n+       dispatch(FormActions.setFieldsErrors('data.task.current', error.body.metadata, { async: true }))\n      }\n    })\n```\n\nBy providing `{async: true}` as an option, it will tell RRF that server validation came from _outside_ normal validation (i.e., it came from async validation), which will let it be submitted again.. Can you verify that `body` is not `undefined` here:\n\n```js\ndispatch(FormActions.merge('data.task.current', body))\n```. > So I guess resetValidity was trying to loop over this object that didn't have a corresponding form key, or something like that?\n\nSounds about right. Closing this as it seems you've found your solution (please let me know if I'm wrong!). If you can give me a reproducible code example (you can fork this CodePen: http://codepen.io/davidkpiano/pen/2cbfd61bdcff474ca6e40e8ed2221ef9 ) I'd be better able to diagnose and hopefully fix the problem.. Instead of importing directly from the folder, import from the `lib` directory:\n\n```js\nimport { Control, Form, /* etc. */ } from 'react-redux-form/lib/immutable';\n```. I would point to it being the proper way and change the documentation to reflect that.. Do you mean `enctype=\"multipart/form-data\"`?. Can you show me a fully reproducible code example?. Added to FAQs here: http://davidkpiano.github.io/react-redux-form/docs/guides/faqs.html. I'm actually in the process of making a Google Forms clone built on React-Redux-Form - so look for that this weekend! Should be exactly what you're trying to do.. Does that model exist?. @sniepoort Please send me a reproducible code example so I can further diagnose.. Like mentioned in the previous thread, start here: http://codepen.io/davidkpiano/pen/2cbfd61bdcff474ca6e40e8ed2221ef9. Can you try this with the latest version?. Closing due to inactivity. Please let me know if you still see this in the latest version.. You can pass in a function to `actions.change`:\n\n```js\nconst itemsToRemove = ['foo', 'bar', 'baz'];\n\ndispatch(actions.change('something', (value) => {\n  const newValue = {...value};\n  itemsToRemove.forEach(item => delete newValue[item]);\n  return newValue;\n}));\n```\n\nThis requires `redux-thunk`. You can also use `actions.batch` for multiple actions at once.. > Is that somewhere, or should I just dig into the source?\n\nAh, it's really only internally used - not meant to be exposed externally, but it _can_ be used. I'd stick to your found solution, if it works for you.. Can I see your code?. And what version of react-redux are you using?\n. Yeah, I was going to say - make sure you're using below version 5 for `react-redux` (there is an existing relevant issue that was fixed but not released yet). I'd have to see your entire code in a reproducible working example to further diagnose this. You can fork this pen: http://codepen.io/davidkpiano/pen/2cbfd61bdcff474ca6e40e8ed2221ef9. Closing due to inactivity. Please send me a code example and update to the latest version of RRF, react-redux, and React.. Don't forget to add `initialState={initialUserState}` to ``. Try that and let me know if it works.. What doesn't work about it? I just tried this locally, and it seems to work just fine.. Yeah, the fix is already in `react-redux` - a new version just hasn't been released yet. \ud83d\ude1e . Please try this again after upgrading to [React-Redux 5.0.3](https://github.com/reactjs/react-redux/releases/tag/v5.0.3).. You would use `track('model', {index: ...})` instead of deleting it by array index. See the docs for it here: http://davidkpiano.github.io/react-redux-form/docs/guides/tracking.html. Interesting, it seems like coercion is already done when changing the form: https://github.com/davidkpiano/react-redux-form/blob/master/src/reducers/form/change-action-reducer.js#L57\n\n```js\n      Object.keys(field).forEach((key) => {\n        if (!!~removeKeysArray.indexOf(+key) || (key === '$form')) return;\n\n        result[key] = field[key];\n      });\n```\n\nDo you know how `parseInt` might return a different result than the unary `+` in this case?. Closing due to inactivity - and I assumed you solved your problem based on the last comment \ud83d\ude04 . If you want to use `dispatch`, you have to first `connect()` the form. Please see here: http://redux.js.org/docs/basics/UsageWithReact.html#implementing-container-components\n\nI'll clarify the quick start guide for this.. > What exactly are the responsibilities of the different reducers (modelReducer, modeled and formReducer)? modeled is only mentioned on the models page.\n\nDon't worry about that - start with just `combineForms` per the Quick Start guide. The (internal) `modelReducer` is responsible for updating the model state (e.g., `user = { name: 'david' }`), and the `formReducer` is responsible for updating the form state (e.g., `user.name.touched = true`).\n\n```jsx\nconst store = createStore(combineForms({\n  user: initialUserState,\n}));\n```\n\n> When would I use combineForms vs createForms?\n\n`combineForms` is just like `combineReducers` in that it creates a single reducer function. If you already have an existing object that you passed into `combineReducers`, you can use `createForms` to create an object that can be passed in with your other existing reducers:\n\n```js\nconst reducer = combineReducers({\n  foo: fooReducer,\n  bar: barReducer,\n  ...createForms({\n    user: initialUserState,\n    goat: initialGoatState,\n  }),\n});\n```\n\n> How do I access the state of the controls / model in my UI? (E.g. for adding a custom CSS class to an input element when it is touched and is invalid.)\n\nTwo ways:\n\n1. in `mapProps` in your `` component. You have access to `fieldValue` which gives you everything you need. See the [FAQs](http://davidkpiano.github.io/react-redux-form/docs/guides/faqs.html) on custom classNames, for example.\n2. Just `connect()` your component like you normally would. You'll see, depending on your store state, that all the form/field states are available under e.g., `forms.user.name` or `forms.user.$form` for an entire form state.\n\n> What is the purpose of the different keys in the redux store? Especially: What state resides in forms.$form (the \"top-level\" $form object which is not related to a specific form)?\n\nLet's say you have a `user` object that looks like `user: { name: 'david' }`. Then:\n\n- `forms.user.$form` would represent the entire form state.\n- `forms.user.name` would represent the field state of `user.name`. Since it's a simple value (a string) and not a complex one, it's considered a field, not a form. \n\n> Is it safe / intended to subscribe to the store and access the $form objects directly?\n\nYes, you can do that. It's especially useful if you want to do something using the same Redux techniques you would use anywhere else - accessing state from the store.\n\n> Is the following statement true for the current version of the library? \"To nest it deep, you must specify where the deep combineForms() reducer will live as a model string in the second argument to combineForms(forms, model)\". (source) I ask because it seems to work just fine using combineReducers({ forms: combineForms({ ... }) });.\n\nThe reason that works is actually because `'forms'` is the default location that RRF looks for the forms. For most intents and purposes, specify the model path to be safe.\n\nHope that helps! I'll link to these answers in the FAQ.\n. Sure thing, @gkweb - I'll add it.. @bpdons you can do that in `mapProps`:\n\n```jsx\n {\n      if (touched && !validity.minLength) {\n        return 'Must be at least 2 chars';\n      }\n    }\n  }}\n/>\n```. Can you open a new ticket with that, @bpdons so it doesn't get lost?. @charrison-symfact That's coming in the next version. Want to open an issue so we can track the enhancement?. @KokoulinM You can just dispatch `actions.load(...)` to initialize the forms. Or use ``.. That's outside the scope of RRF. Use normal React/Redux patterns to accomplish that.. Right - you can't expect `dispatch(...)` to be synchronous. If you want to do validation manually, you should either wait for the model value to be updated in `componentDidUpdate`, or you can assume that the value passed in is the value that it will be changed to:\n\n```js\nonChange(model, date) {\n  dispatch(actions.change(model, formatDate(date)))\n  dispatch(actions.setValidity(model, ownProps.validators(formatDate(date))))\n}\n```\n\nassuming that `ownProps.validators` is a function.. It's a bit more complicated than that. If I have time, I'll work on it as an enhancement. I do not use Immutable.JS so it is not a priority for me - I strongly feel that Immutable.JS is a heavy burden on the project, especially given its ad-hoc data structures that provide little benefit (more details here: https://www.reddit.com/r/javascript/comments/4rcqpx/dan_abramov_redux_is_not_an_architecture_or/d51g4k4/ ). I'd strongly recommend using something like [icepick](https://github.com/aearly/icepick) or [seamless-immutable](https://github.com/rtfeldman/seamless-immutable) instead, which work with normal JavaScript objects and arrays.. Which version are you using?. Can you make a fully reproducible code example? Fork from this pen: http://codepen.io/davidkpiano/pen/2cbfd61bdcff474ca6e40e8ed2221ef9. Sorry about that, here's a forkable pen: http://codepen.io/davidkpiano/pen/yJwmEa. Thank you!. Ah sorry, here's an updated link: http://codepen.io/davidkpiano/pen/yJwmEa/. Also, would this be an `` component to signify that `password` and `password_confirmation` do not match? . Fieldset level validations are in progress, but you can also add form-level validations.\n\n@divined:\n> city field is mandatory if last_name field is filled.\n\n```jsx\n last_name ? !!city : true }\n  }}\n>\n```\n\n@ashleyconnor: \n\n> I would only want to show an error if all fields I am validating have been 'touched'. So I would need values and the dirty status for all fields in the set.\n\nFeel free to implement your own validation. The touched status is available on the `forms` slice of your store state (e.g., `forms.user.city.touched`, and it's simple enough to keep validation in component state by checking somewhere like `componentDidUpdate`:\n\n```js\nif (forms.user.city.touched && forms.user.last_name.touched) {\n  if (!isCityValid(user.city)) {\n    this.setState({ cityValid: false });\n  }\n}\n```\n\nAs an enhancement, I'll consider passing the form metadata as the second param for validation.. @divined What does your store look like? You can `connect(({ forms }) => ({ forms }))(YourComponent)` and get it directly from there.. What about using `resetValidity` instead?\n\n```js\nthis.props.dispatch(actions.resetValidity('userForm'));\n```\n\nThis should work as expected.. Awesome! Also, just for reference, when you `setValidity()` to a form, the intention is that you're setting form-specific validation on it. For example:\n\n```js\n// Form is invalid even if models are valid\ndispatch(actions.setValidity('user', { passwordsMatch: false }));\n\n// Form-specific validity is valid, but overall validity\n// depends on if models are valid or not\ndispatch(actions.setValidity('user', { passwordsMatch: true }));\n```. > What I'm trying to achieve is to know if a model has changed between two actions that save it to the server. If, after a save it has not changed, don't save it again.\n\nThis is use-case specific - we can't make blanket assumptions here because some APIs might change the server-side value externally, so even though it didn't change client-side, it _did_ change server-side.\n\nAll field values have an `.initialValue` prop that you can compare to. You can `connect()` to get that field value from the store (e.g., `forms.user.name.initialValue`) and manually compare.\n\nOther than that, what does an ideal API look like to you for this use-case (with regard to not making assumptions about the server)?\n. I mean, I could add `.isInitial`:\n\n```js\n// initial user: { name: 'david' }\n\ndispatch(actions.change('user.name', 'john'));\n\nforms.user.name.isInitial; // false\n\ndispatch(actions.change('user.name', 'david'));\n\nforms.user.name.isInitial; // true\n```\n\nIf this gets enough interest (vote with \ud83d\udc4d or \ud83d\udc4e ), I'll add it!. > how this .isInitial will be reseted to true on server sync?\n\nThat's, again, use-case specific, depending on how you're syncing with the server already in your client-side code.\n\nIf the server changes, you can always `load` the new value:\n\n```js\nAPI.getUpdatedValue().then(newValue => {\n  dispatch(actions.load('user.name', newValue));\n});\n```\n\nThen `.value` will be compared to the `.loadedValue`.. Still deciding on the API. The problem with `.initial` is that it's very close to `.initialValue`, which can cause some confusion. Also, `.load` _will_ rerender control components, have you tried that?. I like `.unchanged`.\n\nThe difference between `.pristine` and `.unchanged` is that `.pristine` signifies if a control has been changed at all, even if it was changed to its original value. It's more about the life cycle of the control than its actual value, which is useful for displaying validation.\n\nIf you can send me a minimal code example of what you're trying to do, I might be able to help better. My thinking is that this is the exact use-case for `.load`, so there must be some way for that to work with your use-case.. The behavior of `.load` just does a silent `.change`, and when a field is reset, it is reset to the `.loadedValue` instead of the `.initialValue`. It does not change the `.initialValue`, nor odes it change `.pristine` (because it's a silent change).\n\nI think the simplest change, for now, would be to add an `.unchanged` prop to the field state. Would that work for your use-case? Here's the logic:\n\n- if `.loadedValue !== undefined && .value === .loadedValue`, then `.unchanged = true`\n- else, if `.value === .initialValue` then `.unchanged = true`\n- else, `.unchanged = false`. > I am wondering what will be the impact of silencing every server sync \u2014 even the first one?\n\nWhat do you mean by \"silencing\"?. > \"actions.load(model, value) is equivalent to actions.change(model, value, { silent: true })\"\n\nYou're right, there is a subtle difference. Can you open a new documentation ticket about that (and about `.loadedValue` for tracking?. Sorry for the delay! The issue is you're not specifying what the error message should be here:\n\n```jsx\n              \n```\n\nYou should provide it:\n\n```jsx\n               error }}\n                model=\".myerror\"\n              />\n```\n\nTry that and let me know if it works for your project.. Closing due to inactivity. Please let me know if the above solution worked for you.. Which version are you trying to install?. Which last fixes are you referring to?. Closing as this seems to be fixed in #619. Please let me know if you still have the same problem with the latest version.. Can you share the code for `CustomComponent`?. Sure! You can use the [`parser`](http://davidkpiano.github.io/react-redux-form/docs/api/Control.html) prop:\n\n```jsx\n map[val]}\n/>\n```. Here's the problem:\n\n```diff\nfunction nameAvailable(value, done) {\n    checkNameAsync(value)\n        .then(response => {\n-           done({ nameAvailable: response });\n+           done(response);\n        });\n}\n```\n\nBefore, it was setting `user.firstName.validity` to `{ nameAvailable: { nameAvailable: false } }` (accidentally nested objects), and an object is truthy. The specific validator's validity is what's expected to be returned from the promise: `done(response)` to give us `{ nameAvailable: false }`.. I think both issues can be solved by adding a new form property: `.syncValid` (and maybe `.asyncValid`). The current behavior is that you _should_ be able to submit a form if only the sync validation is valid - that is, RRF ignores async validation when determining if a form could be submitted. The \"is sync valid\" state is just not exposed (yet). What do you think?. Bump: @thomasboyt do you think your use case will be solved with `.syncValid` and `.asyncValid`?. Can I see your code? It's hard to debug when I don't have code to reference.. Can you share a reproducible code example? It's in the issue template.. @CradCradHereCrad You can also share a [gist](gist.github.com) if you'd like.. Sure, you can make a PR to refactor/remove this. I think it's safe to remove it, as the error (in most cases) would get shown in the console anyway.. Closed by #697 . @mvanlonden Can you open a quick separate issue?. @Aryk Yes please! And a PR if you're feeling up to it ;-). Sure thing!. Possibly, but it hasn't been implemented yet.\n\nA good middle-of-the-road solution would be to set `updateOn=\"blur\"` in your controls.. I don't think so yet, but it would be very simple to copy [`src/native.js`](https://github.com/davidkpiano/react-redux-form/blob/master/src/native.js) and adapt it for Android controls. Want to do a PR? \ud83d\ude04 . Thanks @januszdotnl ! It should be pretty straightforward - the implementation is very similar to React Native (iOS).. @Jahans3 feel free to tackle this if you know how it'd be done \ud83d\ude09 . Can I see a full code example? Also try setting `defaultValue={1.75}` instead, and I'd like to see what's inside that `this.onHeightChange` function. Instead of: `changeAction={this.onHeightChange}`, you should be using `onChange={this.onHeightChange}`. Let me know if this fixes your problem, or if you have any questions as to why.\n\nShort explanation:\n- `changeAction` specifies which action is to be dispatched, so `setState` makes no sense here.\n- `onChange` is called whenever the model changes, which is perfect for your use-case.. It's not in the docs because it's not encouraged - `defaultValue` is for **uncontrolled** components, and technically, all RRF components are **controlled** components. In order to prevent conflicts/warnings and to preserve the intent of the developer, `defaultValue` in RRF is just a proxy for setting the initial value of the model.. @guywald1 Have you looked into using ``? Might be useful for your use-case, and you can set `initialState={...}` right on the component.. Can I see the full code of `onFormSubmit`?. > Also, is there a way to keep some values in the form and have them returned on submit without creating  components for them?\n\nIf I understand correctly, you can just keep them in `initialState`:\n\n```jsx\n\n```\n\nI'll update the documentation, but in `` you have access to the internal dispatcher via `getDispatch`, so you can do this:\n\n```jsx\n this.formDispatch = dispatch}>\n\n// and then anywhere in the same component where LocalForm is rendered:\nonButtonClick() {\n  this.formDispatch(actions.change('local.whatever', 'any value'));\n}\n```\n\nWith the latest version of RRF (1.9.x), you can even use action thunk creators inside of `this.formDispatch`.. See here for the latest documentation: http://davidkpiano.github.io/react-redux-form/docs/guides/local.html\n\nSpecifically the **Updating the model externally** section. Is there a specific reason you would want the state to not be read-only? Generally, with Redux, you should avoid mutation.. Can you show me the code that is trying to set `.id` to the object?. Right, that's mutating props, which is something that should _ definitely_ be avoided.\n\nPerhaps try looking into using something like [Normalizr](https://github.com/paularmstrong/normalizr) to do this in a non-mutative way.. It actually has nothing to do with `{async: true}`. Unfortunately, I noticed that you're wrapping a `` inside of a ``, both with the same model. That kind of wrapping is definitely going to cause some issues - ideally, (and this is by design) the component you pass into `Control` should not even be aware of React-Redux-Form at all. \n\nHere's how you can refactor:\n\n```diff\nconst TextFieldPresenter = (props) => {\n  const { label, passedProps, required, messages, size, className, disabled, placeholder, unit } = props;\n  const { model, fieldValue } = passedProps;\n  const classes = classNames({\n      className: true,\n      'form-control': true,\n  });\n  const wrapperClasses = classNames({\n    \"has-danger\" : (fieldValue.touched && !fieldValue.valid),\n    \"form-group\" : true\n  });\n\n  return (\n    \n      {label && {label}}\n        {unit && {unit}}\n-      \n-        {unit && {unit}}\n-        \n-      \n+       \n\n\n  );\n};\n```\n\n. It's hard to debug this without a properly reproducible code example. If you have a solution (based on https://github.com/davidkpiano/react-redux-form/blob/master/src/components/form-component.js#L202-L211 ) can you make a pull request?\n\nAs long as your solution seems correct and sound and all existing unit tests pass, I will merge it in.. So there's two ways:\n\n**1. use ``**\n```jsx\n\n  Submit user!\n\n```\n\nIf you put this inside a ``, it will _just work_ because a normal `` will submit the form.\n\n**2. use normal redux state**\n\nSuppose you have a store that looks like:\n\n```js\nconst store = createStore(combineForms({\n  user: initialUserState\n}));\n```\n\nThen you can just `connect()` to get the form state you need:\n\n```jsx\nclass MyForm extends Component {\n  render() {\n    const { userForm } = this.props;\n\n    // ...\n    \n      Submit!\n    \n    // ...\n  }\n}\n\nconst mapStateToProps = (state) => ({\n  userForm: state.forms.user\n});\n\nexport default connect(mapStateToProps)(MyForm);\n```\n. As far as I can recall, no. Those two should be it.. Thank you!. Try passing it into `modelReducer` as well:\n\n```jsx\nexport const model = modelReducer('modules.settings.forms.userPassword', initialState);\n```\n\nThe recommended way is to use `combineForms()` since it does that step for you:\n\n```jsx\nconst userPasswordReducer = combineForms({\n  userPassword: initialState\n});\n```. Most likely a duplicate of #630 - I will publish a patch soon!. @dragGH102 Publishing a patch soon!. The `` component has an `onUpdate` prop that will give you the form-specific values that you need. You can propagate those to component state via `setState` and then display the proper class however you'd like, by reading the values from component state.\n\n```jsx\n// in render()\nconst { isFormValid } = this.state;\nconst formClassName = isFormValid\n  ? 'form-group'\n  : 'form-group has-error';\n\nreturn (\n   this.setState({ isFormValid: form.$form.valid })}>\n    \n      // ...\n    \n\n);\n```. Have you tried setting the initial state of `.toto` to `2`?. @thomasboyt @zabojad You can just do:\n\n```jsx\n\n\n// or even\n\n```\n\nIs that not working for you?. It's in the [Control docs](http://davidkpiano.github.io/react-redux-form/docs/api/Control.html) but I'll add it to the FAQs:\n\n> You can add your own types to the basic `` component as an attribute: ``. Yes! It's one of the biggest reasons that you would implement forms with Redux in the first place.\n\nWhat specifically do you need help with?. > Allow branching (if you choose answer A, we go down one path. Answer B down another)\n\nHow would you solve this in React? Using React-Router/etc? That's the same solution that you would use.\n\n> Can I inject steps dynamically (if we make an API call, can I use the results from that to add additional steps into the form?\n\nYes, of course:\n\n```js\n// in render()\nconst models = ['foo', 'bar', 'baz'];\n\nreturn (\n  {models.map(model => }\n);\n```. Awesome! Feel free to share the code here too, would be great for others to learn from.. You have `show={{ pristine : false }}` which says to show the error message only when the model is not pristine. If the user never changes the value, the model is still pristine. Try removing that and see if it works.. If you can do number 2 I will merge that PR in ASAP. Thank you!. What have you found?. I believe this was fixed with #727. Please let me know if the issue persists - I was not able to reproduce it.. Does it work when you remove `updateOn=\"blur\"`? That could be the culprit, as it tells RRF \"only update the view value of this component whenever a user blurs from it\".. Can you try with the latest version?. And could you make a reproducible code example using this: http://codepen.io/davidkpiano/pen/yJwmEa would be really helpful! \ud83d\ude4f . Can you please post a reproducible code example?. Here's a similar library that might help:\n\nhttps://www.npmjs.com/package/react-redux-form-materialize\n\nAlso, mind throwing that up on CodePen? A template is available on the README or the issue template for you to use. I'd be better able to investigate what's going on.. One tiny lint error, can you fix it real quick?\n\n```\n/react-redux-form/test/model-actions-spec.js\nerror  Missing trailing comma  comma-dangle\n```\n. I have a probable fix that I can push later today or tomorrow.\n\nAs for a workaround, find some way to normalize the data; that is, use an object instead of an array.\n\nWhat's happening is this sequence of events:\n\n1) Email at index 1 is deleted\n2) Email at index 2 now becomes email at index 1\n3) Email at index 1 has its validity reset since it was deleted (even though that old \"email 1\" no longer exists)\n\nThe fix is to do some existence checking, but you can completely avoid the problem with this type of structure:\n\n```\nemails = {\n  1010: { name, email },\n  2020: { name, email },\n  3030: { name, email }\n}\n```\n\nwhere the email IDs are object keys. You can still iterate through them:\n\n```jsx\n{Object.keys(emails).map(id =>\n  \n}\n```. @galkinrost awesome idea, have you tried this in the current codebase? What would it look like?. What validation do you want?. Perfect!. Try this:\n\n```diff\n- formModel: combineForms({test:formReducer})\n+ formModel: combineForms({test:formReducer}, 'formModel')\n```\n\nYou need to tell RRF _where_ the form slice of state lives.. RRF doesn't know about other actions (of course) so I'm thinking of having it be a configurable option for `combineForms()`. Just need to figure out the API for it.. @greghawk Did you solve your issue?. I don't see in the code you showed me where you are logging the refs. In any case, you will need to use the prop `getRef={(node) => ...}` on ` I am using the reduxImmutableStateInvariant middleware. Is that a problem with using this library?\n\nNot too sure about that, can you copy/paste the error?. > @davidkpiano Uncaught Error: A state mutation was detected inside a dispatch, in the path: forms.$form.value.formModel. Take a look at the reducer(s) handling the action {\"type\":\"@@router/LOCATION_CHANGE\",\"payload\":{\"pathname\":\"/personal/FirstName\",\"search\":\"\",\"hash\":\"\",\"state\":null,\"action\":\"PUSH\",\"key\":\"rnpclt\",\"query\":{},\"$searchBase\":{\"search\":\"\",\"searchBase\":\"\"}}}.\n\nFrom what you showed me here, looks like the error might be related to `react-router-redux`.. Personally, I just call `history.push` (or from the `router` from context) and bypass Redux completely - I find it unnecessary to keep route state in two separate locations. Try doing that and see if it fixes your problems.. What version do you have? The uncontrolled warning was recently fixed.. Try 1.8.3 (latest) - if I recall, this particular issue was fixed in 1.8.2.. Just for comparison sake:\n\n> 1) adds additional fields with pre-filled values to the form\n\n```js\n// in an onClick handler, or wherever else:\ndispatch(actions.change('animals', animals => [\n  ...animals,\n  { animal_type: 'dog', name: 'New doggo 1' },\n  { animal_type: 'dog', name: 'New doggo 2' },\n  { animal_type: 'dog', name: 'New pupper 3' }\n]));\n```\n\n> 2) removes other fields, matching certain conditions, if those are present.\n\n```js\n// in an onClick handler, or wherever else:\ndispatch(actions.filter('animals', ({ animal_type }) => animal_type !== 'cat'));\n```\n\nAnd this works 100% as you would expect with dynamic fields \ud83d\udc36 . Here's how to get it working:\n\n```jsx\n props.modelValue,\n    focused: ({ fieldValue }) => fieldValue.focus,\n    onDateChange: (props) => props.onChange,\n    onFocusChange: (props) => ({ focused }) => focused\n      ? props.onFocus()\n      : props.onBlur()\n  }}\n  controlProps={{\n    numberOfMonths: 1\n  }}\n/>\n```\n\nYou can pass any control-specific props inside `controlProps`.\n\nFor `onFocusChange`, since it returns `{ focused: true }` or `{ focused: false }`, you have to help RRF interpret what that means (since React-Dates has no notion of \"blurring\" I suppose). That's why there's this:\n\n```js\nonFocusChange: (props) => ({ focused }) => focused\n      ? props.onFocus()\n      : props.onBlur()\n```\n\nHope that helps! I tested it in your repo and it works fine.. Which react errors are you getting? Can you open a separate issue for that?. Thanks for this! I'll take a look tonight and get a fix out.. What if I added `` ?. > Would you like help with that?\n\nYes please! I get to PRs pretty quickly, and can update the docs ASAP.\n\nIf you want to go ahead and make the other changes in a PR, I would be open to that.\n\n> Why make your Control component have to deal with two sources of truth, one in the Redux store and one on local component state?\n\nMany reasons, one of the most obvious being debounced values, change-on-blur, performance, etc.. I will definitely plan that for 2.0, as it would be a breaking change.. Simply dispatch `actions.change` or `actions.merge` (which allows you to change multiple fields at once) at any time:\n\n```js\ndispatch(actions.merge('user', {\n  firstName: 'Ada'\n  lastName: 'Lovelace'\n});\n```. @bryan-foong You can iterate over each of the fields:\n\n```js\nconst changedUser = { firstName: 'Ada', lastName: 'Lovelace' };\n\nObject.keys(changedUser).forEach(key => {\n  dispatch(actions.change(`user.${key}`, changedUser[key]);\n});\n```. Maybe... it's why it's good to batch (which is what `actions.merge` does). That said, there's nothing stopping you from merging yourself...\n\n```js\ndispatch(actions.change('user', {...user, firstName: 'Ada', lastName: 'Lovelace'}));\n```. @iBasit please post a reproducible CodePen or CodeSandbox example, and open a new ticket if you're having trouble.. You are using a default ``, which, when used with a custom component, makes no assumptions about that component. Replace `` with `` and it should work.\n\nI'll clarify the docs on this, but a plain `` was never intended to assume which props it can map to a custom component (it doesn't make sense to do so). This was a bug in earlier versions that has been fixed.. You're right, I'll revert that change.\n\nEDIT: And yes, `` will pass them @gmeans.. Reverted in [1.10.2](https://github.com/davidkpiano/react-redux-form/releases/tag/v1.10.2). Instead of using ``, use ``. Example from the [FAQs](https://davidkpiano.github.io/react-redux-form/docs/guides/faqs.html):\n\n```jsx\n fieldValue.valid\n      ? 'valid'\n      : ''\n  }}\n/>\n```. The fragile part of this is this: let's say you entered in `$1000` and expected `$1,000` to be the view value in a standard ``.\n\n- The parser needs to always convert `1000` to `$1,000`\n- The parser needs to _also_ know that `$1,000` converts to `$1,000`\n- The formatter needs to convert that `$1,000` back to `1000` and send it back to the store.\n\nAnd let's say you press backspace - your parser needs to be smart enough to know that `$1,00` should parse to `$100` so that your formatter can pick it up again. I can go on but this gets into some tricky logic where, if it's not perfectly in sync, can end up in an infinite loop.\n\nI highly recommend creating a simple custom component for this instead, something like this:\n\n```js\nfunction parseCurrency(value) { /* ... */ }\n\nfunction formatCurrency(value) { /* ... */ }\n\nconst Currency = (props) => (\n   props.onChange(parseCurrency(e.target.value))}\n  />\n);\n\n// rendered anywhere:\n\n```\n\nThe great thing about the above example is that it's more explicit and clear than using `parse` and (a nonexistent) `format`. But I'm curious to see how a `format` prop would look like to you - if you can make a compelling case (with good examples), I'd be more than happy to add it in.. Can you share the code?. I'm actually going to implement formatters soon. I realize it's a necessary feature.. @greghawk You can use a custom component as a stop-gap. What exactly is blocking you?. Of course! Just add the right hooks to your component to let RRF know when it updates, and keep the view value in your own component's state.\n\nThat is, RRF shouldn't care what the view value is. It only should care what the real value is. Even something like [react-maskedinput](https://github.com/insin/react-maskedinput) should work, same concept.. @brycesenz I'll accept it - if developers aren't careful, it can be a footgun, but I'm willing to give the feature a try!. Would you be able to put that code example in a Codepen (using this template)? http://codepen.io/davidkpiano/pen/yJwmEa Would be really helpful for debugging.. Can you post a full code example? At first glance, this doesn't even seem to be related to RRF.. I don't see in the code where React-Redux-Form is being used (if at all). Can you please update your example (if you are using it)? I will reopen this ticket then. Also, I do not see where `.selected_role.name` is even being called.. So, it'll recursively check something like this:\n\n```jsx\n\n\n\n\n\n```\n\nwhich works because the children are \"visible\" to the outer `` component. RRF has no idea what a `` is, so it stops there. I highly encourage you to use `` instead of ``, if you can.. Sure, I can do that. For your example, try this:\n\n```jsx\nconst VanillaText = (props) => (\n    \n\n\n);\n\n// rendered:\n\n```. It works perfectly fine, you just need to change one thing:\n\n```diff\nclass VanillaLastNameInput extends Component {\n  render() {\n    return (\nLast name:\n-     \n+     \n\n    )\n  }\n}\n```. > Will passing down {this.props} work for an arbitrary depth? \n\nIt's nothing magical; just as if you were passing props to any other component. When using ``, the standard props for `` (`onChange, onBlur, onFocus`, etc) are passed down.. > How should that work for multiple-checkbox inputs?\n\n```jsx\n\n\n\n```. Yes, haha:\n\n```jsx\n\n\n\n```\n\nwill give you `{choices: {a: true, c: true}}`. I'm open to PRs for this.. You can grab the `model` from the context:\n\n```jsx\nclass FieldWrapper {\n  render() {\n    const model = this.context.model;\n\n    // ...\n  }\n}\n\nFieldWrapper.contextTypes = {\n  model: PropTypes.any, // could be a string or tracking function, choose what works in your use case\n};\n```\n\nLet me know if that helps!. But what you're talking about is grabbing the model **contextually**, which means that you'd use `context`, no?. > In my case an alternative option might be to use a custom control, where the component renders both the label and the checkbox and copies all the wiring-logic that redux-react-form normally does.\n\nThis would actually be the simplest (and most idiomatic/pragmatic) option. Using `resolveModel` is meant for internal use, and you get the fully resolved model anyway available to you in `mapProps`:\n\n```jsx\n model }}\n/>\n// model will be the fully resolved model,\n// e.g., \"user.firstName\"\n```\n\nI'll add this to the FAQs. This way, we can keep the API surface area low.. > But then there is the question ``.\n\nI'd assume you'd have some wrapper component:\n\n```jsx\nconst PatientForm = (props) => (\n  \n    ...\n  \n);\n```\n\nAnd as far as your store, for most use cases you can just use `combineForms`:\n\n```jsx\nconst store = createStore(combineForms({\n    clinic: { /* your initial clinic state, same as JSON above */ }\n});\n```\n\nDoes that help?. In order to avoid creating multiple form reducers, that could be:\n\n```js\nconst store = createStore(combineForms({\n    entities: combineReducers({\n       patients: patientsReducer\n    })\n});\n```. Use `` - perfect use-case for it: davidkpiano.github.io/react-redux-form/docs/guides/local.html. Do you have a reproducible example that I can test?. Have you tried ``?. Good catch!. This is fantastic, thank you so much for undertaking this effort. I'll merge this PR in, and make a few subsequent changes just to be idiomatic:\n\n- Extract `shouldComponentUpdate` from `DefaultConnectedControl` so it can be used in its variants without them having to `extends DefaultConnectedControl` (which isn't idiomatic React). The result will be the same, just a tiny bit less DRY.\n- Determine if optimizations can be made for other components, such as `Form` and `Errors`.\n\nAgain, huge thanks for this! \ud83c\udf89 . Also, because you asked, the reason that `mapProps` are ignored is because it is assumed that `mapProps` is a configuration object that will never change. Each key/value pair in `mapProps` is a string and a function that takes in the **latest** props and returns the correctly mapped prop value, so there's never any danger of a component being out-of-date because of `mapProps`.. `` is probably fine for now. \ud83d\ude04 . Do you have the same issue when not using ImmutableJS?. Can you do me a favor and try this:\n\n```jsx\n !!(val && val.length) },\n  }}\n>\n```. Makes sense, thank you!. Good catch \ud83d\ude05 . Because it's a ``, it does _not_ know about outside Redux store (this is by design, and is why you would use a `` over a normal ``.)\n\nTo display the error message, you just need to get the internal dispatcher of the local form:\n\n```jsx\nclass UserForm extends Component {\n  getDispatch(dispatch) {\n    // attach dispatch anywhere you can access it, even this.setState({ dispatch })\n    this._dispatch = dispatch;\n  }\n  handleSubmit(values) {\n    // do something with the values\n    setTimeout(()=>{\n      this._dispatch(actions.setErrors(\"login\",{api:\"API ERROR\"}))\n    }, 2000);\n  }\n  render() {\n    return (\n       this.getDispatch(dispatch)}\n        onSubmit={values => this.handleSubmit(values)}>\n        \nFirst name:\n\n\n\nLast name:\n\n\n\n\n          Submit (check console)\n        \n\n    )\n  }\n}\n```\n\nThis will work \ud83d\udc4d (I tried it!). I think the better fix would be to do something like:\n\n```\n## `actions.change(model, value, ...)` {#actions-change}\n```\n\nand use explicit headings, according to here: https://github.com/GitbookIO/gitbook/blob/master/docs/syntax/markdown.md#headings\n\nWhat do you think? I'd greatly appreciate if you made that fix :). Fantastic, thank you!. Hmm... the issue with that is that if the model value doesn't change for invalid values, the field would never know why it's invalid. It would just show as invalid, with an empty (or previously valid) model value. How would you expect this to work, re. desired API, etc.?. @caesay is correct. This is intended behavior. . @mikkelwf I'm unable to reproduce the original issue:\n\n![aug-16-2017 15-43-42](https://user-images.githubusercontent.com/1093738/29382183-d300a22a-8299-11e7-88d9-917a4aa9a282.gif)\n. Can you try this in the latest version, 1.11.1?. Yes, it is:\n\n```jsx\nclass MyInput extends Component {\n  render() {\n    return \n  }\n}\n\n// rendered somewhere\n\n```\n\nI'll update the docs to make this clear.. Thank you!. What is your use-case for wanting `dispatch` in there?\n\nAlso, `changeAction` is _completely_ agnostic to what you return from it. It accepts an action creator, or an action thunk creator, or anything else if you're using something like `redux-saga` or `redux-observable`.. You can make a custom control that includes the parent div. See the FAQs for this, in combination with a custom component: http://davidkpiano.github.io/react-redux-form/docs/guides/faqs.html\n\n```jsx\nconst MyText = (props) => (\n  \nPr\u00e9nom\n\n    {props.children}\n  \n);\n\n// rendered...\n ({ valid }) => valid ? 'error' : '' })\n>\n  \n\n```. Can you share your code?. Can you try this in the latest version?. Hey @kkashou, see this answer: [How do I add conditional class names based on field state?](https://davidkpiano.github.io/react-redux-form/docs/guides/faqs.html). Can you create a reproducible example of this undesired behavior?. Seems like something that should be fixed. I suspect the sequence of events right now is:\n\n- Form is submitted\n- Field is blurred (by this point it's too late)\n\nso I'd have to add some logic that triggers validation on fields before submit... which can be really tricky if we take async validation into account as well.. Can you open a separate issue for that so that it doesn't get lost, @cipater ?. I don't think this should be handled by the library, especially since it's a very specific use-case and non-trivial. However, you can [add class names based on field state](http://davidkpiano.github.io/react-redux-form/docs/guides/faqs.html#how-do-you-add-conditional-class-names-based-on-field-state) pretty easily:\n\n```jsx\n !fieldValue.valid\n      ? 'invalid'\n      : ''\n  }}\n/>\n```\n\nLet me know if that helps.. @stevenmason can you whip up a quick CodePen example for that?. This is expected. `parser` is how the value ends up as a model value, not as a view value. That the control displays that value is a side-effect of this - it's just displaying the view value as it appears as a model value. This sounds like something you'd need to make a custom control for.\n\nHere's a timeline explanation for a debounced control:\n\n- (0ms) Type `foobar`\n- (1ms) `foobar` is shown as the view value\n- (100ms) `foobar` still\n- (800ms) view value parsed and saved to store as model value of `foobar1234`\n- (801ms) control detects that view value doesn't match model value, so it updates the control\n- (801ms) `foobar1234` shown. It's not a use case that makes sense. Think about it - let's say you type the letters `abcde` in an input. If you debounced the view value, you'd see:\n\n- `a`\n- `a`\n- `a`\n- `a`\n- `a`\n- `abcde` after 300 or so milliseconds. The way `mapProps` works is that it defines a mapping between \"standard\" change props (such as `onChange`, `onBlur`, etc.) and custom ones. For performance reasons, it's also \"cached\" so RRF assumes that the mappings (which are all functions) never change.\n\nThese look to be props outside of that use case, so I would recommend defining them directly on the control:\n\n```jsx\n     this.setState({ stateValue })}\n    />\n```\n\nLet me know if this works for your use case.. Can I see how your store is defined?. Also, can you try to reproduce it on Codepen? (link available in the readme). Easiest way is to pass in a function to the `` prop and only render a single child:\n\n```jsx\nfunction ErrorsWrapper({ children }) {\n  return {children && children.length > 1\n    ? children[0]\n    : children\n  };\n}\n\n// render\n\n```\n\nPersonally, I'd just use CSS on a special errors class, something like this:\n\n```css\n.errors > .error:not(:first-child) {\n  display: none;\n}\n```. I'm getting this error: \n\n```\nreact.min.js:14 Uncaught TypeError: Cannot read property 'split' of undefined\n```\n\nwhen trying your example. Can you fix it?. If you want validity to persist between pages, set `persist={true}` to all `` props where you want validation to persist. Otherwise, `resetValidity` will be dispatched whenever a Control component unmounts.\n\nLet me know if this fixes your issue.. Sure! The `validators` prop on `` can be a function, so you can have something like this:\n\n```jsx\nfunction emailValidator(value) {\n  if (value === undefined || !value.length) {\n    // don't show validEmail as invalid if value missing\n    return { required: false, validEmail: true };\n  }\n\n  return {\n    required: true,\n    validEmail: isValidEmail(value) // external function\n  }\n}\n\n// render...\n\n```. Might be a bug, can you share some code?. Can you try this in 1.11.1 ?. Closing this due to inactivity (and it was most likely fixed in 1.11.1). If you want me to look at this, please provide a code example. Thanks!. Can you share a full reproducible code example? Generally, when you are making a deep validator in a `` component, it's of this form:\n\n```\n\n```\n\nand so on. That way, RRF knows that the first key is the model, and doesn't try to make assumptions about the other keys.. That's enough - I'll plan it for the next minor version. I think it would be much more intuitive.. What does your `store` setup look like? Your entire form and model state is in your Redux store, so you can just use `connect()` to get the pieces of data that you want: http://redux.js.org/docs/basics/UsageWithReact.html. If you could put that in a Codepen that would be great (template here: http://codepen.io/davidkpiano/pen/yJwmEa ) but I suspect the infinite loop has to do with `componentWillReceiveProps`, because you're dispatching actions that can change props.. Glad to help!. Shouldn't matter, `` is only a thin wrapper around the native ``.. Do you need to use ``? If not, avoid it, use a plain button.. With normal forms and inputs, this is the default behavior - RRF is not the cause of this behavior (that pressing `Enter` will submit a form). To solve this in vanilla React, you would have something like this:\n\n```jsx\n {\n  if (e.key === 'Enter') e.preventDefault();\n}} />\n```\n\nWith a small change that I need to make, you would do the same in RRF:\n```jsx\n {\n  if (e.key === 'Enter') e.preventDefault();\n}} />\n```\n\nWould that suffice? You can always make a higher-order component that automatically adds this.. @mikkelwf @TimFletcher Can you please make a tiny reproducible example of your issue using the Codepen template? It's much easier to quickly fix these issues when I already have the fully reproducible code example.  \ud83d\ude04 . Related to #798, I'm pretty sure. It should be fixed, please grab the latest version and see if it's resolved!. @popstheman Please open a new issue with that, and if you can dig around and have an idea of what the fix is, feel free to open a PR.. The only instance I could find is here:\n\n```js\nconst findDOMNode = !isNative\n  ? require('react-dom').findDOMNode\n  : null;\n```\n\nAre you sure you can't use this without `react-dom`?. I'll make a fix for that.\n. @nextriot would you be able to make a new PR for it? I can merge it in ASAP.. You can work around this: https://remarkablemark.org/blog/2017/02/25/webpack-ignore-module/. Are you specifically referring to this line (in `getFieldFromState`, aka `getField`)?\n\n```js\nif (isPlainObject(field) && '$form' in field) return field.$form;\n```\n\nIf the check was `(isPlainObject(field) || Array.isArray(field)) && '$form' in field)` it would mitigate this problem, correct? Or is this a larger problem?. Thank you! Would you mind changing the tabbing from 4 spaces to 2?. Ah, never mind then. I'll merge it as is, thanks!. Looks like this was already done. \ud83d\udc4d . Could not reproduce - with the latest version (`1.11.1`) no infinite loop occurs.. Hmm no I didn't. There was an error:\n\n```\npen.js:81 Uncaught ReferenceError: noOp is not defined\n```\n\nso I just replaced it with `() => {}`.. Is there a way for you to isolate this in a reproducible example? (You can use the CodePen template above). Ping @divined, were you able to create a code sample?. No worries, I fixed it! Details are in the release notes for `1.12.0`.. This sounds like something that's a good idea - I'll get it done this weekend.. Thanks! You're right.. Is there a reproducible code example you can share? This typically doesn't happen because either:\n- the _full_ initial state was provided to the form reducer (e.g., `combineForms`) which will set up the fields correctly\n- all present fields are rendered (e.g., ``) which will trigger an initial `LOAD` action upon mounting.\n- both, usually.\n\n. Can you show me some example code of this? There's various things you can do to alleviate this behavior, and many optimizations that RRF tries to make to prevent unnecessary rerenders, so it is possible that something you're doing is invalidating one of those optimizations.. The quick fix for this is changing this:\n\n```diff\n-lang: null,\n+lang: '', // or lang: undefined\n```\n\nIn fact, React will warn you if you try to use `null` for an input value. Changing it to an empty string or `undefined` seems to fix the behavior.\n\nPlease let me know if this also fixes your larger issue that you mentioned.. You can use [`formNoValidate`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-formnovalidate) to disable HTML5 constraint validation on an input.\n\n**Note:** this is a native HTML5 attribute, not a RRF-specific prop \ud83d\ude04 \n\n```jsx\n\n```. Is this still an issue? You closed the ticket. > Even if you don't change the value, the onBlur event still triggers (clicking inside one text field, then inside another);\n\nThis is expected behavior - we can't make a restrictive assumption on this.\n\n> When the onBlur triggers, even if the value did not change (still \"\"), it re-renders the form.\n\nThis could be because the field state is changing `touched: false` to `touched: true`, but I'll investigate why it rerenders if you can provide me a code example.. @jdelafon That's awesome to hear! Maybe you were on an older version? I know that we've made a _ton_ of performance improvements in the last few minor versions.. @jdelafon It's because of the way React works - since it's a tree model, any update in state will cause _all_ of the child components to ask whether or not they should update.\n\nWhat React is smart at is knowing when not to **update** (and this is tweakable in `shouldComponentUpdate`).\n\nWhat React is _not_ smart at is knowing when not to **ask** when to update. Calling `sCU` for every single child element, even if it returns `false` for 99% of them, can be very slow. You're still calling a function 600+ times (in this case).\n\nWith the way React works, it's definitely not easy to say \"I'm only going to update this **one** component - all you other components, don't even bother asking if you should update.\" \n\nA functional/reactive paradigm is what spreadsheets, like Excel, would use. Every cell explicitly knows what other cell/entity to _subscribe_ to, and knows that whenever that thing that it's subscribed to emits an event, it will update. No other cell in the spreadsheet will even blink an eye. It's push-based, not pull-based.. Shouldn't be pointing there - it should be pointing to `node_modules/shallow-compare/lib/index.js`. Try these two things:\n\n1. Exact version: `\"shallow-compare\": \"1.2.1\"` (note missing caret)\n2. `rm -rf node_modules && npm install`. This is expected behavior, and here's why.\n\nIn this scenario, the `.name` is required - you want to ensure the user has entered a name before submitting the form. In order to ensure that, validation _must_ run when the component mounts, even if validating on blur.\n\nWhy? If validation does not occur, that means that `.name` is valid, without it being touched. So when you try to submit the for, you will be able to submit an empty `.name`, even though that's supposed to be invalid.\n\nCan you walk me through your use case?. You can probably pass `UIForm.Input` as a [custom control](http://davidkpiano.github.io/react-redux-form/docs/guides/custom-controls.html). From there, you can map props to the custom control and have access to the field's `.touched` state, so you can show errors only when the field is `touched && !valid`.. That seems like a good solution. Alternatively, you can use the **How do you add conditional class names?** strategy in the FAQs: http://davidkpiano.github.io/react-redux-form/docs/guides/faqs.html. Can you make a reproducible code example? Most likely, something isn't mapping to `onBlur` in your custom control. That's how RRF knows that a control has been touched.. Nope, looks good! By the way, you can use `` for `` and `` for ``.. > do you have any input on requiredError returning true after a failed submit?\n\nCan you elaborate?. @sonarforte If that's a different example, can you make a reproducible example of that on Codepen too?. Solved the issue, see below. The input-specific props were not being passed in. Here's how you can refactor:\n\n```diff\nconst UIInput = (props) => {\n+  const { error, label, ...inputProps } = props;\n\n  return (\n    \n{error ? \"Error\" : label}\n+    \n\n  )\n}\n```\n\nHopefully that's clear! Custom components can be tricky.. Can you make an example using the CodePen template? (see the readme) \ud83d\ude4f thanks!. You can also use www.esnextb.in or www.codesandbox.io with `import { ... } from 'react-redux-form/immutable'` to recreate an example.. @yborunov Can you make a list of these in a separate issue? I will start adding more helpful warnings in development builds.\n\nThank you!. Makes sense, thank you for catching this!. Sure thing, greatly appreciate it. I'll release a patch when the PRs are all in.. It's probably because you're destroying the entire `LocalForm`, not just the control. I'll investigate further.. > Would you like me to create a new issue around this? I'm somewhat hesitant to do this, as I can't rule out that I'm making a stupid mistake somewhere, but I intuit that this might be worth investigating. Thanks again for your effort and support!\n\nPlease do!. I'll have to see how performance is affected with this. Can you elaborate more in how exactly the performance optimizations were preventing context updates? Maybe we can work around it without sacrifices.. > I can declare contextTypes on DefaultConnectedContol though, and then check if they've updated in shouldComponentUpdate. But it seems hacky for thic component to know anything about context props used in resolveModel.\n\nThat might be an idea. The reason for `resolveModel` is that React-Redux's `connect()` doesn't know anything about `context`, unfortunately. If it did, that would fix the issue, as we can do resolved model-checking logic in there.. Looks good, thanks for adding the sCU logic back in!. This is because of the assumptions that:\n- async validators always run _after_ sync validators are done running (hence, *async*)\n- async validators shouldn't run when the field is invalid (no point in async-validating a field that's already invalid).\n\nThis is an edge-case, but I'll still provide a fix, by forcing async validators to run when `asyncValidateOn === validateOn` (that is, when both types of validators run at the same time).. @greghawk Probably a separate issue, can you open a new one for this enhancement?. Looks like this is no longer reproducible in the latest version! \ud83c\udf89 Please reopen if you encounter this again.. > The situation with React forms is so sad.\n\nCheer up! All you have to do is suggest features and make PRs.\n\n> So the only thing I wanted to ask is if it's possible in the next versions (maybe in 2.0) to make it work more like RF works (or make it optional)? I really like the activity and responsiveness in RRF.\n\nCan you make a list of specific features that you would like to see?\n\nAlso, funny enough, if you use ``, you can get a form like you have above working with RRF, and with a bonus: you don't even have to set up Redux. At all.\n\n```js\n// there's better ways to do this; I don't like how\n// Redux-Form uses a single function. That means you have to recalculate\n// every single field's validity on every single change.\nconst validate = values => {\n  const nameValid = values.name && values.name.length > 0;\n  const emailValid = values.email && isValidEmail(values.email);\n\n  return { name: nameValid, email: emailValid };\n};\n\nconst handleSubmit = values => console.log(values);\n\n// in render\n\n\n\nSubmit!\n\n```\n\nYou can't get much simpler than that. \ud83d\ude09 . > setup store once. No need to return to it when a new form is added.\n\nCan you elaborate on this? You only need a one-time setup with RRF too.\n\n> no initial values in store creation. Same as above, setup store once, never come back when form is added / initial values are changed\n\nSame thing, you can create forms dynamically without needing to change the structure of the store.\n\n> forms are not persisted in store. Created when form is mounted, removed when form is unmounted (lazy flag?)\n\nThat's what `` is for - non-persistence. Forms persisting in the store was an intentional design decision - this is a library for making complex forms easily, which includes multi-step wizard forms.\n\nAs I showed above, you _can_ use a single function, just like in RF, to do your validation. It's just not recommended (yes, there are big performance concerns).\n\n> how do you get form props, like submitting prop?\n\nUse `onUpdate`, which gives you the entire `form` state (including the `pending` prop for when a form is submitting), and do whatever you want with that state (save it to component state, etc. http://davidkpiano.github.io/react-redux-form/docs/guides/local.html. Okay, let's see how we can improve or utilize the existing API to make things easier, like you said.\n\n> In RF you setup store once and never come here again\n\nTry this:\n\n```js\nconst store = createStore(combineForms({\n  forms: {}\n});\n```\n\nThat's all you need to do. Want to create a dynamic form? It'll happen automatically, e.g., if you do something like:\n\n```js\ndispatch(actions.change('forms.surpriseNewForm.whatever', true));\n\n// will create:\n{\n  forms: {\n    $form: {  },\n    surpriseNewForm: {\n      $form: {  },\n      whatever: {  value: true }\n    }\n  }\n}\n```\n\n> Since I very rarely have wizard forms, I always wanted to clean my store in RRF.\n\nFair enough. Would adding a prop make this easier?\n\n```jsx\n\n```\n\nWhen `transient === true`, on `componentWillUnmount`, an `actions.reset` action can be dispatched automatically. If you want, I can add this prop. Would take me 5 minutes.\n\n> In RF you use HOC and this props are passed into your form which I find very convenient.\n\nIt's convenient but way too magical, and with:\n- potential unwanted prop overriding\n- your _entire form_ will update on every single change. Bad for performance.\n\nBut if you wanted to, since _it's just Redux_, you can just have something like this:\n\n```js\nclass UserForm extends Component {\n  // ...\n}\n\nconst mapStateToProps = ({ forms }) => ({\n  form: forms.user.$form\n});\n\nexport default connect(mapStateToProps)(UserForm);\n```\n\nThat's very unmagical, but does the exact same thing (under the `form` namespace) and provides the entire form state to you.\n\nWould you want me to add a helper decorator, such as `@withForm('user')`?. @icopp @VladShcherbin How does this future API look to you?\n\n```jsx\n\n  // ... \n\n```\n\nBehind the scenes, this will call `actions.load('user', {...})` to populate the initial state. I'm opting to call it `initialState` to:\n- maintain parity with ``\n- keep consistency with Redux's notion of initial state, which is what this is.\n\nWould this help you move to a better workflow? With this, you wouldn't have to specify initial state in Redux:\n\n```jsx\nconst store = createStore(combineForms({\n  user: {}\n}));\n```. Well currently, you can just dispatch `actions.load('articleForm', article)` once the data is resolved.. > When are the initial value set?\n\nWhen the store is initialized, same as initial state in Redux.\n\n> Is it required (or at least recommended) to declare the schema up front?\n\nYes, but it's not required. Forms can be fully dynamic.\n\n> Is it possible to unload a form (and remove it from the store)..? ... I cannot use a LocalForm instead, because i access the store data within the form itself, to manipulate flow and the components shown.\n\nYou can always `connect()` a component that includes a ``, nothing stopping you from doing that. And you have `onUpdate` and `onChange` hooks to do whatever you want to the updated form/model states inside a local form.\n\n> Where does a Control get its initial value from?\n\nFrom the Redux store. Simple as that.\n\nI'll investigate those issues you listed and see if they're relevant to the confusion you're facing. Sorry about that!. Right, forms are notoriously complex on the web. There's so many different use-cases, it's hard to have a one-size-fits-all solution (but I try!!)\n\nV2 will make the internals much simpler, while keeping mostly the same API. It will be written in TypeScript.. A PR would absolutely be helpful, especially for the Native parts. I don't use React Native primarily in my job, and RRF is supposed to be an abstraction that works naturally with it, but it would be good to have documentation on that. I will add a section on initializing from state in the documentation.. > For instance, I'm convinced that first-class schema support would be a huge boon.\n\n100% agree. Anything you can point to that demonstrates a great example of that?\n\n> A model definition is not exactly a UI concern, and being able to share schemas across forms is huge.\n\nI agree with this too. I'm moving away from UI-centered models in V2.\n\n> I get that error messages are a UI layer thing, but being able to specify reasonable defaults at a higher level, and then overriding them in the UI as necessary is my preferred strategy.\n\nWhat would an ideal API for this look like to you?\n\n> I'll do my best to give you constructive feedback. Thanks a lot for all of your efforts.\n\nI sincerely appreciate it!. You can use an existing reducer in `combineForms`. Check out the bottom of this page (under **Using Existing Reducers**) and see if that helps: http://davidkpiano.github.io/react-redux-form/docs/guides/models.html. I don't know exactly what each of the variables are, but try this:\n\n```js\nconst rootReducer = combineForms({\n  calculators: initialCalculatorsState, // or formsState if that's what that is\n  favourites: favourites,\n});\n```. Interesting, can you isolate the case where using `initialState` with `createStore` causes it to break, and file an issue? I'd greatly appreciate that!. Sure, please file this as a separate bug.. So this is an interesting case because even with `` and/or `` in HTML5 constraint validation, the input will still validate; i.e., `.willValidate === true`. This is per the spec - despite `novalidate` and/or `formnovalidate` the control is not barred from constraint validation.\n\nHowever, per the HTML5 spec:\n- `` will always submit, even if controls are invalid\n- `` can still be invalid, but won't prevent the form from submitting alone\n\nTo address your issue, I added some careful (and small) logic for handling `noValidate` and `formNoValidate`:\n\n**Form noValidate:**\n- If `noValidate={true}`, then the `` _will_ submit even if the form is invalid. This is in line with the spec, and is useful when you want to liberally allow the user to submit a form but also make the user aware of any validation problems.\n- This does _not_ preclude validation errors from showing. They will still show, but they'll essentially be treated as warnings, not errors.\n- The `noValidate` attribute will still be passed on to the native ``.\n\n**Control formNoValidate**\n- If `formNoValidate={true}` on the ``, then HTML5 validity will not affect the field's validity.\n- No checks will be run to sync the HTML5 validity state of the control with the field validity state controlled by RRF.\n- This _will_ allow you to prevent error messages from showing for HTML5-specific validators, and allow your `` to prevent submission if any of the inputs is invalid for your own custom validators.\n\n```jsx\n// noValidate on Form\n\n// handleSubmit will always be called upon submit\n\n\n\n\n\n\n// formNoValidate on Control\n\n// handleSubmit will be called if control is valid per custom validators,\n// not per HTML5 constraint validation\n\n\n\n\n\n// noValidate on Form and formNoValidate on Control\n\n// handleSubmit will always be called\n\n\n\n\n```. > Btw. that really good answer/description deserves a place in the documentation, at least under the FAQ..\n\nGood call!. Probably today or tomorrow at the latest. There's a few more fixes I want to get in.. @peterox The behavior seems correct -- I don't believe this is a breaking change. That is, if you use `noValidate` on your form, it _means_ that it can be submitted according to the HTML5 spec.. @klis87 I like this idea:\n\n> One of ideas would be to add new prop to Form, for example `onValidSubmit`. This would be in sync with HTML5 spec, because `onSubmit` would work as in specs, and this additional callback would be good combination with `noValidate`.\n\n@peterox what do you think of the above? The behavior would be that:\n\n- with `noValidate`, `onSubmit` will _always_ be called (this is supposed to happen, according to the spec)\n- with or without `noValidate`, `onValidSubmit`will never be called unless the form is 100% valid.\n\nWould that fix your concerns?. I agree @peterox. I'll make the addition, add documentation, and bump the minor version up.\n\nSorry for the confusion. The previous behavior (quelling any HTML5 validation popups _and_ still having validation prevent submit) should not have been possible (because `noValidate` means \"do not validate, and let the form always submit\"; hiding the error messages was just a side-effect of that) so it was a bug that turned into an accidental feature. \ud83d\ude16 . @peterox Actually, I found a better solution, that is _much_ more idiomatic (that is, it doesn't require a new magical prop for React-Redux-Form).\n\nIf you want to hide native HTML5 validation errors for a form that should still consider the validity before submitting, **do not use `noValidate`** - it does not mean what you think it means.\n\nInstead, use the native `onInvalid` event handler to prevent the message from showing up:\n\n```jsx\n e.preventDefault()}\n/>\n```\n\nI'll add this to the FAQs.. @peterox I can't replicate this. The below code works perfectly fine:\n\n```jsx\n\n e.preventDefault()}\n  />\n  \nSubmit!\n\n```. @peterox Interesting, can you please open up a separate issue about this? This is more a use-case that hasn't really been explored rather than a bug, but I'm keen on fixing it.. @klis87 Can you open a fresh issue with that?. Can you make a quick reproducible example? Use this as a starting point: http://codepen.io/davidkpiano/pen/yJwmEa. Do you have the latest version of RRF? I recall a similar issue a while back (can't find it now) that has been addressed.. > hm, for some reason I can't reproduce this bug in codepen, errors works fine there\n\nMarking this as \"can't reproduce\", please submit a CodePen example (with the latest version) if you are still able to reproduce it.. Hmm, I'm wondering if the responsibility of this should fall on the developer rather than the library. It's easy enough to do this:\n\n```jsx\nUser name\n\n```\n\nOr this:\n```jsx\n\nUser name:\n\n\n```\n\nBoth would solve the issue. What are your thoughts?. Alternatively, it might be useful to have this automatically be done with a new component:\n\n```jsx\n\nUser name:\n\n\n```\n\n^ This will also allowed it to be used in React Native, where tapping the label would \"focus\" the text input, much like how it works on the web. How does this look?. > Whatever created by the reducer should not be overwritten and instead be merged into the initialState\n\nI'm not sure that was ever intended behavior with React Redux. Regardless, the CodePen example seems to work fine with the latest version of RRF.. That's really weird. If you do this:\n\n```jsx\n\n\n\n```\n\nwithout the intermediate components, do you still get the error?. This sounds like a general testing issue, not specific to RRF. Please make sure that `jsdom` is set up correctly. You can take a look at the unit tests inside RRF to see how that's set up.. There shouldn't be. If you can point me to your code base (or a reproducible example) I'd be able to help better.. The issue is that no input-specific props (`onChange`, `onBlur`, `onFocus`, etc.) were being passed into the actual input. Here's how you can refactor:\n\n```diff\nconst UIInput = (props) => {\n+  const { error, label, ...inputProps } = props;\n\n  return (\n    \n{error ? \"Error\" : label}\n+    \n\n  )\n}\n```. This will be fixed in the next version \ud83d\udd1c \ud83c\udf89 . Might be a bug, but you don't need `` there, a normal `` will suffice.. Do you have a fully reproducible code example? Also, you can have this right on the `validators` prop:\n\n```js\n isEdit ? true : isBankNameValid(value) }}\n/>\n```. Were you not able to replicate it?. Hmm, I couldn't get it to fail in the CodePen either.\n\nA workaround would be for you to use a custom validator instead of `required`, have you tried that?. @jdelafon With the below code, I was _not_ able to reproduce your issue:\n\n```jsx\n console.log(val)}>\n  \nSubmit!\n\n```\n\nThis will successfully show an error when the value is missing, and successfully submit the form when the value is not missing. Are you doing anything different? (assuming an initial state of `user: { name: '' }`. What is an example of what is generated by `makeOptions`? I'll try to reproduce it with ``. Latest version is 1.12.1, please try with that \ud83d\ude04 . @jdelafon Were you able to reproduce this with the latest version? Please let me know and I will reopen the ticket.. > The same happens to me. Any updates?\n\nI'm currently looking into this.. @k4zuk0 Sure, I'll do it soon.. What precludes you from having `asyncValidateOn=\"blur\"` (which is the default), if it's too expensive? By having `asyncValidateOn=\"change\"`, that means exactly that you want async validators to run on every single change.. @greghawk Backtracking a little... would it solve your problem if async validation was always called on submit (whether via enter key or otherwise) and the form prevented from submitting until the async validators passed?. @greghawk Are you on the latest version?. Can you put those newer issues on to a new issue?. Behavior like what? Validation? Model changes?\n\nTake a look at the very first section of [custom controls](http://davidkpiano.github.io/react-redux-form/docs/guides/custom-controls.html). There, you see one of the main benefits of React-Redux-Form: **you can handle absolutely everything in your own way.**\n\nHow? Nothing about RRF requires you to use `` or ``, etc. Those are just conveniences. Instead, you can `dispatch(actions.change('user.name', 'whatever'))` whenever you want, as well as handle practically any other form aspect from actions that **you can dispatch yourself**, whether it's `actions.setErrors('user.name', 'invalid')`, `actions.reset('user')`, etc.\n\nRRF is a library, not a form framework. You can use as much or as little of it as you want. . Thanks for the kind words, @klis87! Have you seen the section titled \"How do I add conditional class names based on field state?\" [in the FAQs?](http://davidkpiano.github.io/react-redux-form/docs/guides/faqs.html) \n\n```jsx\n fieldValue.focus\n      ? 'focused'\n      : ''\n  }}\n/>\n```\n\nI once considered a prop like you suggested (see #441 #509), and decided against it for a couple of reasons:\n- would add much more code to the codebase (V2 is focused on dramatically reducing the amount of code)\n- would be too magical/inflexible\n- `mapProps` is perfect for this use-case\n\nThe third point is especially important - what if you want to have a dynamic class name only applied to an inner child component in a custom control? E.g., \n\n```jsx\n\n\n\n```\n\nHopefully the solution above works for your use-case!. > Also, did you consider removing errors prop from Control component?\n\nYes, I did. I think the duplication is unnecessary as well. I think it will be removed in V2.. Want to make a PR? I'll merge it in ASAP.. @rahulbasu710 @andrewhl If it's a simple fix, mind making a quick PR? I'll merge it in ASAP.. Fixed by #938 . @andrewhl Yes, I do believe that the native wrappers can be improved. If you would like to do that in a PR, that would be excellent!. One quick question, couldn't you just do this?\n\n```jsx\n\n// .. etc.\n```\n\nwhich is the same as `delegate=\"TextInput\"`. Did this not work?\n\nAs far as testing, when I first wrote this, it was difficult/impossible (?) to write tests for React Native components, but I will be switching over to Jest which might make this easier.. Awesome, this can be merged as soon as CI passes. \ud83d\udc4d . Can you make a reproducible CodePen example? You should be able to use your own reducer and have it work normally. \n\n> The problem is that with this reducer declaration, the action never gets called\n\nWhich action are you talking about?. Do you mean having RRF somehow recognize that your own `ADD_CART_ITEM` action is triggering a change on the model, and handling the form state appropriately (which it is not doing right now)?. That's coming in version 2 - it's not the easiest problem to solve, in any form library, because RRF has no idea what an ADD_CART_ITEM action is \ud83d\ude05 . > Couldn't you just take in an array for other reducers before executing your own?\n\nWhat would this accomplish?\n\nAnd no, the tricky part is (performantly) doing a diff on slices of state to determine what has change on each state transition.. If you're doing validation based on more than just one value, it would be a **form-level validator**. Look here for more info: http://davidkpiano.github.io/react-redux-form/docs/guides/validation.html\n\nForm level validators, of course, have access to all of its fields' values.. I'll mark this as an enhancement. What would an ideal API for that look like to you?. > One more question: Is the RRF context object documented anywhere? Is there an HOC that grabs it?\n\nIt's just the Redux store, there's no specific RRF context object (at least not in V1).\n\nAlso, the potential issue with passing in the entire object is that validation based on other fields needs to also be _dependent_ on other fields changing as well, so just naively passing the parent form values is a no-go (unless we want a lot of unnecessary rerenders).. Oh, for `.email` yes, there is a `model` context that is read.\n\nHere's what I'm thinking for a potential API (v2), which will be reactive-based:\n\n```jsx\n// models (function) has the signature:\n// (string | string[]) => Observable\nimport { models } from 'react-redux-form';\n\n// ...\n\n pass === confirmPass)\n  }\n/>\n```\n\nBy using Observables, we can ensure that this control is only re-rendered when either the `user.pass` or `user.confirmPass` models are changed.\n\nThere will also be a similar `fields` function that returns an Observable.. > I really don't want to enter Rx land just to declare form structure and behavior!\n\nThen what would your ideal API be? IMO the one I proposed is very concise.\n\n> I'm still not understanding why you'll get a re-render if the whole state is passed to the validator\n\nLet's say you're validating that two passwords match, `user.pass` and `user.confirmPass` and the validator that checks _both_ of these models belongs to `user.pass`.\n\nIf you tell RRF (somehow) that you only want to \"listen\" to *only* `pass` and `confirmPass`, then the validator will run whenever only `pass` or `confirmPass` changes, as expected.\n\nIf you don't tell RRF and instead you pass the entire state, the validator will need to be run any time _any part_ of the state changes, because the validation function becomes a black box that doesn't immediately know which fields it's supposed to care about.. > The validator may re-run\n\nRight, I don't want that to happen. Validators should only run when they need to. Validation can be expensive.. That increases the API surface area. Going back to my initial proposal, the above can easily be abstracted to something like...\n\n```js\nimport { validateWith } from 'react-redux-form'; // future API?\n\n// ... in render\n\n pass === confirmPass\n  )}\n/>\n. How is your store set up? If you just set up a simple `createStore(combineForms(...))`, then your form state will be under the `forms` key. So you can grab your form validity state under:\n\n```js\nconst mapStateToProps = (state) => ({\n  userFormValid: state.forms.user.$form.valid\n});\n\nconnect(mapStateToProps)(MyForm);\n```\n\nAnd then use that:\n\n```jsx\n// in render()\n\n  Submit!\n\n```\n\nThe easiest way to do it would be to use ``:\n\n```jsx\n\n  Finish registration!\n\n```. Can you share a reproducible example? It should work. When you fire an `actions.change('foo.bar', { ... })`, it should automatically create the form and field states for `foo` and `foo.bar` in the `forms` slice of your state.. I'd need to see a full code example.. Sorry, I'd need to see a full code example in a CodePen or CodeSandbox (makes it way easier to debug).. I'll have to give this a tiny bit more thought. Are there use-cases where developers _expect_ `actions.submit(model)` to force-submit the form, no matter what?. The first option seems like the simplest way to go - hopefully, we can avoid adding extra props. In the future, we can consider something like `actions.forceSubmit(model)`.. Try `actions.remove('user.friends', 3)` where `user.friends` is an array and `3` is the index/key. Also works with objects. This should remove the field as well.. Might be a few days before I get to this. The code isn't that complicated, so if you want to dig around and propose a solution as a PR for having `actions.remove(...)` work as expected, I'd be happy to merge that PR in ASAP if all the tests pass.. > I just ran into this as well. I'd like to see a better API for this for LocalForm... but it seems the current way to do this is:\n\n@cipater What's your ideal API for this?. I'll keep that in consideration!. @KubaChoice Good idea, open a new issue (or better yet, a pull request! it's not too hard) for that please \ud83d\ude4f . It is the intended behavior, because the semantics of changing a model and resetting it are a little different, in that in most use-cases, you want to handle when the user _modifies_ a model, and it's sort of a gray area as to whether or not resetting counts as modifying a model.\n\nWhat do others think? Should the `change` action fire when a model is reset?. Here is a related issue: https://github.com/facebook/react/issues/1152. Thanks so much for the write-up, @jmeas!. Hmm, this is more something that hasn't exactly been considered. Here's a potential way to fix this as an added feature:\n\n```js\n// future API!\ndispatch(actions.setFieldsErrors('user.something', {\n  foo: true,\n  bar: true\n}, { transient: true }); // << this is new\n```\n\nThese will \"mark\" the validator keys `'foo'` and `'bar'` internally as _transient_, which means that they will disappear once the control changes, similar to how async validators work.\n\nHow does this sound?. >  as long as it doesn't clear up the errors on page navigation (remount)...\n\nRight, it would only clear transient errors when an `actions.change` action for that model is dispatched.. > I have tried the piece of advice that you has mentioned using { transient: true } but didn't work.\n\nThat's coming up in a future version.. Sorry @jjmr I've been extremely busy - if you know how `transient` can be implemented (should be straightforward) I'd be glad to review and accept such a PR as soon as possible.. Good catch, thank you!. Can you please make a reproducible example using the CodePen template? It's the quickest way for me to diagnose/fix these issues.. If you initialize the array (that way letting RRF know it's an array), it works fine:\n\n\n\nOtherwise, we're making assumptions - if the property doesn't exist, how will we know whether it's meant to be an array or an object?\n\n- `foo.bar['baz'].name`: definitely in an object\n- `foo.bar[0].name`: in an array\n- `foo.bar.0.name`: in an object... or an array?\n- `foo.bar[567].name`: probably in an array\n- `foo.bar[3].name` when `foo.bar` is already an object: in an _object_\n\nThere's a little ambiguity, but I might be able to be convinced that `[]` in an undefined property value should be an array. Right now, it defaults to objects.\n. If you want to try to do this, it's lines 9 - 11 of `model-reducer.js`:\n\n```js\nfunction icepickSet(state, path, value) {\n  return i.setIn(state, path, value);\n}\n```\n\nCurrently, `icepick.setIn()` will always recursively create _objects_ for each key in path. I think the solution will have to be that we implement a custom `setIn()` (if you look at the icepick code for `assocIn` you'll see it's very terse).\n\nHowever, there's already a custom `utils/assoc-in.js`, so we can just reuse that. We will have to modify the logic so that instead of defaulting to creating an empty object for each key (in line 34 of `assoc-in.js`), it does the following:\n\n- Coerce the key to a number\n- Check if that coerced key is indeed a number\n- Check that the coerced key is an integer (`Math.floor(n) === n`)\n- Check that the coerced key is `>= 0`\n\nIf those are all true, create an empty array instead of an empty object.\n\nAnd then we just have to do that for the Immutable.JS implementation too \ud83d\ude05 \n\nAlso, unit tests.\n\nHope that explains it all!. Please make a reproducible code example. I never use jQuery so I wouldn't know where to begin with this one.. @Bitz This is using [Redux-Form](https://github.com/erikras/redux-form/), not React-Redux-Form. Please move this issue to that repo: https://github.com/erikras/redux-form/issues\n\nThanks!. Related: #849 #751. > Am I overlooking something?\n\nProbably. \ud83d\ude04 \n\nYou'll want to utilize the `mapProps` prop, which allows you to map field-specific props (that come from RRF) to props on your own custom control. Here's a simple example:\n\n```jsx\n !val.length,\n  }}\n  validateOn='change'\n  component={renderInput}\n  mapProps={{\n    error: ({ fieldValue }) => fieldValue.touched && !fieldValue.valid\n  }}\n/>\n```\n\nThen you can use it directly:\n\n```jsx\nconst renderInput = ({ label, children, error, ...otherProps }) => {\n  return (\n    \n\n\n  );\n};\n```\n\nHope that helps! Feel free to reopen if this doesn't work for your specific use-case.. See the field arrays (and more) examples here: http://davidkpiano.github.io/react-redux-form/docs/guides/compare-redux-form.html#field-arrays\n\nAnd here's an updated version:\n\n```jsx\nimport { Form, Control, actions } from 'react-redux-form';\n\nconst initialMember = { firstName: '', lastName: '' };\nconst initialHobby = '';\n\nconst ClubForm = ({ club, dispatch }) => (\n  \n\nClub Name\n\n\n dispatch(actions.push('club.members', initialMember))}\n    />\n      Add Member\n    \n\n    {club.members.map((member, i) =>\n      \nMember #{i+1}\n\nFirst Name\n\n\n\nLast Name\n\n\n dispatch(actions.push(`club.members[${i}].hobbies`, initialHobby))}\n        />\n          Add Hobby\n        \n\n        {member.hobbies.map((hobby, j) =>\n          \nHobby #{j+1}\n\n\n        )}\n      \n    )}\n  \n);\n\nexport default connect(({club}) => ({club}))(ClubForm);\n```\n\nSee how much shorter the code is? \ud83d\ude09 . @husainshabbir Two ways:\n\n1. Think how you would do it normally in Redux, and do it like that \ud83d\ude09 no need for a magical method.\n2. You can use `actions.change` as an action _thunk_ creator (make sure you have `redux-thunk` installed) and pass it an updater function:\n\n```js\ndispatch(actions.change('user.friends', (friends) =>\n  [...friends].splice(index, 0, newFriend)));\n```\n\nWhere `index` is the index you want to insert the new item.. This should work naturally:\n\n```jsx\n// with this store...\nconst store = createStore(combineForms({\n  allForms: []\n});\n```\n\n```jsx\n// and this in render()...\nallForms.map((form, index) => {\n  \n\n\n})\n\n// somewhere else in render()...\n dispatch(actions.push('allForms', {}))}\n  Make new form\n\n```\n\nIs this what you mean?. You're using `bindActionCreators()` wrong:\n\n```js\nconst mapDispatchToProps = (dispatch) => bindActionCreators({\n    dispatch, // <-- this doesn't go here\n}, dispatch);\n```\n\n`bindActionCreators(actionCreators, dispatch)` takes an object of _action creators_ (not dispatch) as its first argument (see [the Redux docs](http://redux.js.org/docs/api/bindActionCreators.html)), so theoretically you can do:\n\n```js\nimport { actions } from 'react-redux-form';\n\nbindActionCreators(actions, dispatch);\n```\n\nOr you can piecemeal it (which is preferred):\n\n```js\nimport { actions } from 'react-redux-form';\n\nbindActionCreators({\n  push: actions.push,\n  remove: actions.remove\n}, dispatch);\n```\n\nOr you can do what I do in all my examples (for simplicity) and omit `mapDispatchToProps` altogether. Up to you.. This works fine:\n\n```js\nconst mapDispatchToProps = (dispatch) => bindActionCreators({\n  push: actions.push,\n  remove: actions.remove,\n  // dispatch // <-- remove this\n}, dispatch);\n\nconst UserFormConn = connect(mapStateToProps, mapDispatchToProps)(UserForm);\n```. Can't replicate... this works perfectly fine:\n\n```jsx\nclass UserForm extends React.Component {\n  render() {\n    return (\n       console.log(e)}\n        validators={{\n          '': {\n            passwordsMatch: ({ a, b }) => a === b\n          }\n        }}\n      >\n        \n\n\n\n    )\n  }\n}\n```. You'd store it in the state from `onUpdate`:\n\n```jsx\nimport React from 'react';\nimport { LocalForm, Control } from 'react-redux-form';\n\nexport default class MyApp extends React.Component {\n  constructor() {\n    super();\n    this.state = { form: undefined };\n  }\n\n  handleChange(values) { /* ... */ }\n  handleUpdate(form) {\n    this.setState({ form }); // << right here\n  }\n  handleSubmit(values) { ... }\n  render() {\n    const { form } = this.state;\n    console.log(form); // all the form metadata\n\n    return (\n       this.handleUpdate(form)}\n        onChange={(values) => this.handleChange(values)}\n        onSubmit={(values) => this.handleSubmit(values)}\n      >\n        \n\n\n    );\n  }\n}\n```. Okay, so initialize it with an object. It's up to you.. @cyberwombat Can you please put that in CodePen/CodeSandbox?. Sorry, I have to close this until I can get a reproducible example. Let me know if you need help creating one.. That looks correct. You can also use `actions.load(model, value)` to set it as the initial value.. Much thanks!. You mean besides `change`?. Where is `debounce` coming from? . Can you please make a reproducible code example if this is a RRF bug?. Are you setting a form-wide error when submit is rejected? If so, you can use that error key as the message key, and then have your own custom message as the value.. ~Is this replicable in other browsers? I recall this being a Chrome-specific bug.~ Never mind, this is according to spec.. Not a RRF issue. You need to add a `step={0.1}` attribute to allow steps.\n\nSee here for more info: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/number#Allowing_decimal_values. Looks good to me! I might do a little cleanup (that I've been meaning to do for native anyway) but I'll do that separately.. Yeah, would you be able to do that in a separate PR?. Sorry about that! That was a mistake in the documentation and never was meant to be a feature.. Please see the [docs on validation](http://davidkpiano.github.io/react-redux-form/docs/guides/validation.html). Specifically, look at `actions.submit(model, promise)`, where **rejecting** the promise will set the errors on the form, if the users are invalid.\n\nOtherwise, please submit fully reproducible code examples explaining your problem. Thanks!. `validateCourtiers` returns a function, not a promise. If you're going to do it that way, you don't need to use `actions.submit`, just call` validateCourtiers` directly.. Any errors in submitting for `'myContractsForms.proxy'` will set the errors on that model. Please provide a working, running code example in www.codesandbox.io or www.codepen.io .. To have error messages for specific fields, use `actions.submitFields(...)`.. Can you try removing line 385 of `control-component.js` in RRF, which is:\n\n```js\n// ...\n            if (isNative) return;\n// ...\n```\n\nand seeing if focusing works as expected?. Can you try installing RRF in your React Native from the `master` branch? (Let me know if you don't know how to do that) I just pushed a commit that uses `findNodeHandle` in React Native, so it _should_ work.. @abudel May I see a bigger code example? I'd like to have this work automatically in RRF.. I don't see `findNodeHandle` in that code :/. The `wrapper` prop can be a function component that takes `` props, so try this:\n\n```jsx\n {\n    \n      {children}\n    \n  }}\n/>\n```. I see. The logic with `` is that it shows errors (of course) if and _only_ if there are errors. Have you tried using a custom control instead?. Any reason you're mapping the prop in the first place? The behavior you're trying to map already should work.. Hmm... if you don't use RRF at all, can you make a custom component that does exactly the behavior you want without the cursor jumping? Might not be (just) an RRF issue.. Okay, solution: you want to use `viewValue` for the mapping, not `modelValue`, and there's a good reason why.\n\nIn an RRF input, when you change a value, two things happen in a specific order:\n1. The `viewValue` (which is in the control's internal state) is set.\n2. The `modelValue` is changed (via dispatching an action)\n\nThat way, if the `modelValue` is updated externally, the component checks if the `viewValue` is out of sync, and updates it. In this case, it doesn't matter where the cursor is since the update is external.\n\nHowever, if you map the `value` to the `modelValue`, then step 1 is _skipped_ (since you're manually setting `value` to the `modelValue` and controlling it yourself), and now RRF has to sync the `viewValue` again, even if it's not an external change. \n\nSo `mapProps={{ value: ({ viewValue }) => viewValue }}` is your best bet, but I'd really like to know what kind of value transformation you're doing, because I can help you find a better way to do it.. So this seems to be a separate issue outside of RRF - in short, you're using `submit` in a way that wasn't intended.\n\nThe real solution for this sounds like you just need to have a promise in `handleSubmit` that continues (`.then`) with the URL, append that URL to your form data, and submit it (again, in `.then(...)`.. Right, you have to map `value` to `searchText` (or whatever the correct prop is) in `mapProps`. Please see the documentation on Custom Controls for more info: http://davidkpiano.github.io/react-redux-form/docs/guides/custom-controls.html. Okay, the value mapping is correct, but maybe the issue is in how the value _changes_. Does Autocomplete have an `onChange`, or is it called something else? ;-). Sorry about that! `npm install react-redux-form@latest` (1.13.2) reverts that commit.. @klis87 @peterox I think I have a solution.\n\nWhat if there were a new prop on ``, called `hideNativeErrors`? The behavior of this would be:\n\n- No native HTML5 error bubbles will be shown when any control is invalid.\n- The form will **not** submit if a control is invalid (this is different behavior than `noValidate`, which will always submit a form)\n- Custom error messages (using ``) will show as normal.\n\nI think this was a suggestion of @peterox. What do you think?\n\n```jsx\n// native errors will NOT show\n//  will show when touched (or submit button clicked) as expected\n\n\n\nSubmit!\n\n```\n\nTwo \ud83d\udc4d 's and I'll get this in ASAP.. I will publish this by end of day today.. Published as 1.14.0!. Are you also using `redux-thunk`? Those actions only work with `redux-thunk` (which, yes, does work with `redux-saga` as well). By other actions, you mean with other thunk actions?. Those aren't thunk actions, so they will work without `redux-thunk`. Make sure you're using `redux-thunk` in order to use `actions.merge`. \n\n```js\nimport thunk from 'redux-thunk';\nimport createSagaMiddleware from 'redux-saga';\n\nconst sagaMiddleware = createSagaMiddleware();\nconst middlewares = [sagaMiddleware, thunk];\n\n// ... in creating your store:\n/* ... */ applyMiddleware(...middlewares)\n```. Please make a reproducible code example using CodePen or CodeSandbox.. They do not make use of the same middleware, as they use a separate internal Redux store instance (by design). In fact, in future versions (v2+) it's best to not even assume that `` will use Redux at all.. Thank you!. Sure it is! Just replace `combineReducers` with `combineForms`. Works almost exactly the same way, but now your reducers will be made \"visible\" to React-Redux-Form and a form state slice will be set up for your reducers.\n\n```jsx\nimport myReducer from './myReducer';\nimport { combineForms } from 'react-redux-form';\n\nconst rootReducer = combineForms({\n    myReducerState: myReducer\n})\n```\n\n. You can get the resolved model here:\n\n```jsx\n props.model,  // <<< right here \ud83d\udc40\n    // anything else you need\n  }}\n/>\n```\n\nAnd then use it in your custom component as `props.model`. Does that not solve your use case?\n. Closing this as resolved. Please let me know if it doesn't solve your use case. Thanks!. Just `dispatch(actions.focus('your.model'));`. Thank you!\n. Interesting, not sure why it wouldn't be found on Linux. I'll close this since you can't repro on Mac (and it might be an outside issue) but please let me know if you find a fix.. Wanna file a PR? \ud83d\ude04 . Let me know if you need help. Just make the changes and run:\n\n- `npm test`\n- `npm run lint:fix` (assuming tests pass)\n\nIf all is green, I'll \ud83d\udea2 . @akkie will do!. Can you please make a reproducible CodePen example? Or codesandbox.io. I'll probably be able to take a look this weekend. If you want to dig into the source code, some help would be nice \ud83d\ude04 . Probably later today!. Pull from `master` and try again please \ud83d\ude4f . Hey @DaveVanRijn, sorry but I forgot to update the docs with the relevant information for this ticket.\n\nPlease see the FAQs for \"How do I hide native HTML5 validation messages, and still prevent the form from submitting if invalid?\" http://davidkpiano.github.io/react-redux-form/docs/guides/faqs.html\n\n```jsx\n// native errors will NOT show\n//  will show when touched (or submit button clicked) as expected\n\n\n\nSubmit!\n\n```\n\nLet me know if this works for your use case!. Simple solution: your validator doesn't work for numbers:\n\n```js\n// numbers don't have a `.length` prop, and `0` is falsey\nconst required = val => val && val.length\n```\n\nTry this instead:\n```js\nconst required = val => val !== undefined\n```. Does normal NPM installing work?. So can this issue be closed? Or is it still an issue? . Yes please. You would use `mapProps` to do this:\n\n```jsx\n !field.valid\n  }}\n/>\n```. Can you put this in a CodePen?. Awesome, glad you figured it out!. Oh, interesting. Can you create a CodePen?. Sure, and this is a JavaScript solution not specific to RRF. There's many ways to approach this, here's what I would do:\n\n```js\n// validatorCreators.js\nconst validatorCreators = {\n  maxLength: (len) => {\n    const fn = (val) => val && val.length <= len;\n    fn.message = 'Length is too long. Max: ' + len;\n    return fn;\n  },\n  required: () => {\n    const fn = (val) => val !== undefined;\n    fn.message = 'Value is required.'\n    return fn;\n  }\n}\n\nexport default validators;\n```\n\nAnd then in RRF:\n\n```js\nimport validators from './validatorCreators';\n\nconst maxLength = validators.maxLength(14);\nconst required = validators.required();\n\n\n\n```. What version React do you have?. Fantastic, thanks!. @kkashou Put is as a form validator:\n\n```jsx\n val // must all be checked\n  }}\n>\n  // ...\n\n```\n\nYou can have a validator that checks individual fields, e.g., `'users[].name': isRequired(name)` to check each name of each `user` in `users[]`. Or you can just do it manually: `checkbox: (vals) => vals.every(val => val)`. Also can you put the original issue in a codepen? There might be an easier way to solve this.. Log the validation:\n\n```js\nconst validators = {\n  required: () => {\n    const fn = val => {\n      console.log(val);\n      return val !== \"\" && val !== undefined\n    };\n    fn.message = \"Value is required.\";\n    return fn;\n  }\n};\n```\n\nYou'll see that `val` is an array, could be empty (`[]`), could be full of values. So it'll never be \"invalid\". Since you are validating that model (which represents the array), you have to be more specific with your validation, e.g., check that `val.length > 0` or something like that.\n\nLet me know if that helps!. Make sure it exists first. `(val && val.length > 0)`. It might be a while before I get to this - extremely busy. However, I'm open to reviewing PRs and merging them in as soon as possible if they are solid and fix the problem.. Yep, @spartDev is right - this is exactly what higher-order components are for. Make a custom component \ud83d\udc4d . It will, but I think you're overthinking it. Check this out:\n\n```jsx\nconst MyControl = ({ errorClassName, ...otherProps }) => (\n   valid ? errorClassName : '' }}\n  />\n);\n\n// usage\n\n```. Can you put this in a CodePen? That way, if I suggest a fix, we can immediately verify that it works.. Closing until this can be reproduced in a CodePen or CodeSandbox. \n\nFor reference, validation is triggered on the component itself. It is not triggered automatically from external changes (such as `actions.change` or `actions.load`) unless that dispatched action itself triggers a change in the component. That will change in V2 (by the end of the year).. > We were trying to find clear documentation on best practices for loading an existing model into a form but it was not 100% clear how to do that.\n\nYou'd just dispatch `actions.load` which _will_ trigger validation if there's validators on the controls and the controls are present. Does that not work for your use case?. Good analysis. Let's do this:\n\n- Switch to `prepublishOnly`\n- Add Yarn support. Fixed by #928 . @dave-clover Go ahead and submit a PR, what you are describing sounds like it should be the expected behavior.\n\nI'll merge the PR ASAP as soon as everything is \ud83c\udf4f . Thanks!. @yourfavorite I haven't released this in a patch yet.. Any reason you can't use `Control.custom`?. Have you tried passing an object instead of a function to `mapProps`?. @abustamam if you want to create a PR with that enhancement, I'll review it, it seems reasonable.. Please provide a CodePen or CodeSandbox to demonstrate the issue.. Go to Pen Settings > JavaScript and add Immutable.JS. What exactly are you trying to accomplish?. Can I see how you're creating your store?. If it's on a shareable repo, that would be best.. > Does form level validators don't work with LocalForm?\n\nThey do.\n\nWith the validators you have set up, you aren't making a form-level validator, you're making a field-level validator:\n\n```jsx\n       value === 'bob' }\n        }}\n        onSubmit={console.log}\n      >\n```\n\nTry this:\n```jsx\n       value.model1 === 'bob'\n          }\n        }}\n        onSubmit={console.log}\n      >\n```\n\nAnd then you will see it will work \ud83d\ude04 . Yes, it should. Feel free to submit a PR!. Thank you!. Can you please put this into a fully functioning CodePen? I'll reopen once that happens. (Sorry, just trying to keep the valid issues clean!). It should work with `action`. Please make a reproducible CodePen/CodeSandbox showing that it's not working.. There's some useful info in the [FAQs](http://davidkpiano.github.io/react-redux-form/docs/guides/faqs.html) that could help you.\n\n> how to set a className based on Control validation state /if the field is invalid to add xxxx className to the input/\n\nSee \"How do I add conditional class names based on field state?\" in the FAQs (linked above)\n\n> how to determinate the dirty state of the form to enable/disable the submit button. Currently the disable function works with valid, but it will be good to have the option for isDirty as well..\n\nSee these docs for the `disabled` prop: http://davidkpiano.github.io/react-redux-form/docs/api/Control.html\n\n```jsx\n// Disable the submit button when the form is invalid\n\n  Submit!\n\n```. Can you please put this in a reproducible CodePen or CodeSandbox? I will reopen once that happens.. There's an internal helper function called `isValid` that you can pass an option to: `isValid(form, { async: false })` which will return `true` if the form is valid, disregarding async validators. I'll expose it as an enhancement.. @greghawk good idea, separate issue? \ud83d\ude04 . @greghawk Might be good to see code of that, if you can share.. This happens because `selectedDate` is most likely undefined. Can you put your code into a CodePen so I can show you an appropriate solution?. `actions.submit` is a thunk action creator. Add `redux-thunk` to your store's middleware or manually use `actions.setPending()` and `actions.setSubmitted` or `actions.setSubmitFailed` within your promise.. Since RRF safely assumes that the server isn't going to return errors directly related to the specific fields, all async errors are considered errors on the form itself, so you'd have to parse them as e.g., `forms.deep.$form.errors` and then assign them directly to the model.\n\nIf you can get a CodePen showing the limitation and what you want to happen, I can reopen this and make it an enhancement.. It should work like normal with `track()`, just as any other ``. If it doesn't, please submit a CodePen or CodeSandbox example demonstrating the issue.. Can you put this into a CodePen (or CodeSandbox) for me to easily reproduce?. I cannot reproduce with this distilled example:\n\n```jsx\nclass App extends React.Component {\n  render() {\n    return (\n       console.log(v)}>\n         false\n        }} />\n        \nSubmit\n\n    );\n  }\n}\n```\n\nClicking `Submit` will successfully show the error message. Is this equivalent to your issue?. http://davidkpiano.github.io/react-redux-form/docs/api/Errors.html\nIt can be a boolean, or a function, string, or object as a Lodash iteratee.\n\nExamples:\n\n- `show={true}` will always show the errors if they exist\n- `show={(field) => field.touched && !field.focus}` will show errors if the model's field is touched and not focused\n- `show={{touched: true, focus: false}}` is the same as above\n- `show=\"touched\"` will show errors if the model's field is touched. Then you use just the normal version of `react-redux-form`, because `seamless-immutable` works as-is with normal JS objects/arrays. \ud83d\udc4d . @davidchase I'll bump a new patch either today or tomorrow.. @niawdeleon With your current usage, it seems like `actions.reset` never gets called at all - add `logger` to see this:\n\n```js\nconst store = createStore(combineForms({\n  user: initialUserState,\n}), applyMiddleware(thunk, logger));\n```. @daronjay can you open a separate issue to track that?. Can you put your validators on the `` instead of the ``?. > Is it really that hard to implement?\n\nGive it a try, submit a PR.\n\nAlso, try to send in a CodePen or CodeSandbox example, in order for me to verify and solve your issue.. Can you show me what you mean by nested `setErrors`?. Trying to see the use-case here. By setting `value=\"whatever\"`, you're making it controlled and telling React that on every render cycle, you want the value prop to be `\"whatever\"` no matter what, so of course it won't work.\n\nCan you explain your use-case further?. Try `defaultValue` or dispatch an `actions.load(model, value)` action.. Thanks!. You misspelled `\"employed\"`:\n\n```diff\nconst initialUserState = {\n  firstName: '',\n  lastName: '',\n- empoyed: true\n+ employed: true\n};\n```\n\nI corrected the spelling and saw that everything worked as expected.. Hey, sorry for the delay. Here's the logic you'd want to look at: https://github.com/davidkpiano/react-redux-form/blob/master/src/reducers/form/change-action-reducer.js#L41-L86. @bevan-chan @christensena Are any of you able to make a small reproducible example on CodePen or CodeSandbox? It's the fastest way for me to fix the issue (or if you know the fix, feel free to make a PR. I review and merge them quickly). Instead of `actions.remove` try using `actions.change(model, () => ...)` with an updater function to manually filter out the fields, and see if that fixes the issue.\n\nIf so, the bug might be around `actions.remove`.. > Loading existing data into the form?\n\nDispatching an `actions.load` action once you receive your data:\n\n```js\ndispatch(actions.load('user', userData));\n```\n\n> Tracking the ID's with track() so that I can add/delete rows.\n\nThe documentation is pretty thorough about this: http://davidkpiano.github.io/react-redux-form/docs/guides/tracking.html\n\n> When/where/how do I use modelReducer/formReducer/combineForms etc?\nPreferably looking for a repo with some examples.\n\nUse `combineForms` - `modelReducer` and `formReducer` are lower-level and better left abstracted. There's a bunch of guides and examples in the documentation.\n\nHope that helps!\n. You want them all checked? I don't understand the full issue.. Awesome, want to share what those \"tricks\" were, in case there's a better way?. Thank you!. You don't have to wrap `` with `` (and you shouldn't) - try transferring `Field` props over to `Control`, and it should work.. See here: http://davidkpiano.github.io/react-redux-form/docs/guides/partial-models.html. Can you post a CodePen example of that?. @kkashou Can you open that in a new issue?. 1.14.4 was just published!. Have you tried using `` instead of ``? Try that first. `` will be deprecated in v2.0.. End of the year. Please show me the code with ``. The behavior is correct - an HTML5 form won't submit on Enter unless part of that form is focused, which you have to do by focusing (clicking, tabbing, etc.) on something.. Add the `autoFocus` prop (HTML5).. Feel free to make a pull request! As long as it doesn't affect performance, this could be a good feature.. Simplest way to implement this would be to add a prop:\n\n```jsx\n\n```\n\nWhat do you think?. The problem is that it either has to be opt-in or opt-out.\n\n- Opt-out (always add the prop) makes too many assumptions, and developers will get lots of \"unrecognized prop\" warnings.\n- Opt-in (using `withFieldValue` prop) is only a little more typing, easily abstracted, and explicit.. All of the form errors are available in the store, so you can just grab them from there.\n\nOtherwise, what would an ideal API look like to you?. Thanks all for taking care of this so fast! I'll publish a patch.. @TLadd Can you please verify with the latest, 1.14.6?. That shouldn't be possible; the latest version has `find-key.js` refactored to not require `immutable` as a dependency.. Are you using babel?. Do you have a repo that you can share?\n\nAlso, if you know the fix, I'll happily accept a PR.. Make a custom component that contains ``. More info here: http://davidkpiano.github.io/react-redux-form/docs/guides/custom-controls.html . Unfortunately, because of the Redux model where it is difficult to chain sequences of actions that are \"reactive\" to state changes, you have to do something like this:\n\n```js\ndispatch(actions.change(model, value));\nsetTimeout(() => dispatch(actions.submit(model, this.submitPromise)), 0);\n```\n\nLet me know if this works for you. It's otherwise tricky because both actions execute with regard to the state being the same, even if the first action changes the state on the next tick. So the above workaround waits til that next tick.. Please create a reproducible CodePen or CodeSandbox example and I'll reopen this. Thanks!. If you have an idea of how you'd like to implement it, please prepare a PR.. It's not exactly supposed to override it; it's supposed to be used as a \"hook\" to perform an action when the `onChange` event occurs.. This might be a React issue, not a RRF issue, since I tested it with a plain:\n\n```jsx\n\n\n  testing\n\n```\n\nand it didn't focus the checkbox for that either. Try posting an issue here: https://github.com/facebook/react/issues. Can you try removing the conditional @kabbi and see if that fixes the issue?. Copying pasting here for clarity:\n\n```jsx\n          case 'validate':\n          case 'reset':\n            if (intent.type === 'reset') {\n              this.setViewValue(modelValue);\n              if (this.handleUpdate.cancel) {\n                this.handleUpdate.cancel();\n              }\n            }\n            if (containsEvent(validateOn, 'change')) {\n              this.validate({ clearIntents: intent });\n            }\n            return;\n```\n\nSo the logic is:\n- If resetting, make sure to update the view value so that the control visually shows the correct value.\n- If there is change validation on the control, resetting \"changes\" the value, so validate it.\n\nI believe the fix here is to add an `else` clause (if it's a reset) to clear the intent.. Yes please!. @yourfavorite Please create a new ticket with a reproduction.. Fantastic, thanks! Will release later tonight/tomorrow.. @valorize Mind submitting a PR for the missing types? (And the second issue as well). Internally, RRF (and lodash) convert these string paths:\n\n```\n\"foo.bar.baz\"\n```\n\ninto array paths:\n\n```\n['foo', 'bar', 'baz']\n```\n\nUnless, of course, it's already an array path. What this means is you can do this:\n\n```jsx\n        \nFirst name:\n\n\n\nLast name:\n\n\n```\n\nAnd it will work as expected. If this is a viable solution, I'll add it to the docs (or you can - Hacktoberfest is going on!). @SuperOleg39 Try `actions.change('user', (user) => { ... })` and updating the user through a function to mitigate this problem.. Will do first thing tomorrow.. Thanks! I think this is fine for now. Did you try it with your original use case?. Thank you!. @patrick-ivers is it possible to reproduce it on CodePen/CodeSandbox? Seems like the first one doesn't reproduce.. Fixed in \nhttps://github.com/davidkpiano/react-redux-form/commit/3de4239803c249c04b7678e07b8cc13b459c6a1c but you have to make sure that `validateOn` is the same as `asyncValidateOn`. The default for `asyncValidateOn = 'blur'` so you have to change that to `asyncValidateOn=\"change\"`.. Just published in 1.16.1. Sorry about that, the documentation was wrong. There is no `previous` property.. > Is it possible that you would accept a PR to make  work with react-redux v5.x.x, assuming that's a scarcely reasonable thing to do.\n\nYes, go for it! I'll merge it in \ud83d\udd1c . I think early versions of 5 did have breaking issues that were since fixed. As long as the tests pass with the latest, should be good to go.. What are the main changes between `control-component-factory` and `control-component`?. I can't reproduce the initial issue. When you unmount the form, you have this logic:\n\n```js\ncomponentWillUnmount() {\n    this.props.dispatch(actions.reset('user'));\n  }\n```\n\nthat will remove the current value.. Can you put this in a CodePen or CodeSandbox template so I can reproduce it?. Okay, figured it out. Two things:\n\n1. When you dispatch an `actions.change`, you're replacing the entire user and essentially telling RRF that only one field exists on the `user` object: `'username'`. Because of that, it'll only validate on the username and not the other fields:\n\n```js\n// Instead of...\nstore.dispatch(actions.change('user', {\n  username: 'john'\n}));\n\n// Do this... (requires redux-thunk)\nstore.dispatch(actions.change('user', (user) => ({\n  ...user,\n  username: 'john'\n})));\n\n// Or this... (doesn't require redux-thunk)\nstore.dispatch(actions.change('user.username', 'john'));\n```\n\n2. When you do the above, you'll see that `.email` now works correctly, but `.age` does not, and that's because RRF initially has no idea that `.age` is a field. The fix here is to provide an initial value for `.age`:\n\n```js\nconst initialUserState = {\n  username: '',\n  email: '',\n  age: ''\n};\n```\n. If you know the fix, I'd happily accept a PR.. Can you put this in a CodePen/CodeSandbox so I can more easily diagnose the issue? I do not use `normalizr`.. Can you do me a favor and put that in the CodePen or CodeSandbox template? I'll investigate, but I think what `setInitial` should do here is completely replace the `test` form tree instead of recursively trying to update the children.\n\nThanks for the detailed investigation, by the way!. If you have a potential fix, please create a PR for it. I'd be happy to look at it and merge it in ASAP.. How would you do it in plain Redux? You can just check the store values and present the other select options accordingly.. You would use whichever method you're comfortable with, and once you received the data, _then_ you `dispatch(actions.change(...))` for the appropriate values.. Your second select has no values:\n\n```jsx\n          \n\n```\n\nI would redirect questions like these to stackoverflow.com unless you find a bug (or have a feature request). Thanks!. Thank you for the succinct fix!. This is a difficult problem to solve (and why I avoided adding `formatter` for a long time). Consider solving this by making a custom component and using something like https://github.com/insin/react-maskedinput. If this is a duplicate of #993, 1.16.1 was just released which should fix this.. Right, you shouldn't have nested forms. Prefer using a `Fieldset` instead.. Yes, that, or you can pass in a function to `actions.change` to simplify things; for example, if a user doesn't exist:\n\n```js\n// change \"users.nonexistant.name\" to \"bob\"\nactions.change('users', (users) => {\n  const currentUser = users.nonexistant || {};\n  return {\n    ...users,\n    nonexistant: {\n      ...currentUser, // existing or new user\n      name: 'bob'\n    }\n  };\n});\n```. Thank you!. You're gonna have to point me to the exact code (please copy-paste it here) that is doing the model loading. However, I'm pretty sure this is fixed by eb18aa8 which fixed #1020 \n\n. > Not works in my case, upgraded package to latest.\n\nHasn't been released yet. You can fork the repo or add the GitHub link directly in `package.json` to test it.. There have been many releases since this issue. @akki199421 Are you not seeing this in the current version?. It's possible. You can dispatch `actions.push('user.phones', newPhone)` to add a new phone, and of course it's smart to give each phone number a unique `id` (otherwise tracking won't work like you'd expect - since it'll just select the first match).. > probably because the initial list is not rendered from the react-redux-form managed state:\n\nCan I see how your store is defined?. Awesome, glad you got it figured out!. Looks good in general, can you fix this one tiny lint issue?\n\n```\n/home/travis/build/davidkpiano/react-redux-form/src/native.js\n  193:3  error  'getField' is not defined  no-undef\n\u2716 1 problem (1 error, 0 warnings)\n```. Weird, I'll merge this in and take care of the lint issue in master. Thanks so much!. Please show me a full working code example in CodePen or CodeSandbox.. Yep, it might help you (us) work through the problem too. Show me how you expect it to work in RRF. I don't know what's inside ``.. Try using `` instead: http://davidkpiano.github.io/react-redux-form/docs/api/Fieldset.html. Wrong library: https://github.com/erikras/redux-form/issues. Can you create a reproducible code example?. Can you make a PR that fixes the example? The `model` prop is required.. Thank you!. It's hard to read the given code example. Please place it in CodePen or CodeSandobx.. ```js\ndispatch(actions.change('user.friends', (friends) => {\n  // update friends (.slice), insert the item, and return it\n});\n```. This already works. Just add more than one validator, and as long as you have `messages={{...}}` for each validator key on ``, you'll see all the messages. See the documentation: davidkpiano.github.io/react-redux-form/docs.html. Please submit a CodePen or CodeSandbox reproduction (the links should be on the issue template when you created the issue).. Please put this in a CodePen or CodeSandbox. It's the only way I can properly test it.. Just published a patch, let me know if that works!. That's because when you switch tabs, your `` component is completely unmounting the first tab, and RRF detects it and removes their validity (which makes sense - it's as if those fields don't apply anymore, so their validity shouldn't affect overall validity).\n\nBut if you want their validity to persist, add the `persist` prop to the `` components. http://davidkpiano.github.io/react-redux-form/docs/api/Control.html. Everything's in your Redux store. I suggest using `redux-logger` to see what you can play with - usually on the `form` object you'll find everything.. You're right, want to make a PR that redirects directly to the docs? Should be fairly simple, and I'll merge it in ASAP.. Use `validators`.\n\nThe only reason to use `errors` is if you don't like describing your validation in terms of \"is this valid\" and instead \"is this an error\".. Yes, put them in `controlProps` and use a higher-order component. This is a React pattern, not something specific to RRF.. This can't be done magically with RRF because RRF doesn't know how to access the inner `` of your custom `TextInput` control in order to attach the native validators.\n\nHere, do this:\n1. Solve it yourself without using Redux or RRF (use `setState`)\n2. Once you have a solution, post it here and I'll help you figure out how to integrate that solution into RRF.. I am \ud83d\udcaf for this idea, would definitely simplify a lot of things.\n\nHave at it! It shouldn't be difficult to do - all you'd have to do is pass in the `fieldValue` (and other things such as `model`) into the function, and you should be good to go.. I'm all for `render` props everywhere. What I'd recommend is keeping the amount of arguments passed to these render props as small as possible - e.g., just `fieldValues` for ``, which contains everything in an object. I want to avoid positional arguments.. I'm not familiar with redux-optimistic-ui. I'll reopen this if you have a working code example and can demonstrate that something with react-redux-form is preventing you from doing what you want.. Awesome to hear @mrsufgi !!. I can't fix this issue without a reproducible code example, sorry. I'll reopen when there is one.. Object of objects are already supported: `model=\"foo.bar.baz\"`, try it out!. That seems like something that should be solved in userland. You can easily create validation on the `user.obj` model.. It should, you can correct the type definition file if it's missing and I'll accept that PR.. Nope, nothing wrong - Yarn just doesn't support Node 4.0 anymore, so I'll remove it.. Can you please create a reproducible (minimal) example that I can run? It might be that RRF doesn't know that `reservation.trips[0]` is a form field.. Yep, you'd want to use `LocalForm` for that. Feel free to add it to the docs, and I'll merge in that PR.. The entire form state is available to you in the Redux store. You can easily grab the validity of each section via a selector from the state, and then solve this problem as you would solve any other Redux problem. It's not RRF-specific.. Is there any way you can avoid using Immutable?. When I got rid of immutable, it worked as expected. In the next version (or a future form library that improves over `react-redux-form`) I would recommend _not_ using Immutable.JS. Working with ad-hoc data structures is a major pain point and creates unnatural, hard-baked dependencies. I recommend working with something like https://github.com/mweststrate/immer or https://github.com/aearly/icepick instead.. > should I attempt a PR?\n\nYes please. PRs always welcome, and I get around to reviewing/accepting/releasing them much, much faster than fixing it myself, due to time constraints.. Immutable is supported in a limited sense, but making absolutely everything immutable (which is a bad idea IMO... just use immutable helpers, not Immutable.JS) makes things much more complicated.\n\nImmer looks fantastic, though. I'm going to be using it myself.. Please provide some starter code so we can work off of that. The links are in the issue template.. Build failed due to an old version of Node being tested. I'll merge this in, thanks so much!. I'd greatly appreciate a PR for this, and I'll get it merged in ASAP. Thank you!. You have to fork the repo first, make the change in your fork, and then make a pull request to this repo.. Published as 1.16.4. I don't see that error in the example.. In your code you have `changeAction={()=>{}}` - that's an undefined action. Remove it and you'll see it works.. Can you please post the example with the full `changeAction`? That's the culprit.\n\nAlso, if you are digging into the code and know a fix, please submit a PR.. This looks good, but what if both `render` and `component` are defined? I think that `component` already acts as a render prop, no?. Yeah, let's deprecate `component` then. . Can you try 1.16.5 and see if the same issue is there?. Is that not giving the expected result? Are you looking to listen for model changes only on `blur`?. @joshacheson These seem like good ideas, and I'd be happy to review a PR swiftly if you decide to implement them.. As in they're nested inside the form? How would you solve this in Redux? Those components can `dispatch` from anywhere in order to update the form correctly.\n\nAlternatively, you can use `` with the provided handlers in order to propagate your data.. I'm not exactly sure what you're trying to do, but you're overcomplicating the props. Start here:\n\n```js\n           \n1\n2\n3\n\n```\n\nYou shouldn't need those extra props.. I'd recommend coding your async validations as a `Promise.all()` inside the form's `submit` method instead.\n. Oh, good catch! Mind making a PR to fix that?. Closed in #1076 . @im1dermike I was under the impression that this was working as expected - can you create a minimal code example to show the issue?. Actually, the property you want is `pending` - that tells you that a submit is in progress.\n\nSince RRF has no way of knowing when a form is \"submitted\" (that is, when it successfully makes its round-trip to the API or whatever other business logic the developer might have for submitting), you have to manually dispatch `actions.setSubmitted(...)`. However, `actions.submit(promise)` abstracts this for you for most common use cases.. Could you create a PR for this? I'll merge it in ASAP.. Closed in #1079 . Thanks!. That's expected behavior. Your form has been touched, so it's no longer pristine. You can always `dispatch(actions.setPristine('yourForm'))` to override this behavior after submit.. If it's preselected, wouldn't that just be the value? That is, there shouldn't be a need for a special `defaultValue`.\n\nAnyway, you can always just wrap your `CustomComponent` in one that exhibits the correct behavior - such as one that takes the `modelValue` from RRF, and sets it as `defaultValue` to your inner `CustomComponent` if it's not set yet.. Can you please share the code?. It might actually be a combination of things in `control-props-map.js` and `control-component-factory` with `changeAction`. \ud83d\udd0d . Thank you!. Wrong library. You're looking for [redux-form](https://github.com/erikras/redux-form/issues/).. Thank you!. For ease of testing, can you post a working example of the problem?. Thanks @tomspeak! Would you happen to be aware of a simple fix for this issue? I haven't had much time to work on RRF lately (but I've been really quick at reviewing and merging PRs).. Thank you!. You're overwriting an HTML5 validator: `valueMissing`. This is handled natively by the browser itself, and shouldn't be handled by the developer.\n\nIf you change `'valueMissing'` to `'noValue'` or something similar, you'll see it works as expected.. If you want to disable HTML5 validation, then add `noValidate` on your form:\n\n```js\nimport { Form } from 'react-redux-form';\n\n// email input will not be validated\n\n\n\n```. If you can mark the old docs as outdated in a PR (or remove them), that would be greatly appreciated.. @zjr It would be on the `gh-pages` branch.. How is your store created? When you create a validator, you have to account for all possibilities. In this case, you should probably have `(value) => value && value.length < 255`.. See \"How do I add conditional class names based on field state?\" here: http://davidkpiano.github.io/react-redux-form/docs/guides/faqs.html. Please post a working code example and I will reopen this.. Can you put this in a CodePen/CodeSandbox so I can play around with it and see the issue?. This is wrong:\n\n```\n!passwordText && passwordText.length < 6\n```\n\nCheck the boolean logic.. Please do, that would be greatly appreciated.. Have you looked into using `modeled` instead?. Try `actions.setInitial`.. Reapproach the problem.\n\n```js\n    const { flag } = this.props;\n    const validators = {\n      minLength: val => flag || val.length > 3,\n      required: val => val.length > 0\n    };\n```. Seems like a simple fix, want to make a PR? (check if the path is empty _and_ the original string isn't just an empty string, etc.). Doesn't this forbid `''` from ever being a form key?. Let's add a `console.warn` and then I'd be fine merging this in \ud83d\udc4d . Seems like you know a probable fix, want to open a PR?. If you know the probable fix, I'd be happy to pull in a PR.. I need to see an example.. Please ask this in Stack Overflow.. Wrong library: github.com/erikras/redux-form/issues. Use `parser`. In `component`, the `children` passed into the `ErrorMessage` are the array of error messages (as spans, by default). Just render only the first child.. Please use `` and not ``, and let me know if your problem disappears.. Use the HTML5 `maxLength` attribute.. Would you like to submit a PR if you know the fix?. Nice! That's an interesting caveat.. What does `CustomError` look like?. Code example please.. A code example would be helpful.. Sorry, I don't. But nothing's stopping you from reading the values directly from the `store` and creating your own Error component that does what you want.. Might just need to `event.persist()` the event. Can you try, and create a PR once you've found the fix? I'll be happy to review it and merge it in.. > PS: I wanted to write test for this, but, to properly test it, we need to update react and react-dom in devDependencies to use react 16, is that okay?\n\nYes, that's fine.. Awesome, thanks!. Thanks!. Please look at the existing unit tests. This doesn't seem to be related directly to the library.. Do you know the fix, and would like to make a PR?. Please create a PR, thanks!. Please create a reproducible example.. It mainly is a lack of time - it's in a stable state (I know a few companies using it in production) and I don't have time to handle the backlog of issues alone, many of which are probably invalid due to their extremely custom use-cases (it's virtually impossible to accommodate all use cases for forms in a single library).\n\nHowever, I will continue to review PRs and welcome community contributions.. Please create a reproducible example and I'll reopen this.. If you can fix it in a PR I'll merge it in.. 1.16.10 released!. Do you have a fix? I welcome any PRs.. LGTM - once the linting errors are fixed (max-length for lines) I'll merge this in. Thanks!. Done - this is now published as `1.16.11`. Published as 1.16.12. Please provide a PR to fix this.. Should this throw an error? What do you think?\n. Oh, that's really smart! Why didn't I think of that? \ud83d\ude05 \n. Don't worry, this isn't a hidden bug - it is expected that the `model` of `` is always a `form`, which means it always has a `$form` prop.\n. Yeah, this is a good idea, thanks!\n. As in, you just added `if (!path) return value.toJS();` ?\n\nIf that works, then by all means, let's use it.\n. Oh, gotcha. That's right.\n. Will `onSubmitFailed()` always be executed on every submit?\n. Yes, this is a safe assumption - do nothing if the values are the same after initial load.. `delegate` can be removed now, right?. I'd prefer that too.. I'd put a warn in here. Very much an edge case, but it's good to be aware..",
    "markerikson": "Yeah, I keep searching through Github for newly updated repos with \"redux\" in the name.  Found some interesting items that way, too.\nI'm currently doing prototyping for my first Redux project, a rewrite of an application that among other things involves a bunch of form editing.  That's next on my list of things to figure out, so I've got a bunch of different React/Redux-related form libs I'm going to be looking at.  redux-form is certainly the big name out there, but at first glance it seems a bit bigger and over-engineered than I'd like, so I'm looking for various other options to try out.\nI'll keep an eye on this to see how it develops.\n. Never touched Angular, so I have no point of comparison there.  \nOther than that, sounds reasonable.  \nI'll go ahead and toss out my use case, just for reference.  My application involves a bunch of flight planning data, so lots of things like lat/lon/alt waypoints, etc.  I have some forms for viewing attributes of an item (name, location, some various enums and booleans and numbers), as well as a form for editing a list of waypoints.  My old app had some custom composite widgets for editing a lat/lon (textbox with a bunch of validation logic), an altitude (numeric input plus a dropdown), and a position (lat/lon + altitude combined).  The waypoint list allows adding/removing/rearranging entries, and the whole parent form can reset to the last saved value or apply the in-form edits to the actual value.\nThe original was written in GWT+SmartGWT several years back, when I only sort of knew what I was doing, so I'm hoping to do things a lot better this time around :)\n. Side question, because I don't want to open up a whole new issue: is the explicit dependency on \"react@^0.14.6\" a problem?  The boilerplate I started with is still set to \"^0.14.0\", and when I tried doing an NPM install for this repo, it pulled down 0.14.6 as a nested dep.  Still learning my way around the NPM ecosystem, but seems like that'd introduce a second copy of React into the build, which would be bad.  Does it maybe need to be a \"peerDependency\" or something?\n. Also wondering about react-widgets.\n. Sounds good.\nSorta-vaguely-related question since I don't want to file an entire new issue: is it possible to set up RRF so that I can handle changes at the component state level first, rather than going straight as an action to a reducer?  Basically, I'd like to keep the total number of actions to a minimum (like, if I type 'a' five times real fast, I'd want to see a single action with 'aaaaa' rather than five actions with 'a', 'aa', etc).  \nI've got a quick and dirty HOC I threw together that lets me do some fancy footwork to keep keep stuff in state at first and only dispatch debounced.  Seems to work okay in the prototype I'm putting together, but I'm totally up for looking at more robust options other people have created.\n. I like it.  Looks pretty straightforward.\n. ",
    "fhelwanger": "I think react-redux-form is better.\n. Nice, thanks!\n. ",
    "webmasterkai": "Thanks for the response. That's helpful.\nDoes the following pseudo-code work for you? I've tried a few variations but can't seem to get it to work like it does when each option is a direct child in same component as in your radio example above.\njavascript\nexport default function Options() {\n  const options = [ { value: 'opt1' }, { value: 'opt2' }, { value: 'opt2' } ]\n  return (\n    <div>\n      { options.map(opt => <input type=\"radio\" value={opt.value} />) }\n    </div>\n  )\n}\n``` javascript\nimport { Field } from 'react-redux-form'\nimport Options from './Options'\nexport default function MyRadioField() {\n  return \n}\n```\nI stumbled upon a similar issue on another React module that does some \"magic\" props application to children via parent component https://github.com/soundblogs/react-soundplayer/issues/9\n\u00af\\_(\u30c4)_/\u00af if it works, it works? I'll just have to take a deeper look into src/components/field-component.js and see why I'm having trouble.\n. ",
    "leandroz": "I think I am having the same problem with AutoComplete from Material-UI.\nI checked the examples for Slider and Checkbox and also implement the same for SelectField, but I can't make it work for AutoComplete (Is related on how the AutoComplete is generated).\nWhat do you think would be a posible solution?\n. Thanks for the response @davidkpiano !\n. ",
    "plandem": "well as for me - i'm highly interesting with anything that can be used with backend - login/register and etc. Right now i just can't understand how to make it to submit :(\n. for example, 'getField' is not working too\nimport { Field, Form, getField } from 'react-redux-form';\n...\n<FieldError field={getField(userForm, 'login')}/>\n. http://davidkpiano.github.io/react-redux-form/#/recipe/sync-validation?_k=kma7hv\nlike here, but just imported 'getField' too:\nimport { Field, Form, getField } from 'react-redux-form';\nanyway, it works fine via:\nuserForm.field('username')\n. lol :) not sure now :) i installed your project today :)\n. hmmm....u just did: \nnpm update --save\nand no updates :(\nthough reinstall helps :)\n. Well, creating Field for each type is not good too - what if i need required + email? I would think about validator components to use like:\n<Field>\n<Validators model={userForm}>\n<Required>Username is required</Required>\n<Email>Username must be a valid email</Email>\n<Validators>\n</Field>\nsomething like this. and use parent from this components to get information\np.s.: looks like too much code :) need time to think about\n. i suppose it will generate some kind of 'error wrapper' and 'attach' validators to field, e.g.:\n<ul>\n<li>Username is required</li>\n<li>Username must be a valid email</li>\n</ul>\nand maybe use settings for - show all errors or only first (maybe a lot of validators - not good idea to spam user with errors) and settings for wrapping elements, as ul/li at example.\n<Validators mode={userForm} container={myContainer} error={myError}>\n<Required>...</Required>\n<Validators>\nand\n```\nfunction myContainer(props) {\nreturn {props.children}\n}\nfunction myError(props){\nreturn {props.children}\n}\n```\n. here is some attempt for 'proof of concept':\n```\nfunction ErrorContainer(props) {\n    return {props.children}\n}\nfunction Error(props) {\n    return {props.children}\n}\n....\n\nUsername\n\n\nUsername is required\n\n\n```\n```\nimport React, { PropTypes } from 'react';\nclass Validators extends React.Component {\n    getChildContext() {\n        return { container: this.props.error, valid: false};\n    }\nrender() {\n    return React.createElement(this.props.container, {}, this.props.children);\n}\n\n}\nValidators.childContextTypes = {\n    container: PropTypes.func.isRequired,\n    valid: PropTypes.bool\n};\nValidators.propTypes = {\n    container: PropTypes.func.isRequired,\n    error: PropTypes.func.isRequired,\n    model: PropTypes.object.isRequired\n};\nexport default Validators;\n```\n```\nimport React, { PropTypes } from 'react';\nimport { connect } from 'react-redux';\nfunction validate(val) {\n    return val && val.length;\n}\nfunction Required(props, context) {\n    return React.createElement(context.container, props.children);\n}\nRequired.contextTypes = {\n    container: PropTypes.func.isRequired,\n    valid: PropTypes.bool\n};\nexport default Required;\n```\nthe only thing left - somehow to attach 'validate' function from each validator to field component.\n. of course it would be better if Field would know something about Validators component and would gather validators by self.\n. can you make public the full example of 'submit validate'? i still can't make it to work :( trying to do login form with auth response.\n. thanks. works fine.\n. it's also much less by size and has quite strict separation.\n. i did npm update for 'react-redux-form' - nothing came\n. ",
    "luisrudge": "What do you want to do with that? I mean.. you can just react to the onChange method of country and fetch your cities.\n. ",
    "khanghoang": "Ya, you're right. I overthink it.\nI will open it again when there is a good circumstance\n. ",
    "tnguyen14": "@davidkpiano is this guide still available somewhere? The link you posted above no longer works.\n. Thank you. I understand that the guide may not be the most updated. I am just trying to figure out what I should use.\n. Thanks @Faulik and @davidkpiano . I am not sure what you mean by adding the custom field with key?\nThe doc seems to suggest that I need to implement a custom change event handler on my Input element, and have it dispatch an actions.change event. Is that right?\n. So I really liked the approach of using createFieldClass with the default controls, instead of declaring each props individually. However, my custom Input field is used generically for all text, textarea, checkbox etc. fields. So does that mean I'd have to create a new field of each of those input types?\n. That is nifty, and yes, Input has a type attribute. Could I even do something like\njs\nconst CustomField = createFieldClass({\n  Input: (props) => {\n    return controls[props.type](props);\n  }\n});\n. Just to update this ticket after talking with David on Discord:\nWhen trying to createFieldClass route, I'm getting an error because the custom component Input that I'm using include a non-input element (label). The error is Uncaught TypeError: Cannot read property 'length' of undefined on this line https://github.com/davidkpiano/react-redux-form/blob/b192a92/src/components/field-component.js#L133\n. @davidkpiano I just updated my app to the latest version to try this again. This time, I get this error instead. Have you seen it before?\ninvariant.js:39 Uncaught Invariant Violation: onlyChild must be passed a children with exactly one child.\ninvariant   @   invariant.js:39\nonlyChild   @   onlyChild.js:29\nrender  @   field-component.js:208\n. @davidkpiano sure I just pushed a temporary branch here https://github.com/tnguyen14/ledge/tree/react-redux-form\n. Yup, that fixed it! Makes sense. Thanks @davidkpiano for all the incredible and timely help!\n. ",
    "joshgeller": "Updating did the trick. Thanks!\n. ",
    "fingermark": "Nice.  Fix works.\n. > What does your ideal code look like for this? Can you post an example?\nGreat question.  Let me try out some things.  I'm still learning what's possible with react-redux-form.\nI'm interested in submitting a request only when the form is valid, while being able to fully use the response (success or fail).  I'll be be adding error messages to the form based on some failure messages.  With the response, I'll be dispatching another action.  I'll be using redux-observable for this.\nLet me try to implement this without the actions.submit for now to see what this looks like.  I'll be posting back today - monday.\nThanks again.  This is a nice library so far.\n. ",
    "arddor": "I like the approach, well done!\n. Awesome. However I have seen that no other recipe can be viewed. I assume that your changes have broken the other pages. Or is this just my problem?\n. I think it would be good if he wrote what he actually did that lead to the error...\nI'm assuming and this is a wild guess, that he does something like this (for react-bootstrap):\njavascript\nconst BSField = createFieldClass(\n  {Input: 'input'}\n);\nBut actually he should do:\njavascript\nconst BSField = createFieldClass(\n  {},\n  {Input: 'input'}\n);\nThis would result in somewhat a similar error.\n. ",
    "gitpjc": "Hi David,\nThanks for your quick reply, will try it out today.  Would really love to\nbe able to use the validation on the react-bootstrap components as well,  I\nbelieve a lot of other people use them as well so would be great if they\nare supported (I see someone else has already raised an issue about\nsupporting them).  I think it would be great if you could provide a\ndownloadable example of a simple application using your form that people\ncan play with so they can get the hang of it more easily and perhaps reduce\npeople not having to ask you questions because they have a working example\nto analyze.  BTW Your documentation is very helpful but some of the code\nexamples on your documents page are missing some imports and braces etc..\nso having a actual working example would be very helpful. Once again thanks\nfor the great module I really appreciate the work you have done so far.\nCheers,\nPaul.\nOn 9 Feb 2016 8:03 am, \"David Khourshid\" notifications@github.com wrote:\n\nHey Paul -\nFor Example 1, you just forgot to include the userForm in your\nselector() function. I'll be pushing up a quick check to better warn you\nthat you forgot to include a valid form state for getField():\nconst selector = (state) => ({\n  user: state.user,+  userForm: state.userForm\n});\nI'm taking a look at Example 2 now!\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/davidkpiano/react-redux-form/issues/15#issuecomment-181538586\n.\n. Thanks David,  your solution for my first problem works just fine. Really\nlooking forward to the validation working for the react-bootstrap\ncomponents since I have to use them on our project. More than happy to test\nout any solution you come up with.\n\nCheers,\nPaul.\nOn 9 Feb 2016 9:17 am, \"David Khourshid\" notifications@github.com wrote:\n\nThanks for the feedback, Paul! I have a ton of documentation updates\ncoming up and am still working through solutions for integrating React\nRedux Form with libraries such as react-bootstrap and material-ui. Let me\nknow if it works for you and I can close out this ticket for the first\nissue! :)\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/davidkpiano/react-redux-form/issues/15#issuecomment-181586780\n.\n. Thanks David.  As I already mentioned the Redux integration seems to\nalready work for the react-bootstrap components just have the problem with\nthe validation issue.\n\nCheers & Thanks,\nPaul.\nOn 9 Feb 2016 3:38 pm, \"David Khourshid\" notifications@github.com wrote:\n\nPerfect! I'll defer 3rd-party integration discussion here: #14\nhttps://github.com/davidkpiano/react-redux-form/issues/14\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/davidkpiano/react-redux-form/issues/15#issuecomment-181707962\n.\n. \n",
    "Kukkimonsuta": "Yes, that's exactly what I'd like to see. I'm currently using the workaround, but it feels too verbose for no good reason.\nThere are, however more properties that should be accounted in this feature, ideally anything that would render to the div if there were more elements. The list of all React supported attributes should be here https://facebook.github.io/react/docs/tags-and-attributes.html#supported-attributes . I'm not sure how to get to that list programatically though.\n. That's very good idea actually! More control over rendering is always welcome :+1: \n. Works great, thank you :cookie: \n. No, clearing the model is not desired behavior and reseting the field is not an option since I don't know what fields I need to reset. What I need is something like\njs\ndispatch(actions.resetValidation('createControl.createForm.form'));\nthat would be the same as calling for each field\njs\ndispatch(actions.setErrors('createControl.createForm.data.' + fieldName, null));\nThe scenario is:\n- user fills form\n- user submits form\n- server returns validation error on field GivenName and Birthdate\n- actions.setErrors is dispatched for GivenName and Birthdate\n- user fixes Birthdate field\n- user submits form\n- server returns validation error on field GivenName\n- actions.setErrors is dispatched for GivenName\nBut at this point are both fields GivenName and Birthdate marked as invalid from previous submit attempt, so I'd like to clear the validation errors before calling actions.setErrors for respective fields. This would be possible by dispatching actions.setErrors with null error for each field, but I'd have to name all the fields - instead I'd like to either get list of fields that are invalid or an action to reset the validation on them.\n. Sounds good, thank you :+1: \n. Thank you.\n. ",
    "lunaryorn": "@davidkpiano Thank you very much for the quick fix.\n. ",
    "mimamuh": "@davidkpiano Got the same issue with react-native 0.22.2, don't know why. I removed the .babelrc from the installed module and it works now. It's not really a solution, but maybe you could exclude it with your npm-ignore from your package like this: https://github.com/kadirahq/npm-base/blob/master/.npmignore?\n. Hi, yes, I created a example project here: https://github.com/MiMaMuh/react-redux-form-child-only-issue\n. Great, thx!\n. @davidkpiano Hi, yes, your test-case looks fine. I just looked to my issue: I updated to react-redux-form 0.14.1 and tried it again.\nI stumbled about a new issue with my temporary fix. To bridge this issue I wrote a onBlur function with: \njsx\n<TextInput \n  onBlur={(event) => this.props.onBlur && this.props.onBlur(event.nativeEvent.text)}\n/>\nThis works just fine with asyncValidateOn={'change'} but I just figured out it is broken with asyncValidateOn={'blur'}. It seems with react-native (0.26.3) the event.nativeEvent doesn't get the text property. \nIt may be a bug in react-native as i found this issue from Dec 2005 \u2013 I'm not sure if this fits to my issue as I tested it on iOS, but it looks similar.\nCurrently I think it isn't an issue of react-redux-form as your test seems fine. I haven't the time to upgrade my project to the latest react-native version and test it again, but I'll post it here when it seems to be fixed.\nThank you for your help!\n. Hi, thx for your quick fix!\nIt seems there ist still an issue: It works when a sync-validation is followed by an async-validation. But when a sync-validation follows an async-validation the store will be overwritten as before.\n. Hm, just considering it: It isn't really an issue. I think it is needed by concept this way otherwise there are conflicts when the value gets changed and the async-error prompts the field is invalid till it gets new results even it may be corret \u2013 tricky.\n. Okay. Yes, I saw the two differences but I think my issue is, that the value is undefined even if I map it with mapProps like: { value: (props) => props.modelValue }.  I logged the props within a map-function and saw modelValue is undefined. \nI've set the initial-state for formReducer and modelReducer but props.modelValue in the mapProps-function is undefined.\nIn my case I want to accomplish two things:\n1. Have an custom control which should display the modelValue initially. I tried to pass a initial-state to the modelReducer and the formReducer. This works when I use props.fieldValue.value within my mapProps-function but won't work with props.modelValue?\nIs it by design?\n1. My custom control uses validators which seem to run after mount. The validation always fails even if I set a valid value with the initial-state. I'm not sure if this is by design ... \n. Basically something like:\n``` js\nconst combinedReducer = combineReducers({\n    myForm: modelReducer('example', {\n        inputValue: '500.00',\n    }),\n    myModel: formReducer('example', {\n       inputValue: '500.00',\n    })\n});\n// ...\n```\n. Thank you, that was my issue!\n. Yes, of course. I think the issue is, that the model will not change when I just tab over the input without selecting it. But I do get the value-attribute-value of the input passed to the validator with isn't correct when nothing is checked I think. \nThere are two use-cases:\nI. I have a group of two radio-buttons where I have to select one of the two options but none is selected currently:\n``` jsx\n<Field\n   ...\n\n<input type=\"radio\" value=\"male\" name=\"gender\" />\n<input type=\"radio\" value=\"female\" name=\"gender\" />\n\n\n```\n\nNow a user uses its keyboard and jumps from a previous input to my radio-button-group. In this case, none of the radio-buttons is selected till the user clicks on one of the radio-buttons or press spacebar on its keyboard. For some reasons the user do not select one of the radios but just tab again to jump to the next input. \nThe model of gender is still nullbut the onBlur validator gets the radio-box-value passed which was focused: male for example. The input should show an error, because the user has to select one of the options but nothing happens, as the validator says: Hey, I got malebut the model says: You are a liar, I got nothing. :)\nII. I have a checkbox for legal reasons to confirm the privacy policy or similar:\n``` jsx\n<Field\n   ...\n\n<input type=\"checkbox\" value=\"privacy_policy\" />\n\n\n```\n\nThe same scenario: User uses its keyboard and jumps over the checkbox without checking it. The onBlur validator should check if it was checked because it is required otherwise show an error. The model is still null but the validator gets privacy_policy as its value ...\nI hope I could clarify it?\n. @davidkpiano Thx, yes, it works with v1.0.10 as long as I do not pass a custom validateOn prop. When I pass a custom validate prop like validateOn={['change']} it starts to validate only on blur and it doesn't matter if I pass validateOn={['focus', 'change', 'blur']} or validateOn={['focus', 'change']} ...\nIt seems, it gets buggy when I start to pass the validateOn prop. \n. @davidkpiano yes, of course:\nhttps://esnextb.in/?gist=e516266426da03e90e42e218e070c848\nI added both examples, the working checkbox and the buggy checkbox. It seems, the working checkbox without the validateOn prop fires the action rrf/setErrors directly after rrf/change which the buggy checkbox doesn't do. \n. @davidkpiano Thank you for your help, work and this great lib! \ud83d\udc4d \n. ",
    "jonlong": "@MiMaMuh @davidkpiano thanks for revisiting this! I did a little more research, and the root of it seems to be RN's move to Babel 6. Here's a thread with more info:  https://github.com/facebook/react-native/issues/4062\nThe team's official fix is just as @MiMaMuh suggested.\n. ",
    "chrisblossom": "Thanks for the quick response! \nAccording to http://semver.org:\nMajor version zero (0.y.z) is for initial development. Anything may change at any time. The public API should not be considered stable.\nSo since you are already following semver I should not consider this stable and not production ready, correct?\n. I appreciate the React reference, but they are not going to follow true semver until 15.0.0. Also react is completely different as it was used in production on Facebook prior to being released to the public as well as the power of Facebook behind it.\nSorry, I am not trying to argue, but trying to make a decision to use this or redux-form. I just figure if you are saying you are happy with the API as it is and you feel it is relatively stable, I think that should warrant a 1.0.0 release following semver. Could always post a warning about your concerns about it not being 100% production ready.\n. I can give it a go if you'd like. If/when you have time, send me a message on discord's reactiflux.\n. Closed via https://github.com/davidkpiano/react-redux-form/pull/30\n. @davidkpiano I just merged eslint the changes listed above. Let me know your thoughts on this PR when you get sometime.\n. @davidkpiano There was a problem with travis-ci downloading node 4 as specified in the .travis config file. Can you re-run the tests through travis? Doesn't look like I am able to.\n. I added a simple remake of mapValues that follows the current usage of it.\nhttps://github.com/chrisblossom/react-redux-form/tree/feature/bundle_size\n. Other lodash modules must share the same functions that are being used with mapValues.\n``` javascript\nBefore:\nInfo:   main.js 291.89 kB (~82.07 kB gzipped)\nlodash: 127.35 KB (12.1%)\nreact-redux-form: 35.47 KB (3.38%)\nmapValues feature/bundle_size\nInfo:   main.js 291.25 kB (~81.65 kB gzipped)\nlodash: 124.01 KB (11.8%)\nreact-redux-form: 35.59 KB (3.40%)\n```\n. +1. A flatter state shape would be a lot cleaner to work with. It would make accessing the whole form's state just as easy as it would be accessing each field. I would vote for a leading _ as it seems more JS-like, but $ works just as well.\nThis change will also make it consistent with the form itself.\n``` javascript\nconst { form, formShape } = this.props;\nconsole.log(form.foo); // value\nconsole.log(formShape.fields.foo); // field state\n// vs\nconsole.log(formShape.foo); // field state\n```\n. I am good with $. I still think this is a good idea to move forward on. @davidkpiano what are your current thoughts?\n. Looking at your deep-field example, it should currently look something like this ( @davidkpiano please correct me if I am wrong):\n``` js\nconst formShape = {\n  / formShape state /\n  fields: {\n    foo: {\n      / formShape.foo state /\n      fields: {\n        bar: { / formShape.foo.bar state / },\n      },\n    },\n    phones: {\n      / formShape.phones state /\n      fields: {\n        0: { / formShape.phones.0 state / },\n        1: { / formShape.phones.1 state / },\n      },\n    },\n  },\n};\nconst fooState = formShape.fields.foo;\nconst barState = formShape.fields.foo.fields.bar;\nconst barValue = formShape.foo.bar;\n```\nThe proposal would make it:\n``` js\nconst formShape = {\n  $field: { / formShape state / },\n  foo: {\n    $field: { / formShape.foo state / },\n    bar: { / formShape.foo.bar state / },\n  },\n  phones: {\n    $field: { / formShape.phones state / },\n    0: { / formShape.phones.0 state / },\n    1: { / formShape.phones.1 state / },\n  },\n};\nconst fooState = formShape.foo.$fields;\nconst barState = formShape.foo.bar;\nconst barValue = form.foo.bar;\n```\n. @davidkpiano Are you describing a helper method for the proposed changes? Maybe I am just misunderstanding what is going on with these arrays, but it looks to me with your example:\n``` js\nfield(userForm.contacts[1].phone).valid === userForm.contacts[1].phone.valid\nfield(userForm.contacts[1]).valid === userForm.contacts[1].$field.valid\n```\n. Is this what the userForm object would look like?\njs\nconst userForm = {\n  contacts: [\n    { /* contacts[0] stuff */ },\n    {\n      phone: {\n        $field: { valid: true, /* reset of field state */ },\n        number: { /* number state */ },\n        otherKey: { /* otherKey state */ },\n      },\n    },\n  ],\n};\n. So for validateOn=\"blur\" I use:\njavascript\n// in render() \nlet { userForm } = this.props;\njavascript\n// displaying the error\n{ \n  !fields.email.valid && \n  (userForm.submitted || userForm.fields.email.touched) &&\n  <div>Please check your email address.</div>\n}\njavascript\n// validateOn=\"change\" while-typing validation\n{\n  !fields.email.valid && \n  (\n    userForm.submitted ||\n    userForm.fields.email.touched ||\n    userForm.fields.email.dirty\n  ) &&\n  <div>Please check your email address.</div>\n}\nEDITED: looks like .focus is not needed with .dirty\n. The form's submitted state should be true if the form has been submitted. Shouldn't have to add any additional code / actions for this to work properly.\nYou should check userForm.submitted as well as userForm.fields.email.touched\n. https://github.com/davidkpiano/react-redux-form/issues/56 would cut down on some code here\n. Given: updateOn=\"change\" validateOn=\"blur\"\n``` javascript\n// After initial validation:\nblur:true\ndirty:false\nfocus:false\npending:false\npristine:true\nsubmitted:false\ntouched:false\nuntouched:true\nvalid:false\nvalidating:false\nviewValue:null\nvalidity:false\nerrors:\"Required\"\ninitialValue:\"\"\n// First focus\nblur:false\ndirty:false\nfocus:true\npending:false\npristine:true\nsubmitted:false\ntouched:false\nuntouched:true\nvalid:false\nvalidating:false\nviewValue:null\nvalidity:false\nerrors:\"Required\"\ninitialValue:\"\"\n// First change, non-blank\nblur:false\ndirty:true\nfocus:true\npending:false\npristine:false\nsubmitted:false\ntouched:true\nuntouched:true\nvalid:false\nvalidating:false\nviewValue:null\nvalidity:false\nerrors:\"Required\"\ninitialValue:\"\"\n```\nCurrently, touched does not get updated until a change happens to the field. This is making it difficult to reliably predict when errors should be shown. I am thinking touched should be false until first blur as shown https://scotch.io/tutorials/angularjs-form-validation\n. I believe the touched change to change on blur was done in commit https://github.com/davidkpiano/react-redux-form/commit/953af9a5963198dc3f8c37eff1af405826c4d4cc\n. onChange is not being called for me still when using updateOn=\"blur\" and pressing enter with 0.9.0.\n. Maybe I am completely misunderstanding what is going on/what the issue is, but wouldn't it be a lot better/sane to stop using forms inside arrays and store them in a plain object with an array pointer for order, similar to gaearon/normalizr.\n``` js\nconst redux = {\n  order: [1, 2, 3, 'foo'], // <-- Keep track of order here\n  forms: {\n    1: {\n      // form 1\n    },\n    2: {\n      // form 2\n    },\n    3: {\n      // form 3\n    },\n    foo: {\n      // form foo\n    },\n  },\n};\nconsole.log(redux.forms[redux.order[3]]); // foo\n```\n. > Just brainstorming here: what about a boolean option one can set, so if submit is attempted and some fields are invalid, the error properties will be set for those fields?\n@ffxsam That is exactly what I do using the .submitted state to see if there has been a submit attempt along with .valid.\n. This might be bad practice (if so, someone please clarify), but I think you need to add value={store.getState().editUser.firstName}.\n``` js\n...\nclass App extends Component {\n...\n  render() {\n  const store = this.context.store;\nreturn {\n    \n\nFirst name\n\n \n\n  }\n}\nApp.contextTypes = {\n  store: React.PropTypes.object,\n};\n```\n. Initially I disagree. It either limits how you display your values or requires another \"displayParser=\" option.\nImagine you want to store a phone number in redux without any special characters/only numbers, so 2085551234 but you want to display to the user a formatted number, (208) 555-1234. Currently you would parse the value inside the store using value={this.props.value ...}\nIf value={} is automatically added to <Field, then this would not be possible without RRF creating a displayParser option, which gets confusing...is it only for updateOn change? Blur?\nMaybe I am missing something though. Very possible.\n. First thought it seems like it could make styles etc complicated. What about just having a showError true/false state per field? \ndispatch(rrf.showError('userForm.email', true/false));\nIf you wanted to expand on that, there could be some config that would set the params to show errors.\njs\nconst config = {\n  showErrors: [touched, !valid, submitFailed],\n}\nEDIT: Also, the ability to store error messages already exists with the errors field (I think also possible with the validity field as well, just more difficult because of the way valid works.\n. FYI I had a breaking issue with this using Logstash/Elasticsearch to log redux state/actions. Because the type changed from an object to string, Elasticsearch would throw errors. Ended up having to instantly dispatch a redux action to reset the type of all errors and reset the database to clear the \"learned\" types.\n. That is awesome! Great news.\n. Peer dependencies aren't there because they are common. The reason react-addons-shallow-compare is a peer dependency is to preserve React 0.14 support. I don't think adding react-addons-shallow-compare warrants dropping support for 0.14.\nOn a side note, especially with pre-1.0 packages, you should pin your packages to specific versions and consider using npm shrinkwrap.\nEDIT: If React 0.14 support is being removed, it should be removed from the version requirements in the peerDependencies.\n. I can't speak for everyone, but I personally am still on 0.14 mainly because of aickin/react-dom-stream, which doesn't support 15 because they are trying to get the changes into React core.\nThink about when React 16 is released. If RRF is going to pin React down to a specific version, how long will it support v15? And when will it move to v16?\nEDIT: What about React v15.0.0 --> v15.1.0? You would have to break support for every React version released as react-addons* are tied to their React versions.\n. ",
    "sattaman": "Brilliant, thank you ! Apologies for missing the fact that example covered what I was trying to do, not sure how I missed it. Didn't realise I could do my checkboxes like that, super useful! \n. So I have an Field set to validate on change\n```\n     { return val && val.length} }} validateOn=\"change\">\n                \n\n```\nThis works but if I change the model through an action \nactions.change(\"myModel.field\", \"newValue\")\nThe validation is not triggered\n. Regarding my validation, I need it to be both onChange and triggered by an action. If the validation reran on change I suppose I could trigger change on all my fields with the same data? \n. I am not changing the value outside of react though, I am using the action to change them? \nI can do, although it would be better to have validaiton logic one place . One thing I did like about redux-form was how it handled validation, having a pure function doing it meant it could be tested in isolation. I also like being able to set the error messages to be displayed. \nI have been wondering about how it could be done, an action which took this pure function and applied it to existing validaiton, and Fields wrapped so they automatically called it on change? I noticed that one of your recent changes was to allow string error messages returned from promises. \n. Yes I like the idea of separating the validation, and I get your point about performance. Some features I'd be really interested are:\n- validation to be triggered by actions.change\n- form wide validation to be triggered from an action\n- ability to specify error text from validation\nBeing able to set error messages from the validation would be really useful from me. I haven't got my head around what you have already implemented, but I think I saw presently you can set the text if using promises? I dont know whether you could use true or text could be an error and empty or false for no error? \nI've been playing with wrapping the field and bootstrap input into a component, which would handle the logic for applying the error highlighting, and uses the help property to display any error message. I suppose if the validators could be defined at the form level then they could be removed from this.\nconst ValidatedInput = ({model, validators, field, ...rest}) => (\n        <InputFormField model={model} validators={validators}>\n            <Input help={field.errors} bsStyle={field.valid ? null : \"error\"} {...rest}  />\n        </InputFormField>\n    )\n. Ok cheers, that was quick! A few quick questions\n- Does form validation run for fields changed via actions?\n- Is it possible to trigger the validation from an action? \n- In order to specify error text, do I need to validate inside of an aciton?\n. Brilliant, will update. Thank you! \n. I ideally want to get it working with ReactBootstrap, I have tried both using controls.checkbox and controls .text.\n```\nexport const CheckboxFormField = createFieldClass({\n    'Input': controls.checkbox\n});\n vals.length}}>\n                        \n\n\n```\n. @muuki88 yes that's exactly what I found, I got it working with a singe checkbox in the end like this: \n```\nexport const CheckboxFormField = createFieldClass({\n    'Input': (props) =>\n        ({onChange: (e, val) => { props.onChange(!props.checked)} })\n});\n\n\n\n```\n@davidkpiano Another issue I had was, since all the bootstrap elements use the same control 'Input', something like \n```\nexport const CheckboxFormField = createFieldClass({\n    'Input':controls.checkbox\n});\nexport const TextFormField = createFieldClass({\n    'Input': controls.text\n});\n```\nDidnt work\n. Hi, thank you for your quick response, yes that explains why I was having issues.\nTo clarify, at present I had named my modal reducers names like:\nsms: createModelReducer(\"message.compose.sms\")\nAm I right in thinking it's only going to work if I instead use names such as \ncomposeSms: createModelReducer(\"composeSms\")\nDoes the reducer hierarchy affect it? For instance, if the reducer for my initial model handled state for 'message.compose'? \n`\n. I may have just spotted the answer in the other issues that was created, namely the nested state example. \nhttp://davidkpiano.github.io/react-redux-form/#/recipe/model-in-nested-state?_k=t4nbbq\n. @nickzarate It seemed to work , I don't think you can define more than one createFieldClass for the same input type, and putting them as text seemed to work. I initially had issues with the state path not matching the model. \n. I don't want to display error messages until the person has either attempted to progress to the next section (in which case I am firing the validaiton via actions), or has blurred or changed the fields. \n. Ok , so if I want to display validation messages if someone attempts to go to the next section without touching what would you recommend? \n. I don't actually use the submit functionality of the form at present. Would that touched be then passed down to all the fields? If updating the field.touched property is the way to go then any way of doing this from an action. \nI suppose the other thing I was wondering about was passing in the form into each validating component, but it would be tidier without \n// displaying the error\n{ (form.someProp || fields.email.touched) && !fields.email.valid &&\n  <div>Please check your email address.</div>\n}\n. Would it make sense if setting touched on the model that this would propagate to the fields? \nactions.setTouched(model)\nSimilar to the resetValidity? \n. Ok, so the plan is to know whether a field needs to display an error message you will need to check the form too? I currently have all my field validation handled by a wrapper around the bootstrap Input which I was just passing the field like so: \n<ValidatedInput field={getField(myForm, \"myField\")}>\nI guess I'll need to change to\n<ValidatedInput form={myForm} field=\"myField\">\nJust thought I'd double check.. \n. ",
    "muuki88": "So this is working with CheckboxFormField now? We have react-bootstrap as well and the complex-values examples doesn't work properly: instead of appending hobbies to the list, it just overrides it. Even we use plain input elements.\nI'll report if the CheckboxFormField works for use. \n. @sattaman were does the controls.checkbox property come from?\n. Sorry. import {controls} from 'react-redux-form';\n. We figured it out. Our error was that we didn't use the correct model paths. Because nesting reducers with combineReducers is the same as model in nested state.\nThis jsfiddle demonstrates how things are working now. Why it took us so long: all other form inputs seem to work (text fields, radio buttons). The checkbox however has an internal checked state. \nAnyway, thanks for your great library and the extensive documentation :)\n. Awesome :) Looking forward to it. We really like your library, but form  validation is always a bit... tricky ;)\n. Sorry, missed this important part :) \nThe props.validate was mapped from the actions in the mapDispatchToProps method.\n``` jsx\nimport {actions as formActions} from 'react-redux-form';\nconst mapDispatchToProps = (dispatch) => ({\n  validate: (model) => dispatch(formActions.validate(model))\n});\n```\nThe action is defined here\n. Okay, thanks for the clarification. We hoped to trigger the validation state for all nested components at once, so we don't have to duplicate the validators and put the model keys everywhere.\nWill this be part of a future release?\n. Thanks a lot @davidkpiano . This is indeed what we were looking for. I can now see why validator \"duplication\" is necessary as reducers can/should not be aware of any logic, but instead being provided with by actions. \nMay be I can create a small esnextb example showing how we do the validator implementation.\n. I build a small example showing how we could use this feature. Feel free to use this for you documentation. Putting the validators in all the correct places feels a bit error prone. Maybe the spread operator helps here ( esnextb seems to not support it ). WDYT?\n. Sweet! Thanks :)\n. ",
    "kmudrick": "I've used https://github.com/substack/node-deep-equal instead of lodash's isEqual and it is fairly small (but not sure if it is smaller than the lodash implementation)\n. So, the reason I asked is because I want to be able to do something interesting: 'reset' the model state for a form to some 'default' state that actually differs slightly from my initialState (so using the reset action creator would not quite work for that.(\nBut I realized - in my own reducer here that I probably don't want to muck with the existing state, since I should not need or require knowledge about how you are actually implementing reduction of the model.\nI guess alternatively, since I am using thunk, I could dispatch using the merge action creator instead?\nWhat sorts of things would or could I do in the reducer enhancer on my state without having to know the particulars of how the library is handling reduction of model values?\n. Perfect, thanks! Much cleaner now going with this approach :)\n. Is this helpful?  I created gists with what the output looks like for field-component with mangling off and with it on.  Copy pasted from my browserify bundle output.\nhttps://gist.github.com/kmudrick/8bff15a1089e4470429e\nhttps://gist.github.com/kmudrick/9f6052f983e95aba1d1b\n. FWIW, other specifics:\nbrowserify 9.0.4\nbabelify 6.4.0\ngulp-uglify 1.5.3 (uses uglify-js 2.6.2)\n. Awesome, thanks!  I am still pretty new to react so I didn't realize that could be the issue.  I'll give the displayName thing a try.\n. Confirmed that dropping in a displayName on the 3 custom components I was wrapping in Field fixed this issue for me\n. Thanks @davidkpiano - is that in the docs somewhere?  Did I miss it?  And how long has that been around?  (We're still on 0.7.2 unfortunately)\nEdit: ohhh, this is on the form component itself!\n. So, I see this was added in 0.7.0.  Using 0.7.2, I simply cannot get this to work.\nThe name of the model is 'skipCriteria'; the name of the model form is 'skipCriteriaForm'\n<Form\n          model='skipCriteria'\n          validators={{\n            '': {\n              thisIsInvalid: (skipCriteria) => true\n            }\n          }}>\n          // .... fields here\nI make changes to the fields themselves (which get reflected when I inspect the form props in react on 'skipCriteria'.) \nI don't see the skipCriteriaForm prop change much at all.  dirty gets set to true.  I don't see thisIsInvalid getting set anywhere in skipCriteriaForm\n. Trying to, but having major issues with esnextb.in right now.\n. Example:\nhttp://esnextb.in/?gist=6b67a70889e949d7cbdc183c9e7053e2\nI cannot get react devtools to work reliably with esnext, so I'm logging out the full props on each render.  As you can see, I don't see commentRequired or reasonRequired showing up anywhere in the skipCriteriaForm prop\n. I can try upgrading, though I am still trying to wade through all of the changes that have happened since early March to see what I need to look out for (hope that doesn't come off as ungrateful, it is just kinda tough to constantly be on top of every dependency these days)\n. Looks like the createFormReducer, createModelReducer renames & redux-thunk upgrade were the only changes I had to make :)\n. So, this is closed now, but - does the form \"valid\" property not actually get computed when following this approach?  Do I have to manually consider:\nvalid = !skipCriteriaForm.errors.commentRequired && !skipCriteriaForm.errors.reasonRequred\n. To answer my own question, from the docs:\n\nThe .errors property of the model field is set: ...\n... if validity is an object, .errors is set to the opposite of each validation key\n\nI needed to actually invert my validation criteria (reasonRequired: true if reason is not empty), etc\n. Oh, the difference between \"is this valid\" is that it is just a boolean, and \"is this an error\" being a boolean as to whether there is an error \"description\" for that field?  Is that right?\nSo If I am using that '': {...} validator on the form component, that is only setting validity, not errors, right?\n. To follow up: here is what I think is happening and is the source of my confusion:\nSince the validator keys (reasonRequired, commentRequired) did not match the model attributes themselves, the valid prop on the form was not getting recomputed correctly.\nThe function being invoked for each validation key should be answering the question \"is this valid\", so it should be returning true when that field/form is valid and false otherwise.  So the keys in the '': { k: v } validator prop should really map to the real model field names.\nI don't have an exact suggestion on how to rewrite it, but I think the validation docs could really use more clarification (it is extra tough when you are jumping between the description for \"Form Component\" and the general purpose description for \"Validation\")\n. Thanks @pauljz - we ran into this issue today as well with 0.13.1, when we merged in code with our second Form instance on a page.  Appreciate the fix.\n. ",
    "acidicX": "Webpack v2 will include tree shaking and only bundle the lodash functions you really used :-)\nhttps://medium.com/modus-create-front-end-development/webpack-2-tree-shaking-configuration-9f1de90f3233\n. ",
    "nickzarate": "@sattaman Is the example link you gave here, a working example? If so, why do you use controls.text instead of controls.checkbox (in the createFieldClass function) if you are using an Input of type checkbox? The docs for react-redux-form say that controls has a list of mappings, text is for text-based inputs and checkbox is for checkbox-based inputs. Does controls.text just happen to work for this instance or am I not understanding the docs correctly?\nJust for the record the action seems to always be firing true in my case as well, and here is the code I'm using:\n```\nimport React from 'react'\nimport { createFieldClass, controls } from 'react-redux-form'\nimport { Input } from 'react-bootstrap'\nconst CheckField = createFieldClass({\n  'Input': controls.checkbox\n})\nexport default class TestCheckBox extends React.Component {\n  render() {\n    return (\n      \n\n\n\n\n    )\n  }\n}\n```\n@davidkpiano Any tips as to what is wrong with my code?\n. My code is separated into different files, I hope its readable. As of now, everything seems to be working as it is supposed to, even with validateErrors, except that the value passed in to the error validator is undefined.\n```\n// MyComponent.jsx\nimport React from 'react'\nimport { Form, createFieldClass, controls } from 'react-redux-form'\nimport { Input } from 'react-bootstrap'\nimport { handleSurveySubmit } from 'actions/survey'\nconst InputField = createFieldClass ({\n  'Input': controls.text\n})\nexport default class MyComponent extends React.Component {\n  render() {\n     this.props.actions.handleSurveySubmit() }>\n      \n{ 'Are you currently a student?' }\n\n\n\n{ 'Continue' }\n\n  }\n}\n...\n// actions/survey.js\nimport { actions } from 'react-redux-form'\nexport function handleSurveySubmit() {\n  return (dispatch) => {\n    const { forms: { surveyForm } } = getState()\n    dispatch(actions.validateErrors('survey.isStudent', {\n      required: (val) => { console.log(val) } // undefined\n    }))\nif (surveyForm.valid) {\n  // do something\n}\n\n}\n}\n...\n// reducers/forms.js\nimport { modelReducer, formReducer } from 'react-redux-form'\nimport { combineReducers } from 'redux'\nconst initialSurveyState = {\n  isStudent: ''\n}\nexport default combineReducers({\n  survey: modelReducer('survey', initialSurveyState),\n  surveyForm: formReducer('survey')\n})\n...\n// reducers/index.js\nimport combineReducers from 'redux'\nimport { forms } from 'reducers/forms'\n...\nexport default combineReducers({\n  forms,\n  ...\n})\n```\n. Ya I have tried controls.radio. When I use controls.radio, everything works the same except that actual radio button that is chosen does not show up, and they are all unmarked (Although I think that's a separate issue). Are you sure it is a React-Bootstrap issue? Even when I take out the  component and submit the form without any user interaction, the validateErrors should be accessing my survey model reducer independently of what is shown to the user right? In that case I am not using Bootstrap at all, but I should still be able to validate my survey model state, though there may not be a point to doing so. Thoughts?\n. Using nearly the exact same code you used:\n```\nimport React from 'react'\nimport { Input } from 'react-bootstrap'\nexport default class Foo extends React.Component {\n  handle(e) {\n    console.log(e.target.value);\n  }\n  render() {\n    return (\n      \n this.handle(e)}/>\n         this.handle(e)}/>\n      \n    )\n  }\n}\n```\nI am not able to reproduce the issue, \"Yes\" and \"No\" are logged to the browser just fine. Not sure why that is. However, if I understood correctly, jquense answered that issue you submitted saying that that is the intended behavior right? (Implying it is not an issue to be 'fixed'). With that in mind, is there a possible workaround or is React-Bootstrap just going to be a problem? On that note, I am having issues with React-Bootstrap using a checkbox input and radio input, and I just saw issue #65, in your opinion, do you think it is worth it to use React-Bootstrap with RRF?\n. Oh sorry I was actually referring to the original issue, which wasn't even with the Radio button actually, that is working for me fine (except for in production because of uglify, and also I use controls.text which works instead of controls.radio which does not work). The problem I am having is that when I submit the form, I cannot validate the errors of any specific field. So for the isStudent state inside my survey model reducer, I can see that \"Yes\" and \"No\" are actually being set as the states, but when I submit the form, my error validators get undefined as the value being pulled from those states. I was confused as to why it was a ReactBootstrap issue because I thought validateErrors was independent of the actual component itself, and only related to the state in the model reducer. Actually (I just tried now), and when I use input instead of React Bootstraps Input, validateErrors is still returning undefined for me. This is the specific snippet of code where I am having trouble:\n```\n// actions/survey.js\nimport { actions } from 'react-redux-form'\nexport function handleSurveySubmit() {\n  return (dispatch) => {\n    const { forms: { surveyForm } } = getState()\n    dispatch(actions.validateErrors('survey.isStudent', {\n      required: (val) => { console.log(val) } // undefined\n    }))\nif (surveyForm.valid) {\n  // do something\n}\n\n}\n}\n```\nI'm pretty new to all this stuff though (even React and Redux in general), so I'm sorry if I'm missing something here or not making any sense, I appreciate the help!\n. @davidkpiano Ok, I figured out what the issue was. I actually suspected this from the beginning but for some reason it slipped my mind! So the issue I was having, and I think this extended to some other issues with RB, was that I have been nesting my modelReducers, and formReducers. I combineReducers of all of my model and form reducers under a forms reducer that I then use in my reducers/index.js. For some reason this extra layer led to issues, maybe because of combineReducers? Here is the snippet of code (from above) that caused the issue:\n```\n// reducers/forms.js\nimport { modelReducer, formReducer } from 'react-redux-form'\nimport { combineReducers } from 'redux'\nconst initialSurveyState = {\n  isStudent: ''\n}\nexport default combineReducers({\n  survey: modelReducer('survey', initialSurveyState),\n  surveyForm: formReducer('survey')\n})\n...\n// reducers/index.js\nimport combineReducers from 'redux'\nimport { forms } from 'reducers/forms'\n...\nexport default combineReducers({\n  forms,\n  ...\n})\n```\nHere is the code that works:\n```\n// DELETED reducers/forms.js\n// reducers/index.js\nimport combineReducers from 'redux'\nimport { forms } from 'reducers/forms'\nimport { modelReducer, formReducer } from 'react-redux-form'\n// import other reducers\n...\nconst initialSurveyState = {\n  isStudent: ''\n}\nexport default combineReducers({\n  survey: modelReducer('survey', initialSurveyState),\n  surveyForm: formReducer('survey'),\n  ... // other reducers\n})\n```\nI'm not sure if I should close the issue, it may be something you want to enable for RRF, or if not maybe mention it in the docs to prevent this from happening? (or maybe I just missed it). It seems nicer to me to have all of my modelReducers and formReducers in their separate file, and then combine them to a 'forms' reducer that is then used in the index.js of a reducers folder (I have quite a few model/form reducers already, and it takes up more space if you are using the Redux Devtools panel)\n. Haha wow, such an easy fix. Thanks!\n. ",
    "leesiongchan": "userId passing along to all the subcomponents seem to be little verbose. Do we have a better option?\n. ",
    "lasergoat": "One possible solution is this:\nform-reducer.js:130\n```\n  case actionTypes.SET_TOUCHED:\n    let formIsTouched;\n    let setTouchedState;\n\n    if (!localPath.length) {\n      formIsTouched = true;\n\n      setTouchedState = icepick.merge(state, {\n        fields: mapValues(state.fields, field => ({\n          ...field,\n          dirty: false,\n          touched: true,\n        })),\n      });\n    } else {\n      setTouchedState = setField(state, localPath, {\n        dirty: false,\n        touched: true,\n      });\n\n      formIsTouched = every(mapValues(setTouchedState.fields, field => field.touched));\n    }\n\n    return icepick.merge(setTouchedState, {\n      dirty: !formIsTouched,\n      touched: formIsTouched,\n    });\n\n  case actionTypes.BLUR:\n    return setField(state, localPath, {\n      blur: true,\n      focus: false,\n      touched: true,\n      untouched: false,\n    });\n\n```\nVirtually the same code as SET_PRISTINE\n. This takes care of setting the form to TOUCHED. BUT it does not take care of the SET_TOUCHED ability. Imagine this:\na user touched a field and then the code calls SET_UNTOUCHED. The form was touched so we need to check if other children were touched, if so the form stays touched but if nothing else was touched, then the form becomes untouched. PRISTINE implements this logic, but touched doesn't.\nThis PR does fix the issue at hand though.\n. correction: show=\"touched\"\nThis sounds good. though I'd like to be able to specify a className for the child spans. What if we could pass JSX into the component field.\ncomponent={<span className=\"blah\"></span>}\ncomponent={<MyElement></MyElement>}\n. Many times I find myself wanting to just use local state for forms and fields. However, as soon as I have to add validation I usually just switch everything over to rrf. Having an easy way to just use rrf for local states would be cool... but it might be the type of thing where it doesn't just work but instead you have to import Field from a different lib.\nimport { Form, Field, actions } from 'react-redux-form/localState';\nI've seen other libraries function in this manner. Then, local doesn't have to be set. If you want both at once, do:\nimport { Form as localForm } from 'react-redux-form/localState';\nimport { Form as globalForm } from 'react-redux-form';\n. just confirmed it by npm run build and moving the control-component to my project's npm folder. this fix works.\n. i have no idea who skrdaniel is lol... but my git config was just daniel@gmail.com which is not me... so I reverted my merge and re did it as actual me. Then, I added the important note.\n. fun fact, this also completes my hacktoberfest commitment.\n. @davidkpiano this is 90% for sure the same issue I'm having.\nI have store.payment which contains a meta.lineItems. lineItems is an array and is the only model affected by this bug. The rest of payment and payment.meta is reset correctly.\nHowever, for each key of payment.meta.lineItems[0] a rrf/change is dispatched with no value thus clearing that key completely from the array.\ndispatch(actions.reset('payment')),\nWhich results in these actions being dispatched somehow:\nConsole LOG\nHowever, if I switch my reset out for a change to the initialPayment object (the same object used in creating the form reducer, my problem is solved.\ndispatch(actions.change('payment', initialPayment)),\n(@jameshy you can use that as a workaround for now also... instead of a reset, just change it to the initial on your own.)\nProblem occurs in versions:\n\n1.3.2\n1.4.0\n1.4.1\n\nI don't have time to test each version but:\nv1.0.15 works just fine!\n. @dragGH102 Sorry for your trouble on this.\nThis is actually just an error in your understanding of LocalForm. The different between LocalForm and Form is that onUpdate, a non-Local form will dispatch the new values into your store model automagically. However, a LocalForm only gives you a way to alter your component's state.\nTake a look at this alteration of your code:\n```JSX\n  constructor() {\n    super();\nthis.state = {\n  firstName: '',\n  formValid: {},\n};\n\n}\n```\n```JSX\n this.setState({\n    firstname: form.firstName,\n    formValid: form.$form.valid,\n  })}\n  onSubmit={(values) => this.props.onFormSubmit(values)}\n\nFirst Name\n\nYou typed: {this.state.firstName}\nsubmit\n\n```\n\nSo - LocalForm gives you the ability to do your own thing with the values, but only if you supply an onUpdate handler.\nNow, if you need to change values outside of your LocalForm and have the model within your form update then let me know and I'll walk you through that also. . @AndyTriumpH can you inspect the .myModel.valueToSet.$form and see if errors are listed there?. @davidkpiano do you know?. @gkweb wow, you are right. By switching the dispatches (I know, bad solution and could cause a race condition) it fixes it. however, the reason i had to reset the validity is because without that if you had a validation error at index 0 and remove it, then suddenly the valid email at index 1 moves to index 0, but the field at index 0 is still marked as invalid.\nHere's a whole new example of that in action\nNotice that I commented out the actions.resetValidity().\nSteps:\n\nopen my new codepen\nclick add recipient twice to add two new emails\nin email number three type an invalid email like asdfasdf\nin email 4 type a valid email like bartle4@doo.com\nnow, click the \"Delete email 3\" button\nbartle4@doo.com which is now in the third spot is now invalid\n\n. ",
    "clarkie": "material-ui does add a lot of 'fluff' to the form elements. I had similar problems with redux-form too.\nI'll have a bit of a dig and post my findings here as I'm stumbling upon the performance issues being discussed over on the redux-form thread.\n. ",
    "greaber": "Thanks for the lightning response.  I'm not sure about an example for the docs, but in my case I have an existing model, and I would like to provide an interface for the user to edit parts of it using forms.\n. +1. I have a slight preference for $.\n. Yes, this approach makes sense.  But I am confused about how I would use the Field component if, for whatever reason, I wanted to.  I may just be overlooking something very obvious.\n. Whatever convenience bonus the Field component adds, shouldn't I be able to get it for my custom component?  Or if the added convenience is trivial, shouldn't it be trivial when using stock components too?  I'm not yet seeing why using the Field component makes sense in one case but not the other. \n. OK, thanks.  This is what I tried initially (although I didn't think about the displayName issue -- I thought an advantage of JSX was never having to think about that).  It wasn't working, but it is possible that is due to some other issue in my code.  I will try to make it work (or just go with the non-Field-involving approach you first suggested).  I'll let you know how it goes.\n. It looks like the Field-involving approach you suggest doesn't work because the mapping of value to props.modelValue gets overwritten by the value of value in  props itself.  I was able to make my component work by changing\nconst {onChange, value} = this.props\nto\nconst {onChange} = this.props\nconst value = this.props.modelValue || this.props.value\nalthough I get a warning that modelValue is failing its propTypes check since it has type object instead of type string.  (As I said in my original message, I am confused about why that propType check is being done.)\n. Thanks.\nIt looks like defaultProps in general take precedence over mappings specified using createFieldClass.  Probably that should be changed.  I looked through the code of React Redux Form, and it appears to me that the overwriting may be happening in the control component, here:\nreturn cloneElement(\n      control, {\n        ...this.props,\n        ...control.props,\n      });\nI also found a couple other places where there is props merging that may be questionable (but I'm not sure).\nIt looks like the controls you define in controlPropsMap are explicitly merging in the existing props last, which would override those mappings if I were using those, e.g.:\ntext: props => ({\n  defaultValue: props.modelValue,\n  name: props.model,\n  ...props,\n}),\nIn createFieldControlComponent, there is this code that seems to recursively accumulate props on nested components, which looks wrong to me, but I may be misunderstanding:\nif (!controlProps) {\n   return React.cloneElement(\n     control, {\n       children: React.Children.map(\n         control.props.children,\n         child => createFieldControlComponent(\n           child,\n           { ...props, ...child.props },\n           options\n         )\n       ),\n     }\n   );\n }\nAlso, in my own component, I wonder if it would be better form to set defaultValue using defaultProps and not value, and then I would not encounter any problem.  However, that is not really how defaultValue is used in the text component (see the mapping I quoted above).  That makes me wonder if I am confused about the semantics of defaultValue -- I would have guessed that the text control would map value to props.modelValue, not defaultValue.\nMore generally, it might be useful to have in the docs a recommendation about how to design the props on custom components if one has the luxury of doing so.  And the recommended ways should have preset mappings in controls under suitably named keys.\n. Sorry, I see this has been discussed under #74 and #77.  I will look at it more to see if I can understand the issue better.  But leaving this open for now.\n. I am using a Field component props mapping like so:\nconst standardControl = props => ({\n    onChange: props.onChange\n    , value: props.modelValue\n})\nI also assign a default value to the value props like so:\nPublicationDateInput.defaultProps = {\n    value: {\n        year   : null\n        , month: 0\n        , day  : null\n    }\n}\nBut now that the control component merges this.props after control.props, my value prop starts out undefined instead of what I tried to set it to as a default.\nA simple workaround would be to use some other prop instead of value, but it can be surprising for users if they can't name their props what they want.\n. This works, thanks.  I can't decide if it is the Right Way to do it -- maybe I should be setting defaults in my model instead of with defaultProps, or maybe React Redux Form should be merging props differently -- but it does the job in a really simple way :-)\n. Sure, you just need to do something like this:\n(showAllErrors || myForm.fields.myField.touched)\n&& !myForm.fields.myField.valid\n&& '*Error!'\nwhere showAllErrors is a prop that you set when the user clicks submit.\n. @ataube You could use component state for showAllErrors, or if you need access from outside the component, you could keep it in Redux.  I am not using any further abstractions like a form reducer enhancer.\n. Why is it considered good practice to specify an initial value for each model?  I already write out all the values of the model in two places: the actual form component and the constructor.  Since the initial state is invalid, I can't construct it with the constructor.  Why is it good practice to list out all the fields in a third place, pairing them all with empty strings or other semantically null values?\n. I might prefer an API that requires a little more typing but is more obvious.  I think that might be the true simplicity.  For instance,\n``` javascript\nimport { createStore, combineReducers } from 'redux';\nimport { modelReducer, formReducerFromModelReducer, modeled } from 'react-redux-form';\nimport bazReducer, { initialBaz } from '../path/to/baz-reducer';\nconst initialFoo = ...;\nconst initialBar = ...;\nconst foo = modelReducer('foo', initialFoo);\nconst bar = modelReducer('bar', initialBar);\nconst baz = modeled(bazReducer, 'baz');\nconst store = createStore(combineReducers({\n    foo,\n    bar,\n    baz,\n    forms: {\n        foo: formReducerFromModelReducer(foo),\n        bar: formReducerFromModelReducer(bar),\n        baz: formReducerFromModelReducer(baz)\n    }\n});\n```\nThis only uses the ordinary combineReducers, so the structure of your store is transparent from your code, even to people who don't know React Redux Form; and it doesn't use a function that has two different behaviors depending on whether it is passed a function or a non-function.  Also, for better or worse, it is less opinionated about how many form reducers you should have.\n. This is related to a question I have.  Before I was using React Redux Form, I had my own actions that would update parts of my model.  But now if I want to update parts of my model, I have to use the React Redux Form change action because otherwise the form reducer won't know anything has changed, right?  So, this means I have to rewrite any reducers that were responding to those old update actions and teach them to parse RRF change actions (except in the special case that they weren't doing anything except updating the model, so that using modeled is enough).  Or is it a good strategy to just fire my update action and then fire the change action (possibly causing some double updates, which would be harmless)?\n. OK, cool, looking forward to 1.0.  Although I wonder if it won't be better to just teach reducers to respond to change actions since they will be generated in response to user interaction even if there are custom actions that change the model in different cases (at least if using the Field component, unless that is also changing).\n. ",
    "SomethingSexy": "Thanks! I noticed when I submit against the <Form> it doesn't seem to run any validation that is set on the <Field>is that correct?  The use case here is that the user doesn't enter any information and they click submit.\n. That makes sense with what I am seeing, thanks! I have one other question then with regards to using the <Form> like you described.  If I have an array of data attached to that form, how would I go about adding that validation on the <Form> ?\n. Thanks, that should work.  Can you go deeper than that as well within numbers if necessary? If numbers was an array of objects?\n. Ya what I was asking (sorry if I didn't make that clear) was doing something like this \n<Field model=\"user.phones[3].type.foo.bar.baz\">\n  ...\n</Field>\nbut on the <Form> instead of the <Field>.  I don't see that in the Form documentation.  My only thought is that I would have to do a Form level validation and then process it manually? Unless the validation on the form can handle \n<Form model=\"foo\"\n  validators={{\n    numbers.type: (val) => isRequired\n  }}>\nor something to that effect?\n. Awesome, thanks for your time! I will try this out tonight.\n. ",
    "mdgbayly": "Still very new to react-redux-form so not sure I fully appreciate the issues being discussed here.\nIs this discussion concerned with how to represent nested fields properties in the form state object?\nHow do you envisage handling arrays in this proposed approach?\nI think this is how they are currently represented?\nformShape: {\n  ...initialState\n  fields: {\n    foo: {...initialState},\n    foo.bar: {...initialState},\n    phones: {...initialState},\n    phones.0: {...initialState},\n    phones.1: {...initialState}\n  }\n}\nThis proposal is talking about changing to something more structured?\nformShape = {\n  $field: { ...initialFieldState  },\n  foo: {\n    bar: { $field: {...initialFieldState  } },\n    $field: { ...initialFieldState }\n  },\n  phones: [\n    { $field: {...} },\n    { $field: {...} },\n  ]\n  // where does phones $field go? A property of the phones array object?\n  // OR\n  phones: {\n    0: { $field: {...} },\n    1: { $field: {...} },\n    $field: {...}\n  }\n}\nAm I talking about something different?\n. OK - not sure if I'm talking about the same thing but I thought currently fields were represented in a completely flat structure?\n\nBut I like your proposal, although it does make the syntax for accessing state and form state different?\nCurrent:\n```\nconsole.log(info.phones[1]); // value\nconsole.log(infoForm.fields['phones']); // array field state\nconsole.log(infoForm.fields['phones.1']); // item field state\n```\nProposed?:\n```\nconsole.log(info.phones[1]); // value\nconsole.log(infoForm.phones.$fields); // array field state\nconsole.log(infoForm.phones.1.$fields); // item field state\n```\nOR\n```\nconsole.log(info.phones[1]); // value\nconsole.log(infoForm.phones.$fields); // array field state\nconsole.log(infoForm.phones[1].$fields); // item field state\n```\nI was a little confused by the current difference in syntax for representing arrays in models (bracket notation) and arrays in fields (dot notation)? But maybe there is a good reason for that?\n. That matches my interpretation.\nJust make sure we don't lose the ability to have field state on arrays.\nfield(userForm.contacts).valid === userForm.contacts.$field.valid\nThe ability to have field state on arrays was one of the reasons why I switched from redux-form.\n. D'oh how did I miss that duplicate...\nTried it out - seems to resolve the issue for me. Thanks!\n. ha - this came back and bit me in another area of my app...\nI'm in the process of converting an app from redux-form to react-redux-form :+1: \nWe have an area of our model that is a sparse array so it is not keyed by the order of the fields in the view.  Instead we only add an entry to the array the first time a value is entered in an input in the view. The input fields have an associated identifier (mapKey) that maps them to a specific array entry. This means the order of the entries in the array can be different to the order of the fields in the view.  An example model looks like this:\nmapEntry: [\n    {\n        mapKey: 'answer_3',\n        mappedValue: '75'\n    },\n    {\n        mapKey: 'answer_1',\n        mappedValue: '50'\n    }\n]\nWe have code like the following that sets up a dummy model entry with an overridden onChange handler. The onChange handler adds a new array entry the first time the user types in a view field.  Subsequently, we setup the model value in the standard way by finding the associated array index.\n```\nfindMapEntry(mapKey) {\n  const { mapEntry, dispatch } = this.props;\nconst mapEntryIndex = mapEntry.findIndex((entry) => {\n    return entry.mapKey === mapKey;\n  }) : -1;\nlet mappedValue;\n  if (mapEntryIndex === -1) {\n    mappedValue = {\n      onChange: function(e) {\n        dispatch(actions.push('mapEntry', {\n          mapKey: identifier,\n          mappedValue: e.target.value\n        }));\n      },\n      model: ''\n    };\n  } else {\n    mappedValue = {\n        model: mapEntry[${mapEntryIndex}].mappedValue\n    }\n  }\nreturn mappedValue;\n}\n```\nBut this code doesn't work with the switch of the props.  I still think switching the ordering of the props is probably the right solution.  But maybe you have some thoughts on the best way to implement the requirement described above?\nFor now I've worked around it by changing the onChange function in the code above to onChangeOverride and then overridding the props mapping in our custom field.  (The field that represents mappedValue in the above code is already a custom field).\ne.g.\nconst CustomField = createFieldClass({\n    MappedValue: (props) => ({\n        ...props,\n        defaultValue: props.modelValue,\n        name: props.model,\n        value: props.modelValue,\n        onChange: props.model ? props.onChange : props.onChangeOverride\n    })\n});\nPerhaps, this is the best solution, or maybe there is a cleaner solution using some reducer tricks?\n. Thanks, I'll give that option some thought.\nMy first reaction is that it is probably not possible to switch to a format like that, but maybe I'm being blinkered.  That mapEntry data format is being given to our app by a backend service, so the client doesn't really control it.  We could normalize it in the client I suppose and convert back to the API format before sending back to the service, but we're trying to minimize the amount of knowledge in the client.  Also the range of values of the mapKey are out of the control of the client app, so I worry that trying to use them as a property name might cause other issues. But I'll give it some more thought.\nMy other thought was to dynamically set the FieldComponent.updateOn property to allow sending the array push action the first time the user types in a field.  Seems like that should work but having issues with it at the moment.  But might not be any less fragile that the solution I posted above.\n. The normalizr solution looks interesting.  It is certainly a pain to deal with these nested objects in an array. Would be so much cleaner if they were a dictionary like you suggested. The main thing stopping me from adopting it is that we do most validation server side and error responses use JSON pointer to indicate which part of the response is in error.  We use those pointers to dynamically set the validity of our model.  If we used normalizr to change the model client side we'd also have to normalize the JSON pointers somehow too. I guess that would be doable.\nAnyway, I have it working with a dynamically set updateOn function now.  That seems less hacky than the original solution I posted as it seems more what it's intended for: 'dispatch custom actions along with the actions.change(...) action'\n. pretty basic: in the example above we require the mappedValues to be numeric and in the range 0-100%.  So if a client tries to save data like:\nmapEntry: [\n    {\n        mapKey: 'answer_3',\n        mappedValue: '75'\n    },\n    {\n        mapKey: 'answer_1',\n        mappedValue: '110'\n    }\n]\nthen the error response from the API would contain something like:\n{\n    code: 'TOO_BIG',\n    pointer: '/mapEntry/1/mappedValue'\n}\n. Interesting idea, but I think we lost the mapKey in your example and unfortunately that is the key relational identifier.  Maybe I'm confusing it by using identifiers like 'answer_1'\nmapEntry: [\n    {\n        mapKey: 'apple',\n        mappedValue: '75'\n    },\n    {\n        mapKey: 'orange',\n        mappedValue: '110'\n    }\n]\n{\n    code: 'TOO_BIG',\n    pointer: '/mapEntry/1/mappedValue'\n}\nNormalized\nmapEntry: {\n  apple: { mappedValue: 75 },\n  orange: { mappedValue: 110 }\n}\nNow not so straightforward to translate our JSON pointer but probably not rocket science:\nNormalized JSON pointer\n{\n    code: 'TOO_BIG',\n    pointer: '/mapEntry/orange/mappedValue'\n}\n. To be honest, I'm kind of tempted to change our API to rework that mapEntry format.  It's a royal pain to have to deal with something that is essentially a map as an array.  We're trying to align our API format to an older legacy XML format which is why it looks like that.  I considered changing it to a plain old object where mapKey is just a property name.\nThe main reason why I didn't do that is because of the issue where we don't control the range of values that can be used for mapKey and I was concerned that a value might be used that would cause issues as a javascript property name e.g. because it clashes with a Javascript reserved name or can't be used with dot notation.  \nOut of interest, how is react-redux-form handling these field names internally?  Does everything get referenced using bracket notation (e.g. via icepick), or could there be areas where property names could cause issues with dot notation?\n. Ok thanks. In this case it is not a connected component but I can pass prev val as a prop from a parent connected component. Just thought if rrf has the prev val at the point of calling parse it could pass it too. I took a quick look at the code and it didn't seem like it does directly? So passing as prop is fine.\nThanks\n. \"It definitely can, but it would be the exact same as just passing in the value itself. \"\nDidn't totally follow what you meant by that? Do you mean same as passing in the value from the state?\nYes but in this case we're in an unconnected component that just takes in a model path string so no state unless we explicitly pass as props.\nMaybe it is wrong that we are doing the parsing in an unconnected component. But yes, for this particular use case it would be useful to have rrf pass current model value  as second parameter or have some way to reject a change.\nMaybe I'm making it too complicated...\n. Sorry, re-opening this to get some more input.\nIncidentally RRF rocks!\nI had a feeling this feature was going to be problematic.\nSo I've implemented the solution discussed above using the parser and passing in the previous value as a prop.  But the issue is that when the user types:\n11 => all is ok\nnow then type one more 1 which pushes the model value over 100 so our parser returns the previous value of 11\nRRF sends a change action, which updates the state (possiblly - it hasn't really changed), but then the component doesn't re-render so the edit control is left with the extra 1 and it still displays 111.\nI know this really makes sense because the state has not changed.  Presumably this is just pure Redux/React behavior rather than anything specific to RRF?\nJust wondering if you have any hints on how to work around such things? e.g. including some other 'key' type parameter in the state which I can change even when the actual model value doesn't change to force a rerender. Thinking maybe I'll have to reach for updateOn again to send that additional action?\n. OK - maybe this is because RRF is being smart and not updating a model value in the state if it has not changed?  If I explicitly update the state in my own model enhanced reducer, the component does re-render presumably because I'm forcing the state object to change?\n. Ok - thanks - I'll give that a try.  The inner control in this case from my app's perspective is a custom 3rd party component.  A masked input. I believe it maintains internal state even though you pass it a value prop, so maybe it's not really playing by the rules or maybe by design it is uncontrolled.\nAnyway, thanks, I'll close this one off again - you've been very helpful!\n. Sweet! thanks just what I needed.\n. Wow, you read my mind - also seems like a great solution for resetting field validity on change if you are not using validators...\n. Hmm, I guess it's a bit more complicated? Because the fields object has named properties? So if you remove something you have to rename all the properties that come after it to take into account the changed indexes?\n. Hmm - maybe hold that thought - i am seeing some very strange behaviour when removing - maybe I have screwed something up.\n. OK - my weird deletion issues were a different problem.\nSo yes, I think my question still stands regarding deleting fields when you remove a model entry?\n. Thanks, this is definitely better, but I don't think it fully addresses the issues.\ne.g. if you have an array of 3 items and the third one is invalid you'll have field state like:\nitem.0: {valid: true}\nitem.1: {valid: true}\nitem.2: {valid:false}\nIf you now delete the second item you end up with:\nitem.0: {valid: true}\nitem.1: {valid: true}\nwhereas I would expect:\nitem.0: {valid: true}\nitem.1: {valid:false}\nI think the fix you added is removing fields that no-longer have an entry in the model, but it isn't retaining field state.  I think part of the difficulty with implementing something like this is that the model reducer funnels most changes through the CHANGE action.  Whilst this is great for simplicity (in fact I love the simplicity of the model reducer!) I think it's losing information. \nI wonder whether the action creators should be passing the 'change based' actions on explicitly rather than defining a new model state in the creator and pushing all changes through CHANGE.  My impression is it wouldn't be a big refactoring to move some of the icepick manipulations for things like REMOVE to the model reducer.  Then the form reducer would have more raw information about the change on which to correctly adjust field states.\nI face a similar issue with the MOVE action I implemented.  In our app we can move items that have errors associated with them and ideally we'd like the errors to be retained.  When I get a few spare cycles I was going to have a play to see if I can come up with some ideas.\nCheers\n. @chrisblossom I'm not sure you're talking about exactly the same thing but your comment has made me stop and pause.  Our issue is that we have an array of data in a single form? Your example looks like it's referring to multiple forms in an array or maybe I'm just misunderstanding what you mean by a 'form 1' etc.\nThis is a simplified view but our app contains arrays in it's state like:\nstate: {\n    items: [\n        {\n             identifier: 'answer1',\n             text: 'Green'\n        },\n        {\n             identifier: 'answer2',\n             text: 'Red'\n        }\n    ]\n}\nWe can associate errors with the attributes in that state so if the state value 'Green' is invalid then we might have a field entry like:\nstate: {\n    answerForm: {\n        valid: true,\n        ...\n        fields: {\n            items.0.text: {\n                valid: false\n                ...\n            },\n            items.1.text: {\n                valid: true\n                ...\n            }\n        }\n    }\n}\nThe issue I'm dealing with is that if the user now deletes 'answer1'/'green', then answer2 now becomes the first item in the array, and unless we fix up the field state, it appears like answer2 is now invalid.  So at one level you need to 're-order/rewrite' all the field states to match the array state because the '.0.' and '.1.' in the field names represent array offsets.\nThe reason you're making me stop and pause is because I'm realizing that dealing with arrays seems to be tricky.  I've had similar discussion with @davidkpiano about issues relating to managing arrays in another area of our app and using normalizr was one suggestion he had made.\nWe're using arrays currently because that's the shape of the data that comes over the API we call and they seemed to be the simplest approach and to be supported by RRF.\nBut I can see now how they make managing field state complex and turning the '.0.' in the field name into a fixed identifier rather than an array offset would make things a lot less fragile.\nWill give it some more thought.\n. @davidkpiano \n\nWhy? Consider a model that has the elements [0, 1, 2, 3]. If you move, filter, or remove items and RRF handles the actions in a way that maintains field references based on item value, you'll get your expected result.\n\nI need to think about your suggestions some more but I'm not sure I was suggesting to maintain field references based on value?  I was thinking that if field references represent array offsets in the state and you change the state of those arrays, then you need to pass the modified array offsets somehow to the field reducer in order for it to correctly update the field state.\nBut it is cumbersome...\nIf you have an array of fields:\nitem.0.text: {}\nitem.1.text:{}\nitem.2.text:{}\nand you remove the state associated with item.0 then you have to rename all the fields above it to fix the array offsets.\nSo maybe you are suggesting using the trackby keys as an alternative to array offsets?\nOr as @chrisblossom  was suggesting maybe, steer clear of arrays in your state as they are trouble? Instead base everything around objects?\nSo will think about it some more.  In our model state that I showed in the previous post, we could potentially normalize around the item.identifier.  I've been reluctant to do that up until now as we don't control the namespace of that identifier and wasn't sure if it might contain values that are invalid javascript property names, But reading some posts on that it seems like there are not many things that are invalid property names if you use bracket syntax?\nOr alternatively we could introduce a level of indirection as maybe suggested by @chrisblossom  so that we can still deal with array data as objects.\n. cool - thanks - i actually took some of the advice from Chris and yourself regarding how to model things and we've modified our API format to normalize the data in some areas to make it easier to deal with.  But this enhancement looks like it will be really cool to have too.\n. It's kind of hard to show our exact code as the Field components are spread across other components.  Is the code for your recipe examples available somewhere - maybe I could take your Deep Fields example and try and replicate there?\n. Ah, sorry, yesterday was a long day...\nI meant delete Option 1!\n. I'll try and create a simple react-redux-form starter app tonight to demonstrate the issue I was hitting and to make sure it wasn't just some subtlety of the way we are using it.\n. Created an example app here to demo the issue we are seeing:\nhttps://github.com/mdgbayly/react-redux-form-starter\nContains two lists of things: phones and colors.\nCreate a couple of phone entries and a couple of color entries.\nThen delete the first entry in the list in each section.\nPhones list does NOT shift the second item up.\nColors list  does shift the second item up\n. I'm sure that would work as then we're making it a controlled component? \nBut with the way we are using these components the actual input tends to be a few layers deep. More like the CustomInput component I used for colors.  They are usually unconnected presentational components that don't have access to the form state.  Of course we could always set a value prop when we use those components.\n<CustomField model={`info.colors[${i}]`} key={i}>\n    <CustomInput type=\"text\" value={info.colors[i]} />\n</CustomField>\nI guess it was just confusing to me that it doesn't just work out of the box.  On the other hand if you give the phones an initial value, then that value is rendered even without setting a value prop (presumably via defaultValue).  Whereas after that they don't take external state updates?\nI was assuming the magic of react-redux-form was handling all the value syncing for me, so was surprised when it broke with remove.\nI think I'm probably still just being a bit dense about the whole controlled/uncontrolled/value/defaultValue thing.\n. Sorry, yeah, realize a full working code example would help with these kinds of things. Our react-redux-form app is part of a larger web application so not so easy for me to post as is.  I'll try and pull some of it out into an example project to help with these kinds of questions.\nIn the meantime, thanks, interesting hint about keeping the key consistent.  I had not realized React would do that.  It works for the general use case of maintaining focus and so is probably the best approach generally if you don't need to use rrf for tracking focus.\nThere is still one interaction where we need to change the focus programmatically. If a user is using the keyboard to move items up the list e.g. by pressing enter on the up button, when an item gets to the top we disable the up button and shift focus to the down button. But maybe it would be better to do that just in React too. I'll play some more.\nI'll close the question for now and re-open it if I have some more info/examples.\n. Hey ffxsam\nHave you seen the createFieldClass examples in the docs.\nWe use that approach to wrap a number of custom React components.\nCheers\nMartin\n. > I haven't yet figured out the best way for npm to pull from a GitHub fork yet, otherwise I would've done that.\nI do that by publishing the fork to npm using a scoped package name.\nhttps://discuss.reactjs.org/t/best-way-to-include-a-react-fork-in-my-project/313/2\nIncidentally, depending on what build tools you use, you can also use the browser field in your package.json to avoid having to rewrite all your requires/imports. e.g.\n```\n  \"browser\": {\n    \"react-maskedinput\": \"@mdgbayly/react-maskedinput\",\n    \"react-textarea-autosize\": \"@mdgbayly/react-textarea-autosize\"\n  },\n```\n. Created a PR #341 \nNot sure if best approach but was working for me.\nCheers\n. Yeh - you're right - I think it would be better to throw an error with a helpful message.  Will update later. Looks like there are now merge conflicts that need resolving anyway so I'll fix up later.\n. ",
    "zabojad": "\nSubmitting a form now sets its touched state to true.\n\nIn that case, submitting a form should set the state of its fields to touched=true ?\nWhen I do this:\n<Errors model=\"user.email\"\n  messages={{\n    required: 'Please enter an email address.',\n    length: 'The email address is too long.',\n    invalid: (val) => `${val} is not a valid email address.',\n  }}\n  show={(field) => (field.touched || field.submitted) && !field.focus} />\nThe validation error messages still doesn't show up when I try to submit a form that hasn't been \"touched\"...\nI think submitting an untouched form should either:\n- set the state of the fields to touched=true\n  or\n- set the state of the field to submitted=true\nSo that we can display an error message if the user clicks on submit before having tried to fill in the form\n. I'm working on \"react-redux-form\": \"^0.12.6\", which was the latest available on npm yesterday...\n. I just tried again and npm install keeps fetching 0.12.6, any idea why ?\n. Oh, it's OK now, I forgot the --save when rm and install... I have the 0.13.1 now.\n. I also confirm the problem I've initially reported is fixed in latest version :)!\n. > It should already work, in that it changes the model's value to the file path.\nIt should not change the model's value to the file path but rather to the File object... When we have an <input type=\"file\" />, we usually need the file object to send it over XmlHttpRequest...\n. I've workarounded it with:\n```\n    function handleFileChange(evt : js.html.InputEvent) {\n    var f = evt.target.files[0];\n\n    props.dispatch(actions.change(\"my_model.picture\", f));\n\n    props.dispatch(actions.validate(\"my_model.picture\", [ myValidators.isImage ]));\n}\n\n// ...\n            <!-- <Field model=\"my_model.picture\"> -->\n\n                <input type=\"file\" \n                       onChange={handleFileChange}\n                       accept=\"image/*\" \n                       capture=\"camera\"\n                       id=\"picture-select\" />\n\n            <!-- </Field> -->\n\n            <Errors model=\"my_model.picture\"\n                    messages={{\n                        \"0\": \"File must be an image\"\n                    }}\n                    show={{ touched: true, focus: false }} />\n\n```\nBut it is a workaround. I think it should work like this out of the box, don't you think?\nPS: don't mind the syntax, this is Haxe javascript syntax...\n. Also, when using defaultChecked on radios and checkboxes with RRF, I have the following warning:\nWarning: A component is changing an uncontrolled input of type radio to be controlled. Input elements should not switch from uncontrolled to controlled (or vice versa). Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://fb.me/react-controlled-components\nWhile I do not have this warning with pure React js (no RRF involved)...\n. @davidkpiano I'm actually using this because in the case of this form, I do not know the initial state at application startup. The initial state is dynamic and fetch from the server.\nHow should I set the initial form state in that case ?\n. PS: does it mean I should not use defaultValue on inputs type text too ?\n\nJust keep in mind that this will remove the ability for RRF to externally check/uncheck these components from outside changes\n\nWhat does it means more practically. What will and what will not work ?\n. ok, I'll do that instead... Thank you !\n. PS: can we dispatch the entire model value at once, ie:\ndispatch(actions.change('user', { name: result.name }));\n. I've just tested with version 0.13.7 and now it even worse: it will display the Errors components wrapper as soon as the field has lost focus (whether validation passes or not).\n. Also is it normal that a form can be submitted even if the validation rules set at the Field components level do not pass?\n. > > Also is it normal that a form can be submitted even if the validation rules set at the Field components level do not pass?\n\nNo, if you are using <Form>, then the onSubmit={...} handler will never be called for an invalid form.\n\nThen I have the following bug: if I submit a form without touching any field, it does trigger the onSubmit callback...\n. Let me describe more precisely the issues I have. Let's consider the following form:\n```\n\n<div>\n    <Field model=\"form_survey.answers.1\"\n           validators={{ \"required\": myValidators.isRequired }}>\n        <label>\n            <input key={1} type=\"radio\" value={1} />\n            <span>Option 1</span>\n        </label>\n        <label>\n            <input key={2} type=\"radio\" value={2} />\n            <span>Option 2</span>\n        </label>\n        <label>\n            <input key={3} type=\"radio\" value={3} />\n            <span>Option 3</span>\n        </label>\n    </Field>\n    <Errors model=\"form_survey.answers.1\"\n                  messages={{\n                        \"required\": \"This answer is required\"\n                    }}\n                  show={{ touched: true, focus: false }} />\n</div>\n<div>\n    <Field model=\"form_survey.answers.2\"\n           validators={{ \"required\": myValidators.isRequired }}\n           updateOn=\"blur\">\n        <input type=\"text\"\n               placeholder=\"Please type something\" />\n    </Field>\n    <Errors model=\"form_survey.answers.2\"\n                  messages={{\n                        \"required\": \"This answer is required\"\n                    }}\n                  show={{ touched: true, focus: false }} />\n</div>\n<div>\n    <Field model=\"form_survey.answers.3\"\n           validators={{ \"notEmpty\": myValidators.isNotEmpty }}>\n        <label>\n            <input key={1} type=\"checkbox\" value={1} />\n            <span>Option 1</span>\n        </label>\n        <label>\n            <input key={2} type=\"checkbox\" value={2} />\n            <span>Option 2</span>\n        </label>\n        <label>\n            <input key={3} type=\"checkbox\" value={3} />\n            <span>Option 3</span>\n        </label>\n    </Field>\n    <Errors model=\"form_survey.answers.3\"\n                  messages={{\n                        \"notEmpty\": \"This answer is required\"\n                    }}\n                  show={{ touched: true, focus: false }} />\n</div>\n\n\n```\nDetails / Problems:\n- If I do not touch any field and submit, onSubmit is triggered.\n- If I touch one required field but do not fill it, then validation triggers (and do not pass) and submission fails (onSubmit not triggered). The first submit will trigger validation on the touched field only (not other fields). A second touch on submit will trigger validation on all fields but will not display the validation message on untouched fields.\n- another issue I have on this form is: if I touch a field that has validators, fill it correctly or incorrectly (both gives the same behaviour) and touch another field, then the focus is not set on this other field and I have to touch it again to set focus on it. Here are the actions it generates:\n```\n{\"type\":\"rrf/batch\",\"model\":\"form_survey.answers.2\",\"actions\":[{\"type\":\"rrf/blur\",\"model\":\"form_survey.answers.2\"},{\"type\":\"rrf/change\",\"model\":\"form_survey.answers.2\",\"value\":\"jkl\",\"silent\":false,\"multi\":false}]}\n{\"type\":\"rrf/setErrors\",\"model\":\"form_survey.answers.2\",\"errors\":{\"required\":false}}\n{\"type\":\"rrf/focus\",\"model\":\"form_survey.answers.3\"}\n```\nWhile this behavior would be acceptable if validation on form_survey.answers.2 did not pass, it is not OK when it has passed...\n. I am using RRF Form component, not HTML form.\n. @davidkpiano Thank you for your help in debugging this.\nI'm trying to isolate what could cause the behaviour I've described and trying to reproduce it on esnextbin.\nI did not yet manage to reproduce all what I've described yet but here is a first reproduced issue: http://esnextb.in/?gist=df6cfa4a49e2a3ecadb6a03dcc07f2a0 => If you submit this right after rendering, it will display a validation on the first field while it should not.\nAlso something odd with the radio and checkbox inputs: if you change their value, it will trigger as many rrf/setErrors actions as there are <input> tags the the Field. Couldn't it be optimize?\nI continue on trying to reproduce those issues...\n. OK, first thing cleared out: I know now why it as submitting without validating. I'm using validator.js and the isNull() method of this lib return false on undefined (why ?!). And my form had validators only on input type text...\nI think the issue can be closed.\nI'll open a new one if needed and will provide a working reproducer on esnextbin.\nThank you @davidkpiano !\n. It seems to be because of the updateOn=\"blur\". How can I bypass this for the initialization of the default state?\n. There is some incoherence here... updateOn=\"Blur\" should make the component \"half controlled\", not uncontrolled at all... I don't see what is the use on this updateOn prop on Field if it make the Field component itself useless...\nIf it were half controlled (synchronizing with the form model/state only at initialization and on blur), then I could have workaround my issue simply by rendering the form after setting the form initial state...\n. @davidkpiano what about adding a submit() method to RRF Form? that we would call via a ref:\n```\n   function myCb() {\n       refs.myForm.submit()\n    }\n// ...\n\n...\n``\n. I'm having another case where I would need this: on some form, I need the checkboxes to trigger their form to be submit when they get checked... How could I achieve that?\n. @davidkpiano is there any temporary workaround I could use (for example some hidden method on the RRFFormcomponent for example) until you come back with some API to submit aForm?\n. @davidkpiano I confirm it works fine now with0.14.0:)!\n. @davidkpiano 3537554 does not address the issues I've described for0.14.1`? Do you confirm it's a bug?\n. > Can you look over that test case and make sure that it is exactly your use case?\n@davidkpiano yes this test case covers the 0.14.0 bug. I'm however not very familiar with writing test cases and I'm thus not sure it covers the 0.14.1 bug I've mentioned initially which is:\n\n-> fields do not update on blur even when there are explicitly set to do so,\n\nI'm pretty sure this fix just covers the 0.14.0 issue, not the 0.14.1 one.\n. @davidkpiano updateOn=\"blur\" still doesn't work on latest version :(...\n. @davidkpiano ok then I won't bother reporting anything else on v0 and I'll wait quietly for v1 :D...\n. Thank you @davidkpiano, it solved my issue !. @davidkpiano indeed it works. It could be useful to add to the doc though.... Here is a reproducer: http://codepen.io/anon/pen/KmzjQp. ",
    "trippingtarballs": ":wink: Sorry. My eager fingers hit enter too quickly. I'm just jotting down my post and I'll update the ticket. Thanks!\n. Awesome library! Love what you're doing for forms in the react + redux echo system. However, I'm having a slight issue with getting Immutable working in an isomorphic project.\nPrototype\nExtending the code snippet you posted on Stack Overflow I was successful in using the modelReducer, exported at react-redux-form/lib/immutable, to work with my immutable user model in the store. Within a sandboxed project I was even able to add the userForm object to the store (as suggested in the docs).\n``` js\n// store.js\nimport { createStore, combineReducers } from 'redux'\nimport { formReducer } from 'react-redux-form'\nimport { modelReducer } from 'react-redux-form/lib/immutable'\nimport Immutable from 'immutable'\nexport default createStore(combineReducers({\n  user: modelReducer('user', Immutable.Map({\n    email: '',\n    phone: ''\n  })),\n  userForm: formReducer('user')\n}))\n```\nProduction\nMoving out of the sandbox, I am attempting to integrate the above working example into my production app. The app is isomorphic, with a fully immutable client-side store. Isomorphism is implemented using something very close to the redux recommended recipe:\n``` js\n// client.js\nimport React from 'react'\nimport { render } from 'react-dom'\nimport { createStore } from 'redux'\nimport { Provider } from 'react-redux'\nimport App from './containers/App'\nimport reducer from './reducer'\nimport Immutable from 'immutable'                            // <-- new line\nconst initialState = window.INITIAL_STATE\n// over-the-wire JS/JSON hydrates into store as immutable\nconst immutableInitialState = Immutable.fromJS(initialState) // <-- new line\nconst store = createStore(reducer, immutableInitialState)\nrender(\n  \n\n,\n  document.getElementById('root')\n)\n```\nFrom the above extract immutableInitialState will reference an immutable object, and that is being used to hydrate the store.\nProblem\nuserForm in store.js will be an immutable type once the client-side store hydration has completed for my isomorphic app. When I then click into a field on my form I get the following error in the console, produced by the form's reducer:\n\nUncaught Error: Error when trying to retrieve field 'email from an invalid/empty form state. Must pass in a valid form state as the first argument.\n\nHaving dug into the source code of react-redux-form I believe the issue lies in the getField() function of reducers/form-reducer.js. I believe this function is executing on the assumption that the value of the state parameter is a plain JavaScript object - whereas, in my case, state references an immutable representation of the same object due to my client-side store hydration.\nProposal\nPlease review my issue and let me know what your thoughts.\nIf it's okay with you, I would like to fork react-redux-form and work on a PR that would enhance the current getField() function. I would like to upgrade getField() such that it can work with state when state is a plain JS object, and when state is an immutable.\nBefore starting such work may I ask that you confirm if updating the getField() function in this way is the cleanest means to solve this problem. \n. hmm .. do you mean a 2nd getField() function in immutable/index.js related to getting on immutables, and have getField() in reducers/form-reducer.js call into immutable/index.js for the scenario that the state is immutable? Or would you like for just the one getField() function, and have it moved from reducers/form-reducer.js to immutable/index.js?\n. Scratch that. I think I get what you mean. PR coming up ...\n. Okay, I know where #63 is going wrong for me ... I may need to change the structure of the logic to the formReducer ... Are you opposed to adding a project dependency on Immutable? I appreciate you're wanting to make react-redux-form a modular project.\n. @davidkpiano, thanks for all your help on this. I've decided to simplify my needs for now, and go in a different direction.\nI did have a go at the refactor on #63. However, the more I looked at it the more I realised it needs a big refactor - to the point where wasn't sure of the gain .. I too thought it might be as simple a case of .toJS(), but it's not. It's the logic of the formReducer itself. Because the state of the form and the state of the fields of the form are updated separately. :(\nThanks again. I'm happy to close this. \n. ",
    "ataube": "I would like to contribute to this issue, if there is anything I can do, give me ping...\n. Nice - would love to have this changes soon...\nI am wondering how to deprecate them? Printing a console.warn for every form reducer?\n. @greaber How do you mange the showAllErrors prop? I can only think of an enhancer of the form reducers supporting this flag. Can you maybe provide an example?\n. That's exactly what I was doing in the end as well, putting the showAllErrors flag in my local component state. Anyhow, it would also be nice to put this flag directly into the redux-form state because this information belongs to the form, doesn't it? \n@davidkpiano What is your opinion about it? I think it's rather a common use case to show all errors at once or not.\n. +1 having the .submitted state to behave as described in #60 would do the trick. This would allow me to remove the hacky showAllErros flag as local component state. \n. I updated the example (see above). Hope this makes it now more clear...\n. Many thanks for the quick feedback, it is working if I use the forms-prefix for the model-reducer and all other places like:\n<Field model=\"forms.myModel.list[0].x\" />\ndispatch(push('forms.myModel.list', {})\nThe code will get a litte verbose, especially if there are deep tree structures. But I also like the simplicity which makes react-redux-form fun to use... :-)\n. Great thanks\n. ",
    "i4got10": "Thanks!\n. Is there any way to detect which props user declare in component yourself, and which come from defaultProps?\nLooks like in your example onChange handler must override Field props. Not sure is it common scenario, never use it it in this way\n. Solve it this way, may be someone else will stack with it\n``` jsx\nimport React, { PropTypes } from 'react';\nimport _ from 'lodash';\nimport { connect } from 'react-redux';\nimport { actions } from 'react-redux-form';\nfunction selector(state, { model }) {\n    return {\n        model,\n        modelValue: _.get(state, model)\n    };\n}\nclass SelectField extends React.Component {\n    render() {\n        const { children, model, modelValue, change } = this.props;\n    return React.cloneElement(children, {\n        onChange: val => change(model, val),\n        value: modelValue\n    });\n}\n\n}\nexport default connect(selector, {\n    change: actions.change\n})(SelectField);\n```\n. fixed!\n. Also strange behavior here\nconst nameField = getField(form, 'name');\nconsole.log(nameField.errors); // empty object {}\nBut after applying validators it become simple boolean\n<Form\n                model={model}\n                validators={{name: value => !!value}}\n                onSubmit={this._save}\n                validateOn=\"submit\"\n            >\n. :+1: \n. Possible related to https://github.com/davidkpiano/react-redux-form/issues/65\n. Also meet that issue today.\nTo simplify you just need form(with validators prop) with one field(field must be without validator prop). \nEvery time after input will become valid, you need to press button twice.\n```\n !!val}}\n    onSubmit={this._save}\n    validateOn=\"submit\"\n\n<TextField model={`${MODEL}.name`}>\n    <input/>\n</TextField>\n<button type=\"submit\">submit</button>\n\n\n```\n. Will wait for release \ud83d\udc4d \n. expected: if one of fields is empty form will be invalid\nto reproduce: load the example http://codepen.io/anon/pen/jrPmaM and try to type anything in inputs. At start I expect that form is invalid.\n. Also try to comment line 32. With line commented, form start to work as expected\n. try to add this lines\n\ncomponentDidMount() {\n    this.props.dispatch(action.change('user', {username:'', email: ''}));  \n  }\n. @davidkpiano, I`ve got it. Sorry, it was really hard to understand. Problem raise if your have two form reducers with similar names(like user and userEx). I made a fork from your example to demonstrate the problem. Interesting thing here if you comment user and userForm reducers(line 10, 11) validation start to work as expected.\nExpect: that validation will work.\nReproduce: type some text in input\n. Thanks!\n. it also affect object values now. {} translates to [object Object] before. Dont know matter it or not\n. I can't use 1.0@beta in my real project, because it does not work without applying many changes right now. So, fix for 0.14.x branch would be appreciated. \n. Probably broke at this commit https://github.com/davidkpiano/react-redux-form/commit/f4939ed1216d93989ae7e7ddd794920cd8b9c131. @marcandrews do you have any ideas?\nLast working version is 1.14.1. @davidkpiano fixed already in master - https://github.com/davidkpiano/react-redux-form/issues/1160. Just need to release 1.16.10. ",
    "prawana-perera": "Thanks, helped me with my issue using reac-bootstrap:\nconst FormField = createFieldClass({\n    'FormControl': controls.text\n}, {\n    componentMap: {\n        FormControl: FormControl // recognize component by constructor\n    }\n});\n. ",
    "mjohnsonengr": "Wait, my bad, that's not Chrome's autofill, it's LastPass that's doing it.  Bug still stands.\n. ",
    "tomlagier": "Awesome, thanks for the quick response.\n. ",
    "tw0517tw": "after react 15.0, set value={} on <input> will cause warning.\n\nWarning: Input elements must be either controlled or uncontrolled \n. \n",
    "UlricGan": "I think if errors is undefined, it is not necessary to validate on it.\n. It is fine now.\n. ",
    "ffxsam": "Ahh. There's a mistake in the documentation:\nhttps://davidkpiano.gitbooks.io/react-redux-form/content/step_by_step.html\n<Form> requires a model prop passed to it.\n. This happens way after the creation of the Redux store and any reducers, though. To give more context, imagine a list of items, each with an edit button. Clicking edit for any particular item pops up a Material UI <Dialog> which contains a form, and that form is pre-filled with the item's existing data. But those form fields have to be linked with rrf.\n. I feel like I'd need to have some sort of dispatch that updates several fields at once, something I can call in componentDidMount.\n. Thanks!\n. Ahh ok.\nBTW, great work on RRF! I've tried many a React/Redux form package, and IMO this is the best one.\n. The only thing so far (very minor) is that I think it'd be good to rename actions.xor to actions.pull, just for consistency (push vs pull).\n. Hmm. If .errors and .validity are just opposites of each other, why have both instead of just one?\n. Let me check all this out today - I had a super busy weekend. Diving into the new changes now with a very barebones project and see if I can get it all working smoothly.\n. Ok, so this is just a first pass. Pasting here instead of a gist, because I don't want to have to keep the snippet around forever.\n``` js\nimport React, { Component } from 'react';\nimport { connect } from 'react-redux';\nimport { Form, Field, actions } from 'react-redux-form';\nimport autoBind from 'react-autobind';\nclass Home extends Component {\n  constructor(props) {\n    super(props);\n    autoBind(this);\n  }\nhandleSubmit(user) {\n    console.log(user);\n  }\ngetError(fieldName) {\n    const field = this.props[fieldName];\n    const errors = field.errors;\nif (!field.touched) return '';\nif (errors.required) return 'Field required.';\nif (errors.isNumber) return 'Need a number.';\n\nreturn '';\n\n}\nrender() {\n    const validators = {\n      firstName: {\n        required: value => !!(value && value.length),\n      },\n      lastName: {\n        required: value => !!(value && value.length),\n      },\n      zip: {\n        required: value => !!(value && value.length),\n        isNumber: value => /^\\d+$/.test(value),\n      },\n    };\nreturn <div>\n  <h1>Home.</h1>\n\n  <div>\n    <Form\n      model=\"user\"\n      validators={validators}\n      validateOn=\"change\"\n      onSubmit={user => this.handleSubmit(user)}\n    >\n      <div>\n        <Field model=\"user.firstName\">\n          <input placeholder=\"First name\" />\n\n          <div>\n            {this.getError('firstName')}\n          </div>\n        </Field>\n      </div>\n\n      <div>\n        <Field model=\"user.lastName\">\n          <input placeholder=\"Last name\" />\n\n          <div>\n            {this.getError('lastName')}\n          </div>\n        </Field>\n      </div>\n\n      <div>\n        <Field model=\"user.zip\">\n          <input placeholder=\"ZIP code\" />\n\n          <div>\n            {this.getError('zip')}\n          </div>\n        </Field>\n      </div>\n\n      <input type=\"submit\" />\n    </Form>\n  </div>\n</div>\n\n}\n}\nexport default connect(({ user, userForm }) => ({\n  user,\n  ...userForm.fields,\n}))(Home)\n```\nThis works pretty great! A couple issues:\n- I get a bunch of deprecation warnings every time I type, even though I'm not using any of the deprecated props.\n- Hitting submit without touching any fields still does nothing. The submitFailed property remains false in the form property list.\n. Thanks! I appreciate your taking the time on this. Once things calm down here, I'd like to learn the codebase and contribute with PRs.\n. Works great! I modified my getError method accordingly:\n```\n  getError(fieldName) {\n    const field = this.props[fieldName];\n    const errors = field.errors;\nif (!field.touched && !this.props.submitFailed) return '';\nif (errors.required) return 'Field required.';\nif (errors.isNumber) return 'Need a number.';\n\nreturn '';\n\n}\n```\nAnd once the user corrects a field, the error goes away. :+1: :+1: I noticed the retouched prop didn't change at all, but it turns out I didn't need it. (I expected it to turn to true once I focused on a field after the submit failed)\n. So is this correct?\n<Form\n        model=\"insights\"\n        validators={validators}\n        onSubmit={insight => props.onSaveInsight(insight)}\n      >\nvalidators = {\n  title: {\n    filled(value) {\n      return value && value.length > 0;\n    },\n  },\n  description: {\n    filled(value) {\n      return value && value.length > 0;\n    },\n  },\n};\nThe submission still occurs. Though I think it actually might not be good to just block that from being triggered, because it might be nice to display a dialog to the user prompting them to fill out the form. So I might just stick with my original approach of validating on the fields only, and checking things in the onSubmit:\nif (!this.props.formTouched) {\n      // Form hasn't even been touched\n      return;\n    }\n    if (this.props.formValid) {\n      // Don't allow submit if any field is in an invalid state\n      this.props.dispatch(userRequestedSaveInsight(data));\n    }\nThough if they leave a required field empty, it doesn't stop them at all. And ideally, it would trigger an error in the field too.\n. This is what I'm after:\n1. User is presented with form. All fields are blank, no error messages displayed.\n2. User focuses on a required field. No error displayed (since they haven't finished with the field yet).\n3. User begins typing, but backspaces so the field is empty. Still no error displayed.\n4. User tabs out of field. Error now displayed under field.\n5. User clicks submit. All invalid fields display an error. (at this point, they would say \"Field is required.\")\nI'd be thrilled if I could get this behavior.\n. Still trying to wrap my head around this. One of the things that trips me up about this package is that I'm not sure which field-specific states will trigger a state change in the form (for validity). There's a lot going on, and I feel like things could be simpler.\n. Well.. first off, I wanna emphasize that this is your creation, so I don't want to overstep. :)\nIMO, I feel like there are already way too many properties on the fields & form. It's difficult to remember and keep track of what they do. Simplification would be awesome.\nJust brainstorming here: what about a boolean option one can set, so if submit is attempted and some fields are invalid, the error properties will be set for those fields?\n. Ah yes, I just got a chance to look at that proposal. Sounds great!\n. You're totally right - and I forgot to come back and post that. It didn't used to be a requirement to use the form reducer, correct? And now it is?\n. Sure, I'll check it out when I get a chance and report back.\n. @mdgbayly You rock!! Thank you for that awesome tip, I didn't even bother to look there.. I guess because the section says \"React Native\" so I skipped it.\n. I think the name is good as is. It's descriptive, it's telling me that I'm creating a field class for my component. So for instance, in my code I now have this:\n<TagInputField model=\"trackModel.tags\">\n  <TagInput ... />\n</TagInputField>\nIMO the name customField is less descriptive.\n. Thanks David! I guess that was my question.. if I hit \"edit\" to edit an item and I want to pre-populate the fields, <Field> doesn't do that automatically, correct? I have to use action.load or action.merge to copy the object into Redux?\n. Duh. Why did I not think of that? Thanks :)\n. This is probably a good thing. If a text field is linked to RRF, then it should most definitely be a controlled input. I can't think of a scenario where I'd want it not to be. But I hardly use <Field> as I usually make my own input components, and using createFieldClass to map props automatically makes your component controlled, via the props.modelValue, correct?\n. Just to clarify this for anyone else reading it:\n<Field model=\"foo.bar\">\n  <input value={foo.bar} />\n</Field>\nObviously foo.bar would come up as an error. This should be a value coming from a Redux connect:\n```\n\n\n\n...\nexport default connect(({ foo }) => ({\n  bar: foo.bar,\n})(MyComponent)\n```\n. I'm having a similar issue. Using the Chrome redux devtools extension, I can see that when I click in a field, there's no focus Redux dispatch action. And as I type, nothing happens in Redux either.\nPaging @mbrookes of the material-ui project to see if he has any insight.\n. @davidkpiano Tomorrow I'll do a test case where I'll replace the fields with regular <input> fields and see if that makes it work.\n. Well, the big question is: is this a MUI issue or an RRF issue?\n. So the new controls and Control replace createFieldClass?\n. Excellent! Question about this:\n<Control component={TextField} propsMap={controls.text} />\nHow would I pass props into TextField then?\n. Gotcha, so Control will handle passing those props into TextField for me. Great!\n. I believe they belong in peerDependencies actually. That's how material-ui does it, at least.\nThe failure was that it simply wasn't working. Focusing in a field, typing in it.. none of those triggers Redux at all.\n. Absolutely!\n. Trying it out now.. (PS, you'll want to remove the stuff in devDependencies that you copied over to peerDependencies.\n. The packages in devDependencies are covered by being in peerDependencies though. devDependencies is typically reserved for things like linting, testing, and dev/performance tools only.\n. Actually on second thought.. material-ui has react in devDependencies as well. I'm not sure why. But I'd just model yours after how they structured theirs :)\nhttps://github.com/callemall/material-ui/blob/master/package.json\n. Ahhh ok. I'll admit, I don't totally understand npm's package system.\n. Man, I don't get it. It's still not working in production. Here are two screencaps.. first one is in production, the second is on my local dev machine.\n\n\n. But rrf is partially working in production. It can load data. Calls to it don't generate errors, but obviously fields aren't working.\n. Oh shoot! Nice find. I've got my own field wrapper I'm using too, BTW:\nexport const MUITextField = createFieldClass({\n  TextField: props => ({\n    onChange: props.onChange,\n    value: props.modelValue,\n  }),\n});\n. Sure.. but tomorrow morning :) \n. Yikes - don't use displayName. It's an extra step that devs don't really want to have to add into their code. If xyz is a React element, use xyz.constructor.name.\n. Oops sorry.. I missed the word \"workaround\" in your comment above \ud83d\ude0f \n. Though I can't seem to figure out how to get the name of a stateless component.\n. I still don't understand what's causing this to break in production. displayName, which RRF relies on, doesn't even exist for me in dev.\n. Testing now..\n. Yes, I see foo.bar being changed in the Redux devtools.\n. An example of my form code:\n<MUITextField model=\"insightModel.title\">\n              <TextField\n                floatingLabelText=\"Title\"\n                errorText={getError(fields, 'title')}\n              />\n            </MUITextField>\nexport const MUITextField = createFieldClass({\n  TextField: props => ({\n    onChange: props.onChange,\n    value: props.modelValue,\n  }),\n});\n. I still don't get why it breaks in production. If I inspect TextField in the Chrome console, $r.displayName and $r.constructor.displayName don't exist. And in your code, you're checking for names via:\njavascript\n    let controlDisplayName = control.constructor.displayName\n      || control.type.displayName\n      || control.type.name\n      || control.type;\nTextField has none of these properties, yet in dev it works fine. Am I missing something?\n\nthe issue is with the .displayName (or .constructor.name) not being visible in material-ui. It's unfortunate, but hey.\n\nNo, .constructor.name actually does work for MUI components:\n(Chrome dev console)\n\u00bb $r.constructor.name\n\u00ab \"TextField\"\n. @davidkpiano What did you find?\n. Where would I do that? This is my code:\n<MUITextField model=\"insightModel.title\">\n              <TextField\n                floatingLabelText=\"Title\"\n                errorText={getError(fields, 'title')}\n              />\n            </MUITextField>\nShould I just do:\nconst MyTextField = TextField;\nMyTextField.displayName = 'TextField';\nAnd then use <MyTextField>?\n. I'll give it a shot. Isn't the fix for this as simple as modifying this code:\nlet controlDisplayName = control.constructor.displayName\n      || control.type.displayName\n      || control.type.name\n      || control.type;\nto be:\nlet controlDisplayName = control.constructor.displayName\n      || control.constructor.name\n      || control.type.displayName\n      || control.type.name\n      || control.type;\n. Ok just curious :) I'd be happy to do a PR as well.\n. Sorry.. getting a lot of pressure from higher up to get this into production. I know this is free/open source so I don't have any expectations (some people get really rude about it), and I'm happy to contribute a fix too. But I'd just need you to publish to npm since I don't have that ability.\nI haven't yet figured out the best way for npm to pull from a GitHub fork yet, otherwise I would've done that.\n. I've got a fork of this exact code change, lemme test it out in production and I'll let you know how it goes.\n. Man, it doesn't work. I don't get it. I'll have to settle for the TextField.displayName = 'TextField' workaround for now.\n. Cool. I'll hang with the workaround till 1.0 then. Thanks for all your hard work!\n. Just confirmed this on a very minimal reproduction.\n. ## /client/reducers.js\n``` javascript\nimport { combineReducers } from 'redux';\nimport appstate from './appstate';\nimport { formReducer, modelReducer } from 'react-redux-form';\nconst defaultData = {\n  name: '',\n};\nexport default combineReducers({\n  appstate,\n  myModel: modelReducer('myModel', defaultData),\n  myForm: formReducer('myModel', defaultData),\n});\n```\n/client/pages/Home.js\n``` jsx\nimport React, { Component, PropTypes } from 'react';\nimport { actions, Field, Form } from 'react-redux-form';\nimport store from '/client/store';\nexport default class Home extends Component {\n  test() {\n    store.dispatch(actions.change('myModel.name', 'Nobody'));\n  }\nrender() {\n    return \nHome.\n  <button onClick={this.test}>Set myModel.name to Nobody</button>\n\n  <div>\n    <Form model=\"myModel\">\n      <p>Hello {this.props.myModel.name}</p>\n      <Field model=\"myModel.name\">\n        <input type=\"text\" />\n      </Field>\n    </Form>\n  </div>\n</div>\n\n}\n}\n```\n. \n. Ahh! The weird thing is, I checked out older versions and my code still didn't work.. very odd.\nI actually don't like the idea of having to reference this.props.myModel.name, because then any place I want to have a form, I have to wire up Redux myself, which gets messy. I'm following a very strict container model (see here and here), so this would mean I'd have to have containers everywhere just to use forms. The thing I actually liked about react-redux-form is that I didn't have to worry about using connect and mapping state to props.\nSo.. a very strong vote for keeping the functionality as it was before :) \n<Field model=\"myModel.name\">\n  <input type=\"text\" />\n</Field>\n. Really? Even in the documentation, you have this:\n```\nimport { Field } from 'react-redux-form';\n// inside a component's render() method ...\n\n\n\n```\nAnd I swear I didn't have to have <input type=\"text\" value={this.props.user.name} /> before. Strange. I feel like I'm in the Twilight Zone. ;)\n. Hey @davidkpiano - one quick follow-up question. In this case:\n<MUITextField model=\"insightModel.title\">\n              <TextField\n                floatingLabelText=\"Title\"\n                errorText={getError(fields, 'title')}\n              />\n            </MUITextField>\nwhere MUITextField is a custom component I made using createFieldClass, this makes the TextField a controlled input, correct? If I load data into the model, it will automatically populate the field.\n. In other words, I can use createFieldClass to make fully controlled inputs without having to use connect to get the redux state mapped to props, right?\n. I'm also getting a few warnings:\n\nWarning: Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://fb.me/react-controlled-components\nWarning: ReelDraft is changing a controlled input of type text to be uncontrolled. Input elements should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://fb.me/react-controlled-components\nWarning: ReelDraft is changing a uncontrolled input of type hidden to be controlled. Input elements should not switch from uncontrolled to controlled (or vice versa). Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://fb.me/react-controlled-components\n\nThe code is:\n<Field className=\"ReelDraft__name\" model=\"reelModel.name\">\n              <input\n                type=\"text\"\n                size={26}\n                placeholder={i18n.__('reelBuilder.namePlaceholder')}\n                value={reelModel.name}\n              />\n            </Field>\nAny ideas? Functionally it works. The field is pre-populated, and as I change it, it updates in Redux. But the warnings are a bit concerning.\n. Sounds good! I'll ignore the warnings then :)\n. I've got the Redux Dev Tools Chrome extension which shows all dispatches & state. What in particular should I look for? (there's a lot!)\n. That's the really odd thing. attachmentForm.valid is always true. I don't even have any validation code.\n. \n. The other fishy thing is that attachmentModel.errors is true, yet if I drill down into the details, the errors object is empty.\n. Wow, cool site! I'll try to put something together in the morning.. and hope that I can replicate it. Thanks!\n. I can't seem to replicate it in a new project.. argh! How can I go about debugging this, any suggestions?\n. Ahh, I got it! It's because the <Field> (or in this case <MUITextField>) doesn't exist when the page first loads up, so <Form> doesn't process it. But when the user chooses the attachment type \"text\", it adds the <Field> but it's too late since <Form> has already traversed through its children.\n(verifying..)\n. Nope. Bummer. I had some conditional code that would either show the field or not.. but I simplified my render's return statement to this:\n``` jsx\nreturn \n\n  <Form\n    model=\"attachmentModel\"\n    onSubmit={data => console.log(data)}\n  >\n    <MUITextField model=\"attachmentModel.content\">\n      <TextField\n        ref=\"textfield\"\n        hintText=\"Enter content here\"\n        multiLine\n        rows={6}\n        style={styles.textarea.outer}\n        textareaStyle={styles.textarea.text}\n      />\n    </MUITextField>\n    <div>\n      <RaisedButton type=\"submit\" primary label=\"Save\" />\n    </div>\n  </Form>\n</div>\n\n```\nAnd I'm still getting the setSubmitFailed. There's nothing fancy going on with the reducers, pretty basic. I'll try your debugging tips and see if I can figure this out.\n. @davidkpiano Ok, formValid is false. Very strange.\n. @Ok, I think a co-worker might've done something wrong. formValue.model is equal to \"messageModel\" which is not mine! Can you think of any reason why another model would be involved here?\n. Solved! Ok, maybe you can tell me what was happening here.\nA co-worker of mine had another model called messageModel with a field called \"content.\" The field name is the same as my attachmentModel.content, though this part was irrelevant.\nHowever, he had this:\njsx\n      <Form\n        model=\"messageModel\"\n        validators={validators}\n        onSubmit={message => this.sendMessage(message)}\n      >\nValidators:\njavascript\nconst validators = {\n  content: {\n    filled(value) {\n      return value && value.length > 0;\n    },\n  },\n};\nThis validator was somehow acting globally, and preventing my form from submitting.\n. So it seems there's some cross-contamination between forms. messageModel's validators definitely shouldn't be evaluated when I'm submitting attachmentModel. But.. I'm gonna guess that since your code has been evolving, we can no longer use validators this way :) I should check the guide for updates.\n. Well, I noticed the guide no longer demonstrates validators as a prop on <Form>.. so that might be outdated usage. I haven't tried putting validators on the <Field> instead. Honestly, since we're still in alpha, I'll probably just wait to add validators until you launch 1.0. We can't keep up with your progress! :)\n. You know, it actually hasn't come up again for some reason. I'm not sure if something on your end changed or on mine.. but it's all good now :)\nBTW, thanks for all the time & effort you put into react-redux-form! Much appreciated. If you're a Bitcoin user & share an address, I'm happy to send some beer money ;)\n. Awesome, thanks!\n. ",
    "madeinspace": "Hi there, \nI have a similar issue although I'm trying to pre-populate a form with some data that are stored in LocalStorage after authentication. The problem I have is that the reducer doesn't get the initial data from local storage in case the user is logged out and the store is created before the localstorage gets updated with user info. haven't found a way to update the form's model so far but a little help would be appreciated! thanks\nlet user = JSON.parse(localStorage.getItem('user'));\nconst initialUserState = user ? { loggedIn: true, user } : {};\nconst rootReducer = combineReducers({\nauthentication,\nregistration,\nalert,\n...createForms({\nuserLogin    : {},\nuserProfile   : initialUserState\n})\n});\nAlso tried the solution above to merge data on componentDidMount but how do get the model and value to componentDidMount? thanks!!\n. Hope this can be helpfull but I fixed it by dispatching the action.merge actioncreator in the componentDidMount function like so:\ncomponentDidMount(){\nlet user = JSON.parse(localStorage.getItem('user'));\nconst initialUserState = user ? { loggedIn: true, user } : {};\nstore.dispatch(actions.merge(\"userProfile\", initialUserState));\n    }`\n    . I think we have a similar question here that I would love to get insight on. I asked the question on StackOveflow:\nhttps://stackoverflow.com/questions/47951142/how-can-i-share-a-reducer-s-initial-state-with-another-reducer?noredirect=1#comment82872787_47951142. ",
    "jamesplease": "@davidkpiano , thanks for the link! It seems that the site no longer has the recipe hosted \u2013\u00a0is that recipe still available somewhere?\n. Thank you! :v:\n. :+1:\n. Cool. I'll do that. Thanks!\n. \u270c\ufe0f\n. Thanks for the quick reply, @davidkpiano ! I see now that I'm going outside of how mapProps is intended to be used. I'm sure I'll be able to find a way to refactor to make the problem go away. \nThanks again \ud83d\udc4c . For the record, I figure I'll add more info to this issue. The example I gave was a simplified version of what I'm actually trying to do. The intent here is that sometimes, the value that I pass down will come from modelValue (which comes from RRF), and then other times, from state. So something like this:\njsx\n<Control.custom\n  model=\"some.model\"\n  component={Dropdown}\n  mapProps={{\n    value: (props) => {\n      return someCondition() ? props.modelValue : stateValue;\n    }\n  }}/>\nBut this does not work due to the caching. The tl;dr here is that value in this Dropdown represents what is currently displayed. But the user can also type into the dropdown to search for results. When they have a search entered, we use their search as the value, because we want to show them what they're typing.\nBut if they select a value, or blur out, then we want to go back to using the modelValue instead.\n\nMy current thinking is that I'll somehow move modelValue into the state of the outer component, then pass that through.\n\nUpdate: Got it working. Thanks again @davidkpiano . . @henry-young , thanks for adding a test case for this. I appreciate that.\nAlso, thanks for the fix @davidkpiano !. Makes sense, @davidkpiano . Are there any hooks for when a value changes due to resetting? If not, do others think that's a problem, independent of whether the notification happens through onChange or not?\nThis causes an issue to me because the thing that resets the form is usually higher up than the controls themselves. There's no simple way for me to \"push\" action that reset down into the component, other than by accessing the value model value from the store. I haven't put too much thought into it, but it seems like a challenging project to get the value of a custom control that accepts the \".model\" syntax from outside of the component, say, in a mapStateToProps for the component that wraps it. My guess (I haven't dug into the code) is that the form puts some stuff on context, which the control then accesses. So I suppose I could access the context directly in my app to find the model, but that doesn't seem as elegant.\nAnother idea would be an onReset callback, but that would break the consistency RRF has with the built-in callbacks.\nAnyway, I'm not necessarily pushing for onChange to change, or anything. I'm open to any solution. If there's a recommended way to do this with the current API, then I'm definitely :+1: to that.. The above comment may have come across as rambling (I admit I was thinking through the issue as I was typing). Here's a simple challenge that illustrates the problem:\n\nBuild a component that wraps Control.custom\nWithin that component's render function, console.log() the current value of the wrapped Control's model\n\nOne way to do this is to use the onChange hook to set some state on the component equal to the new value passed through onChange. Then, you would log out that value in render. Because resets don't fire onChange events, the component's state drifts from the control's value.\nHere's a little snippet to show what I mean:\n``jsx\nclass CustomSearch extends Component {\n  render() {\n    // This may just be\".myModel\", so using it to get the model's value\n    // inmapStateToProps` isn't trivial\n    const { model } = this.props;\n    const { selected } = this.state;\n// When the form is reset, this console.log will be incorrect\nconsole.log('This control\\'s current value is', selected);\n\nreturn (\n  <Control.custom\n    model={model}\n    component={SomeComponent}\n    value={value}\n    mapProps={{\n      onChange: props => selected => {\n        this.setState({ selected });\n        props.onChange(selected);\n      }\n    }}/>\n);\n\n}\n}\n```\n\n~~My current solution is to no longer use the reset action creator.~~\n~~What I'm instead doing is manually changing each value in all of my forms to their initial value to mimic the reset. It's much more verbose, and requires updating the reset code anytime that the form updates, but it's one way to get around the problem for now.~~\nUpdate: Heh, nevermind \u2013 spoke too soon! The change action creator also doesn't trigger the onChange callback.\nThis is another train-of-thought thing, but it may be that I'm going about it the wrong way by trying to build additional behavior on top of Control.custom. I might instead need to flip things, so that my custom behavior is a regular component, then wrap that in Control.custom. In a little diagram, I currently have:\nDropdown \u21e8 Control.Custom \u21e8 CustomDropdown\nwhen I think I need:\nDropdown \u21e8 CustomDropdown \u21e8 Control.Custom\nwhere the \u21e8 symbol means \"wrapped by.\". Makes sense @davidkpiano . Thanks for the cross-reference!\nI haven't tried this yet, but I'm pretty confident that the solution is to always have Control.Custom as the \"highest\" component in a series of wrapped components. This way, it's connected for you, and passes the value of the model down to all of the children.\nI'm going to close out this issue for now. Thanks for all of the help, @davidkpiano !. Alright, so, update \u2013 I finally had a chance to refactor this for one of my inputs, and it ended up working. Here's a thorough description of the problem and the solution:\nFirst, I have a Dropdown component (similar to React Select). It sometimes displays text determined by the model's current value, such as when you've selected an option. But since it's a typeahead-style component, sometimes it instead displays whatever you've been typing. This is stored in the component's internal state.\nThere are two ways to handle this: one is to write a conditional to determine when to render state, or when to render the model's value. The other way is to always render the component's state, and then write code that keeps the state in sync with the model's value.\nWhen I opened this issue, I was attempting to go with the latter approach. But I am now using the former approach.\nThe tl;dr of my solution is:\n\nI set focused state in onBlur/onFocus events\nI set whatever the user types as value state on the component, as well as an associated selectedKey value on state\nIn the onBlur callback, check to see if the state's selectedKey value matches the model's value. if not, I reset the state's value to match the model's value. This is so if the user goes into an input that already has an option selected, and they, say, type \"asdf,\" then navigate away without selecting a new option, it goes back to what was selected before, rather than continuing to display \"asdf\".\nwithin render, if the input is not focused, then I display the model's value. if the input is focused, then I display the value from the state.\n\nBecause the component defaults to using the model's actual value unless the user is typing, then you get free synchronization with the model, which, well, makes a lot of sense in hindsight.\nThere are two takeaways from this:\n\n\nDo not wrap Control or Control.Custom with additional functionality. Keep those things pretty simple, and add additional functionality in the component that they wrap\n\n\nDo not attempt to keep state in sync with a model's value. If you want to use a model's value, use it directly. If there are situations where you want to use some other value, then it is a much simpler problem to detect those situations.\n\n\nIf anyone else runs into a similar problem, or has further questions, just leave a comment here and I'd be happy to help out.\nThanks again for all of the help @davidkpiano !. Sure thing :v:. I only had a moment to look at this, and I wasn't able to find the landing page in the source. I took a quick look in /docs and the root, and ran a search for the word \"versatile,\" but nothing came up. In an effort to find it, I tried booting up the site locally, but gitbook isn't listed as a devDep, so it wouldn't start.\nI've got to get back to work, so if anyone else wants to grab this, go for it. Otherwise, sometime in the next few days I'll:\n\nadd gitbook to the devDeps\nfind and remove the landing page\n\nThanks! And thanks for your quick reply @davidkpiano :v:\n\nUpdate: I just realized that the landing page is probably on the gh-pages branch \ud83d\ude09 . ",
    "Jore": "Thank you for this.\n. ",
    "eminaz": "@davidkpiano I could not open that link now, has the url changed?\n. ",
    "Psykar": "Numbers and booleans would help here - and/or a note in the docs.\nJust ran into this myself, and having a giant debate with myself of the various methods to handle selecting objects in a collection with a <select>.\n- Use ES6 Map objects, but with strings as keys instead of numbers\n- Use ES6 Map objects, and put parser props on all my selects to convert to ints\n- Use objects, which only works because all object keys are silently converted to strings\nHaving numbers on <option value={}> would allow me to use ES6 Map objects with numbers as the keys, reducing the need to convert them all over the place.\n. @igor-im yeah - if you're using objects that's probably only working because object keys are coerced into strings. I've got lots of options, it's just that the 'nicest' one isn't possible due to the native <option> event's being turned into strings. There doesn't seem to be an easy way to solve this in the general case this as @davidkpiano mentions.\nWithout this, the nicest one seems to be adding a parser={value => parseInt(value)} to the controls in question, which isn't too bad.\n. Ah, of course, then it's literally the same object returned from validate, sounds good to me.\nThe part that's a little more up in the air for me (before I'd look at starting a PR) is if the object should be returnable from both 'validator' and 'errorValidator'. The semantics for validate become a little funny if it can be {true/false/object} from validate, where 'object' is actually effectively a 'false' for most purposes except the messaging.\nerrorValidator, where 'object' is equivalent to 'true' seems more palatible, but the 'validator' pattern seems to be more recommended.\n. Ha, unfortunately in my use case min/max can change based on the value of another field, so const's are out. If only everything was simple... \nCan't commit the time to a PR just yet, but I'm hoping sometime this week.\n. If you're comfortable with that sure, that seems rather special case-y to me - although I suppose most people will be using either field level or form level validation, not both.\n. Another thing to note here - if the <Form> component's validators or errors prop changes, the form validation isn't touched. I feel that if either of these properties changes, the entire form should be revalidated.\n. There's actually a beta release already on npm:\nnpm install react-redux-form@1.0.0-beta.2 should work\n. Apologies, I'd started doing the test case and got sidetracked >.>\nThe use case is for dynamic validation that may change based on user input.\nMy use case is a large form which contains multiple 'modules' which can be enabled / disabled at will.\nWhen disabling a module, the data needs to be kept, but we no longer care about it's validation.\nSimilarly when enabling a module we want to start validating it again.\nI'm open to other suggestions - but in my mind the fact that changing the props on <Form> doesn't actually revalidate is a bug regardless of my usecase :)\n. @davidkpiano any chance of getting this added to the 0.14 stream? Should be ready to go.\nI did investigate the v1 beta, but ran into issues ( see #384 )\n. I managed to get a working test of this with the v1 beta, and it is still an issue there.\nI can do the PR against v1 if you'd prefer?\n. A closer look implies that the validator I've used is incorrect, as it doesn't get passed the value from user.lastName when validating, however I'm not actually certain what would be correct.\nIf the <Form> validator is set to\n{\n  lastName: {\n    required: (value) => {\n      console.log(\"checking last name\", value)\n      return false\n    }\n  }\n}\nThen it does get value on the validator, but the form state looks incorrect then as it comes out as \nforms: {$form: {...}, lastName: {...}, user: {...}}\n. (For reference, currently the return value of onSubmit is discarded.\nhttps://github.com/davidkpiano/react-redux-form/blob/c0984596004a31d9f2455dcd4684711850e5034b/src/components/form-component.js#L349\n). Bah, missed this yesterday. Had it as a date field originally but realised that's more complex than I needed for an example! Probably not an issue though.\n. Was getting an error thrown here, as nextChildrenArray was shorter than childrenArray\n. ",
    "igor-im": "@Psykar we use option value as the key in an Object/map, so to load object we got state.data[e.target.value]\nWe haven't seen a single issue with that\n. ",
    "djkz": "Here is how it's setup on my end:\n``` js\nlet defaultQuoteFields = { recipients:[], signatory_id:'' }\nconst quote_reducers = {\n  quote: combineReducers({ \n    quote: modelReducer(\"quote\", defaultQuoteFields),\n    quoteForm: formReducer(\"quote\", defaultQuoteFields)\n  })\n}\nconst app = combineReducers({\n    quote: quote_reducers.quote\n})\nstore = createStore(app,  applyMiddleware( thunk, raygun))\n```\nmodel is 'quote.quote.recipients'\n. Thanks\n. Congrats on 1.0!\nAre you planning on publishing the umd build to npm so it can be downloaded from the /dist again?\n. ",
    "andykent": "Wow, fast work thanks! \nI'll have a play now. \n. ",
    "enkay": "@davidkpiano How would you get the whole form input values to submit whenever a text field changes? I'm using the same handleSubmit function as the form onSubmit for the submitPromise but it needs the input.\n. @davidkpiano Let's say I have a list of books and I want to filter through them using a text input for searching book titles, and an array of checkboxes for selecting genres.\nThis is the input object I would like to pass through to the getBooks action which handles fetching the books from the server every time the form submits.\n{\n  search: 'book title string',\n  genres: ['fiction', 'historical']\n}\nI would also like this form to submit, and therefor to dispatch the getBooks  action with that input object every time the search input changes or a genre is checked of unchecked.\nWhat is the best way to do that? (with v1)\n. Yes but how do you get it to submit the form whenever the value of the search field changes or a checkbox gets checked or unchecked?\n. In this example handleSubmit doesn't accept any arguments, how do you get the form input data into the handleSubmit function?\n. Awesome that works, thanks!\nI also got it to work for onChange, I'm not sure if the code is optimal but it's working.\nhandleChange(e) {\n        this.props.dispatch(actions.change(e))\n        setTimeout(() => {this._form.submit()})\n    }\n. Great, thank you!\n. Thank you for taking the time to answer.\nI got it to work using actions.submitFields('model', submitPromise)\nI am however curious as to how actions.submit is meant to be used. It would seem like submitting a form and validating on the API as the form is submitted is a very common use case, I'm surprised this requires an undocumented function.\nIs there a better way to do this?\n. Thanks for your help.\nIs it possible that the submitFields method is not setting the pending variable to false automatically once the request has been made? It seems stuck in pending state even though the form submitted successfully.\nI've added it manually but is this how it should work? It seems like it should set it to false automatically since it was set to true. Could it be I'm doing something wrong in my submitPromise?\nhandleSubmit(input) {\n    const { dispatch } = this.props\n    const submitPromise = dispatch(submitForm(input))\n    dispatch(actions.submitFields('form', submitPromise))\n    .then(() => { dispatch(actions.setPending('form', false))})\n}\n. I was not referencing the form properly, pending is now getting set to false properly and errors are showing when the API returns a validation error, thank you.\n. ",
    "jeniamoroz": "```\n  componentWillMount() {\n    this.props.dispatch(actions.merge('user', this.props.user));\n  }\ncomponentWillUnmount() {\n    this.props.dispatch(actions.reset('user'))\n  }\n```\nfor sure, that's a dirty solution\n. hmm, figured out by having \"modeled\" reducer\nfunction initialValues(state = initialState, action) {\n  switch (action.type) {\n    case 'SET_INITIAL_VALUES':\n      return {\n        ...state,\n        ...action.values\n      };\n    default:\n      return state;\n  }\n}\n///////////\nconst rootReducer = combineReducers({\n  entities,\n  user: modeled(initialValues, 'user'),\n  userForm: formReducer('user')\n})\nand just dispatch action\ncomponentWillMount() {\n  const {dispatch, user} = this.props;\n  dispatch({\n    type: 'SET_INITIAL_VALUES',\n    values: user\n  })\n}\n. exactly.\nright now I'm about to give you PR, I think it would be \"nice to have\" this action globally ;)\nUPD:\nIt's pretty much the same as change() or merge() function, but it will not make form \"dirty\"\n. ",
    "Rhywden": "nvm. It was another module which silently swallowed anything.\n. Just played a bit with the version numbers - the breakage occurs when going from 0.9.0 to 0.9.1\n. ```\nimport { createFieldClass, controls } from 'react-redux-form';\nconst MTextField = createFieldClass({\n    'TextField': controls.text\n});\nexport default MTextField\n```\nTaken straight from the docs.\n. Okay, it's an issue with the validation which makes sense, considering the commits between 0.9.0 and 0.9.1.\nIf I remove\nvalidators={{\n    username: {required},\n    password: {required}\n}}\nit doesn't throw an error anymore.\n. You mean this? https://github.com/Rhywden/nawischule/blob/master/client/reducers.jsx\n. https://github.com/Rhywden/nawischule\nSpecifically: \nhttps://github.com/Rhywden/nawischule/blob/master/client/containers/TitleBar/LoginPopover.jsx\nhttps://github.com/Rhywden/nawischule/blob/master/client/containers/TitleBar/LoginPopoverContainer.jsx\nAnd, yes, I know that the validation is not exactly great at the moment :)\n. Will do and get back to you tomorrow - it's a bit too late for me to be delving into this further.\n. @ffxsam Already did that. Regular <input /> fields behave as they should both in development and production.\nAnd, yes, MaterialUI textfields don't send the proper dispatches when in production.\nProblem is that due to having upgraded to React@15 I cannot easily revert back to an earlier version of MaterialUI - would probably have to nuke the npm_modules folder and package.json and then try to rebuild everything, starting with a working version of MUI.\n. The lack of error messages make such things always soooo much fun. I'm pretty sure that a language like C# would have already thrown an exception somewhere :)\n. Solved in #147 \n. I can submit success!\nThis indeed solves my issue with the empty model.\n. 0.9.14, or so it seems. Hrmh. And I did an npm update five minutes ago. Will have to see why it doesn't pull in the newer version. Any tips on that?\n. Okay, I still don't know why npm didn't do the one job it's supposed to do but manually bumping the version in package.json seems to have done the trick.\nOne more thing to look out for, or so it seems. Thanks for the prompt reply!\n. ",
    "asvetliakov": "Updated for version 0.10.4 for anyone interested:\nhttps://gist.github.com/asvetliakov/cb814992efb4d89be59867c1c0699795\nRemoved direct deps for redux until new TS 2.0 library references will be landed \nI can host it via typings if @hsrobflavorus agree\nAlternatively @davidkpiano can host it in lib itself (just renamed to index.d.ts or add \"typings\" field to package.json)\n. oh, yes, sorry, i mean updateOn=\"blur\" of course.\nUnfortunately this doesn't work, using your codepen example\n<Field model=\"user.username\"\n          validators={{\n             isRequired,\n            length: (v) => v.length > 1,\n          }}\n          changeAction={(model, value) => {\n              store.dispatch(actions.change(model, value));\n            store.dispatch(actions.setValidity(model, { length: false }));\n            console.log(userForm.fields.username.errors.length); \n                       }}\n          updateOn=\"blur\"\n          validateOn=\"blur\">\n          <label>Username</label>\n....\nafter typing kkkk in field the userForm.fields.username.errors.length is still true because the userForm was binded into context (or re-render didn't happen yet, or something else)\n. My fault, need validateOn=\"change\"\nSorry for bothering\n. Can you make patch release with it?\n. Thank you very much!\n. Yeah, that would be pretty good\n. No rush, since actions.batch() is good workaround for now :smile: \n. Wow, that was very fast! Thank you\n. Looks very good. This way i can throw away trick with calling reducer inside reducer\nWhat about initial form state?\n. Will be result of [enhancers] merged on first run?\ni.e. something like this:\njs\nconst fieldIconStatus = (formState = { fields: { myField: { iconStatus: \"disabled\" } } }, action) => {\n...\n}\nconst reducer = enhanceForm(userFormReducer, [fieldIconStatus]);\nconst state  = reducer(undefined, {});\n// state now:\n{\n  ....\n  fields: {\n    myField: {\n      ...\n      initialValue: '',\n      iconStatus: \"disabled\"\n    }\n  }\n}\nThe problem is to not add additional actions processing to the formReducer (calling reducer inside reducer is ugly but works flawlessly, and anyway it's needed to be done if you want to keep whole state tree as Immutable), the problem is getting own initial state to be merged into form initial state\n. > How about instead of initial state you think of it as default state?\nI.e assume that myField.iconState === undefined by default? That may work for one situation and may not work for other. I.e. this doesn't solve the problem if you want other value rather than undefined.\nSecond form initialFieldState is fine but has drawbacks:\n- need to have two options for form state and field state if you want to attach values to form rather than fields\n- this doesn't look very good:\njs\nformReducer('user', {\n  email: '', // these fields define field state too\n  firstName: '',\n  initialFieldState: { iconStatus: 'disabled' }, // ??? another field state?\n  initialFormState: { formProp: false }\n}\nsomethin like it will be more clear from consumer perspective but will break current API:\njs\nformReducer('user', {\n initialValues: {\n   firstName: '',\n   email: ''\n },\n initialFieldState: { iconStatus: 'disabled' }\n...\n}\n. This better, but why you can't agree with just merging third param into initial state?\n. Yes, sounds good :+1: \nAlso, you should mention in docs that modelReducer(name) should be mounted exactly in root.name , and you don't support immutable states for all action which returns action thunks (such as validate()) since you're calling get(getState(), modelPath) in them :smile: \n. > Hmm, mind opening a separate ticket for that? This would be a good enhancement for v1.\nSure\n\nGood point, I thought I clarified that, but since others are asking questions, I'll add more clarity around that.\n\nThat was surprise for me (however after looking in code itself it became clear why). This breaks Form/Fields components too, so i ended dispatching actions in vanilla onChange/onBlur etc.. and happy now (almost :smile:)\n. Wow, thank you!\n. Supposed fixes:\n1) Provide root state prefix for such actions and form/field components?\n2) Provide setter and getter for immutable structures for form reducer, similar as it works for modeled() in model reducer\nDon't have other ideas now\n. Sure, but let's discuss what to do with these actions. Actually i don't like idea with the providing path prefix, since it's looks like repetition (i actually provided prefix when connect() form, why should i do it again?). Do you have any other ideas?\nMay be passing state prop to form/field? Or provide decorated HOC component and use context?\n. @davidkpiano Thanks for fixing, i'm very busy now with my current work (and i'm not using Form/Field in my proj), but i'll try to find some time on this week to verify / provide code / tests / or anything else that i could help.\n. @davidkpiano Any chance to push new minor version soon?\n. patch is fine \ud83d\udc4d \n. ",
    "hsrobflavorus": "@asvetliakov Thank you! Much appreciated. I'd love it if you would do that, please feel free to host it wherever you have the time to place it. Thanks for leaving the author info in the header, my boss will appreciate having the link to us!\n. @davidkpiano @asvetliakov Updated for 0.13.3 here: https://gist.github.com/hsrobflavorus/d17f5b8c87d75ce6b068\n. ",
    "andrewQwer": "@chrisblossom I have direct access to editUser through props, so I can use it like this:\nvalue={this.props.editUser.firstName} and it works, but I thought that input value should be updated according to state anyway. \n. Look at this gist: https://gist.github.com/andrewQwer/27bc9e647c01e926e9e6d0fe77d40815\nWhen you change input text you will get the following error: field-component.js:336 Uncaught TypeError: Cannot read property 'props' of null\nIf you remove <div id=\"error-wrapper\"> and place getField right after  input element it starts working.\n. ",
    "freddi301": "h3g_ir.zip\nfile app/components/tableModel.js line 56\nit works without enclosing \nstart the project with:\nnpm start\nnpm run dev\nopen localhost:8080\na mongod in localhost is required\n. same project as here: https://github.com/davidkpiano/react-redux-form/issues/113\ntry to import in this project\nI see that spec is working because imported from .../src/...\nbut if i try to import it simply by import { createModelReducer } from 'react-redux-form/immutable' the file cannot be find\n. I couldn't find it in documentation.\nYou should update README.\nThank you for reply\ncan be closed\n. ",
    "bkudria": "I'm still seeing this issue if the form does not have any custom validators either. Is this a valid use-case for RRF?\n. I'll try to work up a minimal case.\n. ",
    "nickwild-999": "Sorry a newbie question here.\nI am just flexing my muscles with React using with Meteor and have not attempted to use Redux yet (although I will).Ahead of doing this I have decided to use react-redux-form as a local form and then migrate to redux when I am more confident.\nI have used the local form for an insert to a mongo database which is straight forward, however I want to now create a form for an update. Can I auto populate this from mongo or do I have to use Redux? If there are any examples of using RRF in local mode with mongo or even  RRF with mongo hooked up as an update form I would be greatful if somebody could steer me in that direction. . I have tried this, but not had any joy - the field is not autopopulated. Any ideas where I am going wrong.\n```jsx\nimport React, {Component} from 'react';\nimport { LocalForm, Control } from 'react-redux-form';\nimport Scenes from '../collections/scene.js';\nexport default class SceneUpdateForm extends Component {\n  constructor() {\n      super();\n      this.state = {\n        scene: {set:\"set22\"}};\n      console.log(this.state.scene.set);\n    }\n//handleChange(values) { ... }\n//handleUpdate(form) { ... }\nhandleSubmit(formvalues) {\n  Scenes.update({\n    sheet_no: formvalues.sheet_no,\n    project_ID: formvalues.project_ID,\n    scene_no: formvalues.scene_no,\n  });\n};\nrender() {\n  return (\n    \n      {this.props.count}\n       this.handleSubmit(values)}\n      >\n        \nSheet No:\n\n\n\nProject ID:\n\n\n\nScene Number:\n\n\n\nSet:\n\n\n    <button type='submit'> Submit </button>\n  </LocalForm>\n\n\n  );\n}\n}\n```. Thanks so much David that works. I am now wanting  to pass in state from a parent I have tried   initialState={this.props.scene} but nothing appears. Any ideas?. Many thanks for the hand holding. the console log returns nothing initially but then returns the object...\n``` Object\n_id:\"8GcLgtgygJq3dd5gf\"\nproject_ID:\"1\"\nscene_no:\"1\"\nset:\"SCENE 1\"\nsheet_no:1 \n. ",
    "ericwooley": "@davidkpiano I am trying to find the docs as they were for version 0.8.4, but can't find any version controlled docs. Is there any docs that are easily accessible for version 0.8.4 or would I need to rebuild the gh-pages branch at the time of the 0.8.4 release?\n. Well, one thing that I see is different is the doc show createModelReducer and the old code I am looking at imports formReducer.\nIf nothing changed then nothing changed i guess, but I usually prefer to look at docs that are somehow matched to the version I am using.\nThanks!\n. ",
    "dreid": "This issue is addressed by https://github.com/davidkpiano/react-redux-form/commit/7d3dedb093b56861c3f03906468665cf6264f025.\n. And I'd also have to wrap the formReducer to handle the revalidation?\nIdeally as a user of react-redux-form I'd be able to:\n1. Specify validation information for a field in exactly one place. (preferably near the field specification)\n2. Have all changes validated.\n. > Do you mean that when you dispatch actions.change('foo.bar', '...'), that validation should occur then too?\nThat is what I would expect. I was quite surprised to discover the differences between the onChange function passed to my controls and the result of calling actions.change.\nIf not exactly when actions.change is dispatched it seems like there should be some documented public mechanism for making changes exactly as onChange would.\n. @davidkpiano Did you mean to close this instead of merging it?. @grigorigoldman A few things to note:\n\nsubmitFields (and submit) will set submitted or submitFailed based on wether the promise passed to it was rejected or resolved.\nsubmitFields (and submit) will set either the fields or form errors if the promise is rejected.\nfetch returns a promise which always resolves (except in the case of network errors).\n.then and .catch return a new promise.\n\nBased on these things, an example closer to what you want it https://codepen.io/dareid/pen/mBRqdO\nHere we use actions.submit (because we're not dealing with individual field errors), and when we construct the fetch we add a .then callback which handles !resp.ok, and we return the promise from resp.json() and add a callback to throw the error message contained within.\nWe also add a .catch to the fetch promise that handles the case of a network error.\nBy structuring the code in this way we satisfy the actions.submit contract instead of trying to dispatch multiple actions to get the desired result.  . ### Workaround\nThe nested batch action can be avoided by having changeAction return a thunk.. ",
    "fairbairn": "Your combination did not work...it submits, but it won't update the name item in the model.  In fact, it has no awareness of it.\nThis combination does...\n```\nclass SampleForm extends Component {\n    render() {\n        return (\n             console.log(model) }>\n            <Field model=\"test.name\">\n                <input type=\"text\"/>\n            </Field>\n\n            <button type=\"submit\">Submit</button>\n        </Form>\n    )\n}\n\n}\n```\nI believe the Form model should be at the same \"level\" as Field.  Field only works from the mapStateToProps tier down, but Form looks like it has to reference the model from the top of the Redux state tree down.\nSeems they should be the same, right?\n. Pretty sure the issue is that the selectors are mis-aligned between Form and Field..\nHere they are...\nForm\n```\nfunction selector(state, { model }) {\n  const modelString = typeof model === 'function'\n    ? model(state)\n    : model;\nreturn {\n    ...state,\n    modelValue: _get(state, modelString),\n    formValue: getForm(state, modelString),\n  };\n}\n```\nField\n```\nfunction selector(state, { model }) {\n  const modelString = typeof model === 'function'\n    ? model(state)\n    : model;\nreturn {\n    model: modelString,\n    modelValue: _get(state, modelString),\n  };\n}\n```\nField actually redefines model based on the assumed selector used.\nForm takes it literally.\n. our basic store looks like this..\nexport const initialState = Object.assign({},\n    {\n        router: {},\n        form: {},\n        ui: {\n            toggle_state: false\n        }\n    }\n);\nHowever, we provide a helper function that puts custom forms under a top level form so we can nest with this..\n```\nimport {combineReducers} from 'redux';\nimport {modelReducer, formReducer} from 'react-redux-form';\nconst form_sections = [\n    {\n        form: 'test',\n        fields: [\n            'sample_text',\n            'sample_radio',\n            'sample_checkbox'\n        ]\n    }\n];\nfunction buildDynamicReducers(sections) {\n    return sections.reduce((combined, section, index) =>{\n        let name = section.form;\n        combined[name] = modelReducer(name, {});\n        combined[${name}_form] = formReducer(name);\n        return combined;\n    }, {})\n}\nconst reducers = buildDynamicReducers(form_sections);\nexport default combineReducers(reducers);\n```\nThat shouldn't matter because the state tree is perfect. \nIf we provide it top level like you stated, then it doesn't find or auto-create the model field value in the state tree.  If we do it our way, it does.\nUnrelated it seems (because we've tried both ways), we can't get checkboxes to work.  It sets it true, but never actually checks the checkbox, and clicking again doesn't set it to false.\nPretty simple syntax for a checkbox...\n<Field model={model}>\n                            <label>\n                                <input type=\"checkbox\"/> {label}\n                            </label>\n                        </Field>\n. For example, this doesn't ever check the checkbox...yet it sets the state variable of form.test.toggle to true.  It doesn't go false though.\n```\nclass SampleForm extends Component {\n    render() {\n        return (\n            \n\n Something\n                \n\n        )\n    }\n}\nconst mapStateToProps = (state) => {\n    return {\n        test: state.form.test\n    };\n};\nexport default connect(\n    mapStateToProps\n)(SampleForm);\n```\n\n. Here's a modified version of yours. I changed one sequence, and state still works, but the submit returns undefined.  I also too added a checkbox, and it does not work.\nhttp://esnextb.in/?gist=d21c090976c1b80f393c668d9ea447a0\nSpecifically, what I did is nest the reducers...(which is appropriate for redux)...so in my scenario, I took the exact test and test_form nodes and nested them one deep under form.  Your system tracks the state of the value properly.  \n```\nconst reducers = buildDynamicReducers(form_sections);\nconst moreReducers = {\n  form: combineReducers(reducers)\n}\nconst store = applyMiddleware(thunk, createLogger())(createStore)\n  (combineReducers(moreReducers));\n```\n. Another version, this one leveraging connect..\nhttp://esnextb.in/?gist=d21c090976c1b80f393c668d9ea447a0\nSame nesting.  Same results.\n. Makes sense.  Guess my next question is since we have to be explicit with the reducers, and since we have to reference model in both cases from the root of state, do we need to connect at all? or are we simply always going to connect(s => s)?\nIt's also a little confusing, because the modelReducer has to be referenced from the root of state, but the formReducer does not?\n. I would argue that the inputs (in terms of a model reference) to the modelReducer and the formReducer should be the same.  People will pull their hair out otherwise.  The fact that these reducers are created in a nested reducer is what tags it to state.form in the first place.  I have no problem that the modelReducer and formReducer need to be told where to look.  It just seems confusing to tell them differently.\nI can hack around this though and I greatly appreciate your help.\nI do have a question why validators and errors both exist, vs. one single validation grouping that handles the state (true/false) and any error messages that are releated.  Did .errors come later and you didn't want to break backwards compatibility?\nJust curious.\nOnce Form supports the errors prop and submit characteristic, I think we we're good to go.\nThanks!!!\n. Back in business!!  Awesome.\n. I will!\nI actually have a slightly different philosophy on how errors could be handled.  I'm working around your structure, but in almost every forms engine I've ever worked with, the errors (per field) usually come back as a list of messages.  In your system, each message essentially has to have a key, although there's no real value in the key (unless I guess you needed to pinpoint specific messages or error conditions), so in our case we have to manufacturer one.  \nNo biggie.  We're using a central validation system, so there is no keyed validation tests.  Instead, we validate the field across a number of tests with a single function that's coded.  So for right now, we're just making the errors: { reasons: fun } keyed event be called reasons.\nWe can't use validators because we need those error messages from our validation engine, hence the need for errors support at the <Form> component level so we can just validate on submit and then have the messages available to us for display purposes.\nGetting closer though to our ideal, and greatly appreciate your rapid response.\n. So a guidance question...\nIf we're going to build our own errors handler from the top-level Form, intercepting our submit handler, and we want to iterate through all the fields (I hate using the word model, model to me sounds like all of the fields, not a single field, so bear with me), and we want to file away an errors array of messages for each field if our validation function detects some failures (or it may not), should we be looking at setErrors or setFieldsErrors?  Keeping in mind that at the field rendering layer, we're going to need to access this again by field name so we can handle the presentation properly, by field.  We actually do both.  We show field level indicators as well as top level aggregate presentation.\nI get a bit confused why there's an errors block under the formReducer section, but there's also an errors block under the fields individually as well - guess the top one are form errors and the fields are field specific?  \nBased on that assumption, my guess would be we care about setFieldsErrors instead.  Finally, our validation routine may not have any tripped errors, in which case our array of error messages would be empty [].  Do we need to call a resetErrors before we run through our routine to essentially set it back to a valid status before we check?  and would that touch the errors under fields or just the form level errors?\nWe can dispatch any number of events when our validation routine runs - just need to know which of the broad array of functions we should really care about depending on desired granularity.\n. Ugh, I think we have the same issue with actions.setErrors and actions.setFieldsErrors, a referencing issue relating to the model name when you get nested...\nAgain, our state has the model at form.test, and the form at form.test_form, so our model and form reducers are nested under state.form with a form name of test.\nSo this time, I'm firing this..\ndispatch(actions.setFieldsErrors(name, errors));\nWhere name is loan_amount and errors is an array of error messages properly calculated from validating the field.\nThe state has this model at state.form.test.loan_amount, but the only way I could get the action to fire correctly was to have name as just loan_amount.  I tried 'form.test.loan_amount' and 'test.loan_amount' and it didn't set a validity result.  Just the field name seemed to work, kind of..\nThat resulted in this happening in Redux...\n\nUnfortunately, nothing gets affected under state.form.test_form (validity, errors, or fields).  I was expecting state.form.test_form.fields to be populated, but it was not.\n. Interestingly, per my original comment, the formReducer DOES have to match with the modelReducer, so in my case, both values must be form.test.\nStill, we can't seem to get any predictability with a nested model.\n. Thank you David.  This is helpful, although I have to say, I went into this extremely enthusiastic about your library, but now I'm just frustrated.\nI think there's a lot here under the hood, and maybe the issue is simply competing docs and yet-to-be-published docs while pre-1.0 is still in so much flux - there's certainly a right way to tackle a particular issue, but it's difficult to intuit that if you begin to really segment out logic and dig into how to leverage it in a modular way.  I really didn't think us moving out our model and model_form nodes from the root of state would cause so many challenges.  We're going to have hundreds of forms in our app.  I really didn't want them all at the root of state.  In fact, we moved it out to a clean named node under form to isolate it a bit, similar to how redux-form works (although I like your separation of concerns better in terms of auto-connecting and optimizing performance).\nInterestingly, when we had them nested, and we followed your guide, we never provided an initial state in the formReducer (per the code above).  Now that we've moved back up to the root of state, we're getting errors that our field elements are not initialized, yet the docs are conflicted.  One doc says you don't provide an initialState in the formReducer, another does.  In fact, even another section of documentation says you don't have to provide it in modelReducer, but the examples usually do.\nSo clearly moving it up a level makes your system work one way, where shifting it down a tier creates some internal chaos that's more difficult to track down.\nWe've tried numerous combinations with setErrors, setValidity, and setFieldsErrors (in a nested state) to no avail, even with the correct model references totally explicit from the root of state.\nWe seem to be getting closer, but we fight with competing terminology (model means the model node, or the model leaf (field)) along with conflicting documentation, which just makes the effort of trying to figure out how to use your magic engine the right way that much harder.\nWe're presently hacking back from our architecture to give the library one more shot, removing our embedded nodes and putting them back at the root of state.  I wish the documented .errors prop was functional under Form like validators, but it's not, so we'll have to write our own and see if the systems magically starts to validate properly.\nWe're persistent, but sadly, if things don't start to fall into place soon, we'll be forced to go down another direction.\n. We couldn't see any accurate changes to any state under the model_form tier of data within redux, especially errors that we were attempting to set.\n. ",
    "appbank2020": "Thanks for your answer.\nI am using react-select 1.0.0.-beta12 now.\nconst propertyTypeOptions = [\n      { value: 'apartment', label: 'Apartment/Unit' },\n      { value: 'studio', label: 'Studio' },\n      { value: 'house', label: 'House/Townhouse' },\n      { value: 'whole', label: 'Entire flat' }\n    ]\n<Field model=\"property.propertyType\">className={form-group}>Property Typename=\"propertyType\"value={this.props.propertyType}options={propertyTypeOptions}onChange={this.onPropertyTypeChange}/>`\nThe problem is that select value is not change.\ndropdown is working, but select and change are not working.\nThanks for your help.\n. ",
    "adrienbrault": "It works, thanks!\n. ",
    "morsdyce": "No need to be sorry, you've built the only redux forms library that actually makes sense!\nI tried debugging it and found it being caused in the following line:\nhttps://github.com/davidkpiano/react-redux-form/blob/5367a7a2c91689811cdff8db4e1ccfd062049547/src/utils/index.js#L60\nBut I'm not sure which parts of the model string I'm supposed to take.\nIn my example its forms.register.username, my guess is taking everything until the last dot. but I'm not sure.\n. I tried working on it and had allot of issues with the dev environment (running only 1 test) and in general working on it.\nI would appreciate if you could take a look at it\n. I am trying to call onChange with the value I want it to update but I get a change event with an empty value.\nHere is an example of what I am trying to do, note that I removed the methods that generate the actual option with values (in this example there is only the default option).\nThe specific line i'm refering to is: this.props.onChange(${day}/${month}/${year})\n``` js\nclass BirthdayDropdown extends React.Component {\nconstructor(props) {\n    super(props);\nthis.state = {\n  year: '',\n  month: '',\n  day: ''\n};\n\n}\nonChange(key, event) {\n    this.setState({ [key]: event.target.value }, () => {\n      this.props.onChange(${day}/${month}/${year})\n    });\n  }\nrender() {\n    return (\n    \n\nSelect a year\n\nSelect a month\n\nSelect a day\n\n    );\n  }\n}\n```\nThe output for the action that comes out is this:\nObject {type: \"rrf/change\", model: \"forms.register.birthday\", value: \"\", silent: false, multi: false}\n. Sorry about that, I didn't run the code just tried to make the minimum viable example.\nit should be wrapped in a div in order to be valid JSX.\nI updated the original example\n. Ok, I just tested it with how you specified it and then modified it to use a custom component field using createFieldClass and it seems to work fine.\nMy example: http://esnextb.in/?gist=d83cb4f1c426576e93bd278f481f7f9e\nIt's probably an issue somewhere in my project.\nSorry to bother you :)\n. The syntax seems a bit verbose, maybe instead of providing a separate map you could supply the actual component as the key?\n. I personally think the example didn't fit to what you were trying to say, the point of this is to minimize requests to the server so if the sync validity is invalid there is no reason to hit the server.\nBut I agree you should let the consumer of this library to decide what he wants.\nI personally would put the async only when sync passes as the default setting as it is for example in angular 1 and probably many more libraries/frameworks.\n. ",
    "vladshcherbin": "Thank you for the quick answer. I guess I need to try and see, how it goes. I looked at RRF before, but was a bit confused with adding many form elements in the store (2 elements per form) while RF had only one element for all forms.\nBtw, the docs are great!\n. @davidkpiano so, my last question - how stable is RRF now (any api changes to expect before v1) and when the v1 will be released (roughly) ?\n. Thank you for the very detailed answer, I appreciate it!\nSo, no major changes that'll need huge refactoring. This is fine for me, I'll try the RRF in my current project.\nI think we can close the issue as this info will be added to the docs later and other devs can find the answer here for now.\n. I think. the issue is this:\nYou have your data fetched, how do you populate the form (to set initialState to this data). For example, you have a page Article, which has a Form component in it. You fetch data in Article and want to populate the form with this data. Like this:\n``` js\n\n\n\n// or\nArticle {\n  componentDidMount() {\n    fetchData()\n    .then(data => {\n      dispatch(actions.setFormInitialValues('articleForm', data))\n    })\n  }\n}\n``\n. @davidkpiano yes, theload` method will do the job. I think, the question is about reset - how do you reset after you loaded the data (as this data is supposed to be initial state for a form).\nI think, in this case, we can store fetched data somewhere and on reset - load it again into the form?\n. @davidkpiano yes, currently this is the best option. Maybe after 1.0, initialState value will be added to the store so this case will be more simple to solve.\nHope this answers the topic starter's question.\n. Awesome, then I'll be using RRF this way. Thanks!\n. @davidkpiano I tried, but it doesn't save the gist\njs\n``` js\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport { createStore, combineReducers, applyMiddleware } from 'redux'\nimport { Provider, connect } from 'react-redux'\nimport thunk from 'redux-thunk'\nimport { modelReducer, formReducer, Field, Form, actions } from 'react-redux-form'\n// Visible is defined, but not priority\nconst initialArticleState = {\n  isVisible: 'true'\n}\nconst store = applyMiddleware(thunk)(createStore)(combineReducers({\n  article: modelReducer('article', initialArticleState),\n  articleForm: formReducer('article', initialArticleState)\n}))\nconst ArticleForm = () => (\n   console.log(values)}>\n    \nVisibility:\n\n\n\nPriority:\n\n\nSave\n\n)\nfunction mapStateToProps({ article }) {\n  return { article }\n}\nConnectedArticleForm = connect(mapStateToProps)(ArticleForm);\nconst App = () => (\n  \n\n\n)\nReactDOM.render(, document.getElementById('app'))\n```\nhtml\nhtml\n<!doctype html>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <title>ESNextbin Sketch</title>\n  <!-- put additional styles and scripts here -->\n</head>\n<body>\n  <div id=\"app\"></div>\n</body>\n</html>\npackage\njson\n{\n  \"name\": \"esnextbin-sketch\",\n  \"version\": \"0.0.0\",\n  \"dependencies\": {\n    \"react\": \"15.1.0\",\n    \"react-dom\": \"15.1.0\",\n    \"redux\": \"3.5.2\",\n    \"react-redux\": \"4.4.5\",\n    \"redux-thunk\": \"2.1.0\",\n    \"react-redux-form\": \"0.13.1\"\n  }\n}\nThe priority value is 1, but when you submit form, you see no value in console. This is what I'm talking about.\n. @davidkpiano the value is just an example. I usually have a defaultValue for a checkbox for example, but it won't be in onSubmit values too if not defined in initialState.\nIf we have 10 checkboxes, triggering dispatch 10 times in componentDidMount is not a good idea I guess.\nSo, basically, we should always set initialState in the reducers or we won't have the default values.\n. @davidkpiano yes, it works for input with type text, number, etc. But I can't make it work for a checkbox.\n. @davidkpiano here is a demo on esnextb.in\nI'm trying to understand, if I need to always set all fields in initialState.\nIn the demo you can see a checkbox. If you open a console and submit the form - you won't have the checkbox value.\nPlus, I found that if you don't specify the initialState for another input in the demo (title), you'll get the uncontrolled/controlled error for it.\n. Okay, I'm closing this as I won't be using Field element. Will try to figure it out with custom components.\n. @davidkpiano yes, this was the whole issue - you need to always to set the initialState values.\n. @davidkpiano oh, this future enhancements will be great. Thank you for the package and for answering all my questions!\nFeel free to close the issue or to leave it as a note / roadmap.\n. @davidkpiano yes, this is a perfect API for me as well.\nA single formReducer with nested forms. It will be easy to create / modify / remove forms in it, take field values, etc. Just like in your examples.\nI like this simplicity a lot \ud83d\udc4d \n. Yes, this would be great. Will the Partial Models with just .name work as well?\n. @davidkpiano createForms, mapForms, composeForms - any would be great, pick one you like the most, we'll be happy with your choice \ud83d\ude09 \n. Yes, this would be awesome.\n. Hey, @davidkpiano . Any news on this or ETA? :)\n. @davidkpiano don't worry, I'll wait until you'll have time to make this enhancement.\nCurrently, I'm using a simple custom forms package, would like to move to rrf when this one will be released ;)\n. @davidkpiano hey, maybe you can add this option to combineReducers?. @davidkpiano , sorry, my mistake. I meant to add this option to combineForms.. Some kind of this, so it is passed to formReducer.\njs\nconst store = createStore(combineReducers({\n  deep: combineForms({\n    user: initialUserState,\n    goat: initialGoatState,\n  }, 'deep', { lazy: true }),\n}));. @davidkpiano I tried to setup the forms this way, but it's not working as I thought it should.\nThe form object is created in store when the form is changed, but when you unmount the component, the form state is still in the store. The way I wanted it to work is like a LocalForm, but saving in redux store. \nSo, when the Form is mounted, its state is created in redux, when it's unmounted - it's destroyed in redux store.\nSome kind of this:\n```jsx\nclass Form extends Component {\n  componentWillMount() {\n    this.props.dispatch(createForm(this.props.model, this.props.initialValues))\n  }\ncomponentWillUnmount() {\n    this.props.dispatch(removeForm(this.props.model))\n  }\nrender() {\n    ...\n  }\n}\n```\nIs it somehow possible to do now or any future plans?. Using custom components like this one also triggers component rerendering:\njs\n<Control.text model=\"forms.user.name\" component={Input} />\n. @davidkpiano yes, this was an issue with 1.0.3, with 1.0.5 everything is great \ud83d\udc4d \n. @davidkpiano I found another interesting stuff - the form has one element, but it renders twice on initiation, also clicking on label triggers rerendering as well. Here is the photo of the form & element + video of the issue:\n\nrrf.zip\n. @davidkpiano hey, this was fast. Thank you :)\n. hey @davidkpiano , maybe you could drop 1-2 small sentences about, I just wanted to understand the purpose.\nI am planning to fully move to RRF for quite some time, but still need a few answers.. Since no one asked for this, we can probably close it.\nThe only question remaining for me is the 2 - What is deep.forms.$form for and it fields (focus, pending, etc), is it the state of all forms or just unused props?\n. @davidkpiano , nah, there is no form for it.\nI have only 1 form - named login, so I have deep.login as model and deep.forms.login as form. There I have deep.forms.login.$form with the form state.\nWhat I'm asking is - deep.forms.$form, it's like a global $form for all forms, what's the state there for \ud83e\udd14 . It's even written there - model: \"deep\", but I don't have such model \ud83e\udd14 . Another way is to use mapProps and pass errors. Then, you can simply do smth like this:\n```js\nconst FieldError = ({ errors }) => {\n  const inValidFields = Object.keys(errors).filter(error => errors[error])\nreturn {translate(forms.validation.${inValidFields[0]})}\n}\n```. > Cheer up! All you have to do is suggest features and make PRs.\nIt works only if the maintainer is active, but when your issues (with bug repo, bug codepens) are left with no answers you don't even know what to do. That's what I absolutely love in RRF \u2764\ufe0f \n\nAlso, funny enough, if you use <LocalForm>\n\nYeah, I can probably try it as I don't need to share form's state. I love Redux though :)\nWhat I liked in RF:\n\nsetup store once. No need to return to it when a new form is added.\nno initial values in store creation. Same as above, setup store once, never come back when form is added / initial values are changed\nforms are not persisted in store. Created when form is mounted, removed when form is unmounted (lazy flag?)\n\nAs for validation, I use ajv to validate json-schema both on client and server. So it looks like this:\njs\nconst schema = {\n  type: 'object',\n  required: ['url', 'seoTitle', 'seoDescription'],\n  properties: {\n    url: { type: 'string', minLength: 2, maxLength: 20 },\n    seoTitle: { type: 'string' },\n    seoDescription: { type: 'string' }\n  }\n}\nIt is passed to validate function and is validated all together. It's convenient to have the same validation on client/server and I don't think it makes a big difference in speed vs single field validation except maybe if the form is huge.\nI would love to give LocalForm a try as I'm sick of RF bugs, inactivity and will hope that I won't need its state somewhere else.. @davidkpiano I checked LocalForm and I'm not sure if it's a good replacement because:\n\nall LocalForm's create its own redux store under the hood (not sure if this is desired when you already have global redux store)\nhow do you get form props, like submitting prop?. > Can you elaborate on this? You only need a one-time setup with RRF too.\n\nWhat I mean is from the docs:\n```js\nconst initialUserState = {};\nconst initialGoatState = {};\nconst store = createStore(combineForms({\n  user: initialUserState,\n  goat: initialGoatState,\n}));\n``\nMaybe I misunderstood, but every time you have a new form (user: initialUserStatefor e.g.) or your form's initial state (initialUserState` for e.g.) has to be changed - you come here and add or update this.\nIn RF you setup store once and never come here again:\njs\nimport { reducer as formReducer } from 'redux-form'\nconst store = createStore(combineReducers({ ..., form: formReducer }))\n\nForms persisting in the store was an intentional design decision\n\nYeah, that's what I liked in RF. Forms are deleted from the store and if you need a wizard form (do you need them more than regular forms?) you add destroyOnUnmount: false prop. Since I very rarely have wizard forms, I always wanted to clean my store in RRF.\n\nUse onUpdate to get props\n\nThis is why LocalForm is inconvenient, you still need to setup a wrapper form, define the whole form state, onUpdate, onChange functions. It's great when you don't have redux, but in the long run Form is more suitable. How can you get it in Form component - I guess you connect to redux store to get this props?\nIn RF you use HOC and this props are passed into your form which I find very convenient.\nSo, as I said in the topic start - this are all design decisions I really like in RF. Minimum setup and more suitable in my use-cases, but there are some bugs and inactivity.\n. Here is my simple perfect workflow:\n\n- user form\n\n```jsx\nconst UserForm = ({ buttonText, submitting, handleSubmit }) => (\n  \n\n\n\n{buttonText}\nCancel\n    \n\n)\n\nexport default form({\n  name: 'userForm',\n  initialValues: {\n    username: 'Mike' <-- just as initial value example\n  },\n  validate: values => validate(schema, values)\n})(UserForm)\n```\n\n\n\n- user create page\n\n```jsx\nclass UserCreate extends Component {\n  handleSubmit = values => {\n    return doSmth(values)\n  }\n\n  render() {\n    return (\n      \ncreate\n\n\n    )\n  }\n}\n```\n\n\n\n- user update page\n\n```jsx\nclass UserEdit extends Component {\n  state = {\n    isLoading: true,\n    error: null,\n    item: null\n  }\n\n  componentDidMount() {\n    this.fetchUser()\n  }\n\n  fetchUser() {\n    // fetch user and update state\n  }\n\n  handleSubmit = values => {\n    return doSmth(values)\n  }\n\n  render() {\n    const { isLoading, error, item } = this.state\n\n    if (isLoading) {\n      return loading\n    }\n\n    if (!isLoading && error) {\n      return error\n    }\n\n    if (!isLoading && !item) {\n      return user doesn't exist\n    }\n\n    return (\n      \nupdate\n\n\n    )\n  }\n}\n```\n\n\n\n1) So, I create dynamic forms store:\njsx\nconst store = createStore(combineForms({\n  forms: {}\n})\n2) Now I need to define UserForm component. Simple component vs HOC (decorator)?\n- If this is a simple Form component, I won't be able to use form state without connecting to redux store, so you will still use connect decorator.\n- withForm decorator can pass this values automatically.\nI know, in RF it's like magic and you expect it to re-render on every change, but there are a lot of lifecycle checks in RF's HOC and it's optimised. I also expected  it to re-render on every input change, but no. I do think it complicates things though.\nI'd prefer HOC as I need form props and will still need to use connect in first variant.\n3) Create page is easy, but where do you specify initialValues? In RF you do this in form HOC. How to do this in RRF, dispatch?\n4) Update page has a fetch function, when user is received I pass it as initialValues into the form, HOC receives it and uses. How to do this in RRF, dispatch?\nWhat do you think about this workflow, possible with RRF? Correct me or suggest better ideas, you know more form use-cases, that's just what I used to do in RF.. @davidkpiano yeah, this would definitely be a nice feature.\nHow do you combine the initial form state with initial loaded state from fetched item for example? \n```jsx\nconst initialValues = { isVisible: true }\nconst ArticleForm = ({ article }) => {\n  const formState = { ...initialValues, ...article }\nreturn \n}\n```\nSmth like this?\n. ",
    "cjcenizal": "So, after comparing your code to mine and re-implementing everything I found the source of my error: I wasn't using combineReducers, and I had introduced a typo in my root reducer. So the form reducer wasn't even being updated when the change action was dispatched! Complete head-desk moment. But I still learned a lot from your code, so thank you for writing that excellent example! Now I know why the smart people use combineReducers. \ud83d\ude09 \n. ",
    "bgriffith": "Awesome, thanks!\n. Hey @davidkpiano - Yeah I have something similar but on the <Form>.\nHere's a quick gist to help explain!\nhttp://esnextb.in/?gist=10d57e542448b97ad80cf5bc22d64e70\nIn short, changing the validator object doesn't seem to result in the form revalidating and checking to see if the previously invalid fields are still invalid/required.\nHope it helps explain what I'm trying to achieve! \n. Ah awesome! A form level validator seems to do the trick and thanks for the tidbits :+1:\nI'll let you know how I get on with this solution.\n. Brill! Appreciate the quick response!. Hey @davidkpiano Thanks for the tips. Weird things be happening though! If I add the controlProps prop to the component (doesn't matter what I include within it) the whole input disappears from view!\nIt does appear that if I apply ref in this way I do get the component in the console though!\n. getRef sounds intuitive enough to me :+1:. Awesome thanks a lot! When you a min could you publish to npm?. ",
    "Faulik": "You need to add custom field with key Input so it will be able to recognize it. It will behave the same way.\n. Yea, something like this. Or just validate action which will trigger field validations, when you don't specify them as argument.\nI'm not sure about validations on render as i changing model and then render. Do i need to specify them somehow except as value={model}?\n. I have done some research and not sure if this is intended but initial values used in validations aren't the ones from initial state or model object. If you specify modelValue on your input it will use it:\n<input type=\"text\" modelValue={model.name}/>\nThere is no word about it in docs so it's better to add it.\n. @davidkpiano Hi again. Expected behavior is like this first example. But i need to specify full path as form name.\nIn general i would like to simplify it to second example but as you see input don't reflect actual model if model isn't full path. But it's reflect next changes just fine. \nAlso in this examples validations are working fine, so i'm still investigating why mine aren't.\nThanks. \n. @davidkpiano Not that. Look at this I added value attribute and it has it in input, but thats not the case. Form is invalid and in console you can see undefined value of modelValue in validator, but model actually has it.\nAnd now this code produces valid model with valid data but needs magic - model name must be full path in state. If you rename all formStore.user to just user it will give you invalid form on start but after any change event it will correctly validate.\nNow i can't figure out how setting modelValue fixed this on my part.\n. Oh, i missed it somehow. Thanks for your efforts.\n. ",
    "cbioley": "That should be working:\njs\nconst CheckboxField = createFieldClass({\n  'Checkbox': props => ({\n    onChange: e => props.onChange(e.target.checked)\n  })\n})\n. @rkrdo You're welcome ^^\nI don't know. \nYou should ask @davidkpiano. He's really a nice guy.\n. @davidkpiano Hey mate! You've indeed fixed my initial issue, thank you!\nI'm afraid to have found another weird behaviour while stress testing (read: clicking like a freak on add/remove/add/add/remove/...) my app, so I now need to narrow down what I've done and write a test to show the issue.\nI hope you don't mind if I post here when I have something to show.\nI wish you a nice day \u2600\ufe0f\n. @davidkpiano Here's a failing test:\n``` js\n  it('should clean after itself when a valid field (scenario with 3 items)', (done) => {\n    const reducer = formReducer('test', {\n      items: [\n        { name: 'item1' },\n        { name: 'item2' },\n        { name: 'item3' },\n      ],\n    });\nconst state1 = reducer(\n  undefined,\n  actions.setValidity('test.items[0].name', true));\nconst state2 = reducer(\n  state1,\n  actions.setValidity('test.items[1].name', false));\nconst state3 = reducer(\n  state2,\n  actions.setValidity('test.items[2].name', true));\n\nassert.isFalse(state3.valid, 'form should be invalid');\n\nlet removedState;\n\nconst dispatch = action => {\n  removedState = reducer(state3, action);\n  assert.isFalse(removedState.valid, 'form should still be invalid');\n  done();\n};\n\nconst getState = () => state3;\n\nactions.remove('test.items', 2)(dispatch, getState);\n\n});\n```\n. @davidkpiano Thanks!\n. @davidkpiano No prob, I could test from master branch \ud83d\udc4d \nI ... (I don't know how to say that) ... may have found another tiny annoyance regarding the errors this time. \nBut fear not, this is way less annoying (for my case at least) so you can pretend I don't exist for now ^^\n. @davidkpiano Please, don't hate me :)\n``` js\n  it('should clean all props after itself when a field is removed', (done) => {\n    const reducer = formReducer('test', {\n      items: [\n        { name: 'item1', dummy: true },\n        { name: 'item2', dummy: true },\n      ],\n    });\nconst invalidItem = reducer(\n  undefined,\n  actions.setValidity('test.items[1].name', false)\n);\n\nlet removedState;\n\nconst dispatch = action => {\n  removedState = reducer(invalidItem, action);\n  assert.isUndefined(removedState.fields['items.1.name']);\n  assert.isUndefined(removedState.fields['items.1.dummy']); // <-- this field is leftover\n  done();\n};\n\nconst getState = () => invalidItem;\n\nactions.remove('test.items', 0)(dispatch, getState);\n\n});\n```\n. ",
    "rkrdo": "@cbioley that worked perfectly, thanks!\nOff topic question, what would be a good channel in discord to ask stuff related to the project? I hesitated to ask this on the redux-form channel\n. Sounds good, thanks! @davidkpiano @cbioley \n. ",
    "sakarit": "You can also fix it little bit cleaner like this:\nconst CheckboxField = createFieldClass({Checkbox: controls.checkbox})\nCheckbox.defaultProps.type = 'checkbox'\n@davidkpiano I tracked down the issue to this line, there is no type prop available in react-bootstrap's Checkbox.\n. Nice! Thank you. :) When will you make a release?. Yes but this is really inconvenient because I must do it manually for every input.\nI would rather have a invalidClassName prop or something.. Okay I guess I could do it with the resolve-model and get-field-from-state utils...\nHowever resolve-model is not exported from the index.js, so I have to import it with an another line of code. Also I'm using TypeScript so I would have to write a declaration file for it. Or use the full model name in every input which sucks.\n@davidkpiano Any chances that resolve model utility would be exported some day?\n. Ok, cool! Thanks mate!. ",
    "mruhlin": "Yeah nesting like that seems pretty natural (or if instead of a separate FieldSet tag you could reuse either Field or Form tags, might be better).  Maybe if everything just nested inherently.  \n<Form model=\"user\">\n    <Field model=\"address\">  <!-- this is implied user.address -->\n        <Field model=\"city\"> <!-- this is implied user.address.city -->\nWould kind of be a breaking change though.\nI'm new to React and Redux so a little reluctant to throw out suggestions that might be terrible.  Ideally I'd like to just pass in the exact object I'm modifying but I guess there's no way to finagle that since we have to know where to put it in state when we're done with our changes.  Maybe if I could pass a selector that returns the object rather than a string path? i.e.\nUserForm:\nvar userSelector = (state) => (state.user)\n<Form model={userSelector}>\n   <Field model={compose((user) => (user.name), userSelector}/>\n   <Address model={compose((user) => (user.homeAddress), userSelector}/>\n   <Address model={compose((user) => (user.workAddress), userSelector}/>\nAddress:\n<Field model={compose((address) => (address.street), this.props.model}/>\nThat seems a little verbose now that I type it out, but maybe there's a way to clean up the syntax?\n. Cool, this looks good.  So for my example about home and work addresses, I'd just have to use multiple form tags, i.e.?\n<Form model=\"user\">\n    <Field model=\".name\"/>\n    <Field model=\".email\"/>\n    // etc\n</Form>\n<Form model=\"user.homeAddress\">\n    <AddressFields />\n</Form>\n<Form model=\"user.workAddress\">\n    <AddressFields />\n</Form>\n<SubmitButton />\nAddressFields.jsx...\n<Field model=\".street\"/>\n<Field model=\".city\"/>\n//etc\nIf I did it that way, I'd still only need one set of reducers in my redux store right, or would I need to create separate form reducers for each address?\n. ",
    "lennerd": "Just my two cents:\n``` js\n\n  // user.address\n       // user.address.city\n          // comment\n```\nSimilar to relativ directory paths.\n. Sorry, I don't quite get, what you mean. You mean a Field component is user outside of Form?\n. But isn't that possible with the dot syntax? Omitting the dot would select the model directly. Similar to react-router where route URLs can be appended to there parent route if you don`t add a starting slash. \nSorry to maybe sound stupid. Maybe it would help if you can give a code example.\n. It would also be possible to have to dots selecting the previous parent. ..name in context of user.images would select user.name for example.\n. ",
    "favetelinguis": "Works just fine, found the error that was unrelated to lib\n. Or no it does not, modelReducer is returning an object if it is given an immutable map as initialState, i see in the source code that there is support for immutable but in not sure how to use the immutable modelReducer? It is not exposed atm?\n. So this did the trick:\nimport {\n  modelReducer\n} from 'react-redux-form/lib/immutable/index';\n. ",
    "daneryl": "thank you !\n. Working great with the default controlled inputs thanks. loving the library !\n. ",
    "markshust": "I stumbled on this issue debugging the same issue. It turned out the submit handler I was passing through handleSubmit was doing an e.preventDefault() check that was leftover from pre-existing code. This was causing the SET_SUBMIT_FAILED action to be triggered. Once I removed the e.preventDefault() check/call from my final submit handler, all worked \ud83d\udc4c  It would be nice if there was a verbose error message that was telling me this, instead I had to grok through the source to debug.\n. ",
    "konzz": "Thanks! Yes it helped.\n. Yes, still the same behaviour. Thanks! Yes it's working perfectly now. ",
    "arcticfalcon": "I'm using custom components and it happens with any component mapped in the createFieldClass definition\njavascript\n<Field model={`${model}.${field}`} errors={errors} validateOn=\"blur\">\n    <DatePicker ref=\"picker\" />\n</Field>\n(Field component there is from createFieldClass)\nThanks!\n. Awesome! Thanks!\n. ",
    "stueynet": "Sorry to resurrect this but curious if there is any new docs on doing masks. The old ones are gone from the internet.. nvm https://davidkpiano.github.io/react-redux-form/docs/api/Control.html#prop-parser. @davidkpiano that explains a lot. So it is not enough to rely on your own redux actions acting upon form reducers, to run the validation process. So it would make sense to either run actions.change as part of a saga or other middleware. The key thing here is trying to hydrate the form data when you are editing an already existing resource.\nIn componentDidMount we would call formReducer.LOAD which would take the resource that is being edited as the payload. This would successfully hydrate the form but would not of course, properly process validation. So instead we can add a watchFormLoad() saga which will load the data to the correct redux form and then run actions.load.\nWe were trying to find clear documentation on best practices for loading an existing model into a form but it was not 100% clear how to do that.\nAlso thanks for the amazing project!. Nope that works perfectly. I'm not sure why we were even confused. . I guess the one issue we had was our local item was not the exact same shape as what ends up in the form. We we were using the reducer to transform it. So we would still need to have the two actions. One to load the model and transform it and the second for actions.load with the transformed model. . ",
    "cal0610": "Thanks David, I scoured through all of the docs and couldn't find a way to hook up a custom toggle / checkbox with RRF. This should be included in the docs because there's some weird behavior.\n<Control component={CustomToggle} />\nClicking the checkbox would always provide a value \"on\".\nThe correct way is as you mentioned:\n<Control.**checkbox** component={...} />\n. @gvidon @davidkpiano  this had me scratching my head for a while, yet another issue I had in my project which is not documented, thank you for pointing me to the right direction.. @davidkpiano \nHi David\nI've encountered the same issue here.\nIf you use control like this:\n\nThen this.handleChange is called but the onChange for CustomComponent is not.\nFrom the documentation it does not specify that the changeAction overwrites the onChange on the custom component.\nWhy this matters?\nI want to update field B based on the value on field A. \n. Any chance we can get this looked at ?. Thanks David!\nJust wanted to confirm that this is expected  and changeAction is supposed to override CustomComponents onchange? \n. ",
    "etrepum": "I went ahead and created a PR with a test that demonstrates the problem at a relatively high level, if that test can be made to pass then the hard problems should be solved.\n. Superseded by #227 \n. I've tried adding this version as a dependency and it doesn't appear to fix the performance problem, I'm still seeing the same behavior inside my components (control, controlProps, onFocus, onBlur, onChange, onLoad, onSubmit changing for every component on every redux store update). I'll dig deeper later today.\n. I can't seem to reproduce the problem in isolation with this PR, it definitely seems like an improvement :+1: Not sure why we're still having problems, but it could be on our end or perhaps there was some pollution in node_modules when I tried to pull it commit from git into our app. I don't see a reason not to merge this as-is.\n. Thanks!\n. Validation can indeed occur anywhere that actions can be dispatched, but if you define your validators in a Field then there is no straightforward way to trigger that validation action without also storing the validations that are applicable to that Field somewhere outside of the view.\nConditionally defining validation via props doesn't really work as I would expect it to, because if the props change without the model value changing then a revalidation does not occur. There's no straightforward way to convince a Field that it needs to revalidate without also changing the model value.\nI suppose the real problem is that having validators on a Field is opinionated and not quite as flexible as it appears to be, and that a coherent and convenient way to deal with them (without propagating onChange/etc. all over the place) outside of Field/Form isn't demonstrated in the docs. Having them on the Form also appears to be a bit inflexible such that validators must all be validated on change, or they must all be validated on submit.\nI haven't put too much thought into what an ideal API would look like. As you've said, there are a lot of things to consider around asynchronous validators (debouncing can be considered a specific case of async). All of the synchronous concerns are possible to sort out in a reducer as it's straightforward to have one that has access to both the current and next form and model state. If the validators were in the store as well, then manipulating the working set of validations would also be straightforward.\n. Yeah you're absolutely right, should not be in the reducer unless it's idempotent, and in these cases it's not always going to be (especially in the async case).\nMiddleware sounds like a great option! I can't think of any caveats to that\u2026 other than, of course, the work to implement it and transition to using that instead :)\n. Not sure what your protocol is for closing these kinds of question issues, but you've definitely satisfied this query from my perspective so I'll go ahead and close it (feel free to re-open of course). Thank you!\n. The use case we have is that some enumeration (radio/select/checkbox) determines how other parts of the form should be displayed and/or validated.\nFor example, a shipping form where there is a country selector and the validators are on the Field components:\n- If the country is US, display the subset of the form that has a US address and relevant validations (city, state, zip)\n- Otherwise display a subset of the form that has a more free-form address input with much more relaxed validation rules\nA case where this breaks down is:\n- Select US\n- Enter an invalid zip code into the form such that it does not pass the validator\n- Select a non-US country (which no longer has a Field with a validator for zip code)\n- Complete the non-US subset of the form passing all of the current validators\n- The form can not be submitted because it is invalid (since the zip code will be considered invalid until revalidated but it will never be)\nThis can be worked around if the validators are on the Form but not if they are on the Field.\n. I think that perhaps zip was a bad example, I'm not talking about an async validation here, just a field that should only be validated at all given some particular value of another field. Pretend I said state instead :) Our actual use case is not exactly this, I was translating it to something a bit more common.\n. Note also that the downside you mention is only true if validators are specified with exactly the same API that exists today, if the field dependencies can be specified statically there is absolutely not a requirement that anything happens any time any part of the form changes. It's also certainly not true that evaluating a validation means that the field needs to be re-rendered.\n. ",
    "Darmody": "@davidkpiano Cool!\n. ",
    "venelin-mihaylov": "initialState does not fit my use case, AFAIK.\nI want to load a record from the server, and use that record as intitialState for the form. Subsequently actions.reset() would reset the values to the initially loaded from the server.\nSpecifying the values during redux store configuration does not allow that, again AFAIK. \nMaybe if there is a method to set the initialValues, say ... actions.setInitialValue() ? But there isn't such method currently ...\nAlso, even if initialState was ok, then the second question is how I do connect that to the custom component? Using redux' connect() ?\n@connect(state => ({modelValue: state['ReactReduxFormModel.myCustomField']})\nOr, alternatively, how you would pass down the value from the form containing component to the custom field component)\n. Thank you very much for your answers.\nI have missed the \"decorating reducers\" part in the documentation. \nHaving \"user\" and \"initialUser\" in redux state, and then decorating my current CRUD reducers will be the best option for now. And on form reset I will use actions.change('user', initialUser)\n. 0.13.8, the latest\n. I was able to better pinpoint the issue, will open a new issue with better description.\n. Thank you for your response.\n. const store = createStore(combineReducers({\n  deep: combineForms({\n    user: initialUserState,\n    goat: initialGoatState,\n  }, 'deep'),\n}));\n. Seems to work :) . Thanks a lot :)\n. updated to 1.0.4\n1. form mounts\n2. actions.reset(model)\n3. actions.load(model, values)\n4. Felds which are not text fields - select / datefield - are marked as invalid, although valid values are shown in the form. I guess the validation is not run when it should. The fields with issues are custom fields, I use prop mapping. I haven't created a reproducible example yet, can you fix the issue without one?\nI checked, the issue is not present when I use Control.select directly\nThe issue is only present with 1.0.4, 1.0.3 is OK\nMy prop mappings:\nconst SUIField = createFieldClass({\n  DatePicker: ({onChange, ...props}) => ({\n    selected: props.modelValue ? moment(props.modelValue) : null,\n    name: props.name || props.model,\n    onChange: (v) => onChange(v ? v.format() : null),\n    ...props,\n  }),\n  Dropdown: ({onChange, ...props}) => ({\n    name: props.name || props.model,\n    value: props.modelValue,\n    onChange: (e, value) => onChange(value),\n    ...props,\n  })\n})\n. I second that, I load data the same way. Currently, I store the loaded record at a separate place in the redux state and on reset I do actions.load(model, previouslyLoadedRecord)\n. In general my forms are connect() -ed. \nIn the example below the form is not. The behavour is the same. \nI use \"trace react updates\" in the react chrome plugin to look at what is being re-rendered. \nThis is a simple form, but the issue is clearly visible.\nhttps://codepen.io/vmihaylov/pen/PGKbLW\nhttps://s.codepen.io/vmihaylov/debug/PGKbLW\n. Additional thoughts:\nIs there a need to re-render all fields on focus, blur, and on every model change (even if it's not the current field)?\nFrom where that 'feature' comes? Can it be avoided? \nmaybe shouldComponentUpdate() can be used?\n. I have the same issue, thanks for fixing it! \ud83d\udc4d \n. ",
    "omerzach": "Nope, I'm doing exactly what https://davidkpiano.gitbooks.io/react-redux-form/content/step_by_step.html describes except without a formReducer (since it says \"Form reducers are always optional\")\n. ",
    "keown": "@davidkpiano \njs\nconst MaterialField = createFieldClass({\n  'TextField': controls.text,\n});\nthis solution works but unfortunately the name attribute of the input field is overridden with something like logInUser.email (in my case) and i need stay with my value user[email]\nis there any solution?\n. thanks a lot @davidkpiano !\n. this code seems to solve the performance issue \njsx\nconst MaterialField = createFieldClass({\n  'TextField': controls.text\n}, {\n  updateOn: 'blur'\n});\nbut unfortunately it breaks the material-ui TextField\ndefining MaterialField this way seems ok\njsx\nconst MaterialField = createFieldClass({\n  'TextField': (props) => ({\n    name: props.name,\n    onChange: props.onChange\n  }, {\n    updateOn: 'blur'\n  })\n})\nbut the formReducer tell me the form is valid even if it's not, same problem of #241 \n. @davidkpiano doesn't fix the problem for me. it seems slower :-(\nby the way this solution is ok for me but i need to find out exactly all params i need to map to make everything work correctly, including validations\njs\nconst MaterialField = createFieldClass({\n  'TextField': (props) => ({\n    name: props.name,\n    onChange: props.onChange\n  }, {\n    updateOn: 'blur'\n  })\n})\ncan you help me with that? i gave a look to the source code but i can't really understand what's needed.\n. ",
    "zargold": "I really need/want to somewhat dynamically build form components based on an API call so its difficult/impossible to build them in from the beginning. Like I have a form for Component A which takes fields [ 'name', 'description', 'image', 'a few more fields coming from server',] as opposed to Component B which takes fields [ 'name', 'description', 'image', 'a few more fields coming from server',] so hopefully the solution will allow for this.\n. I can't really get it to go very far because of routing but here's some full code... I'll get back later to try to get it but esnextb.in gives a randomly generated URL so it messes with routing...\n``` javascript\n// write ES2015 code and import modules from npm\n// and then press \"Execute\" to run your program\nimport 'babel-polyfill'\nimport { render } from 'react-dom'\nimport React, { Component, PropTypes } from 'react'\nimport { combineReducers, Provider,\ncreateStore, applyMiddleware } from 'redux'\nimport { connect } from 'react-redux'\nimport { Router, Route,\nIndexRoute, browserHistory } from 'react-router'\nimport { syncHistoryWithStore, routerReducer } from 'react-router-redux'\nimport { modelReducer, formReducer,\nField, Form, actions } from 'react-redux-form'\nimport thunkMiddleware from 'redux-thunk'\nimport createLogger from 'redux-logger'\n//Configuring store... stuff\nconst initialKeyword = {\n  id: null,\n  name: '',\n  productCategory: '',\n  metaDescription: ''\n};\n//This actually comes from async calls to the server\n//but thats not too relevant\nconst CREATE_NODE = 'CREATE_NODE'\nconst CHANGES_SUCCEEDED = 'CHANGES_SUCCEEDED'\nconst keywordsByUrlReducer = (state=keywordsByUrl, action) => {\n  switch (action.type){\n    // many more cases still irrelevant...\n    case CREATE_NODE:\n    case CHANGES_SUCCEEDED:\n      return Object.assign({}, state, {\n        [url]: keywords(state[url], action)\n      })\n    default:\n      return state;\n  }\n}\nfunction keywords(state=initialKeyword, action){\n  switch (action.type){\n    case CHANGES_SUCCEEDED:\n      return Object.assign({}, state, {\n        didInvalidate: true,\n        changes: [],\n      });\n    case CREATE_NODE:\n      state = Object.assign({}, state, {\n        items: nodeReducer(state.items, action)\n      });\n      state.changes = changeReducer(state, action)\n      return state;\n    default:\n      return state;\n  }\n}\nconst keywordsByUrl = {\n  keywords: {\n    0: {\n        id: 0,\n        name: 'Home',\n        productCategory: '',\n        metaDescription: '',\n        parentId: null,\n        children: [1]\n    },\n    1: {\n      id: 1,\n      name: 'Business',\n      productCategory: 'Business Apps',\n      metaDescription: 'Lorem Ipsum... ipsum lorem',\n      parentId: 0,\n      children: []\n    }\n  }\n}\nconst selectedUrl = 'keywords';\nconst rootReducer = combineReducers({\n  keywordsByUrl: keywordsByUrlReducer,\n  selectedUrl,\n  routing: routerReducer,\n  keyword: modelReducer('keyword', initialKeyword),\n  keywordForm: formReducer('keyword', initialKeyword)\n})\nfunction configureStore(preloadedState){\n  const store = createStore(\n    rootReducer,\n    preloadedState,\n    applyMiddleware(thunkMiddleware, createLogger())\n  )\n  return store\n}\n// Components Stuff:\nconst patchKeyword = (nodeId, formData) => {\n  console.log(wordId, formData);\n  return {\n    type: 'PATCH_KEYWORD',\n    nodeId,\n    formData\n  }\n}\nconst isRequired = (value) => !validator.isNull('' + value);\nclass KeywordForm extends Component {\n  constructor(props){\n    super(props)\n  }\n  handleSubmit(formData){\n    const { dispatch, node: { id } } = this.props;\n    dispatch(patchKeyword(id, formData))\n    debugger;\n  }\n  componentWillReceiveProps(newProps){\n    let { dispatch, node} = newProps\n    node.productCategory = 'asdf'\n    node.metaDescription = 'asdf'\n    node.name = 'asdf'\n    dispatch(\n      actions.load(\n        'keyword',\n        node,\n        {options: {silent: false}}\n      )\n    );\n  }\n  render(){\n    return (\n       this.handleSubmit(keyword)}\n      >\n        \nSection Naming\n\n\nName\n\n\n\n\n    <fieldSet>\n      <legend>Meta data</legend>\n      <div className='formrow'>\n        <Field model='keyword.metaTitle' style={{width: '100%'}}>\n          <label>Meta Title</label>\n          <input\n            type='text' placeholder='Meta Title '\n            style={{width: '100%'}}\n          />\n        </Field>\n      </div>\n    </fieldSet>\n    <button\n      type='submit'\n    >Save\n    </button>\n  </Form>\n);\n\n}\n}\nconst mapStateToProps = (state, ownProps) => {\n  return {\n    keyword: state.keyword,\n    node: ownProps.node,\n    form: state.KeywordForm\n  }\n}\nconst KeywordFormer = connect(mapStateToProps)(KeywordForm);\nclass KeywordParent extends Component {\n  constructor(props){\n    super(props)\n    this.displayName = ${this.props.node.name}\n  }\ncomponentDidMount(){\n    const { dispatch, fetchKeywordsIfNeeded, selectedUrl } = this.props;\n    dispatch(fetchKeywordsIfNeeded(selectedUrl))\n  }\nrender(){\n    const { node, tree } = this.props\n    return (\n      \n        {node && node.name ?\n          \n\n :\n          \nLoading\n\n        }\n      \n    )\n  }\n}\nfunction mapStateToPropsKeywordParent(state, ownProps){\n  const { keywordsByUrl, selectedUrl } = state\n  console.log(keywordsByUrl)\n  const {\n    isFetching,\n    lastUpdated,\n    items: tree,\n    changes\n  } = keywordsByUrl[selectedUrl] || {\n    isFetching: true,\n    items: {},\n    changes: []\n  }\n  const node = tree[ownProps.params.id] || {}\nreturn {\n    selectedUrl,\n    tree, node,\n    saveNode, fetchKeywordsIfNeeded\n  }\n}\n//In actuality this is just exported...\nconst KeywordThing = connect(mapStateToPropsKeywordParent)(KeywordParent)\nconst FRONTEND_URL = 'cd6da4c9-0948-4bff-bb95-21b4a0d41c72/'\nclass App extends Component {\n  render(){\n    return (\n      \n\n          Links:\n          {' '}\n          ${FRONTEND_URL}}>Home\n          {' '}\n          {/ Hard Coded links because whatever /}\n          ${FRONTEND_URL}0/keyword}>First Keyword\n          {' '}\n          ${FRONTEND_URL}1/keyword}>Second Keyword\n        \n\n{this.props}\n\n\n    )\n  }\n}\nclass Home extends Component {\n  render(){\n    return (\n      \n        Why, hello there.\n      \n    )\n  }\n}\nconst routes = (\n  <Route\n    id='content' component={App}\n    path={${FRONTEND_URL}}\n\n<IndexRoute component={Home}/>\n<Route path=':id/keyword' component={KeywordThing}/>\n\n\n)\n\nclass Root extends Component {\n  render() {\n    const { store, history } = this.props\n    return (\n      \n\nhi\n\n    )\n  }\n}\n// Render Stuff...\nconst store = configureStore()\nconst history = syncHistoryWithStore(browserHistory, store)\nrender(\n  ,\n  document.getElementById('root')\n)\n```\n. OK sorry Figured it out... componentWillReceiveProps(newProps) I have to control for the newProps being me typing so what happened was that I would type that would cause a newProps event so then it would once again set it as the node's original values. It would write it and then unwrite it with each componentWillReceiveProps as to the error that ended up somehow being triggered due to some random const being used. \nSo if someone wants it to work with componentWillReceiveProps make sure you control for the newProps being a change to the form or to keyword model those can be ignored.\n. when you say path to form would that allow someone to say this nested object is the form who's path is 'itemsByUrl.myUrl.idWithinUrl[3].item' in other words change that aspect of the state? Right now I am using actions.load to load that path into the Form but I will get to avoid that or am I misreading \n\nis the path to the form state. This will allow you, the developer, to tell RRF \"don't bother looking for the form, I already know where it is\"\n. \n",
    "mewben": "\njsx\nvalidators={{\n  email: (value) => isEmail(value + ''),\n}}\n\nThanks but this doesn't help... value is undefined when using immutable.\nYes I agree it's non-issue with validator.js\nI guess it's in the way immutable access the values.\n. Super awesome! Thanks for the quick address on the request... \ud83d\udc4d \n. Thank you for the quick response. The code works. Thanks. However, what I really wanted was to attach a className to the age input whenever it is invalid.\njs\n{parentModel.children.map((child, k) => {\n    return (\n        <div key={k}>\n            <Field model={`parentModel.children[${k}].firstName`}>\n                <label>Child {k + 1} - First Name</label>\n                <input type=\"text\" />\n            </Field>\n            <Field model={`parentModel.children[${k}].age`}>\n                <label>Child {k + 1} - Age</label>\n                <input type=\"text\" className={'----> ERROR CLASS HERE IF NOT VALID <---'} />\n            </Field>\n        </div>\n    )\n})}\nI tried accessing the parentForm.fields.children.0.age.valid which is fine, but parentForm.fields.children.1.age.valid is undefined.\n. > And are you accessing it via parentForm.fields['children.0.age'].valid? That's the current (ugly) way to access a field.\nYes. That's what I'm using right now. However, it doesn't have ['children.1.age']\n\nHere's the code.\nI tried using \"react-redux-form\": \"^1.0.0-beta.1\", but it doesn't compile in esnextb.in\nHere is the sreenshot using beta in my local machine:\n\nNotice that there's only 1 object in the array instead of 2 from the parentModel.\nP.S. Sorry for the big images. Don't know how to make them smaller. :)\n. Ahhh.. yes.. this works.. Thank you very much. :)\n. Same here... exported isValid is found in the /src but not in the /lib. ",
    "elodszopos": "@davidkpiano Confirmed bug. I ran into this just two days ago.\n. PR incoming in a sec with one more test case. Confirmed that the bug is taken care of. @davidkpiano \n. ",
    "dave-clover": "Okay, I believe I was mistaken.  I wasn't using omit correctly.  I was doing something like:\nactions.omit('blah', 'foo.bar') instead of actions.omit('blah.foo', 'bar').\nI've been thinking a lot about what to suggest, but I think it's probably fine as it is now.  The only thing that might be nice is to allow the user to do actions.omit('blah.foo.bar'), but it seems easy to reproduce this behavior by splitting on the last dot character.\n. Thanks for the quick reply.  The predicate thing would be very cool.\nJust brainstorming here, but it might also be nice to specify the name of the property:\ndispatch(actions.omit('blah', (val, name) => name != 'baz'));\n. Very cool.  Thanks again for such a great library!  The amount of boilerplate code we no longer have to write is enormous.\n. Sorry for the delay...super busy right now.  Sounds fine to me.  Thanks again for the great library.\n. Also...happy to submit a PR.  Of the two options I mentioned, do either (or both) appeal to you?  Or do you have another idea?\n. Thanks for the response and example.  My main concern is that if the form is invalid, \"foo\" or \"bar\" will stick around in the store longer than I would like.  My comment about having an onSubmitFailed function was so I could clear out that field if that happens.\nThis flow is the thing that is bothering me:\nUser tries to submit and either:\n1. It's valid and onSubmitis called\n2. It's invalid and nothing is called.\nI don't think listening for the rrf/setSubmitFailed action in my reducer will work because the model my form is connected to is passed in through a prop (it's a generalized form component).\nonSubmitFailed would allow me to do this: dispatch(actions.reset('user.clicked')).\nThanks again for the quick response and great library.\n. @davidkpiano thank you very much for adding this.  I got caught up with some other tasks before I could get back to this issue.. Sounds good.  I'll get started.. I just wrote those tests.  The purpose of store.dispatch(actions.setErrors('test.foo', {})); is to totally remove all validators for a specific field.\nBasically what it tests is making sure that during an unmount, the child component does not unintentionally re-add validators to the store.  Since a component doesn't receive new props on an unmount, it shouldn't change validators that it doesn't know about.  The parent clears all the validators, and then the child should only try to reset the ones it knows about.  In this case, it doesn't know about any validators, so it shouldn't do anything.\nProbably worth a comment given the complexity.\nIs merge: false basically the current behavior?  If so, that should be the default.  That would definitely be a breaking change.  But I'm not the owner of this repo, so I defer to @davidkpiano.. I had a similar use case and ended up using a Redux store listener to send the updated data to the server (debounced).  It sends the whole form, however.  I'm only adding this comment for those who stumble across this issue.  Good luck!. If you can confirm that what I described is expected, I can submit a PR.  We are currently hitting this bug.  The workaround is to manually dispatch actions.load(parentModel, {}) before dispatching the deeply nested object's load action.. I'm out of the office until next week and will submit a fix when I return.  Thanks again!. Caveat: I'm not familiar with this code, so it's possible this line shouldn't be there.\nThe desired behavior is: whenever a submit occurs, either onSubmit or onSubmitFailed should be called.  This line seemed necessary to achieve that behavior.\nonSubmit gets called here: https://github.com/dave-clover/react-redux-form/blob/d6547e8bdff31419558b7199e373a1714d4dc1a2/src/components/form-component.js#L288 , so it seemed like onSubmitFailed also needed to be called.\nI'll take another look and write some tests around it to ensure it's doing what it should be doing.. ",
    "compact": "My forms also render very slowly. From CPU profiling, the functions taking up most of the time are flatten and findKey inside getFormStateKey. It looks like the entire state gets flattened every time the form state has to be retrieved, when the form state is not cached. The Redux state in my app is a large deeply nested object, and flatten is an expensive operation on it.\n@davidkpiano, will the new API that you describe in this comment solve part of this issue?\nhttps://github.com/davidkpiano/react-redux-form/issues/163#issuecomment-214862616\n. @davidkpiano That fixed the performance issue on a small form, thanks! I'll test with a large form (hundreds of fields) and update you if there are any problems.\n. In V1, if I want to access the state directly from say a selector, will it be .0 or [0]?\n. ",
    "fromanother": "@davidkpiano When moving the validators in the <Form validators={{email: ..., username: ...}}> component it works as described by you.\n. ",
    "skeletorkun": "I have spent the entire day looking for a proper example of ' dynamically updating the initial values' it would be worth adding some examples of it. @davidkpiano \nThe only working proof as a reference i found is : https://swizec.com/blog/populate-react-redux-form-dynamic-default-values/swizec/8158 \nit is really painful... ",
    "Ahmtdnz": "Sorry, i didn't see. Do you have custom component example ? \nThanks for help.\n. it is here.\nbut react-select  doesn't work with www.esnextb.in.\ni have \"react-select\": \"^1.0.0-beta13\" .\n. ",
    "ishwinder": "Were you able to make the select component of material-ui work with react-redux-form ? Material-ui select seems too buggy :(\n. ",
    "philippzentner": "@davidkpiano TextField etc are working great. But it seems to have hard times with custom select & menuitem (option) controls.. ",
    "rahulraibit": "Thanks for the Reply. But In my case I have a base form which will dynamically generate the controls and  a parent form that will pass the model for generating the form. Now I want the handler in my base form should be generic that will simply pass the required data to parent where I can Call my custom reducer and play some logic. \nHere is an example.\nBase Form \nif (element.fieldType === 'selector') {\n<select  key={element.id}  onchange={this.props.handleChange.bind(element, this)}>{ element.values.map(function (value) { return <DropDownOptions options = {value} /> }) }</select>\n}\nHere is the handleChange method that will simply pass the current element and the model to parent form where I will call the reducer and do what ever I want, so that my base form will be generic .\nhandleChange(element, e){\n this.props.handleChange(element, this.props.formFieldValues.apiKeyFields); //passing data to parent handler\n}\nParent Form\n```\nconst initialState = {\napiKeyFields: {                  \n  Device :{\n    Category : ''\"\n   }\n},\nuiKeyFields : {\n    Fields: [{\n      label: 'Category',\n      fieldType: 'selector',\n      id: 'Category',\n      apiKey: 'Device.Category',\n      values: CountryList\n    }}}\nconst store = createStore(combineReducers({\n  formFieldValues: modelReducer('formFieldValues', initialState),\n  formFieldValuesForm: formReducer('formFieldValues', initialState),\n  AddDeviceReduer : modelReducer('formFieldValues', initialState)    //Custom Reducer\n}));\n\n //Base form \n\nhandleChange(element, values){   //here I want to Update the other dropdown with my reducer.\n    var selected ='';\n    if(element.id == \"Category\"){\n      selected = values.Category;\n    }\n  }\n```\nForgive me If I am doing something Crazy, only my motive is to make the base form generic, So that it can be reusable and all the custom logic I can handle in the parent form with my Custom reducer.\nI am able to call the handleChange method in parent form. But I don't know how to call my custom reducer ??\n. ",
    "gregnorris": "Is there an easy way to do that right in the call to <ReactReduxFormField model={ model } updateOn=\"blur\" .... ?\nIf you could throw a snippet of code, that would be fantastic.\nThanks!\n. ",
    "tomspeak": "Which version of RRF are you using? I believe I faced something similar, which, if I understand your problem correctly, was fixed here in v0.13.5.\n. There's an existing discussion at #285.\n. https://codesandbox.io/s/m5oqp02j2p\nYou will need to upload a PDF file that is over 1mb large.\nI noticed that on codesandbox to use redux-logger, you must use your browser's console tool as it won't properly log using the app's console.. @davidkpiano Hey, was wondering if the sandbox link accurately simulating what I was describing for you?\nP.S - Amazing JSConf Iceland talk!. Unfortunately I'm not at all versed with the code base, any insights or direction you could give to get me started would be greatly appreciated.. Ultimately I was misusing the  - it now all works as intended.. @davidkpiano  -  do you require a code example? I assumed I was abusing model=\".\" - I searched through every issue I could find without finding anything similar.. @davidkpiano  - https://codesandbox.io/s/rm4yvjo7m4\nA slightly convoluted example, but close to what I am doing. If you check the box, it'll show the necessary validation message, but when you make an API request via submit(), the error returned will also be shown in the title's Error component - this makes complete sense as I am using model=\".\" - was wondering how to get this behaviour to work so I can have one error message that will validate two fields (a good example being a salary range, or fields that are only required if another field is filled out).. @davidkpiano  - I was wondering if my code example was enough to demonstrate the problem?  Cheers!. hey @davidkpiano, was wondering if you had a chance to look this over? Thanks. If anyone is unfortunate enough to have to show errors for form wide validations like me, this may be the dirty hack you need.\n```js\nimport React from 'react';\nimport { Errors } from 'react-redux-form';\nconst FieldErrors = props => {\n  const { field, error } = props;\n  let show;\n// If we have passed a field, it is a custom Form level validation error.\n  if (field) {\n    // If the error key we passed exists, only show if we have interacted with the field.\n    // If the key no longer exists, it means the form has submitted an error and the key was wiped, thus do not show it.\n    show = error ? field.touched && !field.focus : false;\n  } else {\n    // Generic inline form error logic.\n    show = {\n      touched: true,\n      focus: false,\n    };\n  }\nreturn (\n     (\n        \n          {props.children} {props.error}\n        \n      )}\n      {...props}\n    />\n  );\n};\nexport default FieldErrors;\n```\nUsed like so:\njs\n<FieldErrors\n  model=\".\"\n  field={jobFormFields.compensation_to}\n  error={jobFormForm.errors.isValidCompensation}\n  messages={{\n    isValidCompensation: 'Invalid salary range',\n    isRequired: MESSAGES.isRequired,\n  }}\n/>. ",
    "cipater": "I'm running into the same issue... I'm using setFieldsErrors to set errors sent back from server-side validation. And subsequent submits fail, emitting a setSubmitFailed action followed by setFieldsValidity. Repeated submits continue to fail. \nInspecting the form field in question, I see that valid, validated, validating, and validity are all false.\nThe documentation notes that It simultaneously sets the .validity on each sub-model to the inverse of its errors. Am I supposed to be cleaning up the valid and/or validity keys manually?\n. I added dispatch(actions.resetValidity(modelName)) to the beginning of my handleSubmit function, but that doesn't appear to be working. Perhaps it's the same issue as #463? \nAlthough, I see that issue was fixed in 1.0.10... and while the package.json in my node_modules/react-redux-form claims to be 1.0.10, node_modules/react-redux-form/src/reducers/form/reset-validity-action-reducer.js does not contain the changes from 3acba22.\n. In fact, I'm still experiencing #465 and #466 despite my local copy claiming to be 1.0.10. And that's the case even after deleting and reinstalling the package. \n. I'm still experiencing the issue as of 1.0.14.\nCurrently the only workaround I've found is to run actions.resetValidity() inside an onClick handler on the submit button. Otherwise the handleSubmit function on the form is never reached on subsequent attempts to submit.\n. If it helps, here's a simplified example of what I'm doing:\n``` javascript\nclass OrderForm extends React.Component {\n  resetForm() {\n    dispatch(actions.resetValidity('forms.order.address'))\n  }\nhandleSubmit(order) {\n    dispatch(updateOrder(order))\n    .catch(err => dispatch(actions.setFieldsErrors('forms.order.address', err.address)))\n  }\nrender() {\n    return (\n      \n        { this.props.children }\n        Submit\n\n    )\n  }\n}\n```\nPerhaps it's because I'm calling actions.setFieldsErrors() on a subform that's the issue? I tried actions.setFieldsErrors('forms.order', { address: err.address }) and wasn't getting the results I was expecting.\n. Yeah that's not clear from the example, sorry. forms.order.address is an object. props.children contains various Fieldsets for the main order form. So err is an object of the same shape as the root order form.\njavascript\n{\n  address: {\n    first_name: \"can't be empty\",\n    ...\n  },\n  ...\n}\nAnd since actions.setFieldsErrors('forms.order', err)  wasn't working, I'm calling setFieldsErrors for each object within err. But it would be nice if setFieldsErrors (or some other method) could handle nested objects.\n. Sorry for the delayed response... Yes, this is still an issue as of 1.0.14, which I believe was current at the time of you asking.\n. Hmm. Looking at the commit logs, that doesn't appear to be true... But I've just tried it on 1.2.2, and it's still an issue.\n. I don't know how complicated it would be given the internals... and it would be a significant departure from the current API... But maybe have a single storage/validate object that's stored on the context. Internally, Form, Filed, Control, etc. just all reference the object?\n``` javascript\nimport { reduxStorage, localStateStorage } from 'react-redux-form'\n<Form\n  storage={ reduxStorage || localStateStorage }\n  // ...\n\n```\n\nEssentially the current action creators API and \"getter\" functions would move into this storage object. So reduxStorage will dispatch as is currently being done. And localStateStorage would use setState ... I'm guessing it would have to passed this.state from the host component i.e. localStateStorage(this.state)\nIn this way the form API is decoupled from the storage mechanism, and you no longer need localForm or globalForm, or a lot of boilerplate to do something custom via handle... callbacks. And it would make it \"trivial\" for other storage engines that could use the browser's localStorage or sessionStorage, or even cookies (a terrible idea!), etc.\nThe API is large enough that it might be challenging to write a custom storage engine from scratch... But if someone had special requirements over a default implementation, maybe they could override the behavior thusly\n``` javascript\nlet myCustomLocalStateStorage = (defaultLocalStateStorage) => {\n  const someApiMethod = (...args) => {\n    if (someCondition) {\n       // ... do something different\n    } else {\n      return defaultLocalStateStorage.someApiMethod(...args)\n    }\n  }\nreturn {\n    ...defaultLocalStateStorage,\n    someApiMethod\n  }\n}\n```\nJust thinking out loud...\n. > Sounds good?\nTotally. I was just spit-balling... mostly a reaction to the idea that you might be building separate Form / Control / Errors components for redux vs. local state, which seemed impractical from a code maintenance perspective, especially if additional storage mechanisms were to be considered at some point in the future. But if that isn't the case, or if those components aren't actually been duplicated internally and react-redux-form/local is just some hand-waving with HOCs and exports, then that seems fine.\nRegarding your comments about 'code smell' and opaqueness, I don't necessarily disagree... but I'm curious about your thoughts on the difference between actions.change('model.name', value) and reduxStorage.change('model.name', value). Are they not conceptually similar? I guess my question is, isn't actions essentially already a \"magical storage\" adapter that RRF uses to cede state control to redux? At least from a \"setter\" perspective. Is the only difference that actions isn't passed around on the context whereas ...Storage would be? Or am I missing something else?\n. Every time I revisit react-redux-form, I struggle with this very issue of mixing client side and server side validation errors. \nI find myself regularly wanting to do something like:\n```javascript\nclass MyForm extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      isValid: true,\n      error: null\n    }\n  }\nhandleFormUpdate(form) {\n    this.setState({ isValid: form.$form.valid })\n  }\nhandleSubmit(model) {\n    this.setState({ error: null })\n    const response = saveModelToServer(model)\n/* response shape\n{\n  model: { ... },\n  errors: [\n    { key: 'email', messages: ['has already been take'] },\n    ...\n  ] \n}\n*/\n\nif (!response.errors.length) return\n\nresponse.errors.map( error => {\n  if (error.key) {\n    this.formDispatch(actions.setErrors(`local.${error.key}`, { serverError: error.messages.join(', ') }))\n  } else {\n    this.setState({ error: error.messages.join(', ') })\n  }\n})\n\n}\nattachDispatch(dispatch) {\n    this.formDispatch = dispatch\n  }\nrender() {\n    const { isValid, error } = this.state\n    const { model, children } = this.props\n    let renderedError\nif (error) {\n  renderedError = <Alert>{ error }</Alert>\n}\n\nreturn (\n  <LocalForm\n    initialState={ model }\n    onUpdate={ this.handleFormUpdate.bind(this) }\n    onSubmit={ this.handleSubmit.bind(this) }\n    getDispatch={ this.attachDispatch.bind(this) }\n  >\n    { renderedError }\n    { children }\n    <button type='submit' disabled={ !isValid }>Save</button>\n  </LocalForm>\n)\n\n}\n}\n```\nIt feels clunky to have to import actions from the library, and attach dispatch to my component via a callback just for the purposes of setting errors. To me it'd feel more intuitive to pass errors to <LocalForm /> via a prop. Where the value passed would conform to same shape as the value passed to initialState, just with the error messages as the values.\nFailing something along those lines, then a official example/pattern of how to get something like this working.\nAs it is, the above doesn't work since isValid stays false after the server responds. The only work around I can think of is:\n``javascript\nhandleFormChange(model) {\n  if (!this.formDispatch) return\n  Object.keys(model).map( k => {\n     this.formDispatch(actions.setErrors(local.${k}`, { serverError: false }))\n  })\n}\n...\n\n  ...\n\n```\nBut this is terribly hacky, especially as it loops through the model on every key press :( And it resets all \"server errors\" when any one field is touched.\nIf exposing .syncValid, and modifying the above to code to be setError( ... , { async: true }) does the trick, then great. But like @thomasboyt said, \"async\" doesn't feel quite like the right concept here. And would nice to a have a cleaner more straightforward API, especially when dealing with <LocalForm />.. I think bc4b9b98c50bac022652f8e7d2aaf2515097134c may have introduced a bug for my use-case:\nI have a Custom control that takes an attribute indicating the value should be treated as an Integer... This wraps rrf's onChange function, calling parseInt on the value before passing it down.\nThis works fine when the form is submitted via a button click. However, if this custom control has focus when enter is pressed, it appears to be pulling the String value directly from the input, rather than the value stored in the $form object. \nGiven:\n<LocalForm onUpdate={ form => console.log(form) }>\n  <CustomInput type='number' model='.number' />\n</LocalForm>\nOn pressing enter I get 3 console entries; the first shows $form.number.value  as being an Integer, the next two are both Strings, which is ultimately what the onSubmit handler receives.\nI don't quite see in this commit how the String value would get reincorporated into the $form object. So maybe it's something else... The forcedUpdate ? value : modelValue ternary led me here.. @fraxachun I just ran into this as well. I'd like to see a better API for this for LocalForm... but it seems the current way to do this is:\n```javascript\n this.formDispatch = dispatch } initialState={ state } />\n// when you want to update the initialState\nthis.formDispatch(actions.change('local', nextState))\n``\n. I'm torn on this. On the one hand, I'd expect the behavior @fraxachun mentions\u2014if I pass in new data, I expect that new data to be rendered. After all, Flux/redux/et al are patterns/tools designed to encourage removing state from components. And from the outside looking in,LocalForm` is somewhat ironically using redux to do just the opposite.\nOn the other hand, while LocalForm has gone a long way to abstract away most of the complexities of setting up / using redux, this is nonetheless a redux-based project. And if you want to move beyond the basics while still using LocalForm, the use of getDispatch seems unavoidable. \nAs such, I suspect further abstractions are outside the scope of this project. However, I'd ideally like to see that abstraction pushed as far as is reasonable. i.e. with initialState, maybe have LocalForm do something like actions.change(nextProps.model, nextProps.initalState) inside componentWillReceiveProps. Or on some other prop if using initialState in this way a) is confusing given its name, or b) might break existing code.. ",
    "alexkirsz": "Thanks for the quick reply!\n. ",
    "TLadd": "Cool, thanks for the tip.\n. > Something that I also found puzzling that may or may not be related to this issue is that I originally discovered it because I noticed that while each field on a model e.g. 'forms.signup.username' has the submitFailed attribute in the state, it is never updated to True, even when the submit has failed and the 'forms.signup' state object submitFailed attribute is True.\nI noticed this as well in 1.0.8; when validating a form on submit and the validation fails, the submitFailed value at the $form level is set to true, but the fields' submitFailed values remain false. @davidkpiano, would you expect the fix you mention to fix this as well?\nEdit: the submitFailed field issue is still present in 1.0.9.\n. Ended up just moving the outlying reducers into createForms. There probably isn't really a good reason to have a shape like the above, so it's fine with me if you would like to close.\n. The docs indicate that setInitial ought to change the field state but not the model. Instead the model is getting reset as well.. @marcandrews Yeah, so the module-resolver in my project is set to ['src', 'node_modules'], so that is part of the confusion being seen.\nHowever, the bigger issue here is that https://github.com/davidkpiano/react-redux-form/commit/f4939ed1216d93989ae7e7ddd794920cd8b9c131#diff-044eca1babb8d79413e7adc591159915R1 basically made immutable a peer dependency of react-redux-form, which it was not before. Previously, if you import from react-redux-form index.js, you do not need to have immutable installed. When it was added to the find-key util, that changed. Seems like there needs to be a separate find-key/track function for immutable data to preserve the previous package requirements.. > Adding a separate utils/find-key.js for ImmutableJS support will still add ImmutableJS as a dependency so that is not a solution.\nI don't think that's true. It looks like it should just be a matter of adding findKey to the strategy used in track here: https://github.com/davidkpiano/react-redux-form/blob/master/src/utils/track.js#L7. The defaultStrategy should use the non-immutable version of find-key\nThen in immutable.js, https://github.com/davidkpiano/react-redux-form/blob/master/src/immutable.js#L148 createTrack will be given find-key-immutable instead.\nI believe this would be in line with how immutable.js support works in general for the library.. @davidkpiano, pulled down 1.14.5 and seems like lib may not have been updated?. @BrandonBoone nothing wrong with the module resolver; it just resulted in slightly confusing error messages on my end. Since I (and you) don't have immutable installed as a dependency, the immutable import that was in find-key.js resolves to the immutable.js file in react-redux-form's src directory. Everything should be fine once the update is published.\nAnd yeah, 1.14.5 didn't seem to have the src changes published to lib, so it's still broken. Should be resolved soon I imagine.. @davidkpiano Yep, pulled 1.14.6 and it works. Thank you!. ",
    "jenyckee": "@davidkpiano This causes a refresh when I try this. ",
    "snowghost24": "How do you trigger the handleSubmit  function and pass the event?. ",
    "matias89": "Thanks for response. Then: how I can get the form validation when I submit my form?\n. Sorry, but I can't understand, because if I don't add or change any text in the form when I load it the first time, and the form is submited, and in my submit function I use \"setValidity\" for required field (false), I can't get the validation with \"userProfileForm.valid\".\n. Yes: https://esnextb.in/?gist=0bd9c168f58a07e29cae94483cf699b1\n. I'm sorry, I was with many other things during these days. I understand what did you say, but then: how I can set by default the property in \"false\" (in my case, userProfile.valid false by default)?\n. Ok, I'll test this. Thanks David!\n. ",
    "ottoo": "Originates from form-component \n```\nattachNode(node) {\n    this._node = node;\nthis._node.submit = this.handleSubmit;\n\n}\n```\nLooks like when redirecting to another route it cant find the form to attach the submit because it doesnt exist any more?\nIf I add if (!node) return; to the fn seems to work just fine.\n. ",
    "youtnbe": "my component in custom control get value as empty string, but in redux store value is 0. ",
    "hgylfason": "Ok, that is probably it. Thank a lot for the quick reply and for this brilliant library.\nWould you consider making track handle multiple layers of collections in the future*?\nE.g. track could receive a list of predicates and would use them to identify item in each collection.\n*I admit I am not familiar with the inner workings of track so please dismiss this if it's not applicable.\n. This behaviour was my fault.\nSome of the methods used were depreciated and I forgot to update them.. ",
    "Sephi-Chan": "Same problem here.\n. When I install the 0fffccb commit my build tool (brunch) fails to load the package:\nResolving deps of web/static/js/test_form.js failed. Could not load module 'react-redux-form' from '/Users/romaintribes/Sites/bspirit/web/static/js'.\nOn the current version 0.14.1, I get errors when I import Field from react-redux-form/lib/immutable.\nwarning.js:48Warning: React.createElement: type should not be null, undefined, boolean, or number. It should be a string (for DOM elements) or a ReactClass (for composite components). Check the render method of UserForm.\ninvariant.js:42Uncaught Invariant Violation: Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: undefined. Check the render method of UserForm.\nHere is the minimal code :\n``` es6\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Map } from 'immutable';\nimport { Provider, connect } from 'react-redux';\nimport { createStore, combineReducers } from 'redux';\nimport { actions, formReducer } from 'react-redux-form';\nimport { Field, modelReducer } from 'react-redux-form/lib/immutable';\nconst initialUserState = {\n  firstName: '',\n  lastName: ''\n};\nconst store = createStore(combineReducers({\n  user: modelReducer('user', Map(initialUserState)),\n  userForm: formReducer('user')\n}));\nclass UserForm extends React.Component {\n  handleSubmit(event) {\n    event.preventDefault()\n    let { user, dispatch } = this.props;\n// Do whatever you like in here.\n// You can use redux simple form actions such as:\n// actions.setPending('user', true);\n// actions.setValidity('user.firstName', user.firstName.length > 0);\n// actions.setSubmitted('user', true);\n// etc.\n\n}\n  render() {\n    let { user } = this.props;\nreturn (\n  <form onSubmit={this.handleSubmit.bind(this)}>\n    <Field model=\"user.firstName\">\n      <label>First name:</label>\n      <input type=\"text\" />\n    </Field>\n\n    <Field model=\"user.lastName\">\n      <label>Last name:</label>\n      <input type=\"text\" />\n    </Field>\n\n    <button type=\"submit\">\n      Finish registration, { user.firstName } { user.lastName }!\n    </button>\n  </form>\n);\n\n}\n}\nfunction mapStateToProps(state) {\n  return { user: state.user };\n}\nconst ConnectedUserForm = connect(mapStateToProps)(UserForm);\nclass App extends React.Component {\n  render() {\n    return (\n      \n\n\n    );\n  }\n}\nReactDOM.render(, document.getElementById('container'));\n```\n. ",
    "ozum": "I also couldn't manage to get a working example with react-redux-form either v0.x or v1 beta. using immutable.js.\nCould you please provide single file minimal working example for immutable.js?\n. v 1.0.0-beta.6\n. The code you provided initialises model reducer and form reducer, which works ok as I indicated in my first message. My problem occurs when store is initialised instead of reducers.\nSee complete example below. (Please note that https://esnextb.in does not reproduce problem, try with local server.) Focus and blur last textbox.\n\nsrc/index.jsx\n``` js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { createStore, combineReducers, applyMiddleware } from 'redux';\nimport { connect, Provider } from 'react-redux';\nimport { Field, Form, actions, track, modelReducer, formReducer } from 'react-redux-form';\nimport thunk from 'redux-thunk';\nconst store = applyMiddleware(thunk)(createStore)(combineReducers({\n  user: modelReducer('user', {}),\n  userForm: formReducer('user', {}),\n}), { user: { firstName: 'G', friends: [{ id: 1, name: 'George' }] }})\nclass UserForm extends React.Component {\n  render() {\n    let { user } = this.props;\nreturn (\n  <Form model=\"user\"\n        onSubmit={(user) => this.handleSubmit(user)}>\n    <Field model=\"user.firstName\">\n      <label>First name:</label>\n      <input type=\"text\" />\n    </Field>\n\n    <Field model=\"user.lastName\">\n      <label>Last name:</label>\n      <input type=\"text\" />\n    </Field>\n\n    {this.props.user.friends.map((friend, index) =>\n        <Field model={track('user.friends[].name', (friend) => friend.id === 1 )} key={friend.id}>\n          Focus and blur this: <input type=\"text\"/>\n        </Field>\n    )}\n\n\n    <button type=\"submit\">\n      Finish registration, { user.firstName } { user.lastName }!\n    </button>\n  </Form>\n);\n\n}\n}\nfunction mapStateToProps(state) {\n  return {\n    user: state.user,\n  };\n}\nUserForm = connect(mapStateToProps)(UserForm);\nclass App extends React.Component {\n  render() {\n    return (\n      \n\n\n    );\n  }\n}\nReactDOM.render(, document.getElementById('app'));\n```\nsrc/index.tpl.html\n``` html\n<!doctype html>\n\n\n\n\nReact Redux React-Router with Webpack Boilerplate\n\n\n\n\n\n\n\n```\n./webpack.config.js\n``` js\nconst path = require('path');\nconst webpack = require('webpack');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nmodule.exports = {\n  devtool: 'eval-source-map',\n  entry: [\n    path.join(__dirname, 'src/index.jsx'),\n  ],\n  output: {\n    path: path.join(__dirname, '/dist/'),\n    filename: '[name].js',\n    publicPath: '/',\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: 'src/index.tpl.html',\n      inject: 'body',\n      filename: 'index.html',\n    }),\n    new webpack.DefinePlugin({\n      'process.env': {\n        NODE_ENV: JSON.stringify('development'),\n      },\n    }),\n  ],\n  resolve: {\n    root: [path.resolve(__dirname, 'src'), path.resolve(__dirname, 'node_modules')],\n    extensions: ['', '.js', '.jsx'],\n  },\n  module: {\n    loaders: [\n      {\n        test: /.jsx?$/,\n        exclude: /node_modules/,\n        loader: 'babel',\n      },\n    ],\n  },\n};\n```\n/.babelrc\njson\n{\n  \"presets\": [\n    \"es2015\",\n    \"react\",\n    \"stage-1\"\n  ]\n}\n. Thank you @davidkpiano. I know that current latest production version is 0.x.x.\nI asked which is the latest development version, v1.0.0 or v1.0.0-beta.6?\n. @davidkpiano, isn't form model deep.foo in that case?\nWhat is equivalent combineForms of code below?\njs\nconst store = applyMiddleware(thunk)(createStore)(combineReducers({\n  something: anotherReducer,\n  notDeep: modelReducer('notDeep', initial),\n  notDeepForm: formReducer('notDeep', initial),\n}));\n. Thanks.\n. (I updated second video with more clear one)\nMy point is not general performance issue. My point is performance difference between 1st item and remaining items. All items share same conditions (as expected in a loop), but first line is slow, while other rows' performance are excellent for same conditions. I expect either all rows are slow or all rows are fast.\nBoth for updateOn=\"blur and updateOn=\"change\", see what happens for every key press (even for updateOn=\"blur). Every key press for the first row results in dramatic resource usage such that you can tell when I press a key just by looking FPS meter. However for other rows, key presses does not change graph line in FPS meter.\nYou can access whole code on repo git@bitbucket.org:fortibase/item-list.git, commit 3eefc05.\n. It seems so. I tried again in 3 different machines (OS X, Windows XP, Windows 10 all served by OS X) and I encountered same issue.\nIf possible, could you please try with another machine?\n. Just realized that v1.0.0 is OK.\n. @davidkpiano please reopen this issue at least until you try it on another machine.\nBy 1.0.0, I mean the version from npm. Command: npm install react-redux-form@1.0.0\nP.S. As you remember, this version confused me, which I asked in another case, because I assume 1.0.0 is greater and later than betas. However you are developing new betas after 1.0.0.\n. Latest report. I also updated (first message according to this).\nFor this particular problem:\nv1.0.0: There is no problem.\nv1.0.0-beta.1 to v1.0.0-beta.8: Problem exists. (High usage for every key press on 1st line)\nv.1.0.0-beta.9: Performance greatly enhanced, but still exists. (High usage 1 out of 5 key presses on 1st line)\n. Hi David,\nI'm abroad. I'll look into that when I'm back. I will message you to reopen this if issue still exists.\n. 1.0.0-beta.9 is OK. It's not affected from all three problems I reported.\n. ",
    "erin-doyle": "Is it possible this is still not working completely with immutable.js?\nI am using the latest version (1.0.3) of react-redux-form.  I am importing combineForms from react-redux-form/lib/immutable and using it like so:\n```\nimport { combineForms } from 'react-redux-form/lib/immutable';\nconst store = createStore(combineReducers({\n    routing: routerReducer,\n    intl: intlReducer,\n    form: combineForms({\n        recipientName: fromJS({ name: '' }),\n        senderNameEmail: fromJS({ name: '', email: '' })\n    }, 'form')\n}));\n```\nthen in my form I'm importing Field and Form from the same place like so:\n```\nimport { Field, Form } from 'react-redux-form/lib/immutable';\nconst handleSubmit = (formData) => {\n    console.log('Submitted Data: ');\n    console.dir(formData);\n};\nconst RecipientNameForm = (props) => {\nreturn (\n    <Form model=\"form.recipientName\" onSubmit={ (data) => handleSubmit(data) }>\n        <section className=\"panel\">\n            <Field model=\".name\">\n                <div className=\"input-group\">\n                    <label>{ recipientMessages.label }</label>\n                    <div>\n                        <input type=\"text\" />\n                    </div>\n                </div>\n            </Field>\n        </section>\n        <ButtonComp btnType=\"submit\">\n            <FormattedMessage\n                tagName='span' { ...recipientMessages.button } />\n        </ButtonComp>\n    </Form>\n);\n\n};\nexport default RecipientNameForm;\n```\nIt seems as if when things like updateField() or changeActionReducer() are called they are passed the state as a plain object but when mapStateToProps() in the form-component is called it's passed the state as an Immutable Map and therefore the modelValue is unable to be retrieved as the code attempting to access the value is expecting a plain object.  So the store seems to be getting updated but my onSubmit handler receives undefined.\nI can't tell if maybe there's something not correct about my implementation or if react-redux-router is still not really proven to be compatible with immutable?\n. Ah ok, well that certainly helps to know!  This is a really great library and I thank you for all your efforts so far so I will definitely be looking forward to that!  If you wish to dole out any of the work I'd be very interesting in chipping in and contributing!\n. So is my assumption correct that a punch list of what's left to do can be determined from the export list in https://github.com/davidkpiano/react-redux-form/blob/master/src/immutable.js where there is not yet an immutable counterpart?\n. I think this is pretty close to being done now.  In my testing everything seems to be working.  The only exception I'm finding at this point is if creating the store using the redux-immutable library.  If the entire store is immutable there seems to still be problems, most notably in get-form.js, otherwise if only the models within the store are immutable but the store itself is not, things seem to be working well.\nI am already working on a branch for making things compatible with redux-immutable but just wanted to post that update!\n. So here is what the structure looks like when using redux-immutable's combineReducers like so:\n```\nconst initialUserState = Immutable.fromJS({\n  firstName: '',\n  lastName: '',\n});\nconst store = applyMiddleware(thunk)(createStore)(combineReducers({\n  ...createForms({\n    user: initialUserState,\n  })\n}));\n```\nstate: Map\n  user: Map\n  forms: { // Object\n    $form: { // Object\n      errors: Object\n      focus: false\n      initialValue: { // Object\n        user: Map\n      }\n      model: \"\"\n      pending: false\n      pristine: true\n      retouched: false\n      submitFailed: false\n      submitted: false\n      touched: false\n      valid: true\n      validated: false\n      validating: false\n      validity: Object\n      value: { // Object\n        user: Map\n      }\n    },\n    user: { // Object\n      errors: Object\n      focus: false\n      initialValue: Map\n      model: \"user\"\n      pending: false\n      pristine: true\n      retouched: false\n      submitFailed: false\n      submitted: false\n      touched: false\n      valid: true\n      validated: false\n      validating: false\n      validity: Object\n      value: Map\n    }\n  }\nDoes that still look acceptable to you?  I think the only problem is that now the root state is a Map so just getting a form or model must be done differently in addition to getting values from models.  But it looks like once you get the form it's shape remains a plain object.\n. Actually nevermind, I can see now that isn't right.  It looks like the forms.user object does not contain the structure that it should.  I can look into that.\n. #457 should now make the structure of the forms.user object match whether using an immutable implementation or not. \n. I believe this is now done.  I've done a good amount of testing and have not found any further issues with using just redux or redux-immutable.  I think all that remains is documenting it! :)\n. No problem, happy to help!  I am already in work on the Form and Errors components. :)\n. Sweet I am now!  Thanks for letting me know about it!\n. Oops apparently I have some conflicts!  I'll check it out and fix!\n. No, my intention was that developers using react-redux-form should not be forced to use redux-immutable even when using Immutable.JS.  I only added redux-immutable to the dev-dependencies so we could use it in the examples.  The goal is that react-redux-form be compatible for use with or without redux-immutable.\n. Thank you!  It was my pleasure!  This is a great library and I'm happy to contribute to it to push it forward in acceptance in the community. :)\n. Also, in 1.0.10 you should now be able to use redux-immutable without issue and create your form reducer like so (NOTE the importing from react-redux-form/lib/immutable):\n```\nimport { combineReducers } from 'redux-immutable'\nimport { createForms } from 'react-redux-form/lib/immutable'\nexport default function createReducer (asyncReducers) {\n  return combineReducers({ \n    routing, ...asyncReducers,\n    ...createForms({\n        subscriber: { email: 'foo@bar.com'}\n    }) \n  });\n```\ncreateForms() will prevent the need for deep nesting in a form object but if you prefer that you can still use combineForms like so:\n```\nimport { combineReducers } from 'redux-immutable'\nimport { combineForms } from 'react-redux-form/lib/immutable'\nexport default function createReducer (asyncReducers) {\n  return combineReducers({ \n    routing, ...asyncReducers,\n    form: combineForms({\n      subscriber: { email: 'foo@bar.com'}\n    }, 'form') \n  });\n``\n. My bad, I left out of my example and did not make clear that you need to be importing all of these things fromreact-redux-form/lib/immutableif you're usingredux-immutable`.  Take a look at the Immutable example for more details.\nAs for the warning:\nwarning.js:36 Warning: Unknown prop 'getFieldFromState' on <div> tag. Remove this prop from the element. For details, see https://fb.me/react-unknown-prop\nI'll repeat what @davidkpiano said:\n\nThis is a known issue - will resolve it by tomorrow!\n\nSo it's in the works! ;)\n. It looks to me like the model for your Field component should be subscribe.emailnot form.subscribe.email.  If the Form model is subscribe then the Field model is a child of that, thus subscribe.email.\n. So you've changed your Form model to 'subscribe', your Field model to 'subscribe.email' and your Errors model to 'subscribe.email' and you're still receiving errors?  Can you give us an updated state of your code and the errors you're getting?\n. I think you're going to need to use combineForms or createForms otherwise I don't think it's actually creating the form reducer.\n. Sorry this diff is hard to read.  I really did not change a lot in this file but due to wrapping almost the entire contents in the \n```\nfunction createControlClass(customControlPropsMap = {}, defaultProps = {}) {\n}\n```\nblock with indenting everything inside it makes it look like I changed everything.  Besides that I will point out what else I actually changed with comments.\n. I added this block\n. This was the most crucial change in making this component compatible with immutable\n. I added this so that these defaults can be overridden/appended to with any props passed in to the createControlClass() function\n. Again a nasty diff to read, sorry!  The most notable changes were: \n1. adding the testContext (of course)\n2. adding the getInitialState() function for setting up the state of the reducers before each set of tests\n3. adding the use of get() when getting values out of the model state such as: get(store.getState().test, 'foo')\n. Diff again makes it look like I changed more than I did.  The notable changes were:\n1. Added the defaultStrategy\n2. Moved bulk of content into the createFieldActions function\n3. Converted all usage of _get() to the strategy s.get()\n4. Moved the trackable() wrapping to the return statement using mapValues()\n. You did!  I copied the idea over from model-actions.js. ;)\n. I just want to point out that I left the validation stuff out of this example for now until I can get the Errors component updated to being compatible with Immutable.\n. I just changed the variable name in here for clarity purposes.\n. Bigger diff than what I actually changed, so notable changes include:\n1. Added the defaultStrategy\n2. Wrapped the majority of the contents in function createFormClass(s = defaultStrategy) {} block\n3. Converted use of get, getForm and actions to be retrieved from the strategy\n. This seemed like a hidden bug in that the valid property will never be found on formValue but instead should be expected in formValue.$form.  I added a spec for this as well.  Please let me know if that was an incorrect assessment!\n. The majority of the changes here are just adding the testContexts though there were some little refactor/cleanup changes which are easier to find by looking at the commits than trying to find in this diff.\n. Below is the test I added for the bug fix in handleSubmit() changing the check on formValue.valid to formValue.$form.valid.  It may seem a little weird at first glance because we already have tests covering that the form calls the submit handler when it's valid but the goal was to exercise this block of code in handleSubmit():\n```\nconst formValid = formValue\n        ? formValue.$form.valid\n        : true;\n  if (!validators && onSubmit && formValid) {\n    onSubmit(modelValue);\n\n    return modelValue;\n  }\n\n```\nwhich was being totally skipped in all cases previously.  So the tests below were the best way I could think to cover that but please feel free to let me know if you have any other ideas!\n. Since I'm finding myself repeating the stuff below in each spec file I've been refactoring for the immutable strategy I thought maybe it would be helpful to put it here.  You can see in form-component-spec.js where I then used it like so:\nconst testContexts = {\n  standard: {\n    ...defaultTestContexts.standard,\n    Form: _Form,\n    modelReducer: _modelReducer,\n    formReducer: _formReducer,\n    Field: _Field,\n    Control: _Control,\n    actions: _actions,\n  },\n  immutable: {\n    ...defaultTestContexts.immutable,\n    Form: ImmutableForm,\n    modelReducer: immutableModelReducer,\n    formReducer: immutableFormReducer,\n    Field: ImmutableField,\n    Control: ImmutableControl,\n    actions: immutableActions,\n  },\n};\nLet me know if you don't like that idea though!\n. I also made some changes to the get functions in here to take a value without a path as I was finding that I needed to do that a number of times in form-component-spec.js.  So far the rest of the specs don't have that change, so if you like this approach it will help to convert all those over to using the default from here.\n. Yep that's all I changed.  That way we can assert on an object as a whole in addition to specific paths.\n. Sorry I don't totally follow.  What I mean was that previously it was checking for formValue.valid and that doesn't seem to ever be anything except undefined.  So I changed it to formValue.$form.valid.  Is that right or am I missing something?\n. Notable changes include:\n1. Added the defaultStrategy\n2. Wrapped the majority of the contents in function createErrorsClass(s = defaultStrategy) {} block\n3. Converted use of get, getForm and actions to be retrieved from the strategy\n. Just updates to using the testContexts here\n. ",
    "tmartensen": "I would think that the options would be form state, because those choices might not necessarily be saved as part of the model. For instance, when selecting a car, you would only select one make (e.g., Ford) to become part of the model. All the other options should be somewhere in state, but not in the model. Does that make sense?\n. That answered my question! Thanks!\n. ",
    "alexesDev": "Solution\njs\nconst FormComponent = ({ onSubmit, submitProps, children, ...props }) => (\n  <View {...props}>\n    {children}\n    <TouchableOpacity onPress={onSubmit} {...submitProps}>\n      <Text>Submit</Text>\n    </TouchableOpacity>\n  </View>\n);\njs\n<Form component={FormComponent} validators={validators} ...>\n   <Field ... />\n   <Field ... />\n</Form>\n. @davidkpiano Its an awesome library! Very gracefully :+1: \n. I upgrade my old project. At now packager say...\nUnable to resolve module `react-dom` from `/home/alexes/projects/myfresh/native-client/node_modules/react-redux-form/lib/components/control-component.js`: Module does not exist in the module map or in these directories:\n  /home/alexes/projects/myfresh/native-client/node_modules\n,   /home/alexes/node_modules\nreact-native@0.44.0\nThe project skeleton generated today.. ",
    "debradley": "Thanks for the link to 313 - that definitely helps me move forward for now.\nAs far as the API for nested fields, what you're proposing makes sense to me. Though I don't think there needs to be a trackDeep added, you could add the new behavior to track without breaking anything, right?\n. ",
    "odub": "Btw everything works just fine when I put the modelReducer and formReducer calls in the root. For a large app this doesn't seem too elegant though.\n. Nice! Thanks for the solution.\n. ",
    "Slavenin": "Sorry, is my error, i not call model reduser.\n. I think the same\n. ",
    "richardscarrott": "@greaber Not 100% sure I'm following as I'm not massively familiar with RRF but if you needed to fire multiple actions to update RRF state and your own custom model state then I think you'd incur multiple store change events which would be more expensive. You could look at https://github.com/tshelburne/redux-batched-actions to mitigate this however.\n. ",
    "davidspiess": "Glad you like it! I saw this pattern recently in react-intl and it makes things really flexible.\nBeside that, i like your classNames proposal, only downside i can see is it would not be possible to add a class to the <input type=\"email\" /> inside the Field too. Bootstrap requires me to do that :disappointed: \n. Awesome :) Looking forward to v1.0 :tada: \n. Waiting for this \ud83c\udf89  createForms sounds good.\n. Anyway i expected the error messages to show up after submitting a form.\nE.g in https://davidkpiano.github.io/react-redux-form/docs/recipes/sync-validation.html when submitting the form without filling out anything.\n. I tried that already, but it's not possible to delete a string key.\njs\nactions.remove('user', 'friends');\ndoesn't work.\nThe closest i get is\njs\nactions.remove('user.friends', 0);\nBut this leaves me with \njs\n{ user: { friends: [] }}\ninstead of\njs\n{ user: {}}. ",
    "MilanThomas": "Oh, I see ! Indeed, that makes a lot of sense. \nThank you for pointing me in the right direction and for creating react-redux-form :)\n. ",
    "wojciech-bilicki": "Ok, so I put this on esnextbin.in and it was alright. So I checked what are the differences between my project and esnextbin setup and I found out I was using redux-immutable-state-invariant\nhttps://github.com/leoasis/redux-immutable-state-invariant\nAt that was causing the error to show in console.\n. ",
    "MrBlenny": "Do you have a basic esnextbin setup I can modify?\n. This is still not working in V0.14.6.\nIs the fix in the beta ready to go into one of the main releases? Any reason I shouldn't run the beta in production?\n. Any ETA on the fix?\n. I've made a temp fix for now - not sure what the repercussions are but it is working where I need it to.\nLine 290 of component-control.js - Swapped the ternary logic:\n```\n{\n      key: 'getChangeAction',\n      value: function getChangeAction(event) {\n        var _props3 = this.props;\n        var model = _props3.model;\n        var controlProps = _props3.controlProps;\n    var _getMappedProps = this.getMappedProps();\n\n    var _getMappedProps$chang = _getMappedProps.changeAction;\n\n//        var changeAction = _getMappedProps$chang === undefined ? this.props.changeAction : _getMappedProps$chang; // Old version\n        var changeAction = this.props.changeAction === undefined ? _getMappedProps$chang : this.props.changeAction; // New version\n    var value = isReadOnlyValue(controlProps) ? controlProps.value : event;\n\n    return changeAction(model, (0, _getValue2.default)(value));\n  }\n}\n\n```\nLine 608 of component-control.js - Commented out the default changeAction.\nControl.defaultProps = _extends({\n    // changeAction: _actions2.default.change, no more default changeAction\n    updateOn: 'change',\n    asyncValidateOn: 'blur',\n    parser: _identity2.default,\n    controlProps: emptyControlProps,\n    getter: _get3.default,\n    ignore: [],\n    dynamic: false,\n    mapProps: controlPropsMap.default,\n    component: 'input'\n  }, defaultProps);\n. I've updated to 1.0.14 but the issue is still there.\nDo you have any idea what part of the store would be causing the issue (middleware/store-structure/reducers etc)? This is part of a multi-window electron application so it is hard to share the code unless I know what section could be causing the issue.\nHere is a more detailed CPU profile:\n\nThe store state tree looks something like:\n\nStore config:\n```\nimport { createStore, applyMiddleware, compose } from 'redux';\nimport thunk from 'redux-thunk';\nimport promise from 'redux-promise-middleware';\nimport createLogger from 'redux-logger';\nimport { hashHistory } from 'react-router';\nimport { routerMiddleware } from 'react-router-redux';\nimport getRootReducerRenderer from '../reducers/rootReducer.renderer.js';\nimport forwardToMain from './middleware/forwardToMain';\nimport forwardToRendererWindow from './middleware/forwardToRendererWindow';\nimport routerFix from './middleware/routerFix';\nexport default function configureStore(initialState) {\n  const middleware =[\n    thunk,\n    promise(),\n    routerFix,\n    forwardToMain,\n    forwardToRendererWindow,\n    routerMiddleware(hashHistory),\n  ];\n  if(process.env.NODE_ENV == 'development') {\n     middleware.push(createLogger({\n      level: 'info',\n      collapsed: true,\n    }));\n  }\n  const enhanced = [applyMiddleware(...middleware)];\n  enhanced.push(window.devToolsExtension ? window.devToolsExtension() : noop => noop);\n  const rootReducer = getRootReducerRenderer();\n  const enhancer    = compose(...enhanced);\n  const store       = createStore(rootReducer, initialState, enhancer);\nif (!process.env.NODE_ENV && module.hot) {\n    module.hot.accept('../reducers', () => {\n      store.replaceReducer(require('../reducers'));\n    });\n  }\nreturn store;\n}\n```\n. The issue seems to be related to the store object itself.\nWhen using electron the store can end end up with getter functions instead of normal keys/values. Note the get functions on the state object below (this is the result of using remote.getGlobal() in electron):\n\nThis store structure does not play nice with the recursive get-form calls in react-redux-form. I suppose this is more of an issue with electron inter-process communication - not a problem with react-redux form per se. There is probably no easy fix.\n. Yep, that looks good.\nI very much like the idea of disabling getting form and field values from the model. \nPassing model AND value to the form and field/control components feels much more react-like to me.\n. ",
    "th3fallen": "im not entirely sure i can put a running example up there, but i can provide the code of the files. https://gist.github.com/th3fallen/a754755559d2c72f59ac64a377fb226a\n. For some reason after stashing the changes and moving on and coming back it now works as expected...  thanks for the help anyway\n. \ud83d\udc4d  i think it would be useful for the time being i can use isValid() but it would be nice to have it in state imo\nespecially for conditional class setting\n. Also not sure if this would be possible but for us that will use this in nested states (most i assume) would it be possible to be able to set the full state for the form container then have all Control or Field elements models be based on the forms model?\nI.e form model=\"shared.unclaimed.inviteManager\"\nfield model=\"to\" would become shared.unclaimed.inviteManager.to\nMay be a stretch but could be neat.\nOr do a single reducer that autowires like redux-form does.\n. @davidkpiano awesome thanks man, glad it wasnt something i was doing wrong for once.\n. thanks so much i'll check it out now\n. @davidkpiano any chance you could tag that fix? when installing from the v1 branch i get a ton of errors from webpack crying about it not being installed :(\n. > @davidkpiano any chance you could tag that fix? when installing from the v1 branch i get a ton of errors from webpack crying about it not being installed :(\nah didnt see your previous comment. sounds good i'll keep an eye out\n. ```\nimport { combineForms } from 'react-redux-form';\nconst initalState = {\n  to: '',\n  message: '',\n};\nexport const inviteManager =  combineForms(initalState);\n```\n. i manually build the source based on current v1 branch and this is how im creating the store\n```\nimport { combineForms } from 'react-redux-form';\nconst initalState = {\n  to: '',\n  message: '',\n};\nexport const inviteManager =  combineForms(initalState);\n```\n. @davidkpiano thanks for the help but i dont think that gist quite does it. how my reducers are structured is\n```\nimport { combineForms } from 'react-redux-form';\nconst initalState = {\n  to: '',\n  message: '',\n};\nexport const inviteManager = combineForms(initalState, 'shared.unclaimed');\n```\nwhich is imported into shared/unclaimed/reducers/index.js which does\n```\nimport { combineReducers } from 'redux';\nimport { schedulePreviews } from './schedulePreviews';\nimport { inviteManager } from './inviteManager';\nexport default combineReducers({\n  schedulePreviews,\n  inviteManager,\n});\n```\nyour example duplicates the inviteManger key twice becoming shared.unclaimed.inviteManager.inviteManager.to\nBtw thanks again so much for the time and help.\n. @davidkpiano so if i understand correctly i could get away without using combine forms at all? and just doing form(state.shared.unclaimed.inviteManager) in my component?\n. So when doing that i get an action fired of rff/null not an issue the issue is rff/setSubmitFailed and rff/setFieldsValidity dont actually update anything?\n. By trying to submit a validated form without entering anything\n. ",
    "reduxdj": "The answer was this, I didn't call this API method on the result, this is crucial after a fetch to pre-populate the form:\ndispatch(actions.setInitial(beautyAdvisor, obj.data))\n. ",
    "elisherer": "your suggestion solves the problem having the combineForms needing to be the root reducer, but forces a namespace for all the models, making the model names longer.\nI prefer to use the modelReducer and formReducer.\nI ended up creating a function of my own that given an array of models, creates a reducers dictionary (object) with {model} and {model}Form keys for each model which I then spread into my combineReducers function. it would have been nice to make all the forms under a mount point called 'forms' and let their names be the model names (without the form) but that, again, requires adding a parent model.\n. ",
    "dsomel21": "This solution isn't working for me. I looked at the Model Documentnation but it doesn't help with applying my own reducers.  \nI tried doing the following to merge my own reducers, my middleware and the forms, but \n`.\nexport default function configureStore(initialState) {\n   return createStore(\n      reducers,\n      initialState,\n          combineForms({\n              signupForm: initialSignupForm,\n              loginForm: initialLoginForm,\n         }),\n         applyMiddleware(thunk)\n    );\n}\nconst createStoreWithMiddleware = configureStore();\n`\nand my store is equivalent to Provider store={createStoreWithMiddleware}.\nIf I remove the combineForms({ }) function, my reducers for my components work but form won't and vice versa.\n. ",
    "yourfavorite": "I'm using 0.14.4. Is the beta available anywhere with documentation? I'm working on a personal project so production ready code isn't necessarily a must. \nedit - nvm found the branch. Going to give it a look. Thanks!\n. Looked through the docs and doesn't seem like there's much there yet. Is there an example of a dynamic form anywhere that I could poke through?\n. Being that I'm still learning react/redux I couldn't figure out how to get v1 beta working in my electron boilerplate. I did however work out this solution (which is working in my current build). Is this really a bad way to handle what I'm trying to do?\nIn my parent component that maps through each site to make forms, I pass down a sites prop that is used to build everything out. And then on componentWillMount I dispatch actions.change. This would of course not have hardcoded data in the end.\n``` javascript\nimport React, { Component, PropTypes } from 'react';\nimport { connect } from 'react-redux';\nimport { actions } from 'react-redux-form';\nimport SiteRow from './SiteRow';\nclass SiteList extends Component {\n  static propTypes = {\n    sites: PropTypes.array,\n    dispatch: PropTypes.func\n  };\ncomponentWillMount() {\n    this.props.dispatch(actions.change('sites',\n    [\n      {id: '1', name: 'site one'},\n      {id: '2', name: 'site two'},\n    ]));\n  }\nrenderSites(sites) {\n    return sites.map((site) => {\n      return (\n        \n      );\n    });\n  }\nrender() {\n    return (\n      \n        {(this.props.sites.length > 0) ? this.renderSites(this.props.sites) : 'Loading...' }\n      \n    );\n  }\n}\nfunction mapStateToProps(state) {\n  return {\n    sites: state.sites\n  };\n}\nexport default connect(mapStateToProps)(SiteList);\n```\n. Here's a very simple attempt at recreating what I do in my app, but its not quite the same and I'll have to think a little more on how to recreate it on code pen.\nhttps://codepen.io/anon/pen/WEKYoB?editors=0010\nI'm not sure which part is interesting to you. The clearIntents part or the focus part. I can't get the double clearIntents thing to happen but might be able to dig into it later if you can give me some idea of what exactly clearIntents is doing? The double focus part is firing but it looks like that might be normal?. @davidkpiano On the codepen I'm still getting change event calls on return. In my project I'm working on though, it seems to have fixed the first return, but any returns after that seem to still trigger the change event.. Haha. That would explain it. My bad. \ud83d\ude2c. Hi, I'm running into this bug currently using v1.16.8. My fields are set to update on blur and after calling reset on the model for the form, I have to click into a field to focus it, then blur it and then focus again before I can type anything. Was this bug fixed or do I need to do a modification locally?. Actually, I deleted my node_modules folder forced an npm cache clean and then reinstalled. Looks like I had something cached that was causing the issue. All good now. Thanks!. I don't think I've given enough info for this to be solvable at the moment and there's no proof that its the fault of RRF. Going to close this until I can provide more info. Sorry for the spam.. ",
    "dstudzinski": "It works:) thank you for your help.\n. ",
    "Sourabhd1164": "@davidkpiano \nHow to use onSubmit without a button, how to use something like onChange on the form ?\nThanks!. ",
    "EQuimper": "Remove only the last item each time. Not the one I want. \n. 0.14.5\n. @davidkpiano sorry I didn't get the notification. I got to work around I think that was bad code from my side and note your. The thing happen is when I delete that delete ok in the redux state but the view wasn't the same due to bad rerender\n. ",
    "yoyeung": "Sorry i cannot reproduce it in www.esnextb.in.\n. ",
    "samhains": "sorry, forgot to mention :\n\"react-redux-form\": \"^0.14.5\",\n\"redux\": \"^3.4.0\",\n\"react\": \"~15.2.0\",\n\"immutable\": \"^3.7.6\",\n\"react-dom\": \"~15.2.0\",\n\"react-native\": \"^0.29.0\",\n. ",
    "marcpeterson": "Version 0.14.5.  I'll write a short example.  If it's not enough I can try to make a complete set of files that exhibit it.\nSay I create my validators in the container, and pass them into the component.\nMyContainer.js\nlet validators = {\n  text1: {\n    notEmpty\n  }\n}\nThen I use those validators in the Form.\nMyComponent.js\n<Form model=\"user\"\n  validators={validators}>\nThen a user action triggers a new field to appear.  The container adds a validator for that new field.\nMyContainer.js\nlet validators = {\n  text1: {\n    notEmpty\n  },\n  text2: {\n    notEmpty\n  }\n}\nThat new set of validators gets to the component.  But it doesn't show up in the state tree until I type something into the text2 field.  It's almost like the new set of validators wasn't enough to trigger an update of the Form's validators in the state tree.\n. Indeed it was fixed!  Sorry, I should have searched first.  Much thanks, this is a great library!\n. Our teams share a common input component library, and we built a special layer that helps those input components work with v0.x.  So it's a matter of getting our custom components to work with the new version, then changing how we reference the newer state tree, and our custom validation layer would change too...  It's a bit more than we can do at the moment.\nBut I'd like to share things I've had troubles with that were very difficult to understand in v0.x.  It might be useful for you to know some pain points in case they exist in v1.x (and maybe could use some extra documentation).  Please don't take it as criticism, I really like this library :)\n- There is a tight relation between the model and form.  But it's not necessary for their initial state to match.  Adding things to the model via RRF's actions automatically adds things to the form's fields in the state tree.\n- Use modeled() to add RRF functionality to an existing reducer.  It was right there in the docs but we somehow missed this for months...\n- The naming of collection items in the model is different than in the form.  It's tricky understanding when to use which.  I believe x1.x has solved this.\n- A  can be added to your JSX without being defined in the model or form.  But it won't appear in the state tree until it's touched by the user.  Unless you give it a defaultValue, then it appears in the state tree immediately.\n. Thanks for the quick responses.  Hopefully we'll get to migrate to v1.x soon.... Ok using #553 as an example, I was able to use something like dispatch(actions.change('applicantsForm.applicants', [])) to clear all the items in that array of forms.\nBut I don't see any documentation on actions.batch() if I want to change multiple items.  Is that somewhere, or should I just dig into the source?. ",
    "shubhi-gupta": "@davidkpiano : Its working proper in the beta version. \nThough the scenario is reproducable in the example-> https://davidkpiano.github.io/react-redux-form/docs/recipes/quickstart.html\n. ",
    "max-mykhailenko": "@venelin-mihaylov I can't understand your solution, where you put navReducer?\n. Thanks! Now my form works correct. Only one thing now is looking not perfect: I should add deep. to every model attribute in every control.\nNow it looks:\nmodel={`forms.product.name.${langKey}`}\nCan you describe a reducer data structure? Why we need forms.forms.$form object?\n\n. Yes, I got it, thanks!. One more question \u2014 deep.forms.$form represent state (validation, pristine) of all forms in store? And deep.forms.product.$form represent state of product form only. It's right? \n. Unfortunately my english doesn't allow me to improve docs in PR. Thanks for clarification!\nPS. Your API is better than in redux-form ;D\n. I also have performance problems. My form has 1300 checkboxes and connect() time awful. Form render time is more than 20 seconds. Main delay is in ConnectedControl component. What you can recommend for me?\n. You can just create loop with 1300 iteration and render Control.checkbox in every iteration. Warning: browser tab will hang for 15-20 seconds.\n. ",
    "romseguy": "I think this should be added to https://davidkpiano.github.io/react-redux-form/docs/guides/quickstart.html since it's much more common to have other reducers than not.. Commit amended :wink: . ",
    "slashwhatever": "Ah yes. Sorry, that wasn't apparent from the docs.\nError is now gone. Use-case doesn't work but at least there's no errors now :)\n. Seems I'm getting this from 1.0.0\nI'll update to the beta channel and see what I get....\nEdit: Hmmmm. My webpack config says:\n\"react-redux-form\": \"^1.0.0-beta.12\",\nBut for some reason, our build script (which runs npm install at the start) ends up with this in the react-redux-form package.json:\n```\n  \"name\": \"react-redux-form\",\n  \"version\": \"1.0.0\",\n```\nWhich results in the error being: https://puu.sh/rofWB/93fceb30de.png\nAnd a scan of the source shows shallowEqual is in use in reducers/form/change-action-reducer.js\nimport shallowEqual from 'fbjs/lib/shallowEqual';\nSo I've manually uninstalled react-redux-form and reinstalled to get up to the beta12. While shallowEqual is still called from reducers/form/change-action-reducer.js, the file path is updated and seems to work ok now.\n. ",
    "glensomerville": "Thanks! I was getting a compile error in webpack from this, but perhaps my version was a bit stale already.\nRegarding the file naming, perhaps matching names with exports makes things easier to spot, but the convention may vary.\n. ",
    "vegansk": "@davidkpiano, this bug still exists when using npm install --save react-redux-form@beta \n. @davidkpiano, it's very strange. It worked after some time. CI builds of my project was broken, but now it's ok. Version in package.json is ^1.0.0-beta.12.\n. This is the component type factory:\n``` js\nimport React from 'react';\nimport * as M from 'react-mdl';\nconst mkTypedField = ({\n  type,\n  eq,\n  formatRe,\n  format,\n  parse,\n  errorMsg\n}) => {\nclass TypedField extends React.Component {\nconstructor(props) {\n  super(props);\n\n  this.state = this.updateState({}, props);\n}\n\ncomponentWillReceiveProps(props) {\n  this.setState((s, p) => this.updateState(s, p));\n}\n\nupdateState(state, props) {\n  return {\n    value: props.value || state.value,\n    textValue: (() => {\n      if(state.textValue && props.value) {\n        if(!eq(parse(state.textValue), props.value))\n          return format(props.value);\n      } else if(format(parse(state.textValue)) !== format(props.value)) {\n        return props.value ? format(props.value) : '';\n      }\n\n      return state.textValue || '';\n    })(),\n    error: props.error || state.error\n  };\n}\n\nhandleChangeEvent = (e) => {\n  const textValue = e.target.value;\n  const value = parse(textValue);\n  this.setState({\n    value,\n    textValue\n  });\n  if(value)\n    this.setState({ error: null });\n\n  if(this.props.onChange)\n    this.props.onChange(value);\n};\n\nhandleBlurEvent = (e) => {\n  this.setState({\n    error: formatRe.test(this.state.textValue) ? null : errorMsg\n  });\n};\n\nrender() {\n  return (\n    <M.Textfield\n      type={type}\n      {...{...this.props, error: this.state.error}}\n      value={this.state.textValue}\n      pattern={formatRe.source}\n      onChange={this.handleChangeEvent}\n      onBlur={this.handleBlurEvent}\n    />\n  );\n}\n\n};\nreturn TypedField;\n};\nexport default mkTypedField;\n```\nAnd this is how I use it to create the integer field. And I need to use number|string type everywhere because of babel-plugin-typecheck runtime checks. Because value is a string.\n``` js\n// @flow\nimport mkTypedField from './TypedField';\nimport * as F from 'react-redux-form';\nconst IntegerField = mkTypedField({\n  eq: (x: ?number|string, y: ?number|string) => {\n    if(typeof x === typeof(y))\n      return x === y;\n    return parseInt(x, 10) === parseInt(y, 10);\n  },\n  formatRe: /^-?\\d+$/,\n  format: (x: ?number|string) => x === null || x === undefined ? '' : '' + x,\n  parse: (x: ?string) => {\n    if(!x)\n      return null;\n    const r = parseInt(x, 10);\n    if(isNaN(r))\n      return null;\n    return r;\n  },\n  errorMsg: '\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0446\u0435\u043b\u043e\u0435 \u0447\u0438\u0441\u043b\u043e'\n}); \nexport type IntegerProps = {\n  className?: string,\n  model?: string,\n  label?: string,\n  floating?: boolean\n};\nexport const integer = (props: IntegerProps = {}): ReactElement => {\n  const { floating, label='', className, ...other } = props;\n  if(props.model)\n    return (\n      \n    );\n  else\n    return (\n      \n    );\n};\n```\n. ",
    "newtriks": "Okay, on further digging through previous issues it's led me to using combineForms...\n. Thanks for the quick response @davidkpiano, using the beta version those approaches work. Previous versions of your lib e.g. pre 1.0 the first example didn't seem to work oddly? Regardless, it's all good with the beta thanks!\n. @davidkpiano one final question sorry, which is the preferred approach and why?\n. ",
    "mbiernacik": "@davidkpiano I just checked and scroll issue still exists. So problem must be with something else than plugin I mention above.\n. ",
    "gehsekky": "@davidkpiano This is fantastic, thank you. Are dynamic forms are at all supported in the old 0.14.x branch or just in the beta?\n. ",
    "anaibol": "Thank you very much @davidkpiano! Good reference..\n. ",
    "Maxim-Chugaev": "I have same issue. And more, after reset model my form is valid with empty fields. \n. I have same issue, and i can give access to my repository.\n. I will try to do it in the near future. Now profiler showed this result. May will be helpful.\n\n. I think I made a stupid mistake, maybe it's not a problem of the library.\njavascript\nnew webpack.DefinePlugin({\n            'process.env.NODE_ENV': JSON.stringify('production')\n        })\ni added this code to my webpack config, and after this my app nice was working.\n. i reproduced the problem in this repository \nhttps://github.com/Maxim-Chugaev/react-redux-form_problem\n\n1) model changed in\njavascript\ncomponentDidMount () {\n        setTimeout(()=> {\n            this.props.dispatch(actions.change('user', MyState));\n        }, 1000);\n    }\n2) click button reset\n3) click button load\njavascript\n<button onClick={()=> this.props.dispatch(actions.change('user', MyState))}>\n   Load\n</button>\n. https://github.com/Maxim-Chugaev/react-redux-form_problem\nyep, last commit visualize problem.\nYou need open page, and click reset, then all UI be freezed.\n. I was wrong, this is my problem! sorry\n. I'm not sure this example work for me. I want reserve place for error message and change css property 'visibility' from hidden to visible.. I am need mapping only one attribute to props. But i am must creating new mapping for my control.\njsx\n<Control\n      component={MyTextInput}\n      mapProps={({fieldValue, onClick, onFocus, onBlur, onKeyPress})=>{\n         return {\n             valid: fieldValue.valid,\n             onClick,\n             onFocus,\n             onBlur,\n             onKeyPress,\n             ...etc\n        };\n     }}\n   />\nMaybe do i can merge exists mapping?\njsx\n  <Control.text\n      component={MyTextInput}\n      mapProps={({fieldValue})=>{\n         return {valid: fieldValue.valid};\n     }}\n   />. ",
    "VincentCordobes": "Yep, plus the errors field is the empty object.\n I guess it comes from reducers/form/reset-action-reducer updating the field with initialFieldState which contains the errors: {}. Maybe we should \"revalidate\" the form after being reset ?\n. ",
    "dmzkrsk": "Is it working?\nI have a form, which state is loaded via action.load, then I try to action.reset and my form is blank.\nThis commit refers only field reducer.\nI checked properties of my fields, modelValue is undefined, but fieldValue.initialValue is correct. (I'm still a bit of confused about modelValue vs fieldValue)\n. ",
    "jomasti": "Is this new change not optional?\n. Let's say I have a list of results after creating groups using the form. From that view, you can create a new group. It will take you to a blank form. You can hit cancel and go back to the list view. Also from the list, you are allowed to edit the saved group. You click edit, it will go to that same form and use actions.load to set the state for that saved form. When you hit cancel again to go back to the list, actions.reset is called. But now it isn't reset to the blank form like it previously was. So, I pretty much do want to go back to the initial initial state instead of the initial loaded one. I do see the benefit of that, though, so it makes sense for this to be optional.\n. Oh, okay. That makes sense. Thank you!\n. For me, children of an array field don't get the updated field state on submission failed. They validate correctly, and I can see that there is an error in the state for the subfield. I want to show the error if touched (or submitFailed), but since it never gets the updated state, the error isn't shown.\nI have a simplified structure like this:\n{\n  name: '',\n  description: '',\n  questions: [{\n    title: '',\n    text: '',\n    type: '',\n    options: [{...}],\n  }, {\n    ...\n  }]\n}\nAnd for the questions, I'm mapping over them in a function called in the main form:\nconst renderQuestions = ({ questions }, dispatch) => (\n  <ul>\n    {questions.map((question, index) => {\n      <li>\n        <Field model={`.questions[${index}].type`}>\n          <select>\n            {options}\n          </select>\n        </Field>\n        <Control.text\n          model={`.questions[${index}].title`}\n          placeholder=\"Title\"\n          type=\"text\"\n          validators= {{ required }}\n        />\n        <Errors\n          model={`.questions[${index}].title`}\n          messages={{\n            required: 'A title is required'\n          }}\n        />\n        ... (question object used in here)\n      </li>\n    })}\n  </ul>\n);\nAnything in the fields under questions doesn't get the updated state.\n. Oh, sorry. I'm on 1.0.12.\n. I can confirm that it works for my use case! Thanks!\n. ",
    "MioQuispe": "Also got this issue. Only have 11 fields in my form but it's unusable unless I set updateOn=\"blur\".\nThanks for your great work on this awesome library @davidkpiano !\n. @davidkpiano Not sure if I'm allowed to share the code but I could strip out the relevant parts and send it in a private message. I'm on a deadline atm so I'll do it some time in the near future...\n. @davidkpiano I sent you an email with some code.\n. ",
    "koyoyo": "Thanks very much.\n. ",
    "linguafranka": "@davidkpiano Sorry for adding noise to an old thread.\nI've a similar issue:\n\"react-redux-form\": \"^1.14.0\",\n```js\ncomponentDidMount() {\n  const entry = this.props.user;\n// initialize form\n  if (entry) {\n    this.props.dispatch(actions.change('userForm', {\n      firstName: entry.firstName,\n    }));\n  }\n}\njs\nvalidators={{\n  required: value && value.length > 0,\n}}\n``\nDispatching a change action in cDM doesn't seem to take into account validation.firstName` will get a value after the change action, but the model remains invalid and has errors.\n```js\ncomponentDidMount() {\n  const entry = this.props.user;\n// initialize form\n  if (entry) {\n    setTimeout(() => {\n      this.props.dispatch(actions.change('userForm', {\n        firstName: entry.firstName,\n      }));\n    }, 0)\n  }\n}\n```\nThe workaround is to wrap actions.change() in a setTimeout which resolves the issue. Is this a known issue?\nThanks!\n. @davidkpiano  I see what you mean. Thanks for the explanation. I wish there was a way to rerun validations defined in props after action.change. Especially useful when populating edit forms with initial data. For a large model, it'd get super verbose to do actions.validate with all the validators. Also is very error prone to define model validators in two separate locations.\nOn a different note, moving actions.change to componentWillUpdate seems to work without setTimeout.\nThanks again!. ",
    "cyberwombat": "Ok thank you for you answer. I wanted to make sure I wasn't missing some obvious way. \n. I tried using createForm with immutables but I get an error when I add the Error component:\nTypeError: Cannot read property '$form' of null\n    at mapStateToProps (/Server/node_modules/react-redux-form/lib/components/errors-component.js:246:50)\n    at Connect.configureFinalMapState (/Server/node_modules/react-redux/lib/components/connect.js:154:27)\n    at Connect.computeStateProps (/Server/node_modules/react-redux/lib/components/connect.js:141:23)\n    at Connect.updateStatePropsIfNeeded (/Server/node_modules/react-redux/lib/components/connect.js:203:35)\n    at Connect.render (/Server/node_modules/react-redux/lib/components/connect.js:338:40)\n    at /Server/node_modules/react/lib/ReactCompositeComponent.js:793:21\n    at measureLifeCyclePerf (/Server/node_modules/react/lib/ReactCompositeComponent.js:74:12)\n    at ReactCompositeComponentWrapper._renderValidatedComponentWithoutOwnerOrContext (/Server/node_modules/react/lib/ReactCompositeComponent.js:792:27)\n    at ReactCompositeComponentWrapper._renderValidatedComponent (/Server/node_modules/react/lib/ReactCompositeComponent.js:819:34)\n    at ReactCompositeComponentWrapper.performInitialMount (/Server/node_modules/react/lib/ReactCompositeComponent.js:361:30)\nForm:\n```\nimport React, { Component } from 'react'\nimport { Control, Form, Errors, actions } from 'react-redux-form'\nimport { connect } from 'react-redux'\nimport axios from 'axios'\nconst isRequired = (val) => val && val.length > 0\nclass SubscriptionForm extends Component {\nconstructor (props) {\n    super(props)\n    this.handleSubmit = this.handleSubmit.bind(this)\n  }\n  handleSubmit (data) {\n    const { dispatch, sourceRequest } = this.props\nconst { protocol, host } = sourceRequest\nconst somePromise = axios.post(`${protocol}://${host}/api/v0/newsletter/subscribe`, data)\n\ndispatch(actions.submit('subscriber', somePromise))\n\n}\nrender () {\n    const { form } = this.props\n    let submitted = form.$form.submitted\n    return (\n      \n    <Control.text model='subscriber.email' validators={{ isRequired }} />\n    <Errors\n      wrapper='span'\n      show={{ touched: true, focus: false }}\n      model='subscriber.email'\n      messages={{ isRequired: 'Please provide a valid email.' }} />\n\n    <button type='submit'>\n      Finish registration!\n    </button>\n  </Form>\n\n)\n\n}\n}\nconst mapStateToProps = (state) => {\n  return {\n    sourceRequest: state.sourceRequest,\n    form: state.get('forms').subscriber\n}\n}\nexport default connect(mapStateToProps)(SubscriptionForm)\n```\nI am not sure I am properly accessing the form in my mapStateToProps. I sometimes get a form.$form is undefined in render (yet I can console log it which I am not clear why).\nReducers:\nexport default function createReducer (asyncReducers) {\n   return combineReducers({\n     sourceRequest,\n     ...asyncReducers,\n     ...createForms({\n       subscriber: { email: 'foo@bar.com'}\n     })\n   })\n. Also getting errors when I add the validators={{ isRequired }}\nundefined is not an object (evaluating 'state.$form.model')\nNot sure if it's me not setting the form correctly or if it's part of this bug as well.\n. I am still getting errors on 1.0.11 using Immutables. This happens if I use a validator in Field or an Error component. I have imported from react-redux-form/lib/immutable in all cases. Not sure what I am missing?\nError:\nTypeError: undefined is not an object (evaluating 'form.$form.model') \u2014 get-field-from-state.js:39 (index.js, line 20290)\nTypeError: null is not an object (evaluating 'internalInstanceKey')  getClosestInstanceFromNode (i ndex.js:1155)\nForm:\n```\nimport React, { Component } from 'react'\nimport { Field, Control, Form, Errors, actions } from 'react-redux-form/lib/immutable'\nconst isRequired = (val) => val && val.length > 0\nclass SubscribeForm extends Component {\nrender () {\n    return (\n      \n\n Email address: \n\n\n\n\n          Finish registration!\n        \n\n)\n\n}\n}\n```\nNote that I have tried forms.subscribe.email as well as subscribe.email and other variation as well.\nReducer:\n```\nimport { combineForms, createForms } from 'react-redux-form/lib/immutable'\nexport default function createReducer (asyncReducers) {\n   return combineReducers({\n     sourceRequest,\n     ...asyncReducers,\n     ...createForms({\n       subscribe: { email: 'foo@bar.com'},\n       unsubscriber: {}\n     })\n   })\n  }\n```\n. I tried that. I tried the examples with same result. If I add 'forms.subscribe' to model then the error is\n[Log] TypeError: undefined is not an object (evaluating 'state.$form.model') \u2014 update-field.js:49 (index.js, line 20290)\nwhich is the same that the example gives.\n. @erin-doyle Sorry that was a bit of a typo from my part. as David indicated createforms creates a deep object under forms I have tried that. So forms.subscribe.email. However that doesn't prepopulate the form so it appears that subscribe.email is it. However I cannot use either a validator or the Error component without errors.\n. So this \"may\" be fixed. I gave up on immutables with forms so took that off but still had errors when using createForm (mostly a stack overflow issue). I upgraded from .11 to .12 and that took care of it. So... My forms now work w/o immutables - I can't say if the issue I had is still there - I assume it was part of the same issue.\n. Perfect thank you. \n. Oops my bad. Had changed it to myfom for a sample for this but then I saw that I had essentially the same issue on mine (subscribe vs subscriber). Thank you.\n. There is but just one field.  This may be an issue with my promise. I use axios redux middleware and dispatch that. It returns a promise which I pass to the submit action to dispatch. It submits the form but perhaps only once. If I do a straight axios call it seems to work so gonna look into that further. Closing for now - sorry about that. \n. I see. It's because my promise, on success, returns a data object (axios request data) as opposed to true. \nSo I have:\nconst postUser = api.post({/* user data */})\ndispatch(actions.submit('user', postUser));\nInstead of: \n```\nconst postUser = api.post({/ user data /})\n  // API success\n  .then(() => true) // validity = true\n  // API failure\n  .catch((err) => err) // errors = err\ndispatch(actions.submit('user', postUser));\n```\nSo it makes a successful submit and marks form submitted as true, but only once. What is the reasoning behind requiring a boolean true as opposed to a successful resolve?\n. I was pondering this yesterday and I can see that it makes it easier (as things are now) to handle things like failed authentication where a successful resolve should be handled differently based on whether it was correct. So it's not a form error but an invalid one. If the boolean check gets removed how would this scenario take place?\nformCheck()\n   .then(res => res.isValidLogin)\n  .catch((err) => err)\n. I'm toggling children component (a bunch of inputs) based on the value of a radio. I have a reducer working now - I will make it the actionTypes though.  I was hoping to dispatch an action that causes a from rerender in the same way that say changing pristine state does. I can access the radio value from props.form.value.radio so it seemed a bit silly to create another prop but I don;t know how to force the rerender. Thanks\n. That doesn't really work well. You cant use any of the form states in render since they don't exist without checking to see if form is a valid object\n{ form && !form.valid && form.submitFailed ? ...\n\nIt needs to be something like:\n this.state = { form: { valid: false, submitted: false... }\n\nBut that's not very practical.\n. I realize that that doesn't work either. The object such as validation gets modified during input.. Additionally there seems to be a difference in the form states. Here's my original form:\n```jsx\n render () {\n    const { valid, submitted, submitFailed } = this.props.form\n    return (\n  <Form model='subscribe' onSubmit={(values) => this.handleSubmit(values)}>\n    <Control.text model='.email' type='text' placeholder='Put your email address here' validators={{ isEmail }} />\n\n    { !valid && submitFailed ? <Alert>\n      <Errors\n        model='.email'\n        messages={{ isEmail: 'Please provide a valid email.' }}\n      />\n\n    </Alert> : submitted ? <Alert type='success'>Good job!</Alert> : null }\n\n    <button type='submit'>\n      { submitted ? 'All done!' : 'Finish registration!' }\n    </button>\n  </Form>\n)\n\n}\n```\nThe validation works well. It only shows an error on invalid email once the user submits.\nWith LocalForms - where essentially all I did was change props to state:\n```jsx\nrender () {\n    const { form } = this.state\n    return (\n       this.handleUpdate(form)}\n        onChange={(values) => this.handleChange(values)}\n        onSubmit={(values) => this.handleSubmit(values)}\n      >\n    <Control.text model='.email' type='text' placeholder='Put your email address here' validators={{ isEmail }} />\n\n    { form && !form.valid && form.submitFailed ? <Alert>\n      <Errors\n        model='.email'\n        messages={{ isEmail: 'Please provide a valid email.' }}\n      />\n\n    </Alert> : form && form.submitted ? <Alert type='success'>Good job!</Alert> : null }\n\n    <button type='submit'>\n      { form && form.submitted ? 'All done!' : 'Finish registration!' }\n    </button>\n  </LocalForm>\n)\n\n}\n``\nThe validation doesn't work as expected. It seems thatsubmitFaileddoesn't trigger the same way. It's like it never gets updated on a submit attempt. What could I be doing wrong?. I'm not clear on how to do so. Do you mean something like dispatch(actions.setErrors('subscribe', { 'foo': 'bar'}))`? I played around with that without success.. OK I got it. Posting here for others.\nMy onSubmit should reject a promise:\njsx\nexport const subscribeUser = (data) => {\n  return new Promise((resolve, reject) => {\n    reject({\n      foo: 'Wrong password'\n    })\n  }) \n}\nThen in my form (given a form named 'subscribe'):\njsx\n <Errors model='subscribe' />\nThis will print: \nhtml\n<div><span>Wrong password</span></div>\nI can override the errors as in:\njsx\n <Errors model='subscribe' messages={{foo: 'Whatevs'}} />\nWhich gives:\nhtml\n<div><span>Whatevs</span></div>\n. I've noticed that I must return a promise. Somehow it doesn't get any error message if an error is thrown.  See https://stackoverflow.com/questions/44989109/rejecting-react-redux-form-with-async-throw-instead-of-promise/44989164#44989164. Thanks David that helps. Perhaps a mention in the docs (if not already there - I may have missed it) would be useful.  It seems logical now that I think about it but I didn't think of it when I initially attempted my conversion.. ",
    "amyiee": "Hi,\nGot a question regarding to this,\nWell i keep on getting this error whenever i implemented this code to my code base\nUncaught (in promise) Error: Actions must be plain objects. Use custom middleware for async actions.\nJust wondering if you know any middleware, etc to remedied the issue.\nThanks\n\n. @davidkpiano Got it working, Thanks! \ud83d\udc4d . ",
    "KevinBrolly": "@davidkpiano 1.0.9 does indeed fix the main issue, the show function now has access to the correct form.\nI noticed that other fields as I mentioned, such as 'forms.signup.username' still do not have form values such as \"submitFailed\" correctly set (which is why I had to access the form in the show function in the first place.  How can I get the fields to contain the correct value for \"submitFailed\"?\n. ",
    "BrianDGLS": "I'll pick this up.\n. @davidkpiano I have added an updated .d.ts file as part of #456 . \nI used the Microsoft gen-dts tool to generate it.\nBefore closing this ticket could you add the hacktoberfest label please?\n. @davidkpiano Updated to master.\n. ",
    "tiagoefmoraes": "@BrianDGLS Are you still working on the typings? \nThe new one doesn't export anything and declares a namespace that the old one didn't.\n. @davidkpiano Thanks, it's working great!!!\n. I found another workaround:\n``` javascript\n<Form model=\"user\"\n  validators={{\n    'phones.0.number': { required }\n  }}\n\n```\n\nA more automated aproch:\njavascript\n  render() {\n    const required = (val) => !!val;\n    const { phones } = this.props.user;\n    const phoneNumbersValidators = phones.reduce(\n      (validators, _, index) => {\n        validators[`phones.${index}.number`] = { required };\n        return validators;\n      }, {});\n    return (\n      <Form model=\"user\"\n        validators={phoneNumbersValidators)}\n      >\n'phones[].number': { required } would be much better.\nThanks\n. @davidkpiano Thanks, working 'almost' perfect, when the form is submited it becomes invalid, added some tests on this branch: https://github.com/tiagoefmoraes/react-redux-form/tree/deep_validation_submit\nI fixed, will open a PR soon\n. I have the same problem and found that it validates the same quantity of items in the store's initial state \nIn the provided sample doing the following \"works\", but if we load DATA2 it breaks and doesn't validate  the second item.\n``` javascript\nconst DATA = {\n  username: 'loaded',\n  items: [{name: 'item 1', subitems: [{name: 'subitem 1'}, {name: 'subitem 2'}]}],\n};\nconst store = createStore(combineForms({\n  user: DATA,\n}), applyMiddleware(thunk, createLogger()));\nconst DATA2 = {\n  username: 'loaded',\n  items: [{name: 'item 1', subitems: [{name: 'subitem 1.1'}, {name: 'subitem 1.2'}]},\n              {name: 'item 2', subitems: [{name: 'subitem 2.1'}, {name: 'subitem 2.2'}]}],\n};\n```\n. Managed to fix this, @davidkpiano can you look and say if this is the right way to solve this?\n. @davidkpiano Will rebase and create PR tomorrow\n. @davidkpiano done!\n. As Field and Control pass the properties down it makes sense for them to extend HTMLProps.\nCreated #557 to solve this.. ",
    "noah79": "Agree - the .d.ts with this project isn't usable.\n. ",
    "zach-waggoner": "Interesting; it works when I enclose the forms in a div, although this is not the problem I have. Closing for now.\n. Found the culprit. The problem appears when there are validators in the forms, and the forms are deeply nested with combineForms. Check out the gist posted above.\n. Looks like the form that doesn't submit is whichever is attempted first. When > 2 forms exist, only the last one that is attempted will submit.\n. Not sure why a test failed. Probably the interfaces are wrong, but they erroneously passed before because the module wasn't exported. I recommend reverting to the old declaration file until the new interfaces can be added.\n. I just saw that the tests were broken by e09e0d3ba85a5e2c84aee446be018893db7a92b8. Adding the new file again...\n. I just verified that the new declaration file has incomplete/incorrect interfaces. I am going to close this for now. I am going use the old file and write in interfaces as necessary, and then I'll open a new PR, unless someone fixes this first.\n. @davidkpiano merged.\n. @davidkpiano I don't think I understand. I am appending the URL to the form data and resubmitting it. The problem is that the resubmission doesn't work. I have verified that it does work in a normal HTML form onSubmit handler \u2014\u00a0see https://codepen.io/anon/pen/JJgaNb. If you click submit, you will see preprocessing... logged in the console, followed by the form disappearing and a couple of console errors, indicating the form was submitted to the phony action I added to it. In the code example in my original comment (which I have updated to use a promise for the sake of clarity), clicking on submit causes preprocessing... to be logged in the console, but the form is never actually submitted, even though the submit handler is called again.. I may not have been clear, but the final submission should not be asynchronous.. ",
    "ramiel": "In react you can simply assign a value to the select element and this will set the according option, as explained here. Will this way work also on RRF?\n. Yes but looks like <Control.select model=\".name\" value=\"defaultName\">...</Control.select> doesn't work the same way. Am I doing something wrong? I'll try to put an example somewhere to see if it is reproducible.\n. So, should this work?\nJS\n<Control.select model=\".name\" defaultValue=\"defaultName\">...</Control.select>\n. Ok, thank you, I'll try\n. If I set the defaultValue, the option is choosed but not set in the modelValue. Is an expected behavior?\n. Of course\n. You're right. This is the store:\njs\nconst reducers = combineReducers({\n    ...createForms({\n        options: [],\n    }),\n    auth,\n    routing: routerReducer\n})\nconst store = createStore(reducers, {}, middlewares); // with thunk in middlewares\nThen, the component looks like this (only the relevant parts)\njsx\n{ \nthis.props.payment_options.map((option, index) =>\n  <Control.checkbox\n  key={index} \n   model={track(`options[].enabled`, {id:   option.id}), 'enabled')}\n   changeAction={(model, value) => dispatch => {\n   // async code....\n   dispatch(actions.toggle(model))\n}}\n/>\n)\n}\nand the array of options, once fetched contais object like\njs\n{\nid: 1,\nname: '...'\n}\n. Sorry, I cutted the code to simplify it. Is\njs\nmodel={track(`options[].enabled`, {id:   option.id})}\nand\njs\n{\nid: 1,\nname: '...',\nenabled: true/false\n}\nYes, it is working. Enabled is not undefined but actually it works even if it is undedfined\n. Three more hints:\n- Setting a default value for any property in the user model changes nothing\n- if I do reset('model.leaf.property'), it works and no change is fired.\n- change('user', {}) is a workaround.\nBtw, I think I'm misunderstanding something.... ",
    "geekyme": "I did that but the model in user.photo is still {}.\n. I did this in my component: \nthis.camera.capture()\n      .then(data => {\n        const fileName = `${Date.now()}.jpg`;\n        const fileData = { uri: data.path, name: fileName, type: 'multipart/form-data' };\n        actions.push('forms.createListing.photos', fileData);\n      })\n      .catch(err => console.error(err));\nAnd this is my reducer: \nexport default combineReducers({\n  routes,\n  me,\n  forms: combineForms({\n    createListing: {\n      name: '',\n      desc: '',\n      price_day: null,\n      photos: [],\n    },\n  }, 'forms'),\n});\nBut I realized that forms.createListing.photos is still []\n. Thank you it works!\nOn 13 Oct 2016, at 1:11 AM, David Khourshid notifications@github.com<mailto:notifications@github.com> wrote:\nYou have to dispatch the actions.push() action:\nthis.camera.capture()\n      .then(data => {\n        const fileName = ${Date.now()}.jpg;\n        const fileData = { uri: data.path, name: fileName, type: 'multipart/form-data' };\n-       actions.push('forms.createListing.photos', fileData);\n-       dispatch(actions.push('forms.createListing.photos', fileData));\n    })\n    .catch(err => console.error(err));\n\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHubhttps://github.com/davidkpiano/react-redux-form/issues/459#issuecomment-253276351, or mute the threadhttps://github.com/notifications/unsubscribe-auth/AA7qNC4TNHUnnioajmChw9tQkCfIbiCrks5qzRSqgaJpZM4KSwU0.\n. ",
    "nasushkov": "Thank you for your answer, David.  Well, yes, we can do this by combining both libraries, of course, and that's the easiest solution, but for me it's a little bit inconvenient, since redux-thunk and redux-saga serve the same purpose and I prefer redux-saga for several reasons. So, in this case I had to use both libraries just because of react-redux-form. I can reformulate my question: can we use redux-saga instead of redux-thunk with react-redux-form? For instance, I see that thunks are used in several actions based on submit action, so would it be enough to rewrite these actions as sagas to make it work without redux-thunk?\n. ",
    "dmitrif": "@erin-doyle \nWorking on PR now, but hoping you could chime in.\nSeemingly while using redux-immutable / redux-immutablejs, the code contained in form-reducer / form-action-reducer, update-field, all do not use anything but the default get which fails. Did you have a chance to look into that prior?\nThanks! . Also tried using createForms instead, still failing but with a different error:\nget-field-from-state.js:39 Uncaught TypeError: Cannot read property 'model' of undefined(\u2026)\n. Thanks, David!\nI see the tag for 1.1.0 but when trying to install from NPM it's saying that version doesn't exist.\n. I think this particular issue is fixed. but I think I realized why this doesn't work for us, is this library compat with redux-immutablejs?\nCheers.\n. Thank you!\nIt ends up tripping up on lines such as:\nLine 19 in get-field-from-state.js\nconst formPath = toPath(form.$form.model);\nSince I believe form itself is an immutable object in this case. Along with some other spots.\n. @davidkpiano Thanks :) Working on it!\n. Will resubmit after fixing conflict.. Not sure how to get around lodash.toPath imports failing, any ideas?. I updated the dependencies to explicitly rely on the lodash submodules that are in use, but the unit-tests are still failing on Travis due to the devDependency lodash failing to load. . @davidkpiano Sorry, any ideas? I want to make sure that this PR doesn't diverge too far from master, since it's a pain to get them back into sync (from my past experience).. That's fair. The conversions happen due to the time constraint as I am unable to commit much more time to it \u2014 The logic that relies on toJS would have to be rewritten to accommodate both the immutable / regular branching. \nUnsure how to proceed. . I feel like in some places the calls are justified, in order to reduce the complexity of forking code into branches along the way to support both immutable and icepick. We can always identify the spots we feel are inappropriate for toJS and I can refactor accordingly.\nI do feel it's best to move forward quickly (let me know if you agree), otherwise this PR will fall out of sync fairly quickly with the new updates and will be fairly useless.\nWould love to continue this discussion to ensure that this PR does not get lost. Thank you!. Hi, David. I just attempted a merge, and the problem that I foresaw with letting this pull stagnate is already exhibiting itself. There has been a number of changes to a variety of submodules resulting in a series of conflicts \u2014 without having an intimate knowledge of the library it will be tough for me to determine how to resolve these conflicts, primarily relying on the unit testing to tell me whether I am doing so correctly.\nIs there any chance you could complete the merge of master? . Appreciate it. Thank you in advance :) . Did you get a chance to look at this?. So the main issue with the Immutable compatibility in this, is if the redux state is an immutable object, the traversal / selecting substates becomes problematic as the react-redux-form is also stored in the store. \nThe easiest way would possibly be creating a separate store for React-redux-form?. ",
    "cesarp": "I am having a similar issue, if I add mapProps then my custom component never dispatches a change.\nWithout mapPros I see in dev tools:\n1. focus\n2. change\n3. setFieldsValidity\nWith mapProps nothing is dispatched.\n. 1.0.12 too\n. I am still having the same issue\n. It was a little bit more complex than this but even after reducing it to this it fails, not sure if I am doing something wrong but without the mapProps it works although I want to get the errors, touch, and a few other props to style the component a bit different.\n``` javascript\n(props)  => {\nconst {\n    label,\n    type,\n    required,\n    touched,\n    ...otherProps\n  } = props;\nreturn (\n    \n\n\n{touched}\n\n\n  )\n}\n```\n. ",
    "rainerborene": "Thanks!\n. ",
    "tomzilla": "Same. React 15.3.2\n. ",
    "AaronLaBrie": "Whoo! Thanks for the swift turnaround!\n. ",
    "mathieuseguin": "sure :)\n. I'm having the same issue where I have two controls (both invalid on page load) and I need to enable the second control only once the first control becomes valid.\nI like the proposal and I believe it would work great for my use case too!. In the meantime I've put this hack together where I'm passing the whole state to my component then get the model from the Fieldset (because in my case I don't know the model in advance), so that I can get the value of the first field and do the comparison\n```\nimport React, { Component } from 'react'\nimport PropTypes from 'prop-types'\nimport { connect } from 'react-redux'\nimport { Fieldset, Control } from 'react-redux-form'\nimport _get from 'lodash.get'\nclass MyComponent extends Component {\n  render () {\n    return (\n       {\n          if (!this.model) {\n            this.model = fieldset.model\n            this.forceUpdate()\n          }\n        }}\n      >\n        \n    <Control.text\n      model=\".value2\"\n      disabled={() => {\n        if (!this.model) return\n        const { my_nested_obj } = _get(this.props.state, this.model)\n        return my_nested_obj.value1.length == 0\n      }}\n    />\n  </Fieldset>\n)\n\n}\n}\nMyComponent.propTypes = {\n  'state': PropTypes.object.isRequired\n}\nconst mapStateToProps = (state, ownProps) => {\n  return {\n    'state': state\n  }\n}\nexport default connect(mapStateToProps)(MyComponent)\n```. I was able to get a slightly better implementation using context:\n```jsx\nimport React, { Component } from 'react'\nimport PropTypes from 'prop-types'\nimport { connect } from 'react-redux'\nimport { Fieldset, Control } from 'react-redux-form'\nimport _get from 'lodash.get'\nclass MyComponent extends Component {\n  render () {\n    return (\n      \n\n    <Control.text\n      model=\".value2\"\n      disabled={() => {\n        const { my_nested_obj } = _get(this.props.state, this.model)\n        return my_nested_obj.value1.length == 0\n      }}\n    />\n  </Fieldset>\n)\n\n}\n}\nMyComponent.contextTypes = {\n  'model': PropTypes.any,\n}\nMyComponent.propTypes = {\n  'state': PropTypes.object.isRequired\n}\nconst mapStateToProps = (state, ownProps) => {\n  return {\n    'state': state\n  }\n}\nexport default connect(mapStateToProps)(MyComponent)\n```\nBut it would be even better if the resolveModel wrapper was exposed, as requested here: https://github.com/davidkpiano/react-redux-form/issues/751\n. yes, I need to transform the value based on the value (not implemented in my example here as this is not related to the issue). ",
    "antmdvs": "I had a feeling you were going to do that :) I still think the general philosophy you had in the summary of that wiki page as well as the Main Differences bullet points would be helpful to carry over.\n. ",
    "zachall": "I'm also getting the same error as @cyberwombat:\nwarning.js:36 Warning: Unknown prop 'getFieldFromState' on <div> tag. Remove this prop from the element. For details, see https://fb.me/react-unknown-prop\nSwitching to Controls works, but using Control.Select doesn't work for me for some reason.\nAlso, the same error occurs in the Validation Example at https://github.com/davidkpiano/react-redux-form/tree/master/examples/validation\n. ",
    "DanielLuu": "Thanks for the fast answer!\n. Is the {...} literal?  This throws an error for me\n. Somehow the binding of the data is lost when using the custom component.  The radio buttons aren't mapped back to the model.\nEdit: Everything works if I embed the loop directly inside the Field.  But yes through the component it does not work.\n. Actually I ended up moving the whole Field into the custom component and that ended up working.\n. ```import { createFieldClass, controls } from 'react-redux-form';\nimport TextField from 'material-ui/lib/text-field';\nconst MaterialField = createFieldClass({\n  'TextField': controls.text\n}, {\n  componentMap: {\n    TextField: TextField\n  }\n});\n// render():\n\n\n```. Ok awesome I was looking at the outdated docs.  Thanks for the updated link.. Quick question how would I go about doing the select?. No... not exactly working here's my code\ninput = <Control.select\n                    model={template.key + '.' + question.key}\n                    component={DropDownMenu}\n                    value={this.state.value}\n                    onChange={this.handleChange}\n                  >\n                    <MenuItem value={1} primaryText=\"Never\" />\n                  </Control.select>. https://esnextb.in/?gist=ee823998a00333398edb3faaf77df951. Yeah sorry the esnextb isn't working but basically is there a way to get/set the value the control handles?. Basically I want to make a custom onchange for control since Material UI handles that differently . Actually I got it to work by making a custom component wrapper that dispatches the actions on change and grabs the values from the state.. value is grabbed like so\nthis.props['model_name'][question]\nthe question obj is just data passed to the component\n```jsx\nimport SelectField from 'material-ui/SelectField';\nimport MenuItem from 'material-ui/MenuItem';\nexport class CustomSelect extends React.Component {\n  render() {\n    const { model, dispatch, question, value } = this.props;\n    return (\n       {\n          dispatch(actions.change(model, value));\n        }}\n        floatingLabelText={question.label}\n        className={question.class}\n        fullWidth={true}\n      >\n        {\n          question.options.map((option, index) => {\n            return \n          })\n        }\n      \n    );\n  }\n}\n```. Having this issue as well. ",
    "iBasit": "+1 \u2014\u00a0Does not work for me either on localForm. I can share my code with you, which is following:\n{row.status === 'open' ? <td style={{width: 70}}><LocalForm className=\"form-group\">\n            <Control.select defaultValue={row.orderType} model=\".orderType\" updateOn=\"change\" changeAction={(model, value) => (value !== row.orderType) ? update(row._id, {orderType: value}) : ''} className=\"form-control form-control-sm\">\n            <option value=\"\">Default Limit + Thrust + Inr</option>\n            <option value=\"TAKE_PROFIT_LIMIT\">TPS Take Profit STOP (Thrust + Inr)</option>\n            <option value=\"STOP_LOSS_LIMIT\">TLS Take Loss STOP (Thrust + Inr)</option>\n            <option value=\"TAKE_PROFIT\">TP Take Profit on Limit (Thrust ignored)</option>\n            <option value=\"STOP_LOSS\">TL Take Loss on Limit (Thrust ignored)</option>\n            <option value=\"LIMIT\">Limit (exact price) (Thrust ignored)</option>\n        </Control.select></LocalForm></td> : <td></td>}\nbefore this code, I have other sibling localForms, which I just use the value with placeholder, since defaultValue was not working, but for drop down I can't do that.\nother siblings \n```\n{row.status === 'open' ?  (value && value !== row.limit) ? update(row._id, {limit: parseFloat(value)}) : ''} placeholder={row.limit} className=\"form-control form-control-sm\" /> : }\n        {row.status === 'open' ?  (value && value !== row.thrust) ? update(row._id, {thrust: parseFloat(value)}) : ''} placeholder={row.thrust} className=\"form-control form-control-sm\" /> : }\n        {row.status === 'open' ?  (value && value !== row.incrementBy) ? update(row._id, {incrementBy: parseFloat(value)}) : ''} placeholder={row.incrementBy} className=\"form-control form-control-sm\" /> : }\n``` \n\"dependencies\": {\n    \"react\": \"^16.2.0\",\n    \"react-dom\": \"^16.2.0\",\n    \"react-redux\": \"^5.0.6\",\n    \"react-redux-form\": \"^1.16.3\",\n    \"react-router\": \"^4.2.0\",\n    \"react-router-dom\": \"^4.2.2\",\n    \"react-router-redux\": \"next\",\n    \"redux\": \"^3.7.2\",\n    \"redux-socket.io\": \"^1.4.0\",\n    \"redux-thunk\": \"^2.2.0\",\n    \"sanitize.css\": \"^5.0.0\",\n    \"socket.io-client\": \"^2.0.4\",\n  },\nbtw I'm creating many forms, just to update each row value, since I can't put localForm on <tr> tag.  . do you know when can we expect a fix for this? This is very important for our project or any project. . is this still pending?. sorry off the topic, but is there a method for onChangeSubmit?  (I'm looking for it lol). I have merge issue also, new values does not get merged at all. \nI have even tried .change(..) method on componentDidMount\nI have version 1.16.2. I been trying to do this, but does not work :(. +1. Do you have any CodePen actions.merge or action.contact examples, maybe I can see the demo and see if I'm doing anything wrong.. ",
    "robinspark": "I ended up moving the inner form inside a  component after the form, so I can easily validate and submit. \n. ```\nimport {combineForms} from 'react-redux-form';\nimport moment from 'moment';\nimport {DEFAULT_TIME_FORMAT} from 'shared/constants/datetime-formats';\nexport const initialJobFormState = {\n  clientId: '',\n  jobStartTime: moment().format(DEFAULT_TIME_FORMAT),\n  equipment: []\n};\nexport default combineForms(\n  {\n    job: initialJobFormState,\n  },\n  'reactReduxForm'\n);\n\n//root reducer:\nexport default combineReducers({\n  //other reducers...\n  reactReduxForm\n});\n\nimport {createStore, applyMiddleware, compose} from 'redux';\nimport thunk from 'redux-thunk';\nimport createLogger from 'redux-logger';\nimport redirectMiddleware from 'shared/utils/middlewares/redirect-middleware';\nimport unauthorizeMiddleware from 'shared/utils/middlewares/unauthorize-middleware';\nimport rootReducer from './reducers';\nconst middlewares = [thunk, unauthorizeMiddleware, redirectMiddleware];\nif (typeof window !== 'undefined') {\n  middlewares.push(createLogger());\n}\nconst toCompose = [\n  applyMiddleware(...middlewares)\n];\nif (DEV && typeof window !== 'undefined' && window.devToolsExtension) {\n  toCompose.push(window.devToolsExtension());\n}\nexport default (initialState = {}) => createStore(\n  rootReducer,\n  initialState,\n  compose(...toCompose)\n);\n```\n. I got it to work.\nThe rrf documentation needs to updated, as it specifies \"novalidate\", whereas React requires it to be in camel case. ie. \"noValidate\" with a capital 'V'. \n. cheers : )\nOn Mon, Oct 31, 2016 at 3:06 PM, David Khourshid notifications@github.com\nwrote:\n\nFixed in the docs!\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/davidkpiano/react-redux-form/issues/505#issuecomment-257210145,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AU-j33OF6pTAENb-aXVUZN_krJgp74Koks5q5WlfgaJpZM4KkVEo\n.\n. Why would this error be thrown when resetting an existing form? Shouldn't the reset function check to see if myField exists before calling myField.$form   ?. I tried debugging reset-action-reducer.js\n```\n      var resetFieldState = function resetFieldState(field) {\n        console.log('-------- resetFieldState --------- field:', field);\n        ...\n      }\n\n```\nFor the first reset() which succeeds, the last 4 field values are as follows:\n```\n  field: $form: Object\n  field: {\n    model: \"reactReduxForm.myForm.address\n    ...\n  }\n  field: $form: Object\n  field: {\n    errors: Object\n    focus: false\n    initialValue: Array[0]\n    length: 0\n    proto: Array[0]\n    intents: Array[0]\n    model: \"reactReduxForm.myForm.crew\"\n    pending: false\n    pristine: true\n    retouched: false\n    submitFailed: false\n    submitted: false\n    touched: false\n    valid: true\n    validated: false\n    validating: false\n    validity: Object\n    value: Array[0]\n  }\nFor the second reset() which fails, the last 4 field values are as follows:\n  field: {\n    0: Object\n    $form: Object\n    validated: Object\n    value: null\n  }\n  field: {\n      errors: Object\n      focus: false\n      initialValue: 3\n      intents: Array[0]\n      model: \"crew.1.jobs.0\"\n      pending: false\n      pristine: false\n      retouched: false\n      submitFailed: false\n      submitted: false\n      touched: false\n      valid: true\n      validated: false\n      validating: false\n      validity: Object\n      value: 3\n    }\n  field: {pristine: false}\n  field: null   // this causes the error.\n```. BTW, the model: \"crew.1.jobs.0\" is invalid. Not sure why it gets set to that.. I fixed the issue by calling the following just before reset():\nactions.change('reactReduxForm.myForm.crew', []);. Yes, myForm.crew exists upon initialization. It contains the exact same value just before I call:\nactions.reset('reactReduxForm.myForm');\nWorks the first time. But, not everytime. Sometimes it doesn't fail on the 1st or second call, but after the nth call.\nDebugging: last 3 rrf actions before the error, and value of crew:\n```\nindex.js:152  action @ rrf/reset \nindex.js:152  action @ rrf/setErrors \nindex.js:152  action @ rrf/batch \nindex.js:152  action @ rrf/change \nindex.js:152  action @ rrf/setValidity \nindex.js:152  action @ rrf/setSubmitFailed \nindex.js:152  action @ rrf/setFieldsValidity \nindex.js:152  action @ rrf/focus \nindex.js:152  action @ rrf/blur \nindex.js:164  prev state Object {auth: Object, toasts: Object, fetch: Object, form: Object, reactReduxForm: Object}\nindex.js:168  action Object {type: \"rrf/batch\", model: \"reactReduxForm.rrfJobDetails.crewQuantity\", actions: Array[2]}\nindex.js:168  action Object {type: \"rrf/blur\", model: \"reactReduxForm.rrfJobDetails.crewQuantity\"}\nindex.js:168  action Object {type: \"rrf/change\", model: \"reactReduxForm.rrfJobDetails\", value: Object, silent: false, multi: false}\nindex.js:168  action Object {type: \"rrf/change\", model: \"reactReduxForm.rrfJobDetails.crew\", value: Array[0], silent: false, multi: false}\nindex.js:168  action Object {type: \"rrf/change\", model: \"reactReduxForm.rrfJobDetails.crewQuantity\", value: 0, silent: false, multi: false}\nindex.js:168  action Object {type: \"rrf/change\", model: \"reactReduxForm.rrfJobDetails.equipment\", value: Array[0], silent: false, multi: false}\nindex.js:168  action Object {type: \"rrf/change\", model: \"reactReduxForm.rrfJobDetails.equipment\", value: Array[1], silent: false, multi: false}\nindex.js:168  action Object {type: \"rrf/change\", model: \"reactReduxForm.rrfJobDetails.teamLeaderId\", value: \"\", silent: false, multi: false}\nindex.js:168  action Object {type: \"rrf/focus\", model: \"reactReduxForm.rrfJobDetails.crewQuantity\", value: undefined, silent: true}\nindex.js:168  action Object {type: \"rrf/reset\", model: \"reactReduxForm.rrfJobDetails\"}\nindex.js:168  action Object {type: \"rrf/setErrors\", model: \"reactReduxForm.rrfJobDetails.address\", errors: Object}\nindex.js:168  action Object {type: \"rrf/setErrors\", model: \"reactReduxForm.rrfJobDetails.clientId\", errors: Object}\nindex.js:168  action Object {type: \"rrf/setErrors\", model: \"reactReduxForm.rrfJobDetails.contactId\", errors: Object}\nindex.js:168  action Object {type: \"rrf/setErrors\", model: \"reactReduxForm.rrfJobDetails.crew\", errors: Object}\nindex.js:168  action Object {type: \"rrf/setErrors\", model: \"reactReduxForm.rrfJobDetails.crewQuantity\", errors: Object}\nindex.js:168  action Object {type: \"rrf/setErrors\", model: \"reactReduxForm.rrfJobDetails.date\", errors: Object}\nindex.js:168  action Object {type: \"rrf/setErrors\", model: \"reactReduxForm.rrfJobDetails.equipment[0].item\", errors: Object}\nindex.js:168  action Object {type: \"rrf/setErrors\", model: \"reactReduxForm.rrfJobDetails.equipment[0].quantity\", errors: Object}\nindex.js:168  action Object {type: \"rrf/setErrors\", model: \"reactReduxForm.rrfJobDetails.jobStartTime\", errors: Object}\nindex.js:168  action Object {type: \"rrf/setFieldsValidity\", model: \"reactReduxForm.rrfJobDetails\", fieldsValidity: Object, options: Object}\nindex.js:168  action Object {type: \"rrf/setSubmitFailed\", model: \"reactReduxForm.rrfJobDetails\", submitFailed: true}\nindex.js:168  action Object {type: \"rrf/setValidity\", model: \"reactReduxForm.rrfJobDetails\", validity: Object}\nindex.js:168  action Object {type: \"rrf/setValidity\", model: \"reactReduxForm.rrfJobDetails.address\", validity: Object}\nindex.js:168  action Object {type: \"rrf/setValidity\", model: \"reactReduxForm.rrfJobDetails.clientId\", validity: Object}\nindex.js:168  action Object {type: \"rrf/setValidity\", model: \"reactReduxForm.rrfJobDetails.contactId\", validity: Object}\nindex.js:168  action Object {type: \"rrf/setValidity\", model: \"reactReduxForm.rrfJobDetails.crew\", validity: Object}\nindex.js:168  action Object {type: \"rrf/setValidity\", model: \"reactReduxForm.rrfJobDetails.crewQuantity\", validity: Object}\nindex.js:168  action Object {type: \"rrf/setValidity\", model: \"reactReduxForm.rrfJobDetails.equipment[0].item\", validity: Object}\nindex.js:168  action Object {type: \"rrf/setValidity\", model: \"reactReduxForm.rrfJobDetails.equipment[0].quantity\", validity: Object}\nindex.js:168  action Object {type: \"rrf/setValidity\", model: \"reactReduxForm.rrfJobDetails.jobStartTime\", validity: Object}\n--- Last 3 rrf actions before the error:\nindex.js:152  action @ 10:37:51.875 rrf/setErrors \nindex.js:164  prev state Object {auth: Object, toasts: Object, fetch: Object, form: Object, reactReduxForm: Object}\nindex.js:168  action Object {type: \"rrf/setErrors\", model: \"reactReduxForm.rrfJobDetails.equipment[0].quantity\", errors: Object}\nindex.js:152  action @ 10:37:58.665 rrf/setValidity \nindex.js:164  prev state Object {auth: Object, toasts: Object, fetch: Object, form: Object, reactReduxForm: Object}\nindex.js:168  action Object {type: \"rrf/setValidity\", model: \"reactReduxForm.rrfJobDetails.jobStartTime\", validity: Object}\nVALUE OF CREW:\n    \"crew\": [\n      {\n        \"firstName\": \"Severus\",\n        \"lastName\": \"Snape\",\n        \"phoneNumber\": \"0499888777\",\n        \"address\": {\n          \"number\": \"404\",\n          \"street\": \"Blank St\",\n          \"suburb\": \"Nowhere Town\",\n          \"postcode\": \"3999\",\n          \"state\": \"VIC\"\n        },\n        \"email\": \"abc@123.com.au\",\n        \"id\": \"1\"\n      },\n      {\n        \"firstName\": \"Dobby\",\n        \"lastName\": \"House-elf\",\n        \"phoneNumber\": \"0412341234\",\n        \"address\": {\n          \"number\": \"3\",\n          \"street\": \"Wizard St\",\n          \"suburb\": \"Hogwarts\",\n          \"postcode\": \"2005\",\n          \"state\": \"NSW\"\n        },\n        \"email\": \"d.house.elf@123.com.au\",\n        \"id\": \"7\"\n      }\n    ]\nindex.js:152  action @ 10:37:58.681 rrf/setValidity \nindex.js:164  prev state Object {auth: Object, toasts: Object, fetch: Object, form: Object, reactReduxForm: Object}\nindex.js:168  action Object {type: \"rrf/setValidity\", model: \"reactReduxForm.rrfJobDetails.crew\", validity: Object}\nedit-job-page.js:43 -------- resetForm ---------\nreset-action-reducer.js:36 -------- resetFieldState --------- field: Object {focus: false, pending: false, pristine: false, submitted: false, submitFailed: false\u2026}\nreset-action-reducer.js:36 -------- resetFieldState --------- field: Object {focus: false, pending: false, pristine: false, submitted: false, submitFailed: false\u2026}\nreset-action-reducer.js:36 -------- resetFieldState --------- field: Object {number: Object, street: Object, suburb: Object, postcode: Object, state: Object\u2026}\nreset-action-reducer.js:36 -------- resetFieldState --------- field: Object {focus: false, pending: false, pristine: false, submitted: false, submitFailed: false\u2026}\nreset-action-reducer.js:36 -------- resetFieldState --------- field: Object {focus: false, pending: false, pristine: false, submitted: false, submitFailed: false\u2026}\nreset-action-reducer.js:36 -------- resetFieldState --------- field: Object {focus: false, pending: false, pristine: false, submitted: false, submitFailed: false\u2026}\nreset-action-reducer.js:36 -------- resetFieldState --------- field: Object {focus: false, pending: false, pristine: false, submitted: false, submitFailed: false\u2026}\nreset-action-reducer.js:36 -------- resetFieldState --------- field: Object {focus: false, pending: false, pristine: false, submitted: false, submitFailed: false\u2026}\nreset-action-reducer.js:36 -------- resetFieldState --------- field: Object {focus: false, pending: false, pristine: false, submitted: false, submitFailed: false\u2026}\nreset-action-reducer.js:36 -------- resetFieldState --------- field: Object {focus: false, pending: false, pristine: false, submitted: false, submitFailed: false\u2026}\nreset-action-reducer.js:36 -------- resetFieldState --------- field: Object {focus: false, pending: false, pristine: false, submitted: false, submitFailed: false\u2026}\nreset-action-reducer.js:36 -------- resetFieldState --------- field: Object {focus: false, pending: false, pristine: false, submitted: false, submitFailed: false\u2026}\nreset-action-reducer.js:36 -------- resetFieldState --------- field: Object {focus: false, pending: false, pristine: false, submitted: false, submitFailed: false\u2026}\nreset-action-reducer.js:36 -------- resetFieldState --------- field: Object {focus: false, pending: false, pristine: false, submitted: false, submitFailed: false\u2026}\nreset-action-reducer.js:36 -------- resetFieldState --------- field: Object {0: Object, 1: Object, $form: Object}\nreset-action-reducer.js:36 -------- resetFieldState --------- field: Object {firstName: Object, lastName: Object, phoneNumber: Object, address: Object, email: Object\u2026}\nreset-action-reducer.js:36 -------- resetFieldState --------- field: Object {focus: false, pending: false, pristine: false, submitted: false, submitFailed: false\u2026}\nreset-action-reducer.js:36 -------- resetFieldState --------- field: Object {focus: false, pending: false, pristine: false, submitted: false, submitFailed: false\u2026}\nreset-action-reducer.js:36 -------- resetFieldState --------- field: Object {focus: false, pending: false, pristine: false, submitted: false, submitFailed: false\u2026}\nreset-action-reducer.js:36 -------- resetFieldState --------- field: Object {number: Object, street: Object, suburb: Object, postcode: Object, state: Object\u2026}\nreset-action-reducer.js:36 -------- resetFieldState --------- field: Object {focus: false, pending: false, pristine: false, submitted: false, submitFailed: false\u2026}\nreset-action-reducer.js:36 -------- resetFieldState --------- field: Object {focus: false, pending: false, pristine: false, submitted: false, submitFailed: false\u2026}\nreset-action-reducer.js:36 -------- resetFieldState --------- field: Object {focus: false, pending: false, pristine: false, submitted: false, submitFailed: false\u2026}\nreset-action-reducer.js:36 -------- resetFieldState --------- field: Object {focus: false, pending: false, pristine: false, submitted: false, submitFailed: false\u2026}\nreset-action-reducer.js:36 -------- resetFieldState --------- field: Object {focus: false, pending: false, pristine: false, submitted: false, submitFailed: false\u2026}\nreset-action-reducer.js:36 -------- resetFieldState --------- field: Object {focus: false, pending: false, pristine: false, submitted: false, submitFailed: false\u2026}\nreset-action-reducer.js:36 -------- resetFieldState --------- field: Object {focus: false, pending: false, pristine: false, submitted: false, submitFailed: false\u2026}\nreset-action-reducer.js:36 -------- resetFieldState --------- field: Object {focus: false, pending: false, pristine: false, submitted: false, submitFailed: false\u2026}\nreset-action-reducer.js:36 -------- resetFieldState --------- field: Object {focus: false, pending: false, pristine: false, submitted: false, submitFailed: false\u2026}\nreset-action-reducer.js:36 -------- resetFieldState --------- field: Object {focus: false, pending: false, pristine: false, submitted: false, submitFailed: false\u2026}\nreset-action-reducer.js:36 -------- resetFieldState --------- field: Object {focus: false, pending: false, pristine: false, submitted: false, submitFailed: false\u2026}\nreset-action-reducer.js:36 -------- resetFieldState --------- field: Object {focus: false, pending: false, pristine: false, submitted: false, submitFailed: false\u2026}\nreset-action-reducer.js:36 -------- resetFieldState --------- field: Object {focus: false, pending: false, pristine: false, submitted: false, submitFailed: false\u2026}\nreset-action-reducer.js:36 -------- resetFieldState --------- field: Object {$form: Object}\nreset-action-reducer.js:36 -------- resetFieldState --------- field: Object {focus: false, pending: false, pristine: false, submitted: false, submitFailed: false\u2026}\nreset-action-reducer.js:36 -------- resetFieldState --------- field: Object {0: Object, 1: Object, $form: Object}\nreset-action-reducer.js:36 -------- resetFieldState --------- field: Object {id: Object, name: Object, $form: Object}\nreset-action-reducer.js:36 -------- resetFieldState --------- field: Object {focus: false, pending: false, pristine: false, submitted: false, submitFailed: false\u2026}\nreset-action-reducer.js:36 -------- resetFieldState --------- field: Object {focus: false, pending: false, pristine: false, submitted: false, submitFailed: false\u2026}\nreset-action-reducer.js:36 -------- resetFieldState --------- field: Object {focus: false, pending: false, pristine: false, submitted: false, submitFailed: false\u2026}\nreset-action-reducer.js:36 -------- resetFieldState --------- field: Object {id: Object, name: Object, $form: Object}\nreset-action-reducer.js:36 -------- resetFieldState --------- field: Object {focus: false, pending: false, pristine: false, submitted: false, submitFailed: false\u2026}\nreset-action-reducer.js:36 -------- resetFieldState --------- field: Object {focus: false, pending: false, pristine: false, submitted: false, submitFailed: false\u2026}\nreset-action-reducer.js:36 -------- resetFieldState --------- field: Object {focus: false, pending: false, pristine: false, submitted: false, submitFailed: false\u2026}\nreset-action-reducer.js:36 -------- resetFieldState --------- field: Object {focus: false, pending: false, pristine: false, submitted: false, submitFailed: false\u2026}\nreset-action-reducer.js:36 -------- resetFieldState --------- field: Object {0: Object, $form: Object, validated: Object, value: null}\nreset-action-reducer.js:36 -------- resetFieldState --------- field: Object {focus: false, pending: false, pristine: false, submitted: false, submitFailed: false\u2026}\nreset-action-reducer.js:36 -------- resetFieldState --------- field: Object {focus: false, pending: false, pristine: false, submitted: false, submitFailed: false\u2026}\nreset-action-reducer.js:36 -------- resetFieldState --------- field: Object {pristine: false}\nreset-action-reducer.js:36 -------- resetFieldState --------- field: null\nindex.js:152  action @ 10:38:13.230 rrf/reset \nindex.js:164  prev state Object {auth: Object, toasts: Object, fetch: Object, form: Object, reactReduxForm: Object}\nindex.js:168  action Object {type: \"rrf/reset\", model: \"reactReduxForm.rrfJobDetails\"}\nindex.js:172  error TypeError: Cannot read property '$form' of null\n    at resetFieldState (http://localhost:8080/assets/bundle.client.js:115834:15)\n    at http://localhost:8080/assets/bundle.client.js:11725:20\n    at Array.forEach (native)\n    at mapValues (http://localhost:8080/assets/bundle.client.js:11724:30)\n    at resetFieldState (http://localhost:8080/assets/bundle.client.js:115834:54)\n    at http://localhost:8080/assets/bundle.client.js:11725:20\n    at Array.forEach (native)\n    at mapValues (http://localhost:8080/assets/bundle.client.js:11724:30)\n    at resetFieldState (http://localhost:8080/assets/bundle.client.js:115834:54)\n    at http://localhost:8080/assets/bundle.client.js:11725:20\nindex.js:176  next state Object {auth: Object, toasts: Object, fetch: Object, form: Object, reactReduxForm: Object}\nreset-action-reducer.js:38 Uncaught TypeError: Cannot read property '$form' of null\n    at resetFieldState (http://localhost:8080/assets/bundle.client.js:115834:15)\n    at http://localhost:8080/assets/bundle.client.js:11725:20\n    at Array.forEach (native)\n    at mapValues (http://localhost:8080/assets/bundle.client.js:11724:30)\n    at resetFieldState (http://localhost:8080/assets/bundle.client.js:115834:54)\n    at http://localhost:8080/assets/bundle.client.js:11725:20\n    at Array.forEach (native)\n    at mapValues (http://localhost:8080/assets/bundle.client.js:11724:30)\n    at resetFieldState (http://localhost:8080/assets/bundle.client.js:115834:54)\n    at http://localhost:8080/assets/bundle.client.js:11725:20\n```. The problem isn't readily reproducible, so I'm not sure how to reduce it to it's simplest form.\nOne thing I'm doing that I'm not sure about is calling validate directly on the form model, instead of field models as specified in the docs.\nIs the following legal?\nactions.validate('reactReduxForm.myForm');\nThis triggers a setValidity call on every field in turn. Crew is the last field to be validated.\nactions.setValidity('reactReduxForm.myForm.firstName')\nactions.setValidity('reactReduxForm.myForm.lastName')\n...\n. I think I was going down the wrong path. Setting the crew array to blank before calling actions.reset seemed to fix the problem at first, but that was only because the issue was difficult to reproduce.\nAfter working out a precise number of steps to reproduce the problem, it turns out, a workaround that works is to use actions.change instead of actions.reset:\n```\nexport const initialFormState = {\n  notes: '',\n  clientId: '',\n  contactId: '',\n  receiptNo: '',\n  date: moment().valueOf(),\n  endTime: '',\n  startTime: moment().format(DEFAULT_TIME_FORMAT),\n  equipment: [],\n  address: {},\n  crew: []\n};\n// resetForm: () => actions.reset('reactReduxForm.myForm'),\nresetForm: () => actions.change('reactReduxForm.myForm', initialFormState),\n```. If new form fields are dynamically added to the model, will actions.reset() work properly?. ",
    "ngbrown": "What if the outer Form has <Form component=\"div\" ...> and the inner Form is intended as a normal form so that enter on an input control submits the inner form?  It seems that the behavior I'm getting is that the outer Form (the div) onSubmit is firing (through rrf/addIntent).\nUpdate: It starts to work as expected if I add a event.stopPropagation(); to the inner form's onSubmit handler.  However, because onSubmit won't be called if the inner form is invalid, this isn't going to be foolproof.... Codepen that uses new version and shows shows that #1013 is fixed: https://codepen.io/ngbrown/pen/JwLrPe.  Reproduce steps from #1013 with both original and new codepen.. Thanks for getting a release out so quickly. :). ",
    "sinbazhou": "I try to use react-redux-form with redux-immutable library,but failed\n. ",
    "MixKCet": "Huh, look at that. Thanks @davidkpiano!\n. ",
    "Anarios": "And I found it right after posting the issue\n. ",
    "diffused": "Awesome, thanks. \nMakes sense now. I initially thought the  was referring to account prop and the the controls inside somehow hinged off that.\nCheers for that. Will update my thinking on how this works now :D \n. Just have another question around this model hookup.\nI'm using Form model=\"forms.account\" \nwith a control of Control.text model=\"forms.account.firstName\"\nThe initial value shows up however any changed value doesn't appear in the handleSubmit function.\nIf I just use a control with Control.text model=\"account.firstName\", no initial value appears however the changed values do appear in the handleSubmit function\n. sure thing\n. Managed to figure it out. Needed to name the deep nested object\nexport default combineReducers({\n  routing: routerReducer,\n  account: combineForms({\n    account: account,\n  }, 'account'),\n});\nForm now looks like\n<Form model=\"account\" />\nAnd the Control:\n<Control.text model=\".FirstName\" className=\"form-control\" />\n. ",
    "torifat": "Yes, I'm currently on 1.0.15.\n\n. The problem is I can't reproduce it every time. If I can then I will be able to send a PR too.\nI thought you could figure it out by watching the recursive call.\n. @davidkpiano Yes, I get it. I thought by looking at the recursion you might be able to tell. I'm closing it for now. If I can figure out the code that triggers it. I will reopen it. Thanks.\n. ",
    "bstro": "I'm running into a similar issue. Like @torifat, it occurs inconsistently. \n\nWill continue to dig.. I'm finding that this stack overflow occurs any time the props change and my component re-renders. My component:\nexport function userReportForm({ activeUserId }) {\n  return <Form model={track('reports.users[]', { id: activeUserId })}>\n    <Control.text model=\".name\" />\n  </Form>\n}\nThe initial render succeeds, but when the props change to another active user, I get the RangeError.\nMy store configuration looks like this:\ncreateStore(\n  combineReducers(\n    ...reducers,\n    reports: combineForms({\n      users: [{\n        id: \"d9eec9f7-f7e1-4c17-afa5-d52672ab5090\",\n        name: 'Bob'\n      }, {\n        id: \"ba28fe5a-f06b-4621-a44d-204c2bb293c5\",\n        name: 'James'\n      }]\n    }, 'reports')\n  ), applyMiddleware(\u2026middleware)\n)\nupdate \u2014 I refactored my store configuration to use createForms inside combineReducers and changed my view accordingly and no longer have this issue. This might help narrow things down.. @davidkpiano ^ what do you think about reopening this issue?. It looks like I could possibly use a combination of Control's changeAction prop and dispatch a series of thunks that will create the model prior to attempting to perform actions.change on it. Thoughts?. Thanks! Super helpful.. ",
    "amadeogallardo": "Thanks for the reply. Router is an option; ended up resetting on componentWillMount for a regular stateful component. Will certanily investigate the new option when available!\n. ",
    "Neophy7e": "@davidkpiano there is still places where it's react-redux-form/immutable instead of react-redux-form/lib/immutable\neg : https://github.com/davidkpiano/react-redux-form/blob/master/examples/immutable/store.js\n. ",
    "gocamille": "Hi @davidkpiano ! Has the next release been released? Just npm installed but don't get these changes. \ud83d\ude1e \n. I'll close this issue as I've realized I was not importing the correct /lib/immutable while using ImmutableJS. I also understand Intents now! Thank you for a great library again \ud83d\udc4d \n. It is set up initially as this: \nconst initialState = fromJS({\n  step: 0,\n  fieldValues: {\n    email: '',\n    name: '',\n    password: '',\n    username: '',\n    inviteCode: '',\n    isoList: '',\n  },\n  avatar: {\n    ftype: '',\n    size: 0,\n    name: '',\n  },\n});\n. Hi @davidkpiano ! We seem to have resolved this issue at least, so closing this now. \n. Sorry for the delay, here it is: \njsx\n        <Form\n          model=\"login\"\n          className={`${styles.form} ${t.ph4}`}\n          onSubmit={props.handleSubmit}\n          validateOn=\"submit\"\n        >\n          <div className={`${styles.formFieldWrapper}`}>\n            <Control\n              model=\".email\"\n              className={`${styles.formFieldInput} ${styles.fontLight}`}\n              type=\"text\"\n              placeholder=\"Email address\"\n              autoCorrect=\"off\"\n              autoCapitalize=\"off\"\n              spellCheck=\"false\"\n              validators={{\n                email,\n              }}\n            />\n            <Errors\n              className={`${styles.formFieldError} ${t.pa2} ${t.pl4} ${t.mt2} ${t.br2} ${t.tl} ${t.fw2}`}\n              model=\".email\"\n              messages={{\n                required: 'Required',\n                email: 'Must be a valid email address',\n              }}\n            />\n          </div>\n          <div className={`${styles.formFieldWrapper}`}>\n            <Control\n              model=\".password\"\n              className={`${styles.formFieldInput} ${styles.fontLight}`}\n              type=\"password\"\n              placeholder=\"Password\"\n              validators={{\n                password,\n              }}\n            />\n            <Errors\n              className={`${styles.formFieldError} ${t.pa2} ${t.pl4} ${t.mt2} ${t.br2} ${t.tl} ${t.fw2}`}\n              model=\".username\"\n              messages={{\n                required: 'Required',\n                password: 'Weak password',\n              }}\n            />\n          </div>\n          <div className={`${styles.formSubmitBtnWrapper} ${t.pb3} ${t.pt4}`}>\n            <SubmitButton {...props} />\n          </div>\n        </Form>```\n. Sure! It's the exact copy of what's in the immutable example: \n```\n/\n\n * SubmitButton\n \n/\nimport React from 'react';\nimport { FormattedMessage } from 'react-intl';\nimport messages from './messages';\nimport styles from './styles.css';\nimport t from 'containers/App/index.css'; // tachyons.io\nconst SubmitButton = () => { // eslint-disable-line arrow-body-style\n  return (\n    ${styles.formSubmitBtn} ${t.f5} ${t.link} ${t.dim} ${t.br2} ${t.ph4} ${t.pv3} ${t.mb2} ${t.dib} ${t.white}}\n    >\n      \n\n  );\n};\nSubmitButton.propTypes = {};\nexport default SubmitButton;\n``\n. Hmmm...this still dispatches anrrf/batch` action that doesn't trigger a submit \ud83d\ude1e . ",
    "mikkelwf": "I've resolved it.\nI put the combineForms like this in my createStore:\ncreateStore({\n  form: combineForms(...)\n})\nAnd the consequent naming of my forms in my views did not resolve to the right form in rrf (nothing was actually stored in redux).. \nSo beginners error. I read the documentation again, and its not 100% clear that the naming changes when you nest combineForms in the state. But maybe i just didn't read it well enough.. :)\nAnyway, thanks for the quick reply. Keep up the good work.. :)\n. It makes total sense when you get it. :)\nI guess i just thought i had to omit the part of the path above the combineForms.. \n. No problem.. :)\nI've really enjoying this library, it makes form composition a breeze..\nKeep up the good work..! \ud83d\ude03 . You could call the resolve / reject with yield call(...), but as to if its imperative of not i actually don't know. It doesn't really change much, other than the stops the function execution until the yielded call returns (and in the case here i don't see that it is paramount).\nMy purpose with this was to try to wrap the state changes of the form upon submission, so you could dispatch as normal (as in simple object returning) action in the onSubmit callback of the form.\nIs amounts to some boilerplate either way because executing the actions for the form submission state is not really natural in the flow (meaning that after the onsubmit is called, the form is unaware of the subsequent fate of the action dispatched in that callback.\nIn my current setup the whole flow looks like this:\nonSubmit: trigger main action creator eg: this.props.dispatch(submit(values))\n-> submit is the wrapped action creator with the promise which triggers\n -> actions.submit with the promise that sends\n  -> the original action, which is picked up by\n   -> a takeLatest in the saga. this triggers the first saga\n    -> with a try / catch for the overall execution. it handles fx. redirecting upon success, showing toast messages eg. is yields the ajax saga\n     -> which then actually makes the call to the server.\nSo it's a pretty big russian doll setup already.\nI've adapted you example to omit promise all together, that simplifies it a bit in my setup, and works as my wrapper (except it does not set the form to pristine on successful submission, but that's more of a preference that can be omitted\n```javascript\nfunction* submitSaga (model, saga, ...args) {\n  yield put(actions.setPending(model, true))\ntry {\n    const validity = yield call(saga, ...args)\n    yield put(actions.setSubmitted(model, true))\n    yield put(actions.setValidity(model, validity))\n    return validity\n  } catch (error) {\n    yield put(actions.setSubmitFailed(model))\n    yield put(actions.setValidity(model, error))\n    throw error\n  }\n}\n```\nI'm trying to make the process of updating form state so invisible as possible, and wrapping the action creator as a thunk seems kinda laborious when it really can be  omitted. but on the other hand, using the saga approach means i have to adapt all sagas to use the new wrapper saga, and it seems kinda the wrong place to do it.... okay, after looking at your example again i decided to take another approach.\ni made a dedicated saga just for submitting forms (or maybe i just misunderstood your example), anyway, not it works like this: \n```javascript\nconst SUBMIT_FORM = 'SUBMIT_FORM'\nconst SUBMIT_FORM_SUCCESS = 'SUBMIT_FORM_SUCCESS'\nconst SUBMIT_FORM_FAILURE = 'SUBMIT_FORM_FAILURE'\n// Action creator\nexport function submitForm (model, action) {\n  return {\n    type: SUBMIT_FORM,\n    model,\n    action\n  }\n}\n// Saga\nfunction* submitFormSaga ({model, action}) {\n  // Set the form as pending\n  yield put(actions.setPending(model, true))\n  try {\n    // Dispatch the original action\n    const request = yield put(action)\n    // Listen for the response from the action\n    const {result, error} = yield race({\n      result: take(${request.type}_SUCCESS),\n      error: take(${request.type}_FAILURE)\n    })\n    if (result) {\n      // When receiving the result set the form as submitted\n      // load the most recent data into the form\n      // and set is as pristine\n      yield put(actions.setSubmitted(model, true))\n      yield put(actions.load(model, result.payload))\n      yield put(actions.setPristine(model))\n      yield put({type: SUBMIT_FORM_SUCCESS, model})\n      return result.payload\n    } else {\n      // If the result is an error\n      // set the form is an error state and update field validity\n      yield put(actions.setSubmitFailed(model))\n      yield put(actions.setValidity(model, error))\n      yield put({type: SUBMIT_FORM_FAILURE, model})\n    }\n  } catch (error) {\n    throw error\n  }\n}\nexport default function* () {\n  yield takeEvery(SUBMIT_FORM, submitFormSaga)\n}\n```\nand the onSubmit:\njavascript\nonSubmit (values) {\n  this.props.submitForm('form', asyncActionCreator(values))\n}\nI altered your example a bit. In my setup the setValidity upon success doesn't really apply, since my api only returns successful when is as performed the requested action. I also wanted to ensure the form has the most recent data returned by the api, hence the const result = yield take(${requestType}_SUCCESS) trick, (which fit i my naming convention, but is not generally applicable)..\nAnyway it seems it's quite possible to make a quite lean setup after all, awesome..! \ud83d\ude04  . I have the same issue... Any update on this..?. I have the same issue.... Thanks for the update.. \nI'm a bit sorry for the headline, frustrations, because generally i really enjoy this library. And i would guess that most of my personal struggles/frustrations really comes down to lack of understanding on how the library works. And given that forms are a pretty complicated to wrap you head around, its paramount that the tools you use don't add to the confusion.\nI would love to help out updating/extending the documentation, if i can contribute in any way, but i need to be more confident with the library to do that.. :). Thanks! Amazing!\nLooking forward to the next release.. :)\nBtw. that really good answer/description deserves a place in the documentation, at least under the FAQ.. . I tried to fork the changes, and can confirm it now works as expected.. SUPER NICE..!\nAny ETA on a new release..?. super.. i'm running on my own fork right now, so no pressure.. :)\nagain, super nice with a working fix..! \u2b50\ufe0f . This is so nice.. :D. ",
    "BerkeleyTrue": "So filter and submit are still thunks?\n. Awesome! That should be enough to resolve this issue.\nHappy Coding\n. @davidkpiano Thanks! I'm looking forward to refactoring out redux-form.. Sure:\nMy use case: I have forms that has action/method but I want to use react-redux-form to manage validation and also maintain the form state in redux. But the code without react-redux-form will always preventDefault. \nhttps://github.com/davidkpiano/react-redux-form/blob/master/src/components/form-component.js#L64\nIt would be great to have the option to let the default happen.\nThis is something I do regularly with redux-form. Usually with things like paypal buttons and mailchimp forms.. > For most use cases, preventing the default action of an event is preferable, I would think - otherwise, most forms would navigate to a different state/route\nIf you add target='_blank' the action will take place in a new tab keeping the user session active while they do whatever it is needed. \n\n\\<Form preventDefault={false} > ?\n\nMight be a good patch but the I believe a better option is to always leave it up to the developer, since developers are used to adding preventDefault to their event handlers.\nMaybe adding that option in this version and then in the next update remove the call to preventDefault and letting the developer handle it.. ",
    "bnlambert": "The component having the form is a child component that receives initial data through props directly from the parent component. \n<ChildComponent patient={this.state.patient} />\nNot ajax. When I refresh the form, initial data disappears.\n. Could be a problem with the version I am using? I simply ran the command\nnpm install react-redux-form --save\n. ",
    "stunaz": "@davidkpiano Nope it doesn't work.\nI take your codepen  and created the store as const store = createStore(combineForms({}), applyMiddleware(thunk));\nyes the values are in the states, but the following did not work:\nThe radios and the checkboxes doesnt work . (cant set a radio nor a checkbox)\nand submitting the form return undefined.\n\n. Can't fork a private pen\njust changed the line :\njavascript\nconst store = createStore(combineForms({\n  user: initialUserState,\n}), applyMiddleware(thunk));\nto\njavascript\nconst store = createStore(combineForms({}), applyMiddleware(thunk));\n. Coming from redux-form i have a hard time to migrate to rrf especially if i have to declare each form in advance. And also I dont quite understand the state, it feels like they are duplicated data.\nI mean for a single for form , it creates the following state :\njavascript\n{\n         \"user\": {\n            \"firstName\": \"jon\",\n            \"lastName\": \"doe\"\n        },\n        \"forms\": {\n            \"user\": {\n                \"firstName\": {\n                    \"focus\": false,\n                    \"pending\": false,\n                    \"pristine\": true,\n                    \"submitted\": false,\n                    \"submitFailed\": false,\n                    \"retouched\": false,\n                    \"touched\": false,\n                    \"valid\": true,\n                    \"validating\": false,\n                    \"validated\": false,\n                    \"validity\": {},\n                    \"errors\": {},\n                    \"initialValue\": \"jon\",\n                    \"value\": \"jon\",\n                    \"model\": \"user.firstName\"\n                },\n                \"lastName\": {\n                    \"focus\": false,\n                    \"pending\": false,\n                    \"pristine\": true,\n                    \"submitted\": false,\n                    \"submitFailed\": false,\n                    \"retouched\": false,\n                    \"touched\": false,\n                    \"valid\": true,\n                    \"validating\": false,\n                    \"validated\": false,\n                    \"validity\": {},\n                    \"errors\": {},\n                    \"initialValue\": \"doe\",\n                    \"value\": \"doe\",\n                    \"model\": \"user.lastName\"\n                },\n                \"$form\": {\n                    \"focus\": false,\n                    \"pending\": false,\n                    \"pristine\": true,\n                    \"submitted\": false,\n                    \"submitFailed\": false,\n                    \"retouched\": false,\n                    \"touched\": false,\n                    \"valid\": true,\n                    \"validating\": false,\n                    \"validated\": false,\n                    \"validity\": {},\n                    \"errors\": {},\n                    \"initialValue\": {\n                        \"firstName\": \"jon\",\n                        \"lastName\": \"doe\"\n                    },\n                    \"value\": {\n                        \"firstName\": \"jon\",\n                        \"lastName\": \"doe\"\n                    },\n                    \"model\": \"user\"\n                }\n            },\n            \"$form\": {\n                \"focus\": false,\n                \"pending\": false,\n                \"pristine\": true,\n                \"submitted\": false,\n                \"submitFailed\": false,\n                \"retouched\": false,\n                \"touched\": false,\n                \"valid\": true,\n                \"validating\": false,\n                \"validated\": false,\n                \"validity\": {},\n                \"errors\": {},\n                \"initialValue\": {\n                    \"user\": {\n                        \"firstName\": \"jon\",\n                        \"lastName\": \"doe\"\n                    }\n                },\n                \"value\": {\n                    \"user\": {\n                        \"firstName\": \"jon\",\n                        \"lastName\": \"doe\"\n                    }\n                },\n                \"model\": \"\"\n            }\n}\nAnd I feel that I only need forms.user, I dont really understand what is the rest for. I would love to migrate to rrf, but I think I need some guideline on store/state/reducers...\n. ",
    "nahushf": "Yeah it doesn't work. I tried both the formReducer as well as combineForms, here's the code pen\n. I used \nconst store = createStore(combineForms({ dynamic: {} }));\nand it worked like a charm. Thanks\n. ",
    "lnhrdt": "@davidkpiano is the solution you posted here still the correct way to setup react-redux-form with dynamic forms? I'm having a hard time getting it to work with 1.6.0.\nI'm share @stunaz's sentiment here:\n\nComing from redux-form i have a hard time to migrate to rrf especially if i have to declare each form in advance.\n\nand I feel like I'd rather have the declaration of my form, its initial state, etc. all contained within the form component itself rather than my app's global store configuration.. ",
    "husainshabbir": "@davidkpiano I tried as per your instructions to create my store for dynamic forms like this:\njavascript\nconst store = createStore(combineReducers({\n  forms: formReducer('forms', {\n    dynamic: {},\n  }),\n});\nThen, when I create my form <Form model=\"dynamic.completeNew\">, I get this error:\nError: Unable to create Form component. Could not find form for \"dynamic.completelyNew\" in the store.\n\nThis pen reproduces the error. Am I doing something incorrectly?. I might be missing something obvious here. How do I do that when I have my\nown reducers that I must combine using combineReducers?\n. Ah, thanks. I realized what my mistake was. I was using the word forms as the property name to hold all my dynamic forms, which was probably causing a problem. Changing the name to myForms did the trick.. Redux Form has a way of adding a new item in the middle of an array using fields.insert(position, newObject). I was hoping to find something similar in the action creators, such as actions.insert('myModel', position, newObject), but couldn't find anything. What is the recommended way of adding a new item in the middle of an array?. Of course! Sometimes the most obvious things are often overlooked. Thanks a lot for your help. I appreciate the speedy response.. ",
    "gvidon": "@davidkpiano it is action dispatching. We provide every custom control with this method, using this:\n``` javascript\n// Form row wrapper, provides all data and logic down to wrapped UI component\nimport {has, isUndefined} from 'lodash';\nimport React from 'react';\nimport {actions, Control} from 'react-redux-form';\nconst\n    commonPropsMap = {\n        disabled  : props => Boolean(isUndefined(props.fieldValue.disabled) ? props.disabled : props.fieldValue.disabled),\n        focus     : props => props.fieldValue.focus,\n        isRequired: props => has(props.validators, 'isRequired'),\n        onBlur    : props => () => props.dispatch(actions.blur(props.model)),\n        valid     : props => props.fieldValue.valid,\n        validate  : props => () => props.dispatch(actions.validate(props.model, props.validators))\n    },\ncreateField = (component, mapProps) => {\n    const\n        Field = props => <Control component={component} mapProps={{...commonPropsMap, ...mapProps}} {...props}>\n            {props.children}\n        </Control>;\n\n    Field.propTypes = component.propTypes;\n    return Field;\n};\n\nexport {createField};\n```\nAnd apply like this:\njavascript\nimport ContactRow from 'generic/Form/ContactRow';\nimport {controls} from 'react-redux-form';\nimport {createField} from 'generic/Form/Field';\nexport default createField(ContactRow, controls.select)\n. @davidkpiano it looks like after SET_VALIDITY is dispatched there is no our custom code participating in the process. Loop starts even without changing anything, but during form init. \nThe flow is \u2014 data fetched over network, model store updated, componentWillReceiveProps called, SET_VALIDITY falls into loop.\nIt started right after lodash updated yesterday. Unable to reproduce with lodash < 4.17.0.\n. @davidkpiano thanks!. @davidkpiano do you mean it is a proper way to import from lib/immutable instead of /immutable or is it just a temporary fix?. @davidkpiano thanks!. ",
    "perrydt": "We just ran into a similar problem and by comparing shrink-wrapped versions of our deployed app were able to track it to lodash 4.17.0 as well.  Our affected forms are using custom validation functions in the validators prop, but are all client-side; for us the symptom was not an infinite loop but very poor form performance -- several seconds to handle each keystroke.\nHowever, the problem seems to be gone after updating to lodash 4.17.1 which was released yesterday -- one of the changelog items mentions fixing an \"_.omit performance regression\".\n. ",
    "fxfilmxf": "I noticed the same problem. Several seconds for each keystroke. I traced it down to omit which I thought was pretty odd until I saw the issues that were filed against lodash 4.17.0. There's an issue with pick in 4.17.1 so I would suggest staying on 4.15 or waiting until 4.17.2 is released later today.\n. Thanks!\n. ",
    "brianleonard15": "I just had this same issue. It happens if you incorrectly set up your store and/or incorrectly specify the model path, causing the intents to be set on the wrong part of the store and consequently submit is never handled. There's a lot of different ways you could screw this up, so in @gocamille's case, it may be a matter of changing the form model from \"login\" to one level up, e.g. \"form\". In my case, I added the optional formReducer key string to createForms so that I could keep the form model as \"user\":\njavascript\nconst rootReducer = combineReducers({\n  myOtherReducer: MyOtherReducer,\n  ...createForms({\n    user: UserReducer,\n  }, \"user\"),\n});. Ah I see. I thought there might be some obvious way without using string slicing operations in the reducer, since I'm new to react-redux-form, but the reasoning for having the logic in the reducer vs. the changeAction prop on the Control component was to make the code a little more robust. However, I think using those string operations is even more fragile than just handling the logic with the changeAction prop. Thank you for your help and quick response, David!. Very cool! I'm trying to avoid installing redux-thunk for now since I'm already using sagas so I'm sticking with just manually doing it in changeAction, but that's definitely a more concise way.. Just FYI, actions.push() is not in the table of contents in the documentation for those that have trouble finding it.. Yes, I've got \"babel-preset-es2015\": \"^6.16.0\", \"babel-preset-react\": \"^6.16.0\",\"babel-preset-stage-2\": \"^6.17.0\", \"babel-loader\": \"^6.2.5\", and in webpack:\n     loaders: [\n        {\n          test: /\\.js$/,\n          loaders: ['babel'],\n          include: path.join(__dirname, 'src')\n        },\nAny thoughts?. Using import ... from react-redux-form/lib/immutable vs import ... from react-redux-form/immutable seemed to solve the problem.. @hoangtrucit See my previous post. I just changed the import from this:\nimport {} from react-redux-form/immutable\nto this\nimport {} from react-redux-form/lib/immutable. Did you make sure you did that for every react-redux-form import in your app? Having even just one of them as react-redux-form/immutable will cause this issue for me.. The idea comes from here https://github.com/acdlite/reduce-reducers, but the implementation is a one-liner. Maybe it doesn't need to be used at all here if you have another suggestion on how to achieve this?. Thank you a lot @davidkpiano. Didn't realize the spread syntax could be leveraged here. The only difference is I spread the counterReducer in reducer so that I didn't need the counter key. However, if you do so, React will complain about an unexpected key because combineReducers here is being passed the state which will now have some other keys (like count) in it besides model and form. To solve this, I only passed the relevant state to combineReducers as follows:\n```js\nconst counterReducer = (state, action) => {\n  switch (action.type) {\n    case INCREASE_COUNT:\n      return {...state, count: action.countNumber};\n    default:\n      return state;\n  }\n};\nconst rrfReducer = combineReducers({\n  'model': modelReducer('model', initialModelState),\n  'form': formReducer('model', initialModelState)\n});\nconst reducer = (state = {count: 0}, action) => {\n  const {model, form, ...otherState} = state;\n  return {\n    ...counterReducer(otherState, action),\n    ...rrfReducer({model, form}, action),\n  };\n};\nexport default reducer;\n```\nThis also provides a very nice separation of concerns I think so that my counterReducer doesn't mess with the rrfReducer's state and vice versa. Thank you again!. Also, if you add three items to the array and remove the second item, the model pointed to by the field value of the now second item (used to be the third item) is not updated.\nFor example:\nStart with item 0, item 1, item 2. \nRemove item 1.\nNow you have item0, item 2, as expected.\nUnexpected field value for item 2 is model: \"items.2\"\nExpected this field value's model to be \"items.1\", since that is its new position in the array.. ",
    "ChrisSSocha": "We had a few problems implementing the form as you describe it.\n```\nimport React from \"react\";\nimport {Form, Control, Errors} from \"react-redux-form\";\nexport default class DateOfBirthField extends React.Component {\nrender() {\n\n    const dateValidators = {\n        'isValid': (value) => value.day === '1' && value.month === '2' && value.year === '3'\n    }\n\n    return (\n        <Form\n            model=\".dob\"\n            component=\"div\"\n            validators={{\n                '': dateValidators\n            }}>\n            <label>\n                Date Of Birth\n                <Control\n                    model=\".day\"\n                    placeholder=\"Day\">\n                </Control>\n                <Control\n                    model=\".month\"\n                    placeholder=\"Month\"/>\n                <Control\n                    model=\".year\"\n                    placeholder=\"Year\"/>\n                <Errors\n                    model=\"applicant.dob\"\n                    messages={{\n                        'isValid': 'Not valid'\n                    }}\n                    show={{touched: true, focus: false}}\n                />\n            </label>\n        </Form>\n    )\n}\n\n}\n```\nIn this case we get an error Cannot read property 'day' of undefined thrown from the validator. This goes away if we set the Form model to applicant.dob.\nIs it possible to use  nested form with a partial model? Are we doing something wrong?. Hey @davidkpiano,\nHave you had a chance to look at my follow up question above?\nIs it possible to use nested form with a partial model?. ",
    "Bernhard10": "Could you add an example about the validation with Fieldset to the documentation? I somehow cannot get it to work.. ",
    "jonathanconway": "Sorry about the late reply. Thanks @davidkpiano, yes, that does solve it. Cheers!. ",
    "sl33kr": "Thanks David!\nThis was messing with some styling coming from an external library we use.. @davidkpiano I'm new to typescript as well. Here is an example of what I'm trying to do.\n<Field model=\".customers[0].isNew\" className=\"btn-group\" >\n    <label className=\"btn btn-lg btn-primary col-xs-6\" id=\"new-customer-label\">\n        <input type=\"radio\" id=\"new-customer-option\" value=\"true\" /> New\n    </label>\n    <label className=\"btn btn-lg btn-primary col-xs-6\" id=\"existing-customer-label\">\n        <input type=\"radio\" id=\"new-customer-option\" value=\"false\" /> Existing\n    </label>\n</Field>\nIn typescript the className on Field is invalid as FieldProps doesn't extend HTMLProps. Same case for ControlProps. I'm not sure if there is a way to provide these props without either explicitly adding them to FieldProps or making it extend HTMLProps.\nI then tried to use the controlProps=\"{{className: \"btn-group\"}}\" however this wasn't available on Field either.\nI ended up rendering the div manually.\n<Field model=\".customers[0].isNew\" component={(props) => {\n    return (<div className=\"btn-group col-xs-12 col-sm-12 col-md-12 col-lg-6\">\n                {props.children}\n            </div>);. I did try to interface merge in our project to add the \"extends HTMLProps\" to FieldProps and ControlProps to work around the issue but I could get this working either.. Ok I got the merge working. Messes with intellisense but at least it compiles.\n```\n// react-redux-form.htmlprops.ts\nimport { FieldProps, ControlProps } from 'react-redux-form';\nimport { HTMLProps } from 'react';\ndeclare module \"react-redux-form\" {\n    interface FieldProps extends HTMLProps {\n    }\n}\n```\n```\n// form.ts\nimport { Control, Field } from 'react-redux-form';\nimport './react-redux-form.htmlprops.ts';\n// Some stuff here setting up root form etc.\n\n\n New\n    \n\n Existing\n    \n\n\n\n New\n    \n\n Existing\n    \n\n\n\n\nFirst name *\n\n\n```. Ah sorry! I do remember seeing this now.. Ok I got it working, is there a way to associate this validation with the field models though?\nI can display then under the controls just by adding\n<Errors model=\"appState.enquiry\" messages={{ hasPhoneOrEmail: 'Please enter either a phone number or email.' }} />\nbut would prefer to only display it after either of the fields had been touched.\nWhen I have some more time I'll have a dig through the source.. Hi David,\nI realized I closed this but thought I would just add this in case someone came across this ticket.\nUsing show=\"touched\" in the Errors component when it is display Form errors will cause the validation to display as soon as ANY field in the form is touched.\nSo in our case we had it display under phone/email half way down the form. As soon as the user tabbed from the first field, the phone/email error would display.\nI think this would also be solved by #545 \n. Hi @davidkpiano \nWas just wondering if you have had a chance to consider this?. Great! I'll tidy it up try to get this done over the next day or 2. . If the history is too gross I can make a new branch off master and cherry pick.. I haven't done it yet no sorry.\nThere were a couple of lines in there I had comments on as I wasn't sure the best way to handle them.\n. I'll do type def now.. I think the second option would be the easier to implement. Would it default to merge: true?\nI'm just looking at the SET_ERRORS handler now. . I have just done a test just always doing the merge and there are 4 tests failing.\n\nExtended Control components unmounting should not clobber other non-field-specific validators\n component unmounting should not clobber other non-field-specific validators\n\nChaging \n```\nclass WrappedControl extends React.Component {\n  componentWillUnmount() {\n    store.dispatch(actions.setErrors('test.foo', {}));\n  }\nrender() {\n    return ;\n  }\n}\n```\nto\n```\nclass WrappedControl extends React.Component {\n  componentWillUnmount() {\n    store.dispatch(actions.resetValidity('test.foo'));\n  }\nrender() {\n    return ;\n  }\n}\n```\nmakes those tests pass. Would this still be an accurate test for these or should they do actions.setErrors('test.foo', { merge: false })?. Great! Thanks. Sorry I didn't get to tidy this up.. Do you have an idea on how to correctly handle this? Is the assumption ok?. ",
    "hermanfenderson": "Maybe I should just RTFM a bit more... \n. Here is the relevant part of the code...\nThe error is triggered when submitting with return key on custom change...\n// formRigaBolla.js (a container)\nclass FormRigaBolla extends React.Component {\nupdatePrice = (model,value) => {\n   this.props.actionsRigaBolla.updatePriceFromDiscount(model,value,this.props.formRigaBolla);\n}\nrender() {\n    const { formRigaBolla} = this.props;\n     return(\n            console.log(v)}>\n\n\n\nListino: \n\n\n\n\n\n\n//And an action calling a modeled reducer here: \n//actions/rigaBolla.js\nexport function updatePriceFromDiscount(model, value, formRigaBolla) \n{ \n  if (isPercentage(value))\n  {\n  var sconto1 = formRigaBolla.sconto1.value;\n  var sconto2 = formRigaBolla.sconto2.value;\n  var sconto3 = formRigaBolla.sconto3.value;\n  var prezzoListino = formRigaBolla.prezzoListino.value;\n   //Qui devo gestirmi quale e' il campo in ingresso...\n  var changedField = model.split('.')[2];\n  switch (changedField)\n      {\n      case 'sconto1' : sconto1 = value; break;\n      case 'sconto2' : sconto2 = value; break;\n      case 'sconto3' : sconto3 = value; break;\n      case 'prezzoListino' : prezzoListino = value; break;\n      }      \nreturn (dispatch) => {\n    //Devo cambiare leggermente qui per non aggiornare il prezzo di listino quando sar\u00e0 chiamato da un libro vero\n    dispatch(actions.setValidity(model, {isPercentage: true}));\ndispatch(actions.change(model, value));\ndispatch(actions.change(formRigaBolla.prezzoUnitario.model, discountPrice(prezzoListino, sconto1, sconto2, sconto3)));\n\n};\n  }\n  else \n  { \n  return (dispatch) => { \n    dispatch(actions.setValidity(model, {isPercentage: false}));\n    dispatch(actions.change(model, value));\n    } \n  }\n}\n. This is the full console output of the error BTW\nUncaught Error: Actions must be plain objects. Use custom middleware for async actions.\n    at Object.performAction (:1:24263)\n    at a (:1:18806)\n    at dispatch (:1:22133)\n    at Object.eval [as dispatch] (webpack:///./~/redux-thunk/lib/index.js?:14:16)\n    at Control.handleKeyPress (webpack:///./~/react-redux-form/lib/components/control-component.js?:484:22)\n    at Object.ReactErrorUtils.invokeGuardedCallback (webpack:///./~/react-dom/lib/ReactErrorUtils.js?:70:16)\n    at executeDispatch (webpack:///./~/react-dom/lib/EventPluginUtils.js?:85:21)\n    at Object.executeDispatchesInOrder (webpack:///./~/react-dom/lib/EventPluginUtils.js?:108:5)\n    at executeDispatchesAndRelease (webpack:///./~/react-dom/lib/EventPluginHub.js?:43:22)\n    at executeDispatchesAndReleaseTopLevel (webpack:///./~/react-dom/lib/EventPluginHub.js?:54:10). I pushed in github the latest version of my code: \nhttps://github.com/hermanfenderson/BrucaBook\nThe relevant files are: actions/brucaBook.js and containers/FormRigaBolla2.js\nA quick update... at least I isolated the problem.\nThe error is triggered only if the submit action starts by means of the return key (ASC 13) and only when the return key is pressed in a field with a custom change action.\nIf I submit the form with the \"submit\" button or by pressing return in a plain vanilla field... it works without errors.\nBTW... the validation process is not involved at all...\n. //This action: but if I keep only a one liner with a change action I will get that error as well...\nexport function updatePriceFromDiscount(model, value, formRigaBolla) \n{ \n  if (isPercentage(value))\n  {\n  var sconto1 = formRigaBolla.sconto1.value;\n  var sconto2 = formRigaBolla.sconto2.value;\n  var sconto3 = formRigaBolla.sconto3.value;\n  var prezzoListino = formRigaBolla.prezzoListino.value;\n   //Qui devo gestirmi quale e' il campo in ingresso...\n  var changedField = model.split('.')[2];\n  switch (changedField)\n      {\n      case 'sconto1' : sconto1 = value; break;\n      case 'sconto2' : sconto2 = value; break;\n      case 'sconto3' : sconto3 = value; break;\n      case 'prezzoListino' : prezzoListino = value; break;\n      }      \nreturn (dispatch) => {\n    //Devo cambiare leggermente qui per non aggiornare il prezzo di listino quando sar\u00e0 chiamato da un libro vero\n    dispatch(actions.setValidity(model, {isPercentage: true}));\ndispatch(actions.change(model, value));\ndispatch(actions.change(formRigaBolla.prezzoUnitario.model, discountPrice(prezzoListino, sconto1, sconto2, sconto3)));\n\n};\n  }\n  else \n  { \n  return (dispatch) => { \n    dispatch(actions.setValidity(model, {isPercentage: false}));\n    dispatch(actions.change(model, value));\n    } \n  }\n}\n. I've found the problem. It was in my brain!!! \nDidn't wrap the function in a dispatch block... \nNow it works perfectly. You can close the issue.... The use case was to pass a whole form to a function and use the values to calculate other values...it was useful as well to pass the model names (so if I had to refactor my code it didn't was too hard).\nAre you putting it back in a few hours or it will take longer? In the latter case... I will manage to fix my code.\nThank you for your prompt reply!\n. I appreciate that!!!!\nIl giorno mar 13 dic 2016 alle 17:21 David Khourshid \nnotifications@github.com ha scritto:\n\nThat's a good use case. Give me a few hours, I'll have the values back by\nthis evening at the latest.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/davidkpiano/react-redux-form/issues/573#issuecomment-266784401,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAcOUHdSNZeeGgWGSrnZIm-LR7Aw79-Sks5rHsYFgaJpZM4LL3TB\n.\n. \n",
    "justrag": "I'd be happy with just\n<LocalForm resetOnSubmit={true}>\n:)\nbut your approach will help to solve many similar problems that are bound to pop up soon.. ",
    "neerajhiretual": "Is there any example for resetting the localform within code (programatically) ? . ",
    "agustingp": "@davidkpiano I am using version 1.14.1 and I am having the same issue @lasergoat  had: I have store.sites[] and when dispatch(actions.reset(sites[0])) the key is updated in the model with undefined value. . @davidkpiano thank you for answering! So, how can I do to reset (setting its initial value) the model of an object stored inside the array? . ",
    "toadle": "Thanks for the answer. Will try this shortly!. OK, this is how I solved this in the end.\nI'm able to do a full-featured Bootstrap Input like this: \n<TextField model=\"newUser.email\" label=\"E-Mail\" required=\"required\" messages={{ taken: \"E-Mail ist bereits vergeben.\" }}/>\nThe TextField looks like this: \n```jsx\nconst TextField = (props) => {\n  const { label, required, messages, model } = props;\nreturn (\n     props }}\n             controlProps={{\n               label: label,\n               required: required,\n               messages: messages\n             }}\n             model={model} />\n  );\n}\n```\nThe TextFieldPresenter looks like this:\n```jsx\nconst TextFieldPresenter = (props) => {\n  const { label, passedProps, required, messages } = props;\n  const { model, fieldValue } = passedProps;\nreturn (\n    \n{label}\n\n\n\n\n\n\n\n  )\n}\n```. Hey there! Thanks for tackling this. \nI wanted to try it, but couldn't find a way to install the latest version.\nTried npm install davidkpiano/react-redux-form --save but this would result in node complaining that it can not find the react-redux-form module. \nInstalling with npm install react-redux-form@latest --save will not give me the latest code currently, right? . Hey guys!\nSorry, I only came back to testing this just now. Seems to be broken at least for me. \nHere is what I'm working with: A simple login form that checks the current auth-token:\ndispatch(actions.setPending(\"authentication.token\", true));\n    return jsonApi.find('authentication', authentication.token, {include: 'user', 'authToken': authentication.token})\n      .then((response) => {\n        dispatch(loginSuccessful(response));\n        dispatch(actions.setPending(\"authentication.token\", false));\n      })\n      .catch((err) => {\n        dispatch(actions.setValidity(\"authentication.token\", { valid: false }));\n        dispatch(loginFailed(err));\n        dispatch(actions.setPending(\"authentication.token\", false));\n      });\nNow without the {async: true} this works quite fine. Having the problem that after an initial \"failure\" the form will not resubmit. As described. \nNow changing this to dispatch(actions.setValidity(\"authentication.token\", { valid: false }, {async: true})); causes mayhem:\nBefore\nhttps://www.dropbox.com/s/xv4bty6ufy1408h/before-async.gif?dl=0\nAfter\nhttps://www.dropbox.com/s/u9qq74tya9ckkqa/after-async.gif?dl=0\nRRF somehow ends in a very long loop of changing the validity. Somehow it is not endless. \nHere is the <Form> btw.\n<Form className=\"large-inputs\" model=\"authentication\" onSubmit={this.props.doLogin}>\n    <TextField model=\"authentication.token\" label=\"Token\" required=\"required\" messages={{valid: \"Token ist ung\u00fcltig\"}}/>\n    <Button color=\"info\" size=\"lg\">Dive In</Button>\n  </Form>\nAfter {async: true} it simply looks like this: \ndispatch(actions.setPending(\"authentication.token\", true));\n    return jsonApi.find('authentication', authentication.token, {include: 'user', 'authToken': authentication.token})\n      .then((response) => {\n        dispatch(loginSuccessful(response));\n        dispatch(actions.setPending(\"authentication.token\", false));\n      })\n      .catch((err) => {\n        dispatch(actions.setValidity(\"authentication.token\", { valid: false }, {async: true}));\n        dispatch(loginFailed(err));\n        dispatch(actions.setPending(\"authentication.token\", false));\n      });\nAm I doing this wrong?. @davidkpiano Here you go:\nhttp://codepen.io/toadle/pen/qrjVZq\nYou need to flip that {async: true} switch. I removed all promise-based stuff in order to get it working.\nI somehow have the feeling it has to do with the new way that reducers are declared....just a guess.. @davidkpiano I checked a second example in my app, using {async: true}. In that case it is working. So I suppose I wired something incorrectly in my above example. Can't really tell what. Glad for any advice!. @davidkpiano Thanks for getting back! \nMostly yes. Except for the above example, which still produces an endless barrage of setValidity-actions. I'd just like to know why. I'm still suspecting that I'm doing something wrong in the above example. \n. Done! https://github.com/davidkpiano/react-redux-form/issues/706. BTW: If somebody wants to steer clear of this problem, while it is not fixed.\nJust leave out the {async: true} and rather resetValidityin your <Form> manually or <input> like so: \n<Form model=\"<your model>\" onSubmit={this.props.doStuff} onKeyUp={this.props.resetValidity} onFocus={this.props.resetValidity}>\nimport { actions } from 'react-redux-form';\n...\nexport function mapDispatchToProps(dispatch) {\n  return {\n     resetValidity: () => dispatch(actions.resetValidity('<your model>')),\n     ...\n  }\n}. @davidkpiano Oh ok. My bad. Sorry - I actually didn't notice that. All those examples that work for me don't even do that. That is why they work. \nThanks for the support!. @davidkpiano Sadly this does not solve it. I still get the infinite loop. I also changed the upper codepen to demonstrate.. @davidkpiano Thanks for getting back. \nYour suggestion was my first idea. But I always assumed that <Form model=\"what goes here\" ... > also have to match \nconst store = createStore(combineForms({\n    some name here: { some: \"defaults\" }\n});\notherwise the form/model for a rrf-form will not be found. \nHaving a <Form model={entities.patients[${props.patientId]}> and a store like this: \nconst store = createStore(combineForms({\n    entities: combineForms({\n       patients: patientsReducer\n    })\n});\nShould this work?\n. OK, here is how it will work - which perhaps illustrates my question a bit more. \nexport default combineReducers({\n  entities: combineReducers({\n    patients: patientsReducer\n  }),\n  forms: {\n    patient: formReducer(\"entities.patients\", {})\n  }\n});\nNow you can have a Form like this: <Form model={entities.patients[${this.props.patient.id}]} onSubmit={this.props.updatePatient} > and RRF will work as expected. \nNow one question remains: What if I had to create a new patient therefore need an empty form which is not really linked to an entity yet?\n<Form model={entities.patients[new]} onSubmit={this.props.updatePatient} >\ndid not work.. @davidkpiano Thanks I'll take a look at that.\nBTW: I forgot something in my above example. The reducers will only work if wired this way: \n```\nimport { modeled } from 'react-redux-form';\nexport default combineReducers({\n  entities: combineReducers({\n    patients: modeled(patientsReducer, 'entities.patients')\n  }),\n  forms: {\n    patient: formReducer(\"entities.patients\", {})\n  }\n});\n``. @davidkpiano OK, I created a separate key for creating new objects likeentities.new.patient`. Works flawless. \nStill my question remains: I'm often trying to edit an entity via <Form model=\"entities.patients[2]/> with works when I have a reducer like\nforms: {\n    patients: formReducer(\"entities.patients\", {})\n  }\nBut I'm often running into some endless setFieldsValidity loops when trying to do stuff like actions.setDirty(\"entities.patients[4]\") or similar. \nIs rrf supposed to work this way on collections?\n. @davidkpiano I just found this one: https://github.com/davidkpiano/react-redux-form/issues/796\nSo might be that it actually does not have to do with the collection.. \ud83d\udc4d  I just second this. \nHaving the same problem. Went with the intuitive-version and got Maximum call stack size exceeded.. OK - cool. Thanks for checking. I'm still on 1.8.0 here. Trying again. \nThanks for the great work and the fast support. RRF is still the best solution for redux-forms. Much better that redux-form :-D!\nBTW: Did you update something in the above pen? Cause I had the loop yesterday, with that pen, when I left work.. Indeed works, with latest version 1.11.1. \nThanks.. I fixed my loop, by adding this: \nshouldComponentUpdate(nextProps) {\n    return !_.isEqual(this.props, nextProps);\n  }\n...on the Component that contains the <Form>.\nSo I suppose this somehow has to do with the setFieldsValidity-action that RRF dispatches, when the <Form> appears. Or does this happen somewhen else? So I can't tell if this is my stupidity or that needs fixing. \nI've tried to reconstruct my use-case: https://codepen.io/toadle/pen/aWrMxx\nBut in the above example it also doesn't loop. I access the model's value via \u00b4connect\u00b4 and then depend the validators on it. \n. @davidkpiano Do you have any advice on this? Is this a known issue?\nThanks for any help.. OK, if somebody should come across this kind of problem: Moving the validators from the <Form> to the individual <Field>s will help.\nSo \n```\n    let validators = {\n      firstName: {\n        notEmpty\n      }\n    };\n\nFirst name:\n\n\n\n```\nwill not work. \nBut just:\n<Form model=\"entities.users[0]\">\n          <label>First name:</label>\n          <Control.text model={`entities.users[0].firstName`} validators={{ notEmpty }}/>\n          <Errors model={`entities.users[0].firstName`} messages={{notEmpty: \"Must be present\"}} />\n</Form>\nWill work. Even displaying the correct error-messages and submitting, when all is valid.\n@davidkpiano This problem most probably originates from \nform-component.js:352\n```\n      if (!validators && onSubmit && formValid) {\n        onSubmit(modelValue, e);\n    return modelValue;\n  }\n\n``\nBecause of!validatorsin combination with thegetForm-function that will returnentities.userswhen looking up the form forentities.users[0]. I tried fixing it, butgetFormStateKey` is it's own kind of beast, that I am no match for.\n. @sonarforte We are doing something similar with Bootstrap 4 as UI Kit. In my experience the behaviour regarding validation that @davidkpiano described is indeed more consistent and therefore desired. \nWe also attach the displaying of error-messages to the touched-property. Since this will also correctly work when the user tries to submit something that he has never touched!\nExample for a TextField from our code:\nTextField.js \n```jsx\nconst TextField = (props) => {\n  const { model } = props;\nreturn (\n     props }}\n             controlProps={props}\n             model={model} />\n  );\n}\nexport default TextField;\n```\nTextFieldPresenter\n```jsx\nconst TextFieldPresenter = (props) => {\n  const { label, passedProps, required, messages, size, className, disabled, placeholder, unit, locked } = props;\n  const { model, fieldValue, modelValue } = passedProps;\nconst classes = classNames(\n    className,\n    'form-control',\n    (size ? input-${size} : false),\n    (!fieldValue.pristine) ? \"has-changes\" : false,\n  );\nconst wrapperClasses = classNames(\n    size ? form-group-${size} : false,\n    (fieldValue.touched && !fieldValue.valid) ? \"has-danger\" : false,\n    locked ? locked : false,\n  );\nreturn (\n    \n      {label && {label}}\n      {unit && {unit}}\n      {locked && }\n      \n      {fieldValue.touched && \n\n}\n    \n  );\n};\nexport default TextFieldPresenter;\n``\n. @daisy-cyt Do you get asubmitFailed`-event, when doing that or is it just not submitting?\nIn my experience https://github.com/davidkpiano/react-redux-form/issues/808 it is only a real problem, when you don't get that submitFailed. \n. ",
    "peterox": "This is fantastic as this is exactly the problem I have just hit. I think this should be added to the documentation.. I am also seeing this problem when trying to 'load' a form. I've done some investigating and think I know what is causing this.\nStep 1) dispatch load action\nIn commit  17f06a5:\nThe change to changeActionReducer() meant action.state is copied into $form.loadedValue.\n```javascript\n    const formValue = action.state\n      ? get(action.state, form.$form.model)\n      : getFormValue(form);\nconst formUpdates = {\n  ...form.$form,\n  value: formValue,\n};\n\nif (action.silent) {\n  formUpdates.loadedValue = formValue;\n} else {\n  formUpdates.pristine = false;\n}\n\naction.state is modelCache[cacheId] - see forms-reducer line 91javascript\n    return {\n      ...modelReducers,\n      [key]: (state, action) => strategy.formReducer(model, initialFormState, {\n        plugins,\n        ...formOptions,\n      })(state, { ...action, state: modelCache[cacheId] }),\n    };\n```\nStep 2) Dispatch action for model field that doesn't exist in the loaded object EDIT\ngetFieldAndForm uses icepick to merge the formState\njavascript\n    form = i.merge(createInitialState(\n      formState.$form.model,\n      tempInitialState(modelPath, initialValue)), formState);\nand formState contains $form which contains the reference to action.state which is a reference to modelCache[cacheId].\nIcepick freezes everything.\nStep 3) CacheReducer tries to update modelCache\n```javascript\nfunction cacheReducer(reducer, model, cacheId) {\n  return (state, action) => {\n    const newState = reducer(state, action);\nmodelCache[cacheId][model] = newState;\n\nreturn newState;\n\n};\n}\n```\nThis fails as modelCache[cacheId] has been frozen.\nI'm don't fully (or even a little bit) understand the changes make is commit 17f06a5 so I'm not sure what the best solution is. I have forked the repo and will try and write a test for this situation so stay tuned. :-)\nCheers\nPeter\n. Hi David, I hit save a bit too quick. Created a pull request https://github.com/davidkpiano/react-redux-form/pull/727 for this issue.. @Hi @davidkpiano, \nI've just been bitten by the change made regarding noValidate. I think this is a breaking change for a 'dot' release.\nI had noValidate on all my forms so that the HTML5 error messages weren't displayed as I was taking care of validation and error messages myself.\nThe upgrade to 1.12.1 has caused all by forms to be submittable when invalid.\nI personally think this change should be reverted, or at least the property used to turn off validation should NOT be noValidate. \nAs a side note, I tried to add formNoValidate to my controls, but the HTML 5 error popup is still showing when I submit my empty and invalid form.\nThoughts??\nPeter\n. @davidkpiano that would work for me. \nThough I still think this is a breaking change so should be communicated as such. i.e. v1.13.0 at least\nHere's why.\nUsing v1.12.0 of react-redux-forms with noValidate on my form, my forms were properly validating using my supplied validators without any of the pesky HTML5 validation popups. I am using react-toolbox form components so adding the HTML5 attributes to the inputs was necessary for them to be displayed correctly.\nI did an npm update which updated to 1.12.1. \nMy forms will now submit when invalid.\nIf I am in this boat then I believe many other people would also be.\n. Thanks @davidkpiano. Keep up the awesome work.. Hi @davidkpiano . I tried your idea but this is still not a workable fix.\nWith the onInvalid handler as above, and with the noValidate attribute removed,  the HTML5 error messages don't pop up \nBUT... \nwhen I hit submit on my form that has invalid fields, my error messages used to be shown. i.e. all fields were validated.\nNow, with the above handler added, when I click submit nothing happens. The fields do not show up as in error (and the form does not get submitted). \nPeter. Maybe I left off one piece of the puzzle.\nI have showErrors set to 'touched'. So the initial error messages (like\nrequired) are not shown when the form is displayed. Prior to 1.12.1 when\nyou clicked the submit button all fields were validated and all error\nmessages displayed.\nWith 1.12.1 and the onInvalid handler this doesn't happen.\nLooking at the code validation happens on submit. My guess is that the\nnative browser code never fires submit when an invalid field is found.\nPeter\nOn Mon., 19 Jun. 2017, 6:34 am David Khourshid, notifications@github.com\nwrote:\n\n@peterox https://github.com/peterox I can't replicate this. The below\ncode works perfectly fine:\n\n  <Control.text\n    model=\".email\"\ntype=\"email\"\nonInvalid={e => e.preventDefault()}\n\n/>\n  \n\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/davidkpiano/react-redux-form/issues/823#issuecomment-309301188,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAxGF8QlQMvF55ULEBfhez2tlFkLxSa2ks5sFYnbgaJpZM4NvUVZ\n.\n. Hi @klis87,\n\nI totally agree that this change was not a good one. For a library that provides validation options over and above the HTML5 validations, to then behave the same way as the HTML5 spec seems counter productive.\nFYI to get around this problem, remove the 'onInvalid' attributes as stated in the FAQ and instead add the 'formNoValidate' attribute to your submit buttons (NOT your form).\nAs long as react-redux-form doesn't start complying with the HTML5 spec in this regard then HTML5 validations will not be triggered BUT your validations will be triggered when the user clicks the submit button.\nPeter\n. ",
    "mgutz": "Dupe of #545 . ",
    "CoinGame": "store\n```jsx\nimport { createStore, applyMiddleware, compose } from 'redux'\nimport normalizrMiddleware from 'redux-normalizr-middleware'\nimport logger from 'redux-logger'\nimport thunk from 'redux-thunk'\nimport combineReducers from './reducers/index.js'\nconst composeEnhancers = window.REDUX_DEVTOOLS_EXTENSION_COMPOSE || compose;\nexport default createStore(\n  combineReducers,\n  composeEnhancers(\n    applyMiddleware( thunk, normalizrMiddleware() ) \n  ))\n```\nreducer index\n```jsx\nimport { combineReducers } from 'redux'\nimport { routerReducer } from 'react-router-redux'\nimport { combineForms } from 'react-redux-form'\nimport profile from './profileReducers'\nconst registrationFormState = {\n  username: '',\n  password: '',\n  password2: '',\n};\nconst loginFormState = {\n  username: '',\n  password: '',\n};\nconst profileFormState = {\n  name: '',\n  type: 0\n};\nconst forms = combineForms({\n    register: registrationFormState,\n    login: loginFormState,\n    profile: profileFormState\n  })\nexport default combineReducers({\n  routing: routerReducer,\n  forms: forms,\n  profile,\n})\n```. Is there any examples of react-redux-form where inputs should be pre-populated? I couldn't find any in the documentation, but maybe I missed it. I can simplify further or reuse an existing example to see if it's something config related on my end.. Hi @davidkpiano, thanks for the quick reply. it looks like that actually breaks things further. As running the app immediately throws:\njavascript\nUncaught Error: Could not find form state for 'profile.name' model. Please make sure it exists in the store.\nwhereas before it seemed to be finding the forms in the store fine. RRF allows me to update, and submit data fine which it's drawing from the store. Notice in the screenshot above for the Control component that fieldValue.initialValue, and fieldValue.value are set correctly which it pulled from the store.\nin the CombineForms documentation it stated that the default key for the form data would be forms, and that is how it's currently defined in my store. This gave me the impression that RRF would default to looking for a key called forms with the data rather than having all of the form data in the root.\n\nThis is how my store looks inside the browser. I will try to have all of the form data in the root to see if that helps resolve it.. Boom. You're the dude. I just needed to add the forms key to my forms model attribute. My gut preference is the nested approach. Unless there's some serious drawbacks for the future i'm not aware of. Still kinda new to react/redux, and mixing in things like RRF has been a whirlwind. Appreciate your responsiveness and insights.. Oh man I really appreciate you digging deeper on that. It was a low priority styling thing for me so I didn't have a chance to jump on the reproduction request. When I get back around to styling I'll give this a shot. Either way thanks - you the best.. ",
    "tberster": "Thanks for your prompt reply. I'm now running into the challenge that I would like to dynamically set the class. If you focus the field, and then immediately blur it, it should have the internal state of pristine: true and touched: true. But it doesn't change the classes on the field, because mapProps gets only called once the component gets mounted. Am I doing something wrong here?. Running into a similar issue myself.\nDepending on outside factors, I will have additional fields in a form and corresponding validators.\nOnce I modify the validators, I can't get the fields out of the form any longer. Any ideas on how to resolve this?\nThe idea of having actions.destory('form', [keysToOmit]) seems like it would solve this, but wanted to check if there are any other ways around this.. ",
    "oyeanuj": "@davidkpiano It seems like in #409, the complexity was needing to check what was changed or not in the whole form? The use-case in this issue whereas seems to be a much simplified version of that usecase since it seems logical only to check if that field is dirty (or not pristine). \nThat would not only make 'only-submit-changed-field' logic much simpler, but atleast to me, more intuitive (than submitting the whole form when auto-saving on each field).. @davidkpiano That's interesting. I was thinking of a couple of different approaches. \n\nCloser to your suggestion, but instead of user specifying a submitFilter, the library would only pass to the onSubmit the field that was active and is dirty. By definition, that would only be field at a time. \nIt might be cleaner for the library to do so rather than the user, lets say, if the autoSave prop on the form is set to true.\n\njsx\n<Form model=\"user\" autoSave />\n//the onSubmit function would still receive the model \n//but only with the field which triggered the action\n\nA more extensible option could be providing an onChangeSubmit prop to each field. This might make it a little bit more useful to other usecases than autosaving forms\njsx\n<Form model=\"user\" autoSave>\n  <Control.text model=\"user.firstName\" onChangeSubmit={this.updateFirstName} />\n</Form>\n\nAnother thing to consider if going this route, is if the library should provide a debounce prop to use with the onChange or if that should be somehow be done in userland - maybe as a wrapper around each control?\nAnd finally, the caveat: I haven't used the library yet(!), so not sure if breaks some assumptions around the model concept as you might have envisioned. Sorry about that!\nThoughts? . @davidkpiano Just checking here, to see if you've had the chance to think about the two options above? Or if you had any other ideas for the API?. @davidkpiano Hm.. I was hoping to see this in v2. But I see your point about userland but it ends up being a lot of duplicating logic trying to implement something like onChangeSubmit which only submits that field. \nI feel like if the library offers API similar to what we discussed above, it might make it much cleaner to implement the rest in userland.\nCurious about your thoughts on providing API for those solutions - or are those also best solved in userland?. ",
    "greghawk": "@davidkpiano I was trying a use case where I wanted to delay the value when using a parser.  That way if i was doing a date for instance and replacing every two characters with a / it would work when backspacing. The debounce does not appear to work with the parse method.. I can.  Pretty simple though val + ' test'} model=\"user\"/>. Great! I can do that.  I had talked to you before about parsers/formatters and you mentioned race conditions. I think if  we can get debounce working on parsers things like currency, date and masking things may be possible with the right debounce setting. Also i noticed the docs mentioned that the parser prop has an optional \"previous\" param.  I don't see this ever getting hydrated and in the most recent build i don't see anything passing it either in the source code.. I had tried the 'deep' method but didn't seem to help.  Where does the name 'test' come in? My actual state is formModel as an array of steps. When I do classic redux connect with my state it is fine.  Just cannot get forms to see it. It does set the initialState which is [].  Do I need to set it to this?\nformModel: combineForms({formModel:formReducer}, 'formModel')\n. Keep in mind the formReducer in my code is my own custom reducer not the one in react-redux-form. @davidkpiano So this seems to be a state issue thing.  I just changed your stress test example to remove the initialState (set to []) and when i look in redux state the state never updates for the added rows.  How do i get react-redux-form to listen to state changes from my reducer? I can't seem to find the right combination . @davidkpiano Ok i may have just been being a little dumb.  The state doesn't update to the bundled state until you type in the form..... @davidkpiano I did! thanks! I wasn't realizing that with UpdateOn change that it wouldn't change the state until you typed somewhere.  I was expecting when the form loaded that it would be in state. I will try. It's a little tricky with the custom reducer that is modeled() and all.\nOn Apr 5, 2017, at 9:55 AM, David Khourshid notifications@github.com<mailto:notifications@github.com> wrote:\nCan you make a minimally reproducible test for this (using the codepen template)?\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHubhttps://github.com/davidkpiano/react-redux-form/issues/733#issuecomment-291868776, or mute the threadhttps://github.com/notifications/unsubscribe-auth/AE2tk5csmu938J0aADTfsoXbnt1Hljzvks5rs503gaJpZM4M0Ita.\n. @davidkpiano One thing that may be related and i am getting a state mutate on dispath for $forms issue as well is that I am using the reduxImmutableStateInvariant middleware. Is that a problem with using this library?. @davidkpiano Uncaught Error: A state mutation was detected inside a dispatch, in the path: forms.$form.value.formModel. Take a look at the reducer(s) handling the action {\"type\":\"@@router/LOCATION_CHANGE\",\"payload\":{\"pathname\":\"/personal/FirstName\",\"search\":\"\",\"hash\":\"\",\"state\":null,\"action\":\"PUSH\",\"key\":\"rnpclt\",\"query\":{},\"$searchBase\":{\"search\":\"\",\"searchBase\":\"\"}}}.. I am listening to react-router-redux for path changes and picking currently displayed steps (wizard style) . This is the model i am using.  It basically is a dynamically loaded json model.\n\nI read the url for the last segment of the path and that becomes the stepid. That then in turn looks up combined steps that should display with it.  . ```import {combineReducers} from 'redux';\nimport { routerReducer} from 'react-router-redux';\nimport initialStateReducer  from './initialStateReducer';\nimport offersReducer from './offerPageReducer';\nimport formReducer from './formReducer';\nimport {createForms} from 'react-redux-form';\nconst rootReducer = combineReducers({\n  initialState: initialStateReducer,\n  offerData: offersReducer,\n    ...createForms({formModel: formReducer}),\n  routing: routerReducer\n});\nexport default rootReducer;\n```\nformReducer from above\n```\nimport * as types from '../actions/formActionTypes';\nimport objectAssign from 'object-assign';\nexport default function formReducer(state = {formId: \"\", currentSteps: [], steps: [], buttonText: 'Continue'}, action) {\nswitch (action.type) {\n    case '@@router/LOCATION_CHANGE':\n      let segments = action.payload.pathname.split('/');\n      let currentSteps = [];\n      if (state.steps.length > 0)\n        currentSteps = getCombinedSteps(state.steps, segments[2]);\n      return objectAssign({}, state, {currentSteps: currentSteps, stepId: segments[2]});\n    case types.SET_FORM_STEP:\n      return objectAssign({}, state, {stepId: action.stepId});\n    case types.FORM_LOADING:\n      return objectAssign({}, state, {formId: action.formId});\n    case types.FORM_LOADED:\n      return objectAssign({}, state, {currentSteps: getCombinedSteps(action.steps, state.stepId), steps: action.steps});\n    case types.OUT_OF_WALLET: {\n      let mystate = Object.assign({}, state.steps);\n      mystate.steps.push(...action.formModel.steps);\n      return objectAssign({}, state, mystate);\n    }\n    case types.INTEL_DATA_COMPLETE:\n      return objectAssign({}, state,  action.filterCount);\n    default:\n      return state;\n  }\n}\nfunction getCombinedSteps(stepArray, startStepName) {\n  let currentSteps = [];\n  let startIndex = stepArray.findIndex((item) => item.name === startStepName);\nfor (const [index, step] of stepArray.entries()) {\n    if (index < startIndex)\n      continue;\n    currentSteps.push(step.name);\n    if (step.addnext === false) {\n      break;\n    }\n  }\n  return currentSteps;\n}\n```. I still get the uncontrolled component switching to controlled regardless of removing that middleware. As far as changing the model on url (history change) do you suggest a different method? I am having difficulty getting react-router to play nice with form models in a wizard concept. This is the action on my formReducer that is causing the issue. FirstName is hardcoded in this example\nexport function handleNextSteps(formModel) {\n  return function (dispatch) {\n    dispatch(push('/' + formModel.formId + '/FirstName'));\n  };\n}. So I need to read the Url for the stepId and then set that stepId in the model that the form uses in order to update what step is displayed.  Either way I am updating redux state as that is the state of the app at that url. What is your reducer doing that could be mutating state at the internal modeled copy?. I'll try history push but I need to react to it changing\n. Let's ignore that for now. I'll find another way.  What about the uncontrolled issue?. 1.8.1. Just tried. No dice. I am going to simplify my custom reducer.  I have other pieces in there that are not form elements and maybe that is confusing it.  Not sure what else to do\n. I hear what you\u2019re saying.  It does seem to be a common need in form development though.  Show one way store another.  I will try the custom component wrapper and see how it fares.  I\u2019ll think on the format property and get back.\nI was thinking the formatter was for controlling how the data looks like in the input and the parser is for storage in the store. It is a little different of a concept of what you are using a parser for.\nAngular has a standard way of doing this on its ngModel. See the section for parsers/formatters on this link. https://docs.angularjs.org/api/ng/type/ngModel.NgModelController\nFrom: David Khourshid [mailto:notifications@github.com]\nSent: Tuesday, April 11, 2017 11:06 PM\nTo: davidkpiano/react-redux-form react-redux-form@noreply.github.com\nCc: Hawk, Greg Greg.Hawk@lendingtree.com; Author author@noreply.github.com\nSubject: Re: [davidkpiano/react-redux-form] Formatters versus Parsers missing functionality (#745)\nThe fragile part of this is this: let's say you entered in $1000 and expected $1,000 to be the view value in a standard .\n\nThe parser needs to always convert 1000 to $1,000\nThe parser needs to also know that $1,000 converts to $1,000\nThe formatter needs to convert that $1,000 back to 1000 and send it back to the store.\n\nAnd let's say you press backspace - your parser needs to be smart enough to know that $1,00 should parse to $100 so that your formatter can pick it up again. I can go on but this gets into some tricky logic where, if it's not perfectly in sync, can end up in an infinite loop.\nI highly recommend creating a simple custom component for this instead, something like this:\nfunction parseCurrency(value) { / ... / }\nfunction formatCurrency(value) { / ... / }\nconst Currency = (props) => (\n<input\ntype=\"text\"\n\nvalue={formatCurrency(props.value)}\n\nonChange={e => props.onChange(parseCurrency(e.target.value))}\n\n/>\n);\n// rendered anywhere:\n\nThe great thing about the above example is that it's more explicit and clear than using parse and (a nonexistent) format. But I'm curious to see how a format prop would look like to you - if you can make a compelling case (with good examples), I'd be more than happy to add it in.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHubhttps://github.com/davidkpiano/react-redux-form/issues/745#issuecomment-293459544, or mute the threadhttps://github.com/notifications/unsubscribe-auth/AE2tk90slVwDPgGwCJZhidzbC9O93NlUks5rvD-ngaJpZM4M644c.\n. Here is a more clear article if you aren\u2019t familiar with angular\u2019s implementation. https://alexperry.io/angularjs/2014/12/10/parsers-and-formatters-angular.html\nFrom: David Khourshid [mailto:notifications@github.com]\nSent: Tuesday, April 11, 2017 11:06 PM\nTo: davidkpiano/react-redux-form react-redux-form@noreply.github.com\nCc: Hawk, Greg Greg.Hawk@lendingtree.com; Author author@noreply.github.com\nSubject: Re: [davidkpiano/react-redux-form] Formatters versus Parsers missing functionality (#745)\nThe fragile part of this is this: let's say you entered in $1000 and expected $1,000 to be the view value in a standard .\n\nThe parser needs to always convert 1000 to $1,000\nThe parser needs to also know that $1,000 converts to $1,000\nThe formatter needs to convert that $1,000 back to 1000 and send it back to the store.\n\nAnd let's say you press backspace - your parser needs to be smart enough to know that $1,00 should parse to $100 so that your formatter can pick it up again. I can go on but this gets into some tricky logic where, if it's not perfectly in sync, can end up in an infinite loop.\nI highly recommend creating a simple custom component for this instead, something like this:\nfunction parseCurrency(value) { / ... / }\nfunction formatCurrency(value) { / ... / }\nconst Currency = (props) => (\n<input\ntype=\"text\"\n\nvalue={formatCurrency(props.value)}\n\nonChange={e => props.onChange(parseCurrency(e.target.value))}\n\n/>\n);\n// rendered anywhere:\n\nThe great thing about the above example is that it's more explicit and clear than using parse and (a nonexistent) format. But I'm curious to see how a format prop would look like to you - if you can make a compelling case (with good examples), I'd be more than happy to add it in.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHubhttps://github.com/davidkpiano/react-redux-form/issues/745#issuecomment-293459544, or mute the threadhttps://github.com/notifications/unsubscribe-auth/AE2tk90slVwDPgGwCJZhidzbC9O93NlUks5rvD-ngaJpZM4M644c.\n. @davidkpiano I am trying the custom component but it doesn't seem to do anything with the model now? I am not quite sure how to use the custom component if I lose all the validators, model-state synch etc with this custom control.  Is there a production type example following  this pattern?. @davidkpiano I don't have a small example.  Can you tell me how the custom control is meant to work? It seems like it loses all the functionality of the standard controls. I'm at a loss as to how to use one.. Awesome!!!\nFrom: David Khourshid [mailto:notifications@github.com]\nSent: Tuesday, May 23, 2017 2:44 PM\nTo: davidkpiano/react-redux-form react-redux-form@noreply.github.com\nCc: Hawk, Greg Greg.Hawk@lendingtree.com; Author author@noreply.github.com\nSubject: Re: [davidkpiano/react-redux-form] Formatters versus Parsers missing functionality (#745)\nI'm actually going to implement formatters soon. I realize it's a necessary feature.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHubhttps://github.com/davidkpiano/react-redux-form/issues/745#issuecomment-303494656, or mute the threadhttps://github.com/notifications/unsubscribe-auth/AE2tkw1NyHt9aIJWRIOSY6Tzdw9Mum3vks5r8yj1gaJpZM4M644c.\n. @davidkpiano any movement on the formatters? I am running up against a wall soon.. @davidkpiano You're right. Let me try your example of above and see if can get it going. Will that custom control play nice with validations?. @davidkpiano Cool.  I am trying but the validation piece is not happy.  I'll look at masked input as well to see what they are doing.\nThis is what I've tried so far but I think it is trying to validate the formatted value even though redux is storing proper value:\nconst Formatter = (props) => (\n   props.onChange(() => {\n      return (e.target.value).replace(/\\D/g, '');\n    })}\n  />\n);\nconst TextControl = ({steps, step, formatter, type}) => {\nreturn (\n    \nformData.${step.name}}\n               component={formatter ? Formatter : null}\n               validators={getValidations(step.validation)}\n               formatter = {formatter}\n               asyncValidateOn=\"blur\"\n               updateOn=\"change\"\n               asyncValidators={getAsyncValidations(step.validation)}\n               validateOn=\"change\"\n               placeholder={step.placeholder}\n               type={(step.mask) ? \"password\" : type}\n               autoComplete={(step.mask) ? \"new-password\" : \"\"}\n               autoFocus={steps.length === 1 || (steps.length > 1 && steps[0].name === step.name)}\n               mapProps={{\n                 className: ({fieldValue}) => (fieldValue.valid || fieldValue.pristine || !fieldValue.touched)\n                   ? 'form-control'\n                   : 'form-control has-error'\n               }}/>\n      formData.${step.name}}\n                    component={(props) => {props}}\n                    mapProps={{\n                      fieldValue: (props) => props.fieldValue\n                    }}\n      />. @davidkpiano Here ya go!  http://codepen.io/ghawk/pen/QvYjmY. So there is no mechanism to denounce view value?\nOn May 14, 2017, at 5:47 PM, David Khourshid notifications@github.com<mailto:notifications@github.com> wrote:\nClosed #780https://github.com/davidkpiano/react-redux-form/issues/780.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHubhttps://github.com/davidkpiano/react-redux-form/issues/780#event-1081416939, or mute the threadhttps://github.com/notifications/unsubscribe-auth/AE2tk91rliKWLUYR3ZXxl766MbBd6Cisks5r53ZqgaJpZM4NWnP-.\n. It does if you type 1000 and want after about 300 ms to evaluate and add $ in front and comma after 1. Or type 2 digits and then add a / and then add a / again after 2 more digits like a date. Masking and formatting are common and not custom form needs as far as I've seen.\nOn May 14, 2017, at 11:35 PM, David Khourshid notifications@github.com<mailto:notifications@github.com> wrote:\nIt's not a use case that makes sense. Think about it - let's say you type the letters abcde in an input. If you debounced the view value, you'd see:\n\na\na\na\na\na\nabcde after 300 or so milliseconds\n\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHubhttps://github.com/davidkpiano/react-redux-form/issues/780#issuecomment-301368866, or mute the threadhttps://github.com/notifications/unsubscribe-auth/AE2tk2p1yXdfgy5L8_P3ojxATYcMOuQcks5r58gXgaJpZM4NWnP-.\n. I'm actually seeing on the 801 ms mentioned below this doesn't happen. My model value is set on dispatch changeaction but view value does not reflect.\nOn May 14, 2017, at 5:47 PM, David Khourshid notifications@github.com<mailto:notifications@github.com> wrote:\nThis is expected. parser is how the value ends up as a model value, not as a view value. That the control displays that value is a side-effect of this - it's just displaying the view value as it appears as a model value. This sounds like something you'd need to make a custom control for.\nHere's a timeline explanation for a debounced control:\n\n(0ms) Type foobar\n(1ms) foobar is shown as the view value\n(100ms) foobar still\n(800ms) view value parsed and saved to store as model value of foobar1234\n(801ms) control detects that view value doesn't match model value, so it updates the control\n(801ms) foobar1234 shown\n\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHubhttps://github.com/davidkpiano/react-redux-form/issues/780#issuecomment-301342263, or mute the threadhttps://github.com/notifications/unsubscribe-auth/AE2tk91rliKWLUYR3ZXxl766MbBd6Cisks5r53ZqgaJpZM4NWnP-.\n. @davidkpiano wow that was fast!. @davidkpiano How does this work if i want my sync validators to run on change and my async to run on change but only after the sync ones are valid?  This makes my async calls happen all the time now and they can be pricey.  Maybe add option for asyncValidateOn named  \"aftersync\"?. @davidkpiano I can. Just seemed that this modification changed how you were nicely waiting to fire async until sync was done previously.. I hear what your saying but I have a wizard like form with a continue button. I am fighting the enter key to continue and the blur versus when someone clicks continue. If it validated right when the local validation was good it would both not call expensive validation calls (3rd party) when there was not valid data and be ready before they could hit enter or click continue. As it is now one has to blur then click and then click again. I could disable button but it looks hacky and a similar angular form I am trying to replace handles it with ease.. I thought of trying that but I am unsure how to do that as I have component set to another component in order to support formatting which is slated as a coming enhancement.  I will attach my code file so you can see what I am getting at. AsyncOn is set to blur for now in code below.\nHow would I do if(value is valid)?  I don't have access to the field prop in that scope\n. Main control:\n<Control model={`formData.${step.name}`}\n               component={formatter ? FormattedControl : undefined}\n               {...formObj}\n               validators={getValidations(step.validation)}\n               asyncValidateOn=\"blur\"\n               asyncValidators={getAsyncValidations(step.validation)}\n               validateOn=\"change\"\n               placeholder={step.placeholder}\n               type={(step.mask) ? \"password\" : type}\n               autoComplete={(step.mask) ? \"new-password\" : \"\"}\n               autoFocus={steps.length === 1 || (steps.length > 1 && steps[0].name === step.name)}\n               mapProps={{\n                 className: ({fieldValue}) => (fieldValue.valid || fieldValue.pristine || !fieldValue.touched)\n                   ? 'form-control'\n                   : 'form-control has-error',\n                 value: (props) => props.viewValue\n               }}/>\nComponent referenced as component = {FormattedControl} above\n<input\n      type={props.type}\n      autoComplete={props.autoComplete}\n      autoFocus={props.autoFocus}\n      className={props.className}\n      placeholder={props.placeholder}\n      onBlur={e => props.onBlur(props.modelParser(e.target.value))}\n      value={props.formatter(props.value)}\n      onKeyPress={e => props.onKeyPress(props.modelParser(e.target.value))}\n      onFocus={e => props.onFocus(props.modelParser(e.target.value))}\n      //onKeyDown={e => props.onKeyDown(props.modelParser(e.target.value))}\n      onChange={e => props.onChange(props.modelParser(e.target.value))}\n    />. @leoalves  does (value is valid) work as coded? I thought that was just the actual typed viewValue? What I would need there was FieldValue.valid which is part of the redux store of $form which I don't have at that scope. Am i missing a way to get that as changeAction only has model and value\n. By the way... Thanks so much for you guys help!!!!\n. Love this platform\n. @davidkpiano @leoalves Got this wot work but seems really nasty.\nchangeAction={(model, value, {fieldValue}) => (dispatch, getState) => {\n                 dispatch(actions.change(model, value));\n                 if (step.validation.verification !== null && getState().forms.formData[step.name].valid) {\n                   dispatch(actions.asyncSetValidity(`formData.${step.name}`, getAsyncValidations(step.validation).verification))\n                 }\n               }}. @davidkpiano I got this to work except for the enter key issue.  It fires the rrf changeHandler in the source code and then loops my sync->async done loop again.  I tried various ways but cannot get ahold the the keypress in the changeaction nor can i prevent it inside of rrf on the enter key from happening.  This is the rather gruesome code I have mostly working.\n```\n           changeAction={(model, value, event) => (dispatch, getState) => {\n             dispatch(actions.change(model, value));\n             dispatch(actions.resetValidity(model, [\"verification\"]));\n             if (step.validation.verification !== null && getState().forms.formData[step.name].valid) {\n               dispatch(actions.setPending(model, true));\n               dispatch(actions.asyncSetValidity(model, (value, done) => getAsyncValidations(step.validation).verification(value).then(\n                 (response) => {\n                   dispatch(actions.setPending(model, false));\n                   dispatch(actions.setTouched(model));\n                   done({verification: response});\n                 })));\n             }\n           }}\n           onKeyPress={e => {\n             if (e.key === 'Enter') {\n               e.preventDefault();\n               formActions.handleNextSteps();\n             }\n           }}\n\n```\nthis is rrf code that is doing it.\n```\n      key: 'handleKeyPress',\n      value: function handleKeyPress(event) {\n        var onKeyPress = this.props.controlProps.onKeyPress;\n    if (onKeyPress) onKeyPress(event);\n\n    if (event.key === 'Enter') {\n      this.handleChange(event, true);\n    }\n  }\n\n```. @davidkpiano Sorry I did spam a bunch of info on this thread.  As a general thing for forms that may work but in my case I don't submit on enter.  I have a one or many questions at a time multi-step wizard type of form.  I only submit at the end of the wizard type process. There is a \"continue\" button on each page and then I accrue all the entered data in redux till I'm ready to submit to a backend.. Also I hacked my way out of having the changeaction fire on enter key from rrf.  You'll laugh...\nonKeyPress={(e) => {\n                 if (e.key === 'Enter') {\n                   e.currentTarget.blur();\n                   e.preventDefault();\n                   e.key='PHENTER'  //LOL\n                 }\n               }}. @davidkpiano So I am back in this loop again now.  I can't use the hack I have because if keypress happens quickly before onchange then when I validate I don't have async data yet.  What I am trying to do is have an async validation fire while the user is typing (after the data is valid).  I have tried this in the onchange handler but i end up with duplicate verification calls. . I'm not as i had to do some interesting work you guys helped me with on the onchange handler to fire async only when valid and also make everything work on the enter key (native browser submit). I tried a few days ago with newer lib and had some issues\n. @davidkpiano it is pretty much same issue but i can make a new one.  I tried 1.14.1 but when i set updateOn and asyncValidateOn to change then async runs on all keypress.  I really need and think others to would want it to run only after local validation is successful.  I can't do on blur as my product people want it to run after the field first goes valid.. also the characters sent to async are one character off. they are missing the last typed character right when the field goes local valid. If you type a zipcode it does every char except 5th one but then does the asyc call when you type in 6 characters and sends them\n. @davidkpiano I am having a similar issue and I'll make a separate report if it is not related.  I have an onsubmit handler for the form and if i have local validations and type an invalid character into the field after it is valid and immediately hit the enter key the onsubmit handler fires with the form as valid as the onchange handler has not yet been able to update the state of the field. Seems to be a race condition and i am thinking of setting pending or something in the onchange handler to see if it may prevent this behavior.\nI just checked and the data passed to submit is valid an doesn't contain the updated invalid data.\n. I figured out my issue!  I have debounce set to 250. Of course the onchange isn't happening yet. however it may make sense to make a change to the onsubmit behavior to be aware of debounce and not set the form as valid if there are pending debounces.  I know that may be tricky but thought I'd mention it.. will create now for easier documentation.. @davidkpiano  You already have this working right. I had to add a hack onkeypress in the past to prevent the onchange from happening on enter key. This was making it skip onchange when firing submit. I did this so onsubmit wouldn't cause a secondary 3rd party validator call and stay stuck.  I'll find if i can do another way.\n. @davidkpiano here\u2019s what I did so you can se if you want to do something similar. \nI am running async on change but only after local sync goes valid. This worked great except submit called on change again causing the enter key not to actually submit fully rather calling my async again since all my magic happens in onchangeaction. \nI now store a key in redux with the name of the model + \u201cverified\u201d as soon as I get a good async ack. Then when enter key and submit are fired the onchangeaction checks for the key and if the currently passed value are the same and then returns if so. \nThis covers when they make any changes to the value once it has gone async valid once as well. . @davidkpiano Here is my change action on a text control.  It is a bit busy but this should illustrate my comment above. the validation named verification is my async.\n             changeAction={(model, value, event) => (dispatch, getState) => {\n               dispatch(actions.change(model, value));\n               if (step.validation.verification !== null) {\n                 if (getState().formState[`${step.attributeid}Verified`] !== value || getState().forms.formData[step.attributeid].validity.verification === false)\n                   dispatch(actions.resetValidity(model, ['verification']));\n                 if (getState().forms.formData[step.attributeid].valid && value.length > 0 && (getState().forms.formData[step.attributeid].validity.verification === undefined || !getState().forms.formData[step.attributeid].validity.verification)) {\n                   dispatch(actions.setPending(model, true));\n                   dispatch(actions.asyncSetValidity(model, (value, done) => getAsyncValidations(step.validation).verification(value).then(\n                     (response) => {\n                       if (response && step.actionsafterchange.length > 0)\n                         dispatch(runActionsAfterStep(step)).then(() => {\n                           dispatch(actions.setPending(model, false));\n                           dispatch(actions.setTouched(model));\n                           done(false);\n                           dispatch(changeFormState(objectMapper.setKeyValue({}, `${step.attributeid}Verified`, value)));\n                           dispatch(actions.setValidity(model, {verification: response}, {merge: true}));\n                         }).catch((err) => {\n                           dispatch(actions.setPending(model, false));\n                           dispatch(actions.setTouched(model));\n                           done({verification: false});\n                         });\n                       else {\n                         dispatch(actions.setPending(model, false));\n                         dispatch(actions.setTouched(model));\n                         done(false);\n                         if (response)\n                           dispatch(changeFormState(objectMapper.setKeyValue({}, `${step.attributeid}Verified`, value)));\n                         dispatch(actions.setValidity(model, {verification: response}, {merge: true}));\n                       }\n                     })));\n                 }\n               }\n             }}. Did you look in rrf source to see if it is exported?\n\nOn Nov 3, 2017, at 4:23 AM, L\u00e1szl\u00f3 Ill\u00e9s notifications@github.com<mailto:notifications@github.com> wrote:\nHi @davidkpianohttps://github.com/davidkpiano , I know it's been a while since this has been resolved, but there is something I have to add. I use Webstorm IDE for development, and If I try to use this isValid utility function like in the documentation: import {isValid} from 'react-redux-form', Webstorm says 'cannot resolve symbol isValid'. However, it seems to work in development. But it turns out it fails to work in production, an error raises on the console: index.js:125 Uncaught TypeError: n.i(...) is not a function. Do you have any idea what can cause this?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHubhttps://github.com/davidkpiano/react-redux-form/issues/945#issuecomment-341643548, or mute the threadhttps://github.com/notifications/unsubscribe-auth/AE2tk5UmEu0gq4YliVjzp-4huRgGDngZks5sys1rgaJpZM4PYujP.\n. Just one checked. I tried defaultChecked and checked and I got errors.\ni am seeing this issue.  It seems to be firing onchange as well.  All i want is an initial value\n\"RadioList contains an input of type radio with both checked and defaultChecked props\"\n. @davidkpiano  I worked it out with some tricks. Will do. Owe you a few snippets\n. @davidkpiano  here ya go. I am submitting onchange normally.  What i did was check if there was an event or not when onchange fires.  this prevents the background fire of onchange from advancing my form.\n (dispatch, getState) => {\n                  if (getState().forms.formData[step.attributeid]!==undefined && getState().forms.formData[step.attributeid].pristine === false && event===undefined) {\n                    return;\n                  }\n                  let enums = getState().formDefinition.steps.find(step => step.attributeid === model.split('.')[1]).enumeration;\n                  let modify = enums.find(item =>\n                    item.value == value && item.actionAttribute !== undefined\n                  );\n                  if (modify !== undefined) {\n                    let currVal = getState().formData[modify.actionAttribute];\n                    model = formData.${modify.actionAttribute};\n                    value = (modify.action != undefined) ? transform(modify.action, getState().formData[modify.actionAttribute], modify.actionValue).toString() : currVal || value;\n                  }\n                  dispatch(actions.change(model, value));\n                  if (event) {\n                    handleNext();\n                  }\n                }}\n. @davidkpiano I may not have been clear or I am not understanding your meaning. Let me explain what i am trying to do:\ncreate a div that wraps a Control but is aware of fieldValue. i.e valid, pending etc.  and use that meaning to add a class to the wrapper div when invalid for instance.  without passing props way down though my components which most are stateless i can't seem to access this.  I need this wrapper for attachment of pseudo classes.. @davidkpiano  fixed this via comments on https://github.com/davidkpiano/react-redux-form/issues/771. @davidkpiano so how do I focus on the desired option since defaultchecked and whatnot doesn\u2019t work right and is discouraged?. @davidkpiano Thanks! Totally forgot about that option.. @brycesenz I'm doing something very similar now myself via the change action.  It is true that you have to marry a parser and formatter together. Perhaps if a formatter is a prop then a parser is required. Might fill the potential caveat.. @davidkpiano you see this yet?. You have to open the web debugger like chrome dev tools when doing the codepen and you will see it. I can see it every time. Make sure you type in the first box and hit ENTER\n. \n. @davidkpiano I only did that for brevity.  My actual code does have a function.  What is happening when i stepped into rrf is that it sends a batch action and one of the actions is a string representing the typed in value of the input box.  That is not an object and fails the redux test isObject\n. From within a control.text               \nchangeAction={(model, value) => (dispatch) => {\n                 dispatch(actions.change(model, value));\n                 dispatch(actions.resetValidity(model, ['verification']));\n               }}. I can look in to a PR.  Just wanted to confirm I wasn't doing something unexpected first.  pretty vanilla really. @davidkpiano Awesome idea David! That actually solved a couple of problems for me. Thanks!!. For anyone that this might effect I found at least one way around it.  Just do this.\nmapProps={{\n                 maxLength: ({viewValue, modelValue}) => YOURLENGTHPROP + (viewValue && modelValue ? (viewValue.length - modelValue.length) : 0)\n               }}\n. @davidkpiano  I ended up having to add this.  Not sure where all in the factory to add this.\nonChange={e => {\n                 //this only exists for old droid issue\n                 if (typeof navigator !== 'undefined' && navigator.userAgent.match(/Android/i)) {\n                   setTimeout(() => {\n                     e.target.selectionStart = e.target.value.length;\n                     e.target.selectionEnd = e.target.value.length;\n                   }, 0);\n                 }\n               }\n               }. ",
    "avonian": "Thank you so much!. ",
    "l1br3": "Exactly same issue with createFormReducer from other page of wiki. my pleasure. I've tried something like in #596 but it does not works for asyncValidation.\nMaybe there is another workaround ?. Just tried it right now and I still have the problem. \nThanks for your help. Easiest workaround right now is to trigger validation also on change but it is not what I would prefer for production :s \n. Works perfectly. Not very elegant but efficient, thanks for your solution.\nIf people has the same problem, there is my code without unecessary information.\nFeel free to close the issue if you consider it as solved or left it open if you consider this need to be changed/fixed.\n```javascript\n@connect()\nexport default class SignInForm extends Component {\n  constructor(props){\n    super(props)\n    this.resetError = this.resetError.bind(this);\n  }\nresetError(event){\n    const field = event.target.name\n    this.props.dispatch(form_actions.resetValidity(field), ['available'])\n  }\nrender() {\n    return (\n      \nUsername\n actions.checkUsernameAvailability(val).then(res => done(res))\n            }}\n            onChange = {this.resetError}\n          />\n           ${val} is already used. Please choose another username}}  wrapper=\"span\"/>\n      \n    )\n  }\n}\n```\n. Hi and thanks for your answer. \nUnfotunately I cannot make it work this way too. . I don't know what I changed but now its working.\nThis gist I made won't work correctly as I cannot make recaptcha work on ESnextbin but you can see that the message is displayed.\nIt's also works on my website.\nThanks for your help and sorry for this issue that should have been on SO instead of here :s \n. @davidkpiano ignite is not needed to create the crash, a new classic react native app do the same. \n. Could it be caused because RRF uses features not available in expo ?. Well, sometimes I'm clever, sometimes I'm the dumbest person on earth. The message was quite explicit.\nThis kind of errors cause air crashes...\nnpm i -S react-dom@16.0.0-alpha.12. Thanks @davidkpiano, can push on npm @1.6.11 ?. ",
    "jinty": "I can confirm that I hit this bug with react-redux 5.0.1. Downgrading to 4.4.6 resolved it.. ",
    "jimbolla": "What about 5.0.2? Should be fixed. NM. It hasn't been merged in yet. Sorry.. ",
    "FelixHenninger": "Hi everybody,\na huge and heartfelt thank-you for all of your effort with this, and sorry for the late reply! I had totally lost track of this, but would like to report that this issue (at least in my demo) has indeed been resolved with the latest react-redux version. I'm closing the issue for now, hoping that that is ok (please reopen otherwise).\nI'm excited to get back to react-redux-form in the coming weeks, and am particularly looking forward to integrating the new debouncing feature!\nAll the very best, and thanks again,\n-Felix. Thanks a lot for this suggestion! (and a very happy new year!) Indeed I hadn't tried that, but I've updated the online example so that the internal dispatch can be tested easily and it still doesn't seem to work.\nPoking around in the form internals a bit, I noticed that the connected Form component in React's component tree looks unexpected after updating througth the form dispatch method: The changed values are stored in an entry with an empty key. Might this be part of the solution?. Ah! I figured it out: By prepending 'local' to every model id, the changes get propagated correctly. So if I use the following action/dispatch combination ...\nthis.formDispatch(actions.change('local.title', 'I just changed via the form\\'s dispatch method!')\n... instead of just targeting .title, everything works perfectly. This is fantastic, thanks for pointing me in the correct direction! I'm unsure whether this is intended behavior, though?. Awesome, thank you again for your excellent work on the library! I'd offer to help with the docs, but I'm not sure I know the code well enough. Hope that day will come, though!\n(closing the issue for now, please feel free to reopen if, for example, you'd like to track the doc changes). Hi @davidkpiano, thanks for the super-quick response! If there is anything I can do to help with this, do let me know, I'd be glad to assist.\nI've noticed that debouncing is not covered in the docs, would you like me to draft a brief section? (I'll need until the end of the week to get around to this, but I'd be happy to give it a try. This would go in the Control component API docs, right?). That was super-quick, thanks a lot!. Btw., if you have a moment, can you spot why the example in the CodePen isn't flushing? I've spent hours today trying to figure out why, but I can't spot what's going on -- possibly there's another bug lurking somewhere.. Thanks a lot, that would be great! I've tried to replicate the bug inside my app (where I destroy LocalForms regularly), but things seem to work perfectly there (there is some weirdness going on with an action getting lost when I destroy a form with pending changes, but that might my mistake). I'll see if I can pin this down, but I probably don't know enough about RRF internals.. Just a brief update: This seems to persist with version 1.12.0. Slightly extending the basic pen linked above, it appears that the onChange handler (line 45, cf. also console output) is being called correctly when the LocalForm is torn down, so flushing actually works, but the value that is passed to the handler is not up-to-date.\nWould you like me to create a new issue around this? I'm somewhat hesitant to do this, as I can't rule out that I'm making a stupid mistake somewhere, but I intuit that this might be worth investigating. Thanks again for your effort and support!. Ok, I've put all information in #830 . I'd love to figure this one out!. Ok, so I ran the pen again and noticed that now, the flushing doesn't work. I could swear I saw it running earlier :-/ . \nSo, to update this: The bug still persists, but this shifts it to a slightly different level. Also, it is now visible that onChange is called when the form is initially shown \u2014 I'm not sure whether this is intended behavior?. ",
    "augustincouette": "Yes its works fine. . ",
    "fidiego": "@davidkpiano \nWRT:\n\nOn second thought, would it make sense for async validity to automatically be reset when a field changes?\n\nI think so. I'm having the same problem as the original author. I think it would make sense for the validity to be reset on change.. ",
    "tmcdonnell87": "Sorry, to clarify, I was not able to get ESNextbin working with readt-redux-form/immutable, even well enough to just render the form. \nYou can check out the following: https://esnextb.in/?gist=97d0c044a2f119de9993d1a6274a3639 (https://gist.github.com/tmcdonnell87/97d0c044a2f119de9993d1a6274a3639)\nAdding the line import { Control, Form } from 'react-redux-form/immutable'; causes ESNextbin to throw the following error: \nimport { createModeler } from './reducers/model-reducer';\n^\nParseError: 'import' and 'export' may appear only with 'sourceType: module'\n. That works for you in ESNextbin? I copied and pasted that directly and it's still erroring\n\n. @weichenghsu I ended up using a LocalForm for that particular use case so didn't spend more time on it. Were you able to reproduce in a sandbox?. Seemed like a hack, but it worked. Can't say it's the best approach. Also not clear if it would fix the ESNextbin issue. . ",
    "weichenghsu": "any update? i had the same problem as you have. ",
    "karolbarkowski": "Aaah, the missing piece. Thank you for such quick answer. It's all working as expected now.. ",
    "aaronmagi": "Hi @davidkpiano \nThe more I ended up using the multiple errors tags, one for each field they actually seemed to work ok I just thought it would be nice to be able to setup a grouping of field errors in a single tag.  \nI think after working with the multiple error tags its not such a big deal.\nThanks or the quick reply\n. 1.2.2.  I just reran the test on 1.5.2 and it works.  Thank you. ",
    "kabbi": "There is definitely some problem with actions.reset() not resetting the form state properly. I have reset action on componentDidMount, and it doesn't clear deep dynamic objects. I'll try to reproduce this in simple example.\nThis seems to cause a crash when I try to actions.resetValidity('form'), with the following stack trace:\nicepick.js:143 Uncaught TypeError: Cannot read property 'valid' of null\n    at Object.assoc (bundle.js)\n    at bundle.js\n    at Array.reduce (native)\n    at singleAssign (bundle.js)\n    at Array.reduce (native)\n    at Object.assign (bundle.js)\n    at updateSubField (update-sub-fields.js:45)\n    at bundle.js\n    at Array.forEach (native)\n    at bundle.js. Here is the minimal gist for esnextb.in I could reproduce it with: https://gist.github.com/kabbi/26409b7d818562ddce5c63996709d41f. It would, if all the other places cover this case. I found one that also seems to expect objects:\nhttps://github.com/davidkpiano/react-redux-form/blob/master/src/reducers/form-actions-reducer.js#L23\n. I have several more to come, I've just decided to split them into several PRs. I'm building complex forms with your library, and I'm finding quite a lot of corner-cases :)\nThanks for merging.. The intermediate component you've created, DefaultConnectedControl, does not know anything about contexts that are used by resolveModel. So we can't check if it is updated, and restrictive shouldComponentUpdate implementation would block the context propagation, leaving Controls with an old model value.\nSome kind of related discussion can be found here: https://github.com/facebook/react/issues/2517.\nI can declare contextTypes on DefaultConnectedContol though, and then check if they've updated in shouldComponentUpdate. But it seems hacky for thic component to know anything about context props used in resolveModel.. I'll try to make a PR a bit later. I'm not entirely sure right now though why this check was there in the first place.. Oh, I didn't notice the case 'validate' line. That's trivial then. Should I add a testcase to ensure that each intent type is cleared correctly?. ",
    "baffleinc": "Don't resist the thunk brian. The thunk is inevitable. I was in the same position however it's not worth the effort trying to push the RRF square peg into the saga round hole - at least not on a deadline.\nThey live side by side just fine. As a side note - would be awesome if RRF had a saga version. . ",
    "ianmclean2011": "I'm sorry for the false issue. It turned out to be rendering of spaces in HTML, and the spaces collapsing down to one space. Love the project!. ",
    "hoangtrucit": "@brianleonard15 i have same issue, how to do fix this problem ?. thanks @brianleonard15 , i have installed lastest version and use \nimport {} from react-redux-form/lib/immutable but i don't fix this issue. I'm using create-react-app\n. This is log error\nError in ./~/react-redux-form/src/immutable.js\nModule parse failed: /Users/tructran/react-project/react-nv-client/node_modules/react-redux-form/src/immutable.js Unexpected token (73:2)\nYou may need an appropriate loader to handle this file type.\nSyntaxError: Unexpected token (73:2)\n @ ./src/redux/reducers/index.js 15:18-59. ",
    "danilotorrisi": "I'm having the same issues here, using only react-redux-form/lib/immutable but I still get this:\n```\nERROR in ./~/react-redux-form/src/immutable.js\nModule parse failed: /Users/.../node_modules/react-redux-form/src/immutable.js Unexpected token (73:2)\nYou may need an appropriate loader to handle this file type.\nSyntaxError: Unexpected token (73:2)\n@ ./~/react-redux-form/lib/immutable.js 56:17-37\n```. Unfortunately the repo is private :\\\nFound the issue btw, the problem was the webpack configuration ( resolver.modulesDirectories ) that contained the 'src' folder.. ",
    "pjatacsukb": "Yep thats what I want to achive. I just kinda confused how I can create a reducer that has both of the username and password in its state. Im following the documentation, the pieces is not coming together for me how I can achive that. Now my \"customReducer\" has only the action, the state is an empty object. . Thank you for making things clear with a good example!. ",
    "redguardtoo": "check https://github.com/redguardtoo/react-redux-form-sample README and it's latest commit.. ",
    "OrbX": "thanks a lot. ",
    "GarrisonD": "With Errors component you can specify errors container:\nhtml\n<Errors ... wrapper={({ children }) => <div className=\"errors-container\">{children}</div>} />\nAnd after that you will have something like this:\nhtml\n<div class=\"errors-container\">\n  <span>Email can't be blank!</span>\n  <span>It doesn't look like a valid email!</span>\n  <span>... more spans with error messages ...</span>\n</div>\nAnd then you need to add this CSS snippet in order to hide all spans with error messages per each <div class=\"errors-container\"> except the first one:\ncss\n.errors-container * ~ * {\n  display: none;\n}\n@vkurlyan I hope it helps you!\nP. S. I know my English is poor \ud83d\ude04  but I hope you understand what I wrote above.. And if you add console.log to form validators function, it will print nothing when you change input's value to valid one or submit the form. So it looks like this function isn't invoked at all.. I would like to help you with solving this and other issues, but unfortunately I can't understand how to debug it \ud83d\ude22 . @davidkpiano Thank you for your fast fix.\nBut when I install react-redux-from package via npm install <git-repository>, then webpack tells me that there is no react-redux-form package.\nAnd really there is no lib directory in node_modules/react-redux-form.\nHow can I fix this?. I used yarn add react-redux-form in order to install the latest version of react-redux-form module.\nVersion 1.7.0 was installed and there were not last fixes.. Sorry, everything seems to be OK now. \ud83d\udc4d . ",
    "kostik-noir": "@davidkpiano \nthanks for the answer. ",
    "alvinthen": "The behaviour of LocalForm is now as expected, only with one small warning from React\nWarning: Unknown prop `storeSubscription` on <form> tag. Remove this prop from the element. For details, see https://fb.me/react-unknown-prop. Thanks for the reply, it works on codepen, see the updated codepen\nhttps://codepen.io/anon/pen/qRGapp\nI'm using the same UserForm component as below, however it doesn't work on my app, I wonder what went wrong. Running on rrf@1.5.5\nes6\nexport default function LoginForm(props: Props) {\n  return (\n    <LocalForm\n      className=\"Login-container\"\n      model=\"loginForm\"\n      initialState={{ email: '', password: '' }}\n    >\n      <div className=\"Login-input-group\">\n        <Control\n          required\n          model=\".email\"\n          type=\"email\"\n          placeholder=\"Email\"\n          validators={{ isEmail: val => !!val.length }}\n        />\n        <Errors\n          className=\"popover-bottom\"\n          model=\".email\"\n          show=\"touched\"\n          messages={{ isEmail: 'Invalid email address' }}\n        />\n      </div>\n      <div className=\"Login-input-group Login-password-group\">\n        <Control\n          required\n          model=\".password\"\n          type=\"password\"\n          placeholder=\"Password\"\n          validators={{ required: val => !!val.length }}\n        />\n        <Errors\n          className=\"popover-bottom\"\n          model=\".password\"\n          show=\"touched\"\n          messages={{ required: 'Password is required' }}\n        />\n      </div>\n      <Control.button\n        className=\"Login-button\"\n        model=\"loginForm\"\n        type=\"submit\"\n        disabled={{ valid: false }}\n      >\n        Log In\n      </Control.button>\n    </LocalForm>\n  );\n}\nFWIW, from React Chrome tools, the modelValue and formValue remain unchanged despite typing on the text fields and blurring.\nBtw, I'm not sure if this question suits here, I'll switch to stackoverflow if it does't.. After trying to debug my code and exploring the issues here, it's totally related to #592 \nClosing this. Thanks for the help. We just have to wait then. Thanks for the amazing library \ud83d\ude0a\nOn Sun, 19 Feb 2017 at 02:31, David Khourshid notifications@github.com\nwrote:\n\nYeah, the fix is already in react-redux - a new version just hasn't been\nreleased yet. \ud83d\ude1e\n\u2014\nYou are receiving this because you modified the open/close state.\nReply to this email directly, view it on GitHub\nhttps://github.com/davidkpiano/react-redux-form/issues/671#issuecomment-280865382,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAvHlYMBL5dN8JiZ5mCezPAoe-qldi6gks5rdzkegaJpZM4MEcFK\n.\n. It's working nicely now, thanks!. \n",
    "thomasboyt": "Oh, I didn't realize you could just pass onChange through to a <Control.select /> (or, in my specific case, a <Field /> that wraps a <select />). Is that explicitly documented somewhere I missed?\nThis handler seems to work :)\njs\n    handleCountryChange(evt) {\n        const newCountry = evt.target.value;\n        const newStates = getStatesOrProvincesForCountry(newCountry);\n        this.props.dispatch(actions.change('forms.shippingAddressForm.stateOrProvince', newStates[0].value));\n    }. @davidkpiano I believe so. I'm not 100% convinced that \"sync\" and \"async\" are the right concepts for this - I guess in my head it's more \"submission state\" rather than \"async state,\" but maybe I'm just overthinking things. Whatever the terminology, exposing \"sync validity\" seems like the right move.. As of v1.10, <Control.text> now has some special properties around how value is handled (https://github.com/davidkpiano/react-redux-form/commit/85799170bf432a4fd84981784c6a0ebf1ffe775b) to prevent React warnings on undefined form values. It'd be great if there were Control.email and Control.password controls that used this same logic.\nfwiw, my current workaround to use Control.text as type=\"email\" or type=\"password\" looks like:\n```\nconst PasswordInput = (props) => ;\nconst PasswordField = (props) => (\n  \n);\n``. fwiw, can +1 that this was a really big surprise. In fact, this seems to directly contradict the docs for thecomponentprop (http://davidkpiano.github.io/react-redux-form/docs/api/Control.html#component) _and_ the custom controls doc (http://davidkpiano.github.io/react-redux-form/docs/guides/custom-controls.html), which both clearly state that you should be able to expect that event handlers are implicitly bound for plain` (which is no longer true).\nReplacing with <Control.text> seems to work fine, so thank you for that recommendation :). ",
    "slsriehl": "I can't save my example, getting a bug with esnextb.in, edit my gist is now producing output, working code below /edit and the syntax is linting fine.  Not sure if it's me or esnext.  Here's the minimally reproducible example I wrote, hopefully you can paste it into esnextb.in and see what you see.\nhtml: added to body\n<div id=\"app\"></div>\nreact:\n```\n// write ES2015 code and import modules from npm\n// and then press \"Execute\" to run your program\nconst React = require('react');\nconst ReactDOM = require('react-dom');\nconst {connect, Provider} = require('react-redux');\nconst {Router, Route, browserHistory} = require(\"react-router\");\nconst {Control, Form, actions, combineForms} = require('react-redux-form');\nconst axios = require('axios');\nconst {createStore, combineReducers} = require('redux');\nlet Detail = React.createClass({\n  _submitNotesForm: function(input) {\n    console.log(input);\n    axios.post(input._workNoteForm.note)\n    .then(function(data) {\n      console.log(data);\n      () => actions.reset(_workNoteForm);\n      //also tried \n      //() => actions.reset('_workNoteForm');\n        //(_workNoteForm) => actions.reset(_workNoteForm);\n        //() => actions.reset('_workNoteForm.note');\n      //() => actions.reset('reactReduxForm._workNoteForm');\n      //() => actions.change('reactReduxForm._workNoteForm.note', null);\n      //() => actions.change('_workNoteForm.note', null);\n      //() => actions.change('_workNoteForm', {note: null});\n    });\n  },\n  _notesForm: function() {\n    return(\n      container-4-notes}>\n        notes\nnote} \n          model=\"_workNoteForm\"\n          className=\"form-work\"\n          onSubmit={(_workNoteForm) => this._submitNotesForm(_workNoteForm)}\n        >\n          \n\n            save note\n          \n\n          {/ end container-4-xxx-notes /}\n      \n    );\n  }, \n  render: function() {\n    return (\n      \n        {this._notesForm()}\n      \n    );\n  }\n});\nconst reducers = {\n  _workNoteForm: combineForms({\n        _workNoteForm: {note: null}\n    }),\n};\nconst reducer = combineReducers(reducers);\nconst store = createStore(reducer);\n// function mapStateToProps(store) {\n//   return {\n//   };\n// }\nReactDOM.render(, document.getElementById(\"app\"));\n```. Got it!  For those who stumble across this, the solution that worked with the above code was store.dispatch(actions.reset('_workNoteForm')).. ",
    "jgentes": "Sure, here's a relatively simple form that has this error. Note that the error only occurs when I submit the form:\n```jsx\nrender() {\nconst {addFlow, form, deleteFlowAlert, currentUser, isPublic} = this.props;\n\nif ($('#addFlowForm').length) $('#addFlowForm').parsley();\n\nreturn (\n\n  <Modal\n    show={addFlow}\n    backdrop='static'\n    onHide={() => this.props.dispatch(toggleModal(false))}>\n    <Modal.Header>\n      <Modal.Title>{form.flowUuid ? 'Edit' : 'Add'} Flow</Modal.Title>\n      <span className=\"icon-close modal-close\" onClick={() => this.props.dispatch(toggleModal(false))}/>\n    </Modal.Header>\n    <Modal.Body>\n\n      <div className=\"panel\">\n        <div className=\"panel-body\">\n          <Form model=\"addFlowForm\"\n                id=\"addFlowForm\"\n                data-parsley-validate\n                onSubmit={() => this.submitForm()}\n                className=\"mb-lg\">\n\n            <Control.input model=\".flowUuid\" value={form.flowUuid} hidden/>\n\n            <div className=\"form-group has-feedback\">\n              <label className=\"text-bold\"><h4>Flow Name</h4></label>\n              <Control.input model=\".flowName\"\n                             autoFocus\n                             required\n                             defaultValue={form.flowName}\n                             autoComplete=\"off\"\n                             className=\"form-control input-lg\"\n                             placeholder=\"Enter a name for this flow\"/>\n              <span className=\"form-control-feedback text-muted\"/>\n            </div>\n          </Form>\n        </div>\n        { currentUser.isSuper && form.flowUuid ?\n          <div className=\"form-group has-feedback\" style={{paddingLeft: 15, marginTop: '-10px'}}>\n            <div style={{display: 'inline-block', verticalAlign: 'super'}}>\n              <h4>Make this flow public?</h4>\n            </div>\n            <div style={{display: 'inline-block', marginLeft: 10}}>\n              <Toggle\n                onChange={() => this.props.dispatch(togglePublic(!isPublic))}\n                defaultChecked={isPublic}\n                name='public'\n              />\n            </div>\n          </div>\n\n          : ''\n\n        }\n      </div>\n    </Modal.Body>\n    <Modal.Footer>\n      <div className=\"pull-right\">\n        <Button onClick={() => this.props.dispatch(toggleModal(false))}>Cancel</Button>\n        <Button bsStyle=\"info\" style={{marginLeft: 10}} type=\"submit\" form=\"addFlowForm\">{form.flowUuid ? 'Update' : 'Add'} Flow</Button>\n      </div>\n      <div className=\"pull-left\">\n        <Button bsStyle=\"danger\" className={form.flowUuid ? '' : 'hidden'}\n                onClick={() => this.deleteAlert(form.flowUuid)}>Delete</Button>\n        {deleteFlowAlert}\n      </div>\n    </Modal.Footer>\n  </Modal>\n\n);\n\n}\n```. Correction, I get two errors. The first here is when I open the modal, and the second is when I enter something into the input field:\n```\nApp.jsx:79 Warning: Control contains an input of type undefined with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://fb.me/react-controlled-components\nApp.jsx:79 Warning: Control is changing a controlled input of type undefined to be uncontrolled. Input elements should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://fb.me/react-controlled-components\n``. Line 79 isorgError.apply(console, [message]);`\n```\nrenderWithHotReload(Routes);\nif (module.hot) {\n  /*\n   * Warning from React Router, caused by react-hot-loader.\n   * The warning can be safely ignored, so filter it from the console.\n   * Otherwise you'll see it every time something changes.\n   * See https://github.com/gaearon/react-hot-loader/issues/298\n   /\n  const orgError = console.error; // eslint-disable-line no-console\n  console.error = (message) => { // eslint-disable-line no-console\n    if (message && message.indexOf('You cannot change ;') === -1) {\n      // Log the error as normally\n      orgError.apply(console, [message]);\n    }\n  };\nmodule.hot.accept('./Routes', () => {\n    const Reload = require('./Routes').default;\n    renderWithHotReload(Reload);\n  });\n}\n```. Here's the full stack:\nconsole.error   @   App.jsx:79\nprintWarning    @   warning.js:36\nwarning @   warning.js:60\nmountWrapper    @   ReactDOMInput.js:105\nmountComponent  @   ReactDOMComponent.js:426\nmountComponent  @   ReactReconciler.js:46\nperformInitialMount @   ReactCompositeComponent.js:371\nmountComponent  @   ReactCompositeComponent.js:258\nmountComponent  @   ReactReconciler.js:46\nperformInitialMount @   ReactCompositeComponent.js:371\nmountComponent  @   ReactCompositeComponent.js:258\nmountComponent  @   ReactReconciler.js:46\nperformInitialMount @   ReactCompositeComponent.js:371\nmountComponent  @   ReactCompositeComponent.js:258\nmountComponent  @   ReactReconciler.js:46\nperformInitialMount @   ReactCompositeComponent.js:371\nmountComponent  @   ReactCompositeComponent.js:258\nmountComponent  @   ReactReconciler.js:46\nmountChildren   @   ReactMultiChild.js:238\n_createInitialChildren  @   ReactDOMComponent.js:697\nmountComponent  @   ReactDOMComponent.js:516\nmountComponent  @   ReactReconciler.js:46\nmountChildren   @   ReactMultiChild.js:238\n_createInitialChildren  @   ReactDOMComponent.js:697\nmountComponent  @   ReactDOMComponent.js:516\nmountComponent  @   ReactReconciler.js:46\nperformInitialMount @   ReactCompositeComponent.js:371\nmountComponent  @   ReactCompositeComponent.js:258\nmountComponent  @   ReactReconciler.js:46\nperformInitialMount @   ReactCompositeComponent.js:371\nmountComponent  @   ReactCompositeComponent.js:258\nmountComponent  @   ReactReconciler.js:46\nmountChildren   @   ReactMultiChild.js:238\n_createInitialChildren  @   ReactDOMComponent.js:697\nmountComponent  @   ReactDOMComponent.js:516\nmountComponent  @   ReactReconciler.js:46\nmountChildren   @   ReactMultiChild.js:238\n_createInitialChildren  @   ReactDOMComponent.js:697\nmountComponent  @   ReactDOMComponent.js:516\nmountComponent  @   ReactReconciler.js:46\nmountChildren   @   ReactMultiChild.js:238\n_createInitialChildren  @   ReactDOMComponent.js:697\nmountComponent  @   ReactDOMComponent.js:516\nmountComponent  @   ReactReconciler.js:46\nperformInitialMount @   ReactCompositeComponent.js:371\nmountComponent  @   ReactCompositeComponent.js:258\nmountComponent  @   ReactReconciler.js:46\nmountChildren   @   ReactMultiChild.js:238\n_createInitialChildren  @   ReactDOMComponent.js:697\nmountComponent  @   ReactDOMComponent.js:516\nmountComponent  @   ReactReconciler.js:46\nmountChildren   @   ReactMultiChild.js:238\n_createInitialChildren  @   ReactDOMComponent.js:697\nmountComponent  @   ReactDOMComponent.js:516\nmountComponent  @   ReactReconciler.js:46\nmountChildren   @   ReactMultiChild.js:238\n_createInitialChildren  @   ReactDOMComponent.js:697\nmountComponent  @   ReactDOMComponent.js:516\nmountComponent  @   ReactReconciler.js:46\nperformInitialMount @   ReactCompositeComponent.js:371\nmountComponent  @   ReactCompositeComponent.js:258\nmountComponent  @   ReactReconciler.js:46\nperformInitialMount @   ReactCompositeComponent.js:371\nmountComponent  @   ReactCompositeComponent.js:258\nmountComponent  @   ReactReconciler.js:46\nperformInitialMount @   ReactCompositeComponent.js:371\nmountComponent  @   ReactCompositeComponent.js:258\nmountComponent  @   ReactReconciler.js:46\nmountChildren   @   ReactMultiChild.js:238\n_createInitialChildren  @   ReactDOMComponent.js:697\nmountComponent  @   ReactDOMComponent.js:516\nmountComponent  @   ReactReconciler.js:46\nperformInitialMount @   ReactCompositeComponent.js:371\nmountComponent  @   ReactCompositeComponent.js:258\nmountComponent  @   ReactReconciler.js:46\nmountComponentIntoNode  @   ReactMount.js:104\nperform @   Transaction.js:140\nbatchedMountComponentIntoNode   @   ReactMount.js:126\nbatchedUpdates  @   ReactDefaultBatchingStrategy.js:60\nbatchedUpdates  @   ReactUpdates.js:97\n_renderNewRootComponent @   ReactMount.js:320\n_renderSubtreeIntoContainer @   ReactMount.js:401\nrenderSubtreeIntoContainer  @   ReactMount.js:343\n_renderOverlay  @   Portal.js:84\nPortal_componentDidMount    @   Portal.js:47\n(anonymous) @   ReactCompositeComponent.js:265\nmeasureLifeCyclePerf    @   ReactCompositeComponent.js:75\n(anonymous) @   ReactCompositeComponent.js:264\nnotifyAll   @   CallbackQueue.js:76\nclose   @   ReactReconcileTransaction.js:80\ncloseAll    @   Transaction.js:206\nperform @   Transaction.js:153\nperform @   Transaction.js:140\nperform @   ReactUpdates.js:89\nflushBatchedUpdates @   ReactUpdates.js:172\ncloseAll    @   Transaction.js:206\nperform @   Transaction.js:153\nbatchedUpdates  @   ReactDefaultBatchingStrategy.js:62\nbatchedUpdates  @   ReactUpdates.js:97\ndispatchEvent   @   ReactEventListener.js:147****. No, just an empty string by default.\nOn Sat, Jan 28, 2017 at 12:52 PM David Khourshid notifications@github.com\nwrote:\n\nAt any point, is the value undefined?\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/davidkpiano/react-redux-form/issues/630#issuecomment-275873924,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABGKHpBbYYL1FjCfgnIHfNqEj42GONG8ks5rW6qigaJpZM4Lt6ql\n.\n. If you have a baseline with the basic react components / framework on esnextb.in, that would be helpful.\n\nIn the meantime, I pulled everything out and got it to a bare-bones form, When I open the form, it gives me the Control contains an input of type undefined with both value and defaultValue props. error, and when i type something, it gives me the Control is changing a controlled input of type undefined to be uncontrolled. error.\nHere's the full source of the file:\n```jsx\nimport React from 'react';\nimport {connect} from 'react-redux';\nimport {Form, Control} from 'react-redux-form';\nimport {Button} from 'react-bootstrap';\n@connect((store) => {\n  return {\n    form: {\n      mapUuid: store.forms.addMap.mapUuid.value,\n      mapName: store.forms.addMap.mapName.value\n    }\n  };\n})\nexport default class AddMap extends React.Component {\nsubmitForm() {\n    console.log('yay');\n  }\nrender() {\nconst {form} = this.props;\n\nreturn (\n\n  <Form model=\"addMapForm\"\n        id=\"addMapForm\"\n        onSubmit={() => this.submitForm()}\n        className=\"mb-lg\">\n\n    <div className=\"form-group has-feedback\">\n      <label className=\"text-bold\"><h4>Map Name</h4></label>\n      <Control.input model=\".mapName\"\n                     autoFocus\n                     required\n                     defaultValue={form.mapName}\n                     autoComplete=\"off\"\n                     className=\"form-control input-lg\"\n                     placeholder=\"Enter a name for this map\"/>\n    </div>\n    <Button bsStyle=\"info\" style={{marginLeft: 10}} type=\"submit\" form=\"addMapForm\">Add Map</Button>\n  </Form>\n\n);\n\n}\n}\n. My store is just a bunch of forms, all with empty strings as default:\n// Form Reducers\nconst Forms = combineReducers({\n  addMap: formReducer('addMapForm', {\n    mapUuid: '',\n    mapName: ''\n  }),\n```\nThe reason I have defaultValue in there, is because I reuse this form for two purposes:\n1. Create a new map (empty fields)\n2. Modify an existing map (fields are populated using actions.merge)\nHere's the 'editMap' function:\nexport function editMap(mapUuid, mapName) {\n  return dispatch => {\n    dispatch(actions.merge('addMapForm', {\n      mapUuid,\n      mapName\n    }));\n  };\n}\n. FYI, this issue still exists with 1.9.0. Unfortunately I'm still seeing it in 1.10.1 \ud83d\ude1e . Perhaps the fix wasn't applied to defaultValue ?. I tried but couldn't reproduce it on Codepen. I guess it must be something with how my store is configured, because I can reproduce it with this simple page:\n```\nimport React from 'react';\nimport {connect} from 'react-redux';\nimport {Form, Control} from 'react-redux-form';\n@connect(store => ({\n  form: {name: store.forms.addJob.name.value}\n}))\nexport default class AddJob extends React.Component {\n  render() {\n    const {form} = this.props;\nreturn (\n  <Form model=\"addJobForm\">\n    <Control.input model=\".name\" defaultValue={form.name}/>\n  </Form>\n);\n\n}\n}\n``` . I wasn't able to replicate the store configuration in Codepen, which is why\nI assume that has something to do with it. I'm running 1.10.1 already.\nOn Tue, Apr 11, 2017 at 1:58 PM David Khourshid notifications@github.com\nwrote:\n\nAs in the warning doesn't occur when trying it in CodePen? If so, upgrade\nto the latest version\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/davidkpiano/react-redux-form/issues/630#issuecomment-293397916,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABGKHjlWVEhli0yvwvA-JgtprjSJeBv0ks5ru-l4gaJpZM4Lt6ql\n.\n. If I use value={something} then I run into the cursor jumping issue: https://github.com/facebook/react/issues/955\n\nI somewhat prefer the console error, since at least users won't see that.. As it turns out I had to revert back to 1.8.1 in order to get defaultValue working. Looks like something in 1.8.2 prevents it from populating correctly.. I've tried to set it up here but can't get Redux devtools working in Codepen, so I'm not sure how to tell if the actions.merge is working: http://codepen.io/jgentes/pen/qmWxNQ?editors=0010. Ok, merge issue with defaultValue is replicated here: http://codepen.io/jgentes/pen/qmWxNQ. ",
    "udalrich": "No.  I did not find that mentioned in https://davidkpiano.github.io/react-redux-form/docs/api/Control.html or similar pages.  Where is it documented?. This shows what I am trying to do.  When you click the Add Fields button, it updates state.data.fields to have additional members.  The form then gets a new dropdown for each member.  Clicking Show State does a console.log of the current state to see what is happening.\nAdding defaultValue to the <Control.select> sets the value correctly.  Removing it sets the value to 1.  I am not able to get the same error here that I saw in my original code base.\nAt this point, I know how to do what I want to do, but I think that the documentation does not mention defaultValue.  . ",
    "dasnixon": "Omitting onChange and mapProps didn't do anything, it actually didn't even set the value in the store.\nSo looks as though, esnextbin relies on https://wzrd.in, which seems to be down, throwing a 502.\nLet me try to get something on jsbin, unless you have any other thoughts on potentially why this isn't working.. @Finlorfin I wasn't able to get it working with the Control.select, so I ended up SelectField from material-ui and handling the validation \"manually\". Hope it helps.\n```javascript\n// This is my visual component that is connected with a container\nexport default class CreateApp extends Component {\nconstructor() {\n    super(...arguments);\n    this.props.validatePlatform();\n  }\nsetPlatform = (ev, index, value) => this.props.setPlatform(value);\n\n\n\n\n\n\n\n\n\n}\n//this is container\nclass AppsContainer extends Component {\n  ...\nsetPlatform = (platform) => {\n    const { dispatch } = this.props;\n    dispatch(appActions.setPlatform(platform));\n    dispatch(actions.change('models.app.attributes.platform', platform));\n    this.validatePlatform();\n  };\nvalidatePlatform = () => {\n    const { dispatch } = this.props;\n    dispatch(actions.validate('models.app.attributes.platform', {\n      platformIsValid: this.platformIsValid,\n    }));\n  };\nplatformIsValid = (platform) => PLATFORMS.includes(platform);\n  togglePlatform = (platform) => this.props.dispatch(reportsNavActions.togglePlatform(platform));\n}\n```. ",
    "Finlorfin": "I have the same issue I think, or at least similar, and also with DropDownMenu from material-ui.\nThe rff/change event that is dispatched has a value of \"undefined\" (onChange and mapProps ommitted). The model string is correct though.\n@dasnixon , what does your setPlatform function look like? I'm pretty new to all this so could use some examples.. ",
    "marcandrews": "This seems to be working well for me:\n```jsx\n handleResolutionChange,\n  }}\n  style={{ width: '50%' }}\n\n\n\n\n\n\n``. @davidkpiano InhandleResolutionChange, I dispatchactions.change`.\n\n... but here's an even better way that does not require custom onChange handlers:\n```\n// Curried function that basically transforms Material-UI's onChange function\n// into a react-redux-form dispatch(action.change) function.\nconst handleChange = ({ model, dispatch }, options = {}) =>\n  (ev, index, value) =>\n    dispatch(actions.change(model, value, options));\nforms.overlay.panels[${index}].css.backgroundRepeat}\n  component={SelectField}\n  mapProps={{\n    floatingLabelText: 'Repeating',\n    onChange: (props) => handleChange(props),\n  }}\n\n\n\n\n\n\n\n``\n. @davidkpiano thanks!. @davidkpiano I updated my CodeSandbox with 1.13.0. The error is gone, but theControl.text` components assigned to retrieve the keys in the currently selected collection do not display the values, nor can they update them. Any ideas?. @davidkpiano,\nI've forked your repo and potentially found the problem: findKey() is not equipped to handle Immutable Lists. The following modifications appear to solve the issue; however, I did not test these changes thoroughly.\n/src/utils/find-key.js:\n```js\nimport { List } from 'immutable';\nexport default function findKey(object, predicate) {\n  let resultKey;\nif (List.isList(object)) {\n    resultKey = object.findKey(predicate);\n  } else {\n    Object.keys(object).some((key) => {\n      const isKey = predicate(object[key], key, object);\n  if (isKey) {\n    resultKey = key;\n    return true;\n  }\n\n  return false;\n});\n\n}\nreturn resultKey;\n}\n```\nLet me know what you think or if you'd like me to submit a PR.. . Immutable is a dependency; you won't find it in the repo, but in node_modules. Can you try running npm install again?. Oh I see. Immutable is a dev dependency so it's not being installed when you npm install react-redux-form. Try installing it manually with npm install immutable. You may also have to add it to your own package.json until it can be added as a dependency in react-redux-form.. Is the module resolver getting confused between the Immutable.JS library and the file /src/immutable.js?. @TLadd yes, this has already been determined. Adding a separate utils/find-key.jsfor ImmutableJS support will still add ImmutableJS as a dependency so that is not a solution.\nI can see two solutions:\n1. Add immutableJS as a dependency\n    - Positives: quick and easy\n    - Negatives: one more dependency, but Webpack/UglifyJS should remove most of the Immutable library from your final build if you're not using it directly; also what's one more dependency when you app probably has hundreds if not thousands\n2. Add in the the isList() function directly\n    - Positives: does not add ImmutableJS as a dependency\n    - Negatives: breaks ImmutableJS track support should that library be updated\nHere is isList() from ImmutableJS\njavascript\nfunction isList(maybeList) {\n  return !!(maybeList && maybeList['@@__IMMUTABLE_LIST__@@']);\n}\n@davidkpiano what should we do?. Yes, I think that would work. I have some issues with the #970.\nFor instance, find-key-immutable.js does not need to determine if the array is an Immutable list. This should be all that is necessary:\njavascript\nexport default function findKey(object, predicate) {\n  return object.findKey(predicate);\n}\nDamn, I should have did this in the original PR. Sorry guys \ud83d\ude1e . Is there any particular reason why you're using Immutable@4.0.0-rc.2? Can you try ^3.8.2?. Actually, why are you importing from src/immutable.js? Shouldn't it be from lib/?. Is this really a problem with react-redux-form? I understand the changes, but clearly, you should not have an empty key in state. In my opinion, if an empty key is detected, react-redux-form should throw an error.. @bugzpodder Yes, you're right. It is an opinion that you should not use an empty keys in application state.\nHowever, an object's key must be a string and an empty string is a string, so at the end of the day, it makes sense to support empty keys eventually. It will be weird though, because model references like clients..address.streetName (notice the two dots) would have to be supported. To do this might require a lot of refactoring, as @bugzpodder pointed out.\nPerhaps a console.warn('Empty keys in state are currently not supported') can be issued when returning false and adding full support for empty keys can be addressed later?. FYI, I am here because I recently ran into this issue in my application. I have an Immutable and normalized state. I had miss-referenced an ID and it caused an object key to be 'undefined': String.\nWhen making changes, please don't forget about us Immutable-state users \ud83d\ude1d. Should a console.warn be issued here to warn the user that empty keys in state are currently not supported?. ",
    "tero": "Have you scheduled any roadmap yet? When v2 will be out and what kind of changes is planned there? \nFor temporary API my vote goes for onBeforeSubmit.. ",
    "richchurcher": "Ah, I see. I'd been assuming that combineForms always expects the single object as a 'model'. I'll see if I can come up with a clarifying example for the docs. Thanks! . ",
    "58a36f": "```jsx\nexport default class BootstrapValidForm extends React.Component {\n    constructor(props){\n        super(props);\n    }\nrender(){\n    const { label, passedProps, messages , value ,placeholder } = this.props;\n    const { model, fieldValue } = passedProps;\n\n\n    let validityState=\"\";\n    let validitySpan=\"\";\n    if (fieldValue.valid && fieldValue.touched) {\n        validityState=\"has-success\";\n        validitySpan= <span className=\"form-control-feedback errspan fa fa-check-circle-o\">\n                             </span>\n    }\n    if (!fieldValue.valid && fieldValue.touched) {\n        validityState=\"has-error\";\n        validitySpan= <span className=\"form-control-feedback errspan fa fa-exclamation-triangle\">\n                             </span>\n    }\n\n    return (\n        <div className={\"form-group \"+validityState}>\n            <label className=\"control-label\">{label}</label>\n            <Field model={model}>\n                <input className=\"form-control\"\n                       placeholder={placeholder}\n                />\n            </Field>\n            {validitySpan}\n            <span className=\"control-label\">\n                <Errors\n                    wrapper={(props) => <div className=\"text-center\">{props.children}</div>}\n                    model={model}\n                    messages={messages}\n                    show={(fieldValue) => fieldValue.touched && !fieldValue.focus}\n                />\n            </span>\n        </div>\n\n    );\n}\n\n}\n```\nAnyway I am using asnyc function checkNickname which looks like this:\n```\nasync checkNickname(nick) {\n    dispatch(actions.setPending('user.nick', true));\n    res = await fetch.post(\n     ..//get data from server to res\n     )\ndispatch(actions.setValidity('user.nick', {\n            available: res.body.vysledok,\n }));\n\n dispatch(actions.setPending('user.nick', false));\n\n}\n```\nWhen I use this function as regular validator not asyncValidator , its working correctly.\nBut I would like to do this async validation only onBlur , while other like required onChanged. ",
    "stanleycyang": "I'm noticing this behavior where a regular Form stops running onSubmit as well. It would just keep throwing the batch action instead of submitting:\n\nI don't have any validators on the <Form>, and I'm on the latest react-redux. @davidkpiano This occurs when I'm using react-router. I'd go back and forth between pages and it breaks all of a sudden with onSubmit. Not sure why that would be. @davidkpiano It seems to be working now after updating redux to ^5. Apologies for the fuss!. Oops yes. I tried encType per the React specs however that doesn't work. Now I'm just passing it via FormData to the backend instead. ",
    "aestock": "Ah, nice. I think I tried that syntax, missed that it was createForms and not combineForms. That's producing the structure I was hoping for. Still an extra createEvent Object in the root, but I guess that's by design.\n{\n  createEvent: [Object]\n  report: [Object]\n  forms: {\n    $form: [Object],\n    createEvent: {\n      $form: [Object],\n      comment: [Object]\n      link: [Object]\n    }\n  }\n}\nI solved my second problem by omitting the .toJS() transformation in the return statement. So, it seems forms is just a standard Object rather than an Immutable Map like it should be?. Understandable. I misunderstood what to expect with Immutable.JS compatibility. Unfortunately I'm forced to use a project boilerplate that uses it. But this will still work without .toJS in mapStateToProps and perhaps this thread will help someone else who might be make incorrect assumptions like me. Thanks!. I find I have to use updateOn=\"blur\" with most my forms otherwise typing in the UI lags tremendously.\nI removed updateOn and also changed it to just a basic Control.text instead of my custom component to make sure nothing goofy was happening. No cigar...\nFor reference here's what the form object looks like...\nlist: {\n  entities: {\n    events: {\n      abc123: {\n        note: {\n          errors: [Object]\n          focus: true\n          initialValue: \"Preloaded text\"\n          intents: [Array(0)]\n          loadedValue: \"Preloaded text\"\n          model: \"list.entities.events[abc123].note\"\n          pending: false\n          pristine: false\n          retouched: false\n          submitFailed: false\n          submitted: false\n          touched: false\n          valid: true\n          validated: false\n          validating: false\n          validity: [Object]\n          value: \"Preloaded text\"   // this also gets replaced as you type\n    }\n      }\n    }\n  }\n}\nI didn't notice before when I wrote my original post, but value is loaded too, which is bizarre. I don't need to explicitly set it in the component, right? Map my form state to props and do something like value={this.props.forms.[...].note.value}?. Without changing my code, tried with \"react-redux-form\": \"^1.9.0\". No difference to behavior. State still seems correct, but initial value not displayed.. ",
    "beckmeindia": "hey @davidkpiano my present store looks like this. I did think of combineforms as combinereducers and placed the respective in my reducers.js but that failed too\n\nimport { createStore, applyMiddleware, compose } from 'redux';\nimport thunk from 'redux-thunk';\nimport axios from 'axios';\nimport chalk from 'chalk';\nimport { browserHistory } from 'react-router';\nimport { routerMiddleware } from 'react-router-redux';\nimport createReducer from './reducers';\nexport default (initialState) => {\n  const middlewares = [\n    thunk.withExtraArgument(axios),\n    routerMiddleware(browserHistory),\n  ];\n  const enhancers = [\n    applyMiddleware(...middlewares),\n    DEV && typeof window === 'object' && typeof window.devToolsExtension !== 'undefined' ?\n      window.devToolsExtension() : f => f,\n  ];\n  const store = createStore(createReducer(), initialState, compose(...enhancers));\n  store.asyncReducers = {}; // Async reducer registry\n  if (module.hot) {\n    // Enable Webpack hot module replacement for reducers\n    module.hot.accept('./reducers', () => {\n      try {\n        // eslint-disable-next-line import/newline-after-import\n        const reducers = require('./reducers').default;\n        store.replaceReducer(reducers(store.asyncReducers));\n      } catch (error) {\n        console.error(chalk.red(==> \ud83d\ude2d  Reducer hot reloading error ${error}));\n      }\n    });\n  }\n  return store;\n};\n\nLet me know what needs to be done or should I just use LocalForms due to my setup.\nBy the way I am using this-starter as the universal boilerplate\nThanks. Hey David, so I have not been able to change my store.js file yet because I already have a createreducer() which needs to be passed. So all I have been doing is wondering how to put both the createreducer() as well as combineForms() together. As of now my store looks the same way. I although tried \n\ncreateStore(combineForms({ user: value }), createReducer(), initialState, compose(...enhancers))\n\nBut it has the same problem as I said above about passing only 3 params to createstore\nThanks.  createReucer is just a combinereducers() \nAlso I was seeing that there are options of adding things to combineducers in this lib with modelReducer and etc. . ",
    "danielericlee": "Sure, here's a Codepen that demonstrates the problem:\nhttp://codepen.io/danielericlee/pen/PWyvEx\nTo reproduce, click on 'REMOVE FIRST TOPIC' and then click on 'SUBMIT'. In the console, you'll see that the submission failed despite there being no controls left on the page to validate.\nBUT! I think I figured this out. It looks like this bug if fixed in RRF version 1.5.1. (My Codepen above is using 1.5.0, as does the app I'm developing against). \nSorry to bother you with this one, in the future I'll try to put together a Codepen if/when I file more Issues \ud83d\ude04 . @jmaicher, I'm hitting this problem as well. Did you come up with a workaround?\n@davidkpiano, any progress on this one or ideas for a workaround? Thanks!. ",
    "asfktz": "Good questions.\nseems like it has something to do with HOCs, where a function wraps the original input component.\nI tried to find a way to get the original component name out of a wrapped one, but it seems like its not available.\nOn the other hand, styled-components adds a target property on their wrapper component, \nso we can use it to our advantage.\nI agree that it feels awkward to add a specific check for another library,\nbut I couldn't find a more generic solution to offer \ud83d\ude41\n```jsx\nimport React from 'react';\nimport styled from 'styled-components';\nconst WrappedInput = (props) => {\n  return \n}\nconst wrappedInput = \nconsole.log(wrappedInput.type)              // returns: function WrappedInput(props) { ... }\nconsole.log(wrappedInput.type.target)       // returns: undefined\nconsole.log(wrappedInput.type.name)         // returns: WrappedInput\nconsole.log(wrappedInput.type.displayName)  // returns: undefined\nconst StyledInput = styled.inputbackground: red;\nconst styledInput = \nconsole.log(styledInput.type)               // returns: function StyledComponent() { ... }\nconsole.log(styledInput.type.target)        // returns: input\nconsole.log(styledInput.type.name)          // returns: StyledComponent\nconsole.log(styledInput.type.displayName)   // returns: styled.input\n``. Sorry, my mistake.\nI overlooked  the part in the docs about nestingcombineForms`.\n\nfor deeper parent models, the full path string must be provided\n\njs\nconst reducer = combineReducers({\n  forms: combineForms({\n    user: initialUserState,\n  }, 'forms') // <--\n})\n. It works with <Control.input /> too.. ",
    "ralphstodomingo": "I have managed to get around this by making custom controls: create a control styled with styled-components, then pass it to the Control as the component attribute.. I've been using styled-components and react-redux-form with both antd and material-ui, and can safely say this is not really needed. . Thanks for the response.. First up, thanks for the response! Really appreciate it.\nI just happened to straight-up use the page.body.sections.entities.children collection inside a component using mapStateToProps(), and the same collection is being interpreted as read-only inside that component only after rrf/change triggers on said collection. The component runs the said collection to a parser before displaying it, I'm not mutating the state directly (right?).\nAm I doing an anti-pattern of sorts? Am I supposed to not directly use the returned props from mapStateToProps()? I'm not that much of an expert but so far, all of the packages I used did not require me to spin off a new object from every props that I pulled out from the store.\nIf this is intentional behavior or I'm just doing things wrong I'll close this issue.. In the component that makes use of page.body:\ncomponentWillReceiveProps = (nextProps) => {\n  ...\n  if (this.props.body.sections !== nextProps.body.sections) {\n    const tree= parseTree(nextProps.body.sections);\n  }\n  ...\n}\nInside parseTree:\nconst parseTree= (obj) => {\n  let tree = [];\n  ...\n  //state holds the normalized array\n  obj.entities.state[0].elements.forEach((i) => {\n    let el = obj.entities.children[i];\n    el.id = i;\n  })  \n  ...\n  return tree;\n}\nGiven all that, I can assume that a workaround might be to spin off new instances of the objects rrf touches, but I can't help but think that this couldn't be intended behavior. Thanks for sticking with this so far.. Strangely enough, none of this occurs when I switch to field validation (setting individual validation rules per field). That's how I avoided this, but I know it will get unwieldy when I start to tackle bigger forms.. Haven't tried, removing ImmutableJS isn't that easy at this point. Will try reporting back once I get the chance to try.. Hey! That works. Why does that work and the example doesn't??\nEDIT: Turns out, after a refresh, that it still doesn't work. Weird. Was using hot module reloading btw.. ",
    "tdurand": "I confirm it is babel related, I have manage to get react-redux-form working in the react native app by adding the following devDependencies:\n\"babel-preset-es2015\": \"*\",\n\"babel-preset-es2015-minimal\": \"^2.1.0\",\n\"babel-preset-stage-0\": \"^6.22.0\",\nAnd that in the package.json:\n\"babel\": {\n    \"presets\": [\n      \"stage-0\",\n      \"es2015\",\n      \"es2015-minimal\",\n      \"react-native\"\n    ]\n  }\nIf I understood correctly it seems that react-native is compiling again react-redux-form, shouldn't it use the ES5 outputed version ? Also should we be able to use react-redux-form without react-dom in react native ?\nLet me know if I can help, but hopefully this will help some other people stuck with React Native.. Solved , I had misconfigured the store, forgot the deep parameter, sorry\njavascript\nforms: combineForms({\n    dynamic: {}\n  }, 'forms'). Great ! \ud83d\udc4d  Many thanks for this library BTW ! . ",
    "aditya2592": "Hi @tdurand. Not able to run on react-native with these settings also. Is there any other change required?. ",
    "dfcarpenter": "This just happened for me with the latest version and the changes suggested by @tdurand aren't working. Any ideas?. ",
    "pquelmht": "Hello,\nSorry I was probably following wrong guide:\n(http://davidkpiano.github.io/react-redux-form/docs/guides/quickstart.html)\nas it says that : \"redux-thunk is no longer required for versions 1.3.0 and higher. If you are using a previous version, make sure to install it as well.\"\nand now I found out here is also guide: \nhttps://davidkpiano.gitbooks.io/react-redux-form/\nWhich one is actual or both?\n*EDIT: Ah i see its required for anything besides actions.change. ",
    "abudel": "First of all thanks to get time to answer!\ni tried also in that way, but by using combineForms and instead of passing a initalState, i'm going to pass a reducer.\nSo my rootReducer look like this:\n....\nuser: combineForms({\n        profile: profileReducer,\n    }, 'user'),\n....\nBut when i access to the state, \"profile\" is not a Immutable object is a plainObject. ( i'm using 'react-redux-form/immutable' )\nstate.get('user')\nObject {profile: Map, forms: Object}\nAnd if i'm using combineReducers, i will get a regular Immutable object.\nIs it the correct behaviors ?\nThanks. Thanks for the tips.\nif someone is interests on it, I made it works by using the rootReducer like this:\njs\nuser: combineReducers({\n    ...createForms({\n        profile: userReducer\n    }, 'user')        \n}),\nand changed in my view\njs\nmapStateToProps = (state) =>({\n        profile: state.getIn(['user', 'profile']),\n        form: state.getIn(['user', 'forms']).$form\n})\nIn this way it seams to works as aspected.\n. Thanks for the advice!\n. Thanks for the quick replay.\nI tried but it's not working either.\nIt fails a couple rows after, when it tries to access to this.node prop ( it's undefined ).\nI think the problem is beacause it can not attach the node when the component is mount:\n`attachNode() {\n      const node = findDOMNode && findDOMNode(this);\n  if (node) this.node = node;\n}`\n\nfindDOMNode is null because is not supported on RN.\nThere is another way where i can access to the node?\nThanks. Hi Again\nFinally got it work! \ni used findNodeHandle in combination with \nTextInputState.focusTextInput(this.node)\nThanks for the tips\n. @davidkpiano here you are\nimport TextInputState from 'TextInputState'\n.....\n     //if (isNative) return;\n     const focused = fieldValue.focus;            \n     if ((focused && this.node)\n         && (\n         !this.isToggle()\n         || typeof intent.value === 'undefined'\n         || intent.value === controlProps.value\n      )) {\n          if(isNative) {\n            TextInputState.focusTextInput(this.node)\n           } else {\n              input.focus();\n           }\n           dispatch(actions.clearIntents(model, intent));\n     }\n....\ni did not check if the element to focus in is not a TextInput...\n. findNodeHandle is taking from your  last commit . ",
    "sniepoort": "Yes, right not the workaround is just to manually dispatch my async action on a button click.\nIt would still be great to be able to override it in the Form component though :) \nHowever, after I have done this, I need to reset the forms validity after a succesful post.\nresetValidity is not working. I'm getting a type error:\nCannot read property 'valid' of null \nI am correct in the understanding that resetValidity, when provided with a form model, will set validity back to true for all fields?. ```js\napi.put('/task/${task.id}', task)\n    .then(({ body }) => {\n  dispatch(FormActions.merge('data.task.current', body))\n  dispatch(notifySuccess('Task blev gemt'))\n  dispatch(FormActions.resetValidity('data.task.current'))\n})\n.catch(error => {\n  console.log(error)\n  if (error instanceof ApiError) {\n    dispatch(notifyDanger('Der skete en fejl'))\n  }\n  if (error.body.metadata) {\n    dispatch(FormActions.setFieldsErrors('data.task.current', error.body.metadata))\n  }\n})\n\n```\n. @davidkpiano any luck on this? i'm kind of stuck :)\n. That is nifty :)\nHowever, I'm still stuck on the resetValidity not working, which i still need to do when a succesful response comes from the server . It is not undefined. \nHowever, this morning I stumbled upon the problem. Our knex + bookshelp was outputting interval types in the format { minute: '' , hours: ''}, and not in ISO 8601 as we were expecting. So, when merging the new task into redux forms, one of the fields suddenly had an object instead of a string as it was set up to be. So I guess resetValidity was trying to loop over this object that didn't have a corresponding form key, or something like that? \nThanks for the help :)  . Hey again @davidkpiano \nI unfortunately got the same problem again, although this time it can't be attributed to to an unknown object being returned. \nIt still seems like updateSubFields (from your utils lib) is trying to set validity on a field that doesn't exist? I've double checked that all fields i get returned from my server are included in my initial form reducer. \nI tried logging subField in updateSubFields, and got this:\njavascript \nObject {focus: false, pending: false, pristine: false, submitted: false, submitFailed: false\u2026}\nObject {focus: false, pending: false, pristine: false, submitted: false, submitFailed: false\u2026}\nObject {focus: false, pending: false, pristine: false, submitted: false, submitFailed: false\u2026}\nObject {focus: false, pending: false, pristine: false, submitted: false, submitFailed: false\u2026}errors: Objectfocus: falseinitialValue: 1intents: Array[1]model: \"data.task.current.property_id\"pending: falsepristine: falseretouched: falsesubmitFailed: falsesubmitted: falsetouched: falsevalid: truevalidated: falsevalidating: falsevalidity: Objectvalue: 4__proto__: Object\nObject {focus: false, pending: false, pristine: false, submitted: false, submitFailed: false\u2026}errors: Objectfocus: falseinitialValue: \"\"intents: Array[0]model: \"data.task.current.priority\"pending: falsepristine: falseretouched: falsesubmitFailed: falsesubmitted: falsetouched: falsevalid: truevalidated: falsevalidating: falsevalidity: Objectvalue: null__proto__: Object\nObject {$form: Object, validated: false, retouched: false, intents: Array[1], pristine: false\u2026}\n false\nArray[1]0: Objecttype: \"validate\"__proto__: Objectlength: 1__proto__: Array[0]\nfalse\nnull\nTypeError: Cannot read property 'valid' of null\n    at Object.assoc (http://localhost:5000/assets/app.bundle.js:14705:12)\n    at http://localhost:5000/assets/app.bundle.js:14832:15\n    at Array.reduce (native)\n    at singleAssign (http://localhost:5000/assets/app.bundle.js:14831:29)\n    at Array.reduce (native)\n    at Object.assign (http://localhost:5000/assets/app.bundle.js:14825:33)\n    at updateSubField (http://localhost:5000/assets/app.bundle.js:18758:29)\n    at http://localhost:5000/assets/app.bundle.js:18745:26\n    at Array.forEach (native)\n    at http://localhost:5000/assets/app.bundle.js:18741:30\nNot sure if you can see anything useful there, so let me know what else i could do to diagnose. I did some more digging, and I think it has to do with the way I have been mixing LocalForms into the equation. \nThe problem arises in my initial form state. Here I have some normal fields that have a matching input/edit in my form. Normal stuff. However, I also have some fields that are designated as arrays. One example (which is the first one that fails in the about console log), is contact_persons. This is an array of objects, but the objects themselves do not have corresponding form fields in my initial form. To add a new contact person, a modal opens up with a LocalForm, where the fields are specified there. Upon \"saving\" the contact person, I push this object to the array of contact persons. And then on a save of the whole form, I throw the whole form to the server. \nThe problem arises when there for example are no contact persons added yet, and the server returns a null value (these persons are just saved as a json string). I guess this null value gets merged into my state, and contact persons is no longer an array but just a null value. \nThis seemed like a smart way to mix redux forms with these local forms, but it's possible that I misunderstood how you imagined local forms should be implemented.\nHowever, I think my specific problems comes from redux forms expecting array values, but getting null values returned. A simple server coercion of null values to empty arrays would fix the problem.  . @davidkpiano I kind of have two threads going now with the same issue. Could you merge them or something? \n662\nAs for the reproducible example, i will get to that. Just have to brush up on how to do it, since i haven't done it before. Alright so I have a modal with a LocalForm:\njavascript\n<LocalForm\n            id=\"propertyForm\"\n            model=\"property\"\n            onChange={(values) => this.setState({  property: {...values}}) }\n            onUpdate={(form) => this.setState({  form }) }\n            onSubmit={(values) => handleSubmit(values, this.propertyFormDispatch) }\n            getDispatch={(dispatch) => this.propertyFormDispatch = dispatch}\n            initialState={{\n              name: '',\n            }}\n          >\n            <Control.text model=\".name\" className=\"form-control\" placeholder=\"Navn p\u00e5 ejendommen\" component={ Input } label=\"Navn\" mapProps={{ valid: ({fieldValue}) => fieldValue.valid }}/>\n</LocalForm>\nIn the parent component that renders this modal component, I have the submit handle, which calls an async actions that returns a promise:\njavascript\nhandleNewPropertySubmit (organisation_id) {\n    const { dispatch, createProperty } = this.props\n    return (propertyForm, localDispatch) => {\n      const property = { name: propertyForm.name, organisation_id }\n      dispatch(createProperty(property))\n      .then(_ => {\n        localDispatch(FormActions.resetValidity('property'))\n      })\n      .catch(error => {\n        if (error) {\n          localDispatch(FormActions.setFieldsErrors('property', error, {async: true}))\n        }\n      })\n    }\n  }\nThe weird thing is that I have another modal in a different component, set up exactly the same way, and that one works fine. But that's also the only one out of 4 others.. Just updated my markdown. Sorry about that again. Ah sorry, don't do a lot of posting on github.\nReact-redux 4.4.1\nReact-redux-form 1.5.3\nI can see that I probably should give redux an update. Alright, so I just tried to bump my redux version. \nThat pretty much breaks the local form dispatch of setFieldsErrors. So i guess there is something that i'm not doing quite right. None of the other form actions work either (such as reset()).\nI also tried moving the handleSubmit function into the modal component, just in case passing the localform dispatch up the chain was causing havoc, and that doesn't work either. . ",
    "Jokinen": "That sounds fantastic! Thank you for a quick reply!. Hello David, I'm contacting you to make sure I've not missed the clone. I understand that you are very busy and I do not wish to put pressure on you in case you didn't have the time to finish the project.. ",
    "Hortilly71": "Hello, \nthanks for information but even implementing index I have to do something wrong.\nI have parent componet which deals with rendering array from model.\nIn this parent component in componentDidMount I add first object to array and then in every re-render in componentWillReceiveProps I check if array is valid and add another component .\nIn render I basicly map every array item to react component: \n```\n@connect....\nclass SomeClass extends React.Componet {\nconstrutor(props) {\n   ...\n  this.internalID=0;\n  this.onDelete=this.onDelete.bind(this);\n}\ncomponentDidMount(){\n        const {  disptach} = this.props;\n    let newobject={\n       internalID.this.internalID,\n       oneData:null,\n       twoData:null\n   }\ndispatch(actions.push(\"object.someArray\",newobject));\n}\ncomponentWillReceiveProps(nextProps) {\n     const { objectForm, disptach} = nextProps;\n    let newobject={\n       internalID.this.internalID,\n       oneData:null,\n       twoData:null\n   }\nif (objectForm.someArray.$form.valid) {\n       dispatch(actions.push(\"object.someArray\",newobject));\n  }\n}\n//Deleting item at index ??\nonDelete(index){\n        const { dispatch } = this.props;\n        dispatch(actions.remove(\"object.someArray\", index));\n}\nrender(){\n    const { object } = this.props;\n   let objectRender=[];\n   for (let i in object.someArray) {\n       objectRender.push();\n    }\n  return (\n   \n     {objectRender}\n   \n );\n}\n}\n```\nNow in React component class - ObjectItem - i have functions for finding index in form and model and then rendering according this. \n```\n@connect....\nclass ObjectItem extends React.Component {\n     constructor(props) {\n        super(props);\n    }\nfindIndexInModel(id){\n     const { object } = this.props;\n    for (let i in object .someArray) {\n        if (object .someArray[i].internalID==id) return i;\n    }\n}\n\nfindIndexForm(id){\n     const { objectForm } = this.props;\n     for( let i in objectForm .someArray.$form.value ) {\n        if (objectForm.someArray[i].interlaID.value==id)  return i;\n     }\n }\n\nrender(){\n     const { objectForm,id } = this.props;\n      let vadilidityClass=\";\n      let formIndex = findIndexForm(id);\n     if ( objectForm[formIndex].$form.valid && objectForm[formIndex].$form.touched ) {\n         vadilidityClass=\"has-sucess\";\n     } else {\n        vadilidityClass=\"has-error\";\n    }\nlet model=\"object.someArray[\"+findIndexInModel(id)+\"]\";\nreturn (\n    <div className={vadilidityClass}>\n       <Control.input model={model+\".oneData\"} validators={..} validateOn=\"change\"/>\n       <Control.input model={model+\".twoData\"} validators={..} validateOn=\"change\"/>\n        <label className=\"delete\" onClick={this.props.onDelete(findIndexInModel(id))} />\n    </div>\n\n);\n}\n}\n```\nNow here is the problem I always end up with unexpected items appearing in form model after deleting item.\nWhat index do I use in model? Is it index from form or from model?\nWhat index do I use in delete? \nHere is scenario that I am having problem with:\n1.Add new object to array:\n{\n   internalID=0;\n   oneData=\"A\"\n   twoData=\"A\"\n}\nEverything is correct form and model both have one object in array with correct values\n2.Add anotehr object in array:\n{\n   internalID=1;\n   oneData=\"B\"\n   twoData=\"B\"\n}\nEverything is correct form and model both have one object in array with correct values\n3.Add anotehr object in array:\n{\n   internalID=2;\n   oneData=null\n   twoData=null\n}\nEverything is correct form and model both have one object in array with correct values\nSo now they look like this:\nForm:\n{   internalID=0;   oneData=\"A\";  twoData=\"A\" }  [0:index]\n{   internalID=1;   oneData=\"B\";  twoData=\"B\" }   [1:index]\n{   internalID=2;   oneData=null;  twoData=null }  [2:index]\nModel:\n{   internalID=0;   oneData=\"A\";  twoData=\"A\" } [0:index]\n{   internalID=2;   oneData=null;  twoData=null } [1:index]\n{   internalID=2;   oneData=null;  twoData=null }  [2:index]\nNow delete object 2 with interalID == 1 ,it does not matter if I calculated index from model or form , they are same.\ndispatch(actions.remove('object.someArray',2)\nAfter deleting:, form has 3 values (also deleted object stays there in index 2) and model has 2 values as expected.\nForm:\n{   internalID=0;   oneData=\"A\";  twoData=\"A\" }  [0:index]\n{   internalID=1;   oneData=\"B\";  twoData=\"B\" }   [1:index]\n{   internalID=2;   oneData=null;  twoData=null }  [2:index]\nModel:\n{   internalID=0;   oneData=\"A\";  twoData=\"A\" } [0:index]\n{   internalID=2;   oneData=null;  twoData=null } [1:index]\nNow change value of object with interalID==2 , so when using model array to calculate index than model is: object.someArray[1].oneData from null to C.\nThis change is made from Controll which receives model object.someArray[1].oneData, but it is probably same as:\ndispatch(action.change('object.someArray[1].oneData',\"C\"))\nResult is incorrect, in Form is changed value at index 1 instrad of 2. Result in Model is correct.\nForm:\n{   internalID=0;   oneData=\"A\";  twoData=\"A\" }  [0:index]\n{   internalID=1;   **oneData=\"C\";**  twoData=\"B\" }   [1:index]\n{   internalID=2;   oneData=null;  twoData=null }  [2:index]\nModel:\n{   internalID=0;   oneData=\"A\";  twoData=\"A\" } [0:index]\n{   internalID=2;   oneData=\"C\";  twoData=null } [1:index]\nThis what happens when I use index calculated from model array.\nWhen I use  index calculated from Form array then: model of changing value will be this: object.someArray[2].oneData. Change made from Control but is probably same as:\ndispatch(action.change('object.someArray[2].oneData',\"C\"))\nResult is incorrect again.\nForm:\n{   internalID=0;   oneData=\"A\";  twoData=\"A\" }  [0:index]\n{   internalID=1;   oneData=\"B\";  twoData=\"B\" }   [1:index]\n{   internalID=2;   oneData=\"C;  twoData=null }  [2:index]\nModel:\n```\n{   internalID=0;   oneData=\"A\";  twoData=\"A\" } [0:index]\n{   internalID=2;   oneData=null;  twoData=null } [1:index]\n{  oneData=\"C\" } [2:index]\n```\nSo I do not know which index to use , both ways I get incorrect results. Ok I found my error:\nWhen calculating index I should explict return integer , because if I do not , then data are deleted only from model , not from form\nSo instead of \nfindIndexModel(id){\n        const { object} = this.props;\n        for (let i in object.someArray) {\n            if (object.someArray[i].interalID==id) return i;\n        }\n     }\nuse this:\nfindIndexModel(id){\n        const { object} = this.props;\n        for (let i in object.someArray) {\n            if (object.someArray[i].interalID==id) return parseInt(i);\n        }\n     }. ",
    "skleeschulte": "Wow, thank you for your quick answer!! :)\n\n\nWhat exactly are the responsibilities of the different reducers (modelReducer, modeled and formReducer)? modeled is only mentioned on the models page.\n\nDon't worry about that - start with just combineForms per the Quick Start guide. [...]\n\nBut then how would I know when and how to use modeled?\n\n\nWhat is the purpose of the different keys in the redux store? Especially: What state resides in forms.$form (the \"top-level\" $form object which is not related to a specific form)?\n\nLet's say you have a user object that looks like user: { name: 'david' }. Then:\n\nforms.user.$form would represent the entire form state.\nforms.user.name would represent the field state of user.name. Since it's a simple value (a string) and not a complex one, it's considered a field, not a form.\n\n\nOk, but it is still not clear to me what forms.$form represents. In addition, forms.user.$form seems to contain \"dead keys\": e.g. forms.user.$form.focus and forms.user.$form.pristine are not updated. (Example). And what is retouched?\n\n\nIs the following statement true for the current version of the library? \"To nest it deep, you must specify where the deep combineForms() reducer will live as a model string in the second argument to combineForms(forms, model)\". (source) I ask because it seems to work just fine using combineReducers({ forms: combineForms({ ... }) });.\n\nThe reason that works is actually because 'forms' is the default location that RRF looks for the forms. For most intents and purposes, specify the model path to be safe.\n\nFor me it looks like it also works with other keys, see this example. Isn't that what combineReducers is all about?\nThanks a lot for your help!. ",
    "gkweb": "@davidkpiano Is it possible to add this example or something similar to the documentation for custom control validation. I feel an example like this using custom Control validation could benefit others. Thanks for a great product!\nCodepen here\nCheers, \nG. @lasergoat -- Correct me if I'm wrong but you have called actions.remove on the model and then tried to reset validity on the removed Model. This would then cause the intents to be undefined? \n```javascript\nthis.localDispatch(actions.remove('local.receipts_emails', i));\nthis.localDispatch(actions.resetValidity(local.receipts_emails.${i})); //Model has already been removed with first line, therefore is undefined / has no intents. Remove this line to fix error\n```\n. @lasergoat -- \nMaybe at render the redux store is not yet updated or synced with the component state. Another race condition maybe? Also not sure how local form ties in with calling render on a component when not connected to the store. Maybe someone else has insight..\nTo quickly fix this issue associate the validation back with the component state: \nFrom this: \n```javascript\nlocal.receipts_emails[${i}]}\n   className=\"ui-input\"\n   placeholder=\"email address\"\n   validators={{ isValid }}\n   style={!get(form, receipts_emails.${i}.valid) ? errorStyle : {}}\n />\n```\nTo this:\n```javascript\nlocal.receipts_emails[${i}]}\n   className=\"ui-input\"\n   placeholder=\"email address\"\n   validators={{ isValid }}\n   style={!isValid(lineItem) ? errorStyle : {}}\n/>\n```\n. ",
    "bpdons": "@davidkpiano. I'd really like to know how I could add the error field validation message as a property  to a Control Component? This will allow me to display the error messages inline.  I'm using the Material-UI library and the property that I need to pass to the field directly is errorText. \nI can use the Error Component to display the specific field message below the textfield, but I really want it inline if possible.\nMany thanks for your expertise :)\neg.\n<Control\n          model=\".email\"\n          component={materialUITextField}\n          id=\"registerUser.firstName\"\n          name=\"firstName\"\n          floatingLabelText=\"First Name\"\n          errorText={[error message here if not valid]} \n          validators={{\n            minLength: minLength(2),\n          }}\n/>. Thanks @davidkpiano for your quick reply. I still can't manage to check the validity with your example.\nI've created a Gist of a reduced user-form.js combined with your original example file in GitHub which tries to pass the validation through to an email address Material-UI field component.\nI keep getting 'undefined' as the validity type on line 40 when logging to console.\nCan you please help with what I'm doing wrong?\nhttps://gist.github.com/bpdons/798785bc459da78054e83ee692697704\nMany thanks . ",
    "charrison-symfact": "Is it possible to disable the nested forms from being automatically created?\n\"Forms can be infinitely nested. You can have a form inside a form inside a form! Any sub-model inside a form that isn't a primitive value, such as an object or array, is considered a form. Its form state is accessed with .$form.\"\nMy data model is a structured JSON object (originally xml on the server) and I'm concerned about performance with additional form meta-data at each level.  \nThanks!\n. Excellent ... issue created as \"Disable automatic creation of nested forms for sub-models #1001\". ",
    "KokoulinM": "Good day! Tell me, please, how to organize the application architecture if I have 4 routes and each has its own forms. How to initialize objects of the form when you go to the next page?. Thanks for the answer to the previous question. I have another question: like for example the blur event to send data to Google Analytics? It is better to write middleware or make custom reducer?For example: \n dispatch(actions.blur('___'))} />\n . ",
    "bradabelgit": "@davidkpiano any response to https://github.com/davidkpiano/react-redux-form/issues/675#issuecomment-281176404? \nSo far this library looks to be exactly what I need! I am just doing a deep dive to make sure. For example, I don't want to have to specify forms.user.firstName just because the forms reducers are nested under forms in my redux store. It seems to work just fine nested there, with user.firstName when the second option to combineForms is left out. A little more clarification on why it is necessary would be awesome!. ",
    "daisy-cyt": "latest version \nI used npm install react-redux-form@latest\n\u9648\u5b87\u5a77\n\n\u5728 2017\u5e742\u670821\u65e5\uff0c\u4e0b\u53489:39\uff0cDavid Khourshid notifications@github.com \u5199\u9053\uff1a\nWhich version are you using?\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. I don't know why, but the error disappeared. So I closed the issue.. @davidkpiano I have tried your solution before, but I have to separate into two Control component because my props component is difference. So when the isEdit change, the validators did not update. here is my code before.\n\njavascript\n{ \nisEdit ? \n<Control model=\".bank_name\"\n  validators={{ isBankExist: (value) =>  true }}\n  component={componentA}\n/> :\n<Control model=\"host.bank_name\"\n  validators={{ isBankExist: (value) => isBankNameValid(value) }}\n  component={componentB}\n/>\n}\n and I find out Control component only reset validators in componentWillUnmount, that why the validators won't update I guess. so I fixed my problem with the code below. a little ugly.\njavascript\n{ \nisEdit ? \n<Control model=\"host.bank_name\"\n  validators={{ isBankExist: (value) =>  true }}\n  component={componentA}\n/> : ''\n}\n{ !isEdit ?\n<Control model=\".bank_name\"\n  validators={{ isBankExist: (value) => isBankNameValid(value) }}\n  component={componentB}\n/> : ''\n}\n. ",
    "nigredo-tori": "OK, here's the fork: http://codepen.io/nigredo/pen/ygmEGM .. ",
    "msteward": "A workaround for this is to surround the checkbox control in a <Fieldset>:\n<Fieldset model={track(`users[]`, { id: user.id })}>\n  <Control.checkbox\n    model='.experience[]'\n    value='javascript'\n  />\n</Fieldset>. ",
    "ashleyconnor": "That's correct.\nI've made an example here.\nAs you can see typing in the first field shows the error almost immediately before a user gets the chance to fill in the second. If it was possible to get the value of the first field in the second field's validation method, I think this could be solved by moving the Error component to be attached to the confirmation.. I would only want to show an error if all fields I am validating have been 'touched'. So I would need values and the dirty status for all fields in the set.\nI'm thinking maybe fieldset level validations could be a thing to maintain backwards compatibility of the existing validation API.. ",
    "divined": "Any news here?\nSimilar question:\nForm level validator. How to show  based on it by specific field touched status?\nor how to create dependent rule one field from another. i.e.:\nuser.last_name && user.last_name.length && (!user.city || !user.city.length)\n- city field is mandatory if last_name field is filled.. required: (val, vals) => vals.last_name && vals.last_name.length && (!val || !val.length)\nadd whole form values to validation function?. @davidkpiano\nok, but how to say to \"Error\" component - show message only this two fields are touched?\nbecause errors is appearing when you edit another part of form (. if (forms.user.city.touched && forms.user.last_name.touched) {\nforms <- what the variable? Where i can find it?\n. founded, ty.\nOne more question:\nCan't find action to update whole form. i.e. trigger all fields revalidating.\ntry:\nchangeAction={changeForm} to my component i want to trigger all form revalidate\nand\nfunction changeForm(model, value) {\n  return (dispatch) => {\n    dispatch(actions.change(model, value));\n    dispatch(actions.setPristine('forms.user')); <-what here?\n  };\n}. Error: input is a void element tag and must neither have children nor use dangerouslySetInnerHTML. Check the render method of wrappedInput.. ```\nconst textWithError = (props) => {\n  let inputProps = _.omit(props, ['label', 'hasError', 'wrapperClass']);\nreturn (\n    form-item error ${props.wrapperClass} : form-item ${props.wrapperClass}}>\n      {props.label}\n\n      {props.children}\n   \n  );\n};\n```\n<Control.text\n            component={textWithError}\n            model=\".first.last_name\"\n            validators={{ required: this.rv }}\n            label='Nom'\n            mapProps={{\n              hasError: ({fieldValue}) => !fieldValue.valid && fieldValue.touched\n            }}>\n            <Errors wrapper={this.errorWrapper} model=\".first.first_name\" messages={{ required: \n                 this.rMessage('Pr\u00e9nom') }} show=\"touched\" /> <- error here\n< /Control.text>. nope,\nproblem here <input type=\"text\" {...inputProps} />\nneed to exclude children from props.. using two Errors element not a variant because it is a dynamic component, and create props for each validation rule not good\n```\n<MyElement\n  validation1_rule=...\n  validation2_rule=...\n  ...\n  validation1_message=...\n  validation2_message=...\n  ...\n\n```\n\nlooks ugly.. ty ). Do you have any algorithm suggestion to fix it by using an existing api?. Fixed. Sorry, tested another error here.. Hello,\nno changes (((. 1.11.1 - problem exists.. problem if initial state is:\nfilters: {\n  some_value_1: {1: null, 2: null},\n  some_value_2: {1: null, 2: null}\n}\nthis.props.dispatch(actions.reset('myContractsForm.filters')); -> not works\nthis.props.dispatch(actions.reset('myContractsForm.filters.some_value_1')) -> works;. will try to create a codeSample.. Sorry, i'm on vacation now (. Uncaught TypeError: promise.then is not a function\nfield-actions.js?c5db:292. ```\n handleSubmit = (contracts) => {\n    this.props.dispatch(actions.submit('myContractsForms.proxy', this.validateCourtiers));\n// dispatch submit action here\n}\n\n validateCourtiers = (contracts) => {\n    return (dispatch) => {\n      dispatch(actions.setPending('myContractsForms.proxy', true));\n  dispatch(BO - REST request)\n     .then(data => {\n        //setValidityHere\n        dispatch(actions.setPending('myContractsForms.proxy', false));\n     });\n\n}\n}\n```\n. http://i.imgur.com/DA4Awbk.jpg\nvalidateForm = (contracts) => {\n    return new Promise((resolve, reject) => {\n      this.props.dispatch(api.contracts.validateProxy({data: {validate: contracts}, token: this.props.user.csrfToken}))\n        .then(errors => {\n          if (_.size(errors) > 0)  {\n            console.log('Reject');\n            console.log(errors);\n            reject(errors);\n          } else {\n            console.log('Resolve');\n            resolve(true);\n          }\n        });\n    });\n  };\nhandleSubmit = (contracts) => {\n    this.props.dispatch(actions.submit('myContractsForms.proxy', this.validateForm(contracts)));\n };. What i need to reject in Promise?\n```\n\n\n\n\n```\n```\nreject(\n {\n  $id1: {\n     numeroTiersCourtier: 'Error label',\n     numeroTiersCourtierRassises: 'Error label 2',\n  },\n  $id2: {\n     numeroTiersCourtier: 'Error label'\n  },\n  }\n);\n// not work\nreject(\n {$id1.numeroTiersCourtier: 'Error label'}\n {$id1.numeroTiersCourtierRassises: 'Error label 2'}\n {$id2.numeroTiersCourtier: 'Error label'}\n ...\n)\n// not work\n```. It works =) Thx.\nAnother question: how to reset field state in this case?\nfirst: \nreject(\n  '$id1.numeroTiersCourtier': 'Error',\n  '$id2.numeroTiersCourtier': 'Error',\n)\nsecond\nreject(\n  '$id1.numeroTiersCourtier': 'Error'\n)\nbut $id2 field still has error ((. this.props.dispatch(actions.resetErrors('myContractsForms.proxy'));. Ty ). ",
    "shinzui": "\nAs an enhancement, I'll consider passing the form metadata as the second param for validation.\n\nPlease do that. It would make validation easier. . ",
    "texas697": "it worked! thank you!. ",
    "yamsellem": "@davidkpiano you're right, the server can change values when it answers.\nI understand with your words that this is not possible \u2014 yet \u2014 with react redux form. Right?\nSomething useful could be formActions.change('forms.model', model, {sync: true}) triggered manually by the action after a successful http call. This is exactly like formActions.change('forms.model', model) but it resets pristine back to true.\nBut this is half of the problem.\nWhen the user updates a value, and updates it back to its original value, I guess comparing it to .initialValue will do the trick. So, .initialValue should be overridden when the sync flag is passed.\nSounds great?. @davidkpiano how this .isInitial will be resetted to true on server sync?. @davidkpiano dispatching load \u2014 change silently \u2014 will not rerender components.\nSo, on a server sync, load cannot be used, I guess. We want components to be refreshed.\nIMO, syncing a form with a server and knowing it's in sync it's not really use-case specific. Syncing with a server is a form fate ;-).\nIf this .isInitial can also be manually reseted it's perfect, like formActions.change('forms.model', model, {initial: true}). \n\nPlus, it can add some cool features, like disabling a save button on initial, or displaying an alert on not initial if back is clicked.\n\nps. looking at the field attributes initial seems more likely than isInitial. May I ask why do you choose isInitial? It would look like:\n``javascript\nforms.user.name.isInitial;\nforms.user.name.pristine;\nforms.user.name.focus;\n````\n. @davidkpiano any news about this? Thanks ;-).. @davidkpiano maybe.unchanged` should do the trick?\nUsing load as you said don't solve my issue, because, I'm also trying to activate / deactivate back and save buttons. An .unchanged attribute and its formActions.change('forms.model', model, {unchanged: true}) will greatly help ;-).\nps. by the way, I don't clearly see the point of pristine. This .unchanged sounds way useful to me.. @davidkpiano if I understand correctly what you said, formActions.load('forms.model', model) resets initialValues and pristine? And formActions.change('forms.model', model) updates only the model and sets pristine to false and don't update initialValues?\nMy use case:\n fetch data from the server\n display a form that the user can interact with\n render back and save buttons according to the unchanged state of the model\n fetch data from the server\n* etc. @davidkpiano so, where do we go from here?. Yes, that behavior seems perfect to me.\nI am wondering what will be the impact of silencing every server sync \u2014 even the first one?\nIn my understanding, silencing changes the field values and rerender, but don't change the form status, so the focus stay in place and co. And silencing can be done for the first change call. Is this correct?. By using load or the change's silent option.. @davidkpiano to rephrase it: what is the impact of silencing every server sync with formActions.load('forms.model', model) \u2014 even the first one? \nThe scenario could be the following:\n an api call that load the model (GET /model)\n a user input that change the model\n a user save that triggers an api call that load the model (PUT /model)\n a user input that change the model\n* ...\nThe goal is to properly display:\n a save button only if the model is not .unchanged since the last sync (aka the last load)\n a cancel button that display a are your sure you want to ignore your updates? only if the model is not .unchanged since the last sync (aka the last load)\nSomething is not quite clear in the doc: \"actions.load(model, value) is equivalent to actions.change(model, value, { silent: true })\". But IMO loadis also updating .loadedValue which change does not. Am I right?\nps. in fact the load action documentation says nothing about .loadedValue. ",
    "dl-git": "bump.... ",
    "obykoo": "I debugged it in Redux Dev Tools and this is what is causing problem:\n1. First rrf/change is called , which clearly do what it should do.\nsilent: false,\n  multi: false,\n  removeKeys: [\n    1\n  ]\nWhen I look at Diff , I  can clearly see , that [1] index is removed from both model and form as it should be, but here comes the problem:\nNow rrf/resetValidity is called\n{\n  type: 'rrf/resetValidity',\n  model: 'data.someArray[1]',\n  omitKeys: [\n    'something'\n  ]\n}\nand this adds back object with null value at index [1] in form reducer. https://github.com/davidkpiano/react-redux-form/issues/619 .. this seems like exactly same issue I am having.\nFrom my debugging it seems , that when there is custom control with or without validation (validation is then in Form) , ref/resetValidity is always called after deleting item\nI tried to fork codepen from yours , but I did not manage to make it working. Maybe you can fix some error and make it working.\nhttp://codepen.io/anon/pen/NpPoMO. ",
    "benmann497": "Brilliant, thanks for your help.. ",
    "smattt": "I'm experiencing the same issue.\nI have a lot of pages that display forms with 20+ form elements. The majority of the form elements are Material-UI components that have been setup to work with RRF. The TextField in Material-UI only offers an onChange method, so I listen on that and dispatch actions.change as-appropriate. The problem is that the onChange method fires on every key press, as it should - per its name, but it's causing the entire UI to redraw constantly. This results in terrible performance in Chrome and nearly unusable performance in IE11. \n```\nclass MaterialTextField extends BaseMaterialControl {\n    constructor(props: Props) {\n        super(props);\n    }\npublic render() {\n    return (\n        <div>\n            <Control.text\n                asyncValidateOn='blur'\n                component={TextField}\n                debounce={1000}\n                {...this.GetControlMapping(this.props) }\n                mapProps={{\n                    fullWidth: true,\n                    onChange: (props): ((ev: any, value: any) => void) => this.HandleTextChange(props),\n                } as any}\n                model={this.props.model}\n                updateOn='blur'\n                validateOn='blur' />\n        </div>\n    );\n}\n\nprotected GetControlMapping(props: Props) {\n    return {\n        asyncValidators: props.asyncValidators,\n        disabled: props.disabled,\n        errorText: this.GetErrorMessage(props.fieldState, props.messages),\n        floatingLabelFixed: props.floatingLabelFixed,\n        floatingLabelText: props.label,\n        inputStyle: props.inputStyle,\n        type: props.type || 'text',\n        underlineDisabledStyle: props.underlineDisabledStyle,\n        validators: props.validators,\n    };\n}\n\nprotected HandleTextChange = ({ model, dispatch }, options = {}): ((ev: any, value: any) => void) =>\n    (ev: any, value: any): void =>\n        dispatch(actions.change(model, value, options));\n\n}\nexport default muiThemeable()(MaterialTextField);\n```. Ping... Interested in seeing if this was resolved or not.\nI'm also reworking how we handle forms now and have been recently moving towards a more dynamic model, where I download N form configurations at runtime and would like to inject them into RRF. To further complicate this, one key change I'm trying to make work is that I'd like to store all field values in a single, shared reducer state, this will keep field values in sync across forms if they share an underlying ID - which is a business requirement. I'd like to dynamically inject forms at runtime, which use a slice of the shared reducer state, but ideally still produce unique form state for each dynamic form (so I can quickly and easily check form completeness, for example).\nI'll plow ahead on my own but I'd be interested in hearing if you've already overcome any of these challenges, OP.\nThanks!. I have the same issue that tberster is describing.\nI'm dealing with dynamic forms that vary based on customer requirements. Sometimes we display a field, such as a Y/N question, and if the user selects 'Y' then we might inject an additional form field that requests a description. The description form field also has validation rules that require valid input.\nThis all works great with RRF, but the problem is when the user goes back to the Y/N question and changes their answer to 'N' - the description form field is no longer needed and now gets removed from the UI but its form state remains within in RRF. Due to its failing validation rules, the form is now incomplete and invalid.\nI made progress on the issue by detecting when we are going to hide a form field and then firing off actions.resetValidity for the appropriate form field. After interacting with the form again (change any value), things begin working properly and the form reports that it is in a valid state. I need to make this work immediately, without requiring the user to interact with the form, so I'm continuing to poke around for a better solution.\nThe actions.destroy functionality being discussed seems like it would solve my problem as well.. I'm in a somewhat similar boat and have posted my issue here, in case that helps. . I'm still struggling to make this work.\nSo far, I've been able to dynamically create forms for the various steps in my application. That is working great. The problem is, my fields should have models that point at an entirely different reducer for reading & writing field values to Redux. If I set a Form's model to point at 'dynamic', it seems that I cannot set its child fields to have full models like 'package.businessName' - it only works when I use the partial model '.businessName' but that obviously results in the data being stored in 'dynamic.businessName' rather than 'package.businessName'.\nThe closest that I've gotten has been to store the field values in 'package', have all of my form steps use 'package' for the model, have all fields use partial models like '.businessName', etc. In my various field controls, I listen for onChange and similar events and then fire a custom dispatch to create 'dynamic.form{X}.fieldName'. This custom dispatch creates a new dynamic form and all of the fields are added to it, as the user changes their values... but the downside is that the FormState doesn't stay in sync across my duplicated items, the fields are missing from the FormState until the user inputs a value for them, etc. I could work around the issue with the fields missing up front, but I'm not sure I can easily duplicate FormState and FieldState to a different reducer while also keeping them in sync over time.\nThanks!. Maybe my expectations are incorrect, but I assumed since RRF supports both full and partial models at the Field/Control level that it is possible to create FormState stored in one location but using Field/Control data from another location (fully qualified model path).\n\nIdeally, I'd like the following setup:\n\nSingle data reducer named 'package'. Field values are retrieved and persisted to 'package' reducer.\nDynamic form named 'dynamic', so we can nest our 'virtual' forms underneath.\nEach form step would have a FormState nestled within 'forms.dynamic'. It would contain metadata on all of the fields we rendered in the form step.\n\nThis would result in a central location for all field values and individual virtual forms for each form step. Each form step is effectively a slice of the 'package' data. I could easily check FormState to determine step completeness by checking the appropriate virtual form. If a field is shown twice throughout the overall form application, we can be sure to keep its value in sync without the extra overhead/risk of doing it manually. Now that all of the data would be kept together, it simplifies some operations like incremental backups, rehydrating saved data, etc.. In the end, I gave up on trying to generate virtual forms composed of fields that live outside of its scope. I'm no longer going to use FormState to check status, instead I'm going to scan FieldState with some custom logic that seems to produce the same results.. ",
    "CradCradHereCrad": "I debugged it in Redux DevTools and looked into state , but only with \"valid: false\" is form , nothing else........\n. I have little bit more complex form with lot of custom controls, so its hard to tell why this is happening.\nAny idea why could everything be valid but not whole form?\nI tried to create codepen with at least custom component, but its not working.\ncomponent={TextInput}\nprobably does not work\nhttp://codepen.io/anon/pen/EWNgOP\n. ",
    "marceux": "Thanks, I'll submit one later. Love the library so far.. ",
    "mvanlonden": "@davidkpiano I'm having the same issue but for the Fieldset component. ",
    "Aryk": "@davidkpiano : should I reopen a new ticket for \nsetFieldsErrors\nsetErrors\n...anything else where you can set async: true?\nThe example you gave here will throw a TS error because of the third parameter: https://github.com/davidkpiano/react-redux-form/issues/649#issuecomment-278801937\n. Thanks for fixing this, sorry I didn't get around to the PR, I got side-tracked on some stuff.\n. Oh noticed the extra options wasn't added, would you still like me to PR it?. ",
    "rtkhanas": "Yes, I will try to check this as soon as I have a bit of free time!. I'm not using this project yet, so had to change to look at this issue. \ud83d\ude22 . ",
    "januszdotnl": "Any luck @rtkhanas ?\nIn the mean time, I'll give it a shot @davidkpiano ... Once you go RRF, you never go back :smile: . This actually helped me allot @asafigan ! Much appreciated.. Hi David,\nExactly what I needed to solve this issue! Thank you so much! For future reference and others here is my solution:\nThe control:\njsx\n<Control\n  model='.email'\n  label='Email'\n  errors={{\n    required: val => !val.length,\n    validEmail: val => !isEmail(val), // NOTE: isEmail is the validator package as mentioned in the docs.\n  }}\n  validateOn='change'\n  mapProps={{\n    required: ({ fieldValue }) =>\n    fieldValue.errors.required && fieldValue.touched && !fieldValue.valid,\n    validEmail: ({ fieldValue }) =>\n    fieldValue.errors.validEmail && fieldValue.touched && !fieldValue.valid,\n  }}\n  component={renderInput}\n/>\nThe custom render:\njsx\nconst renderInput = ({ label, required, validEmail, ...otherProps }) => {\n  return (\n    <FormField\n      className='authForm'\n      error={required ? 'This field is required.' : null ||\n              validEmail ? 'Please enter a valid email.' : null} // NOTE: Might make a function function for this but I think this is still readable.\n      label={label}\n      {...otherProps}\n    >\n      <TextInput {...otherProps} />\n    </FormField>\n  );\n};. @davidkpiano I think I forgot to add a file similar to native.js in the root folder (with module.exports = require('./lib/native');) so you can import it as import { Control } from 'react-redux-form/**android**'; ?. ",
    "TheMightyPenguin": "@januszdotnl hey have you done any work on this? I'm thinking on giving it a try to open a PR! \ud83d\ude04 . ",
    "Jahans3": "@TheMightyPenguin did you open a PR in the end? :). @davidkpiano submitted a PR :-). Do you mean as a dependency? That would make sense, although personally I\nwould be against the idea of distributing it as a separate supporting\npackage\nOn Tue, 9 Jan 2018 at 16:35, Rikki Tooley notifications@github.com wrote:\n\nHey just passing by, as a non-react-native user, I think it would be good\nto not introduce a package only relevant to react-native users into this\npackage. Can't these controls be distributed separately?\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/davidkpiano/react-redux-form/pull/1062#issuecomment-356339018,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AMNuB-hvkU2tj2uG3qgXC4m4lSqbin3Bks5tI5VpgaJpZM4RYF4m\n.\n. \n",
    "jpmelnik": "@davidkpiano  Thanks!\n```jsx\n// Libs\nimport React, { Component, PropTypes } from 'react'\nimport classNames from 'classnames';\nimport {bindActionCreators} from 'redux';\nimport {connect} from 'react-redux';\nimport { Form, Control, Field, Errors } from 'react-redux-form';\nimport validator from 'validator';\n// Actions\nimport { calculateIMC } from '../actions';\n// Components\nimport Display from './display';\nconst isRequired = (val) => val && val.length > 0;\nconst lessThan10 = (val) => {\n  const lessThan = 10;\n  if (!(val < 10)) {\n    return { lessThan };\n  }\n  return false;\n};\nclass IMC extends Component {\n  constructor( props ) {\n    super( props );\nthis.state = {\n  weight: this.props.weight,\n  height: this.props.height,\n};\n\nthis.onSubmit       = this.onSubmit.bind(this);\nthis.onWeightChange = this.onWeightChange.bind(this);\nthis.onHeightChange = this.onHeightChange.bind(this);\n\n}\n  onWeightChange( model, value ) {\n    this.setState((prevState, props) => {\n      return { weight: +value };\n    });\n  }\n  onHeightChange( model, value ) {\n    this.setState((prevState, props) => {\n      return { height: +value };\n    });\n  }\n  onSubmit() {\n    this.props.calculateIMC( this.state.weight, this.state.height );\n  }\n  render () {\n    let buttonClasses = classNames('btn', {\n      status: this.props.button.status\n    })\n    return(\n      \n\n{this.props.title}\n\n\n this.onSubmit(imc)}\n          >\n            \n        <div className=\"form-group\">\n          <label htmlFor=\"user-weight\">Your Weight?</label>\n          <Control\n            id=\"user-weight\"\n            className=\"form-control\"\n            type=\"number\"\n            model=\".weight\"\n            changeAction={this.onWeightChange}\n            placeholder=\"Weight\"\n\n          />\n        </div>\n\n        <div className=\"form-group\">\n          <label htmlFor=\"user-height\"> Your Height? </label>\n          <Control\n            id=\"user-height\"\n            className=\"form-control\"\n            type=\"number\"\n            model=\"deep.imc.height\"\n            changeAction={this.onHeightChange}\n            placeholder=\"Height\"\n          />\n        </div>\n\n        <Control.button model={this.props.model} type={this.props.button.type} className={buttonClasses}>\n          {this.props.button.name}\n        </Control.button>\n      </Form>\n    </div>\n  </div>\n);\n\n}\n};\nIMC.propTypes = {\n  title: PropTypes.string,\n  weight: PropTypes.number,\n  height: PropTypes.number,\n};\nIMC.defaultProps = {\n  model: 'deep.imc', // Review\n  title: \"\u00cdndice de Masa Corporal (IMC)\",\n  weight: undefined,\n  height: undefined,\n  button: {\n    type: 'submit',\n    status: 'btn-success',\n    name: \"Calcular!\",\n  }\n};\nconst mapDispatchToProps = ( dispatch ) => {\n  return bindActionCreators( { calculateIMC: calculateIMC }, dispatch );\n};\nexport default connect( undefined, mapDispatchToProps )( IMC );\n```. ",
    "guywald1": "@davidkpiano , is there a reason defaultValue is not in the docs? Or fine to use?\nThanks!. @davidkpiano \nThanks for taking the time to reply! I currently have a project in which I receive default values as props to some component that renders a Form component.\nI would export an \"initialState\" object for the reducer of that form in the module but I am not sure how to approach setting initial state inside my wrapper component.\nWhat would be best practice in that scenario?. ",
    "dragGH102": "@davidkpiano sure.\n```\nexport function mapDispatchToProps(dispatch) {\n  return {\n    onFormSubmit: (values) => {\n      dispatch(storeProfile(values));\n    },\n};\n}\n// connect reducers for model updating based on state\nexport default connect(mapStateToProps, mapDispatchToProps)(ProfileForm);\n```\n\nIt works as intended. The issue is only with loading data into the model\n. same issue here. \n",
    "hellojere": "@lasergoat Thanks for this already! I would highly appreciate a walk through for changing values outside of the LocalForm. Basically what I'm trying to do is to get an image uploader working inside the LocalForm, so I need to update values inside a custom function. \nAlso, is there a way to keep some values in the form and have them returned on submit without creating <Control> components for them?. Thank you so much! . ",
    "kenta88": "@davidkpiano nope. This solutions is not working for my purpose. I would like to use a custom initialFieldState. Is not possible? . here my solution\n```jsx\nconst customFormReducer = (state: Store, action: Action) => {\n    switch (action.type) {\n        case 'rrf/reset': {\n            const updatedState = Object.assign({}, state);\n            Object.keys(updatedState).forEach((key) => {\n                updatedState[key] = {\n                    ...updatedState[key],\n                    ...initialFieldState,\n                };\n            });\n            return updatedState;\n        }\n        default: {\n            return state;\n        }\n    }\n};\nexport const model = modelReducer('modules.settings.forms.userPassword', initialState);\nexport const form = formReducer('modules.settings.forms.userPassword', initialState, {\n    initialFieldState,\n    plugins: [customFormReducer]\n});```. ",
    "chanakasan": "@zabojad I see the same thing and I'm using v1.8.1 as well.\nI'll try to reproduce this in a codepen.. ",
    "Juandresyn": "If anyone is still looking for an answer, Control.Checkbox has a defaultValue props, simply pass a boolean to it.. > Is there any other way? I'm using Localform so I cannot set the initial state. defaultValue doesn't work either\nYou can also use the model prop\n. ",
    "Gricardov": "Is there any other way? I'm using Localform so I cannot set the initial state. defaultValue doesn't work either. ",
    "tchristian32": "Do you have an example showing that?  Just want to see how to show steps and see if you can do two things:\n\n\nAllow branching (if you choose answer A, we go down one path.  Answer B down another)\n\n\nCan I inject steps dynamically (if we make an API call, can I use the results from that to add additional steps into the form?. Thanks @davidkpiano .  That helps a lot.  Is there an example showing how to make a wizard?  Like showing one step at a time with a next button?. Nevermind, I figured it out.  Thanks again. \n\n",
    "knynkwl": "@tchristian32 do you have an example that you can post?. ",
    "AndyTriumpH": "Thanks. I am out of the office now and I will have to try this when I am\nback in.  What you have said sort of makes sense. I read that the pristine\nflag when set to false stops the validation from firing on load of the\ncomponent. This I played with by setting it to true and the message\ndisplayed on load and then cleared when the model updated but not the other\nway around.\nAndy\nOn 24 Mar 2017 17:16, \"David Khourshid\" notifications@github.com wrote:\n\nYou have show={{ pristine : false }} which says to show the error message\nonly when the model is not pristine. If the user never changes the value,\nthe model is still pristine. Try removing that and see if it works.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/davidkpiano/react-redux-form/issues/719#issuecomment-289085780,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AZFhoZP97H5rWCYCiYiQ-AyQeIi4pMgwks5ro_pngaJpZM4Mohi6\n.\n. Hi David\n\nRemoving the pristine flag hasn't worked and, the error message was\ndisplayed on load of the component, and then disappeared on clicking of a\nradio button.\nDo you have any other ideas?\nThanks\nAndy\nOn 24 March 2017 at 18:08, Andy Riome andyriome@googlemail.com wrote:\n\nThanks. I am out of the office now and I will have to try this when I am\nback in.  What you have said sort of makes sense. I read that the pristine\nflag when set to false stops the validation from firing on load of the\ncomponent. This I played with by setting it to true and the message\ndisplayed on load and then cleared when the model updated but not the other\nway around.\nAndy\nOn 24 Mar 2017 17:16, \"David Khourshid\" notifications@github.com wrote:\n\nYou have show={{ pristine : false }} which says to show the error\nmessage only when the model is not pristine. If the user never changes the\nvalue, the model is still pristine. Try removing that and see if it works.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/davidkpiano/react-redux-form/issues/719#issuecomment-289085780,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AZFhoZP97H5rWCYCiYiQ-AyQeIi4pMgwks5ro_pngaJpZM4Mohi6\n.\n\n\n. Fixed issue by using touched,  but when you load the data model back into\nthe form, even though the radio button has the correct value set, you then\nhave to click the button again to stop the validation from firing. Is there\na way round this?\n\nOn 6 Apr 2017 15:27, \"Daniel\" notifications@github.com wrote:\n\n@AndyTriumpH https://github.com/AndyTriumpH can you inspect the\n.myModel.valueToSet.$form and see if errors are listed there?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/davidkpiano/react-redux-form/issues/719#issuecomment-292191445,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AZFhoaAtzKczKnmsmtOf6CZNkUhpH_0Pks5rtPZWgaJpZM4Mohi6\n.\n. \n",
    "asadowns": "This issue was resolved by updating material-ui from \"material-ui\": \"0.16.4\" to \"material-ui\": \"0.17.1\" in case anyone else is having the same issue.. ",
    "danedavid": "@davidkpiano  @guywald1 \nIt's not working in the Markdown docs inside Github..\nTwo solutions:\n1. Either wrap the headings in html <a> tags with name attributes, or\n2. Update the anchors at the top to include correct links (eg: #actions-change-model-value-options)\nIf anyone can say which is preferred, then I can submit a PR. Ok I'm on it :+1:  Will open a PR in a couple of days. Let me check whether all docs must be changed, or just the API docs... Ok, I think some anchors area still not working when it came to github, so closing. Will reopen later.. ",
    "BryceByDesign": "If it helps. I seem to have no issues on componentWillReceiveProps. However, setting the load action creator on componentWillMount still throws an error.\ncomponentWillMount() {\n        const { settings, setDefault } = this.props;\n        if (settings) setDefault('settings', settings);\n    }\nConnect\nexport default connect(null, {\n    setDefault: (model, value) => actions.load(model, value)\n})(FormComponent);\nThere was an error with componentWillReceiveProps as well until I set the proper model path as mentioned here\n\nWith nested form state:\nconst store = createStore(combineReducers({\n  something: somethingReducer,\n  forms: combineForms({ foo: initialFoo })\n});\nYou now get this shape:\n{\n  something: ...\n  forms: {\n    forms: { foo: ..., $form: ... }\n  }\n}\n\nSo I updated my Form Component model from settings to forms.settings\n<Form model=\"forms.settings\"...\nThen no issue with this the componentWillReceiveProps lifecylce method\ncomponentWillReceiveProps(nextProps) {\n        const { settings, setDefault } = this.props;\n        if (nextProps.settings) {\n            setDefault('settings', nextProps.settings);\n        }\n    }. ",
    "VictorBaron": "I also had a lot of problems to make RRF work with MUI components. I could not pass any props to the component, so had to use the default one (not very useful).\nThe Field was also losing the focus after every input.\nIt seems related since if I used only the TextField (not as a component in a Control.text), the TextField worked but the Form, as expected, didn't.\nI found a work around by using Material Components instead of Material-UI, but still.\nHere is the code, where I tried to pass a props to TextField: \nrender() {\n    const CustomInput = props => (\n      <Control.text\n        model={props.model}\n        component={TextField}\n        updateOn=\"change\"\n        ignore={['focus', 'blur']}\n        controlProps={props.controlProps}\n      />\n    );\nreturn (\n    <Form \n     model=\"form.project\"\n      onSubmit={project =>  this.handleSubmit(project);  }\n      form=\"form\"  >\n      <fieldset className=\"field\">\n        <label>Title </label>\n        <CustomInput\n          model=\".name\"\n          controlProps={{\n            floatingLabelText=\"foo\"\n          }}\n        />\n  </fieldset>\n\n</Form> \n   )  \n}\nI feel like I'm missing something in there, but tried virtually every solution and none fully worked. If you have a solution, it'd be helpful !\nThanks !. I feel really idiot : while working on reproducing it on CodePen, I figured out I had accidentally downloaded the alpha version 1.0.0 from MUI. The problem came from there, it works fine with the last stable version, 0.17.2.\nThanks for the help though !. ",
    "galkinrost": "@davidkpiano maybe use some \"key\" property for array fields? like in the React API. ",
    "joinjoohny": "js\n<City\nmodel=\"checkout.city\"\nvalidators={{\n      required: val => val && val.length === 15,\n  }}\n />\n <Errors\n   className=\"errors\"\n    model=\"checkout.city\"\n     show=\"touched\"\n      messages={{\n      required: 'Incorrect message ',\n   }}\n />\nIn other words, how to make work react-select with react-redux-form\nOr I should use something like this:\n```js\nimport { createFieldClass, controls } from 'react-redux-form';\nimport TextField from 'material-ui/lib/text-field';\nconst MaterialField = createFieldClass({\n  'TextField': controls.text\n}, {\n  componentMap: {\n    TextField: TextField\n  }\n});\n// render():\n\n\n\nThx. This works for me.\nhttp://davidkpiano.github.io/react-redux-form/docs/guides/custom-controls.html\nThank youjs\n         val && val.length,\n          }}\n          validateOn=\"change\"\n          mapProps={{\n            value: props => props.modelValue,\n            onChange: props => props.onChange,\n          }}\n        />\n```. ",
    "ndevvy": "This was meant for redux-form.. Hey, thanks for the comp! \ud83d\ude3a  react-redux-form was actually my initial choice for what we're doing, but I went with redux-form for various reasons.  Could be worth revisiting.. ",
    "igorgripas": "Found answer here https://github.com/davidkpiano/react-redux-form/issues/590. ",
    "bovan": "Thanks for help, I've tested a bit and manual input seems to work like in your example (where you put SingleDatePicker) as component.\nunfortunately, to remove all react-errors I have to wrap the component like\njs\nconst dateField = (props) => {\n            const fieldProps = omit(props, [\"model\", \"name\", \"onBlur\", \"onChange\", \"onFocus\", \"onKeyPress\", \"value\"]);\n            return <SingleDatePicker {...fieldProps}/>;\n        };\nand use that as component, and then it stops working again. even just using \njs\nconst dateField = (props) => <SingleDatePicker {...props }/>;\n seems to be enough to stop it from working\nI'll continue to dig into this, any tips would be greatly appreciated, thanks again.. sorry, thought the description was enough (probably as I had just read through 5 similar issues) \nit's the unknown props warning warning.js?3efc:36 Warning: Failed prop type: SingleDatePicker: unknown props found: name, onChange, onBlur, onFocus, onKeyPress, value\nThis is when I use <Control component={SingleDatePicker} />\nIf this isn't supposed to happen I can open an issue. ",
    "andrewsplice": "Hey, future humans!\nI had the same problem with a custom password thingy (leveraging react-bootstrap)\nThe fix has been applied to Control.text, as you can see in the commit. If you just use normal \"Control\" it will still give you this trouble. Use \"Control.text\" with your password boxes.\n@davidkpiano , I'm not sure how you want to fix this, you could apply the fix to the Control object in general, OR you could update your documentation here: http://davidkpiano.github.io/react-redux-form/docs/api/Control.html\nWhere it currently says:\nYou can add other input types to the basic <Control> component as an attribute: <Control type=\"password\">\nYou could change it to:\nYou can add other input types to the basic <Control> components as an attribute: <Control.text type=\"password\">. That would be the sexiest option. I give you the thumbs up emoji. \ud83d\udc4d\nYou are the best of men. Keep up the great work!. ",
    "derrickbeining": "EDIT\nDisregard my original comment; I discovered that the error was mine. Everything works as expected with no warnings. I didn't properly spread the return value of createForms onto the reducers object being passed to combineReducers. Somehow the  and  components were successfully updating the store, but the modelValue changes weren't being communicated back to the components. That's why there was a mismatch between viewValue and modelValue and why my components were initially rendering without any value attribute on the HTML.\nSorry for my confusion!\n\nORIGINAL\n@davidkpiano , I'm just getting started with RRF and immediately ran into this issue setting up a basic login form. I'm using v.1.16.3. I've read through all the previous issues you've closed for this matter, but I'm still not sure what the canonical solution is.\nFor each of these implementations:\n<Control.input type='email' model='login.email' id='login.email' />\n// or\n<Control type='email' model='login.email' id='login.email' />\n// and \n<Control.input type=\"password\" model='login.password' id='login.password' />\n//or \n<Control type=\"password\" model='login.password' id='login.password' />\nI get the typical warning: Warning: A component is changing an uncontrolled input of type email to be controlled. This is unexpected because the docs lead me to think this is the right way to do it. Quoting here: \n\"You can add other input types to the basic <Control> component as an attribute: <Control type=\"password\"\"\nI tried @andrewsplice 's tip about using <Control.text type=\"email\"> and <Control.text type=\"password\"> and that does prevent the warning. But it looks like you added the <Control.password > option. I just tried it and it worked fine. But this update to the source is not reflected in the docs. Would you like help with that?\nIt looks like <Control.email> didn't get its own component. Should the docs also be updated to demonstrate the <Control.text type=\"email\"> solution to that? Or are you do you want to add <Control.email> as well?\nI also came across a solution of my own as I was experimenting. After reading this section on Model and View Values in the Custom Controls article, I decided to try using props.mapProps to see if I could just bypass the this.state.viewValue that appears to be responsible for the actual value that gets rendered to the DOM element.\n<Control\n      type='email'\n      model='login.email'\n      id='login.email'\n      mapProps={{ value: ({ modelValue }) => modelValue }}\n/>\nThis also prevents the warning about switching between controlled and uncontrolled states, which makes me think that somewhere in the source code, there is a disconnect happening between the modelValue and the viewValue. I think it must be at the time of the app initializing, because when I look at the HTML that gets rendered initially, the <input type=\"email\" /> has no value attribute on it, whereas when I use <Control.text type=\"email\" /> it does get value=\"\" on the element (rendering the default '' value from the model in Redux). No idea where the disconnect could be happening, but I wonder if it has something to do with empty strings being falsey. Sound plausible?\nThis made me curious: Why make your Control component have to deal with two sources of truth, one in the Redux store and one on local component state? Why not just make the Control component render whatever it gets from the model in the store?\nAnyhow, I'd appreciate some clarification on the canonical solution for the problem. And let me know if you want help updating the docs with whatever you decide to go forward with.. ",
    "bryan-foong": "Any alternative for actions.merge if we're not using redux-thunk? . Ok thanks for the solution! But will it affect performance to dispatch multiple change actions if I have a large form?. ",
    "gmeans": "@davidkpiano thanks for the explainer, as @thomasboyt mentioned we were going off of the docs.\nRegarding the predefined <Control />s  do they do anything beyond controlling how props are mapped to the the component={}? I'm just wondering if we should watch out for things like Autocompletes that might not map clearly to an HTML input.\nIs this section in the docs valid for <Control />?\n\nTo prevent naming collisions or for more predictable prop-passing behavior, you can also specify the props in the controlProps={...} prop.\n\nSpecifically if I specify the controlProps here will <Control /> pass them?\nThanks!. ",
    "daxiang28": "I was able to hack this together and it seems to work in case it helps anybody prior to 'formatting' being officially released:\n```jsx\nimport numeral from 'numeral';\nimport MaskedInput from 'react-text-mask';\nimport createNumberMask from 'text-mask-addons/dist/createNumberMask';\nconst numberMask = createNumberMask({\n    prefix: '',\n    suffix: ''\n})\nconst MyTextInput = (props) => ;\n val && val.length,\n        minLength: val => val && val.length > 3\n    }}\n    parser={(val) => { return (val) ? numeral(val).format('0') : val; }}\n/>\n```\nI think the trick is the parser cleaning it back up for validation. . @joshacheson I was wondering if you were able to move past a simple proof of concept of the example defined here. A simple form seems to work in my case except for when field level validation is required. . @joshacheson I appreciate the detailed response. I think we're headed down a similar route, but could probably get away with the RRF LocalForm since we don't have a lot of form instances. I am a little curious about the abstraction of the actions API and what you dit there. . ",
    "brycesenz": "@davidkpiano - any thoughts on the PR?  I'll have some time this weekend to work on any revisions you might see fit.. I've just run into this bug as well.  It seems like (and I can verify this is the CodePen example provided by @spartDev ) that there's some conflict between dynamic models names and validation.  In other words, removing validation constraints allows form submit actions to fire again.\nI'm trying to work on a patch for this now, and will keep this thread updated.. So, playing around with this I seem to have learned a few things.  You can see this updated CodePen example to play around with what I'm talking about: https://codepen.io/brycesenz/pen/bxamro\nObservation 1:  In our example, I've initialized the state assuming that I know there is one user with an ID of 1234:\nconst initialUsersState = {\n  '1234': {},\n};\nconst store = createStore(combineForms({\n  users: initialUsersState,\n}), applyMiddleware(...middlewares));\nIf I create a form that references this particular user model (users.1234), all validation, submission handling, failed submission handling, etc. seems to work well.\nHowever, if I create a form that references a different user model (users.1235), form submission does not work.  That observation holds whether I create the reference to user.1235 as a hardcoded value or do it dynamically with an id property.  It seems likely that given the original code, the issue is related to a user with that ID not being part of the original data store.\nWhat is unclear to me though is how this should behave.  In the case where we start with an empty collection of users and want to query it from an external endpoint, how are we supposed to re-initialized those models so that they work?  @davidkpiano - any thoughts?. Ok, so here's the culprit - In utils/get-form.js, we have this code:\n```\nconst getFormStateKeyCached = (() => (state, modelString, s = defaultStrategy) => {\n  if (formStateKeyCache[modelString]) return formStateKeyCache[modelString];\nconst result = getFormStateKey(state, modelString, s);\nformStateKeyCache[modelString] = result; // eslint-disable-line no-return-assign\nreturn result;\n})();\nfunction getForm(state, modelString, s = defaultStrategy) {\n  const formStateKey = getFormStateKeyCached(state, modelString, s);\nif (!formStateKey) {\n    return null;\n  }\nconst form = s.get(state, formStateKey);\nreturn form;\n}\n```\nThat formStateKeyCache is the problem; if I remove that, things work perfectly.  I'm working on trying to put together a PR that fixes whatever is going wrong with caching.. @davidkpiano - it's not clear to me why my build is failing on Travis CI, as all of the specs seem to pass.  Any insight that you could provide which would help get this cleared to merge faster would be greatly appreciated.\nI suspect this PR may also address the issue here - https://github.com/davidkpiano/react-redux-form/issues/1055\nEDIT:  Apologies for dumb linting errors.  All is green now.. Hello @MikolajC ,\nI was able to get react-select to work with this project using the Custom input type.  I'm not sure that this is the most optimal way, but please have a look at my code below:\n```javascript\nclass DummyForm extends React.Component {\n  attachDispatch(dispatch) {\n    this.formDispatch = dispatch;\n  }\nupdateMySelect(e) {\n    const rawValues = _.map(e, (valObj) => valObj.value );\n    this.formDispatch(actions.change('myForm.mySelect', rawValues))\n  }\nhandleSubmit(formValues) {\n    this.props.onSubmit(formValues);\n  }\nrender() {\n    const myReactSelect = (props) => {\n      const options = [\n        { label: 'Option 1', value: 'option1' },\n        { label: 'Option 2', value: 'option2' },\n        { label: 'Option 3', value: 'option3' },\n      ];\n  const valueMap = _.map(props.value, (value) => { return { value: value, label: value }; });\n\n  return(\n    <Select\n      multi={true}\n      name=\"form-field-name\"\n      value={valueMap}\n      options={options}\n      onChange={this.updateInformationCategory.bind(this)}\n    />\n  );\n};\n\nreturn (\n  <div id=\"my-form\">\n      <LocalForm\n        model=\"myForm\"\n        getDispatch={(dispatch) => this.attachDispatch(dispatch)}\n        onSubmit={(values) => {\n          return this.handleSubmit(values);\n        }}\n        initialState={{\n          mySelect: this.props.mySelectValues,\n        }}\n      >\n        <div className=\"input-field\">\n          <Control\n            model=\"myForm.mySelect\"\n            component={myReactSelect}\n          />\n          <label for=\"myForm.mySelect\">Select Values</label>\n        </div>\n        <button>Submit!</button>\n      </LocalForm>\n  </div>\n);\n\n}\n}\n```. @davidkpiano - linting issues fixed; we should be good to go.  Thanks for the quick review, and thanks again for such an awesome library!. ",
    "ryanheathers": "Thanks, I tried repro'ing in your Codepen template but couldn't trigger the error. The Codepen environment has pretty different tooling than my setup so it makes it a bit challenging to get an apples-to-apples test. The error is still happening for my local build, so I'll keep playing around and see if I can narrow down a cause. For now I'll go ahead and close this ticket.. ",
    "ajits731": "Sure ! Here is the code : \n```jsx\nrender() {\n    const heads = [{\n      name: \"Item 1\"\n    },{\n      name: \"Item 2\"\n    },{\n      name:\"Item 3\"\n    }];\n    var selectRowProp = {\n    mode: \"checkbox\",\n    clickToSelect: true,\n    bgColor: \"rgb(238, 193, 213)\",\n    // onSelect: this.onRowSelect.bind(this),\n    // onSelectAll: this.onSelectAll.bind(this)\n };\n\nreturn (\n\n        <div className=\"page-container page-navigation-toggled page-container-wide\">\n        <Sidebar />\n          <div className=\"page-content\">\n              <Header />\n              <SettingsHeader />\n               <ButtonGroup className=\"suserbtn\">\n               <Link to=\"/addhead\" className=\"btn btn-primary\"><i className=\"fa fa-plus\" aria-hidden=\"true\"></i>Choose Header</Link>\n               <Link to=\"/header\" className=\"btn btn btn-danger\" onClick={this.onDeleteClick.bind(this)}>Delete</Link>\n               </ButtonGroup>\n\n\n              <BootstrapTable  \n                  data={ heads }\n                    selectRow={selectRowProp}\n                     pagination className=\"table-hover\" search={true} \n                   >\n                         <TableHeaderColumn  dataField='name' isKey>Name</TableHeaderColumn>\n\n                         </BootstrapTable>       \n            </div>\n       </div>\n\n  );\n\n}\n}\nfunction mapStateToProps(state) {\n     console.log(\"New State\",state.userdata.profile);\nreturn ({ selectedHeads: state.userdata.profile });\n}\nfunction mapDispatchToProps(dispatch) {\n  return  {\n      settingActions: bindActionCreators(settingActions, dispatch),\n      indexActions : bindActionCreators(indexActions,dispatch)\n    };\n}\nexport default connect(mapStateToProps,mapDispatchToProps)(Head);\n```. ",
    "thatneat": "Makes sense; I just saw it described in the docs and got excited about retrofitting my existing field components with RRF without having to fork or edit them all (I have several reusable fields used in different forms and didn't want to involve RRF in all of them at once). But I guess it is not to be. Maybe you could update the docs to be clearer on what you mean by \"recursively\"?. That workaround doesn't seem to be doing the trick. See the updated CodePen.\nEither way, it seems like I should give up on the concept of wrapping vanilla components to RRF-ify them. At some point there will probably be further abstraction within my vanilla components, which would probably break the <Control component={} /> approach as well. Sounds like a maintenance headache in the making. Best practice is probably to keep the RRF magic on the same level as the actual <input> so that it can be documented and prevented from regressing. Does that sound right to you?. Ah, I missed that, thanks!\nWill passing down {this.props} work for an arbitrary depth? Are there specific props that I need to be passing down?\nI see that the docs mention \"(such as onChange, onBlur, onFocus, value, etc.)\" but it would be nice to know exactly what I'm passing down so that I can manage any subcomponents.. Ok, related question (lmk if you think this should be a separate issue): How should that work for multiple-checkbox inputs? Does each checkbox need to be a separate Control with a different model value?\nTo be clear, the model I'm aiming for has multiple values for a named checkbox input, so state is something like: {choices: ['a', 'c']} when the checkboxes with value=\"a\" and value=\"c\" are checked. I've been using model={something.choices[]} for each checkbox input but I still end up with only a single value {choices: 'a'} in the resulting state.. There are a couple options that could be good. With your example, say we click checkboxes A and C. In one version (the one I described), the state would end up as an array {choices: ['a', 'c']}. In the other you'd get an object {choices: {a: true, c: true}}. Either one would be fine; is there a way to achieve either of those using RRF?. Perfect. thanks.. I now see that I probably could have figured that out for myself, but more complete docs would be much appreciated.. ",
    "garrettH3S": "Is there any movement on this? perhaps a work around? . ",
    "RafaPolit": "Yes, thank you.  Sorry not to have mentioned before, we were hopping to access this inside MapStateToProps, as we are trying to avoid using this type of logic inside the render function.\nDoes that make sense at all?\nThanks again.. ",
    "wichert": "I have a very similar situation here, where I am trying to create a label which updates its class based on a containing checkbox. Usage currently looks like this:\nhtml\n<Fieldset model=\"profile\">\n  <legend>Subscribe to our newsletter</legend>\n  <CheckedLabel model=\"profile.newsletter\" value=\"yes\">\n    <Control.radio model=\".newsletter\" value=\"yes\">  Yes\n  </CheckedLabel>\n  <CheckedLabel model=\"profile.newsletter\" value=\"no\">\n    <Control.radio model=\".newsletter\" value=\"no\">  No\n  </CheckedLabel>\n</Fieldset>\nThe CheckedLabel code is pretty simple:\n```javascript\nconst mapStateToProps = (state, ownProps: PropType) => ({\n  checked: getModel(state, ownProps.model) === ownProps.value,\n})\nconst Label = ({ className, checked, children }: PropType, context) => {\n  const cls = ${className || ''} ${checked ? 'checked' : 'unchecked'}\n  return (\n    \n      {children}\n    \n  )\n}\nconst CheckedLabel = resolveModel(connect(mapStateToProps)(Label))\nexport default CheckedLabel\n```\nSince mapStateToProps can not access the context (as @RafaPolit mentioned) I need to provide the full path here, which is quite awkward and possibly fragile if I want to reuse this component. It looks like the resolveModel wrapper is intended to fix that, but that is currently not exposed by react-redux-form.\nIn my case an alternative option might be to use a custom control, where the component renders both the label and the checkbox and copies all the wiring-logic that redux-react-form normally does.. It's certainly an interesting problem. Trying to analyse this a bit I think we can distinguish two values for a control:\n\nthe current stored value (what you would revert to if you reset the form)\nthe current input value, which can be invalid (partial or incorrect input)\n\nI think there is value on always having a saved and validated value in your state, which means the current input value (#2 above) is private to the form instead of part of the global state. You can of course still store that as part of the current state; if I remember correctly redux-form encourages that approach by using a form entry in the state.\nThe question then becomes how you move a value from one to the other at various points in time:\n\nwhen you first render / mount the form (copy from stored value to input value seems logical)\nwhen you submit the form if the entire form validates\nwhen you submit the form, the field is valid but another field in the form is invalid\nwhen you submit the form and the field itself is invalid\nwhen you change a field, and the new value is invalid\nwhen you change a field, and the new value is valid but another field in the form is invalid\nwhen you change a field, and the new value is valid\n\nPerhaps the simplest approach is to add a level which can handle the copy. Something like:\nhtml\n<VolatileForm model=\"profile\" storeOn=\"submit-validate\">\n   <Control ... />\n   <Control ... />\n</VolatileForm>\nWhere VolatileForm would copy profile to form.profile in the state, and the values are copied back if the form is submitted and everything validates. storeOn could them be one of submit, submit-validate, change or change-validate. Maybe storeOn should also be allowed on a control to fine-tune behaviour?\nhtml\n<VolatileForm model=\"profile\" storeOn=\"submit-validate\">\n  <!-- Always save the value of the next control on change -->\n   <Control storeOn=\"change\" />\n   <Control ... />\n</VolatileForm>\nThat would be useful for global settings, for example a language selector or a unit switch (say celsius vs fahrenheit) that should have an immediate effect.\n. #700 seems related to this.. ",
    "bebbi": "I see, so looks like that's passed to underlying elements like it does for custom components.\nThat plus some css helps, thanks for quick reply!\n. ",
    "caesay": "There already is a viewValue and a modelValue stored in each control, and the updateOn property configures when it is persisted to the store.\nData persistence of a store is not a form concern. The form tells you what the values of the fields are, and if they are valid or not. If you wanted updateOn = \"change\" and validateOn = \"blur\" you couldn't even make your suggestion work.\nIf you want non-standard behavior like this you could write your own <Control /> as we have done (for other reasons). Although, then you lose any possibility of knowing if a value is invalid and what it is.\nAlternatively, you could simply check the validity of the model before persisting. You could just check the top level $form and fail if anything in the form is invalid, or you could be more granular and recurse the $form and only persist fields that are valid.. @davidkpiano The file was already mostly in 4 spaces except for a few lines, do you want me to reformat the entire file or just revert the changes I made?. For now, the workaround I chose was to set pending = false first prior to the change as this has no other side effects that I can see and causes the state to be created correctly as well.. For the first point, we have hundreds of fields not all of which are shown initially, they are very conditional so it doesn't make sense for us to pre-populate the store completely, although we do provide some defaults. \nFor the second point, that's exactly what's happening - we're triggering an initial LOAD when our controls mount, and when this happens it creates the state i described above. If i send a FOCUS or SET_PENDING before the CHANGE action, then things work as expected. I will add a code sample shortly if I can.. Ok @davidkpiano, here's an example, when it loads it will dispatch an action and then dump the state to the textbox: https://codepen.io/anon/pen/WjqRbr\nAs described - all I do is send a LOAD action and the state breaks.. An alternative suggestion would be that you could expose the field state or validity via the onSubmit or onBeforeSubmit callback so we can make a decision ourselves. As it stands currently, there's no way to stop a form submission based on its validity unless we connect to the store ourselves or save isValid in the state based on the data in onUpdate.. So it seems that currently onSubmit is always ignored if the form is invalid, and action is always executed no matter what.\nMaybe it would be better to move some things around, here's some suggestions: \n- onBeforeSubmit could pass fieldState along with the event to the caller, this would be a good place to make a decision on whether we want to submit or not (we could check the form state ourselves and preventDefault if we wish).\n- before calling onSubmit we could check defaultPrevented, and if it's true it could bail out of onSubmit for consistency with the action prop.\n- There could be a prop on the form preventInvalidSubmit which would default to true and would prevent both mechanisms by default.\n- if preventInvalidSubmit is false, onSubmit would now get executed on an invalid form if not handled/cancelled in onBeforeSubmit\nIf you tell me what you think is best I would be happy to implement it.\n. ",
    "tmfrnz": "Thank you @davidkpiano v1.11.1 appears to have fixed the issue (also the most recent 1.12.1 works)!. ",
    "sufuf3": "Thank you! \ud83d\udc4d . ",
    "kkashou": "Did you ever figure how to do this? . Thank you :). After further investigation, I noticed for checkboxes since I have the model value like 'user.checkbox[]' it doesn't update form state valid. Is there something that I need to do upon user selecting one or more checkboxes?\nFor select, it doesn't update the state valid when the user selects the first option which has value=''. I am checking on validation (val) => val !== undefined || val === ''; . Solved the select validation by changing the logic of that and then everything worked. (val) => val !== '' && val !== undefined\nAs for checkbox still trying to figure out how validate as a whole group ... any tips would be helpful?\nThanks. Hmmm that didn't seem to work ... here is codesandbox https://codesandbox.io/s/8z49z2wopj\nSo it validates when you click submit, but when you check a checkbox then unselect it the validation doesn't happen and does not put a wrapping classname change. Just got to be able to select at least one checkbox per group.\nHopefully this helps.. Any possible solution for this? \n. That's the thing I did try doing the val.length > 0 I was getting TypeError: Cannot read property 'length' of undefined. :/. Okay that validation seems to work but the parent class names doesn't get updated depending on scenario for example:\nWhen you start clicking the checkboxes and unchecking it only the error messages shows up and the classname of the parent element doesn't switch. Right now I currently am checking valid and touch has been updated. Is there something else I need to look for with checkboxes?\nHere is the link to see demo ... https://codesandbox.io/s/8z49z2wopj\nThanks,\nKevin. @davidkpiano - I know you closed this ticket but still not working how it should be. Any help would be appreciated.. Any ideas why ? . So I have converted this field to a control component and got the mapProps working. But is there a way to actually get that map to the parent content and update the class? \nHere is the update example ... https://codesandbox.io/s/kxz6831wjr (inside the checkbox.js file). @davidkpiano  - I see that, now would validation still work the same way ? Because I am running into a case that validation doesn't output the same results.. @davidkpiano perfect example here https://codesandbox.io/s/8z49z2wopj the first one will have the user. and the second one will have . ... you will see the first work works right highlights everything in red where as the second one nothing gets highlighted.\nDoes that helps? \nThanks. @davidkpiano sure ... created the issue here https://github.com/davidkpiano/react-redux-form/issues/965. @davidkpiano - Any help? . @davidkpiano - I converted it to <Control now it doesn't work at all.\nWhen does v2.0 come out? . @davidkpiano - It is in the checkbox.js file on the files side panel.. @davidkpiano - But I would need to make the ajax call to grab that database value on the first selection. I noticed you have https://davidkpiano.github.io/react-redux-form/docs/api/actions.html would I use that to make the ajax call and update the values on the next select?. @davidkpiano - Can we reopen this ticket? I have an example of what I am trying to do but it isn't working, would like to get input on it.\nhttps://codesandbox.io/s/k38k75ny8v\nThanks\n. Any updates on this?. ",
    "camdub": "I'm seeing the related issue as well:\n\nAlso related to this issue is that once an asynch validator is called all local validators get set to true even though the input is now falsy. Something in setValidity is doing this.. \n",
    "stevenmason": "On react-redux-forms version 1.14.1 this is also happening for the native radio button.. @davidkpiano You can easily test it in @tmcdonnell87 example by changing the react-redux-forms version to 1.14.1. Any progress on this bug?. @davidkpiano would you be able to push the changes to npm please?. Thanks @davidkpiano !. ",
    "netoguimaraes": "I did notice that Control.radio doesn't not support Number values too. It seems to support just String values. I think it would be good if it were at least explained in docs. . ",
    "henry-young": "I'm also experiencing this error. I'll try and get a codepen example. \nIn the meantime, I was able to get the form working calling actions.reset('forms.someResource') or actions.load(forms.someResource) after calling setInitial.. Here is a link to the codepen.\nhttp://codepen.io/henryyoung/pen/Wjyqjo?editors=0010. ",
    "janbuerling": "I have to do this otherwise I get the error: Maximum call stack size exceeded.\nconst validators = {\n      code: { isRequired, hasLength: val => hasLength(val, 8) },\n      'validity.schedule': { isRequired },\n      'benefit.discount': {\n        isRequired: val => (\n          this.props.couponForm.benefit.discountPercent.value ? true : isRequired(val)\n        ),\n      },\n      'benefit.discountPercent': {\n        isRequired: val => (\n          this.props.couponForm.benefit.discount.value ? true : isRequired(val)\n        ),\n      },\n};\nbut cleaner would be:\nconst validators = {\n      code: { isRequired, hasLength: val => hasLength(val, 8) },\n      validity: {\n         schedule: { isRequired },\n      },\n      benefit: {\n         discount:  {\n             isRequired: val => (\n                this.props.couponForm.benefit.discountPercent.value ? true : isRequired(val)\n             ),\n          },\n         discountPercent:  {\n             isRequired: val => (\n                this.props.couponForm.benefit.discount.value ? true : isRequired(val)\n             ),\n          },\n      }\n};\nIs this enough or do you need a live example?. ",
    "TempaGoGo": "David,\nThanks for getting back to me! Ah yes - this works.\nIt worked when I mapped a state element to a prop (say state.meta.version), but wasn\u2019t working if I tried to map state.meta then I got I whole bunch of endless rrf/setPending, rrf/batch and rrf/change actions.\nAny idea (I have attached the code).\nBTW - I have to reflect what others have said\u2026this framework is immense! Super work.\nPhil\n```jsx\nimport React, {Component} from \"react\";\nimport {Button, FormGroup, ControlLabel, FormControl, Panel, PageHeader, HelpBlock} from \"react-bootstrap\";\nimport {Form, Control, Errors} from \"react-redux-form\";\nimport {connect} from 'react-redux'\nimport {actions} from 'react-redux-form'\nimport {getBusinessObjectPromise, persistBusinessObjectPromise} from \"./../objectStore/businessObjectActions\"\nimport {EDITMODE, CREATEMODE} from \"../formModes\"\nconst required = (val) => val && val.length;\nconst maxLength = (len) => (val) => val.length <= len;\nclass Photo extends Component\n{\n    constructor(props)\n    {\n        super(props)\n        this.persist = this.persist.bind(this)\n    }\ncomponentDidMount()\n{\n    const {dispatch, formMode, match} = this.props\n\n    if(formMode !== CREATEMODE)\n    {\n        dispatch(actions.submit(\"photo\", getBusinessObjectPromise(\"photo\", match.params.id)))\n            .then(response => \n            {\n                dispatch(actions.change('photo', response.photo))\n                dispatch(actions.change('meta', response.meta))\n                this.setState({version: response.meta.version})\n            })\n    }\n}\n\n\ncomponentWillReceiveProps(nextProps)\n{\n    const {dispatch, formMode, match} = nextProps\n\n    if(formMode !== CREATEMODE)\n    {\n        dispatch(actions.submit(\"photo\", getBusinessObjectPromise(\"photo\", match.params.id)))\n            .then(response => \n            {\n                dispatch(actions.change('photo', response.photo))\n                dispatch(actions.change('meta', response.meta))\n                this.setState({version: response.meta.version})\n            })\n    }\n    else\n    {\n        dispatch(actions.reset(\"photo\"))\n        this.setState({version: 0})\n    }\n}\n\n\npersist(photo)\n{\n\n    console.log(this.props)\n\n    this.props.dispatch(actions.submit(\"photo\", persistBusinessObjectPromise(photo,\"photo\", this.props.version)))\n        .then ( () =>\n        {\n\n        })\n\n\n    console.log(this.props)\n\n}\n\nselectActionButton()\n{\n    switch(this.props.formMode)\n    {\n        case EDITMODE:\n            return (<Button type=\"submit\" name=\"Update Photo\" bsStyle=\"primary\" bsSize=\"small\" disabled={false} >Save Changes</Button>)\n        case CREATEMODE:\n            return (<Button type=\"submit\" name=\"Add Photo\" bsStyle=\"primary\" bsSize=\"small\" disabled={false} >Create</Button>)\n        default:\n            return(<div></div>)\n    }\n}\n\n\nrender() \n{\n    return (\n        <Panel>\n            <PageHeader>Photograph</PageHeader>\n            <Form model=\"photo\"\n                onSubmit={(photo) => this.persist(photo)}>\n\n                    <FormGroup bsSize=\"small\" controlId=\"id1\">\n                        <ControlLabel>Title</ControlLabel>\n                        <Control.text\n                            model=\".title\"\n                            component={FormControl}\n                            validators={{\n                                required,\n                                maxLength: maxLength(15)\n                            }}\n                        />\n                        <Errors\n                            className=\"errors\"\n                            model=\"photo.title\"\n                            show=\"touched\"\n                            component={HelpBlock}\n                            messages={{\n                            required: 'Required',\n                            maxLength: 'Must be 15 characters or less',\n                            }}\n                        />\n                    </FormGroup>\n\n                    <FormGroup bsSize=\"small\" controlId=\"id2\">\n                        <ControlLabel>Reference</ControlLabel>\n                        <Control.text\n                            component={FormControl}\n                            model=\".reference\"\n                            validators={{\n                            required\n                            }}\n                        />\n                        <Errors\n                            className=\"errors\"\n                            model=\"photo.reference\"\n                            show=\"touched\"\n                            component={HelpBlock}\n                            messages={{\n                            required: 'Required',\n                            validEmail: 'Invalid email address'\n                            }}\n                        />\n                    </FormGroup>\n\n                        <FormGroup bsSize=\"small\" controlId=\"id3\">    \n                            {this.selectActionButton()}\n                            {' '}\n\n                <Control.reset model=\"photo\" type=\"reset\" component={Button} bsSize=\"small\">\n                    Reset\n                </Control.reset>\n\n\n                        </FormGroup>\n\n\n\n            </Form>\n        </Panel>\n    )\n}\n\n}\nconst mapStateToProps = (state) => {\n    return {\n        userName: state.user.userName,\n        version: state.meta\n    }\n}\nexport default connect(mapStateToProps)(Photo)\n```\n\nOn 17 May 2017, at 13:07, David Khourshid notifications@github.com wrote:\nWhat does your store setup look like? Your entire form and model state is in your Redux store, so you can just use connect() to get the pieces of data that you want: http://redux.js.org/docs/basics/UsageWithReact.html http://redux.js.org/docs/basics/UsageWithReact.html\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub https://github.com/davidkpiano/react-redux-form/issues/789#issuecomment-302070080, or mute the thread https://github.com/notifications/unsubscribe-auth/AZrV4M4RKuviFIxI2-mkJyJkxMVMclN7ks5r6uL4gaJpZM4NdmDx.\n\n\n. Ah yes! That makes perfect sense\u2026by mapping some state to a prop, then updating the mapped state in componentWillReceiveProps, I get myself into an endless loop, as the connected prop gets updated! But mapping a specific field the props themselves are not updated! I would have never spotted that - I\u2019m still very much the novice.\nBasically the form can be in one of two modes, create / update. If say the user has a form on screen with data in it, then clicks \u201cCreate New\u201d from a top level menu, the form is not remounted, so I have to ensure the form is cleared out (hence the code in componentWillReceiveProps  I have also allowed it to reload the form with a new record also - say I added a Next Record button on the screen.\nI need to think about how to architect this\u2026I will try and put up in code pen later.\nTHANK YOU SO MUCH!\nPhil\n\nOn 17 May 2017, at 14:55, David Khourshid notifications@github.com wrote:\nIf you could put that in a Codepen that would be great (template here: http://codepen.io/davidkpiano/pen/yJwmEa http://codepen.io/davidkpiano/pen/yJwmEa ) but I suspect the infinite loop has to do with componentWillReceiveProps, because you're dispatching actions that can change props.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub https://github.com/davidkpiano/react-redux-form/issues/789#issuecomment-302097719, or mute the thread https://github.com/notifications/unsubscribe-auth/AZrV4N-Ag36bk5Ig6FBf940aH6woSEh6ks5r6vxkgaJpZM4NdmDx.\n\n\n. So, after a little thought I put a guard around the update I was performing\u2026works a treat! Thank you again! Phil\ncomponentWillReceiveProps(nextProps)\n{\n    const {dispatch, formMode, match} = nextProps\n\n    if(formMode!==this.props.formMode ||  match.params.id !==this.props.match.params.id)\n    {\n        if(formMode !== CREATEMODE)\n        {\n            this.getBusinessObject()\n        }\n        else\n        {\n            dispatch(actions.reset(\"photo\"))\n            dispatch(actions.reset(\"meta\"))\n        }\n    }\n}\n\n\nOn 17 May 2017, at 15:10, Philip Pegden businessnumbertwo@icloud.com wrote:\nAh yes! That makes perfect sense\u2026by mapping some state to a prop, then updating the mapped state in componentWillReceiveProps, I get myself into an endless loop, as the connected prop gets updated! But mapping a specific field the props themselves are not updated! I would have never spotted that - I\u2019m still very much the novice.\nBasically the form can be in one of two modes, create / update. If say the user has a form on screen with data in it, then clicks \u201cCreate New\u201d from a top level menu, the form is not remounted, so I have to ensure the form is cleared out (hence the code in componentWillReceiveProps  I have also allowed it to reload the form with a new record also - say I added a Next Record button on the screen.\nI need to think about how to architect this\u2026I will try and put up in code pen later.\nTHANK YOU SO MUCH!\nPhil\n\nOn 17 May 2017, at 14:55, David Khourshid notifications@github.com> wrote:\nIf you could put that in a Codepen that would be great (template here: http://codepen.io/davidkpiano/pen/yJwmEa http://codepen.io/davidkpiano/pen/yJwmEa ) but I suspect the infinite loop has to do with componentWillReceiveProps, because you're dispatching actions that can change props.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub https://github.com/davidkpiano/react-redux-form/issues/789#issuecomment-302097719, or mute the thread https://github.com/notifications/unsubscribe-auth/AZrV4N-Ag36bk5Ig6FBf940aH6woSEh6ks5r6vxkgaJpZM4NdmDx.\n\n\n. \nDavid,\nQuick question - is Control.button recommended? I noticed that you used  in your examples. Was there a reason for this?\nI wanted to wrap a react-bootstrap button - if I use the react-bootstrap button unwrapped its \u201cclick\u201d visual state doesn\u2019t reset after the click.\nKind regards, Phil\n. I get lots of errors in the console, when I simply changeSave to Save\nsuch as: Uncaught TypeError: Cannot read property '0' of undefined\nAny ideas? Am on latest version.\nThanks David, as ever!\nfull code below:\nimport React, {Component} from \"react\";\nimport {Button, FormGroup, ControlLabel, FormControl, Panel, PageHeader, HelpBlock} from \"react-bootstrap\";\nimport {Form, Control, Errors} from \"react-redux-form\";\nimport {connect} from 'react-redux'\nimport {actions} from 'react-redux-form'\nimport axios from \"axios\"\nimport {EDITMODE, CREATEMODE} from \"../formModes\"\nimport Meta from \"./meta\" \nconst required = (val) => val && val.length;\nconst maxLength = (len) => (val) => val.length <= len;\nclass Photo extends Component\n{\n    constructor(props)\n    {\n        super(props)\n        this.getBusinessObject= this.getBusinessObject.bind(this)\n        this.persist = this.persist.bind(this)\n        this.handleSubmit = this.handleSubmit.bind(this)\n    }\ncomponentDidMount()\n{\n    if(this.props.formMode !== CREATEMODE)\n    {\n        this.getBusinessObject()\n    }\n}\n\n\ncomponentWillReceiveProps(nextProps)\n{\n    const {dispatch, formMode, match} = nextProps\n\n    if(formMode!==this.props.formMode ||  match.params.id !==this.props.match.params.id)\n    {\n        if(formMode !== CREATEMODE)\n        {\n            this.getBusinessObject()\n        }\n        else\n        {\n            dispatch(actions.reset(\"photo\"))\n            dispatch(actions.reset(\"meta\"))\n        }\n    }\n}\n\n\ngetBusinessObject()\n{\n    const {dispatch, match} = this.props\n    const id = match.params.id\n    const objectType = \"photo\"\n    const url = '/rest/' + objectType + '/' + id\n\n    axios.get(url)\n        .then(response => \n        {\n            dispatch(actions.change(objectType, response.data.photo))\n            dispatch(actions.change('meta', response.data.meta))\n        })\n        .catch(error => \n        {\n            console.log(\"BAD\")\n        })\n}\n\n\npersist(payload)\n{   \n    return new Promise((resolve, reject) =>\n    {\n        const {dispatch, match} = this.props\n        const id = match.params.id\n        const objectType = \"photo\"\n\n        payload = Object.assign({},payload, {version: this.props.meta.version})\n\n        if(this.props.meta.version>0)\n        {\n            const url = '/rest/' + objectType + '/' + id\n            axios.patch(url, payload)\n                .then(response => {dispatch(actions.change('meta', response.data)); resolve(true)})\n                .catch(error => {console.log(\"CREATE FAILED\")})\n        }\n        else\n        {\n            const url = '/rest/' + objectType\n            axios.post(url, payload)\n                .then(response => {dispatch(actions.change('meta', response.data))})\n                .catch(error => {console.log(\"UPDATE FAILED\")})\n        }\n    })\n}\n\nhandleSubmit(values) {\n    this.props.dispatch(actions.submit('photo', this.persist(values)));\n  }\nrender() \n{\n    return (\n        <div>\n            <Panel>\n                <PageHeader>Photograph</PageHeader>\n                <Form model=\"photo\" onSubmit={(photo) => this.handleSubmit(photo)}>\n\n                        <FormGroup bsSize=\"small\" controlId=\"id1\">\n                            <ControlLabel>Title</ControlLabel>\n                            <Control.text\n                                model=\".title\"\n                                component={FormControl}\n                                validators={{\n                                    required,\n                                    maxLength: maxLength(15)\n                                }}\n                            />\n                            <Errors\n                                className=\"errors\"\n                                model=\"photo.title\"\n                                show=\"touched\"\n                                component={HelpBlock}\n                                messages={{\n                                required: 'Required',\n                                maxLength: 'Must be 15 characters or less',\n                                }}\n                            />\n                        </FormGroup>\n\n                        <FormGroup bsSize=\"small\" controlId=\"id2\">\n                            <ControlLabel>Reference</ControlLabel>\n                            <Control.text\n                                component={FormControl}\n                                model=\".reference\"\n                                validators={{\n                                    required\n                                }}\n                            />\n                            <Errors\n                                className=\"errors\"\n                                model=\"photo.reference\"\n                                show=\"touched\"\n                                component={HelpBlock}\n                                messages={{\n                                    required: 'Required',\n                                    validEmail: 'Invalid email address'\n                                }}\n                            />\n                        </FormGroup>\n\n\n                        <FormGroup bsSize=\"small\" controlId=\"id3\">\n\n                            <Control.button type=\"submit\">Save</Control.button>\n\n                        </FormGroup>\n\n                </Form>\n            </Panel>\n            {this.props.formMode!==CREATEMODE ? <Meta meta={this.props.meta}/>:<div></div> }\n        </div>\n    )\n}\n\n}\nconst mapStateToProps = (state) => {\n    return {\n        meta: state.meta\n    }\n}\nexport default connect(mapStateToProps)(Photo)\n\nOn 18 May 2017, at 18:24, David Khourshid notifications@github.com wrote:\nShouldn't matter,  is only a thin wrapper around the native .\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n\n\n. ",
    "kallemakynen": "Sounds good to me. ",
    "zcfan": "Have the same problem, and this is the perfect solution to me: https://github.com/erikras/redux-form/issues/572#issuecomment-268905929. ",
    "TimFletcher": "Works perfectly. Thanks so much!. ",
    "popstheman": "actions.reset('model_name') is resetting the model it-self in my redux state. However, my form inputs, username and password fields values are not reset.\n. ",
    "vyozh32": "@popstheman I had the same problem and that's how I solved it.\nYou need pass this.props.value to input field like value={this.props.value}. ",
    "maludwig": "I'm also getting this error. If I'm interpreting the line correctly, it's saying \"If it is web, require react-dom, if not, don't. I'll try replacing it with just findDOMNode = null.. Yeah that worked. Had to restart Expo from scratch, but it worked. Literally just replace this line like this, it seems something is getting required when in needn't be:\n// var findDOMNode = !_isNative2.default ? require('react-dom').findDOMNode : null;\nvar findDOMNode = null;. My current solution (gross):\nmodelAndStateWrapper.js\n```\nimport {connect} from 'react-redux';\nimport _get from 'lodash.get';\nimport modelWrapper from './modelWrapper';\nconst modelAndStateContainer = (WrappedComponent) => {\n    const mapStateToProps = (state, ownProps) => {\n        return {\n            controlState: _get(state.forms, ownProps.model, {}),\n        };\n    };\nreturn connect(mapStateToProps)(WrappedComponent);\n\n}\nconst modelAndStateWrapper = (WrappedComponent) => (\n    modelWrapper(modelAndStateContainer(WrappedComponent))\n);\nexport default modelAndStateWrapper;\n```\nmodelWrapper.js\n```\nimport React, {Component} from 'react';\nimport PropTypes from 'prop-types';\nfunction resolveModel(model, parentModel) {\n    if (parentModel) {\n        if (model[0] === '.' || model[0] === '[') {\n            return ${parentModel}${model};\n        }\n    if (typeof model === 'function') {\n        return (state) => model(state, parentModel);\n    }\n}\n\nreturn model;\n\n}\nexport default function modelWrapper(WrappedComponent) {\n    class ResolvedModelWrapper extends Component {\n        render() {\n            const {model: parentModel} = this.context;\n            const resolvedModel = resolveModel(this.props.model, parentModel);\n            return (\n                \n            );\n        }\n    }\nResolvedModelWrapper.propTypes = {\n    ...WrappedComponent.propTypes,\n    model: PropTypes.any,\n};\n\nResolvedModelWrapper.contextTypes = {\n    model: PropTypes.any,\n};\n\nreturn ResolvedModelWrapper;\n\n}\n```\nMyPersonalTextInput.js\nconst InnerComponent = (props) => {\n    const {model, controlState, ...innerProps} = props;\n    return <div>\n        <pre>{JSON.stringify(controlState)}</pre>\n        <input {...innerProps} />\n    </div>\n}\nconst MyPersonalTextInput = modelAndStateWrapper(InnerComponent);\nexport default MyPersonalTextInput;. So, I think the fix is in \"checkWithValue\" in model-actions.js, the last line should change from:\nreturn change(model, !currentValue);\nto:\nif (typeof currentValue !== \"undefined\") {\n  return change(model, !currentValue);\n} else {\n  return change(model, value);\n}\nbut, it seems like this works too:\nreturn change(model, value);\nI'm not sure if this is where you want to fix it, but it does the trick.. Oh gosh, it's been like 8 years since I've tried that. Let's do this! LEEERROOYYYYY, JENKIINNNSS.. Well, I think I fixed it, but, by build is failing, but I think it can't be with my code. It looks like it's with npm, or...something...I have no clue why it's not happy. I'm officially calling for help. It all works nice and happy on my local. #908 . Yay! It built fine this time! Good fix, thanks!. Done! Caching should kick in with the next deploy!. ",
    "fhaque": "I'm getting the same error as @alexesDev using react-redux-form@1.16.5. ",
    "nextriot": "This still seems to be very much an issue.\nI got around it by commenting out line 26 & line 36 of the control-component.js. \nThen adding: findDOMNode: null after line 36.\nIt looks like pull request 101d3bd that was meant to fix the issue wasn't successfully merged, are the plans to address this?. @davidkpiano the changes that I've made would be destructive to the rest of the project (e.g. the web side).\nThe issue seems to be the static analysis of 'require' statements. Just the fact that it's present in the control-component.js file is forcing the compiler to search for the component. It doesn't make a difference if the 'require' is made conditionally or not, the compiler will always do the lookup.\nThe fastest way I can see around it is by having a separate control-component.js file for React Native use only. Alternatively, there may be a conditional require plugin for react that you could include as a dependency then use the 'require' statement as is with minimal tweaking.\nI don't know enough about the layout of the plugin yet to implement either fix however. Sorry.\nLet me know if there's anything else I can help with. If you want me to make the PR regardless of the above, just say the word.. ",
    "orlando": "Having this issue too with version 1.16.6. ",
    "umair-khanzada": "@davidkpiano in my case model is an empty object {} and when reset the model nothing happens. What is the accepted values of Errors show attribute ?. ",
    "hitchcockwill": "@davidkpiano I'm still experiencing this same issue on IE11 after the 1.12.0 update. I'm seeing this with almost an identical config to the one above only on the  component rather than LocalForm.\nInputs are set up to validateOn=\"change\" and there is a 300ms debounce as well.\nThe stack trace points to the updateParentsForms function. I can try to put together some more detailed tests later.\nUpdate: I did some more digging here. For whatever reason I had decided that I only need to have es5-shim and es7-shim installed. It looks like adding es6-shim to the mix fixed this issue.. ",
    "Kikketer": "Thanks @hitchcockwill I was running into the same issue using a combination of 'create-react-app' and had to simply add es6-shim to the polyfills.. ",
    "jdelafon": "I wanted to open a more precise one when I really figure it out. I think this is the problem:\n- I want to re-render the whole form only if a value changes;\n- Inputs update the store on blur (updateOn=\"blur\"), otherwise the performance is awful;\n- Even if you don't change the value, the onBlur event still triggers (clicking inside one text field, then inside another);\n- When the onBlur triggers, even if the value did not change (still \"\"), it re-renders the form. React-logger says there is \"-- no diff --\" when the \"rrf/batch\" (blur + change) event is fired, yet the whole thing re-renders. I don't understand this.. I wrote a minimal example and the form does not re-render. Performance is great even with 600 inputs. I could find my mistake that caused the re-render. My bad. Good job with this library.. Latest version. My component is still very slow but I figured out that it was because of the dropdown inputs. If I replace them by text inputs it becomes much faster, and apparently most of the time is spent in DOM reconciliation (if it makes any sense), so nothing I can really do about it.\nWhat bothers me in this is that something like Excel is able to deal with way many more inputs without any lag, so why can't we do something similar with React? It is not even close. Or maybe I just suck.. Very interesting, thanks! I am reading about RxJS now, it may be the answer.. I will reopen this as soon as I can replicate in a CodePen... The problem definitely exists, and even for text inputs, but I can't see what the conditions are.. In CodePen it seems to work in the minimal case:\nhttps://codepen.io/jdelafon/pen/EXPXNr?editors=0011\nIn my case I get \"rrf/setErrors\" on every field when it mounts, and on submission:\naction rrf/addIntent\naction rrf/setSubmitFailed\n\nbecause fields are marked as \"valid: false\" even when no value is empty and this is the only validator. This should just not be possible at all. \nSetting the initial value in the Redux store to something else than \"\" is enough to make it fail (even if there is a \"\" <option>). Any idea for me to test? I don't really know what to try anymore to reproduce that in CodePen.. I guess I don't have a choice. This is worrisome, though:\n\nA field that has validated: false, valid: false, initialValue: \"\", value: \"asd\" and prevents submission. The only prop I passed to it is \"required\".\nTracked down to this: how can the error be \"valueMissing: true\" when the currentValue is \"a\" and the next one is \"as\" (on change event)? I think this is worth reopening.\n\n. I give up sorry, I have no idea where it comes from. I will try with custom validators. Just in case it helps one day, a bit of code that I have:\nMy inputs:\n<Form model={\"userDataForms.samples\"} onSubmit={this.handleSubmit}>\n    // Many of these, generated by a function, put in a HTML table, but I simplify:\n    <Control.select  required model={modelName} updateOn=\"change\" ignore={['focus','blur']} >\n        {makeOptions()}\n    </Control.select>\n    ...\n    <button type=\"submit\">Submit</button>\n</Form>\n\nMy reducer:\nlet userDataFormsReducers = combineForms(\n    {\n        libraries: {\n            someProperty: \"\",\n            someOtherProperty: \"\",\n            project: {...: \"\", ...: \"\"},\n            requests: [\n                {...: \"\", ...: \"\"},\n            ],\n        },\n\n        samples: {\n            ...\n        }\n    },\n\n    'userDataForms'\n);\n\nstore.js:\nlet reducer = combineReducers({\n    userDataForms: userDataFormsReducers, ...\n}). It is an array of `<options>`:\n\n/**\n * Build a list of <option>s based on an array representing the different options for a select input.\n * @param options: array [[id, label], ...] to become <option value={id}>{label}</option>.\n * @returns {Array}\n */\nfunction makeOptions(options) {\n    let opts = options ? options.map((v,i) => <option value={v[0]} key={i}>{v[1]}</option>) : [];\n    opts.unshift(<option value=\"\" key=\"-\">-</option>);\n    return opts;\n}. I made a more resembling one but still cannot reproduce. Anyway here it is:\n\nhttps://codepen.io/jdelafon/pen/EXPXNr?editors=0011\nMy own versions:\n\"react-redux\": \"^5.0.5\",\n\"react-redux-form\": \"^1.11.1\",. Yes. What happens is this:\n\n\nThe form loads with the default store state (from the reducer), which is often \"\" (invalid if required).\nThe \"rrf/setErrors\" events fire and set the validity to \"false\".\nThe Ajax call I do to get the data that fills the form gets back and triggers a merge action to fill the form.\nAfter the merge, all values are set and should be valid, but the validation status is not updated, thus all fields are still marked valid: false.\n\nSo validation is not recalculated on merge (which is counter-intuitive imho) and needs to be triggered manually.  That is tedious because the validate action takes a validators argument that I have to read again from the model, but it should work. Of course, custom validators suffer from the same thing, not only required.\nShould validation not be re-calculated on merge/change actions ? That would avoid weird states like in my screenshots before.\nThis reproduces it: \nhttps://codepen.io/jdelafon/pen/EXPXNr?editors=0011. ",
    "sonarforte": "I did step 1 and 2 as you suggested and it worked; it fixed another problem I was having about a missing saga module as well. Thanks.. Sure, so I'm using semantic-ui to do the visuals. \n```\nimport { Control, Form, } from 'react-redux-form'\nimport {\n  Button as UIButton,\n  Form as UIForm,\n} from 'semantic-ui-react'\n//...\nclass NewWidgetForm extends Component {\n//...\n      this.handleSubmit(values)}\n      >\n        \n val && val.length,\n            }}\n            validateOn=\"blur\"\n          />\n          \n\n          Submit\n        \n\n//...\n}\nconst mapStateToProps = (state) => {\nreturn {\n    ...\n    forms: state.forms,\n  }\n}\nexport default connect(mapStateToProps, )(NewWidgetForm)\n```\nThe way this works is that you can compose ui elements with normal elements using the as prop in the ui element. \nThe Form.Input takes an error prop, which is a boolean. When it's true, the field shows up red.\nI'm trying to use the validation of the rrf form element to set the error prop. My idea is to pass the forms in as a prop using mapStateToProps, and accessing the validity as props.forms.forms.widgetCreate.name.valid. \nIs this the right way to go about doing it?. @davidkpiano I tried your suggestion and it's close to working, although the state doesn't seem to update correctly. \n<Control.custom\n  model=\".foo\"\n  component={UIForm.Input}\n  validators={{\n    required: (val) => val && val.length,\n  }}\n  validateOn=\"blur\"\n  mapProps={{\n    error: (props) => {\n      console.log(\"touched: \" + props.fieldValue.touched)\n      console.log(\"valid: \" + props.fieldValue.valid)\n      return props.fieldValue.touched && !props.fieldValue.valid\n    }\n  }}\n/>\nIt turns out that at first, touched is false and valid is true, but then after the rrf/setErrors action, both fields remain false despite typing into the field, blurring it, etc.  \nAny ideas why this could be occurring?\n. Here is the example. For some reason the log statements in the mapProps function only get called twice, even if I continue blurring/focusing, etc. \nHowever, in my code they keep getting called with unchanging values. Either way, I think this might be part of the problem.\n//Edit\n@davidkpiano  I realized that the state updates after submitting the form. In this code example, if you type something in the first box and submit, it will give give you true and false for touched and valid. \nHowever, those values are still wrong, as the validation on foo should be met by the fact that the field has some text in it.. So I got this working and I'm not sure what exactly did it, but here is a complete example for posterity:\n```\nimport { Control, Form, } from 'react-redux-form'\nimport {\n  Button as UIButton,\n  Form as UIForm,\n  Input as UIInput,\n} from 'semantic-ui-react'\n...\nrender() {\nconst required = (val) => val && val.length > 0\nconst requiredError = (props) => {\n  const { touched, valid } = props.fieldValue\n  return touched && !valid\n}\n\nreturn (\n\n  <Form\n    model=\"forms.widgetCreate\"\n    onSubmit={(values) => this.handleSubmit(values)}\n    component={UIForm}\n    className=\"\"\n    validators={{\n      name: { required },\n      description: { required },\n    }}\n  >\n    <UIForm.Group>\n      <Control\n        type=\"text\"\n        model=\".name\"\n        component={UIForm.Input}\n        mapProps={{\n          label: \"Name\",\n          required: true,\n          error: requiredError,\n        }}\n      />\n\n      <Control\n        type=\"textarea\"\n        model=\".description\"\n        component={UIForm.TextArea}\n        mapProps={{\n          label: \"Description\",\n          required: true,\n          error: requiredError,\n        }}\n      />\n    </UIForm.Group>\n\n    <Control.file\n      model=\".image\"\n      accept=\"image/*\"\n      component={UIForm.Input}\n      mapProps={{\n        label: \"Upload a photo\",\n        required: true,\n      }}\n    />\n\n    <Control.button\n      model=\".\"\n      type=\"submit\"\n      component={UIForm.Button}\n    >\n      Submit\n    </Control.button>\n  </Form>\n)\n\n}\n```\nLet me know if you think this approach is too verbose or is not taking full advantage of RRF's capabilities. Thanks.\n//Edit\nWhen I submit the form with a required field missing, requiredError starts to return true for all the fields, even if they have text in them. Thoughts?. Thanks! I don't know if I edited after you responded, but do you have any input on requiredError returning true after a failed submit?. When I submit the form with a required field missing, e.g. the name field in the above example, requiredError returns true for all fields with that error prop in mapProps, whether or not they have any text in them.\nSo let's say I type something in name above, then submit. ThenfieldValue.valid shows up as false for all of the fields, even though it should be valid on the name field since there is text in the field.\n//EDIT\nCheck out this example. If you type in one of the fields and hit submit, they both display an error message. . @davidkpiano Do you mean a different example than the one I included in the previous comment? \nThat codepen example illustrates what I'm talking about.. Thanks for the tip, it certainly gives the desired behavior on the codepen example. \nHowever, and I hate to keep going on about this, I have what is essentially the exact same code in my component and it doesn't work. The errors update correctly, but whenever there is a submit (failed or successful), the fields get cleared.\nI've analyzed the rendered html and there seems to be no difference in the html tags or attributes on the form components. The only difference (aside from the behavior) that I've observed is on my machine there is a prevalence of rrf/batch actions, which I do not see on the codepen example.\nI'm really tearing my hair out as to why the same code works differently in two separate places, so I'm including (what I believe to be) all relevant files.\nThanks again for the help.\n```\n//package.json\n{\n  \"name\": \"widget\",\n  \"version\": \"0.1.0\",\n  \"private\": true,\n  \"devDependencies\": {\n    \"react-scripts\": \"0.9.0\",\n    \"redux-devtools-extension\": \"^2.13.2\"\n  },\n  \"dependencies\": {\n    \"babel-polyfill\": \"^6.23.0\",\n    \"classnames\": \"^2.2.5\",\n    \"crypto\": \"0.0.3\",\n    \"dns\": \"^0.2.2\",\n    \"isomorphic-fetch\": \"^2.2.1\",\n    \"jsonwebtoken\": \"^7.4.1\",\n    \"jws\": \"^3.1.4\",\n    \"jwt-simple\": \"^0.5.1\",\n    \"prop-types\": \"^15.5.10\",\n    \"react\": \"^15.5.4\",\n    \"react-dom\": \"^15.5.4\",\n    \"react-redux\": \"^5.0.5\",\n    \"react-redux-form\": \"^1.12.0\",\n    \"react-router\": \"^3.0.5\",\n    \"react-router-redux\": \"^4.0.8\",\n    \"redux\": \"^3.6.0\",\n    \"redux-logger\": \"^2.10.2\",\n    \"redux-saga\": \"^0.14.8\",\n    \"semantic-ui-css\": \"^2.2.10\",\n    \"semantic-ui-react\": \"^0.67.2\",\n    \"validator\": \"^7.0.0\"\n  },\n  \"scripts\": {\n    \"start\": \"react-scripts start\",\n    \"build\": \"react-scripts build\",\n    \"test\": \"react-scripts test --env=jsdom\",\n    \"eject\": \"react-scripts eject\"\n  }\n}\n```\n```javascript\n// WidgetForm.js\nimport React, { Component } from 'react'\nimport { PropTypes } from 'prop-types'\nimport { connect } from 'react-redux'\nimport { Control, Form, } from 'react-redux-form'\nimport { widgetRequest, } from '../actions/'\n//Same definition as codepen example\nconst UIInput = (props) => {\n  const { error, label, ...inputProps } = props;\n  console.log(\"UIINPUT Rendered\")\n  console.log(inputProps)\nreturn (\n    \n{error ? \"Error\" : label}\n\n\n  )\n}\nclass WidgetForm extends Component {\nhandleSubmit = (values) => {\n    const { client, widgetRequest } = this.props\n    console.log(values)\n    widgetRequest(values)\n  }\nrender() {\n// Whether the field is empty\nconst isRequired = (val) => val && val.length > 0\n// Whether to show the error message\nconst requiredError = (props) => {\n  const { touched, valid, focus } = props.fieldValue\n  return !focus && touched && !valid\n}\n\nreturn (\n  <Form\n    model=\"forms.widget\"\n    onSubmit={(values) => this.handleSubmit(values)}\n  >\n    <Control.text\n      model=\".name\"\n      validators={{\n        isRequired,\n      }}\n      component={UIInput}\n      mapProps={{\n        label: \"Name\",\n        error: requiredError,\n      }}\n    />\n    <Control.text\n      model=\".number\"\n      validators={{\n        isRequired,\n      }}\n      component={UIInput}\n      mapProps={{\n        label: \"Number\",\n        error: requiredError,\n      }}\n    />\n    <Control.button\n      model=\".\"\n      type=\"submit\"\n    >\n      Submit\n    </Control.button>\n\n  </Form>\n)\n\n}\n}\nconst mapStateToProps = (state, ownProps) => {\nconst { requesting, successful,  } = state.forms.widget\n  return {\n    requesting,\n    successful,\n  }\n}\nexport default connect(mapStateToProps, { widgetRequest })(WidgetForm)\n```\n```javascript\n// reducers/index.js\nimport { combineReducers } from 'redux';\nimport { combineForms } from 'react-redux-form';\nimport { syncHistoryWithStore, routerReducer } from 'react-router-redux'\n// There are more things in real life but unrelated here\nimport { fooReducer as foo } from './foo'\nimport { widgetReducer as widget } from './widget'\nconst rootReducer = combineReducers({\n  foo: foo,\n  forms: combineForms({\n    widget: widget,\n  }, 'forms'),\n  routing: routerReducer,\n});\nexport default rootReducer;\n```\nLet me know if there's something I missed. Thanks again.\n. So I fixed the problem, although this is a bit disconcerting. \nMy original code looked like this:\n```javascript\n       this.handleSubmit(v)}\n      >\n        \n\n    <Control.button\n      model=\".\"\n      type=\"submit\"\n    >\n      Submit\n    </Control.button>\n\n  </Form>\n\n```\nBut by changing the <Control.button> component to the third party semantic-ui component like so:\njavascript\nimport { Form as UIForm, } from 'semantic-ui-react'\n//...\n        <UIForm.Button \n          type=\"submit\">\n          Submit\n        </UIForm.Button>\nit fixed the problem. I imagine a vanilla button would have solved the issue as well, but this happens to be what I'm trying. \nI have no idea why this happened when I had the \"correct\" (vanilla rrf) component, but the problem looks solved.. ",
    "yborunov": "@davidkpiano I wanted to, but I couldn't find immutable version of react-redux-form on CDN. Do you know by change how can I use immutable react-redux-form there?. @davidkpiano thanks for recommended sandboxes! While I was creating an example I figured out what my problem was - I hadn't been passing the second parameter to 'combineForms' with the name of parent reducer, so react-redux-form apparently didn't know where to get my state. Interestingly enough, everything else was working fine. \nI've also struggled with many other issues in react-redux-form which of a similar kind, especially with immutable version. It would've been nice to add more exception or warnings to give an idea of a wrong configuration or missing parameters/props.\nFor example, I also spent quite a few time to debug why server-side validation isn't working until I realized that I need to specify empty messages prop on Error component. Another example is when there's a field validator without message, it just does show up and no warning is displayed.. ",
    "sergiocruz": "Btw, the docs claim that this is possible:\nhttps://davidkpiano.github.io/react-redux-form/docs/api/Control.html\n. ",
    "netbek": "I get the same error after submitting a form that has an async submit handler, more than once. I'm not using actions.asyncSetValidity. Below is a simplified version of my case. PR https://github.com/davidkpiano/react-redux-form/pull/837 fixes things sufficiently for my case, and appears (I did a quick test only) to handle the original issue. A more comprehensive fix might address the fact that asyncKeys can have an array or boolean value (https://github.com/davidkpiano/react-redux-form/blob/58fa7ccc2fafe4b4bfb49b4448207b782071bf41/src/reducers/form-actions-reducer.js#L209), which could lead to unexpected behaviour.\n```jsx\nconst formsReducer = combineForms({\n  myForm: {\n    myField: []\n  }\n}, 'forms');\nconst rootReducer = combineReducers({forms: formsReducer});\nclass MyFormComponent extends React.Component {\n  handleSubmit(myForm) {\n    const {dispatch} = this.props;\n    const submitPromise = new Promise(function(resolve, reject){\n      setTimeout(function(){ reject(false); }, 500);\n    });\n    dispatch(actions.submit('forms.myForm', submitPromise));\n  }\n  render() {\n    return (\n !!myField.length\n    }\n  }} onSubmit={(myForm) => this.handleSubmit(myForm)}\n\n\n\n\n\n    );\n  }\n}\n```. \n",
    "icopp": "Not having a straightforward way to set initialValues in the form component rather than in the Redux store is the only reason I haven't switched over to RRF instead of RF at this point.. ",
    "andrewhl": "@davidkpiano Related question. How do I initialize a form from state? Let's say I want to have an edit resource form. Do I initialize a reducer in this fashion? I feel like I need to implement something like the below to make this work. Am I overcomplicating things? Is there a simpler way? I just want to initialize a form with pre-existing values from state. Same idea as redux-form's initialize from state.\n```javascript\nconst initialEditPersonState = {\n    birthday_at: new Date(),\n    gender: 'select',\n    relationship: 'select',\n    first_name: '',\n    last_name: '',\n};\nfunction editPersonReducer(state = initialEditPatientState, action) {\nswitch (action.type) {\n    case api.GET_PERSON_SUCCESS: {\n        return action.payload.person;\n    }\n    case 'rrf/change': {\n        const model = action.model.split('.');\n        const value = model[model.length -1];\n        return {\n            ...state,\n            [value]: action.value,\n        }\n    }\n    default:\n        return state;\n}\n\n}\nconst appReducer = combineReducers({\n    app,\n    deep: combineForms({\n        editPerson: editPersonReducer,\n    }, 'deep'),\n});\n```. I answered my own question (I seem to do this a lot lately). You only need to define the reducer case for initializing. You don't need to handle 'rrf/change'.\n@davidkpiano I want to say that I really love this library. You've done a great job with it. I've tried pretty much every react form library out there (formsy, redux-form, tcomb), and this is hands down the fastest and best implementation. It feels really natural to use. I will advocate it to everyone I know. It even solved issues we were having with redux-form and ReactNative. That said, I find your documentation to be painfully unclear about some really fundamental things. I've had to dig through the docs, your source code, and do my own experimentation to get certain behaviours to work.\nThings I felt are unclear: \n- how to use react-redux-form/native's Control to handle Picker.Item child components (figured it out by guesswork and looking at Control.select in the docs)\n- how to use the same Control to handle custom, e.g. Native Base, form components (I figured it out by looking at the source code for native.js: you pass in the component directly and bypass Control.picker or whatever)\n- how to initialize from state (again, guesswork, piecing things together. It really wasn't clear to me from anything indicated in the docs. This seems like such a fundamental use case that it should have a section dedicated to itself. I happened by chance to read the section in Models on using a custom reducer and extrapolated from that.)\nI may be willing to accept that I am perhaps somewhat more dense than your average developer using this library, but supposing even that I am only equally as dense as the average, you may want to address some of these concerns. I would be willing to submit a PR for the documentation if that would be helpful.. I gave it a go. Looks like it's not currently possible given the state of some of your third party dependencies.\nI updated react and react-dom to v16.0.0-alpha.13, and these dependencies complain:\nwarning \"shallow-compare@1.2.1\" has incorrect peer dependency \"react@15.x\".\nwarning \"react-addons-test-utils@15.6.0-rc.0\" has incorrect peer dependency \"react-dom@^15.4.2\".\nThose are the latest versions of each library. I suppose I'll have to forgo using react-redux-form in this project until everything catches up to React 16.. I may be having an unrelated issue with my local environment. I switched to yarn and the application is building despite the unmet dependencies. So the library appears to be usable with RN 0.43.4. Apologies. It would still be good to get the versions up, but that doesn't seem possible (or necessary) at this time. Closing this.. Some progress doing the following. The picker displays the items, but it doesn't display the selected item and it resets to the 'select' in the UI regardless of what you choose (though it preserves the new value in the reducer).\nI've tried setting the model to deep.relationship, and playing with different initial values in the reducer (e.g., 'select', 'spouse', null). The outcome is the same. Whatever you choose resets in the UI to 'select'.\njavascript\n                <Form\n                    onSubmit={this.onSubmit}\n                    model=\"person\"\n                >\n                    <Control.Picker\n                        placeholder=\"Relationship\"\n                        style={style.picker}\n                        model=\".relationship\"\n                    >\n                        <Picker.Item label=\"Select\" value=\"select\" />\n                        <Picker.Item label=\"Spouse\" value=\"spouse\" />\n                        <Picker.Item label=\"Child\" value=\"child\" />\n                        <Picker.Item label=\"Sibling\" value=\"sibling\" />\n                        <Picker.Item label=\"Parent\" value=\"parent\" />\n                        <Picker.Item label=\"Grandparent\" value=\"grandparent\" />\n                        <Picker.Item label=\"Other\" value=\"other\" />\n                    </Control.Picker>\n                </Form>\nAnd my reducer:\njavascript\nconst appReducer = combineReducers({\n    app,\n    ...,\n    deep: combineForms({\n        person: {\n            birthday_at: '',\n            gender: '',\n            relationship: '',\n            first_name: '',\n            last_name: '',\n        },\n    }),\n});. Okay I realized I hadn't provided the 'deep' parameter to combineForms in my reducer, to instruct react-redux-form on my deep model path. Working now.. @davidkpiano Writing this documentation raised an interesting point for me. Do you think we could improve the native implementation for custom components? I'm not sure my code is even correct, but if it is necessary to redefine mapProps perhaps we could improve that? Like, if the component passed into Control returns a standard React-Native component, for which we know the event mappings, then resolve those mappings automatically?\nI know Native Base components are just fancy wrappers for React Native standard form controls.. @davidkpiano Please review these changes. I didn't really know what the optimal API would be, so I defined a Control.Custom input that accepts an additional 'delegate' prop, and delegates to the appropriate Control component. I updated the documentation to reflect this. I tested locally and it works great. This is the perfect API for standard native iOS inputs and form controls. I don't love the additional 'delegate' prop, but it works. If you have any suggestions on how that could be improved, I'm all ears.\nI noticed you don't have any tests for native.js. Do you have any recommendations for how you'd like to approach testing this? It seems the likeliest starting point is extending custom-control-component-spec.js. In our React Native application we use react-test-renderer and jest. I see you're using mocha. Thoughts?\nIf any of this is over-the-top or wonky, let me know.. @davidkpiano Hello. Any word on this PR? Feedback would be appreciated. If it's not what you're looking for, please let me know. I can modify it as necessary if you can provide guidance for what you're looking for.\nAlso, I was thinking the Native Form component should pick up onPress events from child Button components, because the practice of programmatically calling dispatch(actions.submit('form')) is a bit awkward. I end up having two submit methods for each form. Something like this:\n```jsx\n<Form\n    onSubmit={this.handleSubmit}\n    model=\"form\"\n\n...\n<Button onPress={this.submitForm}>\n     <Text>Save</Text>\n </Button>\n\n\n\nsubmitForm = () => {\n    this.props.dispatch(actions.submit('form'));\n}\n\nhandleSubmit = (form) => {\n    this.props.onSubmit(form);\n    this.props.onClose();\n}\n\n``\nI can't set a ref on theFormcomponent becauseNativeFormis exported as a stateless functional component. So I'd like to improve this behaviour too.. @davidkpiano Thank you. Your recommendation to override the component prop worked like a charm. I've removed my Control.Custom component and updated the documentation to reflect this approach. I've left in the documentation the bit about creating a custom Control component by overriding the mapProps, as I believe that still has value (for scenarios where people do not use a custom component that resolves to a React Native component, i.e., may have different event bindings). Please let me know your thoughts and whether we can merge this in now.. How are you importing Control? Should be:import { Control } from 'react-redux-form/native';`. @davidkpiano He's using 16.0.0-alpha.12. I'm using the same version. No issues here. It's very likely his import.. @davidkpiano Thanks for the response. Sorry, I didn't have time to post a codepen, but I think you answered our question.. Ah yes. I'll get rid of that.. ",
    "jcheroske": "I just wanted to echo @mikkelwf's sentiments. As far as I'm concerned, this IS the react form library. That said, the state of forms in 2017 is still lacking in some areas, and a solution that integrates the best ideas from all the React form libs doesn't exist yet. For instance, I'm convinced that first-class schema support would be a huge boon. A model definition is not exactly a UI concern, and being able to share schemas across forms is huge. I get that error messages are a UI layer thing, but being able to specify reasonable defaults at a higher level, and then overriding them in the UI as necessary is my preferred strategy. Anyways, I'm letting you know that, as far as I'm concerned, you are the guy, and this is the lib, when it comes to React forms. I might not be able to do too many pull requests, but I'll do my best to give you constructive feedback. Thanks a lot for all of your efforts.. Well, first off, I would look at skaterdav85/validatorjs. It is the best validation lib that I've seen, by far. It totally hits the sweet spot on so many levels. For instance, right out of the box, you get:\n Validation ordering: the order of the rules is the order that they will be processed, and obtaining the first rule that fails is easy. In your UI, you can just grab the first error and display that one and that's good for so many cases. For example, if you list required|min:5|email then you'll get the required error first, and when that's fixed, then you'll get the minLength. \n Error messages: Messages are at the validator level, but can easily be overridden. Best of all worlds.\n Template error messages: Not only can you override the entire error message, but you can just override attributes within the message. \n Total flexibility: You can define a schema for a model, but then only pull out part of that schema and use it in a form. You might have a big model, but then have several forms that only mutate part of the model at a time. You could pick the parts of the schema you want and validate against that. So easy!\nIf you embed that lib within a larger schema, then you could define most of your form in one place, like mobx-form does. I'd love to see something like:\n{\n  name: {\n    rules: 'required|min:4|max:40',\n    label: 'Name', // arbitrary prop that can get passed down to components\n    placeholder: 'Enter your name' // another arbitrary prop\n  },\n  email: {\n    rules: 'required|email',\n    label: 'Email',\n    placeholder: 'Enter your email address'\n  },\n  password: {\n    rules: 'required|min:4|max:20',\n    label: 'Password',\n    placeholder: 'Enter a password'\n  },\n  passwordConfirm: {\n    rules: 'required|same:password', // the awesomeness here is blinding\n    label: 'Confirm Password',\n    placeholder: 'Confirm your password'\n    errorMsg: 'Both passwords must match!'\n  }\n}\nIf then, in the Control component, you make all of that available to the wrapped Component, that's some seriously powerful stuff. The component could have access to:\n The first error message, if there is one\n All those extra props (label, placeholder, etc.)\nAt that point, there really isn't all that much that needs to happen at the component level. You could do specific overrides there (pass in a label prop for example), but most of the heavy-lifting has been done by the schema+validation.\n    . I did see that in the docs, but that's not what I'm asking about. If I use\na form level validator, the validation error exists only at the form level\nand is not associated with any specific fields, as far as I know. Being\nable to get the whole model in field level validators has value.\nSpecifically, it would allow the same validator from validatejs to work\ncorrectly. I think then I could add very lightweight schema support with\ndvr to rrf. All other validators would port easily I think.\nOn Mon, Jun 19, 2017 at 1:49 PM David Khourshid notifications@github.com\nwrote:\n\nClosed #849 https://github.com/davidkpiano/react-redux-form/issues/849.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/davidkpiano/react-redux-form/issues/849#event-1129878427,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ADgUyqTfK3HueONx6ygUNTWtgsIVL2Phks5sFt68gaJpZM4N9yyt\n.\n. I think just passing in an object as the second argument would work. Keys for the current model name (user.email) and for the entire model state would be a good start. That's all I would need right now. Something like:\n{\n  currentModel: 'user.email'\n  parentModelValue: {\n    email: 'foo@bar.com',\n    name: 'Jon Doe\n  }\n}\nHave you seen mobx-form? It has really sweet schema support, and supports three different validation libs via a plugins. When you use the validatejs plugin, the schema is just so straightforward and powerful. I think there are some good ideas there that would be so nice to have in this lib.\n\nOne more question: Is the RRF context object documented anywhere? Is there an HOC that grabs it?. > It's just the Redux store, there's no specific RRF context object (at least not in V1).\nHmmm. How does a Control know what Form it's embedded in? Like, when a Control uses the .email type syntax?. In my mind, the complete model would be passed to the validators. This would potentially cause more work to be done in the validation subsystem, but the output of that work would still be an object with the validation results as it is now (keys and boolean values). Aren't the re-renders triggered by that object changing? \nMaybe there could be a flag that controls whether or not the whole model state is passed into each validator, to keep the work done by the validators at a minimum? Most folks wouldn't need to turn it on I'm guessing.. I really don't want to enter Rx land just to declare form structure and behavior! In the same way that, yes, Rx gives you massive power, and you can do anything with a lib like redux-observable, most of the time you don't need it, and are better off just using async/await or promises. See redux-logic for a sweet take on a side-effect lib, that gives you the option of writing Rx if you need to, but doesn't force you into it.\nI'm still not understanding why you'll get a re-render if the whole state is passed to the validator. The output of the validator is a boolean. If that boolean doesn't change, then don't re-render. But I'm kinda dense and am probably missing the obvious.... Right, I get that the validator will run with every state change. But that seems different than a re-render. The validator may re-run, but if its return value (true/false) remains constant, then you don't have to re-render, do you? . Gotcha. What about adding a flag, so that whole-model validation could be enabled when desired?. I love it! In most cases, I think Rx is an implementation detail. \nI think I could write something that would split up a validatejs rules string, and special-case the same validator into that structure.\nOther than the model name, is anything else being passed through the context?. It appears that mapProps actually takes in an object that can contain either keys and values or keys and functions that map props to a new value.. Is fieldValue.valid the magic nugget?. And what should the model prop on Control.button be set to when the button really doesn't associate with a form field? I set it to ., but that seems like a hack.. Yeah, it did that. But for some reason, the validators were saying the form was invalid when it wasn't. As soon as I added the initial state of the model back to createForms it worked.. ```\nimport {FlatButton, TextField} from 'material-ui'\nimport PropTypes from 'prop-types'\nimport {Form, Control} from 'react-redux-form'\nimport {isEmail, isEmpty, isLength, normalizeEmail, trim} from 'validator'\nconst propTypes = {\n  finalCost: PropTypes.number.isRequired\n}\nconst required = val => val && !isEmpty(trim(val))\nconst minLength = min => val => val && isLength(trim(val), {min})\nconst email = val => val && isEmail(normalizeEmail(val) || '')\nconst ContactForm = ({finalCost}) => (\n  \nYour Quote: ${finalCost.toFixed(2)}\n<Form\n  model='forms.contactForm'\n  onSubmit={(...args) => console.log('burp', args)}\n  validators={{\n    name: {\n      required,\n      minLength: minLength(3)\n    },\n    email: {\n      email\n    },\n    phone: {\n      required,\n      minLength: minLength(10)\n    },\n    commodity: {\n      required,\n      minLength: minLength(3)\n    }\n  }}\n>\n  <Control.text\n    component={TextField}\n    floatingLabelText='Full Name'\n    fullWidth\n    mapProps={{\n      errorText: ({fieldValue: {errors, submitted}}) => {\n        if (submitted && errors.required) {\n          return 'Full name is required'\n        }\n        else if (submitted && errors.minLength) {\n          return 'Full name must be 3 or more characters'\n        }\n      }\n    }}\n    model='.name'\n  />\n  <Control.text\n    component={TextField}\n    floatingLabelText='Email Address'\n    fullWidth\n    mapProps={{\n      errorText: ({fieldValue: {errors, submitted}}) => {\n        if (submitted && errors.email) {\n          return 'A valid email address is required'\n        }\n      }\n    }}\n    model='.email'\n  />\n  <Control.text\n    component={TextField}\n    floatingLabelText='Phone Number'\n    fullWidth\n    mapProps={{\n      errorText: ({fieldValue: {errors, submitted}}) => {\n        if (submitted && errors.required) {\n          return 'Phone number is required'\n        }\n        else if (submitted && errors.minLength) {\n          return 'Phone number must be 10 or more characters'\n        }\n      }\n    }}\n    model='.phone'\n  />\n  <Control.text\n    component={TextField}\n    floatingLabelText='Commodity'\n    fullWidth\n    mapProps={{\n      foo: props => console.log(props),\n      errorText: ({fieldValue: {errors, submitted}}) => {\n        if (submitted && errors.required) {\n          return 'Commodity is required'\n        }\n        else if (submitted && errors.minLength) {\n          return 'Commodity must be 3 or more characters'\n        }\n      }\n    }}\n    model='.commodity'\n  />\n\n  <Control.button\n    component={FlatButton}\n    fullWidth\n    label='Contact Us!'\n    mapProps={{\n      disabled: ({fieldValue: {valid}}) => !valid\n    }}\n    model='.'\n    type='submit'\n  />\n</Form>\n\n\n)\nContactForm.propTypes = propTypes\nexport default ContactForm\nHere's my current reducer:\n    const rootReducer = combineReducers({\n      apollo: apolloClient.reducer(),\n      forms: combineForms({}, 'forms'),\n      ...sharedReducers,\n      ...appReducers\n    })\n``\nIf an empty object is passed tocombineFormsthen it doesn't work. If I pass in the initial state for thecontactForm` then it validates.. ",
    "samcolby": "Hi, Thanks for the response.\nI still don't see how I can setup both the dynamic forms and my reducer into the same place in the state tree.  I'm guessing that is what I would need to do (?) \nIf I use the following\njs\nconst rootReducer = combineReducers({\n  calculators: combineForms(formsState, \"calculators\"),\n  favourites: combineForms({favourites}, \"favourites\"),\n});\nI end up with the following state, where my own reducer is one level too low\njs\n{\n  calculators:{...},\n  favourites: {\n    favourites: {},\n    forms:{}  \n  }\n}\n. Hi, \nRight, after a bit more faffing about, I think I've got that to work using the above!  \nAlthough, it breaks if I add some initialState to the createStore call, but setting that to undefined allows it to work fine.\njs\nconst store = createStore(\n    rootReducer,\n    undefined,\n    compose(applyMiddleware(...middleware), autoRehydrate())\n  );\nAlso, my 'non forms' reducer does get called on every form update now, but I can live that!\nReally big thanks for your help with this, it's been driving me potty.\nSam\n. I've had another look and it does make some sense the way it is currently working.  It was just too confusing for me to get it right with no previous knowledge of the combineForms call etc.\nThe state in state.calculators from the reducer is being overwritten by the initialState added to createStore call, but does get added back in when the form is first used (if that makes sense).\nSee https://codepen.io/samcolby/pen/weBwEy if you're interested and let me know if you still want me to file as a bug.\n. ",
    "klis87": "I also have problems with this update. What I need is to onSubmit to be called only when form is valid according to validators rules, but I don't want to show HTML5 messages. Form noValidate will always submit the form, and Input formNoValidate will still show HTML5 error popup. So it looks like there is no way to get what I want for example for <input type=\"email\" />, but I guess that this is quite common usecase, unless it is possible somehow?. One of ideas would be to add new prop to Form, for example onValidSubmit. This would be in sync with HTML5 spec, because onSubmit would work as in specs, and this additional callback would be good combination with noValidate.. @davidkpiano I have the same issue like @peterox and I will say it here as I really think this is a bug.\nI have following components:\n```javascript\nimport React from 'react';\nimport { Control } from 'react-redux-form';\nimport FormGroup from './FormGroup';\nconst isValid = ({ fieldValue }) => fieldValue.valid || (!fieldValue.touched && !fieldValue.asyncKeys);\nconst Input = props => (\n  \n);\nexport default Input;\njavascript\nimport React from 'react';\nimport { FormControl, FormGroup as BootstrapFormGroup, ControlLabel } from 'react-bootstrap';\nimport { Errors } from 'react-redux-form';\nimport ErrorMessages from './ErrorMessages';\nconst show = field => field.touched || field.asyncKeys;\nconst onInvalid = e => e.preventDefault();\nconst FormGroup = ({ valid, label, messages, ...rest }) => (\n  \n{label}\n\n\n\n);\nexport default FormGroup;\n```\nThe problem is, that I wanted error state and error messages to be visible only when field is touched. It won't work in the following case - you don't fill your form but just press submit immediately - show and isValid aren't called when clicking submit, so my components aren't told that fields should become touched and no message or invalid styles are being shown.\nThis is really a serious issue as currently there is no way to make this work, and all I can do is to revert to older version.  . @davidkpiano I missed that one, but it is even better than what I suggested! And exactly what I need :) Regarding removing some codebase, I guess you could remove disabled prop then, as you could achieve conditional disable based on field state by using mapProps as well.\nAlso, did you consider removing errors prop from Control component? In my opinion it duplicates  validators, and the main use case for it is abusing it by doing something like !valid && 'this field is invalid', to show error messages. But as you said in docs, it should be discouraged and messages should be put in Errors component, as this is view part and should be separated.. Thanks, that was really quick!\nCould you please upload this new version to npm?. Thank you! And i confirm, everything works properly with the new version :+1: . ",
    "Venumteam": "hm, for some reason I can't reproduce this bug in codepen, errors works fine there. I have '1.11.1'v. of RRF I'll try to update to the latest release. Thanks for the advice\n. dispatch(actions.setErrors('forms.loginPhone.phoneNumber', { notFound: true }));\nif I set errors by this approach, it seems all fine, but if  I trying to set error message like this\ndispatch(actions.setErrors('forms.loginPhone.phoneNumber', 'error message'));\ni have this bug. Also can you please tell me, how to remove dispatched error, when user trying to resolve his mistake?\n. ",
    "leoalves": "The validator has to be a function or object. \nThat's why the second option gives the error it cannot be a string.\nWith actions.resetValidity(model, [omitKeys]) you can reset the error.. You can manually call the async validator. After the change\nchangeAction={(model, value) => (dispatch) => {\n  dispatch(actions.change(model, value))\n  if(value is valid) {\n    dispatch(actions.asyncSetValidity(model, asyncValidator))\n  }\n}}. Check if the value is valid before you call the async func.\n<Control model={`formData.${step.name}`}\n               component={formatter ? FormattedControl : undefined}\n               {...formObj}\n               validators={getValidations(step.validation)}\n               asyncValidateOn=\"blur\"\n               asyncValidators={{\n               isValueValid: (value, done) => {\n               return (value is valid) ? getAsyncValidations(step.validation) : done(true)\n               }\n               }}\n               validateOn=\"change\"\n               placeholder={step.placeholder}\n               type={(step.mask) ? \"password\" : type}\n               autoComplete={(step.mask) ? \"new-password\" : \"\"}\n               autoFocus={steps.length === 1 || (steps.length > 1 && steps[0].name === step.name)}\n               mapProps={{\n                 className: ({fieldValue}) => (fieldValue.valid || fieldValue.pristine || !fieldValue.touched)\n                   ? 'form-control'\n                   : 'form-control has-error',\n                 value: (props) => props.viewValue\n               }}/>\nSomething like that. I didn't test but should work.. ",
    "Kolombiken": "Thank you for attending to this issue so quickly!\nI agree. It is quite easy to do this for the developer BUT I've seen enough applications built in React to know that people do not do this. Lack of awareness/knowledge is usually the reason. So good examples in documentation are super-needed here! \nI think if either of the things you suggest are implemented it would help greatly \ud83d\ude04  . ",
    "pbreah": "Same problem. It still gets:\nUncaught Invariant Violation: dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a worker thread. Make sure window and document are available globally before requiring React when unit testing or use ReactDOMServer.renderToString() for server rendering.\nI'm disassembling and testing the hierarchy with different configurations to see if I can trace exactly what is generating this problem. The strange part is that it works on the browser (no warnings or errors) until running unit tests.\nIf I find anything I'll post an update here.. I did. jsdom is setup correctly - I have tests that rely on it, and the only test that fails is the one using RRF.\nI also looked at your unit tests for RRF before posting this question, as I have a similar setup, the only difference is that I'm not only testing the form alone. I just wondered if there was something else not documented that causes that problem when rendering RRF on a test env.\n. After an in-depth check of the code, the problem was another dependency that caused the test to crash react-redux-form. It is now fixed after removing it. Sorry for the noise, this is one of those errors that required to take everything apart until finding the combination of \"ingredients\" that triggered the error.. @davidkpiano thanks for the quick response! \ud83d\udc4d . @davidkpiano, thanks for your quick response.\nStill, I made the change on the CodePen. It doesn't fix the problem with\nJavascript\nconst mapDispatchToProps = (dispatch) => bindActionCreators({\n  push: actions.push,\n  remove: actions.remove,\n  dispatch\n}, dispatch);\nOn the latest version of redux, if I don't pass \"dispatch\" explicitly on \"mapDispatchToProps\" I don't get access to it on the component. I don't see the point of wrong as dispatch is doing its work well on the example. Try removing \"dispatch\" from \"mapDispatchToProps\" (from the CodePen) and you'll see what I mean.\nAgain here is the new updated CodePen mapping the action creators - per your suggestion (with the same error): \nhttps://codepen.io/anon/pen/KqQydK?editors=0011\nIt would be helpful if you could fork the same CodePen with the fix that doesn't trigger the error.. @davidkpiano thanks again.\nI see where the confusion came from... on the sample code on #867 you had: \nJavascript\n<button\n    type=\"button\"\n    onClick={() => dispatch(actions.push(`club.members[${i}].hobbies`, initialHobby))}\n/>\nSo using \"dispatch\" on the event handler call caused the problem. Removing \"dispatch\" from the button event handler solved it. \ud83d\udc4d . ",
    "johnhampton": "Wow, that was fast! Thank you!. ",
    "marcosschroh": "The same happens to me. Any updates?  . Hi,\nI have the same issue. I am expecting the same behaviour as setErrors. \nsetErrors action behaviour:\n1. I send the form\n2. The backend responded with an error\n3.  I dispatch the action setErrors with the errors\n4. The message is shown in the form.\n5. I edit a field and the form becomes valid again, so is possible to re-submit (excellent)\nsetFieldsErrors action behaviour:\n1. I send the form\n2. The backend responded with an error\n3.  I dispatch the action setFieldsErrors with the errors\n4. The message is shown in the fields that have errors\n5. I edit the fields that have errors, and the form never become valid again, so is not possible to re-submit\nI have tried the piece of advice that you has mentioned using { transient: true } but didn't work.\nregards,\nMarcos. \n. I am using redux-saga 0.14.8. Is weird because is working with other actions. . I mean actions.change, actions.load, etc.. thanks @davidkpiano !! awesome.. ",
    "k4zuk0": "@davidkpiano Could you please publish a new patch including this fix ? I'm having a similar bug, so I can't ship what I'm working on in production :/. ",
    "ghost": "I guess the problem still persists especially because now React 16 is out! It's a warning but I assume it won't be a deal-breaker in any way. ",
    "georgiosd": "One solution I found is to use your actions instead of defining my own reducer - however, the problem there is that I don't have to change to do custom things, like define an id for each item.. Basically the question is, when you use the combineForms auto-generated reducers, how can you accept your own reducers for the same model at the same time. \nI made due with using actions.push for now but will try to do a codepen soon - meantime if you can give some generic guidance, that'd be great!. Right :) so in essence being able to add your own actions beyond what actions allows.. Of course, understood :) Do you have an ETA for v2?\nWhat makes it difficult? Couldn't you just take in an array for other reducers before executing your own?\nreducer = combineReducers({\nfoo: createForms(myOwnReducer1, myOwnReducer2)\n})\nNew to ReactJS so forgive me if I'm being naive :). Mmmmm gotcha. My intention was to be able to effect the change I wanted to the model but I forgot that you also have to detect the change so you can update the form.\nI look forward to seeing what you come up with :) Great job so far!\n. ",
    "em-ka": "Hi @davidkpiano, are there any plans / progress with the new validateWith  API? Thanks.. Thank you, David, for guiding me the right way. I was successful using the combination of a custom component with NumberFormat and Control.text parser for providing the right value back.. ",
    "Bernix01": "any update on this? @davidkpiano @jcheroske . ",
    "matt-sm": "I fixed this by passing initial values to push():\nconst initialUserState = {firstName: '', lastName: ''};\ndispatch(actions.push(`${model}.users`, initialUserState));\nStill confused how the first object in the collection became \"valid\" when I pushed the second object, but looks like initial state is important.. ",
    "ekynoxe": "@tberster , @smattt , @davidkpiano , I'm having similar issues with a very complex dynamic form, and digging a little into this, it seems to me that it can be solved with actions.omit(...), or if nested (that's my case) using actions.change(...) where the model is the nested object, and the \"value\", an object which keys are the only properties I want to keep.\nIt looks like it's working for me.\nHowever, even if I can see that the keys are indeed being removed from the state, it looks like validation is not ran when this change action is fired.\nI believe this is because validators are on fields, and not the form itself, is that right? So if we remove a field, the overall validation is not changed.\nWhat do we miss?. Actually, it looks like the form gets revalidated properly, it's the fieldsets that I use as \"form sections\" that don't get the new \"valid\" property.\n@davidkpiano I read somewhere else that fieldsets validation wasn't fully complete, but I can't remember where.. ",
    "fraxachun": "Ok, in the end this turns out to be a logical solution and even gives more control about the forms behaviour. Thanks!. ",
    "KubaChoice": "Hi, It will be helpful (in my case) if initialState could take a Promise. What do you think?. Thank You for your answer, \nI did, and with mapToProps and other features it was successful, but it looked like a horrible way for checkboxes and radio buttons groups ...\nBut, still thanks\n. ",
    "ignatiusreza": "Sorry, haven't played around with async validation much to understand the comparison.. but, it sounds like it could solve the use case, as long as it doesn't clear up the errors on page navigation (remount).... Took a quick look into async validation.. and it got me thinking that maybe the timing of when the errors should be cleared should be controlled by either validateOn or asyncValidateOn.. as of now, I'm leaning more toward asyncValidateOn (on blur).. but, this is more because so far, I have only found the need to explicitly use actions.setFieldsError when handling async validation on form submit.. everything else can be handled via validators or errors props.. wdyt?. Managed to work around this issue by normalizing the errors to something like\njs\ndispatch(actions.setFieldsErrors('user.something', {\n  foo: { async: 'foo is not bar' },\n  bar: { async: 'bar is not foo' },\n});\nand then to have the following on each Control:\njsx\n<Form model=\"user.something\">\n  <Control.text model=\"foo\" asyncValidators={{ async: (_, done) => done(true) }} />\n  <Control.text model=\"bar\" asyncValidators={{ async: (_, done) => done(true) }} />\n</Form>\na bit cumbersome to do, but it's working :grin: . updated with test :+1: . ",
    "fabiob": "Has anyone made any progress on this front?\nAs a workaround, I'm currently using this on my mapProps:\njs\nonChange: (props : any) => () => props.dispatch(actions.resetValidity(props.model)). ",
    "jjmr": "Is there any progress on the transient parameter on the setFieldsErrors action? Is it also going to be propagated to actions that use setFieldsErrors like submitFields?. ",
    "creatorkuang": "I have the same issue. I have update the codepan template and you could check it.  https://codepen.io/anon/pen/rwbPYo \n\n\n\n. I agree with you that we could not identify whether it's array or object with this dash model. In some case, it's hard to set the default value . For my case , we allow user to drag and drop to define the form and they don't  need to set up their initialState.  So, I think what you said might be good.\nif the model is[<positive integer>],you identified it as an array, and if user want to use object, use .<positive integer>. \n. @davidkpiano could you point me out where is right place to enhance this, I could spent sometime to do this enhancement.. @davidkpiano  I have done what you propose and it throw me out with this error:\n\nwhich is point to reducers/form-actions-reducer line 97 const { intents } = fieldState;. The code in utils/assoc-in.js as below and i have already test it.  Please point me out what i should do next? \n```javascript\nimport identity from './identity';\nfunction objClone(obj,isArray) {\n  const keys = Object.keys(obj);\n  const length = keys.length;\n  const result = isArray?[]:{};\n  let index = 0;\n  let key;\nfor (; index < length; index += 1) {\n    key = keys[index];\n    result[key] = obj[key];\n  }\n  return result;\n}\nexport function assoc(state, key, value) {\n  const isArray = Object.prototype.toString.call(state) === '[object Array]'\n  const newState = objClone(state,isArray);\nnewState[key] = value;\nreturn newState;\n}\nexport default function assocIn(state, path, value, fn = identity) {\n  if (!path.length) return value;\nconst key0 = path[0];\n  // try to fix #863\nif (path.length === 1) {\n    return fn(assoc(state, key0, value));\n  }\n  let subVal = {};\n  if(state[key0]!==undefined) {\n    subVal = state[key0]\n  } else {\n    const key1 = path[1];\n    if(key1 && !isNaN(key1) &&  Math.floor(key1)===parseFloat(key1)) {\n      // check path .[Number]. or .Number.\n      const valPath = value.model;\n      if(valPath!==undefined) {\n        const key1Idx = valPath.indexOf(key1);\n        const keyGap = key1.toString().length;\n        if(valPath.substring(key1Idx-1,key1Idx)==='[' && valPath.substring(key1Idx+keyGap,key1Idx+keyGap+1)===']') {\n          subVal = [];\n        }\n      }\n    }\n  }\nreturn fn(assoc(state, key0, assocIn(subVal, path.slice(1), value, fn)));\n}\n```. ",
    "Bitz": "Here is a use case: https://codesandbox.io/s/VOxrnZPYX\nAs you can see, it is populated by the data, but it is never fired (ie) The event that should fire to revalidate does not because it does not detect the texboxes being filled. . ",
    "Escapado": "I am piggy bagging this in hope it will be seen. There are a few minor syntactic errors in the example above (as well as the docs) with closing tags at the buttons and import (of connect and React). However even when fixing this I am still having trouble to get this to work.\nIf I insert the corrected example into a new file and import that component then it initially renders properly and after clicking Add Member I even see that in my reducer the members field gets added with one entry. However it's not an array but an object. And if I console.log club then it's undefined. Does anyone know what my problem might be?\n---- Edit ----\nThe problem seemed to be that something goes wrong when the form is not properly initially defined with the createForms() method. Managed to fix it myself. I'll try to submit a PR with the fixes to the syntax.. I wasn't able to reproduce the warning I had in a codepen. I found the reason nonetheless:\nselectedDatewas properly defined but the model should have been \"calendarForm.entry.start\"since I defined a nested object as initial state and screwed up the refactor to adjust for that. Thanks for the quick response anyway and thanks for this great project. Saves me a lot of time and effort!. ",
    "joshacheson": "This approach is one I hadn't considered. I'll give this a shot and report back with my findings here. In the mean time I will close this issue, and re-open for more discussion only if it's necessary. I really appreciate the quick response.\nI'm not sure if there's a place in the docs that references this sort of usage, and I'd be happy to PR to the docs to add an entry under Recipes and Examples if you'd want something like that (again, assuming this solution pans out).. I never ended up using global forms via react-redux-form. What we did instead was always use \"local forms\" (although not react-redux-forms's <LocalForm/>, but instead manually created stores which we pass to <Form/>, so in effect a \"local form\") and we \"register\" those forms to a namespace on a custom <FormsProvider/> at the top of our component tree. This way, we get the benefits of local forms (performance, mainly, by not dispatching to the global redux store all the time) but still have the ability to read from / write to form state all around the application. Our abstractions on top of react-redux-form go well beyond this (we've also abstracted its actions API entirely) but I digress!\nIf you're interest in a solution like the one I described I'd be happy to help / describe it in more depth.. Yeah! So there are a couple different things we did there:\n1) We wrote a Form class (as in a plain class, not a React Component) which wraps a redux store that has a react-redux-form reducer in it.\n2) The Form class exposes an API that is in some ways similar to react-redux-form, but we renamed methods that we didn't think were intuitively named. For instance, we have resetModel and resetUi instead of reset and setInitial (we think of the two parts of form state as \"model state\" and \"ui state\" so this worked well for the language we use internally). Also, all calls to dispatch are implementation details, so we're just calling something like form.change('path.to.field', value) instead of any consumer ever actually using dispatch. In our implementation, redux and react-redux-form have become implementation details. We were meticulous to make sure the abstraction didn't leak. There are a lot of reasons for this, but the number one reason for me was because I think I'll want to write a form's library using mobx for what I think will be huge perf benefits, and when I do that I want to retain our API.\nnote: By doing these things we've basically come up with a \"frameworkless\"-ish form lib but we just happen to build it on top of react-redux-form\n3) We added a new method, do, which is a declarative API for doing effects on a form. do also batches changes for the perf benefits that will come with if you're making multiple changes. Our API for Form#do is like\njavascript\nmyForm.do({\n  'some.field': {\n    errors: { ... },\n    pristine: false,\n  },\n  'some.other.field.somewhere': {\n    value: 5, // this actually edits the model!\n    valid: true,\n  },\n});\nAnd again, under the hood do is just calling react-redux-forms's actions inside a batch.\nThis Form class has enabled us to have form instances that we can pass around, without needing a global redux store, and without needing for a component to stay mounted on the UI for us to retain its state. For accessing state of a form throughout the application, we put together a <FormRegistry/> which uses React's context, sits at the top of our tree, and offers any part of the application access to any form.\nBasic Example\n<FormRegistry>\n  <SomePage>\n    <Main>\n      <Form name='testName'>\n        ...\n      </Form>\n    </Main>\n    <SidePanel>\n      <WithForm name='testName'>\n        {form => (\n          <span>The person's name is {form.get('firstName') + form.get('lastName')</span>\n        )}\n      </WithForm>\n    </SidePanel>\n  </SomePage>\n</FormRegistry>\nOur <FormRegistry/> has some other interesting features, but this is the crux of it.\nOverall, we like keeping form state \"local\" (living in some form class) but we give access to that state via the context to other parts of the UI. This means we're not always dispatching to the app's global redux store (which for us presented perf problems after a while in a really large app).\nSorry it took me a while to reply. Hope this stuff makes sense. Happy to explain more if you're interested.. Do you have any initial pointers as to why v4.x.x is recommended? AFAICT 5 introduced no breaking API changes. I only ask so that I can hone in on the issue quicker :) Will definitely be taking care of the PR here!. I ran the tests against react-redux v5.0.6 (most recent). They passed. I'd put together some doc changes, but there's already a PR: #1000.\nClosing this since it just makes sense to merge #1000.. Here's the codesandbox. The template was super useful, thanks for that:\nhttps://codesandbox.io/s/5ym1mypn3k\nRe: completely replacing test as opposed to recursive updating, the recursive update seems intuitive, but I might be misunderstanding your suggestion.. Hey there! Is there anything I can do to help move this along?. First pass at a PR: https://github.com/davidkpiano/react-redux-form/pull/1024. Closed by #1024. It looks like CI didn't run here, but it's worth mentioning that this branch appears to have introduced a CI breaking change. Here's a run from my branch: https://travis-ci.org/davidkpiano/react-redux-form/jobs/305494217. @davidkpiano if you have any issues with the general approach here please let me know. If so I'll be trying to get up a new PR asap!. I'm happy to. Can you advise as to the best way to fix? That lint error was actually introduced in this PR: https://github.com/davidkpiano/react-redux-form/pull/1022 (but it looks like CI didn't run for that PR). I can't tell what I might import so as to make sure that export (which is causing the lint error) is safe.. https://github.com/davidkpiano/react-redux-form/issues/1041 related / same issue, we can close mine probably?. I believe prepublishOnly (script in package.json) never got to build because the linter failed (due to https://github.com/davidkpiano/react-redux-form/pull/1022. which has since been fixed but was not at the time of release).. Looks good to me :). @davidkpiano looks to me like the Errors component could benefit from a similar API. Support all the existing props, but allow a render prop as a more flexible alternative to wrapper and component. Would be happy to do this also. Any concerns?\nedit: In this case the show prop might be more appropriately named \"filter\" or something, and it can filter whether error messages are passed in.\nAPI example:\njavascript\n<Errors\n  model=\"some.model\"\n  messages={{\n    required: 'Required',\n    length: 'Too long',\n  }}\n  filter|show|when={field => field.touched}\n  render={(errors, field) => (\n    // Pass in both errors and field? Why not?\n    <div>\n      {errors.map(error => <span>{error}</span>}\n    </div>\n  )}\n/>. As it stands if both render and component are defined, component is ignored. Basically there's an implicit preference for the render behaviours over the opaque component api. I might be misunderstanding your question. For clarification:\n1) The component API doesn't seem to act like a render prop to me at all. You can get the same effects more or less out of the component API as with render, but I would make the argument that it's a less idiomatic and explicit way to get those results. component blackboxes a call to React.createElement, which is the specific detail an idiomatic render prop implementation avoids.\n2) The closest thing I can see to a render prop amongst components in react-redux-form is the way <Field/> works if it's passed a function as children. However when <Field/> is used in this way, it does not provide event handlers, just field state, to the provided function.\n3) We have the option of throwing an invariant in a case where both render and component are provided. What are your thoughts on this?\n4) We could deprecate the component API. I'm not certain that it has any benefits over the render API, aside from backwards compatibility.\nSorry if I misunderstood entirely.. Looks correct. I'm totally confused as to what was wrong.. The reason I'm using <Field/> in this way is specifically because I want to read fieldValue at this point in the tree. Perhaps the better way to handle my suggestion is to, well, add a render prop to <Fieldset /> which passes the relevant fieldValue.. Worth mentioning, I guess, that I'm very happy to do all the work for whatever's decided here. Just interested in feedback on the ideas.. ",
    "riceboyler": "Never mind, figured out the problem. I wasn't mapping state to props so I wasn't getting the model representation.\nFeel free to close.. ",
    "atatakobry": "i mean something like this:\n...\nconst debouncedOnDispatchSubmit = debounce(() => {\n  dispatch(actions.submit(formModel));\n}, 1000);\n...\nchangeAction={(model, value) => {\n  dispatch(actions.change(model, value));\n  debouncedOnDispatchSubmit();\n}}\n...\nIn this implementation it works, but, unfortunately, onSubmit method in Form runs twice. debounce was taken from lodash.\nbut it's no matter, 'cause the bug with \"calls twice\" appears even in:\n...\n  setTimeout(() => {\n    dispatch(actions.submit(formModel));\n  }, 1000);. i dunno if it's really bug of RRF, but im gonna try to make some code example tomorrow. thank you!. https://codepen.io/anon/pen/OgBPxE?editors=0010\nit's weird, but i can't reproduce bug in sandbox :( \nand console.log('onSubmit'); runs only one time, not twice\ngonna try to debug my app\nUPD:\nSorry, there was a mistake in way using bindActionCreators and passing dispatch. Closed. OS X\nOpera 46.0.2597.39  - same as Chrome\nSafari 10.1.1 - show tooltip \"Enter a valid value\"\nFirefox ESR 52.2.1 - don't recognize 18.5 as valid number; browser offers to input the nearest valid values: 18.5(lol)  or 19.5.\n. You can use step=\"any\" as at least some solution: https://stackoverflow.com/a/14371142. ",
    "nbiles": "Any update on this?. ",
    "worc": "the issue is that instead of something like visibility: hidden; the element just never renders which causes that inch-worm effect in any dynamic layout, your bootstraps and css flexboxes for example, and is an extra burden when trying to debug a form.\na better approach would've been to render the Errors component, set its visibility to hidden, and remove it from the tab-navigation stack. that way the element still reserves the space it needs when it does have error messages to display, and it could be easily overridden when debugging.. ",
    "lstuartfry": "Looks great, thanks!. I can confirm, this is still an issue with the latest version(s) of react-redux-form.. Just checking back in on this, has a new patch been released?. @davidchase thanks for the update!. Also having this issue, mainly after 'resetting' a field that has a value in the form's initial state (and that value's format doesn't match the format of the Select's options). @im1dermike this could be handled the same way you'd want to handle it in Redux: using .slice() and .concat() array methods to create a COPY of the array stored in redux (without changing it directly).  Check out this short video by Dan Abramov where he explains how to do this - https://egghead.io/lessons/react-redux-avoiding-array-mutations-with-concat-slice-and-spread. As long as you're initializing the form state and creating your store in a similar fashion to the way it's outlined in the Quick Start section on Github, the actions.change() method should hit the reducer and update your redux store properly.\nconst initialUser = { name: '' };\nconst store = createStore(combineForms({\n  user: initialUser,\n}));. ",
    "davidchase": "Hi guys,\nUnless i am missing something this issue is still happening in current version 1.14.1, if you refer to the original code pen from the OP you can see it references the latest version of react-redux-form and calls reset and then change.\nPlease let me know.\nThanks. My current work around is to use debounce from lodash and use changeAction to customize the change handling all as a HOC but i guess it would be nice to have it work in the library as well \ud83d\ude42 . @davidkpiano thanks for the quick fix but for some reason it doesnt seem that the fix has landed in 1.14.2\nhttps://unpkg.com/react-redux-form@1.14.2/lib/utils/debounce.js\nthe above debounce in the lib directory doesnt seem to have the fix and i pulled it down locally with the same issue. @davidkpiano  can we maybe bump to 1.14.3 to ensure all new version have this fixed? . Ok thanks \ud83d\udc4d\ud83c\udffb. @lstuartfry yes it looks like the latest version has patch\nhttps://unpkg.com/react-redux-form@1.14.6/lib/utils/debounce.js L17\nand check the codepen \ud83d\udc46 looks like it works \ud83d\ude04 . @davidkpiano i mean like i have a collection like so\njs\nconst obj = {\n  123: {number: 332},\n  456: {number: 563},\n  789: {number: 445},\n  ...\n}\ni want to validate on form like so\njs\n<Form validators={{'user.obj{}.number'}} />\nRight now you support via user.obj[].number so array of objects https://github.com/davidkpiano/react-redux-form/blob/master/docs/guides/validation.md#deep-model-validation-in-form\n  . ",
    "CharlieIGG": "Right @davidkpiano I did take a look at the docs, but I can't seem to understand them right. I've tried:\njavascript\nmapProps={{\n    searchText: (props) => props.modelValue,\n}}\nand\njavascript\nmapProps={{\n    searchText: (props) => props.viewValue,\n}}\nand\njavascript\nmapProps={{\n    searchText: (props) => props.value,\n}}\nAnd all these with value and searchTexton the opposite side...\nI can't seem to understand this mapping..... Thanks @davidkpiano, indeed Autocomplete only seems to have a onUpdateInput method, but if I do this \njavascript\nmapProps={{\n   searchText: (props) => props.modelValue,\n   onUpdateInput: (props) => props.onChange,\n}}\nI still cannot update the model's value, nor trigger events on change. :$. Found the problem! I forgot to add {...props} when building my YearField component.... In case anyone stumbles with the same issue, this did the trick:\njavascript\nconst handleStateChange2 = ({ model, dispatch }, options = {}) =>\n  (ev, index) => {\n    dispatch(actions.change(model, index, options));\n  };. ",
    "elijah-schow": "@davidkpiano I get this same issue while trying to use LocalForms. Unfortunately, I don't see any way to use thunks with LocalForms. I'm intentionally NOT using my own redux store.. I've encountered a possibly related issue. If add and remove an item from the collection, then change another input field, the item re-appears. It appears that the item is indeed removed from modelValue, but remains in formValue, and re-appears in modelValue after another field changes. The same happens if I use actions.change instead of actions.remove.. ",
    "im1dermike": "I'm running into this problem as well.  I don't believe a CodePen, Plunkr, etc will work because the browser won't save that form.  Ultimately, you can't add a autocomplete=\"false\" attribute to an RFF Form which is the problem.. @davidkpiano I asked how you do something in this framework because I couldn't find any documentation in re: and you ask me to implement a fully working example?. I can try to put together an example but the InnerComponent are just parts of a form (Controls) that have been separated based on concern.. Thanks. I'll give it a try and get back to you. Might be a week or so fyi.. I'm still working through getting my example to work in CodeSandbox, but here is the setup so you can understand it conceptually.\nIn summary, I need to implement a single form where controls within the form are stored in separate components, but they share a same parent form/model/submit event.. I finally got a chance to look at Fieldsets, and it indeed looks like that will solve my problem.  Thanks!. @lstuartfry I actually watched this video earlier today. :) \nI understand how to write the reducer logic, it's just a matter of where does the reducer exist in RFF.  Based on @davidkpiano's comment, I should use the boilerplate action.change(), including the proper reducer logic.. @lstuartfry Thanks.  It looks like I'm on my way to successfully implementing @davidkpiano's suggestion using the boilerplate actions.change().  I'm still not clear on what I would use a modelReducer, however.. Thank you!  \nOn a somewhat related note, I'd like to be able to indicate in the tab link if there is an error on that tab.  How can I access a list of form errors?  I assume there is no way to group errors in a FieldSet together.... I wasn't sure if there was a RRF built-in means to access form control validities (actions.validateFields(model, fieldValidators)?) or if I should access the form directly in my AppState.. @davidkpiano Any thoughts on this?. For posterity:  https://stackoverflow.com/a/48156889/1315956.. @valorize Yes, it doesn't appear that the issues you brought up really pertain to the topic.\n@davidkpiano Can you address my original issue?  It seems like basic functionality for a forms library that is not in place.. @davidkpiano I can try if need be, but can you explain the expected behavior you built for determining at the form-level if a submit was attempted?. @davidkpiano I don't care about knowing when the submit to the server completes.  The point in time I'm trying to identify via $form props is after the form is submitted (via a submit button) and after validation has fired.  pending is false when I submit the form.. @davidkpiano Here you go.\nNot sure if this was obvious, but, to be clear, the existence of the errors prop appears to be the difference in this situation occurring and not occurring.\nIn this example, I'm adding records by just mutating the react state.  In my real code, I call:\nlet newRecords;\ndispatch(actions.change(formModel, records => {\n   return [...newRecords];\n}));\nThe same rrf/setErrors situation occurs in both sets of code.  The only difference is that, in my code, dispatching the change action provides an additional delay separate from the setErrors delay.  1000 records with 2 tracked controls takes an extra 10 seconds.  In fact, calling change on a large tracked form data set is inherently super slow.  Deleting a single record from a 1000 array data set using dispatch(formActions.remove(formModel, index)) takes ~4 seconds.  I hope I'm not concluding that large RRF datasets result in awful performance.... Another example wired into form actions.  This doesn't show the long delays I'm experiencing, but does show some delay.. I ended up resolving this.  Here is an CodePen of my solution.. ",
    "MatejBransky": "But that means that you have created whole form state for exampleProp1 and exampleProp2 which are not forms data or haven't you?\nI need something similar but I don't want to create form state for props which are not form values but I need in my form reducer the access to the state which is not part of the form. How can I do that?\nHere is my attempt:\n```js\nconst store = combineReducers({\n  subApp: myReducer\n  ...\n})\nconst initialState = {\n  schema: {...},\n  uiSchema: {...},\n  data: {...} // form values\n}\nfunction myReducer(state = initialState, action) {\n  // there are some conditions between schema, uiSchema and data\n  const modified = pipe(fn1, fn2, ...)(state) \nreturn {\n    schema: modified.schema,\n    uiSchema: modified.uiSchema,\n    data: modified.data\n  }\n}\n```\nHow can I achieve that with react-redux-form?\nI've tried createForms() but that created form state even for schema and uiSchema which is undesirable.\njs\nconst store = combineReducers({\n  ...createForms({ subApp: myReducer }),\n  ... \n})\nUpdate:\nOk, so I've done something like this:\n(working example: https://codesandbox.io/s/72r9rok4zx)\n\nrootReducer.js - usage with combineReducers\n\n```js\nimport { combineReducers } from 'redux'\nimport createReducer from './createReducer'\nimport { subAppReducer } from './subApp/'\n\nconst rootReducer = combineReducers({\n  counter: (state = 0) => state,\n  subApp: createReducer({\n    reducer: subAppReducer, // wrappedReducer(subAppReducer)\n    formKey: 'data', // combineForms({ data: wrappedReducer })\n    scope: 'subApp' // combineForms(..., 'subApp')\n  })\n});\n```\n\n\nsubAppReducer.js - reducer with form (model data) and related state\n\n```js\nconst initialState = {\n  schema: { // related state\n    boo: true\n  },\n  data: { // model state\n    userName: {\n      firstName: '',\n      lastName: ''\n    }\n  }\n};\n\nconst subAppReducer = (state = initialState, action) => {\n  if (state.data.userName.firstName === '5') {\n    return {\n      ...state,\n      schema: {\n        ...state.schema,\n        boo: false\n      }\n    };\n  }\n\n  return state; \n};\n\nexport default subAppReducer;\n```\n\n\ncreateReducer.js - the main file with a solution\n\n```js\nimport { combineForms } from 'react-redux-form';\n\n/**\n * @typedef {object} Settings\n * @prop {function} reducer - user defined reducer which needs an access to the model and related state\n * @prop {string} formKey - key of a model state\n * @prop {string} scope - state parent key of the model and related state (default = '')\n */\n\n/**\n * Returns reducer which works with model and related state\n */\nconst createReducer = (\n  /** @type {Settings} */ { reducer, formKey, scope = '' }\n) => {\n  const formReducer = combineForms({ [formKey]: wrappedReducer }, scope);\n  // storage for related state (it's needed for currying of output)\n  let curriedState;\n\n  return (state, action) => {\n    // formReducer accepts only form-related state (formKey and 'forms')\n    const formOutput = formReducer(\n      state && { [formKey]: state[formKey], forms: state.forms },\n      action\n    );\n\n    // returns model and related state\n    return {\n      ...curriedState,\n      ...formOutput\n    };\n  };\n\n  /**\n   * Returns model state and stores related state in curried variable\n   * @param {Object.} modelState - model state { [formKey]: any }\n   * @param {Object.} action\n   */\n  function wrappedReducer(modelState, action) {\n    // calls reducer with related and model state\n    const output = reducer(\n      // checks curriedState because second call of @@redux/INIT calls createReducer for the second time\n      modelState && curriedState && { ...curriedState, [formKey]: modelState },\n      action\n    );\n    // stores related state for later return statement of the main reducer\n    curriedState = output;\n\n    // returns model data (for modelReducer)\n    return output[formKey];\n  }\n};\n\nexport default createReducer;\n```\n\n. Thank you for your quick response! \nI was stupid because I didn't noticed that I can so easily to react on form's change. Sry about that.\nBest regards,\nMatt. ",
    "Woile": "Found a solution, setting parser solved my issue.\n```\nfunction toUndefiend(value) {\n  return !value ? undefined : value;\n}\n\n------------\n1\n\n```. ",
    "GrandathePanda": "I can confirm I am still seeing this while using a built in Control.text component. Ok whatever it is is only happening on the linux installation of my project. I tried this on my mac and it runs fine. . ",
    "akkie": "@davidkpiano This can be closed because https://github.com/davidkpiano/react-redux-form/pull/908 was merged! Could you please release a version with this fix?. ",
    "batusai513": "@davidkpiano thanks for your fast response, given that this is a react-native app, i cannot make a codepen or codesandbox, instead i made a basic create-react-native app here react-redux-form-example, you just need to install it and run it with yarn start, there is an error with react-redux form you can reference from here https://github.com/davidkpiano/react-redux-form/issues/792 , let me know if this has worked for you!.\nThanks again.. @davidkpiano any updates on this one?. ",
    "DaveVanRijn": "Thanks, this is exactly what I was looking for.. ",
    "Gidgidonihah": "Wow. I feel real stupid right now. Well, thanks for at least pointing out my issue.. ",
    "bhoomit": "Yes. It does. \nIn my fork, I added prepare script in my private fork and also upgraded my npm to 5.3.0. Now it's working fine. . Should I send a PR? So other don't face the same issue?. ",
    "varzock": "I'm having the same problem. ",
    "grigorigoldman": "https://codepen.io/anon/pen/WEyBdY\nI've noticed that if I remove this line this.props.dispatch(actions.submitFields('user', req)) it works. So, clearly I'm not handling form submits correctly.. I think I got it. My mistake, instead of doing this:\njavascript\nconst req = fetch(url).then(handleResponse);\ndispatch(actions.submitFields('user', req));\nI needed to do:\njavascript\nconst req = fetch(url);\nreq.then(handleResponse);\ndispatch(actions.submitFields('user', req));\n. @davidkpiano Actually, I spoke too soon. The above does work for the .then function but adding .catch function, I'm still getting the same behaviour. See https://codepen.io/anon/pen/WEyBdY.. ",
    "sejsworld": "Sorry for the long delay, Due to my issues I switched to redux-form but it was probably a import or reducer configuration error. Thanks. ",
    "spartDev": "@davidkpiano I don't understand how validation work. It's weird because if you set as initial state the dynamic model id with an empty object, it work !\nhttps://codepen.io/anon/pen/EvGjed. Hi @sakarit \nYou can check if the field is valid or not and had a custom className on the input\n({ fieldValue }) => !fieldValue.valid && fieldValue.validated. You can create a custom component for you input. ",
    "boaticus": "Yep, I'm seeing this issue as well. \nI've resorted to adding an onClick event handler to my button to manually fire my submit handler. Not ideal, and what's worse, is it bypasses all the goodness of the onSubmitFailed paradigm. But, for now, it gets the job done. \nI'd love to see a fix for this, though. \nYour workaround @spartDev doesn't help me in my scenario because I'd first need to know every possible userid to add to my initialState. Well, if I knew that, I wouldn't be using a dynamic model, now would I? :). ",
    "OriAmir": "@davidkpiano @spartDev @boaticus \n There is some way to resolve this  issue? i'm stuck with this.\nThanks! . @davidkpiano  Thanks for your quick reply .\nNot exist quick fix for this bug ? I don't find another way to work with dynamic forms until now. . ",
    "abustamam": "Not OP, but I am making an HoC so that I can easily make  controlled MUI text fields (the library that uses Materialize did not suit my needs), and would like to be able to do something like this:\njs\nconst ControlledMuiTextField = ({ model, label, ...other }) => (\n  <Control\n    mapProps={({ fieldValue: { valid, touched, errors } }) => ({\n      showError: !!(touched && !valid),\n      errors,\n    })}\n    {...{\n      model,\n      label,\n      ...other,\n    }}\n    component={MuiTextField}\n  />\n)\nThe docs say it should be possible, so am just wondering why it isn't. \nAs OP stated, I only want to pass those extra props down, but still maintain the onChange etc events. \nTo clarify, this does work:\njs\nconst ControlledMuiTextField = ({ model, label, ...other }) => (\n  <Control\n    mapProps={{\n      showError: ({ fieldValue: { touched, valid }}) => !!(touched && !valid),\n      errors: ({ fieldValue: { errors }}) => errors,\n    }}\n    {...{\n      model,\n      label,\n      ...other,\n    }}\n    component={MuiTextField}\n  />\n)\nbut I think it'd be better if I could just have a single function that acts as an entire \"selector\" of sorts. \nThanks! . ",
    "gogoku": "https://codepen.io/gokugokul/pen/vJwQOr\nHow Do I use immutable with this pen , because i use immutable with my actual code and thats where the problem occurs. Thanks for the response @davidkpiano  ill get back to u with a working reproduced issue . ",
    "Chris-Kim": "Can we reopen this issue? I am having the same problem of viewValue not getting updated. This causes the formatter and the parser getting an old value as their arguments.. Hi, It was difficult to replicate the issue but I finally found what was causing this !!\nhttps://codepen.io/Chris-Kim/pen/JpYPLB\nThis is a working example and I have added comments for the part that's not working\nBasically if I try to group forms into one and have it combined with other reducers it behaves weird.\n```\nconst store = createStore(combineReducers({\n   abcd: combineForms({\n     user: initialUserState,\n   })\n}), applyMiddleware(thunk));\nstore.dispatch(actions.change('user',{firstName:'chris kim',lastName:'Test'}))\n```\nThe code above actually kind of updates the state but not completely maybe? \nSpecifying the full path for the model seems to work properly.\n```\nconst store = createStore(combineReducers({\n   abcd: combineForms({\n     user: initialUserState,\n   }, 'abcd')\n}), applyMiddleware(thunk));\nstore.dispatch(actions.change('abcd.user',{firstName:'chris kim',lastName:'Test'}))\n```\nThis really confused me because the former code kind of worked so I assumed I had setup everything correct.\n. ",
    "firedeepan": "I have members.list and members.newmember in my redux store. I have mapped members state to my component's props. Now I want to bind my member.newmember prop to the form's model. \n```\nimport * as React from 'react';\nimport { Link, RouteComponentProps } from 'react-router-dom';\nimport { connect } from 'react-redux';\nimport { ApplicationState } from '../store';\nimport * as MembersState from '../store/Members';\nimport * as ReactDOM from 'react-dom';\nimport { Member } from \"../store/Members\";\nimport { Control, Form } from 'react-redux-form';\n// At runtime, Redux will merge together...\ntype MemberFormProps =\n    MembersState.MembersState        // ... state we've requested from the Redux store\n    & typeof MembersState.actionCreators      // ... plus action creators we've requested\n    & RouteComponentProps<{}>; // ... plus incoming routing parameters\nclass MemberForm extends React.Component {\nprivate nameInput: HTMLInputElement | null;\nprivate ageInput: HTMLInputElement | null;\n\ncomponentWillMount() {\n    // This method runs when the component is first added to the page\n    this.props.getMembers();\n}\n\npublic render() {\n    return <div>\n        <h1>Members</h1>\n        {this.renderForecastsTable()}\n        <hr/>\n        {this.renderForm()}\n    </div>;\n}\n\nprivate renderForecastsTable() {\n    return <table className='table'>\n        <thead>\n            <tr>\n                <th>Id</th>\n                <th>Name</th>\n                <th>Age</th>\n            </tr>\n        </thead>\n        <tbody>\n            {this.props.members.list.map(member =>\n                <tr key={member.id}>\n                    <td>{member.id}</td>\n                    <td>{member.name}</td>\n                    <td>{member.age}</td>\n                </tr>\n            )}\n        </tbody>\n    </table>;\n}\n\nprivate handleSave(){\n    if(this.nameInput != null && this.ageInput != null){\n        let member: Member = { name: this.nameInput.value, age: parseInt(this.ageInput.value) }; \n        this.props.saveMember(member);\n        this.nameInput.value = \"\";\n        this.ageInput.value = \"\";\n    }\n\n}\n\nhandleSubmit(values: any) { \n    console.log('submit', values);\n }\n\nprivate renderForm() {\n\n\n    return  <div>\n                <Form model=\"members.newmember\" onSubmit={(val) => this.handleSubmit(val)}>\n                    <label>Your name?</label>\n                    <Control.text model=\".name\" />\n                    <button>Submit!</button>\n                </Form>\n            </div>;\n}\n\n}\nexport default connect(\n    (state: ApplicationState) => state.members, // Selects which state properties are merged into the component's props\n    MembersState.actionCreators                 // Selects which action creators are merged into the component's props\n)(MemberForm) as typeof MemberForm;\n```\nWhen I run this I get: \nUnable to create Form component. Could not find form for \"members.newmember\" in the store.. This is the main configuration file, I think it will be too much code to include all the files. I can upload the full project and share the link if you prefer.\n```\nimport * as WeatherForecasts from './WeatherForecasts';\nimport * as Counter from './Counter';\nimport * as Members from './Members';\n// The top-level state object\nexport interface ApplicationState {\n    counter: Counter.CounterState;\n    weatherForecasts: WeatherForecasts.WeatherForecastsState;\n    members: Members.MembersState;\n}\n// Whenever an action is dispatched, Redux will update each top-level application state property using\n// the reducer with the matching name. It's important that the names match exactly, and that the reducer\n// acts on the corresponding ApplicationState property type.\nexport const reducers = {\n    counter: Counter.reducer,\n    weatherForecasts: WeatherForecasts.reducer,\n    members: Members.reducer\n};\n// This type can be used as a hint on action creators so that its 'dispatch' and 'getState' params are\n// correctly typed to match your store.\nexport interface AppThunkAction {\n    (dispatch: (action: TAction) => void, getState: () => ApplicationState): void;\n}\n```. May I know how to trigger the validation pragmatically for all the fields ? . I found the real issue when trying to create the CodePen example. The issue is, the form is not validated on submit after changing the model with an action. The issue is already raised here: \nhttps://github.com/davidkpiano/react-redux-form/issues/31\nBut, I am trying to do the same thing using LocalForm. But none of the solutions mentioned in #31 worked for me. I tried adding validateOn=\"change\" validators={{'name': required}} in the local form level. but it didn't work. \n. ",
    "dnlsandiego": "I'm experiencing the same issue too. Does form level validators don't work with LocalForm?. ",
    "zhangwei900808": "I want to used action to submit my form not used onSubmit event,how can I to do it. ",
    "netbull": "@davidkpiano thanks a lot! \ud83c\udf7a \nthe first case works well, but the pristine it's not really like isDirty because if you make a change to an input the pristine becomes true and if you undo the change in the input value the pristine doesn't changes back to false which I think should be the behaviour of the dirty state, but I can live with that for now.. ",
    "lilles88": "I'd be a great help, thanks! My current solution is that I have custom components for input fields that can have server side validation, and I dispatch an actions.resetValidity() for the model in the component in the changeAction property. Do you think there is another way around, or I should go with this so far?. Hi @davidkpiano , I know it's been a while since this has been resolved, but there is something I have to add. I use Webstorm IDE for development, and If I try to use this isValid utility function like in the documentation: import {isValid} from 'react-redux-form', Webstorm says 'cannot resolve symbol isValid'. However, it seems to work in development. But it turns out it fails to work in production, an error raises on the console: index.js:125 Uncaught TypeError: n.i(...) is not a function. Do you have any idea what can cause this?\nThe scripts used for starting npm in dev mode and building are the following:\n\"start\": \"cross-env NODE_PATH=./src npm-run-all -p watch-css start-js\",\n\"build\": \"npm run build-css && react-scripts build\",. @greghawk Yes, I looked into react-redux-form.d.ts and I can't find the isValid string there. So I assume it's not exported, but I could find the method itself indeed in the source code elsewhere.. I'm using actions.submitFields(), as per the documentation:\n\nactions.submitFields(model, promise)\n[...]\nIf the promise fails, the action will:\n\nset .submitFailed property of form for model to true\nEach key in the response, which represents a sub-model (e.g., \"name\" for users.name) will have its .errors set to its value. (See example)\n\n\nSo when server-side validation error occurs, the Promise will fail, and the returned messages will be shown for the appropriate <Errors> with the given submodel. This worked great so far, but now my model is a track() expression. So I'd love to see an exampe or some hints how <Errors> works with track() model and action.submitFields(). ",
    "niawdeleon": "Current workaround is to just do a silent change via actions.change(model, val, {silent: true} instead of a load upon asynchronously retrieving the values from the DB. Seems to work but I'm not sure if this is the intended usage.. Sorry about that. I do see the rrf/reset dispatch in my codebase upon unmount, so I've not accurately reproduced the issue. Let me revise the codepen.. @davidkpiano I've revised the codepen to reproduce the issue and have verified that rrf/reset does get called.\n\nAs you can see in the log, rrf/change load:true, silent:true is called right after the reset, but this load is not triggered by the application code.\n. Hi @mitchelldemler that's not my workaround. To clarify, my workaround is to not use actions.load (instead load the values using a silent actions.change) but I am still using actions.reset. I'm not sure firing a change with empty values to reset is the right approach as that might not reset the touched, validation and other important flags. . @davidkpiano I'm trying to read the codebase but I'm having a hard time finding the mechanism by which each control in the form is validated when the entire form's model is validated. What calls the initial sequence of rrf/setErrors on each form control? And then after calling actions.change(model) on the form's model, another set of rrf/setErrors is triggered. Where does this happen?\nThanks. ",
    "mitchelldemler": "I have same problem. I will also use your workaround of just firing a change with empty values to reset.. Haha, I realised that soon after :). Any ideas for this @davidkpiano ? See the above CodeSandbox from @christensena which illustrates the issue. This is quite critical for me as validation is pretty much broken for collections.. Same behaviour shown above when the items are removed with actions.change(model, (items) => items.filter(...)). I also tried actions.filter(model, (item) => item.id !== id) and got the exact same behaviour as above.\nThe rrf/resetValidity action is dispatched every time, and incorrectly sets the empty row to valid, when it should be invalid.\n@davidkpiano Removing this block of code resolves the above: https://github.com/davidkpiano/react-redux-form/blob/master/src/components/control-component-factory.js#L182-L187\nI don't want to make a PR for this as I have no idea what it should be doing, I'd rather leave that to someones more experienced judgement.. I've just realised that my specific issue is probably more related to #729. Not sure if they are the same. I will try your workaround of normalizing the array.. Thanks for the response! I think I was just missing the actions.load in my setup, I will try that out.. @criess I am using 1.16.8 until the next version is released. I don't know how anyone can even use 1.16.9, it completely breaks all inputs.... This is fixed in #1157 \nJust waiting on a new release.. ",
    "daronjay": "Possibly related, if I hit reset twice in a row after an actions.load, the first time it resets to previously loaded values,  the second time I find it clears the form totally as I have no initial values set in store. I would assume reset should always just reset to last loaded or initialised values?. +1 on this, I want to be able to access the field value and all the meta info inside my controlled component in order to do various validation related highlighting on items that don't directly consume the model, like labels etc. Is there any way it could pass a field prop to the controlled component?This was one of the (few) things redux-form did that aided customisation.\nCurrently I'm doing this to get access to them:\n props.fieldValue }}\n          component={TextInput}\n      />\nBut I have to add this mapProps to every controlled component I use, and it feels like I have to know a wee bit too much about the inner workings of rrf at the wrong level of abstraction to get at them. I reckon those puppies should just be exposed to all controlled components by default.. I'm still having this issue, exactly the same symptoms as @BrandonBoone, as far as I can tell I have immutable installed as a dependency. Heres the relevant chunk of package.json\n  \"dependencies\": {\n    \"@types/graphql\": \"^0.11.4\",\n    \"@types/lodash\": \"^4.14.74\",\n    \"@types/react\": \"^15.6.1\",\n    \"@types/react-dom\": \"^15.5.4\",\n    \"extensible-runtime\": \"^4.1.0\",\n    \"immutable\": \"^4.0.0-rc.2\",\n    \"net\": \"^1.0.2\",\n    \"object-hash\": \"^1.1.8\",\n    \"react-animations\": \"^0.1.0\",\n    \"react-event-observer\": \"^0.4.11\",\n    \"react-modal\": \"^2.3.2\",\n    \"react-notifications\": \"^1.4.3\",\n    \"react-redux-form\": \"^1.16.0\",\n    \"react-router-hash-link\": \"^1.1.1\",\n    \"react-select\": \"^1.0.0-rc.5\",\n    \"react-spinkit\": \"^3.0.0\",\n    \"redux-form\": \"^6.8.0\",\n    \"sockjs-client\": \"^1.1.4\",\n    \"stompjs\": \"^2.3.3\",\n    \"validator\": \"^9.0.0\",\n    \"validatorjs\": \"^3.13.3\",\n    \"xml2js\": \"^0.4.17\"\n  },\n. Yeah, my message isn't exactly the same now that I look more closely:\nERROR in ./node_modules/react-redux-form/src/immutable.js\nModule parse failed: Unexpected token (74:2)\nYou may need an appropriate loader to handle this file type.\n| \n| const immutableStrategy = {\n|   ...baseStrategy,\n|   getForm: immutableGetForm,\n|   getFieldFromState: immutableGetFieldFromState,\n @ ./node_modules/react-redux-form/immutable.js 2:4-30\n @ ./app/store.js\n @ ./app/index.jsx\n @ multi ./app/index.jsx\nChild html-webpack-plugin for \"index.html\":\n. Yep, and webpack. Ran npm update as well. I note the message doesn't actually mention find-key, unlike @BrandonBoones version, not sure if that is significant or not.. I think the rrf/blur call is re-rendering the component which is maybe why focus is being lost, not sure how to get around this.  When I use two normal controls, I see a rrf/blur call, a re-render, then an rrf/focus call.  Is that focus call after render being set by an action somewhere? \nUsing my connected components that rrf/focus call never gets sent until I hit the new input again. \nWhat am I missing?. I seem to have got it going using this syntax:\n\nimport allOtherAppReducers from './allTheOtherAppReducers.js'\nimport myCustomFormDataReducer from './myCustomFormDataReducer.js'\nconst store = createStore(\n    combineReducers({\n      ...allOtherAppReducers,\n      apollo: apolloClient.reducer(),\n      ...createForms({\n        formData: myCustomFormDataReducer\n      })\n    }),\n    {},\n    composeEnhancers(applyMiddleware(...middlewares))\n  );\n\nIt's not clear to me from the documentation that you can do the same sort of injection of a custom reducer in createForms as you can in combineForms. I wonder if the documentation needs an update, (assuming I actually have it right). ",
    "thosil": "Hi I'm using latest version, the bug is still here.\nusing redux dev tools, I can send an action {type: \"rrf/reset\", model: \"myModel\"}\ndirectly after, an action {type: \"rrf/change\" ....} is launched, and the fields get filled up with previous values.\nCan't find out who's launching this action, but not my code for sure.\n@niawdeleon  codepen is showing the problem (see line 42 in the js and the logs). ",
    "daniil4": "I want to store validation logic inside of Control. By the way, errorMessages is also stored inside of my Controls. By passing one prop to component I can easily add require validator, errorMessage and change the view of the component. Otherwise, this code will be in 3 different places. If require of the component can be changed by toggling some checkbox on a form, I'll have to change validators for the form with some custom logic, then add this logic to component's render method, instead of encapsulating the whole logic inside one component, making it more reusable for different forms. It seems like a better design choice.\nIs it really that hard to implement?. I find what's wrong in my case while writing CodePen. I get the object from the back-end, that is a composition of 4 other objects. So all the fields on my form belong to one of this 4 objects. It's some kind of nested fields. I realize that setErrors action is triggered only on fields that placed directly and not on nested ones. And that nested setErrors works before the commit, which I mentioned in the first post. Maybe you can add some option in actions.change that turned on old behavior of nested validation?. You can see that setErrors action triggered only on .field3 in the console on my codePen. But .object.field1 and .object.field2 stayed unvalidated. When you click the submit button, all fields will become touched and 2 of them will show error messages because of that. Also, we'll get submit failed.\nBut if you change field1 and field2 manually, validation will be triggered, errors are gone and the form can be successfully submitted.. ",
    "nhooey": "I just want to set the initial value when the page loads, because I'm specifically using redux-query-sync to keep the URL params in sync with some form fields, and it doesn't automatically set the text in the form fields.. Setting the defaultValue property on a Control.text item does nothing.\nAnd dispatching actions.load(model, value), the values in the correct part of the model actually change, but the form fields don't display that text inside them.\nTo confirm that the correct part of the model is being changed, I type some text into the form fields, and it changes the model state to that text, replacing the text that was set by the dispatched action.. The defaultValue property of an <input type=\"text\"> tag in a regular HTML form doesn't even set the text that appears inside the text box, so it can't be used for this purpose.\nHowever it works in the Codepen example, just not mine. I'm trying to figure out why.. To summarize, the resolution for this issue is to use defaultValue instead of value, because value will permanently set the value of the field, not allowing changes.. ",
    "oftenfrequent": "Any idea on this? I can start digging in the source code but would probably need some direction to get going.. ",
    "bevanharcourts": "We've encountered this issue too when removing from a nested collection, is there any progress or work arounds for this issue? Thanks. ",
    "christensena": "I've seen this with just first level (non-nested) collections. \nTo reproduce:\n\nAdd two rows (actions.push()) and touch + make them invalid (e.g. a required field) such that the validation error shows on both.\nMake the second row valid, (e.g. add a value to the required field). Validation error disappears.\nDelete the first row (actions.remove() the still invalid row)\nNotice that the remaining, valid, row now shows the validation error from the deleted row. \n\nThe validation errors seems to be connected by index and showing against the wrong row once the row is deleted.. This sandbox produces similar issues.\n\nThe gif below (from the exact sandbox above) shows how the validation error disappears when an earlier row is deleted. There are other issues with validation errors \"sticking\" as well but I expect they're all connected.\n. ",
    "keattang": "So I had a stab at this and the main issue that I ran into was that this would be a semi breaking change as the default behaviour is to pass all the props directly to the child. So if the child is an <input /> component we get a react warning saying that fieldValue is not a recognised prop for <input />.\nThis is fairly fixable when the component prop of Control is a string e.g. component=\"input\" as we can just check if its a string and then exclude fieldValue from the props passed through. \nFor anyone using a component that looks something like this though, they will get the warning:\nconst CustomInput = (props) => (\n    <div><input {...props} /></div>\n);\nAny thoughts @davidkpiano on how we may avoid causing everyone getting this warning and having to change their code to exclude fieldValue?\nWe could potentially have a flag prop on Control like passFieldValue that controls whether it gets passed through or not but it would be nice to not have to.. It would be nice not have to have the prop but if there's no better way i'm happy to implement it like that. Cool. I've just linked the PR. Let me know what you think.. Thanks!. ",
    "DrewEaster": "Hi David.\nI was thinking something maybe along the lines of:\n\nThe idea being that, if you specify the model at the form - rather than field - level, it would be possible for it to recurse (based on the flag) through the field level errors as well as the form level errors. Something like that, anyway.. ",
    "mdurban": "I'm seeing the same issue with the newest version.. ",
    "w3nda": "It's inside the find-keys.js file at/lib/utils.\nrequire('immutable')\nafter some research found out no immutable inside /lib/utils\nit's placed one folder back at /lib/immutable\nso I tried changing it to require('../immutable')\nthat didn't work as well.. ",
    "designbystephen": "@i4got10 Version 1.14.2 has been working for our project.  @marcandrews deleting node_modules and installing again gave us the same immutable undefined issue, we had to scale back to version 1.14.2 in order to get things working again.. ",
    "nadnevi": "Our build script deletes the node_modules directory for every build and reinstalls all of them.  Immutable isn't getting installed.  It doesn't exist in the node_modules directory or in the output from node list:\n\u251c\u2500\u252c react-redux-form@1.14.4\n\u2502 \u251c\u2500\u2500 icepick@1.3.0\n\u2502 \u251c\u2500\u2500 lodash.get@4.4.2\n\u2502 \u251c\u2500\u2500 lodash.topath@4.5.2\n\u2502 \u2514\u2500\u2500 shallow-compare@1.2.1\nWe were able to get versions 1.14.1 and 1.14.2 to work.  . ",
    "BrandonBoone": "I have immutable installed as a dependency already and still getting this issue. Reverting to 1.14.2 resolves it for me.\nGetting this from my webpack output.\nERROR in ./node_modules/react-redux-form/src/immutable.js\nModule parse failed: C:\\TFSBuildAgent\\_work\\3\\s\\UI\\Mobile\\node_modules\\react-redux-form\\src\\immutable.js Unexpected token (73:2)\nYou may need an appropriate loader to handle this file type.\n| \n| const immutableStrategy = {\n|   ...baseStrategy,\n|   getForm: immutableGetForm,\n|   getFieldFromState: immutableGetFieldFromState,\n@ ./node_modules/react-redux-form/lib/utils/find-key.js 8:17-37\n@ ./node_modules/react-redux-form/lib/utils/track.js\n@ ./node_modules/react-redux-form/lib/index.js\nOdd thing is that these files (immutable.js, find-key.js, track.js, & index.js) appear to be identical when comparing 1.14.2 & 1.14.4. Looking at the changes between 1.14.2 & 1.14.4 doesn't reveal anything obvious (to me anyway).\nI'm on node v6.10.3 & npm v3.10.10. I'll try updating npm & node next.\n. 1.14.5 is still broken for me. @TLadd, I also have my module resolver set to\nresolve: {\n  modules: [\n    'src',\n    'node_modules'\n  ],\n}\nYou seemed to indicate that this could also be a problem.  Do you have any more info on what you meant? Just want to make sure I'm not doing anything dumb on my side. Thanks!. ",
    "Sonith": "I see. Thank you for your quick response. I'll post an issue on the react page.\n. I figured that was the case, but got confused when I saw \nparser?: (value: any, previous?: any) => any;\nin react-redux-form.d.ts\nThank you for your quick response.. ",
    "aminul-technext": "+1\nEven the form gets reset the fields needs to be focused twice.\nOn 1st cycle nothing can be written in the field, on 2nd cycle it works.\nValidation works on as usual, even on the 1st cycle.\nMy current work around is this:\ndispatch(actions.reset(model));\ndispatch(actions.setInitial(model));. ",
    "valoricDe": "Feedback for this merge:\n1. The Typescript-Types for formatter are missing.\n2. When the formatter adds charackters to the initial value the cursor jumps to the end of the input.\nThe second issue can be addressed by the user when he adds a onChange handler like:\n({target} : ChangeEvent<any>) => {\n        const {selectionStart} = target;\n        setTimeout(() => {\n          target.setSelectionRange(selectionStart + additionalAddedCharackters, selectionStart + additionalAddedCharackters);\n        }, 0);\n      };. @davidkpiano pr is created (https://github.com/davidkpiano/react-redux-form/pull/1087) The solution to the second issue is not perfect. It would be perfect to set the selectionRange after the input has been rendered. But I don't know where to hook into.. Actually forms are not allowed in forms: https://wiki.selfhtml.org/wiki/Referenz:HTML/form\nSo I think Form should also be not.. Actually the docu says you can nest: https://davidkpiano.github.io/react-redux-form/docs/api/formReducer.html -> Forms can be infinitely nested. Formatter is a new funtionality which has been added in v1.16. I'm currently fixing the TypeScript typings for it. If you would take over the documentation we should be done.. When I submit a LocalForm my fieldValue's contain a falsy submitFailed property. But only if the browser doesn't prevent the submission beforehand. In my case Firefox did prevent the submission when my form contained input's which contain the attribute required. Firefox did show me a popup underneath the input then. So I had to do something like this:\n```\nconst controlProps : Partial> = {};\n  if(partialInputProps.required) {\n    delete partialInputProps.required;\n    controlProps.validators = {\n      valueMissing: (val) => val && val.length\n    }\n  }\n.${name}}\n        {...controlProps}\n        {...partialInputProps}\n      />\n. What you think would be the proper way to prevent that the Browser is doing HTML5 Validations?. @rikkit Indeed there is a documentation which indicates to add noValidate to the Form component. But if I do so the form will happily call the onSubmit function although the input is required. So actually I want to have validation. But not browser validation. Maybe we should add `noBrowserValidate` as prop to the Form component? @im1dermike sry for kind of hijacking this thread. If conversation goes on I will create another issue.. @im1dermike Can't you listen for the submit action and set a redux state property to something alas `hasBeenSubmittedAtLeastOnce`. I changed my get-value.js file to:\nfunction getEventValue(event) {\n  ...\nif (target.type === 'checkbox') {\n    return target.checked;\n  }\n...\n}\n...\nfunction getCheckboxValue(value, props) {\n  var controlProps = props.controlProps;\nif ((0, _isMulti2.default)(props.model)) {\n    return controlProps.value;\n  }\ndebugger;\n  return getValue(value)\n}\nSo at least I get correct truthy values. But it is still triggering somewhere another change where it sets \"on\" as value. (props.controProps.modelValue by the way is always `undefined`). Could it be tha in control-component-factory.js -> createEventHandler on handleUpdate\nif (this.props.isToggle) {\n          return compose(\n            dispatchBatchActions,\n            persistEventWithCallback(controlEventHandler || identity)\n          )(event);\n        }\n``\nis doing something unexpected?. When I log[model].concat(args)` in trackable (in track.js) I get following on one click of the checkbox\n\n. It's not just checkboxes updating necessary often. When I create a textfield and give it a parser and formatter my parser gets two times a string value and the last time the parsed value :(\nIn control-component-factory -> componentWillReceiveProps it does:\n```\n      value: function componentWillReceiveProps(_ref) {\n        var modelValue = _ref.modelValue;\n    if (modelValue !== this.props.modelValue) {\n      this.setViewValue(modelValue);\n    }\n  }\n\n```\nso viewValue actually receives the parsed value right?\nBut in setViewValue it agains parses the modelValue.\nvalue: function setViewValue(viewValue) {\n        if (!this.props.isToggle) {\n          if (this.props.formatter) {\n            var parsedValue = this.parse(viewValue);\n            this.setState({ viewValue: this.format(parsedValue) });\n          } else {\n            this.setState({ viewValue: this.parse(viewValue) });\n          }\n        }\n      }. interface _FieldState has a viewValue. But when I output fieldValue of my select field I have a value property and no viewValue property. Is this intended? Shall I add a value field to FieldState?. I do not agree that this is not a valid bug report. I do not necessarily know that valueMissing may not be given. And even when valueMissing is not given it is included in the fieldValue.errors object and does not respect my parser. I as a developer expect not the input value to be validated but the parser value.. ",
    "SuperOleg39": "@davidkpiano Hello! Control propTypes allow function or string:\nmodel: PropTypes.oneOfType([\n    PropTypes.func,\n    PropTypes.string,\n  ]).isRequired\nAnd when i pass array of strings to Control component, catch error - \"Failed prop type: Invalid prop model supplied to Control.\"\n. And example code actions.change('user[firstName.test]', 'value') - works strange:\nif prev state is user: { 'firstName.test': '' }, next state will be  user: { firstName: { test: 'value' }, 'firstName.test': '' }, \nactions.change(['user', 'firstName.test'], 'value') works as expected, but in library typings all model arguments are string.. Done!. I did something wrong?. ",
    "sidharthdigiworks": "is there any way to use . in names without using array ?\nI'm using dynamic fields and values with initialValues from state and using names like \"User.Name\" and the forms are not working as intended.\nthe form value is saved as follows and isn't being picked up from initialValues\n{\n  \"User\": {\n     \"Name\": \"Test\"\n  }\n}\n. ",
    "bugzpodder": "@davidkpiano would love a new release with this change.  npm shrinkwrap breaks with any peerDependency warnings.  Thanks!. Yep i'll check it out.. \"but clearly, you should not have an empty key in state\"\nI am not sure how thats clear.\nIf I am trying to specify an empty key as the form name of an rrf form, then its totally fine if rrf throws an error because of doing so might cause some unexpected/undesired behavior within rrf.\nOn the other hand rrf should have no say in governing how I store unrelated data in other parts of my app.  Least of all should it enter an infinite loop and/or crashing my entire SPA.. Are we talking about form key (name) or form field key (name)?\nRegardless I don't think empt key/name is ever supported in the path.\nIn https://github.com/davidkpiano/react-redux-form/pull/1115/files#diff-018b2e0cb7ebc367fc0aada6e02079dcL12 joinPath filters out all empty path keys.\nIn https://github.com/davidkpiano/react-redux-form/blob/master/src/utils/get.js#L13 we also don't like empty key in the very end of path.. As marcandrews mentioned Object.keys() convert undefined into the string 'undefined' (similarly for null).  joinPaths will properly accept this as a segment.  s.get() utilizes lodash.get and from some simple testing it seem to work fine with the string 'undefined'.. The other possibility is that at line 20 we just check if key === \"\" and return false, but that potentially changes the getFormStateKey logic (even though all test cases still pass).  I would mildly prefer that over this safer change since other functions like joinPaths doesn't work with empty path segments.. ",
    "pjivers": "+1 Having the same problem.. ",
    "lijuenc": "Has this been released? It's still an issue as reported in #1013.. I ran into this issue but only when using the debounce prop on the Control components.\nhttps://codepen.io/anon/pen/bYoWwN?editors=0010\nIn this example, both First name and Last name fields have the asyncValidators, asyncValidateOn=\"change\" and debounce={500} props.\nThe difference is that the First name field has a validators prop while the Last name field does not.\nObserved Behaviour\nWhen pasting data into the First name field (or just type e.g. \"chris\" really quickly before hitting the debounce time limit), the asyncValidator is not triggered. Typing after the first debounce then triggers the asyncValidator.\nWhen pasting data or just typing really quickly into the Last name field, the asyncValidator is triggered correctly after the debounce period.\n. It's still an issue is reproducible in my codepen (which as far as I can see, is using 1.16.1).. ",
    "vectorjohn": "I added another case in the pen, the second one with debounce but where the form's initial state does not match one of the available options in the select. It shows how it's somehow related to what React is doing, when it tries to update the options to set the selected attribute based on the select's props, the first time you change the select, nothing matches so React doesn't do anything. But after that, it is somehow resetting the control's selected option before the debounced function goes off.. ",
    "peterdivvito": "The goal was to not have react-dom required/imported when using the native versions. Therefore I extracted the factory into another module so that could be used via native.js but then kept the original component-control module for backwards compatibility.. findDOMNode is now passed in the strategy to the component control factory. My bad. I'll fix this this morning. ",
    "NewOldMax": "Yes, it will remove value and it's ok, but you can't enter new value after mounting component again. ",
    "Filipvdb321": "Hi David,\nI put an example here:\nhttps://codepen.io/Filipvdb321/pen/rYebMB\nYou can see at the end of the JS I dispatch a change action to load a user object. If I do this I can press submit and no validation messages appear. I can see in the logs that the form is submitted.\nIf you remove the dispatch you can see that the validation works correctly.. ",
    "jhserodio": "create a CONTRIBUTING guide for your project, i try searched your gitpage, but didn't find this project.. ",
    "aguo99": "It will be appreciated if anyone can provide or point out the following examples:\n1. initialize the form model data from async server response.\n2. populate list data from nested arrays under model.\nThanks.\n. ",
    "partisanyc": "I also struggled with this. The documentation does state that you can use a custom reducer, but it doesn't tell you why you would or what the effect of doing that would be. I'm new to react, redux, and forms so I just chalked it up to lack of experience, but I am glad to hear I am not the only one who has faced the issue. . ",
    "devorbitus": "renaming this because opening the codepen and typing chris will cause the minimum length is 4 chars error to show up after the async validator completes because that was the last sync validator failure.. Yeah, I have updated the codepen to use 1.16.1 and the issue still exists.. I am going to try and pull down the library locally and see if I can determine the cause but this is not a duplicate of #993 hopefully a PR will be coming.. ",
    "rikkit": "@valorize that's referring to form models only - not the <Form> component. It's saying that you can treat any nested object within a form model as a form model. I agree it's confusing wording.. I think the thing to realise is that the purpose of the form reducer is to store the state of your form - and that's it. That's not the same purpose as your user profile reducer, which is to store a representation of your user. Although it might look like a duplication of data, this distinction is super useful. Along with your initial form states, theres a $form key that react-redux-form uses to track validation and touched states amongst other things, and the separation means you can replay mutation actions on your form state without affecting anything else.\nWith that in mind, I think what you both want is to initialise a form with data asynchronously, rather than reusing existing redux state. I solve this problem by dispatching actions.merge(model, <async data>) then actions.setPristine(model) after all my async data has finished loading.\nAnother thing to experiment with would be the \"dynamic\" initialisation of a form state. You don't need to create initial states up front - you could just dispatch actions.setInitial(anyModelPathYouLike, <data>) after your user profile has finished loading.. @Teyras based on my reading of this PR #618 I think Immutable.js is not supported. Maybe something to do with how it represents objects? There's a lot of state tree traversal in RRF, and if the state tree is a different structure than usual JS because of Immutable, I think you'd get the kind of error that you did.. Hi @grks, I'm learning RRF currently so thought I'd jump in and fix your codepen as practice if that's aight.\nhttps://codepen.io/anon/pen/YYeGWr?editors=1111\nPlease excuse the lack of a proper write up, here are some notes on my implementation instead. There are a few comments in the codepen as well\n\nthe \"toggle all/ toggle none\" is not bound to redux state - it's just a checkbox that dispatches an action. It could be a button instead (imo a button makes more sense from a UX perspective since the other checkboxes can be updated independently). It doesn't take a model name because AFAIK there's no built in react-redux-form action that toggles all the values in an array - because to maintain whether it should set all to true or all to false will depend on what the user of the library wants. Hence my usage of actions.map that simply changes all checkboxes to match the checked state of this checkbox. You could similarly implement \"invert checkboxes\" with actions.map(x => !x)\nfor actions.map to work as expected, the local state needs to already have values. If you want to delay initialisation of the state, you could use actions.change in toggle instead - see comment\ncheckbox B and C get bound to local.cb[0] and local.cb[1], because their values should be the first and second values in the array. I think you can use the track() function of RRF - i.e. set the model prop of both to track(local.cb[]) - to make this automatic but I thought it'd be more helpful to start out this way.\n\nLet me know if there's stuff I could explain better\n. Hi @grks \nI notice you've hooked up the onUpdate prop of LocalForm to see the form model as it changes. I haven't checked exactly when this prop is called, but I think you mean to use the onChange prop instead. onChange is triggered whenever the model that's linked to the form component changes. It receives the new form model as an argument. https://codepen.io/anon/pen/wpjLdM?editors=1111  (I haven't changed the rest of the code)\n\nThat said, what is the difference between form.$form.value.cb and cb.$form.value ? Which do you tend to use if you are going to do something with the form values?\n\nI can't answer that, I know that $form objects are used to track the internal state of the form - each object in the structure of a form model has a corresponding $form object to track stuff like validation, whether the field has changed, etc. If you use the library with redux, you can inspect the redux tree to see what I mean - I am not sure how LocalForm implements this feature, but it looks to be different to Form.. Hey just passing by, as a non-react-native user, I think it would be good to not introduce a package only relevant to react-native users into this package. Can't these controls be distributed separately?. Hi, I tried out your codepen and don't see the error in either the codepen or browser consoles.. @valorize there is a section on HTML5 validation in the documentation. http://davidkpiano.github.io/react-redux-form/docs/guides/validation.html\nI can't help you on the other issue - in my usage, either submitted or submitFailed are set on the root $form object of my form model (i.e. if my form is at forms.foo, check forms.foo.$form.submitted). pristine means whether a user has interacted with a form or not. That's different information to whether the form has been submitted (which is indicated with submitted || submitFailed).. If you're using Form, the form state is in your redux store so you can just bind to the value of the field. If you're using LocalForm, you'll need to use the onChange handler to store the form data in a local component where you can access it. It's not clear from your example code which you're using so it's difficult to help more.. ",
    "Cherviakov": "```javascript\nexport const getUserData = () => (dispatch, getState) => {\n  const payload = new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve({\n        name: 'Ivan',\n        email: 'a.b@gmail.com'\n      })\n    }, 3000);\n  });\ndispatch({ type: ACTIONS.GET_USER_DATA, payload });\n};\nThenjavascript\nexport const defaultState = {\n  name: '',\n  email: ''\n};\nconst mainReducer = (state = defaultState, action) => {\n  switch (action.type) {\n    case ${ACTIONS.GET_USER_DATA}_FULFILLED:\n    case ${ACTIONS.SET_USER_DATA}_FULFILLED:\n      return setUserData(state, action.payload);\ncase `${ACTIONS.GET_USER_DATA}_REJECTED`:\ncase `${ACTIONS.SET_USER_DATA}_REJECTED`:\n  console.error(action.payload);\n  return state;\n\ndefault:\n  return state;\n\n}\n};\nfunction setUserData(state, { name, email }) {\n  return {\n    ...state,\n    name,\n    email\n  };\n}\nAnd that is relation with form modeljavascript\nimport { combineReducers } from 'redux';\nimport main from 'redux/modules/main/mainReducer';\nimport { combineForms, createForms } from 'react-redux-form';\nconst rootReducer = combineReducers({\n  main,\n  ...createForms({\n    user: main\n  })\n});\nexport default rootReducer;\n```\nI tried to make whole app state to be used in form too, still the same.. Huh that commit was 12 minutes ago?. Not works in my case, upgraded package to latest.. Alright. ",
    "akki199421": "@davidkpiano has this been released yet?. i switched to the latest release but i am still getting this problem.. ",
    "pdehne": "Can anyone tell if it is possible at all with react-redux-form? If not I will need to switch to something different.. Many thanks for answering! I think the CodePen is almost there now. But actions.push doesn't seem to have an effect, probably because the initial list is not rendered from the react-redux-form managed state:\n{this.props.currentUser.phones.map((phone, index) => (\n...\n))}\nHow would I render the list of phones from the react-redux-form managed state if the form state has been populated using\n```\nthis.props.load('user', currentUser);\n...\nconst mapDispatchToProps = (dispatch) => {\n    return {\n        load: (model, value) => {\n            dispatch(actions.load(model, value));\n        }\n    };\n}\n```\n. Sure! The CodePen: https://codepen.io/patrick/pen/xPYeQK contains the whole example. Here is how the store is created:\n```\nconst initialState = {\n  currentUser: {\n    id: 1,\n    name: 'John Doe',\n    email: 'john@doe.com',\n    phones: [\n      {\n        id: 1,\n        number: '111222333',\n        type: 'private'\n      },\n      {\n        id: 2,\n        number: '444555666',\n        type: 'office'\n      }\n    ]\n  }\n};\nconst createStoreWithMiddleware = applyMiddleware(thunk)(createStore);\nconst store = createStoreWithMiddleware(reducer, initialState);\n``. I added dispatch to actions.push, sadly still no effect:this.props.dispatch(actions.push('user.phones', { id:3, number:'777', type:'mobile'}));`\nMaybe how I load the initial state is the problem:\nthis.props.dispatch(actions.load('user', currentUser));\ncurrentUser comes from the redux state and is mapped to props using connect. I suspect 'user.phones' is not related to that entity.\nUpdated CodePen: https://codepen.io/patrick/pen/xPYeQK. I finally found where the current form state is available in the redux store. After mapping it into the props of the form component things started working:\n```\nconst mapStateToProps = (state) => {\n    return {\n        user: state.user\n    };\n}\n...\n{user.phones.map((phone, index) => (\n    \nNumber: \n\nType: \n\n\n))}\n```\nFor creating new unique ids when adding phone numbers I use this:\n```\nhandleAddNumber(event) { \n    let { dispatch, user } = this.props;\nlet newID = -1;\nuser.phones.forEach(function (phone) {\n  if (newID >= phone.id)\n    newID = phone.id - 1;\n});\n\ndispatch(actions.push('user.phones', { id:newID, number:'', type:''}));\n\n}\n```\nWorking CodePen: https://codepen.io/patrick/pen/xPYeQK\nFeel free to close this issue. Thanks for taking a look!. ",
    "Emobe": "Will do. Wouldn't you just specify the model dynamically from where ever you render your fields and forms?. ",
    "zzhjerry": "Closing this one since I found an issue in the codepen. Sorry, don't bother. I should have used   \ndispatch(actions.submitField('user', dispatch(loginActionAsync())))\n. Actually, there's another typo. After I fix that, the example in codepen doesn't work again. ",
    "amarendhar": "yeah, sorry, i got the solution.\nNow i'm this.formDispatch to update LocalForm whenever it is required.\nThanks.. ",
    "dinfyru": "It not working for me.\nI push errors with this func and Errors do not appear\nthis.props.dispatch(actions.submit(USER_SIGN_IN_FORM_MODEL_NAME, validation.promise))\nvalidation.promise return for example {email: \"Invalid email format\"}. ",
    "so5tmaker": "Hello! I have the same problem with actions.merge.... Hello! \nAs for me, I solved this problem. I used a Redux action generator actions.merge. At first, It didn't work because I tried to invoke it from the child component. But I should have done it in the MainComponent.js file in the componentDidUpdate hook.\nIn the ActionCreators.js I declared: \n```javascript\nimport actions from 'react-redux-form';\n. . .\nexport const setDefaultFormValues = (values) => (dispatch) => {\n    dispatch(setDefaultUser: (values) => actions.merge(\u2018editTask\u2019, values));\n}\n```\nThen in the MainComponent.js I wrote:\n```javascript\n. . .\nimport { setDefaultValues } from '../redux/ActionCreators';\nconst mapDispatchToProps = dispatch => ({\n. . .\nsetDefaultValues: (values) => dispatch(setDefaultValues(values))\n\n});\ncomponentDidUpdate() {\n        let pathname = this.props.location.pathname;\n        let pos = pathname.search(\"/edit/\") + 6;\n        let taskId = pathname.substring(pos, pathname.length);\n        if (taskId) {\n            let tasks = this.props.tasks.tasks.tasks;\n            if (tasks) {\n                let task = tasks.filter(task => task.id === parseInt(taskId, 10))[0];\n                if (task) {\n                    this.props.setDefaultValues(task);\n                }\n            }\n      }\n}\n```. ",
    "brahimmouhamou": "Hi @davidkpiano,\nThanks for the fast reply!!\nI tried controlProps and I see that every property I pass along will be available in my custom component, but thats not what I'm trying to do. \nI'm trying to add/trigger the existing typeMismatch validator from RRF without creating my own typeMismatch validator.\n<Control.text\n  model=\".email\"\n  type=\"email\"\n  component={TextInput}\n  validateOn=\"blur\"\n />\n<Errors\n  className=\"errors\"\n  model=\".email\"\n  show=\"touched\"\n  messages={{\n    typeMismatch: 'Invalid email address',\n  }}\n />\nCan you provide me with an example?\nI read the docs multiple times but can't put my head around it.. Working on a small POC as you proposed.\nhttps://jsfiddle.net/69z2wepo/95683/\nBut how does RRF get the value of the input element of my custom component?\nCan't we get the input element the same way?. ",
    "mrsufgi": "hey @davidkpiano I think the combination of those packages may be useful for many. I managed to get it to work. I'll post a small how-to here soon! Thanks again!. ",
    "christopher-rain": "Thanks for the reply. I will try to reproduce it as minimal example right after the new year holidays. . Hi David,\nI stripped my project from everything, which is not needed, but tried to preserve the components structure and relationships, as probably the problem comes from there. I added: https://github.com/christopher-rain/rrfcollectionsissue\nYou can:\n\nDownload it.\nnpm install\nnpm run build:dev\nIt is not working for me via file://, so I setup http://rrfcollectionsissue.localhost and then opened it via http://rrfcollectionsissue.localhost/index.html\nYou can open the redux console and hit the Continue to Next Step button. You will see the rrf/addIntent action is dispatched, but not and the rrf/setSubmitFailed.\n\nRegards\n. ",
    "MatheoJaouen": "well I did it with LocalForm, seems to work, but I'm not sure it's the best way?\nIf that can help someone (I'm using react native)\n```jsx\nclass ProfileScreen extends React.Component {\n    constructor(props) {\n        super(props);\n    }\nhandleSubmit(user) {\n    let {dispatch} = this.props;\n    dispatch(actions.change('user', user));\n}\n\nattachDispatch(dispatch) {\n    this.formDispatch = dispatch;\n}\n\nrender() {\n    let {user} = this.props;\n    let {dispatch} = this.props;\n    return (\n\n        <LocalForm\n            model=\"user\"\n            component={View}\n            getDispatch={(dispatch) => this.attachDispatch(dispatch)}\n\n            onSubmit={(values) => this.handleSubmit(values)}\n            initialState={user}>\n            <Control.TextInput model=\".firstName\"/>\n            <Control.TextInput model=\".lastName\"/>\n            <Text>\n                {user.firstName}\n            </Text>\n            <Text>\n                {user.lastName}\n            </Text>\n            <Button\n                onPress={() => this.formDispatch(actions.submit('user'))}\n                title=\"submit\"\n            />\n        </LocalForm>\n    );\n}\n\n}\nfunction mapStateToProps(state) {\n    return {user: state.user};\n}\nexport default connect(mapStateToProps)(ProfileScreen);\n```. ",
    "AxoInsanit": "Not really, no\nOn Thu, Jan 4, 2018 at 8:29 PM David Khourshid notifications@github.com\nwrote:\n\nIs there any way you can avoid using Immutable?\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/davidkpiano/react-redux-form/issues/1059#issuecomment-355456862,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ADCSPwzwUPkiymA2GLtgvM7SvKWU8I8Dks5tHYkPgaJpZM4RT2ao\n.\n. is this a known issue? is there a way to make this work without getting rid of immutable?\n\nBTW, thanks for all the great work!. Thanks for the recommendation, sadly in this case we already have a lot of code tied to immutable as well as RRF.\nis this something fixable (should I attempt a PR?, where should I start looking?) or is tied to architectural stuff ?. ",
    "Teyras": "I was able to resolve this by replacing Immutable.js with Immer. I would still like to know if there was any mistake on my side, though.. ",
    "grks": "Hi David!\nI know this example is not going to work as it's not updating the state properly and that it's something I don't understand yet about react-redux-form. But the example should show what part I have failed to grasp with react-redux-form and how to update state for a LocalForm: https://codepen.io/anon/pen/YYYeRP\nIdea is that clicking the first checkbox should toggle the other checkbox. Your guidance and help is appreciated!. @rikkit Nice and thank you!\nOne thing, I sort of think it could be nice to keep the names in the store, as it could be more pleasant for debugging. But I guess that could be abstracted on top of this. I learned a lot from your example. Thanks again!. @rikkit  I found one issue or maybe a bug with your approach.\nTry this one: https://codepen.io/anon/pen/baMRRw\nSo idea is that it should update the values when you click checkboxA or checkboxB, but it only updates the model when you click the toggle all. Also then it only updates one of the values and not both.\nThat said, what is the difference between form.$form.value.cb and cb.$form.value  ? Which do you tend to use if you are going to do something with the form values?. ",
    "Fouaib": "i tried to add a new branch pr/typescript-def-file , but when i want to push my branch it returns a 403 for my user. Can you authorize me ?. Thx a lot :). Hi david, is it possible to deploy the package on the npm registry please ?\n. Thank youuuuuu !!! :). ",
    "tamas-pap": "Yes, exactly. I would love to know every time the model changes for the component with model=\".text\", and have a handler attached to it. . ",
    "ayoola-moore": "Let me explain to you a bit- \nI'm suppose to create a dynamic form. (https://youtu.be/FZJQFHBR-bA) (it's just 18 sec) Notice that when as I click the number of rooms, Forms where created for each room. and Under those forms, they are more forms created. \nThe first redux dispatch is to ascertain the number of rooms to create. This- \n             dispatch({\n                      type: 'NO_OF_ROOMS',\n                      payload: numberOfRooms\n              })\nThe next for loop dispatch is to create the children for those form and a state for  each of them in my RRF reducer. ",
    "wwwebman": "https://github.com/davidkpiano/react-redux-form/pull/1076. ",
    "marcinm2h": "Probably  changing https://github.com/davidkpiano/react-redux-form/blob/13ce5b0fcaa8597accffa8b0af901f28e5b1f00a/src/reducers/form-actions-reducer.js#L233\nto\nif (action.omitKeys && action.omitKeys.length > 0) {...}\nWould do the job. I'll check it later.. https://github.com/davidkpiano/react-redux-form/pull/1079. I've found out that the problem occurs when I'm not passing initial state to formReducer(''), because initially state[formsReducerKey] doesn't have any sub-forms. Those are created on form actions.\nThen this invalid formKey is cached, and later when I have state[formsReducerKey][subFormModel] in my state getFormStateKey(state, modelString, s) would compute it's model correctly, but it gets the incorrect one from cache/\nI'm not sure if I should avoid cacheing on empty string model (''), or should just avoid initializing this kind of formReducer without initial state \ud83e\udd14.\nEdit: I'll try cacheing formStateKey for dynamic forms, when computed formStateKey's form model seems to be correct i.e. at least contains a part of getForm's argument model.. This was actually a bad idea. Still would get the same error when fieldState.errors is a string, and omitKeys is nonempty array.\nBetter solution:\n```javascript\n      case actionTypes.RESET_VALIDITY: {\n        let validity = { ...fieldState.validity };\n        let errors;\n        let valid;\n    if (action.omitKeys && typeof fieldState.errors !== 'string') {\n      errors = { ...fieldState.errors };\n      action.omitKeys.forEach(key => {\n        delete validity[key];\n        delete errors[key];\n      });\n      valid = isValidityValid(validity);\n    } else {\n      validity = customInitialFieldState.validity;\n      errors = customInitialFieldState.errors;\n      valid = customInitialFieldState.valid;\n    }\n\n    fieldUpdates = {\n      valid,\n      validity,\n      errors\n    };\n\n    subFieldUpdates = {\n      valid: customInitialFieldState.valid,\n      validity: customInitialFieldState.validity,\n      errors: customInitialFieldState.errors\n    };\n\n    break;\n  }\n\n```. ",
    "reneeichhorn": "Isn't it a weird that a form is dirty even after it has been submitted? Usually you would use the pristine flag to determine whether or not the form has been saved yet. For example when the user navigates away without submitting data you would check if the form is pristine or not to warn the user that the form needs to be saved first.. ",
    "lenadss": "Thanks for the idea! I didn't think about such solution :smile:  It works perfectly!. ",
    "zjr": "I don't have a clue about gitbooks.io. That's connected to your repository somewhere? If so, sure, but not what I was expecting.. Hah, when I try to visit http://gitbooks.io I get a 502 error. Are they not running anymore? Do they only have subdomains?. @davidkpiano I think you might be misunderstanding me. This isn't a problem with your current documentation on GitHub Pages. I did in fact check this branch you mentioned\u2026 as one would suspect given the branch's name: this is code for GH Pages.\nThe problem is that you have old docs sitting up on http://gitbooks.com. This is books not pages. I don't have any idea how I would change what you have on GitBooks. This isn't like updating a README.md for you or something, this appears to be a whole other thing outside of GitHub.. When I say old I mean like\u2026 these docs are very different from the way your package currently works, they seem to be quite old.. ",
    "john-mcgowan1992": "@emolchanov this has been driving me nuts for the past day. Thanks for the fix!. ",
    "khaninD": "functions in mapProps are called each time, when value changed, but i want change className onBlur event ... i try use updateOn='blur', it's not working.... ",
    "rztiwari": "I am facing the same issue. @khaninD  were you able to resolve the issue. I am using LocalForm in my case.. ",
    "rdak": "Try to use it:\n<Component.text\nrequired  // for example\nvalidatiors={...} // better use that for complicated validation\nmapProps={{\n  className: (field) => {\n    if (!field.fieldValue.valid) {\n      return \"errorClass\";\n    }\n    else {\n      return \"anotherClass\");\n    }\n}}. ",
    "OscarYuen": "I am experiencing the same issue. Any progress on it~?. ",
    "arntj": "Temporary workaround: Clone class instance to ordinary JS object, like this:\nconst store = createStore(combineForms({\n  user: { ...new User() },\n}), applyMiddleware(thunk));. ",
    "djbingham": "Hi @davidkpiano, thanks for the suggestion but that's not working. From the documentation, it sounds like actions.setInitial is similar to actions.reset but resetting just the form field values, not the model. I want the whole model to reset, but to values that I fetched via an API call after page load rather than to the static initial values.\nI need something similar to actions.load but setting .initialValue rather than .loadedValue on the model.. ",
    "write2art": "+1 here.\nI`m loading values this way:\nactions.load(model, data))\nactions.setInitial(model)\nNow i have my loaded values in initial values of the form state as well, but reseting the form brings back empty initial values from the store initialise. \nIs it expected behaviour? . ",
    "saschb2b": "Seems to occur after the oldHandleBlur change was implemented in 1.16.8 https://github.com/davidkpiano/react-redux-form/commit/0f4051206c4964648a9fde1215172615504e1d80. ",
    "harry-sm": "Thanks!. ",
    "arunganesan": "Did you solve it?. ",
    "hayk94": "@arunganesan what about you?. ",
    "latuszek": "I've tried to initialize the form with dispatch(formActions.load(addToGroupForm.${g.id}, { company: null, users: [] }));.\nThe current result is when I'm clicking submit button only rff/addIntent action is dispatched and nothing more happens (no validation - no submission).\njavascript\n{\n  intent: {type: \"submit\"}\n  model: \"addToGroupForm.14\"\n  type: \"rrf/addIntent\"\n}\nSame thing happens when I'm initializing the form state with reducer function.\nI'm not sure if it matters, but I can see that initialValue is set wrong in the form:\njavascript\ninitialValue: {\n  14: {users: null, company: null}\n}\nShould be {users: [], company: null}. When I'm hardcoding this value instead of loading it asynchronously the validation works as expected, but only on first submission. I'm dispatching reset action after submission - it might be the reason.\nSo far I'm not able to find the solution for my problem, so any guidance will be appreciated.\n. As a workaround I'm using LocalForm to have this working properly with validation.\nHowever, it would be nice to make it work with list of forms stored in redux store.. ",
    "dmitryosipow": "I've found the following solution: onSubmitEditing handler from TextInput handles event when user hits Enter key on mobile, so it is possible to pass function from Field component to TextInput for execution on Enter.\nOne question from me: when TextInput gets input parameter from Field, this input has onFocus, onBlur and other event handlers https://redux-form.com/6.4.3/docs/api/field.md/#meta-props ,but it doesn't have  onSubmitEditing prop, so I have to pass it as another parameter. Why so?\n```\nclass SearchBenefitsForm extends React.Component {\n  renderTextInput = ({ input, autoFocus, onSubmitEditing }: { input: any, autoFocus: boolean, onSubmitEditing: Function }) => {\n    return (\n      \n    );\n  }\nrender() {\n    const {\n      handleSubmit,\n      submitting,\n      invalid,\n      onCancel,\n    } = this.props;\nreturn (\n  <View style={styles.container}>\n    <TouchableOpacity onPress={handleSubmit} disabled={submitting || invalid}>\n      <Image style={styles.searchIcon} source={searchIcon}/>\n    </TouchableOpacity>\n    <View style={styles.searchExpression}>\n      <Field\n        name={SEARCH_BENEFITS_EXPRESSION}\n        autoFocus={true}\n        component={this.renderTextInput}\n        onSubmitEditing={handleSubmit}\n      />\n    </View>\n    <TouchableOpacity onPress={onCancel} disabled={submitting || invalid}>\n      <Image style={styles.closeIcon} source={closeIcon}/>\n    </TouchableOpacity>\n  </View>\n);\n\n}\n}\nexport default reduxForm({\n  form: SEARCH_BENEFITS_FORM,\n})(SearchBenefitsForm);\n```. ",
    "dvakatsiienko": "@davidkpiano wow, thank you so much!. ",
    "davidhagg": "I can give it a try, but I'm not sure if I know the fix. found the issue, if the submit button has a name property name=\"submit\" it does not work in Firefox. Removed that property and it now works!. ",
    "elmarini": "Sorry, closing this issue, wasn't passing in the right props.. ",
    "Ogek": "You must have \"model\" property on LocalForm and the property path as \"model\" property of its fields.\nExample:\n```\n\n\n\n\n```. ",
    "KrisCoulson": "@davidkpiano I can take a deeper look into this when I get a chance. I did take a quick look although  unfamiliar with the code but  it seems that createEventHandler which processes and persist the event has already lost the correct event. \nAs well as \nthis.handleBlur = (...args) => {\n          this.handleUpdate.flush();\n          oldHandleBlur.call(this, args);\n        }\nlogging args here on line 141 returns the empty SyntheticFocusEvent. \nI originally thought it was just an event.persist issue but looking into it looks like it should already be persisted and is being lost when overwriting this.handleBlur. ",
    "peggers123": "Hello,\nThis update has confused me. I am trying to build a Select control that outputs a boolean, but also has an empty value when I want to force the user to select an option:\n                <Control.select model={this.props.model}  validators={validator} parser={parse} formatter={formater} type=\"number\">\n                    <option value='' hidden disabled>{this.props.t('_option select')}</option>\n                    <option value={false}>{this.props.t('_option false')}</option>\n                    <option value={true}>{this.props.t('_option true')}</option>\n                </Control.select>\n\nBut now it is updating with strings rather than booleans - how do I alter this?. ",
    "MartinElvar": "Hello @davidkpiano,\nDid some digging, and it would seem that this is enforced by react. Adding touched={ false } to a vanilla input field will yield the same result.\nSo i'm a bit unsure how to handle this, i could convert forth and back in my own application. Or this could be handled by react-redux-form, i would assume by casting certain boolean values to string, that react actually render to the dom. Could be somewhere in here https://github.com/davidkpiano/react-redux-form/blob/master/src/components/control-component-factory.js#L229.\nI would love to make a pull request, if that is desired road. But would love some input. \nThank you :-).\n. ",
    "TimPetricola": "@davidkpiano thanks for the fast merge \ud83d\ude47 Do you think we could release a patch for this? (I can prepare a PR if you want). ",
    "criess": "Hi guys and gals,\nAlso caused a lot of confusion on my side. Took me half a day to figure out why all of my text-masked uncontrolled inputs broke all of sudden. Should be released via npmjs repo if possible so we have a latest working version of react-redux-form.\nFor now I'll use the package from github.\nThanks for the patch!. ",
    "samdoughty": "I've found that if you pass a different React key to a wrapper element (e.g. <Input key=\"name-required\" /> vs <Input key=\"name\" />) then it will make React re-mount as a different component and that in turn will make react-redux-form to update the validations.. ",
    "Alex0007": "@davidkpiano \nI think, there is another problem with types\nnode_modules/react-redux-form/react-redux-form.d.ts\n(235,20): Cannot find name 'ChangeEvent'.\nTypescript 2.9.2. ",
    "mellis481": "I just ran into this same issue.. ",
    "craig-landry": "The callback and action you mention are correct as far as I have experienced.  Here's an example onSubmitFailed function to get the first failing model and focus it::\nhandleSubmitFailed(form) {\n    Object.keys(form).some((key) => {\n      let obj = form[key];\n      if (obj.valid === false) {\n        this.props.store.dispatch(actions.focus(obj.model));\n        return true;\n      }\n    });\n  }\n. ",
    "gormv": "This is a nice solution, but unfortunately the order of checking is not from top to bottom. Any advice on how to check from top to bottom in form would be appreciated :). ",
    "gianfelipe93": "@AntiFish03 how did you solve this issue ?. ",
    "AntiFish03": "@gianfelipe93, Sorry your message got lost in the clutter. I'm not using RRF.  I went with Formik.. ",
    "atwright147": "Hey,\nBased on your question you seem to be looking for help with redux-form but this repo is react-redux-form.\nKindly close this issue and create a new on at https://github.com/erikras/redux-form/ . ",
    "syte": "@davidkpiano, this is a great lib for those of us who have to store form state in redux. In my use-case I have several forms that need to keep their form values long after being unmounted. I don't think formik necessarily covers this use-case as of yet. Thanks for continuing to maintain it. This is the cleanest implementation of handling forms in redux that I've seen.. ",
    "KO527": "So basically I had to set a proper trigger for the NoSearchResults error, so I set that up in a sibling folder called services in a file called checkQueryValidity.js: \n```\nexport default function checkQueryValidty(val){\n    return async (dispatch) => {\n        dispatch(actions.setPending('SoundCloud.input', true));\n        try {\n            let response = await querySC(val);\n            dispatch(actions.setValidity('SoundCloud.input', {\n                queries: response.queries\n            }));\n        }\n        catch(error){\n            dispatch(actions.setErrors('SoundCloud.input', {\n                NoSearchResults: error.message\n            }));\n        }\n\n    dispatch(actions.setPending('SoundCloud.input', false));\n}\n\n}\n```\nAnd in the file SoundCloudExp.jsx, I replaced SCPromise w/ checkQueryValidity(res) and replaced querySC(res); with dispatch(actions.submit('SoundCloud', checkQueryValidty(res))); \n. ",
    "anujgakhar": "I don\u2019t have a fix yet - just want to know what would the fix be ? Should the handleLoad pick up value as well, in addition to defaultValue ? \n\nOn 12 Sep 2018, at 17:36, David Khourshid notifications@github.com wrote:\nDo you have a fix? I welcome any PRs.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. \n",
    "pratik916": "@mjangir Awesome workout. ",
    "adrienshen": "Oh, I am use Form, however I resolve this already. Thanks closing now.. "
}