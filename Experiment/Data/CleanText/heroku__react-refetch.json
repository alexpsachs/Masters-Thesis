{
    "ryanbrainard": "Merged locally. Closing.\n. ok, i'm going to pull out that re-naming TODO, bump the version, merge and publish this\n. Thanks, but went with #8 since it uses JSX. \n. Awesome, thanks!\n. I have considered something like this, and not a bad idea, but so far, I've done things like this, which has worked in the limited places I have needed it:\n``` .jsx\nexport default connect(({ params: { userId }, location: pathname }) => {\n  const common = (urls) => Object.keys(urls).reduce((reqs, p) => {\n    reqs[p] = {\n      url: urls[p],\n      comparison: pathname,\n      refreshing: true,\n      headers: {\n        'X-Custom-Header': 'true'\n      }\n    }\n    return reqs\n  }, {})\nreturn common({\n    userFetch: /proxy/users/${userId},\n    likesFetch:  /proxy/likes/${userId},\n  })\n})(Profile)\n```\nIf we did something like this, I'm thinking some kind of similar function set in options that would be run on every request after it has been coerced into a canonical request (i.e. in the full object form, not just a URL), but before fetch() is called. Is that what you were thinking?\n. @thomasloh I'm hesitant to add any global options, but this could be a common option that's passed into every connect(). It would be just one extra line, so not too much boilerplate and would avoid global/singleton messiness. Something like this:\n.jsx\nexport default connect(({ params: { userId }, location: pathname }) => {\n  return {\n    userFetch: `/proxy/users/${userId}`,\n    likesFetch:  `/proxy/likes/${userId}`,\n  }\n}, requestPreprocessor: myCommonRequestPreprocessor)(Profile)\nwhere myCommonRequestPreprocessor is a function similar to the common() one I showed before but defined in a separate file so it can be shared. I'm thinking the function would probably take (requests, props) and return requests. How does that sound? Also, open to a better, shorter name than requestPreprocessor. \nAnother way to possibly do it is instead of making it a pre-processor, it would be letting applications overrides the defaults used in buildRequest().\nAlso to consider: the order of exactly when this happens. Should it be before, after, or completely replace buildRequest()?\n. v1.0.0-beta.0 has the ability to change the buildRequest, fetch, and handle Response implementations, which should open up a lot of possibilities here. These features are probably a little too low level for everyday pre-processing; however, I want people to kick the tires on them and see what can possibly be built on top of them. I'm going to close this issue now so that we can re-frame remaining enhancements in this new context by opening new issues.\n. I have not tried it with react-native, but it would great for someone to experiment with. It currently only supports fetching JSON data from over HTTP/S via fetch(). \n. I'm not opposed to it, but just wondering if it would be better to allow applications to provide their own fetch polyfill. Perhaps it should just be a dev dependency in this library and then it would be up to applications to choose what works best for them? Also, whatwg-fetch will not load if you already have another fetch loaded already, so you could probably still use it as-is today and just make sure your fetch is loaded first. I do not claim to be an expert at all on JavaScript modules, imports, and polyfills, so  I'm all ears if someone has a better idea how best to do this.\n. @hnordt The idea was to allow applications to have more freedom to choose which version of whatwg-fetch so it would not conflict if it was already a dependency of the application. Although, to be honest, I'm kind of an npm noob, so if someone knows a better way to do this, please let me know. If we can get away with just making it a devDependency for tests and have applications use whatever polyfill they want (or nothing at all if they don't care about cross-browser support) in production would be ideal. How do other npm modules usually deal with polyfill dependencies like this?\n. > Other npm packages omit the dependency from dependencies, but put it in devDependencies for tests. The user is then responsible for installing the actual dependency into their own project.\nThat sounds good to me. I think that would fix @nicholaswyoung 's original problem as well so he can use whatever  fetch he wants. One additional problem that might come up after this is the use of window.fetch and window.Request. What do people usually do for Node interoperability of these?\n. @hnordt I like the idea of letting applications provide their own fetch; however, it seems like doing things like default URLs and custom token management do not belong in there. I agree we probably need some mechanism for that, but just doesn't seem like it belongs in a fetch implementation. Instead, I think this could be solved with a custom request preprocessor (see https://github.com/heroku/react-refetch/issues/9) that runs before fetch.\n. @nicholaswyoung sweet! Looking forward to to it. Just a heads up that I might slow to respond or get anything merged or published during the holidays. \n. @nicholaswyoung take your time :) just wondering, will you be moving fetch into devDependencies as suggested in https://github.com/heroku/react-refetch/issues/11#issuecomment-166035146 ? I think that's the way to go, but wondering what your approach is going to be. Of course, I'm open to other suggestions as well. \n. +1, just open it now as a \"WIP\" (work in progress) PR for early feedback. \n. @nicholaswyoung Just wanted to check in on this. Anything I can help with on your PR?\n. @nicholaswyoung No worries, the baby is definitely more important than this. Just push up what you have, add a comment that it is a work in progress, and someone else can always build on it. \n\nI can easily submit a PR that switches to node-fetch when used server side. Would that at least fix the current issue? What do you think?\n\nThat sounds great. It is especially good if it is a stepping stone to a more general solution. Again, just push up what you have. If it works as is and adds incremental value, we can pull it in and improve on it later. If it needs work, I'm sure someone will step in and help.\nGood luck with the new arrival! :baby: :baby_bottle: \n. @hnordt Your suggestion could technically work around this, but this is something that should be supported out of the box without users having to create their own handlers.\n. No problem. Thanks @nicholaswyoung and good luck with the :baby: \n. May be addressed in #75 \n. Closed by #76 and release in v1.0.0-beta.0\n. Sorry to be a pain, but the way GitHub is showing this diff with the soft wraps, I can't tell what changed. Can you add a quick PR description?\n. Thanks anyway! :)\nOn Saturday, December 19, 2015, Katy Moe notifications@github.com wrote:\n\nAh, didn't noticed you'd merged a subsequent PR with this fix.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/heroku/react-refetch/pull/12#issuecomment-165965310.\n. Hey @zeke! Long time, no see! \n. Thanks!\n. I like the idea in general, but I'd like to see how well it works with PromiseStates, especially ones that are composed with PromiseState.all() and need to be decomposed on fulfillment. We use that pattern heavily to block on groups of fetches that should rendered together. This might also make it easier to allow for application provided defaults for the pending and error states. If you'd like to try making a PromiseState-specific version of this, it would at least be interesting thought experiment. \n. It works, but I personally don't like having to see the attributes of the PromiseState in all my components and also has duplication for the pending and error states. I like the HOC, but it should really be PS-specific to be used with Refetch IMHO. Perhaps a second-order HOC could even handle the application-specific defaults so something could be included (mostly) out of the box.\n. I'm going to close this for now since there's nothing really actionable here at this point. If you'd like to provide an HOC PromiseStateContainer, please open a pull request. It could even just a link in the readme to a gist, but bonus points if it can be a double HOC the incorporated application defaults and can be included in this library.\n. To do the data transform, you should be able to use then() on the PromiseState instead of on the request in connect(). The latter will fire off a new request, which is probably not what you want. \n. @hnordt  do you mean call the 'query' attribute 'data' (and maybe also share it with 'body') like jquery does? I wasn't following your example in relation to the issue. \n. Also, can we please break this into two separate issues? :)\n. I've been thinking about this, and I've decided to decline on this feature for the following reasons:\n1. The query is part of the URL. Having it be in a separate attribute can lead to confusion.\n2. It requires the use of request object syntax. The URL string request syntax should always be preferred for simplicity. \n3. I agree that declaring the query params as an object/hash is good (I do this myself), but I think that converting it to a query string is something that should be done by an explicit function. We could provide something like this in this library, but I'm sure there are several existing libraries that already provide such a facility (e.g. jQuery's $.param()), so I don't think there would be much value in implementing another one. ES6 string templates/interpolation make this even nicer to use to include in a string. \n. I'm all for accepting more than just JSON, but I'd kind of like to have it based on the Content-Type header in the response rather than adding a new attribute. That might be wishful thinking since there's always going to be some API that doesn't have the right headers and anyway clients will need to send the Accept header as well. \n\nAnother idea is to have customizable response processors. This is kind of possible now with PromiseState.then(), but since it's defaulting to JSON, it's too late once it gets to then(). \nSo, given all this, I'm thinking we should use the response Content-Type if we can, fall through to JSON for backward compatibility, and allow it to be overridden by an attribute. Thoughts?\n. v1.0.0-beta.0 has the ability to change the buildRequest, fetch, and handle Response implementations, which should open up a lot of possibilities here. These features are probably a little too low level for everyday post-processing; however, I want people to kick the tires on them and see what can possibly be built on top of them. I'm going to close this issue now so that we can re-frame remaining enhancements in this new context by opening new issues.\n. @ashtuchkin it will inject a PromiseState to whatever prop you assigned in updateData() inside of connect(). If you want to do something with that like show a user message, you'll need to check that it is both defined and fulfilled. It will be undefined until you call updateData(). Use componentWillReceiveProps() if you want to compare it to the current value, otherwise just use it in render(). \n. Sorry for the delay. I didn't see these comments because they were on a closed issue. Although it wasn't really designed for it, you could try to use andThen() on the request:\njsx\n@connect((props) => ({\n    project: `/api/projects/${props.id}`,\n    updateProject: (data) => ({\n        project: { \n          url: `/api/projects/${props.id}`, \n          method: \"PATCH\", \n          body: data,\n          andThen: () => {\n            // do something here\n            return {}\n          }\n        }\n    })\n}))\nThis is kind of crappy because now there is a side effect, but since it is inside of a fetch function, I guess it is less bad. The other problem is that you probably don't have access to whatever you want to call here either. If we add \"identity requests\", they could actually work quite well here too, so you could do something like this:\njsx\n@connect((props) => ({\n    project: `/api/projects/${props.id}`,\n    updateProject: (data) => ({\n        project: { \n          url: `/api/projects/${props.id}`, \n          method: \"PATCH\", \n          body: data,\n          andThen: () => ({\n            projectUpdated: { \n              value: true // some static value of your choice\n            }\n          })\n        }\n    })\n}))\nThen you'd get projectUpdated in the component as a PromiseState with the provided value. This would let you know that the project is new and a result of calling updateProject(). Not sure if this gives you everything you need, but I think that is at least a step in the right direction. Let me know your thoughts.\nGoing to re-open this so I see the comments.\n. Closing this to be implemented at identity requests in https://github.com/heroku/react-refetch/issues/33. Re-open if there is more discussion to be had.\n. Thanks! :christmas_tree: \n. What if we had a kind of \"identity request\" that would allow a value to be provided in the request instead of a url? The value would get passed through to PromiseState.value and no fetch would actually be performed. This would allow you to use then() on the request side instead of the response side:\njavascript\nconnect((props) => ({\n  data: {\n    url: \"/api/data\",\n    then: (rawValue) => ({ \n      value: rawValue.real_data \n    })\n  }\n}))(Component)\nIt is basically the same as transform, but with one more level of indirection to let it be more composable with things like catch, andThen, etc. It could even be used standalone at the top-level for static data.\nI'm not 100% convinced this is the right way to go and open to suggestions. Thoughts?\ncc: @jsullivan \n. 1) You don't need to specify the data key again with then. Just specify the value and it replaces the existing one. If it was andThen, you would need to specify the key(s), but it would be strange to overwrite the parent key in andThen. It is usually used in cases where you need access to the parent, but also kick off other dependent requests (see https://github.com/heroku/react-refetch#chaining-requests). If you wanted to use andThen with an identity request, it would look something like this:\njsx\nconnect((props) => ({\n  data: {\n    url: \"/api/data\",\n    andThen: (rawValue) => ({ \n      realData: { // <-- different name from parent `data`\n        value: rawValue.real_data\n      }\n    })\n  }\n}))(Component)\nThis would give you inject both data and realData.\n2) Want to avoid that for now. Would transforming the value to Promise.resolve(value) work for you?\n. Closing this to be implemented at identity requests in https://github.com/heroku/react-refetch/issues/33. Re-open if there is more discussion to be had.\n. Thanks! :christmas_tree: \n. I probably won't be able to look into this in-depth until next week, but just noticed that visibility is a devDependency. Is that correct? Also, the defaulting of request attribute should all be in buildRequest() if possible. \n. cc: @ricardochimal any thoughts on this since you originally had the use case for refresh intervals?\n. @hekike I tried this out locally, and it works and looks good overall, but left some comments for some minor changes. Thanks again for working on this.\n. Due to lack of recent activity on this PR, I'm closing it. If this is something still requested, please open a new PR.. You probably also want to make sure that the props actually changed or at least that the PS changed from pending to fulfilled; otherwise, you'll end up calling the action multiple times. \nWithout thinking about it too much, this pattern feels a bit too imperative to me. If this really is a pattern that people would like to use, I'd like to see something more declarative and/or reactive. Furthermore, I'd really like to see use cases/stories so we are designing this to solve real world problems instead of starting with the technology. \nThanks for kicking off this discussion. \n. Closing this out as it seems like the discussion has died off, but feel free to re-open if needed.\n. Thanks! Not sure how all them at trailing white space got in there. I'm guessing it was from me, but I thought my editor would have cleaned that up for me on save. Perhaps it was from direct edits in GitHub. \n. If you want to always refetch regardless of the request changing or not, you can set force: true in the request. This is generally not advisable for top-level requests, but makes sense for requests inside of functions. Alternatively, you can set comparison to some value to check equality with a custom value. \nWith your current setup, are you finding that one fetch happens on component mount, then one refetch happens on the first user click, and then no more refetches for subsequent clicks; or, are finding that only the first fetch happens on component mount? From your description, it sounded like former, but I would expect the latter because the request didn't change even on the first refetch. I'm going to leave this issue open for your response and so I can do some testing of the behavior here once I'm back at a computer. \n. > When the component mounts, I see one fetch. Then when the user clicks a button I see one refetch.\nHmm, I'll need to investigate that. I would only expect the initial fetch. \n\nThe library currently allows for one fetch and one refetch because the mapping changes from not having the refreshing key set (on the original fetch) to having the refreshing key set to true when the user first clicks the button (through the function refresh function passed into the component). \n\nIt shouldn't be comparing that, but I'll need to take a closer look. \n\nI know, setting force to true will allow it to continue refetching for each button click, but I'm wondering if it would make more sense to just see if refreshing is set and true and always allow a refetch if the mapping is valid. \n\nThere are use cases to set refreshing on component mount and cases when a refetch should not occur even on a user action, so I don't want to conflate force and refreshing and chose to keep them separate, explicit attributes. \n\nIt seems to me like each individual component should be responsible for determining when a user clicks on a button if a refetch should actually trigger or not through the components all validation checks, not through the react-refetch library by passing in force: true. \n\nSee above, and also remember that you can pass arguments to fetch functions, so you could even pass in force at runtime to incorporate it into your validation routine. \n. > I believe it is using the same mapping because the key is the same for both the initial fetch and refetch: devicesSearch (in the example above)\nSorry for the delay. I finally got some time to try this out, but I cannot reproduce the issue you were seeing with the first refetch. I copied your code snipped above into a sample app of mine, but I only see the initial fetch happening on page load. The fact that they are both using the same key is exactly why there should not be a refetch. When I tried calling it devicesSearch2 inside the function, it as you mentioned. Are you sure you didn't have a typo in the key name? I way you described the behavior in #28 is correct, so I'm going to pull that in and close this issue, but please let me know if you're still having problems with this.\n. Err, scratch half of what I just said. I re-read what you have in the readme:\n\nIn the above example, if props.userId is 1, /users/1 would be fetched, then refetched once if triggered, but not refetched a second time if re-triggered.\n\nThis is not the behavior that is expected or what I experienced when I tried this. With force: false and no change to the props, it should never refetch. I'm going to update the example to include force: true, but still curious about the behavior you saw. If you're still seeing that, please re-open this. \n@hnordt mentioned he also ran into the general force: true issue. @hnordt, did you see this same behavior of a first (but not second) refetch that @jwdotjs saw? \n. @jwdotjs Ah, I see what the problem is! It is not the refreshing: true (which is not considered for equality), but that you are specifying method: 'GET' only on the request in the function. GET is the default method, but the defaults are not applied until after the equality check. This is mostly a bug in Refetch, but I need to re-think if there was any reason it was done in this order. For now, if you just remove the method: 'GET', it should work for you. I'll file a bug for this as well.\n. Try moving export default before connect. As you have it now, you're exporting the unconnected component, so it's undefined. \nClosing this now, but reopen if you're still having issues. \n. Re-reading the first example in the readme, I can totally see why you did the export like you did. I'm going reopen this as a reminder for myself (or anyone who wants to send a PR) to update it to make it clearer.\n. Thanks for writing this up. Re-reading the example, I can see how it's easy it would be to misunderstand this. I'm also going to fix up the example and make a couple tweaks to make this clearer.\n. I may have gone a little overboard in my \"tweaking\" and ended up incorporating your additional into the example instead of making it stand alone. Please let me know if it still captures the spirt of what you wanted to convey. \n. Manually merged all but 4b0e6bf, so having to manually close. Thanks @hnordt !\n. This might be something that could be added to PromiseState.meta Feels a little messy, but meta is kind of designed as an escape hatch for some of these underlying things like this.\nAnother alternative might be to just use Promise.resolve() to create a dummy Promise. Don't know if it will work, but something like this:\nhandleSubmit(data => Promise.resolve(postProject(data)).then(resetForm))\n. @hnordt How does that work if \"Redux Form expects a promise to be passed to handleSubmit\" ? On the TODO help, are you asking how to do that with the lib today or a feature request for fulfillment handlers? If it is the former, just compare this and next props for a change to postProjectResponse.fulfilled.\n. Going to close this unless there is an active/open ask here.\n. Released in v0.7.0-beta.0\n. @jsullivan Can you review this when you get a chance?\n. Released in v0.7.0-beta.0\n. @georgebonnr \n\nI was just about to ask about this, to help with transformations.\n\nIdentity requests will allow for transformations of responses inside of connect(); however, you can use PromiseState.then() to do the same thing in the component. The only downsides of doing it that way are 1) gets applied for any prop change and 2) could clutter up the component if complex. Here's an example to transform the usersFetch to only include the verified users:\nthis.props.usersFetch.then(users => users.filter(u => u.verified))\n\nAny timeline, or is this a request for a PR\n\nI'd like to get to this soon, but we don't actually have a real need for it at this point with our own application of React Refetch, so that's slowing it down a bit. Also, there are a few different asks about transformations, handling different data types, etc, and I'd like to think about them holistically before rushing on any of them in piecemeal; however, I feel pretty confident about this one adding value with or without the others. I might even play around with it tonight since it should be fairly strait forward. With that said, anyone is welcome to open a PR for any of these enhancements.\n. Implemented in #36 \n. Merged #36 and released in 0.7.0-beta.0. Please kick the tires :)\n. Thanks!\n. Just added a new commit that breaks out createPromise() to treat identities as a resolved Promise and work the same as HTTP fetch for post processing. This abstracts things a bit and should make it easier to introduce generic/customizable request handling. \n. Released in v0.7.0-beta.0\n. Good catch. I thought for sure I remember seeing id in the doc, but you're right that it is not there. I'm thinking I can instead do this:\ne = new Error(message)\ne.id = id\nthrow e\nIt's a little dirty to set the id like that as a field, but just don't want to loose that data in case someone needs it. I just tested this in the console with Chrome and it works. Would you so kind to try it on IE8 (sorry, I don't have easy access to IE8)?\n. Thanks for testing that out.\nYes, I'd be happy to make it more generic. id is a Heroku API-specific\nthing where we put error codes, and probably doesn't belong in here. What\nI'm thinking is placing the entire original error in a Java-style cause\nfield, so then you can get to anything you want. For example, id would be\nat e.cause.id and your arbitrary fields would also be accessible. Would\nthat work?\nOn Wednesday, January 13, 2016, Joe Haines notifications@github.com wrote:\n\nYeah that works fine, IE sets the message and id properly.\nWould you be willing to change the name from id to something more\ngeneric, or add a new field for additional information about an error\n(maybe context)? We're dealing with a legacy application that often\npasses arbitrary data back from the server on errors and it would be nice\nto be able to handle the same cases without having to refactor things\ntoo much to begin with.\nWe could just attach it to id but it'd be nice to have a proper place for\nthat sort of thing to live.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/heroku/react-refetch/issues/37#issuecomment-171225169\n.\n. Released in v0.7.0-beta.0\n. Released in v0.7.0-beta.0\n. > a way to handle POST/PUT/DELETE requests.\n\nSet the method in the request.\n. I'm still idly noodling on how to handle custom request and response handling. There's several way to do it, but so far not totally satisfied with something that both retains reasonable defaults and gives users enough power. Good to see more use cases like this though.\n. @hnordt The reason I don't want to do it that way is that then it applies to everything in connect and not granular to one request/mapping. Of course we could put buildRequest and handleResponse on the request/mapping, but there is usually a strong correlation between the two (e.g. text/csv headers and CSV handers) and it would be nice to have them be applied together. Perhaps this is simple as doing something like { handlers: { request: ..., response: ... } }, but then I'd still want the ability to be able to provide defaults like you did at the connect level. I know that sounds a bit contradictory, but the point is that the handlers should be primitives on the mappings and then what goes at the connect level (or maybe one level within) should be selecting the defaults of those mappings. If you want to take a stab at this, I would recommend opening a pull request.\n. @hnordt I think we're talking about two different kinds of \"defaults.\" I'm not talking about different default handlers (e.g. json. csv, etc), but rather connect-level, user-provided default for the requests within. \nFor example, it can see it being helpful do something like this to apply a default refreshInterval to all request mappings:\njsx\nconnect(({ userId }) => ({\n   userFetch: `/users/${userId}`,\n   likesFetch: `/users/${userId}`/likes,\n}), { refreshInterval: 1000 })\nsimilarly, you could do something like this for a default handler:\njsx\nconnect(({ userId }) => ({\n   userFetch: `/users/${userId}`,\n   likesFetch: `/users/${userId}`/likes,\n}), { handler: (response) => {...} })\nwhich is kind of like what you are suggesting, but what I'm saying is that that is really just a convenience for the true expanded form of\njsx\nconnect(({ userId }) => ({\n   userFetch: {\n     url: `/users/${userId}`,\n     handler: (response) => {...}\n   },\n   likesFetch: {\n     url: `/users/${userId}`/likes,\n     handler: (response) => {...}\n   }\n}))\nMy point is just that the handler primitive should be at the request mapping level, not the connect level. We could also support connect-level defaults, but those would not be handler-specific.\nMake sense or more confusing now? :)\n. v1.0.0-beta.0 has the ability to change the buildRequest, fetch, and handle Response implementations, which should make this possible now. Feel free to open another issue if there's something that that does not provide, but I'll like to have the conversation in that context.\n. Going to pull this in early for the beta, but please review async before this ships in 0.7.0\n. This should be possible. I have components that basically do the same thing. The first thing I see wrong with your example is that deleteResume is not in your connect(). Can you try adding that? Also, I would recommend adding PropTypes to make sure everything is being passed as expected, and please let me know if a specific error you are getting or exactly where it is breaking down. I'm going to close this for now, but please re-open if you're still having issues.\n. @Adam-Burke Not currently possible, but should be very simple by just adding support for mode like this original PR did, but would need to be seriously rebased, so probably easier to start fresh. I'll open an enhancement request, and I'll try to get to it or would be happy to accept a new PR.. Yes, I think that is the best way to do it.\n. Might actually pull this out all together as a peer dep, but sounds good for now. \n. @eyalw If you use the beta version (v0.7.0-beta.0 or higher; v0.7.0-beta.4 is the latest), you can get to the underlying error with the new cause attribute on the error. See https://github.com/heroku/react-refetch/pull/38 for details. Closing this now, but re-open if you're still having issues.\n. @eyalw Can you give an example and version number please?\n. Thanks @eyalw, I'll try to look into this week.\n. @eyalw Happen to have anything to do with the missing commas between your key-values?\n. Haven't nailed down exactly what is happening, but I was able to reproduce and there's definitely something weird going on here. Hope to dig in more soon.\n. Oh, I see what it is. The identity request in the then is overwriting the original equality check where the comparison happens. Need to test, but pretty sure that's what's happening. \n. See #64 for a fix\n. Workaround in the meantime: set comparison again inside the object returned by then\n. Released in https://github.com/heroku/react-refetch/releases/tag/v0.7.0-beta.3\n. @volkanunsal \n\nIt looks like there are a couple of bugs in iOS.\n\nDo you mean in React Native? This has not been tested at all with React Native. I would love someone who is more familiar (or has a real use case) in that space to try out, doc, and maybe even improve compatibility.  \n\nThe first one is that a polyfill is required for Object.assign. \n\nCorrect me if I'm wrong, but that should probably be the responsibility of the app. Would documentation around this help?\n\nPromiseState fails to resolve in iOS\n\nAny ideas why? Reproducers?\n. @volkanunsal Thanks digging in and investigating this. As far as action items:\n- Document recommended polyfills (note, there is also a plan to remove whatwg-fetch as a peer dependency and make it just an app selectable polyfill, as needed)\n- Document this issue for Safari\n- Anything else for this project?\nNote, as far as Request being experiment, the whole Fetch API is considered experimental.\n. Re-opening as a reminder for the action items above.\n. Closed by #76 and release in v1.0.0-beta.0\n. When the user changes the time range selection, can you just update the URL (perhaps a query parameter), which would update the props? This allows all the state to be in the URL, so you can bookmark it, share it, etc, and see the exact same thing. Another (lesser) alternative is to set it in the history state of the URL, which would also be available via props if using React Router. I'm opposed to adding any mutable state in Refetch itself.\n. This library was forked from react-redux, which does this. I dropped it during early development because we didn't need to for our own needs, but I'm not opposed to adding it back. I think all we need to do break out build again like this: https://github.com/reactjs/react-redux/blob/master/package.json#L7-L10\n. I think that https://github.com/heroku/react-refetch/issues/11 will need to be completed first. It would also be good have some docs/examples for it. \n. Now that v1.0.0-beta.0 has shipped, there are a lot more isomorphic possibilities. Now would be a good time for anyone interested to kick the tires and experiment with server side rendering with React Refetch.\n. @isaachinman We don't do anything isomorphic with this library internally, so there is no explicit support and what might exist incidentally is not tested or documented. \n. This issue is address that by anyone who would like to contribute. I just don't have the expertise or need for isomorphism, but there is someone who does, PRs would be welcome :)\n. @mymtwcom Sorry, still the same answer as before.. Have you tried using andThen as @hnordt suggested in https://github.com/heroku/react-refetch/issues/47?\n. @eyalw Sorry for the delay getting back to you. I would like to support your use case, but I'd like to understand it a little better:\nIs there a reason you want to pass in the callback as a ref? Does that give any advantage over proving a function that takes the wrapped component as an argument? I don't use refs very much, so perhaps I'm missing something.\n\n@ryanbrainard, can you explain how it helps in the scenario I described? I see @hnordt has a prop array named 'history' given to the wrapped component, and promise value is pushed into that array.\n\nI don't think that history is an array, but rather the history from https://github.com/reactjs/history being injected as a prop by react-router. The push should be doing redirect, not adding to an array.\nWhat if meta contained a reference to the wrapped component with, so you could do something like this?\njsx\nconnect({\n  fetchAccountPs: {\n     method: \"GET\",\n     url: \"/some/url\",\n     andThen: (_, meta) => {\n        meta.wrappedComponent.onAccountFetched()\n        return {};\n      }\n  }\n)...\nNot sure if this is the best place to expose this, but just spitballing a bit. I'd like to do this in a supported, clean way, but would like to understand the requirements a bit better to see if RR should be calling the function on your behalf, if the promise should be exposed in meta, or what is the best approach. If anyone want to open a PR with idea, that would be welcomed as well. I personally don't have any need for this, so a PR will probably be the faster than waiting for me to do something :)\n. @eyalw andThen is called in the callback to setState. This is inside of the promise fulfillment handler, so it will be called after the fetch successfully returns and the JSON is parsed. \n\nwhat is the props of the component at that instant? \n\nThe prop should be fulfilled\n\nare they already updated with the new fetched data?\n\nyes\n\nwas willReceiveProps already called for the wrapped component or not?\n\nyes\n\nI think what you are getting at here is that it might not work since it's already updated. then by contrast is called before setState and could be used with an identity request, but feels like a crappy workaround:\njsx\nconnect({\n  fetchAccountPs: {\n     method: \"GET\",\n     url: \"/some/url\",\n     then: (value, meta) => {\n        meta.wrappedComponent.onAccountFetched()\n        return {value, meta};\n      }\n  }\n)...\nSo, if we create a new place to do this kind of thing, where would be the best place in here so that to happen? ...or, would then or andThen actually work? It would be nice to leverage them if possible so we don't have a sprinkling of hooks everywhere, so something that uses them as is or extends them would be prefered, but not totally against adding something new if its needed.\n. @eyalw Thanks for bringing this up again and opening the PR. \n@yarinm, the change in https://github.com/heroku/react-refetch/pull/128 should allow for an empty return.\n. > is there anything limiting us from passing this into the function and simply call stuff on it in the andThen?\nI don't believe there is (didn't try it), but @eyalw 's proposal in #139 has the nice property of also working in cases where you aren't calling a fetch function.\n. This was lifted directly from react-redux during the fork. I would not be opposed to updating this, but would like to do so in a backward compatible way. It would also be nice if it could continue to work the same way as react-redux (perhaps two PRs are needed?) \n. Related: is there any good reason react-redux requires withRef: true be set explicitly? Would it hurt anything to just make the ref always available?\n. We currently don't keep a tally of in-flight promises, so I'd rather just maintain our own _isMounted property (since isMounted() is going away) and skip setting the state when the promise is settled. Even the cancelable promise Facebook recommends is not really cancelling anything, but rather just ignoring the result, so not too different and would require more bookkeepping.\n. Fixed by #87\n. @neezer This is expected behavior. It was a bit of a judgement call during implementation of identity requests to make them either A) skip pending or B) act like any other request and go through the full lifecycle. I went with B for consistency; however, I would not be too opposed to changing this. I do see the value of your use case. Going to leave this open for comments from others that were involved in the original PR:\n1. Is there good (real world) reason to have the identity request go through the pending state? (i.e. keep behavior we have today)\n2. What would you expect to happen? Skip pending of go through pending?\n3. Would there be any reason to make this configurable?\ncc: @jsullivan @hburrows @georgebonnr @ashtuchkin @hnordt\n. Released in https://github.com/heroku/react-refetch/releases/tag/v0.7.0-beta.3\n. > ..but I'm not the deciding vote. :wink:\nGiving people til EOD and then I'm merging this sucker :)\n. Definitely sounds like a bug. The presence of a body should not affect the the post-processing. However I tried a quick unit test, but could not reproduce. Perhaps I'm missing something, but in the meantime, could you see if catch/andCatch work? If they do, is there an error returned?\n. @neezer Ok, so probably a problem with the JSON parser blowing up and rejecting the promise. What version of whatwg-fetch are you using? Either way, we can handle it in RR, but it wondering why my unit test didn't fail...\n. Hmm, same as me. I can dig in more later. Guessing the problem is in https://github.com/heroku/react-refetch/blob/master/src/components/connect.js#L105-L112 if someone wants to experiment\n. @neezer Thanks for the pull! \nI rather not base this on Content-Type because 1) it's common for 204 responses to still set Content-Type: application/json as a default header and 2) requiring Content-Type: application/json could be a breaking change. I was going to suggest that you key off of Content-Length: 0, but that does not work for Transfer-Encoding: chunked. I think there are two options here:\n1. Special case the 204 status and do not attempt to parse the body. This should be fine according to the HTTP spec.\n2. Always try to parse the body with an error handler for this case. This feels messy and error prone.\nSince it's possible for other statuses to have empty bodies, it would probably be good to also check for Content-Length: 0. Together (response.status === 204 || response.headers.get('content-length') === 0), these should account for most cases and is non-breaking. I'd like to change how a lot of the media type handling works to support more then just JSON, and at that point, we could probably re-think how some of this works and be stricter about Content-Type.\n. :+1: Thanks!\n. Released: https://github.com/heroku/react-refetch/releases/tag/v0.7.0-beta.4\n. I don't see a reason why we couldn't do this and feels like the right thing to do. There could be a limitation on the context actually being populated in the HOC, but I haven't tried. Would anyone like to test that and submit a PR?\n. Hopefully the static hoisting will take care of that.\n. This is ES6 object literal property value shorthand:\nhttp://ariya.ofilabs.com/2013/02/es6-and-object-literal-property-value-shorthand.html\n. Fixed by #47. Sorry about the trouble here!\n. Sorry, and thanks!\n. Originally, I was pretty opposed to having something like this, but I'm starting to warm up the idea especially as since there's conflicting ideas around how pre and post processing should work and having more flexibility for isomorphic fetch and other fetch implementions. How are you imagining the you'd configure something like this? Some kind of fetch-provider you'd pass in as an argument to connect()?\n. FWIW, there is actually is an options hash, but it is currently only used for withRef and I'm probably going to drop that (just make it always available). \nI kind of like that last option. I'm really liking the chainability of connect.withFetch, and thinking that it could be used for other options as well in the future.\nSide note, this could also help with improving testability because fetch could be dependency injected. From my dabblings with getting isomorphic fetch to work, I think the hardest thing here is going to getting the tests to work because of weirdness with global objects. That stuff needs to be cleaned up anyway, and maybe this is a good opportunity to do that.\n@passcod Would you be interested drafting a PR for this?\n. @passcod Cool, and feel free to open the PR sooner than later and add the \"WIP/DO NOT MERGE\" label if you want feedback before you get too far.\n. Closed by #76 and release in v1.0.0-beta.0\n. @passcod Looking good so far! I just tested it out on our internal project that uses RR, and it worked without modification and I tried a simple wrapper for a connect and it worked. Left a few minor comments, but otherwise, this is looking good. Can you also add an example into the readme about this? Perhaps also something about what apps should or should not do in their custom fetch?\n. Now that we have a nice way to chain options onto connect, we could add nicer ways to set defaults and post-processing to avoid conflicts with the built-in JSON processing. As I've mentioned before, I'd really like to have declarative ways to set those kinds of things, but perhaps this can be the lower level option and then there's a higher level declarative thing later on. Either way, I think the way it is now still adds value, and more can be added later (i.e. don't add it to this PR :smile:)\n. > mentioning these caveats there is probably a good idea, right?\nYes, and probably something like \"This is an advanced feature. Use existing declarative functionality wherever possible, but this is provided as a way to control the fetch implementation when necessary. Please be aware that changing the fetch implementation could conflict with built-in current or future functionality.\"\n. @nfcampos I understand what you're saying, but wha about cases where you only want to replace the pre or post processing? That means you'd be forced to re-write half the default implementation (even though it is only one line). What would you think of having these as three separate options (i.e. withBuildRequest, withFetch, withHandleResponse)?\n. Yes, except handleResponse is Response -> Promise since the standard onFulfillment and onRejection handlers would still need to be chained after whatever is overridden. \n. > Do we want to do this in this PR or in another one as follow up?\nYour choice. I don't want to cut a release until they are all in, but your choice on how to break up the PRs.\n. Also, what do you think of the names withBuildRequest and withHandleResponse? They feel slightly clunky to me. Anyone have more concise names to express what these do?\n. We should also consider how assignDefaults plays in with all this. That happens during mapping coercion, but would probably would want to be updated with (or instead of) the request builder. I don't really want to expand the scope too much here, but something we should consider before releasing this.\n. > withPre, withPost? too cryptic?\nYes, pre-what? post-what?\n. > assignDefaults should just be part of the default buildRequest no?\nIt's probably doing too much now. The request-specific parts (headers, method, credentials, redirect) of it probably should be moved into buildRequest, and comparison and meta should be in coerceMapping. \n. Not, sure I really like them as nouns. Sounds like they take objects (and it's withFetch, not withFetcher). Probably just go back to the original withBuildRequest, withFetch, withHandleResponse. Slightly clunky, but they are the clearest. Good we talked through options though\n. > I'm going to take a break and come back to this later today. As a side note, I won't be able to work on this from Thursday until Monday or Tuesday due to surgery so if I don't respond during that period that's why ;)\nSounds good. Good luck on the surgery!\n. I've been thinking about the assignDefaults problem. In actual use, when\nI have wanted to have common default for all mappings, I would just want to\nbe working with the mapping objects, not building out the full request.\nAlso, I was setting things like comparison, which would be outside the\nrequest itself. Not exactly sure what the answer is, but the way we are\nplanning to do buildRequest would both be making me do too much and not\ngiving me enough control. Thoughts?\n. > for defaults would it be enough to just provide a withDefaults() method ...\nYes, I think that's how it should work, but the question is should it happen inside of buildRequest or before it? I'm thinking before it.\n\nare four customisation hooks too much?\n\nPerhaps. I was thinking about this, and realizing that many times they will be used in together. For example, if you want to fetch a CSV file, you'll probably override defaults and have a custom response handler, or if you want to pull from offline storage, you'd override fetch and probably the other handlers. Because of this, perhaps, we should still think of them as separate, but part of something more cohesive (like a \"profile\" or something of related options). Perhaps just going back to treating them as an object like connect.with({withRef: true, fetch: fetch}) would achieve this. The other reason I like it as an object is that these could be attributes pushed down into the mapping (and we just happen to be allowing them to be set at the connect level here). See https://github.com/heroku/react-refetch/issues/40#issuecomment-172949423 for some of my previous thoughts on this and why I was hesitant to go this route. I don't want to change to course here too much on this PR, but we should think about how these can also be set at the individual mapping level, and that might inform us to treat them as  attributes in an object.\n. @passcod We could, but that would more methods for every option. I could be getting ahead of myself here, but I'm thinking is something like this where buildRequest, fetch, and handleResponse are just options in the mappings like everything else AND any option in the mapping can be set in a default. Something like this (notice the connect-level and mapping-level handleResponses):\njsx\nconnect.defaults({\n  buildRequest: ...,\n  fetch: ...,\n  handleResponse: ...,\n  refreshing: true,\n  headers: {\n    'Custom-Header': 'true'\n  }\n})(({ params: { userId } }) => ({\n    userFetch:    `/users/${userId}`,\n    userLikesFetch: {\n      url: `/users/${userId}/likes`,\n      handleResponse: ...\n    }\n}))(Profile)\nThis example looks a bit ugly, but if these things were extracted out, I think the overall API works and is quite nice. Again, I could be getting ahead of myself here and blowing out the scope of this PR (sorry!), but I at least wanted to get your thoughts on this, and if we like it, can iterate toward it.\n. @nfcampos ha, I think we're saying the same thing in https://github.com/heroku/react-refetch/pull/76#issuecomment-194539138 and https://github.com/heroku/react-refetch/pull/76#issuecomment-194542891 :) Good timing on our comments too!\n. oops, had a an extra . in my example. fixed it up\n. @nfcampos In mine, I changed the method name from with to defaults. Seemed clearer to me. Like that change?\nAlso, are you on board with the proposal overall? It sounds like you are...\n. Glad to hear it went well!\nYes, I'm thinking everything should be able to be set at both the connect and mapping levels. Some of them probably don't make much sense as defaults, but I'd rather not special case anything if possible. \nI like the idea of a base URL too! That is especially helpful with isomorphic fetch because it requires absolute URLs on the server side. Yes, probably a separate PR. \n. @passcod Just wanted to check in on this PR. Looks like you added some commits, so guessing you're feeling better :) How close do you think this is from being ready for review and merge?\n. @passcod SGTM\n. @passcod Love the checklist! Looking forward to it. Let me know if I can help with anything.\n. > I know it's a bit of a shitty feeling, but this PR has taken literally 20 times more time than I originally planned for\nI hear you. Let's get this merged sooner than later, and we can follow up with additional PRs as needed. (and a big thank you for your work on this!)\n\nFigure out what to do about force and comparison (does it even make sense to set them in defaults.\n\nI definitely would use comparison as a default. In fact, I have a pattern that I use that is a data context container around other components that silently refreshes on changes to the path (i.e. { comparison: location.pathname, refreshing: true }). It's a really nice way of do local caching. I should probably write it up somewhere outside of this PR.\n. Looking really good overall. Mostly just small documentation things. I do think that everything should be available in both defaults and mappings, but that is something we can work on in the future.\nI'm going to test this out on our internal app and let you know how it goes. If everything is good, I think we should pull this in very soon.\n. Ugh, I realized that my use of comparison in defaults won't work because I don't have access to the props. I guess i could use the global location.pathname, but a better future fix would be to support comparison as a function.\n. I tested it out on the internal app, and it worked great for the most part. The big problems were the Uncaught TypeError: Illegal invocation and lack of header merging. Let's get those fixed and bring this in.\ncc: @jsullivan \n. @passcod Good to go? You're probably itching to get this merger more than I am :)) Just tell me when and I'll press the big green button. \n. :boom: : :tada: :shipit: \n. Release in v1.0.0-beta.0\n. Wow, this ended up (directly and indirectly) closing 7 issues! Nice work @passcod!\n. Damn, that's what I get for hand writting these examples :-/ Thanks!\n. I'm not completely opposed to it, but wanted these methods to mirror their Promise counterparts. It also provides nice symmetry with array spread syntax:\nconst [a, b] = PromiseState.all([aFetch, bFetch])\n\nthese two functions taking as an argument an iterable but the current implementations only allow for providing arrays\n\nGood catch! That's what I get for copying the Promise API doc :)\n. Broke out the iterable bug in https://github.com/heroku/react-refetch/issues/79.\nGoing to mark this as \"discussion\" if other people have thoughts, but at this point, I'm slightly opposed to allowing separate parameters.\n. > maybe it's not worth it\nClosing this for now. Re-open if there's still a reason to do this.\n. Thanks! Hmm, not sure what's up with watch (i don't use it on this project)...\n. Added in #85 \n. Released in v0.7.1\n. We need to add documentation about which polyfills are needed. See https://kangax.github.io/compat-table/es6/#test-Object_static_methods_Object.assign, but I personally use babel-polyfill in my projects. \n. That _extends is from the transcompilation during the build process. What you are seeing on Line 189 in the transcompiled source is coming from https://github.com/heroku/react-refetch/blob/877e8d5fab391e984c08fd20d5b18d94cdaad276/src/components/connect.js#L141-L144 in the original source. All other uses of Object.assign are in the original source itself. \n\nAnd do you plan on shipping react-refetch already polyfilled in the future ?\n\nNo, I was not planning on it. My thinking was that I wanted to give people the option of what polyfills to use and not conflict with other polyfills. Similar to the direction we want to take with allowing you to bring your own fetch implementation. My aim is not to introduce pain for developers, so if bundling in an custom assign function would make it better, I'm not fundamentally opposed to it, it just felt unnecessary. @passcod had originally done that in https://github.com/heroku/react-refetch/pull/76 and I had him revert it, but I'd like to hear more thoughts on this (partiularly what is done in other JS projects -- TBH, I don't use JS very much outside of this project)\n. Ugh, we should probably be using mapping.hasOwnProperty('value') instead. I can try to get a fix out for you.\n. Fix is at https://github.com/heroku/react-refetch/pull/84\n. Released in v0.7.1\n. Released in v0.7.1\n. Looks good! Can you update the API doc and maybe an example in the readme?\n. > As for the example, any example with context gets kind of verbose (defining all those contextTypes, etc.), which might be too much for the readme, no?\nYeah, perhaps. I'll merge this now and then we can add more to the readme if it adds value.\nThanks for working on this @nfcampos !\n. Released in https://github.com/heroku/react-refetch/releases/tag/v0.8.0-beta.0\n. @nfcampos I think you're updating the docs on the wrong branch...\n. I already merged the unmounted changes into master, but GitHub isn't closing this automatically because I rebased. Closing manually.\n@nfcampos Thanks for fixing this! \n. @nfcampos Just tested this on an internal app that was running into #62 when components were being rapidly mounted/unmounted and it works great now. Thanks! cc: @jsullivan \n. Yes, we should.\nOn Wednesday, March 16, 2016, Nuno Campos notifications@github.com wrote:\n\n@ryanbrainard https://github.com/ryanbrainard glad to hear it works!\nunrelated: should we add this eslint rule to warn about the curly braces?\nhttp://eslint.org/docs/rules/curly\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly or view it on GitHub\nhttps://github.com/heroku/react-refetch/pull/87#issuecomment-197494828\n. Released in https://github.com/heroku/react-refetch/releases/tag/v0.8.0-beta.0\n. It's probably not being cached per se, but not firing the request again because the URL and data didn't change. Try adding force: true into your request and it should work. Alternatively, you can use comparison: if you want finer-grained control when it fires again. \n\nRe-open this issue if you're still having problems.\n. Looks good other than two simple little style nitpicks. \nOnce #76 is pulled in, we might want to add some explanation explaining why you would set defaults in connect.default vs context, but we can do that later.\n. > The reason for doing it via context is basically so that it can change dynamically, right?\nDynamically and/or more locally (depending on how global your defaults are). \n\nI can add that note now if you want.\n\nLet's hold off. I'm going to pull this in now, and push a release so that #76 will have its own beta.\n. Yep, for sure. I like this use of context for defaults as you've shown.\nReleased: https://github.com/heroku/react-refetch/releases/tag/v0.8.0\n. The data source should probably just be dummy data from the server as part of the example. It would be nice if the whole thing was self-contained and could be deployed as an Heroku app via a Heroku  Button.\n. Yeah, make sure they are functions (or undefined). Any reason not to?\n. > this would be a breaking change\nWe're incrementing to 1.0.0, so let's do as part of that\n. > how do you feel about moving the type check definitions to a separate file\n+1. We should probably go through and do some overall housekeeping.\n. > pure option like react-redux. .. Any reason why you didn't bring that over when you forked \nI think I left it out for immediate simplicity with the intention of adding it back, but never did.\n. Closed by #96\n. I need to think about this a bit more, but some initial thoughts:\n- can dependentProps be worked into comparison and/or value somehow? If possible, I'd like to have this based on identity requests. Perhaps value could take a Promise and do things like this.\n- I've considered breaking out PromiseState into a separate npm module. Perhaps that would help if we a separate module for this kind of thing.\n. @nfcampos Good point. Need to think on that.\n. @nfcampos is your previous comment still valid?\n\nI realised now that for this to be useful value has to be a function that returns a promise, instead of a promise\n\nAre you saying your would like this as is or wrapped in a function?\n. Yeah, I think that makes sense, is simpler, and more consistent. Pulling this in.\n. >  I think this optimisation should apply only to componentWillReceiveProps \u2014 ie. whether to call refetchDataFromProps or not \u2014 and not do anything on shouldComponentUpdate \u2014 ie. whether to rerender the component or not.\nI'm not sure I 100% agree (mostly because I haven't thought about it enough), but I think that confining it to componentWillReceiveProps is a great start and nicely limits the scope of this PR. Mind rebase/merging with master and then we can pull this in?\n. Released in v1.0.0-beta.2. Thanks @nfcampos !\nNote, when I was testing this out, my app was still using React Router 1.0, so the router stuff was in props and my components where directly connected to the router, so that meant the optimization didn't actually do anything since props were always changing. Upgrading to 2.0 would probably help since things would move to context (of course unless context was also being used by connect), but it does show the need to potentially add a layer between the connected component and the outside world to only pass in the props that are actually needed. onlyupdateforkeys could also probably help here. Because if someone really needs this optimization, they would probably need to also use onlyupdateforkeys, I question its need a little bit (and hope it doesn't introduce subtle bugs), but I think it is probably the right thing to do, so pulled it in and let's see how it does in beta.\n. Interesting point about children. One thing we could do is to base equality on the children's keys, as suggested in https://stackoverflow.com/questions/28784050/react-how-to-compare-current-props-children-with-new-one. I did a bit of googling, but was kind of surprised this isn't a problem more people have run into. I would have expected that React would have an out of the box util for comparing nodes. Do you know of something?\n\ncases above make this more primitive optimisation worth it\n\nIf we did something like this, are you thinking something that would go into defaults? \nSide note: This does make me question again a bit of we should be stuffing connect-level only things inside of defaults. I know we just did work to merge options into defaults, and I think that was the right move for all the things that can actually be in connect or mappings, but for things that are truly only for connect, I wonder if it could be confusing (both for apps and internal use). Thoughts on this?\n. Agree on all points. \nYou're right, children should be opaque to connect -- let's just omit it by default. If there's a legitimate case, maybe we can have some option to consider it.\nI also agree on a chainable options for connect-level things things like withRef and maybe an onlyUpdateForKeys-like option. I think splitting options and default will be clearer for everyone. \n. @nfcampos i was hesitant to pull in more deps, but that is probably better to use something like lodash for this and also for shallowEquals rather than maintaining our own. react-redux is also depending on it now, so that definitely makes me feel more comfortable doing it.\n. @nfcampos Sure, have at it :)\n. LGTM! Thanks!\n. This all looks really good! We might want to update the API doc to reflect some of these changes, but I don't want to block on that. Pulling this in now and feel free to send additional PRs for doc changes.\n. Instead of exposing it, it seems like PromiseState.resolve should just call flatten the value implicitly. This would mirror what Promise.resolve does. Ditto for similar methods.\n. Thinking about this a little more, PromiseState.resolve should probably do as I explained above, but only for fulfilled PromiseStates. It would be weird to call PromiseState.resolve(PromiseState.rejected('x')) and expect it to actually be fulfilled -- instead, I think this should throw an error. This does open up room for your original ask. I'll open a PR shortly.\n. You're right. I tested out Promise.resolve(new Promise((resolve, reject) => reject())) when working on #105, but for some reason I remember it nesting the promises. It must have been late, because I just did it again and it works as you explained. I'll change #105 to just return the PromiseState and get rid of #cast since I don't think there's much value in that anymore.\n. Awesome, thanks for fixing this!\n. Released in v1.0.0-beta.3.\n. Good catch!\n. Released in v1.0.0-beta.3.\n. Good call. What if we just implicitly set force: true on then and catch? That should allow us to simplify/remove all that parent business. (I feel like there was a good reason I didn't do this before, but can't recall now.)\n. mapPropsToRequestsToProps should recalculate the mappings and set force to\nfalse (unless actually true) again. I'll need to confirm and test things\nout, but I think it should work.\nOn Saturday, April 9, 2016, Nuno Campos notifications@github.com wrote:\n\nhmm... but if we set force: true on then and catch doesn't that mean that\nany request with a then will be refetched every time\nmapPropsToRequestsToProps is called? That sounds wasteful, and surprising\nto the user, no?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly or view it on GitHub\nhttps://github.com/heroku/react-refetch/issues/102#issuecomment-207768874\n. Awesome, thanks for doing this. Looks good, but API doc needs updating :)\n. Awesome work, bringing this in.\n. Released in v1.0.0-beta.3.\n. Released in v1.0.0-beta.3.\n. Thanks for fixing this! \n. Released: https://github.com/heroku/react-refetch/releases/tag/v1.0.0-beta.4\n. Yes, I think that makes sense. If not, there could be some subtle bugs where the someone is depending on children, but it doesn't actually update on change. I'd rather have it fail fast. I'm guessing you'd do that in https://github.com/nfcampos/react-refetch/blob/master/src/components/connect.js#L214?\n. Sorry, which shouldComponentUpdate thing?\n. Ah, yes, sure.\n. Yes, we should default to pure: true, but allow apps to override with pure: false.\n. > should the pure option also control the componentWillReceiveProps optimisation? \n\nYes, I think so. I'd like to limit the options and if something is impure, let's consider the whole thing impure. \n. Looks good. I'll wait for the remaining bits and then merge.\n. Thank you!\n. Hmm, good point. It's a bit unclear what the order would be if we did support it. I agree, let's block it until there is a good reason to support both.\n. > In a way you can already do it, I guess you just have to define the andThen hook on the then mapping, instead of the original\nyeah, if someone really needs it, they can do it explicitly like that.\n. I like the way the returned Promise cleans things up internally, but it's a little strange how this is only helpful for functional mappings, and I fear that will expose too much of the internals. For #58, it seems like we need more universal and opaque hooks. I'd be ok with using the Promise internally, but not so sure about actually returning it to the app.\n. If we're on the fence on this, what about just omitting the final return? That way we pull in the refactorings to use Promise, but without changing the API. Think it is worth it?\n\nI actually think the existing hooks are enough if we allow returning undefined for when you need to use them for side effects\n\nThat is probably a good idea anyway. \n. Due to lack of recent activity on this PR, I'm closing it. If this is something still requested, please open a new PR.. Thanks!\n. Interesting idea. I wouldn't like to special case PATCH, but perhaps there could be a function that you could provide to set value from the existing value. Something like this (not sure what it should be called though):\njs\nconnect(({params}) => ({\n  project: `/project/${params.id}`,\n  save: (name) => ({\n    project: { \n      url: `/project/${params.id}`,\n      method: 'PATCH',\n      optimistic: (value) => {...value, name},\n      refreshing: true,\n      body: {name}\n    }\n  })\n}))(ProjectPage)\nThoughts?\n. Perhaps we should change to this style:\nhttps://github.com/reactjs/react-redux/blob/master/src/index.js\nI can test it out and push up a branch\n. Are you calling this.props.moreThings(nextPageToken) in your component? It looks like that should work.\nWith that said, I might recommend passing in the page token in from props (instead of using a function) by changing the URL in the browser. It's up to you and your situation, but I find holding that state in the URL and passing it down through props can be nice for bookmarking and sharing links. \n. Ah, I see what you're trying to do now. Yes, it would get replaced. See my comment at https://github.com/heroku/react-refetch/issues/113#issuecomment-211615973 that would also help in this case. A workaround would probably be to store the value in an external variable and then do a transformation (in a 'then' handler) to append to the previous value. \n. You might be able to use a combination of https://github.com/heroku/react-refetch/pull/122 and the then suggestion above for this. Please try it out and let me know if that works for you. Closing this for now.\n. The problem with this is that it would then break JSON parsing for errors that are actually in JSON, which is really the how the error should be formatted. This handler should probably be improved to be more flexible for cases like this, but this change would not be backward compatible. If you want to use this implementation for your own app, you can set it as a custom handler like so:\njsx\nconst customConnect = connect.defaults({\n  handleResponse: function handleResponse(response) {\n    ...\n  }\n})\nThen use customConnect as you would connect. See https://github.com/heroku/react-refetch#setting-defaults-and-hooking-into-internal-processing for details.\n. What about making it where then is only applied if it is different from the parent's then? I can't think of a good recursive case, but if there is one, apps could always re-create the function by using Function.prototype.bind() (kind of hacky, but maybe ok for such a corner case?). I'll poke around the code to see if this will work...\n. Fixed by #123 \n. Included in #123\n. @jsullivan thanks for handling this while I was out.\n@nfcampos looks good! \ud83d\udc4d \n. \ud83d\udc4d \n. Yes, that is what it would do. I had more complicated logic that involved comparing defaults.then and parent.then, but I realized you would probably never want to inherit these from parent. If someone really wants to use the same then in some kind of recursive scenario, they can always explicitly do so in the mapping itself. I also like this because while it is still special cased, at least it is like the existing things for mappings with a parent.\n. Thanks!\n. Since this is a test-only change, not planning on doing a special release for it.\n. Hmm...yeah, I think that'll work. Might need to think on it. Also, maybe parent should always be the top-level mapping as to work in cases with multi-level chains?\n. Seems like that should work\n. Thanks!\n. I can't remember offhand what it was, but I was also running into some kind of problem with these not being able to be undefined. I think we should allow it. \n. Hmm, good question. undefined does not make sense for some of them where a value is required (e.g. method). I guess we could make undefined assign the default in those cases, but I just don't want it to be too magical. I think we should do whatever is the most consistent for the user. I'm a bit on the fence, but I think we should just do it for these 4 for now and consider doing the others later if it makes sense. Do you have any opinions on it?\n. Ah, good call! Thanks\n. Looks like the test needs to be updated.\n. Thanks!\n. @nfcampos oh, sure, sorry I didn't already\n. @nfcampos Released https://github.com/heroku/react-refetch/releases/tag/v1.0.0-beta.8\n. Yes, I think that probably makes sense to emit a warning in that case. \nThere was recent work (https://github.com/heroku/react-refetch/pull/128) on changing how undefined is handled for response transformations. I don't think that would have caused this, but might be worth try out the previous version (v1.0.0-beta.7) to see if that fixes the issues. What version were you using?\n. Thanks!\n. See #132 \n. Fixed by https://github.com/heroku/react-refetch/pull/133\n. What do you think about doing like https://github.com/reactjs/react-redux/pull/213 instead? \n. I'm not too opinionated about it, but since this was originally forked from react-redux (and sometimes used along side it), I like it keep things like this more or less the same.\n. That would be great :)\n. Thanks! \n. Released: https://github.com/heroku/react-refetch/releases/tag/v1.0.0-beta.9\n. Good catch. I think this got missed in a refactoring. Looks like _mapFlatMapValue could be completely inlined now.\n. Thanks!\n. The response will not be immediately available because it is async. Instead, you need to do your logging inside render() and it should be populated on the next render that is triggered. Note, it should be console.log(this.props.postTaskResponse). \n. Closing this unless it is still an issue.\n. I just did a quick unit test for this, but it's working for me. Can you provide details about the exact response headers and body, and also what lib you are using for fetch?\n. Sorry for the delay. I'm pretty sure this has to do with both of these responses being non-JSON. See https://github.com/heroku/react-refetch/blob/master/src/utils/handleResponse.js#L8 where the pasrsing happens and the associated TODO. Can you have your server always return a well-formed JSON response, even for a 404? I really don't want to special case 404 in RR, but if you want to tackle supporting other content types, I'd welcome PRs.\n. Cool, that works too! :)\n. Thanks for opening this. Would you also be able to add a test (there's probably an existing one that can be easily modified), add it to the API doc, and perhaps add an example?\n. Thanks @eyalw !\n. I was just doing a quick test of this in a real app and got:\nInvariant Violation: addComponentAsRefTo(...): Only a ReactOwner can have refs. You might be adding a ref to a component that was not created inside a component's `render` method, or you have multiple copies of React loaded\nI haven't taken the time to dig in, but just wanted to check with @eyalw if you had this happen when using connect.options({ withRef: true })\n. @eyalw Oh, yes, sorry, I can cut a release\n. Released: https://github.com/heroku/react-refetch/releases/tag/v1.0.0-beta.9\n. Would you be able to instead put the presentation state in an anchor/hash in the URL and pass it down as props?\n. Due to lack of recent activity on this PR, I'm closing it. If this is something still requested, please open a new PR.. According to https://github.com/github/fetch/issues/241, Chrome and Firefox should theortically convert the 304 into a 200. What browser and fetch implementation are you using? We should probably also expose the cache option for fetch.\n. I see, it would be best to fix it by using a fetch impl that does the right thing, but if it's a simple fix in react-refetch to handle the status correctly, I'd be open to a pull request. However, I think the tricky part is going to be retrieving the cached body -- does your fetch handle that?\n. @nfcampos you did a lot of the work on shallow comparisons. See anything this would break? Either way, some tests should be added.\n. Good point.\nOn Friday, August 5, 2016, Nuno Campos notifications@github.com wrote:\n\nseems fine other than my comment\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/heroku/react-refetch/pull/143#issuecomment-237803250,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AA7AbMYwbCxlokRglItnB8J3XFAhVSJYks5qcv-_gaJpZM4JbFr1\n.\n. Thanks!\n. Released: https://github.com/heroku/react-refetch/releases/tag/v1.0.0-beta.9\n. Good question. What I have done in situations like this is to have only the CustomerWrapper be connected to RR, and then pass down customer and updateCustomer to CustomerDetailsEdit via context. Something like this:\n\n``` jsx\nclass CustomerWrapper extends Component {\n  static childContextTypes = {\n    customer: PropTypes.instanceOf(PromiseState).isRequired,\n    updateCustomer: PropTypes.func.isRequired,\n  }\ngetChildContext() {\n    return {\n      customer: this.props.customer,\n     updateCustomer: this.props.updateCustomer\n    }\n  }\n}\nconnect(props => ({\n  customer: api/customer/${props.params.id},\n  updateCustomer: customer => ({\n    customer: { method: 'PUT', body: JSON.stringify(customer) }\n  })\n}))(CustomerWrapper)\nclass CustomerDetailsEdit extends Component {\n static contextTypes = {\n    customer: PropTypes.instanceOf(PromiseState).isRequired,\n    updateCustomer: PropTypes.func.isRequired\n  }\n}\n// CustomerDetailsEdit is not connected to RR\n```\nIt would be simpler (and prefered) to pass them down via props, but with wrapper in React Router, context is easier.\nClosing this now, but re-open if you still have questions.\n. Do you know if the underlying Promise is actually rejected? Also, which fetch lib are you using?\n. I recently ran into this myself, and I solved it by setting the lazy response to null with an \"identity request\". For example:\njsx\nexport default connect((props) => ({\n  opResponse: {\n    value: null, // clear results\n  },\n  opRequest: (pkg, service, method, args) => ({\n    opResponse: {\n      url: `${pkg}/${service}/${method}`,\n      method: 'POST',\n      body: JSON.stringify(args),\n    },\n  }),\n}))(MyComponent)\nSo what happens is that when MyComponent first loads, opResponse is fulfilled with a value of null. Then when the opRequest function is called, opResponse goes to pending and fulfilled again, but with an actual value this time. Then the next time something causes the mappings in connect to be recalculated (i.e. a change to props or context), opResponse is set to fulfilled with a value of null again. So your states above would become something like this:\njs\nconst isEmpty = updateFetch && updateFetch.fulfilled && !updateFetch.value\nconst isSaving = updateFetch && updateFetch.pending\nconst isErrored = updateFetch && updateFetch.rejected\nconst isSaved = updateFetch && updateFetch.fulfilled && updateFetch.value\nOf course this does require you to have something cause the props to change, which might work for you, but if you want it to be more explicit, you could also do something like this:\njsx\nexport default connect((props) => ({\n  opResponse: {\n    value: null, // clear results\n  },\n  opRequest: (pkg, service, method, args) => ({\n    opResponse: {\n      url: `${pkg}/${service}/${method}`,\n      method: 'POST',\n      body: JSON.stringify(args),\n    },\n  }),\n  clearOpResponse: () => ({\n    opResponse: {\n      value: null, // clear results\n    },\n  }),\n}))(MyComponent)\nthen you can just call clearOpResponse() and opResponse will be cleared.\nI'd rather not doing anything with the a time delay, but you could get fancy with using the meta.component in then() on the response (see docs) if you wanted to call something in your component so handle this in a more custom way.'\nPlease let me know if you think this value: null works for you. I've personally found it better to have the PromiseState itself always exist, but have the internal value be null rather than having to deal with ever having a null/undefined PromiseState. When @Soul-Burn originally opened this issue, I don't think identity requests (i.e. this ability to set the value directly) existed. I'm going to close this for now because I think this solves it, but feel free to re-open if you think there should be more consideration.. This is likely an issue with your fetch library. Can you try it directly without refetch and see if it works?\n. Ah, makes sense (kind of). Since this is still probably fetch library dependent, I'm hesitant to document it, but perhaps a note in the docs would help someone else not run into this same issue. \n. Just bumped the version to 1.0.0 and slapped on the fancy new logo.\nhttps://github.com/heroku/react-refetch/releases/tag/v1.0.0. Good catch! I can put together a quick fix\n. Released: https://github.com/heroku/react-refetch/releases/tag/v1.0.0-beta.10\n. See https://github.com/heroku/react-refetch/pull/190. Released in 1.0.4: https://github.com/heroku/react-refetch/releases/tag/v1.0.4. Travis is failing on this rule. Are you sure its correct?. @alfonsomunozpomer Since you are composing the two PromiseStates in the end, it is probably better to use then instead of andThen. There are a few different ways you could do this, but probably best to do something like this with nested thens and combining the two with as an identity request by setting the final value to an array of the two:\njsx\nexport default connect(props => ({\n  allFetches: {\n    url: `/json/experiments/${props.experimentAccession}/info`,\n    then: experimentInfo => {\n      return {\n        speciesFetch: {\n          url: `/json/species/${experimentInfo.species}`,\n          then: species => {\n            return {\n              value: [experimentInfo, species]\n            }\n          }\n        }\n      }\n    }\n  }\n}))(GBLFetcher)\nIf you need access to experimentInfoFetch before speciesFetch completes (which should be the only time you need andThen), an alternative would be to create a dummy pending PromiseState if speciesFetch is undefined:\njsx\nconst allFetches = PromiseState.all([experimentInfoFetch, speciesFetch || PromiseState.create()]);\nor a resolve/fulfilled PromiseState with a null value:\njsx\nconst allFetches = PromiseState.all([experimentInfoFetch, speciesFetch || PromiseState.resolve(null)]);. I agree it would be nice, but wondering if it would be better done in userspace with a function that wraps your mappings instead:\njs\nstatic transform(mapPropsToRequestsToProps) {\n  return (props, context) => {\n    const mappings = mapPropsToRequestsToProps(props, context)\n    // manipulate mappings with context here\n    return mappings\n  }\n}\nYes, you'd have to repeat this in each connect, but would be explicit and at least would be a workaround until if/when a hook is added. Happy to accept PRs if someone's up for it.. Thanks!. Thanks!. I had considered it as some point, but didn't know if there would be interest. I guess there is :) Not sure how soon I'll get it it, but in the meantime you can do import {PromiseState} from 'react-refetch' to just import the PromiseState. While I think it is better probably handle this in the component, I can also see that returning an empty/null/undefined mapping should probably be a no-op instead of an error. Going to think on it a bit, but we could follow the same pattern as then that no-ops on undefined. Would that be an acceptable solution?. I'm pretty sure this is expected behavior internal to any failed network callouts in Chrome, and I'm not sure of a way to override it. For example, just try running this directly with fetch:\nfetch('http://httpstat.us/422')\n\nand you'll get:\n\nCompare that to running it in Node:\n```node\n\nfetch('http://httpstat.us/422')\nPromise {  }\n```\n\nThis all happens before the catch is run and is a side effect (i.e. it does not impact the resulting PromiseState). \nAlso, just a side note: Not sure if you were using a simplified catch just an example for this issue, but (at least in the real world) you should be supplying an alternative URL to fetch from like this:\njsx\nuserFetch: {\n    url: 'http://httpstat.us/422',\n    catch: (err) => {\n      console.warn('there was an error', err)\n      return 'http://httpstat.us/200'\n    },\n  }\nNote, this catch in the URL mappings is different from the semantics of Promise.catch and also different from PromiseState.catch.\nI'm going to close this since I don't think this is an issue with this library, but rather with the browser. Please feel free to re-open if needed.. Correct, but that's really a question for Chrome, not this library. React Refetch is not writing to the console in this case. . Related: http://stackoverflow.com/questions/14337351/can-i-prevent-the-chrome-developer-tools-console-from-logging-image-404-errors. @arbesfeld Thanks for the report. I haven't tried reproducing yet, but sounds plausible in the non-resolving case. Marking as a bug. . The fix from @TacticalCoding has been pre-released in v1.0.1-0. Please try it out! Will cut a patch release if all goes well.. This came up before (can't find where at the moment), but we decided not to add cancellation functionality because the fetch API didn't have something for cancelling and looks like it still doesn't, so we'd really just end up only ignoring responses, which is already in effect what happens when we compare timestamps of the previous state. In other words, the fetch is still performed, but we only keep the response whose request was the started last. Once fetch has a way to cancel, I'd be open to exploring this more, but until then, what we have now is probably sufficient (please re-open if you think otherwise). . @tjokimie Thanks for finding that. I'll re-open this, but no promises on getting to it any time soon :). As mentioned in https://github.com/heroku/react-refetch/issues/57, there is no explicit support for server-side rendering. If you'd like to tackle it and send a PR with any changes or documentation, it would be welcome, but so far we've never needed it, so there is currently no support for it. . Thanks for the fix!. Pre-released in v1.0.1-0.. No official support. It might work, but I have never tried it. From other issues and questions, it sounds like other have at least experimented with it. If you get it working, I'd love to improve the docs or incorporate other changes.. Is this fixed by #172?. Looks like a reasonable change, but looks like there's a test failure. Also, any thoughts on if this function should take any arguments? We can always add that later if a need arises, but just thinking about it. . @nfcampos Can you provide an example of what you're suggesting. If it's possible without changes to the lib, that sounds better, but I'm not totally following your suggestion.. @nfcampos Oh, now I see you did provide an example above in https://github.com/heroku/react-refetch/pull/172#issuecomment-300468745. \nGiven the amount of Object.assign sprinkled in this lib, I'm a little hesitant to change how a lot of that works, but that's probably mostly my own unfamiliarity with the ins and outs of getters, getOwnPropertyDescriptors, and defineProperties. How much work do you see it being to make this change and how risky would it be for backward compatibility?\nGiven that other areas of this library support the raw value or function pattern (like the prop mappings themselves), which probably could have also been done with getters, I'm leaning toward merging this PR as is because it will be familiar. Then later, we could consider also supporting getters, but doing it everywhere, not just headers. Thoughts?. Ok, sounds like that's something to save for a later day, but the way this is now will make headers work the same way other things do, so merging it. . Released in v1.0.1-1 (beta). Released in v1.0.1. Thanks \ud83d\udc4d . You can set value to a Promise instead of setting a URL. Something like this:\njsx\nconnect(props => ({\n  listFetch: {\n    value: api.list()\n  }\n}))(MyComponent)\nYou might also want to consider setting comparison to control when this is refetched.\nSee https://github.com/heroku/react-refetch#identity-requests-static-data--transforming-responses for details.. @ipanasenko I think that would be great!. I think I'm breaking some jsdom best practices here and surely could be improved, but this what I'm doing in setup:\n```js\nimport { jsdom } from 'jsdom'\n// maybe not needed, but i had some scripts (removed) in the head tags that needed to be loaded\nglobal.document = jsdom('<!doctype html>' +\n  '' +\n    '' +\n    '' +\n    '' +\n  ''\n)\nglobal.window = document.defaultView\nglobal.navigator = window.navigator\nglobal.self = window\nwindow.fetch = function () {\n  throw 'DO NOT CALL fetch() FROM TESTS'\n}\nwindow.Request = function () {\n  throw 'DO NOT CALL Request FROM TESTS'\n}\n```. Closing this, but re-open if needed.. @aaronschwartz thanks for adding that!\n@nfcampos I'm thinking we might want to move these type checks to happen at fetch time rather than connect time to avoid this kind of issue and workaround in tests. Perhaps there could be a test mode or something too, but I'd rather avoid that. Just thinking out loud, but would be interested to hear your thoughts.. Released in v1.0.1-2. Sorry for the delay on getting this out.. Released in v1.0.1. Fixed by #181 . Sorry, I didn't get this earlier. I was on leave and this fell under the radar when I returned. This looks good. I'll merge this and put it out in a beta version.. Released in v1.0.2-0. Curious, what is the reason for upgrading these two? What issue is this fixing?. Ok, I'll pull this in and put it out as a patch beta so folks and try it out. Released in https://github.com/heroku/react-refetch/releases/tag/v1.0.3-0. Fixed in https://github.com/heroku/react-refetch/commit/e812392e6e12d47c0d9196342f92720e75cb736c and pre-released in v1.0.3-0. This still needs to be tested, so this is just a pre-release, but wanted to get something out there so folks and kick the tires.. This library only supports JSON data. It's something we'd like to expand to other data type, but only JSON for now.. Ah, you were using buildRequest. Your original issue did not say that. Glad to resolved the issue.. Thanks!. This library does not return Promises, but rather PromiseStates, so things like await are not going to work. Please see the readme for examples.. @jsullivan turns out we were using a super ancient version of npm. I synced it up with what react-redux is using for versions.. I'd rather go a route more like https://github.com/heroku/react-refetch/issues/177 so that you could achieve this just by usingvalueandcomparison`:\njavascript\nexport default connect(props => ({\n  userFetch: {\n    value: MyImperativeApi.fetchUserPromise(props.userId),\n    comparison: props.userId, // or array if multiple arguments needed\n  },\n}))(Profile)\nThis would work now, except that value will eval every time and not respect comparison. The idea in https://github.com/heroku/react-refetch/issues/177 is to only eval value if the comparison changes.\n  . Just updated the example above to actually pass the prop to fetchUserPromise and make it a function. Sorry, I wasn't thinking through it before -- this should make things clearer. I think this will actually be a more flexible and powerful API (and more consistent with what actually exists now).. Thanks for working on this! Looks good at first glance, but will look into the tests and corner cases a little more later.\nSince someone could have theoretically provided a function before, I guess this should be considered a breaking change..\nOh, can you update the API doc and readme for this change too?. @slorber @ipanasenko I just published this as a beta release: react-refetch@2.0.0-0. @ipanasenko I just pushed up some changes to https://github.com/heroku/react-refetch/compare/stage-2.0.0. I updated the docs and tests as I mentioned in my review. If you're happy with them, we could merge them as-is (or of course push any changes you don't like). Then we can do the warnings (if we want them... interested to hear your thoughts) in a separate PR.. I finally dusted this off and added the 'Request object with functional 'value' must also declare 'comparison' invariant to the stage-2.0.0 branch. I'll merge that into master shortly.. Published as beta v2.0.0-3. Published in v2.0.0. This isn't a bad idea, but when I needed something similar, I ended up just making a component to do the fetch the individual record. For example, instead of having a connect in App, add a connect into User:\njs\nrender() {\n  return this.props.users.map(user => (<User userId={user.id} />))\n}\nand then inside User:\njs\nconnect(props => ({\n  userFetch: `/users/${props.userId}`\n}))(User)\nThis isn't really a composition and won't block like PromiseState.all does, but just wanted to throw it out there in case it solves for your use case. I know the conventional wisdom in React is to have data fetching and \"smartness\" be at the top-level and have children be \"dumb\" components, but with the way react-refetch works, I've found it actually better to have fetching happen at the lowest level possible (i.e. just high enough so you're not fetching any shared data twice), so just something to consider. \nWith that said, if you want to submit a PR, I think it could be a nice addition.. Sorry for the horrible delay on this. This came in at a bad time and then I never got back to it. I'm going to close this one on master but merge https://github.com/heroku/react-refetch/pull/198 on stage-2.0.0. Thank you for this change and your patience.. Looks great, but this warning on fbjs scares me a bit:\n\nNote: If you are consuming the code here and you are not also a Facebook project, be prepared for a bad time. APIs may appear or disappear and we may not follow semver strictly, though we will do our best to. This library is being published with our use cases in mind and is not necessarily meant to be consumed by the broader public. In order for us to move fast and ship projects like React and Relay, we've made the decision to not support everybody. We probably won't take your feature requests unless they align with our needs. There will be overlap in functionality here and in other open source projects.\n\nSince we're using so few functions, it might be better to lift out what we need and remove the dep all together?. Look good, thanks!. Published in v2.0.0. Pull requests are welcome :). As I mentioned on https://github.com/heroku/react-refetch/pull/219, I'd be looking for help reviewing @lmontoute 's PR, as I have never used TypeScript.. All the props handling should be done in mapPropsToRequestsToProps, which creates the mapping to be passed to buildRequest. Ideally, buildRequest should be generic enough to deal with any mapping and no longer need the props. If you do want to pass them along for some reason, I'd probably recommend stuffing them in meta, which could then be accessed inside of buildRequest. Would this work? I'm going to close this, as I don't think there's a use case for this, but if there is, please let me know and we can re-open and discuss it.. @dprentis Ah, ok. Yeah, I think how you are going it now makes the most sense. If this is a common need, I could see doing something like configurable pre/post hooks for doing common things like this, but that is essentially what buildRequest/handleResponse is now, so probably fine to keep doing it there. Perhaps exposing the default implementations of buildRequest/handleResponse would help so you could use that instead of re-inventing (or copy/pasing) the wheel in your implementation?. Interesting proposal. I guess this would just work if we always allowed url to be a function. I'm not sure I'd want to pass in the props because they'd be the old values, but at least in your case, a no-arg function would work too. Or do you need the props too?. That code sandbox doesn't seem to be using then or refreshInterval. Your description also doesn't seem to be using then, two clicks. Can you please clarify?. Thanks, definitely some kind of bug there. I haven't gotten a chance to dig into to see exactly what's wrong, but will mark this issue as a bug and will investigate more later (or if someone beats me to it, that's welcome :) ). No, sorry, there is not an API for this as this would break the one-way data flow model. I can see how it would be helpful, but for keeping the lib simple, I think it\u2019s best to manage this in the app. . Sorry, but I'd really rather not add method-specific behavior to the lib. Both for simplicity and backward compatibility.. Try setting force: true in the post request. This is happening because your props aren't changing, so the request isn't being made. force: true overrides this behavior.. The problem is that in that response errors is plural, but the lib is looking for error (or message) singular. You can either change the response or override handleResponse.  to process it as you see fit. Using meta will not give you access to response bodies.. Also, if you do find a nice way to generalize this case of an errors array, feel free to open a PR to change how parse(cause) works. I'm not sure if we should take the first error, map over them, or what, but opening a PR could generate some discussion.. Sorry, but this issue does not ask a clear question. Please provide a simplified example along with a simplified component and properly formatted code.. > Even if the fieldValuesFetch is not returned when text is small, the former fieldValuesFetch remains injected into the component\nWhat do you mean by \"remains injected into the component\"? If I'm understanding correctly, isn't that what you'd want; otherwise, there would be nothing for the component to render. \n\nI think it would be easier to provide an ability to \"skip\" / \"ignore\" a fetch conditionnally.\n\nProbably the easiest thing to do would be to set comparison to something like value.length > 2 && value. This will make it false unless it's longer than 2 characters and will skip fetching (because false === false, not that false is has some special meaning here).. Alternatively, could you just control this with a conditional value. I haven't tried it, but I think this would clear the previous PromiseState, or at least with an undefined value and skip the fetch:\ncomparison: value,\nvalue: value.length < 2 ? undefined : () => searchField(value, ProviderLabel),\nI'd rather not change the internals of the library for this since. Perhaps we could have some utility to help make this easier, but I don't think previously set state should \"automagically\" be cleared.. @tkvw Nice to see someone working on this :)\nhttps://github.com/heroku/react-refetch/issues/214. @lmontoute Awesome, thanks for adding this! I don't know anything about TypeScript, so I'm going to rely on other folks who do. Perhaps @rjhilgefort or @hburrows (hey, long time no see!) could lend a hand?\nAs an aside, we should probably also add Flow types at some point.. Keeping them here seems to make more sense to me. I'm assuming this would be easier on developers using these types so they don't have to depend on somehow https://github.com/DefinitelyTyped/DefinitelyTyped?\nDoes this need a release for people to pick up the changes? I'm guessing so, but wondering if we can get back with just a merge.. @lmontoute thanks again for this! This has been released in 2.0.1. I skipped going through a beta phase since this doesn't impact existing code. \n@hburrows want to give it a spin and see how it goes? . Awesome, thanks @rjhilgefort . @ipanasenko oh, you're right !\ud83e\udd26\u200d\u2642\ufe0f\n@lmontoute (or anyone else who knows TypeScript), is there something we need to change on the build/publish to make this end up in the released artifacts?. I like types too. I'll open a PR for that. I'm a little concerned about how that'll play with Flow types, but we can cross that bridge if/when we need to.. So, I tried this out, and it seemed to not be an either/or thing. I had to add it to files for it to be included in the published artifact (tested with npm pack):\ndiff\ndiff --git a/package.json b/package.json\nindex c81f763..6e7a92a 100644\n--- a/package.json\n+++ b/package.json\n@@ -3,6 +3,7 @@\n   \"version\": \"2.0.1\",\n   \"description\": \"A simple, declarative, and composable way to fetch data for React components.\",\n   \"main\": \"./lib/index.js\",\n+  \"types\": \"./index.d.ts\",\n   \"scripts\": {\n     \"build\": \"babel src --out-dir lib\",\n     \"clean\": \"rimraf lib dist coverage\",\n@@ -17,7 +18,8 @@\n     \"url\": \"https://github.com/heroku/react-refetch.git\"\n   },\n   \"files\": [\n-    \"lib\"\n+    \"lib\",\n+    \"index.d.ts\"\n   ],\n   \"keywords\": [\n     \"react\",\nIs this correct?\nAnother thing I'm wondering about is if the types should go in src next to index.js. That seems better me, but not sure if that's prefered.. Proposed solution in https://github.com/heroku/react-refetch/pull/220. @lmontoute Awesome, thanks for testing that out. I'll get this out as 2.0.2.. If I understand the problem your facing, this is happening because refreshing: true. That will cause the new PromiseState to not overwrite the old one while the refresh is in progress. The doc is below, but it might be easier to understand from the code.\n\nrefreshing (Boolean | Function): If true, the request is treated as a refresh. This is generally only used when overwriting an existing PromiseState and it is desired that the existing value not be cleared or changing into the pending state while the request is in flight. If no previous request was fulfilled, both pending and refreshing will be set. If refreshing is a function \u2014 refreshing: value -> value \u2014 then before the new request starts the value of the existing mapping will be replaced by the return value of this function, which is called with the existing value as its sole argument. This is useful to support optimistic updates with eg. refreshing: value => ({...value, ...body}).\n\nTry instead:\nforce: true,\nrefreshing: false // or just omit this\nand see if that has the behavior you're looking for. I'm going to close this now, but please re-open if you're still having problems.. This is definitely better than object, but the Request docs say:\n\nThe body type can only be a Blob, BufferSource, FormData, URLSearchParams, USVString or ReadableStream type, so for adding a JSON object to the payload you need to stringify that object.\n\nso wondering if we want to list these or just use Any... Thoughts?. I'm going to merge this for now because its better than what we have now and covers the general case. We can always go back and add more types if needed.. Released in v2.0.3. Thanks @raphaelpra !!! \ud83c\udf89 . That sounds reasonable, although it strange that it doesn't include other things like Blob and FormData. \nHere is another I found. They also have BufferSource, which is defined as ArrayBuffer | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array. This one seems a little more complete. . There is nothing to this out of the box, but you could override the fetch implementation to do this. See https://github.com/heroku/react-refetch#on-changing-the-fetch-and-request-implementations. This wouldn't be a bad idea as a default option, but unless there isn't a lot of demand, just overriding like this is probably best.. Thanks for this. While it does make sense, I'm afraid of this potentially breaking existing apps. What do you think about having this as a configured option?. @lmontoute, can you comment on this?. Instead of passing getData() to loadMore(), what if you pass the actual data and then you'd have access to it in the andThen? Something like this:\njs\nonst connections = {\n  widgets: '/api/widget/?limit=20',\n  loadMore: (offset, data) => ({\n    loadingMore: {\n      url: `/api/widget/?limit=20&offset=${offset}`,\n      andThen: (res, meta) => ({\n        widgets: { value: data.widgets.value.concat(res) },\n      }),\n    },\n  }),\n};. Looks like this could be simplified with visibility.onVisible() to improve readability and avoid the if (!visibility.hidden()) { conditional.\n. It's a corner case, but it would probably be good to also check for this.state.mappings[prop] && this.state.mappings[prop].fulfilled so that this does not block the initial load in case the tab is hidden.\n. Ignore what I said previously about moving this into buildRequest(). For #31, I need to break out the defaults from the request building. Once that is done, this can move there (no need to block on that in the meantime though).\n. not sure i like the name of this variable. i'm not really sure what to call it, but this would still be true on initial page load and could also get confusing with the refreshing attribute. Perhaps the clearest would be a more literal hasRefreshInterval\n. spelling\n. spelling\n. can you add a test for refreshHidden: true?\n. shouldn't this be in dependencies?\n. good catch\n. why the extra indentation?\n. @georgebonnr Correct, it will not prevent a function from being called to create value, but it will prevent the PromiseState from being updated with the same value. If you want to memoize the function result, it would need to happen outside of connect() or possibly use comparison to have finer grain control of when the PromiseState is updated, but not sure it would really help much for something just based on a top-level prop. As you mentioned, the typical case inside of then or andThen will stop the function from being called unnecessarily. \n. just realized this return here will block chaining off of an identity request. Not really sure what the use case would be for that, but for consistency, identity requests should still support chaining. need to fix.\n. Merged. Sorry for the delay.\n. I went ahead and made this set the provided meta on the pending PromiseState; however, this is different behavior from the value, which is not set until the PromiseState is fulfilled. I'm not super happy about this, but I think it is the most expected behavior. We can think about setting value up front, but then it's different from regular URL-based requests. Feedback welcome.\ncc: @jsullivan @hburrows \n. See https://github.com/heroku/react-refetch/issues/42\n. note, this change from Any to Object is breaking, but only on the beta channel, so should not require anything special for versioning\n. you could add a /empty here instead of going it in the test. this fixture is all kind of messy (my fault), but at this way its consistent\n. Looks good. I know the tests are a bit verbose. Need to refactor some things. \n\nAlso the error message is not fantastic (buried in the diff provided by toIncludeKeyValues), so that could probably be improved.\n\nWhat do you mean?\n. Oh, weird, I've never seen that. I guess the assertion diff facility is doing that\n. FWIW I just tried running the tests locally with your fix commented, but I see the full object:\n1) React connect should not parse the body if response is a 204:\n     Uncaught Error: expected { fulfilled: false, meta: { request: { _bodyInit: undefined, _bodyText: '', credentials: 'same-origin', headers: { map: { accept: [Object], 'content-type': [Object] } }, method: 'GET', mode: null, referrer: null, url: '/empty' }, response: { _bodyInit: '', _bodyText: '', bodyUsed: true, headers: { map: { 'content-type': [Object] } }, ok: true, status: 204, statusText: undefined, type: 'default', url: '' } }, pending: false, reason: [SyntaxError: Unexpected end of input], refreshing: false, rejected: true, settled: true, value: null } to include { 'fulfilled': true }\n      at Function.assert (node_modules/expect/lib/assert.js:20:9)\n      at setup.js:16:14\n      at Array.forEach (native)\n      at Expectation.toIncludeKeyValues (setup.js:11:27)\n      at Immediate._onImmediate (connect.spec.js:977:48)\n. wonder if we should do just fetch here so that if someone is using isomorphic-fetch, (I think) it will work out of the box.\n. i think we can default this to true or probably even just remove it as an option, unless someone has a good reason you'd want to be able to not have a ref. See https://github.com/heroku/react-refetch/issues/60#issuecomment-187852641\n. also, should we call this fetch const something different to avoid confusion w/ the global fetch?\n. Perhaps add an invariant check before this so the developer gets a better error message in console?\n. what is this achieving over the standard Object.assign?\n. Yeah, I guess browser support isn't as universal as I thought: \nhttps://kangax.github.io/compat-table/es6/#test-Object_static_methods_Object.assign\n. can we move 'whatwg-fetch' from peerDependencies into devDependencies and make a note in the readme (and an invariant in code) to make it the app's responsibility to provide fetch? This should also deliver #11 since app's can just use isomorphic-fetch instead.\n. I'd rather not pull in another dep\n. Related: there are still uses of window.Request. Can this just be Request? Any reason for this to be customizable as well?\n. > about the name I'm not sure, you're right it might be confusing for someone dropping in on the code without context, but would a comment suffice?\nYeah, you're probably right. Leave it as is.\n\nyep just Request should be enough. customising Request sounds like a bad idea since it's the Request object is used internally by fetch, no? I mean, Request is basically an implementation detail of fetch(), so I don't really see anything that could be achieved with a custom Request that you couldn't do by supplying a custom fetch\n\n+1\n. Sounds good. We can do that in a second pass.\n. > We can revert to native Object.assign, as the code was already peppered with calls to it before this PR, though.\nYeah, let's revert to using Object.assign. This lib already expects it. We should just document all the polyfills expected: Object.assign, ES6 promises, fetch\n. I like that we are dropping the options hash here, but I'm slightly worried that that is a breaking change. What do you think about still allowing it in the options hash with something that emits a warning? We can leave it in there for one release and then pull it out.\n. maybe rename this to InnerComponent since it actually doesn't have any props\n. curly braces please :)\n. more curlies \n. This was a peer dependency, but not actually included. I wonder if it would be good to add recommended polyfills for these. Don't block on this. We can always add something later.\n. use case (two words)\n. use case (two words)\n. Customizing handleResponse isn't explained anywhere, is it?\n. this section doesn't really explain how to change the fetch and Request implementations, just warning that it is advanced\n. thanks for doc'ing this. perhaps it should support Headers in the future, but I kept it as simple key-values because everything else was at that point.\n. is it is full override or a merge?\n. similar question above about the use of the word \"amended\". not clear if that is overriding or merging the keys\n. will this be after coercion? in other words, will this function need to handle raw url strings or will mapping always be an object? I'm guess the latter, but I'm purposely reading the docs before looking at the source to have an outsider's mind.\n. window.fetch or just fetch?\n. so nice to see this go away! :boom: \n. perhaps we can use https://www.npmjs.com/package/warning here. (don't block on this. we can do this later)\n. any reason meta is not set in defaults? i realize it seems a bit silly as a default, but also seems strange to special case\n. note to self: re-think this whole parent.comparison thing. there's probably a better way. (future thing, not this PR)\n. no the\n. :heart: \n. whoa, what's this little regex monster doing? ;)\n. This line fails on \u201cUncaught TypeError: Illegal invocation\u201d in Chrome. See http://stackoverflow.com/a/9678166/129492 for why. Changing it to const fetched = defaults.fetch.call(window, request) fixes it, but this probably need to be done in a way that holds onto the reference to window and probably more places than just this.\n. Fine to leave them out for now. \n. what do you think about deep merging w/ defaults.headers here? in my test on a real app, i was just adding a custom header, but that overwrote these default JSON headers. \n. True, but Content-Type and Accept are probably ones you should always set, so could be overridden. \nRelated side note, this is kind of weird:\n```\nnew Headers({foo: undefined}).get('foo')\n\"undefined\"\nnew Headers({foo: null}).get('foo')\n\"null\"\n```\nPerhaps if it is null or undefined we just remove them instead of letting it turned into a string like this. \n. Oh, you might be able to use bind instead of call. I'm guessing that'll be easier to implement. See http://stackoverflow.com/a/34888425/129492\n. s/urlPrefix/URL prefix/\n. s/react-refetch/React Refetch/\n. Still matches /The options argument is deprecated/\n. We might want to merge these all in one list. This is fine for now, but I might take another pass through the docs for #98.\n. yeah, i figured that was the case. i just pulled it in for now and will think about it. maybe how it is is fine.\n. perhaps I'm missing something, but where is _propsDidChange defined?\n. oh, i see, you're defining it here and using it below\n. It does add some complexity (and did confuse me for a minute as you see above), but I guess just leave it in since it's already there and tested.\n. When I was experimenting before with children, I think that this.props.children != nextProps.children might always be true. I probably don't understand the intricacies of when this it changes well enough, but I remember it not being equal when nothing was changing. Also, just wondering about the intention here. It is correct to re-render a parent when the children change?\n. sure, go ahead\n. Yes, but maybe add 'implicitly' into the test description\n. Ah, makes sense. \nThinking about this more, let's pull out the this._propsDidChange to reduce the complexity. It just feels like a bug waiting to happen.\n. perhaps add something to this test to know that then was actually called\n. ...also, this assertion looks wrong. shouldn't it be something like value.deferredFetch.value?\n. this can be removed now, right?\n. doesn't this need a return and inside of setAtomicState as well? (otherwise the return below isn't doing anything)\n. ugh, not sure how that happened... must have deleted it between running tests and committing. fixed\n. I've had this test fail locally with just npm test a few times like this. Were you seeing it consistently?\n. ah, i see the fix below. that should do it\n. This message will be weird if ${types} is an array. Probably need to do some joining.  Also, it might be easier to convert types to an Array before the invariant to avoid having two special cases in here.\n. yeah, it would probably read better that way. (Of course this really isn't super important since it is only something shown in the dev console...)\n. this should probably be done right after line 267 (or something like const meta = Object.assign(meta, {component: this.refs.wrappedInstance}) so that identity requests and regular fetches (i.e. the branches of the if/else) are treated the same in this regard.\n. Good point. I'll add this note after merging. \n. Good point. I'll add this note after merging. \n. I didn't address it here, but was noticing how it's a little weird that meta here is only used if previous is undefined; although, it does act like resolve(value, meta) though. I believe I did that this to simplify some of the logic on the refetch size, but it makes this API a little ambiguous. Don't think it needs to be addressed now, but just calling it out for the future.\n. shouldn't this happen before after()? I'm also not really clear what's going on there with the spy.destroy() below... can you explain what this is doing? it appears that it's just forcing the call the the refreshTimeout._onTimeout, but doesn't seem like that would actually test the code you added.. makes sense. I just tested this (and the other test) with the spy up before after() and without the spy.destroy() and it worked fine. The reason it didn't really matter is that the setImmediate is what triggers the change by yielding to the promise. I'll merge this as is and then fix both of the tests.. test name dupe. this looks like this was an accidential copy/paste of another test. What about changing to fetching a single user with a comparison on the props.userId so it's more obvious when the function is called again?. even though it won't actually change the behavior of the test, consider changing to value: () => { valueSpy() } to better test the function being created inside (like most apps would do), while still having the spy outside (so your test works). ",
    "jsullivan": "I like all of this. Thumbs up from me.\n. Sounds good. After a new release is cut then I'm good with https://github.com/heroku/dogwood-ops/pull/84 getting merged in, too.\n. LGTM.\n. LGTM!\n. LGTM.\n. :+1: \n. @nfcampos I think you're right about andThen and andCatch. I need to give this more thought because I haven't come up with a way to fix this that I'm happy with yet either.\n. LGTM. Want to update the docs before I merge?\n. @nfcampos I'm bringing this in, too. Mind merging or rebasing first?\n. Also, thanks for this and all of your other contributions :heart:. \n. @nfcampos n/m, I don't see any conflicts so I'm going ahead and bringing this in.\n. Hey @nfcampos this looks good to me. I'm going to go ahead and bring in this PR and #121 but did you want to update the docs first?\n. :thumbsup: merging.\n. +1 for promoting beta to 1.0.0 proper. Maybe give it another few days for folks to chime in, though?\n. This LGTM. I'm restarting the Travis build to see if those connection timeouts from the last build self-resolve.. Hm, not sure what's up with Travis.. LGTM! Bring it on in. :). The naming of these makes sense to me, especially given the context that @ryanbrainard says inspired these functions:\nhttp://www.scala-lang.org/files/archive/nightly/docs/library/index.html#scala.concurrent.Future\n. ",
    "moretti": "Whoops, sorry, I didn't realize there was an identical PR.\nIt's essentially equivalent to https://github.com/heroku/react-refetch/pull/7 but uses jsx instead of js.\n. ",
    "thomasloh": "@ryanbrainard yeah exactly. A way to specify common metadata to be coerced into the final canonical request, and should allow overrides as well.\nThe bigger question is probably how/where to do it, because the metadata should only be specified in one place, upfront somewhere. And then is used by all connect(), or selectively via decorators\n. @ryanbrainard oh yeah no definitely don't want to maintain any state there! I should rephrase, it should be defined once somewhere, like you suggested, in a separate module/file, which can then be used by interested connect().\nPersonally I like the idea of preprocessors, because it behaves like middleware and allow composition. Something like,\n``` js\n// requestPreprocessor.js\nconst compose = (...fns) => (reqs, props) => fns.reduce((finalReqs, fn) =>  fn(finalReqs, props), reqs);\nfunction addAuthorizationHeader(reqs, props) {\n}\nfunction addComparison(reqs, props) {\n}\nexport default compose(\n  addAuthorizationHeader,\n  addComparison\n  ...\n)\n```\nCalling it just preprocessor sounds good to me, so like\n``` js\nimport refetchPreprocessor from \"/common/refetch-preprocessor\" // naming of this is in userland of course\nconnect(() => {...}, preprocessor: refetchPreprocessor)\n```\n. ",
    "hnordt": "@ryanbrainard \nI liked your approach, maybe we can support something like enhancers.\nI think it's like the middleware idea from Redux.\nYou provide the common usage, but people can create enhancers.\nFor example, you don't need to handle CSV requests, you can create a enhancer for it. You provide the core, people provide \"uncommon\" things using enhancers.\nUsage\n``` js\nimport myRequestPreprocessor from './myRequestPreprocessor.js';\nimport handleCSV from 'refetch-csv';\nimport { handleJWTRequest, handleJWTResponse } from 'refetch-jwt';\n// if you have many enhancers, and want to use it on many components,\n// just create a request-enhancers.js and/or response-enhancers.js files and \n// export your enhancers as an array\n// second param: request enhancers (accept one enhancer or an array of enhancers)\n// third param: response enhancers (accept one enhancer or an array of enhancers)\nexport default connect(props => ({ foo: 'bar' }), [myRequestPreprocessor, handleJWTRequest], [handleCSV, handleJWTResponse]);\n```\nmyRequestPreprocessor.js\n`` js\n// the returned object is merged into react-refetcht's default request\nconst requestPreprocessor = request => ({\n  url:http://foo.com/api/${request.url}`,\n  headers: {\n    'foo': 'bar'\n  }\n});\nexport default requestPreprocessor;\n```\nrefetch-csv\n``` js\n// the resolved promise should be the final response\nconst handleCSV = (request, response) => {\n  return Promise((resolve, reject) => {\n    if (request.dataType === 'csv') {\n      myCSVParser(response.body)\n        .then(data => resolve(Object.assign({}, response, { body: data })))\n        .catch(error => reject(new Error(error));\n    }\n    resolve(response);\n  });\n};\nexport default handleCSV;\n```\nrefetch-jwt\n`` js\n// if you return nothing, nothing is merged\nconst handleJWTRequest = request => {\n  if (localStorage.token) {\n    return {\n      headers: { Authorization:Token: ${localStorage.token}` }\n    }\n  }\n};\n// of course if we release it as a npm module, we should support a configurable pathname\nconst handleJWTResponse = (request, response) => {\n  return Promise((resolve, reject) => {\n    if (request.pathname === '/auth/login' && response.ok) {\n      localStorage.token = response.body.token;\n    }\n    const UNAUTHORIZED = 401;\n    if ((request.pathname === '/auth/logout' && response.ok) || response.status === UNAUTHORIZED) {\n      localStorage.token = null;\n    }\n    resolve(response);\n  });\n};\nexport default { handleJWTRequest, handleJWTResponse };\n``\n. @ryanbrainard my suggestion on https://github.com/heroku/react-refetch/issues/40#issuecomment-172942228 can handle this.\n. @ryanbrainard I'm just wondering whywhatwg-fetch` is a peerDependency and not a dependency?\n. @ryanbrainard another problem I see is that for some apps, the API URL is different from the app URL.\nFor example, app can be running on http://foo.com but the API is running on http://api.foo.com.\nSpecifying URL for every mapping isn't a good option I think.\nFor some apps we need to work with tokens too.\nMaybe you can install whatwg-fetch as a dependency, but enable us to implement our own version of it.\nFor example:\n``` js\nimport SomeFetchImplementation from 'some-fetch-implementation';\nconst MyOwnFetchImplementation = (method, url, params) => {\n  return SomeFetchImplementation(method, url, params, {\n    Authorization: localStorage.token ? Token: ${localStorage.token} : ''\n  }).then(response => {\n    if (url === '/auth/login') {\n      localStorage.token = response.body.token;\n    }\n    return response.body;\n  }).catch(error => {\n    const UNAUTHORIZED = 401;\n    if (error.status === UNAUTHORIZED) {\n      alert('Session expired');\n      localStorage.token = null;\n    }\n    throw error;\n  });\n};\nReactRefetch.fetch = MyOwnFetchImplementation;\n```\nOr maybe if we just want to specify a global URL:\njs\nRectRefetch.fetch.URL = 'http://api.foo.com';\n. @ryanbrainard agreed. +1 for custom request preprocessor for the other cases I specified\n. @ryanbrainard I don't know if it's good yet, but if you let applications provide their own fetch it open doors for people implementing offline support, we could save requests in IndexedDB, and refetch only if we have an active connection.\n. @nicholaswyoung please share your code so we can improve it together. Better than starting from scratch :D\n. @ryanbrainard my suggestion on https://github.com/heroku/react-refetch/issues/40#issuecomment-172942228 can handle this.\n. @ryanbrainard following my idea I thought a isomorphicRequestEnhancer could be created to handle this:\n``` js\n// enhancedConnect.js\nimport { connect }  from 'react-fetch';\nimport isomorphicRequestEnhancer from 'react-fetch-isomorphic-request-enhancer';\nimport otherRequestEnhancer from '<...>';\nconst enhancedConnect = compose(isomorphicRequestEnhancer, otherRequestEnhancer, connect);\nexport default enhancedConnect;\n```\n. I'll not implement anything yet. We are on the discussing stage.\n. I'll use React Refetch on my projects, then I'll start the experiments with \"HOCing\".\nSoon I'll post my thoughts.\n. @ryanbrainard I found a simple solution, I don't even need to change my code:\n``` jsx\nimport React from 'react';\nimport { connect, PromiseState } from 'react-refetch';\nimport Async from '@hnordt/reax-async';\nimport ProjectPanel from './ProjectPanel.js';\nconst AsyncProjectPanel = Async(ProjectPanel);\nconst Projects = ({\n  projectsFetch,\n  likesFetch\n}) => {\n  const allFetches = PromiseState.all([userFetch, likesFetch]);\n  return (\n    \n  );\n};\nexport default connect(() => ({\n  projectsFetch: '/api/projects.json',\n  likesFetch: '/api/likes.json'\n}))(Projects);\n```\n. I like both ideas. :+1: \nJust one suggestion, instead data:\njs\nconnect(({ name }) => ({\n  barFetch: {\n    url: `/foos/${name}`,\n    query: { foo: verifyFoo(), bar: verifyBar() }\n    transform: ({ foos, page }) => ({ bars: foos, page  }),\n    then: (foo) => `/bar-for-foos-by-id/${foo.id}`\n  }\n}))\n. @ryanbrainard,\nIf you approve the syntax I'll be happy to create a pull request.\n. @ryanbrainard I think transforming data on PromiseState is ok, better than add a new prop.\nAbout query. Sorry, I miss typed the verify part. Another example:\n`` js\nconnect(({ name }) => ({\n  barFetch: {\n    url:/foos/${name}`,\n    query: { foo: 'bar', bar: 'foo' }\n  }\n}))\n// barFetch should request /foos/${name}?foo=bar&bar=foo\n```\nI think objects are better than raw string for query params because we can do things like this:\njs\n{ query: Object.assign({ foo: 'bar' }, { bar: testBar() ? 'foo' : null }) }\n. I would like to suggest something like this:\njs\nconnect(({ name }) => ({\n  barFetch: {\n    url: `/foos/${name}.csv`,\n    dataType: 'csv' // maybe responseType?\n  }\n}))\n@ryanbrainard,\nIf approve this I would like to pull request.\n. @ryanbrainard :+1: for Content-Type.\nPlease look at my enhancers idea: https://github.com/heroku/react-refetch/issues/9#issuecomment-166420907\n. @ryanbrainard my suggestion on https://github.com/heroku/react-refetch/issues/40#issuecomment-172942228 can handle this\n. You can read from PromiseState. It returns fulfiled when finished.\n. @ashtuchkin \nYou don't need to use state, you have two options:\n``` jsx\nclass ProjectEditPage extends React.Component {\n    saveProject() {\n      if (props.project.fulfilled) {\n        this.props.updateProject(props.project.value);\n      }\n    }\n    render() {\n        if (this.props.project.pending)\n            return \n        if (this.props.project.rejected)\n            return \n    return <div>\n         Project name: <input value={this.state.name} onChange={..change this.state.name}/>\n         ....other props...\n         <button onClick={()=>this.saveProject()}>Save project</button>\n    </div>\n}\n\n}\n```\nOr:\n`````` jsx\nclass ProjectEditPage extends React.Component {\n    saveProject() {\n      this.props.updateProject(props.project.value);\n    }\n    render() {\n        if (this.props.project.pending)\n            return \n        if (this.props.project.rejected)\n            return \n    return <div>\n         Project name: <input value={this.state.name} onChange={..change this.state.name}/>\n         ....other props...\n         {props.project.fulfilled && <button onClick={()=>this.saveProject()}>Save project</button>}\n    </div>\n}\n\n}\n```jsx\n``````\n. @ashtuchkin \nHere is my idea:\njsx\n@connect(({ id }) => ({\n  project: `/api/projects/${id}`,\n  updateProject: data => ({\n    project: { url: `/api/projects/${id}`, method: 'PATCH', body: data }\n  })\n}))\nclass ProjectEditPage extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      project: null,\n      projectUpdated: null\n    };\n  }\n  componentWillReceiveProps(nextProps) {\n    if (nextProps.project.fulfilled) {\n      this.setState({\n        project: nextProps.project.value,\n        projectUpdated: this.state.project.isDirty // if project was dirty, means it was updated\n      });\n    }\n  }\n  handleProjectChange(property, value) {\n    this.setState({\n      project: Object.assign({}, this.state.project, {\n        [property]: value,\n        isDirty: true\n      })\n    })\n  }\n  render() {\n    const {\n      project: {\n        pending: isPending,\n        rejected: isRejected\n      },\n      updateProject\n    } = this.props;\n    if (isPending) {\n      return <Spinner />;\n    }\n    if (isRejected) {\n      return <Error />;\n    }\n    const {\n      project,\n      projectUpdated\n    } = this.state;\n    return (\n      <div>\n        {projectUpdated && <strong>Updated!</strong>}\n        {project && (\n          <div>\n            Project name:\n            <br />\n            <input value={project.name} onChange={event => this.handleProjectChange('name', event.target.value)} />\n            <button onClick={() => updateProject(project)}>Save project</button>\n          </div>\n        )}\n      </div>\n    );\n  }\n}\n. @ashtuchkin am I wrong or we can make it work using PromiseState?\nPromiseState.all([project]).then(() => flash())\nHave you also tried this.props.project.then()?\n. @ryanbrainard if we have this.props.project.then() why not this.props.saveProject().then()? :P\nI agree with @ashtuchkin, returning a promise is helpful.\n. @ryanbrainard said that we can handle it on PromiseState.then().\nI think it's a good approach, but I like the idea of having a transform property. I think it keeps our component cleaner.\n. @ryanbrainard connecting both RR and Redux to the same component doesn't worked well on my tests. Handling updates inside componentWillReceiveProps was a mess.\nI propose a different approach:\njsx\nconnect((props, state, dispatch) => ({\n  projectsFetch: '/api/projects.json',\n  someStateFromRedux: state.someStateFromRedux,\n  onSomething: () => dispatch(someReduxAction())\n}))(Projects)\nMaybe you can enable mapping state and dispatch as additional properties. As store will be available through this.context maybe you can check for it and enable state/dispatch mapping if it's available.\n. As I can't make RR work with Redux for now I've created a side project based on RR ideas for cases that you really need Redux.\nHere is a sample usage: https://github.com/hnordt/reax/blob/f148edeb1fa870c12f0b7a26c603101fa4990cb2/src/projects/containers/Projects.js\nRepo: https://github.com/hnordt/reax-api\nWhile it's already working and I'm using in production, it doesn't cover all RR features (I don't even know if it will, as it's not the point).\nThe cool part is that it's already very flexible (if you really need Redux).\nYou just need to dispatch a callAPI action, the first param is id, then id will be available to be read from state.api.<id>. For example:\n``` js\n// data will contain endpoint data in case of both success or failure\n// isLoading will be set to true if request is not complete\n// error will be set to true in case of failure\nconst mapStateToProps = state => {\n  const {\n    data: projects, // just renaming data to projects because it'll be passed to a component\n    isLoading = true, // isLoading will default to true\n    error\n  } = state.api.projects || {}; // state.api.projects will be undefined before the request, so we need a empty object for destructing\n  return {\n    projects,\n    isLoading,\n    error\n  };\n};\nconst mapDispatchToProps = dispatch => ({\n  // callAPI(id, method, url, params, dispatchRequest = true)\n  // if you change dispatchRequest to false, isLoading won`t be changed\n  loadProjects: () => dispatch(callAPI('projects', 'GET', '/api/projects'))\n});\n```\n. I liked the additional explanation :+1: \nI faced the same situation as you on #26 \n. Second commit: import*\n. Here is a working solution (although feels a little ugly):\njsx\n<Form onSubmit={handleSubmit(data => {\n  postProject(data);\n  return postProjectResponse ? postProjectResponse.then(resetForm) : Promise.resolve();\n})}>\nUPDATE: actually it doesn't work. The problem is that when user submit the form for the first time postProjectResponse is not available and Redux Form doesn't return anything. After the second call it does work because now postProjectResponse is available. The only way to make it work properly is if postProject returns a promise.\n. @ryanbrainard \nI found a better approach. There is only one missing piece, can you help with the TODO?\n``` jsx\nclass ProjectForm extends Component {\n  componentWillReceiveProps(nextProps) {\n    // TODO: call this.props.resetForm() on success (postProjectResponse.fulfilled)\n  }\n  render() {\n    const {\n      fields: { name },\n      handleSubmit,\n      postProject,\n      postProjectResponse: {\n        pending,\n        reason\n      } = {}\n    } = this.props;\n    return (\n      \n\n\n            {reason && {reason}}\n            \nName\n\n\n\n              {pending ?  : 'Save'}\n            \n\n\n\n    );\n  }\n}\nexport default reduxForm(\n  {\n    form: 'project',\n    fields: ['name'],\n    validate: ({ name }) => {\n      return {\n        name: isEmpty(name) && 'Required'\n      };\n    }\n  }\n)(connect(() => ({\n  postProject: data => ({\n    postProjectResponse: {\n      url: 'http://httpbin.org/post',\n      method: 'POST',\n      body: JSON.stringify(data)\n    }\n  })\n}))(ProjectForm));\n```\n. Great @ryanbrainard. Simple and very efficient :clap: \n. @ryanbrainard it's not so simple, offline POST/PUT/DELETE requests need to be queued, so we can dispatch them when we back online. We'll need to do something like:\njs\nconst handleRequest = request => {\n  if (request.method === 'POST' && isOffline) {\n    return localforage.setItem('queue', [...queue, request]);\n  }\n  // ...\n};\n. @ryanbrainard,\nI would like to suggest something that is simple and very flexible:\nChange:\njs\nreturn fetched.then(handleResponse).then(onFulfillment(meta), onRejection(meta))\njs\nfunction buildRequest(mapping) {\n  return new window.Request(mapping.url, {\n    method: mapping.method,\n    headers: mapping.headers,\n    credentials: mapping.credentials,\n    redirect: mapping.redirect,\n    body: mapping.body\n  })\n}\njs\nfunction handleResponse(response) {\n  const json = response.json() // TODO: support other response types\n  if (response.status >= 200 && response.status < 300) { // TODO: support custom acceptable statuses\n    return json\n  } else {\n    return json.then(cause => Promise.reject(newError(cause)))\n  }\n}\nTo:\njs\nreturn fetched.then(handleResponse.bind(null, request).then(onFulfillment(meta), onRejection(meta))\njs\nfunction buildRequest(mapping) {\n  if (options.buildRequest) {\n    // TODO: warn if options.buildRequest doesn't return a promise\n    return options.buildRequest(mapping)\n  }\n  return new window.Request(mapping.url, {\n    method: mapping.method,\n    headers: mapping.headers,\n    credentials: mapping.credentials,\n    redirect: mapping.redirect,\n    body: mapping.body\n  })\n}\njs\nfunction handleResponse(request, response) {\n  if (options.handleResponse) {\n    // TODO: warn if options.handleResponse doesn't return a promise\n    return options.handleResponse(request, response)\n  }\n  const json = response.json()\n  if (response.ok) {\n    return json\n  } else {\n    return json.then(cause => Promise.reject(newError(cause)))\n  }\n}\nThen we'll be able to create an \"enhanced\" connect:\n``` js\n// enhancedConnect.js\nimport { connect } from 'react-refetch';\nconst buildRequest =  mapping => {\n  return new window.Request(${__API_URL}/${mapping.url}, {\n    method: mapping.method,\n    headers: Object.assign({}, mapping.headers, {\n      'X-Custom-Header': 'true'\n    }),\n    credentials: mapping.credentials,\n    redirect: mapping.redirect,\n    body: mapping.body\n  })\n};\nconst handleResponse = ...;\nconst enhancedConnect = (mapPropsToRequestsToProps, options = {}) => {\n  return connect(mapPropsToRequestsToProps, Object.assign({}, options, {\n    buildRequest,\n    handleResponse\n  }));\n};\nexport default enhancedConnect;\n```\n``` jsx\n// FooBar.jsx\nimport React from 'react';\nimport connect from './enhancedConnect.js';\nconst FooBar => ;\nexport default connect(...);\n```\nToughts?\n. @ryanbrainard I like the idea of having defaults. The problem is that way we'll need to implement every possible type of response (CSV, PDF, offline caches, etc.).\nI think React Refetch should do the basic, i.e. handle common JSON, if you need something specific, you are free to enhance the connect.\nUsing the concept of enhancers, the community can create React Refetch enhancers and share them.\nA CSV enhancer will be able to handle more use cases than injecting it inside React Fetch.\nThats exact same idea from Redux's store enhancer:\n\nA store enhancer is a higher-order function that composes a store creator to return a new, enhanced store creator. This is similar to middleware in that it allows you to alter the store interface in a composable way.\nStore enhancers are much the same concept as higher-order components in React, which are also occasionally called \u201ccomponent enhancers\u201d.\n\nReact has HOCs, Redux store enhancers and middleware, React Refetch will have request and response enhancers. That's my idea.\n. @ryanbrainard updated my previous comments, please read again :P\n. ",
    "LucaColonnello": "@hnordt Great Idea!! I'm waiting this ti use this lib in production! Are you making some of these changes?\n. Good work guys!\nIl luned\u00ec 28 marzo 2016, Ryan Brainard notifications@github.com ha\nscritto:\n\nv1.0.0-beta.0\nhttps://github.com/heroku/react-refetch/releases/tag/v1.0.0-beta.0 has\nthe ability to change the buildRequest, fetch, and handle Response\nimplementations, which should open up a lot of possibilities here. These\nfeatures are probably a little too low level for everyday pre-processing;\nhowever, I want people to kick the tires on them and see what can possibly\nbe built on top of them. I'm going to close this issue now so that we can\nre-frame remaining enhancements in this new context by opening new issues.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly or view it on GitHub\nhttps://github.com/heroku/react-refetch/issues/9#issuecomment-202268620\n\n\nLuca Colonnello\n+39 345 8948718\nluca.colonnello91@gmail.com\n. ",
    "apsaros": "@hnordt +1\nand great work with the lib @ryanbrainard :)\n. ",
    "eyalw": "May I suggest fetch-intercept?\nIt allows both interception of request and response, globally in the app,\ngreat for response value adapters, and request header settings (like csrf). \n. [update]: see the code below from inside the library, it seems like the lib is expecting a certain format of an error object with id/message/error fields. otherwise, it tried to throw new Error(json) - but the Error api expects a human readable message string, so instead of recieving my json at the other end, i get \"[object]\"... \n\n. thanks!\n. Yes, I will on Sunday when I get back to my work computer,\nbut for now it was something like \n{\n  comparison: ...\n  then: (res) => {\n     value: res.data,\n  }\n}\nand fetches kept being sent even though comparison value didn't change.\nthen I removed then() and they stopped.\n. This is the exact code, i commented the lines that caused the bad behavior (refetching without change to url)\n(the then() is the issue, the comparison was an attempt to solve the issue, which didnt work eiher)\n\n. no.. the code compiled, not a noob :)\nI must have removed them after i commented or something...\n. Thanks :)\n. @ryanbrainard, can you explain how it helps in the scenario I described?\nI see @hnordt has a prop array named 'history' given to the wrapped component, \nand promise value is pushed into that array.\nI actually want to put the promise value into the wrapped component state (for example).\nor - redirect (which will require access to this.context.router with react-router API).\n. @arbesfeld this works because onDismiss() will close the view component you are in.\nbut if it didnt, (e.g. setState, or update view) - on the next \"willReceiveProps\" the onDismiss() will be called again and again... so it doesn't make sense for me.\nReally surprised such a classic scenario does not have an answer in RR. I really like the design pattern of RR, its really simple and declarative, no boilerplate code. I wish the HOC will call a callback I defined,\nor at least have the createProject() return a promise.. (less prefered)\n. @ryanbrainard  any idea?\n. What I ended up doing was wrapping my component with my own HOC below the Connect HOC, which middlewares the willReceiveProps lifecycle method and checks for a change in promiseState.settled value between this.props and nextProps, and triggers an exposed function on the wrapped element.\nI wish it was a built in function though\n. @ryanbrainard I like your idea. Your API seems more flexible, and you can control the function being called better, and add conditions and pass different values.\nI do also like it when an API offers me to code the common case in shorter way, which I think is: wrappedComponenet[calbbackName](err, returnVal) - so I guess I would have preffered to have a shorthand as well\nAs to your question about my use case, its mostly stuff like:\n``` javascript\nonFetchAccountResponse(err, account) {\n  if (!err)\n    this.setState({ account }); // load data into a state-binded-form-fields\n}\nonSaveAccountResponse(err) {\n  if (!err) {\n    showNotification('success', 'Wohoo! Account saved'); // one time GUI notification\n    this.context.router.redirect('/somwhere'); // redirect\n  }\n}\nonChangePasswordResponse(err) {\n  if (!err) {\n    showNotification('success', 'Your password was changed'); // notify again, and:\n    this.setState({ formData: null }); // clear the form fields\n  }\n}\n```\n. @ryanbrainard I'm interested to learn, when andThen() will be called, and will make a call to a function on my component, what is the props of the component at that instant? are they already updated with the new fetched data? was willReceiveProps already called for the wrapped component or not?\n. having both then and andThen as 2 different times to hook into - before and after the props have passed down to the wrapped component - seems great to me.\nI was asking because I was thinking my wrapped component callback might be using \"this.props\" to get the new value, or must it be passed in the callback.\n. @ryanbrainard any updates on this issue? I think meta.wrappedComponent is a very good addition to the API.\n. Can we close this issue now?\n. so I guess we check the type of the ref prop (string/func) and act accordingly\n. I can't think of a reason why they require this...\n. +1\nThis can be fixed within RR with checking \"isMounted()\", but today it's considered an anti-pattern.\nA better solution will be to use a cancellable promise (which will not call \"then()\" if cancel()ed on componentWillUnmount()).\n. Sounds good\n. Hey @neezer \nthis might be a duplicate of #58  ?\n. there has to be a way to specify the contextType the HOC will need access to in the mapping function.\nnot sure how the api should be changed.\n. @neezer not sure I understand the problem,\ncheck out #9 \nat the end, I suggest the package \"fetch-intercept\" for your use case.\nIt allows both interception of request and response, globally in the app,\ngreat for intercepting all requests made by the app, and add headers to them like CSRF or JWT token.\n. you're missing parenthesis:\njavascript\nconnect(({ name }) => ({\n   foosFetch: '/foos',\n   createFoo: name => {\n     method: 'POST',\n     url: '/foos',\n     andThen: () => ({ // <-- here\n       foosFetch: { \n         url: '/foos',\n         refreshing: true\n       }\n     }) // <-- here\n   }\n }))\n. Have you tried this: https://github.com/werk85/fetch-intercept ?\n. fixes #58 \n. I didn't, an odd message. Do you have a short code that duplicated the\nwarning?\nOn Thu, 28 Jul 2016 at 5:31 AM Ryan Brainard notifications@github.com\nwrote:\n\nI was just doing a quick test of this in a real app and got:\nInvariant Violation: addComponentAsRefTo(...): Only a ReactOwner can have refs. You might be adding a ref to a component that was not created inside a component's render method, or you have multiple copies of React loaded\nI haven't taken the time to dig in, but just wanted to check with @eyalw\nhttps://github.com/eyalw if you had this happen when using connect.options({\nwithRef: true })\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/heroku/react-refetch/pull/139#issuecomment-235784038,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAlJnV-V6zyPNultk4v0Ki9rI8FU9o2gks5qaBSHgaJpZM4JTXPY\n.\n. @ryanbrainard are you releasing a new beta with this code soon?\n. \n",
    "secretfader": "@ryanbrainard That's an even better idea. The big issue of mine was that Node doesn't recognize window, so we'll need to decide how that dependency is passed in. That's what originally led me down this path.\nI'll dig into this and see if I can come up with a workable solution. \n. @ryanbrainard I have a branch that is working with an alternative fetch implementation (in Node, server-side). It needs a bit of polish, but should be ready either tonight or tomorrow.\n. @ryanbrainard It's all good! Thanks for the heads up, but it's what I expect. (And what should be happening. Enjoy!)\n. Still working on perfecting it, @boyswan. It'll be coming around soon though.\n. That's exactly the idea, @ryanbrainard. I'm hoping to have the PR out this weekend (now that festivities are over). If I can knock out two issues with one commit, then I should at least try. \n. Update: So, I thought finishing the PR would be easier than it was. I have the prototype working, but I'm still feeling out a couple of the design decisions, and want to make sure my code fits in nicely alongside what has already been written. tldr: I have a solution, but it needs cleanup.\nI'll probably be tied up with client work for most of the week. I'd like to finish the PR, but know that it'll be a while. If someone gets to it first, I completely understand. \n. Will do when I get a chance to push it up. \n. @ryanbrainard Catching up... a lot of things, this issue included, have fell by the wayside as I prepare for the impending arrival of a new baby. :smile: \nI don't think I have the bandwidth to tackle a configurable fetch dep, but I can easily submit a PR that switches to node-fetch when used server side. Would that at least fix the current issue? What do you think?\n. @ryanbrainard She isn't here yet, but is coming fast! (And one day, she will probably be annoyed that Dad brought her up on GitHub, but...)\nIn all of the hubbub, I just realized that I lost the changes I had, and didn't check them in. But, I'll try to get a PR in tomorrow morning. \n. I'm going to bow out, since I haven't yet had a chance to get down into the code this week. I'm covered up with too many other projects.\nIf @hnordt can solve this and assemble a PR, I'll back anyone's idea... Because it's better than mine at this stage!\nBetween a dead laptop, projects, and prepping for all of the items above \u2014 my plate is overflowing. It's best that I get out of the way and let someone else take over.\n. ",
    "wilmoore": "@nicholaswyoung \n\n...The big issue of mine was that Node doesn't recognize window, so we'll need to decide how that dependency is passed in. That's what originally led me down this path.\n\nYou might check out: https://www.npmjs.com/package/global\n. > How do other npm modules usually deal with polyfill dependencies like this?\nOther npm packages omit the dependency from dependencies, but put it in devDependencies for tests. The user is then responsible for installing the actual dependency into their own project.\n. ",
    "boyswan": "any news on this?\n. +1\n. ",
    "leesiongchan": "+1, this project is great but why only for client-side :'(\n. Sorry, my mistake, it's not an issue.\n. ",
    "kmoe": "Just a s/let's/lets in \"instead of mapping state to props, this let's you map props to URLs to props\" -> \"instead of mapping state to props, this lets you map props to URLs to props\"\n. Ah, didn't notice you'd merged a subsequent PR with this fix.\n. ",
    "ashtuchkin": "That's even better! :)\n. Moved discussion of transform functions to #21\n. I guess I can do that. Maybe we can do better though.. See my case of a simple edit page with a save button:\n`` es6\n@connect((props) => ({\n    project:/api/projects/${props.id},\n    updateProject: (data) => ({\n        project: { url:/api/projects/${props.id}`, method: \"PATCH\", body: data }\n    })\n}))\nclass ProjectEditPage extends React.Component {\n    constructor(props) {\n        super()\n        // We don't have the data here as it's not loaded.\n        this.state = {}\n    }\n    componentWillReceiveProps(props) {\n        if (props.project.fulfilled) {\n            // When the project is loaded or updated, we set the state to new values.\n            this.setState({props.project.value})\n        // How do we notify user that save is successful? Is this even a good place?\n    }\n}\n\n// 200 lines here\n\nsaveProject() {\n    this.props.updateProject(this.state)\n    // isn't it a lot clearer to just add .then(() => flash(\"Save successful\")) here?\n}\nrender() {\n    if (this.props.project.pending)\n        return <Loading/>\n    if (this.props.project.rejected)\n        return <Error ... />\n\n    return <div>\n         Project name: <input value={this.state.name} onChange={..change this.state.name}/>\n         ....other props...\n         <button onClick={()=>this.saveProject()}>Save project</button>\n    </div>\n}\n\n}\n``\n. @hnordt not following you.. I need user to edit these inputs. those values are definitely state. Plus, where do I notify user that the save is successful?\n. So basically you propose to add anisDirty` flag to state and check it in componentWillReceiveProps. This will work, although it seems more like a workaround to me. \nI still think returning a promise makes sense conceptually (as a signal that the action is done) and makes code cleaner/easier to follow. I do understand that extending api surface will require more maintenance though, so will not press. Thanks.\n. Yeah, but it's has different semantics. this.props.project.then() is data-specific (transform the data when it's loaded), but I wanted something action-specific (that a particular action is finished).\n. Transforming directly in request definition is helpful if you're creating a wrapper to the api, i.e.:\n``\n// api-helpers.js\nfunction myApiRequest(action, data) {\n    return {\n        url:/api/${action}`,\n        data: data\n        transform: ....\n    }\n}\n// in all views\n@connect((props) => {\n    project: myApiRequest(\"get_project\")\n}))\n```\nThat way, we can handle the api returning data in some hard-to-use, but consistent format.\n. This would work for my case. I like it. It's more general.\n1) Do I understand correctly that you need yet another level of indirection, like this:\nes6\nconnect((props) => ({\n  data: {\n    url: \"/api/data\",\n    then: (rawValue) => ({ \n      data: {   // <- this one\n        value: rawValue.real_data\n      }\n    })\n  }\n}))(Component)\n2) We could go even further and allow raw promises as a request value:\n``` es6\nconnect((props) => ({\n  data1: \"/api/data1\",\n  data2: { \n    url: \"/api/data2\",\n    then: (rawValue) => {\n      data2: new Promise((resolve, reject) => { async_action(resolve); })\n    }\n  },\n  data3: genericAsyncActionReturningPromise(),\n  data4: anotherAsyncAction().then((rawValue) => rawValue.real_value)\n// another, less intrusive variant\n  data5: {\n    promise: asyncAction(),\n    then: ...\n  }\n}))(Component)\n```\nOne use case for that is asynchronous loading of requirejs module that contains code for sub-components. The only challenge I see here is that the evaluation of the function given to connect needs to be well-defined (i.e. called only once, etc.). What do you think? I can create a separate issue to discuss this.\n. ",
    "bbirand": "I see now that this is the place where the magic happens:\nhttps://github.com/heroku/react-refetch/blob/019a17057d7af6c22e4c9e160e77d08a11ec41c0/src/components/connect.js#L79\nIf you can point me in the right direction, I can try to give this a shot.\n. ",
    "hekike": "@ryanbrainard sorry for the late response. I made most of the requested changes. I also commented to te outstanding ones.\n. @ryanbrainard thanks to letting me know, I will!\n. done\n. ok I'm waiting\n.  I understand and agree but seems to be that this.state.mappings[prop] doesn't have fulfilled property. I need to dig deeper to understand the code and check for it. Could you help here?\n. ",
    "XVincentX": "Is this still happening?. ",
    "frontsideair": "I think it should just work, unless Refetch and Redux connect imports clash. I imagine passing your component to one connect and pipe it to the next one and you should have all required props available.\nI'll keep an eye on this discussion though.\n. ",
    "anaibol": "+1\n. ",
    "tomasdev": "@hnordt where did your project go!? I need it :)\nTake a look at https://github.com/facebook/flux/blob/master/examples/flux-chat/js/actions/ChatServerActionCreators.js and https://facebook.github.io/flux/docs/chat.html\nYou can workaround by dispatching an action UPDATE_ALL to put the RR .value into the redux store\nAlso http://redux.js.org/docs/advanced/ExampleRedditAPI.html presents a solution. No need of react-refetch then, if you need your data in the store.\n. ",
    "tomat": "Was also looking for a solution to this, and ended up writing my own (of course :-P), might be interesting for others ending up here, at least for inspiration:\nhttps://github.com/tomat/react-reflorp\nBasically I really like the way Refetch does things, but I still wanted less boilerplate, and to keep things in the Redux store. Ended up with something of an ORM, where it keeps track of which component needs which entity with which id, and stores them separately in Redux, but still allowing use of regular Redux and Refetch within the same decorators. Not in any way production ready, though :-)\nFeel free to open an issue over there if you have a question...\n. Just stumbled on this when building react-reflorp, resorted to explicitly setting comparison in the original mapping, and then the same comparison and force: true in then, but I would expect a more logical default behaviour. Took some debugging to figure out why this was happening. Maybe store the last non-identity-request mapping on each key and compare to that unless comparison is set?\n. ",
    "jwdotjs": "When the component mounts, I see one fetch. Then when the user clicks a button I see one refetch.\nThe library currently allows for one fetch and one refetch because the mapping changes from not having the refreshing key set (on the original fetch) to having the refreshing key set to true when the user first clicks the button (through the function refresh function passed into the component). \nI know, setting force to true will allow it to continue refetching for each button click, but I'm wondering if it would make more sense to just see if refreshing is set and true and always allow a refetch if the mapping is valid. \nIt seems to me like each individual component should be responsible for determining when a user clicks on a button if a refetch should actually trigger or not through the components all validation checks, not through the react-refetch library by passing in force: true. \n. > It shouldn't be comparing that, but I'll need to take a closer look.\nI believe it is using the same mapping because the key is the same for both the initial fetch and refetch: devicesSearch (in the example above) \n\nThere are use cases to set refreshing on component mount and cases when a refetch should not occur even on a user action, so I don't want to conflate force and refreshing and chose to keep them separate, explicit attributes.\n\nOk, later tonight I will create a pull request to update the readme's Manual Refetching section to describe the mapping, comparison, and force attribute so other users don't run into the same situation, if that works for you. \nThanks for your help :)\n. > Sorry for the delay. I finally got some time to try this out, but I cannot reproduce the issue you were seeing with the first refetch. I copied your code snipped above into a sample app of mine, but I only see the initial fetch happening on page load. The fact that they are both using the same key is exactly why there should not be a refetch.\nThe below example is more complete than my original with a full component and demonstrates one fetch on mount/load and only one additional fetch when the button is clicked. The key for both mappings is deviceMessageSearch but because the mapping changes between the mount/load and the user trigger refetch (by adding refreshing: true it allows the user to make one request in addition to the mount/load request, then no more requests).\n``` jsx\nimport React from 'react';\nimport moment from 'moment';\nimport { map } from 'lodash';\nimport { connect, PromiseState } from 'react-refetch';\nclass DeviceMessages extends React.Component {\n  static propTypes = {\n    history : React.PropTypes.object.isRequired,\n    params : React.PropTypes.shape({\n      userId : React.PropTypes.string.isRequired,\n    }).isRequired,\n    refreshMessages : React.PropTypes.func.isRequired,\n    deviceMessageSearch : React.PropTypes.instanceOf(PromiseState).isRequired,\n  }\nstate = {\n    messages : [],\n  }\nrenderDeviceMessages() {\n    const { deviceMessageSearch } = this.props;\n    const allSearches = PromiseState.all([ deviceMessageSearch ]);\nif (allSearches.pending) {\n  return 'Loading Device Messages...';\n} else if (allSearches.rejected) {\n  return 'There was an error loading messages';\n}\n\nconst [ messages ] = allSearches.value;\nif (! messages.length) {\n  return <h3>No new messages.</h3>;\n}\n\nconst rows = map(messages, (message, key) => {\n  const { device, place } = message;\n  return (\n    <tr key={key}>\n      <td>{device && device.name || '-'}</td>\n      <td>{place.name}</td>\n      <td>{message.message}</td>\n      <td>{message.updated_at ? moment(message.updated_at).fromNow() : '-'}</td>\n    </tr>\n  );\n});\n\nreturn (\n  <table className='collapsable-table'>\n    <thead>\n      <tr>\n        <th>Device Name</th>\n        <th>Room Name</th>\n        <th>Message</th>\n        <th>Date</th>\n      </tr>\n    </thead>\n    <tbody>\n      {rows}\n    </tbody>\n  </table>\n);\n\n}\nrender() {\n    return (\n      \nDevice Messages\nRefresh messages\n        {this.renderDeviceMessages()}\n      \n    );\n  }\n};\nexport default connect((props) => {\n  const deviceMessageUrl = ${process.env.API_URL}api/users/${props.params.userId}/device-messages;\n  return {\n    deviceMessageSearch : deviceMessageUrl,\n    refreshMessages : () => ({\n      deviceMessageSearch : {\n        url : deviceMessageUrl,\n        method : 'GET',\n        refreshing : true,\n        // force : true,\n      },\n    }),\n  };\n})(DeviceMessages);\n```\nSample response object from DB:\ncreated_at: \"2015-12-27T20:54:28.018Z\"\ndevice: { id : 5, name : \"hoosier_turtle\" },\nid: 247\nmessage: \"Motion Detected\"\nplace: { id : 1, name : \"Kitchen\" },\nupdated_at: \"2015-12-27T20:54:28.018Z\"\nRequest 1 On Component Mount:\n\nRequest 2 On Button Clicked:\n\nWhen I click a button for the second time, nothing happens.\n\nSwitching to force: true allows me to click and refresh data as much as I want:\n\n. Gotcha! Sorry for missing that piece in the first example.\n. I think the new documentation perfectly demonstrates how manual refetching is expected to work right out of the box. :+1: \nThanks again Ryan!\n. ",
    "chickencoder": "Oh thank you! Works great :+1: \n. ",
    "georgebonnr": "Trying refetch out tonight, I was just about to ask about this, to help with transformations.  Any timeline, or is this a request for a PR?\n. > Identity requests will allow for transformations of responses inside of connect(); however, you can use PromiseState.then() to do the same thing in the component.\nCool, yeah that's what I was planning on doing until identity is implemented \u2013 but no need now!  :clap: \n. cool!  going to go ahead and point to this branch for now.\n. @ryanbrainard Not 100% familiar with the code...  But if you have value: doTransformationWork(rawValue) in your mapping, that work will be done every time to produce the final value, so the equality check here doesn't prevent that work from being done?\nThat being said, seems like the primary use case for the value prop is in a then or andThen prop (so the equality check for the parent mapping is the important part)...  This could be used in a 'top level' mapping, but then you'd probably just want to apply any transformations to the plain props directly instead of using refetch?\nIs that correct or am I missing something?  Going to be using this in .then so not really a problem.  But I guess I can also use my own memoization on that transformation function if I ever needed to.\n. ",
    "imjoehaines": "Yeah that works fine, IE sets the message and id properly.\nWould you be willing to change the name from id to something more generic, or add a new field for additional information about an error (maybe context)? We're dealing with a legacy application that often passes arbitrary data back from the server on errors and it would be nice to be able to handle the same cases without having to refactor things too much to begin with.\nWe could just attach it to id but it'd be nice to have a proper place for that sort of thing to live.\n. No worries.\nYeah, that sounds like it would work perfectly!\n. Just tested in Chrome & IE and it works fine. Thanks for fixing this so quickly!\n. ",
    "claudiuandrei": "Closing for now, there is an issue with parsing responses in the 'no-cors' mode. I need to investigate further.\n. ",
    "Adam-Burke": "I'm looking for assistance in getting this library working with mode: 'no-cors'. Is this possible?. ",
    "yarinm": "I just noticed the \"cause\" property in the new beta release.\n. I would really be happy to see @ryanbrainard suggestion implemented. \nBut why do we need to return {value, meta}? can't we also support an empty return ?\n. +1\n. ",
    "volkanunsal": "No, I mean the Safari browser on iPhone. I'm testing in an emulator.\n\nCorrect me if I'm wrong, but that should probably be the responsibility of the app. \n\nMentioning that we need to add polyfills for some ES6 features in the documentation would be helpful. It seems like the headline for it would be the library doesn't support IE and Safari by default. \nMy guess on the PromiseState issue is it probably also requires a polyfill for a Promise. Or maybe the implementation of the Promise object in Safari is faulty. I haven't tested this idea yet, but I will report what comes out of it.\n. I checked the Promise issue. It's not related to a faulty implementation. I observed the same behavior with a polyfill. The interesting thing about it is that one of the promises are fulfilled, and the second one isn't. This only happens on Safari. Other browsers fulfill both requests. I will try to get a test case up, but my code looks like this:\n`` javascript\n@refetch(props => {\n  let fetchers = {\n    dirFetch: {\n      url:https://api.github.com/repos/volkanunsal/docs/contents/pages,\n      then: (pages) => ({value: pages})\n    }\n  };\n  if (props.params.splat) {\n    fetchers.pathFetch = {\n      url:https://api.github.com/repos/volkanunsal/docs/contents/${props.params.splat}`,\n      then: (page) => ({ value: page.content ? atob(page.content) : '' })\n    };\n  }\nreturn fetchers;\n})\nexport default class DocsPage extends React.Component {\n  render() {\n    const { dirFetch, pathFetch } = this.props;\n    let pages = [];\n    console.log(dirFetch);\n    // => Fulfilled\n    console.log(pathFetch);\n    // => Not fulfilled\n  }\n}\n``\n. Oh you're also using Request! That's not supported by Safari either, and it's marked as [experimental technology in Javascript reference docs.](https://developer.mozilla.org/en-US/docs/Web/API/Request)\n. It seems like the Request object is polyfilled by [whatwg-fetch library.](https://github.com/github/fetch/blob/a9f49ab0875e284dbd0eda9be5004949e31b4161/fetch.js#L215) But it's important to realize that library is [only included if the native Promise object doesn't exist.](https://github.com/github/fetch/blob/a9f49ab0875e284dbd0eda9be5004949e31b4161/fetch.js#L4-L6) Meaning browsers that support Promise, but not Request, like Safari, won't be able to use it.\n. It looks like the problem was usingatobin thethenfunction. This probably took longer than it should in Safari and caused some problems with how Promises get fulfilled. Now the promise gets fulfilled, but it won't return the correct value. It returns an empty string. Again only on Safari.\n. Looks like this is an issue with [Safari's implementation ofatob](http://stackoverflow.com/a/27536313/32816). I guess that takes care of the second problem.\n. @ryanbrainard Awesome. Yeah, I think that's all of it. \n. @nfcampos That's weird. That's not what I'm seeing. Themetaobject of a fulfilledPromiseState` appears to be empty for me. My response is also being post-processed in a promise, though, so that might be the issue. \njavascript\nprojectSearch: {\n      url: `/api/search${queryString}`,\n      comparison: queryString,\n      then: (results) => {\n        return {\n          value: normalizeProjects(results)\n        }\n      }\n    },\nI can't get the returned value from a then method to include a non-empty meta property. If I had access to the original PromiseState in that block, rather than only the json() output, that would solve the problem for me.\n. Problem solved. \ud83d\udc4d \n. ",
    "balupton": "Perhaps https://github.com/bevry/editions would be the way to go\n. Perhaps https://github.com/rollup/rollup-plugin-commonjs#custom-named-exports will help me\n. ",
    "isaachinman": "@ryanbrainard What's the status on isomorphic support as of now?\n. Ah okay, that is a shame.\n. Hi there, been a couple months but I've just come across this library. Is there a proposed data source for the TodoMVC example?\n. ",
    "mymtw": "Hi, Is server-side rendering still not implemented?. ",
    "arbesfeld": "FWIW, I also have had to do this, and have been using a pattern like this:\ncomponentWillReceiveProps(nextProps) {\n  const { createProjectResponse } = nextProps;\n  if (createProjectResponse && createProjectResponse.fulfilled) {\n    this.onDismiss();\n  }\n}\nBut it would be nice if the createProject just returned a promise.\n. @ryanbrainard - this appears to happen whenever the first url doesn't \"resolve\", and then the component is unmounted. ",
    "neezer": "I'll chime in in support an implementation for this behavior, as #66 (duplicate of this issue, effectively) illustrates my use case.\nAlso, @hnordt's solution doesn't work for me since I'm using react-router v2, where router is defined on this.context (this.props.history is being deprecated). \nYou can still workaround that fact using the singleton history, but you're going to run into issues with universal apps with differing history strategies (in-memory vs browser).\n. :+1:\n...but I'm not the deciding vote. :wink: \n. Ahh, you're right @eyalw. Missed that. My bad. Will pick up the conversation there.\n. @ryanbrainard catch/andCatch fails with\n\nSyntaxError: Unexpected end of input\n\nWith no stacktrace.\n. \"whatwg-fetch\": \"^0.11.0\"\n. @ryanbrainard That seems like a good guess. Thinking that because response.body stream is empty, the line that reads response.json() is effectively doing something akin to JSON.parse(\"\"), which yields the same error I'm getting.\n. @ryanbrainard Toying around, this fixes the issue for me, though no vote on whether or not this is a good approach (just adding an early return):\n``` es6\nfunction handleResponse(response) {\n  if (response.headers.get('content-type') === null)  return;\nvar json = response.json(); // TODO: support other response types\n  if (response.status >= 200 && response.status < 300) {\n    // TODO: support custom acceptable statuses\n    return json;\n  } else {\n    return json.then(function (cause) {\n      return Promise.reject((0, _errors2.default)(cause));\n    });\n  }\n}\n```\nPerhaps better to gate the JSON parsing based on whether or not the Content-Type is actually application/json.\n. > Together (response.status === 204 || response.headers.get('content-length') === 0), these should account for most cases and is non-breaking.\n@ryanbrainard Good points. I've updated this PR to reflect that while also adding a new test case so that each condition is tested.\n. @eyalw The issue is request pre-processing at the time the request is made, not when the class is instantiated. @hnort's idea about \"request enhancers\" would work if they were executed at runtime. Similarly his other suggestion would also work. \n\nfetch-intercept monkey patches the global fetch method...\n\nThat would provide a solution, but in the form of a hack, which I'm reluctant to pursue.\n. @eyalw Here's an example failing test case of the functionality that's missing:\n``` es6\n// connect.spec.js\nit('should preprocess request object before all fetches with preflight option', (done) => {\n  const props = ({\n    foo: 'bar',\n    baz: 42\n  })\nconst genRandToken = () => (Math.random().toString(36)+'00000000000000000').slice(2, 7)\n  window.authToken = genRandToken()\n@connect(({ foo, baz }) => ({\n    testFetch: {\n      url: /${foo}/${baz},\n      headers: { 'Authorization': Bearer ${window.authToken} },\n    },\n  }))\n  class Container extends Component {\n    render() {\n      return \n    }\n  }\nconst container = TestUtils.renderIntoDocument(\n    \n  )\nconst newRandToken = genRandToken()\n  window.authToken = newRandToken // override previous token\nsetImmediate(() => {\n    const stubFulfilled = TestUtils.findRenderedComponentWithType(container, Passthrough)\n    expect(stubFulfilled.props.testFetch).toIncludeKeyValues({\n      fulfilled: true, pending: false, refreshing: false, reason: null, rejected: false, settled: true, value: { T: 't' }\n    })\n    expect(stubFulfilled.props.testFetch.meta.request.headers.get('Authorization')).toEqual(Bearer ${newRandToken})\n    expect(stubFulfilled.props.testFetch.meta.response.status).toEqual(200)\n    expect(stubFulfilled.props.testFetch.meta.response.bodyUsed).toEqual(true)\ndone()\n\n})\n})\n```\nThis test fails with\n```\nReact\n  connect\n    1) should preprocess request object before all fetches with preflight option\n0 passing (200ms)\n1 failing\n1) React connect should preprocess request object before all fetches with preflight option:\nUncaught Error: Expected 'Bearer 8tzo7' to equal 'Bearer 3vf92'\n+ expected - actual\n\n-Bearer 8tzo7\n+Bearer 3vf92\n\n```\n\nI was thinking it would be easiest to provide some sort of preflight option, like:\nes6\n@connect(({ foo, baz }) => ({\n  testFetch: {\n    url: `/${foo}/${baz}`,\n    preflight: (request) => {\n      request.headers.set('Authorization', `Bearer ${window.authToken}`)\n    },\n  },\n}))\nThat way you could compute the value of the Authorization header _at execution time_ rather than during initialization.\nDoes that help clarify the issue?\n\n@ryanbrainard :money_with_wings: for your thoughts?\n. @eyalw @ryanbrainard I got a working implementation of my preflight idea, but I can't figure out how to make the tests simulate a change to the window.authToken variable... I confirmed the change does fix my app, however:\nChanging src/components/connect.js:95:\n``` es6\nfunction buildRequest(mapping) {\n  const request = new window.Request(mapping.url, {\n    method: mapping.method,\n    headers: mapping.headers,\n    credentials: mapping.credentials,\n    redirect: mapping.redirect,\n    body: mapping.body\n  })\nif (Function.prototype.isPrototypeOf(mapping.preflight)) {\n    mapping.preflight(request)\n  }\nreturn request\n}\n```\nIf y'all have an idea about how to fix the test to reflect the new behavior, I'd be happy to throw up a PR for this.\n\nMy current test (slimmed down from the one posted above):\n``` es6\nit('should preprocess request object before all fetches with preflight option', (done) => {\n  const genRandToken = () => (Math.random().toString(36)+'00000000000000000').slice(2, 7)\n  const oldRandToken = genRandToken()\n  const newRandToken = genRandToken()\n// make sure the oldRandToken is the value present during initialization\n  window.authToken = oldRandToken\n@connect(({ foo, baz }) => ({\n    testFetch: {\n      url: '/some/url',\n      preflight: (request) => {\n        request.headers.set('Authorization', Bearer ${window.authToken})\n      },\n    },\n  }))\n  class Container extends Component {\n    render() {\n      return \n    }\n  }\nconst container = TestUtils.renderIntoDocument(\n    \n  )\n// after initialization, override with the newRandToken\n  window.authToken = newRandToken\nsetImmediate(() => {\n    const stubFulfilled = TestUtils.findRenderedComponentWithType(container, Passthrough)\n    expect(stubFulfilled.props.testFetch).toIncludeKeyValues({\n      fulfilled: true, pending: false, refreshing: false, reason: null, rejected: false, settled: true, value: { T: 't' }\n    })\n    expect(stubFulfilled.props.testFetch.meta.request.headers.get('Authorization')).toEqual(Bearer ${newRandToken})\n    expect(stubFulfilled.props.testFetch.meta.response.status).toEqual(200)\n    expect(stubFulfilled.props.testFetch.meta.response.bodyUsed).toEqual(true)\ndone()\n\n})\n})\n```\nI get the same failure as before with or without the change, but in my manual testing with a live browser window, the change works as expected. I suspect it's something to do with my window.authToken update not happening correctly with setImmediate, but every permutation I've tried has failed.\n. Nm, I've determined that there is a bug in my code and not with react-refetch. :no_mouth: \nSorry for the issue spam! \n. I'm unsure how compatible this is with all derivative forms of the JSON MIME type (things like JSON API, etc.).\nAlso not sure if ancillary information like ;charset=UTF-8 is always guaranteed to come after the actual MIME type. Would appreciate some insight here.\n. I did my best to strip this down to the essential test, but I feel like it could be stripped even more. Also the error message is not fantastic (buried in the diff provided by toIncludeKeyValues), so that could probably be improved.\n. The failed assertion is\n\nUncaught Error: expected { BIG OBJECT } to include { 'fulfilled': true }\n\n... but the actual error is buried inside BIG OBJECT:\n\n... reason: [SyntaxError: Unexpected end of input] ...\n\n\n\nUncaught Error: expected { fulfilled: false, meta: { request: { _bodyInit: undefined, _bodyText: '', credentials: 'same-origin', headers: { map: { accept: [Object], 'content-type': [Object] } }, method: 'GET', mode: null, referrer: null, url: '/empty' }, response: { _bodyInit: '', _bodyText: '', bodyUsed: true, headers: { map: { 'content-length': [Object], 'content-type': [Object] } }, ok: true, status: 200, statusText: undefined, type: 'default', url: '' } }, pending: false, reason: [SyntaxError: Unexpected end of input], refreshing: false, rejected: true, settled: true, value: null } to include { 'fulfilled': true }\n. > ... but I see the full object\n\nYup, that's my point. My previous post was an abbreviation to help clarify my initial comment, but I guess I missed the mark. :smile: \nAll I was trying to say is that I think the failure should be clearer and less verbose, and take you right to the heart of the problem. It's a minor thing, though.\n. ",
    "amoskl": "+1\n. ",
    "uripo": "+1\n. ",
    "XAMeLi": "+1\n. ",
    "gaugau": "I encountered the same scenario as @eyalw. Where I just want to trigger an action eg. updateUser and then performing an action (eg. show notification). I think it's common case and the documentation should be updated to show an example of how to achieve it with RR.\nCurrently, I need to hook into componentWillReceiveProps to check if the response has been fulfilled and perform the callback action. But any changes on props later could trigger the same callback action multiple time. :(\n. ",
    "Soul-Burn": "In my case, I want to show a dialog window when the result was fulfilled.\nIn e.g. material-ui this is done by sending a open=\"true\" prop to the dialog, usually coming from the state/props of the parent. It is then closed when a button is clicked and the handler sets the state of the parent.\nWhile the fetch promise prop doesn't exist, the dialog is not shown.\nWhen it exists and pending, I show a loading animation.\nWhen it fulfilled, I show the dialog.\nHowever, there is now no way to now dismiss this dialog, as the promise will remain until it is replaced/refetched.\nA one time callback like proposed here will let me set the dialog state.\nI can work around this by defining a \"value\" fetcher and relying on this value rather than the promise's fetching state.\nHowever, in my case, and along the lines of RR taking care of state, it makes more sense to have a way to dismiss the existing PromiseState and return it to how it was before the fetch function was called to designate the of this flow.\nSomething like this could work (not tested):\njavascript\nconnect(props => ({\n  shouldShowDialog: { value: false },\n  dismissDialog: () => { value: false},\n  postStuff: data => ({\n    stuffRequest: {\n      method: 'POST',\n      url: '/stuff',\n      andThen: () => ({\n        shouldShowDialog: { value: true }\n      })\n  })\n}))(MyApp)\nThen my code could use the value in shouldShowDialog combined with the stuffRequest promise state.\nThat said, is there anything limiting us from passing this into the function and simply call stuff on it in the andThen?\njavascript\nconnect(props => ({\n  postStuff: data, component => ({\n    stuffRequest: {\n      method: 'POST',\n      url: '/stuff',\n      andThen: () => ({\n        component.doStuff();\n        return {};\n      })\n  })\n}))(MyApp)\n. Makes sense.\nWhat about the proposal of dismissing a fetch, back to how it was before it was fetched?\nSo we could have rendering like this example:\nno fetch - nothing shown\npending - loading animation\nfulfilled - some result, possibly a dialog showing\nrejected - another result, possibly a dialog showing\nOnce the dialog is done, the fetch can be dismissed to move it back to the original state.\n. Yes. This seems like a suitable solution for these kinds of requests. I think I even considered using identity requests, but it seemed like a bit of fiddling.\nI don't think it's good to set it to null every time props change, because a different interaction might cause props to change, which in turn might break my interaction.\nTherefore, I would still need to test for the two empty cases, like this:\nconst isEmpty = !updateFetch || (updateFetch && updateFetch.fulfilled && !updateFetch.value)\nThe rest of the code would be simple. I can encapsulate this logic in a function to reduce the boilerplate checks, e.g mapping a fulfilled and undefined value to undefined.\nmapEmpty(promise) {\n    return (promise && promise.fulfilled && promise.value === undefined) ? undefined : promise;\n}.\n",
    "nfcampos": "there is one reason why you don't want withRef to always be true (or even default to true), stateless functional components don't have refs, so if you wrap one of those you can't provide a ref\n. I've added this in PR #86 \n. well, the easiest way to allow chaining is to not need it\njs\nconnect.with({fetch: fetch})\nconnect.with({withRef: true, fetch: fetch})\nbut i can't say i'm too happy about this either\n. and one way i can think of to get rid of the options hash is to keep track of it in a closure\njs\nfunction connectFactory(options) {\n  function connect(mapPropsToRequestsToProps) {\n    ...\n  }\n  connect.withFetch = function(fetch) {\n    return connectFactory(Object.assign({}, options, {fetch: fetch}))\n  }\n  connect.withRef = function(withRef) {\n    return connectFactory(Object.assign({}, options, {withRef: withRef}))\n  }\n  return connect\n}\nconst defaults = {\n  fetch: window.fetch,\n  withRef: true\n}\nexport default connectFactory(defaults)\nthis actually also allows for chaining connect.withFetch(fetch).withRef(false) unless i did some horrible mistake\n(you'd want to use _.assign instead of Object.assign to avoid messing with polyfills)\n. let me know if you want another pair of eyes looking into the test failures :)\n. I'll take a look\n. speaking of uses, i just realised my main usecase for a custom fetch won't work with this:\n(supporting long polling)\njs\nconst customFetch = (...args) => {\n  return fetch(...args)\n    .then(resp => resp.json())\n    .then(data => {\n      if (data.task)\n        return pollUntilTaskCompletes(data)\n      else\n        return data\n    })\n}\n// pollUntilTaskCompletes polls for completion, returning a promise that resolves once the task is complete\nThis looks like the kind of thing one might do with a custom fetch.\nHowever, since I need to consume the json of the request when react-refetch's handleResponse() tries do the same it will fail...\nIf a custom fetch can't be used for request post-processing then exactly what can one do with this?\nActually, @passcod 's example on issue #75 won't work either (assuming it also needs to consume the json to process the response...\n. you can only call .json() on a Response instance once, so I'd have to do something like\njs\n  fetch(...args)\n    .then(resp => [resp, resp.clone().json()])\n    .then(([originalResponse, data]) => {\n      if (data.task)\n        return pollUntilTaskCompletes(data)\n      else\n        return originalResponse\n    })\n  // and remember to do the same dance inside pollUntilTaskCompletes()\nwhich I think we can all agree is pretty terrible...\n. by terrible I mean it's error prone and not intuitive (how many people know you can only consume the body of a Response once?). So what is a good, non-hacky, use case for this?\n- Response processing would certainly be better handled by allowing a custom handleResponse()\n- Request pre-processing maybe?\n. I feel that this API would be more useful if it embraced the fact that if you're replacing the transport (fetch) it's extremely likely you'll want to replace some other part of the network logic, namely request pre- and post-processing.\nhow about this?\njs\nconnect.withTransport((defaultBuildRequest, defaultHandleResponse) => {\n  return function(mapping) {\n    // do whatever you want\n    return data\n  }\n}\nin which the default implementation is\njs\nconnect.withTransport((defaultBuildRequest, defaultHandleResponse) => {\n  return function(mapping) {\n    return fetch(defaultBuildRequest(mapping).then(defaultHandleResponse)\n  }\n}\nOtherwise, since there's practically no use for replacing fetch() in which you don't need to replace either buildRequest or handleResponse you'll always end up working around the default implementations of these two.\n. in which:\n- buildRequest is mapping -> Request\n- fetch is Request -> (promise that resolves to) Response\n- handleResponse is Response -> (promise that resolves to) value\nsomething like this?\nThis sounds like a good solution\n. exactly\n. (note for the docs: all requests go through this pipeline of three functions except for identity requests, which bypass all three, just returning value)\n. withPre, withPost? too cryptic?\n. preFetch,fetch, postFetch?\nassignDefaults should just be part of the default buildRequest no?\n. withBeforeFetch, withFetch, withAfterFetch ?\n. @ryanbrainard yep, i agree, that division makes sense to me\n. and withReponseHandler()?\nI think these make sense, they hint at the function signature and are not terrible to read\n. @passcod Good luck!\n. Two thoughts:\n- for defaults would it be enough to just provide a withDefaults() method that takes an object of defaults that is later used somewhat like so: Object.assign({}, defaults, mapping) (with some special handling to also merge the headers object, etc.) For the use cases I can think of this sounds like enough, do you see any advantage to actually overriding the assignDefaults function?\n- are four customisation hooks too much? Or can we just assume they are for specialised use and most people will use none or just connect.withDefaults() so it's fine?\n. I kind of like the symmetry of the API as you proposed with connect.with({}). It sounds like a good idea to be able to do something like:\njs\n@connect.with({comparison: ..., credentials: ..., fetch: () => {...}})(props => ({\n  usersFetch: 'some/url',\n  otherFetch: 'some/other/url',\n})\nclass Blah extends Component {\n  ...\n}\nand know that any keys provided to with()will simply act as defaults for the mappings \n. @ryanbrainard yep exactly the same thing :)\n. yep defaults is more obvious, so better :)\nYes, I'm on board with this, it creates all (all I can think of at least) the customisation hooks that seem useful and does it in a clear way that works both at the connect-level as well as at the individual-mapping level\n. It looks like you didn't make it possible to set fetch, handleResponse and buildRequest at the individual mapping level, is that on purpose?\n. Also, as long we're doing sanity checks on the arguments to .defauts might as well do it for all, then, catch, andThen, andCatch, force, refreshing are missing. What do you guys think?\n. @passcod fair enough, but I don't think it's a great experience if someone erroneously supplies a non-function as eg. andThen and we silently ignore it instead of warning, since supplying a non-function to those keys is certainly a mistake.\nedit: but then again changing that is probably not something for this PR, so nevermind\n. but there are pretty valid use cases for them (at least some of them) at the mapping level, eg.\njs\nconnect(props => ({\n  userFetch: 'api/some/json', // will use the default json-ready handleResponse\n  dataFetch: {\n    url: 'api/some/csv',\n    handleResponse(resp) { return resp.text().then(...) }\n  },\n})\n. also, just noticed that the api documentation mentions these two functions taking as an argument an iterable but the current implementations only allow for providing arrays, since they then call Array.prototype methods on it. A simple fix would be to add a line at the begging of each doing\niterable = Array.from(iterable)\n. yes, the parity with Promise.all() is a good point, maybe it's not worth it\n. (btw, @ryanbrainard there's some problem with the tests when ran on watch mode, they always fail the 2nd time they run, ie. the first time they detect a change) It's always something saying window.Request is not defined (but it works when ran not on watch mode)\n. There are basically 4 options:\n1) depend on polyfills and include them (we can't do this, the user must be the one to choose what polyfills to use)\n2) depend on polyfills and warn the use he has to include them\n3) use implementations of these functions from a dependency (we don't have to test and maintain them)\n4) write our own implementations (maybe the bundle size is smaller, maybe not)\nMost libraries seem to do 3 or 4. I'm not a big fan of 4 because it's one more thing to maintain. Doing 3 might not increase the bundle size for the user if a) the dependency we include for it is as small as what we would write or b) it's a dependency that is common enough that some users would already be including it anyway (eg. single methods from lodash).\nWe can also do 2) and either add warnings in the README or runtime warnings telling you to include the polyfill if it isn't there?\n. Looks great, thanks!\n. yep looks great!\n. I'll update the docs.\nAs for the example, any example with context gets kind of verbose (defining all those contextTypes, etc.), which might be too much for the readme, no?\n. happy to help!\n. yeah after a while I noticed that ;) all fixed now\n. @ryanbrainard glad to hear it works!\nunrelated: should we add this eslint rule to warn about the curly braces? http://eslint.org/docs/rules/curly\n. I can add that note now if you want. The reason for doing it via context is basically so that it can change dynamically, right?\nedit: it makes more sense to do this after both are merged in\n. one other reason i can think of to use context:\nan example like the default refreshTimeout I added to the readme in which you want to have a default for some mappings is impossible to do with .defaults()\n. type check then, catch, andThen and andCatch as well?\n. since currently we ignore any values for these 4 that are not functions this would be a breaking change (as in it might break someone's app). But i still think we should do it\n. also, how do you feel about moving the type check definitions to a separate file, connect.js is getting kind of crowded, and it's not like you need to see the type checks to understand the rest of the code?\n. btw, something i've been meaning to do is add a pure option like react-redux has (only recompute the mappings when props (or context) actually changed (compared with shallowEqual), also only rerender when same thing is true). Any reason why you didn't bring that over when you forked from react-redux?\n(I remembered this now because with the defaults assignment, now we add type checking for each mapping, etc it probably gets kind of expensive when you have lots of mappings...)\n. I've opened a PR for the pure optimisation #94 \n. I've made these changes regarding type checking individual mappings, etc. I'll open a PR soon. (edit: #96)\n. - value optionally taking a promise is a great idea, sounds like a very natural extension of the current API (and it looks like it'd be pretty trivial to implement, just change this line https://github.com/heroku/react-refetch/blob/master/src/components/connect.js#L345 to return Promise.resolve(value).then(onFulfillment(meta), onRejection(meta)) (and move line 349 outside of the if)\n- as for dependentProps, it is kind of a specific implementation of a comparison function (called with (prevProps, nextProps) as arguments), if we had such a thing. But being able to specify comparison as an array of props to be shallowly compared actually sounds like something that would be useful for regular requests as well, what do you think? (btw, this api of dependentProps as an array of props to be compared was inspired by this https://github.com/acdlite/recompose/blob/master/src/packages/recompose/mapPropsOnChange.js)\n- today I also considered whether PromiseState should be its own module, but honestly as long as you export it in react-refetch there's no practical difference at all, I had no trouble implementing this today importing PromiseState from react refetch\n. #93 does the most significant part of this, so I'll close this issue\n. I realised now that for this to be useful value has to be a function that returns a promise, instead of a promise, otherwise it will recompute every time anything about props changes, which seeing as these are potentially expensive operations (that's why they're async in the first place) is a deal breaker. \n. Assuming that any function that is assigned to value is a promise-returning function that we should call sounds too restrictive (I don't see a use case for using identity requests to inject a function, though, so maybe not?), another option is for this behaviour of promise identity requests to be under a new key promise. what do you think?\n. This is definitely not something that I need in every component but I've now hit a second situation where I'd have used this, do you think this belongs in react-refetch @ryanbrainard ?\n. value: somethingThatReturnsPromise() works inside then, andThen, etc., in functional mappings. The only place where it might be problematic is directly as a top level request, but even then it's probably fine for most uses because we now only re-run the mapPropsToRequestsToProps function if the props changed. So I think it's fine as is, what do you think?\n. I think I'm going back on this and I think this optimisation should apply only to componentWillReceiveProps \u2014 ie. whether to call refetchDataFromProps or not \u2014 and not do anything on shouldComponentUpdate \u2014 ie. whether to rerender the component or not.\nRationale is two fold:\n- if we keep the optimisation confined to componentWillReceiveProps there's no need to make it optional, since it doesn't affect re-rendering the wrapped component\n- while it's impossible for a user of react-refetch to apply the optimisation of componentWillReceiveProps without our explicit support, it's trivial for the user to apply the re-render optimisation, either use PureRenderMixin, write a shouldComponentUpdate on the wrapped component or wrap the wrapped component in eg. https://github.com/acdlite/recompose/blob/master/docs/API.md#pure before passing it to connect\nWhat do you think @ryanbrainard ?\n.  I'm not sure myself, because for my uses I always want the component to be pure, but some use cases might require that it be non pure, so it'd probably have to be an option and I don't like options...\n. I've rebased\n. Good points.\nThis got me thinking about times when componentWillReceiveProps is called:\na) the connected component is rendered inside a component that has state \u2014 every time the state of the parent changes componentWillReceiveProps of the connected component will be called even if nothing about the props changed, see this gist I made real quick http://esnextb.in/?gist=4c7a4e4335d112eacab14c8f0ef5d6e6 (click execute, probably only works in chrome)\nb) same as above but the connected component is rendered with children \u2014 gist: http://esnextb.in/?gist=8d2073bb6513d796670665685b38df4f\nc) ~~the component wrapped by connect defines contextTypes but the connect function doesn't use context (it's the wrapped component itself that needs the context)~~ (edit: forget the context case, see issue #99, the way I'd fix that would make sure the component never gets contextTypes if mapPropsToRequestsToProps doesn't depend on context)\nThe optimisation in this PR takes care of (a) and (c). (b) would actually be good to take care as well, I don't think there's any sane use case in which mapPropsToRequestsToProps uses props.children so we could just omit children in the shallowEqual comparison. What do you think about this?\nAs for subtle bugs, basically they'll come down to times when people write mapPropsToRequestsToProps functions that are either not pure (eg. depend on document.location) or when they change something their props in a way that maintains shallow equality, let's be on the lookout for that, but what would you want to do if such issues appeared, remove the optimisation or make it optional?\nDirectly doing something like\njs\nonlyUpdateForKeys(['this', 'that'])(connect( props => ... )(SomeComponent))\nsounds perfectly reasonable but I think the cases above make this more primitive optimisation worth it, what do you think?\n. - re: children, comparing children is basically what React does internally every time render is called to decide whether anything in the DOM needs to change, so I don't think we should try to do that ourselves (especially because children is kind of an array of objects that can contain other children props, so comparing children is basically a deepEqual comparison of two objects, which is pretty expensive. Comparing just keys isn't enough because you might have a set of children with the same keys but different props. But for componentWillReceiveProps I don't think there's any value to comparing children, you can't use them inside mapPropsToRequestsToProps so you don't care whether it changed I think. (If we're talking about something for shouldComponentUpdate then the fact that comparing children is too expensive still applies, I think when children changes you have to call render again and that's it)\n- as for mixing defaults and options I agree that it is confusing to define them in the same object/method. But I think the idea of defaults as a method that you call and which returns a new connect with the defaults applied is superior to the previous way of setting settings as the 2nd arg to connect because settings might also be something you want to share across your whole app. So maybe another one of these methods called options for setting these options like withRef?\n. I've opened a PR with the .options() method. How do you want to go about omitting children, do we use eg. omit from lodash or do we add that functionality to our shallowEqual?\n. @ryanbrainard any opinion on the above, whether to use a dependency for that or not?\n. @ryanbrainard sadly lodash doesn't have a\nshallowEqual so that one we should probably keep ours, but I'll use lodash for omit to omit children. Another thing, I've now seen the pattern connect(...)(pure(Component)) enough times in my code that I think it's worth it to add in the shouldComponentUpdate optimisation to react-refetch (since mapPropsToRequestsToProps is already supposed to be a pure function, it's very likely that a significant part of the users also make their wrapped components themselves pure functions...). Do you agree with adding it? Should it live behind an option pure like in react-redux?\n. To be consistent with Promise.resolve I think I actually agree with your first comment, since Promise.resolve(new Promise((resolve, reject) => reject())) is a rejected promise it sounds like PromiseState.resolve() should do\nif (value instanceof PromiseState)\n  return value\nelse\n  return new PromiseState({\n      fulfilled: true,\n      value: value,\n      meta: meta\n    })\n. fixed in #100\n. hmm... but if we set force: true on then and catch doesn't that mean that any request with a then will be refetched every time mapPropsToRequestsToProps is called? That sounds wasteful, and surprising to the user, no?\n. I've updated the API docs (also with the changes mentioned in #98). While I was at it I fixed two small things in the README\n. @ryanbrainard I also added a test for an untested part of the .defaults() method \u2014 making sure it doesn't apply the defaults to the original connect it is called on. Also fixed the comparison test in the same manner as #101\n. Looks great :)\n. in two places i think: https://github.com/nfcampos/react-refetch/blob/master/src/components/connect.js#L213 and https://github.com/nfcampos/react-refetch/blob/master/src/components/connect.js#L189\n. actually you're right, i'll do it just in the one you linked to\n. done\n. @ryanbrainard should I include the shouldComponentUpdate thing in this PR?\n. (I went ahead and updated the react devDependencies to v15)\n. similar optimisation but for preventing extraneous re-renders, the one we talked about here: https://github.com/heroku/react-refetch/pull/94#issuecomment-209108489\n. should I make it optional, the component being pure, only re-rendering when props or state shallowly changed?\n. should the pure option also control the componentWillReceiveProps optimisation? or in other words, setting pure: false only allows the render method of the wrapped component to be impure or also allows the mapPropsToRequestsToProps function to be impure?\n(I'll do the API doc changes when we decide what the pure option controls)\n. I've made the changes you mentioned, just missing the tests for componentWillRecceiveProps when pure is false and updating the API docs\n. @ryanbrainard I've added the missing tests and updated the API docs\n. I need to remember what I was trying to do using both that led me to find it wasn't possible, it's certainly not a common need. In a way you can already do it, I guess you just have to define the andThen hook on the then mapping, instead of the original \n. Yeah I agree this doesn't look like an amazing solution. I actually did it partly because it was so easy, most of the necessary code was already in place.\nI actually think the existing hooks are enough if we allow returning undefined for when you need to use them for side effects \n. If not for what I mentioned in this comment https://github.com/heroku/react-refetch/pull/111/files#r60853379 I'd agree with leaving this in without the final return. Because of that, and considering the limited utility, I'm on the fence. What do you think about the issue of leaving promises unhandled?\n. one possible benefit of pulling this promise refactor in is that it allows us to register a general onError handler for all react-refetch asynchronous operations, not sure we need that though\n. that sounds like a better idea, but that's the sort of thing I want to set on .defaults(), but how do I set that as a default, since it only applies to PATCH requests? (maybe to address this the signature could be\njs\n(prevMapping, nextMapping) => {\n  if (nextMapping.method == 'PATCH')\n    return {...prevMapping.value, nextMapping.body}\n}\nI'm really unsure about this though since it kind of looks like going down a rabbit hole of niche customisation...\nWhat do you think?\n. reading the Response body via response.json() only consumes the body not the headers. The headers are made available at meta.response.headers. Can you provide more detail of your situation in which the headers are not available?\n. Ah, I see. That's replacing the whole PromiseState with one that has just value and doesn't have meta anymore. I believe meta is available as the 2nd arg to the then handler.\nSo you could do something like\njs\n    projectSearch: {\n      url: `/api/search${queryString}`,\n      comparison: queryString,\n      then: (results, meta) => {\n        return {\n          value: normalizeProjects(results),\n          meta: meta\n        }\n      }\n    },\n. Thinking about this a bit more it seems that default andThen and default andCatch are fine because the comparison prevents the requests from going forward. (if the default andThen has force: true it might fall into this bug as well)\n. @jsullivan yeah I'm not sure how to fix this bug and still cleanly support setting a default for then. I don't see any way of doing so that doesn't treat then mappings as somehow special, which I'd like to avoid\n. this contains important fixes for the tests (to make sure something like #119 doesn't happen again) so it should be pulled in as soon as we find a nice way of fixing #119\n. @jsullivan I've updated the docs :)\n. Thanks :)\n. @jsullivan I've updated the docs. I also made refreshing functions be ignored if it is set on a mapping that was never fulfilled before, I'd forgotten this the first time around.\n. hi @ryanbrainard :)\nso this would make it so that mappings that have a parent just do not inherit default then and andThen, right? I think this ends up being the most straightforward solution, so it's less likely it'll surprise someone. And yeah it makes sense to inherit fetch and the other two from the parent. I think those three are enough.\n. Yeah I agree parent should always be the top level mapping\n. the cleanest way to do that is to save a reference to parent (if it exists) in each mapping, inside coerceMapping, any reason not to do that?\nlike this:\n\n. alright, should we allow undefined for all keys or just these 4?\n. yeah I think we can allow undefined only for these 4 for now\n. closed by #128 \n. fixed now\n. @ryanbrainard could you cut a release with this?\n. @ryanbrainard Thanks!\n. this happens because the first time render is called componentDidMount hasn't been called yet, so countriesFetch isn't defined yet. makes sense?\n. how about just using withState from https://github.com/acdlite/recompose/blob/master/docs/API.md#withstate ? Wouldn't this do what you're after @eyalw ? This is what I do in my components when i need something similar\njs\ncompose(\n  withState('containerState', 'setContainerState', null),\n  connect(...)\n)(MyComponent)\n. seems fine other than my comment\n. It's been working great for me, haven't found any issues with it\n. (and the current behaviour goes against the docs ;) https://github.com/heroku/react-refetch/blob/master/docs/api.md#promisestate)\n\nProperties should be treated as read-only and immutable. If the Promise enters a new state, a new PromiseState object is created.\n. This looks great! \ud83d\udc4d \n. Thanks!\n. how about this?\n\njs\nconnect(() => ({\n  updateUser: (user) => ({\n    something: {\n      ...,\n      then: () => {\n        browserHistory.push(`/users/${user.id}`)\n      }\n    }\n  })\n})\n. why not use a getter?\njs\nconnect.defaults({\n  headers: {\n    get token() { return localStorage.getItem(\"token\") }\n  }\n}). Fair enough, would it be better then to change the code to allow getters to be used, eg. using Object.getOwnPropertyDescriptors and Object.defineProperties instead of Object.assign?. I tend to prefer to use language features in place of new APIs but don't mind too much either way.\nAnyway, it's up to @ryanbrainard i'm just offering my 2 cents as someone very familiar with the library. @ryanbrainard I agree, this change should probably apply everywhere, not just to headers. And I'm afraid it should be a major version bump, because it does possibly change what values we use for properties in the mappers \u2014 ie. for users that were using getters we'd previously always be using the value the getter returned when we internally use Object.assign, and now we'd only invoke the getter once the value was actually used in a request.\nThe change would basically be replacing all usage of Object.assign with something like \njs\nfunction assign(target, ...sources) {\n  for (source of sources.filter(Boolean)) {\n    for (key of Object.keys(source)) {\n      const descriptor = Object.getOwnPropertyDescriptor(source, key)\n      if (descriptor.get) Object.defineProperty(target, key, descriptor)\n      else target[key] = source[key]\n    }\n  }\n  return target\n}\nSo, it wouldn't be much work to change it, but it does sounds like something that would have to be considered more carefully.. @ryanbrainard sorry for the late reply, yes I do agree, we should be checking only at fetch time, should make testing less fiddly. (test modes I'm not a fan of, but by moving the check to fetch time we can avoid that I think). @passcod if you move the defaults inside connect() all the tests pass\nthis line becomes:\njs\nconst { fetch=window.fetch, withRef=false } = options\nremove the defaults outside of connect and do\njs\nexport default connectFactory()\nit's something to do with window.fetch not being defined when the module is imported, but being available at the time the connect function is called, that's why inside connect() works but outside it doesn't\n. we might want to add some check here to make sure the passed argument at least is a function\n. see my comment in that issue for a reason to keep the option\n. yes i agree with dropping the window part (one difference is it will throw a ReferenceError if it isn't defined, ie. if the browser doesn't have it and the user forgot to include a polyfill, but this is probably a plus actually)\n. about the name I'm not sure, you're right it might be confusing for someone dropping in on the code without context, but would a comment suffice?\n. yeah an invariant is indeed better than the ReferenceError\n. we can only be sure Object.assign is available if a polyfill is included, no?\n. but actually i think it'd be better to use the assign function from lodash or some other library rather than maintaining our own assign method\n. yep just Request should be enough. customising Request sounds like a bad idea since it's the Request object is used internally by fetch, no? I mean, Request is basically an implementation detail of fetch(), so I don't really see anything that could be achieved with a custom Request that you couldn't do by supplying a custom fetch\n. good point, I've renamed it.\n. added :)\n. oops, bad habits :)\n. This example suggests there's no use case for providing a default Request which is not covered by changing buildRequest, seeing as you could just return new MyCustomRequest(...) at the end of your custom buildRequest. Is there a use case for replacing Request without replacing buildRequest?\nWe at least need a warning preventing the user from supplying both custom Request and custom buildRequest, since a custom Request would only be used by the default buildRequest\n. strictly speaking fetch isn't ES6, it's just a browser API, but it doesn't really matter\n. if anyone can think of a better name for this._propsAndContextDidntChange I'm all ears :)\n(I save it to avoid recomputing it shouldComponentUpdate (which, if props or context changed, always runs after componentWillReceiveProps))\n. yeah I wasn't sure about making it two separate lists, the idea was that those 4 are kind of really not something you will usually use at the individual mapping level, but that's kind of a weak reason to separate them\n. should I make this change to the other state objects as well? I don't need to because I never compare them like I do data, but maybe it'd be more consistent?\n. this is implicitly assuming the default is pure: true, should it?\n. I removed these because it's no longer true, there is a need to re-render there because the prop changes in a way that is not shallow equal\n. this would be simpler if I were to shallow compare the props again, is the complexity worth the performance gain from not calling shallowEqual again for the props?\n(if the reason for shouldComponentUpdate being called is the props having changed, componentWillReceiveProps will have been called just before)\n. exactly, should i change this to be less confusing?\n. So writing a componentShouldUpdate for components that have children is kind of a bummer, because the children will always be different on every update, even if they didn't change. The only time this is not so is when the component doesn't have children, in which this.props.children == nextProps.children is always true. Since connected components might or might not have children this condition is there for the times when the wrapped component doesn't have children.\n(You have to re-render a parent when the children change, otherwise the new children would never appear on the screen)\n. should i add a comment explaining this._propsDidChange is defined in componentWillReceiveProps and will be used in componentShouldUpdate?\n. alright, i'll take it out\n. Ah, so the way I did this is the promise resolves not with the PromiseState but with just the value (it was less code this way, and I didn't see any use for the rest of the PromiseState, but now I'm thinking maybe meta would have been useful)\n. yep, forgot about that, ive removed it now\n. I think this one doesn't need a returnbecause it's a functional mapping, there's no useful return value for a functional mapping (I guess), so I just placed the return below and it returns undefined\n. This line I'm not sure about, because up until now the promise created in createPromise was handled (ie. became a fulfilled promise) if it rejected. With this change, re-throwing the exception, we're making it an un-handled promise, which will emit the unhandledRejection event that browsers are starting to implement. I'm not sure it makes sense for react-refetch, as a library, to leave the promise unhandled like that, especially since we do handle it (set the correct state in the component etc.)\n. Good point about making sure then was actually called. if we decide to keep this i'll add that to the test\n. handleResponse: parent.handleResponse,\n. I'm not sure why but when run in watch mode this test was failing because these two times were equal\n. before the 2nd run in watch mode the jsdom globals would be recreated and the fetch polyfill would get confused\n. yeah in watch mode the 2nd time the test ran it always failed there (without watch mode it had never failed for me)\n. actually I tested it and an array is coerced to a string correctly, eg.\njs\narr = ['function', 'undefined']\nstr = `then must be a ${arr}`\nstr will be then must be a function, undefined which is pretty clear but when types is an array I can replace a with one of so that it becomes then must be one of function, undefined, should I do that?\n. done\n. only if you passed withRef: true to options, otherwise component will be undefined\n. if objA is undefined then typeof objA won't be 'object' so there's no need to check for both, just remove the === undefined check\n. Yeah that's a little weird\n. ",
    "joerodrig": "This was an issue stemming from the way I was loading my component via the React-on-Rails gem and then the React Refetch call. Instead of calling the Connect() call to load my component, I was still exporting my initial React component and loading the view with that, and with my Connect() call in the same file, I was actually then just loading the JSON data which resulted in the back button only recognizing that request\n. Ah I see, thank you. I was able to get this working last night. Just for reference for everyone, what @eyalw said above is the correct syntax if you're chaining a refresh call.\nIf you want to chain anything else, you wouldn't the parenthesis, ie. modifying props(see issue https://github.com/heroku/react-refetch/issues/47).\nI'll submit a quick PR to add the parenthesis to the docs.\n. ",
    "passcod": "That's interesting, but not much more than my code block above. It acts globally, so it doesn't provide the ability to set interceptors or modifiers or proxies or whatnot on a per-connect basis, which is really what I wish for.\n. It also doesn't play great with libraries or other parts of my code that use fetch but shouldn't be affected by the modifications I make for react-refetched components.\n. (Yes, I was reluctant at first, seeing replacing fetch as a nasty hack, but with further thought, the fetch interface is quite neat and simple, and I can definitely see a small ecosystem of stack-agnostic libraries that override fetch. Like gulp and node streams ubiquitised the Pipe Transform as building block for anything, and React got the connect() pattern, and ES7 brings @decorators, and express/rack made server middleware essential, so could fetch middleware become another such pattern and building block. Or maybe that's just wishful thinking.)\nOk, that is tricky. I originally knee-jerked like \"just add it to the options obj\u2014 ah\" but there's no options object. Your API is really clean! :+1: \nJust for arguments sake, we could add it to the main argument but uuugh so ugly:\njs\nconnect(props => ({\n  fetchProvider: customFetch,\n// or maybe:\n  _fetch: customFetch,\n// yeah, nah.\n  usersFetch: {\n    url: `/users`,\n    then: (users) => ({\n      value: users.filter(u => u.verified)\n    })\n  }\n}))(Users)\nI guess the two cleanest ways would be:\nAs second argument to connect()\njs\nconnect(props => ({\n  usersFetch: {\n    url: `/users`,\n    then: (users) => ({\n      value: users.filter(u => u.verified)\n    })\n  }\n}), customFetch)(Users)\nOr with an options object, maybe:\nconnect(props => ({ ... }), { customFetch })\nThat may introduce a slippery slope / precedent of adding options, though, which may be against the aesthetics / goals for this API.\nAs argument to static method on connect:\njs\nconnect.withFetch(customFetch)(props => ({\n  usersFetch: {\n    url: `/users`,\n    then: (users) => ({\n      value: users.filter(u => u.verified)\n    })\n  }\n}))(Users)\nProbably more idiomatic like:\n```\nimport React, { Component } from 'react'\nimport { connect, PromiseState } from 'react-refetch'\nimport { usersFetch } from './fetchProxies'\nconst refetch = connect.withFetch(usersFetch)\nclass Users extends Component { ... }\nexport default refetch(props => ({\n  usersFetch: {\n    url: /users,\n    then: (users) => ({\n      value: users.filter(u => u.verified)\n    })\n  }\n}))(Users)\n```\nMy preference is slightly for the second form, as it makes it really explicit and self-descriptive (in a way that a second argument won't), without adding an options object. I'm not too attached to the .withFetch name, though, but naming is hard.\n. Absolutely! I'll get on it this weekend.\n. Definitely, thanks for suggesting it :)\n. :tada: :package: \n. Looks to work fine, except I now have half of the tests failing and it's the wrong half (the withFetch and chaining tests pass fine). Investigating.\n. Sure! Here's a gist with the test fails. I've pushed the failing code on this PR (I'll squash when it's all fixed :) It's past midnight for me, going to adjourn until tomorrow.\n. All fixed up, and squashed into one commit. @ryanbrainard review?\n. @nfcampos You'll need to return a Response from within your last .then(). Given Responses can be constructed from user code, this is fine. Modify the data, do whatever you want, then construct a new Response from the original and the new data. Then that will work fine with React-Refetch as you'll be respecting the fetch API as spec'd. Maybe:\njs\nconst customFetch = (...args) => {\n  return fetch(...args)\n    .then(resp => resp.json().then(data => ({ resp, data })))\n    .then(({ resp, data }) => {\n      if (data.task)\n        return pollUntilTaskCompletes(resp, data)\n      else\n        return resp\n    })\n}\n// pollUntilTaskCompletes returns a Response\n. For the possibility of modifying Responses, it's not that terrible. One could write wrappers that take care of those details (that's my intention!).\n. Request preprocessing, definitely. fetch-level custom caching (construct and return a Response from memory or, say, IndexedDB instead of trying the network. A kind of page-local Service Worker that works today, if you will). Response post-processing with caution (or with something that takes care of it). As @ryanbrainard asked, I'll add something to the Readme about withFetch()... mentioning these caveats there is probably a good idea, right? \n. Sounds good. Do we want to do this in this PR or in another one as follow up?\n. That new proposal of three functions also takes care of factoring out the problem of the window.Request call as discussed above, very good.\n. withBeforeFetch doesn't really read well. Maybe either .beforeFetch(), leaving off the with prefix, but that runs into the problem of not really describing what's happening before fetch. So instead perhaps withRequestBuilder(), as a rewording of the original?\nAnd withResponseHandler() or just withHandler() for the other one.\n. Good point on the withFetcher. Anyway, these don't look like words to me anymore, ugh. I'm going to take a break and come back to this later today. As a side note, I won't be able to work on this from Thursday until Monday or Tuesday due to surgery so if I don't respond during that period that's why ;)\n. Could always do both: withRef, withFetch... and a convenience .with({ ref: true, fetch: () => {}, ... }) that takes an object and maps it to the chained methods in one go.\n. So surgery went well and although I'm not going to actually work on this until the weekend, I wanted some clarification:\n1. Is every property that can be set in defaults() also available in the individual fetch blocks, or are there things that are defaults-only (or fetch-block-only)?\n2. The list of properties that can be in defaults:\n   - [x] buildRequest\n   - [x] fetch\n   - [x] Request\n   - [x] withRef\n   - [x] handleResponse\n   - [x] refreshing\n   - [x] headers\n   - [x] comparison\n   - [x] credentials\n   - [x] method ?\n   - [x] redirect\n   - [x] refreshInterval\n   - [x] force\n   - [x] then,\n   - [x] catch,\n   - [x] andThen,\n   - [x] andCatch\nAny I've missed?\nAs an addition, although this should probably be another PR done later, how about a urlBase or urlPrefix default so we can avoid repeating the same thing over and over?\n`` js\n@connect.defaults({ urlBase: '/api/v3' })(props => ({\n  usersFetch: '/users',\n  projectFetch:/projects/${props.projectId}`\n}))\n// instead of\n@connect(props => ({\n  usersFetch: '/api/v3/users',\n  projectFetch: /api/v3/projects/${props.projectId}\n}))\n```\n. Probably this weekend :)\nOn Wed, 23 Mar 2016 06:50 Ryan Brainard notifications@github.com wrote:\n\n@passcod https://github.com/passcod Just wanted to check in on this PR.\nLooks like you added some commits, so guessing you're feeling better :) How\nclose do you think this is from being ready for review and merge?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly or view it on GitHub\nhttps://github.com/heroku/react-refetch/pull/76#issuecomment-199935324\n. Checklist, in rough order:\n- [x] Implement (see checklist on https://github.com/heroku/react-refetch/pull/76#issuecomment-195805510)\n- [x] Test checks (see same checklist)\n- [x] Figure out what is contaminating the environment so I can properly do the item below\n- [x] Test \"Missing available fetch impl\" check\n- [x] Push working code once the above is done\n- [x] Test behaviour (see same checklist again)\n- [x] Push working code once the above is done\n- [x] Readme blurb, including caveats and usage guidelines for fetch\n- [x] Mention that Object.assign (also see #82), Promise, fetch have to be polyfilled by the user, if necessary.\n- [x] API docs for the new defaults\n- [x] Push when documentation above is done\n- [x] Test deprecated options usage warning\n- [x] Warn the user from supplying both custom Request and custom buildRequest, since a custom Request would only be used by the default buildRequest\n- [x] Fix the then, andThen, catch, andCatch tests\n- [x] Push working tests above\n- [x] Final overall check\n- [x] Squash / clean up history\n- [x] Rebase onto master\n- [x] Final test run and lint\n- [x] Ask for review\n- [ ] :question: Figure out what to do about force and comparison (does it even make sense to set them in defaults?)\n- [ ] :sparkles: Review :sparkles:\n- [ ] :ship: \n- [ ] Open urlBase PR\n. Interesting consequence of this PR: I can try things out in a node REPL without the library complaining about missing fetch/Request objects. The isomorphic people are going to be happy. (Question about expect edited out because I figured it out.)\n. I can't see a test for force's behaviour in the original suite, so I'm not sure how to test that force is being overriden in defaults. Not sure it makes sense for that to happen, but still.\n. Here's a thought: should .defaults() also set defaultMapPropsToRequestsToProps?\n. It should be finished tomorrow (so ~24 hours, it's late night here), and after that the review will take a little bit. I'd say it will be merged next week (as in the first week of April), tops? But I can't really predict those things.\n. Isomorphic discussion should probably be done on #11. Note that this PR is very much not focused on delivering a complete solution for isomorphic React Refetch. I have not and will not test more than what I have outlined in the checklist in this regard, and I strongly suspect that there will need to be further work to make it work completely in Node for the purpose of isomorphic rendering.\n\nA temporary solution to get the code to run is to just use my branch, although it may break suddenly. I recommend you just wait.\n. @ryanbrainard: Review please! :)\nAs mentioned above in https://github.com/heroku/react-refetch/pull/76#issuecomment-201687379 the only thing I'm not sure about is whether force and comparison make sense in defaults. I've added them anyway, but there are no tests for them. There is no test at all for force as of before this PR, and I can't figure out how to test for comparison when used in defaults.\nAt @nfcampos's suggestion https://github.com/heroku/react-refetch/pull/76#discussion_r57512221 I added a console info message if both Request and buildRequest are specified. I did not make it a warning as doing it anyway does not really do anything.\nThere are tests where I just wholesale copied source from previous tests or from connect.js source. I don't feel great about that, especially for the connect.js source material, but short of exporting some internal connect.js functions (the default internal buildRequest and handleResponse, notably), I don't really see a way around it.\n. force, refreshing, and a few others are Booleans, but they're Booleanish-ly evaluated, so they can be falsy/truthy. Checks thus don't make any sense, given we can supply literally anything.\nthen, catch, and others take functions, sure, but they can also take anything else and that will be evaluated as \"not a function\" and thus will not be used.\nBoth these behaviours are what was already happening, so I just didn't change them. The second one could probably benefit from a \"falsy or function\" check, though, sure.\n. And yes, setting fetch etc at the mapping level is not possible. I don't believe fetch-in-mappings to be particularly intuitive, especially once you start adding fetch block functions. (As in, those.)\n. I know it's a bit of a shitty feeling, but this PR has taken literally 20 times more time than I originally planned for, and even though actually implementing that change would be 8 lines, testing it would be a nightmare. For me. I think, anyway. I recognise there are some usecases for it. (You can also implement your example using a \"global\" handleResponse that switches based on the URL/Content-Type/whatever, so it's not like it's impossible to achieve this in the first place.) I'm just a bit tired of this. So, I'm asking for help? Here's a minimal patch for adding the feature:\ndiff\ndiff --git a/src/components/connect.js b/src/components/connect.js\nindex b20bfd6..e15abd9 100644\n--- a/src/components/connect.js\n+++ b/src/components/connect.js\n@@ -207,0 +208 @@ function connect(mapPropsToRequestsToProps, defaults) {\n+        buildRequest: defaults.buildRequest,\n@@ -209,0 +211 @@ function connect(mapPropsToRequestsToProps, defaults) {\n+        fetch: defaults.fetch,\n@@ -210,0 +213 @@ function connect(mapPropsToRequestsToProps, defaults) {\n+        handleResponse: defaults.handleResponse,\n@@ -215,0 +219 @@ function connect(mapPropsToRequestsToProps, defaults) {\n+        Request: defaults.Request,\n@@ -224 +228 @@ function connect(mapPropsToRequestsToProps, defaults) {\n-    return new defaults.Request(mapping.url, {\n+    return new mapping.Request(mapping.url, {\n@@ -325 +329 @@ function connect(mapPropsToRequestsToProps, defaults) {\n-          const request = defaults.buildRequest(mapping)\n+          const request = mapping.buildRequest(mapping)\n@@ -329 +333 @@ function connect(mapPropsToRequestsToProps, defaults) {\n-          const fetched = defaults.fetch(request)\n+          const fetched = mapping.fetch(request)\n@@ -332 +336 @@ function connect(mapPropsToRequestsToProps, defaults) {\n-            return fetched.then(defaults.handleResponse).then(onFulfillment(meta), onRejection(meta))\n+            return fetched.then(mapping.handleResponse).then(onFulfillment(meta), onRejection(meta))\n. > In fact, I have a pattern that I use that is a data context container around other components that silently refreshes on changes to the path (i.e. { comparison: location.pathname, refreshing: true }).\nThis sounds really cool!\nI'll try to make a test for comparison in defaults.\n. > I don't have access to the props\nYes, exactly, that's what I found when I tried to write tests. Supporting a function would be ideal, but probably not in this PR.\n. That should be it for the code changes, I'll do the handleResponse, fetch, and Request documentation tomorrow.\n. Rebased to master\n. Still a bit of docs to go, examples for fetch. I'm doing shopping now, but soon as get home :)\n. Ok, I think that's it :)\n. If we start to include polyfills, we better make sure that we also include polyfills for every feature we use that's not supported in [browsers we want to support]. And draw that line.\n. Pinging here as it's related. I have added some wording regarding polyfills in my PR: https://github.com/heroku/react-refetch/pull/76/files#diff-04c6e90faac2675aa89e2176d2eec7d8R19\n. One thing I wanted to do (but couldn't due to the one-file status of connect.js) when documenting #76 is that when, in the docs, there are places where it would be useful to refer to a particular place in the source, it would have been neat to actually link to the source.\nGiven that this PR is splitting everything up, that's now achievable :) For example, the handleResponse sample here would benefit greatly from a link to the default implementation in the source.\n. Yeah @nfcampos mentioned the polyfill thing, but lodash wasn't already included, so I wrote that. I just checked the Object.assign MDN page, and it shows an ES5 implementation which I believe is functionally equivalent to mine. We can revert to native Object.assign, as the code was already peppered with calls to it before this PR, though.\n. @ryanbrainard I left as-is to avoid too much scope creep on this PR.\n. Ah, hmm, I'd missed the call to window.Request directly. If a completely custom fetch is provided, it would be reasonable to expect a similarly completely custom Request. Annoyingly, there's no way to derive Request from fetch. We could have a separate .withRequest(Request) to not use the global Request, or add it as optional parameter to withFetch.\nThe fetch function signature can be any of:\njs\nfetch(req: Request)\nfetch(url: String)\nfetch(url: String, options: PlainObject) // same args passed to Request constructor\nfetch(req: Request, options: PlainObject) // options here override Request ones\nSo one can easily imagine switching between those forms to be done upon firstArg instanceof Request, where Request is internal to the fetch implementation. That's how github/fetch aka whatwg-fetch does it, for example. Also this other fetch polyfill. Heck, I just tried replacing window.Request in my browser (which has a native fetch), and from the behaviour, it seems it does the same thing.\nThus, using window.Request with a non-window fetch is probably a no-go.\n. Ah yes. We can make it transparently merge options and display a warning:\njs\n  function connectImpl(map, callOptions = {}) {\n    console.warn(...)\n    return connect(map, Object.assign(options, callOptions))\n  }\n. Ok :)\n. For your first point: yes, there is, when replacing fetch but not buildRequest.\n. Yeah, I can't find a way to rephrase that accurately. \"Modern platform features\" feels clunky and \"ES6 functions and browser APIs\" is too verbose. Idk.\n. For your second: I added it onto the list, ~~but am wondering about the future. Given that it is possible that a future React Refetch may very well use Request outside of buildRequest, and that including both is relatively harmless, is it really useful to console.warn() the users versus just adding a note in the readme?~~ done.\n. That's what I figured. Headers also doesn't have a simple way to merge, you'd have to iterate one to set values into the other, that's definitely more clunky than plain objects.\n. Yep, I had trouble phrasing this. Not sure if \"merging\" necessarily implies the overwriting. I added the example for that reason. I'll change to merge anyway in both places to keep it consistent.\n. This will be after coercion, yes.\n. Um, not sure which instance of fetch you're talking about here.\nIf the link to MDN: Not sure. I wanted to keep the distinction with the method name and the React Refetch terminology.\nIf the \"...global fetch, if available...\", that's because it can either be window.fetch, global.fetch, or self.fetch. If that's unclear I can try to reword.\n. Good idea, and it would avoid the clunky console && console.warn checking as well as the ESLint disables. I'll leave it for after review.\n. Neither meta nor value are in defaults, mostly because I figured they were special cases already as they're only used for development/faking responses/ad-hoc custom responses in fetch block functions/etc.\n. Escape characters that have special meaning in regexps. I'll add a comment.\n. I wondered about that. I like the idea, but what if you actually want to remove these defaults? Hmm, I suppose someone wanting to remove those headers could just set them to null or \"\" or something.\nWhat about .defaults() chaining? Intuitively, we would also merge headers there, right?\n. Hmm, tricky. I'll have a think.\n. Done above now.\n. IIRC, this warning is tested, so changing the wording may need a change in the test.\n. ",
    "edoardo-bluframe": "Hey you guys - amazing work!\nMy React app is using react-refetch - it's awesome - and I'm making my app isomorphic this weekend... and I ran into the the wahtwg-fetch issue when I import the Routes from node!\nDo you know when you're planning to merge the pull request?\n. Awesome - that would be amazing\nIs there a temporary solution you can think of so I can get the code to run?\nOr is it stop the iso-morphing till the PR is merged?\n. ",
    "Gui-Jun": "Ryan thanks!\nI have been fixed for Object.assign issue that you suggest for using babel-polyfill.\n. ",
    "felixgirault": "Hi,\nI'm sorry to reopen this issue but I had some trouble solving the problem.\nI find babel-runtime cleaner than babel-polyfill, and I thought it was doing exactly the same thing in the end.\nIn fact it does, but in a much more limited scope. For example, given this webpack config:\njs\n{\n  module: {\n    loaders: [\n      {\n        loader: 'babel',\n        test: /\\.js$/,\n        exclude: /node_modules/\n      }\n    ] \n  }\n}\n...and the babel-plugin-transform-runtime set up correctly, the code from react-refetch is not polyfilled as babel doesn't run on node_modules/.\nFinally, I ended up using babel-polyfill and it works like a charm, but I found something quite strange in the generated code from react-refetch (v7.1).\nIn lib/connect.js, Object.assign seems to be polyfilled at line 5:\njs\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n_extends is then only used at line 187, but everywhere else Object.assign is used directly.\nIt seems like the code is kinda polyfilled but actually not so much ^^ \nDo you know what could cause this ?\nAnd do you plan on shipping react-refetch already polyfilled in the future ?\nAnyway, thank you for the lib, and sorry for such a long post ;)\n. @ryanbrainard I totally understand your point on letting people use what they want as polyfills. But on the other hand I'm usually expecting a compiled dependency to work out of the box.\nIn fact, letting people polyfill fetch makes a lot of sense to me, but Object.assign is such a small utility that it is indeed a little annoying to have to include it myself. As @nfcampos said, it could easily be included in the build without increasing the bundle size too much.\n@nfcampos Adding warnings is a good idea, that's one of the things I really like in React.\nMaybe a good compromise would be to polyfill Object.assign in the build, but also include source files in the npm package so that the user can build its own version if needed ?\n. Thank you for adding that in the README, it will probably save you and the users some time :)\n. ",
    "loris": "@ryanbrainard @nfcampos Thanks for the example, I was wondering if there is a more DRYer way to make react-refetch access values in the context (in my case, authentication data such as API tokens) without explicitly doing this for every components using react-refetch (I have hundreds of them in a large codebase):\nstatic contextTypes = {\n  apiToken: PropTypes.string.isRequired,\n}\nI was thinking of wrapping my component with a \"child-as-a-function\" component (see example here: https://github.com/heroku/react-refetch/issues/140#issuecomment-245650583) instead of the HOC, what do you think?. +1\n. +1. Proposed solution is a lot of boilerplate. IMO :\nexport default connect(props => ({\n    experimentInfoFetch: {\n        url: `/json/experiments/${props.experimentAccession}/info`,\n        andThen: experimentInfo => {\n            return {\n                speciesFetch: `/json/species/${experimentInfo.species}`\n            }\n        }\n    }\n}))(GBLFetcher)\nspeciesFetch should be defined as a pending PromisedState as soon as the component renders. Why should we not have that behavior?. Hi @kieranja thanks for the heads up. This is already what I'm doing (using localStorage actually), and I will keep on doing this if this looks like a proper way to do this. It just doesn't feel very react to store data in globals, outside of state, props and context.. ",
    "ashaffer": "Doesn't that replace things with the result of moreThings? I'd like it to concatenate the two. Also, I receive the next page token as part of the response to the initial request.\n. ",
    "ewiner": "I was on the latest, v1.0.0-beta.8.  I'll let you know how it goes if I try beta-7.\n. ",
    "oblador": "Sure that works too, I'm kinda agnostic but there's already a .npmignore file. \n. So, do you want a new PR?\n. Aight, opened a new PR, closing this one.\n. Cool, a new npm version would be greatly appreciated too :-)\n. ",
    "msaron": "Yes. Thank you!!!\n. ",
    "Stupidism": "Request URL:http://127.0.0.1:8081/api/sensors\nRequest Headers\nProvisional headers are shown\naccept:application/json\ncontent-type:application/json\nReferer:http://127.0.0.1:8081/\nUser-Agent:Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.94 Safari/537.36\n. chrome browser fetch\n. ``` js\nconst ComponentWithSensors = ({ sensorsFetch, ...rest }) => {\n    if (sensorsFetch.pending) {\n      console.info('pending', sensorsFetch);\n      return ;\n    } else if (sensorsFetch.rejected) {\n      console.info('rejected', sensorsFetch);\n      return ;\n    } else if (sensorsFetch.fulfilled) {\n      console.info('fulfilled', sensorsFetch);\n      return ;\n    }\n    return ;\n  };\n```\n. Sorry, I can't reproduce it, either. But now I have another serious problem #138 .\nMaybe it was caused by me, only wrote this before.\nif (sensorsFetch.pending) {\n      console.info('pending', sensorsFetch);\n      return <Component sensors={defaultSensors} />;\n    } else if (sensorsFetch.fulfilled) {\n      console.info('fulfilled', sensorsFetch);\n      return <Component {...rest} sensors={sensorsFetch.value || defaultSensors} />;\n    }\n. Here is the 404 content. Also, when response content is a 200.html, it will cause react-router not working\n<Error>\n<Code>NoSuchKey</Code>\n<Message>The specified key does not exist.</Message>\n<Key>api/sensors</Key>\n<RequestId>0FD0FFD66C031E13</RequestId>\n<HostId>+DErSsifskDUSdFVTj2ywdImM3VPX7eUQ9I+L85TYJ3TG3OJDdsXknPL1EyzkZmf1KmrLGbkA7o=</HostId>\n</Error>\n. Yes, I figured it out. I solved this by adding my own handleReponse.\n. ",
    "TimothyKrell": "After watching this React Rally talk by @ryanflorence I've started experimenting with the child-as-a-function style for react-refetch instead of HOC. Using this pattern, this issue is not a problem.\n``` js\n// Create a wrapper component to facilitate the child as a function pattern\nclass Connector extends React.Component {\n  static propTypes = {\n    mappings: React.PropTypes.object.isRequired,\n    children: React.PropTypes.func.isRequired,\n  }\nrender() {\n    const { children, ...rest } = this.props\n    return children(rest)\n  }\n}\nConnector = apiConnect(({ mappings }) => ({\n  ...mappings\n}))(Connector)\n// Component with state\nclass StatefulComponent extends React.Component {\n  state = { userId: 1 }\nrender() {\n    return (\n      \n this.setState({ userId: id })} />\n        http://someapi.com/user/${this.state.userId}\n          }}\n        >\n          {({ user }) => {\n            if (!user.fulfilled) return \n        return (\n          <UserDetail user={user.value} />\n        )\n      }}\n    </Connector>\n  </div>\n)\n\n}\n}\n```\nThis may not be everyone's cup of tea, but it makes the state problem a non-issue. I'm liking it so far.\n. Thanks so much for your help! Using context did the trick.\nI like to use generic layout components as wrappers with named components for route children, so I ended up using this abstraction so I didn't have to keep re-wrapping the layout component:\n``` jsx\n// Routes definition\nconst customerConnect = props => ({\n  customer: {\n    url: customers/${props.params.id},\n  },\n  saveCustomer: (customer) => ({\n    customer: {\n      url: customers/${props.params.id},\n      method: 'PUT',\n      body: JSON.stringify(customer),\n      refreshing: true,\n    },\n  }),\n})\n\n\n\n\n// \nclass AppLayout extends React.Component {\n  static childContextTypes = {\n    connect: React.PropTypes.object\n  }\ngetChildContext() {\n    const { connect } = this.props.route\n    return {\n      connect: connect ? _.pick(this.props, Object.keys(connect(this.props)))\n        : {}\n    }\n  }\nrender() {\n    // renders toolbar and main\n  }\n}\nAppLayout = connect(props => {\n  if (!props.route.connect) return {}\nreturn props.route.connect(props)\n})(AppLayout)\n```\nThanks for the awesome library!\n. ",
    "BilalBudhani": "@ryanbrainard Oh, I see. I'm using this library in React Native that's the reason I'm facing this problem. \n. ",
    "PriteshJain": "removed extra semicolon.\n. @ryanbrainard @nfcampos I have updated the code removed undefined check and added few test cases for null and undefined check. Let me know if I can help in any other way.\n. ",
    "diegodurli": "Hey @ryanbrainard! Thanks for replying!\nI'm using a Chrome native fetch implementation, didn't change to add a custom one.\nNot sure about the underlying Promise being rejected. There's a specific way to check it?\n. ",
    "mars": "fetch doesn't reject unless the network connection fails. Otherwise the response resolves, and the HTTP status code must be checked in then.\nHere's an ES6/ES2015 fetch wrapper to handle unsuccessful responses:\n```javascript\nconst fetch = require('node-fetch');\nfunction fetchJson(...args) {\n  return fetch(...args)\n    .then( response => detectStatus(response, args) );\n}\nfunction detectStatus(response, originalArgs) {\n  const status = response.status;\n  if (status >= 200 && status <= 299) {\n    return response.json();\n  } else {\n    if (originalArgs instanceof Array) {\n      throw new Error(${response.status} ${response.statusText} from request to ${originalArgs[0]});\n    } else {\n      throw new Error(${response.status} ${response.statusText});\n    }\n  }\n}\nmodule.exports = {\n  fetchJson,\n  detectStatus\n}\n```. ",
    "tkh44": "@mars Thanks for the snippet. You can just check response.ok if you want to save some typing. . Yeah, I'm doing it that way right now. Just thought I would make an official request.. ",
    "ianstormtaylor": "I'm also curious about this. My use case is for easily rendering an inline loading/validation indicator at the right side of an <input> that shows that a field is saving/saved/errored after you've typed in it.\nIt's fairly easy to get these states:\njs\nconst isEmpty = !updateFetch\nconst isSaving = updateFetch && updateFetch.pending\nconst isErrored = updateFetch && updateFetch.rejected\nconst isSaved = updateFetch && updateFetch.fulfilled\nBut there's no easy way to \"reset\" (or potentially better named \"unset\") the lazy fetch after a bit of time to have the lifecycle restart itself for future edits.\nI think it would be nice to have an imperative API for it\u2014something as simple as:\njs\nupdateFetch.reset()\nBut, for consistency and simplicity, it would also be nice to add an automatic reset window in the request object, using an interval after succeeding, like:\njs\n{\n  ...,\n  resetInterval: 5000\n}\nSuch that the timer begins after the fetch succeeds.\nJust a concept, open to a different way to solve it simply though!\n. Thanks @ryanbrainard, that does seem like a viable solution! I'll experiment with it and see how it feels, but it seems like it's definitely close enough to warrant not adding more complexity to core.. Ah no, I forgot that it would require eslint-plugin-react to be upgraded, my bad. I kinda just fired this off quickly because I saw https://github.com/heroku/react-refetch/issues/152 was open and I figured why not open a quick fix. But now that I look at it again, I'm not exactly sure why that issue is open, because the eslint-plugin-react is pegged so it should never be a problem \ud83d\ude33. @ryanbrainard yup undefined sounds great to me!. ",
    "zhouchengcom": "@connect( props => (\n {\n        newProject: data => ( {\n            newProjectRespond: {\n                url: '/new',\n                method: 'POST',\n                body: data,\n                force: true,\n                headers: {\n                    'Content-Type': 'multipart/form-data'}\n            } })}) )\nand then\n \u2018const data = new FormData()\nthis.props.newProject( data )\u2019\nbut post data miss boundary= \njust like this\ncontent-type:multipart/form-data\n. raw fetch is ok      I found the right way is  set\nheaders: {\n                    'Content-Type': null\n                }\n\uff1a\uff09\n. ",
    "ivan-kleshnin": "@nfcampos oh, I felt like I've missed something from the docs... for a reason \ud83d\ude25 \nThanks! \ud83d\udc4d \n. ",
    "blaskovicz": "As a workaround, I had to override connect.defaults.fetch with some nasty logic.\n. ",
    "ghost": "+1. ",
    "alexcanessa": "+1\nAny updates on this?. ",
    "alfonsomunozpomer": "I went with andThen because, as it was stated in the docs, it specifically addresses the problem of needing the intermediate fetch result. I thought about using an identity request but couldn\u2019t figure out how... I wanted to do the whole thing in the first then but having a second one does the trick. :)\nThanks a lot for the reply. It helps a lot. In the end I did soemthing similar to your second alternative, but I\u2019ll change that to have all the fetch logic in connect.\nAlso, congrats for the project! It\u2019s definitely helped keeping my sanity.. ",
    "ericdfields": "I'm building the same sort of thing now. @loris with your technique, speciesFetch is undefined when the component renders and PromiseState throws an error.\nIf I include something like const allFetches = PromiseState.all([experimentInfoFetch, speciesFetch || PromiseState.create()]);, it works with your technique.\nEdited for clarity.\n. ",
    "kieranja": "How about an implementation of handleResponse which checks to see if your auth endpoint is being invoked - and if so, handle it differently? \nhandleResponse(response) {\n    if (response.url == '/api/auth') {\n       sessionStorage.setItem('token', response.data);\n    }\n}\n. @loris No problem! Absolutely - I know that feeling! Ultimately there is going to be some global state. This library itself actually uses functions such as fetch which are on the global scope (can see it's binding to window.)\nThe demo also mentions using a global function (getToken) or something along those lines. My login page is non-react (external site) which has to set a cookie with the access token. Eventually we'll move it over to react. However, I simply read the cookie using cookie.get('...'). I may be doing it completely wrong - but when implementing it I did a  lot of research and this seemed to be the most robust solution (moving to localStorage shortly)\n. ",
    "ghempton": "This seems sub-optimal to require a global here. Seems like it would be good to have a hook to apply defaults to mappings that has access to the context.. That approach breaks down for mappings to functions.. Is there any reason why we couldn't just continue to propagate the context into refetchDatum, further down the chain, and pass it in as an additional argument to buildRequest?. ",
    "garetmckinley": "@ryanbrainard So if an API endpoint is returning any error code, there's no way to silence it?. ",
    "aaronschwartz": "I have noticed this behavior as well. I'm using react-router, and if I navigate to a new page before an API request has returned from react-refetch, the polling is not cancelled from the previous page we were on and I see requests for both pages.. Yep it should be. Thanks.. I thought of using the getter as well but the object is spread into another object early on (at which point the getter is evaluated), but only the getter's value is passed on so it never gets evaluated again:\nhttps://github.com/heroku/react-refetch/blob/master/src/components/connect.js#L45\nI'll fix the Lint warning.. I don't really mind either way as far as API goes. There are a couple of places where the headers are object.assign'd and merged with overrides. I was trying to do the least amount of changes possible so I didn't break anything. I'm not too familiar with getOwnPropertyDescriptors and defineProperties.. I finally found the equivalent setup in jest. Posting for future onlookers.\nCreate a setupJest.js file:\n// setupJest.js\nglobal.fetch = () => {\n    throw 'DO NOT CALL fetch() FROM TESTS';\n};\nglobal.Request = () => {\n    throw 'DO NOT CALL Request FROM TESTS';\n};\nAdd to your package.json file:\n// package.json\n\"jest\": {\n  \"setupFiles\": [ \"./setupJest.js\"]\n}. Anybody get a chance to take a look at this?. Thank you!. Hmm.. You're right that it is strange that it is after but I was following the 'should not call setState if component is unmounted' test which does it similarly. But it seems to be working like this because it fails without my change and passes with it. \nI was having a hard time coming up with a better test than this. If you have any ideas that would be great.. I'm forcing the refreshTimeout._onTimeout after the component has been unmounted. If _onTimeout is called without the setRender(false), the setTimeout gets called and the refresh continues indefinitely even though the component has unmounted. \nIf you remove the code I added, this test does indeed fail. I'm not sure this is the proper fix, but it seems to be working for the issues I've been having.. ",
    "3ll3d00d": "This fixes it in my app. When will you publish an official release?. ",
    "dmr": "Thank you for the response. I unterstand your argument and think that it is a wise choice to wait for fetch.\nUnfortunately I still have the use case to implement so maybe I'll explore other options.. ",
    "tjokimie": "Fetch now supports AbortController which can be used to abort requests, see https://robwise.github.io/blog/cancel-whatwg-fetch-requests-in-react for example.. ",
    "ipanasenko": "@ryanbrainard thank you very much. I indeed saw identity requests part, I just didn't notice that I can provide a Promise to a value. Thanks!. @ryanbrainard what do you think about adding support for thenables? Right now we try to pass a thenable object instead of Promise instance, and it doesn't work properly. I can provide PR for this.. @ryanbrainard https://github.com/heroku/react-refetch/pull/176. I did it like this:\njs\nexport default connect(props => ({\n  likesFetch: {\n    value: api.getLikes()\n  },\n  createLike: likeText => ({\n    likesFetch: {\n      value: api.createLike(likeText).then(api.getLikes),\n      refreshing: true\n    }\n  })\n}))(Likes);\nBut anyway, making identity requests to have all the same feature as normal requests would be awesome. @ryanbrainard Hi, Ryan. Can you have a look at this PR, please?. Nice idea, but I think it will not work, as there will be at least three requests performed. In current code, mapping.value is accessed three times in one function, each time making a request. @slorber I've started, but abandoned it for now. I really hope @ryanbrainard will find time to implement this himself :)\nIn case someone wants to have a look at my progress, here it is: https://github.com/heroku/react-refetch/compare/master...ipanasenko:feat/identity-function. Okay, I think I've made it. Everyone, you are welcome to review and comment: https://github.com/heroku/react-refetch/pull/192. @ryanbrainard nothing, just two outdated dependencies, which caused multiple versions of same packages in my project, that's it. @ryanbrainard updated docs. @slorber I was very lazy, so I just built dist and copied it into my project's node_modules. You can fetch my branch and do the same ;). @slorber or modify your package.json to look like this: \"react-refetch\": \"ipanasenko/react-refetch#feat/identity-function-dist\",. I've installed 2.0.1, but I don't see types bundled with it. Am I missing something?. ",
    "nihakue": "Hey folks,\nCould identity requests same be used for updates/overrides? e.g.\njs\nexport default connect(props => ({\n  likesFetch: {\n    value: api.getLikes()\n  },\n  createLike: likeText => ({\n    likeCreation: {\n      value: api.createLike(likeText),\n      andThen: () => ({\n        likesFetch: {\n          value: api.getLikes(),\n          refreshing: true\n        }\n      })\n    }\n  }) \n}))(Likes);\nsandbox here\nI'm seeing that the update is not being called after creation. Is this possibly a bug?. Ah, I see! Thanks. Not quiet the same though, since andThen preserves the 'createLike' PromiseState and this clobbers it. Would love to see promises more fully supported.. Also, I couldn't get that to work. Had to end up doing the following:\njs\nexport default connect(props => ({\n  likesFetch: {\n    value: api.getLikes()\n  },\n  like: likeText => {\n    const likePromise = api.like(likeText);\n    return {\n      likeResponse: {\n        value: likePromise\n      },\n      likesFetch: {\n        value: likePromise,\n        refreshing: true\n      }\n    };\n  }\n}))(LikesContainer);\nWill sharing the promise cause problems with react-refetch?. What about this?\njs\nfunction mapPropsToRequestsToProps(props) {\n  return {\n    fooFetch: {\n      get value() {\n        return api.foo(props.id);\n       }\n     }\n   }\n}\nI'm not sure this will actually reduce the number of requests, but it will cause value to be lazily evaluated.. Could always memoize the promise! :p\njs\nfunction mapPropsToRequestsToProps(props) {\n  let foo;\n  return {\n    fooFetch: {\n      get value() {\n        return foo || (foo = api.foo(props.id))\n       }\n     }\n   }\n}. ",
    "slorber": "is someone working on supporting this feature? @ipanasenko ?. thanks @ryanbrainard i'm fine with such an API even if it's not as clear it's flexible enough so that I can provide my own abstraction. that that API is fine for me. @ipanasenko @ryanbrainard can we publish this as beta on npm? I'd be happy to test that implementation on a real project. thanks,\ni've just tested and it seems to work fine. @ryanbrainard maybe it's worth issuing a warning in dev in case function change over time and comparison is not provided. @ryanbrainard \n\ninitially my component does not receive any fieldValuesFetch (PromiseState) prop\nthen I type text, and it receives fieldValuesFetch as soon as there is more than 3 chars\nthen I erase the text, and make the text empty, and the component still receive the fieldValuesFetch which actually contains the result of the last text that triggered the fetch\n\nI'd like no NOT receive that prop when I make the text input empty again, because otherwise my autocomplete dropdown keeps showing former results when the input is empty. It looks to me the lib should do state cleanup when it detects that a fetch config has just been removed.\nI'd like to never receive the fieldValuesFetch prop when the input text length <= 2. Currently, this is not consistant and depends on former fetch results.\nAs expected, the following does not really do what I want:\njs\nconst ConnectedCompanyField = connect(({ value }) => {\n  return {\n    fieldValuesFetch: {\n      comparison: value.length > 2 && value,\n      value: () => searchField(value, ProviderLabel),\n    },\n  };\n})(CompanyField);\nWith this config the searchField promise API still fires, it's just it will fire only once as long as the comparison remains false, which can lead to something even more dangerous: results being queried for a small texts of 2 chars, and results not changing when the 2 letters do change because comparison remains constant. Here is a basic code solution to add the behavior I want. I'd like to submit a proper PR if you agree with this behavior and the implementation:\n```js\n        const arrayDiff = function(a,b) {\n          return a.filter(function(i) {\n            return b.indexOf(i) < 0;\n          });\n        };\n    const omitKeys = function omitKeys(obj,keys) {\n      const { x, ...copy } = obj;\n      keys.forEach(key => delete copy[key]);\n      return copy\n    }\n\n```\n```js\n      refetchDataFromMappings(mappings) {\n        mappings = coerceMappings(mappings)\n        Object.keys(mappings).forEach(prop => {\n          /// ... nothing here, keep the original code\n        })\n    // Do state cleanup on mapping removal\n    const removedMappingProps = arrayDiff(Object.keys(this.state.mappings),Object.keys(mappings));\n    // clear refresh timeouts before removal\n    if ( removedMappingProps.length ) {\n      removedMappingProps.forEach(prop => {\n        if (this.state.refreshTimeouts[prop]) {\n          window.clearTimeout(this.state.refreshTimeouts[prop]);\n        }\n      })\n      // remove prop mapping from state\n      this.setState({\n        mappings: omitKeys(this.state.mappings,removedMappingProps),\n        data: omitKeys(this.state.data,removedMappingProps),\n        startedAts: omitKeys(this.state.startedAts,removedMappingProps),\n        refreshTimeouts: omitKeys(this.state.refreshTimeouts,removedMappingProps),\n      });\n    }\n\n  }\n\n```\n. hi @horyd \nI've build this: https://github.com/slorber/react-async-hook\nmaybe it's what you were looking for? . it takes an async function, the 2nd args is the async fn args that will be injected. If they change data is refetched\nI'm trying to figure out if my code makes any sense, because suspense probably makes this useless. ",
    "justinjdickow": "Was much easier to just use Fetch for this. ",
    "heyimalex": "PromiseState is only a representation of promise state, its methods don't actually do anything but synchronously make more PromiseStates. Not that the idea is bad or your gripe is unjustified, just that PromiseState isn't the right place for it.\nI personally just write the code when I need it. If you're really lazy you could write a helper function :)\n``js\nfunction refreshable(key, url) {\n  return {${key}Fetch: url,${key}Refresh: () => ({${key}Fetch`: {\n        url,\n        force: true,\n        refreshing: true\n      }\n    })\n  }\n}\nconnect(props => ({\n  ...refreshable('user', /users/${props.userId})\n}))\n```. ",
    "rohit-ravikoti": "I figured out how to work around this for anyone who might be having similar issues:\nI was using the buildRequest default which was returning a new Request object-- safari and ios do not support this. So, I implemented a custom fetch that took an object with url and options and passed it in to fetch instead: return fetch(request.url, request.options). From buildRequest, I return the object in the specified format.\nHope it helps!. ",
    "andriijas": "@ryanbrainard  what do you think? Is the PR ok?       Thanks. Then we can just disregard this pr and go for #195 . ",
    "oscar-b": "@ryanbrainard Any update on this?. ",
    "ptoussai": "I can confirm that only this works: \nconnect.options({ withRef: true })(() => ({\n    postLogin: credentials => ({\n      loginResponse: {\n        url: urls.login,\n        method: 'POST',\n        body: credentials,\n        then(value, meta) {\n          console.log(meta);\n        },\n      },\n    }),\n  })). ",
    "wmonk": "Possibly also need to update hoist-non-react-statics. ",
    "horyd": "Yea I noticed when I tried 16.3 that none of the my PromiseStates were included in the props at all :S. Hi @slorber!\nCool package. Does that just take a regular promise as an argument? How is fetchStarwarsHero dependent on id?\nIf you like check out these two posts I wrote on the topic, the second one in particular might be handy as it is for triggering async behaviour on UI actions.\nhttps://medium.com/@jaryd_34198/seamless-api-requests-with-react-hooks-part-1-7531849d8381\nhttps://medium.com/@jaryd_34198/seamless-api-requests-with-react-hooks-part-2-3ab42ba6ad5c\nHappy to chat/collab, let me know :). I was taking a closer look at Suspense and it kind of applies mostly to the conditional/asynchronous rendering, not so much to the actual logic. I spent a bit of time exploring the concept of triggered async actions in that second article because in Suspense that would look a little odd?\nYou would need to have the onClick handler set a state variable that then rendered the Suspense component and from within that you made the POST request and handled the response?. ",
    "rjhilgefort": "Bump! (Sorry to be a bother).\nThanks for the awesome library!. Just want to chime in and say that I appreciate you guys working towards this! I'm not currently working on the project I was that needs this, but I love this library and look forward to having typing when I jump back. If there's still something to do when I get back to it, I'd be happy to help!. I'm seeing this as well. My workaround was just to use another HOC that transformed the props after.. @lmontoute's TS expertise is beyond mine, but it looks good to me. Much more complete than what I had created for myself and covers what I covered plus a lot more. Thanks for submitting this @lmontoute! \nForgive the potentially stupid question. Is it idiomatic to submit something to https://github.com/DefinitelyTyped/DefinitelyTyped as well?. @ryanbrainard I'm working with react-refetch on a TS project right now, so I'll bump to 2.0.1 and let  this thread know if I find any holes or issues in the type defs.. ",
    "lmontoute": "We wrote some types for this library actually, I can look into cleaning it up when I get some spare time to do so. PromiseState was straightforward enough, but mapPropsToRequestsToProps is a little trickier.. Not something readily available, unfortunately. Been a bit too busy to get these together. Here's what we use for PromiseState though if you want to take a look at adding more:\nEDIT: Finally got around to this! Will open a PR, for now this will work in a declaration file :)\n```ts\ndeclare module \"react-refetch\" {\n  import {\n    Component,\n    ComponentClass,\n    ComponentState,\n    StatelessComponent,\n  } from \"react\";\n////////////////////////\n  // PromiseState\n  ////////////////////////\n// Similar to PromiseLike\n  export type PromiseStateLike = T | PromiseState;\nexport interface PromiseStateStatic {\n    create(meta?: any): PromiseState;\n    refresh(previous?: PromiseState, meta?: any): PromiseState;\n    resolve(value?: PromiseStateLike, meta?: any): PromiseState;\n    reject(reason?: any, meta?: any): PromiseState;\n    all(iterable: Iterable>): PromiseState;\n    race(iterable: Iterable>): PromiseState;\n  }\nexport interface PromiseState {\n    readonly pending: boolean;\n    readonly refreshing: boolean;\n    readonly fulfilled: boolean;\n    readonly rejected: boolean;\n    readonly settled: boolean;\n    readonly value: T;\n    readonly reason: any;\n    readonly meta: any;\n    then: (\n      onFulfilled?: (\n        value: PromiseStateLike,\n      ) => PromiseStateLike,\n      onRejected?: (reason: any) => PromiseStateLike,\n    ) =>\n      | PromiseStateLike\n      | PromiseStateLike\n      | PromiseStateLike;\n    catch: (\n      onRejected?: (reason: any) => PromiseStateLike,\n    ) => PromiseStateLike | PromiseStateLike;\n  }\nexport const PromiseState: Readonly;\n////////////////////////\n  // connect\n  ////////////////////////\ninterface RequestType {\n    prototype: Request;\n    new (input: RequestInfo, init?: RequestInit): Request;\n  }\nexport interface Connect {\n    (map: MapPropsToRequestsToProps): (\n      component: ComponentClass | StatelessComponent,\n    ) => ComponentClass & WithRefetch;\n    defaults: (newDefaults: Mapping) => Connect;\n    options: (newOptions: ConnectOptions) => Connect;\n  }\nexport interface ConnectOptions {\n    withRef?: boolean;\n    pure?: boolean;\n  }\nexport type MapPropsToRequestsToProps = (\n    props: T,\n    context: any,\n  ) => PropsMap;\n// String or PromiseState\n  type PromiseStateMapping<\n    TProps,\n    TProp extends keyof TProps\n\n= TProps[TProp] extends PromiseState\n    ? string | Mapping\n    : never;\n\n// Function\n  type FunctionMapping<\n    TProps,\n    TProp extends keyof TProps\n\n= TProps[TProp] extends ((...args: infer TArgs) => void)\n    ? ((...args: TArgs) => PropsMap)\n    : never;\n\nexport type PropsMap = {\n    [TProp in keyof TProps]?:\n      | PromiseStateMapping\n      | FunctionMapping\n  };\nexport interface Mapping {\n    buildRequest?: (mapping: Mapping) => any;\n    fetch?: (request: any) => any;\n    handleResponse?: (response: any) => Promise;\n    Request?: RequestType;\nurl?: string;\nmethod?: string;\nheaders?: { [key: string]: string | (() => string) };\ncredentials?: \"omit\" | \"same-origin\" | \"include\";\nbody?: object;\nredirect?: \"follow\" | \"error\" | \"manual\";\nmode?: \"cors\" | \"no-cors\" | \"same-origin\" | \"navigate\";\nrefreshInterval?: number;\nrefreshing?: boolean | ((value: TValue) => TValue);\nforce?: boolean;\ncomparison?: any;\n\nthen?: <TReturned>(\n  value: TValue,\n  meta: any,\n) => Mapping<TProps, TReturned> | void;\ncatch?: <TReturned>(reason: any) => Mapping<TProps, TReturned> | void;\n\nandThen?: (value: TValue) => PropsMap<TProps>;\nandCatch?: (rason: any) => PropsMap<TProps>;\n\nvalue?: TValue | PromiseLike<TValue>;\nmeta?: any;\n\n// Everything else is passed through unmodified\n[key: string]: any;\n[key: number]: any;\n\n}\nexport interface WithRefetch {\n    WrappedComponent: ComponentClass;\n    new (props: TProps, context?: any): Component &\n      WithRefetchInstance;\n  }\nexport interface WithRefetchInstance {\n    getWrappedInstance(): Component;\n  }\nexport const connect: Connect;\n}\n```\nUsage is as you would expect:\n```tsx\nclass MyComponent extends React.Component {\n  // ...\n}\ninterface MyComponentProps {\n  myRequest?: PromiseState;\n}\nexport default connect((props) => ({\n  myRequest: \"https://www.example.com\", // Or an object with the relevant props\n}))(MyComponent);\n```. Got around to this today :)\nUpdated the above snippet with a full declaration file. Will look at submitting a PR.\nSome of it was quite a pain to figure out, I think this requires TypeScript 2.8ish if not 3.0 to handle the conditional and inferred types.. > @lmontoute's TS expertise is beyond mine, but it looks good to me. Much more complete than what I had created for myself and covers what I covered plus a lot more. Thanks for submitting this @lmontoute!\nNo problem!\n\nForgive the potentially stupid question. Is it idiomatic to submit something to https://github.com/DefinitelyTyped/DefinitelyTyped as well?\n\nEither option works. Keeping the types in the same repository helps ensure (theoretically) that they're up to date, and is recommended especially if the package is written in TypeScript. It also makes package consumption much easier, as developers won't have to independently search for types. \nMaking a PR to DefinitelyTyped for a @types/[name] package is useful if the repository owners choose not to have the types included with the package.\nNever both at once though, as it will lead to conflicts.\nIt's mainly a question of maintenance, especially if a package has an evolving API. Even though this package isn't written in TS, it might be worth keeping here if Flow types are being considered as well (that way, they can easily be kept in sync). Up to you folks of course :). Ah, I missed this! It seems index.d.ts just needs to be included under files in package.json. Or alternatively the type definitions can be moved, but a types field would need to be added to package.json (ex: \"types\": \"./lib/main.d.ts\")\nReferences:\nhttps://docs.npmjs.com/files/package.json#files\nhttps://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html#including-declarations-in-your-npm-package. Good to know! I wasn't 100% sure if both or just one of these were needed.\nAs for file location, I don't believe there are any issues in putting the file in a location that fits the project.\nFor example, we provide a library for our API with a lot more types. Instead of a single index.d.ts in the root, we break the types down into individual files + an index.d.ts in a types folder.. References fine for me in VSCode. Tested by deleting the types we're using, right clicking an import and going to declaration, which takes me to ./lib/index.d.ts.\nWe don't use every library feature exhaustively but I imported everything and there were no compiler errors across our whole project.\nI think this is good to go \ud83d\ude42 . ",
    "hburrows": "@lmontoute Do you have any initial typings that you can share?  I'm also interested in type declarations for this project and would rather not start from scratch. . @lmontoute Thanks for sharing.  I used dts-gen to bootstrap an initial declaration file and this is much better; I immediately knew I needed a parameterized PromiseState which you already have.  I'll definitely try to add more support and contribute back.  This package could really benefit from typescript (and flow) declarations.  I'm surprised nothing yet exists in DefinitelyTyped.  Let's change that!. I second bundling the type declarations here.  I've noticed a trend since using TS that more and more type definitions are migrating from DefinitelyTyped to their package.  I view DefinitelyTyped as a \"transitional\" place for declarations to exist before being adopted by the package proper.  I'm swamped but will look closely in the next day or 2.. @ryanbrainard This will need a release.  After merging I'm happy to use it directly and give it some burn in.  I have a couple pages that are going to use both react-refetch and react-redux and I'm curious if the HOCs will play nicely together.. Personally, I like using the types property.  The intention is very clear and unambiguous.. ",
    "dprentis": "Any thoughts?. Ok, thanks for the reply. My use case is, I need to pass an authentication header with all my requests to the api. This token is stored in a mobx store. I'm using the buildRequest handler to do this, so I need to access the store inside the handler.\nThe store is being injected into the component using a mobx-react Provider, so is available in props. The logical solution is to make props accessible to the buildRequest handler, because otherwise I would have to either:\na) make the store globally accessible and import it directly to use in the handler (not so nice IMHO)\nb) pass the store prop to the handler explicitly for each and every request, through meta. Also not nice IMHO.\nSimilarly, I have a handleResponse handler, which also accesses the store.\nAnyway, never mind - I will stick with my current solution for now and consider the other two options.\n. Would it be difficult to let connect.default optionally accept a function of props, that would return the configuration object? eg.\nconst refetch = connect.defaults(props => ({\n  buildRequest: function (mapping) {\n    // make request based on mapping and props ...\n  },\n  handleResponse: function (response) {\n    // return value based on response and props ...\n  },\n}));\n. ",
    "luke-unifymonitor": "Thanks Ryan.\nMy full use case is for a url which reads http://foo.com/{id}/{epoch} - The id would be the same across requests, but guess I would need that from the props. epoch would obviously change.  \nI thought this might do it...\nconnect((props) => {\n    return {\n      dataFetch: {\n        url: (props) => { return `http://foo.com/${props.id}/${new Date().getTime()}` }, \n        refreshInterval: props.refreshInterval\n      }\n    }\n  })\nI didn't realise it would always result in the props having old values though.  I'm not familiar with the code base - would that be a difficult thing to make happen?. Hi Ryan,\nCan you have another look?  I've placed all the code in index.js now so should be able to see it all from the default view.\nhttps://codesandbox.io/s/xrzrp27w4q\nThanks, Luke. ",
    "villesau": "Fixing this would require to change the fetch to start in componentDidMount instead of componentWillMount to get the handle to the component (connect.js:199), and adding the ref to meta in case of values too (connect.js:277).\nChanging the lifecycle method is reasonable but would probably require some bigger changes on how the promise state objects would be handled.. @ryanbrainard This prevents us from using e.g getDerivedStateFromProps with react-refetch. Using new lifecycle methods means that old lifecycle methods are not called:\n```\nvendor.js:504207 Warning: Unsafe legacy lifecycles will not be called for components using new component APIs.\nRefetch.connect(MyComponent) uses getDerivedStateFromProps() but also contains the following legacy lifecycles:\n  componentWillMount\n  componentWillReceiveProps\n  componentWillUpdate\n```. @tkvw what's the status of this?. ",
    "fc": "I'm stilling running into problems.  It will create an infinite loop because it triggers a re-render.  To me seems like a bug.  If the this.props.postLike(someSubject) callback could return a promise, I think that could make this work.\nIt looks like it calls refetchDataFromMappings here:\nhttps://github.com/heroku/react-refetch/blob/5519f201aa17f590b0e99baf233b88d80e9ef28a/src/components/connect.js#L242\nBut... it does not look like there would be an easy for it to return a promise.\nThoughts? or, suggestions on what to do? @ryanbrainard . Aha... using the PromiseStateContainer, I could use shouldComponentUpdate.\nshouldComponentUpdate(nextProps) {\n    const { ps } = this.props;\n    // ps changed, update\n    if (!nextProps.ps || ps !== nextProps.ps) return true;\n    if (ps) {\n      if (\n        ps.fulfilled !== nextProps.ps.fulfilled ||\n        ps.pending !== nextProps.ps.pending ||\n        ps.rejected !== nextProps.ps.rejected\n      ) {\n        // Status changed, update\n        return true;\n      }\n      // Status did not change, don't update\n      return false;\n    }\n    return true;\n  }\nBut... shouldComponentUpdate is not guaranteed to work like this in the future, since \"In the future React may treat shouldComponentUpdate() as a hint rather than a strict directive, and returning false may still result in a re-rendering of the component.\" Bummer.\nI did find a workaround but it still feels hacky since it uses the andThen hack I mentioned in my first post.\nIt seems like the way I can achieve what I want is to actually not use react-refetch for the case when I want to dispatch an action / etc.. ok..clearly I was making this all too complicated.\nThe simple way to achieve it is:\nconst ConnectedForm = apiConnector({\n  updateThing: (body, then) => ({\n    updateThingResponse: {\n      method: 'patch',\n      url: `/thing/${body.id}/`,\n      body,\n      then,\n    },\n  }),\n})(Form);\nThen in, for example, your onSubmit handler:\nonSubmit={values =>\n            updateThing(values, () => {\n                // stuff here\n            })\n          }\nI still like the idea of it returning a promise from refetchDataFromMappings which might be achieved by returning mappings from that, then access it as updateThing(values).then({updateThingResponse})... but this is not tested.. ",
    "mattrothenberg": "FWIW, I'm using this on a Next.js project, and was able to circumvent this error by including import 'isomorphic-fetch' in all of my connected components.. Nope, no more request errors. As long as I include the following (in any connected component), I seem to be OK.\n```js\n// UserList.jsx\nimport 'isomorphic-fetch'\nimport { connect } from 'react-refetch'\nconst UserList = () => ...\nexport default connect(props => ({\n  usersFetch: /api/users/\n}))(UserList)\n```. ",
    "KristerV": "hmm, you didn't even get the Request error? Interesting. I'll try this again at one point. For now I was forced to move back to simply using await fetch().\n@mattrothenberg Could you post a gist of your component? I do wonder how you've set everything up in terms of component functions and stuff. An example in the next.js repo under examples/ would be extra king, but too much work for me to ask you :D. Okay. Since my import was import fetch from 'isomorphic-unfect' I'll close the issue for now and open it again if following your example doesn't work for me. thanks! :). ",
    "tkvw": "I actually came across the same issue today. You need Request and fetch on the global state for react-refetch to work on SSR. I don't use react-refetch on the server, because I need user credentials to make authenticated requests and I'm not going to implement a proxy for this. So my solution is very simple, I created a blocking ssr hoc: \n// connect.js\nimport { connect } from \"react-refetch\";\nconst BlockSsr = Component => () => null;\nexport default (...args) => (process.browser ? connect(...args) : BlockSsr);. I decided to go with my own custom redux based implementation; this is on my to-do list, but don't expect it to be finished soon. . ",
    "raphaelpra": "Thanks for the merge !\nI agree with remark regarding the Request. However I do believe that any type is misleading. Since it is a common mistake to put an object instead of string in body of a request (I have done so many times). I appreciate having a type validation in this case.\nI will have a look on how we can allow other types (Blob, FormData, ...). Ideally, I think we should infer the type from Fetch library used. Not sure how to do it, but I'll have a look. Thoughts ?. Maybe something like that -> https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/node-fetch/index.d.ts#L168 without NodeJS.ReadableStream (backend logic) and URLSearchParams (that would require the new dependency 'url'). ",
    "gwn": "Thank you for taking the time!\nI agree that it may break some apps. Having a configured option makes sense to me.\nThe challenge is, what can we name that option? :)\noverrideParentProps, preferRefetchProps, preferRefetchPropsOnConflict; are some ugly suggestions.. ",
    "nuschk": "Yes, I tried that one. This leads to problems when calling loadMore() multiple times before it completes (which, e.g., when using react-virtualized, is normal, as the user is free to scoll on at full speed). You end up accessing old versions of data which have been updated since the call to loadMore.. ",
    "weekwood": "Fixed, think error come from copy paste. sorry about that.\n. "
}