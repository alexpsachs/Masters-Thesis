{
    "cfregly": "fixed.  thanks again, allen!\nclosing.\n. looks good, allen.  thanks for the quick turnaround.\nclosing.\n. ",
    "allenxwang": "I can change the dependency to eureka-client if that provides a workaround.\n. To programmatically set the list of servers, you can call this API BaseLoadBalancer.setServerList(List). \nThe load balancer created from ClientFactory all extends BaseLoadBalancer so you can safely cast it.\nIf the servers are dynamic, then use DynamicServerListLoadBalancer. First implement ServerList where you can dynamically set the list of servers, then pass the instance to DynamicServerListLoadBalancer.setServerListImpl()\n. 1) There is no existing implementation of ServerList that can do that. However, I imagine it can be easily accomplished by implementing one that delegates to both Eureka based (DiscoveryEnabledNIWSServerList) and configuration file based server list (ConfigurationBasedServerList). Normally it would delegate to DiscoveryEnabledNIWSServerList, but in case something is wrong, it delegates to the ConfigurationBasedServerList. The switch can be controlled by a Archaius DynamicProperty.\n2) The Rule that the load balancer users to choose a server is not currently changeable at runtime. To make use of multiple rules, you can either use inheritance or composition (decoration). For example, the AvailabilityFilteringRule extends RoundRobinRule and RetryRule decorates the RoundRobinRule. Please note that RetryRule already has the capability of RoundRobin.\n3) Inside Netflix, use of Hystrix over Ribbon is a typical use case. Hystrix and Ribbon have some overlaps in resiliency, but not completely. The circuit breaker in Hystrix typically represents a call route to a server cluster, while the circuit breaker in Ribbon represents the network connection to an individual server. Ribbon also has the capability to avoid or choose a subset of servers (for example servers in an availability zone in AWS) in the cluster, while being transparent to  Hystrix . It is possible that the circuit breaker in Hystrix is closed, but some are open for the Ribbon. It might also be possible that the circuit breaker for Hystrix is open (due to increased latency), but some circuit breakers in Ribbon are closed because the HttpClient's read timeout is configured differently from Hystrix. We are thinking of making Hystrix and Ribbon more tightly integrated and make Hystrix information visible to Ribbon. It is also possible to completely disable the circuit breaker feature in Ribbon by setting property \"niws.loadbalancer.availabilityFilteringRule.filterCircuitTripped\" to false.\n. Fixed in 0.1.11.\n. Cloudbee build passed.\n. DI will be supported in Ribbon 2 for the new \"ribbon\" module that has higher level client APIs.\n. Can you provide a test case so that the bug is reproducible there?\nFor ResponseTimeWeightedRule to work properly, its initialize(ILoadBalancer) method must be called as part of its initialization. This is where maxTotalWeight gets its initial value. I suspect that this code in the initialize(ILoadBalancer) \njava\n// do a initialrun\n        ServerWeight sw = new ServerWeight();\n        sw.maintainWeights();\nhas a race condition with the thread created from this code:\njava\nserverWeightTimer.schedule(new DynamicServerWeightTask(), 0,\n                serverWeightTaskTimerInterval);\nso the sw.maintainWeights() may exit silently without calculating the first maxTotalWeight due to the code\njava\nif (serverWeightAssignmentInProgress.get()) {\n                return; // Ping in progress - nothing to do\n            }\n. Yes, the initialization does have some problem which leads to infinite loop. I propose that the rule should fall back to round robin while no statistics is available yet. \nAfter looking at the code, there are other problems:\n- ResponseTimeWeightedRule has the same function as WeightedResponseTimeRule. Will deprecate the later.\n- Some variables are updated in one thread while read in another thread. \n- I have some doubts on the weighted logic which I need to confirm with the original author.\nPlease wait for a pull request from me.\n. @zarfide \nOnce you have figured out how this will impact httpclient4, can you also update com.netflix.niws.client.http.RestClient. The related code is pasted below:\n``` java\n        if (isSecure) {\n            final URL trustStoreUrl = getResourceForOptionalProperty(CommonClientConfigKey.TrustStore);\n            final URL keyStoreUrl = getResourceForOptionalProperty(CommonClientConfigKey.KeyStore);\n        if (trustStoreUrl != null || keyStoreUrl != null) {\n            try {\n                final ClientConnectionManager currentManager = httpClient4\n                .getConnectionManager();\n\n                SSLContext context = new URLSslContextFactory(\n                        trustStoreUrl,\n                        (String) ncc\n                        .getProperty(CommonClientConfigKey.TrustStorePassword),\n                        keyStoreUrl,\n                        (String) ncc\n                        .getProperty(CommonClientConfigKey.KeyStorePassword))\n                .getSSLContext();\n                currentManager.getSchemeRegistry().register(new Scheme(\n                        \"https\",\n                        443,\n                        new SSLSocketFactory(\n                                context,\n                                (X509HostnameVerifier) null)));\n            } catch (Exception e) {\n                throw new IllegalArgumentException(\n                        \"Unable to configure custom secure socket factory\",\n                        e);\n            }\n        }\n    }\n\n``\n. @mrshah DynamicServerListLoadBalancer now has a method shutdown() which will stop its server list refresh task. Does it work for you or a@PreDestroyis still required?\n. Another way to achieve this is to write aServerListFilter. There are two examples in Ribbon:ZoneAffinityServerListFilterandServerListSubsetFilter`. \nBasically ServerListFilter gets the complete server list from Eureka, but filters the list according to custom logic before giving the list to load balancer. In your ServerListFilter, you can get the statistics of each server, and if the one for the local host shows healthy, you can remove all other servers from the list before giving the list to the load balancer.\nYou can set the ServerListFilter programmatically or in the properties file:\n<clientName>.ribbon.NIWSServerListFilterClassName=<your ServerListFilter class name>\n. RestClient delegates to Jersey Client so it is matter of configuring Jersey Client. \nIf necessary, you can create a Jersey Client and configure it with necessary providers. Then call RestClient constructor RestClient(Client) to pass in the Jersey Client.\n. The Netty based asynchronous communication support will be added to 1.x branch as in this new pull request:\nhttps://github.com/Netflix/ribbon/pull/67\n. One workaround would be creating the Jersey Client yourself, and then set it with the RestClient. Would that work for you?\njava\n    Client client = ...\n    RestClient restClient = ClientFactory.getNamedClient(\"solr-client\");\n    restClient.setJerseyClient(client);\nIn this way, you will get all the functionalities of load balancers, but need to create the HttpClient and configure its related properties.\nI will look into your suggestions. Since RestClient wraps Jersey Client and HttpClient, it is hard to find a good way to support all the configuration options.\n. @mumrah There should be no side effect other than you have to create underlying client and configure it yourself.\n. I don't think Ribbon plays a role here.\nWhen you pass encoded string to create the URI, whether you use getQuery() or getRawQuery() to reconstruct the URI, neither of these will pass:\njava\n        URI uri = new URI(\"http://localhost.com:8080/bar?test=\" + URLEncoder.encode(lotsOfToughChars, \"UTF-8\"));\n        URI newURI = new URI(uri.getScheme(), uri.getUserInfo(), uri.getHost(), uri.getPort(), uri.getPath(), uri.getRawQuery(), uri.getFragment());\n       assertEquals(uri, newURI);\njava\n        URI uri = new URI(\"http://localhost.com:8080/bar?test=\" + URLEncoder.encode(lotsOfToughChars, \"UTF-8\"));\n        URI newURI = new URI(uri.getScheme(), uri.getUserInfo(), uri.getHost(), uri.getPort(), uri.getPath(), uri.getQuery(), uri.getFragment());\n     assertEquals(uri, newURI);\n. The important thing is what is being sent on the wire. This is the string sent when URI is reconstructed with getQuery() which can be decoded back to the original string.:\nPOST /test/setObject?test=%C3%A9%C6%8E&=%25!@%23$%25%5E&() HTTP/1.1[\\r][\\n]\nThis is the string sent when the URI is reconstructed with getRawQuery() which cannot be decoded back to original string.\nPOST /test/setObject?test=%25C3%25A9%25C6%258E%2526%253D_%2525%2521%2540%2523%2524%2525%255E%2526_%2528%2529 HTTP/1.1\n. I have tried the suggested JUnit test and it passed.\n. OK, it looks like isURIEncoded() is not needed. The original intention is that if nothing (including path and query string) is encoded in the original URI, we can still safely use the multi-args URI constructor and bypass the manual construction of the URI. But the implementation of the isURIEncoded() is obviously wrong.\nSo I think we can safely discard isURIEncoded() method and always constructing the URI by concatenating things together without using the multi-args URI constructor. The only thing to add in the manual construction step is to make sure user info, host and port are appended correctly. Currently this is taken care of from the result of the multi-args constructor: newURI.getRawAuthority()\n@timmc, are you open to send a PR?\n. @benjchristensen Please take a look at ObservableAsyncClient for Observable related APIs. Also ribbon-examples provide extensive examples of its async APIs. The actual implementation of the AsyncClient is RibbonHttpAsyncClient.\n. @benjchristensen The deadlock you observed may have been addressed in this JIRA: https://issues.apache.org/jira/browse/HTTPASYNC-59\n. @benjchristensen HttpAsyncClient 4.0 GA is available now. You can give it try to see if it fixes the deadlock problem.\n. Work started with https://github.com/Netflix/ribbon/wiki/Working-with-load-balancers\n. The class that extends AbstractLoadBalancerAwareClient is com.netflix.niws.client.http.RestClient. RestClient uses NFHttpClient as the underlying client for HTTP communication.\n. Yes, it uses Jersey client. Jersey client in turn uses the Apache HttpClient.\nAre you suggesting that you would like an implementation directly on top of HttpClient without Jersey client?\n. Sounds good. I would like to see your pull request. \nA couple of questions/suggestions:\n- it probably fits into its own subproject without Jersey dependency\n- do you need to handle serialization/deserialization? I have created a generic serialization framework without Jersey dependency. Take a look at https://github.com/Netflix/ribbon/blob/master/ribbon-httpasyncclient/src/main/java/com/netflix/httpasyncclient/RibbonHttpAsyncClient.java which is built on top of HttpAsyncClient and https://github.com/Netflix/ribbon/tree/master/ribbon-examples/src/main/java/com/netflix/ribbon/examples.\n. For async client, once you implement the interface, you can wrap it by AsyncLoadBalancingClient and it will be able to do load balancing. AsyncLoadBalancingClient does not extend LoadBalancerAwareClient but it gets certain functions from LoadBalancerContext.\nFor sync client, currently you need to extend AbstractLoadBalancerAwareClient.\n. See https://github.com/Netflix/ribbon/wiki/How-to-contribute\nIt is very easy to build with gradle once you have forked the repo. It should build out of the box without any set up.\nbuild.gradle on the top level defines all the dependencies. settings.gradle contains the set of sub projects to build. You should only need to work with those two files if you need to add a sub project.\n. I wrote this simple test and it seems to work as expected:\njava\n    @Test\n    public void testDifferentNameSpace() {\n        ConfigurationManager.getConfigInstance().setProperty(\"myclient.mynamespace.\" + CommonClientConfigKey.MaxAutoRetriesNextServer, \"10\");\n        IClientConfig config = DefaultClientConfigImpl.getClientConfigWithDefaultValues(\"myclient\", \"mynamespace\");\n        assertEquals(\"10\", config.getProperty(CommonClientConfigKey.MaxAutoRetriesNextServer));\n    }\nDid you also change the properties to have a different name space? For example, instead of myclient.ribbon.MaxAutoRetriesNextServer=10, it should be myclient.myNameSpace.MaxAutoRetriesNextServer=10\n. Yes, since it extends ResponseCallback<END>, it will inherit method completed(END end)\n. The interface design is updated to reflect the result of discussion.\nThe major shift in the design is to take care of the use case where caller of the AsyncClient is generally interested in the entity received from the communication, as opposed to the raw response which is protocol specific. This will enable easier change of protocol, while keeping the callback logic the same. In case an unexpected response is received, for example an HttpResponse with 404 status code, the client will by default interpret it as an error and invoke callback method failed(Throwable e), instead of the 'completed()` method. The actual Throwable can be generated from a user error handler that is responsible to interpret responses as success or not.\nFor the use case where the caller is interested to receive callback on the raw response, it can be achieved by specifying the callback type to be the raw response type. However, the getEntity() methods will be deprecated for HttpResponse.\n. Close the issue as the design is shifted to use RxJava Observable for Ribbon 2.\n. Looks good to me. Can you add copyright notices?\n. I prefer the second option. \nWe may want to pass IClientConfig to NFHttpClientFactory for parameters that are not honored by ApacheHttpClient4.\n. fixed in 0.3.4\n. I am wondering if this is a server set up problem:\nhttp://httpd.apache.org/docs/2.2/mod/core.html#allowencodedslashes\nAbstractLoadBalancerAwareClient needs to dissemble the passed in URI and replace the host with what load balancer supplies (if applicable). This is the code that does the final assembly:\n``` java\nString urlPath = \"\";\n            if (theUrl.getRawPath() != null && theUrl.getRawPath().startsWith(\"/\")) {\n                urlPath = theUrl.getRawPath();\n            } else {\n                urlPath = \"/\" + theUrl.getRawPath();\n            }\n        newURI = new URI(scheme, theUrl.getUserInfo(), host, port, urlPath, theUrl.getQuery(), theUrl.getFragment());\n\n```\nThe behavior is determined by the URI constructor. \n. It is expected that URI constructor that takes the multiple argument will encode % again, which is called double encoding. Only the simple constructor that takes one string argument will leave the URI string intact.\nJersey client will work as expected since you are passing the complete encoded URI to the client. The URI will not be modified by the Jersey client.\nBut in Ribbon, the URI has to be dissembled and reassembled to add the host name and port. The only solution seems to be avoid calling the URI constructor, but manually reassemble the URI in our own code which takes care of path that is already encoded, which might be tricky and duplicating a lot of stuff from JDK.\nAny suggestions? I would still think that server side solution is an option.\n. One possible solution is that we detect if the original URI is already encoded. If so, instead of invoking the multi-parameter URI constructor, we simply concatenate the parts using string operation:\njava\n    newURI = new URI(scheme, theUrl.getUserInfo(), host, port, urlPath, theUrl.getQuery(), theUrl.getFragment());\n    // For illustration only, no null check\n    if (isAlreadyEncoded(theUrl)) {\n        String rawURI = newURI.getScheme() + \"://\" + newURI.getRawAuthority() \n                 + theUrl.getRawPath() + \"?\" + theUrl.getRawQuery() + \"#\" + theUrl.getRawFragment();\n        newURI = new URI(rawURI);\n    }\n. fixed in 0.3.4\n. Fixed in 0.3.4.\n. An alternative solution would be adding this logic to DiscoveryEnabledNIWSServerList.obtainServersViaDiscovery(). This will enable us to solve both internal and external requirements in one place.\n. Thanks for taking the extra step to mock out the Discovery APIs!\n. Thanks for the contribution!\n. Looks good to me.\n. @amit-git you may need to include jersey-servlet into your dependency.\n. @timmc Thanks for the contribution!\n. Added in Ribbon 2 release.\n. Added in Ribbon 2 release.\n. Added in Ribbon 2.\n. @Serneum Are you using the latest release of Ribbon?\nWe had an attempt to similar issue https://github.com/Netflix/ribbon/issues/49 and my impression is that this is fixed. We used URI.getRawQuery() and URI.getRawPath() to ensure that we do not double encode.\n. @jdappel Can you explain more on this request? Do you mean having specific cookie handling APIs in HttpRequest and HttpResponse classes? Examples should help.\n. There is no default property value for IsSecure. When it is not defined, it is treated as not secure. That means you must set the property explicitly for each secure client.\nTo see the list of default property values, look into DefaultClientConfigImpl.loadDefaultValues().\n. Looking at this stackoverflow post, we might want to create a test to verify that PATCH works with our Jersey client backed by Apache HttpClient:\nhttp://stackoverflow.com/questions/22355235/patch-request-using-jersey-client\nCan we rely on MockHttpServer for that purpose?\n. @timmc I was able to build the master without test failures. Also, the cloudbee test failure is not from RetryTest, but HttpAsyncClientTest, which has nothing to do with your changes. I suspect the test might be a little flaky. RetryTest has been passing for the past cloudbee PR builds.\n. Added in Ribbon 2 a new rule class BestAvailableRule\n. The reason why the method is not public is that it uses Guava API. I would like to keep Guava APIs as an implementation detail rather than exposing it publicly. So if in the future we want to get rid of it, it is possible to do without any client impact. In Ribbon 2.x, there is no more API that expose Guava.\nI would agree to the PR if you add a new method with the signature of Map>, which is fairly easy to convert to once you create the Multimap. Of course, the drawback is to convert it back to Multimap internally.\n. Thanks to @NiteshKant for great design suggestions and @benjchristensen for the comments!\n\n\n\n\n\n\nRegarding the AsyncRequest name, it seems it should be something without Synchronous or Asynchronous in the name since both execution modes are supported.\n\n\n\nI agree, the AsyncRequest name does not represent what it does. The intent of having a base interface for RibbonRequest was that HystrixResponse interface also had the same methods execute(), queue(), observe() and toObservable() but the name is not correct. Also, we can just keep it package private and not expose it outside as the intent is just to share the methods.\n\n\n\nWhat about something like RxRequest? \n\n\n\n\n\n\nShouldn't we either let the function throw an Exception or return one of its own making?\n\n\n\nWe discussed about this point, but decided against it because the use case seems to be of transforming a response and it fits in naturally more at the transport level instead of the Ribbon API level. I was intending to move the karyon interceptor abstraction into rx-netty and make it available for both client and server. Finagle calls this abstraction as filters.\n\n\n\nWe choose to have it return a simple Boolean under the assumption that it is simple enough for majority of use cases. \nI see the point that having a response transforming API in Ribbon can reduce the burden of client creator for creating his own transport client. But if the interceptor in rx-netty can make it simple then it might be a better option.\n\n\n\nIt seems this is overly precise when there could be other types of metadata we want to make available, including the HTTP response codes, headers, etc (even when type T is returned).\n\n\n\nWe thought about this. The reason it only returns Hystrix metadata is that at the point this information is available, Hystrix execution is already done and it is hardly useful to check the protocol specific meta data, which is the layer below Hystrix. Also it would be cumbersome from design point of view (especially generics) to include protocol specific data here.\n\n\n\nThe first is nothing but a simple function that takes the input args and returns the cache key.\nThe second is I think what the CacheProvider is solving for, correct?\n\n\n\nThat is my intention. Let me know if Hystrix cache should be reflected in the design in a different way.\n\n\n\nHowever, from this point I am starting to think that we can completely eliminate the RibbonClient abstraction. Instead we may want to only have\n\n\n\nSeems like a good idea. \n. Changes after the discussion reflected in commit: https://github.com/allenxwang/ribbon/commit/8b74aff5a8c8a8a18ae719b2a8b0f48c87928354\nSummary of changes:\n- FallbackProvider renamed to FallbackHandler\n- HystrixCommand changed to HystrixObservableCommand in FallbackHandler\n- addCacheProvider(CacheProvider<O> provider, String keyTemplate) changed to withCache(String keyTemplate, List<CacheProvider<O>> providers) and added javadoc to call out its relationship to Hystrix internal cache\n- RibbonClient removed\n- public RibbonRequest<HystrixResponse<T>> withHystrixInfo(); changed to public RibbonRequest<RibbonResponse<T>> withMetadata();\n- AsyncRequest renamed to RxRequest and made package private\n- added RequestTemplate.copy() API\n- Ribbon APIs updated to add newHttpRequestTemplate() and rename create(Class<T>, ...) to from(Class<T>, ...)\n- Example updated to show creating request from the same template\n. > > > withCacheKey(String keyTemplate)\n\n\n\nand \nwithCacheProvider(CacheProvider provider)\nPassing a list would prohibit use of lambdas/closures.\n\n\n\n@NiteshKant How do we enforce that when withCacheProvider() is called, withCacheKey() must also be called? I guess we can throw RuntimeException to enforce this, but wonder if there is other better options.\nAlso, since the intention is to allow multiple cache provider, will withCacheProvider() gives people impression that it will override the previous withCacheProvider()? Would addCacheProvider() sound better?\n. @khawes I think it is wrong to use Hystrix but does not expose APIs to configure Hystrix. The Hystrix related APIs in the ribbon extension are all optional.  We will provide a set of default Hystrix behaviors derived from the ribbon client configuration.\nFor people who want to avoid Hystrix, it is better to be up front and tell them that we are using Hystrix, as opposed to hide the fact and having them find out later at runtime.\nFor clearCacheProviders(), I think we should avoid such APIs since all the APIs we provide in ResourceTemplate are addictive. You can achieve the same of clearing cache providers() by constructing a template without any providers and call copy().\n. > > > What is needing to be associated with it? If a key or something, then it can be like this:\n\n\n\nwithCacheKey(String keyTemplate, CacheProvider provider);\n\n\n\nShouldn't the keyTemplate be the same for all providers, including Hystrix?\n. The updated design as of now: \n``` java\n/*\n * @param  request input entity type\n * @param  response entity type\n * @param  response meta data, e.g. HttpClientResponse\n /\npublic interface RequestTemplate {\nRequestBuilder<O> requestBuilder();\n\nRequestTemplate<I, O, R> copy();\n\nRequestTemplate<I, O, R> withFallbackProvider(FallbackHandler<O> fallbackProvider);\n\nRequestTemplate<I, O, R> withFallbackDeterminator(FallbackDeterminator<R> fallbackDeterminator);\n\n/**\n * Calling this method will enable both Hystrix request cache and supplied external cache providers  \n * on the supplied cache key. Caller can explicitly disable Hystrix request cache by calling \n * {@link #withHystrixCommandPropertiesDefaults(com.netflix.hystrix.HystrixCommandProperties.Setter)}\n *     \n * @param cacheKeyTemplate\n * @return\n */\nRequestTemplate<I, O, R> withCacheKey(String cacheKeyTemplate);\n\nRequestTemplate<I, O, R> addCacheProvider(CacheProvider<O> cacheProvider);\n\nRequestTemplate<I, O, R> withHystrixCommandPropertiesDefaults(HystrixCommandProperties.Setter setter);\n\nRequestTemplate<I, O, R> withHystrixThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter setter);\n\nRequestTemplate<I, O, R> withHystrixCollapserPropertiesDefaults(HystrixCollapserProperties.Setter setter);\n\npublic abstract class RequestBuilder<O> {\n    public abstract RequestBuilder<O> withValue(String key, Object value);\n\n    public abstract RibbonRequest<O> build();\n}\n\n}\npublic interface CacheProvider {\n    Observable get(String key);\n}\ninterface RxRequest {\n    public T execute();\npublic Future<T> queue();\n\npublic Observable<T> observe();\n\npublic Observable<T> toObservable();\n\n}\npublic interface RibbonRequest extends RxRequest {\npublic RibbonRequest<RibbonResponse<T>> withMetadata();\n\n}\npublic interface RibbonResponse extends RxRequest {\n    HystrixExecutableInfo getHystrixInfo(); \n}\npublic interface FallbackHandler extends Func1, Observable> {\n}\n/*\n * @param  Protocol specific response meta data, e.g., HttpClientResponse\n /\npublic interface FallbackDeterminator {\npublic boolean shouldTriggerFallback(T responseMetaData);\n\n}\npublic final class Ribbon {\nprivate Ribbon() {\n}\n\npublic static <I, O> HttpRequestTemplate<I, O> newHttpRequestTemplate(HttpClient<I, O> transportClient) {\n    return null;\n}\n\npublic static <I, O, T> T from(Class<T> contract, HttpClient<I, O> transportClient) {\n    return null;\n}\n\n}\n```\n. > > > The only parts I'm aware of Hystrix being exposed are:\nIt is also exposed in RequestTemplate where you can pass in Hystrix properties setter to override default Hystrix configuration:\n``` java\nRequestTemplate withHystrixCommandPropertiesDefaults(HystrixCommandProperties.Setter setter);\nRequestTemplate<I, O, R> withHystrixThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter setter);\n\nRequestTemplate<I, O, R> withHystrixCollapserPropertiesDefaults(HystrixCollapserProperties.Setter setter);\n\n```\n. I would like to update/add APIs to reflect the need for Hystrix command key name in the design.\nSpecifically, add the following API to RequestTemplate\njava\n    public String name();\nAnd change Ribbon.newHttpRequestTemplate(HttpClient) to \njava\n   public static <I, O> HttpRequestTemplate<I, O> newHttpRequestTemplate(String templateName, HttpClient<I, O> transportClient)\nThis will ensure that the Hystrix command instance we create under the hood will have unique command key name per resource so that users can override Hystrix properties using the command key name in the property name. \n. Thinking over again, for Hystrix command name we may just add this API in RequestTemplate\njava\n    RequestTemplate<I, O, R> withName(String name);\nSo that the name is mutable in case the RequestTemplate is a copy of another one and needs to be renamed.\nThen there is no need to change Ribbon API.\n. I did not see name related API in RxClient interface.\nI think the client name, if it has, is better to be used as the command group name. A template name is more like one method name of a service contract, whereas the client is responsible to execute all methods in the contract.\n. @benjchristensen I did not see a way to create a HystrixObservableCommand.Setter with HystrixThreadPoolProperties.Setter or HystrixCollapserProperties.Setter. Does it mean those properties have to be from Archaius, but not programmatically set?\n. Changes to the design:\n- Change FallbackDeterminator to be a filter function that transform the network response (e.g. HttpClientResponse)\n- add RequestTemplate.withHystrixProperties(HystrixObservableCommand.Setter setter) and removed other APIs for passing in Hystrix properties\n- Add String RequestTemplate.name()\n- change RequestTemplate.copy() to RequestTemplate.copy(String name)\n- Change Ribbon.newHttpRequestTemplate(HttpClient<I, O> transportClient) to\n  Ribbon.newHttpRequestTemplate(String templateName, HttpClient<I, O> transportClient)\n``` java\npublic interface RequestTemplate {\nRequestBuilder<O> requestBuilder();\n\nString name();\n\nRequestTemplate<I, O, R> copy(String name);\n\nRequestTemplate<I, O, R> withFallbackProvider(FallbackHandler<O> fallbackProvider);\n\nRequestTemplate<I, O, R> withNetworkResponseTransformer(ResponseTransformer<R> transformer);\n\n/**\n * Calling this method will enable both Hystrix request cache and supplied external cache providers  \n * on the supplied cache key. Caller can explicitly disable Hystrix request cache by calling \n * {@link #withHystrixCommandPropertiesDefaults(com.netflix.hystrix.HystrixCommandProperties.Setter)}\n *     \n * @param cacheKeyTemplate\n * @return\n */\nRequestTemplate<I, O, R> withCacheKey(String cacheKeyTemplate);\n\nRequestTemplate<I, O, R> addCacheProvider(CacheProvider<O> cacheProvider);\n\nRequestTemplate<I, O, R> withHystrixProperties(HystrixObservableCommand.Setter setter);\n\npublic abstract class RequestBuilder<O> {\n    public abstract RequestBuilder<O> withValue(String key, Object value);\n\n    public abstract RibbonRequest<O> build();\n}\n\n}\npublic interface FallbackHandler extends Func1, Observable> {\n}\npublic interface ResponseTransformer extends Func1 {\n}\ninterface RxRequest {\n    public T execute();\npublic Future<T> queue();\n\npublic Observable<T> observe();\n\npublic Observable<T> toObservable();\n\n}\npublic interface RibbonRequest extends RxRequest {\n    public RibbonRequest> withMetadata();\n}\npublic interface RibbonResponse extends RxRequest {\n    HystrixExecutableInfo getHystrixInfo(); \n}\npublic final class Ribbon {\nprivate Ribbon() {\n}\n\npublic static <I, O> HttpRequestTemplate<I, O> newHttpRequestTemplate(String templateName, HttpClient<I, O> transportClient) {\n    return null;\n}\n\npublic static <I, O, T> T from(Class<T> contract, HttpClient<I, O> transportClient) {\n    return null;\n}\n\n}\n``\n. All three scenarios are handled by theResponseTransformer1. ResponseTransformer returns the same response\n2. ResponseTransformer throws an exception\n3. ResponseTransformer transforms the response. For example, return a newHttpClientResponsewhere the the content (Observable) represent empty result\n. @khawes You will have access to HystrixExecutionInfo to see if the empty result is from fallback. The network response (Http headers) are not exposed after Hystrix execution is done since it is hardly useful once the final result (after fallbacks) is available. \n. Given comments from @benjchristensen, the choices to implement null/empty (in case of 404) are (in the ResponseTransformer):\n- throwsHystrixBadRequestExceptionwith your customized cause (you can deserialize the content from response body). This will causeObserver.onError()invoked or RuntimeException thrown fromexecute()`\n- give back empty Observable if user does not expect visible error in this case\n. A change to the design regarding API for get metadata (e.g. HystrixExecutableInfo):\n``` java\npublic interface RibbonRequest {\npublic T execute();\n\npublic Future<T> queue();\n\npublic Observable<T> observe();\n\npublic Observable<T> toObservable();\n\npublic RequestWithMetaData<T> withMetadata();\n\n}\npublic abstract class RibbonResponse {\n    public abstract T content();\npublic abstract HystrixExecutableInfo<T> getHystrixInfo();\n\n}\npublic interface RequestWithMetaData {\n    Observable>> observe();\nObservable<RibbonResponse<Observable<T>>> toObservable();\n\nFuture<RibbonResponse<T>> queue();\n\nRibbonResponse<T> execute();\n\n}\n```\nWith this change, one is possible to do\n``` java\n        request.withMetadata().observe()\n            .flatMap(new Func1>, Observable>() {\n                @Override\n                public Observable call(RibbonResponse> t1) {\n                    if (t1.getHystrixInfo().isResponseFromFallback()) {\n                        return Observable.empty();\n                    } \n                    return t1.content().map(new Func1(){\n                        @Override\n                        public String call(ByteBuf t1) {\n                            return t1.toString();\n                        }\n                });\n            }\n        });\n\n```\n. Latest design is in gist:\nhttps://gist.github.com/allenxwang/9f290dc863705bb4903f\nChanges:\n- Enabling Hystrix cache via a separate API and cache key \n- Having a different cache key template for each provider\n- Renamed ResponseTransformer to ResponseValidator which extends Action1 and withResponseValidator(ResponseValidator). I feel onResponse sounds like reactive, but in the case of template building, we want user to actively set this piece.\n. The design is updated  here\n- Added ResourceGroup and HttpResourceGroup\n- Added ClientOptions to provide simple interface for common client configurations\n- Changed the generic type for RequestTemplate to be the entity type instead of the raw type from HttpClient\n- ResponseValidator and FallbackHandler no longer extends from Rx functions\n- Other minor renaming\nThe reason why ClientOptions is not offered as a setter for ResourceGroup is that the underlying client should be immutable (given that it is shared for all templates) once the group is created, so it does not make sense to have mutable client options.\n. Minor naming changes in ClientOptions to reflect comments from @khawes  and @benjchristensen \nhttps://gist.github.com/allenxwang/9f290dc863705bb4903f\n. After discussion with @mikeycohen, the RequestTemplate.addCacheProvider() is reverted back to RequestTemplate.withCacheProvider() to make sure that only one cache provider can be specified.  User can implement the multiple cache providers scenario with composition.\n. Close this as the design is reflected in new ribbon module in 2.0-RC1. New issues will be created for further improvements.\n. I am open to suggestions for names. ribbon-api seems a little ambiguous to me.\nThe build fails because it uses an RxNetty API which is not released yet. Merging anyway ...\n. It would be great if you can write a junit for it. You might want to look at how discovery client can be mocked from DiscoveryEnabledLoadBalancerSupportsPortOverrideTest\n. @aspyker You may need to sync with master and resolve conflicts to update your PR to get cloudbees build going.\n. Looks like the failure is caused by cloudbees issue:\nCaused by: java.lang.NoClassDefFoundError: Could not initialize class org.apache.tools.ant.Location\n. All done.\n. Since most of the APIs are hidden from the caller, shall we make the classes package private?\n. Can you provide an comprehensive annotation example in src/examples directory?\n. Shall we use com.netflix.ribbon.proxy and com.netflix.ribbon.proxy.annotation as the package name?\n. I started to think if @Var is really needed since we have @Content. Seems to be redundant and have to repeat a lot of times if there are a lot of arguments. Also, it brings up the problem what to deal with argument that is not annotated with either @Var or @Content.\n. Thanks @tbak for the contribution.\n. @tbak I have merged everything into 2.x branch. Can you please resend the pull request to that branch?\n. Looks good to me.\n. Added ClientConfigFactory which is injectable and it is used by ribbon module when creating configurations.\n. A design for Http looks like this:\n``` java\n/\n * Object used as the input argument to the HystrixObservableCollapser \n \n * @param  Type of request content\n /\npublic interface HttpRequestInput {\n    public Observable getRequestContent();\npublic ContentTransformer<T> contentTransfomer();\n\npublic Map<String, Object> requestProperties();\n\n}\n/\n\n * @param  Key object type used in Hystrix batch return type and request argument selector\n * @param  Batch return type\n * @param  expected return type \n /\npublic interface HttpRequestCollaper {\n    // required to implement HystrixObservableCollapser\n    public Func1 getBatchReturnTypeKeySelector();\n// required to implement HystrixObservableCollapser\npublic Func1<HttpRequestInput<?>, K> getRequestArgumentKeySelector();\n\n// required to implement HystrixObservableCollapser\npublic void onMissingResponse(CollapsedRequest<ResponseType, HttpRequestInput<?>> r);\n\n// required to implement HystrixObservableCollapser\npublic Func1<BatchReturnType, ResponseType> getBatchReturnTypeToResponseTypeMapper();\n\n/**\n * Merge a collection of {@link HttpRequestInput} into one to be used for batch call\n */\npublic HttpRequestInput<?> mergeHttpRequests(Collection<HttpRequestInput<?>> inputs);\n\n}\n/\n * The Http request template which will automatically collapse calls to batch call\n * for the {@link RibbonRequest} created from its {@link RequestBuilder} \n * \n * @author Allen Wang\n \n * @param  Return type\n * @param  Batch return type\n * @param  Key type used to map batch response object to response object, and \n /\npublic class BatchEnabledRequestTemplate extends HttpRequestTemplate {\npublic final CallCollaper<K, B, T, HttpRequestInput<?>> getCollasper() {\n    // ...\n}\n\npublic final HttpRequestTemplate<B> getBatchTemplate() {\n   // ...\n}\n\n}\n```\nAnd add this method to HttpResouceGroup:\njava\n    public <T, B, K> BatchEnabledRequestTemplate<T, B, K> newBatchEnabledRequestTemplate(String name,\n            Class<? extends T> classType, HttpRequestTemplate<B> batchTemplate, HttpRequestCollaper<K, B, T> collapser) {\n        // ...\n    }\nSo from user point of view, they need to first create an HttpRequestTemplate corresponding to the batch call, then use it to create the actual HttpRequestTemplate for the individual element where requests will be automatically collapsed to use the batch template. This ensures that caching for batch call will be taken of by its own template, and let user deal with different types (return type vs. batch return type) in different templates to avoid confusions and mistakes.\nGiven that serialization is not supported, it may not make sense to implement this feature since HttpRequestCollaper.getBatchReturnTypeToResponseTypeMapper() will essentially become \njava\n    public Func1<ByteBuf, ByteBuf> getBatchReturnTypeToResponseTypeMapper();\nIt means to get an individual ByteBuf for one of the response object from the ByteBuf that includes complete response for the batch call, which cannot be really implemented.\n. The JUnit test failure was caused by a connection problem with MockHttpServer.\n. Looks like the build gets stuck in findbugs. \n. @aspyker The properties required are the same as those for RestClient:\nDeploymentContextBasedVipAddresses\nNIWSServerListClassName\nHere is an example showing Ribbon 2 working with a mocked DiscoveryClient:\nhttps://github.com/allenxwang/ribbon/blob/cp/ribbon/src/test/java/com/netflix/ribbon/DiscoveryEnabledServerListTest.java\n. @aspyker If you run the test without mocking, DiscoveryManager.getInstance().getDiscoveryClient() will return null. If you run the same code in Karyon, DiscoveryManager.getInstance().getDiscoveryClient() should not return null as Karyon should properly initialize DiscoveryClient. If you observe DiscoveryManager.getInstance().getDiscoveryClient() returns null in Karyon, please fire a bug against Karyon.\n. @aspyker I think there is a way to manually initialize DiscoveryClient. This is the code from DiscoveryManager:\njava\n    public void initComponent(EurekaInstanceConfig config,\n            EurekaClientConfig eurekaConfig) {\n        this.eurekaInstanceConfig = config;\n        this.eurekaClientConfig = eurekaConfig;\n        if (ApplicationInfoManager.getInstance().getInfo() == null) {\n            // Initialize application info\n            ApplicationInfoManager.getInstance().initComponent(config);\n        }\n        InstanceInfo info = ApplicationInfoManager.getInstance().getInfo();\n        discoveryClient = new DiscoveryClient(info, eurekaConfig);\n    }\nSo you would need to do something like this:\njava\n    DiscoveryManager.getInstance().init(config, eurekaConfig);\nYou should be able to get further details about how to obtain EurekaInstanceConfig and EurekaClientConfig from Eureka project.\n. @elandau Thanks for the DI work. I am wondering if the HttpRequestTemplateFactory is necessary. It seems to me that being able to inject HttpResourceGroupFactory will satisfy our use case since it can further control the behavior of creating HttpRequestTemplate.\n. Will send a PR to fix the test not to rely on external host for redirecting.\n. @willblackie Thanks for fixing this\n. We will either publish a snapshot or release to maven soon. There is a little problem with our release builds and we are working on it.\n. Fixed in 2.0-RC6\n. The intention of the HttpRequestTemplate is that it should be tightly controlled by APIs who create them and should never leak them to caller of the API. So it is not thread safe and is documented as such. The following code demonstrates the expected usage pattern of HttpRequestTemplate:\n``` java\npublic class MovieService {\n    private final HttpRequestTemplate template;\npublic MovieService() {\n    template = Ribbon.createHttpResourceGroup(\"mygroup\").newHttpRequestTemplate(\"recommendation\");\n    template.withHttpMehtod(...)\n                  .withUriTemplate(...);\n    // call other setters of template\n}\n\npublic RibbonRequest<ByteBuf> getRecommendations(int userId) {\n    return template.newRequestBuilder().withRequestProperty(\"userId\", userId).build();\n}\n\n}\n```\nI agree it is better to have a builder to enforce immutability and thread safety once the template is constructed and necessary setters are called.\n. I would prefer the builder approach since the finish() method. From API point of view, finish() cannot be easily enforced and object allocation post finish() is not obvious.\n. To fix the problem, the design of ResourceGroup is changed to have a builder class for RequestTemplate:\n``` java\npublic abstract class ResourceGroup> {\n    // ...\n    public static abstract class TemplateBuilder> {\n        public abstract TemplateBuilder withFallbackProvider(FallbackHandler fallbackProvider);\n    public abstract TemplateBuilder withResponseValidator(ResponseValidator<R> transformer);\n\n    /**\n     * Calling this method will enable both Hystrix request cache and supplied external cache providers\n     * on the supplied cache key. Caller can explicitly disable Hystrix request cache by calling\n     * {@link #withHystrixProperties(com.netflix.hystrix.HystrixObservableCommand.Setter)}\n     *\n     * @param cacheKeyTemplate\n     * @return\n     */\n    public abstract TemplateBuilder withRequestCacheKey(String cacheKeyTemplate);\n\n    public abstract TemplateBuilder withCacheProvider(String cacheKeyTemplate, CacheProvider<S> cacheProvider);\n\n    public abstract TemplateBuilder withHystrixProperties(HystrixObservableCommand.Setter setter);\n\n    public abstract T build();\n}\n\npublic abstract <S> TemplateBuilder<S, ?, ?> newTemplateBuilder(String name, Class<? extends S> classType);\n\n}\n```\nHttpResourceGroup itself will also have a builder:\n``` java\npublic class HttpResourceGroup extends ResourceGroup> {\npublic static class Builder {\n\n    public Builder withClientOptions(ClientOptions options) {\n        // ...\n    }\n\n    public Builder withHeader(String name, String value) {\n        // ...\n    }\n\n    public HttpResourceGroup build() {\n        // ...\n    }\n}\n\n@Override\npublic <T> HttpRequestTemplate.Builder newTemplateBuilder(String name, Class<? extends T> classType) {\n     // ...\n}\n\n}\n```\nRibbon is changed to create HttpResourceGroup.Builder as opposed to HttpResourceGroup itself:\njava\n    public static Builder createHttpResourceGroupBuilder(String name);\n. Addressed in ribbon 2.0-RC9.\n. Fixed in 2.0-RC6\n. Fixed in 2.0-RC6\n. Fixed in ribbon 2.0-RC9.\n. @aspyker This PR looks good to me except for the two minor comments. Thanks!\n. @aspyker This PR is created again master branch which is the branch for 2.x. That's why the build failed as it cannot merge master with changes in 1.x branch.\nCan you try recreating the PR against the 1.x branch?\n. Possibly change the logic to the following:\njava\n @Override\n    public boolean isRetriableException(Throwable e, boolean sameServer) {\n        if (retryEnabled) {\n            if (sameServer) {\n                return Utils.isPresentAsCause(e, getRetriableExceptions());\n            } else {\n                return true;\n            }\n        }\n        return false;\n    }\n. Fixed in ribbon 2.0-RC9.\n. @elandau can you update the pull request after sync with master?\n. Does this PR also address #176?\n. It is worthwhile to add some tests in NettyClientTest to verify the behavior of retrying on same server by passing in a URI with valid host name (localhost:port).\n. I think it is fine to eliminate the use case of retry on both same and next server. However, it would be better to solicit some input from other teams and at least raise it as an issue.\n. Here is the code in LoadBalancingRxClient that deals with SSL:\n``` java\nif (isSecure) {\n            final URL trustStoreUrl = getResourceForOptionalProperty(CommonClientConfigKey.TrustStore);\n            final URL keyStoreUrl = getResourceForOptionalProperty(CommonClientConfigKey.KeyStore);\n            boolean isClientAuthRequired = clientConfig.get(IClientConfigKey.Keys.IsClientAuthRequired, false);\n            if (    // if client auth is required, need both a truststore and a keystore to warrant configuring\n                    // if client is not is not required, we only need a keystore OR a truststore to warrant configuring\n                    (isClientAuthRequired && (trustStoreUrl != null && keyStoreUrl != null))\n                    ||\n                    (!isClientAuthRequired && (trustStoreUrl != null || keyStoreUrl != null))\n                    ) {\n            try {\n                sslContextFactory = new URLSslContextFactory(trustStoreUrl,\n                        clientConfig.get(CommonClientConfigKey.TrustStorePassword),\n                        keyStoreUrl,\n                        clientConfig.get(CommonClientConfigKey.KeyStorePassword));\n\n            } catch (ClientSslSocketFactoryException e) {\n                throw new IllegalArgumentException(\"Unable to configure custom secure socket factory\", e);\n            }\n        } else {\n            sslContextFactory = null;\n        }\n    } else {\n        sslContextFactory = null;\n    }\n\n```\nAnd then in LoadBalancingHttpClient.cacheLoadRxClient(), sslContextFactory is used for clientBuilder.\nAre TrustStore, KeyStore and IsClientAuthRequired properties all configured properly?\n. @dhawken Looks good to me. Would you like to make a pull request?\nI would add a check from client config if client auth is required before calling setUseClientMode(true). \n. @dhawken Thanks for the contribution!\n. There is a client property for gzip but it is not used:\njava\n    public static final IClientConfigKey<Boolean> EnableGZIPContentEncodingFilter = new CommonClientConfigKey<Boolean>(\"EnableGZIPContentEncodingFilter\"){};\nWe need to call addFilter(new GZIPContentEncodingFilter(false)) for RestClient if this property is turned on.\n. You can do that with @ClientProperties. See \nhttps://github.com/Netflix/ribbon/blob/master/ribbon-examples/src/main/java/com/netflix/ribbon/examples/rx/proxy/MovieService.java\nThe properties defined with such annotations will be exported to Archaius configuration manager.\n. There is no explicit API to create named client using annotations. However, you can still have all configurations in Archaius and have the client created using Archaius properties. Here is an example:\nhttps://github.com/Netflix/ribbon/blob/master/ribbon-examples/src/main/java/com/netflix/ribbon/examples/rx/proxy/RxMovieProxyExample.java\n. good catch. We could wrap all Throwable with ClientException and change the callback interface to to onException(ClientException). The drawback is client may have always do getCause() to see the root cause. Any thoughts?\n. that's correct.\n. I don't think \"%s\" works here. Should be \"{}\".\n. why is that necessary?\n. This will expect a global property for all Ribbon clients in the same JVM to use IP address. However, we would like to be able to set this property for individual clients.\nThe way it works should follow the pattern of properties defined in DefaultClientConfigImpl:\n1. Defined the property as a key in CommonClientConfigKey\n2. Load its default value (which should be \"false\") in DefaultClientConfigImpl\n3. use clientConfig.getProperty() to access it\nI suggest the name to be \"UseIPAddrForServer\" for the new property.\n. The name seemed a little odd. Maybe RibbonProxyException?\n. Do we support multiple header of the same name? e.g.:\n@Header(name = \"X-MyHeader1\", value = \"value1\"),\n@Header(name = \"X-MyHeader1\", value = \"value2\")\n. Check to enforce that ContentTransformerClass is provided if content is not String, byte[] or ByteBuf?\n. Can we simply name it ResourceGroup?\n. I feel this Map structure is wrong. Two different cache providers may have the same cache key template.\n. I am fine with not allowing multiple values for the same header. But in this case throwing an exception would be better than silently ignore the first value.\n. This will trigger evcache execution asynchronously. What we need here is not to trigger any execution unless it is subscribed to. You may need to use Observable.create(OnSubscribe) API.\n. Is it guaranteed that it will create an error if there is a cache miss? \n. Can we also name it \"key\" to be consistent with CacheProvider?\n. Since we support typed property, this can be simply\njava\nclientConfig.get(CommonClientConfigKey.ServerListRefreshInterval, LISTOFSERVERS_CACHE_REPEAT_INTERVAL);\n. Same as above, this can be written as\njava\nserverWeightTaskTimerInterval = clientConfig.get(WEIGHT_TASK_TIMER_INTERVAL_CONFIG_KEY,  DEFAULT_TIMER_INTERVAL);\n. java\nserverWeightTaskTimerInterval = clientConfig.get(WEIGHT_TASK_TIMER_INTERVAL_CONFIG_KEY, DEFAULT_TIMER_INTERVAL);\n. should be {@code?\n. As we discussed, the Hystrix cache command needs to have its own name and default properties including time out.\n. Should we move it to package com.netflix.ribbon.hystrix or something else since it has nothing to do with http?\n. Can you revert this change? toBlockingObservable() is deprecated in 0.19.\n. We can also move this method to the command itself and possibly create a parent command class for both RibbonHystrixObservableCommand and HystrixCacheObservableCommand. Then the method in CommandChain class is only responsible for chaining the two commands, but not transforming the Observable. What do you think?\nI also suggest that we rename RibbonHystrixObservableCommand to HttpResourceObservableCommand and rename HystrixCacheObservableCommand to CacheObservableCommand.\n. Since convertToRibbonResponse() already uses a ReplaySubject, this will double \"replay\", which is unnecessary. We can perhaps add some logic in convertToRibbonResponse() to avoid that.\n. Shouldn't we use \"key\" here?\n. Since Hystrix properties use \".\" as a delimiter, I think it will be safer to use \"_cache\" here.\n. A solution to support creation of different ResourceGroup using DI is to make RibbonResourceGroupFactory an abstract class with methods for creation of each type of ResourceGroup. Initially it will only have one method newHttpResourceGroup() but later can add new methods like newUdpResourceGroup(). The default implementation would just call the constructor of each type of ResourceGroup. Same with RibbonTransportFactory.\nThat way we don't need to create a complex class hierarchy with generics and the injectable is simplified.\n. This is an unintended commit. I was experimenting this new API for certain udp client, but have not decided whether this should be offered as a Ribbon public API or should it just be part of the user code. I will remove this.\n. I think the only way to reuse test classes is to move them to ribbon-test. \"testCompile\" dependency cannot be used for classes in src/test.\n. Looks like this does the trick:\ntestCompile project(':ribbon').sourceSets.test.output\n. I am not sure if having \"proxy\" in the name is exposing too much details of the implementation. Let's think more on this.\n. I would suggest changing name of the property to:\njava\nUseIPAddrForServer(\"UseIPAddrForServer\"),\n. This method must be called in loadDefaultValues() otherwise it is not useful.\nI suggest changing the method name to match the property name.\n. This is not necessary once the DefaultClientConfigImpo.loadDefaultValues() calls appropriate method. See my previous comment.\n. Instead of hardcoded false, we can use DefaultClientConfigImpl.DEFAULT_USEIPADDRESS_FOR_SERVER\n. Can you add \"Test\" as a suffix of the class to make it clear that it actually includes tests, not a supporting class for tests.\n. Since the parameter is already a Collection, I feel it will seem strange if we do further accumulation for the with() method in a builder. At least it does not seem intuitive to me.\n. In build(), I can make an copy to an immutable list before passing to command constructor. Will that suffice?\n. Since listner has access to its own context, it should expect that object that is put into the context by itself be there when it tries to get it. Otherwise it is an error condition. So I am not sure if this is necessary.\n. No, it cannot be. There must be a client configuration for a client. If not passed in when the client is constructed, a default one will be used.\n. Right. onStartInvoked should be removed. Load balancer command should make sure that it won't happen.\n. Sometimes you may not be able to retry on the different server, if the service is not stateless. \nAnother use case to retry on the same server is when the request goes to an absolute URI like google.com. You can only retry on the same server.\n. Actually this does not work. The current design creates a new instance of RetryNextServerOperator when caller calls retryWithSameServer() and recursively subscribe the same instance of the operator during the retry process. So this counter has to be at instance level. Of course, this will be changed when we try retry(predicate) approach.\n. The original intention of the test is a negative test. So we should probably keep that by setting the server list (badserver, badserver, badserver, goodserver).\n. Please clean up the unnecessary comment.\n. What would be the performance penalty we pay for the concatMap() operation? Does it work if we use map() and throws an exception if status is 503?\n. Is this used any where?\n. Please also update the same code example in README.\n. ",
    "saurabh113": "got it thanks.\nhttps://github.com/Netflix/netflix-commons\n. ",
    "adriancole": "+1\nOn Thursday, April 18, 2013, allenxwang wrote:\n\nCurrently the server filtering logic is scattered in several classes, some\nof them are written as Rule, some of them are written as ServerListFilter.\nThese logic includes:\nZone affinity\nZone avoidance\nAvailability filtering (circuit breaker logic)\nIt is hard to write more complicated filtering logic to arbitrarily\ncombine more two or more filtering logics.\nThe proposal is to rewrite them as Predicate in Guava and support\ncompositions of those predicates.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/Netflix/ribbon/issues/22\n.\n. +1\n. closed via c2b88a7\n. switched approach as making headers parameterized causes a ripple of generic type complexity.  current approach: make response headers multimap\n. last approach: use Map<String, ?> as it has less impact\n. also remove extra aws sdk del\n. can you reproduce this with a MockWebServer or such test?  Feel free to say no :P\n. you can probably steal boilerplate from here: https://github.com/Netflix/feign/blob/master/feign-ribbon/src/test/java/feign/ribbon/RibbonClientTest.java\n. as far as I can tell, you are correct.  the readme should be updated to include closing the response.\n\nDo you mind adding your test case into a pull request for ribbon-httpclient?  It shows that when used properly, the client does survive many short-lived requests.\n. updated the wiki: https://github.com/Netflix/ribbon/wiki/Getting-Started\n. thanks!\n. Good job, @looztra\n+1 just awaiting buildhive.\n. kicking due to incorrect buildhive setting\n. can you squash these commits?\n. Thanks \n. general comment is \"async retry is hard\"\nI can tell this is tricky to do cleanly.  Not an endorsement, but there's a recent stab at async retry posted in various places.  http://java.dzone.com/articles/asynchronous-retry-pattern  Basically, it resubmits the operation with a context of last throwable, etc.  Since there's so much context in ribbon, could be worth a look at.\nWRT testing, it would be nice to have a realistic test, for example, a couple embedded http servers that send back bad responses.  This clarifies the user behaviors expected, as opposed to the inner workings that make this possible.  ex. https://github.com/Netflix/feign/blob/master/ribbon/src/test/java/feign/ribbon/LoadBalancingTargetTest.java\n. ahh ic there was an embedded server test already, and a fake bad one in NettyClientTest. testLoadBalancingClientWithRetry().  I mistook that test for something else.  Probably worthwhile making it really support multiple servers, though.\n. volatile lazy init pattern needs double-check null\nex.\nif (tracer == null) {\n        synchronized (this) {\n          if (tracer == null) {\n            tracer = Monitors.newTimer(clientName + \"_OperationTimer\", TimeUnit.MILLISECONDS);\n          }\n        }\n      }\n. most changes in this file s/Exception/Throwable  might want to double-check this one is still ok\n. might want to document in what case ClientException is raised, as opposed to being emitted in a callback\n. unless there's reason to make this mutable, prefer final\n. same lazy init pattern comment as prior.  p.s. might want to note that this is expensive (else wouldn't lazy init in the first place)\n. public ctor should check null params.\n. hmm is this valid (ex. no asyncClient passed?)\n. probably cleaner to make a static inner decorator class that accepts a delegate param of ResponseCallback<Response> (seemingly other params, too).  Could be easier to test this way.\n. nit prefer format vs string concat\n. interesting that we are converting the callback onException val to ClientException.. For some reason I thought the param was Throwable type\n. I'd prefer onFailure(Throwable) as that's more typical w/ callbacks.  I'd\nnot wrap anything.\nOn Wed, Sep 18, 2013 at 2:47 AM, allenxwang notifications@github.comwrote:\n\nIn\nribbon-core/src/main/java/com/netflix/client/AsyncLoadBalancingClient.java:\n\n\n\n\nrequest.getUri() + \":\" +  getDeepestCause(e).getMessage(), e));\n\n\n}\nlogger.error(\"Exception while executing request which is deemed retry-able, retrying ..., Next Server Retry Attempt#:\"\n\n\nretries\n\n\n\n\n\", URI tried:\"\n\n\n\n\nrequest.getUri());\n\n\ntry {\nasyncExecuteOnSingleServer(computeFinalUriWithLoadBalancer(request), this);\n} catch (ClientException e1) {\ncallback.onException(e1);\n}\n} else {\nif (e instanceof ClientException) {\ncallback.onException(e);\n} else {\ncallback.onException(new ClientException(\n\n\ngood catch. We could wrap all Throwable with ClientException and change\nthe callback interface to to onException(ClientException). The drawback is\nclient may have always do getCause() to see the root cause. Any thoughts?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/Netflix/ribbon/pull/46/files#r6422677\n.\n. \n",
    "cloudbees-pull-request-builder": "ribbon-pull-requests #2 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #4 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #5 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #7 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #8 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #9 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #10 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #12 FAILURE\nLooks like there's a problem with this pull request\n. ribbon-pull-requests #13 FAILURE\nLooks like there's a problem with this pull request\n. ribbon-pull-requests #14 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #15 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #16 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #17 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #19 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #20 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #21 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #22 FAILURE\nLooks like there's a problem with this pull request\n. ribbon-pull-requests #23 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #24 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #25 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #26 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #27 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #28 FAILURE\nLooks like there's a problem with this pull request\n. ribbon-pull-requests #30 FAILURE\nLooks like there's a problem with this pull request\n. ribbon-pull-requests #31 FAILURE\nLooks like there's a problem with this pull request\n. ribbon-pull-requests #33 ABORTED\n. ribbon-pull-requests #37 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #38 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #39 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #40 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #41 FAILURE\nLooks like there's a problem with this pull request\n. ribbon-pull-requests #42 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #43 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #44 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #45 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #46 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #47 FAILURE\nLooks like there's a problem with this pull request\n. ribbon-pull-requests #48 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #49 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #50 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #51 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #52 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #53 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #54 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #55 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #56 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #57 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #58 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #60 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #61 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #59 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #62 FAILURE\nLooks like there's a problem with this pull request\n. ribbon-pull-requests #63 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #65 FAILURE\nLooks like there's a problem with this pull request\n. ribbon-pull-requests #66 FAILURE\nLooks like there's a problem with this pull request\n. ribbon-pull-requests #67 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #69 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #70 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #64 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #68 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #71 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #72 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #73 FAILURE\nLooks like there's a problem with this pull request\n. ribbon-pull-requests #74 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #75 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #76 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #77 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #78 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #79 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #80 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #81 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #82 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #83 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #84 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #85 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #86 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #87 FAILURE\nLooks like there's a problem with this pull request\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #37 FAILURE\nLooks like there's a problem with this pull request\n. ribbon-pull-requests #89 FAILURE\nLooks like there's a problem with this pull request\n. ribbon-pull-requests #90 FAILURE\nLooks like there's a problem with this pull request\n. ribbon-pull-requests #91 FAILURE\nLooks like there's a problem with this pull request\n. ribbon-pull-requests #92 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #163 FAILURE\nLooks like there's a problem with this pull request\n. ribbon-pull-requests #164 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #165 FAILURE\nLooks like there's a problem with this pull request\n. ribbon-pull-requests #93 FAILURE\nLooks like there's a problem with this pull request\n. ribbon-pull-requests #94 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #95 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #96 FAILURE\nLooks like there's a problem with this pull request\n. ribbon-pull-requests #98 FAILURE\nLooks like there's a problem with this pull request\n. ribbon-pull-requests #99 FAILURE\nLooks like there's a problem with this pull request\n. ribbon-pull-requests #100 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #101 ABORTED\n. ribbon-pull-requests #102 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #103 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #104 FAILURE\nLooks like there's a problem with this pull request\n. ribbon-pull-requests #105 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #97 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #106 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #107 ABORTED\n. ribbon-pull-requests #108 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #109 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #110 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #113 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #114 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #111 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #112 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #115 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #116 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #117 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #118 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #119 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #120 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #121 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #122 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #123 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #124 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #125 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #126 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #127 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #128 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #129 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #130 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #131 FAILURE\nLooks like there's a problem with this pull request\n. ribbon-pull-requests #132 ABORTED\n. ribbon-pull-requests #133 ABORTED\n. ribbon-pull-requests #134 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #135 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #136 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #137 FAILURE\nLooks like there's a problem with this pull request\n. ribbon-pull-requests #141 FAILURE\nLooks like there's a problem with this pull request\n. ribbon-pull-requests #142 FAILURE\nLooks like there's a problem with this pull request\n. ribbon-pull-requests #143 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #144 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #145 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #146 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #147 FAILURE\nLooks like there's a problem with this pull request\n. ribbon-pull-requests #149 FAILURE\nLooks like there's a problem with this pull request\n. ribbon-pull-requests #150 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #151 FAILURE\nLooks like there's a problem with this pull request\n. ribbon-pull-requests #152 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #138 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #140 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #148 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #139 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #153 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #154 FAILURE\nLooks like there's a problem with this pull request\n. ribbon-pull-requests #155 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #156 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #157 FAILURE\nLooks like there's a problem with this pull request\n. ribbon-pull-requests #158 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #159 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #160 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #161 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #162 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #166 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #167 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #168 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #169 FAILURE\nLooks like there's a problem with this pull request\n. ribbon-pull-requests #170 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #171 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #172 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #174 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #173 FAILURE\nLooks like there's a problem with this pull request\n. ribbon-pull-requests #175 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #176 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #177 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #178 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #181 FAILURE\nLooks like there's a problem with this pull request\n. ribbon-pull-requests #182 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #179 FAILURE\nLooks like there's a problem with this pull request\n. ribbon-pull-requests #180 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #188 FAILURE\nLooks like there's a problem with this pull request\n. ribbon-pull-requests #189 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #190 FAILURE\nLooks like there's a problem with this pull request\n. ribbon-pull-requests #191 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #192 FAILURE\nLooks like there's a problem with this pull request\n. ribbon-pull-requests #193 FAILURE\nLooks like there's a problem with this pull request\n. ribbon-pull-requests #194 FAILURE\nLooks like there's a problem with this pull request\n. ribbon-pull-requests #195 FAILURE\nLooks like there's a problem with this pull request\n. ribbon-pull-requests #196 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #198 FAILURE\nLooks like there's a problem with this pull request\n. ribbon-pull-requests #199 FAILURE\nLooks like there's a problem with this pull request\n. ribbon-pull-requests #200 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #201 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #183 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #184 ABORTED\n. ribbon-pull-requests #185 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #187 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #186 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #197 FAILURE\nLooks like there's a problem with this pull request\n. ribbon-pull-requests #202 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #203 FAILURE\nLooks like there's a problem with this pull request\n. ribbon-pull-requests #204 FAILURE\nLooks like there's a problem with this pull request\n. ribbon-pull-requests #205 FAILURE\nLooks like there's a problem with this pull request\n. ribbon-pull-requests #207 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #208 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #209 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #211 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #210 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #212 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #213 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #214 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #216 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #217 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #218 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #219 FAILURE\nLooks like there's a problem with this pull request\n. ribbon-pull-requests #220 FAILURE\nLooks like there's a problem with this pull request\n. ribbon-pull-requests #221 FAILURE\nLooks like there's a problem with this pull request\n. ribbon-pull-requests #222 ABORTED\n. ribbon-pull-requests #223 FAILURE\nLooks like there's a problem with this pull request\n. ribbon-pull-requests #224 FAILURE\nLooks like there's a problem with this pull request\n. ribbon-pull-requests #225 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #226 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #227 FAILURE\nLooks like there's a problem with this pull request\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #1 SUCCESS\nThis pull request looks good\n. ribbon-pull-requests #228 SUCCESS\nThis pull request looks good\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #2 SUCCESS\nThis pull request looks good\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #3 SUCCESS\nThis pull request looks good\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #4 SUCCESS\nThis pull request looks good\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #5 SUCCESS\nThis pull request looks good\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #6 SUCCESS\nThis pull request looks good\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #7 SUCCESS\nThis pull request looks good\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #8 SUCCESS\nThis pull request looks good\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #9 FAILURE\nLooks like there's a problem with this pull request\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #10 FAILURE\nLooks like there's a problem with this pull request\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #11 SUCCESS\nThis pull request looks good\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #12 FAILURE\nLooks like there's a problem with this pull request\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #21 FAILURE\nLooks like there's a problem with this pull request\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #22 FAILURE\nLooks like there's a problem with this pull request\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #23 FAILURE\nLooks like there's a problem with this pull request\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #24 FAILURE\nLooks like there's a problem with this pull request\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #26 SUCCESS\nThis pull request looks good\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #13 SUCCESS\nThis pull request looks good\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #14 FAILURE\nLooks like there's a problem with this pull request\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #15 FAILURE\nLooks like there's a problem with this pull request\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #16 FAILURE\nLooks like there's a problem with this pull request\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #18 FAILURE\nLooks like there's a problem with this pull request\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #19 SUCCESS\nThis pull request looks good\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #20 SUCCESS\nThis pull request looks good\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #27 SUCCESS\nThis pull request looks good\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #28 SUCCESS\nThis pull request looks good\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #29 FAILURE\nLooks like there's a problem with this pull request\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #30 SUCCESS\nThis pull request looks good\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #25 SUCCESS\nThis pull request looks good\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #31 SUCCESS\nThis pull request looks good\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #32 FAILURE\nLooks like there's a problem with this pull request\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #34 FAILURE\nLooks like there's a problem with this pull request\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #35 FAILURE\nLooks like there's a problem with this pull request\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #36 FAILURE\nLooks like there's a problem with this pull request\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #38 SUCCESS\nThis pull request looks good\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #39 SUCCESS\nThis pull request looks good\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #40 SUCCESS\nThis pull request looks good\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #41 SUCCESS\nThis pull request looks good\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #42 SUCCESS\nThis pull request looks good\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #43 SUCCESS\nThis pull request looks good\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #44 SUCCESS\nThis pull request looks good\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #45 SUCCESS\nThis pull request looks good\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #46 SUCCESS\nThis pull request looks good\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #47 SUCCESS\nThis pull request looks good\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #48 SUCCESS\nThis pull request looks good\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #49 SUCCESS\nThis pull request looks good\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #50 FAILURE\nLooks like there's a problem with this pull request\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #51 FAILURE\nLooks like there's a problem with this pull request\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #52 FAILURE\nLooks like there's a problem with this pull request\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #53 FAILURE\nLooks like there's a problem with this pull request\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #54 SUCCESS\nThis pull request looks good\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #55 SUCCESS\nThis pull request looks good\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #56 SUCCESS\nThis pull request looks good\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #57 SUCCESS\nThis pull request looks good\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #58 SUCCESS\nThis pull request looks good\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #59 SUCCESS\nThis pull request looks good\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #60 SUCCESS\nThis pull request looks good\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #61 SUCCESS\nThis pull request looks good\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #62 SUCCESS\nThis pull request looks good\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #63 FAILURE\nLooks like there's a problem with this pull request\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #64 FAILURE\nLooks like there's a problem with this pull request\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #65 SUCCESS\nThis pull request looks good\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #67 SUCCESS\nThis pull request looks good\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #68 FAILURE\nLooks like there's a problem with this pull request\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #69 SUCCESS\nThis pull request looks good\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #71 SUCCESS\nThis pull request looks good\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #66 SUCCESS\nThis pull request looks good\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #70 SUCCESS\nThis pull request looks good\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #72 SUCCESS\nThis pull request looks good\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #73 SUCCESS\nThis pull request looks good\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #75 SUCCESS\nThis pull request looks good\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #76 SUCCESS\nThis pull request looks good\n. NetflixOSS \u00bb ribbon \u00bb ribbon-pull-requests #77 SUCCESS\nThis pull request looks good\n. ",
    "looztra": "will try\n. Thanks for the sample code\nI could reproduce it: https://gist.github.com/looztra/5920717\nRuns without any problem when response.releaseResources() is used after each client call\n. will do\n. my bad, I did not launch a full build before providing the PR.\nI can submit a small patch that will not fail findbugs\n. buildhive is vicious in this case:\nBUILD SUCCESSFUL   \nTotal time: 1 mins 40.422 secs\nBuild step 'Invoke Gradle script' changed build result to SUCCESS\nRecording test results\nNo test report files were found. Configuration error?\nBuild step 'Publish JUnit test result report' changed build result to FAILURE\nPutting comment on the pull request\nFinished: FAILURE\ndoh!\n. ",
    "RubenChadien": "Yes, of course\n``` java\n    @Test\n    public void testServerWeightsInit(){\n        try{\n            ConfigurationManager.loadPropertiesFromResources(\"sample-client.properties\"); \n        ConfigurationManager.getConfigInstance().setProperty(\n                \"sample-client.ribbon.NFLoadBalancerClassName\", \"com.netflix.loadbalancer.DynamicServerListLoadBalancer\");\n        ConfigurationManager.getConfigInstance().setProperty(\n                \"sample-client.ribbon.NFLoadBalancerRuleClassName\", \"com.netflix.loadbalancer.WeightedResponseTimeRule\");\n        ConfigurationManager.getConfigInstance().setProperty(\n                \"sample-client.ribbon.InitializeNFLoadBalancer\", \"true\");\n\n        RestClient client = (RestClient) ClientFactory.getNamedClient(\"sample-client\");\n\n        HttpClientRequest request = HttpClientRequest.newBuilder().setUri(new URI(\"/\")).build();\n\n        HttpClientResponse response = client.executeWithLoadBalancer(request);\n        System.out.println(\"Status code for \" + response.getRequestedURI() + \"  :\" + response.getStatus());\n    }\n    catch (Exception e){\n        e.printStackTrace();\n    }\n}\n\n```\nI added som debug logging to ResponseTimeWeightedRule and i think the problem is when it calculates the weights in \njava\npublic void maintainWeights()\nthe server list is size 0, this makes the maxTotalWeight to be zero.\n. ",
    "zarfide": "In eclipse the way to set to remove whitespace:\nPreferences=>Java=>Editor=>Save Actions => add \"Remove trailing white spaces on all lines\"\n. Yes, this is good stuff... I'll try to get to it in the next couple of weeks.\n. Ahh, always forget something... sure... will do...\n. > DiscoveryEnabledNIWSServerList\nI like this idea -- I'll go ahead and put the logic there.\n. Agree -- the test checks for the intent of the code change now.\n. My bad.  I have a bunch of these -- I'll just replace it with string concat.\n. https://code.google.com/p/powermock/issues/detail?id=277\n. Wouldn't this test have passed before since StringIndexOutOfBoundsException is a RuntimeException?  Should something more specific like an IllegalArgumentException be used or should the test check for the actual property name in the error string?\n. Or just check the message in the runtime exception instead of using the expected annotation. (ew?)\n. ",
    "mumrah": "It looks like the DynamicServerListLoadBalancer is shutdown with a JVM shutdown hook. \nAre there any plans to utilize Karyon or Governator within Ribbon?\n. @allenxwang I tried this, and get the following error:\n```\nSLF4J: Failed to load class \"org.slf4j.impl.StaticLoggerBinder\".\nSLF4J: Defaulting to no-operation (NOP) logger implementation\nSLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.\nException in thread \"main\" com.sun.jersey.api.client.ClientHandlerException: java.lang.IllegalArgumentException: URI is not absolute\n    at com.sun.jersey.client.urlconnection.URLConnectionClientHandler.handle(URLConnectionClientHandler.java:151)\n    at com.sun.jersey.api.client.Client.handle(Client.java:648)\n    at com.sun.jersey.api.client.WebResource.handle(WebResource.java:680)\n    at com.sun.jersey.api.client.WebResource.access$200(WebResource.java:74)\n    at com.sun.jersey.api.client.WebResource$Builder.post(WebResource.java:568)\n    at com.netflix.niws.client.http.RestClient.execute(RestClient.java:513)\n    at com.netflix.niws.client.http.RestClient.execute(RestClient.java:418)\n    at [....]\nCaused by: java.lang.IllegalArgumentException: URI is not absolute\n    at java.net.URI.toURL(URI.java:1079)\n    at com.sun.jersey.client.urlconnection.URLConnectionClientHandler._invoke(URLConnectionClientHandler.java:159)\n    at com.sun.jersey.client.urlconnection.URLConnectionClientHandler.handle(URLConnectionClientHandler.java:149)\n    ... 8 more\n```\nI will debug later on tonight.\n. @allenxwang Ah, figured it out...\nI was calling RestClient#execute instead of RestClient#executeWithLoadBalancer. I guess execute requires absolute URIs (which makes sense since otherwise where would the host:port come from). Passing in the JerseyClient worked like a charm. Are there any side effects or features that don't work when you provide the client like this?\n. @allenxwang, great. This is a non-issue then. Thanks for the help\n. ",
    "abesto": "Hi,\nwe've faced the same problem. Here's our current solution (in Scala). It introduces an extra pass over the server list to keep the implementation simple; keep this in mind if you have a huge instance count. (Disclaimer: \"we\" is not Netflix)\n``` scala\nclass PreferredHostRule extends AvailabilityFilteringRule {\n    def getHostname = ???  // Implement your own method to figure out which hostname is preferred\nprotected def serverIsAvailable(lb: ILoadBalancer, server: Server): Boolean = {\n    val circuitBreakerTripped = lb match {\n        case base: BaseLoadBalancer =>\n            base.getLoadBalancerStats.getServerStats.get(server).isCircuitBreakerTripped(System.currentTimeMillis)\n        case _ =>\n            false\n    }\n    server.isAlive && server.isReadyToServe && (!circuitBreakerTripped)\n}\n\noverride def choose(key: scala.Any): Server = Option(getLoadBalancer).map(lb =>\n    lb.getServerList(true).filter{server =>\n        server.getHost == getHostname && serverIsAvailable(lb, server)\n    }).getOrElse(Seq()) match {\n    case Seq()          => super.choose(key)\n    case matchedServers => matchedServers(0)\n}\n\n}\n```\nAnd then use this by adding something like this to your eureka-client.properties:\nproperties\n$CLIENTNAME.ribbon.NFLoadBalancerRuleClassName = com.example.loadbalancer.PreferredHostRule\n. ",
    "dcapwell": "Since jackson is already in the classpath, would it be possible to get jackson support out of the box for more complex json objects?\n. ",
    "timmc": "Ribbon is in fact incorrectly handing querystrings, but it appears to be in dead code as of this moment. If isURIEncoded (which seems to be misnamed?) were to return false, that value would not be overridden and Ribbon would mangle the querystrings. As it is, I do not believe any plausible input can produce this behavior, since I think isURIEncoded would only return true if given something that did not contain URI syntactic characters (such as foo), which would not contain &.\nSo I think the method needs some cleanup, but it appears to be safe for the moment. I would, however, recommend adding a test showing that %26 in a querystring does not get munged:\njava\n    /** Ensure that the encoded ampersand is neither decoded nor double-encoded (regression test) */\n    @Test\n    public void testComputeFinalUriWithLoadBalancer_regressionRaw() throws ClientException {\n        HttpRequest request = HttpRequest.newBuilder().uri(\"/test?ampersand=foo%26bar\").build();\n        HttpRequest newRequest = context.computeFinalUriWithLoadBalancer(request);\n        assertEquals(\"http://www.example.com:8080/test?ampersand=foo%26bar\", newRequest.getUri().toString());\n    }\nMore details on the would-be bug: Ribbon is incorrectly using java.net.URI#getQuery() (by calling it at all!) and is compensating for this by using the multi-argument URI constructor (which also does the wrong thing.) Here's a quick demo of what's wrong with getQuery and the multi-arg constructor:\n``` clojure\nuser=> (def orig (URI. \"http://www.netflix.com/?candy=M%26M\"))\nuser=> (URI. (.getScheme orig) (.getRawUserInfo orig) (.getHost orig) (.getPort orig) (.getRawPath orig) (.getRawQuery orig) (.getRawFragment orig))\n\nuser=> (URI. (.getScheme orig) (.getRawUserInfo orig) (.getHost orig) (.getPort orig) (.getRawPath orig) (.getQuery orig) (.getRawFragment orig))\n\n```\nThe original query has the key-value pair candy = M&M encoded correctly. getQuery incorrectly decodes the %26, which means the result cannot be parsed by splitting on ampersands. Unfortunately, the multi-argument constructor expects to receive just such a value and then encodes all non-safe characters except for ampersands (also wrong). That constructor is never safe to use, since it encodes %, which means a caller cannot safely construct something with ampersands in the data. Here's a demo:\n``` clojure\nuser=> (URI. \"http\" nil \"www.netflix.com\" -1 nil \"candy=M&M\" nil)\n\nuser=> (URI. \"http\" nil \"www.netflix.com\" -1 nil \"candy=M%26M\" nil)\n\n``\n. Yes, I should have been more clear -- that's a test to make sure the line that I highlighted inLoadBalancerContext` is not in effect. (Which it is not, at present, but changes to other parts of the code could expose it and the bug it carries.)\nWhat I'd really like to see is that code reworked to remove the buggy line, but I'm not sure why it's there in the first place, so all I can safely recommend is a safety net to make sure it never takes effect. :-P\n. OK, I have confirmed that that line (back in v0.3.3) was what was causing problems for us. I think the line should be deleted along with the isURIEncoded method, just to be safe.\n. Sure thing!\n. This is to address #49.\n. It would be great if callers could just specify arbitrary strings so that they would not be limited to the most common HTTP methods but I wasn't up for the design task today.\n. I'm having trouble with existing tests, actually. Running ./gradlew clean build from the project root gives me a test failure, even if I back up my repo to 0.3.12:\ncom.netflix.niws.client.http.RetryTest > testSuccessfulRetries FAILED\n    java.lang.AssertionError at RetryTest.java:210\nI assume that's the right command to use for testing -- I grabbed it from the cloudbees console log. :-)\n. Mysterious. Well, I've run ./gradlew clean build several times and RetryTest keeps failing (although HttpAsyncClientTest does not.) It still fails if I remove all 0.3.1x entries from my m2 repo as well, so unless gradle is caching things somewhere, I'm stumped.\nI'll come back to this some other time to see if I can get tests to pass.\n. @lukasT Dunno, not sure if anyone Netflix is still working on this project. The tests on the master branch (and this commit) fail with an SSL verification failure when trying to connect to www.linkedin.com:80 so it seems kind of busted? Our team has moved on and is not using ribbon any longer so I don't have any drive to fix this myself.\n. We ended up not using Eureka + Ribbon for unrelated reasons. If you really need PATCH, I'd recommend using a fork of Ribbon and deploying it to a local Nexus or to Maven Central. You can contact me at the email on my commits if you need more info, probably best to take this discussion off the PR.\n. ",
    "benjchristensen": "I did some load testing today in an unrelated test and got this deadlock:\n```\nFound one Java-level deadlock:\n=============================\n\"qtp1554254702-41\":\n  waiting to lock monitor 0x00007fe584231cd8 (object 0x00000000c8567f68, a org.apache.http.impl.nio.client.DefaultClientExchangeHandlerImpl),\n  which is held by \"RxComputationThreadPool-3\"\n\"RxComputationThreadPool-3\":\n  waiting to lock monitor 0x00007fe564021f48 (object 0x00000000c83f9748, a org.apache.http.impl.nio.client.DefaultClientExchangeHandlerImpl),\n  which is held by \"qtp1554254702-41\"\nJava stack information for the threads listed above:\n\"qtp1554254702-41\":\n    at org.apache.http.impl.nio.client.DefaultClientExchangeHandlerImpl.connectionAllocated(DefaultClientExchangeHandlerImpl.java:266)\n    - waiting to lock <0x00000000c8567f68> (a org.apache.http.impl.nio.client.DefaultClientExchangeHandlerImpl)\n    at org.apache.http.impl.nio.client.DefaultClientExchangeHandlerImpl.access$000(DefaultClientExchangeHandlerImpl.java:57)\n    at org.apache.http.impl.nio.client.DefaultClientExchangeHandlerImpl$1.completed(DefaultClientExchangeHandlerImpl.java:333)\n    at org.apache.http.impl.nio.client.DefaultClientExchangeHandlerImpl$1.completed(DefaultClientExchangeHandlerImpl.java:340)\n    at org.apache.http.concurrent.BasicFuture.completed(BasicFuture.java:115)\n    at org.apache.http.impl.nio.conn.PoolingNHttpClientConnectionManager$InternalPoolEntryCallback.completed(PoolingNHttpClientConnectionManager.java:439)\n    at org.apache.http.impl.nio.conn.PoolingNHttpClientConnectionManager$InternalPoolEntryCallback.completed(PoolingNHttpClientConnectionManager.java:423)\n    at org.apache.http.concurrent.BasicFuture.completed(BasicFuture.java:115)\n    at org.apache.http.nio.pool.AbstractNIOConnPool.fireCallbacks(AbstractNIOConnPool.java:443)\n    at org.apache.http.nio.pool.AbstractNIOConnPool.lease(AbstractNIOConnPool.java:276)\n    at org.apache.http.nio.pool.AbstractNIOConnPool.lease(AbstractNIOConnPool.java:248)\n    at org.apache.http.impl.nio.conn.PoolingNHttpClientConnectionManager.requestConnection(PoolingNHttpClientConnectionManager.java:239)\n    at org.apache.http.impl.nio.client.DefaultClientExchangeHandlerImpl.requestConnection(DefaultClientExchangeHandlerImpl.java:326)\n    at org.apache.http.impl.nio.client.DefaultClientExchangeHandlerImpl.start(DefaultClientExchangeHandlerImpl.java:120)\n    - locked <0x00000000c83f9748> (a org.apache.http.impl.nio.client.DefaultClientExchangeHandlerImpl)\n    at org.apache.http.impl.nio.client.InternalHttpAsyncClient.execute(InternalHttpAsyncClient.java:188)\n    at org.apache.http.impl.nio.client.CloseableHttpAsyncClient.execute(CloseableHttpAsyncClient.java:57)\n    at rx.apache.http.ObservableHttp$2.onSubscribe(ObservableHttp.java:146)\n    at rx.apache.http.ObservableHttp$1.onSubscribe(ObservableHttp.java:96)\n    at rx.Observable.subscribe(Observable.java:205)\n    at rx.operators.OperationMap$MapObservable.onSubscribe(OperationMap.java:139)\n    at rx.operators.OperationMap$1.onSubscribe(OperationMap.java:65)\n    at rx.Observable.subscribe(Observable.java:205)\n    at rx.operators.OperationMerge$MergeObservable.onSubscribe(OperationMerge.java:150)\n    at rx.operators.OperationMerge$1.onSubscribe(OperationMerge.java:69)\n    at rx.Observable.subscribe(Observable.java:205)\n    at rx.operators.OperationMap$MapObservable.onSubscribe(OperationMap.java:139)\n    at rx.operators.OperationMap$1.onSubscribe(OperationMap.java:65)\n    at rx.Observable.subscribe(Observable.java:205)\n    at rx.operators.OperationMerge$MergeObservable.onSubscribe(OperationMerge.java:150)\n    at rx.operators.OperationMerge$1.onSubscribe(OperationMerge.java:69)\n    at rx.Observable.subscribe(Observable.java:205)\n    at rx.operators.OperationZip$ZipObserver.startWatching(OperationZip.java:176)\n    at rx.operators.OperationZip$Aggregator.onSubscribe(OperationZip.java:321)\n    at rx.Observable.subscribe(Observable.java:205)\n    at rx.operators.OperationMap$MapObservable.onSubscribe(OperationMap.java:139)\n    at rx.operators.OperationMap$1.onSubscribe(OperationMap.java:65)\n    at rx.Observable.subscribe(Observable.java:205)\n    at rx.operators.OperationMerge$MergeObservable.onSubscribe(OperationMerge.java:150)\n    at rx.operators.OperationMerge$1.onSubscribe(OperationMerge.java:69)\n    at rx.Observable.subscribe(Observable.java:205)\n    at rx.operators.OperationZip$ZipObserver.startWatching(OperationZip.java:176)\n    at rx.operators.OperationZip$Aggregator.onSubscribe(OperationZip.java:321)\n    at rx.Observable.subscribe(Observable.java:205)\n    at rx.operators.OperationMerge$MergeObservable.onSubscribe(OperationMerge.java:150)\n    at rx.operators.OperationMerge$1.onSubscribe(OperationMerge.java:69)\n    at rx.Observable.subscribe(Observable.java:215)\n    at perf.test.TestCaseAServlet.doGet(TestCaseAServlet.java:74)\n    at javax.servlet.http.HttpServlet.service(HttpServlet.java:687)\n    at javax.servlet.http.HttpServlet.service(HttpServlet.java:790)\n    at org.eclipse.jetty.servlet.ServletHolder.handle(ServletHolder.java:698)\n    at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1564)\n    at org.eclipse.jetty.websocket.server.WebSocketUpgradeFilter.doFilter(WebSocketUpgradeFilter.java:164)\n    at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1535)\n    at org.eclipse.jetty.servlet.ServletHandler.doHandle(ServletHandler.java:524)\n    at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:138)\n    at org.eclipse.jetty.security.SecurityHandler.handle(SecurityHandler.java:568)\n    at org.eclipse.jetty.server.session.SessionHandler.doHandle(SessionHandler.java:221)\n    at org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:1110)\n    at org.eclipse.jetty.servlet.ServletHandler.doScope(ServletHandler.java:453)\n    at org.eclipse.jetty.server.session.SessionHandler.doScope(SessionHandler.java:183)\n    at org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:1044)\n    at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:136)\n    at org.eclipse.jetty.server.handler.ContextHandlerCollection.handle(ContextHandlerCollection.java:200)\n    at org.eclipse.jetty.server.handler.HandlerCollection.handle(HandlerCollection.java:109)\n    at org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:97)\n    at org.eclipse.jetty.server.Server.handle(Server.java:445)\n    at org.eclipse.jetty.server.HttpChannel.handle(HttpChannel.java:278)\n    at org.eclipse.jetty.server.HttpConnection.onFillable(HttpConnection.java:216)\n    at org.eclipse.jetty.io.AbstractConnection$1.run(AbstractConnection.java:505)\n    at org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:601)\n    at org.eclipse.jetty.util.thread.QueuedThreadPool$3.run(QueuedThreadPool.java:532)\n    at java.lang.Thread.run(Thread.java:724)\n\"RxComputationThreadPool-3\":\n    at org.apache.http.impl.nio.client.DefaultClientExchangeHandlerImpl.connectionAllocated(DefaultClientExchangeHandlerImpl.java:266)\n    - waiting to lock <0x00000000c83f9748> (a org.apache.http.impl.nio.client.DefaultClientExchangeHandlerImpl)\n    at org.apache.http.impl.nio.client.DefaultClientExchangeHandlerImpl.access$000(DefaultClientExchangeHandlerImpl.java:57)\n    at org.apache.http.impl.nio.client.DefaultClientExchangeHandlerImpl$1.completed(DefaultClientExchangeHandlerImpl.java:333)\n    at org.apache.http.impl.nio.client.DefaultClientExchangeHandlerImpl$1.completed(DefaultClientExchangeHandlerImpl.java:340)\n    at org.apache.http.concurrent.BasicFuture.completed(BasicFuture.java:115)\n    at org.apache.http.impl.nio.conn.PoolingNHttpClientConnectionManager$InternalPoolEntryCallback.completed(PoolingNHttpClientConnectionManager.java:439)\n    at org.apache.http.impl.nio.conn.PoolingNHttpClientConnectionManager$InternalPoolEntryCallback.completed(PoolingNHttpClientConnectionManager.java:423)\n    at org.apache.http.concurrent.BasicFuture.completed(BasicFuture.java:115)\n    at org.apache.http.nio.pool.AbstractNIOConnPool.fireCallbacks(AbstractNIOConnPool.java:443)\n    at org.apache.http.nio.pool.AbstractNIOConnPool.lease(AbstractNIOConnPool.java:276)\n    at org.apache.http.nio.pool.AbstractNIOConnPool.lease(AbstractNIOConnPool.java:248)\n    at org.apache.http.impl.nio.conn.PoolingNHttpClientConnectionManager.requestConnection(PoolingNHttpClientConnectionManager.java:239)\n    at org.apache.http.impl.nio.client.DefaultClientExchangeHandlerImpl.requestConnection(DefaultClientExchangeHandlerImpl.java:326)\n    at org.apache.http.impl.nio.client.DefaultClientExchangeHandlerImpl.start(DefaultClientExchangeHandlerImpl.java:120)\n    - locked <0x00000000c8567f68> (a org.apache.http.impl.nio.client.DefaultClientExchangeHandlerImpl)\n    at org.apache.http.impl.nio.client.InternalHttpAsyncClient.execute(InternalHttpAsyncClient.java:188)\n    at org.apache.http.impl.nio.client.CloseableHttpAsyncClient.execute(CloseableHttpAsyncClient.java:57)\n    at rx.apache.http.ObservableHttp$2.onSubscribe(ObservableHttp.java:146)\n    at rx.apache.http.ObservableHttp$1.onSubscribe(ObservableHttp.java:96)\n    at rx.Observable.subscribe(Observable.java:205)\n    at rx.operators.OperationMap$MapObservable.onSubscribe(OperationMap.java:139)\n    at rx.operators.OperationMap$1.onSubscribe(OperationMap.java:65)\n    at rx.Observable.subscribe(Observable.java:205)\n    at rx.operators.OperationMerge$MergeObservable.onSubscribe(OperationMerge.java:150)\n    at rx.operators.OperationMerge$1.onSubscribe(OperationMerge.java:69)\n    at rx.Observable.subscribe(Observable.java:205)\n    at rx.operators.OperationMap$MapObservable.onSubscribe(OperationMap.java:139)\n    at rx.operators.OperationMap$1.onSubscribe(OperationMap.java:65)\n    at rx.Observable.subscribe(Observable.java:205)\n    at rx.operators.OperationMerge$MergeObservable.onSubscribe(OperationMerge.java:150)\n    at rx.operators.OperationMerge$1.onSubscribe(OperationMerge.java:69)\n    at rx.Observable.subscribe(Observable.java:205)\n    at rx.operators.OperationZip$ZipObserver.startWatching(OperationZip.java:176)\n    at rx.operators.OperationZip$Aggregator.onSubscribe(OperationZip.java:321)\n    at rx.Observable.subscribe(Observable.java:205)\n    at rx.operators.OperationMerge$MergeObservable$ParentObserver.onNext(OperationMerge.java:236)\n    at rx.operators.OperationMerge$MergeObservable$ParentObserver.onNext(OperationMerge.java:189)\n    at rx.operators.OperationMap$MapObservable$1.onNext(OperationMap.java:142)\n    at perf.test.utils.BackendResponse$1.onSubscribe(BackendResponse.java:59)\n    at rx.Observable.subscribe(Observable.java:205)\n    at rx.operators.OperationSubscribeOn$SubscribeOn$1.call(OperationSubscribeOn.java:57)\n    at rx.operators.OperationSubscribeOn$SubscribeOn$1.call(OperationSubscribeOn.java:54)\n    at rx.concurrency.DiscardableAction.call(DiscardableAction.java:44)\n    at rx.concurrency.ExecutorScheduler$4.run(ExecutorScheduler.java:126)\n    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:471)\n    at java.util.concurrent.FutureTask.run(FutureTask.java:262)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:178)\n    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:292)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)\n    at java.lang.Thread.run(Thread.java:724)\n```\nI can't yet see anything I am doing wrong to cause it ... but it's happening deep inside the client.\n. You can see the implementation where that deadlock occurred in two places:\n- https://github.com/benjchristensen/WSPerfLab/blob/master/ws-impls/ws-java-servlet-blocking-rxjava/src/main/java/perf/test/TestCaseAServlet.java\n- https://github.com/benjchristensen/WSPerfLab/blob/master/ws-impls/ws-java-servlet-3_1-nonblocking-rxjava/src/main/java/perf/test/TestCaseAServlet.java\n. Since this is 82 files ... can you point me to where specifically I should start? What's the entry point?\n. Ah nice!\n. Excellent, thanks for the heads up. I'll update in our perf tests and retry.\n. This is great @allenxwang, thank you for kicking off this discussion with a well thought-out proposal.\n. Regarding the AsyncRequest name, it seems it should be something without Synchronous or Asynchronous in the name since both execution modes are supported.\nWhat is the reason for not having just RibbonRequest? \n. The FallbackDeterminator seems to solve a valid need, but the semantics seem more narrow than desirable. \nFor example, right now with it just returning a boolean all Ribbon can now do is throw a standard Exception of some kind to trigger failure.\nShouldn't we either let the function throw an Exception or return one of its own making?\nIn other words, if we instead just had a callback such as onNetworkResponse or mapNetworkResponse then a user can do anything they want, including failing.\nA signature could be:\njava\npublic void onNetworkResponse(Func1<T response, R returnResponse> f);\nThen it could be used like this:\njava\nonNetworkResponse(HttpClientResponse<ByteBuf> response -> {\n     if(response.getStatus().code() >= 500) {\n          throw MyCustomException(\"message here\");\n     } else {\n          return response; // pass-thru (but could decorate or modify if wanted)\n     }\n});\nI don't know the input and return types well enough to get this quite right, but what do you think of this kind of approach that is more generic and allows both success and error handling with increased flexibility?\n. The signature of HystrixFallbackProvider doesn't seem to be a provider, but a function. It's not a factory providing a fallback function, it is just the function isn't it? And I believe that's correct, all it needs to be is a function of this signature:\njava\nFunc1< HystrixExecutableInfo<T>, Observable<T>>\nSo I think it should just be called HystrixFallback or FallbackHandler or something like that, but not \"provider\".\nNote also how I change it from HystrixCommand to HystrixExecutableInfo. We need something that both HystrixCommand and HystrixObservableCommand implement (though we could probably get away with just HystrixObservableCommand as everything here should be non-blocking). The other benefit to HystrixExecutableInfo is that it has none of the execution methods on it, just the metadata. The only thing I don't like about HystrixExecutableInfo is its name.\nSo I suggest either HystrixObservableCommand or HystrixExecutableInfo, but not HystrixCommand as that is blocking.\n. For caching there are 2 types of cache keys we need to support:\n1) Hystrix getCacheKey() for in-memory caching (request-scoped, de-duping)\n2) EVCache/Memcached/Cassandra/whatever caching\nThe first is nothing but a simple function that takes the input args and returns the cache key.\nThe second is I think what the CacheProvider is solving for, correct? \n. Regarding withHystrixInfo:\njava\npublic RibbonRequest<HystrixResponse<T>> withHystrixInfo();\nIt seems this is overly precise when there could be other types of metadata we want to make available, including the HTTP response codes, headers, etc (even when type T is returned).\nHow about:\n``` java\npublic RibbonRequest> withMetadata();\npublic interface RibbonResonse  {\n  public HystrixExecutableInfo getHystrixInfo();\n  public HttpHeaders getHttpHeaders(); // or whatever we want here\n  ... etc ...\n  public T getResponse();\n}\n``\n. On theRibbonfactory, what is the difference betweenfromandcreate` that has a \"contract\" class?\nhttps://github.com/allenxwang/ribbon/blob/2.x-commonclient/ribbon-client-extensions/src/main/java/com/netflix/ribbonclientextensions/Ribbon.java#L14\n. The RibbonClient piece looks like it will support TCP, HTTP, etc. Does that mean the FallbackDeterminator functionality (and other similar things) will get the type via the transport chosen such that it could get an HttpResponse or TcpResponse object?\nI suggest we consider having two different object models, one for request/response like HTTP (including SSE), and another for bi-directional such as TCP and WebSockets. This is similar to the decisions we've made in RxNetty since request/response and bi-directional streaming are very different. \nHow do you think that will affect this design?\n. What does \"success status\" and \"error status\" end up causing to occur?\n. How does this differ from just having a function that lets you do whatever is needed?\njava\nonNetworkResponse(HttpClientResponse<ByteBuf> response -> {\n     if(response.getStatus().code() >= 500) {\n          throw MyCustomException(\"message here\");\n     } else {\n          return response; // pass-thru (but could decorate or modify if wanted)\n     }\n});\n. This discussion is about the details \u2013 we are designing the API :-)\n\nIt does not. We evolved into that function. \n\nCool, that's good to know ... as we want to have something as generic as possible without making it useless.\n\ncontains a set of defaults for the overall client\n\nMakes sense to make reuse easy, basically \"partial application\" (http://en.wikipedia.org/wiki/Partial_application and http://www.ibm.com/developerworks/library/j-jn9/).\n. > Does it translate to having a method copy()\nProbably something like that as I doubt we can afford the object allocation overhead of making the builder immutable. If we could do it as an immutable builder (like Rx sequences) then you can take any Template at any point and just embed inside something else without worrying about mutation.\n. > I still don't think it's a good Idea to expose Hystrix.  It really should be an implementation detail that is hidden from the users of Ribbon Client. \nI disagree. They need to be aware since they are going to be looking at all the metrics and managing all the properties. It is far better to be transparent rather than opaque. \nUnless we are planning on hiding all properties, metrics, dashboards and other such system that are about Hystrix, we should not try and hide Hystrix underneath Ribbon. \n. Regarding the cache provider design, I agree with @NiteshKant:\n\nPassing a list would prohibit use of lambdas/closures.\n\nWe want to support functional interfaces and the use of closures.\nThis interface is good:\njava\npublic interface CacheProvider<T> {\n    Observable<T> get(String key);\n}\nWhat is needing to be associated with it? If a key or something, then it can be like this:\njava\nwithCacheKey(String keyTemplate, CacheProvider provider);\nThis can be used like this:\njava\nwithCacheKey(someCacheKeyTemplate, (key) -> {\n    return Observable.from(data);\n});\n. > clearCacheProviders()\nThat is a really odd thing for a builder pattern. I don't like the idea of removing/altering what has already been \"built\". \nThat seems to mean the templates being built on top of are built wrong and should be simpler defaults without cache providers.\n. > We could/should add an HystrixFallbackHandler and an HystrixFallbackDeterminator to the Hystrix code base that would allow straightforward plugging in of an existing Hystrix command. for those that have already embraced them.\nThat's already doable if you're handling an existing command without fallback:\njava\ncommand.observe().onErrorResumeNext((error) -> {\n return fallback here;\n})\n. My view on FallbackDeterminator was stated at https://github.com/Netflix/ribbon/issues/99#issuecomment-45826702\nI find it too restrictive by just returning a boolean that says \"fallback\". This prevents it from providing/throwing an exception with details about what the failure is. \nRibbon would only be able to do something like:\njava\nif(fallbackDeterminator.call()) {\n   // it says to fallback but we have no idea why so just throw a generic error\n  throw FallbackDeterminatorException()\n}\nIt could have no cause associated, no error message, etc.\nInstead, if we allow a function to be executed like the following, the user has far more control over the failure and messaging. This is then thrown to the user, or available in the fallback handler.\njava\nonNetworkResponse(HttpClientResponse<ByteBuf> response -> {\n     if(response.getStatus().code() >= 500) {\n          throw MyCustomException(\"message here\");\n     } else {\n          return response; // pass-thru (but could decorate or modify if wanted)\n     }\n});\n. @khawes I don't know if I understand what you're saying, but I think you're suggesting we'd allow wrapping existing HystrixCommands inside the new Ribbon API. Is that what you're saying?\n. > NOT fall back\nThat's HystrixBadRequestException, but we could have RibbonBadRequestException or whatever extend from that. It bypasses the Hystrix fallback logic.\n. Ribbon should not accept existing HystrixCommand instances. The whole point of the Ribbon 2 API is to define the implementation methods of a HystrixCommand plus the networking piece. Thus, an existing HystrixCommand already has the run() method and possibly getFallback() implemented. \n. The only parts I'm aware of Hystrix being exposed are:\n1) Optionally if asking for withMetadata there would be a getHystrixInfo option that returns HystrixExecutableInfo to get access to the many pieces of runtime results.\nThis is shown here: https://github.com/Netflix/ribbon/issues/99#issuecomment-45827312\n2) The fallback handler needs to be given the HystrixExecutableInfo to handle various use cases where the fallback behaves differently depending on the scenario (short-circuit, error, etc).\nThis is shown here: https://github.com/Netflix/ribbon/issues/99#issuecomment-45826885\nFor example:\njava\n// I'm explicitly including the types in the lambdas for clarity, but real code wouldn't need them\nRibbon.from(httpClient)\n        .newRequestTemplate()\n        .onNetworkResponse((HttpClientResponse<ByteBuf> response) -> {\n             if(response.getStatus().code() >= 500) {\n               throw MyCustomException(\"message here\");\n              } else {\n               return response; // pass-thru (but could decorate or modify if wanted)\n              }\n         })\n         .withFallback((HystrixExecutableInfo info) -> {\n            if(info.isResponseShortCircuited()) {\n                return specialFallback;\n            } else {\n                if(info.getFailedExecutionException() instanceOf SomeThingImLookingFor) {\n                    return fallback1;\n                } else {\n                    return fallback2;\n                }\n            }\n         })\n. ... going quiet on here for a while ... \n. Right now it doesn't have a way to set HystrixThreadPoolProperties as originally it was intended to not allow using thread-isolation on an ObservableCommand, but I'll probably add it back. This shouldn't affect Ribbon though, as you should just accept the HystrixObservableCommand.Setter and then anything on it can be configured.\n. K.I.S.S to me argues against FallbackDeterminator as it is a single-purpose thing. The simplest thing is a function that allows throwing an exception.\n. The handler will have access to the network response (headers, content, status codes, etc) and can inspect whatever it needs to for making a decision:\njava\nRibbon.from(httpClient)\n        .newRequestTemplate()\n        .onNetworkResponse((HttpClientResponse<T> response) -> {\n               // right here it can look at whatever it wants\n             if(response.getStatus().code() >= 500) {\n               throw MyCustomException(\"message here\");\n              } else {\n                 // validate content\n                 if(response.getContent().isValid()) {\n                     throw new BadDataException(\"the data is corrupt\");\n                 } else {\n                        return response; // pass-thru (but could decorate or modify if wanted)\n                }\n              }\n         })\n. A HystrixBadRequestException (or whatever we extend that with) is thrown to the user with whatever message/cause you gave it.\n. > Remember we are asking service owners to write these clients and they are not well versed in RX. Making them learn RX puts an overturned big rig on our road to adoption.\nThe function being discussed has little to do with Rx so please don't conflate them. The function is nothing more than a callback to process from HttpClientResponse<T> to either Throwable or T.\n. How does the onNetworkResponse have anything to do with defining \"how\" to fallback? It is only about processing a network response and deciding if you want to throw an exception. \nThe fallback, if you can implement one, is passed into the withFallback method. If you can't provide one, then a consumer will either receive an exception and must handle it, or must provide you a function that can be injected into the withFallback method.\nThe two use cases you are referring to are handled in two different places.\nHere is the code again to show the two places:\njava\nRibbon.from(httpClient)\n        .newRequestTemplate()\n        .onNetworkResponse((HttpClientResponse<ByteBuf> response) -> {\n             // use case 1: when to fallback\n            // handle use case to determine a failure based on network or data \n            return ...;\n         })\n         .withFallback((HystrixExecutableInfo info) -> {\n            // use case 2: how to fallback\n         })\n. If I understand correctly your arguments are:\n1) You don't find the name onNetworkResponse clear and are concerned it will result in developer error.\n2) You don't think onNetworkResponse should be able to both throw and transform data.\nFor 2, even if we split it into two functions, I don't see how that prevents misuse. For example, we could code it like this\"\njava\nRibbon.from(httpClient)\n        .newRequestTemplate()\n        .throwIfBad((HttpClientResponse<ByteBuf> response) -> {\n             // throw an exception if bad\n             if(x) throw new RuntimeException(); // this will go to fallback \n         })\n        .transformIfNeeded((HttpClientResponse<ByteBuf> response) -> {\n             return response or transformed response;\n         })\n         .withFallback((HystrixExecutableInfo info) -> {\n            // use case 2: how to fallback\n         })\nThe transformIfNeeded function can still be misused as you suggest. And what if they throw exceptions from there, since they can achieve everything about throwIfBad from transformIfNeeded.\nSo, we can split them up, but I don't like doing so. The onNetworkResponse(Func<NetworkResponse, T>) approach is the simplest, most flexible way of doing it - let the user process the response and do anything they need or want to do to it:\na) do nothing, it's fine\nb) throw a RuntimeException, it's bad, go to fallback\nc) throw a HystrixBadRequestException, it's bad, but the users fault so don't go to fallback\nd) manipulate the data (such as mapping keys), return to user\nIf we split these it is purely arbitrary, artificially limiting, and less efficient (causing the response to be processed twice).\nSemantically throwIfBad takes (b) and (c) and transformIfNeeded takes (a) and (d) and then withFallback if (b) happens, but in practice I can do all of it within the transformIfNeeded method.\nConsidering all of that, let's determine whether (d) is necessary. If it's not then this debate is moot as we don't need the ability to transform and return type T. If it is needed I don't see any reason to split it into two functions, just let it stay simple as if it is a map function from T -> R.\nThe premise of (d) has been that some data comes off the wire and there is a reason to allow modifying it somehow. \nThinking about this further though, I'm not sure that will work very well due to serialization and static typing. We can't mess with static types all that well. It could work with dictionaries (mapping keys for example), but that is a runtime decision by the user, not something that can be coded into this by the developer providing the client.\nSo perhaps onResponse is an Action1<HttpClientResponse> that doesn't have a return type and can only throw?\njava\nRibbon.from(httpClient)\n        .newRequestTemplate()\n        .onResponse((HttpClientResponse<ByteBuf> response) -> {\n             // throw an exception if bad\n             if(x) throw new RuntimeException(); // this will go to fallback \n         })\n         .withFallback((HystrixExecutableInfo info) -> {\n            // use case 2: how to fallback\n         })\nand if that's the case, would a name like validateResponse be preferable?\njava\nRibbon.from(httpClient)\n        .newRequestTemplate()\n        .validateResponse((HttpClientResponse<ByteBuf> response) -> {\n             // throw an exception if bad\n             if(x) throw new RuntimeException(); // this will go to fallback \n         })\n         .withFallback((HystrixExecutableInfo info) -> {\n            // use case 2: how to fallback\n         })\nHowever, the thing I don't like about validateResponse is it implies it's only for validation, but any side-effecting work can be done there. This is why I prefer things like map(T -> R) as it does not limit what can be done by its name.\nShould transforming of the response be permitted or not? It looks like it may be problematic.\n. Are these dependencies common for all of the submodules, including ribbon-core?\n. ",
    "yairogen": "My bad. The \"MaxAutoRetriesNextServer\" wasn't set properly. It works fine. Thanks.\n. Thanks. I thought it uses the Jersey client, no?\nOn Oct 30, 2013 6:04 PM, \"allenxwang\" notifications@github.com wrote:\n\nThe class that extends 'AbstractLoadBalancerAwareClient' is\ncom.netflix.niws.client.http.RestClient. RestClient uses NFHttpClient as\nthe underlying client for HTTP communication.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/Netflix/ribbon/issues/55#issuecomment-27404292\n.\n. Exactly. Jersey client as a rest client is a stopper for us. Non rest APIs\ndon't feel natural.\nOn Oct 30, 2013 8:02 PM, \"allenxwang\" notifications@github.com wrote:\nYes, it uses Jersey client. Jersey client in turn uses the Apache\nHttpClient.\nAre you suggesting that you would like an implementation directly on top\nof HttpClient without Jersey client?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/Netflix/ribbon/issues/55#issuecomment-27419824\n.\n. Nice.\n\nSo, if I'm picking this up then the AsyncClient should also have a LoadBalancerAwareClient wrapping, right?\n. Allen, I'm happy to contribute. Can you point me to some resource on the process of contribution? \nAlso, I'm not a Gradle user. I use maven. Can this work out somehow? \n. @allenxwang  I haven't had the time to contribute but am now interested again. Was this already done by someone?\n. ",
    "dstengle": "Does your test run for long enough that the dynamic callbacks trigger a refresh of the properties? It also works for me right after the load from properties. Later on (sleep 30?), when the client is retrieved for use, the properties are suddenly different.\nWe've tried using a different namespace and not. That doesn't seem to be the problem. Some time after successful loading, if you get the properties of the named client \"myclient\" there will be a property of myNameSpace.MaxAutoRetriesNextServer=10 and another property MaxAutoRetriesNextServer=2 (or whatever the default is).\nI will try recreating the problem with your code above. We've been encountering this in the zuul project which is using  older libraries for everything (even though none of the code related to this has changed). I really can't see how this is happening. We spent a day and a half looking through lots of the code and it all looks right, we just couldn't get it to work.\n. I tried reproducing this several ways in the test code above, including moving the config out to a file with a polling loader and confirming that the value is getting changed and I don't get any difference.\nIn zuul the behavior is very different and I wonder if it has anything to do with the fact that it is running inside a Groovy class that may be slightly different with respect to the classloader?\nThe frustrating thing is, even when we use the default namespace and the config is correct, Ribbon is still following redirects. This is doubly broken when the original URL is SSL but the backend is http. Not sure if there is a way to do this that makes sense inside Ribbon or if it requires more post-processing (if we want to actually handle the redirect).\n. It feels as if this is possible. Looking at @stonse talk on microservices, the ribbon example shows ribbon returning a typed object when the client is generated from a service interface. The mechanics of this are not clear, though.\nThe RxMovieProxyExample.java just deals in ByteBuf. Is this just unreleased code?\nI just found this burried in there:\nthrow new ProxyAnnotationException(format(\"Method %s must return\nRibbonRequest type not %s\",\nSo it seems like the current implementation only allows working with ByteBuf.\n. I want the properties to be read from archaius, not written to. I want an IClientConfig to be built from properties, not the other way around. Like the older code:\nRestClient client = (RestClient) ClientFactory.getNamedClient(\"sample-client\")\nWith @ClientProperties it's back to hard-coding things.\nWhat about a @NamedClient / @NamedClientProperties annotation or something similar? It seems like the same config code is used underneath and ultimately it all comes back to an IClientConfig.\n. This is perfect! I see the implementation in the ResourceGroup.java and how it is derived from the class' simple name in ProxyHttpResourceGroupFactory.java\nI was getting geared up to try and do a patch for an annotation, but it looks like it isn't necessary.\nIs there any way to contribute to documentation?\n. ",
    "g9yuayon": "Would we need a streamCompleted(END end) in StreamingResponseCallback? Otherwise, how would we distinguish streaming being done from server being idle? \n. ",
    "NiteshKant": "Thanks Allen for sharing this, these interfaces look much better & streamlined.\n\"The reason is that since the client is generically typed for response, an entity typed response for the client means the client should only deal with one type of entity, which is often not the case for a general HTTP client and makes it harder to add async style to RestClient without breaking compatibility.\"\nI did not understand this statement. What will be the case a client handles multiple type of entities for the same request. I do understand error & success, which we can factor for.\nAlso, since Async & existing client interfaces are completely different, I do not understand the compatibility part.\nThe ResponseWithTypedEntity interface exposes entity & inputstream both, are they mutually exclusive i.e. can I call both getEntity() & getInputStream on the same response instance? \nDo we really need TypeToken in these interfaces? I think it will be better not to have a dependency on ext libraries in these public interfaces.\nHttpResponse exposes headers as a Map (logically Multimap). This will entail a copy of data from the underneath framework (netty in our case) to convert from the framework representation to a map. Also, it makes the framework loose control (unless you wrap the map implementation) on what is added/removed from the headers & validation thereof. \nAlso, the response just exposes the status code, not the status message, if any.\nIn both client interface execute methods throw an exception. I think it will be better to model this as a failure callback on the future listener. The current abstraction makes it confusing as to in which case will you throw an exception & in which case will it be a callback. \nAlso, in general, it will be better to make any objects passed to the callback not throw exception unless they are doing a computation. \n. Thanks @benjchristensen for comments!\n\n\n\nRegarding the AsyncRequest name, it seems it should be something without Synchronous or Asynchronous in the name since both execution modes are supported.\n\n\n\nI agree, the AsyncRequest name does not represent what it does. The intent of having a base interface for RibbonRequest was that HystrixResponse interface also had the same methods execute(), queue(), observe() and toObservable() but the name is not correct. Also, we can just keep it package private and not expose it outside as the intent is just to share the methods.\n\n\n\nShouldn't we either let the function throw an Exception or return one of its own making?\n\n\n\nWe discussed about this point, but decided against it because the use case seems to be of transforming a response and it fits in naturally more at the transport level instead of the Ribbon API level. I was intending to move the karyon interceptor abstraction into rx-netty and make it available for both client and server. Finagle calls this abstraction as filters.\nAt the hystrix level, we would want to handle entities as opposed to transport responses as the transport is already done at the time of making these decisions.\n\n\n\nThe signature of HystrixFallbackProvider doesn't seem to be a provider, but a function.\n\n\n\nAgree with this comment entirely.\n\n\n\nFor caching there are 2 types of cache keys we need to support\n\n\n\nThe reason why this does not fit in as two CacheProviders is because the key can be different?\n\n\n\nIt seems this is overly precise when there could be other types of metadata we want to make available, including the HTTP response codes, headers, etc (even when type T is returned).\n\n\n\nAgree with the name being too precise. \n\n\n\nOn the Ribbon factory, what is the difference between from and create that has a \"contract\" class?\n\n\n\nThey should both be named from()\n\n\n\nThe RibbonClient piece looks like it will support TCP, HTTP, etc. Does that mean the FallbackDeterminator functionality (and other similar things) will get the type via the transport chosen such that it could get an HttpResponse or TcpResponse object?\n\n\n\nThe purpose of RibbonTransport is to marry ribbon's load balancing feature with RxNetty's transport.\nRibbonClient as it stands today is catering to a request-response protocol and it tries to reflect that by having the only method newRequestTemplate(). Currently, there is only HTTP but the other protocols would be Thrift, ProtoBuf, custom binary request-response protocol, etc.\nI am not very sure how will hystrix fallback, cache, etc. will fit into a full-duplex protocol like websockets, my current understanding being that those will not make sense. eg; what will you cache or fallback for a websocket/tcp connection. What would be handy is the hystrix traffic shaping functionalities which we would have to work out when we get to the full duplex protocol level.\nHowever, from this point I am starting to think that we can completely eliminate the RibbonClient abstraction. Instead we may want to only have \n``` java\npublic final class Ribbon {\nprivate Ribbon() {\n}\n\npublic static <I, O> HttpRequestTemplate<I, O> newHttpRequestTemplate(HttpClient<I, O> transportClient) {\n    // ...\n}\n\npublic static <I, O, T> T from(Class<T> contract, HttpClient<I, O> transportClient) {\n    // ...\n}\n\n}\n``\n. @benjchristensen are thewithHystrix*PropertiesDefault()` methods sufficient?\nShould programmatically defining these properties in the template be the only way to specify hystrix properties or there should also be a convention, eg:\n<request-template-identifier>.HystrixCommand.execution.isolation.thread.timeoutInMilliseconds\n. > > > Please don't loose the ability to create templates based on templates that is in the original RibbonResource prototype that I wrote.\n@khawes can you explain the usecase more? \n. > > > What about something like RxRequest?\n@allenxwang yeah that could work too but I would vote for making the interface package private as it is just for defining common methods and making it public introduces confusion as to why is there a RibbonRequest and RxRequest? What is the difference between them?\n. > > > Makes sense to make reuse easy, basically \"partial application\" \nDoes it translate to having a method copy() on RequestTemplate which creates a new copy and then since the builder is additive, you start building from the copy.\n. @allenxwang can you update the design proposal in this issue with the latest code?\nwithCache(String keyTemplate, List<CacheProvider<O>> providers) can this be broken down into two methods:\nwithCacheKey(String keyTemplate)\nand \nwithCacheProvider(CacheProvider<O> provider)\nPassing a list would prohibit use of lambdas/closures.\n. > > > Probably something like that as I doubt we can afford the object allocation overhead of making the builder immutable. If we could do it as an immutable builder (like Rx sequences) then you can take any Template at any point and just embed inside something else without worrying about mutation.\nYeah it would be good to have the template thread-safe (by immutability) but the cost would be large as it means every mutation copies the template. I think we can just say that the template is not threadsafe from the point of view of mutations to the template, however each template.requestBuilder() call creates a new RequestBuilder and this method specifically is safe to be called concurrently.\nThis model will aid people to create a shared RequestTemplate instance which can be used across threads to create new RequestBuilder and hence RibbonRequest instances.\n. @khawes If I understand correctly, you are fine with the approach of providing a copy() method on the template to support the usecase you were mentioning.\n. > > > Templates are meant to be static and created at initialization time, after\n\n\n\nthat you use the requestBuilder call to get a thread safes copy that can\nthen be used to make your remote call by adding in the values to fill out\nyour template, and initiating the remote call.\n\n\n\nOk so I understand that you support the proposed design.\n. > > > Shouldn't the keyTemplate be the same for all providers, including Hystrix?\nYeah that was the reason to break into two methods. Having different templates for different providers would mandate we do a string replace per provider, which in most cases should be unnecessary.\n. I think we should also have a variable map passed to the CacheProvider.get() for cases where the passed key does not directly map to the out of process cache. Thoughts?\n. @khawes we are exposing Netty when we think it is an overhead to hide (i.e. we expose netty's ByteBuffer) and we build on top of netty when we think the abstractions can be improved. \nThe same argument is with Hystrix. \nConfiguration\nFrom the perspective of people using ribbon 2, there is no good reason for us to provide a different configuration which translates to hystrix configuration as a majority of people inside Netflix use Hystrix now. This change will make them define these new config with no additional value.\nRuntime\nSince, we are using Hystrix internally, having our API exposing a different interface wrapping Hystrix means we create a wrapper object per hsytrix command execution. This is an overhead which is unwarranted.\nSo, I think hiding Hystrix is a big tax from runtime & configuration perspective that is not justified with the benefit it provides (i.e. flexibility to change). If at all we need to change Hystrix, we will up a major version of ribbon and move on. It will not be an easy decision to move away from Hystrix inside Netflix anyways.\n. RxClient defines  a name, can we use that to get a unique name for the template/request instead of having it define it's own name?\n. > > > I believe that the most common use cases can be handled by withFallback & withFallbackDeterminator and that by not having a single method doing both, that the road to adoption will be easier and less error prone. Remember we are asking service owners to write these clients and they are not well versed in RX. Making them learn RX puts an overturned big rig on our road to adoption.\nI do not agree that providing this helper method will make the path to adoption of ribbon easier or less error prone. I do not think it's a mainstream usecase either. \nThe provided ResponseTransformer (we are going to change it to the original proposal of onNetworkResponse(Func1<HttpClientResponse<T>, HttpClientResponse<T>> func) instead of the ResponseTransformer interface)  has nothing to do with Rx, it takes an HttpClientResponse and returns HttpClientResponse with optional modification.\nThe approach of onNetworkResponse is generic enough to handle all these usecases. On the other hand, providing these methods:\njava\n class FallbackDeterminatorBuilder() {\n       .withSuccessHttpStatus(int... httpStatusCodes)\n       .withErrorHttpStatus(int... httpStatusCodes);\n// or\n       .withNonFallbackHttpStatus(int... httpStatusCodes);\n// take your pick\n   }\naddresses specific use cases that we now think are reasonable. Anything out of these cases will require a different function. eg: I can not do a check based on a range of error codes (> 200, 400-500, etc.)\n. > > > By combining the two disparate actions into one method it makes it very difficult to separate the two concerns.\nThe two concerns of when to provide fallback and the fallback itself are expressed as:\n- onNetworkResponse()\n- withFallbackProvider() (@allenxwang I think we are changing the name to withFallback() ?)\n. > > > Should transforming of the response be permitted or not? It looks like it may be problematic.\nI think response transformation belong to the transport layer. Once it comes to the ribbon API layer, there should not be any transport response change done (atleast not evidently from the API). So in this case, instead of Func1 we should use Action1\n. > > > Renamed ResponseTransformer to ResponseValidator which extends Action1 and withResponseValidator(ResponseValidator). I feel onResponse sounds like reactive, but in the case of template building, we want user to actively set this piece.\nResponseValidator does not do justice to the intention. Its not validating, its asserting whether response is a success or not.\nI would like to stick to onResponse(Action1) API rather than a first class interface for ResponseValidator.\n. Hoping that ribbon-client-extensions will be called ribbon-api finally?\n. I think we should look at making the HttpRequestTemplate as well as HttpResourceGroup thread-safe as it is easy to accidentally use it in a multi-threaded scenario.\nOne way of implementing immutability can be that you provide an explicit finish() method in the HttpRequestTemplate after which any write will create a new HttpRequestTemplate instance and return. This will not have runtime side-effects (exceptions) based on which path you create a HttpRequestTemplate instance but has an object allocation overhead if there is a mutation post finish()\nThe following sample elaborates the above:\njava\n        Ribbon.createHttpResourceGroup(\"mygrp\")\n              .newRequestTemplate(\"mytemp\")\n              .withHeader(\"Blah\", \"blah\") // Updates the current template\n              .finish() // creates a new immutable instance (copy) \n              .withHeader(\"blah1\", \"blah\"); // Every update creates a new immutable template instance\n. @OskarKjellin that will happen if the response does not have any content. \nRxNetty (used by ribbon underneath) does not pass through empty ByteBuf to the caller. This specific issue is discussed in this PR: https://github.com/ReactiveX/RxNetty/pull/238\nTill the time we fix that issue: you can use lastOrDefault() instead of last() to work around this issue.\n. @OskarKjellin \n\n\n\nDoes that sound right?\n\n\n\nYes thats correct.\n\n\n\nAt what point will the default value be invoked? How can we be sure that the only case this happens if a response has been indeed been returned but the bytebuf was empty?\n\n\n\nSo the contract of lastOrDefault is that it will wait for the last message on the observable (i.e. the onNext before either onComplete or onError are triggered). If the source did not have any item (no call to onNext ) then it will first send the default value and then send the complete/error event. The contract is described here:\nhttps://github.com/ReactiveX/RxJava/wiki/Blocking-Observable-Operators#single-and-singleordefault\n\n\n\nSeems like we're getting false defaults...\n\n\n\nCan you explain more as to when are you getting false defaults? \n@meenal5254 single() has the same behavior as last() with respect to empty streams so you would also have to use singleOrDefault() instead.\n. @meenal5254 @OskarKjellin can both of you provide reproducible tests/code that is showing this behavior. Its tough to debug without that.\n. @OskarKjellin nope did not have time to try this out. Lemme get back to you on this in a day or two.\n. @OskarKjellin I haven't yet been able to find the root cause but I could reproduce this with a simpler code:\n``` java\npublic class TestClientAndServer {\npublic static final Observable<ByteBuf> RESULT = RxNetty.<ByteBuf, ByteBuf>newHttpClientBuilder(\"localhost\", 8080)\n        .enableWireLogging(LogLevel.ERROR)\n        .withMaxConnections(1).build()\n        .submit(HttpClientRequest.createGet(\"/\"))\n        .flatMap(\n                new Func1<HttpClientResponse<ByteBuf>, Observable<? extends ByteBuf>>() {\n                    @Override\n                    public Observable<? extends ByteBuf> call(HttpClientResponse<ByteBuf> response) {\n                        return response.getContent();\n                    }\n                });\n\npublic static void main(String[] args) {\n    HttpServer<ByteBuf, ByteBuf> server = RxNetty.createHttpServer(8080, new RequestHandler<ByteBuf, ByteBuf>() {\n                                                                       @Override\n                                                                       public Observable<Void> handle(final HttpServerRequest<ByteBuf> request, final HttpServerResponse<ByteBuf> response) {\n                                                                           return response.writeStringAndFlush(\"true\");\n                                                                       }\n                                                                   }\n    );\n    server.start();\n\n    while (true) {\n        createUser();\n    }\n}\n\nprivate static ByteBuf createUser() {\n    ByteBuf toReturn = RESULT.toBlocking().singleOrDefault(null);\n    if (null != toReturn) {\n        return toReturn;\n    } else {\n        throw new IllegalStateException(\"No content received.\");\n    }\n}\n\n}\n```\nI will spend some more time on it to find the cause, however it does not seem to happen with the latest code (scheduled to be released with rxnetty 0.3.15)\n. @OskarKjellin I believe the real reason for this issue is: https://github.com/ReactiveX/RxNetty/issues/272 which is fixed in the rx-netty-0.3.18\n. @sumanjupudi I did not quiet understand your question completely, can you show us some code to elaborate your situation?\nIf you are trying to use ribbon module with zuul, it probably is a wrong abstraction as that module is specifically for cases when the target service contract is well defined so that you can create request templates. You will be better off, using ribbon-transport module instead.\n. Looks similar to this bug in RxNetty:\nhttps://github.com/ReactiveX/RxNetty/pull/342\n. @tbak we should allow adding the same header multiple times. Netty's header implementation allows adding the same header multiple times, so if you make this a multi-map and use request.withHeader() multiple times on RxNetty's ClientRequest, you will achieve the desired (spec compliant) result.\n. Since this is an annotation and the other simple class (I assume) the qualification would not be necessary?\n. Does this mean flipping from eureka 2 to eureka 1 & vice-versa requires reboot of an application?\n. Is there a timeout for this wait or it waits forever?\n. I think from eureka point of view it should be configurable (passed as an argument to this method) , whether we make it configurable from ribbon or not, it is up to you.\n. Cool :+1: \nDoes ribbon overwrites the new list of servers? How would getInitialListOfServers() from eureka1 and getUpdatedListOfServers() from eureka2 work?\n. Nitpicking: Is this \"prefer\" or \"use\"?\n. Is there a need to shutdown the existing client, if present?\n. Shutdown the new reader if CAS failed?\n. Are any of these configs dynamically changeable? Looks like we load it once.\n. I think it is not at all intuitive if the timeout is configured via property inside ServerListReader and more so it is global value then for all awaits.\n. ok\n. ",
    "mushkoor": "In order to verify if it is a server configuration issue, I just replaced ribbon-client with jersey-client to invoke GET on URL \"http://localhost:8080/resources/abc%2Fxyz\" without any change at server.\nWith jersey-client, I am able to get correct answer from server (server gets a hit on http://localhost:8080/resources/abc%2Fxyz)\nBut with ribbon-client, I am not able to get correct answer from server (server gets a hit on http://localhost:8080/resources/abc%252Fxyz).\nHence, this issue is not in server configuration.\nThis issue seems to be in reassembly. During reassembly, the URI class is encoding urlPath again for '%'.\nPlease take a look at javadocs:\nhttp://download.java.net/jdk7/archive/b123/docs/api/java/net/URI.html#URI(java.lang.String, java.lang.String, java.lang.String, int, java.lang.String, java.lang.String, java.lang.String)\n. The purpose of URI reassembly should be just to replace host name and port (for load balancing or switch over). Other part of the URI should not be changed.\nThis particular behavior will cause special handling at servers and clients.\nI think this behavior should be fixed in ribbon client. The ribbon-client should just replace host name and port in provided URI.\nPlease let me know if it makes sense.\n. ",
    "WywTed": "how to change loadbalancer rule for a provider at run-time  with ribbon.. ",
    "amit-git": "ribbon-eureka jar pulls in eureka-client jar which seems to be the root cause in this issue. There was a change made in eureka-client jar that removed jersey-bundle dependency and replaced it with jersey-client dependency. As a result when you explicitly include new version of ribbon-eureka (which pulls in latest eureka-client) you don't see jersey-bundle in the classpath which could explain CNF exception. Now the question is the class 'com.sun.jersey.spi.container.servlet.ServletContainer' which used to be part of jersey-bundle jar is no longer getting included in a combination of jersey-core, jersey-client, jersey-server jars. Investigating further.\n. https://github.com/Netflix/pytheas/pull/12\n. ",
    "Serneum": "@allenxwang \nI'm using Ribbon 0.3.5 right now. I'll download the latest and give it a spin. I'll report back with my findings within the next day or so\n. I did some testing with Ribbon 0.3.11 and the issues seem to have gone away. I'm checking with another developer to see if it works for him as well, but it does seem like this issue was just from using a really old version of the library.\n. ",
    "lukasT": "Can somebody give me an update on the status of this? \nOr is there another solution, that I just didn't find? \n. @timmc thanks for the update. Could you tell me to what solution you moved on? I have been thinking of investigating a bit more on that failing tests for the pull-request but if there isn't anyone that would actually do the merge in the end, this seems useless. I really need this PATCH-method :(\n. ",
    "mattnelson": "@qiangdavidliu  @twicksell\nCould we get this PR merged as well? Since verb is an enum there is no way to extend it to add the additional verb.\nI know I'm bouncing a really old issue, but PATCH will be officially supported with JAX-RS 2.1.\nhttps://github.com/jax-rs/api/blob/2.1-m09/jaxrs-api/src/main/java/javax/ws/rs/PATCH.java. @twicksell @elandau @qiangdavidliu @tcellucci\nAny updates? These changes are isolated to ribbon-httpclient which is listed[1] as one of the modules still used at scale within Netflix.\n[1] https://github.com/Netflix/ribbon#project-status-on-maintenance. Bumping again as there has been some recent activity on this project.\n@twicksell @kerumai @qiangdavidliu Could this be merged?. @drtechniko Since ribbon was placed into maintenance mode[1] it doesn't look like any new PRs have been accepted[2]. What process should be followed?\n\nHowever, if someone were to do work on their own and submit complete pull requests, we\u2019d be happy to review and accept.\n\n[1] https://github.com/Netflix/ribbon#project-status-on-maintenance\n[2] https://github.com/Netflix/ribbon/pulls?utf8=%E2%9C%93&q=is%3Apr%20merged%3A%3E2016-04-12\n. I wasn't envisioning a change that intrusive, just some additional metadata about the Server that a custom load balancer could use when making routing decisions or a health check to report the staleness of the data. My original thought was that the server/client would make the decision of staleness, but it does seem like the load balancing scheme should be responsible for that.\nThe reason this is important is when migrating legacy services behind ribbon clients. The old way of doing load balancing was server side load balancing which is counter to the goal of ribbon's client side load balancing. Until those services are refactored to use eureka for client side load balancing the server's alive status is unlikely to ever be dead. This does not mean that the ping should be skipped, just that a much longer interval is acceptable. Because of this much larger interval the staleness of the alive status starts to becomes a factor.\n. I would guess this is unlikely to be addressed based on the current status\nThe eureka blocker has been addressed with 1.6.0. The only ribbon change would be to create a jersey2 version of AbstractLoadBalancerAwareClient. Not sure what caused the failure, looks like it might be a transient error.\n. @elandau @qiangdavidliu with the recent internal Netflix activity on #310. I would like to ride that wave and get #275 and #298 merged before you cut the next release.\n. @twicksell @elandau @qiangdavidliu @tcellucci \nCan I get a general idea of where you stand on this PR? The changes are isolated to ribbon-loadbalancer which is listed[1] as one of the modules still used at scale within Netflix. I want to know if I should just give you some time or if I should move on.\n[1] https://github.com/Netflix/ribbon#project-status-on-maintenance. Is this only a problem if ribbon is on the module path?. Addressed on 6646ac8. Change \"PATCH\" to verb.verb() to avoid the duplicate magic string.. It would be cleaner to change the above call from getAllServers to getReachableServers. ",
    "qiangdavidliu": "@mattnelson thanks for the ping, we'll take a look .... @mattnelson we are averse to merging this in without a proper unit test. Do you want to add a test to this change? Thanks.. #276 contains an alternate impl that's probably cleaner.\n. Closed in favour of #276\n. @mattnelson I agree that this is the right thing to do here, however changing the current default (right or wrong) may have impact on other systems that already assume the existing defaults.\nI see that a work around is mentioned in #254 so that may have to do for now.\n. @mattnelson we'll take a look\n. Hi. To give an update on this, our grpc specific interceptors are still internal at the moment. However, integration with current OSS eureka as a grpc NameResolver can be relatively straight forward and it looks like there has already been some provided by the community. For example,\n- https://github.com/LogNet/grpc-spring-boot-starter\n- https://github.com/ExampleDriven/grpc-eureka-java\n(Please note that these are not what we use internally so please evaluate with your own needs in mind).. @lowzj this seems like an oversight that you are fixing, however I am not familiar enough with logic here to be able to say whether this change may impact any existing assumed behaviour (whether the existing assumption is right or wrong).\nRibbon is currently in maintenance mode for us, which means that we may make changes/fixes that affect our internal usage, and also may be able to take a look at small, obvious PR requests from external contributors. However changes that can affect the existing \"status quo\" are something we want to avoid if possible.\nI will try to point this PR to someone who remembers this code a bit better to see if they have any insight, but please remember, maintenance means we\u2019re trying to change this project as little as possible.\n. Thanks @sghill \n. release 2.2.4 is out with this fix.. Thanks for the contrib @mattnelson . @lowzj @tiny-dancer we'll look into making a release in the next few days. Thanks.. @spencergibb. Yeah, unfortunately due to some decisions from a long time ago :(.\nThis PR is still probationary, no need to merge it in now. At some point in the future we'd like to bump the ribbon dependencies to be more inline with what we actually use.\nIf you guys have a preference, we can do this later.. No worries. If/when the java8 does happen, it will absolutely be 2.3.x.. Thanks @rk13 .. Thanks @tingliu9 and @Aloren . Going to close this one in favour of #365.. @Aloren thanks for the PR, that looks reasonable. One minor nit but otherwise LGTM.. Thanks again @Aloren . Looks great. Thanks.. This method is the same code as what's in DiscoveryEnabledNIWSServerList. Can we consolidate commonalities in both into a base abstract class?\n. Do we need to ensure thread safety for this method?\n. Please use @ deprecated javadoc here\n. In the LB impls (both this and the Base version), if we are deprecating getServerList(boolean), it would be preferable to move the code logic into getReachableServer() and getAllServers(), and defer getServerList(boolean) to call either getReachableServers or getAllServers based on the boolean.\n. formatting seems messed up here?\n. sure\n. this eventually call updateAllServerList which is already busy guarded.\n. That'll have to be a separate discussion.\n. The lastUpdated compared against uses millis, and is also used in an older class and published as a metric. For backwards compatibility, this'll have to be millis also.\n. It should, fixing.\n. You can shutdown the shared executorService (ThreadPoolExecutor) multiple times.\n. The default provider provides a singleton but good point on that the Provider interface does not require this. Changed to wrap the provider with an internal singleton version.\n. Just took this from the existing ZoneAwareLoadBalancer, not sure what you mean? It was pretty much impossible to refactor so that I can use the existing ZoneAwareLoadBalancer which is why some code is duplicated.\n. Just took this from the existing ZoneAwareLoadBalancer. It was pretty much impossible to refactor so that I can use the existing ZoneAwareLoadBalancer which is why some code is duplicated.\n. Indeed, don't know why I didn't catch on to that.\n. The original usage was lazy, so I'm using a provider instead of direct injection to keep the old behaviour in case there's subtle reasons that's needed.\n. It can, but it's easier to be more explicit to be clear on the action taken.\n. sure\n. done\n. it can get set in a few different places.\n. sure, changed\n. Just a heads up that this is java8 only, so if we want to maintain older JDK compatibility, we may want to use the old syntax.\n. nit, weird spacing?\n. Minor nit, can you also update the other constructor to call this(null, host, port)?. Hi, the potential busy spin here is a little concerning. What about something like\nint current = Math.abs(nextIndex.incrementAndGet());\nreturn current % modulo;. Fair point, that would indeed be an issue.. Minor nit, please use individual imports instead of * imports, especially for Java.util.. We should improve the API, but for now, can you change from the deprecated DiscoveryClient.getZone to the following?\nFirst, get hold of EurekaClient (there is already an instance), then\nEurekaClientConfig clientConfig = eurekaClient.getEurekaClientConfig();\nString[] availZones = clientConfig.getAvailabilityZones(clientConfig.getRegion());\nString instanceZone = InstanceInfo.getZone(availZones, myInstanceInfo);\nserver.setZone(instanceZone);\n. nit: this is package private so 'should' be safe to do, but just in case since Ribbon is such an old library, can you do an additional overload method to be compatible? Thanks.\nvoid initWithConfig(IClientConfig clientConfig, IRule rule, IPing ping) {\n    initWithConfig(IClientConfig clientConfig, IRule rule, IPing ping, createLoadBalancerStatsFromConfig(config));\n}. instead of throwing a RuntimeException, it may be more compatible if we fallback to emitting a WARN log and create the stats class with the existing new LoadBalancerStats(clientName).. Hmm, looks like ribbon still depends on a really ancient version of eureka, that method was added to the interface from 1.6.0 onwards. Do you mind also updating the eureka dependency to 1.7.2? (1.7.2 is the current latest Java7 compatible version). Thanks.. should this be wrapped in a lazy loader?. might be worth updating the eureka dependency to eureka-client-archaius2 as well.. please specify the alternative in javadoc. Please javadoc the alternative.. Did you mean to return the parent type here or the implementation type?. Is this done? (mentioned in the PR description).. Is the default a null obj or should there be an NoOp version that can be referenced?. ",
    "dmuino": "It makes sense. I'm just iterating over the header multimap and calling header() in my current implementation, so this is not a problem.\n. ",
    "khawes": "Building on Ben's comments regarding:\nRegarding\njava\npublic RibbonRequest<HystrixResponse<T>> withHystrixInfo();\nbecoming \njava\npublic RibbonRequest<RibbonResponse<T>> withMetadata();\nI Agree and believe it would be best not to name Hystrix by name at this API level.  Just as we don't expose Netty vs.  another transport, lets not expose Hystrix vs. another (as yet undefined) resiliency mechanism.\n. Please don't loose the ability to create templates based on templates that is in the original  RibbonResource prototype that I wrote. it is extremely useful when you get down to creating actual thin clients on top of this.\n. Here's some sample code for being able to define a template using another template.  Note the ResourceTemplateSettings differs from the ResourceTemplate class in that it has no generic return classes so that it can be reused in many templates:\n``` java\n   private final RESTClient restClient;\nprivate static final ResourceTemplateSettings defaults = new ResourceTemplateSettings()\n        .withClientVersion(DMSClient.class)\n        .withRESTClientName(NIWSClientName)\n        .withErrorClass(RESTResult.class);\n\n\nprivate static final ResourceTemplate<RendezvousEntity> POST_RendezvousStart =\n        new ResourceTemplate<RendezvousEntity>(RendezvousEntity.class,\n                                               RestClient.Verb.POST,\n                                              \"/rendezvous\",\n                                               defaults)\n                .withSuccessHttpStatus(HttpStatus.SC_CREATED)\n                .withErrorHttpStatus(HttpStatus.SC_CONFLICT,\n                                     HttpStatus.SC_UNAUTHORIZED);\n\n```\nand later it's called like this:\njava\n    public Resource.Builder<RendezvousEntity> rendezvousStart(String esn) {\n        RendezvousEntity entity = new RendezvousEntity();\n        entity.esn = esn;\n        entity.state = DeviceEntity.State.Init;\n        return POST_RendezvousStart.resourceBuilder().withEntity(entity);\n    }\n. Success will cause the return of the RendezvousEntity.class in this\nexample, error is the RESTResult.class (again in this example) and other\nHTTP codes would result in fallback handling.  We've change how we specify\nwhen to fallback.  This is not an example of that but an example of the use\nfor nesting templates.\n-- Keith\n\nDon\u2019t listen to me, I play with Christmas lights\nhttp://www.christmasoutloud.com/ all year long.\nOn Thu, Jun 12, 2014 at 10:52 AM, Ben Christensen notifications@github.com\nwrote:\n\nWhat does \"success status\" and \"error status\" end up causing to occur?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/Netflix/ribbon/issues/99#issuecomment-45925275.\n. It does not.  We evolved into that function.  Fon't focus on the details of the example but on the use case for defining one template using another template, which contains a set of defaults for the overall client that would be tedious and error prone to copt into every resource template in your client. \n. I made a copy of the builder in the containing object and passed the get methods down to the default if there were no existing values (e.g. null).  For headers they were merged on build.  I don't recall my reasoning as it's been a few years now since I wrote it. \n. Yes\n@khawes https://github.com/khawes If I understand correctly, you are\nfine with the approach of providing a copy() method on the template to\nsupport the usecase you were mentioning.\n. > Probably something like that as I doubt we can afford the object\nallocation overhead of making the builder immutable. If we could do it as\nan immutable builder (like Rx sequences) then you can take any Template at\nany point and just embed inside something else without worrying about\nmutation.\nYeah it would be good to have the template thread-safe (by immutability)\nbut the cost would be large as it means every mutation copies the template.\nI think we can just say that the template is not threadsafe from the point\nof view of mutations to the template, however each\ntemplate.requestBuilder() call creates a new RequestBuilder and this\nmethod specifically is safe to be called concurrently.\nThis model will aid people to create a shared RequestTemplate instance\nwhich can be used across threads to create new RequestBuilder and hence\nRibbonRequest instances\n\nTemplates are meant to be static and created at initialization time, after\nthat you use the requestBuilder call to get a thread safes copy that can\nthen be used to make your remote call by adding in the values to fill out\nyour template, and initiating the remote call.\n. >  Templates are meant to be static and created at initialization time,\n\nafter\nthat you use the requestBuilder call to get a thread safes copy that can\nthen be used to make your remote call by adding in the values to fill out\nyour template, and initiating the remote call.\nOk so I understand that you support the proposed design.\nYes, with one caveat: I still don't think it's a good Idea to expose\nHystrix.  It really should be an implementation detail that is hidden from\nthe users of Ribbon Client. Even if all you do is build an interface to\nreplace HystrixObservableCommand in FallbackHandler and have hystrix\nimplement it. As much as we think Hystrix is a great thing there are\nEngineers who really don't like it and will resist anything that makes them\n\"Learn / Use Hystrix\", and if we expose it, it will be come a barrier to\nacceptance.   Don't make the user think about Hystrix vs. the connection,\nFor example: the user should be thinking in terms of a single overarching\ntime-out, not socket level connect, read, and hystrix time-outs and ribbon\nclient should handle the rest.\n. Both\n\nAlso, since the intention is to allow multiple cache provider, will\n\nwithCacheProvider() gives people impression that it will override the\nprevious withCacheProvider()? Would addCacheProvider() sound better?\nThere may be times I want to keep the existing ones and times I want to\noverwrite.   Or better yet:  clearCacheProviders() and addCacheProvider()\n. I still don't think it's a good Idea to expose Hystrix. It really should be\nan implementation detail that is hidden from the users of Ribbon Client.\nI disagree. They need to be aware since they are going to be looking at\nall the metrics and managing all the properties. It is far better to be\ntransparent rather than opaque.\nUnless we are planning on hiding all properties, metrics, dashboards and\nother such system that are about Hystrix, we should not try and hide\nHystrix underneath Ribbon.\nMetrics, and dashboards, are a requirement of ANY resilience/reliability\nimplementation, of which the best we have found is Hystrix, but that does\nnot mean that it is the only implementation we will ever use.    Speaking\nof metrics and dashboards: Tricorder provides server side metrics and\ndashboards for any Jersey based server, yet you don't need to know how it\nworks you only need to list its package in your jersey configuration.\n Tricorder could be replaced by another product/project and with a\ndependancey and startup config change the replacement would be up and\nrunning -- no major code changes.\n\nThink back to those first meetings we had where there was considerable\ndiscussion of having a configuration that would get interpreted and used to\ncreate/influence the configuration for NiwsRestClient and Hystrix because\nthe interaction between the two is complex and people often get it wrong.\nThere have been many great arguments on why we should NOT to expose NETT,\nand most came from you Ben.  Every time NETTY was exposed in Robbon there\nwas a long discussion as to why it should not be exposed.   Those very same\narguments apply to why we should not expose Hystrix.   Let's not put\nourselves in a position for major code chafes if/when a replacement emerges\nin the OSS ecosystem.\nHystix is close to us because we wrote it, and I think we are allowing that\nrelationship to clouding our judgement.   Please ask yourselves: \"If\nHystrix were written by Apache, LinkedIn, Google, etc. would we be treating\nit as an implementation detail of ribbon client as we are doing with NETTY\nor not?\"   For me that answer is a resounding YES.\nIt's not going to be easy,  it took almost a year to not surface NETTY, buy\nwe did it and ribbon client is simpler to use because of it.\n. I'll buy the configuration argument.    I don't however think you need to wrap hystrix to push it down a layer.  Regardless if Hystrix is exposed or not it handles Metrics, and circuit breakers with out any intervention outside of configuration.  This leaves fallback requiring exposure.  There are two parts to falling back: How and When.  The FallbackHandler handles the How, and FallbackDeterminator handles the When.   Hystrix should be flexible enough to delegate to those, with out exposing it's own internal workings, if not lets fix it.\n. We could/should add an HystrixFallbackHandler and an HystrixFallbackDeterminator to the Hystrix code base that would allow straightforward plugging in of an existing Hystrix command. for those that have already embraced them.\n. @benjchristensen so we add a withHystrixCommand to the ribbonClient API and one could choose the withHystrixCommad(...) route or the withFallBack*() route?\n. @benjchristensen RE: FallbackDeterminator.  I'm up for that, as log as we have an Exception to inherit from that tells us we need to NOT fall back -- we can lump all other exceptions into the fallback bucket.\n. @benjchristensen I think that is what you are saying.  re your I don't know... comment.\n. The exception should be clear though:   RobbonUnexpectedResultNoFallbackException  :)\n. @benjchristensen   YEA!  I think we are on the same page, or almost.   There were some example where Hystrix was part of the parameters, do those still apply?\n. I did not see name related API in RxClient interface.\n\nI think the client name, if it has, is better to be used as the command\ngroup name. A template name is more like one method name of a service\ncontract, whereas the client is responsible to execute all methods in the\ncontract.\nI agree, Client Name -> group name, and withName will provide a name for\nthis endpoint/command.  If not specified we can make one at build time\nusing the verb and template.  e.g \"GET_/dms/v2/device/{esn}\"  Substituting\nout any invalid characters.   If I choose to use withName I can even make\nthe name match the Tricorder metric name on the server side for easy\nmatching of client & service side metrics .\n. > The only parts I'm aware of Hystrix being exposed are:\n1) Optionally if asking for withMetadata there would be a getHystrixInfo\noption that returns HystrixExecutableInfo to get access to the many\npieces of runtime results.\nThis is shown here: #99 (comment)\nhttps://github.com/Netflix/ribbon/issues/99#issuecomment-45827312\n\nThis use case works for me.\n\n2) The fallback handler needs to be given the HystrixExecutableInfo to\nhandle various use cases where the fallback behaves differently depending\non the scenario (short-circuit, error, etc).\nThis is shown here: #99 (comment)\nhttps://github.com/Netflix/ribbon/issues/99#issuecomment-45826885\nFor example:\n// I'm explicitly including the types in the lambdas for clarity, but real code wouldn't need themRibbon.from(httpClient)\n        .newRequestTemplate()\n        .onNetworkResponse((HttpClientResponse response) -> {\n```\n         if(response.getStatus().code() >= 500) {\n           throw MyCustomException(\"message here\");\n          } else {\n           return response; // pass-thru (but could decorate or modify if wanted)\n          }\n     })\n .withFallback((HystrixExecutableInfo info) -> {\n    if(info.isResponseShortCircuited()) {\n        return specialFallback;\n    } else {\n        if(info.getFailedExecutionException() instanceOf SomeThingImLookingFor) {\n            return fallback1;\n        } else {\n            return fallback2;\n        }\n    }\n })\n\n```\nCan  HystrixExecutableInfo implement an interface say\nRibbonExecutionResults and we have withFallBack accept the interface\ninstead?\n. Can't we replace:\n\nRequestTemplate<I, O, R>\nwithHystrixCommandPropertiesDefaults(HystrixCommandProperties.Setter\nsetter);\nRequestTemplate<I, O, R>\nwithHystrixThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter\nsetter);\nRequestTemplate<I, O, R>\nwithHystrixCollapserPropertiesDefaults(HystrixCollapserProperties.Setter\nsetter);\nwith a\nwithProperties(Properties props)\nand extend those three Hystrix property builders to give back a\nproperty map?  This method could/would accept additional properties\nfor tweaking Hystrix, Netty, NFCache etc.\n. withFallbackDeterminator vs withResponseTransformer.    With this switch in naming convention we conceptually move from determining how to fall back, to transforming the response.   The former seems easy,  the latter seems daunting,  just from a naming perspective.    Can we add back FallbackDeterminator, and define it to throw a class of exceptions that will trigger a call to fall back handler (and let's hand the exception to the handler too)   If you think we want to be able to transform the response, by all means keep withResponceTransfromer, but just because it can do the job of a FallbackDeterminator let's not conflate them. \nK.I.S.S.\n. @benjchristensen I agreeFallbackDerterminator should throw an exception to indicate fallback, the FallbackHander can and should use the exception to determine how to fallback.  \nI'm saying we should NOT change the name/semantics to ResponseTransformer \n. Question:\nThere are three outcomes when we finally call get() to get the resulting object:\n1. Success -- expected object is returned\n2. Failure -- timeout/5xx -- fallback should be triggered \n3. Error -- expected object is not returned eg 404, on a login\n1 & 2 are well defined, but I can't seem to glean how are we handling the third state.  How does case 3 work?\n. I'm going to ignore the ResponseTransformer conflation of FallbackDeterminator & FallbackHandler, because it is not relevant to my question. \nAnd extrapolate the answer:\n1. The object\n2. The Object -- with fallback data\n3. null/empty\nSo how do we determine why I got a null/empty result?\n. Let me add context to the question that I though was obvious but apparently is not. \nFrom a user of my client library, who eventually calls get() to get the object he/she is expecting from the service being called.\nWhat do they see for outcome #3 (non fall back error e.g. 404)?\nHow do they differentiate a success from a non-fallback failure?  e.g.  the login situation where a bad password does not result in a customer object.\n. that's what I was missing, and is also missing from your example above. \nNow back to our regularly scheduled debate: withFallback & withFallbackDeterminator vs withResponseTransformer:  \nI believe that the most common use cases can be handled by withFallback & withFallbackDeterminator and that by not having a single method doing both, that the road to adoption will be easier and less error prone.    Remember we are asking service owners to write these clients and they are not well versed in RX.  Making them learn RX puts an overturned big rig on our road to adoption.\nWe can even have an HTTP FallbackDeterminatorBuilder that we can use:\njava\n   class FallbackDeterminatorBuilder() {\n       .withSuccessHttpStatus(int... httpStatusCodes)\n       .withErrorHttpStatus(int... httpStatusCodes);\n// or\n       .withNonFallbackHttpStatus(int... httpStatusCodes);\n// take your pick\n   }\nwhich makes it even easier for adoption.\n. @NiteshKant one can absolutely do range of error codes with the FallbackDeterminator approach.  I showed one (and only one) possible implementation of it.\nIf I'm looking at using RibbonClient for the first time How do I know that fallback logic goes in some object that needs to implement onNetworkResponse(...)?    It's not intuitive., therefore I may not correctly implement fallback logic.  \nRibbonClient should be simple and easy to use for most use cased yet be able to handle the more advanced cases by dropping down a layer. If you conflate these two layers you end up with a high barrier to entry, and teams writing the high level layer over and over, and we loose best practices again.  \n. Fundamentally, as a client writer I must always specify when to fallback.  However as a client writer I cannot always specify how to fallback.\nHere are two examples:\n- A/B:  can specify when and how to fallback because fallback uses the test metadata for falling back.\n- DMS: can specify when to fall back but cannot specify how, because It is called by apps that have cookies, c-tickets and/or MSL data on which to fallback.  \nBy combining the two disparate actions into one method it makes it very difficult to separate the two concerns.  Those that cannot provide code for fallback will end up not providing for fallback, and users will not only have to provide fallback but also define when.  We have this situation today because Hystrix already has this conflated view of falling back, and because of it we wound up with at least 3 separate implementations per DMS end point, and each and every one of them got it wrong on several occasions, and in addition others opted to not implement Hystrix at all.\nWe need to keep determining when to fallback separate form the act of falling back; so that we can have users of the client easily specify fallback actions, while leaving when to fallback to the client writer.\n. > How does the onNetworkResponse have anything to do with defining \"how\" to fallback? It is only about processing a network response and deciding if you want to throw an exception.\n\nThe two use cases you are referring to are handled in two different places.\n\nSo that's not clear at all based on the name of the method onNetworkResponse and these comments, which lead me down the path that the \"right palace\" to replace the fallback response object is in the onNetworkResponse method:\n\nit takes an HttpClientResponse and returns HttpClientResponse with optional modification.\n\nand\n\nThe function is nothing more than a callback to process from HttpClientResponse to either Throwable or T.\n\nand\n\nAll three scenarios are handled by the ResponseTransformer\n1. ResponseTransformer returns the same response\n2. ResponseTransformer throws an exception\n3. ResponseTransformer transforms the response. For example, return a new HttpClientResponse where the the content (Observable) represent empty result\n\nAll of these say I need to to return T (my result object) so it looks like the fallback response object needs to be returned at this point.   There is no contract between onNetworkResponse and FallbackHandler.   FallbackDeterminator had an implicit contract with FallbackHandler. via the naming convention which tells you the relationship, and that the determinator shouldn't be where you are supposed to be messing with T.\nThe result of determining fallback should be either:\n- Don't\n- Do & Why.\nnot one of:\n- Don't\n- Do & Why\n- Don't - yet use this alternate value for the result instead of the real value.  Which is what I'm reading doResponseHandler is supposed to enable. \nIf you walk down this path you will find people handling the fallback internal to doResponseHandler and your metrics will not be counting fallbacks and the circuit breakers won't fire. \nIf you need to have something to mess with  then by all means create a way to do so, but it shouldn't be related to fallback or its confusing. \n. @mikeycohen \n\nFor Keith's use case, I wonder if there is a flag that can be passed to the server to determine success vs failure.\n\nWhich use case are we talking about?\nThere is a face to face on Friday @11:30\n. @mikeycohen Flipping is a great way to explain what I'm trying to get across.   Extending your example to it's logical conclusion we get:\n- In the A/B case there can be a singleton implementation of the fall back handler and A/B can just set it at initialization time, freeing it's users from the burden.\n- DMS uses will still have the burden of creating a fall back handler with the appropriate data for every call. \n. @NiteshKant the name ResponseValidator is closer to the intention of asserting success, failure, or error than the name onResponse is. We're not trying to assert success or failure but success, authoritative error, and failure.  It's the 'authoritative error' that is important. because you don't wan to fall back on these, and yet it is not successful in the sense that the expected result was returned.   Lets try to find a name that mans decide if the call was successful and if not if we should fallback.\nAs for making it a first class interface...  I believe that it needs to be. We want to be encouraging the best practice of specifying when fallback is necessary and The builder pattern is great for calling this out.\n\nAll that aside I think we are diverging from our original intention of having clients built on top of this that are so thin we can almost \"test\" them with our eyeballs.    e.g. code so simple it's hard to introduce non-obvious errors.\nAre we  adding functionality that is useful for a few edge cases? I think we are.  Take a step back an look at NIWSRestClient.  It was very flexible and required a lot of boilerplate be created by client libraries for the common use cases.  So much so that we have rest-client-utils that wraps it to allow all that boilerplate to be pushed down a layer.   The result is straight forward to use and difficult to get wrong.  It is also more restrictive, but that's how it gets it's simplicity.  If you need the flexibility you can always drop down a layer and have at it.   That's a long winded way of saying we need move the edge cases down a layer?\n\nI like to think about the common client from the client library users perspective. And think it should look like this:\njava\nSubscribedObservable<DmsDevice> deviceCall = dmsClient.getCustomerDevice(esn, \n               customerid, \n               new myFallbackhandler(cTicket));\nif fallback must be provided by the user and:\njava\nSubscribedObservable<DmsDevice> deviceCall = dmsClient.getCustomerDevice(esn, customerid);\nif not.\nDon't dump all over the word SubscribedObservable It's only trying to communicate that the remote call behind the Observable is already in progress at this point (e.g. the remote call has started) so that later the user can call:\nDmsDeivce device = device.get();  The point is that the object I get back from my call to a client library is an observable that is already in progress so I can call several client libraries and then start doing the .get()s.  \nOh and don't make me type deviceCall.toBlockingObservable.get() just give me deviceCall..get() and do that extra ensuring the object is ready for consumption bit behind the scenes. The problem with boilerplate (no matter how small) is that right after you copy and past it is that it's out of date.\nIn my head the implementation of ` dmsClient.getCustomerDevice(esn, customerId, myFallbackhandler(cTicket));'  looks something like this:\njava\nSubscribedObservable<DmsDevice> deviceCall(String esn, Long customerId, FallbackHandler fallback) {\n        GetCustomerDeviceRequestTemplate.getResource(\"esn\", esn, \"custId\", customerId)\n        .withResponseValidator(deviceCallValidator)\n        .withFallback(fallbackHandler)\n        .build() // the act of building fires off the remote call (subscribes)\n         }\n}\nDon't make me type .build().subscribe() because at some point I will forget, or it will get deleted by a stray key stoke.  Since Observable is the result of both, and If I leave out .subscribe() It will be an error I won't see unless I test that my call is executing in parallel upon return. which will also get neglected. \ndeviceCallValidator is a singleton dedicated to this endpoint, and since this is a REST call it will look at the http response codes. (As will all REST calls so we can and should provide a builder for these)\nGetCustomerDeviceRequestTemplate defines the rest endpoint and getResource is the fully formed resource that is for this one call, because it now contains data for this one call to the resource. \nFinally, if as a user if I feel I need to get at the builder before it's built I can go talk to the client library owner to have a method exposing the builder, or if the owner sees benefit for all their users it gets built into the client and everybody gets the enhanced functionality.\nEnd of line.\n. withConnIdleEvictTimeMilliSeconds was hard for me to read/parse.   Maybe use:\nwithIdleEvictTimeMilliseconds or withConnectionIdleEvictTimeMilliseconds\nthe latter seems to cause me to infer this is related to making a connection rather than a dealing with a connection pool, so I prefer the former.  Maybe go so far as withConnectionPoolIdleEvictTimeMilliseconds \nPS Milliseconds is one word so no need to camel case the S in seconds. \n. in HttpRequestTemplate and we change withUri to withUriTemplate  since the URI needs to look like this:  \"/v1/dms/Device/{Esn}/{CustomerId}\" and not \"/v1/dms/Device/TIVO-123456756/1234567845\"  the Former is a template and the latter is a URI.\n. ",
    "mikeycohen": "I just spent the last 45 mins catching up on this thread.  I think at this point it may warrant an in person discussion on these points.  I think we may run the risk of adding complexity to this design to offer too much flexibility. Rather than making this design fit more and more complex use cases, maybe we should question the validity of the use case.  Should we ask ourselves if it's easier in terms of the design and reduction of complexity to have the server side absorb some of this complexity? For Keith's use case, I wonder if there is a flag that can be passed to the server to determine success vs failure. In general, I favor less specific methods that allow ease of understanding and use.\nA lot of this task should be narrowing the scope of what is possible for a client to do, and make that simple.\n. Here are two examples:\nA/B: can specify when and how to fallback because fallback uses the test metadata for falling back.\nDMS: can specify when to fall back but cannot specify how, because It is called by apps that have cookies, c-tickets and/or MSL data on which to fallback.\nFor these examples, these are great cases for flipping the logic; \nAB can have the test metadata passed in; for DMS requests, this data can be passed in to the client as well. This simplifies the logic within the client, and makes the caller need to explicitly pass in the appropriate data for the call.\n. ",
    "aspyker": "As discussed I'd like to mock this and create a test for you.  Right now I am trying to decide between doing that for 1.0 or 2.0.  As soon as I get through the 2.0 eval, I'll get back to this.  If this is something you'd want to add yourself that is good too.\n. @allenxwang two questions\n1.  Do you know why cloudbees failed to git merge?\nhttps://netflixoss.ci.cloudbees.com/job/ribbon-pull-requests/165/console\n- Wondering if this is a issue with me working in 1.x (that I branched) vs. 2.x?\n- If so, I could just restart this work on 2.x\n1.  Can you look at the following:\n   https://github.com/aspyker/ribbon/blob/446ab1fb76e247f21c67864fae5f80c9de8e0278/ribbon-eureka/src/main/java/com/netflix/niws/loadbalancer/DiscoveryEnabledNIWSServerList.java#L75\nI haven't learned Archaius enough, but I had hoped that the call to get property \"X\" would work if either \"ribbon.X\" or \"client.ribbon.X\" was used.  From looking at the other property there (line 66), I think it suggest that the layered configuration object isn't passed to this level and I will have to do a first lookup in the \"client.ribbon.X\" and then later look for \"ribbon.X\" to override?\nI also wonder if the problem is how the test cases are instantiating the clientConfig (vs. how the main path in a running app would).  I can't seem to find any other test cases that test \"ribbon.X\" configuration working.\n. To make the merger cleaner on my side, I decided to start over with my clone.  I will submit a second pull request.\n. This should be closed as I started a clean 2.x and 1.x set of pull requests.  This one was becoming difficult as the code was pulled and merge before the Ribbon 2.x and 1.x split.\n. I tried this with my project.  I still see similar behavior.  What specific configuration is needed in the properties?\n. @allenxwang I think your test is only working as you mock out the DiscoveryClient.  I changed yours to instead do the following:\n```\n@Override\nprotected String getVipAddress() {\n    return \"ACMEAIR_AUTH_SERVICE\";\n}\n@Test\npublic void testDynamicServers() {\n    ConfigurationManager.getConfigInstance().setProperty(\"MyService.ribbon.\" + Keys.DeploymentContextBasedVipAddresses, getVipAddress());\n    ConfigurationManager.getConfigInstance().setProperty(\"MyService.ribbon.\" + Keys.NIWSServerListClassName, DiscoveryEnabledNIWSServerList.class.getName());\n    ConfigurationManager.getConfigInstance().setProperty(\"eureka.shouldUseDns\", \"false\");\n    ConfigurationManager.getConfigInstance().setProperty(\"eureka.serviceUrl.default\", \"http://172.17.0.15/eureka/v2/\");\n```\nand in your mock:\npublic void setupMock(){\n//        List instances = getDummyInstanceInfo(\"dummy\", getMockServerList());\n//        PowerMock.mockStatic(DiscoveryManager.class);\n//        PowerMock.mockStatic(DiscoveryClient.class);\n//\n//        DiscoveryClient mockedDiscoveryClient = createMock(DiscoveryClient.class);\n//        DiscoveryManager mockedDiscoveryManager = createMock(DiscoveryManager.class);\n//\n//        expect(DiscoveryClient.getZone((InstanceInfo) EasyMock.anyObject())).andReturn(\"dummyZone\").anyTimes();\n//        expect(DiscoveryManager.getInstance()).andReturn(mockedDiscoveryManager).anyTimes();\n//        expect(mockedDiscoveryManager.getDiscoveryClient()).andReturn(mockedDiscoveryClient).anyTimes();\n//\n//        expect(mockedDiscoveryClient.getInstancesByVipAddress(getVipAddress(), false, null)).andReturn(instances).anyTimes();\n//\n//        replay(DiscoveryManager.class);\n//        replay(DiscoveryClient.class);\n//        replay(mockedDiscoveryManager);\n//        replay(mockedDiscoveryClient);\n    }\nThis is a valid eureka server as well as vipAddress as:\nispyker:~ aspyker$ curl http://172.17.0.15/eureka/v2/apps/ACMEAIR_AUTH_SERVICE\n\nACMEAIR_AUTH_SERVICE\n\nispyker.raleigh.ibm.com\nACMEAIR_AUTH_SERVICE\n9.27.117.176\nUP\n...\nThe problem in tracing my test code and yours with this change to not have a mocked eureka is:\ncom.netflix.niws.loadbalancer.DiscoveryEnabledNIWSServerList:\n```\nprivate List obtainServersViaDiscovery() {\n    List serverList = new ArrayList();\nDiscoveryClient discoveryClient = DiscoveryManager.getInstance()\n        .getDiscoveryClient();\nif (discoveryClient == null) {\n    return new ArrayList<DiscoveryEnabledServer>();\n}\n\n```\nWith your move, the getDiscoveryClient is coming back as non-null due to your mocking.  When eureka isn't mocked, it comes back as null.\nCan you confirm that this code works when you don't mock Eureka?\n. @allenxwang formattting issues with code.  The curl command comes back with XML that shows the instance as up.\n. Ok that was my worry as most of my work before was in Karyon.  Do you know of a way to get Eureka property configured in a non-Karyon environment - or is this a question to ask over in the Eureka projects.  Will move to Karyon immediately instead of J2SE and see what happens.\n. Today I was able to move my client to be a Karyon hosted service which meant that Eureka registration/initialization happened.  After doing this, I do see (with your ribbon cp branch on github) it paying attention to the archiaus properties and a eureka located service worked fine with:\nacmeair-auth-service-client.ribbon.NIWSServerListClassName=com.netflix.niws.loadbalancer.DiscoveryEnabledNIWSServerList\nacmeair-auth-service-client.ribbon.DeploymentContextBasedVipAddresses=ACMEAIR_AUTH_SERVICE\nIt would nice to have a simple Eureka+Ribbon J2SE sample that showed how to initialize Eureka, but for my needs, Karyon server is fine.\nI think when I opened the original issue, the problem was with my sample app (not using Karyon and/or not initializing Eureka in J2SE).  I'm glad you found an issue with Archaius in your investigation, but likely I can't confirm that issue as it al works for me now.\n. Just a note that while I have tested the 1.x stream jars in an end to end application, for 2.x I have no such application, so the only testing I have performed is the unit test provided.\n. @allenxwang have you successfully performed any pull requests against the 1.x branch?\nI see that the Netflix project lists the project as stale and 281 commits behind:\nhttps://github.com/Netflix/ribbon/branches\nI took the Netflix project, cloned it clean, made the changes in master branch and did a pull request for that (2.x):\nhttps://github.com/Netflix/ribbon/pull/162\nI then took my clone and made a branch from the 1.x branch.   It also was 281 commits behind:\nhttps://github.com/aspyker/ribbon/branches\nLocally this builds fine, tests fine, and I even tested the jars in my end to end application and the property worked as expected (both globally and for a specific ribbon client config).\nI haven't yet had to deal with branches and pull requests.  Any guidance of how to get git to catch up would be nice.  I can see that I could pull the Netflix master into my 1.x branch (UseIPAddrForServer1.x), but I don't think i want to do that as that would pull in all of the 2.x/master changes that aren't appropriate (the 281 commits).\nI haven't found any git guides that cover this well enough.\nIf you want to cherry pick the changes from my 1.x branch, they have been locally tested and I believe them to be correct.\n. ok, will try.  canceling this one for now.\n. I will look at this next.  I will note that for IBM's needs (and I'd think many others), but able to set it globally would be the most typical case.\n. @elandau agreed.  in talking with @allenxwang we wanted to be careful of changing the behavior here (orig code only caught Throwable), but if you think it's safe, I'm for it as well.  The fact that it was catching Throwable and the async code change I believe caused the bug I was fixing.\n. ",
    "tbak": "Ok\nOn Wed, Jul 2, 2014 at 3:06 PM, allenxwang notifications@github.com wrote:\n\n@tbak https://github.com/tbak I have merged everything into 2.x branch.\nCan you please resend the pull request to that branch?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/Netflix/ribbon/pull/112#issuecomment-47843381.\n. > Make @TemplateName optional and default is the method name\n\nIt is already implemented (see pull request https://github.com/Netflix/ribbon/pull/128).\n\ninstead of \"uriTemplate\" and \"cacheKeyTemplate\", just say \"uri\" and \"cacheKey\"\n\nI agree that it makes sense to shorten it.\n\n@Provider inside @CacheProviders seems repetitive. Can we remove it?\n\nJava does not support multiple annotations of the same type. To handle the collection we needed @CacheProviders annotation. Otherwise @Provider would be enough. However given that we no longer support multiple cache providers, we can make it more slim now, and leave only @Provider annotation.\n. The build failure was caused by DNS resolution problem in one test.\n. Agree. I will rename also the package name to \"proxy\".\n. It would be best, but we have ResourceGroup class as well. It will be ambiguous and will require using full name for one or the other, if the two are to be referenced in the same file.\n. According to the HTTP spec:\n\"Multiple message-header fields with the same field-name MAY be present in a message if and only if the entire field-value for that header field is defined as a comma-separated list [i.e., #(values)]. It MUST be possible to combine the multiple header fields into one \"field-name: field-value\" pair, without changing the semantics of the message, by appending each subsequent field-value to the first, each separated by a comma. The order in which header fields with the same field-name are received is therefore significant to the interpretation of the combined field value, and thus a proxy MUST NOT change the order of these field values when a message is forwarded.\"\nSo I would say by default we shall ignore or not allow it. Right now in the code the last entry wins (overrides the earlier). We could alternatively detect it and throw an exception.\nQuestion is if we shall provide a dedicated mechanism to pass multiple headers with the same name. The HTTP spec states that it should be equivalent to merging all of them with comma as a separator, and so  Ribbon user can just do that and put all the values into one header annotation directly. Since having support for multiple headers is more a syntactic sugar than a new feature, I would stay with current implementation.\n. Agree. I will fix it.\n. Yes, otherwise it will fail with NullPointerException in MethodTemplateExecutor class.\n. Ok, I will add support for that.\n. Yes, Observable.from creates an observable from a future, that handles properly errors as well.\n. Ok, I have changed it accordingly.\n. Can we do this without injecting such long delay into the test? 10-100ms might be acceptable.\n. This code runs in Rx thread, so the assignment to fromCommand[0] is not properly published to the main thread. AtomicReference can be used to fix that.\n. Can we shorten or eliminate this timeout?\n. OK\n. During our discussion we agreed that we will use hystrixCacheKey as it is now.\n. We need second ReplySubject, so we do not loose the elements before a client's subscriber subscribes. For streaming responses this is however not acceptable, as we will be accumulating data in the ReplySubject indefinitely. I have created issue  #143 for that.\n. toResultCommandPairObservable makes sense only in the context of the command chain. I think we should leave it here.\nI renamed the observables as suggested.\n. Do we need this method? It does not use any object attributes, and is equivalent to calling Ribbon.from directly.\n. Is it the plan to have single RibbonResourceFactory for all possible protocols, or we should have a corresponding class hierarchy like for ResourceGroup class.\n. Similar comment to RibbonResourceFactory. Are we going to have other transport protocols in this class?\n. Having @Inject annotation here forces all ribbon users to depend on the javax.inject.jar. Previously we had all injections isolated to ribbon-guice module. \n. Multiple test classes are copied from ribbon to ribbon-evcache project. We could have instead dependency between test packages, and reuse the test classes across projects.\n. Is connectWithAction part of public API? Why is it needed?\n. RibbonResourceFactory.from method is not very self explanatory in this context. I would change it to something more descriptive, like ribbonProxyFrom(...).\n. There is no need for reboot. For each request a status flag is checked, and the request is dispatched accordingly.\n. Yes, and it is hard coded to 30sec now. If you feel it is better to make it configurable, I will add one more property to cover that.\n. I guess it is up to load balancer implementation, but what is currently there (BaseLoadBalancer) swaps old list with a new one. In any case, the data we get from Eureka1 and Eureka2 should be eventually the same.\n. On a second thought I will make it configurable via property. Some tuning should be possible.\n. \"use\" is better word here. I have renamed it.\n. It depends how we define the contract. Now Eureka2Clients uses injected EurekaInterestClient, but does not own it. In DI environment EurekaInterestClientProvider is managing the full lifecycle (create and destroy). I think it is better as single client can be used in different places.\n. Good catch.\n. This is how we do it in DiscoveryEnabledNIWSServerList. Client configuration change should be handled by creating a new ribbon client, for example If there is a vip change, RestClientManager will create a new RestClient.\n. ServerListReader has a constructor argument for this timeout, and in Ribbon I have introduced a configuration property.\n. This method is thread safe, which comes from thread safety of ServerListReader.\n. Changed\n. Changed\n. Yes, it is correct. We want to set it to null, only if current object is there. As this method may be run concurrently, another thread may initialize new serverListReader at the same time.\n. ",
    "esigma5": "Hi. Are there any news about this implementation?\n. Hi there. Any news about this? It's crazy yo have to add all of the ribbon dependencies manually to our pom.\n. Hi there. It would also be nice to have a way of use a stub object at the final step of the chain, in order to fake the http calls but register them and be able to query them later. Maybe it would suffice if we could inject a mock object (created with mockito) what would replace the real http calls.\n. Thanks! I'll take a look a it. \n. Hi there, I am having the same problem here. Any updates about a possible fix? @schmitch , did you find a way of fixing the annotation client or just switched to template based client?\nEDIT: I noted that the bug only occurs when using multiple instances of the proxy (i.e.: calling Ribbon.from() for every request). On the other hand, if creating the proxy instance once, the problems ceases to exist (didn't find any documentation about that though)\n. Another way of fixing it is to replace com.netflix.ribbon.Ribbon for a custom MyRibbon class, that creates a new DefaultResourceFactory() foreach from() call, and creating foreach new resourcefactory a new MyAnnotationProcessorsProvider (which could be a copy of DefaultAnnotationProcessorsProvider). That way, multiple instances of the same client could be created without this problem.\nThis is useful for also using this MyRibbon class to provide the possibility of creating proxy instances for custom namespaces.\n. PR was provided: https://github.com/Netflix/ribbon/pull/242\n. Hi there. There's also https://github.com/Netflix/ribbon/issues/239 that I guess is the same. Luckily someone would mark one of them as duplicate and would answer it, but it seems that no one at netflix is currently working on this project right now.\n. Nice! I read they are accepting PRs, so maybe you could create one :)\n. Hi there, we are also using this project as a base for all our microservices' clients, so whenever you have decided what will you do with the project, please let us know as soon as possible.\nPersonally, I think a lighter ribbon version would be the right approach, as many features like http templating/proxing and the integracion with rxnetty, archaius and eureka are enough reasons for ribbon to exist.\n. ",
    "ArekCzarnik": "Any news about Request collapsing?\n. ",
    "willblackie": "No problem... thanks for getting it in so quickly.\n. How does your process work from here? .. when will RC4 be published to bintray/maven?  Is there already a snapshot build out there somewhere that I refer to in my projects until then?\nCheers\n. ",
    "dhawken": "Forked and tried my idea - the handshake did proceed, but the cert authentication between client and server did not.  Will continue that investigation, but in theory, these are the same trust/keystores that were providing successful results with the prior change.\n. Yes, i've traced through this code and it all seems to work fine.  I've tried it with both client auth required (with a trust store) and no client auth (with keystore, truststore and both).   It isn't this code that would be an issue, this code is just in the builder that configures the sslContextFactory while constructing the client.  When a request is submitted, the SSLEngine is retrieved from the sslContextFactory in LoadBalancingHttpClient via DefaultFactories.fromSSLContext.  If the setUseClientMode(true) is indeed required, that would be where that would have to happen.  I guess the question still remains if that's an issue or not of course. However, if I use these attributes in the Iclientconfig and trigger this code, handshake does not happen regardless of the key/trust store supplied.  \nI'll continue looking at our stuff and try to determine if there's an issue with any protocol/cipher diffs between the client and the server, but as I said, using the RxNetty client with an SSLEngineFactory supplied OR supplying a PipelineConfigurator constructed off the same SSLEngineFactory with the LoadBalancingHttpClient does work.\n. Update to my fork - this works when both the trust store and key store are specified (for whatever reason).  This might shed some light on the subject, but with the RC7 version, the handshake does not happen whatsoever in the same config.\n. Here is the relevant update I've made in LoadBalancingHttpClient::cacheLoadRxClient(Server server)\nLine 339:\n\n```\n   if (sslContextFactory != null) {\n         try {\n            SSLEngineFactory myFactory = new DefaultFactories.SSLContextBasedFactory(sslContextFactory.getSSLContext()) {\n                @Override\n                public SSLEngine createSSLEngine(ByteBufAllocator allocator) {\n                    SSLEngine myEngine = super.createSSLEngine(allocator);\n                    myEngine.setUseClientMode(true);\n                    return myEngine;\n                }\n            };\n        clientBuilder.withSslEngineFactory(myFactory);\n    } catch (ClientSslSocketFactoryException e) {\n        throw new RuntimeException(e);\n    }\n}\n\n```\n\n. Hey, thanks.  I will make the pull request. \nFor the client auth piece, that seems independent of the client mode.  If we have not setUseClientMode(true), the handshake doesn't proceed as if neither side thinks its the client and the ClientHello message never goes out.  This is regardless of whether client auth is required, wanted or neither.  Once setUseClientMode(true) is set, the ClientHello message goes out and the handshake proceeds.  After that, whether or not client auth was set to required on the server and/or client will be picked up and the proper cert exchanges happen.\nI think we still need to set useClientMode(true) regardless of the client auth flag.\n. Pull request accepted.\n. RC10 seems to be on rx-netty-0.3.17.  Will 18 be rolled in to that?  We also seem to be encountering this issue and am interested in a work around.  Haven't found anything yet, outside of retry, which isn't great for all situations.\n. Can you turn on SSL debug output on the client and the server?  If its the same issue I had (https://github.com/Netflix/ribbon/issues/169), you will see no SSL handshake whatsoever.  If that's the case, the fix I made was accepted and should probably be in the next release candidate version.  However, in the meantime, I know of a few workarounds I did while investigating the internals of Ribbon prior to making the fix.\nPlease let us know what the ssl output reveals as far as the handshake.\n. That sounds similar to what I experienced.  I also found the custom socket factory builder attribute didn't do too much for me.\nI think RC10 will fix this issue if the change I made gets in there, but in the meantime, you could try one of the workarounds I did prior to finding where to fix in the internals of Ribbon.  Essentially, you need to get a handle on the SSLEngine creation and setClientMode(true) on it.  I did this multiple ways, but about the cleanest version I had that involved only my changes and not internal Ribbon changes was to:\n- create my own SSLEngineFactory that overrides createSSLEngine()\n- create my own PipelineConfigurator with the SSLEngineFactory\n- create my LoadBalancingHttpClient with that configurator (there is a constructor in RibbonTransport.newHttpClient that takes these).\nI used RibbonTransport to create my client - it seems HttpRequestTemplate eventually burrows down to RibbonTransportFactory, so this approach might not work for you.\nIf that sounds like something you'd like to check out, let me know.\nOh ya, one of my other workaround was to use the RxNetty client directory.  There is a method on there to accept a custom SSLEngineFactory (IIRC), which got me going directly, but I lost the load balancing part.  You seem to be setting \"host\" directly, so that might be an option for you.\n. ",
    "OskarKjellin": "@NiteshKant at least I am not seeing that specific error any more. I also tried doing the same for futures with something like this;\nobservable.lastOrDefault().toBlocking().toFuture();\nDoes that sound right? \nAt what point will the default value be invoked? How can we be sure that the only case this happens if a response has been indeed been returned but the bytebuf was empty? Having huge issues trying to make this backwards compatible. Seems like we're getting false defaults... \n. @NiteshKant I'm trying around a bit. Our integration tests fail a lot when using the new version but haven't been able to pinpoint what is going on. A few exceptions are logged but with other requests we are getting no response when we expect to. \nRunning few tests with empty response and timeouts with or without futures have been working well.\nCould it be something with the reference count of the bytebuf? I do see this exception sometimes:\nio.netty.util.IllegalReferenceCountException: refCnt: 0, increment: 1\nAre we intended to retain/release or is that done by ribbon?\n. @NiteshKant Okay, haven't been able to narrow then exactly when this happens, but we do get the default response without validate or our map method being called (the blocking returns after 1 ms).\nWith my tests, if there was an error in the request, I did get the exception in the toBlocking so I am a bit curious of how this happens?\n. @NiteshKant I see that onComplete is being called directly after sending the request. This cannot be due to the server returning empty response because the server has not yet processed the request. No onError or onNext is called. The response validator is not called either.\n. @NiteshKant I'm trying to create a small reproducible test but haven't been able to reproduce locally yet. It only happens when we run multiple different requests at the same time.\nDo you know any reason that we could get this error:\nio.netty.util.IllegalReferenceCountException: refCnt: 0, increment: 1\nOr get a call to onComplete without onNext, validate or onError getting called? Would really help me troubleshoot. I got an onComplete the same millisecond as I sent the request.\nShould we bother with the refCounts at all? I see that observe causes ribbon to increment the refCount?\n. @NiteshKant I've been able to reproduce locally but with a more complex test that is creating a user internally in our service and then signing in the user. Sometimes (each test creates 8 users and signs them in with in a separate thread) after a lot of test runs (usually around each tenth time) the login fails. \nI added debug logging when doing this and from what I can see the request is not being sent. The rx-selector-x-x thread is not logging the bytes sent on these occasions. The receiving server does not see the request either. No onNext nor onError is called, but onComplete is called.\nWill continue troubleshooting to see if I can find why the request is not sent.\n. @NiteshKant After a lot of testing, I've been able to make a (relatively) small example that reproduces it.\nhttps://gist.github.com/OskarKjellin/e6fa19fc9e936d0b2287\nIf I put a breakpoint at the logging of \"Could not create\" and \"Could not sign in\", occasionally it hits. When this happens I always get the \"OnCompleted called but nothing emitted\".\nSeems like the request is actually sent after this happens though. But it still returns the default value, and then sends the request. \nWhen we run this with our own servers and code, we see this a lot which makes it kinda hard to use.\nReally looking forward to hearing from you if we're actually doing something wrong\n. @NiteshKant Have you had time to look at it? Just tried with only RxNetty and could reproduce the same issue\n. @NiteshKant Glad to hear I'm not the only one able to reproduce it  :+1: \nWill try with the latest code and see if our servers run OK with it. \nMaybe we should close this issue and open one at RXNetty instead? Because the issue does not seem to be within Ribbon.\n. ",
    "meenal5254": "I am getting same error when trying to use observable.toBlocking().single()\nNOTE: my code is running fine when I am using version 2.0-RC7 of ribbon, it just breaks when I am trying to upgrade to 2.0-RC9\n. @NiteshKant if I use singleOrDefault it gives me a default value, which should not happen. I need the value which is returned by the server. \n. I created a small test/code. It spin up its own jetty server and tries to get the content of simple HTML file using a simple GET method from ribbon.\nTest Class: https://github.com/meenal5254/ribbon-example/blob/master/example-impl/src/test/java/com/ribbon/example/impl/ExampleTest.java\nhttps://github.com/meenal5254/ribbon-example\nI have also  updated README to include the actual stacktrace that I am getting in my actual application.\n. ",
    "luckyswede": "Sorry for responding late, haven't had time to look at this for a few days.\nI'm using -Djavax.net.debug=ssl:handshake:data on the client now, and I can't see any ssl-related logging when connecting to the https service.\nAlso, when searching for \"CustomSSLSocketFactoryClassName\" on ribbon github it looks as if it is only the RestClient that is reading this property. I can't find another similar property for e.g. LoadBalancingHttpClient.\nBR / Jonas\n. Hello again :)\nGot it partially working by using the following config:\nIClientConfig clientConfig = ClientFactory.getNamedConfig(contextName);\nclientConfig.set(CommonClientConfigKey.IsSecure, Boolean.TRUE)\n    .set(CommonClientConfigKey.TrustStorePassword, \"changeit\")\n    .set(CommonClientConfigKey.TrustStore, \u201cpath-to/jre/lib/security/cacerts\")\nhowever, it doesn't work with server certificate chains... Not a huge deal I guess, but still annoying.\nUsing RC13 now.\nBR / Jonas\n. WRT certificate chains, that was my fault of course. It was because I switched from openjdk7 to oracle jdk8 which didn't include the StartCom root ca. \n. ",
    "elandau": "This doesn't seem like a proper fix for the bug since it skips the isAlive() check. \n. We are currently working on the improvements you mention.  A more robust entity mapping and serialization framework will be taken care of as a separate project under rxnetty.\n. Since the server lists are immutable it probably makes sense to also make the unmodifiable by calling aCollections.unmodifiableList at the time the member variables are set.  Also, it may be possible to remove locking entirely by tracking the server lists in an AtomicReference and using CAS operations.\n. Closing this in favor of #214 which has the correct artifact names for rxnetty.\n. For some reason this change broke connection priming.  My suspicion is that the short initial delay masked another bug.  The change was reverted until I can figure this out. \n. Much of Ribbon is made obsolete by new features introduced in RxNetty 0.5.  We are in the process of determining whether we will continue developing and supporting Ribbon or roll any missing features into RxNetty or a newer and more much lightweight version of Ribbon.\n. Java6 is barely supported anymore and we see no reason to revert to it.  If anything we should be upgrading to Java8.  http://www.oracle.com/technetwork/java/eol-135779.html\n. We should implement what's described here instead as it is more 'correct' instead of pushing the problem further out in the future by using longs.\nhttp://stackoverflow.com/questions/7572434/how-to-implement-a-concurrent-circular-ticker-counter-in-java\n. LGTM  Just had a few nitpicky comments.\n. lgtm\n. Closing this PR for now as I'd like to go in a slightly different direction with this implementation . Can withListeners be called multiple times?  Might want to accumulate the listeners instead of replacing previous ones.\n. Should be an ImmutableList so calls to CommandBuilder can't affect instances that have already been created with calls to build()\n. Shouldn't this be inside the if {} above?\n. Would be nice to also have \npublic Object get(String name, Object defaultValue)\n. Can clientConfig be null?\n. Should calling this more than once throw an exception?  Seems like an invalid state.\n. consider extending Func1<Server, Observable<T>>.  It would make it easier to compose using Rx.\n. Move declaration into the call method to tie the counter with the Subscriber.  Otherwise multiple calls to call() will end up using the same counter.\n. Is there a valid use case for retrying on the same server?  Shouldn't we always try a different server on failure?\n. We should use retry(predicate) instead.  The OperatorRetry implementation deals better with RxJava idiosyncrasies. \n. We had the same thing in governator and eventually had to add a method called withAdditionalListeners for backwards compatibility.  This caused a lot of ambiguity with sequences of withAdditionalListeners mixed with withListeners.\n. Not much of hit when using concatMap instead of flatMap.  Throwing exceptions in the map() handler doesn't work well because you end up having to wrap it in a RuntimeException.  Doing concatMap or flatMap type operations give you far greater control over error handling since the real exception is used. \n. Doesn't seem like.  I'll remove it.\n. We should never catch Throwable.  We should change this to Exception.\n. nitpick, make these final\n. Why not just use AtomicBoolean.getAndSet()?\n. Why not use AtomicReference.getAndSet()?\n. Return value of compareAndSet never used?  Should it be? \n. Capitalize constants\n. A 'cleaner' and more readable API would be to create two new methods in ILoadBalancer.  getUpServerList() and getServerList().  Then deprecated getServerList(boolean).\n. Add the date too\n. Make this lazy https://en.wikipedia.org/wiki/Initialization-on-demand_holder_idiom\n. Might want to add a 'busy' AtomicBoolean to make sure this sit not called concurrently.  It's ok to drop the extra event.\n. We may want to add a registerEventListener(listener, executor) to the eurekaClient API to take an executor in addition to the listener. \n. Shouldn't eurekaClient == null throw exception?\n. System.nanoTime() is preferable to System.currentTimeMillis()\n. This can just be a 'volatile'\n. This will end up doing multiple shutdowns of the shared executor (if used).  You may want to track a 'sharedExecutor' variable that is null if the sharedExecutor is not used. \n. This may end up creating a second eurekaClient instance when one was not created in the first place.  The eurekaClient and eurekaClientProvider as separate members.\n. Why is this lazy?\n. Is this necessary?  Seem like the 'zone' should already be guaranteed lower case.\n. Sorry, what I really meant to say is that shutting down one of these LoadBalancers will end up shutting down the scheduler for all other instances.\n. This seems unnecessary as EurekaClient should be bound as a singleton.  LegacyEurekaClientProvider already takes care of making this singleton.\n. Should we not inject EurekaClient directly instead of using a Provider?\n. Should be 'volatile' as we aren't doing any CAS or atomic increment operations here\n. Why is this volatile?\n. null check serverListUpdater\n. This is only used in one place.  Just create an anonymous class where it's used.\n. Can this just be a Runnable?\n. I thought you also wanted to change Throwable to Exception, no?\n. You're right.  Don't know why I thought catching Error would be any better.  Will fix this.\n. Stats are tracked in all sorts of places.  In some situations this can be null, which I'm taking as stats shouldn't be tracked.\n. This is done in a background thread.  I'm not even sure this is enabled.  We can research this separately.\n. This does ultimately get caught and handled.  I think it's fine to throw here.\n. You'll hit an NPE way before this.  Either way, i'll change this to just s, as that's what's used in other messages.\n. yes!\n. nope, java7.  we're good.\n. It gets cached in registerClientFromProperties.  I really wanted to fix the cache interaction but the code is so convoluted that I'm afraid to break something.  I may revisit that at a later time.. It's really an int everywhere.  It's consistent now.  . Recently added it and doubt it's used anywhere outside this codebase but there's no harm in deprecating the old method.. The old way is totally messed up.  Archaius defaults to ConfigurationBasedDeploymentContext which doesn't actually update configuration when setValue() is called but does initialize from configuration.  So, if someone actually set the system property @zone then it will be picked up by ConfigurationBasedDeploymentContext.  Netflix's NetflixConfiguration actually does the right thing in its implementation of DeploymentContext#setValue by also setting @zone in config.  \nThis is a bit of a breaking change for any code relying on ConfigurationManager.getDeploymentContext().setValue(ContextKey.zone, \"us-eAst-1C\"); to set the zone, which is something I would hope isn't actually done in practice.  . Actually, it's not worth going through a deprecation here. Risk here is extremely low since this method is only called internally.  . ",
    "zaininfo": "I've corrected this behaviour in the latest commit.\nAlthough, I would ideally like to incorporate something like Optionals to avoid returning null, but that needs discussion.\n. ",
    "jon077": "@elandau  - you seem to be making recent commits.  Is there any chance you can review?\n@allenxwang  - thoughts?\n. Awesome!  We wil use Func1 until then.  Is there a rough ETA?  We are excited.\n. ",
    "diptanu": "@pstout @elandau @zarfide Could you guys take a look please?\n. @elandau Alright done. Also wrapping the whole method with try catch would not have the property name in the scope so we won't be able to have the name of the property in the message of the exception. \n@zarfide It's not great but the test checks for the message of the exception now.\n. @elandau Sent a PR your way which fixes this.\n. @elandau @NiteshKant Can you guys please take a look at this?\n. @elandau Cool, but I had changed the artifact name of rxnetty to io.reactivex too!\n. Agreed, that the test would pass even without the check for correct property. Not sure how to effectively test unless we create a new type of RuntimeException and expect that in the test. \n. @pstout Yeah that makes it more intuitive. I will add to the PR.\n. @pstout Well what you suggested would not work straight away. Because for a property like myclient.ribbon=bar the namespace is ribbon and there is no property in there and that's why the code fails in the first place. We can just tell the user that there was some problem parsing properties in that namespace.\n. ",
    "brharrington": "It is a bug in the usage of servo. Non-numeric values can be exposed with the INFORMATIONAL type.\n. You could do something like:\njava\nInteger.remainderUnsigned(nextIndex.getAndIncrement(), eligible.size());. See #275.. Did you consider remainderUnsigned?\njava\nindex = Integer.remainderUnsigned(nextIndexAI.incrementAndGet(), serverCount);\nserver = allList.get(index);\n. I noticed a bunch of these transitioned from Throwable to Error. Should that be Exception?\n. ",
    "RaphC": "Thanks for your quickly response and fix. Do you know when is the next ribbon release date?\n. ",
    "avram": "Is this PR going to be merged? The current release of Ribbon cannot be used with Servo without it.\n. ",
    "sumanjupudi": "Hi Nitesh,\nThanks for the suggestion. We used template based ribbon during proof of concept to simplify the work and also easy to bind with Hystrix command.  I have done some examples with ribbon transport client but would like to find our if this client does the Hystrix command wrap ( Template annotation provides simple Hystrix annotation to fallover etc). If you could provide more inputs it will help our dev process.\nThanks,\nSuman\n. ",
    "joshuawhite929": "I came across this issue several months back.  Is this still open or is there a workaround for this?\n. ",
    "rspieldenner": "Could I get an assist looking at the one failing test. I'm only getting it to fail on cloudbees, not locally?\n. The Gradle maven publishing plugin we use puts everything in runtime scope. I take this as a project should have direct dependencies on things it depends on. It would be nice if there was a separation between libraries that were part of the api and those I need to compile that a downstream doesn't.\nI believe that dependencies shouldn't pollute the compile scope of people using them.\n\nOn Feb 16, 2015, at 4:16 AM, Lasse notifications@github.com wrote:\nAll Maven POMs in release 2.0.0-rc.14 have dependencies that used to have the scope \"compile\" set to \"runtime\". This breaks pulling in required dependencies. I guess this happened by mistake or am I missing something here?\n\u2014\nReply to this email directly or view it on GitHub.\n. At least for the short term. If we have have transitive dependencies that\nare used in the API we'll bump up on our priorities to be able to\ndifferentiate between things we need to compile that users don't need to\ncompile and api level dependencies that they do.\n\nOn Tue, Feb 17, 2015 at 1:40 AM, Lasse notifications@github.com wrote:\n\nThe problem with \"runtime\" dependencies not being available in \"compile\"\nscope is that all of my classes that are using Netflix classes don't\ncompile now, lest I manually add all dependencies, which is inconvenient\nand potentially has to be updated on every upgrade.\nSo is this the new dependency policy for ribbon now?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/Netflix/ribbon/issues/206#issuecomment-74640714.\n. The plugin requires a git repo to calculate version\nOn Fri, Mar 17, 2017 at 4:42 AM lorgine notifications@github.com wrote:\nwhen i build ribbon and print\n\nWhat went wrong:\n   An exception occurred applying plugin request [id:\n   'nebula.netflixoss', version: '2.2.10']\n\nrepository not found:\nC:\\Users\\lichengsheng\\Downloads\\ribbon-master\\ribbon-master\n\nTry:\n   Run with --stacktrace option to get the stack trace. Run with --info\n   or --debug option to get more log output.\n\nBUILD FAILED\nand my env is jdk 1.8 and the gradle.build is:\nplugins {\nid 'nebula.netflixoss' version '2.2.10'\n}\n// Establish version and status\next.githubProjectName = rootProject.name // Change if github project name\nis not the same as the root project's name\nsubprojects {\napply plugin: 'nebula.netflixoss'\napply plugin: 'java'\nsourceCompatibility = 1.7\ntargetCompatibility = 1.7\ngroup = \"com.netflix.${githubProjectName}\" // TEMPLATE: Set to organization of project\nrepositories {\n    jcenter()\n}\nif (project.hasProperty('useMavenLocal')) {\n    repositories {\n        mavenLocal()\n    }\n}\nif (project.getProperty('status').equals(\"snapshot\")) {\n    repositories {\n        maven { url 'http://oss.jfrog.org/oss-snapshot-local' }\n    }\n}\n}\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/Netflix/ribbon/issues/332, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAvvFjwKfP1_HIqYJwsctyVE4cCLElYvks5rmnGFgaJpZM4MgfI3\n.\n. Upgrade to the newest version of gradle and the nebula.netflixoss plugin.\nThat earlier version required a git repository to operate\nOn Wed, Jul 26, 2017 at 10:44 PM polarcoral notifications@github.com\nwrote:\n@lorgine https://github.com/lorgine Have you fixed your issue? I have\nthe same problem.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/Netflix/ribbon/issues/332#issuecomment-318264721, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AAvvFn3uR81U_iCLybGM2RrF6-VFvfnwks5sSCPJgaJpZM4MgfI3\n.\n. Either gradle 4.0.2 or 4.1-rc-1\nnebula.netflixoss -> 3.6.4\n\nNeed to modify ribbon/build.gradle to start with\n```\napply plugin: 'nebula.test-jar' // deprecated plugin was renamed\napply plugin: 'nebula.facet' // plugin was renamed\ntask licenseExamples(type: nl.javadude.gradle.plugins.license.License) // create license task for custom source set (which I'll look at at work since this should be automatic) \n```\nAnd there is a failing test. ListenerTest. testFailedExecutionForAbsoluteURI\nI would need the ribbon team to weigh in on the failing test.. I work on the nebula plugins so I can help get the build working. There is\nanother team that works on the ribbon project itself that will better\nunderstand any test failures.\nOn Fri, Jul 28, 2017 at 2:38 AM polarcoral notifications@github.com wrote:\n\n@rspieldenner https://github.com/rspieldenner\nYou said :\n--- > There is a failing test. ListenerTest.\ntestFailedExecutionForAbsoluteURI\nI saw this test case. What you mean? You can get my import ribbon project\nrunning information via the test case remotely?\n-----> I would need the ribbon team to weigh in on the failing test.\nwhat I can do for you when you need the ribbon team to weigh in on the\nfailing test?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/Netflix/ribbon/issues/332#issuecomment-318608415, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AAvvFomK9IRex558WQXBNbD_shgKRc7Iks5sSawKgaJpZM4MgfI3\n.\n. I saw the test failure since I cloned ribbon locally and updated my copies\ngradle and nebula.netflixoss and made the changes I asked you to make. Then\nran './gradlew build' and had that test failure.\nOn Fri, Jul 28, 2017 at 7:24 AM Rob Spieldenner rob.spieldenner@gmail.com\nwrote:\nI work on the nebula plugins so I can help get the build working. There is\nanother team that works on the ribbon project itself that will better\nunderstand any test failures.\nOn Fri, Jul 28, 2017 at 2:38 AM polarcoral notifications@github.com\nwrote:\n\n@rspieldenner https://github.com/rspieldenner\nYou said :\n--- > There is a failing test. ListenerTest.\ntestFailedExecutionForAbsoluteURI\nI saw this test case. What you mean? You can get my import ribbon project\nrunning information via the test case remotely?\n-----> I would need the ribbon team to weigh in on the failing test.\nwhat I can do for you when you need the ribbon team to weigh in on the\nfailing test?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/Netflix/ribbon/issues/332#issuecomment-318608415,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAvvFomK9IRex558WQXBNbD_shgKRc7Iks5sSawKgaJpZM4MgfI3\n.\n\n\n. \n",
    "lasselasse": "Just ran into the same issue. I don't see any reason why DynamicServerListLoadBalancer overwrites setPing(), it could just be removed.\n. Are there any impediments to merging the fix for this issue, pull request #208?\nWe've had this much needed patch in production for months now and would love to see it included in the next release.\n. The problem with \"runtime\" dependencies not being available in \"compile\" scope is that all of my classes that are using Netflix classes don't compile now, lest I manually add all dependencies, which is inconvenient and potentially has to be updated on every upgrade.\nSo is this the new dependency policy for ribbon now?\n. Any chance to re-run the CI for this pull request? It reported an error, but looking into the console output only shows an unrelated gradle error.\n. I don't see how the commit you are referencing has anything to do with swallowing throwables. That commit simply introduced optional ServerStatusChangeListeners and throwables occurring upon their invocation are properly logged as errors.\n. ",
    "kukgini": "It seems fixed in current 2.x branch (after 7aff37b).\nso, i close this issue.\nI think nebula-facet plugin related build issue is still alive. but, it's not a ribbon's current problem. \n. If you set properties like this:\nribbon.IsSecure=true\nribbon.SecurePort=443\nribbon will use 443 port instead of 80 port.\n. ",
    "ghost": "One workaround is to use a mod:ed DefaultClientConfigImpl\n```\n    DefaultClientConfigImpl config = new DefaultClientConfigImpl() {\n        @Override\n        public  T get(IClientConfigKey key) {\n            if (!key.equals(IClientConfigKey.Keys.PrimeConnectionsClassName))\n                return super.get(key);\n        return (T) getPropertyAsString(key, DEFAULT_PRIME_CONNECTIONS_CLASS);\n    }\n};\nconfig.loadProperties(clientName);\n\n```\n... but I would rather not have to.\n. ",
    "spencergibb": "Why not use something like http://wiremock.org/junit-rule.html and plug in a ServerList that only returns the wiremock server? We do something similar in spring-cloud-netflix, but we use spring-boot integration testing instead of wiremock.\n. @elandau that worries me a little bit. There will be spring cloud users hesitant to move to netty based clients right away. I'd prefer a newer lighter weight version.\n. Awesome!\n. IIRC, it's the version of the actual http client that doesn't support it. Newer versions of spring cloud don't use RibbonClientHttpRequestFactory, they use the default RestTemplate http client, so patch isn't an issue.\n. See https://github.com/Netflix/eureka/issues/600\n. Here is one way https://github.com/Netflix/ribbon/tree/master/ribbon#ribbon-annotations\n. This is not the appropriate issue tracker for Spring Cloud questions. Looks like a good question for http://stackoverflow.com/questions/tagged/spring-cloud\n. This is not the right place for spring cloud issues.\n. I like the new status.\n. Maybe it could be opt-in with a configuration setting so the default behaviour stays the same, but allows the option?\n. @mbtanveer I'm not a maintainer here. @twicksell?. This isn't the spring cloud repo. if you are using spring-cloud-netflix open an issue there.. This is not the spring cloud issue tracker. You guys and changing java versions in a minor :-). So is this after 2.2.3?. NP, can you at least bump the ribbon version to 2.3.x so the 2.2.x line stays java 7?. This is not the spring cloud netflix issue tracker.. Relying on the exception message is brittle. This is not the spring cloud Netflix issue tracker. This is not the spring cloud Netflix issue tracker. That's my guess. The module path likely won't be feasible until the whole graph of open source dependencies are modules.. I'd rather see a similar configuration to IPing and IRule. I don't think it's practical to extend BaseLoadBalancer in many cases. It would be easier to have it in a constructor and only call this method if there isn't a custom on passed in.\n. ",
    "dersteve": "@esigma5 or @spencergibb can you share some code snippets how to inject the ServerList?. ",
    "GrapeBaBa": "Hi elandau,\nWhen ribbon 3.x codebase will open source?\n. ",
    "jjteo74": "Digging further and found out that ReadTimeoutHandler cannot be re-activated once its been destroyed by calling handlerRemoved.\nManaged to get the test case to pass by patching io.reactivex.netty.pipeline.ReadTimeoutPipelineConfigurator to use a place holder ChannelInboundHandler so that a new ReadTimeoutHandler instance can be swapped in at every write completion.\n``` java\n    @ChannelHandler.Sharable\n    private class ReadTimeoutHandlerLifecycleManager extends ChannelOutboundHandlerAdapter {\n    @Override\n    public void write(final ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n        // Add the timeout handler when write is complete.\n        promise.addListener(new ChannelFutureListener() {\n            @Override\n            public void operationComplete(ChannelFuture future) throws Exception {\n                @SuppressWarnings(\"unchecked\")\n                final DelegatingHandler<ReadTimeoutHandler> timeoutHandler = (DelegatingHandler<ReadTimeoutHandler>) ctx\n                        .pipeline().get(READ_TIMEOUT_HANDLER_NAME);\n                if (null == timeoutHandler) {\n                    ctx.pipeline().addFirst(\n                            READ_TIMEOUT_HANDLER_NAME,\n                            new DelegatingHandler<ReadTimeoutHandler>(new ReadTimeoutHandler(\n                                    timeout, timeUnit)));\n                } else {\n                    // This will always be invoked from the eventloop as it is a future listener callback.\n                    ChannelHandlerContext handlerContext = ctx.pipeline().context(timeoutHandler);\n                    timeoutHandler.swap(new ReadTimeoutHandler(timeout, timeUnit))\n                            .handlerRemoved(handlerContext);\n                    timeoutHandler.handlerAdded(handlerContext);\n                }\n            }\n        });\n        super.write(ctx, msg, promise);\n    }\n}\n\nprivate class DelegatingHandler<T extends ChannelInboundHandler> implements\n        ChannelInboundHandler {\n\n    private volatile T delegate;\n\n    public DelegatingHandler(final T delegate) {\n        this.delegate = delegate;\n    }\n\n    public T swap(final T newDelegate) {\n        T oldCopy = delegate;\n        delegate = newDelegate;\n        return oldCopy;\n    }\n\n    @Override\n    public void channelRegistered(final ChannelHandlerContext ctx) throws Exception {\n        delegate.channelRegistered(ctx);\n    }\n\n    // ... more methods forwarding to `delegate`\n\n}\n\n```\n. ",
    "juristr": "I made some progress, following suggestions here: http://stackoverflow.com/a/16531462/50109\nI started to get other errors and had to include a dependency to\nxml\n<dependency>\n   <groupId>asm</groupId>\n   <artifactId>asm</artifactId>\n   <version>3.3.1</version>\n</dependency>\nNow I'm getting a NullPointerPointerException at\nCaused by: java.lang.NullPointerException\n    at com.sun.jersey.server.impl.cdi.CDIExtension$ParameterBean.later(CDIExtension.java:961)\n    at com.sun.jersey.server.impl.cdi.CDIExtension$ParameterBean.create(CDIExtension.java:977)\n    at org.jboss.weld.context.unbound.DependentContextImpl.get(DependentContextImpl.java:69)\n    at org.jboss.weld.manager.BeanManagerImpl.getReference(BeanManagerImpl.java:733)\n    at org.jboss.weld.manager.BeanManagerImpl.getReference(BeanManagerImpl.java:789)\n    at org.jboss.weld.injection.FieldInjectionPoint.inject(FieldInjectionPoint.java:92)\n    at org.jboss.weld.util.Beans.injectBoundFields(Beans.java:358)\n    at org.jboss.weld.util.Beans.injectFieldsAndInitializers(Beans.java:369)\n    at org.jboss.weld.injection.producer.DefaultInjector.inject(DefaultInjector.java:72)\n    at org.jboss.weld.injection.producer.ResourceInjector.inject(ResourceInjector.java:60)\n    at org.jboss.weld.injection.producer.DefaultInjector$1.proceed(DefaultInjector.java:66)\n    at org.jboss.weld.injection.InjectionContextImpl.run(InjectionContextImpl.java:48)\n    at org.jboss.weld.injection.producer.DefaultInjector.inject(DefaultInjector.java:64)\n    at org.jboss.weld.injection.producer.BasicInjectionTarget.inject(BasicInjectionTarget.java:90)\n    at org.jboss.resteasy.cdi.JaxrsInjectionTarget.inject(JaxrsInjectionTarget.java:48)\n        ...\nThe code where it fails is in the CDIExtension.ParameterBean.later():\njava\n        public void later() {\n           ...\n            boolean registered = webApplication.getServerInjectableProviderFactory().\n                    isParameterTypeRegistered(parameter);\n           ...\n        }\n. ",
    "jonathanlarav": "I have the same issue and for some reason creating a proxy instance just once didn't fixed the issue for me. Wondering if using Feign will also solve the issue or it's an issue with Ribbon itself.\n. ",
    "dfjones": "Are there any known workarounds to this issue? \n. ",
    "faubertin": "Yes, you can generate a dummy keystore:\nkeytool -genkey -keyalg RSA -keystore dummy-keystore.jks -keysize 2048\nLeaving all default values except for the password.\nThen setup Ribbon like this:\njava\nDefaultClientConfigImpl.getClientConfigWithDefaultValues()\n            .set(CommonClientConfigKey.IsSecure, true)\n            .set(CommonClientConfigKey.IsClientAuthRequired, false)\n            .set(CommonClientConfigKey.KeyStore, \"/path/to/dummy-keystore.jks\")\n            .set(CommonClientConfigKey.KeyStorePassword, \"$keystorePassword\")\n. ",
    "heyjustin": "I don't believe the build failure is related to the contents of the pull request.  \n...\nCaused by: org.gradle.api.GradleException: Could not generate a proxy class for class nebula.core.NamedContainerProperOrder.\n. The example on the wiki page needs to be updated too.  Unfortunately I can't submit a PR for that.\n. ",
    "TarlochanKalsi": "Closing this issue and posted this question in ribbon-users google group.\n. ",
    "balamaci": ":+1: \n. ",
    "stvvan": "+1\n. ",
    "minhdanh": "+1\n. ",
    "maksimlikharev": "add 2 methods to HttpRequestBuilder\n1. withHeader \n2. withCookie\nor just #1 only.\n. already in 2.1 closing\n. ",
    "ispringer": "I missed that one. Thanks. \nYeah, I also noticed that the project appears dead. Last commit was 3 months ago...\n. ",
    "netrebel": "I had the same question... \nI think we are meant to use: io.reactivex.netty.protocol.http.client.HttpClient\nSomething like this:\nConfigurationManager.loadCascadedPropertiesFromResources(serviceName);\nIClientConfig clientConfig = IClientConfig.Builder.newBuilder(url).build();\n            clientConfig.set(IClientConfigKey.Keys.ListOfServers, url);\nLoadBalancingHttpClient<ByteBuf, ByteBuf> ribbonClient = RibbonTransport.newHttpClient(clientConfig);\n. ",
    "abel-von": "+1\n. ",
    "victuxbb": "I'm interested too! :+1: \n. Hi @elandau can you provide some answer about this? Im really interested in find a solution without forking this repo :)\nThanks for your time.\n. ",
    "ramonibz": "That would be a great feature, we are currently using Ribbon and facing this problem too :+1:\n. ",
    "enriclluelles": ":+1: \n. ",
    "ismaelfernandezscmspain": ":+1:\n. ",
    "danielricart": "i am interested on it. :+1: \n. ",
    "aloon": "me too\n. ",
    "danigui": ":+1:\n. ",
    "xfornesa": ":+1:  go for it!\n. ",
    "roykachouh": "@elandau Thanks for all the great work!\nI agree with @spencergibb. This is a bit worrying. We have invested lots of effort on building our service stack on top of ribbon. Is there any high level roadmap resource that we can view, just so we can plan accordingly and be in a better position to react to future changes?\n. ",
    "keaplogik": "Netflix OSS still touts this as a keystone project. Am I incorrect in assuming that? If so, what types of client side load balancing are the Netflix team using? Has the architecture changed, or is ribbon just not the direction moving forward? Many use this project, but it has became difficult to maintain. If RxNetty is the way forward, it may be worth vesting more in client loadbalancing within that project or an external one. The example in that project is trivial and not as advanced as this.\n. This is the answer we are looking for, and it's good to have a general idea of direction (At Netflix) going forward especially with open source technology. \nLoad balancing is the key piece of this software that quickly gives us HA in the cloud without single point of failure when integrating services. In general, RPC is not going to be the direction for many writing microservices, so it will be interesting to see where companies move from here (REST w/ externalized models/schemas, protocol buffers w/ gRPC, MOM, or likely a mix)\nThanks for the heads up, and hope this gets communicated to other interested parties.\n. ",
    "drtechniko": "Dear Billy,\nWe haven\u2019t been good at communicating out, so I understand your frustration. Your question triggered a series of internal discussions, so I apologize for our delayed response. You touched on a point that we at Netflix had looked at only from the lens of the day to day incremental problem solving but not really sitting down and framing the bigger picture. \nRibbon comprises of multiple components some of which are used in production internally and some of which were replaced by non-OSS solutions over time. This is because Netflix started moving into a more componentized architecture for RPC with a focus on single-responsibility modules. So each Ribbon component gets a different level of attention at this moment. \nMore specifically, here are the components of Ribbon and their level of attention by our teams:\nribbon-core/                        [deployed at scale in production]\nribbon-eureka/                    [deployed at scale in production]\nribbon-evcache/                 [not used]\nribbon-guice/                      [not used]\nribbon-httpclient/               [we use everything not under com.netflix.http4.ssl. Instead, we use an internal solution developed by our cloud security team]\nribbon-loadbalancer/         [deployed at scale in production]\nribbon-test/                         [this is just an internal integration test suite]\nribbon-transport/               [not used]\nribbon/                               [not used]\nEven for the components deployed in production we have wrapped them in a Netflix internal http client and we are not adding new functionality since they\u2019ve been stable for a while. Any new functionality has been added to internal wrappers on top of Ribbon (such as request tracing and metrics). We have not made an effort to make those components Netflix-agnostic under Ribbon.\nRecognizing these realities and deficiencies, we are placing Ribbon in maintenance mode. This means that if an external user submits a large feature request, internally we wouldn\u2019t prioritize it highly. However, if someone were to do work on their own and submit complete pull requests, we\u2019d be happy to review and accept. Our team has instead started building an RPC solution on top of gRPC. We are doing this transition for two main reasons: multi-language support and better extensibility/composability through request interceptors. That\u2019s our current plan moving forward.\nWe currently contribute to the gRPC code base regularly. To help our teams migrate to a gRPC-based solution in production (and battle-test it), we are also adding load-balancing and discovery interceptors to achieve feature parity with the functionality Ribbon and Eureka provide. The interceptors are Netflix-internal at the moment. When we reach that level of confidence we hope to open-source this new approach. We don\u2019t expect this to happen before Q3 of 2016.\nI hope that answers your questions but don\u2019t hesitate to follow up with thoughts and suggestions.\nThank you for bringing our focus back on a matter we\u2019ve neglected.\n. Hi Maciej,\nI just merged a fix for this here: https://github.com/Netflix/ribbon/pull/260\nI decided to make the int a long instead of the absolute value so that the modulo wraps around properly (assuming 10 servers) 7->8->9->0 instead of 7->8->7->6...\nBest of luck!\n. No problem. I will check out the LongAdder. I thought of something along\nthose lines but I figured it was simpler and more efficient to use a long\nfor all practical purposes given this is a load balancing frequency counter\nand not a tight loop (shrug).\nOn Thursday, January 7, 2016, elandau notifications@github.com wrote:\n\nWe should implement what's described here instead as it is more 'correct'\ninstead of pushing the problem further out in the future by using longs.\nhttp://stackoverflow.com/questions/7572434/how-to-implement-a-concurrent-circular-ticker-counter-in-java\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/Netflix/ribbon/pull/260#issuecomment-169847475.\n. @elandau Have a look and let me know. Btw, this file seems to be formatted using MS-DOS. I didn't mess with that part to not distract us.\n. @elandau I added a second commit that fixes the ILoadBalancer API.\n\n@brharrington I liked remainderUnsigned() but it's a java 1.8 only API and I wasn't sure if we're ready to make ribbon not backwards compatible with 1.7 yet.\n. Hi Matt,\nThank you for sharing your proposal. I'm not sure if I fully understood it but here are some thoughts and feel free to chip in and correct/clarify.\nIt would be worth to compare the benefits of your proposal to a scheme where you configure the ping interval to something shorter (that could be only for the one app that is sensitive to changes) while having your client capture an exception (Connection, IO, application specific) and send the request to another instance in your load balancing scheme in case it has hit a \"stale\" instance.\nThe ping interval sets your staleness window in a sense. I'm having a hard time understanding how a second timestamp-based \"refresh\" interval would benefit the application. If it's longer than your ping interval then it's not effective. If it's shorter than your ping interval then we are looking at a performance optimization trade-off: is it cheaper to have a high ping interval and have a potential storm of requests to \"stale\" servers to check their status when clients \"refresh\" interval is maxed or to simply have a shorter ping interval?\nAlso, unless we consider a notification mechanism, any expiration-based scheme would ultimately have to rely on the client detecting the bad instance at the time of the request, mark it and move on to the next. Also, to bound delays when cascading failures-and-retries happen you can have a look at Hystrix.\n. released. closing.\n. you're welcome. enjoy.\n. @spencergibb and @twicksell Here we go.\n. ",
    "bradhandy": "Is this a pull request which will never be integrated?  If so, I'd like to know soon as I need to take other steps to make sure can compile the library with Java 1.6, and implement procedures for incorporating future changes to the library.\n. ",
    "jkubrynski": ":+1: \n. ",
    "michalig": "@ilayze, did you found solution?. Issue was (in somehow a bit hackish way) resolved in this stackoverflow topic:\nhttp://stackoverflow.com/questions/34456075/pass-request-headers-to-ribbon-irule-key-parameter\nSetting the serverLocator param with the whole request object would allow to do what you want with a proper IRule implementation (it is then used as a key object in IRule).\nWould be nice to be able to customize LoadBalancerCommand with composition (LocaBalancerCommandFactory?), NOT by overwriting AbstractLoadBalancerAwareClient.executeWithLoadBalancer method as this requires overwriting of FeignLoadBalancer and CachingSpringLoadBalancerFactory (AFAIK).. ",
    "xxlabaza": "+1. ",
    "lowzj": "see the PR: https://github.com/Netflix/ribbon/pull/309. Is there anyone to take a look about this pr?\n. @qiangdavidliu @spencergibb Maybe it's difficult to make a decision whether to merge this PR. And the opt-in with a configuration setting solution would lose efficacy when invoking executeWithLoadBalancer(request) or executeWithLoadBalancer(request, null).\nHow about another solution: the class AbstractLoadBalancerAwareClient exposes a protected method buildLoadBalancerCommand. So It could stay the same behavior by using the default implementation, and at the same time it gives a chance to its derived classes to customize their own LoadBalancerCommand. The drawback is that we have to change its derived classes to override buildLoadBalancerCommand method .. @spencergibb @qiangdavidliu There is nothing that affect the existing 'status quo', just give a chance to its derived classes to customize the LoadBalancerCommand object.. @elandau  Could you please take a look at this PR? I'm eager for it to be merged.. Is there anyone to take a look at this PR?. @csterwa I don't know, it seems no.. @qiangdavidliu ping.. ",
    "Zenedith": ":+1: \n. ",
    "przemeq": ":+1: \n. ",
    "mhawrylczak": ":+1: \n. ",
    "panqingcui": "ribbon  Load Balancer as eureka client\n. ",
    "enisher": "Sorry. That has been fixed by @mattnelson in d98065c.\n. ",
    "ipapapa": "Diego, this is a cool idea. Are you envisioning Ribbon talking to Dyno locally, and then Dyno talking to Dynomite? or Ribbon sending REST calls directly to Dynomite?\n. @diegopacheco I had a quick chat with @elandau and he informed me that Ribbon will not be actively developed in the near future. You can see some info #248 . Moreover, my understanding is that the cache you are referring to is a static pre-loaded cache so that is why you can find a PUT call to feed it.\n. ",
    "diegopacheco": "@ipapapa  @timiblossom  @tbak\nI Could be wrong but as far as i know this changes are more likely to be into Ribbon rather than in Dyno. Dynomite is awesome solution and looks like a perfect cache for low latency IMHO. I use the Netflix stack already with ribbon so would make more sense to me introduce dynomite as cache through dyno at ribbon level, so would be transparent for the microservices consumers. \nWe could make ribbon call dynomite via Dyno. That`s what i would like to do. I realize Ribbon has s caching annotation called: com.netflix.ribbon.proxy.annotation.CacheProvider  which is a factory and you provide a key + factory(CacheProviderFactory) that creates: CacheProvider.\nHowever com.netflix.ribbon.CacheProvider just have a GET method :( So i don`t see how i can hook a PUT call to Dynomite via Dyno to feed a cache. There is not enough information in context to make the PUT call on the get operation. Since this is build based on a Ribbon Template class here(https://github.com/diegopacheco/netflixoss-pocs/blob/master/ribbon-map-cache/src/main/java/com/github/diegopacheco/netflix/pocs/ribbon/cache/RibbonServiceProxy.java) i would need to know: \n- What is the method that was called\n- What is the cache key name\n- What args was passed to the method\n- Have the proxy object instance\nThem i would be able to do the call there and feed the cache, this info could be passed to another method something like OnCacheMiss or a updateCache method that`t could receive this info. \nAnother option would be have the reference of the instance RequestWithMetaData them i would just do: .execute().content() and i would have the ByteBuf in hand i would be happy :-) \nYou can get all code on this simple project i did here: https://github.com/diegopacheco/netflixoss-pocs/tree/master/ribbon-map-cache (there is no Dyno/Dynomite code here, but has some code using ribbon and show my point with a memory HashMapCache which does not working well because is caching all the time :(. If we have this changes in place it would be easy to replace the HashMap for a Dyno call or something else if someone want it. \nCheers,\nDiego Pacheco\n. @ipapapa  @elandau  thanks for the information i was not aware about this.\nI will do the cache using Dyno and Dynomite  but outside of Ribbon, that`s fine. \nCheers,\nDiego Pacheco\n. ",
    "websusk": "Is there an option to use a load-heavy version of Ribbon using Spring Cloud Netflix before this is released?  Is is possible or recommended to override this dependency until them?\n. ",
    "PedroAlvarado": "@drtechniko @dmitry-cherkas The kind folks behind jersey released a new version 1.19.1. This version includes a fix for JERSEY-2795(Github Issue) which a number of users are currently running into in production by proxy of using ribbon. I'd be great if you guys can help us get this dependency upgraded to address this issue. Thank you in advance for your help.\n. ",
    "dmitry-cherkas": "Hi @spencergibb , thanks for your feedback! I have updated my code to use constructor injection.\n. Any chance accepting my pull request and releasing new version? My project really needs this extension point.\n. Thank you very much, @drtechniko !\n. ",
    "Yannic92": "So you say backwards compatibilty is more important than convenience?\nHow would things getting better then?\nI would've enjoyed this pull request + it would have saved me one hour of time to find out whats going on... ",
    "d53dave": "That's a change my team would like to see as well. Determining the best available server should take failures into account.. ",
    "tkvangorder": "Fast-Forward two years, we had this custom rule in place and we ran into an issue! Once a box entered the error state and there was not enough load to choose it over one of the other \"healthy\" nodes, it would not reenter the pool! So I dont recommend this approach....maybe I should close this issue? . ",
    "twicksell": "Awesome, looks good\n. This wouldn't be a backwards compatible change. Want to keep the old method name and deprecate it? . Should this be duplicated into another test to confirm that the old style of setting values on DeploymentContext still works?. ",
    "pparth": "+1 to the question. \n. +1\n. ",
    "bipin-yadav": "+1 , getting the same issue.. ",
    "szlachet": "I would like to ask again if a migration to Jersey 2.x is planned because it is used by spring-cloud-starter-consul-discovery and as  @nodje mentioned above integration with application that are using Jersey 2.x cause problems. . OK, thanks @mattnelson for answer.. ",
    "Hyunk3l": "PR you opened https://github.com/Netflix/ribbon/pull/295 (just to put the ref). +1. ",
    "01sas": "Is there any plans to close this issue in the nearest feature? As I can see problem is fixed and pull request opened.. ",
    "mengchaozhong": "Thanks for quick response. Is there a way to do it with spring cloud configurations?\n. ",
    "pwillemann": "I am having the same issue.  Have you found a solution yet?\n. ",
    "AbbelSop": "Hi @pwillemann \nNot directly. I analyzed the problem with some developers at the wildfly-swarm forum and we found out that the two options are completly ignored in the current ribbon implementation (at least in the client that is used when using the proxy or template way to use ribbon). Since Ribbon is now in maintanance mode (you can only create pull-requests to fix issues yourself) i opted to implement the loadbalancing myself.\nIf you have any other questions, feel free to ask away (if you are using wildfly-swarm just stop by the forum, you can find the link on their site).\n. ",
    "get2parag": "Moved this issue to spring-cloud-netflix project - link\n. ",
    "hoaz": "ribbon-core and ribbon-loadbalancer modules share the same packages, which makes them incompatible with OSGI\nI ended up building fat JAR which contains both. Here is sample maven configuration:\n</dependencies>\n        <dependency>\n            <groupId>com.netflix.ribbon</groupId>\n            <artifactId>ribbon-core</artifactId>\n            <version>2.2.0</version>\n        </dependency>\n        <dependency>\n            <groupId>com.netflix.ribbon</groupId>\n            <artifactId>ribbon-loadbalancer</artifactId>\n            <version>2.2.0</version>\n        </dependency>\n        <dependency>\n            <groupId>io.reactivex</groupId>\n            <artifactId>rxjava</artifactId>\n            <version>1.0.9</version>\n        </dependency>\n     </dependencies>\n     <build>\n         <plugins>\n             <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-shade-plugin</artifactId>\n                <executions>\n                    <execution>\n                        <phase>package</phase>\n                        <goals>\n                            <goal>shade</goal>\n                        </goals>\n                        <configuration>\n                            <artifactSet>\n                                <includes>\n                                    <include>com.netflix.ribbon:ribbon-core</include>\n                                    <include>com.netflix.ribbon:ribbon-loadbalancer</include>\n                                </includes>\n                            </artifactSet>\n                            <createDependencyReducedPom>false</createDependencyReducedPom>\n                        </configuration>\n                    </execution>\n                </executions>\n            </plugin>\n            <plugin>\n                 <groupId>org.apache.felix</groupId>\n                 <artifactId>maven-bundle-plugin</artifactId>\n                 <configuration>\n                     <instructions>\n                        <Import-Package>\n                            !com.netflix.*,\n                            rx.functions,\n                            com.google.common.reflect,\n                            com.google.common.cache,\n                            com.netflix.config,\n                            com.netflix.util,\n                            com.netflix.util.concurrent,\n                            com.netflix.servo.monitor,\n                            com.netflix.stats.distribution,\n                            org.apache.commons.configuration,\n                            *\n                        </Import-Package>\n                         <Export-Package>\n                            com.netflix.loadbalancer\n                         </Export-Package>\n                     </instructions>\n                 </configuration>\n            </plugin>\n         </plugins>\n    </build>\n. ",
    "agarbutt": "Any update / progress on merging this change?. ",
    "vision-ken": "Any update / progress on merging this change?. ",
    "gfortaine": "cc @elandau \n. ",
    "imberda": "Is there any update on this? It would be great to see a gRPC (Java) load balancer implementation which uses Eureka for discovery. \nI'd strongly imagine there are a large number of projects / developers that are users of Eureka / Ribbon for REST. If the above were to be open sourced it would pave the way for those folks to easily adopt gRPC. . ",
    "maseb": "Bump. :) . ",
    "LutzStrobel": "Hi, is anybody out there having an eye on this issue? A correct loadbalancing and failover behavior is a decision critical feature to choose netflix or not!\n. ",
    "csterwa": "@lowzj @spencergibb has there been any review of this PR?. ",
    "dorkolog": "@vojta13 I am not sure why its written that way, but, in the case when application loads all servers, while some of them are dead, ribbon is expected to run its retry mechanism, so even in that case you should be safe.\nHowever, it seems that com.netflix.loadbalancer.RandomRule does use lb.getReachableServers(), so this actually might be a bug. @vojta13 \nI think it worth @mention one project contributor that seems to be active before issuing a PR.. ",
    "vojta13": "@dorkolog Thank you for getting back to me. With the retry mechanism, if I understood it correctly that is only when it is configured to retry if it is specified with zero it would still fail. Although it would safe this situation the underlying behavior that I was describing still seems to me not ideal.\nI am also new to contributing to a open source project. You mentioned it might be a bug and I think as well. What is a next step? Can I submit pull request with this small change to be reviewed and potentially merged or does someone else actually have to confirm it is a bug and a fix is desired?. @dorkolog ok.\nHello @elandau, you seem to be the recent active contributor to this project. I am wondering if you could provide your view on this issue. What do you think is it a bug to fix and may I proceed to issue a pull request?. ",
    "jhspaybar": "Many of my comments could just be my ignorance.  If that's the case, feel free to merge it since they're all relatively minor. \ud83d\udc4d \n. This doesn't look like a recoverable scenario, should you be re-throwing this one?  Or is there some default/fallback VipAddressResolver if the instantiation fails here?\n. Should we at least log?\n. It looks like this could be the first dereference of \"s\" in this function, if it could be null, please null check it before logging data from it.\n. should you pass this instead of calling toString()?  That way it won't evaluate toString until it knows it should be logging?\n. Should you still return null here but at least add some logging?\n. Are we pinging connections before sending requests? (not something related to this pull request, but just something I'm interested in learning)\n. \ud83d\ude06 were we also swallowing null pointer exceptions?\n. Are you certain this isn't in use? I wonder if we should just leave it behind just in case?. ",
    "howardyuan": "LGTM\n. ",
    "tcellucci": "PR has checks for Server.isAlive that will behave incorrectly at runtime.  Server.isAlive needs to be volatile, like Server.id and Server.readyToServe, to prevent concurrency errors\n. public method no longer returns 'null' in the arbitrary IClientConfig failure case, but throws an exception instead.   Is the upcoming release not backwards-compatible?\n. not sure this is the right behavior here.  Previous behavior was to wrap errors of any kind in a checked exception 'ClientException' and throw, but new behavior is to do that only for a few exception types and let other types propagate to the caller.  That seems like a net 'no improvement' for a breaking api change.   Also the javadoc needs to be updated so that the caller doesn't think that 'any errors' will be thrown as ClientException.\n. same comment as previous.  This is a breaking change in terms of exception handling for no net benefit: ClientException previously would be thrown for any failure, but now it's thrown only in a few cases.\n. ",
    "jjathman": "Is this something that can get merged in? I'm looking for this exact functionality as well.\n. ",
    "mbtanveer": "Is this going to be merged? I am also looking for this exact functionality. Either way please leave a comment.. @spencergibb is this request going to be accepted.. ",
    "wsz-": "Sorry ,i saw  pull 296\n. ",
    "WeipingGuo": "Opened the issue in https://github.com/spring-cloud/spring-cloud-netflix/issues/1466\n. ",
    "pacoyi": "ok, the CI failed at test case \"com.netflix.loadbalancer.PredicatesTest > testAvalabilityPredicate FAILED\n    org.junit.ComparisonFailure at PredicatesTest.java:96\".\noriginally it is to get then increment, like i++, the new one is get the increment value ++i.\n. ",
    "stoneliyi": "this is a serious bug that bit us on production where more than 2 billion requests were made. and as it is the default rule provided by Spring Cloud, many applications could run into the issue. please merge it to fix the bug. . thanks @pacoyi and @qiangdavidliu. \nin which ribbon release should we expect to see this fix? . as its comment suggests, it's the same as RoundRobinRule.incrementAndGetModulo(int modulo)(in master branch). it should be safe. \nand for \"int current = Math.abs(nextIndex.incrementAndGet()); \"\njava docs writes \"Note that if the argument is equal to the value of Integer.MIN_VALUE, the most negative representable int value, the result is that same value, which is negative.\"\nhttps://docs.oracle.com/javase/7/docs/api/java/lang/Math.html#abs(int)\nit seems that could be an issue when it's overflowed. \n@pacoyi is the one who made the PR though. :-)\n. ",
    "khauser": "Okay, then I would try with spring-cloud-netflix... ",
    "regevbr": "We have the same issue...\nThere is no way to close the ScheduledThreadPoolExecutor manually, even though there is a shutdown method for the BaseLoadBalancer which I would expect to close that thread pool. ",
    "tpenne": "I do agree, that is really annoying. ",
    "T3rm1": "It's still in there. Holy shit. They even have a logger field in the class. This project must be really dead ^^. ",
    "YordanBorisov": "@spencergibb could you please help with this topic.\n. ",
    "WreathCrystal": "@lorgine   Have you fixed your issue?  I have the same problem.  . @rspieldenner     Another issue occurs after upgrading to the newest version both of gradle and the nebula.netflixoss plugin.     \nThe content of build.gradle  as  below:\nplugins {\n    id 'nebula.netflixoss' version '3.5.2'\n}\n// Establish version and status\next.githubProjectName = rootProject.name // Change if github project name is not the same as the root project's name\nsubprojects {\n    apply plugin: 'nebula.netflixoss'\n    apply plugin: 'java'\nsourceCompatibility = 1.7\ntargetCompatibility = 1.7\n\ngroup = \"com.netflix.${githubProjectName}\" // TEMPLATE: Set to organization of project\n\nrepositories {\n    jcenter()\n}\n\nif (project.hasProperty('useMavenLocal')) {\n    repositories {\n        mavenLocal()\n    }\n}\nif (project.getProperty('status').equals(\"snapshot\")) {\n    repositories {\n        maven { url 'http://oss.jfrog.org/oss-snapshot-local' }\n    }\n}\n\n}\nThe gradle version as attachment\n\nAnother errors : \n\n. @rspieldenner   Maybe you can tell me the accurate  version both of gradle and nebula.netflixoss plugin with which  ribbon project will  be imported and  built successfully.   . When I modify ribbon/build.gradle to start with:\napply plugin: 'nebula.test-jar' // deprecated plugin was renamed\napply plugin: 'nebula.facet' // plugin was renamed\napply plugin:  'nebula.netflixoss'\nthe error as below:\n\nThen I  commented  out  the  code   of  NetflixOssProjectPlugin.groovy  file of gradle-netflixoss-project-plugin project which I got from the website: https://github.com/nebula-plugins/gradle-netflixoss-project-plugin\n\nThen I replaced the NetflixOssProjectPlugin.class  file in  gradle-netflixoss-project-plugin-3.6.4.jar with the just complied local file NetflixOssProjectPlugin.class\nthe error changed:\n\n. Then I insert lines to  ribbon/build.gradle\nplugins {\n  id \"nebula.nebula-test-jar\" version \"2.2.2\"\n}\nThe import error changes to this:\n\n. @rspieldenner  I can import ribbon project successfully now. Thank you !   But I think the error as below maybe a bug?  what do you think?\n\nThere is another problem left. When I import  missing  dependency http-20070405.jar into ribbon/ribbon-loadbalance project,  I got one error: The method setSSLParameters(SSLParameters) is undefined for the type HttpsParameters\n\nThis maybe caused by http.jar version confict,  Which version you are using? \n. @rspieldenner \n  You said : \n--- >  There is a failing test. ListenerTest. testFailedExecutionForAbsoluteURI\n           I saw this test case. What you mean?  You can get  my import ribbon project running information via the test case remotely?  \n----->   I would need the ribbon team to weigh in on the failing test.\n               What I can do for you  when  you need the ribbon team to weigh in on the failing test? \n. ",
    "suood": "how do you fix it?. ",
    "jbaurchn": "Are these issues of security concern.\nIf so, please provide the ways to address them.\n. ",
    "clatko": "SNI needs to be added as an SSLParameter to the SSLEngine. That engine is only created in rxNetty, but has been overriden in LoadBalancingHttpClient - https://github.com/Netflix/ribbon/blob/master/ribbon-transport/src/main/java/com/netflix/ribbon/transport/netty/http/LoadBalancingHttpClient.java#L510\nYou would have to add code there or modify rxNetty. I really don't think there is a clean way to do it without the rxNetty modification.. https://github.com/Netflix/ribbon/pull/391. added logger. gather all hosts. ",
    "tiny-dancer": "seconded, specifically: https://github.com/Netflix/ribbon/pull/309\n@lowzj i've been on your github trail these last two days deep diving into solving likely a very similar problem :)\nappreciate the work and persistence on your efforts.  . ",
    "dxin93": "Oh, sorry. I'll repost there.. ",
    "harishkadamudi": "+1 for this.. I am also facing this Issue, sometimes, LB gives different instance. ",
    "rk13": "Thank you. Please check with ribbon-loadbalancer-2.2.5.\nProblem should be fixed by https://github.com/Netflix/ribbon/pull/357. ",
    "HashZhang": "Not all SocketTimeoutException should be retried, but for that exception with msg \"connect time out\", it should be retried.\nThis exception always take place while restart one of multiple instances of the same microservice. In this case, the request should be retied on other running instances. While the timeout is set less than 1000, \"java.net.SocketTimeoutException: connect timed out\" will be thrown.  while it is large than 1000, \"java.net.ConnectException: Connection refused: connect\" will be thrown\n```\npublic static void main(String[] args) throws IOException {\n        Socket socket = new Socket();\n        try {\n            socket.connect(new InetSocketAddress(\"127.0.0.1\", 8080), 500);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        socket = new Socket();\n        socket.connect(new InetSocketAddress(\"127.0.0.1\", 8080), 1100);\n}\n\n```\nthe output is:\njava.net.SocketTimeoutException: connect timed out\n    at java.net.DualStackPlainSocketImpl.waitForConnect(Native Method)\n    at java.net.DualStackPlainSocketImpl.socketConnect(DualStackPlainSocketImpl.java:85)\n    at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)\n    at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)\n    at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)\n    at java.net.PlainSocketImpl.connect(PlainSocketImpl.java:172)\n    at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392)\n    at java.net.Socket.connect(Socket.java:589)\n    at com.hash.test.TestRxJava.main(TestRxJava.java:14)\nException in thread \"main\" java.net.ConnectException: Connection refused: connect\n    at java.net.DualStackPlainSocketImpl.waitForConnect(Native Method)\n    at java.net.DualStackPlainSocketImpl.socketConnect(DualStackPlainSocketImpl.java:85)\n    at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)\n    at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)\n    at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)\n    at java.net.PlainSocketImpl.connect(PlainSocketImpl.java:172)\n    at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392)\n    at java.net.Socket.connect(Socket.java:589)\n    at com.hash.test.TestRxJava.main(TestRxJava.java:19). for both of the exceptions, they should be retried.\n. Well. It's right.\nBut for this case, cannot find a better way to implement. ",
    "penghbgit": "Have these two exception retryes been fixed? In which version?. ",
    "marvin-min": "@HashZhang @spencergibb Any good solution on this? I found this issue on windows server again. However, the microservice still online. I am not sure why this hannpens.. ",
    "smartest-water": "private int incrementAndGetModulo(int modulo) {\n    for (;;) {\n        int current = nextServerCyclicCounter.get();\n        int next = (current + 1) % modulo;\n        if (nextServerCyclicCounter.compareAndSet(current, next))\n            return next;\n    }\n}\n. ",
    "Aloren": "Please check my solution to this problem.\nI think that when such situation is encountered (nodes were added or removed from eureka), WeightedResponseTimeRule should use RoundRobinRule, because accumulatedWeights were calculated for different nodes. So just retrying the process of choosing node will choose node based on the luckiness of the randomWeight value.. @qiangdavidliu could you please review?. fixed. thanks. ",
    "tingliu9": "Yes, It is a good solution.. I have Added a unit test. ",
    "ahaaaaa": "+1. ",
    "kerumai": "@qiangdavidliu How does that look?. Absolutely. Although it looks like getEurekaClientConfig() only exists on DiscoveryClient, not EurekaClient - so is it ok for me to cast to DiscoveryClient if it is an instanceof?. ",
    "StevenWash": "@pablete @moustaki @zkwentz . ",
    "dominicqi": "i have the same question . . ",
    "migue": "We're programmatically using the load balancer provided by Ribbon (for our ClickHouse http client) and I've found really useful to have the ability to define the ping interval from the builder.\nNot sure if this is something that could be useful to every one, but I thought it was worth to make the pull request :D. ",
    "mujun0312": "\u6211\u8ba4\u4e3a\u6bcf\u4e2a\u6743\u91cd\u533a\u95f4\u8fb9\u754c\u7684\u5f00\u95ed\u5f62\u5f0f\u662f\u8fd9\u6837\u5b50\u7684\uff1a(x, y]\uff0c\u4e0e\u6b64\u540c\u65f6\uff0c\u56e0\u4e3a\u968f\u673a\u503crandomWeight\u7684\u6700\u5c0f\u503c\u53ef\u4ee5\u4e3a0\uff0c\u6700\u5927\u503c\u53d6\u4e0d\u5230\u6700\u5927\u7684\u6743\u91cd\u503c\uff0c\u56e0\u6b64\uff0c\u7b2c\u4e00\u4e2a\u670d\u52a1\u5b9e\u4f8b\u7684\u6743\u91cd\u533a\u95f4\u7684\u4e0b\u9650\u662f\u95ed\u533a\u95f4\uff0c\u6700\u540e\u4e00\u4e2a\u5b9e\u4f8b\u7684\u6743\u91cd\u533a\u95f4\u7684\u4e0a\u9650\u662f\u5f00\u533a\u95f4\uff0c\u6240\u4ee5\u6211\u8ba4\u4e3a\u5224\u65ad\u6761\u4ef6\uff1ad >= randomWeight \u662f\u6b63\u786e\u7684\u3002. @qiangdavidliu Could you please review?. Yes, server should be selected on upList, but the index should not be chosen from serverCount, it may be greater than upList.size(). If the server that is reachable is down, then the upCount is 0. ",
    "shunminli": "randomWeight \u662f 0 \u6ca1\u95ee\u9898\u554a > \u7684\u8bdd \u4e5f\u662f [0, X)\n\u5047\u8bbe\u4e09\u4e2a weight \u5206\u522b\u662f 2, 2, 2 \u90a3\u4e48\nd \u4f9d\u6b21\u662f 2, 4, 6\n\u6211\u4eec\u5df2\u77e5 randomWeight \u7684\u5206\u5e03\u5728 [0, 6)\n\u5982\u679c\u662f d >= randomWeight \u4f60\u5c06\u4f1a\u5f97\u5230\u4e09\u4e2a\u6982\u7387\u533a\u95f4 [0, 2]\uff0c(2, 4]\uff0c(4, 6)\n\u5982\u679c\u662f d > randomWeight \u4f60\u5c06\u4f1a\u5f97\u5230 [0, 2)\uff0c[2, 4)\uff0c[4, 6)\n\u4f60\u8ba4\u4e3a\u54ea\u4e2a\u662f\u6b63\u786e\u7684\u5462\uff1f\n\u95ee\u9898\u4e0d\u5728\u4e8e \u7b2c\u4e00\u4e2a\u670d\u52a1\u5b9e\u4f8b\u7684\u4e0b\u9650\u548c\u6700\u540e\u4e00\u4e2a\u670d\u52a1\u7684\u4e0a\u9650\uff0c\u95ee\u9898\u51fa\u5728\u7b2c\u4e00\u4e2a\u670d\u52a1\u7684\u4e0a\u9650\u548c\u6700\u540e\u4e00\u4e2a\u670d\u52a1\u7684\u4e0b\u9650 @mujun0312 . @qiangdavidliu. ",
    "MadeInChina": "pls merge to version 2.2.5 as well.\nor should ask spring-cloud-netflix team to upgrade version when ribbon release a new version ?\nbecause \nhttps://github.com/spring-cloud/spring-cloud-netflix/blob/master/spring-cloud-netflix-dependencies/pom.xml are using \n<ribbon.version>2.2.5</ribbon.version>\n. ",
    "dchack": "@spencergibb sorry, I don't know what can I do more to understand this problem. do you mean i can use like stackoverflow.com to get an answer?. @ChengChuanxin94 sorry, I have no idea. when my project restart, I make the project DOWN very quickly.. @ChengChuanxin94 you can read this issue : https://github.com/spring-cloud/spring-cloud-netflix/issues/2667. ",
    "ChengChuanxin94": "hello, I got the same problem, do u solved it? . @dchack  ok,i have solved it, u can put the configuration like this:\n```\nspring:\n   cloud:\n     loadbalancer:\n         retry:\n            enabled: true\nribbon:\n   MaxAutoRetries: 1\n   MaxAutoRetriesNextServer: 2\n   OkToRetryOnAllOperations: true\n   ReadTimeout: 1000\n   ConnectTimeout: 250\n   ServerListRefreshInterval: 1000\n   retryableStatusCodes: 500,404,502\n   ServerListRefreshInterval: 2000\nzuul:\n retryable: true\n```. ",
    "HuaiJoe": "I found the issue had been fixed. \nI found more details about the issue at  https://github.com/Netflix/ribbon/pull/322. ",
    "futurechan": "I found the jar on jboss. Adding that as a maven repository fixed the issue.\nrepositories {\n    maven {\n        url \"https://repository.jboss.org\"\n    }\n}. ",
    "Ravis22": "I have services with hyphen e.g user-service name with which it is registered on discovery server. I am using properties file instead of yml but this should not make any difference. \nuser-service.ribbon.listOfServers=http://localhost:9999. ",
    "pstout": "Should the argument be 'key' rather than 'prop'?  Put another way, will users be confused by having the namespace omitted in the error message.  Alternatively, should the namespace be included as a separate value in the message, for example: String.format(\"Property '%s' in namespace '%s' is invalid.\", prop, getNameSpace())\n. Any particular reason this line and the next are not simplified to: for (String key: props.getKeys()) {?\n. nit: This is a bit of belt and suspenders with the try-catch block in the PingerTask class.  Consider marking this method as throwing Exception and removing the catch block.\n. Will's suggestion matches the behavior that you have implemented in the catch block for the next rule.choose() call.  See next diff.\n. Is this an intentional change from using the existing ping object?  I suspect so as using the existing object may not actually result in a ping happening, but I wanted to check.\n. ",
    "lukasz20p": "This field is no more used. Only deprecated RestClient used it.\n. Interface used for getContext\n. We trust self signed certificate. \n. ",
    "JonathanO": "Done, thanks. That removes the need for the isAlive() check, but I guess the isReadyToServe() check is still required (assuming that's not part of an obsolete feature?). ",
    "msigne": "Unit test?. Typo \"Occured\"?. ",
    "yyvess": "Server should not be selected on upList ?\nint index = chooseRandomInt(upCount);\nserver = upList.get(index);. Check upCount isn't sufficient ?. Use a logger . Some dough that is correct to get only the first one . ",
    "troshko111": "Typo: \"one\" (or \"single\").. I see that getNamedLoadBalancer caches the one registered from config upon success, does this one intentionally not cache it in the map?. This one is int and long interchangeably, based on the usage I'd stick to int.. "
}