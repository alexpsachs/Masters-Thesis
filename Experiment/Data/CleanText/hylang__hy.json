{
    "paultag": "hilariously done\n. Less shitty \n. @jd hit this one hard.\n(hy)[tag@leliel:~][07:26 PM]$ hy\nhy 0.9.3\n=> (if)\nTraceback (most recent call last):\n  File \"/home/tag/.virtualenvs/hy/bin/hy\", line 7, in <module>\n    execfile(__file__)\n  File \"/home/tag/dev/local/hy/bin/hy\", line 130, in <module>\n    version=hy.__version__\n  File \"/usr/lib/python2.7/code.py\", line 243, in interact\n    more = self.push(line)\n  File \"/usr/lib/python2.7/code.py\", line 265, in push\n    more = self.runsource(source, self.filename)\n  File \"/home/tag/dev/local/hy/bin/hy\", line 54, in runsource\n    _ast = hy_compile(tokens, root=ast.Interactive)\n  File \"/home/tag/dev/local/hy/hy/compiler.py\", line 645, in hy_compile\n    ret = tlo(body=compiler._mangle_branch(compiler.compile(tree)))\n  File \"/home/tag/dev/local/hy/hy/compiler.py\", line 60, in compile\n    return _compile_table[_type](self, tree)\n  File \"/home/tag/dev/local/hy/hy/compiler.py\", line 85, in compile_raw_list\n    return [self.compile(x) for x in entries]\n  File \"/home/tag/dev/local/hy/hy/compiler.py\", line 60, in compile\n    return _compile_table[_type](self, tree)\n  File \"/home/tag/dev/local/hy/hy/compiler.py\", line 479, in compile_expression\n    return _compile_table[fn](self, expression)\n  File \"/home/tag/dev/local/hy/hy/compiler.py\", line 155, in compile_if_expression\n    test = self.compile(expr.pop(0))\nIndexError: pop from empty list\n(hy)[tag@leliel:~][07:26 PM]$\nWe need to add some decorators to the Compiler internals - so we see stuff like\n(hy)[tag@leliel:~][07:26 PM]$ hy\nhy 0.9.3\n=> (import os)\n=> (.abspath os.path)\nTraceback (most recent call last):\n  File \"<console>\", line 1, in <module>\nTypeError: abspath() takes exactly 1 argument (0 given)\n=>\nThis might involve some serious hackery, but I think we can pull it off somehow.\n. @jd sent in #69 - fixed!\n. clojure\n(-> (read) eval print loop)\n(not bin/hy)\n. Aye! I'm just a bit concerned with re-serial-izing Python responses into s-expressions to return over the line -- this should be wicked simple for most things, but I know there'll be some payloads that will crash the nrepl consumer :)\nReally +1 on that idea, though\n. \n. slayed. macros in python (\"macros\") work fine. need quoted syntax for native macros next\n. 98pct \n. implemented like hell\n. closed in fb6ec426e646fa7d80024c311ae4e03d49e700fb - thanks @cwebber \n. s/compression/comprehension/g - doh. renaming\n. and first / rest\n. done like a mo'fo\n. Split ast27/3x or rename module \n. Done \n. Mostly, I'd like to document all the builtins and macros, with small docs on what they do -- I'm going to leave this open until my eyes bleed with docs\n. Alas, that's a bit of a pain (auto generation) - I'd like to include human readable bits, examples, descriptions and gotchas.\nWe need to document all the funky behavior somewhere clear :)\n. don't know what this means, killing with fire\n. we done merged it in. Thanks, @rumple!\n. implemented as an if/else macro\n. This sounds pretty interesting, I actually like how easy it sounds, and I'm tempted by the prospect of having keywords (a lot).\nIt also seems like this'd work in the case of:\nclojure\n(import-from foo bar :as brah)\nwhich is even more interesting (and almost enough to call this blocking #20)\n. Well, right :)\nI do like the idea of subclassing HYString into HYKeyword. I'd say I'm +1.\n. (for the record, here's what we said on IRC:)\nHow should we handle (function-call foo :foo \":foo\" \"foo\") to native Python?\nShould :foo == \":foo\" ? What does (set [:foo \":foo\"]) do?\nHow can we do it without depending on Hy? Should we depend on Hy?\n. @algernon  I don't hate the idea to be sure. Bummer we won't be able to support:\nclojure\n(:foo {:foo \"bar\"})\n(well, until our macro system grows up anyway)\nWhat does this mean for Python interop, @algernon ?\nIf something external is expecting {\"foo\": \"bar\"}, it might be getting {\"_hy_prefix_string_keyword_foo\": \"bar\"}\nDo we care, even? :)\n. Hella done \n. Done\n. Initial macros added\n. swagin' out\n. Kinnnnda works.\n. clojure\n(try\n  (error function call)\n  (catch IOError (...))\n  (catch FooError (...)))\n. hilariously works\n. Oh snap, I did this already.\nclojure\n(.join \" \" [\"1\" \"2\" \"3\" \"4\"])\nTotally works now\n. Changes look good, they appear (at a glance) to be fit to be merged without change -- just need to pull it down and review (i'll do that now)\nQuestion: What's the expected behavior of:\nclojure\n([f o o b 1 2 3] 2 3 4)\nShould we fix this after? \n. (so we can do dynamic args for real)\n. initial impressions:\nclojure\n(defn foo [x y & rest])\nno way to do kwargs with my initial gut\n. Thanks, @agentultra - let's get some of the others to chime in with their ideas too (although :thumbsup: this would work) - @jd / @algernon / @cwebber \n. At the very least, we aught to support this as one method of declaring this. The more I think about it, the more I'd be apt to use something like this.\nAnyway, it is just begging me to do:\nclojure\n  (defn foo (x & rest x :optional (y 0) :aux kwargs))\nbut yeah. That leads to all sorts of crap (see #22 )\n. @cwebber that's where my gut went off the bat too - I don't really love the &&kwargs, but it is really short and familiar to Pythonistas\nMost of these have some big pluses and just enough minuses to annoy us all :)\n. Right. Let's go for lambda lists. Its a bit verbose, but better then nothing. Who knows, we may macro some of the pain away somehow later.\nI like @jd's dict suggestion - let's do dicts in the optional place. \nCan we figure out what accepting lambda list syntax here implies for other bits of hy? Any other uses we need to consider?\n. This landed \n. Thanks so much! Glad you enjoyed it, it was a fun one to give!\nChanges look great, thanks! I'll merge this up shortly :+1:  -- thanks for doing that -- this will help me when I rewrite the parser (coming up shortly) -- hopefully I can clean it up (as you noticed, it's a pretty big mess in there)\nAs for the two bits:\n- Lexer -- you're absolutely right. I'll change this when I get back in there for a refactor\n- expression -- I'm not actually sure, so I'll defer to you -- I've come from Clojure land, where it's common to call s-expressions expressions, and all that. I'd much rather be proper, so I'll look into that a bit more carefully and see what I find :)\nThanks so much! I super appreciate it!\n. Whoops, sorry for letting this hang!\n. @jonathanmarvens hit me up on IRC -- irc://irc.freenode.net/#whube -- let's get your rollin'\n. Now fully in progress \n. Reeeeewritten \n. I think this is fixed \n. undropped\n. Killer! Thanks, @rumple!\n. with-as exists\n. :thumbsup: \nGood move. Let's do this. Future paul, it's not a problem, with-as can be done as:\nPython\nwith foo(bar) as z:\n   pass\nClojure\n(with (z (foo bar)) (pass))\n. donish\n. Looks killer, thanks!\n. Initial work merged into master. Hot shit.\nNext up: If statement hoisting.\n. Ifs in. Closing this.\n. unquote is eval, homie\n. sweet jesus\n. :thumbsup: thanks @willkg !\n(that's actually where I got the idea from, seems neat)\nparsimonius looks nice too -- add that to the to-look-at list!\n. What's the status? I've forked rply until @alex has a chance to review your PR.\n. nice\n. Oh man! NICE! :thumbsup: lets get on this\n. At the very least, consider for use in generating pyc files\n. @Coaldust I don't understand what you mean:\n``` Python\n\n\n\nast_ = ast.parse(\"\"\"if True:\n...     pass\n... elif False:\n...     pass\n... else:\n...     pass\n... \"\"\")\nast.dump(ast_)\n\"Module(body=[If(test=Name(id='True', ctx=Load()), body=[Pass()], orelse=[If(test=Name(id='False', ctx=Load()), body=[Pass()], orelse=[Pass()])])])\"\n```\n\n\n\nelif is just sugar for AST, but we're not using Python (the language) as a backend target\n. I think we do that, no? Have an example?\nOn Mon, Dec 30, 2013 at 2:17 PM, Coaldust notifications@github.com wrote:\n\n@paultag https://github.com/paultag I wasn't aware that elif resulted\nin the same AST as else if, though it makes some sense. I thought it\nwould have saved some bytecode.\nIn any case do blocks definitely do not need to generate code to return\ntheir last value if that value is not used. A cleanup pass could strip that\nout, making AST dumps easier to read, and saving a little execution time\nand space.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/issues/60#issuecomment-31362633\n.\n\n\n:wq\n. so, +1 on native eval, but this is at compile time -- we'll have to tweak eval to be a macro that expands out to some runtime bits.\nRight now, I think this will just noop from checking the diff -- I'll give it a careful review in a skitch\n. Closing this out, we talked about it on IRC. I\"m moving it to a bug!\n. @paultag vulture the tests & comment them out until we can get eval working\n. Tests jacked. Thanks, @jd\n. :thumbsup: \n. PR merged, thanks @willkg \n. Crap, wrong bug\n. oh wait, eval sorta kinda works. see https://github.com/hylang/hy/issues/105 for moar info\n. Utterly hilarious - not at my machine, but +1 feel free to merge\nP.s. - strong advocate of encouraging some neighborly graffiti\nPush at will, anyone! (No not that will) \n. Also hyve is now official \n. needs a small change (py3 failure fix) but otherwise generally great way forward - was trying to originally do some things like:\n@params(HySymbol, HyList, HyFoo), but that sucks for var-arity funcs, etc.\nI approve of this method totally. \n. Lookin' slick!\n. someone was doing this. I lost track. Seemed doable.\n. @jd: ensquished\n. @jd pushed up an assert, good move\n. ``` patch\ndiff --git a/tests/native_tests/language.hy b/tests/native_tests/language.hy\nindex e029480..6b00a3e 100644\n--- a/tests/native_tests/language.hy\n+++ b/tests/native_tests/language.hy\n@@ -427,6 +427,7 @@\n    (assert (= and123 3))\n    (assert (= and-false False))))\n+\n (defn test-or []\n   \"NATIVE: test the or function\"\n   (let [[or-all-true (or 1 2 3 True \"string\")]\n@@ -436,6 +437,17 @@\n    (assert (= or-some-true \"hello\"))\n    (assert (= or-none-true False))))\n+\n+(defn test-if-return-branching []\n+  \"NATIVE: test the if return branching\"\n+  ; thanks, algernon\n+  (assert (= 1 (let [[x 1]\n+                     [y 2]]\n+                 (if true\n+                   2)\n+                 1))))\n+\n+\n ; FEATURE: native hy-eval\n ;\n ;   - related to bug #64\n```\ntest case\n. dis got fixed by @jd \n\n. Yeah, importing macros is a massive pain - for sure a bug.\nBy the time the ast.Import runs, the hy is already byte code. We need to scan imports at macro time - also, if we don't - future native macros won't work :)\n. (require) now exists. huzzah.\n. Needs an update for the code_branch change\n. Hiya!\nSo, cool request!\nGiven hy, we can sketch out some python (though its sometimes wrong) off the compiled AST. That's around on the web as HTTP://hy.pault.ag \nThere's also a debug tool called hy2py which does that (but not as neatly)\nGoing the other way (py2hy) aught to be easy to generate off the ast, but may involve writing some code. I'd be happy to help provide guidance on hy's internals or the python AST to write this :)\nHTH! \n. @jd it's segfaulting pypy - any idea what's up?\n. Meh, not doing it locally.\n. Wait, yes it is. Looking into it.\n. It happens with (pass) istr\n. still segfaulting :'(\nI can see about this one this weekend if you need a second pair of hands, @jd \n. OK, I got it passing, @jd \n``` patch\n@@ -312,6 +312,15 @@ class HyASTCompiler(object):\n                 orelse=orelse,\n                 finalbody=finalbody)\n\nif not handlers:\nhandlers = [ast.ExceptHandler(lineno=expr.start_line,\ncol_offset=expr.start_column,\ntype=None,\nname=None,\nbody=[ast.Pass(\nlineno=expr.start_line,\ncol_offset=expr.start_column)])]\n+\n         return ast.TryFinally(\n             lineno=expr.start_line,\n             col_offset=expr.start_column,\n```\n\nThe issue here is this isn't what we want, since this turns\nclojure\n(try)\ninto\npython\ntry:\n    try:\n        pass\n    except:\n        pass\nfinally:\n    pass\nWhich isn't really what we want :>\nI think something's gone wrong -- that function is looking really huge, think we can break it up?\n. OK, I trust your judgement, @jd :)\nI'll be around to help; I think I see what's going on here\n. this also sucks ; needs to manage imports\nwe also klobber python's eval.\n. unsucked\n. Ackd - we should get an @olasd signoff on parser changes since he has a long running patch in progress -- tests would rock\n. No, tests are good. I'd still like @olasd to sign off on any changes to the parser until his work is merged\n. Right, looks good and has @olasd ack. Merged, thanks @khinsen !\n. Merged up, thanks, @agentultra - the index there isn't used [yet] but it'll come in handy for the rewrite.\nThanks for the typo fix!\n. @algernon this fails in Python 3 because unicode isn't defined :)\n. Is pass true or false?\n. I'm thinking we ought to turn 'pass' into 'false' if we expect a stmt - we aught to have a philosophical bug on avoiding this class of crap with hoisters and manglers \n. :thumbsup: - pass was there to make Python syntax valid; we can pop them where we need them. There's no reason the programmer needs them.\nRockn'. Rockn'.\n. removed like woah\n\n. @garyposter turns out it doesn't :)\nThis was added (the syntax in the bug) via some trickery with the parser directly, but that same trickery rendered reader macros hard. We should likely close this with more info. @olasd - mind commenting and re-closing with an explanation of why we need some serious hacking to add reader macros?\n. We should be able to add reader macros on a dispatch char (e.g. #), IIRC -- I'm interested in pysistence, though! Time to look into it! :)\n. Ack, uch I suck :)\nOn Nov 12, 2013 8:56 AM, \"Nicolas Dandrimont\" notifications@github.com\nwrote:\n\nOK. That definitely sounds doable with the dispatch thing.\nWe should definitely cut 0.10.0 before cramming new features in though\nhint hint\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/issues/103#issuecomment-28294710\n.\n. @gekailin could you also get away with using a dispatch char (like #) for what you have in mind?\n. #377 RFC :)\n. Thanks to @Foxboron I think we have a first cut\n. \n. e.g. you can't kwapply a dict var:\n\nclojure\n(kwapply (foo bar) {\"one\" \"two\"})\nis good, whereas:\nclojure\n(setf baz {\"one\" \"two\"})\n(kwapply (foo bar) baz))\nbasically, try to double-star apply (**kwargs) to the function rather then only taking dicts :)\n:+1: \n. fixed\n. Idea - conditionally eval either inline if stmt or exec if not \n(Note to self)\n. I'm +1.\n. Right, let's just do future division. It trips me up all day, and Hy shouldn't behave that differently from 2 to 3. \n:+1: on the idea.\n. Right, so, we're not going to make + / - functioins, it'd really slow things down a lot, and it'd cause a mess. It's how Hy 1.0 worked, and it got out of hand quickly.\nHowever, we can be aware of where we use it, and I was considering implementing even? as a lambda -- so that even? builds out to: lambda _hy_even_arg: _hy_even_arg % 2 == 0, which means we could pass it around or use it as a function.\nWe could try to see if we can do this with hoisters\n. Well (+) would apply invocation - it'd be all non-first instances of + in a form \n. OK. I theoretically agree with this, but we would need to do it right. Let's prototype a few approaches and make this work.\n. Awesome! Be sure to check out the hoisters and manglers, I think that's how we ought to do this.\n. @khinsen ponder (print (if true 1 0))\nIn python this has no meaning :) that mangler wraps the (if ) in a ((fn [] ...)) - it's actually a mangler not a hoister; hoisters have to do with scoping issues :)\n. @khinsen but that's not true for the general case; such as:\nclojure\n(print (if true\n  (do\n   (print \"foo\")\n   (+ 1 1))\n  false))\nand yeah; scope isn't a good name, some of this needs better docstrings and names, I didn't want things to get hoisted in the middle of an if. Ignore the name, it started out as only fn, but it's grown as I've found some complexity.\nIt should be codebranchable or something\n. Yeah totally. There's an open bug on -OMG-FAST mode :)\n. (we might have to shove them into a function; since we can't have stmts in lambda)\nI agree. We'd have to expand @jd's basic signature checking stuff to do good and reliable signature inference (or rather; good enough to not break) and generate off that.\nI'm a fan of that. We'd need to use the auto-import bits, I think, but it's for sure doable.\n. Also, it's going to be a serious dent for us; since we output AST depending on the args, we'd have to make the wrapper function take the args, get it into the astize stuff, compile that, run it, return the result.\nBleh. I really don't want to implementations of each operator either, though.\n. Humm! You're right!\nI don't like how it'll be so overhead-ey, but I'd rather be correct. Let's do it.\n. That's not a bad idea.\nLet's marinate on this and get some code hacked up for 0.9.8\nOn Mon, May 6, 2013 at 8:12 AM, Nicolas Dandrimont <notifications@github.com\n\nwrote:\nIn a second step, if we want to avoid overhead, we can give those\nfunctions predictable names, dedupe them and hoist them up to the top of\nthe AST.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/issues/108#issuecomment-17478352\n.\n\n\n:wq\n. @khinsen we have var-arity lists :)\n@agentultra added lambda list syntax to (fn [] ) -- we can make it happen no problem :)\n. merged!\n. Need to review PSF license for MIT / Expat compatibility; likely OK, just need to review the PSF license. Might need to split it out. Putting on hold, but it's a fantastic idea.\n. Yep, full-ack. I'd like to have it (and modify it to print AST nodes without lineno entries red)\nJust need to do a bit of homework, no worries!\nThanks, @agentultra !\n. So the approach is good.\nIf continue with this approach, compile_ needs to change to _compile (pep8 istr)\nI'm not entirely fond of the codegen dumper printing the future statement which makes me think about adding it to the ast, but its a bit of a hack.\nThe other option is to just use generated python as debuggable output.\n. Oh shit, I'm wrong\nsingle_trailing_underscore_: used by convention to avoid conflicts with Python keyword, e.g.\n. No, I agree.\nI'd almost be tempted to just remove that print and just make a note that we always use future division. Let's put a pin in this, I'll merge this tonight and make some random arbitrary decision if we keep / remove the print depending on my mood :)\n. Merged, removed the print, screw it. Thanks, @khinsen \n. Merged with a small bit of editorial love. Thanks! Filing a bug about removing import-from / import-as\n. Looks great, thanks, @vladimir-g !\n. @jd we should find a way to test pyc generation -- have some ideas? @olasd had an idea, but it's all theory.\n. Its a core part of hy - I'm going to call this wontfix - the idea here is bi-directional interop - I'm going to make a zen of hy guide that explains some this, but excessive mangling will ruin any chances of python talking to hy\nIt'd encourage writing hy with underscores - which would suck.\nIf folks need only one direction, stuff like guile or clojure-py beats the socks off hy :)\n. yeah, we can see if others disagree, but I am open to debate :)\n. @willkg yep!\nAlso, forgot to bring up python interop - its nice to invoke native python as render-template rather then render_template \nAnyway enough horse beating - let's communicate this better. I'm on my phone, can someone reopen and retitle as a documentation bug?\n. label added; need to figure out rights; this is becoming a PITA\n. My bad\n. A good point!\n. @khinsen the manglers exist for a reason -- they solve a very particular problem we hit with the way we do the compiling -- they are pretty general already. We could modify the If mangle to do more, but I was thinking of small testable mangles, since they're pretty complex already.\nI should document a bit, but I've not had the chance yet.\nRE: (+ (do 2 3) 1), yeah. We should fix that. That might also need to become mangled like we do with (if) blocks.\n. Also, I'm +1 on changing the behavior of (setv), we did it for functions already :)\n. OK. Let's put a pin in this and file a bug on the rest of the kruft. I'm still of the mindset that we just need to get around the builtins, and we'll be fine.\nLet's sketch stuff out, but I'm not convinced we can't do this by edge-casing the edge-cases.\n. @olasd how's this branch going; I want haz\n. Erm, right. Shit. Closing\n. ultra mega :sparkles: :sparkles: :sparkles: :sparkles: \n. not exactly sure how we can throw this into a (for) form unless we default the (else) to the outermost for.\nSomething to ponder in the macros.\n. p.s. filed issue https://github.com/hylang/hy/issues/123\n. this PR thrills me\n. closed\n. @Foxboron closed this with that PR\n. ack - and it's used all over the place; we might need to just go on a patching spree soon. Let's wait until after .6 release to do the great purge\n. @algernon looks good - can you add this to NEWS?\n. I don't think this will work, since it's only compile time. I'd return a lambda that tests the arg\n. e.g.\n(defn foo [x]\n  (if (keyword? x) ... ...))\n. +1 sounds good - perhaps we should consider a way to add hyperbation to hylang once we can play nice (like future imports ;))\n. +1; we have functools.partial, which should work. Perhaps we can use some macro goodness like we do for eval.\n. Whoops, didn't mean to close.\n. @jd ok, this is due to bad hoisting behavior -- I could have sworn I filed a bug on this.\nHuge ACK.\n. but what's the function resolve to -- the builtins aren't callable (yet?) - this is another case of an annoying tidbit. I really really really don't want to implement things twice.\nThis is a dupe of can't-use-plus-to-map, I think\n. Same here, looks great. Killer.\n. big duh on this one, I wonder why I wrote it like that to begin with.\nThanks!\n. So, it likely returns a generator - basically a special type of iterator. Reading items is destructive, so doing a len won't work, aye. Most of the time a for/else will work -- I'll look in more detail tonight :)\n. yah, bleh, 2-->3 thing. I think we might just have to suffer :(\n. hum, this one sucks. ack'd.\n. +1; filing a bug. Thanks, @jd :)\n. so, forgive me here -- but what's that s'posed to do? :)\nIt seems like some (e.g. Clojure ;) ) don't let you do this (it'd fail with requires-even-number-of-forms type thing)\n. @jd added a trivial little bump there; those tests cover oodles.\n. masta-merged, thanks, @jd !\n. Killer work, @agentultra ! :sparkles: \n. Tests still failing; I've punted, will resolve and merge shortly.\n. shit all the fixes were in the merge commit.\nFuck. Oh well.\n@agentultra you can't use comas in lists in hy :) - there was no bug in assert ;)\n. Let's get native tests on this, aye.\n. Otherwise +1 good to merge\n. Merged this up, thanks, @eal -- I'm about to overhaul some compiler bits; so I'm trying to sync up with pending contributions here\n. ..... awesome\n. so awesome\n. my new :heart: bug\n. slick stuff. Let's add this to NEWS\n. Looks great, thanks, @eigenhombre !\n. 15:36 < paultag> jacobsen_: right now, those might be best implemented as Python macros (ugh, working on it) in the core/bootstrap \n15:36 < paultag> jacobsen_: they suck to write and debug, but they get the job done\nHeyya! Tests look great, and I love the direction, but adding them as macros would be better :)\nThis can compile down to slicing, etc :)\n. No problem, @eigenhombre - I appreciate the work! Using a macro is usually the answer if we already have the tools to make the operation happen, but just need some sugar :)\n. ... A good point. Let's file a bug and work that out \n. In the meantime I'll review when I get home \n. Looks great, thanks, @eigenhombre !\n. Let's put it in core -- hy.core.xxxx where xxxx is something that makes sense-ish. That whole core folder needs a stern kick.\nWe need to do the auto-import thing for them too. Might need to do that with some sort of something.\n. @eigenhombre this might actually require some small tweaks -- doing the import stuff is currently in the compiler, I'm hoping I can provide a protocol for forcing the imports in -- hang tight on this one, I'm on it.\n. This should be fixedish as #202 \n. still active, bug #205 dupe\n. (see #205 for the example)\n. nommy; assigning self\n. I'm considering this a blocker for 0.9.7.\n. +1\n. I agree. Let's make a comment on the bug and assign if you can -- github bugs suck.\nSucks it happened, but at the same time also shows how active we've become.\nLet's avoid clashes by being better at claiming bugs (all of us), and keep up the great work\n. Can we merge any code from this into what's in the tree now?\n. Minimal failure snippit on pypy:\npython\n. Minimal failure for pypy:\nclojure\n(defclass B []\n  [[x 42]\n   [y (fn [self value] (+ self.x value))]])\n. not in pypy :)\nOn Sat, Apr 27, 2013 at 2:01 PM, Julien Danjou notifications@github.comwrote:\n\n@paultag https://github.com/paultag except that it works in the CLI on\nits own :(\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/pull/157#issuecomment-17120415\n.\n\n\n:wq\n. We use functools.partial :)\nSeems to still be in Python 3 :)\nOn Wed, May 1, 2013 at 1:02 PM, khinsen notifications@github.com wrote:\n\nI just discovered that Python 3 no longer has the apply function, meaning\nthat Hy doesn't have it either when running under Python 3.\nThe rationale for removing apply was that it's no longer needed, because\nyou can use fn(*args). But we can't do that in Hy.\nHy has the builtin kwapply but that's only for keyword arguments. We\ncould make apply a builtin in just the same way. However, I'd prefer apply(and\nkwapply BTW) to be standard functions and thus first-class objects.\nAnother obvious idea is to have such stuff in kind of standard library,\nwhich reminds me of the discussion in #150https://github.com/hylang/hy/issues/150\n.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/issues/159\n.\n\n\n:wq\n. (apply) auto-imports and masks :)\nOn Wed, May 1, 2013 at 3:01 PM, khinsen notifications@github.com wrote:\n\nOK for occasional use, but it's cumbersome (extra import, longer name, one\nmore level of parentheses) and inefficient (two extra function calls plus\none object creation).\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/issues/159#issuecomment-17299491\n.\n\n\n:wq\n. um, crap. Only in my hallucinations. See #128 \n. hoodoggy. Working great; just need to read it through as a formality / get @jd to review as well (but it looks and works great so far)\n\n\n\n. What could go wrong?\n \n+1 here. @jd ?\n. (breaks the hy site) \n. diff\ndiff --git a/tests/native_tests/language.hy b/tests/native_tests/language.hy\nindex 20f4d1c..6abc96d 100644\n--- a/tests/native_tests/language.hy\n+++ b/tests/native_tests/language.hy\n@@ -648,3 +648,8 @@\n     xxx\n     (assert False))\n    (except [NameError])))\n+\n+\n+(defn test-try-except-return []\n+  \"NATIVE: test we can return from in a try except\"\n+ (assert ((fn [] (try xxx (except [NameError] (+ 1 1)))))) 2)\nwill patch when I can be bothered (shortly!)\n. s'alright, it'll be a good chance to get my hands in the new compiler stuff more -- we knew there were little bugs like this, @olasd, no big deal. We're still net bug negative on the changeset\n. grumble grumble\ntry / except is fucking huge. we also need to treat it like we treat an if / else, so that we can share the same tmpvar to store the result from, which the current code will blow up on, since try / except are compiled in their own bits.\nI'm going to refactor this to work. I'm assigning myself so I can learn the complexities in some of the new stuff better.\n. geironed :)\n. :+1: \n. Erm, Don't merge :-1: hy site's still broken. Looking into it, will update.\n. I'm an idiot, works fine, I just had master checked out.\nFuck me, right?\n. Updated to unsuck\n. SHIT. I didn't see the request for review.\nCRAP. @jd @agentultra @algernon - sorry - don't mind me. Let's hotfix any issues you find. \n100% my bad\n. negative code karma. that's what I like to see\n. Hey! Looking slick there @cndreisbach - thanks! I was thinking of doing some doc work soon, this rocks -- thanks, man!\n. still on thisish, been sick so I've not landed anything\n. I'm +1 on moving macros into the compiler more; it was part of one of the plans I started to work on before I got distracted by a shiny object. \n@olasd @jd - thoughts?\n. I've cleanroom reimplemented what I read about this and hit the same issue:\nThe output of:\nclojure\n(defmacro rev [&rest body]\n  \"Execute the `body` statements in reverse\"\n  (quasiquote (do (unquote-splice (list (reversed body))))))\nproduces:\npython\nimport hy\nhy.macros.macro(u'rev')()\nWhich is just wrong :>\nIt's my gut things aren't expanding right.\n. Erm, wrong bug. Sorry about that comment.\nI'm not rightly sure about what's going on here yet, I'm doing some Debian work tonight, but I'll evaluate this one ASAP.\nIn the meantime, the changes you suggest sound sane, I'd love to see the code :) - I totally trust your judgement\n. while this makes me think we're going to get into issues if someone passes a quoted HyDict into a Python function expecting it's actually a dict, this cleans up some code and helps us keep order.\nNot thrilled about this change myself.\n. Merged against my better judgement. I'm sure it'll be fine, but we need to document this now.\n. Hurm, OK. @olasd - how are you feeling about landing this for .13?\nOn Jan 10, 2014 9:12 AM, \"Gergely Nagy\" notifications@github.com wrote:\n\nI've been using @olasd https://github.com/olasd's hycons branch for\nadderall, it's tremendously useful. It would be very hard to implement\nminiKanren without it (most other miniKanren implementations on platforms\nwithout cons, emulate it)\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/issues/183#issuecomment-32029867\n.\n. Looks like the right thing (tm) - just playing around with a few things; but :+1: will merge in about a minute\n. This one is going to be a pain in the ass\n. That sounds perfectly reasonable to me. @jd / @olasd ? I'll get on reviewing this\n. Clever. Very clever. You mentioned this has a precedent, @khinsen? Mind linking me to the docs for some of it (actually just interested, I'll likely merge this after a quick @jd / @olasd signoff that we're not doing something that breaks internals)\n. This seems like thrilling stuff; can I get a @jd comment on this?\n. Throw caution to the wind! Thanks, @khinsen !\n. Yes. I agree with @khinsen \n. Slick, thanks @khinsen \n. I suck at spelling, thanks @thomasballinger :D\n. great idea, let's just fix up the tests, +1 @olasd \n. I'mma closing this, I think it's fixed in git. Sorry for not merging sooner :(\n. I like this kludge\n. @olasd although that's just for \\x right?\n. ```\n\n\nprint \"\\a\"\nprint \"\\b\"\nprint \"\\f\"\nprint \"\\n\"\nprint \"\\r\"\nprint \"\\t\"\nprint \"\\v\"\n\n\n\n```\n. merge me merge me merge me merge me merge me \n. \\o/ - thanks homies \n. Looks great, thanks @rahmu ! :+1: \n. @jd can I get an ACK? I see you moved them to the travis setup - was it because it was broked on Py 3?\n. Thanks, @rwtolbert :)\n. I'm for it, so long as we allow for using it later as unquote - which is something Clojure ditches for a different operator, but always sorta \"got\" the comma\n@olasd - can we make this work in parser 2.0?\n. I'm tempted to just have this live in another repo - that way we can grow it as we need it (for some future nrepl type thing (see #8)) - thoughts, @jd / @olasd ?\n. (wrong button)\n. @rahmu the idea is to build up a stdlib of common Lisp-ey functions (properly handling apply, and friends) that will be auto-imported when they're used up at the top to make it slightly easier on the hacker.\nI might also implement linked lists somehow, so that cons car and cdr can be used in a more traditional way.\nIt's going to be light - I don't want to end up with a clojure startup time dent :)\n. Patch to make this work better IRL following - along with a purge of most\nof our macros (hacking around it now)\nOn Sun, Jun 23, 2013 at 3:52 PM, Julien Danjou notifications@github.comwrote:\n\nLGTM\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/pull/202#issuecomment-19879964\n.\n\n\n:wq\n. Added auto-import bits. This is just so much magic, but we'll be able to get rid of most of the macros. Incoming.\n. d'oh, swaped. thanks @rwtolbert !\n. ok, someone merge me, I'm hands off\n. @rwtolbert do you have an example where this drop would fail?\n=> (.join \"\" (drop 2 \"Hello, World\")))\nu'llo, World'\n. @rwtolbert drop3 is almost how I implemented this and looks right. I can merge that with this PR if you're cool with that\n. Ah, right :thumbsup: - let's use drop3 - are you OK with me taking it into Hy? (I see you've licensed it nicely)\n. Bwaaahahahah I just got that.  A+ work\nOn Jun 25, 2013 8:07 AM, \"rwtolbert\" notifications@github.com wrote:\n\nOh, i don't care about the license. I'd just like it if you can get your\nstuff in, then I can add to it if that's ok.\nKind of bummed no one liked the name.\nI thought \"hyroad.take\" (or hy.road.take) was kind of cute.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/pull/202#issuecomment-19971479\n.\n. needs ack + merge plox (@jd / @olasd)\n. Force-pushed like a goon. @jd @olasd \n. re setup.py, perhaps; I prefer using requirements.txt; but we can see about getting it added\n\nas for loading; yeah. You're likely right. I just didn't want to have some subtle bug where the stdlib wasn't reloaded if we cached the Compiler object to prevent creating a bunch, but that seems more and more unlikely as we move on.\nI'll see about moving it\n. Thanks, @Foxboron !\n. dupe of bug #151\n. It worked on my machine - I bet the namespace object was a dict at one\npoint. Let's add juju for this - can we setitem on both?\nOn Jun 24, 2013 7:03 PM, \"Morten Linderud\" notifications@github.com wrote:\n\nwoooppss. My code. I will take a look at it!\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/issues/206#issuecomment-19942366\n.\n. also add tests as penitence\nOn Jun 24, 2013 7:07 PM, paultag@gmail.com wrote:\nIt worked on my machine - I bet the namespace object was a dict at one\npoint. Let's add juju for this - can we setitem on both?\nOn Jun 24, 2013 7:03 PM, \"Morten Linderud\" notifications@github.com\nwrote:\n\nwoooppss. My code. I will take a look at it!\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/issues/206#issuecomment-19942366\n.\n. Merged to master, can we ACK the fix again?\n. Since we always try to evaluate lists, use an empty vector for now - this is still a valid bug\n. Why not [] - they're the same\nOn Jun 25, 2013 9:02 AM, \"rwtolbert\" notifications@github.com wrote:\n\nI resorted to using (list) as an empty list.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/issues/207#issuecomment-19974146\n.\n. Merged away, since this fixes already upgefucked code.\n. Stunning stuff, thank you @oubiwann !\n\n\n. Looks like really promising stuff - some questions:\nclojure\n(for [x (cons (cons 1 2) (cons 2 3))] (print x))\n(1 . 2)\nisn't exactly what I'd expect - same with \nclojure\n(list (cons (cons 1 2) (cons 2 3)))\n[(1 . 2)]\nIs the idea that we just can't interop with a (cons)'d list?\n. Did we reach consensus? \n. Closing until we get a snazzy v2.0 impl\n. Could you also add yourself to AUTHORS?\n. Looks stunning to me. ACK.\n@jd @olasd - can one of you ACK too and merge? Simple change. S'nice.\n. I suggest the following diff however (when someone merges it, just batch this after):\npatch\ndiff --git a/hy/macros.py b/hy/macros.py\nindex b824cea..2c5bc02 100644\n--- a/hy/macros.py\n+++ b/hy/macros.py\n@@ -72,7 +72,7 @@ def process(tree, module_name):\n     if isinstance(tree, HyExpression):\n         if tree == []:\n             return tree\n-        \n+\n         fn = tree[0]\n         if fn in (\"quote\", \"quasiquote\"):\n             return tree\n. This PR looks like a great idea, sorry about not having supported Windows, most of the core-dev team are also Debian-folk.\nOne note - perhaps we can have one switch where we just do a:\nPython\ntry:\n    import readline\n    # other readline kruft here\nexcept ImportError:\n    pass\nSince you can have a GNU/Linux install without GNU Readline installed.\nWould you be willing to patch this up?\n:+1: thank you, you rock!\n. Me too, thanks @rwtolbert !\n. Yep. I think it's because the importer will set the module to None before loading, in the case of a recusive import - we should catch an exception and pop that guy off.\nValid bug for sure, thumbs up. Thank you!\n. rebased should be fine\n. Fscking PITA merge conflict.\nSomeone merge this after I fix it again\n. ARE YOU CHRISTING KIDDING ME.\nMerge conflict again. This is annoying.\n. that's right @algernon - and I never did trust any sandboxing. I'd much rather disable that entirely, preventing stuff like infinite loops is just a huge hack (P=NP / halting problem to solve it right).\nIt's not the best solution, but meh. Perhaps we can allow python -m hy.nrepl or something, and let the web UI hook into the local nrepl instance to run commands. Might be a good motivation to fix #8 \n. google appengine has a sandbox that prevents any real damage :)\nOn Wed, Dec 18, 2013 at 5:40 PM, Joe H. Rahme notifications@github.comwrote:\n\nHow does try-hy deal with this issue?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/issues/217#issuecomment-30888531\n.\n\n\n:wq\n. Looks fantastic! Thank you so much, @tuturto! Really appreciate it!\n. Hummmm.\nAn interesting question, this.\n. Love the work, keep it up, thank you!!\n. Nice points, @rahmu, thank you!\n. Yeah. Getting them rebased would be nice, and since it's in a different folder, it ought to do it without trouble.\nI'm fine with the history being so long, it reflects reality, in a sense :)\n. Nah, just force push it up to the same branch (cringe) and it'll update this\n. Fantastic, thank you @tuturto !! You rock!\n. @olasd - this will affect your rply branch. Can we sync up approaches here?\n. Right, so.\n@rwtolbert - cl arg handling has ACK. Let's hold off on getting huge code changes in a few days before release; I'm shooting for Saturday night or Sunday. Let's make 0.9.10 support windows first class.\n@Foxboron - Issue #214 has ack. I'm tempted to block release on this one. Let's tighten up with Python's behavior here.\n@Willyfrog - No problem. That kwapply bug is nasty, I'm a bit afraid to mutate strings. Symbols are OK, but strings slightly concern me.\nRight.Go team.\n. Looks good so far - mind changing the raise e to just raise? Style :)\n. Are you sure this fixes it?\nfoo.hy is set to:\n(print \"Foo\"\nAnd, I ran a session\n(hy)[tag@leliel:~/dev/local/hy][pr/225]$ hy;\nhy 0.9.8\n=> (import foo)\nTraceback (most recent call last):\n  File \"<console>\", line 1, in <module>\n  File \"/home/tag/dev/local/hy/hy/importer.py\", line 172, in load_module\n    self.path)\n  File \"/home/tag/dev/local/hy/hy/importer.py\", line 73, in import_file_to_module\n    _ast = import_file_to_ast(fpath, module_name)\n  File \"/home/tag/dev/local/hy/hy/importer.py\", line 66, in import_file_to_ast\n    return hy_compile(import_file_to_hst(fpath), module_name)\n  File \"/home/tag/dev/local/hy/hy/importer.py\", line 56, in import_file_to_hst\n    return import_buffer_to_hst(f.read())\n  File \"/home/tag/dev/local/hy/hy/importer.py\", line 50, in import_buffer_to_hst\n    return tokenize(buf + \"\\n\")\n  File \"/home/tag/dev/local/hy/hy/lex/__init__.py\", line 32, in tokenize\n    raise LexException(\"Incomplete Lex.\")\nLexException: Incomplete Lex.\nfoo.hy was edited to be:\n(print \"Foo\")\nRe-run in the existing REPL:\n=> (import foo)\nTraceback (most recent call last):\n  File \"<console>\", line 1, in <module>\nImportError: No module named foo\n=>\nBut, when I cycle the importer without changing foo.hy\n(hy)[tag@leliel:~/dev/local/hy][pr/225]$ hy;\nhy 0.9.8\n=> (import foo)\nFoo\n=>\n. LGTM; can I get an ack and merge @olasd?\n. Merged, thanks @ralph-moeritz !\n. It actually might be thrilling if we kill two birds here; I wonder if we can't work out a method of calling that allows keywords to be used to apply arguments to code.\nAs example, something like:\nClojure\n(#.foo :foo bar :baz foo)\nWhich would translate to:\nPython\nfoo(foo=bar, baz=foo)\nI don't like the #. though.\n. This PR has my ACK\n. Erm, unacked.\nTrying this locally for a while - hy foo broke and put me in a REPL\n. This has my ACK again. Can someone do final review and merge please?\n. (looking at @hylang / @hylang/core)\n. +1 @rwtolbert \nsploosh to this PR\n. we broke things.\n. \nNo wait, it's merged!!\n\n. See #270 - reverted the push (sorry history)\nre-opening.\n. I can't re-open. What the dick github\n. Re-merged. My bad y'all.\n. If you try it through hy2py, it turns into\nPython\nprint u'hello'\n(False and True)\n(Which, frankly, I don't see as bad)\nDue to Python's distinction between expr and stmt. It's just a side-effect, and the fact it stops at the first isn't really that important.\nWe can wrap it in a function or something if we need to, but I'm not totally convinced it's needed yet.\n. so print function won't solve the general problem with stmts in an expr place in the Python AST.\nhy2py can be run by invoking ./bin/hy2py file.hy in place in the git repo :)\n. There's nothing we can do about changed behavior - it's like saying there's an issue because two bits of Python code act differently on 2.x to 3.x, it's just a fact of  Python life :)\nWe need to take the Pythonic \"We're all consenting adults\" approach and trust the programmer can make sound decisions that work for their usecase :)\nWe make small accommodations (future division, etc), but on the whole, I think we can trust the programmer knows what version of Python the code is running under\n. Sure, that sounds totally cool. The major bits of work aren't so much the problem, since it's just invoking code in the importer, we have routines for what I've got in mind.\nSomething a bit more fancy than:\n+------------------------------------+----------------------------------------+\n| (print (if true                    | [(u'print' (u'if' u'True'              |\n|          (do (+ 1 1) true)         |   (u'do' (u'+' 1 1) u'True')           |\n|          (do (+ 2 2) false)))      |   (u'do' (u'+' 2 2) u'False')))]       |\n+------------------------------------+----------------------------------------+\n| Module(body=[                                                               |\n| If(                                                                         |\n|   test=Name(id='True', ctx=Load()),                                         |\n|   body=[                                                                    |\n|       Expr(value=BinOp(left=Num(n=1), op=Add(), right=Num(n=1))),           |\n|       Assign(targets=[Name(id='_hy_anon_var_1', ctx=Store())],              |\n|              value=Name(id='True', ctx=Load()))],                           |\n|   orelse=[Expr(value=BinOp(left=Num(n=2), op=Add(), right=Num(n=2))),       |\n|           Assign(targets=[Name(id='_hy_anon_var_1', ctx=Store())],          |\n|               value=Name(id='False', ctx=Load()))]),                        |\n|           Print(dest=None,                                                  |\n|               values=[Name(id='_hy_anon_var_1', ctx=Load())], nl=True)])    |\n+-----------------------------------------------------------------------------+\n| if True:                                                                    |\n|     (1 + 1)                                                                 |\n|     _hy_anon_var_1 = True                                                   |\n| else:                                                                       |\n|     (2 + 2)                                                                 |\n|     _hy_anon_var_1 = False                                                  |\n| print _hy_anon_var_1                                                        |\n+-----------------------------------------------------------------------------+\nwith some sort of highlighting, and being able to trace back where stuff came from (etc)\n. I'd also like a web-UI based one too, so when running from git, we can enable a feature to drop a Compiler error into a Flask server with a full report of what's going on :)\n. +1 on the whole, this is thrilling.\nUnsure about lazy-seq'ing everything. It uses a lot of memory for not much gain in a lot (i'd argue the majority of) cases, given Python it's self doesn't have such a system (or rather, it's not common to do so)\nI'm also unsure about overloading Python's filter.\nThrilling work. Really. :+1: \n. I very much ACK the cached versions of functions showing up in core. I'm mildly in favor of ^, but something a bit more sensible would be interesting.\nI summon @jd @agentultra @algernon @khinsen and all the other Lispers to comment\n. FWIW, I agree completely with @rwtolbert - I think we just need a good symbol for the warted' names, or if there's universal distate, abuse the require keyword to allow auto-importing from another lib at runtime as well.\n. Everything's lazy, we are just wondering about the \"cached\" generators, so that if you have a CPU intensive generator, you can iterate over the same values twice without additional CPU cost, like clojure. It's implemented by making an iterable out of an iterator\n. Yah, right - so now that we're all on the same page - what do you think about the suggestion to postfix with a char to denote caching. What do you think of the suggested ^?\n. slick shit, I love what I see, let's just tune up the last things :)\n. has my ack. Please merge @hylang/core \n. @hylang/core RFR\n. win!\n. Nice work! :yum: \n. @Foxboron: since we can express it in AST, we should avoid making a function for it :)\n. We talked about this out of band; I suck.\nIMHO we should implement (apply) in hy.core.language, and define (kwapply) in terms of (apply).\n. How's this guy going, @Willyfrog \n. FWIW, lambda isn't entirely redundant, since it will attempt to use a python lambda if it's able to do so, and only create a function if it needs to, whereas fn always creates a function.\nWe should clean that up.\ndef, in my mind, should create a global symbol, a-la Clojure.\nIn retrospect, not such a great idea, since we do allow (defn) inside (defn). More thought needed.\n. That'll break when you're at module level :(\nOn Aug 12, 2015 12:36 PM, \"Ryan Gonzalez\" notifications@github.com wrote:\n\nThat would also align nicely with the current usage.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/240#issuecomment-130364535.\n. Also nested defns\nOn Aug 12, 2015 12:39 PM, \"Paul R. Tagliamonte\" paultag@gmail.com wrote:\nThat'll break when you're at module level :(\nOn Aug 12, 2015 12:36 PM, \"Ryan Gonzalez\" notifications@github.com\nwrote:\n\nThat would also align nicely with the current usage.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/240#issuecomment-130364535.\n. This has my ack. @hylang/core - needs final signoff and merge\n. RFC @hylang/core \n. BTW, needs testing, I only did that one test case.\n. @rwtolbert actually - this is to not return anything when we are yielding :)\n. Oh yikes. I'll debug this.\n. 'twas a result of ast.Yield being an expr :)\n. Don't they?\n\n\nOn Sun, Jul 14, 2013 at 1:16 PM, Nicolas Dandrimont \nnotifications@github.com wrote:\n\nACK on the code. The tests could probably check that the correct stuff\ngets yielded, though.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/pull/243#issuecomment-20939768\n.\n\n\n:wq\n. Those were checking for SyntaxErrors, since that's what was crapping Py 2\nout, but yeah, I s'pose invoking them would be good too.\nOn Sun, Jul 14, 2013 at 1:19 PM, Nicolas Dandrimont \nnotifications@github.com wrote:\n\nFirst three tests don't have an assert.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/pull/243#issuecomment-20939828\n.\n\n\n:wq\n. please merge @hylang/core \n. +1\n. What's the status of this PR?\n. Did we reach consensus?\n. I'm a fan of this if we inject some code at the end that runs _main if it exists in the current module otherwise nothing (simple if  name == \"main\", etc)\nLet's get this tidied up\n. You rock!\nOn Thu, Oct 10, 2013 at 10:43 PM, Morten Linderud\nnotifications@github.comwrote:\n\nIll try do that during the weekend!\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/pull/247#issuecomment-26109935\n.\n\n\n:wq\n. poke\n. :+1: thanks! Nice bug!\n. On Sun, Jul 14, 2013 at 12:07 PM, rwtolbert notifications@github.comwrote:\n\nSorry, i was comparing this literally to assignment in Python, which does\nappear to return None.\nNot sure how to \"print x=1\" in Python\n\nYou can't in Python ;)\n\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/issues/249#issuecomment-20938576\n.\n\n\n:wq\n. :+1: from me\n. Provided there are no objections (seems that way), I'll (or @jd / @olasd - anyone with owner) should add him to the core dev team 24 hours after this bug was filed.\n:heart: \n. powers granted.\n. Slick stuff, thanks!\n. Thanks guys! \n. Generally awesome PR! I want to get this in ASAP\n. Has my ACK. Merged, thanks!\n. This crashes when you do hydoc (without an arg) with:\nPython\nTraceback (most recent call last):\n  File \"/home/tag/.virtualenvs/hy/bin/hydoc\", line 9, in <module>\n    load_entry_point('hy==0.9.10', 'console_scripts', 'hydoc')()\n  File \"/home/tag/dev/local/hy/hy/hydoc.py\", line 504, in main\n    sys.exit(hydoc(sys.argv))\n  File \"/home/tag/dev/local/hy/hy/hydoc.py\", line 482, in hydoc\n    if os.path.isfile(name) and os.path.exists(name):\n  File \"/home/tag/.virtualenvs/hy/lib/python2.7/genericpath.py\", line 29, in isfile\n    st = os.stat(path)\nTypeError: coercing to Unicode: need string or buffer, NoneType found\n. perhaps we want has CL handing here too?\n. @rwtolbert any chance we could add in @olasd's feedback for merge?\nMuch love! Miss you! :heart:\n. It's been a few months since we had any activity on this :(\nI'm going to close this for now, please do reopen it if we can get it rebased on master and stuff.\n:heart: \n. RFC @hylang/core \n. Has my +1\n. Thanks, @Willyfrog !\n. Thanks, @tuturto !\n. Has ack. Please merge @hylang/core \n. ok sync'd. I'll push docs after this push. We can build out yield-from as people need it :)\n. Gah. My fault. I was in a rush\nOn Sun, Aug 4, 2013 at 9:21 PM, Bob Tolbert notifications@github.comwrote:\n\nThis appears to be based against the wrong SHA. These diffs appear to be\nremoving the set of changes i had to add back and push last week for the\nhy/core/language.hy. An example function that got missed in that first\nmerge is (numeric? ...) and its use by many of the other functions.\nSo don't merge this until we understand that.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/pull/266#issuecomment-22083019\n.\n\n\n:wq\n. No, needs to be fixed. Bad 2 minute rebase\nOn Aug 10, 2013 12:25 AM, \"J Kenneth King\" notifications@github.com wrote:\n\nIt's also removing LambdaListKeyword and its associated test? Is that on\npurpose?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/pull/266#issuecomment-22433869\n.\n. Updated.\n. @hylang/core RFR\n. Has ACK. Please merge @hylang/core \n. Re-ping @hylang/core \n. RFR. Damnit, c'mon, anyone review and merge - @hylang/core \n. And this is why we don't use eval :)\n. @agentultra security is for loozers\n. I lied\n. gensym would be interesting to add, even if we have a better solution for this bug\n. Aye, thank you!\n. Whoh. Awesome. Smells like our rply changes. Do we frig up with \\r handling?\n. Total no brainer - let's get this in!\n. Bwahahaha, this is an awesome bug.\n\nThanks for reporting it!\nOn Tue, Aug 20, 2013 at 4:03 PM, Ivan Kozik notifications@github.comwrote:\n\nMy REPL crashed when I tried to add a big number:\nuname -a\nLinux sand4 3.8.0-27-generic #40-Ubuntu SMP Tue Jul 9 00:17:05 UTC 2013 x86_64 x86_64 x86_64 GNU/Linux\npython --version\nPython 2.7.4\n~/.local/bin/hy\nhy 0.9.10\n=> (+ 1 1000000000000000000000)\nTraceback (most recent call last):\n  File \"/home/at/.local/bin/hy\", line 9, in \n    load_entry_point('hy==0.9.10', 'console_scripts', 'hy')()\n  File \"/home/at/.local/lib/python2.7/site-packages/hy/cmdline.py\", line 263, in hy_main\n    sys.exit(cmdline_handler(\"hy\", sys.argv))\n  File \"/home/at/.local/lib/python2.7/site-packages/hy/cmdline.py\", line 258, in cmdline_handler\n    return run_repl(spy=options.spy)\n  File \"/home/at/.local/lib/python2.7/site-packages/hy/cmdline.py\", line 186, in run_repl\n    version=hy.version\n  File \"/usr/lib/python2.7/code.py\", line 243, in interact\n    more = self.push(line)\n  File \"/usr/lib/python2.7/code.py\", line 265, in push\n    more = self.runsource(source, self.filename)\n  File \"/home/at/.local/lib/python2.7/site-packages/hy/cmdline.py\", line 84, in runsource\n    tokens = tokenize(source)\n  File \"/home/at/.local/lib/python2.7/site-packages/hy/lex/init.py\", line 33, in tokenize\n    return parser.parse(lexer.lex(buf))\n  File \"/home/at/.local/lib/python2.7/site-packages/rply/parser.py\", line 22, in parse\n    current_state = self._reduce_production(t, symstack, statestack, state)\n  File \"/home/at/.local/lib/python2.7/site-packages/rply/parser.py\", line 73, in _reduce_production\n    value = p.func(targ)\n  File \"/home/at/.local/lib/python2.7/site-packages/hy/lex/parser.py\", line 52, in wrapped\n    ret = fun(p)\n  File \"/home/at/.local/lib/python2.7/site-packages/hy/lex/parser.py\", line 205, in t_identifier\n    return HyInteger(obj)\n  File \"/home/at/.local/lib/python2.7/site-packages/hy/models/integer.py\", line 32, in new\n    return super(HyInteger, cls).new(cls, number)\nOverflowError: Python int too large to convert to C long\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/issues/276\n.\n\n\n:wq\n. I like where this is going. Having it work like you describe avoids the shitty import problem I had earlier. It would also let us move some code out of the compiler (Is this still true?) which is a huge bonus.\nOne question - what if the module isn't on PYTHONPATH or so? e.g. if we had a Python module imported by filename with importlib provide some macros, what's the fully qualified name? How do we import that in the pyc generated?\nI love the direction this is going in.\n. Seems fair enough!\n. RFR @hylang/core \n. Moved the gensym symbol to a UTF reserved char.\nAdded tests.\nIgnoring threading. We have other race conditions all over the place too. If someone has a fix that won't dent perf hard, send in a PR\n. RFR @hylang/core \n. I'm filing a new bug. This isn't the only race condition we have, I'll defer this until we have a chance to audit (but I'll make such a multithread audit blocking the next release)\n. Rebased and took @Willyfrog's suggestion (Hey, thanks!)\n. I've filed the issue as #290 \nMazel tov\n. This PR is deprecated in favor of @rwtolbert 's #374 \n. Non invasive changes; just pushed it\n. Can we get @olasd's comments addressed soon?\nMuch love.\n. @olasd can you ack this makes you happy so I can review / merge?\n:heart:\n. Fucking nice idea.\n. (getattr) would work though. Just ugly.\nOn Mon, Sep 2, 2013 at 5:28 AM, Tuukka Turto notifications@github.comwrote:\n\nach, that's true. Hm.. interesting\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/issues/288#issuecomment-23649527\n.\n\n\n:wq\n. Looks great, thanks so much @kaizoku! If you want, you can join us in #hy on irc.freenode.net - welcome!\n. (Let's get @olasd 's comments addressed)\nThanks for doing this, @Foxboron !\n. It's in, Morten!\nOn Thu, Oct 10, 2013 at 10:45 PM, Morten Linderud\nnotifications@github.comwrote:\n\n@paultag https://github.com/paultag We should get @olasdhttps://github.com/olasd's\nPR changing the bootstrap.py into Hy code inn, then i'll patch this up as\nHy instead of python.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/pull/291#issuecomment-26109998\n.\n\n\n:wq\n. At one point it was intentional - so the core macros were there for the language - since I want to move more from the compiler to macros, will language work with macros in the same file? I can't remember the behavior there \n. Lgtm; can't test (remote) but seems great! Thanks so much! @hylang/core rfr\n. Sweet, thanks, @Willyfrog !\n. I hereby do declare that we change keywords to allow using them to pass kwargs to functions. If this fucks our using them in the Clojure way, that's OK. Let's get some minds on this, the hyperspec looks tennable, but I didn't spend time on it yet\nThe BDFL has spoken.\n. Crazy idea from the bar:\n(foo x=1)\nIdeas? What does this break?\n. I don't like lambda lists for this, and yeah, foo=bar is likely also a\nbad idea.\nOn Fri, Jul 18, 2014 at 2:07 AM, Gergely Nagy notifications@github.com\nwrote:\n\nEven better.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/pull/295#issuecomment-49398475.\n\n\n:wq\n. has ack. good idea!\nWe need to check it on py2.6, but if it works there, let's merge it. RFC @hylang/core \n. fuckyeah.jpg\nOutstanding work, @olasd \n. nommy, thanks all! merged in with http://hy.rtfd.org/quickstart - props, @jrabbit \n. Awesome, thanks @berkerpeksag !\n. You know what, I like this a lot.\nHas ack. @hylang/core RFR\n. Looks awesome, thanks @berkerpeksag - you rock!\nIf you're in the mood, adding virtualenvwrapper would be killer! (if not, I'll add it later :) )\n:+1: Thank you!\n. Looks awesome, thanks @berkerpeksag !\n. Looks great, thanks @sbp !\n. nom; this feature r00ls;\ntwo things:\n1. Can we get around this being a compiler builtin? Somehow my gut is telling me no, which may be fine, I'd just rather know early. I wish we had MACROEXPAND-1, so that we can expand the macro one step at a time (i,i)\n2.Unit tests would rock\nWelcome, @sbp - nice work so far!\n. No-brainer. Has ack. RFR @hylang/core \nTBH this should have been in 0.9.11; my bad. Let's tie this into 0.9.12, which means we've got to beat #325  :)\n. Yo, bronies, RFR, @hylang/core \n. How's this and #311 doing? I'm seriously interested; let's see what we can do here - @olasd - you've got some commits, do you remember offhand what's up (if not, it's cool; I need to dig in a bit)\n. I'm hugely +1, let's land this\n. @hylang/core RFR\n. Thanks y'all!\nOK. Who's got something for this release? I'll declare blockers shortly after we have a short list\nLet's do this!\n. OK, I'm releasing. Hang on folks, let me rebuild @Willyfrog 's NEWS into the repo (hey, thanks @Willyfrog !)\n. Released! Thanks to everyone who helped with this release!\n. swag\n. DUDE! Awesome!!!!!\n. (We should fix that rply thing)\n+1, @hylang/core RFR\n. We added this in a different PR I think (if not, please reopen so I can look closer :) )\n:+1: thanks for your work! :)\n. doh, my fault, I'll get on this\n. Badass, how's this going, @Willyfrog ? I'd love to see this merged soon, I'm growing to hate the kwapply I hacked up out of nowhere\n. has ack, rfr @hylang/core \n. Thanks, @berkerpeksag !\n. PR pending, thanks for the bug, @eigenhombre !\n. @willkg I agree, but this is a minor thing to change\n. LGTM; RFR @hylang/core \n. LGTM; RFR @hylang/core \n. OK. Baring valid objection, I'll add @berkerpeksag as core in 24 hours\n. welcome!\n. Sound advice! :)\n. @rcarmo totally agree, I love bpython!\nI have a post about how to do this, I need to dig up that shim code!\nNice idea!\n. This PR is the feature that we decide 0.9.12 on. This will be tied to it's release, so let's be careful with changes before this one.\n. I really want this change :)\n. Yes please. Has ack. @hylang/core please review / merge\n. (btw breaks against master, merger beware)\n. @theanalyst merge away!\n. haha, just kidding, already did this, a long time coming. Welcome!\n. http://www.youtube.com/watch?annotation_id=annotation_1512699725&feature=iv&src_vid=Eal4fep7pK4&v=l8AioTlq4dc\n. So, this happens if you don't use the shim technique that I've used for flask apps - try using a Python shim to import the app and invoke it, so it can re-eval' it and be valid Python :)\nWorth looking into better solutions to be sure\n. has ack, thanks @Willyfrog - rfr @hylang/core \n. Yeah, I think this is a good idea; I just don't think anyone verified the\nAPI is the same, and that it behaves the same way, but huge +1, let's see\nif we can get this in!\nOn Wed, Nov 20, 2013 at 11:17 PM, Abhishek L notifications@github.comwrote:\n\nHy should possibly have reduce from functools imported if runnning\npython3 by default in core?.\nAlso map in 2 and 3 differ, should we default to itertools.imap instead ?\n(And while we're at it we should possibly throw in partial as well)\nThoughts on this?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/issues/331\n.\n\n\n:wq\n. Neat, thanks, @hcarvalhoalves !\n. Awesome work, team kickass.\n. PR pending for hackers who want to test it out or ack it\n. https://github.com/hylang/hy-style-guide\n. :+1: merger, fix the flake8 issues :) - @hylang/core RFR\n. @olasd fixed, good move\n. (Added a NEWS entry. No changes other than that)\n. Hurm. What would the expected behavior be for that?\nOn Tue, Dec 3, 2013 at 3:59 AM, Henrique Carvalho Alves \nnotifications@github.com wrote:\n\nNot sure if it's a problem/possibility at that point, but will break at\nmultiple '?'.\n\n\n\ndef conv(obj):\n...   if obj.endswith(\"?\") and obj != \"?\":\n...      obj = \"is_%s\" % (obj[:-1])\n...   return obj\n...\nconv(\"foo?\")\n'is_foo'\nconv(\"foo??\")\n'is_foo?'\n\n\n\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/pull/343#issuecomment-29692966\n.\n\n\n:wq\n. (no is and two ??s?)\nOn Tue, Dec 3, 2013 at 11:55 AM, Paul R. Tagliamonte paultag@gmail.comwrote:\n\nHurm. What would the expected behavior be for that?\nOn Tue, Dec 3, 2013 at 3:59 AM, Henrique Carvalho Alves \nnotifications@github.com wrote:\n\nNot sure if it's a problem/possibility at that point, but will break at\nmultiple '?'.\n\n\n\ndef conv(obj):\n...   if obj.endswith(\"?\") and obj != \"?\":\n...      obj = \"is_%s\" % (obj[:-1])\n...   return obj\n...\nconv(\"foo?\")\n'is_foo'\nconv(\"foo??\")\n'is_foo?'\n\n\n\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/pull/343#issuecomment-29692966\n.\n\n\n:wq\n\n\n:wq\n. :+1: \n. thanks, @Willyfrog !\n. I'm just going to merge this away, it's a quick cosmetic change - send one in for docs, please!\n. :+1: thanks, @theanalyst !\n. done, thanks, I think I need to change a few things too\n-t\nOn Mon, Dec 2, 2013 at 11:44 PM, Abhishek L notifications@github.comwrote:\n\nI think the repo owner might need to login to coveralls.io and add this\nproject there\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/pull/348#issuecomment-29683335\n.\n\n\n:wq\n. Sweet, awesome, thanks @hcarvalhoalves ! Could you add yourself to AUTHORS? :)\n:+1: from me, RFR, @hylang/core \n. I just changed AUTHORS. I should have saved ack until that was done. Oh well. Thanks for your contribution, @hcarvalhoalves - feel free to send in a PR altering your entry in AUTHORs if you want :)\n. I need to take a closer look, but I'm a fan of where this is going :)\n. I don't love reimplementing our own repr. and the __hyrepr__ workaround -- I mean, I see where it's coming from, though.\nThis is a tough one.\n. (:+1: from me)\n. poke @algernon - can we get @olasd 's stuff cleaned up?\nkthx, u r0x\n. @alex no problem! I think we're all really happy we don't have to fork / maintain a fork or anything. Thanks again! :+1: \n. :+1: solid hack, thanks @alex !\n. Thanks, @alex :)\n. (and thank you @rwtolbert)\n. no effing way\n. This is awesome. I'll get on reviewing this tonight. Steller work, @lmatthieu !\n. This is great. Code changes look good. Let's get an ack, @hylang/core \n. Nice work so far!\n. It's been a few months since we had any activity on this :(\nI'm going to close this for now, please do reopen it if we can get it rebased on master and stuff.\n:heart: \n. Can you please turn this into a bug so we don't lose your code or idea?\nOn Sat, Dec 14, 2013 at 10:09 PM, Abhishek L notifications@github.comwrote:\n\nThe idea was to return the first or second form and still eval the body\nfor side effects.. something like\n(defmacro foo-timer [&rest body] `(prog2 (start-timer) (prog ~@body) (stop-timer)))\netc. But mostly this can be avoided; and it is not pure (in a functional\nsense).\nAnyway the prog1 implementation may not do what it is supposed to do\nbecause of the let block atm. (Maybe I'll try again after gensym)\n@algernon https://github.com/algernon @noprompthttps://github.com/nopromptThanks for the inputs\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/pull/370#issuecomment-30597069\n.\n\n\n:wq\n. clojure\n=> (do/profile (print \"hey there\"))\n```\nhey there\n\n         2 function calls in 0.000 seconds\nRandom listing order was used\nncalls  tottime  percall  cumtime  percall filename:lineno(function)\n        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}\n        1    0.000    0.000    0.000    0.000 {print}\n=> \n```\n. Hurm, I mean, it is cprofile. I wonder if we shouldn't just move this into\na contrib module as profile\nOn Dec 22, 2013 11:22 PM, \"Abhishek L\" notifications@github.com wrote:\n\n+1 for hyprofile\nOn Mon, Dec 23, 2013 at 2:26 AM, Bob Tolbert notifications@github.comwrote:\n\nactually, hyprofile isn't a terrible name either.\n\u2014\nReply to this email directly or view it on GitHub<\nhttps://github.com/hylang/hy/pull/371#issuecomment-31095749>\n.\n\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/pull/371#issuecomment-31103839\n.\n. I'll do that in a scitch. Sorry\n\nOn Fri, Dec 27, 2013 at 3:13 PM, Bob Tolbert notifications@github.comwrote:\n\nAny more thoughts on moving to a contrib module?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/pull/371#issuecomment-31278150\n.\n\n\n:wq\n. Moved into a contrib module. Added let and gensym.\n. word. this should be an easyish fix\n. Yeah, this guy is going to be a patches welcome situation - I don't know about a few core things:\n- Will if no longer compile to ast.If, if PyObject_IsTrue  isn't DTRT. What will we use? hy.core.lang.if ? I don't want to get back into function-call-a-paloza, double so when our LoL is broken because of scoping in Python\n- What happens if you give a Truethey 0 to Python? Should something I think is True be evaluated to False by Python?\nAnyway. I'm going to close this because it's really hard, and gives us only a slight gain. If you come up with a brilliant way, I'd love to consider it.\n:heart:\n. I don't hate it entirely. I think an if macro may solve some of this, but I'm still not absolutely sure. I'm going to need more @hylang/core on this\n. Dayum, this thread fired up.\n\nlanguage who's designer did not think for more than a second about the consequences of 0 having false semantics\n\nI re-opened the bug, didn't I?\nI'm still with @olasd and @khinsen here - what's the usecase?\n. Alright debate has gone on long enough.\nThere are 2 ways to fix this, that I can see.\nFirst is to shadow if, and to add a hy core function that tests if the\nfunction is not either False or None.\nSecond is to create a new function (something like truth?) that you can use\nin filter and friends. We can talk about adding if-truth? as well.\nOur official stance, unless I find a way to convince myself otherwise\n(which I might, but I don't think I will)\nWe're going to go with the second. I don't think the gain in syntax clarity\n(which I think there is) is worth fighting Python over.\nLet's get a PR including truth? and is-truth? (or whatever we'll call that)\nin soon.\nOn Thu, Dec 19, 2013 at 10:11 AM, Coaldust notifications@github.com wrote:\n\nHy's current behavior is the correct behavior. I'm stating this as a fact,\nrather than a opinion, because making the suggested change will cause bugs.\nA careless reading of the proposal makes it seem reasonable. Indeed,\ntreating 0 and empty containers as a boolean value is wrong. Doing this\nleads to bugs, as can be seen frequently in C-syntaxed languages where \"=\"\nis accidentally used in a \"if\" statement. That's why some modern\nprogramming languages have a real boolean type, and do not automatically\nconvert nonsense into boolean values. Popular programming languages that\nget this right include C# and Java.\nA careful reading reveals that the author actually wants 0 and empty\ncontainers to be treated as True, because some other Lisps made this\nmistake.\nSo the proposal suggests replacing bad Python semantics with bad Lisp\nsemantics. Note that I consider both to be bad semantics for reasons\nI've already stated. If I had my way, and it didn't result in overhead and\nweird looking code from hy2py (which it would), a exception would be thrown\nany time a test expression resulted in a type that was not \"bool\". It\nwould, in fact, be possible to do this.\nThe reason changing Hy's current behavior is \"wrong\" is that Hy code may\nbe called by Python programmers who do not know the code was written in Hy.\nThese Python programmers will expect None 0 and empty containers to be\nconsidered False. Making use of the fact that non-existent and empty\ncontainers are considered False is unfortunately encouraged by the Python\ncommunity. In other words, the bad Python semantics are often depended\nupon.\nBeing able to use Hy code 'invisibly' is a large part of its appeal. It is\na 'stealth Lisp'. I realize \"a transpiler for s-expressions into Python\"\nwas meant to be disparaging, but Hy should wear the label proudly.\nA Python programmer doesn't have to go through any effort at all to use\ncode written in Hy. They just import it and call it as if it was all\nwritten in Python.\nhy2py can even generate very readable Python code that, with minor\ntweaking, you could pass off as hand-written in a workplace that forbid the\nuse of any programming language but Python. At least you could avoid\nwriting lots of boilerplate and \"design patterns\" that macros can automate.\nThis creates the opportunity to use it in the workplace. It could\nresurrect the, seemingly extinct, Lisp job.\nOf course if Hy not replicating every last aspect of Common Lisp or\nScheme, even the bad parts, really infuriates you, you can always use\nmacros to re-implement them on top of Hy. Racket has used macros to embed a\nstatically type checked Lisp, after all.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/issues/373#issuecomment-30935726\n.\n\n\n:wq\n. if-truth? *\n. Great work so far, let's hack!\n. @rwtolbert no problem; literal kwargs use a utf char as a prefix not the literal \":\" :)\nLet me take a look here.\n. :+1: nice work, thanks!\n. mad love, thanks @sigmavirus24 \n. LGTM, :+1: - RFR @hylang/core \n. Sweet. Let's call this a blocker for 0.9.12\nOn Dec 17, 2013 8:53 AM, \"Morten Linderud\" notifications@github.com wrote:\n\n=> (defreader ^ expr)=> #^\"hy\"hy=> #^'(1 2)('quote' (1 2))=> #^(1 2)(1 2)=> #^(+ 1 2)('+' 1 2)=> #^{\"a\" 1}{'a' 1}=> #^[1 2 3][1 2 3]=> #^(+ (- 1 2) 4)('+' ('-' 1 2) 4)\n@garyposter https://github.com/garyposter quite happy myself. Just need\nto refactor some code and get some error handling in place.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/pull/377#issuecomment-30751969\n.\n. Let's fix travis and get this merged - https://travis-ci.org/hylang/hy/builds/15821201 - code changes look good to me\n. fixxxxxxxxx eeeeeetttttttttttttt\n\nOn Sun, Dec 22, 2013 at 1:24 PM, Morten Linderud\nnotifications@github.comwrote:\n\nwell, i tried to fix the first flake error, but he didn't like my fix\neither. So meeehhh\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/pull/377#issuecomment-31092695\n.\n\n\n:wq\n. Awesome work, team!\nOn Dec 23, 2013 9:25 AM, \"Nicolas Dandrimont\" notifications@github.com\nwrote:\n\nOutstanding stuff!\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/pull/377#issuecomment-31121449\n.\n. Please keep using requests, it's much better :)\n\nOn Wed, Dec 18, 2013 at 11:34 AM, Berker Peksag notifications@github.comwrote:\n\nGood point. I will use httplib (and probably will rewrite the script in\nHy).\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/pull/379#issuecomment-30856866\n.\n\n\n:wq\n. Yep, it's good.\nI'm just going to merge this. Thanks!\n. :+1: thanks! This looks like a good ole' fashion compiler issue :)\n. So, before we do this, which I'm for - how can we represent *foo* in Python? Right now, this change will turn *foo* into foo -- that's not great. Let's find a better way to represent *foo*, but this is good stuff so far\n. @Coaldust I don't think having foo and *foo* being the same symbol is all that intuitive. I'd rather us do something that makes sense here.\n. Did we ever figure out what existing foo code becomes for interop?\nOn Aug 5, 2015 5:40 AM, \"Gergely Nagy\" notifications@github.com wrote:\n\nAight, I'll merge this ~tomorrow, as is (after fixing up the conflicts).\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/pull/383#issuecomment-127935656.\n. So foo and foo will clash?\n\nI'm still not sure I care enough to fix this, but if we have to, make sure\nearmufs are safe from massive breakage.\nOn Aug 5, 2015 7:48 AM, \"Gergely Nagy\" notifications@github.com wrote:\n\nfoo will have the earmuffs stripped, judging by the code. It shoud\nlikely become a global with earmuffs stripped, if I understand the docs\ncorrectly.\nOn the other hand, looking at this and #378\nhttps://github.com/hylang/hy/issues/378, I'm not so sure we want this.\nWe're Hy, not some-other-lisp. And there's nothing terribly wrong with the\nearmuffs...\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/pull/383#issuecomment-127969742.\n. Kickass work, team\n\nOn Sat, Dec 21, 2013 at 11:58 AM, Emre Y\u0131lmaz notifications@github.comwrote:\n\n[image: :+1:]\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/pull/384#issuecomment-31067054\n.\n\n\n:wq\n. :+1: lgtm, let's get this in!\n. nice work, thanks :)\nOn Sun, Dec 22, 2013 at 1:28 PM, Berker Peksag notifications@github.comwrote:\n\nI've also changed the version to 0.9.12.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/pull/386#issuecomment-31092776\n.\n\n\n:wq\n. :+1: LGTM! gogoog, @hylang/core !\n. Is there any way we can feed compiler exceptions in as well? I get this with (for) (old-style error)\n=> (for)\nTraceback (most recent call last):\n  File \"/home/tag/dev/local/hy/hy/compiler.py\", line 1960, in hy_compile\n    result = compiler.compile(tree)\n  File \"/home/tag/dev/local/hy/hy/compiler.py\", line 467, in compile\n    ret = self.compile_atom(_type, tree)\n  File \"/home/tag/dev/local/hy/hy/compiler.py\", line 458, in compile_atom\n    ret = _compile_table[atom_type](self, atom)\n  File \"/home/tag/dev/local/hy/hy/compiler.py\", line 613, in compile_raw_list\n    ret = self._compile_branch(entries)\n  File \"/home/tag/dev/local/hy/hy/compiler.py\", line 498, in _compile_branch\n    return _branch(self.compile(expr) for expr in exprs)\n  File \"/home/tag/dev/local/hy/hy/compiler.py\", line 358, in _branch\n    results = list(results)\n  File \"/home/tag/dev/local/hy/hy/compiler.py\", line 498, in <genexpr>\n    return _branch(self.compile(expr) for expr in exprs)\n  File \"/home/tag/dev/local/hy/hy/compiler.py\", line 479, in compile\n    raise HyCompileError(e, sys.exc_info()[2])\nHyCompileError: Internal Compiler Bug \n\u2937 TypeError: _hy_anon_fn_1() takes at least 1 argument (0 given)\nCompilation traceback:\nFile \"/home/tag/dev/local/hy/hy/compiler.py\", line 465, in compile\n    tree = macroexpand(tree, self.module_name)\n  File \"/home/tag/dev/local/hy/hy/macros.py\", line 173, in macroexpand\n    tree = macroexpand_1(tree, module_name)\n  File \"/home/tag/dev/local/hy/hy/macros.py\", line 195, in macroexpand_1\n    obj = _wrap_value(m(*ntree[1:]))\n=>\nThis PR is the most amazing thing ever.\n. All changes have ack. Causing a conflict, but that's not a grave one. +1\n. No problem, we're all to blame :-)\nWe should add more tearing next time\nOn Dec 23, 2013 6:39 PM, \"Guillermo Vay\u00e1\" notifications@github.com wrote:\n\nLGTM so far\nSorry to introduce such a big bug :( I should be more careful and test\nmore.\nThank you @olasd https://github.com/olasd for the fix.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/pull/391#issuecomment-31150510\n.\n. Testing*\nOn Dec 23, 2013 6:40 PM, \"Paul R. Tagliamonte\" paultag@gmail.com wrote:\nNo problem, we're all to blame :-)\nWe should add more tearing next time\nOn Dec 23, 2013 6:39 PM, \"Guillermo Vay\u00e1\" notifications@github.com\nwrote:\n\nLGTM so far\nSorry to introduce such a big bug :( I should be more careful and test\nmore.\nThank you @olasd https://github.com/olasd for the fix.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/pull/391#issuecomment-31150510\n.\n. Requesting review from @agentultra \n. Merged against master.\n. RFR, I'm cool with ap-if, since I lifted the name from aif in the canonical anaphoric docz\n. slick change. I'm all over this. LGTM\n. send a PR adding nil\n\n\nOn Fri, Dec 27, 2013 at 3:16 PM, Joel Holdbrooks\nnotifications@github.comwrote:\n\nNone being equivalent to nil makes sense.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/issues/394#issuecomment-31278293\n.\n\n\n:wq\n. LGTM, let's phase out null\n. but good instinct\nOn Fri, Dec 27, 2013 at 4:11 PM, Bob Tolbert notifications@github.comwrote:\n\nwant me to replace all uses of null with nil before we merge this?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/pull/395#issuecomment-31280267\n.\n\n\n:wq\n. let's hold off on that until 0.10, where we can make a few breaking changes\nat once\nOn Fri, Dec 27, 2013 at 4:11 PM, Bob Tolbert notifications@github.comwrote:\n\nwant me to replace all uses of null with nil before we merge this?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/pull/395#issuecomment-31280267\n.\n\n\n:wq\n. needs merge, please review @hylang/core \n. Nice work.\n. Slck. Looks good, but I can't get py3.4 in a virtualenv again, something\nbroke - I'll try again for a review, but needs more eyes, @hylang/core\nOn Sun, Dec 29, 2013 at 6:11 AM, Coveralls notifications@github.com wrote:\n\n[image: Coverage Status] https://coveralls.io/builds/407391\nCoverage remained the same when pulling 8120a25\nhttps://github.com/hylang/hy/commit/8120a25c0822598c9ed974562f068a94b0097ace\non berkerpeksag:wr_long into f189f0a\nhttps://github.com/hylang/hy/commit/f189f0a45774692b284069b9adb1651ea2ac7805\non hylang:master.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/pull/397#issuecomment-31315252\n.\n\n\n:wq\n. I have more 3.4 changes on my repo. Something's up with ast.arg.\n. I've just filed up for #410 based on this\n. I hit this this morning and realized that i'd fucked up and told @Foxboron to do the wrong thing.\nI've sent in a PR to fix some of this, basically (for) will match Clojure's, and (with) will behave like (import) sorta.\n. #406 linked\n. (BTW, this doesn't remove the nesting, that's key, it just doesn't add syntax for it)\n. done\n. Total no-brainer. Thanks!\n. (kickass work, I love the docs)\n. @theanalyst the answer to should we add docs is literally always yes :)\nSend in a PR!\n. Nice! Has ack (currently working on something or I'd merge it)\n. Thanks to @rwtolbert for inspiring me. I'll add some diagrams in a skitch.\n. BTW; for reviewers - the breakage in nose is going on because of some tragic encoding stuff. When I run hy2py by hand, it works fine, so I think it's a bug in nose. I'll look at it more later.\n. (but fine to merge, sine 3.4 is beta anyway)\n. P.S., 3.4 support before it releases?\n\n. \n. More gross merges and hacked code.\n\n. killer work\n. ```\nmuch travis fail \n                very `HyMacroExpansionError: `bar' takes exactly 2 arguments (0 given)`\n\n```\n. \n. \n. has ack\n. I sent in a PR as #429 - thanks, @youngsu999 \n. Should work in git master. Thanks, @youngsu999 !\n. Has ack. Simple builtin, looks tight. Nice work, as always @olasd \n:shipit:, die getattr, die!\n. This is amazing. Reviewing now\n. Has ack so hard\n. you rule\n. Fuck it, let's core it. Looks clean and is a big step up. Someone merge\nthis PR and send in another promoting it\nOn Jan 10, 2014 9:31 AM, \"Clinton N. Dreisbach\" notifications@github.com\nwrote:\n\n@rwtolbert https://github.com/rwtolbert @algernonhttps://github.com/algernonThat's a good question. I'm not sure how the Hy team prefers to introduce\nnew language features. I made it contrib, assuming that people could try it\nout and if the core team felt like it, they'd pull it into core in a rev or\ntwo, after it became a bit more polished.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/pull/424#issuecomment-32031373\n.\n. That's OK, it's experimental. This is also breaking pypy. Looking into it.\n. \n. I'm also mildly :+1: provided that we fix it.\n. As a result, I'll mildly merge this.\n. \n. \n. Nommmm. Thanks, Clinton!\n\nOn Sat, Jan 11, 2014 at 11:31 PM, Clinton N. Dreisbach \nnotifications@github.com wrote:\n\nWhile adding docs around a Hy subtlety (dashes and underscores being\nequivalent in symbols), I noticed that unquote and unquote-splice did not\nhave documentation. Now they do!\nYou can merge this Pull Request by running\ngit pull https://github.com/cndreisbach/hy doc-improvements\nOr view, comment on, or merge it at:\nhttps://github.com/hylang/hy/pull/430\nCommit Summary\n- Add note about underscore/dash shadowing\n- Added docs for unquote and unquote-splice\nFile Changes\n- M docs/language/api.rsthttps://github.com/hylang/hy/pull/430/files#diff-0(40)\nPatch Links:\n- https://github.com/hylang/hy/pull/430.patch\n- https://github.com/hylang/hy/pull/430.diff\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/pull/430\n.\n\n\n:wq\n. hilariously, car is still a macro, but that needs to die soonish\n. Always import core stuff at the top of any compile session, and move it out of the expression compile?\n. IDEAS WE NEED IDEAS\n. +1's, -1's? @hylang/core \n. Added to core. Welcome!\n. @cndreisbach welcome! Feel free to read over the core-dev guidelines over on the docs - thanks for your work so far, killer stuff!\n. (any hy2py showed no for)\nOn Sun, Jan 12, 2014 at 6:19 PM, Brandon Hsiao notifications@github.comwrote:\n\nThe following looks like it should work:\n(defmacro ret-if-not &rest body)\nUnfortunately, this gives me the following error:\nHyMacroExpansionError: `ret_if_not' name 'pair' is not defined\nI think it's a problem with for, since there's no reason pair shouldn't be\ndefined when it's in the wrapping for.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/issues/436\n.\n\n\n:wq\n. mad clown love @cndreisbach\n. :D\nOn Sun, Jan 12, 2014 at 6:55 PM, Coveralls notifications@github.com wrote:\n\n[image: Coverage Status] https://coveralls.io/builds/435535\nCoverage remained the same when pulling 0afbbeb\nhttps://github.com/hylang/hy/commit/0afbbeb68c88215fc440a0d3f8723f6070f6f658\non paultag:paultag/feature/more-tco into 47d67b0\nhttps://github.com/hylang/hy/commit/47d67b006293a3cdec7e0572200f9221f147b2c8\non hylang:master.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/pull/437#issuecomment-32138637\n.\n\n\n:wq\n. @olasd @cndreisbach - I refactored (loop) to use a (fnr) (fewer lines), can I haz ack? - I also changed to use a decorator (thanks @olasd)\n. @hylang/core can I haz review + merge?\n. Slick look. Nice refactor. Was going to suggest that if you didn't manage to do it (should have known)\nHas ACK. Nice work.\n. Someone merge the damn thing :)\nOn Jan 16, 2014 5:45 AM, \"Gergely Nagy\" notifications@github.com wrote:\n\nLooks sweet. [image: :+1:]\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/pull/448#issuecomment-32458477\n.\n. Ye. I'll do this tonightish \n. Sick. Thanks!\n. God I suck. OK. We should get on this like soon. Release window is open, I'm going to close and tag in a week or so if there's not much more on this.\n\nGOGOGOGOOGOG!\n. Looks good. It feels wrong on some level, I can't describe it. I'll chalk it up to the code smell.\nIt's totally understandable, since we're kinda bolting this on, and I can't point to anything as being 'wrong'.\nBottom line: cons is good. Let's do that. This is top grade work, +1. LGTM. RFR @hylang/core \n. OK, I'll give this a stress test (although algernon did this already) and\nmerge it tonight.\nOn Thu, Jan 30, 2014 at 8:34 AM, Abhishek L notifications@github.comwrote:\n\nLGTM, Top class work as always\n\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/pull/471#issuecomment-33687706\n.\n\n\n:wq\n. On my phone, sorry this will be brief,\nlambda will turn into a Python iff the lambda expression only has one expression in it.\nIf there is one statement, or has a body of more than one, it'll become a ast.Function and replace the expression with a ref to the function (something like hy_anon_fn_0001)\nThat answer your question?\n. Ugh, fails on Python 2, fucking cavemen. Let me port it to py2. Uch.\n. stupid python2 if-python2 added. cavemen, murmer murmer.\n. uhhhh, it broke 3.2. Wat. OK. I'll come back to this in a hot sec.\n. I think it's OK now. waiting for tox and friends:\n\n. Goddamnit flake8\n. Sorry there are two patches in here, but flake8 changed from under us (fair enough)\n. (should be clear in a sec, I hope)\n. Woooo. RFR @hylang/core \n. Just as a snippit what is the normal usage pattern? Seems like casual\nhackers might use it twice\nOn Jan 29, 2014 9:22 AM, \"J Kenneth King\" notifications@github.com wrote:\n\nThank Python.\nYou'll need to test specifically for (and (not (= 0)) (not False)) if you\ncare about parsing numbers.\nOn Jan 29, 2014, at 1:28 AM, Nicolas Dandrimont notifications@github.com\nwrote:\n\n(integer-char? \"0\") will eval to False in boolean contexts?\n\nReply to this email directly or view it on GitHub.\n\n\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/pull/481#issuecomment-33588036\n.\n. Ah, I see!\n\nOn Wed, Jan 29, 2014 at 9:40 AM, J Kenneth King notifications@github.comwrote:\n\nminus the extra brackets... on integer-char?\nOn Jan 29, 2014, at 9:39 AM, James King james@agentultra.com wrote:\n\nWhen writing parser combinators, a typical token parser for integers:\n(defun int? )\nIs a pretty straight-forward example. Anywhere you'd want to parse\nintegers out of a string.\nhttp://clhs.lisp.se/Body/f_digi_1.htm\nOn Jan 29, 2014, at 9:25 AM, Paul Tagliamonte notifications@github.com\nwrote:\n\nJust as a snippit what is the normal usage pattern? Seems like casual\nhackers might use it twice\nOn Jan 29, 2014 9:22 AM, \"J Kenneth King\" notifications@github.com\nwrote:\n\nThank Python.\nYou'll need to test specifically for (and (not (= 0)) (not False)) if\nyou\ncare about parsing numbers.\nOn Jan 29, 2014, at 1:28 AM, Nicolas Dandrimont \nnotifications@github.com\nwrote:\n\n(integer-char? \"0\") will eval to False in boolean contexts?\n\nReply to this email directly or view it on GitHub.\n\n\nReply to this email directly or view it on GitHub<\nhttps://github.com/hylang/hy/pull/481#issuecomment-33588036>\n.\n\nReply to this email directly or view it on GitHub.\n\n\n\n\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/pull/481#issuecomment-33589654\n.\n\n\n:wq\n. @hylang/core what's consensus on this?\n. Hey there @halitalptekin ! Thanks for this patch! Looks great! I'll give it a review soon (as will others from @hylang/core)\nCould you also add yourself to AUTHORS ? (we have other one-line-change folks in there too, but it's how we like it :) )\n. Not a huge deal! :)\nOn Jan 30, 2014 9:27 AM, \"Halit Alptekin\" notifications@github.com wrote:\n\nHey, sorry for that. I will be more careful at the next time.\n\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/pull/484#issuecomment-33691907\n.\n. Nice, thanks, @halitalptekin !\n. nice. Thanks, y'all!\n. Nice! Thanks, @Foxboron and @theanalyst !\n. and @berkerpeksag, sorry for missing you :)\n. and @algernon damnit, paultag\n. Sure, why not, LGTM :)\n. RFR @hylang/core\n. Nice change. LGTM. RFR @hylang/core \n. @hylang/core please merge\n. I appreceate the time you took to send this in. I see no reason not to accept it, but there is much worse profanity elsewhere I'm sure - most of our core libs are drug puns too.\n\nI don't want to start gutting the codebase or docs (playful joking throughout) over this, but no harm in the readme.\nThanks!\n. Dupe of #499\nThanks for the PR! :)\n. Looks great :)\n. Thanks for the change, @microamp ! This rocks!\n. Word. Looks good to me!\n. RFR @hylang/core \n. Thanks, bro!\n. I'm on the fence, can go either way. Seems harmess enough, but I do want to avoid kitchen-sink'ing everything.\n. @hylang/core RFR\n. I'm loving these changes, but it does change the arguments of (slice). That seems OK to me. Let's get some thoughts from @hylang/core.\nNice work, @calembendell !\n. This breaks against master - it'd be great to get this rebased - just a simple exports conflict.\nIt'd also be good to get rid of the whitespace on line 56\nLooks good to me, though - this is really awesome stuff! Has ack after those two things. @hylang/core \n. Pretty annoying for Acid - consider this a bribe for review - ping @hylang/core \n. :heart: you guys rule\n. Looks like a really useful function, thank you @kirbyfan64 !\nSome comments:\n1) Can this become a plain function? Having it as a function means we can work with it better in a few cases where we need to pass the function around (macros don't appear in the namespace :(\n2) Would you mind adding a test to ensure we don't break this really nice feature in the future?\n3) Could I trouble you (while you're in there) to style the code similar to other functions in core?\nThanks so much for the PR! This looks great! Can't wait to shipit!\n(We can add docs in a followup PR)\n. Hylang\n(hy3)[tag@leliel:~][\u231a 09:54 PM] \u2192  hy\nhy 0.9.12\n=> (defn test [x] (print x))\n=> (test 1)\n1\n=> (apply test [1])\n1\n=> \n(hy3)[tag@leliel:~][\u231a 09:55 PM] \u2192  python --version\nPython 3.4.0b2\n(hy3)[tag@leliel:~][\u231a 09:55 PM] \u2192\n. It's actually a compiler builtin, which means it's a pain to use. \n. Something like this is a workaround:\nPython\n=> (defn -apply- [fnc args] (apply fnc args))\n=> (defn hi [x] (print x))\n=> (-apply- hi [1])\n1\nWhich sucks. Perhaps we need a bug on adding a shim function into core. This is sorta the autolambda thing.\n. @kirbyfan64 that's not a bad idea, it's something we do with for and for*. @hylang/core - what do you think about apply* and apply?\n. It seems ironic we can't apply (apply).\n. Hurm, yeah, this looks annoying. Thanks, @signalpillar !\n. Build is failing, s'up with this\n. ack\nOn Sat, Mar 8, 2014 at 1:13 PM, Abhishek L notifications@github.com wrote:\n\nBuild fails as the tests that run on 2.6,2.7,3.2 as there are tests for\nyield-from which was the macroed form earlier. I guess we should do like\n@Foxboron https://github.com/Foxboron mentioned, ie. compilerize when\npossible ie 3.3+ and use the existing simple yield-from macro for other\nversions\n\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/pull/515#issuecomment-37104983\n.\n\n\n:wq\n. Thats two acks, Abhishek - merge away!\nOn Feb 24, 2014 12:39 AM, \"Abhishek L\" notifications@github.com wrote:\n\n[image: :+1:]\n\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/pull/517#issuecomment-35859094\n.\n. Yeah, what's up with that double if? -- also, you need to quote that if, @algernon :)\n\nNice. Once that's fixed up, let's get it in \n. Looks good to me. I don't like lisp-if as a name, but it'll do for now. I think I'll use this myself :)\nRFR @hylang/core \n. Hurmmmmmmm.\nLet me think about this one. It's a solid idea, I just need to think about where this'll break (if it will)\n. We just had a PR on this -- can we re-test this against master and see what's up? I think we're doing tuple -> vector now\nre-open if this is still a thing\n:heart:\n. Cool! So, what's the status here @ghubber - what's left to merge? :)\n. Nice. Thanks!\n. Nice discussion here. Solid. What's the status on this?\n. OK, sounds good. I'll give this a review shortly and see if we can't get\nthis in :)\nOn Sat, Mar 8, 2014 at 1:31 PM, Doug notifications@github.com wrote:\n\nIn short, the status is this: this pull request now fixes #493https://github.com/hylang/hy/issues/493,\n502 https://github.com/hylang/hy/issues/502, #331https://github.com/hylang/hy/issues/331,\nand #532. In addition to that, it makes take-while, drop-while, zipwith,\nrepeat, cycle, take, drop, iterable?, and iterator? much cleaner. The\ndocumentation for zipwith is now in the correct place, and all functions\nthat work on iterables raise proper errors on invalid indices rather than\nsilently returning nil.\n\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/pull/524#issuecomment-37105473\n.\n\n\n:wq\n. This all looks solid. RFR @hylang/core \n. Pretty neat idea. Not sure where I am right now on this - it looks like we should consider exposing some of the internals for this -- but neat!\nDo you have some awesome code I can meditate on with this? I usually resort to macros when I need to dynamically create symbols; dynamically creating them in functions sounds neat :)\n. Nice work, @schuster-rainer !\n. @olasd think we can find a way to unify this with the lexer internals?\n. I really needed this the other day, I'm in favor :)\nOnly thing I'm not sure about is the name function name - seems like that's commonly - other ideas for function names, @hylang/core ?\n. Hrurm.\nWhat's consensus here? I'm really afraid of a common name like \"name\" causing trouble to users.\nWe need this functionality. \nWhat are our options here? \n. It's not that I disagree that there's precedent and that it makes sense,\nit's that name is a really common variable name, and I could see people\ntripping over that once in a while.\nI guess that's not much different than using reduce or hash or id as\na variable name.\nOn Thu, Jul 31, 2014 at 10:20 AM, Rainer Schuster notifications@github.com\nwrote:\n\nAnd as I'm not reinventing the wheel here, similar stuff for java interop,\nas you already know. Just to mention for everyones reference.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/pull/525#issuecomment-50764798.\n\n\n:wq\n. keyword is great :)\nOn Thu, Jul 31, 2014 at 10:23 AM, Rainer Schuster notifications@github.com\nwrote:\n\nSo consensus over the whole thread right now is keyword. The discussion\npoint as I understand it is 'name' vs. 'keyword-name'. Maybe @agentultra\nhttps://github.com/agentultra didn't read the implementation carefully,\nas the code should be really generic, as he supposed KEYWORD-NAME. I'm fine\nexpanding the implementation to match the needed criteria for being name a\nfirst class citizen.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/pull/525#issuecomment-50765236.\n\n\n:wq\n. That's right, everything else is amazing.\nOn Thu, Jul 31, 2014 at 10:25 AM, Rainer Schuster notifications@github.com\nwrote:\n\noh you mean due to conflicts shadowing a variable called name ...\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/pull/525#issuecomment-50765437.\n\n\n:wq\n. Let's get this in the next release. This is a blocker for #622 \n. Let's roll with these names, in that case. Seems fine. Let's go with it.\n@hylang/core Let's get some eyes on this. Looks good to me. I'll ACK it in a second when I can sit down with it.\n. LGTM\n. Yikes merge conflict. Can someone do this merge? I'm in time debt D:\n. hy/core/language.hy and tests/native_tests/language.hy both seem like straightforward changes\n. Sick. Has ack. RFR @hylang/core \n. Sick. Thanks, @berkerpeksag \n. (in the 2.6 venv)\n. Nice call @algernon - changes made\n. Thanks, @theanalyst!\n. Looks great. A paired with Allison on this - has ack from me. @akaptur - mind adding yourself to AUTHORS?\nRFR @hylang/core \n. :thumbsup: thanks @akaptur !\n. Oh! Nice, @kirbyfan64 ! That could be totally awesome! I had no idea how we could have even done that, in the mood for a PR?\n. Sweet, thanks @kaitlin and @kirbyfan64 :D \n. (this will let us get rid of the from test.some_module.other_thing import * hack)\n. balls; good point. Thanks @berkerpeksag :)\n. @kirbyfan64 you rock, thank you! :D \n. Oh right, sorry - rfr @hylang/core I'm remote today \n. nice work. Love it. Thank you!\n. Hah, I love this. Can we get @tuturto 's comments lined up? Has my ack otherwise - @tuturto mind merging this in when it's good?\nNice work, y'all!\n. The exact reason is because using a break with a double for is not\nimplementable --\n(for [x .. y ..] .. (else ..))\nCan't be turned into nested for loops easily\nOn Apr 22, 2014 3:19 AM, \"Matthew Wampler-Doty\" notifications@github.com\nwrote:\n\nWell, so I could see that this might be a good design if itertools.productwas more efficient somehow than nested for loops.\nI was curious about this so I decided to run a few micro-benchmarks to\nfind out:\nHere's itertools.product\n$ python -mtimeit -s'a,b=(range(20),range(20)); import itertools' 'for (x,y) in itertools.product(a,b): x*y'\n10000 loops, best of 3: 39.2 usec per loop\nHere's nested for-loops:\npython -mtimeit -s'a,b=(range(20),range(20)); import itertools' 'for x in a:\n   for y in b: x * y'\n10000 loops, best of 3: 33.6 usec per loop\nNested for-loops appear to be 1.16x faster.\nI recognize that pressing this issue is annoying, but I just don't\nunderstand why there's this regression in 0.10.0 if it's both slower_and _less\ngeneral than the implementation in 0.9.12 .\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/issues/573#issuecomment-41010515\n.\n. Sick. Nice work.\n. You're setting an attribute on an external module, this is expected,\nsince Python is mutable.\n. perhaps so\n\nOn Fri, Apr 25, 2014 at 10:56 AM, Matthew Wampler-Doty \nnotifications@github.com wrote:\n\nGotcha; let is usually dynamically scoped so this was a bit of a\ngotcha. I'd argue that setting attributes should be forbidden from letforms, since it just leads to confusion and foot-shootingness, IMHO.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/issues/576#issuecomment-41401725\n.\n\n\n:wq\n. Again, because Hy compiles to Python, it inherits Python's semantics. Perhaps email python-dev with how they can change assignment? \n. We need this for plenty of things, and it's valid Python - I don't like setv losing the ability to set things like class attributes\n. Ah! I should have read that\n. solid. I'll give this a review\n. :heart: looks legit. Nice work @xcthulhu !\n. Nice stuff. Loving it.\n. Thanks, @xcthulhu !\n. Let's get some work on this going\n. @hylang/core - ideas?\n. Hurm, we're getting some 3.2 failure. Looks fantastic other than that\n. Sick. I love it. Has ack. RFR @hylang/core \n. Looks great. Tests? Has ack!\n. you rock, thank you! :D\nOn Mon, May 12, 2014 at 8:42 PM, John MacKenzie notifications@github.comwrote:\n\nI'll look at a test or two this week!\n\nOn May 12, 2014, at 5:49 PM, Paul Tagliamonte notifications@github.com\nwrote:\nLooks great. Tests? Has ack!\n\u2014\nReply to this email directly or view it on GitHub.\n\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/pull/593#issuecomment-42905773\n.\n\n\n:wq\n. related work: https://github.com/hylang/hy/blob/master/hy/contrib/curry.hy \nperhaps we can merge these two?\n. @kirbyfan64 Man, sorry, I forgot to look after I saw your mail. This is totally my fault, I suck, sorry.\nMerging it would be great :\\\nI know this sucked, sorry. Totally cool if you're not interested in contributing anymore :(\n. No worries - hope you're having fun with Hy!\nOn May 13, 2014 8:16 AM, \"Evan Bender\" notifications@github.com wrote:\n\nClosed #596 https://github.com/hylang/hy/issues/596.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/issues/596#event-120529210\n.\n. :heart:\nOn May 13, 2014 8:55 AM, \"Evan Bender\" notifications@github.com wrote:\nI can't stop giggling. [image: :monkey:][image: :monkey:][image: :monkey:]\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/issues/596#issuecomment-42950665\n.\n. Impossible where?\n\nThey run fine :)\nThe idea is to create names that won't clash with local vars :)\nOn May 13, 2014 8:31 AM, \"Morten Linderud\" notifications@github.com wrote:\n\nWell, the quickest solution is to maybe just add a try/except clause and\nyell out about the impossible variable name. Might not be the best behavior\ntho?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/issues/597#issuecomment-42948492\n.\n. Really clever, I forgot about this. I've not had enough coffee to think this through yet, but can we get tests passing? Also, thoughts, @hylang/core ?\n. Tests aren't passing still, and nothing has been updated here for a while -- mind re-opening when the tests pass, @xcthulhu ?\n. the return is basically a StopIteration(2).\n. Well let's see how we can improve hy.contrib.loop ?\nOn Aug 27, 2014 7:41 PM, \"J Kenneth King\" notifications@github.com wrote:\nIt probably wouldn't be worth it. You can't actually manipulate stack\nframe activations in Python (no pointers) so these decorators (as noted by\nother commentators on the linked page) are actually slower than Python's\nnormal recursion for anything but large values of N -- which is the usual\ncase for many iterations in a program.\nThere's nothing stopping you from implementing the decorator in Hy for\nyour cases though I don't think we should include this in core.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/609#issuecomment-53667209.\n. This seems funny. Let's track that down; not super happy.\n\nI'm guessing this is because we're getting a raw Python Integer (rather then a HyInteger) in the compiler, which will bomb out the compiler, since the unquote will eval that guy.\nHowever, there's only one way to compile that down, we should add that to the known things.\ncc @olasd \n. Me! :)\nOn Jul 7, 2014 5:19 AM, \"Rui Carmo\" notifications@github.com wrote:\n\nI'd love to be able to profile hy apps using hy -m cProfile -out\nhy.pstats foo.hy. Who's with me?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/618.\n. Nice catch, yeah.\n\nOne of the things that I really hate, you're totally right.\nSince let creates a function to form the closure, yield will yield back to the inner function, and it won't yield-from properly.\nIt would be really awesome to fix this. Perhaps yield-from is a potential solution for Python 3.\n. Yeah that totally sucks. I've written this macro in a few places, I'm\nkeen on seeing this added to the compiler:\n(defmacro ylet [&rest args] `(yield-from (let ~@args)))\nWhich works great. We should file a bug on making sure the compiler will\ndo this automagically.\nOn Wed, Jul 09, 2014 at 02:11:15AM -0700, \u00c5smund Grammeltvedt wrote:\n\nI'm not completely sure if this is a bug or expected behaviour. At the\n   very least, it's a confusing gotcha.\n(defn test )))\nproduces the following python code:\ndef test():\n     while True:\ndef _hy_anon_fn_1():\n         a = u'b'\n         yield foo\n     _hy_anon_fn_1()\nwhich results in an infinite loop of creating the generator object,\n   instead of returning it from test.\nExchanging positions of the let and while provides the expected result:\n(defn test )))\ndef test():\ndef _hy_anon_fn_1():\n     a = u'b'\n     while True:\n         yield foo\n return _hy_anon_fn_1()\n\u2014\n   Reply to this email directly or [1]view it on GitHub.\n\n\n.''.  Paul Tagliamonte <paultag@debian.org>  |   Proud Debian Developer\n: :'  : 4096R / 8F04 9AD8 2C92 066C 7352  D28A 7B58 5B30 807C 2A87. '  http://people.debian.org/~paultag\n `-     http://people.debian.org/~paultag/conduct-statement.txt\n. #584 officially a blocker \n. OK. Re-ping on this. Let's get this going. Currently blocked on read. Anyone else have pending patches, @hylang/core?\nIf not, let's sweep PRs and get this out the door.\n. Right, we'll call #525 a blocker \n. - [x] https://github.com/hylang/hy/pull/584\n- [x] https://github.com/hylang/hy/pull/525\n- [x] https://github.com/hylang/hy/pull/635\nLet's get on #525 @hylang/core \n. Ping? :D \n. Hurm, yeah.\nCan we retarget this PR as a changeset against hy.contrib.profile to clean\nthat up?\nAwesome.\nOn Mon, Aug 18, 2014 at 12:14 PM, Abhishek L notifications@github.com\nwrote:\n\nMaybe it would make some sense to move this to contrib.profile instead of\nhylang core itself?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/pull/625#issuecomment-52515378.\n\n\n:wq\n. So it's been a while and there's no more activity on this -- please re-open this if we can get it rebased on master and get all the comments addressed\n:heart:\n. Super interesting first cut. I'm liking the direction.\n. Changeset looks great. Has my ACK. Nice work, @Foxboron !\n. Hurm. Yeah. Good point. I think you might be right. Any thoughts from other\n@hylang/core 'ers?\nOn Tue, Aug 12, 2014 at 1:39 PM, Tianon Gravi notifications@github.com\nwrote:\n\nHmm, thinking about it more, isn't stdin kind of a strange name for the\nIO object being read? Wouldn't something like input make more sense,\nsince it really just needs to be something that can be \"read\" from?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/pull/628#issuecomment-51949156.\n\n\n:wq\n. Outstanding. ACKed still. Looks amazing. Tests should pass.\nRFR @hylang/core \n. We need a contrib manager. I'm tempted to make @olasd do it. \n. I'm tempted to punt for now, let's reopen as needed.\n. Hurm. Is Hy installed in the virtualenv or system-wide?\nOn Mon, Aug 11, 2014 at 3:36 PM, stormcoder notifications@github.com\nwrote:\n\nI have found that certain modules will not import in Hy but will import in\npython. I'm running Hy .10.0 on Python 3.4.1 x64 on Windows 7.\n=> (import cx_Oracle)\nTraceback (most recent call last):\n  File \"\", line 1, in \nImportError: No module named 'cx_Oracle'\n=> (import cx-Oracle)\nTraceback (most recent call last):\n  File \"\", line 1, in \nImportError: No module named 'cx_Oracle'\n=> (import cx-oracle)\nTraceback (most recent call last):\n  File \"\", line 1, in \nImportError: No module named 'cx_oracle'\n=> (import zmq)\n=> (import tornado)\nTraceback (most recent call last):\n  File \"\", line 1, in \nImportError: No module named 'tornado'\nPython output:\nPython 3.4.1 (v3.4.1:c0e311e010fc, May 18 2014, 10:45:13) [MSC v.1600 64 bit (AM\nD64)] on win32\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n\n\n\nimport cx_Oracle\nimport tornado\n\n\n\nHy Python Path:\nhy 0.10.0\n=> (import sys)\n=> (. sys path)\n['', 'C:\\Python34\\Scripts', 'C:\\Windows\\system32\\python34.zip', 'C:\\Python\n34\\DLLs', 'C:\\Python34\\lib', 'C:\\Python34', 'C:\\Users\\mowens\\AppData\\Roa\nming\\Python\\Python34\\site-packages', 'C:\\Python34\\lib\\site-packages', 'C:\\\n\\Python34\\lib\\site-packages\\win32', 'C:\\Python34\\lib\\site-packages\\win32\\\n\\lib', 'C:\\Python34\\lib\\site-packages\\Pythonwin', 'C:\\Users\\mowens\\Docume\nnts\\QA\\lib']\nPython:\nPython 3.4.1 (v3.4.1:c0e311e010fc, May 18 2014, 10:45:13) [MSC v.1600 64 bit (AM\nD64)] on win32\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n\n\n\nimport sys\nsys.path\n['', 'C:\\Windows\\system32\\python34.zip', 'C:\\Python34\\DLLs', 'C:\\Python34\\\n\\lib', 'C:\\Python34', 'C:\\Users\\mowens\\Documents\\Env\\Activation34', 'C:\\U\nsers\\mowens\\Documents\\Env\\Activation34\\lib\\site-packages', 'C:\\Users\\mow\nens\\Documents\\Env\\Activation34\\lib\\site-packages\\win32', 'C:\\Users\\mowen\ns\\Documents\\Env\\Activation34\\lib\\site-packages\\win32\\lib', 'C:\\Users\\mo\nwens\\Documents\\QA\\lib']\n\n\n\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/632.\n\n\n:wq\n. That may be - we use the console entry points config, I think that\nhardcodes the interpreter to use, so when you spawn it, it uses the\nsystem-wide Python rather then the Python in the virtualenv.\nLet's leave this open - as a workaround, try pip install'ing (or\nsetup.py'ing) Hy in your virtualenv\nOn Mon, Aug 11, 2014 at 4:12 PM, stormcoder notifications@github.com\nwrote:\n\nI have it installed system wide but I started it in the environment. Maybe\nthe script for the repl needs to be tweaked?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/632#issuecomment-51833797.\n\n\n:wq\n. Yeah. My gut is telling me this is a setuptools / setup.py thing. I'll look\ninto it. Sorry about that.\nOn Mon, Aug 11, 2014 at 4:19 PM, stormcoder notifications@github.com\nwrote:\n\nSo I installed hy in the env and it works correctly. Problem is that if\nyour in an env that doesn't have hy installed it is going grab the system\nhy and things won't work correctly. It might be good to have the start\nscripts be sensitive to the current env.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/632#issuecomment-51834713.\n\n\n:wq\n. @reillysiemens Are you sure hy is installed inside your virtualenv? This issue sounds like Hy was installed with sudo pip install or via apt-get install and not working inside a virtualenv.\n(Just like Python, FWIW)\n. (hy)[paultag@cassiel:~][\u231a 08:41 PM] \u2665  python3 -c 'import sys; print(sys.path)'\n['', '/home/paultag/dev/local/hy', '/home/paultag/.virtualenvs/hy/lib/python3.4/site-packages/clint-0.5.1-py3.4.egg', '/home/paultag/.virtualenvs/hy/lib/python3.4/site-packages/astor-0.5-py3.4.egg', '/home/paultag/.virtualenvs/hy/lib/python3.4/site-packages/rply-0.7.4-py3.4.egg', '/home/paultag/.virtualenvs/hy/lib/python3.4/site-packages/args-0.1.0-py3.4.egg', '/home/paultag/.virtualenvs/hy/lib/python3.4/site-packages/appdirs-1.4.0-py3.4.egg', '/home/paultag/.virtualenvs/hy/lib/python3.4', '/home/paultag/.virtualenvs/hy/lib/python3.4/plat-x86_64-linux-gnu', '/home/paultag/.virtualenvs/hy/lib/python3.4/lib-dynload', '/usr/lib/python3.4', '/usr/lib/python3.4/plat-x86_64-linux-gnu', '/home/paultag/.virtualenvs/hy/lib/python3.4/site-packages']\n(hy)[paultag@cassiel:~][\u231a 08:41 PM] \u2665  /usr/bin/python3 -c 'import sys; print(sys.path)'\n['', '/usr/lib/python3.4', '/usr/lib/python3.4/plat-x86_64-linux-gnu', '/usr/lib/python3.4/lib-dynload', '/usr/local/lib/python3.4/dist-packages', '/usr/lib/python3/dist-packages']\nCheck which hy. It should be in the virtualenv, not out of it.\n(hy)[paultag@cassiel:~][\u231a 08:41 PM] \u2665  which hy\n/home/paultag/.virtualenvs/hy/bin/hy\nJust like Python:\n(hy)[paultag@cassiel:~][\u231a 08:42 PM] \u2665  which python\n/home/paultag/.virtualenvs/hy/bin/python\n. Anyway I'm pretty sure that's the issue. If I get a few ACKs that that's the issue, I can close this out :)\n:+1: \n. Good call; more bulletproofing here is needed\nOn Sat, Aug 16, 2014 at 3:18 PM, kirbyfan64 notifications@github.com\nwrote:\n\nlist-comp should check its arguments for validity, since this happens when\nthe arguments get reversed on Python 2:\nryan@DevPC-LX:~/stuff/hy$ hy\nhy 0.10.0 using CPython(default) 2.7.6 on Linux\n=> (list-comp [x [1 2 3]] x)\nSegmentation fault (core dumped)\nryan@DevPC-LX:~/stuff/hy$\nand Python 3:\nryan@DevPC-LX:~/stuff/hy$ ~/stuff/anaconda/bin/hy\nhy 0.10.0 using CPython(default) 3.3.5 on Linux\n=> (list-comp [x [1 2 3]] x)\nTraceback (most recent call last):\n  File \"/home/ryan/stuff/anaconda/lib/python3.3/site-packages/hy-0.10.0-py3.3.egg/hy/importer.py\", line 42, in ast_compile\n    return compile(ast, filename, mode, flags)\nValueError: comprehension with no generators\n=>\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/634.\n\n\n:wq\n. Sweet. Let's get eyes on this. Description looks good. I'll look at the\nimpl tonight. @hylang/core\nOn Aug 22, 2014 6:24 AM, \"han semaj\" notifications@github.com wrote:\n\nThis PR implements drop-last.\nI have also reimplemented butlast in terms of drop-last in order to make\nit work well with lazy/infinite sequences. The problem with the current\nimplementation is that it would only work well with fully realised\ncollections and iterators that implement len which can be problematic\nin some cases. Please consider the following examples.\n=> (butlast (interleave (range 10) (range 10 20)))\nTraceback (most recent call last):\n  File \"\", line 1, in \n  File \"/home/microamp/devel/projs/hy/hy/core/language.hy\", line 41, in butlast\n    (itertools.islice coll 0 (dec (len coll))))TypeError: object of type 'itertools.chain' has no len()\n=> (import itertools)=> (take 5 (butlast (itertools.count)))\nTraceback (most recent call last):\n  File \"\", line 1, in \n  File \"/home/microamp/devel/projs/hy/hy/core/language.hy\", line 41, in butlast\n    (itertools.islice coll 0 (dec (len coll))))TypeError: object of type 'itertools.count' has no len()\nPlease find the new tests to see how drop-last/butlast handle\nlazy/infinite sequences now.\nThanks for reviewing in advance.\nYou can merge this Pull Request by running\ngit pull https://github.com/microamp/hy fix-butlast\nOr view, comment on, or merge it at:\nhttps://github.com/hylang/hy/pull/637\nCommit Summary\n- Implement drop-last\n- Reimplement butlast in terms of drop-last\nFile Changes\n- M docs/language/core.rst\n  https://github.com/hylang/hy/pull/637/files#diff-0 (51)\n- M hy/core/language.hy\n  https://github.com/hylang/hy/pull/637/files#diff-1 (11)\n- M tests/native_tests/core.hy\n  https://github.com/hylang/hy/pull/637/files#diff-2 (26)\nPatch Links:\n- https://github.com/hylang/hy/pull/637.patch\n- https://github.com/hylang/hy/pull/637.diff\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/pull/637.\n. <3 \n. Agreed. Want to do the PR, han? I'd love to get you into core after a few\npatches.\nOn Aug 22, 2014 7:03 AM, \"han semaj\" notifications@github.com wrote:\nfirst is basically (nth coll 0), and nth can be reimplemented with nil as\nthe default value.\n(defn nth [coll index]\n  \"Return nth item in collection or sequence, counting from 0\"\n  (next (drop index coll) nil))\n(Note: try/catch is no longer needed)\n=> (assert (nil? (first [])))=> (assert (nil? (nth [] 0)))=> (assert (nil? (nth [] 1)))=> (assert (nil? (nth [] 100)))\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/638#issuecomment-53048230.\n. Agreed. This is a blocker for release.\n\nNice catch, han.\nOn Aug 22, 2014 9:01 AM, \"Morten Linderud\" notifications@github.com wrote:\n\nThis is mostlikely a bug in the implementation of + in hy/core/shadow.hy;\nhttps://github.com/hylang/hy/blob/master/hy/core/shadow.hy#L27\nTo be able to use reduce,map & co with operators we needed to shadow the\nfunction of +.\nRef: #602 https://github.com/hylang/hy/pull/602\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/639#issuecomment-53057199.\n. so, syntax proposals?\n. ``` python\ndef foo(a: int, b: str) -> int:\n    return 0\n\nThen, given:\nfoo.annotations\nWe get:\n{'b': , 'return': , 'a': }\n```\nCurrently only given meaning by third party stuff.\nLet's allow setting them. Who knows some similar syntax for Lisplikes?\n. Not a bad syntax.\nYeah not yet, that's what this bug is for! :D\n On Aug 22, 2014 3:28 PM, \"kirbyfan64\" notifications@github.com wrote:\n\nFor functions, I was thinking of something like this:\n(defn my-func [a int] [b int])\nBTW, Hy has no way of representing function annotations, does it? If it\ndid, then it could be used on top of MyPy.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/640#issuecomment-53109441.\n. Erm yeah. I was thinking 3.4 annotations. Bug subject is a typo :)\nOn Aug 22, 2014 3:29 PM, \"kirbyfan64\" notifications@github.com wrote:\nMaybe that same syntax could be used for annotations? That way, people can\nuse libraries like plac https://code.google.com/p/plac/ from Hy, too.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/640#issuecomment-53109632.\n. Lgtm merge away\nOn Sep 3, 2014 7:08 PM, \"J Kenneth King\" notifications@github.com wrote:\n[image: :+1:] lgtm\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/pull/648#issuecomment-54381264.\n. Thumbs up. Nice\nOn Sep 4, 2014 8:25 AM, \"Berker Peksag\" notifications@github.com wrote:\nSee https://github.com/hylang/hy/commits/master?author=microamp for his\ncommits so far.\nSee also https://github.com/hylang/hy/pulls/microamp for his pending\npatches.\n[image: :+1:] from me :)\nThoughts, @hylang/core https://github.com/orgs/hylang/teams/core?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/650.\n. invite sent to @microamp \n. @microamp  welcome to hy society! \n. Let's get this into a 0.11\n. @hylang/core Can we get this in? We'll have to do a 0.12, but I'm OK with that. Thoughts>\n. Sounds like rply might not be installed, did you install the\nrequirements? Which version of rply do you have? :)\n\nOn Sun, Sep 07, 2014 at 08:02:13AM -0700, ghufransyed wrote:\n\nI get the following error when trying to make the hy html docs:\ndocs ghufran$ make html\n   sphinx-build -b html -d _build/doctrees . _build/html\n   Running Sphinx v1.2.3\nException occurred:\n   File \"/Users/ghufran/Documents/programming/python/hy/hy/hy/lex/init.py\",\n   line 21, in\n   from rply.errors import LexingError\n   ImportError: No module named rply.errors\n   The full traceback has been saved in\n   /var/folders/mm/58j3wfjj0q55bk0_w0wqjq140000gn/T/sphinx-err-yOIjbG.log, if\n   you want to report the issue to the developers.\n   Please also report this if it was a user error, so that a better error\n   message can be provided next time.\n   A bug report can be filed in the tracker at\n   [1]https://bitbucket.org/birkenfeld/sphinx/issues/. Thanks!\n   make: *** [html] Error 1\n\nthe full traceback is listed below\n```\n                         Sphinx version: 1.2.3\n                     Python version: 2.7.5\n\n                 Docutils version: 0.12 release\n\n                     Jinja2 version: 2.7.3\n\n                       Loaded extensions:\n\n```\nTraceback (most recent call last):\n   File\n   \"/Library/Python/2.7/site-packages/Sphinx-1.2.3-py2.7.egg/sphinx/cmdline.py\",\n   line 253, in main\n   warningiserror, tags, verbosity, parallel)\n   File\n   \"/Library/Python/2.7/site-packages/Sphinx-1.2.3-py2.7.egg/sphinx/application.py\",\n   line 107, in init\n   confoverrides or {}, self.tags)\n   File\n   \"/Library/Python/2.7/site-packages/Sphinx-1.2.3-py2.7.egg/sphinx/config.py\",\n   line 229, in init\n   execfile_(filename, config)\n   File\n   \"/Library/Python/2.7/site-packages/Sphinx-1.2.3-py2.7.egg/sphinx/util/pycompat.py\",\n   line 105, in execfile_\n   exec code in globals\n   File \"conf.py\", line 19, in\n   import hy\n   File \"/Users/ghufran/Documents/programming/python/hy/hy/hy/__init_.py\",\n   line 37, in\n   import hy.importer # NOQA\n   File \"/Users/ghufran/Documents/programming/python/hy/hy/hy/importer.py\",\n   line 24, in\n   from hy.lex import tokenize, LexException\n   File \"/Users/ghufran/Documents/programming/python/hy/hy/hy/lex/init.py\",\n   line 21, in\n   from rply.errors import LexingError\n   ImportError: No module named rply.errors\n\u2014\n   Reply to this email directly or [2]view it on GitHub.\nReferences\nVisible links\n1. https://bitbucket.org/birkenfeld/sphinx/issues/\n2. https://github.com/hylang/hy/issues/653\n\n\n.''.  Paul Tagliamonte <paultag@debian.org>  |   Proud Debian Developer\n: :'  : 4096R / 8F04 9AD8 2C92 066C 7352  D28A 7B58 5B30 807C 2A87. '  http://people.debian.org/~paultag\n `-     http://people.debian.org/~paultag/conduct-statement.txt\n. Awesome! :D\nOn Mon, Sep 8, 2014 at 11:34 AM, ghufransyed notifications@github.com\nwrote:\n\nthe python setup.py install\nbut the\npip install -r requirements-dev.txt\ndid the trick, thanks!\nOn 7 September 2014 23:16, Morten Linderud notifications@github.com\nwrote:\n\n@ghufransyed https://github.com/ghufransyed use python setup.py\ninstall\nThe deps are listen inn\nhttps://github.com/hylang/hy/blob/master/setup.py#L48-53\nyou could also use the requirements-dev.txt by doing pip install -r\nrequirements-dev.txt\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/653#issuecomment-54780141.\n\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/653#issuecomment-54838739.\n\n\n:wq\n. Push away, no PR needed for that change!\nOn Sep 8, 2014 9:00 AM, \"Morten Linderud\" notifications@github.com wrote:\n\nAdded new mail to the map. Nuthing big.\n[image: :shipit:]\nYou can merge this Pull Request by running\ngit pull https://github.com/Foxboron/hy mailmap-fox\nOr view, comment on, or merge it at:\nhttps://github.com/hylang/hy/pull/654\nCommit Summary\n- added new mail\nFile Changes\n- M .mailmap https://github.com/hylang/hy/pull/654/files#diff-0\n  (5)\nPatch Links:\n- https://github.com/hylang/hy/pull/654.patch\n- https://github.com/hylang/hy/pull/654.diff\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/pull/654.\n. And you're awesome for it :D\nOn Sep 8, 2014 9:14 AM, \"Morten Linderud\" notifications@github.com wrote:\n@paultag https://github.com/paultag pffftttt, guidelines man!\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/pull/654#issuecomment-54815081.\n. Care to share syntax?\nOn Sep 10, 2014 2:08 AM, \"Rui Carmo\" notifications@github.com wrote:\nDoesn't feel very LISPy to me... Then again, I'm quite used to Clojure\nhinting, which has spoiled me somewhat.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/pull/656#issuecomment-55074829.\n. I'm going to close this until @Foxboron is done prototyping this stuff :)\n\n:+1: \n. wait, what's the breaking change\nOn Thu, Nov 6, 2014 at 2:45 PM, Tianon Gravi notifications@github.com\nwrote:\n\nI went with 0.10.2 for now since I personally think it makes sense to\nassume we don't have breaking changes that warrant 0.11 until we actually\nget some (in which case, it's not hard to search for 0.10.2 and replace it\nwith 0.11 [image: :+1:]). Happy to change it if there's disagreement\nthough! [image: :smile:]\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/pull/658#issuecomment-62039098.\n\n\n:wq\n. tests failed D:\n. Awesome, on it\nOn Sat, Nov 15, 2014 at 7:53 AM, Berker Peksag notifications@github.com\nwrote:\n\nIt's the old PyPy failure. We can merge this safely :)\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/pull/658#issuecomment-63171326.\n\n\n:wq\n. Nice!\n. Not a bad idea -- we should likely implement this as a second PEP302 loader -- after all, it is what they were designed for :)\n. LGTM; AUTHORs merge is trivial, tests can be cleaned up after. \n@hylang/core - can someone merge? :)\n:+1: \n. Yep, this is one for sure. On python 3 (don't know to fix this on Python 2,\nwhich was blocking my bugfix, sigh python 2) we can:\n(defmacro ylet [&rest args] (yield-from (let ~@args))\n(but do that automatically in the compiler)\nOn Mon, Sep 29, 2014 at 9:37 AM, Alexander Artemenko \nnotifications@github.com wrote:\n\nSuch code:\n(let [var 1]))\nCompiles into:\ndef _hy_anon_fn_1():\n    var = 1L\n    return (yield u'Hello' if var else None)_hy_anon_fn_1()\nAnd return inside a generator leads to SyntaxError: 'return' with\nargument inside generator error.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/663.\n\n\n:wq\n. That's what the compiler does now (in Result.contains_yield) -- this is\njust an uncaught edge-case.\nIt sucks, and i've been aware of it, just never come up with a great way to\nfix Python 2. Perhaps I should implement a fallback yield-from.\nOn Mon, Sep 29, 2014 at 9:45 AM, Alexander Artemenko \nnotifications@github.com wrote:\n\nIs there a way in hy to write a function which returns nothing? If so, let\nmacro could analize if there are yields in the args tree and if there are,\nthen return nothing.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/663#issuecomment-57162438.\n\n\n:wq\n. ok i'll take a stab at this\n. or (yield-from (let )) - I had a PR for some of this before\nOn Wed, Jul 15, 2015 at 3:45 PM, Ryan Gonzalez notifications@github.com\nwrote:\n\n@rcarmo https://github.com/rcarmo You could always use setv as a\nworkaround. Or:\n(defmacro multi-setv [&rest args]\n  (do\n    ~@(map (fn [[a b]](setv ~a ~b)) (zip (slice args nil nil 2) (slice args 1 nil 2)))))\nWhich would let you do:\n(multi-setv [x-inc (+ width spacing)\n                   y-inc (+ height spacing)\n                   ...])\n(continue work here)\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/663#issuecomment-121724682.\n\n\n:wq\n. The issue was (IIRC) figuring out when to trigger the yield-from\nOn Wed, Jul 15, 2015 at 3:46 PM, Paul R. Tagliamonte paultag@gmail.com\nwrote:\n\nor (yield-from (let )) - I had a PR for some of this before\nOn Wed, Jul 15, 2015 at 3:45 PM, Ryan Gonzalez notifications@github.com\nwrote:\n\n@rcarmo https://github.com/rcarmo You could always use setv as a\nworkaround. Or:\n(defmacro multi-setv [&rest args]\n  (do\n    ~@(map (fn [[a b]](setv ~a ~b)) (zip (slice args nil nil 2) (slice args 1 nil 2)))))\nWhich would let you do:\n(multi-setv [x-inc (+ width spacing)\n                   y-inc (+ height spacing)\n                   ...])\n(continue work here)\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/663#issuecomment-121724682.\n\n\n:wq\n\n\n:wq\n. That won't work for macro'd yields or coroutines that send values out. I\nhave half a PR using yield-from.\nPerhaps I can hack on that again\nOn Jul 22, 2015 2:37 AM, \"Zack M. Davis\" notifications@github.com wrote:\n\n@gilch https://github.com/gilch clever!\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/663#issuecomment-123577664.\n. This is tragically broken in like 3 ways, since we need to figure out if the yield is inside another function.\n\nhttps://github.com/paultag/hy/commit/aa4dd40c46dc010e6145919f171e2d5f6e3b7823\nI couldn't find my old code. I think it's what was behind the AST Macro bug\n. (this breaks in the following 5000 cases:)\n- (let [[x 1]] (fn [] (yield 1)))\n- (let [[x [1 2]]] (yield-from x))\n. @kirbyfan64 Out of curiosity, why is this better than (setv) plain?\n. It'll still leak\n``` python\n[tag@cassiel:~][\u231a 12:32 PM] \u2665  python\nPython 2.7.10 (default, Jul  1 2015, 10:54:53) \n[GCC 4.9.2] on linux2\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n\n\n\ntry:\n...     x = 1\n... finally:\n...     pass\n... \nprint(x)\n1\n```\n. @kirbyfan64 I see what you're saying now --\n\n\n\nso, what about things like x where you'd shadow the outer scope -- or if you try to do Let over Lambda (it'll silently fail in a kinda nasty way)\nI think that what you're saying is a totally valid approach, I'm just not quite convinced using del on things in the let will work quite right. I'm open to examples of why i'm wrong, though!\n. You're filing bugs for all my long-standing issues, again, another bug that has no fix in Python 2 (python 3 can use nonlocal)\nIf only we could kill Python 2 with fire.\n. bug: #246 \n. Also the reason is because it detects local by checking assignment - with dict lookup, remember, you're just doing a get on the object, not assigning to a new name, so it does the namespace lookup thing \n. Best hy bug ever\n. @svetlyak40wt because they're the same - http://legacy.python.org/dev/peps/pep-0237/ - We wrote for the Python 3 codepath (which treats them as the same type), and picking long on Python 2 let us avoid two codepaths.\nPython 2 is deprecated anyway, I'm not super keen to hack around Python 2 mistakes in Hy unless we have to :)\n. I took this in and put it in scripts.\nBecause why not and this is pull 666. Feel free to hack on that script by just pushing @hylang/core without PR (non-critical helper script)\n. OK, fine fine, let's move it to contrib :)\n. OK, I'm going to open a PR series for a few things\n. moving to #673 \n. This is just for discussion:\n@olasd - thoughts on internals / Results mangling stuff. I think we have more bugs like this\n@akaptur - thoughts on yield-from? Am I missing something that yield from is doing internally?\n. Sidenote, this will likely break a lot, and I see a few places where my sed work caught let in docstrings and stuff. This is just to talk over the approach\n. OK this is kinda busted for now, needs ast macros\n. Ugh what\nOn Nov 1, 2014 6:40 PM, \"Berker Peksag\" notifications@github.com wrote:\n\nI've just looked the PyPy 2.4.0 release notes. Quoting from it:\n\"Classes in the ast module are now distinct from structures used by the\ncompiler\"\nI didn't investigate further, but it could be related to our test failure.\nhttp://doc.pypy.org/en/latest/whatsnew-2.4.0.html\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/675#issuecomment-61386475.\n. does a build from 2.4 segfault or are you config flags different?\n\nOn Wed, Nov 5, 2014 at 1:11 PM, Ryan Gonzalez notifications@github.com\nwrote:\n\nThis is a PyPy issue; a version compiled from tip works, while the 2.4\nbinaries segfault. In the meantime, you could always explicitly check if\nPyPy is running the tests (python --version | grep PyPy) and, if so,\nmanually download the nightly builds and use those instead.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/675#issuecomment-61854095.\n\n\n:wq\n. Let's also perhaps ping the travis people for options if we can isolate\nthis as a pypy bug (I didn't catch that - did anyone rebuild with 2.4 out\nof version control (not binaries), reproduce the segfault and then test\nagainst tip and have it work? All I see is we had it segfauting against the\nofficial builds, but not with a development build of tip -- makes me think\nconfig options may be in play\nAlso, yeah. Let's see if we can get the pypy patch backported for travis or\nsomething.\nWorst comes to worst, I can put it in a PPA and we can use that.\n-T\nOn Wed, Nov 5, 2014 at 4:50 PM, Berker Peksag notifications@github.com\nwrote:\n\nYes, but downloading a nightly binary build of PyPy(~20 MB tarball) and\nextracting it will take a while. Anyway, I'm +0 on your idea. Please open a\nPR :)\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/675#issuecomment-61887542.\n\n\n:wq\n. I mean, we should try a dev build of 2.4 just to be paranoid sure :)\nOn Wed, Nov 5, 2014 at 5:03 PM, Ryan Gonzalez notifications@github.com\nwrote:\n\n@paultag https://github.com/paultag No, I did a development build of\ntip. No special config options. Works fine. A pre-built PyPy 2.3 and PyPy\nnightly work fine. Pre-build PyPy 2.4 fails. It probably isn't config\noptions.\nI'm working on a fix using the Makefiles. It's messy, but it looks like it\nmight work.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/675#issuecomment-61889456.\n\n\n:wq\n. Okokok :)\nMove to contrib :)\nOn Oct 26, 2014 2:16 PM, \"Ryan Gonzalez\" notifications@github.com wrote:\n\nMOVE IT, DON'T DELETE IT! PLEAASEE!!!!\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/678#issuecomment-60526381.\n. Let's move it to contrib and call it a day :)\n. still failing D:\n. Also this change strikes me as odd, what exactly is going on here?\n. <3\n\nOn Wed, Nov 5, 2014 at 6:37 PM, Ryan Gonzalez notifications@github.com\nwrote:\n\nNow the tests are failing for a completely different reason. Looking into\nit...\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/pull/681#issuecomment-61902578.\n\n\n:wq\n. Nice! Thanks!\n. Sure. Let's PR that into shadow\nOn Apr 24, 2015 10:06 AM, \"Rui Carmo\" notifications@github.com wrote:\n\nbump\nThis would be really handy in a couple more instances (I've already turned\nthat reduce with a lambda into a macro for my own use, but...)\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/683#issuecomment-95944026.\n. Nice catch!\n. Thanks, @darkfeline !\n. Nice. Has ack. Will merge.\n. Wait, tests failed, checking in\n. Ah, easy. I'll just merge this w/fix. Just a typo.\n. \n. Hum. On a plane - anyone object to eol'ing py 3.2?\n. 3.2 dropped from the testing tools in this commit; a full drop of 3.2 will come with a compiler and compat cleanup\n. 2.6 is on probation until it breaks like 3.2 broke for us here -- 2.7 is going to stick around for a while, but slowly grow more hacks like this :)\n. Cool. Updated to kill 3.2 in the tests. Good for review!\n. @cwebber :heart: \n. After some further thought, I'm not sure how to do this right yet. Closing.\n. Yikes, interesting.\n\nWe'd lose a lot -- including stuff defined in the body sticking around without (del) calls -- it'd also break for (let [[x 1]] (let [[x 2]] (print x)) (print x)) -- which I think works now\nAlso - I'm about to fix some stuff with yield-in-let after I get #686 and #687 in\n. Yeah that sounds awesome! :D\nPerhaps also machine readable lexer errors!\nOn Thu, Nov 20, 2014 at 2:02 PM, Koz Ross notifications@github.com wrote:\n\nI'm writing a syntax checker for Hy in Flycheck at the moment, and have\nhit a bit of a stumbling block. At the moment, the only (easy...) way to\nsyntax-check Hy source code is to pump it through hy and hope it\nexecutes. This isn't very desirable in a Flycheck checker, as it means\nexecuting (again and again) code that may take a long time to run or have\nside effects we don't want.\nWould it be possible to add a flag to hy (I suggest -c) which only checks\nit for syntactic validity? It would spew the same errors as hy does now\nif the code isn't syntactically valid (or it can't find the module or\nwhatever), and do nothing but return success otherwise?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/689.\n\n\n:wq\n. Hurm, the result yield detection must be broken somehow by this -- that's not good.\nNice bug.\n. So, this is a real bug, but i'm not sure how we can sove this for 0.10.2 yet.\nTestcase for future hypsters:\n``` diff\ndiff --git a/tests/native_tests/native_macros.hy b/tests/native_tests/native_macros.hy\nindex 9066f9b..e58c9cd 100644\n--- a/tests/native_tests/native_macros.hy\n+++ b/tests/native_tests/native_macros.hy\n@@ -241,6 +241,26 @@\n     (yield-from [1 2 3]))\n   (assert (= (list (yield-from-test)) [0 1 2 1 2 3])))\n+(defn test-yield-from-exception-handling-up []\n+  \"NATIVE: Ensure exception handling in yield from works right going up\"\n+  ; testcase taken from https://github.com/hylang/hy/issues/692\n+  ; thanks, @pyos!\n+\n+  (defn f []\n+     (yield 1)\n+     (try\n+       (yield 2)\n+     (catch [e ValueError] (yield 3))))\n+\n+  (defn g []\n+     (yield-from (f))\n+     (assert true))  ; see issue #691\n+  (setv x (g))\n+  (next x)\n+  (next x)\n+  (assert (= (x.throw ValueError) 3)))\n+\n+\n (defn test-yield-from-exception-handling []\n   \"NATIVE: Ensure exception handling in yield from works right\"\n   (defn yield-from-subgenerator-test []\n```\n. (Deleted my comment, I should read the bug thread before replying via email)\n. @gilch send a PR! :D \n. Let's call it 0.10.2 - unless we pull in an API breaking change (even if we\ndo, we can always release just before)\nOn Wed, Nov 26, 2014 at 10:07 AM, Bob Tolbert notifications@github.com\nwrote:\n\n@paultag https://github.com/paultag\nThis is a really good question. Seems to be no current way to know what\nthe 'next' version is going to be in order to get this :versionadded thing\nright.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/pull/693#issuecomment-64658651.\n\n\n:wq\n. LGTM too, but yeah some @rwtolbert love on here would be good since he knows the most about that part of the code. OK to merge?\n. I think cons/car still have the old behavior over (first) and (rest)\nOn Fri, Dec 5, 2014 at 8:49 AM, J Kenneth King notifications@github.com\nwrote:\n\nI agree. This does need to be fixed.\nSent from my mobile\n\nOn Dec 5, 2014, at 7:30 AM, Gergely Nagy notifications@github.com\nwrote:\nFWIW, in Scheme (Guile):\n(car (cons 1 2))\n; => 1\n(cdr (cons 1 2))\n; => 2\nSo in other lisps, where cons are supported, (rest) returns the tail. Hy\ndiffers here, and that's unfortunate. Can we fix this, please?\n\u2014\nReply to this email directly or view it on GitHub.\n\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/696#issuecomment-65791703.\n\n\n:wq\n. Thanks for the fix! :D\nOn Sat, Dec 6, 2014 at 11:02 AM, Berker Peksag notifications@github.com\nwrote:\n\nDone in b78f0e3\nhttps://github.com/hylang/hy/commit/b78f0e3b7972e2cd9d63beb9fa31d43e93a9ef9a.\nThanks again! :)\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/pull/697#issuecomment-65903205.\n\n\n:wq\n. :+1: :heart: \n. Really nice! Thanks so much!\n. Nice one! Thanks, @NathanW2 !\n. Hah, nice\n. Thanks, @rwtolbert !\n. @hylang/core let's get a PR in place. This is the last blocker for the release\n. +1 for a release. I'll do it tonight.\nOn Sun, Apr 26, 2015 at 5:26 AM, Berker Peksag notifications@github.com\nwrote:\n\n+1 for a new release. Already merged changes:\n- #795 https://github.com/hylang/hy/pull/795\n- #773 https://github.com/hylang/hy/pull/773\n- #762 https://github.com/hylang/hy/pull/762\n- #763 https://github.com/hylang/hy/pull/763\n- #756 https://github.com/hylang/hy/pull/756\n- #795 https://github.com/hylang/hy/pull/795\n- #753 https://github.com/hylang/hy/pull/753\netc.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/709#issuecomment-96352503.\n\n\n:wq\n. Ach. OK, I'll look at work I need to do an PR them. Sorrrrryyyyy.\nOn Mon, Apr 27, 2015 at 11:26 AM, Morten Linderud notifications@github.com\nwrote:\n\nI think we need those yield-from bugs fixed before a release looks at\npaultag\nOn 04/27/2015 04:59 PM, Paul\u202eetnomailgaT\u202d wrote:\n\n+1 for a release. I'll do it tonight.\nOn Sun, Apr 26, 2015 at 5:26 AM, Berker Peksag <notifications@github.com\nwrote:\n\n+1 for a new release. Already merged changes:\n- #795 https://github.com/hylang/hy/pull/795\n- #773 https://github.com/hylang/hy/pull/773\n- #762 https://github.com/hylang/hy/pull/762\n- #763 https://github.com/hylang/hy/pull/763\n- #756 https://github.com/hylang/hy/pull/756\n- #795 https://github.com/hylang/hy/pull/795\n- #753 https://github.com/hylang/hy/pull/753\netc.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/709#issuecomment-96352503.\n\n\n:wq\n\u2014\nReply to this email directly or view it on GitHub <\nhttps://github.com/hylang/hy/issues/709#issuecomment-96687927>.\n\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/709#issuecomment-96707659.\n\n\n:wq\n. I'm calling a punt on https://github.com/hylang/hy/issues/691 for this release\n. and punting on https://github.com/hylang/hy/issues/692 for this release too. Both are non-trivial at the moment.\n. Where we at on #707 ?\n. Let's add that as a blocker\nOn Apr 29, 2015 10:43 PM, \"Zack M. Davis\" notifications@github.com wrote:\n\n(If I may be so bold, I would like to suggest merging #796\nhttps://github.com/hylang/hy/pull/796 before a release\u2014passing\nanonymous functions as arguments is the sort of thing that one would expect\nto work in a Lisp, and the three-line patch probably isn't very expensive\nto review.)\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/709#issuecomment-97639164.\n. We can do https://github.com/hylang/hy/issues/740 on the next cycle, I'm doing a release now :)\n. Oh wait, we don't have NEWS. Can someone send up a NEWS? We're good to release once that's in master.\n. Where's this at, @berkerpeksag has +1? We've got one from @Foxboron - let's land this! :)\n. Ping! I'd love to get this merged when it's ready!\n. I'm going to close this until things are cleaned up -- please re-open it when it's ready!\n. Actually this was how I originally had it, but we wanted to assign stuff to\nnil\n\ne.g.\n(let [[x] [y 1]])\nIf that's still an argument, I don't know\nOn Thu, Dec 11, 2014 at 8:20 AM, J Kenneth King notifications@github.com\nwrote:\n\nI think more research is needed.\nI remember reading somewhere that McCarthy lamented there couldn't be\nfewer parentheses in let binding forms. I'd like to recall what held them\nback from doing what we're proposing here.\nObviously we don't have historical baggage yet but what else is there? We\ndon't have flet yet or let* but what about macros etc?\nSent from my mobile\n\nOn Dec 11, 2014, at 2:02 AM, Gergely Nagy notifications@github.com\nwrote:\n+1.\nIIRC the double [[ was there originally, because that was much easier to\nimplement. The reason for for only having one, is that you can only specify\none pair there, no?\n\u2014\nReply to this email directly or view it on GitHub.\n\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/713#issuecomment-66617626.\n\n\n:wq\n. I'm with @emidln on this - I share that point of view strongly. The original implementation looked like Clojure's let, but we wanted to start adding consistency. \nWhat this means for us for 1.0, I'm not sure. We just broke keywords pretty hard, now's the time to fix the language.\n. LGTM; this is awesome! Nice work, @unmerged !\n. Yeah, I'm a pytest fan too -but the python 3 skipping stuff is due to\nsyntax errors not runtime behavior changes :)\nOn Sun, Dec 14, 2014 at 7:55 PM, Ryan Gonzalez notifications@github.com\nwrote:\n\n+1 Pytest is much nicer than nose (which isn't even a test framework).\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/720#issuecomment-66938464.\n\n\n:wq\n. Yep, send it in!\nOn Tue, Dec 16, 2014 at 12:59 PM, Ryan Gonzalez notifications@github.com\nwrote:\n\nWould adding assoc to hy.core.shadow work?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/724#issuecomment-67202392.\n\n\n:wq\n. On Tue, Dec 16, 2014 at 2:15 PM, Ryan Gonzalez notifications@github.com\nwrote:\n\nassoc\n\n'assoc should work? Hunh. Push it up somewhere :)\n\n:wq\n. Seems fine:\n```\n=> (let [[x assoc]] (x {} \"foo\" \"bar\"))\nfrom hy.core.shadow import assoc\ndef _hy_anon_fn_1():\n    x = assoc\n    return x({}, 'foo', 'bar')\n_hy_anon_fn_1()\n=>\n```\nOn Tue, Dec 16, 2014 at 3:41 PM, Ryan Gonzalez notifications@github.com\nwrote:\n\n@paultag https://github.com/paultag\nhttps://github.com/kirbyfan64/hy/tree/shadow_assoc\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/724#issuecomment-67228192.\n\n\n:wq\n. Are you talking about https://github.com/hylang/hy/issues/647\nTest out https://github.com/paultag/hy/tree/paultag/bugfix/fix-apply -\nperhaps also help me out with tests :)\nOn Tue, Dec 16, 2014 at 3:45 PM, Ryan Gonzalez notifications@github.com\nwrote:\n\n@paultag https://github.com/paultag But...\nryan@DevPC-LX:~/stuff/hy4$ python -c \"import hy.cmdline; hy.cmdline.hy_main()\"\nhy 0.10.1 using CPython(default) 2.7.6 on Linux\n=> (apply assoc [{} \"a\" 1])\n  File \"\", line 1, column 8\n(apply assoc [{} \"a\" 1])\n         ^----^\nHyTypeError: `assoc' needs at least 3 arguments, got 0.\n=>\nthe issue still isn't solved.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/724#issuecomment-67228751.\n\n\n:wq\n. try paultag/bugfix/fix-apply -- I do that so folks can fetch my repo into\ntheir repo and not worry about conflicting names on checkout\nOn Tue, Dec 16, 2014 at 4:38 PM, Ryan Gonzalez notifications@github.com\nwrote:\n\n@paultag https://github.com/paultag How is that cloned? I tried:\ngit clone https://github.com/paultag/hy.git -b bugfix/fix-apply\ngit clone https://github.com/paultag/hy.git -b fix-apply\ngit clone https://github.com/paultag/hy.git -b bugfix\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/724#issuecomment-67236828.\n\n\n:wq\n. Not yet, I'd love some test cases for fix-apply - if you want to fork that\nand send that in with test cases, that'd be <3 <3 -- then we can base the\nassoc change on top of that once we get the PR merged\nShould be clean, I remember that branch being pretty minimal :)\nOn Tue, Dec 16, 2014 at 4:43 PM, Ryan Gonzalez notifications@github.com\nwrote:\n\n@paultag https://github.com/paultag Got it! It works! Do you want me to\nmerge it into the changes I made and open a PR?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/724#issuecomment-67237584.\n\n\n:wq\n. This also seems to break an unrelated test -- thrilling\n. Tests are failing, re-open when this guy's ready!\n. Interesting approach!\n. I'll get on a more in depth review with how this is structured, since this adds a bunch of new things to internals. Very cool work, though!\n. Ah, yes, the news is I'm literally the worst.\nLet's get eyes on this and tend to it - ping @hylang/core \n. Interesting approach, using Exceptions. The overhead on this might slow it down, but short of crosscutting into Bytecode, we can't have GOTO/JUMP instructions. \nThis is pretty similar (but not similar enough to merge with) https://github.com/hylang/hy/blob/master/hy/contrib/loop.hy -- not sure which I like more.\nCan we move this to contrib to start with? This is a total no brainer for contrib right now, but I'd love to battle test this a little before putting it into core.\nReally interesting work. I like it. Well done, @Tritlo \n. Merge conflicts against master - mind updating? I'm going to close this until it's ready :)\n:+1: \n. Yeah let's find a good literal syntax\nOn Dec 27, 2014 4:48 PM, \"Berker Peksag\" notifications@github.com wrote:\n\nReopened #732 https://github.com/hylang/hy/issues/732.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/732#event-212228054.\n. I'd be happy to hack a bit on documenting example usage patterns from OO to\nHy!\nOn Dec 29, 2014 11:36 AM, \"Berker Peksag\" notifications@github.com wrote:\n+1\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/735#issuecomment-68272812.\n. Yeah, but its ugly :) - I'll have to clean that up soon\nOn Mar 24, 2016 3:32 PM, \"Matthew Egan Odendahl\" notifications@github.com\nwrote:\nDon't we have one of those?\nhttps://github.com/hylang/hy/blob/master/eg/flask/meth_example.hy\n\u2014\nYou are receiving this because you commented.\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/735#issuecomment-200984475\n. Love the approach!\nOn Dec 29, 2014 10:18 AM, \"Adam Schwalm\" notifications@github.com wrote:\nThis fixes #305 https://github.com/hylang/hy/issues/305 by adding a new\ntoken PARTIAL_STRING, which causes the parser to raise PrematureEndOfInput\nif encountered.\nYou can merge this Pull Request by running\ngit pull https://github.com/ALSchwalm/hy multiline-str\nOr view, comment on, or merge it at:\nhttps://github.com/hylang/hy/pull/736\nCommit Summary\n- Add support for multi-line strings in interpreter\nFile Changes\n- M hy/lex/lexer.py\n  https://github.com/hylang/hy/pull/736/files#diff-0 (10)\n- M hy/lex/parser.py\n  https://github.com/hylang/hy/pull/736/files#diff-1 (6)\n- M tests/lex/test_lex.py\n  https://github.com/hylang/hy/pull/736/files#diff-2 (7)\nPatch Links:\n- https://github.com/hylang/hy/pull/736.patch\n- https://github.com/hylang/hy/pull/736.diff\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/pull/736.\n. Nice work, @ALSchwalm!\n. :+1:\nOn Dec 29, 2014 10:52 AM, \"Christopher Allan Webber\" \nnotifications@github.com wrote:\nMerged #737 https://github.com/hylang/hy/pull/737.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/pull/737#event-212501059.\n. I'm -1 on return, but let's open a bug and discuss. Basically, I'm worried\nwe'll wind up with a Ruby-style mess, and having return values be confusing\nto grok.\n\nOn Fri, Jul 24, 2015 at 11:02 AM, Morten Linderud notifications@github.com\nwrote:\n\n@hylang/core https://github.com/orgs/hylang/teams/core opinions? Might\nbe a good idea for the cleanup\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/739#issuecomment-124551856.\n\n\n:wq\n. My main objection is not ascetic. Two ways to do something is something I'd\nprefer to avoid :)\nOn Feb 25, 2016 5:57 PM, \"ez47\" notifications@github.com wrote:\n\nI'm also -1 on return. I really like building code where last value of\nfunction is returned, without having to have return there.\nkill yourself, seriously what kind of argument is that?\nreturn function should be included not only for the compatibility between\npython but even beyond that, a truely functional way of programming is the\nspecification pattern where you SPECIFY both the INPUT and the OUTPUT .\nwith which you can chain and compose arbitrary pieces of logic.\ninstead of this\n'''\n(defn specify clause &rest work\n(eval exePointer))\n(specify (not form) (do_something) '(\"no form\"))\n'''\nwhich doesnt even work.\nyou could have something like\n'''\n(specify (not form) (do_something) '(return \"no form\"))\n'''\nLanguages shouldnt be treated like some artsy past time, 1 return per\nfunction is a high level human constraint, not a logical one.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/739#issuecomment-189020861.\n. @ez47 your attitude is entirely unwelcome and that you're not constructively adding to the conversation.\nkill yourself\n\nIs not appropriate.\nI also feel like these comments are not adding any signal to this bug.\n. Locking this issue. Folks can prod me about this but I'm not enjoying the way this went.\n. :+1: thanks! :dancer: \n. Hey, looks great! Thanks, @iKevinY and @berkerpeksag !\nI love the Harry Potter quote! :D Thanks! You rock! \n. What exactly breaks?\n(hy)[tag@cassiel:~][\u231a 06:06 PM] \u2665  hy\nhy 0.10.1 using CPython(default) 3.4.2 on Linux\n=> (defn call-this [some-func]\n...   (some-func \"yup\"))\n=>\n=> ;; this works fine, as a \"lambda one-liner\"\n=> (call-this :some-func (lambda x))\nyup\n=>\n=> ;; so does this, with a more complex lambda, as a positional argument\n=> (call-this (lambda x))\nyup\n=>\n=> ;; but this doesn't, as a keyword argument\n=> (call-this :some-func (lambda x))\nyup\n=>\n\n:wq\n. What's the status of this PR? cc/ @algernon \n. No update on this PR; closing. Re-open when it's ready!\n. Let's merge bugfix code with low regression potential quicker :)\nOn Jan 16, 2015 5:13 PM, \"Morten Linderud\" notifications@github.com wrote:\n\nThe code looks sane. But i'll pull this and play with it a little before\napproving it..\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/pull/756#issuecomment-70331129.\n. :+1: thanks!\n. Very interesting PR series - I like it! LGTM!\n. @hylang/core RFR\n. This approach is just so much better.\n\nRFR @hylang/core - I'll give it a review in a sec\n. Yep, LGTM. This will save a bunch of stupid bugs from happening. Really great work, @larme \n. :+1: let's do this! Let's get a PR lined up and land it -- it's a widely used feature and I miss it too :)\n. LGTM! Thanks! :dancer: \n. Hey, @rhaps0dy mind sending a PR adding yourself to AUTHORS?\n. Yeah; we need a shaddow entry for these guys\n. \\o/\nOn Wed, Mar 11, 2015 at 7:24 PM, Tianon Gravi notifications@github.com\nwrote:\n\nGot a working patch:\nhy 0.10.1 using CPython(default) 3.4.2 on Linux=> (list (map < [4 7 5 9] [1 9 4 9]))[False, True, False, False]=> (list (map <= [4 7 5 9] [1 9 4 9]))[False, True, False, True]=> (list (map > [4 7 5 9] [1 9 4 9]))[True, False, True, False]=> (list (map >= [4 7 5 9] [1 9 4 9]))[True, False, True, True]\nOn to tests!\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/775#issuecomment-78394827.\n\n\n:wq\n. <3 thanks!\nOn Thu, Mar 12, 2015 at 7:06 AM, Berker Peksag notifications@github.com\nwrote:\n\nThanks!\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/pull/776#issuecomment-78460506.\n\n\n:wq\n. LGTM! RFR @hylang/core \n. Could you post the hy2py of your rhy script?\nOn Mar 15, 2015 12:10 PM, \"\u30e8\u30fc\u30f3\u30c8\" notifications@github.com wrote:\n\nI tried the example in the eg/ folder and I get\n[translation:ERROR] Exception: object with a call is not RPython: \n[translation:ERROR] Processing block:\n[translation:ERROR]  block@46 is a \n[translation:ERROR]  in (test:9)main\n[translation:ERROR]  containing the following operations:\n[translation:ERROR]        v1 = simple_call((function fib), v0)\n[translation:ERROR]        v2 = simple_call((builtin_function_or_method print), v1)\n[translation:ERROR]  --end--\nideas?\nthanks!\nPS: i'm using python2 on ArchLinux, the PyPy source I have is 3-2.4.0\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/780.\n. What's the status here? Let's get this guy ready! :D \n. Nice work, y'all!\n\nAnd, thanks Antony!\nOn Wed, Apr 8, 2015 at 3:02 AM, Antony notifications@github.com wrote:\n\nThank you folks! Great to see such a positive, engaging team.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/pull/782#issuecomment-90824741.\n\n\n:wq\n. Looks like this is a bit out of date with master, and no update for a while. Closing this until it's ready - re-open it once we're ready again!\n. PR from @nicolas-p was merged, closing this ticket! Thank you!\n. Oh this feature is awesome\n. Very much LGTM, really outstanding work, @nicolas-p \n. @hylang/core RFR\n. @nicolas-p :confetti_ball: :confetti_ball: :confetti_ball: :confetti_ball: :confetti_ball: \nThank you so much! That's amazing! It really means a lot to all of us! :heart: \n. You can use a bare quote, and use a string, like many python people do :)\nOn Apr 7, 2015 8:44 AM, \"acekingke\" notifications@github.com wrote:\n\njust single comment?\n; as comment\nbut I enjoy the multiline comment like C languange /**/\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/789.\n. You can use a bare quote, and use a string, like many python people do :)\nOn Apr 7, 2015 8:44 AM, \"acekingke\" notifications@github.com wrote:\njust single comment?\n; as comment\nbut I enjoy the multiline comment like C languange /**/\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/789.\n. (while fun, this also requires valid syntax inside the comment)\n\nOn Tue, Apr 7, 2015 at 9:39 AM, Brandon Adams notifications@github.com\nwrote:\n\n(defmacro comment [& body] nil)\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/789#issuecomment-90557073.\n\n\n:wq\n. (while fun, this also requires valid syntax inside the comment)\nOn Tue, Apr 7, 2015 at 9:39 AM, Brandon Adams notifications@github.com\nwrote:\n\n(defmacro comment [& body] nil)\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/789#issuecomment-90557073.\n\n\n:wq\n. Sure :)\nOn Tue, Apr 7, 2015 at 9:43 AM, Brandon Adams notifications@github.com\nwrote:\n\nWell, yes. To be fair, most things ar valid syntax if they're not being\nevaluated.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/789#issuecomment-90557768.\n\n\n:wq\n. because ' is quote, use \" :)\nOn Tue, Apr 7, 2015 at 11:54 AM, Jared Forsyth notifications@github.com\nwrote:\n\nDoing this:\n(print 'hi')\nResults in:\nLexException: Could not identify the next token.\nUnboundLocalError                         Traceback (most recent call last)\nUnboundLocalError: local variable 'tokens' referenced before assignment\nWhich is confusing...\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/790.\n\n\n:wq\n. to be clear, quote as in a quoted form, which is to say - 'foo is valid\nsyntax\nOn Tue, Apr 7, 2015 at 11:54 AM, Paul R. Tagliamonte paultag@gmail.com\nwrote:\n\nbecause ' is quote, use \" :)\nOn Tue, Apr 7, 2015 at 11:54 AM, Jared Forsyth notifications@github.com\nwrote:\n\nDoing this:\n(print 'hi')\nResults in:\nLexException: Could not identify the next token.\nUnboundLocalError                         Traceback (most recent call last)\nUnboundLocalError: local variable 'tokens' referenced before assignment\nWhich is confusing...\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/790.\n\n\n:wq\n\n\n:wq\n. I don't get that, funny :)\n```\n[tag@helios:~/dev/sunlight/moxie-jobs][\u2387  master] \u2665  hy\nhy 0.10.1 using CPython(default) 3.4.2 on Linux\n=> (print 'foo')\nLexException: Could not identify the next token.\n=>\n```\nWhich is the \"right\" error, I guess. We could make it better, I guess, have\na patch in mind?\nOn Tue, Apr 7, 2015 at 2:48 PM, Jared Forsyth notifications@github.com\nwrote:\n\nRight, I know this is wrong syntax. The error message is confusing though.\nWhy an UnboundLocalError?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/790#issuecomment-90695645.\n\n\n:wq\n. That's Python 2 only - and I think we can make it work by fixing the\nargument compiles --\nwith hy --spy:\n=> (defn x [(, a b)])\ndef x((u',' u'a' u'b')):\n    pass\n=>\nappears to be buggy\nOn Tue, Apr 7, 2015 at 3:23 PM, Jared Forsyth notifications@github.com\nwrote:\n\nbut why not have it be a language feature? Python already has function\nargument destructuring built-in\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/792#issuecomment-90705742.\n\n\n:wq\n. Can someone confirm that syntax works in py 3\nOn Apr 7, 2015 6:21 PM, \"Jared Forsyth\" notifications@github.com wrote:\n\nWould it take better advantage of the python runtime to just convert it\ninto the ast generated by this?\ndef foo((a,b)):\n  print a+b\nFor reference, here is the ast for the function's args in python 2.7\n\"args\": {\n  \"_type\": \"\",\n  \"args\": [\n    {\n      \"elts\": [\n        {\n          \"_type\": \"\",\n          \"ctx\": {\n            \"_type\": \"\"\n          },\n          \"id\": \"a\",\n          \"col_offset\": 7,\n          \"lineno\": 2\n        },\n        {\n          \"_type\": \"\",\n          \"ctx\": {\n            \"_type\": \"\"\n          },\n          \"id\": \"b\",\n          \"col_offset\": 9,\n          \"lineno\": 2\n        }\n      ],\n      \"_type\": \"\",\n      \"ctx\": {\n        \"_type\": \"\"\n      },\n      \"lineno\": 2,\n      \"col_offset\": 7\n    }\n  ],\n  \"kwarg\": null,\n  \"defaults\": [],\n  \"vararg\": null\n},\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/pull/793#issuecomment-90748451.\n. So, LGTM, however, before we merge, let's check in on Python 3.5 - I think there's some advanced unpacking stuff coming down the pipe - it would be interesting if we made this 3.3 -> 3.4 only. Can someone check up on that?\n. Nope I lied. Perhaps 3.6? I think this is good to merge.\n. def x(_hy_anon_var_1):\n    [x, y] = _hy_anon_var_1\n    [x, y]\n\nI wonder if that's due to not using as_expr right in the Result\n. (hy-spy session)\n=> (defn x [[x y]] (print x y))\ndef x(_hy_anon_var_1):\n    [x, y] = _hy_anon_var_1\n    [x, y]\n    return print(x, y)\n=> (x [1 2])\nx([1, 2])\n1 2\n. Otherwise LGTM. Let's just explain that and perhaps patch it before merge.\n. @kirbyfan64 so when you run hy --spy and do the following in the REPL:\n=> (defn x [[x y]] (print x y))\ndef x(_hy_anon_var_1):\n    [x, y] = _hy_anon_var_1\n    [x, y]\n    return print(x, y)\nThe generated AST has a stray [x, y], which I'm assuming is for expr-asignment on the code-branch in the fn. I think if we use the Result object, and let the as_expr handle the return, that block won't result in the code branch.\nThe generated code will run fine, but just has a stray instruction there to create a list :)\n. OK, I'm happy calling that a setv bug. LGTM!\n. I'm going to close this since @berkerpeksag points out the clojure & foo is &rest foo here :)\n. Yesssssssssss\nOn Apr 13, 2015 1:23 AM, \"Zack M. Davis\" notifications@github.com wrote:\n\nConditional on berkerpeksag/astor#17\nhttps://github.com/berkerpeksag/astor/pull/17\u2014\nPython 3.5 will have a new commercial-at infix operator with the magic\nmethods matmul, rmatmul, and imatmul, unused as yet in the\nstandard library, but intended to represent matrix multiplication in\nnumerical code; see PEP 465 (https://www.python.org/dev/peps/pep-0465/)\nfor details. This commit (developed against Python 3.5 alpha 3) brings\nsupport for this operator to Hy when running under Python 3.5 (or,\nhypothetically as yet, greater). For Hy under Python <= 3.4, attempting\nto use @ in function-call position currently results in a NameError;\nthis commit does not change that behavior.\nThis is intended to resolve #668 https://github.com/hylang/hy/issues/668\n.\nYou can view, comment on, or merge this pull request online at:\nhttps://github.com/hylang/hy/pull/795\nCommit Summary\n- adds support for Python 3.5 infix matrix multiplication\nFile Changes\n- M hy/compat.py\n  https://github.com/hylang/hy/pull/795/files#diff-0 (1)\n- _M hy/compiler.py\n  https://github.com/hylang/hy/pull/795/files#diff-1 (16)\n- M tests/native_tests/mathematics.hy\n  https://github.com/hylang/hy/pull/795/files#diff-2 (51)\nPatch Links:\n- https://github.com/hylang/hy/pull/795.patch\n- https://github.com/hylang/hy/pull/795.diff\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/pull/795.\n. \\o/\n\nNice work, y'all!\nOn Sun, Apr 26, 2015 at 5:22 AM, Berker Peksag notifications@github.com\nwrote:\n\nThanks @zackmdavis https://github.com/zackmdavis :)\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/pull/795#issuecomment-96351063.\n\n\n:wq\n. Let's keep it productive, things like \"???\" aren't helpful.\nI think this is talking about range being a generator of infinate numbers - perhaps itertools.count?\nhy\n=> (import itertools)\n=> (take 4 (itertools.count))\n<itertools.islice object at 0x7f69d8dcb4a8>\n=> (list (take 4 (itertools.count)))\n[0, 1, 2, 3]\n. NICE! Thanks so much!\n. LGTM! @hylang/core RFR\n. Yep! Thank you!\nOn Jul 23, 2015 12:40 AM, \"Zack M. Davis\" notifications@github.com wrote:\n\nMerged #800 https://github.com/hylang/hy/pull/800.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/pull/800#event-363021262.\n. @acron0 :heart: thanks for your time anyway!\n. Oh fuck yes. Hella LGTM\n\n@hylang/core RFR - let's get this landed. \n. @zackmdavis looks like there's been no update on this for a while, closing this until it's ready. I love this feature, asyncio is a fav of mine, so I'd love for this to be re-opened once it's updated\n. Yeah, a lot of code Hy creates isn't valid Python source --\nfrom hy --spy\nhy\n=> (defn foo! [] (print \"Hi!\"))\npython\ndef foo!():\n    return print('Hi!')\nBecause we never write out Python, it works, since we write AST, not Python source :)\nThere are bunches of things hy2py won't get right, and I don't think anyone's pushed for it to be more than a debugging mode -- is there a reason you're using the source and not the AST?\n. @bollwyvl and just to expand on @Foxboron - we interop in both directions, 100% - the issue is we only target the AST, not code - we don't output templated Python, we construct Python AST -- stuff like pdb works on Hy, and it works because of how careful we are -- we just don't target the Python source, we target the Python runtime\n. Just to drive the point home a bit more::\n```\n(hy)[tag@sol:~][\u231a 04:13 PM] \u2665  cat foo.hy \n(defn square [x] (* x x))\n(hy)[tag@sol:~][\u231a 04:13 PM] \u2665  cat bar.py \nimport hy\nimport foo\nprint(foo.square(8))\n(hy)[tag@sol:~][\u231a 04:14 PM] \u2665  python bar.py \n64\n(hy)[tag@sol:~][\u231a 04:14 PM] \u2665\n. As for `*`, after thinking about it and looking at the AST, you're both right and it still works, since it imports everything from shadow (perhaps not the best idea, I wonder if we should change up how we handle var names to do an attr lookup rather) :)\n.\n=> (let [[x ]])\n\n=> (get (locals) \"\")\n\n=> (get (locals) \"+\")\n\n=> \n```\n. @bollwyvl Yeah, I think the team here largely considers the generation of Python source code largely a byproduct of our debugging techniques, and not as a first-class target -- I'm open to work making it more supported, but I'm not sure how much work that'd be\nWe provide nearly identical interface(s) as Python's internals, so if the Python kernel can do X, I'm positive we can land support for a modified X that also works with Hy, but just talks AST, or shims out (e.g. our PEP302 loader, etc)\nBTW; I love your work on hy_kernel, thanks so much for working on it :)\n. @hylang/core - if anyone disagrees, please speak up :) :+1: \n. :+1: thank you!\n. @ewaldgrusk Any chance we could get tests passing? I'd love to merge this! \n. Yeah, this is wonderful, can we grab a test, @ewaldgrusk ? Otherwise LGTM!\n. @ewaldgrusk This one is a total no-brainer, but can we get this updated against master and a test added? I'm going to close it while we wait -- wish we could have this in master!\n. :+1: my vague emotions as well\n. Yeah, even though the Hy community has been outstanding in this regard, codifying it is a must. Thanks, @algernon !\n. I'm +1; thanks for the suggestion @berkerpeksag and thank you for all you've done so far, @zackmdavis !\nReally means a lot to all of us, @zackmdavis - truely! Thanks for being an awesome part of our community.\nI trust his work completely, I say we grant core - let's get a PR up against the docs.\nBaring objections from anyone in @hylang/core - let's do this in 3 days\n. Invited! Updated core.rst, welcome to Hy Soceity! Thank you!\n. Let's go with #815 \n. :heart: \n. Awesome, thanks!\n. I wonder if we can constrain what we find in the or/and as conceptually part of the same scope and cheat a little.\n. e.g. actually getting aggressive with nonlocal \n. Just re-read my comment, it's basically \"fix scoping\"\n\n. @gilch I don't see #842 as blocking this, let me get a review on this\n. @hylang/core RFR \n. @gilch let's break this into two - first is lack of (/ 2) support. I think that's not bad. Let's add it. \nHere's how it was added for plus - https://github.com/hylang/hy/blob/master/hy/compiler.py#L1725\nAlso let's double check on the shadow opers\n. Second: the fraction type. Interesting idea. Can we file a second bug on that and see what we can do there?\n. Good gut, but I'm thinking that might be a bit confusing.\nI'm mostly worried about how this interacts with code that expect a Long or\nsomething.\nExplicitly doing this won't be the end of the world (esp. with macros), but\nsome sort of contrib addon would be interesting.\nOn Fri, Jun 26, 2015 at 3:34 PM, Ryan Gonzalez notifications@github.com\nwrote:\n\nWhat I'm envisioning (here I'm going to use \\ for a fraction literal):\n(/ x) => (/ 1 x) ; reciprocal, like K\n(\\ x y) => (Fraction x y)\n(\\ y) => (Fraction 1 y)\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/825#issuecomment-115849202.\n\n\n:wq\n. Nice work so far. This is going to be great!\n. Sweet! This is great! LGTM! @hylang/core \n. (Can we add an empty set testcase? I see you added that codepath, it'd be good to exercise it, though!)\n. Sweet. LGTM! @berkerpeksag good to merge?\n. You're awesome. Thanks, @kirbyfan64 and @berkerpeksag ! Outstanding work!\n. (and you too @Foxboron - of course :))\n. I think you want (disassemble)\n. => (print (disassemble '(fn [] (print \"hi!\")) true))\ndef _hy_anon_fn_1():\n    return print('hi!')\nOr run hy --spy\n. from IRC:\n14:09 < paultag> we should perhaps make keywords actual objects\n14:09 < paultag> rather then utf-8 strings\n14:09 < paultag> I think we long lost the hy import thing\n14:10 < paultag> we did it that way (you did it that way :) ) because it\ndidn't add hy dep on runtime\n14:10 < paultag> now we nearly always have one\n14:10 < paultag> so might as well just make it an object\n14:10 < paultag> which we can also make __call__'able\n14:10 < paultag> without having a compiler special case\n14:10 < algernon> was thinking along the same lines.\n14:10 < paultag> which also makes it map'able\n14:11 < algernon> I'll add that to the milestone, to collect more input\n14:11 < paultag> ++\n14:11 < paultag> \u2665\n. So, unfortunately, it won't fix it, due to the compiler being a bit dumb\nabout some of this stuff\nNamely, if the compiler sees a form with a name, and that name is a\nbuiltin, it'll generate the AST for it. Since assoc turns into index\nassignment, it'll\nalways do that, without turning it into an ast.Call.\nI would be open to a patch removing assoc from builtins entrirely, and\nturn it into a function, though!\n. Yeah, hunh. What's the hy function look like?\nOn Jul 14, 2015 12:20 PM, \"Ryan Gonzalez\" notifications@github.com wrote:\n\n@paultag https://github.com/paultag I have a fix \"ready\" here\nhttps://github.com/kirbyfan64/hy/commit/7eb1353e09aca6db78223e828b741bbe8b293e01,\nbut it's giving a really weird error:\nryan@DevPC-LX:~/stuff/hy$ ./run\nhy 0.11.0 using CPython(default) 2.7.6 on Linux\n=> (setv x {})\n=> (assoc x 2 2)\nTraceback (most recent call last):\n  File \"\", line 1, in \n  File \"/media/ryan/stuff/hy/hy/core/language.hy\", line 301, in assoc\n    (is x None))\nNameError: global name 'v' is not defined\n=>\nryan@DevPC-LX:~/stuff/hy$\nThis is what hy2py outputs for hy/core/language.hy:\ndef assoc(tgt, *args):\n    if (not is_even(len(args))):\n        raise TypeError(u'expected an even number of key-value pairs')\n        _hy_anon_var_2 = None\n    else:\n        _hy_anon_var_2 = None\n    it = iter(args)\n    for [k, v] in zip(it, it):\n        tgt[k] = v\n    return tgt\nIt looks like it should work. What's wrong?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/841#issuecomment-121295557.\n. @kirbyfan64 it means I don't really want 2.6 to block test passage anymore -- I didn't pull our codepaths, so it'll continue until it becomes too much of a maintenance burden -- thoughts?\n. (Python 2.6 was officially EOL'd in 2013)\n. Let's wait to make sure @kirbyfan64 doesn't have blocking objections, and if we're good, we'll merge!\n. @kirbyfan64 fuck it, let's drop 2.6 - if someone needs it, we can re-introduce. Fire away with set literals, that counts as a maintenance burden \n. I prefer let as well, but it's pretty broken, and my attempts over the last two days to fix the yield behavior turn out to be really hard.\n\nIn particular, you have to know if let is in a function or not (which makes it double-hard), and I'm thinking we either need AST macros (ugh, I kinda hate this idea) or bail on let. I'm starting to think we need to do a serious cleaning.\nI say we prune out a bunch of stuff, get things into a one-true-way thing, and fix things like double square brackets. Throughout the language. I'd rather see this breakage once.\n. Fact is, our semantics are tied to Python, and our efforts to wrap that away are, well, basically endless.\nThe semantics of scoping and stuff are pretty annoying (no Let-over-lambda), so I'd rather clean out everything broken and start to re-add things as we get them correct. This will piss off anyone with existing Hy code.\n. Thinking further, we could move those functions and macros we're pulling out into a contrib shim for the next release to give folks migration time.\n. Yeah. No problem. Let's get a ticket open with a TODO of things to fix. We\nshouldl appoint someone from core to BDFL this.\nOn Fri, Jul 24, 2015 at 9:47 AM, Gergely Nagy notifications@github.com\nwrote:\n\nCan we do the cleanup before ~september? I'd rather go into production\nwith \"modern\" Hy.\n(The contrib shim sounds like a reasonable idea.)\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/844#issuecomment-124526741.\n\n\n:wq\n. @algernon is cleanup BDFL, he's on the job!\nOn Fri, Jul 24, 2015 at 10:04 AM, J Kenneth King notifications@github.com\nwrote:\n\n:D\n\nOn Jul 24, 2015, at 9:49 AM, Paul\u202eetnomailgaT\u202d notifications@github.com\nwrote:\nYeah. No problem. Let's get a ticket open with a TODO of things to fix.\nWe\nshouldl appoint someone from core to BDFL this.\nOn Fri, Jul 24, 2015 at 9:47 AM, Gergely Nagy notifications@github.com\nwrote:\n\nCan we do the cleanup before ~september? I'd rather go into production\nwith \"modern\" Hy.\n(The contrib shim sounds like a reasonable idea.)\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/844#issuecomment-124526741.\n\n\n:wq\n\u2014\nReply to this email directly or view it on GitHub.\n\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/844#issuecomment-124533216.\n\n\n:wq\n. @rcarmo anything we do remove will be moved into a contrib module with its current behavior exactly - so we can have some time to figure out how (or if) we reintroduce them. I prefer (let), too, and nearly all my code will break if we remove it, but I see the point that it's really horrifically broken because of Python scoping.\nWhat are your thoughts?\n. Or let setv take multiple pairs\nOn Jul 24, 2015 1:23 PM, \"Gergely Nagy\" notifications@github.com wrote:\n\nI'd keep some kind of let. A macro that expands to a set of setvs, to\nat least seem familiar. But then, calling that let may not be the best\nidea...\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/844#issuecomment-124585771.\n. Let's get a bug and PR on that\nOn Jul 24, 2015 1:29 PM, \"Abhishek L\" notifications@github.com wrote:\nlike {e,c}lisp's setq\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/844#issuecomment-124587927.\n. Great! Let's get a PR together for this :) :+1: \n. I guess omitting braces is fine here, since there's no body following\n\nMy only hangup is if there's a consistency issue with the rest of the language - @hylang/core anyone see a need for braces or am I losing it?\nIf no one else sees a problem, I've got a :+1: LGTM here!\n. P.S., forgot to say - I love the return semantics.\n. Tests are bombing and no activity on this for a while :)\nClosing! Re-open when it's ready!\n. LGTM too!\n. @zackmdavis thanks! This is awesome!\n. I'm +1! Really great work, @farhaven!\nOn Tue, Jul 28, 2015 at 11:13:48PM -0700, Morten Linderud wrote:\n\nBased on his work here:\n   [1]https://github.com/hylang/hy/commits?author=farhaven\n   and vim-hy ([2]https://github.com/hylang/vim-hy/commits?author=farhaven)\n+1\n   [3]:shipit: [4]:dancer:\n\u2014\n   Reply to this email directly or [5]view it on GitHub.\nReverse link: [6]unknown\nReferences\nVisible links\n1. https://github.com/hylang/hy/commits?author=farhaven\n2. https://github.com/hylang/vim-hy/commits?author=farhaven\n3. https://github.com/hylang/hy/issues/865\n4. https://github.com/hylang/hy/issues/865\n\n\n.''.   Paul Tagliamonte <paultag@debian.org>    |   Proud Debian Developer\n: :'  :  https://people.debian.org/~paultag       |   https://pault.ag/. '               Debian - the Universal Operating System\n `-        4096R / 8F04 9AD8 2C92 066C 7352  D28A 7B58 5B30 807C 2A87\n. Thanks, @algernon ! Beat me to it :) :heart: \n. This is some proper hackery :)\nInteresting! I'm not huge on #G myself, but I love the idea, and I'm sure we can bikeshed the byte we put there cc/ @hylang/core \n. @gilch @kirbyfan64 what's the status of this? Can we update against master and address feedback?\nPlease re-open once it's updated!\n. Neat! Nice work!\nCan we make this into a real function? Any reason it has to be a macro?\n. Nice! Thanks a ton! :D \n. https://github.com/hylang/hy/commit/2167c211203fc1d43cb3a9d8c0d10598f7c55388 was my changeset adding product to for - https://github.com/hylang/hy/issues/573 was a bug that it introduced \n. and https://github.com/hylang/hy/pull/574 was when we reintroduced the current semantics\n. (Basically, they're similar (for and product) except when they're not because they can't be :) )\n. Huge fan.\n. Impl looks tidy. LGTM.\n. @gilch Ah, yeah, man, I thought you already had a commit in the repo already or I'd have said something - please add yourself to AUTHORS!\n. doc and squash sounds great!\n. @hylang/core good to merge once @gilch sorts out the squash and stuff!\n. I'm OK with purging true false null and nil.\nOn Aug 9, 2015 8:28 PM, \"Matthew Egan Odendahl\" notifications@github.com\nwrote:\n\nI'd also keep the true, false, null and nil aliases (because I use them a\nlot, and shift is far away).\nSee, I knew the other groups would be more controversial. This pull (so\nfar) only targets the first group, and we don't have to agree to fixing the\nother two before merging this part.\nWe can still talk about them though.\nAs for the second group, I'll admit to using the easier-to-type aliases\ntrue/false/nil almost exclusively in my own code, and they're used a lot\nin Hy proper. But I still think this is extra complexity for marginal\nbenefit.\nEven if you're not convinced by the following, can we at least get rid of\nnull? It's hardly ever used, and not easier to type than nil.\nCorrect me if I'm wrong about this assumption, but Python keywords have to\nbe reserved in Hy, because Hy compiles to Python and can be imported from\nPython. They don't have to mean the same thing in Hy as in Python, though\nthis can get confusing. def (for example) has a pretty different meaning,\nbut there's no other good meaning for True and False that we could use\ninstead. True/False/None are reserved in Python3. They cannot be assigned\nto in Python, and it would be problematic to allow this in Hy. Thus, if we\nhave to choose, the clear choice is the Python words.\nI am unconvinced by the argument that true and false are easier to type.\nTrue and False literals are actually not used as much as you might\nexpect. Sure, Booleans are used all the time, but usually you type in an\nexpression that evaluates to a Boolean rather than forcing one or the other\nyourself.\nThe case where Boolean literals get used the most is in testing. If you're\ntesting at the REPL and just need a generic truthy or falsey value, admit\nit, you're going to use 1 and 0 over even true and false, because it just\ndoes not get any easier to type than that.\nUnit tests, on the other hand, also serve as a kind of documentation. It's\nworth making them readable. Now if we decide that it's idiomatic in Hy to\nuse 1/0 for unit tests, then people will be used to it and it will not be\nconsidered hard to read. (Many of Hy's unit tests already do this by the\nway.) On the other hand, True and False are no less readable, and they\neven stand out more.\nI am also unconvinced by the argument that true and false are used all\nthe time. It's a simple one-line fix:\ntrue, false = True, False\nThe first group in the pull (which we do seem to agree on) breaks stuff a\nlot harder than this. Yes, the Grand Language Cleanup will break stuff.\nBest get it over with now. If removing true/false turns out to be a\nmistake, it will be an easily correctable mistake. If NOT removing true/\nfalse turns out to be a mistake, it will only get harder to fix.\nThere's a better argument for keeping nil, I suppose. This really does\nget used a lot. None could perhaps be used for something else, but I\ndon't know what. But nil may cause confusion for Common Lisp programmers\nexpecting it to be the empty list. None wouldn't have that connotation.\nI'd still prefer we be consistent and get rid of nil, but I'd be more\nwilling to make an exception here.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/pull/880#issuecomment-129263631.\n. Love it, nice!\n\nOn Mon, Aug 10, 2015 at 10:35 AM, Morten Linderud notifications@github.com\nwrote:\n\nMerged #885 https://github.com/hylang/hy/pull/885.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/pull/885#event-378059168.\n\n\n:wq\n. This looks stale, and from a quick glance, this looks like it won't work on Python 3K (right?)\nPlease re-open when it's ready!\n. Yes please. Thank you!\nOn Aug 11, 2015 6:30 PM, \"Matthew Egan Odendahl\" notifications@github.com\nwrote:\n\nThis pull only removes the redundant null from Hy. It is not sufficient\nclose #240 https://github.com/hylang/hy/issues/240, but it is a step in\nthe right direction.\nRationale: We already have None, and null was barely ever used anyway. If\nthis breaks something, a simple (def null None) will suffice to patch it.\nThe fate of the other redundant keywords remains open.\nYou can view, comment on, or merge this pull request online at:\nhttps://github.com/hylang/hy/pull/889\nCommit Summary\n- purged null from Hy\nFile Changes\n- M eg/debian/parse-rfc822.hy\n  https://github.com/hylang/hy/pull/889/files#diff-0 (2)\n- M hy/compiler.py\n  https://github.com/hylang/hy/pull/889/files#diff-1 (2)\n- M hy/lex/parser.py\n  https://github.com/hylang/hy/pull/889/files#diff-2 (1)\n- M tests/compilers/test_ast.py\n  https://github.com/hylang/hy/pull/889/files#diff-3 (4)\n- M tests/native_tests/language.hy\n  https://github.com/hylang/hy/pull/889/files#diff-4 (4)\n- M tests/native_tests/unless.hy\n  https://github.com/hylang/hy/pull/889/files#diff-5 (4)\n- M tests/native_tests/when.hy\n  https://github.com/hylang/hy/pull/889/files#diff-6 (4)\nPatch Links:\n- https://github.com/hylang/hy/pull/889.patch\n- https://github.com/hylang/hy/pull/889.diff\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/pull/889.\n. apply takes up to 3 arguments - callable, args and kwargs.\n\nhy\n (apply foo (+ [1 2 3] [4 5 6]))  ; works\n. in particular, CL isn't dealing with what we have to deal with with **kwargs (same with Clojure by not having kwargs)\n. Short of adding vectors around args and kwargs, I don't know how to do this\nin a clean and predictable way.\nAnd if + isn't good enough when you mix types, try itertools.chain.\nOn Aug 12, 2015 2:38 AM, \"Gergely Nagy\" notifications@github.com wrote:\n\nSlapped a Grand Language Cleanup milestone on this one.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/891#issuecomment-130186760.\n. No, I mean (apply [1 2])\nOn Aug 12, 2015 11:16 AM, \"Matthew Egan Odendahl\" notifications@github.com\nwrote:\nShort of adding vectors around args and kwargs\nSomething like this?\n(apply foo 1 2 3 [(, 4 5 6) {\"k\" \"v\"}])\nYou'd still need an empty args if you only wanted to unpack kwargs.\n(apply foo 1 2 3 [(,) {\"k\" \"v\"}])\nThis doesn't seem any better than option two.\nI don't know how to do this in a clean and predictable way.\nOption three might be a little confusing, but the other two are very\npredictable.\nAnd if + isn't good enough when you mix types, try itertools.chain.\nchain does work. Still kind of a pain to need it and to import it.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/891#issuecomment-130339252.\n. Good holy hot damn. This is amazing teamwork and a really model PR. Nice\nwork, team.\n\n\ud83d\udc96\ud83d\udc96\ud83d\udc96\ud83d\udc96\ud83d\udc96\nOn Oct 12, 2015 5:57 PM, \"Ryan Gonzalez\" notifications@github.com wrote:\n\n@gilch https://github.com/gilch #956\nhttps://github.com/hylang/hy/pull/956\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/pull/903#issuecomment-147532497.\n. LGTM! RFR, someone give this a last ack and merge, @hylang/core! \n. If it comes down to a deadlock tie, I'm going to make the following argument:\n\n\nHy's failures mostly stem from us trying to cover up the fact it's actually Python\nWe're about to break large chunks of the language in a few cleanups\nIf we're going to break anything it should be done in the next release or two\n\nTherefore:\n\nWe should remove as much as much aliasing as we can, since it's not actually helping anything, and hiding the truth of the universe.\n\nIf folks feel strongly enough that the above isn't going to be enough to gain consensus, we'd be at our first deadlock as a project. Which is both great (yay!) and not great. I don't want to do the BDFL thing if I can avoid it, but I'm happy to.\nIt's worth stating, if I had to make a call, it would be to gut all aliases of True and False from Hy. I use true, false and nil in my programs, but they cover up the fact it's actually True, False, and None. I mean, None and nill also strike me as semantically different too, but that's another matter maybe :). Also (print (eval (read)))\nOn May 18, 2016 8:45 AM, \"Gregor Best\" notifications@github.com wrote:\n\nHy can import Python modules and Python can import Hy modules, if you do import\nhy first. I already posted a way to tokenize and eval Lisp code.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/913#issuecomment-220014830\n. Fair enough! Thanks!\n. Easy peasy changeset. Who's looking for easy karma, @hylang/core ? :)\n\n:confetti_ball: \n. 'octel' was spelled wrong. It's 'octal', Way to go 3 AM me. I also added 0b as a leader for binary. Thanks @olasd \n. @farhaven Hurm, good question. Thoughts?\n. My guess is folks who need to write hex would know to write 0x. 0o is a weird one to be sure, but my guess is folks would go for how Python does it first in Hy. Not opposed to documenting it, but I'm on the 'meh' side of the fence. Other folks?\n. Yes, but it understands this notation:\n``` python\n[paultag@cassiel:~][\u231a 11:33 AM] \u2665  python2\nPython 2.7.10 (default, Jul  1 2015, 10:54:53)\n[GCC 4.9.2] on linux2\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n\n\n\nint(\"0o13424\", base=8)\n5908\n```\n\n\n\nSo this will work fine :)\nOn Tue, Sep 15, 2015 at 11:27 AM, Ryan Gonzalez notifications@github.com\nwrote:\n\nDoesn't Python 2 still use the other octals though:\nhttp://stackoverflow.com/questions/11620151/what-do-numbers-starting-with-0-mean-in-python\n.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/pull/938#issuecomment-140429975.\n\n\n:wq\n. Ah! A good point!\nOn Sep 15, 2015 12:00 PM, \"Ryan Gonzalez\" notifications@github.com wrote:\n\n@paultag https://github.com/paultag I was using that as an example to\nwhy it should be documented. :)\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/pull/938#issuecomment-140442381.\n. Quick note added to docs. Nothing fancy.\n. @hylang/core - got two acks who's doin' it? :)\n. @hylang/core - got two acks who's doin' it? :)\n. Thank you! :D\n\nOn Wed, Sep 16, 2015 at 1:56 PM, Berker Peksag notifications@github.com\nwrote:\n\nI'm the chosen one :)\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/pull/938#issuecomment-140821486.\n\n\n:wq\n. (HySymbol) creates a quoted symbol\n. ``` hy\n(import inspect)\n(defn resolve-var-scope [stack symbol]\n  (setv scope (get stack 0))\n  (for [(, frame file line func lines index) (get stack (slice 1 nil))]\n    (if (in symbol (. frame f-locals))\n      (do (setv scope (. frame f-locals))\n          (break))))\n  scope)\n(defn intern [symbol]\n  (setv stack (get (inspect.stack) (slice 1 nil)))\n  (setv scope (resolve-var-scope stack symbol))\n  (if (in symbol scope)\n    (get scope symbol)\n    nil))\n(defn foo []\n  (setv x 1)\n  ((defn bar []\n    (print (intern \"x\")))))\n(foo)\n``\n. I wonder if something like this could solve Let over Lambda concerns - cc @olasd \n. Yeah, true. This might (at least) work for read\n. :+1: totally. I'll add @gilch in a few days  :)\n. Invited!\n. Welcome to core, @gilch , and thank you so much for all you've done so far!\n. Change made on RTD; looks good, thanks for the ping!\n. LGTM; RFR @hylang/core \n. Yeah, I want to avoid doing more of what we did with keywords -- basically,\nI want to change it to be the (perhaps slower) method of using the object\nand implementing.call`.\nCurrently, stuff like (map :foo ...) won't work, and that kinda sucks.\nOn Wed, Oct 14, 2015 at 4:48 PM, Gergely Nagy notifications@github.com\nwrote:\n\nThe keyword implementation is - as far as I remember - is a very ugly,\nslightly flaky hack. Might be worth extending to vector/map/etc literals,\nmind you. I'll have a try at remembering how the heck the keyword magic\nworks, and see if it can be extended to other stuff too.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/963#issuecomment-148194139.\n\n\n:wq\n. Yeah, :foo keywords\n``\n=> (:foo {:foo 1})\n1\n```\nAnd no, I want to change that to be a Hy object. That comes from the old\ndays when I thought we could live without the .pyc depending on hy :)\nOn Wed, Oct 14, 2015 at 4:53 PM, Ryan Gonzalez notifications@github.com\nwrote:\n\n(and I have no clue what keywords you guys are talking about...)\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/963#issuecomment-148196735.\n\n\n-- \n:wq\n```\n. I remain -1 on compile time hacks :)\nOn Oct 14, 2015 6:12 PM, \"Matthew Egan Odendahl\" notifications@github.com\nwrote:\n\nI think the tuple special form (,) should also support this. It could\nalso be detected at compile time.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/963#issuecomment-148218161.\n. Yay! Thank you, @endrebak!\n. @hylang/core - can pls add to authors :)\n. I really need to write up a copy paste explainer.\n\nYes. However, I want them to be real Objects. ':foo should be the same as\n:foo in the resulting code.\nCheers,\n  Paul\nOn Mon, Dec 14, 2015 at 4:02 PM, Andrew notifications@github.com wrote:\n\nBTW, is there any reason to prefix keywords with \\uFDD0? Couldn't find any\nplease where it is actually useful.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/982#issuecomment-164558487.\n\n\n:wq\n. That's the intent -- it's a local use char.\nThis makes :foo != \"foo\" != foo\nOn Mon, Dec 14, 2015 at 4:17 PM, Andrew notifications@github.com wrote:\n\nComment would be useful, since I'm still not following :)\n\\uFDD0 is not character '. According to this link\nhttp://www.charbase.com/fdd0-unicode-invalid-character it's actually\nunassigned. My terminal certainly can't print it...\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/982#issuecomment-164562322.\n\n\n:wq\n. @endrebak I'm not opposed to it, but I've never used it, is there a way to tell it to use the hy channel on irc?\n. OK. Well, perhaps we'll stick with IRC for now, and look at it again later - I don't super love nonfree communications systems (lawl I'm on github right now), and I flat out won't pay for a nonfree service (paid free: yeah, perhaps) -- we've got a full IRC room right now, so, perhaps we'll stick on IRC :)\nThanks for the suggestion, though!\n. @kirbyfan64 not at the number of people we have on IRC :)\n. Test cases? Also, what exactly is this doing? And mind merging with master?\n. :heart: thanks!\n. @digitalvectorz can you open a new PR adding yourself to AUTHORS?\n. @digitalvectorz don't we already have tab complete? (https://github.com/hylang/hy/blob/master/hy/completer.py#L50-L53)\n. @digitalvectorz What platform and conditions? \n. (We import readline over in https://github.com/hylang/hy/blob/master/hy/completer.py#L40-L48 too)\n. @digitalvectorz I can't reproduce - and on and older version -- http://asciinema.org/a/89notjhpgljyt390qe6tpx9f7\nHow are you launching hy? Can you send me a screengrab?\n. @digitalvectorz any update?\n. @jwilk - you're the best!\n. Yay! Thanks so much!!\n. Seems good to me! Has ACK. RFR @hylang/core \n. Hilarious, yeah. Totally.\nWhat an awesome bug.\nRight, so this looks good and it totally fixes the issue, so I say we're good. @hylang/core RFR\nI mildly prefer .format to %, but it's OK. Other things in the compiler use modulo, so I'm tempted to punt on that.\nNice work thanks!\n. @Scorpil Also, looks like you're a new contributor - mind opening a new PR adding yourself to AUTHORS?\n. @berkerpeksag I think you're right, I was also surprised this fixed the bug when I was just looking at the diff -- I your point really resonates with me right now, (as a strong believer of the unicode sandwich)\n@berkerpeksag I'll leave this PR up to you! \n. @hylang/core feedback, please!\n. @kirbyfan64 why aren't you core?\n. https://github.com/paultag/hy/tree/paultag/let-over-lol?files=1 is tracking this idea \n. Invited, thanks!\n. However, when you eval it:\nhy\n=> (eval (macroexpand '(bar)))\n1\nNone\n. Yeah, I think so:(I posted that on IRC but forgot to paste it here)\n04:07 < paultag> (macroexpand) must not be recursive\ncc @olasd (since you said it was recursive a few days ago)\n. I dig the idea and think it's worthwhile.\n. I'll start a 0.11 release branch\n. https://github.com/hylang/hy/tree/0.11 is open for changesets\n. @tianon sounds legit to me, yep. That's the only way we can test the intended patch for this release, the 3.5 support\n. I'm reluctant to drop 2.6 in a micro stable release update\n. I think we should just resolve conflicts for now\n. LGTM! RFR @hylang/core\n. LGTM; waiting on green button. RFR @hylang/core \n. OK. Green. This seems like a good candidate for the release branch - change in master, fixes a big issue. Change is small, good to go. RFR @hylang/core \n. cc @tianon \n. 0.11.1 released to pypi\n. Sounds right to me, that was the idea I had in my head for this!\nOn Thu, Dec 31, 2015 at 4:22 AM, timmartin notifications@github.com wrote:\n\nThe proximate cause appears to be this code in compiler.py:\nif body.expr:\n        if body.contains_yield:\n            body += body.expr_as_stmt()\n        else:\n            body += ast.Return(value=body.expr,\n                               lineno=body.expr.lineno,\n                               col_offset=body.expr.col_offset)\nIt looks like it should be enough to weaken the condition so that the\nast.Return is always generated in Python 3 (actually, Python 3.3+ I\nthink?)\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/1010#issuecomment-168154637.\n\n\n:wq\n. Thanks, jwilk!\n. Also LGTM; thanks @timmartin ! This is great!\n. @jwilk you rule, once again\n. @jwilk please tell me hy is a test for one of your typo finders :)\n. @kirbyfan64 cosmic bit flip. Re-ran and it was fine.\n. Thanks a ton, @poltak !\n. You have a typo, the function defines a var wat,\nOn Mar 3, 2016 9:49 PM, \"ez47\" notifications@github.com wrote:\n\n```$ hy index.hy\n(defn deftype [wat, &rest args]\n`(\"Type\" ~wat ~@args https://github.com/args)\n)\n(print (deftype \"string\" \"asdadasd\"))\nTraceback (most recent call last):\nFile \"/bin/hy\", line 9, in\nload_entry_point('hy==0.11.1', 'console_scripts', 'hy')()\nFile \"/local/lib/python2.7/site-packages/hy/cmdline.py\", line 347, in\nhy_main\nsys.exit(cmdline_handler(\"hy\", sys.argv))\nFile \"/local/lib/python2.7/site-packages/hy/cmdline.py\", line 335, in\ncmdline_handler\nreturn run_file(options.args[0])\nFile \"/local/lib/python2.7/site-packages/hy/cmdline.py\", line 210, in\nrun_file\nimport_file_to_module(\"main\", filename)\nFile \"/local/lib/python2.7/site-packages/hy/importer.py\", line 78, in\nimport_file_to_module\neval(ast_compile(_ast, fpath, \"exec\"), mod.dict)\nFile \"index.hy\", line 5, in\n(print (deftype \"string\" \"asdadasd\"))\nFile \"index.hy\", line 2, in deftype\n`(\"Type\" ~wat ~@args https://github.com/args)\nNameError: global name 'wat' is not defined\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/1025.\n. ``\n[paultag@cassiel:~][\u231a 09:51 PM] \u2665  cat test.hy \n(defn deftype [wat &rest args](\"Type\" ~wat ~@args))\n\n(print (deftype \"string\" \"asdadasd\"))\n[paultag@cassiel:~][\u231a 09:51 PM] \u2665  hy test.hy \n('Type' 'string' 'asdadasd')\n```\nClosing! Thanks for the bug! :D\n. \ud83d\udc4d\ud83d\udc4d\ud83d\udc4d\ud83d\udc4d\ud83d\udc4d\ud83d\udc4d\n. just had breakfast :)\n. :+1: LGTM! :D\n. LGTM -  my stance on the URL thing is that protocol relative URIs should be discouraged these days, there's no harm in always using TLS for hardcoded URLs :)\n. I like this idea; the example (dicts) totally makes sense. A bit funny at first, but I do like it a bit! I find myself adding newlines, this seems like a great way to do it on one line. :+1: . So I think the core misunderstanding is that we compile to Python bytecode, by way of Python's AST (Python's syntax), we don't do anything fancy, really.\nSo, when we say (setv foo 1), that translates into Python bytecode literally:\nhy\n=> (dis.dis (fn [] (setv a 1)))\n  1           0 LOAD_CONST               1 (1)\n              3 STORE_FAST               0 (a)\n              6 LOAD_FAST                0 (a)\n              9 RETURN_VALUE\nThis is the same as running a = 1 in Python.\nSo the simple implementation is \"Well, why don't we just write to locals or something?\". The issue here is that locals() is something you can't write to in a program (but you can in a REPL :) )\nIf that was to work, the issue is now handling weird edge-cases a[\"foo\"] = baz, globals, nonlocals (although I think we could ignore globals and nonlocals for now?), but it could be tractable.\nIt's mostly an issue where once again, we have to break on the lisp-y-ness of Hy in order to make a pragmatic choice about what our end goal is.\nSo, neat bug, love the idea, and solving it would be a really neat hack, that we could use in loads of places :)\n. :heart: \n. The point is valid; we should really update the pypi release. Can someone file a new bug for a minor version release? (0.X.0)\n. gah, just flake8 errors; mind cleaning that up?\n. It may be due to an upgraded flake8; let me send a PR\n. Ah, no it's due to this PR - getargspec is unused :)\n. Sorry! I\"m the worst. you're right!\n. Yay! Seems like a no-brainer! No objections, and I'll do the add!\nOn Wed, Nov 2, 2016 at 5:14 PM, Ryan Gonzalez notifications@github.com\nwrote:\n\n(I was literally about to make this same issue!)\n\u2014\nYou are receiving this because you are on a team that was mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/hylang/hy/issues/1146#issuecomment-258001251, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AAIFXz6DzDS_R575jYTi2EyL0c3L8S5Bks5q6P08gaJpZM4Knuyn\n.\n\n\n:wq\n. I was just bad about doing it! Doing it now.. Invite sent!. We should honestly get rid of true and false as well, having \"one way\" to do it seems right to me\nBut hey, that whole mess is my fault :)\n. (same with nil)\n. :+1: happy to see the cleanup!\n. (FWIW; I'm OK with removing botsbuildbots, but it was a nice fun easter egg for a while :) ). I have the login - let me see if I can make it build 'stable' docs off a tag\nOn Mon, Jan 2, 2017 at 12:04 PM, Kodi Arfer notifications@github.com\nwrote:\n\nAh. I guess that comes to show that we either need to move away from\nreadthedocs, or use it in some way other than GitHub's automatic\nintegration, in order to get the kind of control we need over our own\ndocumentation site.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/hylang/hy/issues/1198#issuecomment-269997180, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AAIFXxn7Id9lJoEbM2F3LCwOwzZ0rNY7ks5rOS4PgaJpZM4LYo48\n.\n\n\n-- \n:wq\n. I think http://docs.hylang.org/en/stable/ should work\nOn Mon, Jan 2, 2017 at 12:05 PM, Paul R. Tagliamonte paultag@gmail.com\nwrote:\n\nI have the login - let me see if I can make it build 'stable' docs off a\ntag\nOn Mon, Jan 2, 2017 at 12:04 PM, Kodi Arfer notifications@github.com\nwrote:\n\nAh. I guess that comes to show that we either need to move away from\nreadthedocs, or use it in some way other than GitHub's automatic\nintegration, in order to get the kind of control we need over our own\ndocumentation site.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/hylang/hy/issues/1198#issuecomment-269997180, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AAIFXxn7Id9lJoEbM2F3LCwOwzZ0rNY7ks5rOS4PgaJpZM4LYo48\n.\n\n\n--\n:wq\n\n\n-- \n:wq\n. Why not change the index to contain loud pointers to it, or a banner like Django does?. @kirbyfan64 @Kodiologist ohai :)\nSorry about that, I think I accidentally muted this thread in gmail -- I tried adding all four of you to rtfd, but only @tuturto had an account, so he got it :)\nI'll add the rest of you if y'all post your account names here. I hate being a SPOF :). Done!. Damn long time coming. LGTM; will merge when it's green, thank you @Kodiologist . 0.12.1 sgtm; i'll merge and push. @Kodiologist get the travis builds green and i'll do the merge without an ack :+1: . Great, let's just re-run it and pass -- accept nothing on faith  :). I think they need to stay and not move. I'd be fine with changing the LICENSE file, but the file headers should stay.\nIs there an actual reason or \"It's kinda annoying sometimes when I look at a file\"?. https://pypi.python.org/pypi/hy/0.13.0\n:heart: . Weird. The above works for me too, on hy 0.13.0. The exact issue is pretty tied up to some code, but there's a few macros and imports happening all over the place. I'm not sure what's going on, exactly yet.\nI can't get a minimal reproduction at the moment - I'm seeing weird stuff happening, but I did see this happen in the code, and removing the exact .pyc from the cache caused it to recompile the code and start working. I lost a few minutes on that.\nLet me try to figure out why it's doing this. Oh crap I know why.\nI have a macro in a file and I was only changing the macro. I bet that when you have a macro in one file, require it in another, and generate the file off the macro, it will cache the pyc, and modifying the original file won't cause anything using that macro to update.. Writing a reproduction now. Sorta, this would still be an issue if that was fixed. (projector) [paultag@nyx:~/x][05:36 PM] \u2665  cat api.hy \n(defmacro yeah []\n  (import mmm)\n  (mmm.generate-function))\n(yeah)\n(projector) [paultag@nyx:~/x][05:36 PM] \u2665  cat mmm.hy \n(defn generate-function [] `(defn yeah [] (print \"hi\")))\n(projector) [paultag@nyx:~/x][05:36 PM] \u2665  cat main.py \nimport hy\nimport api\napi.yeah()\n(projector) [paultag@nyx:~/x][05:37 PM] \u2665  python main.py \nhi\n(projector) [paultag@nyx:~/x][05:37 PM] \u2665  cat mmm.hy \n(defn generate-function [] `(defn yeah [] (print \"hi!\")))\n(projector) [paultag@nyx:~/x][05:37 PM] \u2665  python main.py \nhi\n(projector) [paultag@nyx:~/x][05:37 PM] \u2665  rm -rf __pycache__/\n(projector) [paultag@nyx:~/x][05:37 PM] \u2665  python main.py \nhi!\n. The issue is things we require may change the bytecode, and we have no way of knowing without going through requires and invalidating if the required file(s) have been updated after our bytecode.\nI remain skeptical hacking that on top would work. I don't know that we should be writing .pyc files out by default -- maybe we need some sort of production-mode or compile-package helper and let admins do this explicitly?. I actually made this example evil by not using require - so that it proves the point about how hard this would be to detect. I didn't know .pyc files were being generated - this is a huge gotcha, and I'm going to claim that we ought to not magically write out pyc without a human saying they should. Correctness should always trump speed. I am currently manning @hylang :)\nOn Aug 2, 2017 5:04 PM, \"Kodi Arfer\" notifications@github.com wrote:\n\n@hylang/core https://github.com/orgs/hylang/teams/core Does anybody\nwant to maintain a blog? I don't. We do have a Twitter account, but I don't\nknow who controls that.\n\u2014\nYou are receiving this because you are on a team that was mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/hylang/hy/issues/1353#issuecomment-319798048, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AAIFX2HKr8J1oAt8LKqs2CQv9BtOeqTtks5sUORdgaJpZM4OpTT9\n.\n. I had to ban a web client since some spam bots looked to be using #hy as a C2 Channel. It's not you, it's the web client.\n\nI'll drop the ban for the web client - but another fix is to make an account with a cloak and log in - I'll close this bug when I remove the ban . Sorry about that, I'll drop that ban when I get to a terminal.\nOn Aug 15, 2017 8:05 AM, \"Peter Nagy\" notifications@github.com wrote:\n\nThanks for the quick response. I'm not sure where and how to get a cloak.\nBut if the problem is only the one web client I don't mind switching to\nanother one. Unfortunately I have to go through a web client since the IRC\nports are blocked here.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/hylang/hy/issues/1381#issuecomment-322449134, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AAIFX-hhwt8n_lbCEOuQ0PhffmzWFSoYks5sYYmCgaJpZM4O3Zje\n.\n. @xificurC try again, re-open if you're still banned and I'll hack more :). @xificurC sadly, spambots are back. I put the ban back up. Is there any chance you could use another WebIRC client, like Freenode's IRC client, or something? So sorry.. Just reading this on my inbox, but I'm guessing this is threading into\nthe function - so it might be turning into (fn {\"key\" \"value\" [x] ..)\n\nTry a hy2py or hy --spy to check\nOn Mon, Sep 18, 2017 at 10:07 AM, Tristram Oaten notifications@github.com\nwrote:\n\nI agree I could just use get here, but still I'd like to know why the\nanonymous function is being returned unapplied, rather than being called\nwith the dictionary.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/hylang/hy/issues/1428#issuecomment-330233929, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AAIFX6EhzU2ZMiZA-1dvJSN0ABANScelks5sjnkYgaJpZM4Pa9NN\n.\n\n\n-- \n:wq\n. Try running it as ((fn))\nOn Mon, Sep 18, 2017 at 10:18 AM, Paul R. Tagliamonte paultag@gmail.com\nwrote:\n\nJust reading this on my inbox, but I'm guessing this is threading into\nthe function - so it might be turning into (fn {\"key\" \"value\" [x] ..)\nTry a hy2py or hy --spy to check\nOn Mon, Sep 18, 2017 at 10:07 AM, Tristram Oaten <notifications@github.com\n\nwrote:\nI agree I could just use get here, but still I'd like to know why the\nanonymous function is being returned unapplied, rather than being called\nwith the dictionary.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/hylang/hy/issues/1428#issuecomment-330233929, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AAIFX6EhzU2ZMiZA-1dvJSN0ABANScelks5sjnkYgaJpZM4Pa9NN\n.\n\n\n--\n:wq\n\n\n-- \n:wq\n. Yeah -\n=> (-> {\"key\" \"value\"} ((fn [x] (get x \"key\"))))\n'value'\n=>\n. \ud83d\udc4d\ud83c\udf8a\ud83c\udf8a\nOn Dec 6, 2017 11:22 PM, \"Tuukka Turto\" notifications@github.com wrote:\n\n\ud83d\udc4d\n\u2014\nYou are receiving this because you are on a team that was mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/hylang/hy/issues/1462#issuecomment-349858960, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AAIFXxm9Qf3nz1RV0nBvGSCSEDjavKxXks5s92gdgaJpZM4Q4tU3\n.\n. Done!. Yeah I need to add some new folks. Can you file a bug and assign me for when I get back to my computer?. (And also get the pypi names of folks who want in)\n. Thanks!\n\nOn Thu, Dec 7, 2017 at 12:29 PM, Kodi Arfer notifications@github.com\nwrote:\n\nDone: #1463 https://github.com/hylang/hy/issues/1463\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/hylang/hy/issues/1462#issuecomment-350038109, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AAIFXzrILMstwLUz6ieUiqX_GHQbe9w5ks5s-CBfgaJpZM4Q4tU3\n.\n\n\n-- \n:wq\n. @Kodiologist I added you! Fire away!. Gah. Will do, congrats!\nOn Fri, Mar 23, 2018, 11:04 AM Kodi Arfer notifications@github.com wrote:\n\n@paultag https://github.com/paultag pls.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/hylang/hy/issues/1521#issuecomment-375715264, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AAIFX_i0wVw7nKDjlmYqAWJUwfg7ELMwks5thR0igaJpZM4SbIe5\n.\n. Done, thanks for all your work, @vodik!. This is a tough one. Let me think about it a bit. I can see both sides of this; on the one hand, having eval eval hy code when you're in Hy seems sensible (after all, eval'ing Python from Hy seems.... weird. eval'ing Hy forms seems more likely), but I also understand that overloading internals causes confusion, and one would expect accessing a Python internal from Hy would give you that internal.\n\nI half-heartedly reach for the bashism / out of sheer instinct, but I'm also sure that's not the right solution either (e.g.:\n$ alias ls=echo\n$ ls /tmp\n/tmp\n$ \\ls /tmp\npulse-PKdhtXMmr18n\n)\nLet me work this over a bit . :shipit: . > Stop playing the victim, Kodi. Real talk. I can understand your initial mistakes borne of ignorance, but your continued refusal to format your code in a readable way demonstrates that you don't care about wasting our time if it saves you a little. Your hostility toward the rest of the team deserves a response in kind, because you won't care unless someone makes you, by calling you on it. Spinning your personal laziness as a disagreement with me personally was pure spite. Enough of this.\n@gilch I understand there's some amount of disagreement here, and I'll admit that I'm not super active these days, but shit like this is so completely out of line.\nI understand you perceive there to be a lot of hostility, and I understand you know that this behavior is unacceptable and used it to try to make a point, but it's 100% not OK. We're all here to work together on something fun. I don't understand why we're at each other's necks.\nI don't care about who started what or who disagrees about what, but no one should be writing crap like that about indentation. Readability is important, but getting personal is beyond rational.\nLet's make sure that this doesn't happen again, I'm incredibly incredibly sad to read conversations like this in PRs and discussions.\nAs a community, we've never had to take any steps beyond reminders like this to fix behavior, so I'm fairly confident that we can cut this out without any extra actions needing to be taken.\nThat being said, I'm going to start keeping an eye on comments on all PRs for a while, I'm really unhappy to read this.. concur; I'd like to maintain my ownership just because I'm happy to keep helping and stuff, but this is absolutely right, the old farts must never remain in charge because we got here first. :+1: . :confetti_ball: :tada: . e.message is a 2.7ism - we could try something like str(e) or so\n. hoshit, that's actually a bug\n. Let's compile a ast.Pass into there, so that python3.x is happy :)\n. shouldn't you list-comp the flattened list, or am I misreading this?\n. so; I'm not overly jazzed about the name -- this seems sorta like an internal implementation detail, not a language feature, really. I get why it's there (it's pre compiler time, since it needs the hoister), but I think we might need a naming scheme for \"back the fuck off\" stuff, like Python's __.\n@olasd @jd @algernon let's brainstorm.\n. (the name being do-setv not compile_do_setv_expresson)\n. for expr in exprs? :)\n. Is this right? I see you keeing off the lambda lists below; are they coming in reversed (I will read on!)\n. So, I'd be careful - the order of keys() and values() isn't assured -- let's do a for k, v in expr.items() or so, and just args.append(k), defaults.append(v) (compiled)\n. feels good brah\n. we might have to be careful with this -- .format assumes the same encoding in char and the rest of the string -- that's implicitly ascii in 2.x -- which means, UTF chars might break this. Can we get a test on this?\n. This is in it's own filed PR -- it's under non-MIT / Expat license terms. Mind removing this -- I'll merge it back in with the other PR\n( #111 )\n. Let's just\npython\nif tree:\n   ...\n. It's slightly more idiomatic to use the vector notation here, e.g.\nclojure\n(list-comp (* x 2) [x collection])\n. It's slightly more idiomatic to use the vector notation here, e.g.\nclojure\n(list-comp (* x 2) [x collection])\n. space between the operator please - run flake8 over the source before a PR - either run tox or make r :)\n. Since we are Pythonic, conditional makes more sense to me, or if we're trying to show off our Clojure heritage, I believe we can call it a test.\nI'd say +1 to conditional \n. The behavior of def will likely perhaps change someday if I stop being lazy. Perhaps we can make a note of this?\n. super-class can be a number of thing (super-classes!)\n. fucking slick use of callable kwargs.\n. They are, I introduced both because I had a hard time choosing.\nI thusly declare setv is the one true Hy way to glory.\nSomeone ought to file a bug / PR removing setf.\nOn Tue, Jul 9, 2013 at 7:18 PM, Joe H. Rahme notifications@github.comwrote:\n\nIn docs/language/api.rst:\n\n@@ -176,10 +180,48 @@ Some example usage:\n def / setf / setv\n\n+def, setv and setf  are used to bind value, object or a function to a\n\nIs there any reason to keep both setf and setv? Isn't this redundant?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/pull/237/files#r5104835\n.\n\n\n:wq\n. So, that's not actually completely true. The Python AST does in fact have a decorator element in the AST - and I think it's not the same in the Bytecode. I'd love for someone to look into this; but hy for sure adds it as a decorator on the AST and not the ole' wrap-and-replace manually (although the behavior is the same)\n. Why was this changed - aren't these the same (basically?) :)\n. you should always except Exception; without catching the class in question, you risk trapping and passing something that you shouldn't\nbetter yet, why isn't this a for loop? (or why don't you just return the iterator?)\n. Why not just modify call.expr.kwargs in place? :)\n. (Not for this PR)\nFor an incremental improvement; we could use a (set []) :)\n. this freaks me out a little\n. perhaps we use zip here?\n. yeah, +1. It'd be nice to get that in\n. I'm tempted to ask to implement this as a while, and drop the iterator after you're done with dropping\n. you forgot semicolons here :)\n. Meh, yeah, but I like them :)\nI think were consiatant in always using parents with the str modulo\noperator\nOn Dec 1, 2013 9:03 PM, \"Berker Peksag\" notifications@github.com wrote:\n\nIn hy/lex/parser.py:\n\n@@ -238,6 +238,9 @@ def t_identifier(p):\n     if \"-\" in obj and obj != \"-\":\n         obj = obj.replace(\"-\", \"\")\n-    if obj.endswith(\"?\") and obj != \"?\":\n-        obj = \"is%s\" % (obj[:-1])\n\nA very minor nit, but the parentheses are redundant here.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/pull/343/files#r8016384\n.\n. is there any chance we could move this to get_context ? We use underscores consistently :)\n. Prod. I'd love to get this in if you don't mind fixing this (otherwise I can fix it and open a new PR)\n. This breaks Python 3 :)\n\nI'd just remove the print\n. We do support Python 2.6 if we can avoid breaking it. Don't you run tox?\nOn Sat, Jan 4, 2014 at 7:39 AM, Berker Peksag notifications@github.comwrote:\n\nIn hy/contrib/hysyntax.py:\n\n@@ -0,0 +1,89 @@\n+\"\"\"\n-   Inspired by PyXL, register.py.\n  +\"\"\"\n  +from future import with_statement\n\nWe don't support Python versions older than 2.7. You can safely remove\nthis line.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/pull/368/files#r8651563\n.\n\n\n:wq\n. seconded\n. holy crap, this is valid?\n. Nah, I mean, inside the class to if out methods\n. ImportError would be best, no?\nLet's just get it in :)\nOn Apr 19, 2014 4:14 PM, \"Berker Peksag\" notifications@github.com wrote:\n\nIn docs/conf.py:\n\n@@ -96,7 +96,13 @@\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n # a list of builtin themes.\n-html_theme = 'default'\n+try:\n-    import sphinx_rtd_theme\n  +except:\n\nFair enough :) but I would use except Exception.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/pull/562/files#r11795428\n.\n. I'm not super overly thrilled with tight loop on read(), but I get it. I mean, this isn't any worse than the old parser.\n\nHave we checked on the speed dent?\n. comparing something like\nhy\n(foo bar baz\n bar foo bar\n foo foo bar)\n. (e.g. straight replacement of readline for read)\n. I kinda hate that we have to re-lex every time.\nMan. I wonder if we can't patch rply in a way that isn't super invasive.\n. We can always check against 'foo, which is technically slightly more correct; but this is fine :)\n. trailing whitespace here :)\n. dashes, man, dashes!\n. doing iter(exprs) beats fiddling with dunders\n. @kirbyfan64 do you mean (get d 123) ?\n. so skipping won't work great if we raise a SyntaxError -- which is why we have the if-python2 macro\n. Yeah, let's fix that except\n. should be clear-er now :)\n. Yeah, might be nice, since this will be sent to the user once in a while :)\n. Yeah, I'm OK leaving them in the modules. @berkerpeksag any other thoughts on this?\n. can we make the his gender neuter? :)\n. ping :)\n. We use snake-casting rather than camel casing :)\n. @zackmdavis thanks! Yeah, only just noticed this. Fixed, thank you!\n. ",
    "theanalyst": "Related #264 & #375\n. closed via #448 \n. closing this. hy.pault.ag doesn't exist anymore ;)  (We have try-hy now)\n. Closed via #377/ c9fdd40\n. RF (#317)\n. implemented in #317 \n. closed via #471 \n. :+1:  on this\n. Don't we already have str? and int? macros via #284 ?\n. muchas gracias :+1: \n. PR under review #325 \n. Related #423 \n. use (. foo atrr) now \n. > I'd rather have (foo :x 1) than (foo x=1). The former feels lispier, and is easier to compose. Eg: (do-something :list-of-stuff (filter odd? blah)) vs (do-something list-of-stuff=(filter odd? blah)). The second looks plain wrong, and I bet it is a pain to parse, too.\nFeel the same way (foo x=1) seems so much out of place for a lisp. \n. Since we have LambdaListKeywords anyway why not\n(my arg1 arg2 &key {:key val..})\nEDIT : format fix...\n. We should get this in. (love to have apply in hy)\nDoesn't kwargs macro need gensym ?\n. And have a start with 9531d772cf385cfa974a759f85b72ef1480d5892 :)\n. I've also brought up botbot.me once.. however we didn't decide back then whether we wanted irc logging \n. :+1: from me. Consistency with let looks good. I prefer this version of for over the current one anyday.\n. I'll merge this tomorrow if nobody else has anything else. Any more opinions @hylang/core \n. :+1:  we should get this in\n. Any idea why this breaks travis?\n. LGTM, while we're taking this up, test_bin.py should also be fixed, as of now, as this runs only for python2, we should be able to remove that check with this\n. LGTM :+1:  \nthat UTF-8 fix was good..\n. #524 solves most of this \n. :+1:  prefer this over the predicate form\n. In my opinion we'll keep the docs with the core stuff, keep this seperate\n. @tuturto yeah will fix that..actually this needs a bit more fixing..the quasiquote example misses a quote (thanks @paultag ) Also will try to document eval as well, maybe then we can give a better example for quote\n. :+1:  As far as the anaphoric magic variable is documented it or acc etc. , I love the conciseness possible by using anaphoric macros. \n. For ap-map-when I guess the arg should be just pred instead of predfn ?\n. Glad to help :)\n. LGTM :+1: \n(let [[she-\u2665-me? False]]\n     (assert (= False hy_is_she__me_de1g)))\n. @joefromct as of now the pip version doesn't support py3.4 yet. We'll do a release soon\n. rfr #410 \n. Maybe we should add this in quickstart of the docs as well?\n. I think the repo owner might need to login to coveralls.io and add this project there\n. Rebased and merged thanks!\n. Thanks!\n. LGTM :+1: \n. Thanks\n. :+1: \n. The idea was to return the first or second form and still eval the body for side effects.. something like \n(defmacro foo-timer [&rest body] `(prog2 (start-timer) (prog ~@body) (stop-timer)))\netc. But mostly this can be avoided; and it is not pure (in a functional sense). \nAnyway the prog1 implementation may not do what it is supposed to do because of the let block atm. (Maybe I'll try again after gensym)\n@algernon @noprompt Thanks for the inputs\n. +1 for hyprofile\nOn Mon, Dec 23, 2013 at 2:26 AM, Bob Tolbert notifications@github.comwrote:\n\nactually, hyprofile isn't a terrible name either.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/pull/371#issuecomment-31095749\n.\n. > About the length of the reader: I'm fine with it being just one character, but then it should be @checkargs(min=1, max=1). Is there a reason to accept more characters if we are not using it?\n\nWhy not just use @checkargs(exact=1)\n. @Foxboron yes sure.. I hadn't read the entire thing, sorry \n. LGTM :+1: \n. what you're trying works when trying \n(slice (get a 0) 0)\nBut yeah, not as concise as the numpy way of slicing\n. Thanks for the bug report\n. LGTM\n. Wait for it.. I'll fix @olasd's comments (after $Work)\n. I removed the use of numeric-check (raising a TypeError as expected)  also used gensym for the macros ap-last and ap-first\n. Also pending docs of reader macros \n. :+1: \n. :+1: \n. LGTM\n. :+1: :shipit: \n. Closed via #395 \n. :+1:  I'm all for this.. maybe we need to document this too \n. @rwtolbert if we do it in the compiler (setv (. foo bar) \"baz\") might work.. But this will break when nesting \n. PR under review #423 \n. Should we just add docs to flatten as well\n. :+1: \n. I  just added version_added directive and merged this via d7956d03c35d23407172a69663576b5d95a4f892\nThanks\n. LGTM\n. :+1:\n. Thanks!\n. LGTM, btw are we sure we're going to 0.10.0 (ie. no 0.9.13 fix release etc. ) \n. merged via d9d113670ee012f35140d34e2a159d2709c21798. Thanks!!\n. +1\n. Thanks for the report, this was an issue introuduced in the latest release, now fixed via PR #429. \n. LGTM \n(. foo method args) will not work like this right (currently called as (.method foo args).. This is only for attribute access\n. Fine with this, lets get this in :)\n:+1: \n. :+1:  Brilliant work, just add the line to __init__.py as @berkerpeksag  mentioned and we're good to go :)\n. You can drop the 'L' in the long number in tests, that is failing travis I think\n. :+1: \n. :shipit: \n. :+1: \n. :+1:\n. :+1: \n. hi, you do not need to do a (return ~ret) just a ~ret will do. For eg. \nclj\n=> (ret-if-not [false (+ 1 1)] [(< 2 0) (+ 2 40)] )\n; [ 2, 42]\nThough I'm not entirely sure why you are returning a evaluated list of expressions when cond is true.\nFeel free to reopen if this was not what you intended \n. move the test in contrib too ?\nOn Tue, Jan 14, 2014 at 9:36 AM, Coveralls notifications@github.com wrote:\n\n[image: Coverage Status] https://coveralls.io/builds/438399\nCoverage remained the same when pulling 2545917\nhttps://github.com/hylang/hy/commit/25459177ebd380dbf2808a940914bab051439380\non berkerpeksag:meth-updates into 8ababcb\nhttps://github.com/hylang/hy/commit/8ababcb905efe14bca982550ae25a644ed6b3f00\non hylang:master.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/pull/441#issuecomment-32237264\n.\n. I meant what @Willyfrog said..I wasn't that clear though.\n\nAlso @paultag was mentioning possibility of creating a seperate repo for meth \n. Also IIRC we don't import reduce by default, then a form like (if-python2 nil (import [functools [reduce]])) might be necessary inside the function body\n. oh thats because when is not available for language.hy. IIRC Only macros in bootstrap.hy are available for language.hy.  Try with ifs at the moment\n. +1, very nice to have generator expressions & dict comprehensions\nOn Thu, Jan 16, 2014 at 8:21 AM, Paul Tagliamonte\nnotifications@github.comwrote:\n\nSlick look. Nice refactor. Was going to suggest that if you didn't manage\nto do it (should have known)\nHas ACK. Nice work.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/pull/448#issuecomment-32438133\n.\n. how about a defalias too? We could then use defalias inside defn-alias? \n. The unicode symbols seems like a valid point..while it looks nice when using unicode for math etc. for interop an alternative function name would have to defined, and IMO defn-alias makes more sense there than doing a (def A B) dance :+1:  from me. \n\nMore opinions @hylang/core \n. LGTM. Good catch, however you missed the closing bracket when deleting the line\nAlso no email id was visible in the commit . If you could provide that info, we'll add your name & email id to AUTHORS file \n.  Github did provide a fake email address (it was not that the email was not\nvisible)\nOn Sat, Jan 18, 2014 at 4:56 PM, Jack Hooper notifications@github.comwrote:\n\nFixed the closing bracket.\nRegarding my email address, GitHub should have provided a fake one for me\n(I set it up that way to avoid spam). I can provide my real one if you\nlike. If no email address was visible at all, then I'm not sure what's\ngoing on there... might it be a GitHub bug? Let me know if you need any\nother info from me.\nJH\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/pull/460#issuecomment-32679807\n.\n. Milestone created. Tagged most merged PRs (excluding doc fixes)  post 0.9.12 for easability of preparing a changelog\n. And we're 0.10.0\n. cffi works quite well with hy.. have an example here\n. oops hyperspec http://clhs.lisp.se/Body/m_dotime.htm\n. I have updated to meet the hyperspec..dropped the pos? check as range does the right thing for -ve and 0 values. The iterator variable is incremented so as to follow in line with hyperspec.\n\nThe other way is the Let over let way \n`` cl\n(defmacro cl-dotimes-1 [spec &rest body]\n   (unless (and  (isinstance spec HyList) (>= (len spec) 2))\n    (macro-error spec \"dotimes' needs a spec of the form [var num &optional result]\"))\n  (let [[it (first spec)]\n        [n (second spec)]]\n    `(let [[~it 0]]\n       (unless (pos? ~n)\n          (macro-error ~n \"second arg to dotimes must be positive\"))\n       (while (< ~it ~n)\n         ~@body\n         (setv ~it (inc ~it)))\n       ~@(slice spec 2))))\n```\n...however, this fails the second case (ie. (dotimes [i 10] (setv a (inc a))) throwing the unbound local variable error. Any other possibilities are welcome\n. closing this... the clojure version is equivalent to (for [i (range ~n)]) anyway..and cl version doesnt seem to add anything that much worthwhile.\n. Once we have a LoL I'll maybe look back into this :)\n. LGTM\nwhat about kwonly args, here we do an (apply foo [] {some-dict})\n. never mind, I thought apply could take args not being supplied to it,  when we call apply for a function with only keyword args, we have to make explicitly make args as an empty list. (Just read that an issue was already created for this #453, I missed that) \n. I'm merging :+1: \n. LGTM, Top class work as always \n. LGTM\n. :+1:  :ship: \n. :+1: once the tests are green that is :)\n. hmm 3.2 does not have inspect either, it's the depreciated getargspec or getfullargspec\n. :+1: \n. flake8 no likey the init comment\n. One more clarification, wasn't (def self.fn fn) causing the problem the last time. or was it something else?\n. :+1:  LGTM\n. :+1: on @khinsen's suggestion. Seperate repos looks like a positive step in a way we are keeping core hylish \n. ref #524 \n. ref #520 \n. should be fixed in #524 \n. I'm voting for nth, first and rest.  Not sure about not-any? & not-every?. Though, I don't mind either way.  Other than that, we probably shouldn't be importing itertools at language.hy, just importing itertools.islice as an when required by the function might be better I guess.\nLets get more reviews rfr @hylang/core \n. :+1: :ship: \nWe have enough votes on #511 already, so this is ready for merge\n. Build fails as the tests that run on 2.6,2.7,3.2 as there are tests for yield-from which was the macroed form earlier. I guess we should do like @Foxboron mentioned, ie. compilerize when possible ie 3.3+ and use the existing simple yield-from macro for other versions\n. > We could also expand out to a full implementation of yield-from for the older macro, though I think if we were going to do that, we should port over the cpython unit tests for yield from to hy and test against that.\nYep that could be a seperate bug/feature request with a link to PEP 380 \n. LGTM (need to bump versionadded to 0.10.0 when merging)\n@paultag / @olasd can you take a quick look at this\n. :+1: \n. in a sec. was at work earlier, hence the delay :)\nOn Mon, Feb 24, 2014 at 7:30 PM, Paul Tagliamonte\nnotifications@github.comwrote:\n\nThats two acks, Abhishek - merge away!\nOn Feb 24, 2014 12:39 AM, \"Abhishek L\" notifications@github.com wrote:\n\n[image: :+1:]\n\nReply to this email directly or view it on GitHub<\nhttps://github.com/hylang/hy/pull/517#issuecomment-35859094>\n.\n\n\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/pull/517#issuecomment-35888302\n.\n. :+1: :shipit: \n. Hi, we do have some profiling macros in hy.contrib.profile, do checkout \n. agree with this. Kind of related #331 \n. #524 addresses most of this. If there are pending issues, feel free to reopen \n. Looks good enough, lets go for this. lets add the tests and get this in\n. :+1: LGTM; (un)related we should probably open a pr in linguist as well\n. Looks good :+1: \n. Looks good.\n\nRelated keep an eye on https://github.com/travis-ci/travis-ci/issues/1989 when travis rolls out 3.4 we should update our tests as well\n. :+1:  I'm merging this\n. This should be a duplicate of #382 which affects the current (0.9.12) version was fixed in master. A new release (0.10.0) is around the corner & this issue should be fixed! Thanks for taking the time to report \n. Should be fixed in 0.10.0. Feel free to reopen in case the issue resurfaces\n. Hi, eval evaluates a quoted s-expression. For eg.\nHy\n(setv input '(+ 2 3))\n(eval input)  ;=> returns 5\n. Has 2 ACKs, flake8 is happy now, good to merge I guess\n. #570 fixes this :)\n. Go ahead\n. #524 is merged, this should be fixed\n. :+1: merging this\n. has ACK, I'm at work, someone else can merge in the meantime \n. > (I'm too lazy to name my virtualenvs correctly, and I don't see them during a long repl session anyway...)\n@algernon I was suffering from the same problem :)\n. @berkerpeksag On PyPy, the current version it looks like this\nhy 0.10.0 using Python 2.7.3 (2.2.1+dfsg-1, Nov 27 2013, 19:50:08)\n[PyPy 2.2.1 with GCC 4.8.2] on linux2\nHow can I get the name ie Python without hardcoding\n. I ended up with something like \nPython\n    \"{appname} {version} using {py}[{build}] {pyversion} on {os}\".format(\n            appname=hy.__appname__,\n            version=hy.__version__,\n            py=platform.python_implementation(),\n            build=platform.python_build()[0],\n            pyversion=platform.python_version(),\n            os=platform.system()\n        )\nBasically problem being If I go for python_version directly, for PyPy it will go for something like PyPy-2.7.5 which is wrong. \nThis looks like \nhy 0.10.0 using CPython[default] 2.7.5+ on Linux\nand on PyPY\nhy 0.10.0 using PyPy[2.2.1-dfsg-1] 2.7.5+ on Linux\nIf this is preferable, I'll push this. Better ideas of course welcome \n. @berkerpeksag that is nice, but how did you get PyPy & Python 2.7.2 versions \n. updated to earlier suggestion, I know (default) will be a bit redundant, but Python repl also displays similiar info, \n. Nice catch, fixed\n. Have updated a point about squashing. Take a look and let me know \n. Thanks for the report\nrelated :\nWe don't currently set the ast level attribute that says about relative imports, a fix would probably check for dots before an import and set levels accordingly in the compiler\nhy\n=> (import ast)\n=> (disassemble '(import [.foo [bar]]))\nModule(body=[ImportFrom(module='.foo', names=[alias(name='bar', asname=None)], level=0)])\n=> (ast.dump (ast.parse \"from .foo import bar\"))\n\"Module(body=[ImportFrom(module='foo', names=[alias(name='bar', asname=None)], level=1)])\"\n. Ack\n. thanks for the report!\n. requirements-dev.txt  already includes requirements-travis.txt so these are already included\n. @tuturto Fixed the unquoting, have a look & let me know if anything else needs fixing\n. In emacs we have an inferior lisp mode which allows the running of repl inside of editor and sending of s-exps/files etc. Initially when we did not have a hy-mode I used a hacky setup use clojure-mode & customized to use hy insread of nrepl. I don't know how fireplace/vim works, @paultag / @Foxboron  might be able to help with that \n. Thanks @tuturto, Have fixed the docs, let me know if anything needs further fixing\n. Great!\n. Could you write the intended equivalent Python Expression for this. I'm not sure whether you can do an expression False and break in python\n. LGTM :+1: ...\nThough, crazily enough in Python2, setting True and False to values completely seems working \n```\n\n\n\nTrue = 0\nif True:\n...     print \"hello\"\n... else:\n...     print \"Truth is False\"\n... \nTruth is False\n```\n\n\n\nthough allowing world to change around like this is not very helpful. IMO we should be keeping True, False None as keywords which cannot be changed\n. Maybe we shoud try getting #584 in?\n. Should we gracefully fail in case get fails?\n. Great! \nI want an opinion on this, whether we should make the macro print the time directly or just return it.. as in if you're kind of doing this a lot it might make sense if we just return the value for further analysis etc. \n. Maybe it would make some sense to move this to contrib.profile instead of hylang core itself?\n. Might try this in hash as well. Nice work!\nOn Fri, Jul 25, 2014 at 2:38 PM, Gergely Nagy notifications@github.com\nwrote:\n\nDelicious! Can't wait to use it in Hydiomatic! (Especially if/when we can\nteach read how to preserve some meta-data, like line numbers and stuff!)\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/pull/628#issuecomment-50125503.\n. LGTM, Great Work! @Foxboron \n. > I can help out if needed. But would love to have atleast one experienced guy helping out.\n\nSame here.\n\n\u2014\nReply to this email directly or view it on GitHub.\n. LGTM :+1:\n. LGTM @microamp can you rebase so that this merges cleanly \n. :shipit: , Thanks @microamp \n. :+1: \n. Guess this has to do with semantics of os.path.join itself rather than def/setv. I guess you wanted\n\n(def *store-path* (join (get environ \"HOME\") \"foo\"))\ninstead, as join thinks /foo is an absolute path and previous args are thrown away.\nBTW setv and def are exactly same in behaviour and also, they mirror the assignment in python.\n. interesting! Thanks for reporting this\n. Love issues that close themselves :)\n. Ray Alez writes:\n\nI've found a function list-comp, is there something similar that returns a dictionary?\n\nTried dict-comp ? \nhttp://docs.hylang.org/en/latest/language/api.html#dict-comp\n\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/hylang/hy/issues/670\n\n\nAbhishek\n. Sorry disassemble in core already does ast & python .. only bytecode bits are pending\n. > I can't reproduce the PyPy errors. Can anyone else figure out what's going on?\nprobably #675 \n. :+1:  with dropping 3.2. (please don't kill 2.7 yet )\n. LGTM\n. Just played around this patch, LGTM, would love to see this in... one of those PR's requiring BDFL blessings before merge :)\nping @paultag \n. LGTM , :+1: from me. \n. There is a somewhat sparse documentation at the internals doc http://docs.hylang.org/en/latest/language/internals.html#hykeyword . keyword? was introduced in .10.1 and needs doc. \n. Brilliant @ALSchwalm !!\n. Yep probably we can give links to both hy-mode: <github> <melpa>  sort of\n. Thanks @iKevinY :)\n. the first one list/p is an error to be fixed .. the second one, not so sure\n. Could you please add the docs as well, we generally forget to add the documentation once the code is merged in\n+1 \n. LGTM\n. LGTM \n. patches welcome :-)\n. This works as a reader macro as well, which ignores the form supplied  :-)\n=> (defreader _ [&rest body] nil)\n=> #_(foo bar)\nOn Tue, Apr 7, 2015 at 7:09 PM, Brandon Adams notifications@github.com\nwrote:\n\n(defmacro comment [& body] nil)\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/789#issuecomment-90557073.\n. Great ! Thanks for doing this.\n\nOn Sun, 3 May 2015 23:06 Coveralls notifications@github.com wrote:\n\n[image: Coverage Status] https://coveralls.io/builds/2476488\nCoverage remained the same at 82.4% when pulling 82b68da\nhttps://github.com/hylang/hy/commit/82b68da88ce707968c32a41e616ef4cc1dcc28d4\non zackmdavis:draft_news_for_0.10.2 into 42983d1\nhttps://github.com/hylang/hy/commit/42983d173fdabab098d586e8dc599065b8f209b7\non hylang:master.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/pull/799#issuecomment-98513415.\n. Awesome! thanks for taking the effort\nOn Wed, May 20, 2015 at 6:03 PM, Coveralls notifications@github.com wrote:\n[image: Coverage Status] https://coveralls.io/builds/2606100\nCoverage decreased (-0.64%) to 81.76% when pulling 46115fc\nhttps://github.com/hylang/hy/commit/46115fc9f9db2e5f9aab475b39a4b2cb1204e234\non zackmdavis:async_awaits into 685688f\nhttps://github.com/hylang/hy/commit/685688f04cee7901c20d87112570fe8a377b16b7\non hylang:master.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/pull/805#issuecomment-103865402.\n. Not lazy seq as such.. though you can achieve partly using generator\nexpressions.. an example in the core docs\nhttp://docs.hylang.org/en/latest/language/core.html#sequence-functions\n\nOn Sat, May 23, 2015 at 9:01 AM, acekingke notifications@github.com wrote:\n\nIn clojure , It can write like here\n(defn lazy-seq-fibo\n()\n(a b))\nBut how to make it in Hy?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/808.\n. could you add tests for the else-form .. tests live in tests/native_tests/contrib/anaphoric\n. Thanks. Much needed.. +1 \n. Welcome Zack\n. like {e,c}lisp's setq \n. @acekingke you could probably announce/start the discussions in the hylang mailing list https://groups.google.com/forum/#!forum/hylang-discuss  since anyone browsing in the future could probably see the link etc.. as a github issue once it is closed, the links tend to be forgotten\n. @gilch  LGTM.. as of now the we dont have sphinx taking the docstrings from Hy.\n. LGTM\n. +1\n. @paultag are we actually supposed to remove the copyright of the previous years as well? (ofc, IANAL). here predfn is used as the argument and pred is evaled in the body. Wouldn't this break unless pred is bound?\n. lst is passed as the argument and list is used instead\n. you could add the signature of the function call here something like  Usage:  (loop bindings &rest body)\n. 2 spaces, lets keep flake happy\n. while you're fixing flake8 ..remove this as well :)\n. minor nitpick...can we opne square brace on next line along with [[-dispatch-fns..\n. again minor nitpick..should we let bind the name?\n. minor typo handles\\handled\n. Typo tupple/tuple\n. Guess this progn can be avoided\n. Since the definition is in flavor.scheme guess here we can remove null?\n. Maybe first line should explain what the file does, like multi-arity functions in Hy..\n. typo s/regislators/legislators\n. maybe we should call this example as (apply optional_arg [2 3] {\"keyword1\" 1 \"keyword2\" 40}) , though I'm ok either way\n\nEDIT Scratch that... I'm fine with the way it is\n. typo \n. we can prolly return all([kw ..stuff)) instead of if foo return True\n. Extra blankline ...triggering flake8 failure\n. This might be no longer needed as #524 is merged\n. Hm, good idea I'll try adding\n. Hm better, thanks\n. Thanks, (I should stop making PRs when I'm half asleep)\n. minor nit s/defun/defn ? \n. Oh I see makes sense then\nOn Thu, Jul 24, 2014 at 5:29 PM, Gergely Nagy notifications@github.com\nwrote:\n\nIn hy/core/language.hy:\n\n@@ -332,7 +332,10 @@\n   (_numeric_check n)\n   (= n 0))\n-(def exports '[butlast calling-module-name coll? cons cons? cycle\n+(defun Botsbuildbots () (Botsbuildbots))\n+\n\nNo, it is intentionally defun, because that's what is in the original,\nand the point of the function is to be 100% the same as in the Portal\nsoundtrack.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/pull/623/files#r15342214.\n. update syntax here to (nth coll n [default nil]) ? also probably mention that we return some optional specified default if out of bounds..\n. Guess we should go with &optional in the syntax (ie first one) @hylang/core I guess we can standardize that format for functions with optional args\n. @microamp you can go ahead with the first format\n. Think the (fn [] ) bit  is redundant here .. also let is serial (somewhat like let* in CL like lisps) so I guess here we can probably fit this in one let expression\n. Might be more pythonic to do that with yield ?\n. python doesn't support optional-arg?\n :)\n. It does, but then dashes turn to underscores anyway.. so both are equivalent.. probably you can leave this as it is for now\n. \n",
    "Foxboron": "Closed by #628 \n. Semi-related: https://github.com/cemerick/nrepl-python-client\n. It does, i just forgot the issue\nOn 07/07/2015 11:30 AM, Gergely Nagy wrote:\n\nI think HyREPL https://github.com/Foxboron/HyREPL does this. Should this issue be closed?\n\u2014\nReply to this email directly or view it on GitHub https://github.com/hylang/hy/issues/8#issuecomment-119136621.\n. The commits speak for themself.\n. fixed with #325\n. http://hy.readthedocs.org/en/latest/language/internals.html#hysymbol\n\nRecent addition too the docs! Closing this.\n. With the new documentation, there is a tutorial working as a introdution. \nhttp://docs.hylang.org/en/latest/tutorial.html\n. Sort-off pointless as PyGame works inside Hy. The solution would be to maybe make a wrapper for PyGame, but thats another issue and i will be closing this one.\n. Why can't we do something along what clojure does?\nNote: the refference was just to the tons of different vars in clojure you can set, the enable-commas was just something i came up with.\nclojure\n(set! *enable-commas* true) ;; Default null\n. We are after all doing lambda calculus.\n. Update:\nSo after a little on an off discussion it seems that most people would like a .config file or something related to the REPL where we can customize a prompt. Since a NREPL version is probably going to be developed the feature won't be added before then. So closed until further notice.\n. I had the same thought really. We could probably also then add several other syntax files (Emacs and Sublime).\n. while is a loop. the if is not. You can't do this in normal python either.\n. woooppss. My code. I will take a look at it!\n. In both python 2.7 and 3.3 __builtins__.quit = \"a\" work fine, so i can't seem to find the error.\n. I think it is funny that this little issue was solved by me so i could just get going hacking on Hy, look what a mess we have gotten into ^^\n(If i am allowed to have an opinion) I totally agree on code review as it would increase the code quality in the code base.\n@rahmu i don't know how to check that either, that is why i checked after the correct __repr__message. The override was also moved into hy/cmdline.pyso it was able to be imported into the tests, instead of trying to solve another mess with importing a file magically with both Python 2.x and 3.x (they got different ways of importing code)\n. I'd love if people who is reporting/experiencing the bug can test my branch for the fix and report the exact error ya get.\nhttps://github.com/Foxboron/hy/tree/builtin\n. @rahmu NP :+1: Then we can merge! :D\n. https://github.com/hylang/hy/issues/124\n. The problem should be solved by trying to import__builtin__ (2.x) or builtins (3.x) and overwriting their quit and exit methods. So as long as the correct string from __repr__ is there, it should work. But i agree a better test should be written, but i can't come up with anything.\nRefference:\nhttp://docs.python.org/2/library/builtin.html\n. whats the status of this?\n. Read about squashing commits\n. I'll be writing up the test for https://github.com/hylang/hy/issues/214 during the day. So that one is atleast crossed off the list.\n. I got no idea how this was closed. I believe github auto-closed this when i merged the PR\n. :shipit:\n. Wouldn't it be possible to override it in the core lib? name the compilers assoc too assoc*(or something) and reimplement the actual assoc function in the std lib and make it return the modified map\n?\n. This is solved now \\o/\n. Added new test :+1: \nCurrently everything is evaluated once before we go check for the -main function. So;\n``` clojure\n(print \"hello\")\n(defn -main [args]\n  (print \"aaannnd another hello\"))\n(print \"another hello\")\n```\nwould return:\nhello\nanother hello\naaannnd another hello\nI believe this is desired behavior, but just a little tip anyway.\n. @rahmu i'll sound like a party pooper, but lets be realistic. No newcommers to any language will be using Hy, i think it is a non existing problem (at the moment) we will face.\nI do not see how compatibility is broken with Hy<->Py as the idiom it self can be used even tho with the addition of -main.\n. Err. We have just discussed it briefly in IRC. I am not sure if we have come any further with this at all.\n. Ill try do that during the weekend!\n. I'll be looking at a way to inject code into the main file so we can actually do this in a clean and nice way, but my laptop is current being repaired so will try and do it by the end of the week/weekend/when my laptop returns.\n. I'm still unsure. I feel like we should inject some code to have a consistency too this, but i'm not sure where we should do that and how. I'm cleaning up this atm and looking at the issues @rwtolbert posted, but still not sure what to do this with.\n. That is actually a neat idea! :+1: \n. Closing this in favor for @cwebber.\n. I'll grant myself temp voting powers and do a :+1: from me considering he have been doing a decent contribution to Hy.\n. 2nd that. Don't see any problems here.\n. Awsome work :+1: i don't see any problems.\n. ping @rwtolbert. Whats the status? This looks really damn need, but needs more work for the current version of Hy.\n. :+1: \n. I believe importing the modules from future solves all the above problems and should maintain compat across all versions\n----- Reply message -----\nFra: \"Joe H. Rahme\" notifications@github.com\nTil: \"hylang/hy\" hy@noreply.github.com\nEmne: [hy] Replace raw-input with input in Python 2 (#259)\nDato: l\u00f8r., juli 20, 2013 00:00\nPython2's input function is bad. If you want to eval the input, you should do so explicitly. This is why Python2 introduced raw_input and why Python3 made input behave like raw_input.\nI think Hy should have a single function input that doesn't evaluate the string it gets. It should automatically translate into raw_input if translated to Python2 and input if translated to Python 3.\nCons\nI think this might affect the holy Python <-> Hy interoperability. \nHowever\nI think we do something similar with division in Hy, where (/ 3 2) always evaluates to 1.5 regardless of the version of Python it compiles to.\nBasically, I'd like to get your opinion before starting coding this one. We could discuss the technical details of the implementation, but first let's focus on deciding if it's a sound design choice.\n\u2014\nReply to this email directly or view it on GitHub.\n. I believe this is fixed now!\n. Fixed with #628 \n. :shipit: \n. :shipit: \n. :shipit: \n. > I wonder if it will be confusing for someone that (instance? int 3) and (instance? str \"abc\") performs differently on py2 and py3\nIt essentially breaks code on the two versions that is suppose to be compat, something we should void at all costs.\n. lets just get another ACK!\n:+1:\nNow :shipit: \n. Fixed with #325 \n. :shipit: \n. And hey! The tests failed! Back too the drawing board!\nEDIT:\n(with [] None)\n& \n(for [] None)\nBreaks (what a surprise). I'll take a look at it tomorrow.\n. @paultag We should get @olasd's PR changing the bootstrap.py into Hy code inn, then i'll patch this up as Hy instead of python.\n. I'll just ping this for more discussion on what todo!\n. :shipit: \nThen i can also update my PR (#291) for the with and for changes.\n. I believe there is/was a bug regarding multiline comments in the REPL, but not sure about the status on that. The syntax however is \"\"\" Hello \"\"\", not single doublequotes.\n. I'll be fixing up #291, making it compat with @olasd's recent changes.\n. Well, we got a working gensym implementation with #374, so getting that merged along with this should be doable. Possibly a blocker along with #377 for 0.9.12?\nAlso :+1: \n:shipit: \n. Got a code of conduct and contribution guide so closing this\n. @rcarmo Been discussion about rewriting the REPL in Hy with the inclusion of  read. Not sure what the current stand is.\n. IRC!\nHy on freenode!\n:shipit:\nOn Tue, Sep 9, 2014 at 11:38 AM, Rui Carmo notifications@github.com \nwrote:\n\nBesides the mailing-list (which seems... quiet), where do those \ndiscussions take place? :)\n\u2014\nReply to this email directly or view it on GitHub.\n. We have been discussing about that aswell. But nothing have been done \non that front.\nThere are several people from different timezones tho, like me.\n\nOne solution is setting up a bouncer, or we can try and actually start \nlogging.\n:shipit:\nOn Tue, Sep 9, 2014 at 11:41 AM, Rui Carmo notifications@github.com \nwrote:\n\nsigh\nThat requires real-time interaction... (not on a US timezone)\nArchives/logs?\n\u2014\nReply to this email directly or view it on GitHub.\n. Also fixed up code and tests for https://github.com/hylang/hy/pull/338 as they where not added into native_tests/__init__.py.\n. So, whats it gonna be @hylang/core?\n. @paultag not everything should be sorted.\n\n@hylang/core pretty pretty pretty please?\n. LGTM @hylang/core  :c?\n. http://www.youtube.com/watch?v=Eal4fep7pK4\n. I'll just go ahead and merge this as olasd's issue have been fixed AFAIK.\n:+1: :shipit: \n. :shipit:\n:+1: \nI'm not sure if there is any better way of solving it. It's also cleaner then the -p as mentioned above.\n. Seems like someone found the same bug, for the same module, and submitted a PR each. At the same time.\nThat is rather amusing!\nI'll be +1 this instead of the other (https://github.com/hylang/hy/pull/340) as its simpler then the other.\n:shipit: \n. :+1: \n:shipit: \n. I don't see how this will be a nightmare to maintain. We don't add a core member every month, so where is the problem? Updating this once every other/3rd month isnt a hassle at all.\n. ping @hcarvalhoalves\nalso ping @paultag for possible review with new commits\n. @hcarvalhoalves also going to point out that the rebase didn't go that well as you got two sets of commits atm.\nThere is also an error with class HyKeyword(HyObject, str_type): on 3.2 and 3.3. The unicode error only shown on 3.4.\n. @paultag pst\n. Could't we just have the docstrings appended to an own dict/method? not completely sure how the macros itself are defined and called, but should't it be possible todo something along the lines of how doc works with objects?\n. :shipit: \nLets merge!\n. :shipit: \nNo brainer really.\n. LGTM @hylang/core \n:+1: :shipit: \n. Wop! :+1:\n:shipit: \n. I'll be totally sad by crushing your dreams here. \nPython supports the use of with Class(): and with Class() as cm:.\nIf we used a Clojure-like syntax here, it would be unparse-able. As an example: (with [cm (Class) (Class)] ...). If we start having several nested-context managers, there is no way to parse this in a sane way, but doing (with [[cm (Clamm)] [(Class)]] ...) solves this problem.\nBecause we want to have consistency, we are changing all the syntax to be like Common LISP.\nReference: #325 \n. Closing this issue in favor for #713 and adding it to the current cleanup milestone\n. ping @lmatthieu!\n. :+1:\n:shipit: \n. i'll :+1:. But i really think we should find a better name then prog1and prog2, something that maybe imply their use better.\n. I question the name do/profile, not really sure its a convetion used in CL, but isnt it better with do-profile or doprofile?\n. :+1:\n:shipit: \n. Added with #628 \n. clojure\n=> (defreader ^ [expr] (print expr))\n=> #^\"hy\"\nhy\n=> #^'(1 2)\n('quote' (1 2))\n=> #^(1 2)\n(1 2)\n=> #^(+ 1 2)\n('+' 1 2)\n=> #^{\"a\" 1}\n{'a' 1}\n=> #^[1 2 3]\n[1 2 3]\n=> #^(+ (- 1 2) 4)\n('+' ('-' 1 2) 4)\n@garyposter quite happy myself. Just need to refactor some code and get some error handling in place.\n. Or i wait until i am 100% done with PR :3\nOn Thu, Dec 19, 2013 at 6:11 PM, Julien Danjou notifications@github.comwrote:\n\nLGTM, more points if you merge those commits. :)\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/pull/377#issuecomment-30946883\n.\n. @hylang/core finalized the PR. Reviewing, gogogo!\n:shipit:\n. Well basically. Becuause of our current lexer, we are limited as how to redefine synta.\n- We can't redefine any predefined syntax. Well, we can sort-off, but our lexer dosnt see it that way. This is sort-off being discussed how to solve. But it would require more work on the lexer and parser, and then the reader-macrs would follow. The problem however, is that we can't really raise an exception either, as the lexer will fuck it up before we come too that point. So the solution is just documenting the problem.\n- I asked @olasd if we should allow more then one char, he said no. Thats my reasoning on that matter.\n- I thought raising macro-error was a good idea, but maybe NameError or something else would be better.\n- I havent come as far as documenting reader-macros.  But will do when i get too that point.\n. @theanalyst haha. I actually didnt think much of it when i got defreader to work in the first place. I'll fix it after work.\n@Willyfrog Ill check up the symbols that might not be used and do what you suggested, thanks!\n. well, i tried to fix the first flake error, but he didn't like my fix either. So meeehhh\n. @theanalyst \ni went with @checkargs(min=2, max=3)as defreader needs atleast the symbol, and the args list. But it can at max take the code body aswell. Using exact=1 just allows us to write (defreader ^)\n. @theanalyst no problem.\n\n@hylang/core lets git it merged beore @olasd hands me more conflicts to fuck up.\n. I'm a little unsure. Do we really need to use requests for this script? All i see is two basic calls too the Github API. Sure we can't use urllib to do this? Thus we avoid a uneeded dependency?\n. @paultag Sure, requests is better. But do we care for requests as a dependency when we are just making two calls?\n. Need documentation on reader-macros, but i'll sort that when i can.\n. closing this in favor for #652 \n. :+1: \n:shipit: \n. LGTM.\n:+1:\n:shipit:\n. @theanalyst shhhhhhh\n. after some fiddling, the (for) issue was solved.\n```\n=> (for)\n  File \"\", line 1, column 1\n(for)\n  ^---^\nHyMacroExpansionError: for missing 1 required positional argument: 'args'\n``\n- Moved all errors tooerrors.py- Made a new error calledHyMacroExpansionErrorthats raised inmacroexpansion_1`if it fails too expand the macro.\nEDIT: I totally pressed the wrong button,\n. :-1: \nohright! Bug!\n:+1: :shipit: \n. :+1: :shipit: \nLGTM @hylang/core (cough @paultag)\n. The rationale is to think of for*/with* as the underlying compiler implementation where, the macro is just to get the correct syntax. This is to get the consistency of how we write things like let in our code base, even if its nested or not. If we changed this, and switch the * cases around, what about let? are we going to have two lets just to keep consistency?\n. Need more opinions @hylang/core \n. Easier to work with:\nhttp://titanpad.com/RkjJjkE6yu\n. (Is anyone able to find this PR btw?)\n. :angry:\n(ohokay :+1: then)\n. :+1: :shipit: \nsuch support. pre-release wow. such effort\n. +1 :shipit: \nClean and easy fix. Nuthing fancy.\n. :+1: :shipit: \n. :+1: :shipit: \n. i'll just close this so we don't get duplicates.\n. I just think we should keep the docs neat and tidy, so change that one word!\nThen:\n  :+1: \n. :shipit: :+1: GOGOGO\n. :+1: :shipit: \n. :+1: :shipit: \n. Right, i totally forgot to run sphinx before pushing.\n. ping @hylang/core!\n. ping @bismigalis.\n. @bismigalis also please fix the stuff mentioned by @theanalyst and @tuturto \nTry to solve all the PR's lingering :)\n:shipit: \n. :+1: :shipit: \n. :+1: \nLooks much better!\n. So, i looked into it and left a few comments in your commit. Works here :)\n. :+1: Spot on! Merging!\n. https://github.com/hylang/hy/blob/master/hy/contrib/loop.hy#L50\nJust for refference.\n. While on the topic of reorganizing. I think we should move \"Reader Macros\" somewhere else. It dosnt feel important enough to be on the same level as API and Internal docs. But the question is where?\nThe changes so far is +1 tho!\n. :+1: :shipit: \n. We could have it set inside Meth?\n. Well, i'd say we drop the shim and do as suggested in #329\n. LGTM! :shipit: \n. :+1: :shipit: \n. I got no idea how this was merged by me. #603 was the one i closed, and somehow this went inn aswell.\nWut?\n. :+1: :shipit: \nLGTM\n. Wopwop, fixed @theanalyst\n. Example use\nclj\n=> (require hy.contrib.multi)\n=> (defmulti foo \n...   ([a] (print a))\n...   ([a b] (print b))\n...   ([a b c] (foo c)))\n=> (foo 1)\n1\n=> (foo 1 2)\n2\n=> (foo 1 2 3)\n3\n. @theanalyst It was (apply fn args kwargs) causing the problem. I do believe @olasd said (def self.fn fn) should blow up, but so far it have been working without a hitch.\n. @copyninja I disagree. This dosn't at all resemble the multimethods from clojure at all, thus it would be slightly wrong having this in flavor.\n. @copyninja You are very much correct. But its just the name, the actual function of them are different.\n.  We could try and have this sorted for a possible 1.0.0 some time in the future. Trying things out and asking people actually using hy what they think and feel about it would probably be ideal for this.\n. Closing this issue as the discussion is happening in the PR\n. I'll just take a stab at this and say we close this and go with the other PR.\n. @rwtolbert Seems to be the general agreement in the issue. So i'll just close it.\n. @calben later tonight (when i am more sober) i can learn you how to squash commits if you want.\n. @calben ping on this PR.\n. #652 Is the new PR. Closing this!\n. Closing this is as #524 was merged.\n. LGTM!\nOhwait, 2 reviews! Looks like someone got his wish!\n. We could also just do it like we have currently done with apply. Having anything above 3.2+ use the AST and anything under use a re-write of the macro as a special form inside the compiler.\n. Yes, yes and more yes. Lets get this inn ASAP.\nLGTM :+1: \n. Looks great in my opinion. If @cwebber got problems fixing tests he can reuse the ones i made for my original PR, or i can do it and submit a PR for his branch.\n. :+1:  :shipit: \nLooks great!\n. Also, hy2py on Hy code with set! returns invalid syntax: def set!(.\nThe first is actually a problem, but imma just explain this part.\nThe AST dosnt care what we give it. It can take anything we'd like it to take, and it accepts it. hy2py dosnt return valid Python code, this is very apparent when you start using gensyms and have :G_123 = True which obviously isnt valid Python.\nYou have to seperate the two things, Python's AST dosn't follow the grammar of Python. Python puts its own restrictions on what it accepts, like !. In return, Hy can be more loose and accept unicode or bangs and question marks without any problem at all, except for the problem mentioned in this issue.\n. :shipit: \n. +1, but not merging before we know why travis fails.\n. I'll close this as the read PR solves this issue, when/if it gets merged.\n. LGTM :shipit: \n. LGMT :shipit: \n. Just for refference; collected most of them on my blog. Except for the pycon one.\nhttp://fox.devport.no/?p=82\n. I'll close this and add it as a feature on the gethy repo.\n. +1 :shipit: \n. Related/Duplicate problem of #543\n. Looks greats. :+1: \n. This seems to be a 2.7 only bug.\n=> (genexpr [x [1 2 3]] x)\nTraceback (most recent call last):\n  File \"/usr/lib/python3.4/site-packages/hy/importer.py\", line 42, in ast_compile\n    return compile(ast, filename, mode, flags)\nValueError: comprehension with no generators\n=> (list-comp None [])\nTraceback (most recent call last):\n  File \"/usr/lib/python3.4/site-packages/hy/importer.py\", line 42, in ast_compile\n    return compile(ast, filename, mode, flags)\nValueError: comprehension with no generators\n=>\n. Well, the quickest solution is to maybe just add a try/except clause and yell out about the impossible variable name. Might not be the best behavior tho?\n. :+1: :shipit:\nLGTM\n. @joefromct so, fireplace is sadly Clojure-only AFAIK. I have tried to write an nrepl for Hy and hook it up, but fireplace spits clojure code to the nrepl server and does some more vodoo.\nWhat you can do is use a plugin to communicate with a screen/tmux plane and send code into the repl. Can't recall what its called but i know there is one.\n. Ping @olasd @paultag \n. #693 Solves this!\n. I'll try and get read working.\n. 0.10.1 is out and stuff!\n:shipit: \n. @algernon mind fixing the merg conflict so we can get it merged?\n:shipit: \n. @microamp in refference to #628, should i maybe add a (read-string) along with the current (read) function? Wouldn't that simplify the current code?\n. We got hytest as an own lib. Do we still want this or?\n. Python2.6 dosn't like the tests either it seems. Working on figuring out both the problems.\n. Pushed a suggestion for how to solve the multiline problem. Works but uses a hacky *in* variable to store any expression parsed, but not handed out. Lacking a good way to write back to stdin without doing more wizardy.\nSuggestions, rate or hate?\n. Current behaviour.\nhy\n=> (read)\n(\n+\n2\n2\n)(-\n2\n1)\n('+' 2 2)\n=> (read)\n('-' 2 1)\n. I can help out if needed. But would love to have atleast one experienced guy helping out.\n. I'll just close this and review it if it some how becomes an issue later.\n. Is this still relevant after read got merged?\n. Status?\n. This is mostlikely a bug in the implementation of + in hy/core/shadow.hy; https://github.com/hylang/hy/blob/master/hy/core/shadow.hy#L27\nTo be able to use reduce,map & co with operators we needed to make a shadow of several operators.\nRef: #602 \n. LGTM\n:shipit:\n. I'll go ahead and merge this as it seems solid and @agentultra dosnt have any objections at all!\n:shipit: \n. Decided on attrs, so closing this :)\n. @calben I'd really like if you'd keep this in one PR. Neat and tidy!\n:shipit: \n. Need @paultag and possibly @olasd opinion if we should merge this now, or wait for 1.0.0\n. @tianon it could indeed.\n. @ghufransyed use python setup.py install\nThe deps are listen inn https://github.com/hylang/hy/blob/master/setup.py#L48-53\nyou could also use the requirements-dev.txt by doing pip install -r requirements-dev.txt\n. @paultag pffftttt, guidelines man!\n. Parsing return types can be hard. I got no idea how to approach this.\nThere is no way to figure out when something is a return value or a body without adding new syntax.\nhy\n(defn foo [a] (max 3 7))\n(defn foo [a] int)\n(defn foo [a] int (max 3 7))\nI suggest maybe doing something like\nhy\n(defn foo [a] -> int (max 3 7))\nOpinions!\n. Hy seems to not be bothered by a clean arrow. So i figured borrowing from Python would be neat.\nPushed support for return annotations.\nhy\n=> (defn a [[y int]] -> (max 3 7) 7)\n=> a.--annotations--\n{'y': <class 'int'>, 'return': 7}\n. I did some testing for fun\nhttps://github.com/ceronman/typeannotations\nhy\n=> (import [annotation.typed [typechecked]])\n=> (with-decorator typechecked (defn test [[a int]] -> int (print \"yes\")))\n=> (test 1)\nyes\nTraceback (most recent call last):\n  File \"<input>\", line 1, in <module>\n  File \"/home/fox/.virtualenvs/hy/lib/python3.4/site-packages/annotation/typed.py\", line 450, in wrapper\n    return _check_return_type(signature, target(*args, **kwargs))\n  File \"/home/fox/.virtualenvs/hy/lib/python3.4/site-packages/annotation/typed.py\", line 427, in _check_return_type\n    raise TypeError('Incorrect return type')\nTypeError: Incorrect return type\n=> (test \"lol\")\nTraceback (most recent call last):\n  File \"<input>\", line 1, in <module>\n  File \"/home/fox/.virtualenvs/hy/lib/python3.4/site-packages/annotation/typed.py\", line 449, in wrapper\n    _check_argument_types(signature, *args, **kwargs)\n  File \"/home/fox/.virtualenvs/hy/lib/python3.4/site-packages/annotation/typed.py\", line 418, in _check_argument_types\n    raise TypeError('Incorrect type for \"{0}\"'.format(name))\nTypeError: Incorrect type for \"a\"\n=>\n. ``` hy\n;; Something like?\n(defn a [y ^str] (print \"lol\"))\n(defn a [^str y] (print \"lol\"))\n;; But then\n(defn a [y ^\"HEYHO LETS GO!\"] (print \"lol\"))\n(defn a [^\"HEYHO LETS GO!\" y] (print \"lol\"))\n(defn a [^(lambda [x] (print x)) y] (print \"lol\"))\n(defn a [y ^(lambda [x] (print x)) ] (print \"lol\"))\n```\n. @rcarmo The problem i see here is that its the same syntax for different problems. Type hints in clojure is used for optimization, nothing more. Type annotations is much more flexible and goes beyond the scope of hints.\nIf the question is about using the same syntax, we should much rather go with the syntax from typed-clojure (is this even possible?) or Racket.\n. @rcarmo i got a feeling that will be damn hard to implement correctly. But i think it would look better.\n. @agentultra I did have a implementation doing that. But i don't know the practical difference between adding it into the AST or as the decorator. I can write the given decorator above tho and test with some type checking libs.\n. @agentultra it seems like there is a big difference between adding annotations on the AST level and just doing it in .__annotations__. Tried using the typeannotations lib to see what would happen, and it dosnt actually detect the types given by the decorator. It removes them.\nAnother option is adding the suggested \"decorator\" syntax into the compiler. Then just add everything there, as we got control on everything.\n@paultag @olasd sanity checks! Common D:\n. Code i wrote btw:\n``` hy\n(defn AddAnnotations\u00a0[ann ret]\n  (defn _ [fn]\n    (def ret-ann (dict ann))\n    (assoc ret-ann \"return\" ret)\n    (setv fn.annotations ret-ann)\n    fn)\n  _)\n(defmacro ann [types ret fn]\n  (def ret-type (second '~ret))(with-decorator (AddAnnotations '~types ~ret-type) ~fn))\n(ann [[a int] [b int]] [-> str]\n  (defn foo [a b]\n    (print \"lol\")))\n(print foo.--annotations--)\n(import [annotation.typed [typechecked]])\n(with-decorator typechecked\n(ann [[a int] [b int]] [-> str]\n  (defn foo [a b]\n    (print \"lol\"))))\n(print foo.--annotations--)\n;; Output:\n;; {'b': 'int', 'return': 'str', 'a': 'int'}\n;; {}\n```\n. quick update. @agentultra's suggsted syntax might actually work. I'm just having a problem trying to quote the variables without quoting the types aswell. I was just being a tad blunt and quoting everything, making several problems down the line.\n. Did some more work on type annotations.\n``` hy\n(import inspect)\n(defn AddAnnotations\u00a0[ann ret-ann]\n  (defn _ [fn]\n    (assoc ann \"return\" (first ret-ann))\n    (setv fn.--annotations-- ann)\n    fn)\n  _)\n(defmacro ann [args fn]\n  (def ret-ann (if (in :-> ~args) (slice ~args (+ 1 (.index ~args :->)))))\n  (def fn-args (get fn 2))\n  (def ann-args(dict (zip '~fn-args (slice ~args 0 (len '~fn-args)))))\n`(with-decorator (AddAnnotations ~ann-args ~ret-ann) ~fn))\n(ann [int int :-> str]\n  (defn foo [a b]\n    (print \"lol\")))\n(print foo.--annotations--)\n(print (inspect.signature foo))\n```\nThis should be compatible with any libs using annotations, as inspect returns: \n``` python\nMap of annotations\n{'return': , 'a': , 'b': }\nInspect returns\n(a:int, b:int) -> str\n```\nFor further discussion i suggest a keyword/optional annotation syntax along the lines of:\nhy\n(ann [str &optional {:a int :b str} :-> str]\n  (defn foo [bar &optional [a 12] [b \"hey\"]]\n    \"Somethingsomething\"))\nAtm borrowing from core.typed to see if this solves our problem. Not sure how we would be able to parse the latter examples, but might be the correct direction?\n:shipit:\n. I'll just keep this open even tho i have kinda been trying to do this as a separate library and see how far i can take it.\nhttps://github.com/Foxboron/Hype\n. @Tritlo The lib is somewhat functional for use :P \n. This isn't really hard. We could just pass along **locals() into the function.\ndef _hy_anon_fn_1(**locals()):\n. I had no had enough coffee when i thought of that :coffee: \n. And thats a fix on Python2.7? Neat.\n:shipit:\nOn Wed, Oct 1, 2014 at 8:21 PM, Ryan Gonzalez \nnotifications@github.com wrote:\n\nThis has been fixed in the Python source repo.\n\u2014\nReply to this email directly or view it on GitHub.\n. The build shows error, but there seems to be a problem with Travis as tests are passing.\n\n+1 from me :shipit: \nRef: @hylang/core \n. I believe this issue is gone?\nReopen if thats not the case!\n. Superseded by #687\n:shipit: \n. @paultag status?\n. +1 :shipit: \n. Added.\n686\n:shipit: \n. Just gotta love when the only failure is flake8 :D\nOn 11/01/2014 09:31 PM, Berker Peksag wrote:\n\nLGTM. Thanks!\nCould you please silence this flake8 warning:\n|hy/_compat.py:59:30: E701 multiple statements on one line (colon)\n|\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/pull/680#issuecomment-61382170.\n. @kirbyfan64 Anything fixing silly little travis is a +1 LGTM :shipit: from me!\n. How about we just scrap 2.x while we are on it?\n\nOn 11/15/2014 03:17 PM, Berker Peksag wrote:\n\nanyone object to eol'ing py 3.2?\n+100 (and also 2.6)\n\u2014\nReply to this email directly or view it on GitHub https://github.com/hylang/hy/pull/686#issuecomment-63173781.\n. @rcarmo It's more of an internal joke then reality. Don't worry :3\n. Yup. This looks good but i'm not sure if the versionadded is the correct one. \nPing @paultag 0.11 next or 0.10.2?\n. LGTM!\n:shipit: \n. LGTM.\n\n:shipit: \n. Well, it is correct. What you are looking at is the scoping issue we are trying to work around.\nhy --spy and run your code yields this:\n``` hy\n=> (while true\n... (let ((y false))\n... (if (not y)\n... (break)\n... (setv y 1))))\nwhile True:\ndef _hy_anon_fn_1():\n    y = False\n    if (not y):\n        break\n        _hy_anon_var_1 = None\n    else:\n        y = 1\n        _hy_anon_var_1 = y\n    return _hy_anon_var_1\n_hy_anon_fn_1()\n\nTraceback (most recent call last):\n  File \"/usr/lib/python3.4/site-packages/hy/importer.py\", line 42, in ast_compile\n    return compile(ast, filename, mode, flags)\n  File \"\", line 4\nSyntaxError: 'break' outside loop\n```\nAnd as you can see, let creates a function, wrapping the body inside let aswell.\nOn 12/06/2014 11:41 PM, typedweb wrote:\n\nThe following code should compile correctly but the compiler instead says that there is an invalid break outside of a loop, which is not true:\n=> (while true\n(let ((y false))\n(if (not y)\n(break)\n(setv y 1))))\nTraceback (most recent call last):\nFile \"/usr/local/lib/python2.7/dist-packages/hy/importer.py\", line 42, in ast_compile\nreturn compile(ast, filename, mode, flags)\nFile \"\", line 1\nSyntaxError: 'break' outside loop\n\u2014\nReply to this email directly or view it on GitHub https://github.com/hylang/hy/issues/703.\n. I think the better approach would be to try and look into the scoping issue. But i'll CC @paultag and @olasd on this as they got more knowledge on this topic.\n. Great work! Made a few comments, but overall great work on much needed documentation!\n:shipit: \n\nEDIT: Why do berker get awesome comments while i get sucky ones :/? Split-view difference or?\n. LGTM!\nMoar reviews!\n:shipit: \n. @mcktrtl Still an issue even tho you solved it in this case ;)\nBut yes, we could maybe cast the args to the equivalent type before calling replace on it.\n. Partly related: https://gist.github.com/Foxboron/9d05458f76f72380193e\nBeen in the process of rewriting the readme to better explain and showcase Hy in the readme, as its sort-off the landing page for the project, and the current readme doesn't really do any of that in its current shape.\nFeel free to steal/comment/rate/hate on the gist ^^!\nNote: I also like the flat option, looks better with github in my opinion.\n. @iKevinY My only problem is trying to present that quote from paultag without it looking wierd.\n. @iKevinY yeah but the whole quoting part kinda look a bit cheesy.\nAlso uh, PR direction!\n\nEDIT:\nI have now gotten my paultag fanclub card withdrawn for that statement :/\n. Wopetiwop!\n@iKevinY feel free to comment on the gist and i'll try actually fix a PR with it soon\u2122\n. I think we need those yield-from bugs fixed before a release looks at paultag\nOn 04/27/2015 04:59 PM, Paul\u202eetnomailgaT\u202d wrote:\n\n+1 for a release. I'll do it tonight.\nOn Sun, Apr 26, 2015 at 5:26 AM, Berker Peksag notifications@github.com\nwrote:\n\n+1 for a new release. Already merged changes:\n- #795 https://github.com/hylang/hy/pull/795\n- #773 https://github.com/hylang/hy/pull/773\n- #762 https://github.com/hylang/hy/pull/762\n- #763 https://github.com/hylang/hy/pull/763\n- #756 https://github.com/hylang/hy/pull/756\n- #795 https://github.com/hylang/hy/pull/795\n- #753 https://github.com/hylang/hy/pull/753\netc.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/709#issuecomment-96352503.\n\n\n:wq\n\u2014\nReply to this email directly or view it on GitHub https://github.com/hylang/hy/issues/709#issuecomment-96687927.\n. Neat code overall. Tests seem sane enough.\n+1 all over this, LGTM\n:shipit: \n. LGTM.\n:shipit: \n. A little bit unsure about the error message it self. Doesn't read that well in my opinion.\nOtherwise it looks sane. Thinking maybe a test should be added?\n\n:shipit: \n. All tests are passing with this patch. LGTM.\nThen we could also get the #803 merged\n:shipit: \n. closing this in favor for #783 \n. Basically, thats what we have been thinking about. But we ain't really sure what to do. Hack rply into a suitable form? Replace everything (again)?\nI have been messing to see if its possible to add new things into the rply instance while its running...but uh....easier said then done.\nOn 12/15/2014 02:52 AM, Bogdan Opanchuk wrote:\n\nCurrently Hy has some limited support of reader macros (quote, |#| etc). Is it planned (or even wanted) to add full support of reader macros similar to CL's |set-macro-character|? I think it will\nrequire either replacing the current lexer+parser pair with a custom reader in Python, or, alternatively, leaving the lexer+parser as the first stage that compiles the actual reader written in Hy.\n\u2014\nReply to this email directly or view it on GitHub https://github.com/hylang/hy/issues/722.\n. closing this in favor for #783 \n. closing in favor for #725 \n. You can't, but i will \\o/\n. I really think @agentultra is on something. How much can we reduce the compiler by doing clever macros with the new AST support as an example?\n. @Tritlo you can implement this using the return AST form. Not really hard, but @paultag have been against explicit return statements.\n. @hylang/core opinions? Might be a good idea for the cleanup\n. I think a neat idea would be to have metadata inside functions. Clojure\ndoes this, and i think its an interesting appraoch to problems like\nthese.\n\nclojure\n(defn function [a b c]\n  \"Function with explicit return\"\n  {:return True}\n  (return [a b c]))\nThoughts?\nOn Fri, Jul 24, 2015 at 01:49:09PM -0700, Tuukka Turto wrote:\n\nI'm also -1 on return. I really like building code where last value of function is returned, without having to have return there. So far I haven't had a case where I had needed to return a value from middle of a function. But, I like to chop things into relatively tiny pieces anyway. All of this is of course just a personal preference.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/hylang/hy/issues/739#issuecomment-124718232\n. The line could be done before a comment or something. It's a suggestion, syntax isn't that important yet.\n. > kill yourself, seriously what kind of argument is that? \n\nYeah no. That's just horrible. \nRead https://github.com/hylang/hy/blob/master/CONTRIBUTING.rst and try again if you want to voice your opinions on issues on this project.\n. LGTM! Ze merge is real!\n:shipit: \n. Rad!\nI do find those empty except statements annoying but thats the only nitpick i got.\n:shipit: \n. The code looks sane. But i'll pull this and play with it a little before approving it..\n. whats the difference between switch and cond?\n. Yepz, LGTM.\n:shipit: \n. Looks good to me. :shipit: \n. Needs documentation! Also a possible entry in AUTHORS?\nOtherwise: +1\n. Looks good to me!\n:shipit:\n. Yupz, LGTM!\n:shipit: \n. New flake8 version? Since these does not show up in master.\n. @paultag Might have someone doing it already :D\n. Now #767 can be happy!\n\\o/ LGTM!\n:shipit: \n. rest returns a generator. To avoid this, just wrap it with a list: (list (rest alos))\n. Rpython is a subset of python. It will probably never run on rpython alone.\nOn 03/15/2015 05:13 PM, \u30e8\u30fc\u30f3\u30c8 wrote:\n\nlooks like the |print| call isn't python's standard print..\n\u2014\nReply to this email directly or view it on GitHub https://github.com/hylang/hy/issues/780#issuecomment-81131572.\n. We have discussed if it's possible to generate a .pyc file with everything hy needs.\nThat would be interesting.\n\nOn 03/24/2015 06:41 PM, Nemanja Trifunovic wrote:\n\nWhy not using Hy to develop Hy instead of Python :smiley: ?\nPython sources could be generated for packaging and distribution.\n\u2014\nReply to this email directly or view it on GitHub https://github.com/hylang/hy/issues/786.\n. Yep, lets this merged! LGTM\n:shipit: \n. @hylang/core pop the wine bottles!\n:wine_glass: :fireworks: :beers: :balloon: :tada: :dancer: \n. So rad. Imma +1 this aswell!\n:shipit: \n. I'd say go for it. The limitations with built-ins could very well be worked around.\nIf you got any questions, or wanna hang around to chat, feel free to join #hy on freenode\n. Yepz. Looks goooddd\n:shipit:\n. Seems like this makes it hard to write things in hy which normal py users could use... from the whole JS/Coffee/Typescript debacle, it's at least usually the case that one can use the output of a transpiler in the upstream language.\n\nWell no. Python never see the \"literal Python\" we can generate from the \"invalid\" AST. Python only see the AST. So the AST we generate is valid Python AST, but not really valid \"literal Python\". We also generate variables like :something = 123 which can't be parsed. But the AST is actually more flexible then Python itself.\n. @bollwyvl Not at all trying to sound harsh. Just trying to explain how Hy interacts with the Python world ^^\n. LGTM. :shipit: \n. My terminal ain't even rendering those glyphs :/\nOn Fri, Jul 24, 2015 at 07:41:28AM -0700, J Kenneth King wrote:\n\nAnd when you have a mail client that renders those glyphs\u2026 I lol.\n\nOn Jul 24, 2015, at 10:32 AM, Ewald P. Grusk notifications@github.com wrote:\nI have applied the fix suggested by @algernon (see #821 and #822) to the working directory of my local repository. The tests pass, but here\u2019s the catch:\n;; Python 2.7.3 on Linux\n((\nfn [\ud83d\udca9] \ud83d\udca9) 1\n)\n;; 1L\n((\nfn\n [\ud83d\udca9] \ud83d\udca9) :\ud83d\udca9)\n;; UnicodeEncodeError: 'ascii' codec can't encode character u'\\U0001f4a9' \u2026\n((\nfn [\ud83d\udca9] \ud83d\udca9) :\ud83d\udca9 1\n)\n;; UnicodeEncodeError: 'ascii' codec can't encode character u'\\U0001f4a9' \u2026\nNeedless to say that Python 3 is not affected by this.\n\u2014\nReply to this email directly or view it on GitHub.\n\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/hylang/hy/pull/815#issuecomment-124545151\n. Atleast i got vim keybinds!\n\nOn Fri, Jul 24, 2015 at 07:46:55AM -0700, J Kenneth King wrote:\n\nYou read email in a terminal still? I have no sympathy. \ud83d\ude1d\n\nOn Jul 24, 2015, at 10:42 AM, Morten Linderud notifications@github.com wrote:\nMy terminal ain't even rendering those glyphs :/\nOn Fri, Jul 24, 2015 at 07:41:28AM -0700, J Kenneth King wrote:\n\nAnd when you have a mail client that renders those glyphs\u2026 I lol.\n\nOn Jul 24, 2015, at 10:32 AM, Ewald P. Grusk notifications@github.com wrote:\nI have applied the fix suggested by @algernon (see #821 and #822) to the working directory of my local repository. The tests pass, but here\u2019s the catch:\n;; Python 2.7.3 on Linux\n((\nfn [\ud83d\udca9] \ud83d\udca9) 1\n)\n;; 1L\n((\nfn\n[\ud83d\udca9] \ud83d\udca9) :\ud83d\udca9)\n;; UnicodeEncodeError: 'ascii' codec can't encode character u'\\U0001f4a9' \u2026\n((\nfn [\ud83d\udca9] \ud83d\udca9) :\ud83d\udca9 1\n)\n;; UnicodeEncodeError: 'ascii' codec can't encode character u'\\U0001f4a9' \u2026\nNeedless to say that Python 3 is not affected by this.\n\u2014\nReply to this email directly or view it on GitHub.\n\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/hylang/hy/pull/815#issuecomment-124545151\n\u2014\nReply to this email directly or view it on GitHub.\n\n\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/hylang/hy/pull/815#issuecomment-124546779\n. @kirbyfan64 join IRC tomorrow and i'll help you fix it \\o/\n. basically\n\ngit checkout master\ngit checkout -b <new branch>\ngit cherry-pick #Get the commits you want from the short-circuit branch\ngit push -f origin:short-circuit <branch name>\nor try revert the changes you did with rebase (not likely) and try again\n. \\o\\ \\o/  /o/\n. :+1:\nMerrgginnggg\n. hy\n=> (defreader s [x] `(set ~x))\n=> #s[1 2 2 3]\n{1, 2, 3}\n=>\nWe do have \"reader macros\" (not proper by any means) that uses # as a dispatch character. But having { as en exception to this rule could work. Won't be hard to implement really.\n. Missing tests and docs \\o/\nDoes looks OK apart from that.\n. I feel 1/2 should be mentioned in the docs. Minor nitpick maybe? It looks great apart from that tho!\n. Yes. +1+1+1+1 all over this!\n:shipit: \n. Missing docs. I really think we need a test in tests/models and tests/lex/test_lex.py as we add new syntax and a model.\n. Oh, right. My mistake. Forgot while i was looking for places to write tests\n. Shouldn't be too hard.\nhttps://docs.python.org/2/library/sets.html\n. +1 :shipit:\n. It's a more lispy way of denoting a static value. The compiled AST will turn this into LIMIT\n. I'll just close this since we do have an issue on the topic\n:shipit: \n. No, i like Python2.6\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\nNot at all. LGTM! :shipit: \n. You are in a camp where we all dream of a day without Python2. We have\npartially started dropping support for Python26 tho, so progress \\o/\nOn Thu, Jul 23, 2015 at 12:49:08PM -0700, gilch wrote:\n\nActually there's a really easy way to make that unnecessary: Drop support for Python 2. Not saying we should necessarily, but Python2 is supposed to go away eventually anyway.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/hylang/hy/issues/844#issuecomment-124222215\n. :shipit: \n. I enjoy the last example a lot. Should give enough flexibility while also supporting the python features\n. -1 from me on this. I really don't see a reason to remove these braces. Let and with, yes sure. But import could match Clojure's import without any problems\n. I believe fixing #846 does fix this issue. So closing this so we don't get duplicates ^^\n\n:shipit: \n. :+1: \n:shipit: \nLooks great, you even removed some of my cough_copypasta_cough from when i implemented it lalala\nLGTM, great work.\n. This also looks sane. +1 :shipit: \n. Looks great. :shipit: \n. Yeps, looks great.\n:+1: :shipit: \n. Also note defmulti i hy isnt multi-methods, but arity-overloading. I\nhave realized in later time its horrible naming. But going to try and\nthrow multimethods into hy.contrib.multi when i can work it out.\nBut i do wonder if we should move it out of contrib and give it a better\nname. That would be neat\nOn Thu, Aug 06, 2015 at 11:51:50PM -0700, Gergely Nagy wrote:\n\nThere's a difference between multimethods (defmulti) and arity overloading (same function, different number of arguments). What you want is the latter, not the former.\nIn hy, this is a bit awkward to do, but entirely doable:\n``` hy\n(defn partition [n &rest args]\n  \"Bla bla bla\"\n(setv argc (len args)\n        coll (last args)\n        step 1\n        with-fillvalue false)\n  (cond\n    [(< argc 2) (throw \"some error\")]\n    [(= argc 3) (setv step (first args))]\n    [(= argc 4) (setv step (first args)\n                      fillvalue (second args)\n                      with-fillvalue true)]\n    [(> argc 4) (throw \"some other error\")])\n;; Here, step and coll are already set. If we have a fillvalue, then \n;; with-fillvalue is true and fillvalue is set. Otherwise with-fillvalue is false.\n\n...)\n\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/hylang/hy/issues/878#issuecomment-128614590\n```\n. The problem is that the decrorator is written in python, so i gotta do a\nrewrite there before anything gets moved.\n\nOn Fri, Aug 07, 2015 at 10:34:30PM -0700, Gergely Nagy wrote:\n\nFair point. We should get defmulti into core then, preferably with a better name.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/hylang/hy/issues/878#issuecomment-128920619\n. It's honestly not confusing. Clojure uses this to a large extend on map/filter/reduce\n\nclj\nuser=> (map #(+ %1 10) [1 2 3])\n(11 12 13)\nuser=> (map (fn [a] (+ a 10)) [1 2 3])\n(11 12 13)\nIn my experience it reduces the verbosity on smaller operations.\n. I'd also like the alias functions to stay. They are usefull even tho the core lib won't be using them much.\n. and more testes! \\o/\n:shipit:  :+1: \n. LGTM! :shipit: \n. Yepz, check all over this!\n. Straight forward. :+1: \n:shipit: \n. Essentially, this is not being used; https://github.com/hylang/hy/blob/master/hy/models/init.py#L39\nWe wrap the different types into HyModels, but they don't always work very well. Thats why you sometimes see people explicitly using HyModels inside macros.\n. My suggestion on IRC is to move get as get-in and implement get with default value as third parameter.\n. Closing this \\o/\n. Closing this. @gilch feel free to make a new issue about the switch idea \\o/\n. Mmmm, do we want a test on this? I think it would be reasonable.\n. Awesome! +1 LGTM!\n:shipit: \n. @ALSchwalm congratz with your first hylang patch :fireworks:\nRealized it wasnt your first patch and your name was in AUTHORS, thats embarrassing. Sorry.\n. Great! LGTM!\n:shipit: \n. Right so, all contributors are added to the AUTHORS file. So @timmartin, feel free to open a PR and add yourself, or hand me a mail and i'll do it for you!\n. This looks solid, also noticed the setv's got replaced for the new def which is pretty nice. Love the sorting of the functions and so on. Great work\n:shipit:  :+1: \n. \\o/ Thank you!\n. closing this as we have the PR!\n. I'll just be blunt and shoot this down.\nThis isn't a hy problem. The reason why you have python2 and python3 is because python offer two versions, and they have been packaged for this. This isn't handled by Python itself, its handled by the package to your distro. Hy isn't suppose to care, and if you want hy to care, you churn out a virtualenv.\nI really struggle to see why this should be fixed in the Hy source.\n. CC: @paultag on this.\n. @gilch \nhttp://kivy.org/planet/2014/10/hy-lisp-and%C2%A0kivy/\n. I kinda think this is partially tied with the Grand Cleanup (still going on). The stable docs have been added so yeah, i'll just close this to unclutter the logg.\n. Interesting request. CC: @paultag @olasd \nSide note: Hei fra Bergen!\n. Closing this for the PR\n. I'd love if you could backtick the require word.\n. <3 Awesome work!\n. I'm actually working a little bit on this problem these days. We are well aware of the problem tho \\o/ Thanks for the code, just what i need!\n. Wops, sorry. LGTM\n:shipit: \n. For future notice i'd advice to use the mailinglist. It's better suited for these kinds of things the github issues.\nhttps://groups.google.com/forum/#!forum/hylang-discuss\nWe should maybe promote it more?\n. Thank you o/\n:shipit: \n. Awesome work \\o/ :shipit: \n. LGTM! :shipit: \n. This looks great!\nLGTM!\n. Might need documentation. Want that in another PR ;P?\n. :shipit: +1\n. Looks great! Thank you. +1\n:shipit: \n. Great! Awesome!\n:shipit: \n. That would be very trivial actually. We decided on one character when i wrote it a looonngg time ago.... maybe @olasd still remembers why.\n. Hurm. Should try and figure out a new name for the defmulti removed in this patch. People are using it afaik, so we can't just remove it.\nOther then that. Looks pretty great!\n:+1: \n. The old defmulti should be renamed IMO. The name was bad and doesnt really reflect how defmulti works inn clojure as an example/\n. 1) Hy is a refference to Hymenoptera. Paultag wrote a master thesis about swarm intelligence if i recall correctly.\n2) I don't recall how we wound up with the cuttlefish.. Thats what i originally did. Tho i still think its more approriate to write it in Hy, since its contrib. I also do agree its a clusterfuck and hard to read. But i am not really sure how i can make it easier.\nhttp://hastebin.com/nahikiciji.py\n. Totally, fixing this with a new push today with some new stuff.\n. PY33 = sys.version_info >= (3, 3)\nPY34 = sys.version_info >= (3, 4)\nas they evaluate to True or False it is.\n. The problemt is that we can't really do that without inserting the ugly *in* hack i did earlier. We might have edge cases like\n(foo bar baz\n bar foo bar\n foo foo bar)(+ 2 2)\nWhat happens with the last line when readline have caught both the form, tokenized them and only spits out the first? Figure that out and we could maybe attempt a readline instead of reading byte by byte.\nWhen it comes to timing:\n``` hy\n(import io)\n(import time)\n(def buf (io.StringIO \"(foo bar baz\\nbar foo bar\\nfoo foo bar)\"))\n(def t (time.time))\n(apply read [] {\"stdin\" buf})\n(print (- (time.time) t))\n```\nEnds up at 0.0125.... Not the best profiling, but i don't think time will be a problem.\n. That would be awesome indeed.\n. Yes totally. I looked for examples showing optional values, but i didn't find anything...until now!\nI'll write up some doc changes and fix read!\n. It's actually Cuddles the Cuttlefish :)\n. Hurmhurm, CC: @paultag\nNow i became uncertain.\n. Completing unicode names might need some work aswell?\n. What about Python 2 :)?\nOn 01/19/2015 05:25 PM, Ilia Choly wrote:\n\nIn hy/completer.py https://github.com/hylang/hy/pull/756#discussion-diff-23169958:\n\n```\n     return matches\ndef global_matches(self, text):\n```\n-        path = PATH\n-        if self.namespace:\n-            path.append(self.namespace)\n-        matches = []\n-        for p in self.path:\n-            for k in p.keys():\n-                k = str(k).replace(\"_\", \"-\")\n\nUnicode completion works for python 3.\n\u2014\nReply to this email directly or view it on GitHub https://github.com/hylang/hy/pull/756/files#r23169958.\n. \n",
    "algernon": "nREPL being a protocol-like thing, we could perhaps implement the backend side of it, and then boom: every nrepl client would work with Hy!\nPiggieback might serve as an example, or inspiration, although that approaches the problem from a different angle as far as I see.\n. I think HyREPL does this. Should this issue be closed?\n. I've been thinking about keywords, and how to implement them, and wrapping HYString sounds easiest, so in the compiler, we can add them to the special types, and use self.special_types there (assuming #32 gets merged in one form or the other), to transform (:foo bar) into (index bar :foo). Everywhere where keywords are not in function position, they can act exactly as a HYString would.\n. Well, (import-from) would need to be smart to notice keywords, but yes.\n. What I was thinking recently, is to modify my patch above to prefix :keywords with some special char to avoid clashes. That's pretty much how ClojureScript does it. This also means that strings will need a similar, inverted check.\n. For python interop, there's two ways to do it (and forgive me, I'm not up to date on recent hy developments, so I'm not sure if either one is feasible): one is to just translate :foo to a prefixed string and be done with it, in which case python code will get a prefixed string indeed. The other way is to 'leak' a Hy object. In either case, the thing will be sufficiently unique - if one wants perfect python interop, then one will have to make sure not to leak advanced lisp stuff out, whatever form that stuff may be in.\nAs for keywords being able to look themselves up in collections... a macro system will not allow that exact form, as far as I see. But again, I'm quite far behind on Hy news, so I'm not sure how it works internally at the moment. I'll see if I can figure that out Soon(tm), in the hopes of finding a way to make clojure-style keywords supported.\n. For the record, there's some work-in-progress code on the f/hy.lang.keyword branch of my repo, at algernon/hy@50a404c5f7114cb0e390969602b763d358b692ee in particular. It needs to be rebased onto master, tests added, compile_keyword fixed to not hardcode casting to unicode, and a little code cleanup.\nOtherwise I'm fairly happy with the implementation, will likely submit a pull request later today.\n. Regarding ([f o o b 1 2 3] 2 3 4), that should throw an arity error.\n. I like @agentultra's idea above, and I especially like the :keyword-ification. But yep, keywords are a bit of a problem. I'll dump my ideas about them in #22 in a bit.\n. grumbles. I'll update the branch later today.\n. There we go, updated. I'll add another test case shortly, just to be safe. But this appears to work fine under both python2.6 and 3.2.\n. Oh, that would be:\nclojure\n(import [sys [exit :as foobar]])\n. I'm not entirely happy with the implementation yet, it's overly verbose for one. I'd also like to remove import-from and import-as, but when I tried to do that, things blew up very badly, when I tried to change the import_from thing at the end of compiler.py.\nNevertheless, the tests pass, and I likely won't have time to work on this more this weekend, so... comments and whatnot welcome.\n. FWIW, I have a partial solution for this on f/smart-import-2. The problem is, if I change the hy_compile function, things break terribly, and I'll get exceptions complaining about the lack of lineno.\n(The branch is also incomplete and wrong, (import [x]) is valid, for example, but there's a test against it).\n. By the way, import-as is easily killable, import-from is the hard one.\n. My branch kills all import-from/import-as usage everywhere, that part wasn't hard (just noisy). The hy_compile is what upsets it badly.\nAgreed on post-.6 though.\n. Not sure. I had a go at it, and lineno errors kept getting thrown in my face, and sadly my skills are far too weak to track those down. I'll refresh my branch later today, though, so it can be reviewed and perhaps someone more knowledgeable can tell me where I screwed up.\n. Assigned to myself, got stuff working, will submit a PR in a bit, after some cleanup.\n. This can be done as a macro, because macros do not touch the lexer, so #126 does not apply.\n. clojure\n(defn foo [x] (if (keyword? x) :KEYWORD :BULLSHIT))\n(foo \"foo\")\n;=> u'\\ufdd0:BULLSHIT'\n(foo :foo)\n;=> u'\\ufdd0:KEYWORD'\nThe code in the pull request works (it's different than the function posted in the original issue).\n. As in, the macro translates to:\nclojure\n(.startswith symbol \"\\uFDD0\")\nWhere, for python2 compatibility and other reasons, the \\uFDD0 is not hardcoded, but an empty HyKeyword is used instead.\n. Come to think of it, I can implement this as a function too:\nclojure\n(defn keyword? [kw] (-> kw (.startswith :)))\nThis works because an empty keyword is allowed (if that should be considered a bug, then we could use (first :something) instead.\nThe macro is still faster though, as it avoids a function call and translates directly to the startswith thing.\n. Wrote tests and whatnot, available in my hyperbaton incubator here. Once some stuff is sorted (see #150), this can go in there too.\nShall I close this ticket, so we have only one thing open?\n. Oh, one learns a new thing every day! I'll see if I can mangle functools.partial into some hyper-super shape.\n. Right, so, nothing really needs to be done:\nlisp\n(import [functools [partial]])\n(def add-one (partial (lambda (x y) (+ x y)) 1))\n(add-one 2)\n;=> 3\nIt would be neat if partial was available without having to import it explicitly, but that's just some sugar on top of the cake.\n. On a related note, #108 is something similar, the solution for both cases may be very much alike.\n. Right, first was a bad example. Here's another:\nclojure\n(import [functools [partial]])\n((partial and True) False)\nI can work around it with a lambda:\nclojure\n((partial (lambda [x, y] (and x y)) True) False)\nBut that's kind of awkward. And yes, the example is horrible, noone in their right mind would write code like this, but this is the simplest form I could distill from the mess I have locally.\n. :+1: \n. It's pretty much x = None or something similar, when you want to make a variable available within the scope, but don't want to give it a default value yet. It's handy, in my opinion.\nThe reason Clojure does not support is likely due to two things: immutability, and clojure's let is a single vector, not a vector of vectors. You can't bake this in there.\n. +1 for aliasing it to defvar too\n. +1\nSuch a library would  be great. Some of the things are in hy/compiler.py already, under different names (nth could be an alias for get, for example). But for the rest. how about hy.heavens ? :)\n. I think that an \"I'll provide a patch\" or \"I'm working/will be working on this\" comment is preferable, unless one can assign the bug to themselves. Notifications are not sent when an issue gets assigned, so if the assignment happens later than issue creation time, mentioning it in a comment should be preferable, in my opinion.\nBut that's just my 2 bits.\n. This was done in the first Hy, but was dropped when I implemented :keyword support for the second time, because I couldn't figure out how to make them really callable, without leaking a HyKeyword object through. In the first version, the compiler checked whether keywords had any arguments, and did its trick then.\nBut stuff like (map :foo {:foo \"foo\" :bar \"bar\"}) did not work then, yet, should have, if keywords were really callable.\n. Yes, please!\n. Hey, lets revive this, and see if we can push this forward within the Grand Language Cleanup!\n. I've been using @olasd's hycons branch for adderall, it's tremendously useful. It would be very hard to implement miniKanren without it (most other miniKanren implementations on platforms without cons, emulate it)\n. The current error is much better:\nHyTypeError: First argument to (fn) must be a list\nTherefore, since olasd's suggestion also solves the problem, I'm closing this issue.\n. Me no like commas, I found them noise in the vast majority of cases. Instead, the repr of Hy objects should be more hyish, in my opinion, to make repl <-> code interaction more convenient.\n. I stand by my opinion of a year ago, and seeing that this didn't get much traffic since, I'm leaning towards closing this without changing Hy.\nAdded to the Grand Language Cleanup milestone nevertheless, because this'd be a breaking change.\n. I like the lambda, but an all unicode prompt is a bit awkward for my taste. \u03bb > or something similar I would be happy with. Or even better, ~/.hy-repl (or something else, like ~/.config/hy/repl.hy) being auto-imported and evaluated when launching the repl. Then everyone could set the prompt whatever way they like.\n. Are you sure *FOO* and 'FOO are the same thing? I don't know Chichek-Scheme, but the apostrophe is for quoting in both lisps I know (elisp & clojure), so 'FOO is more like (quote *FOO*) in Hy, and the latter works.\nClojure also throws an exception when you try to dereference an undefined symbol, and so does Emacs.\n. Just an interesting tidbit, if you want to return a value after changing it, let is your friend:\nclojure\n(defn foo [n]\n  (if (< n 10)\n    (let [old-n n]\n     (setv n (+ n 1))\n     old-n)))\n. Right, you need another [] in the let, but it still doesn't work then, either, due to some funkyness. I'll have a look at it later..\n. Well, every commit goes through Travis CI. Problem is, there aren't enough tests, and this particular code was likely not hit by any of the existing ones.\n. This returns a better error now:\n=> (if true ((print \"hello\")))\nhello\nTraceback (most recent call last):\n  File \"<input>\", line 1, in <module>\nTypeError: 'NoneType' object is not callable\nI believe this is reasonably understandable: it tells me that None can't be executed, so I'll try to find where I'm trying to call a None object, and voila, I find the ((! We can't really suggest using do here, because ((some-fn-that-returns-an-fn)) is entirely valid.\nClosing, because current master has an acceptable error message in this case at least.\n. I think what @paultag really wants, is to prevent people from exploiting shyte. Sand & box come to mind, but I may be missing some context.\n. This should be pretty easy to implement, I believe, and also a great and easy candidate for the Grand Language Cleanup! I'll have a go at it.\n. What do y'all think about this:\nhy\n(apply some-function [] {\"a-b\" 1})\n(apply some-function [] {:a-b 1})\nboth translating to:\npython\nsome_function(*[], **{\"a_b\": 1})\n. As in #198, I'd prefer this option instead of allowing pythonic syntax.\n. +1\n. This is a bit tricky implementation-wise, though, as (assoc foo bar baz) translates to foo[bar]=baz right now. If we want it to return foo, then we'll have to wrap it in a function, which is a bit costy. Or we need to make the compiler smart enough to wrap it only when neccessary... Either way, not easy.\n. The \"which one to use\" is a funny can of worms. But yes, this belongs to the Grand Language Cleanup.\nLast time this came up, one idea was to have a namespace that sets up the aliases. So if someone prefers CL-ish names: (import hy.style.common-lisp)\n. Haha, I like that suggestion.\nOh boy, the possibilities! Tie it in with hydiomatic, and funny warning messages.... mmm. That'd be going a bit too far, though. So perhaps hy.style shouldn't be part of the core language.\n. One of nil and null should go, I agree, but not both. The lower-case names aren't confusing, and feel more Hyish to me. Purging them would create more work than what little complexity it removes. It's just not worth it.\nSo, for the second group, I suggest dropping null, that's neither Pythonic, nor Lispy.\n. The PR had a \"close #240\" string in its description, GitHub caught that, and thought you want to close it. You have to be careful around that thing, it listens to some keywords and ignores context, and then goes and destroys valid issues violently. Tsk, tsk.\nIt can be a useful feature too, but one does have to pay attention.\n. Nothing has to be removed. Some convenience is worth a little extra complexity (though aliases aren't all that complex).\n. I use cons quite extensively in adderall. Without cons, both adderall and hydiomatic would be much harder to implement, and to work with.\n. hy\n=> (cons 1 2)\n(1L . 2L)\n=> (type (cons 1 2))\n<class 'hy.models.cons.HyCons'>\nThis is what I use extensively in adderall & hydiomatic. This lets me do stuff like:\nhy\n(run* [q] \n  (prep \n    (== ?expr `(defn foo [params] (something) (something)))\n    (== ?expr `(~?fn ~?name ~?params . ~?body))\n    (== q ?body)))\n;; => [((u'something') (u'something'))]\nUnifying on (?foo . ?whatever) means that ?whatever will be the rest of the expression. It'd doable with lists and generators and whatnot, but noticably harder, and expressing the intent wouldn't be so easy, either. With cons cells, this is natural: some head, and a tail. Incredibly useful.\n. Looks good to me, and a useful feature too. There's one thing I miss, though: a test that tests whether the thing works if there is no -main, but code in the main body of the file. That should - and is - still supported, and I believe a test for it would be nice to have too.\n. I'd say that is desired behavior, yep. So +1 with the new test!\n. This behaviour is very confusing, especially when combined with hy --spy. Adding it to  the Grand Language Cleanup.\nNot sure how best to fix it, though, or if there's any code relying on this behaviour...\n. +1\n. Looks good to me now. :+1: \n. :+1: \n. While ancient, this'd also be a nice candidate for the Grand Language Cleanup. I'll see if I can pick it up this week.\n. I'd rather have (foo :x 1) than (foo x=1). The former feels lispier, and is easier to compose. Eg: (do-something :list-of-stuff (filter odd? blah)) vs (do-something list-of-stuff=(filter odd? blah)). The second looks plain wrong, and I bet it is a pain to parse, too.\n. (my-func :key=value) has the same issue that (my-func key=value) has: when value is an expression, it looks awkward, and isn't all that easy to compose, or parse. It also feels as alien as key=value.\nAnother option may be:\nhy\n(my-func arg1 arg2 :kwargs {:key value\n                            :key2 value2})\n. Even better.\n. For the record:\n- (defn \"hy\" [] 1) raises a HyTypeError\n- (defn &hy [] 1) works, and is callable later.\n- (defn :hy [] 1) raises a HyMacroExpansionError\n- (defn if [] 1) raieses a HyTypeError\nDidn't test the new HyType case, though. I'll add tests for these cases.\n. :+1:\nLike @Willyfrog, I'd be happier with is_foo than with foo-p (I hate this in Emacs Lisp too).\n. This would be great indeed. I've been debugging some Hy code in pudb recently, and when I use an excessive amount of unicode chars in my symbol names, the munging becomes really annoying. While having this feature will not immediately make pudb more useful, it would make it possible to enhance it to know about the Hy attributes.\n. I'll try my best to spend a little time on cleaning this up in the next few days. Likely not before christmas, but 26th or so looks doable.\n. Updated my branch, it now uses _compile_collect, has more tests, and if the collection is an expression, that gets handled correctly too. Thanks for spotting the mistake, @olasd!\n. Clojure has doall, and dorun, which do something similar, although not exactly the same. But doall sounds good for prog1, in my opinion.\n. See the discussion in #383: we saw no compelling reason to change the earmuffs. For Hy, earmuffs are some minor sugar, and they do not - and should not - work like in other lisps. We're not other lisps.\n. From my experience, when I'm using *foo*, I will try to avoid using foo at the same time, because they're too close, and using both would be confusing. From what I've seen, I'm not the only one keeping things this way, so *foo* => foo is not all that likely to break existing code. Add some shouting bold stuff to NEWS (Hy is still not 1.0, and we did break things before, anyway!) and all will be well.\nThe few of us who use Hy in production already can deal with such breakage. So :+1: from me on this change as-is.\n. Aight, I'll merge this ~tomorrow, as is (after fixing up the conflicts).\n. *foo* will have the earmuffs stripped, judging by the code. It shoud likely become a global with earmuffs stripped, if I understand the docs correctly.\nOn the other hand, looking at this and #378, I'm not so sure we want this. We're Hy, not some-other-lisp. And there's nothing terribly wrong with the earmuffs...\n. Hrm. Lets skip this, to be honest. I too, fail to see a compelling reason for the change.\nI'm closing this, as wontfix.\n. I think ClojureScript's .- makes sense, but in ClojureScript, you write (.-bar foo), not (.- bar foo). It's not a macro, but reader-level sugar.\n. Umpf, that is ugly indeed, and _ isn't all that uncommon (semi-private attributes and all).\n. Me likes too.\n. Yes, please make it core.\n. Me likes, :+1: \n. :+1: this would also simplify some of the code I have in adderall.\n. @paultag can you elaborate what you mean by smarter? \nHandle tuples? (works)\nHandle multiple symbol-value pairs? (works, as of recently)\n. :+1:, I was delighted to use apply today, after remembering that kwapply should die. still not perfect, but much better.\n. For the record, (.foo? (Foo)) at the moment gets translated to is_.foo (Foo ()), which is wrong on two accounts.\n. Yep, those need to be handled too. I'll do it sometime soonish.\n. Updated the patch set, now it includes test, and supports all the examples mentioned by @olasd, and more.\n. Perhaps I can make fluke happy now.\n. I'll rename it to mangle then. As for pushing it to HySymbol, I had a go at that, but after fighting a bit with python and concluding that I'm stupid, I gave up. It would be neat to have that, but I don't want to do that as part of this patch.\n. Branch updated. Renamed the function, and cleaned them up a little bit, so they pass flake8 individually too. Also rolled a new test case into one of the earlier patches.\n. Made flake8 happy, and also changed the print(\"\") to print()s.\n. :+1:, I agree with @berkerpeksag, nothing but the example needs to move, the patch is just making the example more visible.\n. Apart from the typo, which can be patched up in a followup patch, this looks good to me. :+1:\n. :+1: \n. Looks sweet. :+1: \n. I like the new wording more, but the line became too long. Could you re-flow the paragraph, please?\nThe line length does not matter when the document is formatted, but when viewed raw, it looks odd.\n. Looks better, thanks! :+1:\n. :+1: \n. This works under python3, and python2 + hy raises an error:\n```\n=> (defn foo [&kwonly a] a)\n  File \"\", line 1, column 20\n(defn foo [&kwonly a] a)\n                     ^^\nHyTypeError: keyword-only arguments are only available under Python 3\n```\nI think this is sufficient to close this issue (y'all should migrate to python3!)\n. I'll update the branch, and add the (is alias1 alias2) test too, thanks for the notice! As for defalias, I don't think that would be useful for the defmacro-alias/defn-alias case, as the aliases are made in different ways in this two cases. The first creates N macros, same body, different names. The second creates one body, and different references. While some of the code looks similar, I don't see the point of abstracting that away at the moment.\n. Branch rebased to master, new test added. Ping @hylang/core for another review.\n. The main reason I want it is because in another project (adderall), I'm using unicode symbols for function names, which look sweet, but are hard to type. And when I'm working in a REPL outside of my Emacs, I prefer ascii names instead. So I use stuff like this:\nclojure\n(defn-alias [empty\u1d52 emptyo] [l]\n  (\u2261 [] l))\nMuch nicer than doing a (defn) followed by a (def A B). It's also a nice thing to have around when you want to rename a function, but still keep the old for compatibility's sake: you just do an alias, add an obsolete note to the docs, and remove the old name a couple of releases after, giving folk time to migrate. Although I don't see anyone doing that, but in adderall, (defn-alias) is definitely useful.\n. Good catch, thanks! Updated the branch accordingly.\n. :+1: It is supposed to print the generated Python code, indeed.\n. Ping @hylang/core. Not related to the Grand Cleanup, but I'm going through all bugs, and this one seems straightforward.\n. @farhaven, care to turn this into a PR? :)\n. Call me a nitpicker, but canhasdocs too? Or a link to the refspec.\n. Yes please! :+1: \n. Hydiomatic does not call _wrap_value anymore, and I even forgot why we'd need this. Since noone else felt the need to comment, I'm closing this now.\n. Looks good to me. I switched the hy branch adderall and hydiomatic uses to include these patches, and after killing off the local (cons?) and (list*) implementations I had in adderall, all tests pass (tests passed anyway, but all works with the proper implementation of said functions too).\nBig :+1: from me! Looking forward to dropping the forked branch for adderall.\n. I hate you, flake8. You make my code look awful.\n. Patch is backwards, doesn't do the right thing. Will update later.\n. Right. It turns out that I managed to bring in the native type (a list) from hydiomatic. So this PR at least, is invalid and not useful. I'll keep #469 open to track any wrapping issues.\n. :+1:\n. :+1:, except for flake8 being a whiny little mean thing, and wanting two empty lines between defs...\n. :+1:\n. Rebased my branch on top of master, and added support for walking cons cells. @hylang/core review would be lovely, because if this gets in, I can drop the same thing from hydiomatic (and from another project I'm working on, so less dups! YAY!)\n. :+1:, I like it. If I may have a suggestion for future patches: A little bit more descriptive commit message would be nice\u00b9. Something like (in the long description, the summary is fine!): \"Using (:name) resulted in a weird, incomprehensible backtrace.\"\n\u00b9:Commit messages are the hardest part of a patch...\n. :+1: \n. :+1: \n. This is simply multiple arities, which Clojure supports, but so does a lot of other things too. I think contrib is a good place for it for the time being.\n. Indeed, BytesIO is what I needed. Thanks for the hint!\n. :+1:\n. ``` clojure\n(require compatibility.bullshit)\nb\"foo\"\n```\nNot sure if that's doable, but it would be hylarious.\n. Just an update: I can reproduce the same issue on python2, running hy master.\n. Aaand it turns out that this is not a bug, but a feature. We don't want --main-- to get mangled to anything else than __main__. There are other similar cases where we want to keep the current way of mangling. The case of adderall wanting -\u1d52 exported is a corner case, with a known workaround. Therefore, this issue can be safely closed.\n. Has tests, docs too, code looks good too. :+1:\n. This will be terribly useful to me. If I understand this correctly, it will mean I can drop the fn.py dependency from adderall, which would be very nice.\n. YAY! This was mighty annoying for hydiomatic too.\n. If I can be a bit nitpicky: it would be nice to collapse the closing parens onto the last line (same line map is on). Docs, of course, would be super cool, too.\n. I'd love if we could keep some form of (yield-from) for pythons earlier than 3.3. I'm using it in adderall at the moment, and the code is more readable with (yield-form) than the previous version, so I'd like to keep that.\n. I believe this is either fixed, or at least better on master. Can you check?\n. I like the first better too, and it sounds doable too. In setv, have a look at the second arg, if it's a HyList, and starts with yield, go that route, otherwise go on about the usual business.\n. Also, I'm not sure which name I'd prefer... I find both if-true and lisp-if a bit confusing. Perhaps if-truth? But then:\nclojure\n(if (truth? test) :yes :no)\nThat'd make it - at least to me - clearer. That is, having a truth? function that returns lisp-y truthiness and using normal if. That way we keep the pythonicity of Hy, and can use lispy truthyness too, if so preferred, without strangely named macros.\nBut that's just an opinion, I have no strong opinions on the topic, and can be convinced either way.\n. If we want this feature, then :+1: from me on the implementation (but see my comment on efficiency, a minor thing, but nitpick is my middle name).\n. :+1: (and github's rendered diff view is awesome for these kind of doc changes)\n. While working on HumpY, I really wanted name, and thought this got merged already. Since it didn't, here's a bump to @hylang/core! Can we have something like these for 0.10.1 (#622)?\n. I think both name and keyword are fine. name could apply to all kinds of stuff (symbols, keywords, functions, etc), and do the right thing. There was no question about keyword, was there?\n. In other words, +1 for both functions from me, as is.\nWhat kind of trouble would name cause? As far as I see, it does not exist yet, neither in python, nor in hy... (and applies to more than just keywords).\n. With hy master:\n```\n=> (let [x 4] x)\n  File \"\", line 1, column 9\n(let [x 4] x)\n          ^^\nHyMacroExpansionError: let lexical context element must be a list or symbol\n```\nThe setv one still throws an ugly trace. Will see if I can fix that.\n. My opinion here is that this is not a bug. There are symbols that Python can't handle, but Hy can, and symbols that end with a bang are such. There's also ^, and a couple of others that do not get mangled.\nOn the other hand, the foo! syntax is reasonably common, so... how about mangling that to foo_bang ?\n. :+1: \n. This is a bit better on Hy master now:\n``\n=> (defmacro m [] (with-gensyms [sys](do (import [sys :as ~sys]) (print ~sys.stdout))))\n=> (m)\n  File \"\", line 1, column 1\n(m)\n  ^-^\nHyMacroExpansionError: expanding `m': AttributeError(\"'HySymbol' object has no attribute 'stdout'\",)\n```\nAt least it tells you that a HySymbol doesn't have that attribute, which is somewhat better than the previous error. Not sure if we can/want do better. I can add a rule to hydiomatic that'd catch this, though. I'll see what I can do, but if improving hy master's behaviour is too complicated, I'm inclined to close this issue, as we already saw improvement.\n. Aight. So ~sys.stdout gets translated to (unquote sys.stdout), and we can't teach unquote to warn when it sees a dot, because (defmacro m [](do (print ~butlast.--doc--)))` is entirely valid too.\nSo I believe the current error message is a reasonable one, and therefore, I'm closing this issue.\n. Travis fails because you need --allow-external, due to a change in their environment. Bit me a few times before.\n. For the record, I borrowed the unicode trick from ClojureScript. I don't mind migrating to a better way, if there's any, that doesn't leak HyKeyword out of the compiler.\n. Looks good to me, too. Except for the versionadded thing, but that can easily be patched up after merging this. So :+1: from me.\n. Minor correction:\n``` python\nfrom hy.lex import parser, lexer\nfrom hy import HyList\ndef string_to_quoted_expr(s):\n  return HyList(parser.parse(lexer.lex(s))))\n```\nOtherwise the eval will barf and blow up.\n. Hm... Hy master blew up for me on (+ 1 2) without the HyList cast. We really should have a nice wrapper that does the heavy lifting for us. I ran into wanting this a few times too.\n. Oookay, so the following causes Python 2.7 to blow up horribly:\nhy\n(genexpr x [])\n(genexpr [x [1 2 3]] x)\nThey all fail because the ast.ListComp generated by them crashes python. The python syntax does not allow either of these to happen.\nI think we can guard against both of these reasonably well. I'll see what I can do.\n. It was failing due to Travis environmental issues. I relaunched the build, and it passed now.\n. Me likes! I get lost in virtualenvs easily, this is great help! (I'm too lazy to name my virtualenvs correctly, and I don't see them during a long repl session anyway...)\nSo :+1:\n. #634, #591 and #572 are manifestations of the same bug. I'm closing all of them but the first, because they're duplicates.\n. FWIW, if you use ~x instead of ~0, you get the correct error message. You can work it around with something like this:\n````` hy\n(defmacro foo [x]((fn [] (foo ~x))))\n(foo 0)``\n``````\n. Closing this, because #661 was merged.\n. I investigated further, and the issue is not limited to macros. If I have functions ininit.hy, they will not import under python3 (but will do so under python2), and(print \"hello\")will not execute, either (while it does under python2).\n. For the record, importing frominit.py` works under both versions of python, so the problem is likely somewhere on our side.\n. Fixed with #706, whee!\nThanks @rwtolbert!\n. Something like #525 would be really nice to have.\n. Yes, the capital letter is  because this thing is \"special\".\n. Rebased on current master, conflict fixed.\n. @rwtolbert the PR adds an alias, so remove will still be there, except it will be an alias of filterfalse instead of having our own implementation.\n. Wouldn't it be better to use the timeit module available in python 2.3+?\nEven though timeit.timeit requires code to be passed as a string, we could work that around in a macro (put the code in a function, and construct a string that just calls that, and pass that to timeit).\n. For some reason, when using this implementation, the adderall test suite fails. I adapted the interleave function from toolz (see below), and that works. I'll try to narrow down the issue.\nhy\n(defn interleave [seqs]\n  (setv iters (map iter seqs))\n  (while iters\n    (setv newiters [])\n    (for [itr iters]\n      (try\n       (do\n        (yield (next itr))\n        (.append newiters itr))\n       (catch [StopIteration])))\n    (setv iters newiters)))\n(and if I change [&rest seqs] to [seqs] in the PR version, it still fails)\n. I'd prefer the toolz behaviour, but... there's roundrobin in the itertools documentation, which does exactly what I need for adderall. Perhaps we could have interleave as above, and roundrobin from tose recipes? (Or I can have the roundrobin in adderall)\n. The zip-longest approach fails the adderall test suite, there are a few cases where the result does contain nil. I tried that before, but unfortunately, the behaviour I want is a bit different.\nWhat I need is a function that interleaves elements from the given seqs until they all have elements, then continues interleaving those that still have elements left, and continues until all lists are exhausted, even if only one list remains at the end.\nFor example:\nhy\n=> (list (interleave [(range 1 6) [:a :b :c :d] ['foo 'bar] [nil]]))\n[1, :a, 'foo, nil, 2, :b, 'bar, 3, :c, 4, :d, 5]\n=> (list (round-robin [(range 1 6) [:a :b :c :d] ['foo 'bar] [nil]]))\n[1, :a, 'foo, 2, :b, 'bar, 3, :c, 4, :d, 5]\nI need the nil there, that is a perfectly valid value.\n. Delicious! Can't wait to use it in Hydiomatic! (Especially if/when we can teach read how to preserve some meta-data, like line numbers and stuff!)\n. :-1:, the traffic on contrib is low, yet, getting code into hy is easy, so I do not see the point of moving contrib out of Hy at this time. And submodules are a huge pain, that'd just make contrib much more newcomer unfriendly.\nSince the downsides are numerous, and upsides are few, how about we close this issue without doing anything? :)\n. #634, #591 and #572 are manifestations of the same bug. I'm closing all of them but the first, because they're duplicates.\n. Looks good to me! :+1:\n. Clojure uses ^str, so: (defn pow2 [^int n] (^int (* n n))) or something like that. But those are type hints, not annotations. Yet, it is fairly succint.\n. Since we're breaking the world anyway, lets get this in. Needs a rebase, though (I can do that locally, if need be).\n:+1: \n. I'll merge this as-is (after patching up the conflicts) ~tomorrow. The name is fine, and a reader macro can be introduced later (or locally, if someone really prefers).\n. After rebasing, there are some test failures, as new tests that use slice were introduced after the PR was made. I'll correct those, and merge the rebased stuff in a bit.\n. I has a very sad.\n. Agreed, contrib it should go.\n. Branch rebased on top of current master. Pinging @hylang/core for one more review!\n. pokes stuff\nOne of the most important stuff in the Grand Language Cleanup is let. I like some of the things here, so... how can I help make this go forward?\n. I like where this is going. Will have a stab at it today.\n. I had a go at this, and found a few complicating issues:\n- instance?, first, and defn are not yet available at bootstrap, so you can't use that in the macro definition.\n- gensym is problematic... it should be moved to bootstrap if we want to use it from let... but it is easier to use uuid instead then.\n- replace-symbols needs to do a deep walking, and traverse into lists and dicts too, otherwise things will break:\n``` hy\n(let [[citer (iter coll)]]\n  (for* [v citer]\n    ...))\n(let [[x 1]]\n  {:x x})\n(defmacro zing [] `x)\n(let [[x 1]] (zing))\n```\nThese all work currently, but wouldn't with @farhaven's replace-symbols\n. You pretty much need hy.contrib.walk for this, and some heavy rewriting. The most problematic part is the last one, where you use a macro within let. You can't rewrite that without expanding the macro first.\n. > Have you tried it?\nYes. That's why I listed it as a problem. Mind you, perhaps my implementation was lacking. I'll push what I have onto a branch on ~monday.\n. FWIW, in Scheme (Guile):\nscheme\n(car (cons 1 2))\n; => 1\n(cdr (cons 1 2))\n; => 2\nSo in other lisps, where cons are supported, (rest) returns the tail. Hy differs here, and that's unfortunate. Can we fix this, please?\n. Hm, indeed. (cdr (cons :a :b)) works in Hy too. That's good enough for me. Thanks!\nClosing this issue, since there's an existing solution that works across all Hy versions adderall cares about.\n. <3\n. +1.\nIIRC the double [[ was there originally, because that was much easier to implement. The reason for for only having one, is that you can only specify one pair there, no?\n. clojure\n(let [x nil\n      y 1])\n?\nWhat purpose does (let [[x]]) serve, that (let [x nil]) can't solve?\n. Silly me copy & pasteing and not testing afterwards. Fixed the failing test with a force push.\n. @cwebber, what do you think of the syntax in #875? Is that better, good enough?\nIf so, we may be able to close this issue.\n. :-1:. Hy's still not 1.0, it is expected to break existing code from time to time. Supporting older syntax and stuff via language versioning is terrible. If something doesn't work with a newer Hy, either migrate, or use an older Hy version, I'd say.\nNowadays we try to not break many things, so the problem is far less pressing than it used to be.\n. I'm also -1 on return. Mixing explicit and implicit returns would be confusing, in my opinion.\n. We may want to reevaluate whether an explicit return is useful. I can do without it, but in the time between my previous diapproval and now, I became less... opinionated. So +0, I guess? :)\n. I like this latest proposal.\n. Changing eval would break things like (eval '\"foobar\"). While that is rare, it's not unheard of to have functions or macros that build either an s-expression, or a plain value (string or number, or anything else). It makes the caller code easier if I can just eval the results, without having to check whether it's an s-expression.\n. Happens with 0.11 and git master too.\n. This may be related to wnck, because if I import pretty much any other module I could think of instead of it, then both forms work.\nMind you, (import [adderall.dsl [*]] [wnck]) (print \u2261) works in the REPL when placed on one line. On two separate lines, it fails. That's a little bit weird too.\n. Running hy --spy reveals:\n=> (import [adderall.dsl [*]] [wnck]) (print \u2261)\nfrom adderall.dsl import *\nimport wnck\nprint(hy_2ch)\n<function hy_2ch at 0x7f5b23e6c1b8>\n=> (import [adderall.dsl [*]] [wnck])\nfrom adderall.dsl import *\nimport wnck\n=> (print \u2261)\nprint(\u2261)\nTraceback (most recent call last):\n  File \"<input>\", line 1, in <module>\nNameError: name '\u2261' is not defined\nSo the reason why it works in the REPL when on the same line, is likely because whatever magic wnck is doing is done after the REPL is done parsing and mungling the symbol names. While when its on another line, the symbol rewriting is botched by then.\n. Tempted to close this as some wnck hackery with python internals that I'm just not interested in solving. A workaround exists, noone else seems to have run into this issue, and by the look of things, the fix would be a workaround too, just on the hy side, instead of in libraries that dare use funky function names.\nSo closing it is!\n. LGTM :+1: \n. The problem is that we want to have two things:\n- An error message when one tries to do stuff like (defn get [&rest args] 42) at the top level. We want this, because otherwise it'd be surprising that sometimes the built-in gets called, sometimes our function.\n- Yet, we also want to allow names with builtins in cases where there's a surrounding context (such as a class)\nThis is hard. Hard, because the compiler - as far as I see - doesn't see the context.\n. There are a number of solutions I can imagine:\n1) Teach the compiler about context. If it can walk up the expressions to see if it is under a particular form, that'd help. This has the drawback that this isn't entirely trivial. We can't just store the parsed stuff, we have to macroexpand it too. Doesn't sound pretty to me.\n2) Teach (setv) to take a special argument, something like this: (setv :^allow-builtins ...). If the flag is present, we allow deffing stuff which would otherwise shadow builtins. Then (defclass) could be taught to rewrite setvs and defns within itself to add an :^allow-builtins flag. This sounds like a bit of a hack, though.\n3) Store some state within the compiler: (defclass) would set self.allow_builtins to true while compiling its body, and set it back to its original value at the end. This is a hack, but at the python level, and doesn't leak through to Hy code. Not sure it would work, though.\nI'll have a stab at the third option.\n. LGTM :+1: \n. Since this is doable in Hy, using itertools.count, I'm closing this issue. Our range is python's range, which works the way it does.\n. I'm not sure you can catch this. Macro expansion happens at compile time, while try/catch at runtime. By the time Hy gets to the (try (catch ...)) block, the macro expansion already happened, failed, and raised an exception.\n. Protocols would be lovely to have. That would make a lot of things in adderall a lot easier, and a number of features that I'd love, possible.\n. That's because [> is not the same as (>. [> (total 3 4) 100] is a vector of three elements: the function >, the result of (total 3 4) and the number 100, whereas (> (total 3 4) 100) would be a proper function call.\nSo if does work correctly, and does what it needs to: given that a non-empty vector is true-ish, it executes the true branch. Once you fix it, and change the vector to a list, the else branch will be run.\n. Merged this, after patching it up a bit with stuff from #822. All tests pass, and the error message is nice.\n. Fixed on master.\n. The fix in #815 may be better than mine.\nShould've looked more closely before filing a duplicate.\n. Ping @hylang/core for more opinions/+1s. I'd like to release a new version of hydiomatic, but that depends on this fix.\n. Not yet. I'll update the PR in a bit, using @zackmdavis's example.\n. I'd say that's a different issue @gilch. A worthwhile topic to explore, but indeed, more related to #842, so lets track that separately from this. Can you open a bug?\n@kirbyfan64 Squash it! :)\n. This is a toughie. I think that (string? 'symbol) returning true is wrong. On the other hand, (string? :keyword) throwing an exception ain't exactly friendly, either. I'd propose both should return false.\nOpinions?\n. See #846 \n. hy\n(+ '(3 3) '(4 4))\n. In favour of let, I'd like to say that working primarily in Clojure, my fingers remember let. It would feel strange and alien without it. Nevertheless, a macro that translates it to setvs would be fine with my finger memory.\n. Can we do the cleanup before ~september? I'd rather go into production with \"modern\" Hy.\n(The contrib shim sounds like a reasonable idea.)\n. I'd keep some kind of let. A macro that expands to a set of setvs, to at least seem familiar. But then, calling that let may not be the best idea...\n. This'll do for a bug. I'll prep a PR tomorrow, unless someone beats me to it.\n. I have a proposal: while @kirbyfan64 is working on the try/except-based let, I'd implement the other, fallback option: a let macro that translates to setv.\nSomething like this:\nhy\n(defmacro let [bindings &rest body]\n  `(do\n    (setv ~@bindings)\n    ~@body))\nThat'd also address #713.\n. I started working on the let change proposed above. Turns out it is much more involved than initially thought. WIP code available on the f/let-to-setv-based-macro branch in my repo. Tests fail, with cryptic errors, and some of the translations are likely buggy too.\nUnfortunately, my timebox for this task today is used up, feel free to take what I have and run with it, or ignore and start from scratch.\n. My plan is to have a let, that follows python scoping rules. See the short macro I posted earlier. So with-gensyms would still use let underneath (or setv, doesn't matter much, although I find the let form more familiar).\n. Yes, it would. But the contrib shim would need to be imported explicitly, and would shadow the other one.\n. Well, the shim should only be imported if all lets in that context need to follow the old ways. I'll make sure that the hy built-in macros won't be affected (they'll likely use setv directly). So I don't think this'll be a huge issue.\nOr, we can just drop the idea of an old-let shim: while changes too, and there'll be plenty of other breaking changes. I suggest we try to improve the tooling instead. HyREPL + hydiomatic + vim/emacs/lighttable integration would mean that one can press a combo, and get a hint at what the form should be replaced with. Or run hydiomatic on a piece of code, and get a diff back.\n. I'll be closing this one. We pretty much agreed that we want to reimplement let, one way or the other, but we'll be keeping some kind of let.\nSee #688 and #713 for various options.\n. That is certainly an option too. But it looks a bit weird to have (import [foo :as bar]), but not having keywords. If we get rid of keywords, we'll need to figure out a way to change imports too, I'd say.\n. Almost two years in, and having Hy depolyed into production at various places, it turns out that I can live without keywords as objects. As noone else stepped up to implement them either, lets get rid of this issue!. Sounds like it shouldn't be too hard to implement!\n. hy\n(list-comp (, x y) [x (range 10) :if (= 0 (% x 5))]\n                   [y (expensive_generator)])\nThis is a variant of 1 & 2: each predicate is in a vector, which makes it straightforward to parse. (The no-brackets option would be a pain to parse and highlight, imo).\n. One argument in support for braces: they make it easier to quickly select, move, rearrange, kill, etc a particular part of the expression. Also makes it easier for stuff like hydiomatic to make sense of the expression.\nFor example, if we have this:\nhy\n(list-comp (, x y)\n  x (some-expression-that-makes-the-line-long-enough-to-wrap 10) \n    :if (= 0 (% x 5))\n  y (expensive_generator))\nIn Emacs, I can't easily cut the first predicate: it spans two lines, and I'd have to teach hy-mode to recognise the form to be able to support selecting it. If it is in brackets, paredit already handles it for me. One of the reasons I prefer brackets & parens around distinct parts of an expression is because it makes it easier to navigate the source programmatically.\nWhen you do a lot of work that involves walking the code (hello hydiomatic!), you'd like to be able to walk it easily, without reimplementing half of the compiler.\n. Looks good. A test @gilch described would be great, though, I'd merge this much more confidently. Big :+1: otherwise!\n. No strong opinion on this, but I'd keep one of the braces:\n(defclass Cat []\n   [age None\n    colour \"white\"\n    speak (fn [self] (print \"Meow\"))])\nThis would make it a tiny bit easier and more straightforward to add docstring support (if we want / can):\n(defclass Cat []\n   \"Kitty kat says Meow\"\n   [age None\n    ...])\n. Yuck, --doc-- looks terrible, sorry. We could do without an explicit docstring marker, and without brackets, but that'd be even more confusing. Just a hunch, but I'm for only removing one level of brackets. But, as I said earlier, I have no strong arguments for or against either way.\n. The last proposed syntax looks fine to me. A noticable improvement over the current one, :+1: for that!\n. Ping @hylang/core, any other opinions?\nI was also toying with this idea:\nhy\n(defclass Cat []\n  \"docstring\"\n  [age None\n   colour \"white\"]\n  (for [x (range 10)]\n    (print \"side effect #\" x))\n  (defn speak [self]\n    (print \"meow\"))\nThat is, we'd have an optional property list, because that looks nicer than (setv ...). Parsing would go like this:\n- Is the first arg a string? Yes? Docstring! If no, continue.\n- Is the next arg a HyList? Yes? Property list! If no, continue.\n- Everything else translates to stuff within the class's scope.\n. Another idea: have a class that doesn't do much sugar:\nhy\n(class Cat []\n  \"optional docstring\"\n  (setv ...)\n  (defn ...))\nAnd build a (defclass) macro on top of that.\n. I'm ok with either. The difference is about 5-6 lines of code (and updates to docs / tests). I'm slightly happier with the special case, but if others in @hylang/core prefer the bare-bones approach, I'll update the patch.\n. I'd keep the current import syntax. The current one is closer to Clojure, and in my opinion, is more readable than without a set of braces. In case of let and while, the double braces are annoying, but we don't have that with import (sometimes at the end, yes, but that's not an issue in general).\nSo :-1: from me too.\n. The consensus here (even when not counting my own) seems to be in favour of keeping the current syntax. I don't see a compelling reason for dropping the redundant braces, therefore I'm closing this issue.\n. I wouldn't use keywords there... instead:\n(with [arg (expr)\n       _ (expr)]\n  block)\nJust make them pairs - easy to split, easy to work with, less to type, and - in my opinion - feels more natural.\n. Nil's fine, yep.\n. FWIW, this should be done after #713.\n. I can teach hydiomatic to add these kinds of suggestions. It can't automatically rewrite the code for you, though. That'd be a different (and useful) tool.\n. For the record, only #830 is left now. I'm closing this, so we have only one issue to track further. Added that to the milestone.\n. How about this:\nhy\n(defclass Foo [Parent1 Parent2 [:meta MyMeta]])\n  ...\nThe reason for the extra brackets is that this makes it stand out a bit more, which makes it easier (for the human eye) to notice, especially when one adds more parent classes after:\nhy\n(defclass Foo [P1 [:meta Meta] P2]\n  ...)\nvs\nhy\n(defclass Foo [P1 :meta Meta P2]\n  ...)\nNegligible difference, mind you, but I believe bracket-grouping these kinds of things is a useful thing. Also, this way I can just iterate over the members of the parent list, and if I find a list, I'll handle that specially. If we had it inlined, I'd have to check each element and sometimes pop one off, sometimes two. With a bracket, we pop one off every time, and maybe treat it specially. Again, not much of a difference, but still.\nSince this is not likely to be used all that much, the extra brackets shouldn't be much of an issue to type.\n. Hrm. I brooded over this last night, and your reasoning makes sense. I'll prep a PR with a (defclass Foo [a b :meta m] ...)  syntax.\n. :+1: for #@\n. Looks good. Could you rebase the branch on top of master?\n:+1: after that.\n. :+1: \n. Done, welcome @farhaven!\n. I too, prefer the current syntax. Braces aren't necessarily evil, we do not need to purge as many of them as possible. And in case of for, they serve a desirable purpose.\nOn the other hand, I agree that an implicit do would be a blessing - same goes for cond, that drived me nuts a couple of times too. Can you open a separate bug about that @kirbyfan64?\n. Closing this one, #874 is where the fate of for is discussed further, while #868 takes care of the implicit do.\n. How about this?\n`` hy\n(defreader G [expr](genexpr ~expr))\n(tuple #G(x [x (range 12)] (even? x)))\n```\nYes, I know, no parens/braces saved. But still shorter... Can't put my finger on why, but #G(tuple x [x (range 12)] (even? x)) feels strange. Mind you, I'm just throwing around an idea now.\nThe reason the \"alias\"-like reader macro feels better to me is that in Python, the syntax makes the generator expression simpler. So does the macro. If we put the #G outside of the whole form, I don't know... that suggests we apply it to the whole expression, which is not exactly the case.\n. #() sounds better, indeed. I faintly remember trying to name a reader macro that, and failing (because the parens get parsed or something earlier). So that may need some changes in deeper parts of Hy, too.\n. tests/native_tests/contrib/walk.hy needs an update, for the implicit do.\nOther than that, looks good! :+1: after the test fix.\n. There's a failing test... something changed in a way the test doesn't like. Probably harmless, but should be investigated. Do you want to do it @kirbyfan64, or shall I have a go at it?\n. I had a go at it: (get [] -1) raised an error, that was the bulk of it. And that came to be because in (for [x]), we have no body. So adding a check before the (setv lst (get body -1)) fixes the issue. The check should throw a \"requires body to evaluate\" error, and we'll keep the other check within the cond too, to catch the case where there is an else-body only.\nI'll add these changes to a branch, with a test case, and merge that along with the changes in this PR.\n. Looks good to me, :+1: \n. :-1:, the current for syntax is not only more readable than having to use product, but the bindings are easier to see at a glance. Compare this two:\nhy\n(for [x (range 3)\n      y (range 2)\n      z (range 1)]\n  (println [x y z]))\nvs\nhy\n(for (, x y z) (product (range 3) (range 2) (range 1))\n  (println [x y z]))\nAt a glance, I can see that y is (range 2) from the first: variable and value are right next to each other. In the second case, I have to scan through the entire line. Even if I reformat it a bit:\nhy\n(for (,        x         y         z)\n     (product (range 3) (range 2) (range 1))\n  (println [x y z]))\nThis is easier to see, but the formatting becomes more work too.\nOn the other hand, teaching the for macro to use product underneath instead of nested for* loops may worth a try. We'd need some approximate numbers though, to see if its worth it.\n. > I'll admit the [] version is prettier than ,/product, however, the same readability complaint applies whenever assigning to tuples, such as (setv (, x y z) (, 3 2 1)), or (for [(k,v) (some-dict.items)] ...). Why are these OK? I don't think we should change all of these to use [] and pairs, do you? \nIn case of (setv), it only has one kind of arguments: symbol-value pairs to associate. You could write the (setv (, x y z) (, 3 2 1)) like this:\nhy\n(setv x 3\n      y 2\n      z 1)\nAlready more readable. Mind you, it doesn't cover the case where you want to destructure the return value of a function, that will always be done with tuples, everywhere, consistently. The reason I don't think a [] makes sense for (setv), but does for (for) is because - as hinted above - the former only has one kind of arguments, while (for) has a list of bindings and a body at least. The [] is a visual aid. Could we get rid of it? Yes. We could get rid of all brackets and parens, too.\nYes, there will be cases - may even be most cases - where you'll have to use a tuple anyway. That's fine, I have nothing against tuples. But if there's a case where we can make it simpler, while not making the other cases terrible, I think we should add that bit of sugar.\nAs for calling a Python Python: Hy is Hy, not Python-with-parens.\n(Mind you, I've yet to deal with #848, I haven't taken those changes in consideration yet.)\n. @gilch: I'd rather fix #855 in a separate PR. I've no clue about the topic, and need to read up on wtf it is about first. We can break stuff twice, no biggie, we're still in the Grand Cleanup.\n. Ping @hylang/core, any more opinions? (leaving #855 aside, for now)\n. I'll open a separate PR about --init-- instead. Shouldn't be too hard to do, will give it a go.\n. One of the use cases of py2hy, namely to discover areas where Hy is more limiting than Python, is something I'd care less about: one can always write that part in python and import it. I don't think of Hy as Python with a different syntax, I think of it as a language that happens to compile to Python AST, and has a reasonably good interop with Python. If you treat it as a different language, the need for py2hy diminishes.\nIt'd still be a useful tool, and combined with hydiomatic and some decent pretty printer & auto-formatter, one could do incredible things. But unlike paultag, I wouldn't be so optimistic about Python AST->Hy being easy.\n. There's a difference between multimethods (defmulti) and arity overloading (same function, different number of arguments). What you want is the latter, not the former.\nIn hy, this is a bit awkward to do, but entirely doable:\n``` hy\n(defn partition [n &rest args]\n  \"Bla bla bla\"\n(setv argc (len args)\n        coll (last args)\n        step 1\n        with-fillvalue false)\n  (cond\n    [(< argc 2) (throw \"some error\")]\n    [(= argc 3) (setv step (first args))]\n    [(= argc 4) (setv step (first args)\n                      fillvalue (second args)\n                      with-fillvalue true)]\n    [(> argc 4) (throw \"some other error\")])\n;; Here, step and coll are already set. If we have a fillvalue, then \n;; with-fillvalue is true and fillvalue is set. Otherwise with-fillvalue is false.\n\n...)\n\n``\n. If moved out of contrib, it should be baked intodefn, I believe. Or call itdefn-arity... or perhaps make it a macro + decorator monster? (not sure if that'd work)\n. Fair point. We should getdefmultiinto core then, preferably with a better name.\n.,` looks a bit weird to me. ,# or #, (the latter may clash with reader macros, mind you) looks a bit better. But I have no strong preference either way.\n. Being in the middle of the Grand Language Cleanup, I like @agentultra's suggestion best. :laughing: \n. :+1:, except for defn-alias and defmacro-alias. They're very useful when you're doing - arguably crazy - stuff like these:\n`` hy\n(defmacro-alias [cond\u1d49 conde] [&rest cs]\n  (with-gensyms [s c]\n    (let [[ncs (__subst-else cs)]](with-monad logic-m\n         (fn [~s]\n           (m-plus (map (fn [~c]\n                          ((apply all ~c) ~s))\n                        [~@ncs])))))))\n(defn-alias [first\u1d52 firsto] [l a]\n  (fresh [d]\n         (cons\u1d52 a d l)))\n```\nGranted, the number of people who do that are few, but when you want to give a function a hy-ish, perhaps unicode name, and still want to allow python people to use it without tearing their hair out, these macros are handy. And fun. I agree they don't have much use, but they aren't completely redundant.\n. :+1: on keeping the setv/def pair. I'd also keep the true, false, null and nil aliases (because I use them a lot, and shift is far away). lambda and fn are slightly different in behaviour, if I remember correctly, but that may have changed.\nI also seem to remember there being a slight difference between first/car and rest/cdr, but I may be imagining things.\n. :+1: on keeping the setv/def pair. I'd also keep the true, false, null and nil aliases (because I use them a lot, and shift is far away). lambda and fn are slightly different in behaviour, if I remember correctly, but that may have changed.\nI also seem to remember there being a slight difference between first/car and rest/cdr, but I may be imagining things.\n. Ok, lets get this rolling: defn-alias / defmacro-alias moved to contrib is a reasonable compromise, I believe, and the rest of this PR is good to go. We'll discuss the other stuff in different PRs / issues (like #240).\n@gilch, can you do the contrib move? Or I can merge this as-is, up to the prior commit, and do the move myself.\n. Suggestions for improvements are welcome. This is something I quickly threw together that passes the tests, but it is kind of ugly.\n. The (def --init-- (fn [self] ...)) case is already handled. I don't want to handle the (def Something.--init-- (fn [self] ...)) one, to be honest, because Something may not be a class, and thus, not need a nil at its end.\nHowever, adding the same logic to --new-- is trivial, I'll do that.\n. This only works for --init-- and --new-- within defclass. I don't think definit or defnew would be any improvement - quite the contrary. For a python programmer, they'd be surprising, as they'd just expect --init-- and --new-- to work without further ado.\n. Ping @hylang/core O;)\nNeed one more thumbs up, or some more criticism. (Except for the special macro stuff, that's already -2 :P)\n. g\nRebased on top of current master, and the --new-- patch dropped.\n. Patch updated, following the suggestions. Breaks due to coverage-foo.\n. Merging this, as there's not much point waiting for more feedback.\n. Ping @hylang/core. This is fairly straightforward, I think.\n. ACK, thanks for the test case. Will fix after sleep.\n. I suppose kwargs is python3+, yes?\n. Right. I had a go at it, and failed miserably. Since I have no use for metaclasses right now, the effort required outweighs my motivation. If someone else feels like taking it further, be my guest.\n. Ping @hylang/core: some of the new code I'm writing would benefit greatly from this, and this is fairly straightforward, too.\n. LGTM, :+1:\n. Slapped a Grand Language Cleanup milestone on this one.\n. See #356, which is related.\n. :+1: \n. (with [nil (open \"touch-me-gently\" \"w\")] (print \"!\")) works. It worked before too, just as _ too, (with) didn't change in that regard.\nI'll redo this PR, and instead of completely changing let, I'll just drop the brackets, and deal with let elsewhere.\n. Updated, now it doesn't change let all that much, just drops the brackets.\n. The old version and the new both do the same thing: hope it does something sane-ish. I'll add a test case, though.\n. Actually, there already is such a test:\nhttps://github.com/algernon/hy/blob/3e7453e5171c82be3c6d15660600ac6d905f3f83/tests/native_tests/language.hy#L574\n. I don't think it's worth removing brackets from cond: we just recently made it so that the vectors have an implicit do, so you can have multiple statements.\nThus:\nhy\n(cond\n [(= foo bar) (do-this) (do-that)]\n [(= hue hue) (do-something-else) (do-that-too)])\nIf we drop the brackets, we lose the ability to do an implicit do. I believe the implicit do is much more useful than dropping the brackets would be.\n. Ping @hylang/core.\n. On the other hand, we have (defn), (def), (defmacro), etc. (defclass) just follows the convention.\n. FWIW, I removed the python builtin check, and the following worked just fine:\nhy\n(def class 1)\n(defclass Foo [] (defn zing [self] (print \"zing!\")))\n(def f (Foo))\n(.zing f)\n(print class)\nPerhaps we should allow Python keywords to be used in Hy? Or at least, some of them.\n. Well, I think if one uses reserved python keywords in Hy code, that's not something we should care about. If one intentionally makes it hard to interoperate with their code from Python (or Hy), that's not something we should be responsible for. One can already make interop a pain, this wouldn't be any different.\nIn short, I'd :+1: a PR that removes the python keyword checking lines, and as such :-1: on defclass => class.\n. LGTM, :+1: \n. This looks interesting, will take a look in a bit.\n. Well, that \"bit\" took a bit long, but I like this, :+1:\n. My preference would be T/F > true/false > True/False.\n. There's already a pretty printer in Hydiomatic, which would be reasonably easy to move over to Hy (as hy.contrib.pprint or somesuch - I wouldn't put it in core just yet).\n. I like this suggestion. PR coming up in a bit.\n. There's a slight problem here: Hy's (get) works on everything that supports the python subscript stuff, be that arrays, dicts, and whatnot. Trying to subscript a key or index that doesn't exist, raise different exceptions. So to make (get) truly generic, I'd have to catch all exceptions. That does not sound like something we'd want.\n. So, unless someone knows a way how to do this in a sane way, I'd say (.get) ain't that bad.\n. Based on the problem explained above, I'm closing this, because there's no way to properly implement it.\n. :+1: \n. I'd suggest a new issue for the else branch of cond. Shouldn't be too hard to implement after this, I hope!\n. Looks good to me, by the way, so :+1: \n. @kirbyfan64 if you already have it, feel free to push it here, no need for a separate PR then.\n. The problem is that test.+ is still + as far as the test module is concerned, and thus, would shadow a built-in. Right now, the only way to define a function with the name of a built-in, is to use Hy from git master, and (defclass).\n. I like this, a lot. :+1:\n. :+1: \n. :+1:\nAnyone want to fire up a PR to drop zipwith?\n. Looks good to me on a quick glance. :+1: \n. :+1:\nI'm updating hydiomatic too, based on these changes.\n. I'd be fine with allowing the user to specify what postfix to append to the binaries installed by hy. I may have python3.2 and python3.4 installed at the same time, and the current patch won't handle that. Since this is a distro thing, if Hy makes it easy to change the script names, that's fine. But trying to do that automatically is not something we should do, in my opinion.\n. Looks good. Could you perhaps add a test that verifies that (def foo bar baz) has the right error message?\n. :+1: \nGreat work, thank you!\n. Already fixed, closing.\n. Looks good to me too.\n. :+1: for the PR, and another :+1: for bumping the version on master.\n. :+1: \n. Macros:\nhy\n(defmacro blah [&rest args]\n  `(< ~@args))\n(blah 1)\n(blah 1 2)\nMuch simpler than if you'd have to check the length of args for each similar macro.\n. true for all but !=, which would be false, and the collection-related comparators (in, not-in, etc) I wouldn't touch, either.\nI have a patch in the works, btw, just finishing up the tests.\n. Looks good, :+1: \n. Lots of things are valid lisp, yet, ugly.\nI'd have a counter-proposal:\n(defn addition ^[@increment] [a b] (+ a b))\n(defn addition ^{:decorator increment} [a b] (+a b))\nI'd put the decorators after the function name, and use a ^ mark, to make it clear it is not the argument list. I'd also allow the second form, which paves the way for additional meta-data, clojure-style.\n(These are just random ideas, I have no preference whatsoever, as I am fine with #@ so far.) \n. Hydiomatic already warns about this, provided that the symbol (without the \",\") is used later in the body of the function. It only checks within fn, defn, defmacro and defun... adding let, for and a couple of other things that take bindings may be worth it. Warnings are only displayed by hydiomatic if run with the -w option.\nI wouldn't add a warning to Hy itself, because the variable name is valid, one just has to remember that \",\" is part of the name, too. Mind you, there's not a lot of sane use cases for it, but still.\n. The keyword implementation is - as far as I remember - is a very ugly, slightly flaky hack. Might be worth extending to vector/map/etc literals, mind you. I'll have a try at remembering how the heck the keyword magic works, and see if it can be extended to other stuff too.\n. Looks good! The git history is a bit funky (I have an idea or two why, I'll drop by on IRC tomorrow and explain, if anyone's interested), but that's no big deal.\n:+1: \n. Ah, no worries. I'll just dump the ideas here then. :)\n. Looks sweet, :+1:\n. Closing this, the solution provided by @gilch should be sufficient.\n. The syntax was improved recently, the hy 0.11.0 does not support {:title \"Lord\"} yet. Use {\"title\" \"Lord\"} instead.\nThe docs for the last released version of Hy are at http://docs.hylang.org/en/stable/\n. I will try adderall and hydiomatic with this let, over the holidays.\n. +1\n. Docs. Me no like docs. Should be here, but for some 24 reasons, I'd prefer to do that in another.\n. There's macroexpand-all in hy.contrib.walk, which is recursive, and does the right thing.\nAt least it does, when I copy & paste the code to a repl. If I import it, it fails, which is weird as hell.\n. Tests say green, lets give this a greenlight too.\n:+1: \n. +1 for fixing it for Python3. Going forward, py3 is the way to go, lets make things easier there!\n(This'd also allow me to sneak Hy into more places without anyone noticing...)\n. FWIW, hylang/hydiomatic can catch these kind of issues. :)\n. A test would be very neat, but I'd :+1: it anyway.\n. Looks good to me, and I agree with the previous suggestions re: old defmulti.\n:shipit: \n. :+1:\nI came to the conclusion, that a contrib let is fine with me.\n. I agree, #_ would be great. It needs to be on a parser level, I suppose, since it needs to be ignored, and not even make it to the AST.\n. Not sure I can do that, Hydiomatic sees the mangled names only, unless we added some meta-data to Hy while I wasn't looking (or if I was looking, I forgot). But if Hydiomatic can, somehow, figure out the original symbol name, then adding these checks would be a breeze.\n. The thing is, (+ method \"_\" name) will result in a string, while defn requires a symbol. Try wrapping that in (HySymbol ...).\nAs for the others - yeah, name mangling is not applied in these cases.\n. We mangle ordinary symbols because of Python interop. Keywords are already a pain to interop with from Python, so mangling there does not buy us anything useful, in my opinion.. If I'm reading the code correctly, do-setv works like (do-setv name expression), right? In that case, we could just call it (setv!), perhaps.\n. Well, if I have a function which needs kwargs, and returns a function which also needs kwargs, and I want to immediately call that function, then nesting apply would be useful. But that's a pretty convoluted example, which can be worked around by a temporary variable.\n. Neat, thanks. I'll update in a bit.\n. No, it is intentionally defun, because that's what is in the original, and the point of the function is to be 100% the same as in the Portal soundtrack.\n. http://docs.travis-ci.com/user/caching/#pip-cache\n. Indeed, we can. Thanks!\n. Well, if the return value wouldn't be nil, it'd blow up a few lines later, wouldn't it?\n. Force of habit. The space is there so it lines up nicely with comments below it (if any):\n``` hy\n! /usr/bin/env hy\nstuff.hy -- does stuff\nCopyright (C) 2015 Some One over@the.rainbow\n```\nCompare it to the spaceless variant:\n``` hy\n!/usr/bin/env hy\nstuff.hy -- does stuff\nCopyright (C) 2015 Some One over@the.rainbow\n```\nStriking difference in favour of the first, I say!\n. ",
    "jd": "Mind sharing your idea?\n. I hope you're targeting auto-generation.\n. I definitely lean towards the CLHS solution, probably because I'm more used to this and it makes more sense to me. Maybe using a dict for optional parameter, since it is what it is? Would that make sense?\nclojure\n(defn foo (x &rest args :optional {y 0} &aux kwargs))\n. I'd say that it'd be more Lispy to do\nclojure\n(with (foo)\n  (baz))\nAnd\nclojure\n(with (e foo)\n  (baz))\nHaving only one with sounds better.\n. Looks good to me, but you definitely want to merge your test with your fix so we can avoid having the build failing in the middle of this branch, as Travis tells us :)\n. :+1: \n. Hum mind squashing the commit? It bother me to have test failing in the middle of a branch if we ever need to bisect at some point.\n. Which patch segfaults, the first one?\n. I don't think breaking it up will change anything unfortunately. I'll try do git further into tomorrow this anyway!\n. @khinsen can I be the PITA and ask for a few unit tests? We're likely to change the lexer soon, and it will be neat to have 0 regressions on this.\n@paultag Tested, it works and it's a must have, I definitely want this. I let you merge if the code please you (don't know the lexer that much yet). But I'd prefer we wait unit tests if @khinsen is kind enough to write a few.\n. There's actually some tests that might be enough for now -- I'm just emphasing it. Though there's a mistake in one of the function, I've added a comment on the commit (Github seems to have some problem right now with comments on code line).\n. I'm thinking we should remove pass entirely from the language. It's useless and just a source of problem.\n. Since @paultag agrees with that, I'll fix this by removing pass altogether.\n. Yes, agreed, we already fixed that for with and I think that was the plan to fix that.\nYou missed the case \"from sys import exit as foobar\" I think.\n. I'm unhappy because there's no tests. So we won't know if it breaks again.\n. @algernon want to assign this bug to youi?\n. Ok, I'll assign to me so I'll take a look at what you did.\n. Agree that this is not a bug we likely want to fix in Hy, unless we want to auto import some function. I take the responsibility to close. :)\n. I don't understand the bug. This works fine:\n=> (import first)\n=> (map first.first [[1 2 3] [2 3 4] [3 4 5]])\n[1, 2, 3]\nfirst is not a builtin.\n. That could be fixed with a reader macro forcing resolution to function like #' in CL.\n. LGTM just waiting for Travis\n. Closing because there's no text so I've no clue what the poinf ot this is.\n. Ok, spent 2 hours trying to fix, no result so far, but I know understand mangle and hoist almost perfectly\u2026\nThe problem is that hoist() is stupid & buggy:\nclojure\n(if true (let [[x 0]] x) 42)\nAfter macro expansion extends to\nclojure\n(if true ((fn [] (setv x 0) x)) 42)\nWhich turns into:\nclojure\n(if true (def _hy_hoisted_fn_1 [] (setv x 0) x) (_hy_hoisted_fn_1) 42)\nThe simplest fix I found was to fix hoisting by doing:\nclojure\n(if true (do (def _hy_hoisted_fn_1 [] (setv x 0) x) (_hy_hoisted_fn_1)) 42)\nAnd this work\u2026 BUT it breaks the following:\nclojure\n(= 2 ((fn [] (+ 1 1))))\nBecause this get translated to:\nclojure\n(= 2 (do (def _hy_hoisted_fn_1 [] (+ 1 1)) (_hy_hoisted_fn_1)))\nand would generates the following AST:\nInteractive(body=[Expr(value=Compare(left=Num(n=2,\n                                              lineno=1,\n                                              col_offset=4),\n                                             ops=[Eq()],\n                                             comparators=[[FunctionDef(name='_hy_hoisted_fn_1',\n                                                                       args=arguments(args=[],\n                                                                                           vararg=None,\n                                                                                           kwarg=None,\n                                                                                           defaults=[]),\n                                                                       body=[Return(value=BinOp(left=Num(n=1,\n                                                                                                         lineno=1,\n                                                                                                         col_offset=17),\n                                                                                                        op=Add(),\n                                                                                                        right=Num(n=1,\n                                                                                                                  lineno=1,\n                                                                                                                  col_offset=19),\n                                                                                                        lineno=1,\n                                                                                                        col_offset=19),\n                                                                                               lineno=1,\n                                                                                               col_offset=19)],\n                                                                       decorator_list=[],\n                                                                       lineno=1,\n                                                                       col_offset=7),\n                                                                      Call(func=Name(id='_hy_hoisted_fn_1',\n                                                                                     ctx=Load(),\n                                                                                     lineno=1,\n                                                                                     col_offset=7),\n                                                                                    args=[],\n                                                                                    keywords=[],\n                                                                                    starargs=None,\n                                                                                    kwargs=None,\n                                                                                    lineno=1,\n                                                                                    col_offset=7)]],\n                                             lineno=1,\n                                             col_offset=4),\n                                    lineno=1,\n                                    col_offset=4)])\nWhich as far as I can tell (the error talking about lineno is not obvious) is not compatible with Python. It seems that you can use FunctionDef into comparators=[\u2026], haha. C'mon.\nSo one solution is probably to add a DefMangle that is hoisted outside of the scope if self.scope[0] == HySymbol(\"=\") or any comparator.\nAnother solution, which could be much simple, is to wrap comparators arguments into functions.\n. So each compile method in HyCompiler returns an ast element, either a stmt or a expr.\nWhat if\u2026\nWe change hy.compiler.compile() to add an argument split_stmt which indicates what the parent calling compile() wants statement and expression from its children split into 2 lists (which is, I think, the ultimate problem).\nIf split_stmt is set to True, we make compile() returns 2 things: a list of ast.expr and a list of ast.stmt.\nFor example, compile_compare_op_expression() would build its ast.Compare with split_stmt=True set since it only wants exprs and no stmt:\n``` python\n\u2026\nCompile stuff but keep expr and stmt split\nleft = expression.pop(0)\nleft_expr, left_stmt = self.compile(left, split_stmt=True)\nexpr_and_stmt = [self.compile(x, split_stmt=True) for x in expression]\nReturn a list of expr (our Compare) and a list of stmt to be placed before our exprs\nreturn  ([ast.Compare(left=left_expr, comparators=[e[0] for e in expr_and_stmt]])],\n              [e[1] for e in expr_and_stmt] + [left_expr])\n```\nIn this case, the caller of compile_compare_op_expression would be responsible to build an upper level AST object (what should it be? ast.Expression?) that would evaluate the statement first, and then the expression.\nWDYT @paultag?\n. @olasd: is there a unit test added that will make sure we never break this again? (even if unlikely now :)\n. @olasd Yep, added.\n. Ok that reassures me. LGTM, I'm not hitting merge just because I still don't understand the code. :)\n. What about aliasing to something like defvar too?\n. This fails with pypy for a reason I can't get.\n. @paultag except that it works in the CLI on its own :(\n. % pypy bin/hy\nhy 0.9.6\n=>  (defclass B [] [[x 42] [y (fn [self value] (+ self.x value))]])\n=> (B)\n<__console__.B instance at 0x00007f926d96c460>\nWhat's wrong?\n. @olasd updated with your advice!\n. I will review this on Monday and will give my opinion for sure.\n. Well, I finally had same time today to finish my reviewing.\nSo basically, the code is much better than what we had, and it passes all tests, and will passes more tests as soon as I'll take the time to write more. It will also fix a lot of existing bugs.\nIt's quite clear, and I'm pretty sure that where it's not yet I'll find some way to clarify or comment what it's doing, so this is a ok for me. I'm just sad it doesn't have more unit test, but I'll take that on me.\nSo let's merge this!\n. I'm still new to the compiler, do I've nothing to say, just added a few inline comments.\n. Looks like astor doesn't work with Py3. I'll disable test for it then.\n. @olasd updateed with the any version.\n. :+1: \n. :+1: except you maybe want to use car and cdr in return super(HyCons, cls).__new__(cls) no? or that doesn't matter maybe.\n. Ok, so that doesn't matter then.\n. LGTM\n. Yes, astor doesn't work with Py3.\nThis file isn't used AFAICT, so it shouldn't matter anyway.\n. @paultag there's a likely chance that this is going to be done via reader macro, not via the parser exclusively FWIW.\n. Not sure about the lambda char\n. I don't mind having this by default, however it would be better to check for the locale environment to be UTF-8 at least.\n. I'm all for doing this in another repo.\n. LGTM\n. @olasd I made the same request on @Paultag on IRC already. :)\n. LGTM. Not sure I would have write the code that way, but since it works and we have test, that's good enough for now!\n. @algernon is right, these aren't the same things. 'FOO is (quote foo) and this way different than foo.\n. I'd like to get why @paultag overwrote the buildins in the first place.\nI'm not sure the tests really prove what was wrong in the first place.\n. @Foxboron ahah thanks, purely cosmetics indeed, but nice :)\n. You should also reference the issue you're fixing which seems to be issue #206 \n. Yep, this is a bug, I'm sure @olasd will fix it in a snap since you provided the test case :)\n. The point about returning [1:] is that because cdr on a Python list is actually implemented as [1:]. So it makes sense to say that [1:] is what you want if you want the cdr. I admit that if your cons is composed of a cdr that is not a list, then getting [1] should work, however, using [1] isn't a good idea, cdr should be used.\n@rahmu Your analysis is correct about @paultag problem. You can test it with Common Lisp to be sure:\n``` lisp\n* (list (cons (cons 1 2) (cons 2 3)))\n(((1 . 2) 2 . 3))\n```\nWhich can be written and is equivalent to (((1 . 2) . (2 . 3))\n. Hum this is tricky indeed, the thing is that Lisp list end with a cons where cdr is null, which is never going to really happen in Hy. So I tend to agree with you it's the right thing to do to mimic what CL does here.\n. LGTM\n. Needs rebasing, but LGTM.\n. This looks like a really dumb idea. Could you elaborate on the macro problem?\n. This is a major issue of Hy IMHO. You can't just consider this as a side effect and let it be. This is going to bite a lot of people, and documenting isn't going to be enough, this has to be fixed.\nI'd say that writing `and' as a macro might be a way to fix it.\n. LGTM :+1: \n. LGTM.\nI think setq would be more Lispy though.\n. :+1: \n. LGTM\n. It's going to be a PITA to look for multi-threading issues later. I don't see how it's hard to use a basic lock mechanism right now. We can replace it by something else later, but at least, we won't miss it. (with a test).\n. LGTM\n. LGTM, more points if you merge those commits. :)\n. Ack!\n. ",
    "Coaldust": "There are also set comprehensions in Python, which might be nice to have.  I think most LIsps get by with map, though, so it's not critical.\n. first and rest are pretty harmless, but are you really sure you want to add car and cdr?\nMost programmers think a car is something you drive, and a cdr is a abbreviation that would be better off written out.  Lets not force another round of programmers to memorize the meaning of a register on a long-dead hardware architecture.  Leaky abstraction is leaky.\nWorse, supporting car and cdr will encourage the use of harmful CL idioms, like writing functions like caddaddaddaddaddaddr.  I do not look forward to the day when that is considered \"idiomatic Hy\".\n. This doesn't have to be bad for debugging.  It'd be great if it converted if ... else lf ... chains into elif chains.  It'd also be great if it stripped out all the cruft do blocks leave when nothing is 'listening to' the variable assignments they make.\nIt would, of course, be very spiffy for speed and bytecode space saving.\n. @paultag I wasn't aware that elif resulted in the same AST as else if, though it makes some sense.  I thought it would have saved some bytecode.\nIn any case do blocks definitely do not need to generate code to return their last value if that value is not used.  A cleanup pass could strip that out, making AST dumps easier to read, and saving a little execution time and space.\n. @paultag I've managed to construct some examples that show deeply nested ifs assigning the last return value to a chain of variables, but they can be read by the REPL, and would propagate up to the \"main\" procedure, if present.\nI apologize for my ignorance.  Perhaps this feature is only good for optimization.\nI suppose all that could be done to make the Python translation more readable is have the code that converts the AST to Python source convert else if to elif, to reduce the indention.\n. If you do this, be sure to consider odd corner cases like \"degenerate lists\" ((a . a)).  Be sure you have a way to prevent them, or work with them.\nSome people consider cons to be low level, and a design flaw in Lisp.\n. Hy's current behavior is the correct behavior.  I'm stating this as a fact, rather than a opinion, because making the suggested change will cause bugs.\nA careless reading of the proposal makes it seem reasonable.  Indeed, treating 0 and empty containers as a boolean value is wrong.  Doing this leads to bugs, as can be seen frequently in C-syntaxed languages where \"=\" is accidentally used in a \"if\" statement.  That's why some modern programming languages have a real boolean type, and do not automatically convert nonsense into boolean values.  Popular programming languages that get this right include C# and Java.\nA careful reading reveals that the author actually wants 0 and empty containers to be treated as True, because some other Lisps made this mistake.\nSo the proposal suggests replacing bad Python semantics with bad Lisp semantics.  Note that I consider both to be bad semantics for reasons I've already stated.  If I had my way, and it didn't result in overhead and weird looking code from hy2py (which it would), a exception would be thrown any time a test expression resulted in a type that was not \"bool\".  It would, in fact, be possible to do this.\nThe reason changing Hy's current behavior is \"wrong\" is that Hy code may be called by Python programmers who do not know the code was written in Hy.  These Python programmers will expect None 0 and empty containers to be considered False.  Making use of the fact that non-existent and empty containers are considered False is unfortunately encouraged by the Python community.  In other words, the bad Python semantics are often depended upon.\nBeing able to use Hy code 'invisibly' is a large part of its appeal.  It is a 'stealth Lisp'.  I realize \"a transpiler for s-expressions into Python\" was meant to be disparaging, but Hy should wear the label proudly.\nA Python programmer doesn't have to go through any effort at all to use code written in Hy.  They just import it and call it as if it was all written in Python.\nhy2py can even generate very readable Python code that, with minor tweaking, you could pass off as hand-written in a workplace that forbid the use of any programming language but Python.  At least you could avoid writing lots of boilerplate and \"design patterns\" that macros can automate.\nThis creates the opportunity to use it in the workplace.  It could resurrect the, seemingly extinct, Lisp job.\nOf course if Hy not replicating every last aspect of Common Lisp or Scheme, even the bad parts, really infuriates you, you can always use macros to re-implement them on top of Hy.  Racket has used macros to embed a statically type checked Lisp, after all.\n. It might be suspected that given the heat to light ratio of this discussion that it's all bikeshedding.  This may be partially true.  If you don't depend on bad semantics then you won't notice any difference between other Lisps and Hy.\nDepending on 0 and empty containers being considered True is like depending on the order of evaluation of arguments.  Common Lisp happens to define the order of evaluation as left to right, but many other programming languages do not, because not doing so provides more optimization opportunities.  Just because some Lisp did it, does that mean we have to too?  If so, what do we do when two or more Lisps disagree?  For example, Scheme does not define order of evaluation of arguments.\nOne of the ways Scheme supposedly improved on older Lisps was by not confounding nil, false, and empty.  Indeed, eq?, eqv? and equal? return #f (false) when comparing these.  I was unpleasantly surprised to find out that your if examples do work in Scheme.  It had never occurred to me to write code that way, much less depend on it.\nI will try to add some light to this discussion now...\nnoprompt demanded examples of where depending on bad Lisp semantics, instead of bad Python semantics, could cause bugs.  Here are some examples.\nImagine I'm writing a predicate in Hy that is intended to be used to filter a container of containers.  It should return True when a entry is \"interesting\", and False otherwise.  It should be as robust as possible.\nA concrete example is a predicate to filter key combinations within a certain range of frequency of use, to be used in a keyboard layout optimizer.  The key combinations are stored as frozensets within a frozenset.  I've actually written this, so it's not a contrived example.\nThe way a programmer calling this predicate from Python would expect it to be written is:\ndef is_valid_frequency(key_set):\n        if key_set:\n            key_set_frequency = frequency(key_set)\n            if key_set_frequency >= MIN_FREQ and key_set_frequency <= MAX_FREQ:\n                return True\n            else:\n                return False\n        else:\n            return False\nPython's official style guide http://www.python.org/dev/peps/pep-0008/#programming-recommendations says \"For sequences, (strings, lists, tuples), use the fact that empty sequences are false.\"  Although no reason is given, I believe it's because this results in shorter code.\nA direct translation to Hy with its current semantics is:\n(defun valid-frequency? [key-set]\n      (if key-set \n          (let [[key-set-frequency (frequency key-set)]]\n            (if (and (>= key-set-frequency +min-freq+)\n                     (<= key-set-frequency +max-freq+))\n                True\n                False))\n          False))\nA translation to Hy with the proposed semantics is:\n(defun valid-frequency? [key-set]\n      (if (and (!= key-set None)\n               (!= (len key-set) 0))\n          (let [[key-set-frequency (frequency key-set)]]\n            (if (and (>= key-set-frequency +min-freq+)\n                     (<= key-set-frequency +max-freq+))\n                True\n                False))\n          False))\nA programmer who has grown accustomed to thinking of Hy as just another Lisp is more likely to write:\n(defun valid-frequency? [key-set]\n      (let [[key-set-frequency (frequency key-set)]]\n        (if (and (>= key-set-frequency +min-freq+)\n                 (<= key-set-frequency +max-freq+))\n            True\n            False)))\nIt's shorter, easier to understand, and more idiomatic Lisp.  However, this code will not tolerate missing or empty entries like Python programmers have grown to expect.  They could be in for a nasty surprise when calling it from Python.\nAt this point I should admit to having simplified the previous code.  In reality, for a keyboard layout optimizer, you would not use constants for the frequency range.  This was done in the interest of shortening the argument, which I still feel is overlong, but it seems some people were having trouble following it, so I decided to be very explicit, while trying to avoid extraneous complexity.\nI have also written a program that manipulates a binary format for skeletal animations used by a 3-D game.  I won't be posting any code, because it's long, and the relevant code is very simple to explain.  The binary format stores some True/False and On/Off values.  True and On are represented as 1, while False and Off are represented as 0, as in the vast majority of programming languages.  Using Lisp bad semantics, instead of common bad semantics, makes (de)serializing these values more complex and error prone, because extra code will need to be written to map between the two.\nAlthough I have not done it, Python can call procedures in C.  This is necessary at some level to be able to interact with the outside world, since all popular operating systems are written in C.  C considers true to be 1 (or at least that's what the TRUE constant is, but technically any non-zero integer will work) and false to be 0.  If Hy adopts bad Lisp semantics interfacing with C will become more error prone and complex, because extra code will need to be written everywhere booleans are passed.\nThose are the examples I can think of where adopting bad Lisp semantics instead of bad Python semantics could create bugs.  I'm sure there are more.  What they have in common is interoperability with the rest of the world, which isn't written in Lisp.\nAlthough Lisp fans may be bitter about it, it's important to recognize the reality that Lisp is not a popular programming language.  Every programming language popularity index that I'm aware of show it, in any form (Common Lisp, Scheme, Clojure...), as accounting for less than 1% of usage.\nThe significance of Lisp's unpopularity is that it is very important for code written in Lisp to be safe and easy to call from popular programming languages.  That means respecting the conventions of popular programming languages.  Lisp fans should try to write useful, safe, easy to use, code in Lisp, that can be called from other programming languages, so other programmers will at least tolerate its usage, and ideally decide to use it.  With popularity comes more libraries (e.g. of macros) and job opportunities.  That's why Clojure and Hy are hijacking popular environments.\nTake a \"Lisp's way or the highway\" attitude at your own peril.  Lisp programmers are not in a position to demand other programming languages adopt their ways.\nAnother issue is overhead.  If every if requires an extra function call to enforce Lisp's boolean type punning, it will be slower.  This may be enough to matter when it occurs in loops, especially deeply nested ones.  CPython is particularly slow, relative to most programming languages ( http://benchmarksgame.alioth.debian.org/u32q/benchmark.php?test=all&lang=all&lang2=python3&data=u32q ).\nPeople wanting to use hy2py to generate code that can easily be cleaned up to look like handwritten Python code (something Clojure cannot do) will also have more work to do, reducing its utility.  I may be in the minority in that I care about this though.\nYet another issue is the \"slippery slope\".  If Hy reduces its usability and performance, just so the small number of existing Lisp programmers can do something they really shouldn't be doing anyway, where does this end?\nThings that actually matter (unlike supporting something you shouldn't do) that others might then expect Hy to adopt:\n- full compatibility with Common Lisp defmacro, Scheme syntax-rule and syntax-case, Racket syntax-parse, and/or Clojure defmacro\n- full compatibility with Common Lisp, Scheme, and/or Racket reader macros\n- Scheme's full numeric tower\n- Scheme's tail-call elimination\n- continuations in delimited (e.g. Racket's) and/or non-delimited (e.g. Scheme's) form\n- Lisp Machine Lisp's \"world\" image dumping and restoration\n- Lisp Machine Lisp's versioning of all files\nTo think I was happy just having a \"s-expressions to Python transpiler\" (with macros)...\n. PEP8 (the official Python style guide) says here that mutable global variables \"conventions are about the same as those for functions\".  The section on function names says \"names should be lowercase, with words separated by underscores as necessary to improve readability\".  The Google Python Style Guide agrees that this is how mutable global variables should appear.\nTherefore *foo* in Hy should become foo in Python.  Another example is *razzle-dazzle* in Hy becoming razzle_dazzle in Python.\nThis isn't a problem.  It's pretty clear any variable created outside a procedure is global.  The case of the identifier indicates whether you can depend on it not changing.  Short of telling you the type (and Python is dynamically type checked), I can't think of anything else you'd want to know.\nI would not prevent all mutable global variables from being importable.  There are rare cases where this might be useful, much the way dynamically scoped variables are used in Lisp.  It would be nice to have a way to exclude things (not just mutable global variables) from being imported via * (a usually-discouraged practice anyway), like identifiers with leading underscores in Python, but I don't believe there are any Lisps with an agreed-upon convention.  Simply starting the name with a hyphen happens to work in Hy due to how the translation is handled, but that looks weird to Lisp programmers.\n. @Paultag If you think the use of mutable global variables needs to be more glaring, I suppose you could prefix them with \"global_\".  Then *foo* in Hy would become global_foo in Python.  That would still obey the style guides, and bears some resemblance to how predicate? in Hy becomes is_predicate in Python.  I guess this would buy you some readability over not prefixing it, in that you could see that something is global at the point where it is used, not just where it is declared (which I think is obvious enough without the prefix, due to being oustide any other construct).\nIf you go this route, I'm not sure whether global constants (like +foo+) should become prefixed or not.  Consistency suggest they should.  The tendency of people to hate long identifiers suggests they should not.  I would lean toward not prefixing them, at least if you're trying to clone the flavor of Clojure, since Clojure's style guides suggest not doing anything special to constants, since they are the norm.  Doing it this way would also seem consistent from the Python side, since using the global annotation is only necessary for mutation.\nUsing some Hungarian abomination (like g_some_variable) is probably a bad idea.  It's not clear what the \"g\" means to anybody outside the secret circle, and it still makes the identifier longer.\nI really strongly advise against violating the style guides.  People using lint-like tools, like pep8.py and PyFlakes and PyLint may be unhappy if you do.\nNote that even prefixing global variables will break Python interoperability, which is why I still think +foo+ -> FOO and *foo* -> foo is the right thing.\n. I don't see any mention of nil or null there, and neither Lisp nor Python normally uses null, so I doubt it's intentional.  Clojure does translate nil to NULL (None in Python), so it seems very likely that is what is intended.\n. @Foxboron I'm not sure what this should imply for the implementation, but it is, I think, important to present a good interface to the user.\nlet* usually is described as \"nested let\".  For a random example: http://docs.racket-lang.org/guide/let.html  Search for \"In other words, a let* form is equivalent to nested let forms, each with a single binding\".\nRacket also has for and for* and for* is the nested version.  http://docs.racket-lang.org/guide/for.html\nI don't think there's any universal meaning to *-suffixed symbols, but they do seem to often translate roughly into \"nested\", and they seem to never be used for the common case.  At least I can't think of any Lisp constructs where you almost always use the *-suffixed version instead of the non-suffixed version.\n. ",
    "olasd": "Yes, we really want to have car and cdr and cons.\n. Now that we have keywords, maybe we could do something like\nclojure\n(with [foo bar :as quux] (use foo quux))\nwhich would be equivalent to:\npython\nwith foo:\n    with bar as quux:\n        use(foo, quux)\n(py2.6 doesn't do multiple context managers in a single with statement)\n. So, I took a stab at a few parser libs lately.\n- Parsley: https://github.com/olasd/hy/tree/feature/parsley-parser\nThe grammar looks fairly clean (there are some clunky things, but overall it's not that bad), but it's DOG slow. Like, 8 times as slow. Plus it is not python3 compatible :(\n- rply: https://github.com/olasd/hy/tree/feature/rply-parser\nThis looks even cleaner than parsley, IMHO. All the tests but a few pass.\nThe only real pending issue is that of getting the source position for tokens (column/line number), as rply does not give it... yet! There is a todo about that in the rply source, I'm looking at patching that in right now.\nOh, and, almost forgot, it stays quite fast (20% slowdown taking into account the need for exception handling and displaying for the failing tests, so should go down).\n. ``` clojure\n(import ast hy.compiler)\n(defn disassemble [tree]\n (defn fix [tree]\n  (if (isinstance tree list)\n   (for [x tree]\n    (fix x)))\n  (setv tree.start_line 1)\n  (setv tree.start_column 1)\n  (setv tree.end_line 1)\n  (setv tree.end_column 1))\n (fix tree)\n (ast.dump (hy.compiler.hy_compile tree)))\n(print (disassemble (quote (print ((fn [] (if x y z)))))))\n```\nYields\npython\nModule(body=[FunctionDef(name='_hy_anon_fn_1', args=arguments(args=[], vararg=None, kwarg=None, defaults=[]), body=[Return(value=IfExp(test=Name(id='x', ctx=Load()), body=Name(id='y', ctx=Load()), orelse=Name(id='z', ctx=Load())))], decorator_list=[]), Print(dest=None, values=[Call(func=Name(id='_hy_anon_fn_1', ctx=Load()), args=[], keywords=[], starargs=None, kwargs=None)], nl=True)])\nOn my refactor/compiler branch. That works on master too, but that particular construct yields a buggy ast AFAICT.\nSo that could be added to the (not yet existing) stdlib?\n. The patch looks OK from a technical standpoint. However, I have doubts on a language standpoint:\nIIUC, it makes something like\n```\n!/usr/bin/env hy\n42 {\"foo\" \"bar\"}\n```\na valid Hy script, even though it does not make much sense. Maybe we should make sure the compiler doesn't generate a bogus python AST from this in the native tests?\nI see the point of this in the REPL, but something that doesn't start with a paren can be wrapped into a ((fn [] )) on the fly, yielding the same effect.\nMy parser patches actually make it stricter (only allowing parenthesized expressions at the toplevel), but if we agree this is the way to go, it should be a breeze to make them work like this.\n. Fair enough. +1 then.\n. Could you squash 21703d8 and b19dc10 to avoid breakage during bisects? Otherwise it looks good to me.\n. Actually, the commit-close was a typo (it should have closed #104).\nAs for the original bug, yes, the comma and quote syntaxes are available in master (actually, it's tilde and quote to avoid overloading the comma which is already used for tuples). Those symbols are hardcoded in the grammar.\nThe problem for generic reader macros is that there is a grammar, and therefore the user can't plug himself into the token stream and do whatever he likes. Therefore generic reader macros are out of the question as long as we use rply (which is a neat thing, but I'm not married to it, I just want a parser that doesn't suck donkeys).\nTo (slightly) mitigate the reader macro issue, we could extend the grammar to allow syntax extensions using the current tokens. For instance, you could be able to dispatch #f(foo bar baz) to a runtime-defined macro reader-macro-f which would get passed HyExpression([HySymbol('foo'), HySymbol('bar'), HySymbol('baz')]).\nNobody ever told me what real life problem they wanted to solve with reader macros, so I'm not quite sure what to do about them...\n. OK. That definitely sounds doable with the dispatch thing.\nWe should definitely cut 0.10.0 before cramming new features in though hint hint\n. I don't understand what doesn't work yet, care to elaborate?\n. Fixed in 387bc0d9\n. If we want to break stuff, why not go the lisp way and return fractions?\n. Couldn't we special-case the use of (+), (-), ... with no arguments as operator.add, ...?\n. @khinsen:\nThe approach you're taking in 5672df7 is promising, but I think it can be done in a more generic, and DRY, way:\nI think that it should be fairly easy to \"auto-lambda\" stuff that's a builtin when we compile bare HySymbols.\nThe only real issue I can think of is deciding the number of arguments for the auto-lambda-ed function. A solution could be to add an an explicit argument (auto_lambda_nargs) for the @builds decorator, or to add another decorator.\nIf the number of arguments is known, then it's just a matter of replacing the HySymbol with (lambda [arg1 ... argN] (HySymbol arg1 ... argN))\nWhat do you think?\n. We can just generate\npython\nHyExpression([\n   HySymbol(\"fn\"/\"lambda\"),\n   HyList([HySymbol(\"arg1\"), ...]),\n   HyExpression([HySymbol('foobar'), HySymbol(\"arg1\"), ...])\n]).replace(foobar)\nand pass that down to compile?\n(choice of \"fn\"/\"lambda\" depends on whether 'foobar' can compile down to just an expression or not)\n. (I'm actually starting to think that lambda and fn could be synonyms, and that the compiler should dispatch between those by itself)\n. In a second step, if we want to avoid overhead, we can give those functions predictable names, dedupe them and hoist them up to the top of the AST.\n. We can't star-apply a builtin, so I don't think that's really going to work... I think we need to be explicit about the number of arguments for auto-lambdaed builtins\n. I'll try to come up with some non-theory later today.\n. @vladimir-g: That's what I'd have gone with. However, I think it'd be better to do the compilation in a tempfile instead of hardcoding the path.\nMind doing that and filing a new pull request? If the test passes on all python versions I'll merge. Thanks!\n. Fixed in 3d8a3d5. It does some funky things in the hy REPL though, as 9d8accb added useless \"bare names\" between statements, and the REPL unhelpfully prints those. I'll open a separate issue for that.\n. @khinsen: that pretty much amounts to folding the logic for do_setv (i.e. the compilation of the \"inner expression\") inside setv. That sidesteps the problem of the \"internal\" keyword nicely. I'll see if I can do that later today.\n. Well it's not going anymore. Wouldn't it be superseded by the compiler refactoring anyway?\n. I addressed this in my rply branch.\nBasically I use a regexp to tokenize whole strings, then at parsing time I eval() the contents of the token, getting the python parsing for free (which is ugly, but avoids a buggy reimplementation).\n. Clearly, we can make the solution for #108 work for this, too.\n. Fixed in 3d8a3d5:\n[nicolasd:~/code/hy/hy] [hy] master* \u00b1 hy\nhy 0.9.6\n=> (if true (let [[x 0]] (print x)) (print 42))\n0\n. Nope. I think something along the lines of\nclojure\n(assert (= 0 (if true (let [[x 0]] x) 42)))\nwould be a good candidate for that?\n. In common lisp, it's equivalent to (let [[x nil]]).\n. @paultag: could you write some code that failed before, to make sure that it doesn't anymore or that it still does?\n. Done and merged through #160 \n. -m might be neat too. I think this amounts to all the relevant python cli options.\n. Merged in #157.\n. This branch has clean-ish auto-imports, which can help pushing #108, #130, #150, #159 along.\n. That's also annoying on the REPL, as those get printed if they are non-nil.\nThe issue is around 9d8accb. I'm thinking we should optimize Names if they are tacked on statements, which would leave the (try xxx (except [NameError] yyy)) testcase untouched.\n. Sorry about that! There's XXXs where it counts, it shouldn't be too hard to do.\n. Well, I think the underlying issue for the map problem is the same as not being able to do (reduce + [1 2 3 4]), that is #108 or #130.\nI guess we could iron something when we get keyword callability back?\n. I claim that for tonight.\n. That looks straightforward enough. :+1: from me.\nIt'd be nice to expand a bit on the tests (i.e. check that multiple handlers return correctly, and that we can return from the body too)\n. I'd be glad to get a lisper (poke @jd, @algernon, @agentultra) to review the syntax.\n. That's done AFAICT.\n. Maybe it'd be a good idea to add a \"thou shalt not raise me\" warning in HyCompileError's docstring? Anyway, :+1: from me.\n. Merged, thanks!\n. Apart from the list(filter()) thing which is a bit unpythonic, that PR looks good to me.\n. :+1:\n. That's expected behavior, and I'm not sure that we can fix it.\nThe caveat is that macro expansion is done in the hy -> python AST conversion process, while the let-binding is done at runtime. The compiler does not know that \"rev\" has been bound to math.sqrt inside the let, and does the macro-expansion as if nothing happened.\nI agree that the lisp behavior can be useful. This needs some thought.\n. So.\nWe (@paultag, @agentultra and @jd) hashed it out on IRC a bit, and we found a way we could make this work.\nBasically, the idea is to keep track of the \"assigned-to\" names in the compiler. That should not be a big deal, as we pass most of those in the \"_storeize\" function anyway. That way, we can know at compile-time what names are being assigned to, and avoid macro-expanding those.\nIt's not a silver bullet, as it won't save you if you do funky stuff like injecting variables in --globals-- or whatnot. But it should work in most of the cases.\n. I think we should probably get rid of the recursion in hy.macros.process and let the compiler handle it (which it is supposed to do already).\n. Would something along the lines of\n``` python\nfrom hy.models import HyObject\nfrom hy.models.list import HyList\nclass HyCons(HyObject):\n    \"\"\"\n    HyCons: a cons object.\nBuilding a HyCons of something and a HyList builds a HyList\n\"\"\"\n\n__slots__ = [\"car\", \"cdr\"]\n\ndef __new__(cls, car=None, cdr=None):\n    if isinstance(cdr, HyList):\n        return cdr.__class__([car] + cdr)\n\n    else:\n        return super(HyCons, cls).__new__(cls)\n\ndef __init__(self, car=None, cdr=None):\n    self.car = car\n    self.cdr = cdr\n\ndef __repr__(self):\n    return \"(%s . %s)\" % (repr(self.car), repr(self.cdr))\n\n```\nwork?\n. I'm not sure it will work, as HyObject's constructor doesn't take those arguments...\n. I think it is fair to keep require and import separate, as they really affect two different parts of the hy module \"lifetime\" (compilation to AST and runtime). I'll take a detailed look at the diff later today, but at a glance there doesn't seem to be anything shocking.\n. So, after reading the code, I think the approach is reasonable.\nIt might be a good idea to split the test_ast.py refactoring in another commit to make the macro refactoring a bit more self-contained. I have commented on other nits inline.\nThanks for your work, we should be able to merge that soon!\n. Good to merge for me. Let's wait for another pair of eyes on this, though.\n. I'm +1 on keeping the dichotomy between compile and eval. Having compile-time evaluation by default could be very confusing, and eval-when-compile looks quite straightforward.\n. Looks good to me from an internals POV. The hy_eval dance could be factored out in a common function.\nFrom a semantics POV, the eval-when-compiled thing is evaluated at runtime too. Is that intended? (I feel it contradicts the meaning of the eval-when-compile special form in elisp, for instance). Either way, it should be tested.\n. http://www.gnu.org/software/emacs/manual/html_node/elisp/Eval-During-Compile.html suggests the opposite. The semantics you are talking about seem to be from eval-and-compile? I think we need some @jd knowledge here :)\n. This looks like a good idea in theory, but in practice you should update the tests to account for the move.\n. I like the idea of having all of python's escapes.\nHowever, I think you need to special-case python2 to make the string you generate a unicode string (so adding a u prefix in your eval), else I'm not sure the concatenation will go right if you have some non-ascii stuff in your string.\n. Nevermind that, in the lexer for strings, self.nodes already contains a mixture of unicodes and strs and everything works fine.\n\n. Looks good to me.\n(This review brought to you by )\n. Hy gets confused because fn is a special form.\n``` clojure\n(defn memoized [decfn]\n  (setv decfn.cache_dict {})\n(defn memoized_fn [n] ;; TODO: replace it with *args\n    (if (.has_key decfn.cache_dict n)\n      (.get decfn.cache_dict n)\n      (do\n       (.setdefault decfn.cache_dict n (decfn n)))))\n  memoized_fn)\n```\nought to work.\nI'm not sure why the error reporting sucks that much, though, so I'll keep the ticket open.\n. This branch is a mess. 12 commits and 2 merges from master, several breaking tests, ugh.\nCould you please clean it up before merging?\n. (the diff from master looks fine, though)\n. Shouldn't the stdlib loading be done in __init__ rather than in compile (which means it gets done a lot), or am I missing something? Except for that, it looks fine. The way symbols get auto-imported looks good imho.\nI think importlib is missing from setup.py?\n. :+1:\n. @rahmu regarding gerrit, we considered it (under the impulse of @jd), but one of the other core committers opposed it as making contributions way harder than they need to be.\nSo it didn't really go anywhere. I'm still keen on trying it out though.\nRegarding \"being more cautious before merging\", lately we have waited for 2 commiters to give the go-ahead before merging, which works pretty well, until @paultag gets on a caffeinated merging-frenzy instead of keeping his calm :D\n. And, what do you expect to get ?\nI suppose that you yield the car, then iterate the cdr, is that correct?\n(So (list (cons (cons 1 2) (cons 2 3))) will yield (cons 1 2), 2, and then what?)\n. A few things:\nhy's (list) has python semantics, which means that it only takes one (iterable) argument and consumes it into a list. That's not the same as the lispy semantics where (list 1 2 3 4) yields the same thing as '(1 2 3 4) AIUI. Whether that's a bug or not is another discussion.\nI took my little clisp and did:\n[8]> (loop for item in (cons (cons 1 2) (cons 3 4)) do (print item))\n(1 . 2) \n3 \n*** - ENDP: A proper list must not end with 4\nWhich sounds like the right thing to do: you don't iterate on a linked list that doesn't end with nil, and if you do, you get spanked.\nSo, really, what does (for [x (cons (cons 1 2) (cons 3 4))] (yield x)) do?\nWDYT?\n. I think I'll implement __iter__ as itertools.chain([self.car], iter(self.cdr)).\nMy current implementation is a bit unsatisfactory, as it does its mangling before compilation which is somewhat unsettling. I'll amend that before I send it for review, but I'd rather have the rply stuff merged first so we can have an unsucky syntax from the get go.\n. That's been merged. I apparently need more caffeine.\n. It feels a bit overkill to split stuff out in another file, although I can see the point, to keep all the readline-related cruft together. If anything, it should have a more explicit name (readline_helpers, cli_support, cli_helpers, I don't know...).\nAnyway, here's my review:\n- Changes to .gitignore shouldn't be mixed in with that stuff.\n- The new file lacks the license/copyright headers\n- The split makes the bin/hy tests fail (at least an import os seems to be missing)\n- You should add yourself to the AUTHORS file\nThanks for working on this!\n. Fixed in e4ae988.\n. Yes please.\n. Closing (wontfix).\n\n. I'd rather have us allow pythonic syntax (see #198) than hack around printing python builtin objects, as this sounds quite painful.\n. Thanks for this documentation work, it's really appreciated!\nThere are a few things that could be fixed, though:\n- and and or shortcut, which means:\n  - all the arguments don't necessarily get evaluated\n  - the first false-y (and) or true-y (or) value is returned\n  - see for instance (and 1 32 42) => 42, (or 0 False [\"foo\"] True) => [\"foo\"].\n- (do) can now be used in lambdas, because they get translated to fns on the fly if needed.\n- the assert example is wrong\n- print can only print to the screen, and I don't think we want to change that (well, in Python3 you can always kwapply some more arguments to it, but it's an implementation detail).\n. So, the rply-based lexer has a STRING token, that matches a whole string, quotes and everything included.\nThe parser just evals the token we received, tacking on a u before if we're in python2. It's fugly, but avoids buggily reimplementing string parsing.\nSo adding support for raw strings to it is trivial (just a matter of adding r in the prefixes).\nRegarding this PR, I'll admit not wanting to dig up in this parser more. The skip_one mechanism feels a bit weird, but looks fairly sound.\n. Hmm, I thought there was an issue separate from this PR. Don't mind me.\n. Squashed and merged, thanks.\n. Thanks for this. However, I think @rwtolbert is working on a more generic (and, IMO cleaner) approach to writing the scripts, so I'd like to hear him chime in.\n. That would be a no from my side.\nThe point of kwapply is to add **kwargs to an existing call.\nFor instance:\nclojure\n(import subprocess)\n(kwapply (subprocess.Popen [\"/bin/ping\" \"127.0.0.1\"]) {\"shell\" False})\nwhich translates to\npython\nimport subprocess\nsubprocess.Popen([\"/bin/ping\" \"127.0.0.1\"], shell=False)\nwith your changes, we lose the ability to do that.\n. It seems to me that setup.py is missing a dependency on argparse?\n. Also, setf doesn't exist anymore so the tests fail.\n. Yeah, that Clojure shorthand should probably be a separate ticket.\n. 51358e0 should fix the \"bootstrapping\" issue. I'm not a big fan of the method, and I'm not sure it's worth it (the other solution would be to hardcode the version number in setup.py, which i'm not a fan of either...)\n. First off, I'll note that I'm firmly of the opinion that the current behavior (I implemented) is a stop-gap before a proper solution can be implemented. Leaking statements that wouldn't be executed if they were \"expressions\" is confusing behavior.\nWriting and as a macro would not solve the general problem (and I think the perf hit wouldn't be worth it)\nTransforming statements into a function means creating a closure, which means losing the possibility of effecting on the global namespace. Which I think would be confusing too.\nOne solution for this problem, would be to resort to a hack hooking storeize to collect variable names and using global to enable access to the toplevel names in the closure (making it leak). But that sounds gross.\nI'm open to less-gross ideas if you have any.\n. If anything, the fix should be in storeize, disallowing bare strings. You just don't setf to a string. If you setf to a symbol, everything will be fine.\n. LGTM, go @paultag go!\n. You can take a look at https://github.com/olasd/hy/blob/feature/rply-parser/hy/lex/lexer.py and https://github.com/olasd/hy/blob/feature/rply-parser/hy/lex/parser.py\nThe shorthand forms for quoting and unquoting aren't live yet, neither are unicode escapes in strings, but we'll get them as soon as the branch is merged.\nThere's also https://github.com/olasd/hy/blob/feature/parsley-parser/hy/lex/hy.parsley, which I think is fairly up to date.\n. (range 3) is [0 1 2], not [1 2 3].\n. ACK on the code. The tests could probably check that the correct stuff gets yielded, though.\n. First three tests don't have an assert.\n. We'll wait for a long time...\n. That's done AFAICT (in hy.core.macros).\n. setv doesn't return None, it returns what's been assigned to. The compiler just drops autogenerated \"bare\" names.\nSee:\nclojure\n=> (print (setv f 42))\n42\nI agree this is surprising behavior: all the \"static\" structures should probably be dropped.\n. Yep. that's supported. Just use single double-quotes.\nOTOH, our REPL doesn't like it, as it assumes that it can tokenize lines one by one.\n. Multiline strings are now supported (break in the REPL though, that's #305). Closing\n. (with single-dubquotes, so\n(= \"foo\nbar\" \"foo\\nbar\")\n)\n. That PR seems like a very good idea, and I'd be keen on seeing that merged soon.\nA few comments:\n- I tried hydoc subprocess, and the \"Methods inherited from [...]\" don't seem to get mangled like the others (missing a dot).\n- *args should be mangled to &rest args (noted on hy.contrib.meth)\n- This lacks tests (I'd suggest trying hydoc on a hy module, e.g. hy.core.language, and on a python module, e.g. hy.compiler, in addition to the options advertised in hydoc -h).\nIf you fix that up, we should be able to merge.\n. @tuturto, welcome to @hylang/core!\n. /me looks at a spider web\nI'm +1 on fixing this py2/3 inconsistency, as we're doing elsewhere (long, integer division and whatnot). Go go go!\n. So is this fixed?\n. I think the \"macro changes\" would be better off with a bit more than the two words you gave them. Splitting out macros that can be used by the core stuff and the others looks like a good move though.\nThe yield from is somewhat... Well, the behavior is \"a bit\" less complicated than what python3.3 gives. With a disclaimer, it looks fair.\nSo :+1: from me with the editorial changes :P\n. wait, what.\n```\nIn [1]: from hy.lex import tokenize\nIn [2]: tokenize(r'''\"\"(os.path.abspath \".\")\"\"\"\"''')\nOut[2]: [u'', (u'os.path.abspath' u'.'), u'', u'']\n```\nHow is that an issue?\n. (fyi that already works on master)\n. Well yeah, that's because your function is actually defined at runtime, that is, not in the context where the macro is defined.\nTried wrapping the defn in an eval-when-compile?\n. (after a quick test, that doesn't work either... ??)\n. What's up with this, do tests still fail?\n. Thanks for the confirmation.\n. That's fixed. (#284)\n. I think we should be able to lessen the py2/py3 differences with some (str?) / (int?) macros.\n. I don't like the HyInteger/HyLong dichotomy introduced by the second commit, and I think the first commit on its own would be fine.\nOne issue that was raised about that is that some external libraries could expect to be passed ints and not longs. IMO they are broken, and in any case you can always (int) away.\n. LGTM, go @paultag go\n. I really feel that this code is unwieldy, and I don't really see the point.\nIf you really want sugar for nested loops/withs, just do:\nclj\n(defmacro for_rec [args &rest body]\n   (if args\n     `(foreach ~(.pop args 0) (for_rec ~args ~@(list body)))\n     `(do ~@(list body))))\n(you're forced to do (list body) because of a bug in the handling of unquote-splicing, which I'll report shortly)\n. I don't know about ^ which is a pain to type (I use deadkeys here), but overall this looks pretty solid. See the comments inline.\n. I don't hate %. I think we need a BDFL (poke @paultag) decision on this, though.\nRegarding the diff: you should not raise HyCompileErrors, but HyTypeErrors: they give that user-friendly message telling you where things went wrong, instead of the ugly traceback.\nRegarding this, you should add some more tests, in tests/lex/test_lex.py (about the behavior of %-keywords) and tests/compilers/test_ast.py (about where/how % keywords are getting compiled, checking for relevant error reporting)\nAlso, the print hunk is not relevant anymore.\n. __future__ imports only affect the module in which they are called. It's basically a hook in the interpreter to enable new features.\nYou can mix both without any issue.\n. \"All is well \u2014 The Travis CI build passed\" should be enough.\n. So, I revisited that PR while cleaning up hy.macros to be able to write macroexpand/-1. Basically, I remembered wtf we were doing when CORE_MACROS and EXTRA_MACROS were introduced. I added some docstrings accordingly.\nI think the current branch is truer to that original intent, but it changed things enough that it should be re-acked (hello @hylang/core).\n. Please only put # NOQA on the lines that trigger flake8 warnings. We want to keep the other checks (you can take a look at hy/__init__.py for inspiration).\nApart from that, the PR looks good.\n. Yeah, the redirect works fine here.\nI think something more useful would be to do a http://hy.rtfd.org/quickstart redirect (I created it just now), if the RTFD.org behavior stays consistent.\n. I think we should keep passes in the empty subclasses. They feel like they're missing something. In a straw poll on #python, 100% of the one respondent (cough) agreed with me.\nThe other ones, I'm (obviously) okay with.\n. The syntax is \"foo\nbar\", not the other thing.\n. Fixing the merge conflict, I'm :+1: on this.\n. Done with #310. Outstanding work!\n. :+1: LGTM\n. :+1:\n. Be especially careful when @paultag urges you to merge something :>\n. I still feel the base cases should be swapped (i.e. the built-in should have the shorter name, and the nested thing the long name) but I'm not going to make a big fuss about it.\n. Because astor is broken in py3 IIRC.\n. @berkerpeksag please make the dep python2-only and you'll be good for a merge. Thanks!\n. The route docstring looks wrong. Apart from that, I'd say this is the way to go.\nWe need to check that stuff is still working. I'm not sure there's much that uses hy.contrib.meth, maybe @paultag's snitch?\n. Thanks for your PR! However, #339 came just before and is way simpler so I merged that one instead.\nCheers!\n. That looks pretty good.\nI think you can even quote the whole list, which would make for an even cleaner syntax.\n. :+1:\n. HyCompileError?\n. (or two is_'s)\n. So, after mulling this over a bit, I decided to punt the double-? issue. The current behavior is a net win for interop. We can just decide that \"??\" will not be interoperable and be done with it.\n. :+1:\n. Nice one.\nHowever:\n=> (get ((fn [] {\"first\" {\"second\" {\"third\" \"level\"}}})) \"first\" \"second\" \"third\")\nTraceback (most recent call last):\n  File \"<console>\", line 1, in <module>\nNameError: name '_hy_anon_fn_1' is not defined\nWhat you should do, is use compile_collect to compile all the arguments collecting the \"hoisted\" stuff, construct the nested ast.Subscripts with the compiled expressions, and return the hoisted stuff + the ast.Subscripts\n. My first reaction to this issue was \"what the fuck is wrong with 0 being falsey, and why is everyone so obnoxious about it?\". Statements like \"you should see a therapist\" or \"you're doing X a disservice\" are not helping you to get your point across. Please calm down.\nOther lisps do it that way so it must make sense. I tried, but I can't find why. I would just like to know what are the expected false values and why some \"python-false\" values should be taken as true.\nImplementation-wise, this is trivial: in hy/compiler.py, scroll down to @builds('if'), and change \npython\ncond = self.compile(expression.pop(0))\nto\npython\ncond = expression.pop(0)\ncond = HyExpression([HySymbol('is_truthy'), cond]).replace(cond)\ncond = self.compile(cond)\nOpen hy/core/language.hy, implement the relevant (defn truthy? [value]). Done. No need to be obnoxious about it. Just show us why we should do this.\n. Hold your horses there.\nRegarding gensym:\n- We should be able to use gensym by hand.\n- gensym should probably be implemented in language.hy.\n- gensym should return a HySymbol\n- gensym should return something that can't (easily) be generated by valid hy. CL generates an uninterned symbol, in hy I'd suggest adding a : in front of the symbol (making it ungenerable by Python or hy).\nRegarding the auto-gensym feature for defmacro.\n- I'm not sure that we want to add the gensym \"penalty\" by default in defmacro. It should be pretty easy to make this a macro that makes a macro. Suggested reading: http://letoverlambda.com/index.cl/guest/chap3.html#sec_5\n- If we go for this, I'd be more inclined to use a prefix instead of a suffix.\n- A regex to check for a trailing character is way, way overkill\n. f5d88bb looks good ! :+1:\n. Outstanding stuff!\n. So 0.9.12 was released.\n. Hmm. The behavior is just the same as with the corresponding python code.\nclj\n=> (import numpy)\n=> (setv a (numpy.array [[1 2] [3 4]]))\n=> (slice a 0)\narray([[1, 2],\n       [3, 4]])\n``` python\nIn [1]: import numpy\nIn [2]: a = numpy.array([[1L, 2L], [3L, 4L]])\nIn [3]: a[0:]\nOut[3]: \narray([[1, 2],\n       [3, 4]])\n```\nWhat's the issue?!\n. So the real issue there is that Hy cannot be used to create a slice object (simply).\nYou could use (get a (, ((get --builtins-- \"slice\") None) 0)) but that's pretty ugly.\n. This for error means that it doesn't do enough error checking. This should be fixed at the source, not by putting a ton of paint on the bug.\n. Please make the traceback switch \"--show-tracebacks\". mixed-dashes-and-underscores are annoying !\n. Thanks!\n. poke @hylang/core\n. apply on method calls is just something that didn't work, and didn't even happen before, so the bug wasn't obvious.\nIt's been uncovered by the meth tests, which did use kwapply on a method call.\n. Has ack. @hylang/core, time to merge this before @paultag has no hair left.\n. We're probably doing 0.9.13\n. So. The main issue I have with this is that it would break (setv (first foo) bar).\nIn the end, we should probably make our setv implementation less trivial, to replicate more of the CL setf behavior.\nFor reference: \n- http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/mac_setfcm_psetf.html\n- http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/sec_5-1-2-2.html\n. (I'm mildly :+1: on this, with the provision that we fix setv before releasing)\n. Solid changes. :+1:\n. what about (foo.bar?)?\n. (and (foo?.bar) too)\n. So, a few quick comments:\n- \"mungle\" is not a verb. I think we want either \"munge\" or \"mangle\".\n- I'd be keen on having the mangle function be a constructor for HySymbol. That way, you can keep the \"unmangled\" name around too.\nThis constructor would need to be easily accessible from Hy, for macro-building purposes.\n. Pushing the idea further, the \"split\" method on HySymbol should probably return a list of HySymbols, which would allow to keep the unmangled name around on functions defined in hy. Think introspection/hydoc.\n. Fairy nuff. I'll do that later.\n. Doc fixes! omnomnom\n. The docs conflict with the defmacro-alias doc fix.\nThe tests should probably check that the function objects are the same ((is alias1 alias2)), but apart from that, good move.\n. Thanks!\n. I think this should have the same signature as (if): you should be able to only pass one argument, and have the other one default to 'nil.\nThen, (unless) could probably be redefined in terms of (if-not).\n. And merged!\n. Before putting this into core, the logic should probably be reversed, that is:\nclj\n(defn recursive-replace [old-term new-term body]\n  \"Recurses through `body` looking for `old-term` and replacing it with `new-term`.\"\n  (cond\n    [(= body old-term) new-term]\n    [(instance? hy.HyList body)\n     ((type body)\n      (list-comp (recursive-replace old-term new-term term) [term body]))]\n    [True body]))\n. Well, we seem to be far off what the CLHS provides, and I don't really see the point of it \"standalone\". So I'm :-1: until this is fixed to conform to the CLHS better.\n. aaaand merged.\n. pretty please, can we finally free ourselves of the atrocity that is kwapply?\nI think the examples could have been reworked more systematically, for instance (apply .format [\"http://foo/{tumblr}\"] {\"tumblr\" \"something\"}) should still work.\nHas ACK anyway.\n. Good move!\n- Could you add a few functional tests, which would make sure that that stuff works everywhere, and which would avoid us breaking the feature in the future? You should put those in a new tests/models/test_dict.py file.\n- Could you add yourself to the AUTHORS file?\nThanks a bunch!\n. Outstanding work, thanks!\nFor future PRs, please don't hesitate to squash commits and keep your history clean :-)\n. nom :+1:\n. cough squash cough\n. I wonder what the point of that function is. However, implementation looks good, has tests, so sure, go ahead. :+1:\n. (integer-char? \"0\") will eval to False in boolean contexts?\n. @khinsen very thoughtful comment, which mirrors my point of view on this.\nFurthermore, as @copyninja said, our core and contrib language libraries are a mish-mash of functions and macros influenced by every lisp ever.\nI don't see a real direction we're heading in, and I'm pretty sure that:\n- experienced lispers are weirded out by the mess\n- inexperienced hypsters need some consistency, which we currently don't really provide.\nThe \"flavor\" system is an idea I talked about on IRC to try to contain the mess, I don't know how it'll play out but maybe we can try it?\n. clj\n=> (defreader b [x] `(.encode ~x \"utf-8\"))\n=> (type #b\"barf\")\n<type 'str'>\nAlso, yuck.\n. With your macro a, what should (a b c d) return?\n. hmhm.\nI see you want to fix this inception.\nTo do so, in hy/macros.py, you need to add a tuple entry to the _wrappers dict. This entry should wrap the values in a HyExpression.\n. Why not just rename the slice special form to cut? I'm not a big fan of having to call the slice built-in function every time I want to take a slice from a list (which is basically what your macro does).\n. So, @paultag asked me to review this again, here goes:\nHaving cut as a function is bad. You're turning the previously generated Python code, which was pretty much (slice a b c d) => a[b:c:d], into (cut a b c d) => from hy.core.language import cut; cut(a, b, c, d), which then goes on to call on a[slice(*(b, c, d))]. This indirection will really be painful.\nI'm still firmly of the opinion that cut needs to be a compiler builtin. Furthermore, and although that feature wasn't tested before, your refactoring broke slice assignment ((setv (slice a b c) foo) used to work and doesn't anymore).\n. grmbl 3 commits mumble\nACKed anyway.\n. Hy doesn't control what leaks where at runtime, so we can't really do much here AFAICT.\nIf you don't want your loop variables to leak, use python3.\n. That's correct.\n/me ponders caffeine before comments.\n. That's #130.\n. I think there's some confusion here.\nMacros are expanded during the compilation phase, that is before python bytecode is emitted. This happens way before the system is even ready to process user input.\nOnce your code is running, of course unless you're using the eval built-in, there is no way that user input can be interpreted by the compiler.\nAnd, even if you're using eval, there is no automatic conversion between \"Python objects\" (that the runtime world understands) and \"Hy objects\" (that the hy compiler understands). There are only two sites in the hy code where this automatic conversion happens:\n- The return value of a macro function is turned into a Hy object\n- The car of a cons cell gets turned into a Hy object if the cdr is a list (which helps building lists with conses)\nYou would have to do an explicit conversion to get a keyword from user input. I really think that by then you deserve your pain.\n. On a related note, the automatic conversion doesn't even know how to emit a HyKeyword: https://github.com/hylang/hy/blob/aefea557cb23547bf68c6de69254bff5a7e7cd64/hy/macros.py#L109-136\n. Unhappy flake8 is unhappy.\nHonestly I could see the \"correct behavior\" go either way. But I suppose this is a sensible generalization of the \"n exception handlers\" case for n = 0, so :+1:.\n. This is the behavior that I intended when I wrote cons cells.\nThe rationale behind it is that the HyCons is an internal, \"quoted\" Hy object (i.e. something that comes from the hy compiler world and not from the python world). It therefore made sense (at least in my mind) that the arguments to the cons function get \"quoted\" (i.e. turned into HyObjects). The intent was, for instance, to allow building dicts by consing stuff together, such as in (list* 1 2 3 4 {}) (which would build something equivalent to '{1 2 3 4})\nI now notice that that behavior is broken too. When the cdr of the cons cell is an instance of a list, the HyObject cast doesn't happen which makes the behavior inconsistent.\nIf the whole wrapping behavior is deemed to be a bug, it can be fixed by dropping all the _wrap_values in hy/models/cons.py. If it's not, then the other bug should be fixed by wrapping the cdr before checking whether it is a list.\n. To further my point:\nIn common lisp, (1 2) is a two element list. (1 . 2) is a cons cell, or a two-element dotted list. Inputting both of those in the toplevel would evaluate them (i.e. try to call a function called 1 with the relevant argument). Calling (cons 1 2) would be equivalent to calling '(1 . 2), that is generating the quoted cons cell with car=1 and cdr=2. My intention was to replicate this behavior.\n. eww.\n. So the real issue here is that the compilation of a HyLambdaListKeyword (&rest) fails through an internal compiler error, instead of an explicit failure.\nLambda list keywords are only ever used in macros / special forms, so we should error out if the compiler encounters one.\n. So that does interesting things when you have multiple expressions on one line, or have a multiline expression.\nBut as a first stroke, I think it's worth getting in if we mention the caveats in the docs.\n. While I agree with the general sentiment that some behaviors around hy's \"turn all statements into expressions\" stance are weird, I'm a bit uneasy with the approach of wrapping everything into function calls.\nSee for instance let. The fact that it wraps stuff in a function call confuses people to no end, as we get all the weird scoping issues of Python. I have the feeling this will end up the same, sadly.\n. (also, I have no clue for a \"more proper\" way of fixing this :/)\n. \n. I for one think that single-letter uppercase symbols are really ugly, and i've never seen those used anywhere else. I think that removing the True and False variant provides exactly zero gain, and that true and false are okay.\nBasically I think this issue should be closed doing nothing.\n. Looks sensible :+1:\n. :+1:\n. I'm sorry but I'm :-1: on this. I feel it makes the code completely unreadable, it invents a convention and provides exactly no gain over true/false.\n. The hy.contrib.walk module already has a let macro, with (more) proper let semantics than what you're providing here (it does work around some of the python scoping mess).. Done. @Kodiologist and @kirbyfan64 are now owners of the @hylang org.. Hmm, I want dos to be transformed into lists of expressions before I flatten. I'm pretty sure this is the right order to do that.\n. @rahmu Really, they aren't. What you notice is a side-effect of how we convert statements to expressions.\nSee for instance:\nclojure\n=> (defn side-effects [x] (print \"I can has\" x) x)\n=> (and (side-effects false) (side-effects 42))\nI can has False\nFalse\nThe issue is that right now, the statements we \"hoist\" above expressions are executed unconditionally. I kinda-agree that the statements we hoist should really get deferred until we actually evaluate the resulting expression.\nWe could put those statements in a function call, but then they wouldn't be able to affect the global namespace, which isn't very obvious either. I'm open to ideas on how to fix that issue.\n. this should be sys.version_info >= (3, 3)\n. This should be sys.version_info >= (3, 4)\n. While you're right, I pretty much mirrored the language from the definition of get below.\n. three or four\n. This should be on the already existing hy._compat import line below.\n. s/portion/portions/\n. I guess that's the keyword argument labels.\n. ... to stop overloading the python built-in\n. add an example ?\n. Python3 only\n. \"Stop returning the last form in --init--\" ?\n. \"a\" multi-expression body, I guess.\n. s/octel/octal/\n. Might want to bundle that up with the unary division.\n. ???\n. redundant with language changes\n. ",
    "hoffoo": "\"Most programmers think a car is something you drive, and a cdr is a abbreviation that would be better off written out.\"\nBut not Lisp programmers - Lisps are pretty fragmented already when it comes to syntax.\n. ",
    "willkg": "Did what @cwebber do cover this?\n. Fizix0rd cl -> clj issuez. ^^^\n. parsley link: https://github.com/washort/parsley\nAnd Allen's talk at pycon: http://pyvideo.org/video/1736/worry-free-parsers-with-parsley\nparsimonious (https://github.com/erikrose/parsimonious) might be interesting, too.\n. pull #65\n. Good catches!\n. OMG! That's a deep question.\n. In case anyone was hankering for a reference: http://www.python.org/dev/peps/pep-0008/#descriptive-naming-styles\n. Can we call the \"zen of hy\" guide The Hymnal?\n. Reopened and retitled. I was going to tag it with a \"docmebro\" label, but I can't seem to create a label.\n. Yay! Let the hypocalypse begin!\n. I LOVE COMMAND LINE STUFF! I WILL FIRST WRITE MY OWN ENUM LIBRARY FOLLOWED BY A STATIC BLOG GENERATOR SO I CAN BLOG ABOUT MY ENUM LIBRARYY. THEN I WILL WRITE MY OWN ARGUMENT PARSING MODULE AND DO AWESOME THINGS WITH HY!!!1!\n. Done in 4e59af0.\nPlus I implemented -. Now we can do ridiculous things like:\ncurl -s http://elite-evil-thing.com/eat-your-computer-because-you-run-arbitrary-scripts-from-internet | hy\n. Sorry about that. It didn't look like any one was working on this, so I assigned it to myself, tossed a comment in and then implemented it.\n. I think you have to something something in order to assign yourself an issue with the issue tracker. I'm not sure. I'm also not sure if it sends a notice about the assignment. Thus I assigned it to myself and added a comment.\nI think any time you want to work on something you probably should at least add a comment to the issue along the lines of, \"I'm working on this now.\" That's my rule of thumb. I don't know if that's a common practice in the great hylang project collective.\n. Oops--sorry about that. I grabbed the issue earlier today.\n. Two things:\n1. @berkerpeksag you're everywhere!\n2. I'm going to close this out because I landed an implementation just before this pull request was created. Again--super sorry about that.\n. That's a fair question.\nWhat's in the tree now uses optparse which is available across all the Python versions we support whereas this version uses argparse. So we can't really use that stuff.\nThis adds support for -c, -i and -h. All three are covered by what's in the tree now.\nI re-used HyREPL which I thought would give syntax errors and other things nicely, but apparently it doesn't. e.g.\n$ hy -c \"(foo\"\n$\nSo that should get fixed.\nThis version created this:\ndef import_buffer_to_module(module_name, buf):\n    _ast = import_buffer_to_ast(buf)\n    mod = imp.new_module(module_name)\n    eval(ast_compile(_ast, \"\", \"exec\"), mod.__dict__)\n    return mod\nThat might be a better way to do the -c. The -i needs to drop into the repl, so seems like it should use the repl.\n. Scratch that bug bit. It does work:\n(hy) 1 (M=fb814 hy/) saturn ~/projects/hy> hy -c \"(+ 1 foo)\"\nTraceback (most recent call last):\n  File \"<input>\", line 1, in <module>\nNameError: name 'foo' is not defined\n. Er, let me redo this.\n. I checked LexException and it doesn't know anything about anything. I'll look at opening up an issue for that later.\nI switched the code to use @eigenhombre's import_buffer_to_module because it raises LexExceptions properly.\n. Give me a day and I'll add tests for the new command line stuff and toss it in this pr, too.\n. ^^^ Rebased against master, fixed a silly thing I did and added tests so that @jd doesn't hate me anymore.\n. ^^^ That fixes tests under Python 3.2 and 3.3. So this should be all set now. For realz.\n. That's a pretty standard way of dealing with centralizing the version information. I do that in all my projects.\n. Python 2.6 is no longer supported as of a couple of weeks ago:\n\nPython 2.6.9 is the final security-only source-only maintenance release of the Python 2.6 series.  With its release on October 29, 2013, all official support for Python 2.6 has ended.  Python 2.6 is no longer being maintained for any purpose.\n\nhttp://www.python.org/dev/peps/pep-0361/\nSo, I'm not sure I'd do any more work for Python 2.6 compatibility.\n. ",
    "agentultra": "lisp\n  (defun foo (x &rest xs &optional (y 0) &aux kwargs))\nThe idea here is from the CLHS: http://clhs.lisp.se/Body/26_glo_l.htm\n\nlambda list n. a list that specifies a set of parameters (sometimes called lambda variables) and a protocol for receiving values for those parameters; that is, an ordinary lambda list, an extended lambda list, or a modified lambda list.\nlambda list keyword n. a symbol whose name begins with ampersand and that is specially recognized in a lambda list.\n\nThe idea being that the &keywords don't have any meaning other than being an informal protocol to tell the parser how to interpret the arguments list. In hy's case it just tells the parser how Python interprets arguments. I think we only need three to cover Python arg lists:\n1. &rest args -> args\n2. &optional (foo \"some default, optional parameter\") -> foo=\"some default, optional parameter\"\n3. &aux kwargs -> *kwargs\nAlso the binding of names is consistent, no special syntax things, names, and such. Expicit is better than implicit.\n. It's practically the same thing except now the parser has to look for two different tokens.\nThe CLHS solution has the benefit of being straight-forward to parse and side-steps positional issues. \"When you hit a lambda-keyword token, the following symbols should be bound as... until you hit another keyword or end-of-expression\"\n. Well the hammer has to fall somewhere. I'm not really sure what the goal/driving-philosophy of this is yet, so I'm just re-using what's already there.\n. https://github.com/agentultra/hy/tree/feature/lambda-list-keyword WIP\n. I think DISASSEMBLE returns None (or NIL in CL parlance) and prints its output to the stdout stream. +1 for pretty-printing as well.\n. Cool, +1\n. It's all good. If not, people can use it separate from the project. I just found it useful.\nOn 2013-04-12, at 9:12 AM, Paul Tagliamonte notifications@github.com wrote:\n\nNeed to review PSF license for MIT / Expat compatibility; likely OK, just need to review the PSF license. Might need to split it out. Putting on hold, but it's a fantastic idea.\n\u2014\nReply to this email directly or view it on GitHub.\n. Which test? The native test?\n\nIt's failing because of a bug in something ASSERT or something. If you run that code in the feature branch manually it should work just fine.\nOn 2013-04-21, at 11:02 AM, Paul Tagliamonte notifications@github.com wrote:\n\nTests still failing; I've punted, will resolve and merge shortly.\n\u2014\nReply to this email directly or view it on GitHub.\n. Of course not. Derp.\n\nOn 2013-04-21, at 12:22 PM, Paul Tagliamonte notifications@github.com wrote:\n\nshit all the fixes were in the merge commit.\nFuck. Oh well.\n@agentultra you can't use comas in lists in hy :) - there was no bug in assert ;)\n\u2014\nReply to this email directly or view it on GitHub.\n. The lisp I know seems to do the right thing:\n\nCL> (defmacro rev (&body body)\n         `(progn (reverse (list ,@body))))\nREV\nCL> (let ((rev #'sqrt)) (rev 2))\n;Compiler warnings :\n;    In an anonymous lambda form: Unused lexical variable REV\n(2)\nWhich, if I am not mistaken, is what Hy currently does (which is what a Lisp-2 would do, oddly enough).\n. Well flet and macrolet establish new lexical scopes, so no worries about clobbering anything.\nYou could use flet to get the equivalent to your example and within the scope of that form rev would be shadowed by the function bound to the symbol in the form's lambda-list.\nhttp://www.lispworks.com/documentation/HyperSpec/Body/s_flet_.htm\nI know Hy is supposed to be a Lisp-1 which is why I found it fun that it behaved (perhaps accidentally) like a Lisp-2. ;)\nOn 2013-05-14, at 10:00 AM, khinsen notifications@github.com wrote:\n\nInteresting. My own experience is with Lisp-1 dialects (Scheme and Clojure), which I think is what Hy tries to be, given that Python works that way too.\nI really know very little about Common Lisp, but wouldn't you have to use flet to get the equivalent of my example? If so, how does that behave when shadowing a macro name?\n\u2014\nReply to this email directly or view it on GitHub.\n. I am in favor of keeping lazy versions of the functions in a lazy namespace. \n\nSent from my mobile\n\nOn Jul 9, 2013, at 6:49 PM, Paul Tagliamonte notifications@github.com wrote:\nI very much ACK the lazy versions of functions showing up in core. I'm mildly in favor of ^, but something a bit more sensible would be interesting.\nI summon @jd @agentultra @algernon @khinsen and all the other Lispers to comment\n\u2014\nReply to this email directly or view it on GitHub.\n. Come to think of it I don't think lazy matters much since Py3 defaults to generators for map/filter etc. I was thinking of Py2 and eagerly evaluating by default and being explicit about laziness. \n\nDisregard my earlier comment. \"Lazy\" by default in the sense of obeying the Iterable interface and returning generator objects. \nSent from my mobile\n\nOn Jul 9, 2013, at 8:15 PM, rwtolbert notifications@github.com wrote:\n@agentultra, can you be more specific? Do you think the cached versions should be in a separate namespace from the non-cached versions, instead of a wart on the name? Or do you mean we should have non-lazy versions of say \"take\" and \"drop\" in the core?\nWhen I say lazy (and I know this gets convoluted with the clojure lazy-seq) I mean they work on iterables or iterators and use yield instead of returning a concrete list.\nI think the core versions should be just what we have here, with the decorator removed, since the decorator (despite its name) only adds the cache.\nThen it is a separate decision whether the cached versions have warted names like \"take^\" or if they live in a separate namespace, with totally different names.\nSo, just to be clear, in my mind there are three versions of these possible.\nVersions that take a list and return a new concrete list. \nVersions that take a list or an iterator and return a generator, making them lazy and able to handle infinite sequences.\nTake number 2. and wrap the decorator around them so that they maintain a cache and are thus re-usable.\nI think 1. is not ideal. I think the best choice for core is 2. and then 3. is either names with a wart or new namespace.\n\u2014\nReply to this email directly or view it on GitHub.\n. I wouldn't keep cached generators as the default. Clojure does it because it uses immutable data types by default. Computing a sequence can be expensive memory-wise with all the copying that entails so caching makes sense. Hy is built on Python though where we enjoy the comforts (and pitfalls) of mutability -- caching a generator doesn't really make sense.\n\nWhat if you iterate over a computed set of objects whose state has changed by the time you iterate over them a second time?\nThrow in threading and you've got a handful. :)\nOn 2013-07-10, at 7:58 AM, Paul Tagliamonte notifications@github.com wrote:\n\nEverything's lazy, we are just wondering about the \"cached\" generators, so that if you have a CPU intensive generator, you can iterate over the same values twice without additional CPU cost, like clojure. It's implemented by making an iterable out of an iterator\n\u2014\nReply to this email directly or view it on GitHub.\n. I prefer clear names to funny characters.\n\nOn 2013-07-10, at 8:59 AM, Paul Tagliamonte notifications@github.com wrote:\n\nYah, right - so now that we're all on the same page - what do you think about the suggestion to postfix with a char to denote caching. What do you think of the suggested ^?\n\u2014\nReply to this email directly or view it on GitHub.\n. -1\n\nLAMBDA is more clear than trivial syntax. We're better off waiting until we can implement READ and reader-macros.\n. > Alan Perlis: Syntactic sugar causes semicolon cancer\nAnd he wasn't just talking about semi-colons.\n. Same\nSent from my mobile\n\nOn Jul 14, 2013, at 2:17 PM, Gergely Nagy notifications@github.com wrote:\n+1\n\u2014\nReply to this email directly or view it on GitHub.\n. It's also removing LambdaListKeyword and its associated test? Is that on purpose?\n. Ah someone broke it. Good. Now you see ;)\n\nSent from my mobile\n\nOn Aug 1, 2013, at 11:13 PM, Paul Tagliamonte notifications@github.com wrote:\nAnd this is why we don't use eval :)\n\u2014\nReply to this email directly or view it on GitHub.\n. That's precisely the work around I've used to skirt the issue.\n\nDon't really have a constructive solution yet. Not sure we can implicitly import * when using REQUIRE\nSent from my mobile\n\nOn Aug 19, 2013, at 8:53 AM, khinsen notifications@github.com wrote:\nWhat you need to add to bang.hy is (import [mac [foo]]).\nExplanation: (require mac) makes the macros defined in mac.hy available in bang.hy at compile time (more precisely, hy-to-python compile time). It doesn't make foo available at run time. Wrapping the definition of foo in eval-when-compile would allow to call foo in the definition of the macro bar, but it doesn't magically import it into another module.\nSo far for how Hy works right now. The example shows a common Lisp idiom consisting of a macro expanding into an expression involving a call to a function defined in the same module. Hy should have some nice way to express this. This is less straightforward than in other Lisps due to the way symbols and namespaces work in Python.\nProblem #1 is deciding how symbols used in macro expansions should be taken from by default. For now, they are taken from the namespace in which the macro is used, not the one in which the macro is defined. Worse, there isn't any way to specify that they should be taken from the macro-defining namespace. There should be one, and probably it should be the default. But doing this is not trivial.\nThe fundamental issue is that Python provides no way to refer to a symbol inside a given namespace directly. What a symbol means is always defined by the import statements of the module it appears in. We could make macro expansions include some imports, of course, but then we risk a name clash with explicit imports made in the module that uses the macro. One possible but ugly solution is to use gensyms to refer to such automatically imported names.\n\u2014\nReply to this email directly or view it on GitHub.\n. I\u2019m happy with the Common Lisp idiom since it requires the fewest number of characters.\n\n(some-func :a 1 :b 33)\nThe problem of course has always been how can the compiler differentiate between a keyword and a value:\n(some-func :a 1 :b :a)\nWhich is no problem in CL at least because eval can inspect the object referred to by \u2018SOME-FUNC and inspect the lambda list and match.\nSince all we can do is parse and generate, iirc, there\u2019s no easy way for Hy to tell whether :a is a value to pass into a positional arg, is a kwarg, or a value to a kwarg when generating a call node.\nI did try and take one stab at it to maintain a global ChainedDict of lexical scopes for symbol->function mappings but didn\u2019t get very far. It\u2019d be more lisp-like if our symbols were objects that had a reference so we could just have a symbol table in the compiler we can check.\nI could be over-complicating things. Perhaps a new syntax for function calls is just what we need.\nOn Sep 25, 2014, at 12:52 PM, Ryan Gonzalez notifications@github.com wrote:\n\nIf you agree on a keyword argument syntax, I would be happy to open a PR for it.\n\u2014\nReply to this email directly or view it on GitHub.\n. On Sep 26, 2014, at 4:03 PM, Christopher Allan Webber notifications@github.com wrote:\nAfter having talked on IRC with paultag, I found that:\nhe didn't like the (foo &kwarg1 \"monkey\" &kwarg2 \"bananas\") syntax because it looks confusingly like other syntax, and looks just way too much like the lambda list syntax\nbased on j_king's info, it seems we either need to get rid of hy keywords like :foo to avoid ambiguity in (foo :kwarg1 :monkey :kwarg2 :bananas), but paultag is willing to do it if need be\nHowever, paultag seems to think that the (foo #:kwarg1 :monkey #:kwarg2 :bananas) compromise is a reasonable one, since it already looks like an existing syntax that's similar enough in guile\nHowever, ther's one concern, which this would mean mixing guile call syntax with common lisp defn declarations. Is that messy?\n\nYes, but practicality beats purity.\nLet\u2019s try to get a collection of test-case code and see if the syntax reveals any ambiguities, odd-ness, or just plain noise. :)\n\n\u2014\nReply to this email directly or view it on GitHub.\n. Added as a contrib module. Still very basic, needs more work before the next milestone release (but it's a start!)\n. I just wanted to make the signature indicative of its use. Where in most parameters of an anaphoric macro you pass in a form, in this particular case you pass in a binary function; hence predfn whereas other macros that expect predicate forms use, pred.\n\nHowever I suppose with good doc-strings we could settle the matter explicitly...\n. Anyone know what's up with the failing test?\n. The use-case I've found in the past is unbounded input where 0 is still a value and the predicate is testing for the presence of a value vs. None (since both evaluate to False in a boolean context but we're interested in the value of one of them):\n(ap-map (if it (* it 3)) [1 0 2 3 None 3]) ;; aw sadface\nObviously if you've been coding Python for any amount of time you're used to seeing:\nmap(lambda x: x * 3, (n for n in input if n is not None))\nWhich is a minor nitpick. Technically conflating a numerical value with a boolean is mixing apples with oranges (and is a legacy left to us from Algol). Despite having to test explicitly for the presence of None in our lists the world hasn't come apart. It just has sloppy code and has perhaps raked the hackles of a few programmers who didn't catch the edge case in their tests.\n. @noprompt I like the idea and would review a PR implementing it.\n. Ear muffs are just a convention in CL and don\u2019t mean anything\u2026 \n\nOn Aug 5, 2015, at 8:04 AM, Gergely Nagy notifications@github.com wrote:\nSee the discussion in #383: we saw no compelling reason to change the earmuffs. For Hy, earmuffs are some minor sugar, and they do not - and should not - work like in other lisps. We're not other lisps.\n\u2014\nReply to this email directly or view it on GitHub.\n. aight, lgtm +1 etc.\n\nOn Dec 26, 2013, at 5:59 PM, Paul Tagliamonte notifications@github.com wrote:\n\nRFR, I'm cool with ap-if, since I lifted the name from aif in the canonical anaphoric docz\n\u2014\nReply to this email directly or view it on GitHub.\n. Probably intentional: https://github.com/hylang/hy-style-guide\n. @olasd it'll make sense when parsing.\n. Thank Python.\n\nYou\u2019ll need to test specifically for (and (not (= 0)) (not False)) if you care about parsing numbers.\nOn Jan 29, 2014, at 1:28 AM, Nicolas Dandrimont notifications@github.com wrote:\n\n(integer-char? \"0\") will eval to False in boolean contexts?\n\u2014\nReply to this email directly or view it on GitHub.\n. When writing parser combinators, a typical token parser for integers:\n\n(defun int? )\nIs a pretty straight-forward example. Anywhere you\u2019d want to parse integers out of a string.\nhttp://clhs.lisp.se/Body/f_digi_1.htm\nOn Jan 29, 2014, at 9:25 AM, Paul Tagliamonte notifications@github.com wrote:\n\nJust as a snippit what is the normal usage pattern? Seems like casual\nhackers might use it twice\nOn Jan 29, 2014 9:22 AM, \"J Kenneth King\" notifications@github.com wrote:\n\nThank Python.\nYou'll need to test specifically for (and (not (= 0)) (not False)) if you\ncare about parsing numbers.\nOn Jan 29, 2014, at 1:28 AM, Nicolas Dandrimont notifications@github.com\nwrote:\n\n(integer-char? \"0\") will eval to False in boolean contexts?\n\nReply to this email directly or view it on GitHub.\n\n\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/pull/481#issuecomment-33588036\n.\n\u2014\nReply to this email directly or view it on GitHub.\n. minus the extra brackets\u2026 on integer-char?\n\n\nOn Jan 29, 2014, at 9:39 AM, James King james@agentultra.com wrote:\n\nWhen writing parser combinators, a typical token parser for integers:\n(defun int? )\nIs a pretty straight-forward example. Anywhere you\u2019d want to parse integers out of a string.\nhttp://clhs.lisp.se/Body/f_digi_1.htm\nOn Jan 29, 2014, at 9:25 AM, Paul Tagliamonte notifications@github.com wrote:\n\nJust as a snippit what is the normal usage pattern? Seems like casual\nhackers might use it twice\nOn Jan 29, 2014 9:22 AM, \"J Kenneth King\" notifications@github.com wrote:\n\nThank Python.\nYou'll need to test specifically for (and (not (= 0)) (not False)) if you\ncare about parsing numbers.\nOn Jan 29, 2014, at 1:28 AM, Nicolas Dandrimont notifications@github.com\nwrote:\n\n(integer-char? \"0\") will eval to False in boolean contexts?\n\nReply to this email directly or view it on GitHub.\n\n\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/pull/481#issuecomment-33588036\n.\n\u2014\nReply to this email directly or view it on GitHub.\n. Exactly. Glad I could help everyone learn something. ;)\n\n\n\nOn May 18, 2014, at 1:44 PM, Berker Peksag notifications@github.com wrote:\n\nCopying from IRC:\nolasd | because j_king reset his master branch\nolasd | and his master branch is now == to hylang/hy's master branch\nolasd | that must've confused github's pull request management thinger\nolasd | (and kids, this is why you don't PR from your master branch)\n\u2014\nReply to this email directly or view it on GitHub.\n. It\u2019s so easy to write a Lisp that anyone who thinks they can do better just adds another incompatible Lisp to the pool.\n\nI don\u2019t think Hy should try and be another Lisp. There\u2019s no point. It\u2019s not a Lisp.\nThe most frustration I\u2019ve had with Hy is when I\u2019ve mistaken it for a Lisp.\nHy is just a different syntax for Python.\nHy is Just Python\u2122\nAnd I think everything we do should fall out of that.\nI think flavours are a bad idea for the core language. They should be third-party libraries. The core language should focus on what\u2019s best for Python programmers. No more pandering. I\u2019m tired of issues being posted that amount to whining that Hy isn\u2019t Scheme/CL/Clojure-enough. They completely ignore the fact that Hy isn\u2019t any of those things.\nIf we want the flamewars to stop we have to stop pandering.\nOn Feb 19, 2014, at 3:27 AM, khinsen notifications@github.com wrote:\n\nThe question of how to handle the historical mess of the Lisp universe is not a simple one. Ideally, we'd all be better off with a single Lisp dialect. But it's so easy to personalize the language that many people did it and more will do so in the future.\nIntroducing \"flavors\" conveys the message that we are aware of the existing diversity and don't want to exclude anyone. Presenting a single language conveys the message that we want to do better than the mess of the past. I'd prefer the second message but I am not sure it would be credible. It would easily be understood as \"this is our language and if you don't like it, make your own\".\n\u2014\nReply to this email directly or view it on GitHub.\n. Hm... HyTuple?\n. I'm mucking up histories again. b97e025 is what we want. Hopefully I can make dd19df1 go away.\n. iirc; &rest doesn't work in CL macros either. \n. IMO this doesn't need HYIFY in order to work (and may be confusing ultimately). Consider the CL alternative:\n\nCL-USER> (make-keyword (name)\n           (values (intern name \"KEYWORD\")))\nCL-USER> (make-keyword \"foo_barest bar\")\n:|foo_barest bar|\nThe function to consider is INTERN which retrieves a name from the current package or creates one if it doesn't exist (the optional parameter we pass is a package name, which by CL convention is the package where keyword symbols are interned).  Notice how it doesn't manipulate the contents of name.\nI think the same applies here... there's no reason we cannot accept an arbitrary string and if the user wants to manipulate it before creating the keyword symbol they can do so on their own before passing it to KEYWORD.\nI don't agree that the name need be any more specific. It is a constructor for a Hy type and is not far from the Pythonic convention of lower-cased names for constructors of types (ie: int(), str(), float(), etc)\n. Except NAME... should be KEYWORD-NAME or some such as it applies to a specific object.\n. I think what we really need is READ. \nSent from my mobile\n\nOn Jun 27, 2014, at 4:53 AM, Gergely Nagy notifications@github.com wrote:\nHm... Hy master blew up for me on (+ 1 2) without the HyList cast. We really should have a nice wrapper that does the heavy lifting for us. I ran into wanting this a few times too.\n\u2014\nReply to this email directly or view it on GitHub.\n. QUOTE merely returns its argument unevaluated.\n\n`(1 . 2)\nIs just a reader macro that expands to\n(QUOTE (1 . 2))\nCalling (cons 1 2) is calling a function called, CONS. It has completely different behaviour than QUOTE and is not equivalent.\nOn May 27, 2014, at 7:56 PM, Nicolas Dandrimont notifications@github.com wrote:\n\nTo further my point:\nIn common lisp, (1 2) is a two element list. (1 . 2) is a cons cell, or a two-element dotted list. Inputting both of those in the toplevel would evaluate them (i.e. try to call a function called 1). Calling (cons 1 2) would be equivalent to calling '(1 . 2), that is generating the quoted cons cell with car=1 and cdr=2. My intention was to replicate this behavior.\n\u2014\nReply to this email directly or view it on GitHub.\n. :+1: lgtm\n. Curious how the CI builds and tests are passing...\n. You'll have to know compiler internals to understand. After we parse and encounter a call we dispatch binops which emit the appropriate AST node directly. \n\nHowever we import our functions Ito the global namespace under our symbol names.\nThe difference is in the compiler. Which isn't very consistent in lisps terms but lets us only use the function versions we include as parameters to functions. When you use a basic integer expression we still emit the more efficient Python binary operator.\nSent from my mobile\n\nOn May 19, 2014, at 2:30 AM, Tuukka Turto notifications@github.com wrote:\nTests are passing for me locally too, which I find sort of puzzling.\nMaybe we should add Python 3.x specific tests that import reduce from functools and try to run something simple like (assert (= (reduce * (range 1 5)) 24))?\nTo tell the truth, I'm not sure at all that I understand how Hy picks between + operator and + function.\n\u2014\nReply to this email directly or view it on GitHub.\n. It probably wouldn't be worth it. You can't actually manipulate stack frame activations in Python (no pointers) so these decorators (as noted by other commentators on the linked page) are actually slower than Python's normal recursion for anything but large values of N -- which is the usual case for many iterations in a program.\n\nThere's nothing stopping you from implementing the decorator in Hy for your cases though I don't think we should include this in core.\n. Uh\u2026 do you mean (defn foo \u2026) ?\nIt should raise some sort of NameError because \u2018&rest\u2019 is not a function/name that is defined (assuming spam is bound to a value). If spam is not defined it should raise the NameError for that.\n(foo \u2018[&rest spam] \u2026) raises the appropriate NameError for foo\u2026 thanks for reporting this. :)\nOn Jun 2, 2014, at 10:18 AM, Gregor Best notifications@github.com wrote:\n\nThe following top level form\n(foo &rest spam\nshould cause a NameError because foo is not defined. Instead, it causes a HyCompileError with the message Unknown type: '. If the parameter list is empty, a NameError is correctly thrown.\n\u2014\nReply to this email directly or view it on GitHub.\n. There's nothing stopping someone from binding a function to the name &rest, is there? There's nothing special about lambda lists on CL outside of DEFUN and DEFMACRO, iirc.\n\nIn this case we should evaluate '(&rest spam)' as we would any other form.\nHowever it's also unlikely that a user is going to name a function or value '&rest' so raising an error when encountering such symbols outside of the intended context doesn't seem like it could do much harm. \nSent from my mobile\n\nOn Jun 3, 2014, at 1:36 AM, Nicolas Dandrimont notifications@github.com wrote:\nSo the real issue here is that the compilation of a HyLambdaListKeyword fails through an internal compiler error, instead of an explicit failure.\nLambda list keywords are only ever used in macros / special forms, so we should error out if the compiler encounters one.\n\u2014\nReply to this email directly or view it on GitHub.\n. This made my morning. \ud83d\ude0f\n\nSent from my mobile\n\nOn Jun 4, 2014, at 8:08 AM, Kodi Arfer notifications@github.com wrote:\nIn hy 0.10.0, hy -c '(while True (and False (break)) (print \"hello\"))' prints nothing. The break is executed although the and should short-circuit around it.\n\u2014\nReply to this email directly or view it on GitHub.\n. :+1: lgtm\n. I actually get (Hy 0.10.0 master branch)\n\n```\n=> (defn test ()\n... (while true\n...  (let [[foo \"bar\"]]\n...   (yield foo))))\ndef test():\n    while True:\n    def _hy_anon_fn_1():\n        foo = 'bar'\n        return yield foo\n    _hy_anon_fn_1()\n\n```\nWhich has the same problem of just calling _hy_anon_fn_1() in an infinite loop.\n. :+1: from me.\nShould we bother adding regression tests for this module? My naive local testing says that reduce isn't any slower than sum in this one single case (and I'm not surprised).\n. There are similar libraries for many lisp likes. As long as it\u2019s progressive it should be fine. I hate type annotations unless I really need them. Sometimes duck-typing is actually useful.\nhttp://docs.racket-lang.org/ts-guide/\nhttp://typedclojure.org/\nA more progressive-enhancement approach:\nhttp://www.lispworks.com/documentation/HyperSpec/Body/04_bc.htm\nBut not as popular.\nCheers\nOn Aug 22, 2014, at 12:53 PM, Paul Tagliamonte notifications@github.com wrote:\n\ndef foo(a: int, b: str) -> int:\n    return 0\nCurrently only given meaning by third party stuff.\nLet's allow setting them. Who knows some similar syntax for Lisplikes?\n\u2014\nReply to this email directly or view it on GitHub.\n. :+1: lgtm\n. Maybe we could consider the meaning of annotation in an old-school Pythonic lense of using a decorator to apply its arguments to the function's annotations dict?\n\n(: [[a int] [b str] [-> str]]\n  (defn foo [a b]\n    (* b a)))\nWouldn't cost much to implement.\n. @Foxboron Just a suggestion, admittedly not the best. Annotations appear in the arg grammar definition... so kind of makes sense to mirror the Python syntax as closely as possible. Unless a macro can modify the arg objects of a FunctionDef at expansion time.\n. I agree. This does need to be fixed. \nSent from my mobile\n\nOn Dec 5, 2014, at 7:30 AM, Gergely Nagy notifications@github.com wrote:\nFWIW, in Scheme (Guile):\n(car (cons 1 2))\n; => 1\n(cdr (cons 1 2))\n; => 2\nSo in other lisps, where cons are supported, (rest) returns the tail. Hy differs here, and that's unfortunate. Can we fix this, please?\n\u2014\nReply to this email directly or view it on GitHub.\n. I think more research is needed. \n\nI remember reading somewhere that McCarthy lamented there couldn't be fewer parentheses in let binding forms. I'd like to recall what held them back from doing what we're proposing here.\nObviously we don't have historical baggage yet but what else is there? We don't have flet yet or let* but what about macros etc?\nSent from my mobile\n\nOn Dec 11, 2014, at 2:02 AM, Gergely Nagy notifications@github.com wrote:\n+1.\nIIRC the double [[ was there originally, because that was much easier to implement. The reason for for only having one, is that you can only specify one pair there, no?\n\u2014\nReply to this email directly or view it on GitHub.\n. I suggest we just let it be. We have text editors. It may not be ideal in some peoples\u2019 eyes but there\u2019s history to prove that it works and doesn\u2019t get in the way of good code. I don\u2019t think there\u2019s enough justification for the effort just to drop a few parenthesis and I suspect neither was there one in the legion of Lisps that have come to this question before.\nOn Dec 30, 2014, at 12:10 PM, Tianon Gravi notifications@github.com wrote:\nOh duh, we need the next param to be the code. /me sulks off into the corner\n\u2014\nReply to this email directly or view it on GitHub.\n. I have a branch sitting around that has an almost complete parser-combinator for Hy written in Hy\u2026 it will just need some love to update it with the recent changes.\n\nOnce we have an actual reader (and not a parser-generator) implementing reader-macros, while not trivial, is not far fetched.\n\nOn Dec 15, 2014, at 12:39 AM, Bogdan Opanchuk notifications@github.com wrote:\nBased on my very limited understanding of how parsing works, I don't think you can represent full Lisp reader with a lexer-parser pair. So, no amount of tinkering with rply will help.\nOf the two solutions I mentioned, I'd prefer the latter one: keep rply as a parser for the \"static\" subset of Hy, and then adopt some existing reader implementation (for example, Clojure reader written in Clojure).\nWhat also slightly worries me is that a full reader reads input stream character by character, as opposed to rply lexer which uses regexps on the full string, so there will be some performance drop (can't say how significant, though).\n\u2014\nReply to this email directly or view it on GitHub.\n. Having with_kwargs in the first position of the predicate should be enough for :+1: \n. I don\u2019t like the idea of versioning the language. We fail our users every time a user wants a feature that requires changing the parser. Adding to the pain of versioning the interpreter our code generator runs on is not a good idea. It\u2019s a shot in the foot (\u201cPython 2.7.1 + Hy 1.3? Python 3.2 + Hy 1.7? 2^m*n permutations to support, woo\u201d).\n\nIn my not-so-humble opinion we should focus on reducing down our core primitives to their most hardened, well-understood forms. We should re-write as much of Hy as we can in Hy. We\u2019ll win when we can build-up instead of maintaining everything top-down. Get the foundations right and we won\u2019t have to force core developers into stewardship over another parser and grammar.\n\nOn Dec 30, 2014, at 12:32 PM, Paul\u202eetnomailgaT\u202d notifications@github.com wrote:\n@hylang/core - going to need some feedback on this one\nI'd like to suggest adding a compat stop-gap for Hy source code. This will be optional, and likely result in more crap sitting in core or the compiler.\nI'm not sure about the details yet, but I'm wondering if we could add something to the package metadata in setup.py for projects (or a file in the package directory) to declare a \"Hy compat level\".\nThis would let people declare the major and minor (e.g. no patch level) version number of Hy that it needs.\nThe idea here is that we'd support old minor releases for a few versions to ensure we can do a migration (but throw a few deprecation warnings), such as our recent keyword changes, and likely changes to (let) that will pop up soon. I'm assuming defun, car, cdr are up next.\nThis would add a few more codepaths in the compiler, and I have no idea if this is a good idea or not, but I don't like the idea of a minor bump breaking code in a way that requires tons of changes. If we could suggest adding a compat while they migrate, I'd be more open to changes like this.\nAfter a few releases, I'm assuming we'd formally deprecate it, and raise an Exception if the compat is too far out of date (and we'd trim the code out). If we get a future compat, we should also likely error out.\n\u2014\nReply to this email directly or view it on GitHub.\n. :+1: \n. You'd have to ship a Hy interpreter or ask the user have one in order to bootstrap it. \n\nIf I ever finish my parser-combinator I can implement READ in Hy and we wouldn't need our present parser generator. \nBut you'd still have to bootstrap it with Hy. :)\nSent from my mobile\n\nOn Mar 24, 2015, at 1:40 PM, Nemanja Trifunovic notifications@github.com wrote:\nWhy not using Hy to develop Hy instead of Python  ?\nPython sources could be generated for packaging and distribution.\n\u2014\nReply to this email directly or view it on GitHub.\n. No, since the output of the interpreter is still a Python AST; you\u2019d still need a Python interpreter to consume it.\n\nThe fundamental difference would be that the artifact of bootstrapping a Hy interpreter is a Python module that is a Hy interpreter. All Hy-in-Hy is proposing is that we write Hy\u2019s core in Hy instead of Python.\n\nOn Jun 8, 2015, at 9:28 AM, Christopher Allan Webber notifications@github.com wrote:\nWould we lose out on interoperability with Python's wonderful world of libraries (arguably Hy's biggest selling point as a lisp?)\n\u2014\nReply to this email directly or view it on GitHub.\n. That too. Derp.\n\nSorry, have only had one coffee. Daughter woke me up super early this morning. :)\n\nOn May 6, 2015, at 9:41 AM, Antony notifications@github.com wrote:\nalgernon> (ap-map-when (fn x) (* it 2) [1 2 3 4])\nMind the doors.\n\u2014\nReply to this email directly or view it on GitHub.\n. When I originally implemented ap-map-when I originally designed it with this behaviour. However we went with its current incarnation for various reasons; primarily that it was neater.\n\nI\u2019d like to avoid defining similar macros for different parameter types if we could. Is it possible for us to do some introspection at macro-expansion time to support both function types?\nCheers\n\nOn May 6, 2015, at 9:37 AM, Antony notifications@github.com wrote:\nAdded ap-map-whenl as an alternative to ap-map-when which takes the predicate in lambda form.\nI am ready to abandon this PR if some on can tell me of another way to do this :)\n=> (require hy.contrib.anaphoric)\n=> (setv foo 2)\n;; doesn't work\n=> (list (ap-map-when (= it foo) (* it 2) [1 2 1 2]))\nTraceback (most recent call last):\n  File \"\", line 1, in \n  File \"\", line 1, in _hy_anon_fn_1\nTypeError: 'bool' object is not callable\n;; works\n=> (list (ap-map-whenl (= it foo) (* it 2) [1 2 1 2]))\n[1L, 4L, 1L, 4L]\nYou can view, comment on, or merge this pull request online at:\nhttps://github.com/hylang/hy/pull/801\nCommit Summary\n\u2022 Added ap-map-whenl as an alternative to ap-map-when which takes the predicate in lambda form.\nFile Changes\n\u2022 M docs/contrib/anaphoric.rst (17)\n  \u2022 M hy/contrib/anaphoric.hy (10)\n  \u2022 M tests/native_tests/contrib/anaphoric.hy (5)\nPatch Links:\n\u2022 https://github.com/hylang/hy/pull/801.patch\n  \u2022 https://github.com/hylang/hy/pull/801.diff\n\u2014\nReply to this email directly or view it on GitHub.\n. Why not just sub-class the types you\u2019re interested in and make them quack for assoc? \u201cDuck typing,\u201d is a kind of protocol. :)\nOn May 19, 2015, at 1:28 PM, Ed Blake notifications@github.com wrote:\nI want to use Pyrsistent with Hy. Ideally I would replace all data literals with versions that create immutable versions. In reality I planned to create reader macros to get close. I also want to replace data manipulation functions with Pyrsistent analogs. This seems impossible:\nhy 0.11.0 using CPython(default) 2.7.8 on Windows\n=> (defn assoc d k v)\n  File \"\", line 1, column 7\n(defn assoc d k v)\n        ^----^\nHyTypeError: Can't assign to a builtin: `assoc'\nI would really like something like Clojure's protocols where interfaces could be extended to existing types. Then the assoc could be extended to work on arbitrary data types by the user at run time...\nHere is a good SO post explaining why protocols: http://stackoverflow.com/questions/5986120/clojure-defprotocol-as-a-solution-to-the-expression-problem\n(Having written no code) it seems trivial to implement something like protocols in Python/Hy. Even if I did implement something I wouldn't be able to modify assoc though because, as per another issue, assoc isn't a function but emits AST for the Python statement d[key]=value.\nI might have a go at implementing protocols in Hy anyway. Here is a link mainly for my own reference: https://github.com/clojure/clojure/blob/master/src/clj/clojure/core_deftype.clj#L508\n\u2014\nReply to this email directly or view it on GitHub.\n. This isn't the first time someone has tried these ideas in Python and I've never been convinced of their utility. \n\nIt seems like a YAGNI for me without some hard evidence. \nTry it out in your project and give us some concrete examples of how it has improved your code!\nSent from my mobile\n\nOn May 19, 2015, at 5:30 PM, Ed Blake notifications@github.com wrote:\nYou could maybe implement getitem and setitem in this case and get the built-in assoc working, but protocols are a more general solution. Protocols are about open extension, adding features to someone else's objects without modifying its code or monkey patching.\nHere is a gist where I've sketched part of a protocol implementation: https://gist.github.com/kitsu/83d0120b5ef3ba783940\nIt still needs a lot of machinery for grouping functions in actual protocols and extending those sets over existing types. Then all that machinery can be hidden on the Hy side with some nice macros.\n\u2014\nReply to this email directly or view it on GitHub.\n. :+1: lgtm \n\nSent from my mobile\n\nOn May 23, 2015, at 7:36 AM, Gregor Best notifications@github.com wrote:\nProof of concept for #809. I need this for a Hy-only nREPL implementation.\nYou can view, comment on, or merge this pull request online at:\nhttps://github.com/hylang/hy/pull/810\nCommit Summary\nAllow specification of global table and module name for (eval ...)\nFile Changes\nM docs/language/api.rst (5)\nM hy/compiler.py (19)\nPatch Links:\nhttps://github.com/hylang/hy/pull/810.patch\nhttps://github.com/hylang/hy/pull/810.diff\n\u2014\nReply to this email directly or view it on GitHub.\n. And when you have a mail client that renders those glyphs\u2026 I lol.\nOn Jul 24, 2015, at 10:32 AM, Ewald P. Grusk notifications@github.com wrote:\nI have applied the fix suggested by @algernon (see #821 and #822) to the working directory of my local repository. The tests pass, but here\u2019s the catch:\n;; Python 2.7.3 on Linux\n((\nfn [\ud83d\udca9] \ud83d\udca9) 1\n)\n;; 1L\n((\nfn\n [\ud83d\udca9] \ud83d\udca9) :\ud83d\udca9)\n;; UnicodeEncodeError: 'ascii' codec can't encode character u'\\U0001f4a9' \u2026\n((\nfn [\ud83d\udca9] \ud83d\udca9) :\ud83d\udca9 1\n)\n;; UnicodeEncodeError: 'ascii' codec can't encode character u'\\U0001f4a9' \u2026\nNeedless to say that Python 3 is not affected by this.\n\u2014\nReply to this email directly or view it on GitHub.\n. You read email in a terminal still? I have no sympathy. \ud83d\ude1d\nOn Jul 24, 2015, at 10:42 AM, Morten Linderud notifications@github.com wrote:\nMy terminal ain't even rendering those glyphs :/\nOn Fri, Jul 24, 2015 at 07:41:28AM -0700, J Kenneth King wrote:\n\nAnd when you have a mail client that renders those glyphs\u2026 I lol.\n\nOn Jul 24, 2015, at 10:32 AM, Ewald P. Grusk notifications@github.com wrote:\nI have applied the fix suggested by @algernon (see #821 and #822) to the working directory of my local repository. The tests pass, but here\u2019s the catch:\n;; Python 2.7.3 on Linux\n((\nfn [\ud83d\udca9] \ud83d\udca9) 1\n)\n;; 1L\n((\nfn\n[\ud83d\udca9] \ud83d\udca9) :\ud83d\udca9)\n;; UnicodeEncodeError: 'ascii' codec can't encode character u'\\U0001f4a9' \u2026\n((\nfn [\ud83d\udca9] \ud83d\udca9) :\ud83d\udca9 1\n)\n;; UnicodeEncodeError: 'ascii' codec can't encode character u'\\U0001f4a9' \u2026\nNeedless to say that Python 3 is not affected by this.\n\u2014\nReply to this email directly or view it on GitHub.\n\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/hylang/hy/pull/815#issuecomment-124545151\n\u2014\nReply to this email directly or view it on GitHub.\n. Shouldn\u2019t keywords be their own type, perhaps sub-classed from str?\n\n\n(issubclass :keyword HyKeyword) => True\n\nOn Jul 24, 2015, at 10:06 AM, Gergely Nagy notifications@github.com wrote:\nThis is a toughie. I think that (string? 'symbol) returning true is wrong. On the other hand, (string? :keyword) throwing an exception ain't exactly friendly, either. I'd propose both should return false.\nOpinions?\n\u2014\nReply to this email directly or view it on GitHub.\n. (.extend [1 2] [3 4])\n\nHy is just Python. (3 4) isn't a linked list. ;)\nSent from my mobile\n\nOn Jul 10, 2015, at 4:51 AM, Gergely Nagy notifications@github.com wrote:\n(+ '(3 3) '(4 4))\n\u2014\nReply to this email directly or view it on GitHub.\n. for k, v = zip(it, it) ?\nOn Jul 14, 2015, at 12:20 PM, Ryan Gonzalez notifications@github.com wrote:\n@paultag I have a fix \"ready\" here, but it's giving a really weird error:\nryan@DevPC-LX:~/stuff/hy$ ./run\nhy 0.11.0 using CPython(default) 2.7.6 on Linux\n=> (setv x {})\n=> (assoc x 2 2)\nTraceback (most recent call last):\n  File \"\", line 1, in \n  File \"/media/ryan/stuff/hy/hy/core/language.hy\", line 301, in assoc\n    (is x None))\nNameError: global name 'v' is not defined\n=> \nryan@DevPC-LX:~/stuff/hy$ \nThis is what hy2py outputs for hy/core/language.hy:\ndef assoc(tgt, *args):\nif (not\n is_even(len(args))):\nraise\n TypeError(u'expected an even number of key-value pairs')\n        _hy_anon_var_2 = \nNone\nelse:\n    _hy_anon_var_2 =\nNone\nit = iter(args)\nfor\n [k, v] in zip(it, it):\n        tgt[k] = v\n    return tgt\nIt looks like it should work. What's wrong?\n\u2014\nReply to this email directly or view it on GitHub.\n. Or just implement it as a convenience macro for setv'ing a bunch of variables. It's just Python under the hood. \n\nSent from my mobile\n\nOn Jul 23, 2015, at 5:42 PM, Christopher Allan Webber notifications@github.com wrote:\nOne alternative is to provide let to preserve backwards compatibility, but fully document that it's mostly broken and why it is unlikely that a real let will never exist, and not use it in any example code.\n\u2014\nReply to this email directly or view it on GitHub.\n. Design by committee diatribe aside, I agree 100%. \n\nANSI specifications are useful so that your language isn't dictated by implementation. Python would be better off with one so that PyPy, Jython, et al wouldn't have to duplicate CPython bug for bug. \nSent from my mobile\n\nOn Jul 23, 2015, at 7:14 PM, gilch notifications@github.com wrote:\nOne alternative is to provide let to preserve backwards compatibility, but fully document that it's mostly broken and why it is unlikely that a real let will never exist, and not use it in any example code.\nA major failure mode for design-by-committee (historically) has been cruft. That's why C is a pretty good language, but C++ is crazy scary. Also compare Common Lisp to Clojure. Languages with a single designer or benevolent dictator don't have such a cruft problem. Compromise leads to compromised language. I think the move to Python 3 was a good thing because it got rid of cruft. But it did cause some other problems (putting it mildly). Mainly because there was so much software written in Python 2 already. That means the best time to clean up cruft in Hy is as soon as possible. While we're still in alpha and not too much depends on the current version of the language. (We are still in alpha, right?)\nIt already bothers me that Hy has so much duplication polluting the default namespace because it's trying to be Clojure and Common Lisp (and Python) at the same time. We don't need both do and progn etc. do alone will do. We don't need both True and true. We can put Python first, it's True. Hy does not need to be compatible with Clojure or Common Lisp, and certainly not both.\nIf we want to take the route of deprecating let as you suggest, can we at least move it out of Hy's core, and into a contrib. library or something? It would take a simple import statement to fix the old scripts. We could do the same for the other duplication and keep Hy's core simpler.\nOr just implement it as a convenience macro for setv'ing a bunch of variables. It's just Python under the hood.\nBetter yet, just extend setv to work on multiple pairs simultaneously. In Common Lisp, setf already does this. (quoting from the hyperspec)\n(setf place-1 newvalue-1\n       place-2 newvalue-2\n       ...\n       place-N newvalue-N)\nis precisely equivalent to\n(progn (setf place-1 newvalue-1)\n        (setf place-2 newvalue-2)\n        ...\n        (setf place-N newvalue-N))\nWe could make setv work the same way:\n(setv spam 1\n      eggs 2\n      bacon 3)\nspam = 1\neggs = 2\nbacon = 3\nbacon\nPython can already do simultaneous assignment using tuples. So we can already do something similar to psetf like this:\n(setv (, spam eggs bacon) (, 1 2 3))\n(spam, eggs, bacon) = (1, 2, 3)\n(spam, eggs, bacon)\nIn many cases it makes no difference though.\n\u2014\nReply to this email directly or view it on GitHub.\n. :D\nOn Jul 24, 2015, at 9:49 AM, Paul\u202eetnomailgaT\u202d notifications@github.com wrote:\nYeah. No problem. Let's get a ticket open with a TODO of things to fix. We\nshouldl appoint someone from core to BDFL this.\nOn Fri, Jul 24, 2015 at 9:47 AM, Gergely Nagy notifications@github.com\nwrote:\n\nCan we do the cleanup before ~september? I'd rather go into production\nwith \"modern\" Hy.\n(The contrib shim sounds like a reasonable idea.)\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/844#issuecomment-124526741.\n\n\n:wq\n\u2014\nReply to this email directly or view it on GitHub.\n. Python is not the JVM. Hy is not Clojure for Python. It's apples to oranges. \n\nThe problem, as I understand it, is that Python only implements lexical scopes using functions. We don't have a real progn and we'd have to eval with the lexical envs\nSent from my mobile\n\nOn Jul 24, 2015, at 11:42 AM, Rui Carmo notifications@github.com wrote:\nsigh seeing as I'm doing Clojure again and let is kind of... inevitable, I'm torn. I just know I'm going to have to hack sushy to bits once the new release is out, but if you really have to break Hy, then...\n\u2014\nReply to this email directly or view it on GitHub.\n. The context switch is always hard but they are separate things and should not be conflated.\n\nI really like having let but we don\u2019t have the facilities in Python to really support it, just hacks.\nIf we come up with a progn implementation we could do it but I suspect we\u2019ll have to eval code in the enclosing lexical scope and that might make some Python programmers uncomfortable (even though we use eval in some of the builtin libs\u2026). It also might make us uncomfortable since Python\u2019s eval takes strings\u2026 :(\n\nOn Jul 24, 2015, at 12:25 PM, Rui Carmo notifications@github.com wrote:\n\nOn 24 Jul 2015, at 17:18, J Kenneth King notifications@github.com wrote:\nPython is not the JVM. Hy is not Clojure for Python. It's apples to oranges. \n\nYeah, well, I am quite aware of that. That is not the comparison I had in mind.\nRather painfully so, since I\u2019ve been using Hy for a fairly extensive set of little things. It\u2019s just that it will be annoying to code some things without let, just like it is to have it partially broken like it is today - and being close to Clojure helps a lot when you\u2019re switching contexts frequently.\n\u2014\nReply to this email directly or view it on GitHub.\n. It should, regardless. :)\nOn Jul 24, 2015, at 1:27 PM, Paul\u202eetnomailgaT\u202d notifications@github.com wrote:\nOr let setv take multiple pairs\nOn Jul 24, 2015 1:23 PM, \"Gergely Nagy\" notifications@github.com wrote:\n\nI'd keep some kind of let. A macro that expands to a set of setvs, to\nat least seem familiar. But then, calling that let may not be the best\nidea...\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/844#issuecomment-124585771.\n\u2014\nReply to this email directly or view it on GitHub.\n. Derp, forgot you can give eval code objects\u2026 my point either way is that we can\u2019t evaluate arbitrary lexical environments; or we could if we could actually compile an arbitrary let body into an expression code object we pass to eval.\n\nOn Jul 24, 2015, at 3:15 PM, gilch notifications@github.com wrote:\nIf we come up with a progn implementation we could do it but I suspect we\u2019ll have to eval code in the enclosing lexical scope and that might make some Python programmers uncomfortable (even though we use eval in some of the builtin libs\u2026). It also might make us uncomfortable since Python\u2019s eval takes strings\u2026 :(\nPython's eval doesn't cut it. It only does expressions, not statements. You need exec. Also, these don't have to take strings. They work on code objects, which we can compile() from AST.\n\u2014\nReply to this email directly or view it on GitHub.\n. You also have to be clever to not bash outer scopes.\n\nNot sure if our statement-mangling eval can compile a code object we can pass to eval with the lexical environment defined by the let but that\u2019d be the only way I can see it happening.\n\nOn Jul 24, 2015, at 4:58 PM, gilch notifications@github.com wrote:\nClever, but no. A finally/del is nowhere near a proper let, because it breaks closures. For example:\n; Common Lisp\n- (defvar foo\n  (\n  let ((counter 0\n  ))\n    (\n  lambda\n  () (incf counter))))\n- (funcall foo)\n1\n- (funcall foo)\n2\n- (funcall foo)\n3\n*\nNow let's try that with finally/del in Python.\n\n\n\ntry\n:\n    counter \n= 0\n\n\n\ndef _hy_anon_fn_1\n():\nglobal\n counter\n        counter \n= counter + 1\nreturn\n counter\n_hy_anon_var_1\n_hy_anon_fn_1\nfinally\n:\ndel\n counter\n\n\n\nfoo =\n _hy_anon_var_1\nfoo()\nTraceback (most recent call last):\n  File \n\"\", line 1, in \n\n\n\nfoo()\nFile \n\"\", line 5, in\n _hy_anon_fn_1\n    counter \n= counter + 1\nNameError: name 'counter' is not\n defined\n\n\n\nYou see the problem? If this were in a function we could use nonlocal instead of global, but it still wouldn't work. And let is allowed outside of functions.\n\n\n\n\u2014\nReply to this email directly or view it on GitHub.\n. It\u2019s not that Python has strange scoping; it just doesn\u2019t have delimiters for arbitrary scope. All scoping is function-scope. Even bindings (at least used to, pretty sure they fixed it in 3.3+) in comprehensions leaked to the outer scope because of this limitation.\n\nlet in the lispy form is typically implemented by an implicit progn in an eval with the specified environment defined by the bindings (at least that\u2019s what we\u2019d expect the naive transformation to be\u2026 implementations often do some tricks to generate better code). We have been able to mimic that in Hy by generating nested functions but that has it\u2019s own problems when interacting with other parts of the language since the programmer doesn\u2019t have any control over the generated code there.\nIf Python was purely defined by expressions then it would be arbitrary to eval an expression with the enclosing environment defined by the let. We might be able to still do that with some hackery to convert the (Hy) body to a valid Python expression, compile the code object and pass it to eval with the let bindings shadowing over the local environment. However the usual caveats of eval in Python would apply: it\u2019s slow as molasses. That cost might not be a big deal in practice depending on where the let is located but you\u2019d have to be awfully careful not to call a function in a tight loop with a let inside (which is generally good practice anyway even in a Lisp world where this sort of structure is basically free).\nlet in the Python sense is the same as a variadic setv. We can bind names all we want given the normal Python rules. However we can\u2019t generate new scopes without generating hacks and work-arounds.\nThe eval route might still work; but it would take some investigation to see how we can limit the generated Hy body to only, ever output a valid Python expression code object to pass to Python\u2019s eval.\n\nOn Jul 28, 2015, at 8:50 AM, John Jacobsen notifications@github.com wrote:\nIt looks like this is still up for discussion...? As a full-time Clojurian coming back to Hy after a few years away, I'm still playing catch-up as to how let is broken in Hy (Python); but after getting over my initial visceral reaction (\"you'll have to pry let from my cold, dead hands\"), I would like to +1 what @algernon wrote in favor of let, above. Almost every Lisp I've used has a let, or several. Aside from providing a certain kind of scoping behavior, let, especially in Clojure, usually signals the following intentions:\n\u2022 I'm going to take a value and bind it to a name;\n  \u2022 I'm not going to change its value (generally; OK Clojure is immutable by default, but generally I'll program that way in Python too if I can help it);\n  \u2022 I only care about this binding in the scope of this form. (I could also add:\n  \u2022 My binding might shadow another binding in the outer scope but this seems less critical to me.)\nI'll be a little sad if Hy loses a shared (very Lisp-y) idiom for this most common of patterns. If one can work around Python's strange scoping, all the better.\n\u2014\nReply to this email directly or view it on GitHub.\n. The other alternative is to not have keyword objects. Python doesn\u2019t have keyword objects.\nOn Jul 24, 2015, at 10:17 AM, Gergely Nagy notifications@github.com wrote:\nThe main reason keywords are invalid unicode strings is that we didn't want to leak Hy objects into python. Having used Hy in production for a while, and planning to deploy it yet another place, I do not see an issue with leaking Hy objects into python space.\nTherefore, I propose we turn keywords into proper objects!\nPros:\n\u2022 (string? :keyword) would do the right thing.\n  \u2022 We could make keywords callable, which'd give us quite a bit of neat syntax: (map :keyword [{:keyword \"found me!\" :closet :skeleton}]) => (\"found me\")\n  \u2022 Less keyword-specific magic in the compiler\nCons:\n\u2022 Hy objects leak through into python.\n\u2014\nReply to this email directly or view it on GitHub.\n. It\u2019s a macro and pretty harmless.\n\nI needed a canonical lisp-ish sense of logical truth to implement a corner-case in a monadic parser-combinator I was writing to parse Hy\u2026 so that we could write READ in hy and eventually have Hy written in Hy. Python\u2019s idea of truth is a little too broad in certain situations where 0 is a perfectly legitimate value and not a boolean.\n\nOn Jul 24, 2015, at 3:48 PM, gilch notifications@github.com wrote:\nWhat's the rationale for making False truthy in lif? Because that's just bizarre. I know that nil in its various incarnations is the one true false in Common Lisp. But in every Lisp I know of that actually has a false, it is, in fact, falsey.\nI do understand the need for both Pythonic if and Lispy lif. There are cases it simplifies, that could fail on e.g. 0 being falsey. I think Clojure is our best guide here. In Clojure, both nil and false (and nothing else) are falsey.\nNow I am not proposing a third cif, I think that over-complicates things. If there truly are good reasons for making false truthy, then we should change all the ? predicates in Hy to return nil instead of false (as with Common Lisp's p predicates). Otherwise, can we make lif act more like Clojure, please?\n\u2014\nReply to this email directly or view it on GitHub.\n. seconded.\nOn Jul 24, 2015, at 7:26 PM, gilch notifications@github.com wrote:\n@paultag I don't think we need braces here.\n\u2014\nReply to this email directly or view it on GitHub.\n. Why, oh why, do we need syntax for anonymous functions? lambda is perfectly fine and legible.\n\nFrom one perspective I understand that \u201clambda,\u201d is so common that like \u201cquote,\u201d \u201cunquote,\u201d and friends it perhaps deserves syntax in order to keep readers from being distracted by mundane details. However the same could be said for \u201cdefn\u201d or \u201cdefmacro\u201d and others. Unlike \u201cquote\u201d and \u201cunquote\u201d I think \u201clambda\u201d isn\u2019t just noise but like \u201cdefn\u201d and \u201cdefmacro\u201d it defines a new form and deserves to be spelled out.\nIf it\u2019s too much to type, write a reader macro or learn to use your text editor.\n\nOn Aug 10, 2015, at 2:15 AM, Gergely Nagy notifications@github.com wrote:\n,\\ looks a bit weird to me. ,# or #, (the latter may clash with reader macros, mind you) looks a bit better. But I have no strong preference either way.\n\u2014\nReply to this email directly or view it on GitHub.\n. It\u2019s entirely possible to use Java without an IDE. You just wouldn\u2019t want to. I could use an editor as you described for Lisp development but I wouldn\u2019t want to when I have emacs + slime + paredit. The bar is much higher than you think.\n\nJava\u2019s legendary verbosity is the least of its problems. Text editors take care of managing text for you. The good ones do anyway.\nThe problem I have with introducing Clojure\u2019s syntax for LAMBDA is that I find it superfluous for the following reasons:\n1. Python users already type \u201clambda\u201d (or have their editor do it for them)\n2. CL, Scheme, Racket, and innumerable other Lisps use \u201clambda\"\n3. Like DEFN and DEFMACRO, LAMBDA introduces a new form. In contrast QUOTE and friends are only interesting to READ and are only moderate interest to a human reader \u2014 ergo reader macros such as ' and , in CL or Scheme.\n4. Parsers would have to be written to support structural editing and highlighting of short-hand lambda syntax (hy-mode in Emacs land for example)\n5. Special syntax requires beginners to become experts and is non-transferable rote knowledge.\n6. In the case of Hy there is no real benefit other than forcing new users to learn more syntax.\n\nOn Aug 10, 2015, at 2:23 PM, Matthew Egan Odendahl notifications@github.com wrote:\n,\\ looks a bit weird to me.\nIt's not unusual for a programming language to substitute ASCII digraphs for other characters not easy to type, so \u2192 becomes ->, for example. Similarly, \u03bb could become ,\\, or perhaps .. Haskell doesn't even bother with a digraph and just uses \\ for lambda. That's really the only reason I chose ,. The choice of characters is not that important, and easily changed. It just has to be short.\nWhy, oh why, do we need syntax for anonymous functions? lambda is perfectly fine and legible.\nWhy, oh why, do we need a Hy? Python is perfectly fine and legible ;) \"Need\" is a relative term. One may as well ask, \"Why does Clojure need #(...) when it has the perfectly fine and legible (fn ...)?\". For something so \"unnecessary\", it sure seems to get used a lot. The #(...) syntax is different from fn in that it doesn't need extra () in the body and does not require a parameter list. It's implied by special names for the parameters themselves.\nA major use case for this syntax is partial function application with a minimum of ceremony. This is something one uses quite a lot when writing code in the functional style, especially in a language that does not have automatic currying. This is so important that Python added functools.partial, despite already having the perfectly fine and legible lambda that could easily be used for this purpose. See PEP 0309, for exactly this argument.\nIf it\u2019s too much to type, ... learn to use your text editor.\nYes, and Java's tedious verbosity is made much more tolerable with a good IDE. Any language you have to excuse via editor has serious issues. A good Lisp should need little more than parentheses-balancing and indent support.\nI'm surprised by the lack of enthusiasm here. I do understand (and support) the need to guard against cruft in the language, but this can be taken too far in the other direction. After all, Hy is a Lisp, and if some things are missing in the language, the user will add them. With macros, if necessary. (Like how I just added a macro for function literals.)\nIf a standard is too minimal for too long (e.g. Scheme, Lua), then the community will fragment because everybody has to re-invent the wheel, but they all do it independently and in incompatible ways. Hy avoids a lot of this kind of problem by supporting Python's libraries, just as Clojure does with Java's. But Clojure still has both fn and #(), and a large core (~600 forms vs Python's 68 builtins), because Java is not a Lisp, and can't help with that part. Python is not a Lisp either. Domain-specific macros will be in Hy libraries, or individual applications. That can't be helped. But the general-purpose macros that might otherwise get re-invented a lot belong in Hy proper, to combat fragmentation.\n\u2014\nReply to this email directly or view it on GitHub.\n. I still don't understand the benefit this would bring to Hy. I know Clojure. I still don't see the appeal or the benefit it brings users. As near as I can tell fn and lambda being aliases for the same thing is redundant and worth cleaning up.\n\nI'd be more in favour for making better reader macros. Then this discussion would be moot. We could just have lambda and those who think syntactic short-hand improves their programs can run off into the woods and be merry. \nSent from my mobile\n\nOn Aug 10, 2015, at 8:30 PM, Matthew Egan Odendahl notifications@github.com wrote:\nI wouldn\u2019t want to when I have emacs + slime + paredit.\n- Evil . I do appreciate a good editor. But if you find that you're tempted to write a new emacs function to help you with writing repetitive/boilerplate Lisp (like IDEs do for Java), you're better off writing a macro so it's not repetitive instead.\n(lambda ,1 ,2 ,3) repeats the ,1, the ,2, and the ,3. \nThe (,\\ + ,1 ,2 ,3 -1) macro it was expanded from doesn't.\nThe problem I have with introducing Clojure\u2019s syntax for LAMBDA is that I find it superfluous for the following reasons:\n1. Python users already type \u201clambda\u201d (or have their editor do it for them) \n2. CL, Scheme, Racket, and innumerable other Lisps use \u201clambda\"\nWe already have Clojure's syntax for LAMBDA! It's spelled \"fn\" in Clojure as well as Hy. (Which is superflous given that we have lambda in Hy.) This is not the same as Clojure's function literals #(), which we do not have. Note, the macro expands into an ordinary lambda form, thus it cannot take lambda away from Hy.\n1. Like DEFN and DEFMACRO, LAMBDA introduces a new form. In contrast QUOTE and friends are only interesting to READ and are only moderate interest to a human reader \u2014 ergo reader macros such as ' and , in CL or Scheme.\nWe can put the ,\\ inside the parentheses instead of the #% outside of them, if you prefer. This makes it a macro form, instead of a reader macro.\n1. Parsers would have to be written to support structural editing and highlighting of short-hand lambda syntax (hy-mode in Emacs land for example)\nParsers general enough to support macros will support this macro too. Hy does use macros. A lot.\n1. Special syntax requires beginners to become experts and is non-transferable rote knowledge. \n2. In the case of Hy there is no real benefit other than forcing new users to learn more syntax.\nOh, I agree syntax should be kept as simple as possible... but no simpler.\nHy has an entire contrib section dedicated to anaphoric macros, and even has defmacro/g! built-in. ,\\, as proposed, is just another anaphoric macro like these. It's not meant to get rid of lambda. It's meant to get rid of repetition, same as any macro.\n\u2014\nReply to this email directly or view it on GitHub.\n. I see what you're saying now. \n\nPerhaps it'd fit nicely in hy.anaphoric\nIf it took this amount of discussion to get the point across there's no sense confusing new users.\nWe don't need confusing syntax for lambda which ever way we cut it. \nSent from my mobile\n\nOn Aug 10, 2015, at 10:30 PM, Matthew Egan Odendahl notifications@github.com wrote:\nAs near as I can tell fn and lambda being aliases for the same thing is redundant and worth cleaning up.\nAgree with this part, though they don't behave exactly the same now. I would be in favor of removing fn altogether, and using lambda for both cases. But what does that have to do with this issue?\nI still don't understand the benefit this would bring to Hy. I know Clojure. I still don't see the appeal or the benefit it brings users. ... I'd be more in favour for making better reader macros. Then this discussion would be moot.\nI'm not certain we're even talking about the same thing at this point. You seem to be saying that you're not in favor of adding an alias for lambda like, (lambda x y z to (\u03bb x y z) or to #\u03bb(x y z).\nBut this is not what is being proposed here at all. I'm suggesting an anaphoric macro like the defmacro/g! we already have, that expands into a lambda. I'm not sure of the exact word or prefix to use (part of what I wanted to discuss), but if you're more familiar with defmacro/g!, it would be something like this:\n(fn/p! list p!3 p!1 p!2 \"spam\"), which would expand into\n(lambda p!1 p!2 p!3).\nHere p! stands for \"parameter\", just like g! stands for \"gensym\" in defmacro/g!. Except we'd choose something easier to type than p! for the prefix. The suffix indicates what order the parameters appear in the lambda's parameter list once it gets expanded.\nI really don't know what defmacro/g! and the like has to do with reader macros, so that doesn't make any sense.\n\u2014\nReply to this email directly or view it on GitHub.\n. It\u2019s not confusing to someone already familiar with it. They\u2019ve already committed it to memory. Perl is very effective for people who\u2019ve internalized its idioms. It\u2019s initial curve is rather wonky.\n\nIf we just want to re-implement Clojure on Python there are better ways to do it. It seems to me that this discussion is starting with a foregone conclusion. Why is this useful for Hy?\n(ap-map (+ it 10) [1 2 3])\n(ap-filter even? [1 2 3 4 5 6 7 8])\nWhat\u2019s the win here for adding this special syntax?\nI think we can just put it in the hy.anaphoric package and those who like it can use it.\n\nOn Aug 11, 2015, at 9:40 AM, Morten Linderud notifications@github.com wrote:\nIt's honestly not confusing. Clojure uses this to a large extend on map/filter/reduce\nuser=> (map #(+ %1 10) [1 2 3])\n(11 12 13)\nuser=> (map (fn a) [1 2 3])\n(11 12 13)\nIn my experience it reduces the verbosity on smaller operations.\n\u2014\nReply to this email directly or view it on GitHub.\n. > On Aug 11, 2015, at 4:00 PM, Matthew Egan Odendahl notifications@github.com wrote:\nWhy is this useful for Hy?\n(ap-map (+ it 10) [1 2 3]) \n(ap-filter even? [1 2 3 4 5 6 7 8])\nWhat\u2019s the win here for adding this special syntax?\nThese do indeed fix the verbosity problem in the particular cases of map and filter. And the other ap- functions have their own uses. But when using the functional style, you need to pass higher-order functions as arguments a lot, not just to builtins like map/filter, but to other functions you may define yourself. An anaphoric lambda will fix the verbosity problem in every case.\nThe biggest win is for partial function application, as I mentioned before. You need this all the freaking time in functional programming. That's why pure functional languages like Haskell automatically curry their arguments. For example, in Haskell, if you define something equivalent to the Python \nfoo = (lambda a, b: [a, b])\nand then call it without enough arguments:\nfoo(42)\nThen rather than getting an error, it just returns a partial application, like\nlambda b: [42, b]\nwhich you can then call later with the remaining arguments, perhaps multiple times with different remaining arguments.\nIt's never going to be that automatic in Python, but this capability is important enough that Python got functools.partial in PEP 0309. To make this anywhere near as usable as auto-currying, the syntax must be as short as possible. Clojure's form is good enough, but fn/p!, while clearer to you, is too much.\nBut an anaphoric lambda is even more general than this. It's very common in functional programming to create a pipeline of lazy generators by composing functions. For those who use Unix derivatives, this is very similar to the pipelines one would build in a bash one-liner, for example. But for a pipeline to work the output of one function must match the expected input for the next. Sometimes you need an adapter. Say you need to reverse the order of a binary operator? Anaphoric lambda does it: #(- %2 %1); functools.partial can't do it. Maybe you need convert one argument to a string? Anaphoric lambda does it: #%(list (str %1) %&); functools.partial doesn't. It's nearly as general as lambda itself, but much less verbose.\n\nThis argument isn\u2019t going anywhere because of that foregone conclusion I had mentioned. I know what all of this stuff is and I get it. It still doesn\u2019t answer why Hy needs it.\nWhy does this have to go in core and not in a contrib module? I\u2019m not saying it isn\u2019t useful I just don\u2019t see it being useful in core. Python is not a functional programming language and probably never will be. And it\u2019s not terribly hard to write a module with curry, compose, bind, etc as I did for a monadic parser combinator library I wrote to replace our dependency on rply.\n. > On Aug 11, 2015, at 5:47 PM, Matthew Egan Odendahl notifications@github.com wrote:\n\nWhy does this have to go in core and not in a contrib module? I\u2019m not saying it isn\u2019t useful I just don\u2019t see it being useful in core. Python is not a functional programming language and probably never will be.\nYou don't need a pure functional language to use the functional style. Just like you don't need an object-oriented language to use the object-oriented style. GTK+ is a great example of object-oriented C. Python supports multiple paradigms. It has lazy generators (yield, genexprs, itertools), higher-order functions, and functools. I use functional style quite a lot in Python.\nLisp is not a functional language either, but it is very multi-paradigm, and Clojure in particular tries to support functional style well. Hy inherits quite a lot from Clojure, thus I assumed supporting functional style with Clojure idioms was a design goal for Hy.\n\nPreaching to the choir, good buddy. I\u2019ve been working on and off on a monadic parser combinator library to replace our dependence on rply. Hopefully get us to Hy in Hy.\nYou can program in a functional style in Python. Python will probably never curry functions.\n\nNo, we don't have to put it in core. Consensus seems to be, put it in anaphoric and not in core, at least for now--answers one of the main questions I asked in the OP, \"would you prefer I put it in core or contrib?\"\nOh, neat. x1, x2, xi and so on would work I think.\nOK, I'll try to put together a pull using the xi syntax in hy.anaphoric.\n\nSweet\n\n\u2014\nReply to this email directly or view it on GitHub.\n. I dislike special snowflake hosted communications services.\n\nAn irc bouncer like bitlbee is perfectly serviceable if you truly need to be always present.\nMost of the time you don\u2019t though\u2026 any important discussion should happen in ML or issue tracker, etc.\nWe can also host a bot to log our chat room\u2026 \n\nOn Dec 15, 2015, at 1:46 PM, Ryan Gonzalez notifications@github.com wrote:\nI like Gitter a lot. It's like IRC, but any messages you miss get emailed to you, and there's always a persistent log, which I find to be two major deficiencies of IRC (missing messages).\n\u2014\nReply to this email directly or view it on GitHub.\n. Is there a particular reason for limiting the body to if*? Is there an issue attached to this?\n. A typical Lisp eval, as in Common Lisp, accepts a form as the parameter and computes its value using the dynamic environment to provide meaning for names in the form. The user eval is really a front-end for the internal one which takes an environment as a parameter as macro-expand-1 does.\n\nMaybe there\u2019s a way to map the Python concept of module-level scope to a dynamic environment in Lisp?\n\nOn Apr 12, 2016, at 4:30 PM, Matthew Egan Odendahl notifications@github.com wrote:\nAnother potential issue: eval should be able to can mutate a global or local with setv. It currently can't mutate locals, but it can for globals. If you make a new dict with globals+locals, then eval can't update globals by writing to it either.\nOverall, Hy's eval seems to work more like Python's than like Lisp's. I wonder if this is the wrong approach. How does our REPL even function without a proper eval? Can we just use that for eval instead?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub\n. A typical Lisp eval, as in Common Lisp, accepts a form as the parameter and computes its value using the dynamic environment to provide meaning for names in the form. The user eval is really a front-end for the internal one which takes an environment as a parameter as macro-expand-1 does.\n\nMaybe there\u2019s a way to map the Python concept of module-level scope to a dynamic environment in Lisp?\n\nOn Apr 12, 2016, at 4:30 PM, Matthew Egan Odendahl notifications@github.com wrote:\nAnother potential issue: eval should be able to can mutate a global or local with setv. It currently can't mutate locals, but it can for globals. If you make a new dict with globals+locals, then eval can't update globals by writing to it either.\nOverall, Hy's eval seems to work more like Python's than like Lisp's. I wonder if this is the wrong approach. How does our REPL even function without a proper eval? Can we just use that for eval instead?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub\n. Ah yes, I originally intended to be popping off more than one item in an iteration and forgot to clean this up.\n. Sure... I think the % interpolation was messing with me under 3.3 for some reason.\n. Derp. Of course. :)\n. Indeed. I originally had it that way and yeah... late night. ;)\n. It's right if you use\n\nwhile exprs:\n    expr = exprs.pop()\nSince pop comes off the other side. ;)\nBut it's wrong if you're iterating straight through which we should be doing since it turns out that there isn't a lot of sub-expression parsing going on after all.\n. Is this intentional? I'm not sure it's a good idea to drop users into the debugger when compiling their code (unless they ask for it of course).\n. Would this be more efficient if we raised the with_kwargs clause into its own branch? The thought being that we're going to test this clause on every iteration regardless of whether we're compiling an ast.Call node. \n. They could be, but not the keyword version\u2026 you\u2019d need to import operators.and_\n\nOn Mar 12, 2015, at 12:40 AM, Tianon Gravi notifications@github.com wrote:\nIn hy/core/shadow.hy:\n\n+(defn <= [&rest args]\n-  \"Shadow <= operator for when we need to import / map it against something\"\n-  (comp-op operator.le args))\n  +(defn = [&rest args]\n-  \"Shadow = operator for when we need to import / map it against something\"\n-  (comp-op operator.eq args))\n  +(defn != [&rest args]\n-  \"Shadow != operator for when we need to import / map it against something\"\n-  (comp-op operator.ne args))\n  +(defn >= [&rest args]\n-  \"Shadow >= operator for when we need to import / map it against something\"\n-  (comp-op operator.ge args))\n  +(defn > [&rest args]\n-  \"Shadow > operator for when we need to import / map it against something\"\n-  (comp-op operator.gt args))\n  +; TODO figure out a way to shadow \"is\" (and then shadow \"is_not\" too)\n\nI suppose this would apply to and and or as well, since I don't believe and can be shadowed either.\n\u2014\nReply to this email directly or view it on GitHub.\n. \n",
    "cwebber": "Why not just make it close to python?\nclojure\n    (defun foo (x y:\"foo\" &args &&kwargs)\n. My way of looking at it is this: hy is a \"pythonic lisp\".  I mean, really, it's turning into python!\nIt might be lisp heresy to have &&kwargs as such, and it certainly doesn't look familiar, but does it matter?  (Maybe it does, I'm not totally sure.)\n. That said I like the design of jd's last suggestion :)\n. I also fixed the comments to be hy comments style in one place now!\n. So, assoc is useful in a lisp using linked lists because it usually works with alists, which, while not the most efficient structures in the world, are (assuming nobody does any nasty stuff and mutate the cons cells), mostly immutable mapping structures.  Of course, sometimes people want more efficient variants... in Guile there are vlists, and there's a whole set of purely functional data structures and fectors available.  Which is great.  Often these reuse the name \"assoc\" in some way, but are purely functional!\nSo my suggestion is, instead of abusing assoc to try to fake immutability through having nice new structures returned on totally mutable structures by copying the dicts (yikes!), Hy should add nice sugar around existing immutable datastructures for Python... maybe pyrsistent?\n. Why not avoid injections altogether and have a (defmain) macro that does the whole shebang?\n(defmain [&rest args]\n  (foo.bar))\nDone!\n. ... The suggestion of course is that it expands to:\n```\n(defn main [&rest args]\n  (foo.bar))\n(if (= name \"main\")\n  (sys.exit (main sys.argv)))\n```\n. I gave an attempt at this in #526 which I think is pretty good.\nThere's a problem though: afaict a macro can only output 1 s-expression at a time.\nThis is the macro in the pull request:\n``\n(defmacro defmain [args &rest body]\n  \"Write a function named \\\"main\\\" and do the if __main__ dance\"\n  (let [[retval (gensym)]](do\n      (defn main [~@args]\n        ~@body)\n  (when (= --name-- \"__main__\")\n    (import sys)\n    (setv ~retval (main sys.argv))\n    (if (isinstance ~retval int)\n      (sys.exit ~retval))))))\n\n```\nIt works-ish.  The problem is that I think because the (def main) is wrapped in the (do) there's no way to import the \"main\" function from the command line.\nIs there any way for a macro to output multiple s-expressions?  I don't know of any way.\n. So, the reason why not a gensym for the function name is in case you want to be able to import and test that function, named main.  Say, for unit tests or the like.\nBut maybe if you need to import something in unit tests, you shouldn't use defmain... you could always have defmain call another function that's unit testable.  If that's true we could def use a gensym and not stress it.\nHeck, if that's true, we could both have a \"defmain\" and an \"ifmain\"... I really wouldn't mind a macro like:\n(ifmain (main))\nAnd of course defmain could use it too.\n. Actually \"whenmain\" might be better.  I don't think \"ifmain\" is as good, because nobody ever seems to use an else clause.\n\"whenmain\" sucks though as a name.\n. Despite my \"why not gensym\", I pushed up both a gensym for the main function and switched things over to using integer?\nIf people are okay with this direction then, I can write tests and we can get this thing merged.\n. I'm really excited about this idea.  What's needed for it to land?\nI'm not clear on what the reason for %foo over :foo is.  Is it that :foo has meaning in hy? (I'm still now sure yet what that meaning is.)\n. So, I kind of how this looks in guile scheme.\nscheme@(guile-user)> (define* (some-func #:key (a \"monkeys\") (b \"bananas\"))\n                       (list a b))\nscheme@(guile-user)> (some-func #:a 1)\n$5 = (1 \"bananas\")\nscheme@(guile-user)> (some-func #:b 33)\n$6 = (\"monkeys\" 33)\nNo need to add #:foo to the function definition, but why not in calls?  We're not using #:foo for anything, and it looks pretty nice.\nBut otherwise using an & looks good.\nI think this is a pretty critical issue for making Hy code look awesome so would love to see it implemented!\n. Why not hit a simple middle ground:\n(some-func &a 1 &b 33)\nThis uses a new character.... no ambiguity, but otherwise, uses the cl \"style\" of passing.  Done.\n. Good point @kirbyfan64 !\nHow does everyone else feel about this syntax then?  Good enough to go forward?\n. After having talked on IRC with paultag, I found that:\n- he didn't like the (foo &kwarg1 \"monkey\" &kwarg2 \"bananas\") syntax because it looks confusingly like other syntax, and looks just way too much like the lambda list syntax\n- paultag would prefer we don't invent new syntax, though.\n- based on j_king's info, it seems we either need to get rid of hy keywords like :foo to avoid ambiguity in (foo :kwarg1 :monkey :kwarg2 :bananas), but paultag is willing to do it if need be\n- However, paultag seems to think that the (foo #:kwarg1 :monkey #:kwarg2 :bananas) compromise is a reasonable one, since it already looks like an existing syntax that's similar enough in guile\nHowever, ther's one concern, which this would mean mixing guile call syntax with common lisp defn declarations.  Is that messy?\n. So, I tried to take two steps back and think about two things:\n- why isn't (foo :key :tricky-value) possible?\n- why do we want :hykeywords in the first place, outside of that syntax?\nThe former is obviously because of the possibility of collisions with the ability to just do :foo wherever.  But the whole reason we want :foo is so that, from my understanding, creating nice looking DSLs is possible.\nSo it would be pretty ironic if we either got rid of :foo as an arbitrary DSL feature, or if we switched to having a totally different syntax for keyword arguments in function calls than we are allowed to set up for our own DSLs!  After all, why would you want:\n(cool-macro\n :nifty-kwarg \"yeah\"\n (some-method #:different-looking-kwarg \"uhoh\"))\nThat seems like a bummer, and I think the real thing is: that's why we're all kind of unhappy with this!  I think it's not so bad of a situation to end up with, but it's a bit annoying to have the inconsistency, to not be able to use the same things that function calls do.\nBut, shower thought this morning!  I don't know enough about the compiler, but is it possible for Hy to tell the difference between:\n(let ((our-kwarg :fun-kwarg))\n  (call-this-method our-kwarg \"banana\"))\nand:\n(call-this-method :fun-kwarg \"banana\")\nIs there some sort of property, or something that could be set on the keyword argument to be like \"this is where the value was actually sitting!  It's not wrapped in a variable reference!\"  I'm not sure a property is the right thing... but is it possible to make that distiction somehow to the compiler?\nIf so, why not just decide that as soon as you start to introduce keyword arguments, not wrapped in variables, but actually in the function call, in the argument list, that yes, we've now switched to passing in keyword/value pairs?\n... or is the above conundrum the whole crux of the problem and I didn't realize that until now? :)\n. Actually, is this even a problem at all?  Here's an interesting test in guile:\nscheme@(guile-user)> (define* (test-keywords #:key (ah 'yeah)) (symbol->string ah))\nscheme@(guile-user)> (test-keywords #:ah 'no)\n$15 = \"no\"\nscheme@(guile-user)> (let ((oh #:ah)) (test-keywords oh 'no))\n;;; <stdin>:276:17: warning: possibly wrong number of arguments to `test-keywords'\n$18 = \"no\"\nSo, both of these are functionally the same.  The only difference is that the latter gives a compiler warning.\nIf it's good enough for guile...?\n. Right, okay, I'm being dumb, because we can't do that in Hy, because we don't know what the value is by the time we get to putting together these expressions and generating the AST.\nSorry for being dumb.\n. I've submitted a version of this that supports both macros and function-call kwargs using the same syntax of :kwarg !  See #729 for details.\n. Since #729 (largely based on @Willyfrog's work here) got merged, we can close this!\n. @Willyfrog wouldn't have figured it out if it weren't for your clear initial work! :)\n. So how to do this?  I assume the problem is with hy/lexer/lexer.py, in this section:\npython\nlg.add('STRING', r'''(?x)\n    (?:u|r|ur|ru)? # prefix\n    \"  # start string\n    (?:\n       | [^\"\\\\]             # non-quote or backslash\n       | \\\\.                # or escaped single character\n       | \\\\x[0-9a-fA-F]{2}  # or escaped raw character\n       | \\\\u[0-9a-fA-F]{4}  # or unicode escape\n       | \\\\U[0-9a-fA-F]{8}  # or long unicode escape\n    )* # one or more times\n    \"  # end string\n''')\nSince leaving a string open on a line can't be lex'ed with this (it's either a complete string or it isn't) it's not surprising that it fails.  But I imagine not doing a \"complete open and close\" might get tricky because then we start interpreting everything inside the string as other tokens until the string is closed... is that right?\nI assume in rply there's no way to \"leave the string hanging open for now\"?\n. Similarly, here is the all or nothing section of hy/cmdline.py:\npython\n    def runsource(self, source, filename='<input>', symbol='single'):\n        global SIMPLE_TRACEBACKS\n        try:\n            tokens = tokenize(source)\n        except PrematureEndOfInput:\n            return True\n        except LexException as e:\n            if e.source is None:\n                e.source = source\n                e.filename = filename\n            sys.stderr.write(str(e))\n            return False\n. Killer work by @ALSchwalm on the fix!\n. I know nobody needs to add things to the debate, the debate is over.  But there's something learned in this bug, and I want to just note it here for future reference.\nI think after reading agentultra's comment here my feelings on this and related issues became really clear.  @agentultra made things really clear there, so I recommend just reading above.\nSo a year ago when I wrote the first draft of the tutorial in Hy, I added a section somewhat jokingly phrased: \"Hy is python flavored lisp (or vice versa?)\"\nIt's obvious to me now which side of that it goes: Hy is a lisp flavored Python.  But it's still Just Python\u2122.  This doesn't mean that it's not incredibly value-added... it is by a lot.  By getting a \"lisp flavored python\" you get a lot of cool things in that flavor... being able to design new language features with macros being the most obvious.\nIf someone really wants scheme or common lisp, those languages exist, people can use them.  But there's nothing else out there like Hy.  I don't mind supporting some like-my-favorite-lisp in officially supported modules (probably external).  But if we move away from Python semantics, we break expectations.  What's the point of being able to import .hy files in .py files if they don't act like Python?  Do we really want to go to great effort to lose the core of what Hy really is?\nI think we should get in a if-truth macro, either within Hy core or in a contrib module, and close out this bug.  But I suggest we also remember that lesson.\n. Since #519 is now closed and we have lisp-if support, I think we can now close this.\n. Unfortunately, this might fix things in python 2, but it breaks things for python 3.  All exceptions seem more or less broken in python 3.\n```\n  File \"/home/cwebber/devel/hy/hy/compiler.py\", line 305, in _raise_wrong_args_number\n    len(expression)))\nhy.errors.HyTypeError\nDuring handling of the above exception, another exception occurred:\nTraceback (most recent call last):\n  File \"/home/cwebber/env/xudd3/bin/hy\", line 9, in \n    load_entry_point('hy==0.9.12', 'console_scripts', 'hy')()\n  File \"/home/cwebber/devel/hy/hy/cmdline.py\", line 295, in hy_main\n    sys.exit(cmdline_handler(\"hy\", sys.argv))\n  File \"/home/cwebber/devel/hy/hy/cmdline.py\", line 283, in cmdline_handler\n    return run_file(options.args[0])\n  File \"/home/cwebber/devel/hy/hy/cmdline.py\", line 193, in run_file\n    sys.stderr.write(str(e))\nTypeError: str returned non-string (type bytes)\n```\n. The previous version was also a macro.\nMaybe we could make it so that pre-py3.3 uses a macro, otherwise we use the real yield from.  We could keep the (incomplete) yield from presently, but open a bug to expand the functionality for pre-3.3 to the the yield-from code.  What do people think?\n(also, oops, forgot to update the tests here.  heh.)\n. We could also expand out to a full implementation of yield-from for the older macro, though I think if we were going to do that, we should port over the cpython unit tests for yield from to hy and test against that.\nBut maybe that could be a separate bug, since we could also just use the simple yield-from for now.\n. Added back the macro version for older pythons, and added caveat to the docs that the macro version exists but does not fully implement things.  \nI also added #531 to reference the future-implementation of this backport.\nOkay to merge and close?\n. @paultag asked me to remove the conditional macro because it turns out we can't currently conditionally define macros, so the proper AST version never worked. Pushed, and rebased.\nI didn't squash the commits, though there aren't too many.  Someone is welcome to squash if they want to, or can pressure me to do so later.  Or paultag can hit that merge button for pycon reasons ;)\n. Will fix in a sec.\n. Fixed, and squashed it all down to one commit.\n. It turns out this \"always worked\" with the AST version of yield-from, it was just being blocked because we were always using the macro version of yield-from.  This bug is invalid, closing.\n. Well, my code was much more wrong for other reasons also.\n(if (is ~test True) ~success)\nThis doesn't make things lispy anyway, despite the two branches.  It shouldn't be if it's True... it's if it's not the equivalent of \"nil\".\nBy the way, what is the Python/hy equivalent of nil?  It seems to not be False actually, it seems to be None.\n. Given that confusion that this isn't actually testing for true, is \"is-true\" really the right macro name?  I think it isn't.  if-true is basically what my macro implemented (hence why the name caused me to not think correctly of what a traditional lisp expects anyway), but it really should be something like (lisp-if) (lif??)\n. Okay, I just pushed up a new commit that switches if-true to lisp-if, aka lif.  This actually implements what's expected in a lisp.\nNote, it only considers nil/None false.  Weirdly, this means that it does not consider False to be False.  While technically correct lisp-wise this is super weird to me.  I've thought of making an exception and making False also be falsey.  But technically, nil is the One True Falsiness, lisp-wise.\n. Updated the title to be more accurate.\n. I don't think there's any point to this if we do (if (truth?))\nThe whole point is to satisfy traditional lisp people who want an easy way to use an if that works the way they're used to.\nMy vote is: either we add this macro, or we decide that there's no reason to need this feature anyway.\n. Pushed your suggested change.\n. Squashed it all into one commit to make you people happier.\n. Note: comments on this are happening at #247 for now.  Confusing!\n. Okay, a few things done... I think it's ready for merge but someone should review...\n- added Foxboron's old tests.  I did it as a merge, so it does make the history kind of thready, but not any worse than recent stuff.  If someone wants to rebase, go ahead... I'm out of time for this one.  Tests seem to work though.\n- docs added\n- I discovered I was being an idiot about the (do) thing... don't ask.  So I switched (def main) back from a (gensym) to an actual (def main).  This means (defmain) will always produce a function named main.  I think this is a feature... this will probably help some people write tests.  I can be convinced to switch it back, though.\n- I switched it so sys.argv is (apply)'ed like (apply main sys.argv)... this way people can be really lazy and accept positional arguments in their main function if they like (and do [&rest args] otherwise).  I originally meant to do it this way.\nHope it's good enough... this was fun to do!\n. Removed directive.  Also added explicit (sys.exit 0) if no integer return value (note: I think this is the default, but now it's explicit... might as well be!).  I also documented this and added an example where the system exit status is 1.\nTime to merge? :)\n. Hm.  The second conditional I added broke things in certain pythons and not others and I have no idea why.  I think it might actually be a bug in Hy, but i have no idea what it would be.\nI took the lazy way out and used the implicit (sys.exit 0) that python does instead of declaring it in the else.  Everything's fine now.\n(That does make me worry a bit that there's some bug in Hy unrelated to this, but I don't know how it would be uncovered.)\nAnyway, tests are passing, it's documented, things seem good.  Now time to merge? ;)\n. Ah I see what you mean.  Yes that's true.  I can add that to the docs.\nrwtwolbert, if you want to see the failure, check out the commit at 809ceaf0a353576bbc823ce7da501732bf8365e6 and run tox.  I can't figure out the source of the issue.\n. Explicitly mentioned that bit in the docs about putting (defmain) last.\n. Fixed the typo.  Don't have time to do the squash right now... maybe later.  Someone else is welcome to do it, or merge it as-is.\n. Just squashed it.  Tests passing, seems good to go.\n. It looks like the with-decorator docs disappeared?  I'm assuming that's a mistake?\n. LGTM.  Merging!\n. I now doubt this will happen since we found out that it doesn't seem possible to conditionally define macros at this point.\n. Again, I'm happy to close it out if this is not an issue (also I know kwargs don't exist yet.)\nIf the (apply) example doesn't make sense, then consider instead a macro that does:\n`(print-valentines ~@string-user-input)\n. Fair enough.  Okay, I'm convinced that paultag's future valentine factory is safe from injections.\nSorry about the long-winded example, and thanks for the clear replies!\n. It looks fine to me, though it is incomplete IIRC.  If exceptions are called, they should be able to be propagated via the coroutine's .throw() method, correct?  I don't think this happens here?\nhttps://www.python.org/dev/peps/pep-0380/#formal-semantics gives a sense of how this works I think.\nWe could merge this as-is, but it would need to be documented that this functionality is not included.\n. @paultag is right and I am wrong.  Exception handling in the yield-from macro works as expected.  As such I merged @paultag's branch.  I also added a test to prove that paultag is right, so we know for eternity that exception handling is indeed working right.  (I also fixed some indentation on paultag's test while I was at it!)\nNice work @paultag!  I'm glad I was wrong, and impressed by the conciseness of the implementation!\n. Is it just Python 2?  Could we just make a Python 3 version of \"let\" only and have it be sane?\nI don't think clean language design should be held back by Python 2.\n. To whoever reviews: if it's agreed that this functionally works well enough, I can also submit docs.\n. Apparently Travis is failing here, but I don't understand why or what's happening with the unit tests.  I don't get what's happening in the output... could someone help me decipher that?\n. Yup @kirbyfan64, macros work as they did before!  Nothing macro-related is removed... this only happens at function-call level, as far as I can tell.\n=> (defmacro identify-keywords [&rest elts]\n             `(list\n               (map\n                (lambda (x) (if (is-keyword x) \"keyword\" \"other\"))\n                ~elts)))\n... ... ... ... => \n=> (identify-keywords 1 2 :foo)\n['other', 'other', 'keyword']\n. Are people happy with this direction?  Once I get a :+1: from another core dev I'll be happy to rebase and add docs.\n. Great!  Writing docs and doing rebase now.\n. Okay, I added docs and rebased the branch!\nThe part of the tutorial that documented apply got replaced with a clearer :keyword example, but I still think documenting apply is important, so I did so immediately afterwards as a way to reproduce *args and **kwargs argument passing from python.\n. @gknapp Keywords are added very recently, yes... the tutorial explains how to use them, but they aren't documented elsewhere.  I couldn't figure out where else I should put them, so I didn't.  (I know the domain of tutorial.rst well, but not the other files.)  Happy to add more docs if people have suggestions of where they go.\n. Nm, (bytes) works fine.\n. note that b\"fooo\" requires (bytes \"fooo\") which means this has to do a cast.  Which means this is a built-in \"solution\", but how much of a solution is it?  I'd be open to a reopening.\n. You're right, thanks for the catch @berkerpeksag !\n. I'm hesitant to make the tutorial longer than it already is.  I don't mean for it to seem onerous.\nI wouldn't mind having an examples section.\n. Now that we have keyword argument passing, maybe we could do some Django ORM examples?  That's something a lot of people are familiar with, and is very \"OO-looking\".\n. Oh holy awesome.  Just as I was complaining about things in #305!  Coincidence or are you just that fast? :)\nWill give this a test real quick.\n. I just tested and all seems to be working great here.  I'm :+1: on merging.\nMaybe someone experienced with rply should scan over real quick, but I've confirmed all works well.\nAwesome work @ALSchwalm !\n. @olasd ack'ed this, so that's good enough for me.  Merging!\n. I also don't think versioning Hy in-Hy is a good idea.  I think that's going to result in a load of spaghetti and we are going to hate ourselves in the end for it.  Need an older Hy?  Use an older Hy.\n@agentultra I think implementing as much of Hy in Hy is good, though I don't think we should drop all our support for \"use native Python AST where possible\" rather than implementing our own.  I think we'll start to hit speed tradeoffs and lose some of the value of what Hy is.\nBut maybe we could have a certain section designated as the \"hardened core\" and have the option of using just that and building on top of it.\n. I think there's no need for a future import... why not just include it as an option, then strongly encourage using the other pattern instead?\nI do think there are points in code where not using a (return) is hard, especially without abusing exceptions or resulting in nested ifs that aren't really ideal.  They're comparatively rare, but still.\nSome other lisps have ways of getting around this; for example, in Common Lisp I have blocks, so I can do\nlisp\n(defun foo ()\n  (block \n      got-result\n    1\n    2\n    (return-from got-result 3)\n    4))\nSometimes, especially in Python code, bailing out early is nice.  We should encourage other forms in Hy, but why prevent users from using this function?\nI might understand more if it breaks other complicated-scoping code, but is that really the reason?\n. Actually, it turns out common lisp sets up the function as a block, so:\n(defun foo ()\n  1\n  2\n  (return-from foo 3)\n  4)\n. Alternately, if other core developers decide \"there's no way forward\" or that this bug won't provide a useful dialogue, feel free to close it.\n. DrRacket seems to have even more debugging features, but how do those work?  How are you able to so easily set breakpoints and step through, from a GUI even?  What sorcery is this?  I'd love to hear more from someone who knows.\n. Note, @paultag says pdb will probably never be able to help with this.  But maybe hdb could?\nI don't know that tracebacks could be made easier but maybe at least hdb could make debugging nicer.\nWhat would it do?  I'm not sure, but a crazy idea is that it might write information about Hy lines to a hdb-readable-only object, or something?\n. Oh, I was making a joke about hdb, is there such a thing?\n. @kirbyfan64 The point about hy2py is really good.  Maybe hdb could have an easy \"py-l\" command which prints out where you'd be from a hy2py perspective if running \"l\" in pdb?  That could help, and would be easy to write I think.\n. @kirbyfan64 What was the surrounding context?\nAlso see #741 which I just filed... which either you saw, or we have serious zeitgeist going on here.\n. It seems hy-mode is in melpa, so that might make describing how to install with emacs easier.\n. It's going to sound strange, but try executing it as a file instead of in the interpreter.  It works in the interpreter as I showed above if you enter it line by line... I think because the last one inherits the name of the former anonymous one.\n. @paultag In fact (separate bug?) you can see that it's running the \"prior\" lambda.  In the same session as above, try this:\n=> (call-this :some-func (lambda [x] (do (print \"what\") (print x))))\nyup\n=>\nOops, it should have printed \"what\" too!\n. Looks like @zackmdavis fixed this in #796.  Closing!\n. Would we lose out on interoperability with Python's wonderful world of libraries (arguably Hy's biggest selling point as a lisp?)\n. @agentultra :+1: then!  Thanks for the explaination.\n. One alternative is to provide let to preserve backwards compatibility, but fully document that it's mostly broken and why it is unlikely that a real let will never exist, and not use it in any example code.\n. Which edge cases does it not handle?  I believed also that it was failling to handle exception propagation, but it turned out that this was not true (we now have a test that proves as such).  If there are edge cases not being handled, please submit test cases and file bugs!  Thanks! :)\n. Good point!  File a bug! :)\n. Haha, it's not intentional.  These lines are also known as \"Chris got so excited that things finally worked he committed without reading his own diff first\" or \"yes, this is why Hy has a code review policy\"!\n. Good point!  I think that can be refactored pretty easily.\n. @agentultra I've been thinking about how to do this.  There seem to be a few options:\n1. Leave it as it is.\n2. Replace with two separate functions, one that pulls out keywords and one that doesn't.\n3. Keep it in one function, and make it so that with_kwargs returns 3 things, whereas when that's set to False, it returns 2.  This requires modifying less calls outside the function.\n4. Switch the order of line 449 so it instead checks with_kwargs before it checks isinstance, which is probably faster if performance is the main concern.  Checking a boolean is probably fast enough.  In fact, this change is so easy I just made it in commit e852e9f!\n5. Simply add a nested \"if\" clause, but this doesn't make the code look any cleaner.\nThoughts?  None of these options feels \"super clean\" to me, but none of them seem so bad either.\n. There were inconsistencies all over tutorial.rst, updated everywhere in that file.\n. Okay, fixed.\n. Gah, fixed.\n. ",
    "mattfenwick": "Good point about s-expressions.\nI looked them up on wikipedia, clojuredocs, stackoverflow, and c2wiki, and got a different definition at each.  :(\nI don't know what the correct term is for something like (a b c), but I think it's important to save the word expression for things which can be evaluated to values.  \nThanks for the feedback!\n. No -- thanks for the link :+1: , it's quite helpful -- but I was looking for a terse, formal-ish grammar.\n. Cool, looks good.  Thanks for the response.\nJust curious -- will that be on the mainline soon?\n. ",
    "jonathanmarvens": "Dude, I really want to help, but I don't really know what to help with. I have knowledge about programming languages, but it's all just theory, so I'd love to help in an actual implementation (even if it's just for fun). That way, I can have actual practice while working on something cool. I currently don't know the Clojure dialect of LISP, but I'm pretty sure I can learn it very quickly.\n. ",
    "Kodiologist": "astoptimizer is no longer maintained, and its successor, fatoptimizer, is unstable and doesn't seem to be particularly effective (yet). Meaningful optimizations to Hy are always helpful, but hopefully they'll all be of the sort with no downsides that we can enable all the time, instead of requiring the user to enable them explicitly.. We have hy2py, and we now have a separate issue for py2hy, so I'm closing this.. I say yes. This is what we have hy.core.shadow for.. I'm going to close this in favor of #1103, since that's presumably the way forward.. I'm closing this in favor of the more general #351.. I believe these are some other manifestations of the same issue:\nhy\n(setv x 1)\n(setv y (+= x 1))\n(print y)\nThat should print 2, but it prints None.\nhy\n(setv l [\"a\" \"b\" \"c\"])\n(defn f [a]\n  (print \"hi\")\n  a)\n(setv y (setv (get l (f 0)) \"A\"))\n(print y)\nThat should print \"hi\" only once, but it prints \"hi\" twice.\n. Yep, it should stay open, in my opinion. Or maybe we should make new issues for each operator or function that exhibits this problem, if they're going to have to be dealt with piecemeal.\n. Now that setv returns None, we probably don't want the mutating operators to be any different, anyway.. #909 and #911 cover the only remaining cases, so we can close this issue.. I think the way macros and modules play together is now firmly established enough that we can say this isn't a bug. If you want the expansion of bar to be able to refer to a function foo defined in mac, you need to include (import [mac [foo]]) or something in that expansion. Otherwise, how could Hy tell that by foo you meant mac.foo instead of bang.foo?. > Inside a quasiquote, plain symbols are converted to namespaced ones. Each symbol is first looked up in the \"hy\" namespace, if it isn't there, it is attributed to the namespace in which the macro is defined.\nThen how would you write an anaphoric macro, or otherwise refer to a symbol in the module where the macro expansion ends up, rather than the module it was defined in?. Anyway, I don't think this is necessary now that we have selective forms of require.. I think what you're describing is orthogonal to the Lisp-1 versus Lisp-2 issue, which has to do with whether function names share the same namespace as ordinary variables.. I see. Well, I would always recommend against using the name of a builtin for something other than a builtin. Using a non-builtin function in the expansion of a macro currently requires including an import in the expansion (unless you're writing an anaphoric macro, of course). It would be nice to not have to do that manually. So I'd guess we'd want to make Hy automatically add the appropriate imports (and convert the call to invoke the module explicitly). Intuitively, this sounds like it would get complicated fast.. I don't understand this issue, so I'm going to close it.. We have string? and integer?, which do the job.. I don't think this is in scope for this repository. Whoever wants to write it should develop it as its own project.. /eg is gone as of  #1180.. This still doesn't work in 2017 with Python 3, but it just crashes now:\nhy 0.12.1+50.g741b9b9 using CPython(default) 3.6.0 on Linux\n=> (import [flask [Flask]])\n=> (setv app (Flask \"main\"))\n=> (setv app.debug True)\n=> (.run app)\n * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)\n * Restarting with stat\n/usr/local/bin/python3.6: can't find '__main__' module in '. Thanks for letting us know, Marisa, and sorry if I bothered you. Feel free to mute this thread, as mentioned in the email you got from GitHub.. Actually, the same sequence of calls fails with the same error in Python's own REPL. I'm going to close this until somebody can show an example that works in Python but not a recent version of Hy.. I don't think it will be any easier to implement this for Hy specifically than for Python in general. Hy provides only a thin layer over Python that's mostly gone by the time the program is running and you're doing introspection like this. The upside of this is that any such apropos function that works for Python should work for Hy, too, without issues. If not, the problem can be addressed by patching Hy, patching the apropos library, or writing a new library that depends on the old one, as appropriate. I'm closing this issue in lieu of these approaches.. It's still around. Here's a slightly simpler example. Create this file and call it `test1.hy`:\n\n(import sys)\n(setv foobar 15)\n(when (= --name-- \"__main__\")\n  (print foobar)\n  (print (hasattr (get sys.modules \"__main__\") \"foobar\")))\n\nhy test1.hy will print False, but hyc test1.hy && python3 test1.hy will print True. You also get True if you write the file in Python to start with:\nimport sys\nfoobar = 15\nif __name__ == \"__main__\":\n  print(foobar)\n  print(hasattr(sys.modules[\"__main__\"], \"foobar\")). Oh, wait, this is described better in #459. I'll close this, then.. Closing in lieu of more information, but feel free to reopen, @paultag.. #791 is a duplicate of this, but I'll close this one, sincer there's more discussion over there.. Closing in lieu of an explanation.. If you want to prevent something from being imported by `import *` without defining `__all__`, it suffices to begin its name with a single underscore. (You shouldn't use double underscores on both sides because that notation is reserved by Python itself for future magic names.) Is that good enough?. This issue can be closed now. `(defmacro a [&rest b]) (a 1 2)` returns `[1 2]`.\n\n. I have a macro geta in Kodhy that lets you write, e.g., (geta x 1 : 2) to mean x[1, :, 2].. In my opinion, this is one of several imperfections in Python's scoping rules, but trying to paper over it in Hy is a Bad Idea: we don't want to change Python's semantics more than we have to in order for the idea of Python-as-a-Lisp to work. After all, this leakage does have an advantage\u2014namely, that you can tell where the loop stopped\u2014so it's not as if we would be unconditionally better off without it.\nI'm closing this issue, but anyone who disagrees should feel free to reopen (or, better, open a pull request with a proposed implementation and tests).. This isn't a bug. Quoting a form preserves the literal syntax, without evaluating anything. '{\"a\" 1 \"b\" 2} doesn't equal '{\"b\" 2 \"a\" 1} even though they evaluate to equal objects, because they're not equal as s-expressions.. Honestly, your guess is as good as mine. Cons cells are a part of the language I've yet to touch.. The following works:\n$ mkdir d\n$ touch d/__init__.py\n$ echo '(print \"hello from math.hy\")' > d/math.hy\n$ echo '(import math) (print (math.sqrt 2))' > d/test.hy\n$ hy d/test.hy \n1.4142135623730951\n\nCreating a test file tests/native_tests/math.hy doesn't work with the new pytest-based testing infrastructure. Ultimately, this seems to be because the method pypkgpath in pytest assumes that packages have to have a file __init__.py in them, rather than, say, __init__.hy. I doubt this is worth trying to \"fix\" on the pytest side, and it's easy enough to avoid on the Hy side by not giving any of our test files the same name as a standard module, which is a bad idea anyway.. This doesn't work in Python 3, either:\n$ echo 'import x' > pypkg/__init__.py\n$ echo 'print(\"hello\")' > pypkg/x.py\n$ python3           \nPython 3.6.1 (default, May  1 2017, 14:17:25) \n[GCC 6.3.0 20170406] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> import pypkg\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"/tmp/pypkg/__init__.py\", line 1, in <module>\n    import x\nModuleNotFoundError: No module named 'x'\n\nIt works in Python 2, but is it worth implementing a Python 2-specific importing feature in Hy? I'm inclined to say no.. I agree with Paul. This isn't a bug. It could lead to a bug once we try to make hy2py create runnable Python code, but that's a separate, larger issue.. You're right, you can't. You can't even hide the break in a function like you can for raise. The closest equivalent is if False: break. In order for and and or short-circuiting to work for break (and presumably for some other constructs like continue), they'll need to be translated to if-else constructs, I think.\n. Whoops, this is a duplicate of #233.\n. Overall this seems to be more of a virtualenv pitfall than anything we should be trying to fix in Hy, so I'm going to close this issue.. With syntax like (defn f [[a int] [b int]] (print a b)), I don't see how you'd distinguish an optional argument from a type hint.\n. Tested in test-apply-op.. Yeah, I was thinking of doing a PR for this after #1261 is in.. Can you describe your use case in more detail, or provide a simpler one? It's confusing to me that you'd want to shadow apply, and I don't know anything about Hypothesis.\n\nIs there any reasoning not to have all such hy functionality shadowed?\n\nYes, some special forms couldn't reasonably be shadowed, such as setv and while.\n\nIs there any list of hy api components not availible as functions?\n\nNo. If you want to make such a list, you can compare hy.core.shadow to the @builds(...) decorators in hy.compiler, which define special forms, and the macro definitions in hy.core.bootstrap and hy.core.macros.. @ekaschalk I still don't understand your example, perhaps because I'm unfamiliar with Hypothesis. In particular, what object is the sharp macro $ producing that evidently has a method named map?. Okay, if I understand correctly, you're trying to do the following:\n(=\n  (.map obj (fn [&rest args]\n    (apply (fn [x unpack] (+ x (reduce + unpack))) args)))\n  obj2)\n\nIf I'm not mistaken, that could be written more concisely as:\n(=\n  (.map obj (fn [x unpack]\n    (+ x (reduce + unpack)))\n  obj2))\n\nOr, yet more concisely,\n(=\n  (.map obj (fn [x unpack]\n    (sum unpack [x])))\n  obj2). Try using parameter unpacking:\n\n=> (tuple (map (fn [[x unpack]] (sum unpack x))\n...             [[[1 2] [[1 2 3] [1 2 3 4]]]\n...              [[2 3] [[2 3 4] [2 3 4 5]]]]))\n([1, 2, 1, 2, 3, 1, 2, 3, 4], [2, 3, 2, 3, 4, 2, 3, 4, 5]). > Is this documented anywhere\n\nI don't know. To be honest, I hadn't realized the feature was removed from Python in Python 3 (PEP 3113) and that Hy does the destructuring itself in compile_function_def.. I would expect shadowed get to work like getitem. The obvious implementation is something like\n(defn get [thing &rest keys]\n  (for [k keys]\n    (setv thing (get thing k)))\n  thing)\n\n. > No, the obvious implementation is from operator import getitem as get.\nThis would fail to emulate get with more than two arguments.. No, nobody has worked on this since. Presumably @berkerpeksag marked it good-first-bug on the assumption that you'd either use a method like Kirby suggested or use pylint. But in any case, I'd tend to think it's not a very good first bug.. This one's still around as of 5bf9ecfc5a40821eb15e2ac7f218ae276f81fa60. That said, I'm inclined to think yield-from on Python 2 isn't worth supporting, so we should remove it rather than fix it.. I'm closing this in favor of #848.. A simple way to reproduce this (on Python 3) is:\n$ echo '(print \"LOADED\")' > test.hy\n$ hy\nhy 0.12.1+101.g5bf9ecf using CPython(default) 3.6.1 on Linux\n=> (import test)\nLOADED\n=> (import importlib)\n=> (importlib.reload test)\n<module 'test' (<hy.importer.MetaLoader object at 0x7f1b0e9badd8>)>\n\n\"LOADED\" should appear twice, but only appears once.. Shouldn't this issue stay open? The bug remains in Hy master.. According to the discussion in #568, this behavior is intentional.. Provided by #1279.. Apparently, nobody cared enough to fix the merge conflicts. Feel free to make a new PR out of this if you want to do it.. The bytes function doesn't really replace bytestring literals. For example, suppose you want b\"\\xa0\". As of Python 3.5, (bytes \"\\xa0\") raises TypeError because of the lack of an encoding, and (bytes \"\\xa0\" \"UTF-8\") produces b\"\\xc2\\xa0\". So you actually need (bytes [160]) or (bytes [0xa0]).\nI played around a bit with trying to implement bytestring literals. The tricky part is that on Python 3, HyString inherits from str (and HySymbol inherits from HyString). We'll probably need to make HyString a bit more abstract so that it can represent both literal bytes objects and literal str objects (and continue to represent literal unicode objects under Python 2).\n. Whoops, this is a duplicate of #495.. Looks like the nays have it.. I'm thinking of the simple approach to this, which I don't think has been mentioned yet: add a (return \u2026) form, which takes one optional argument and compiles to a return statement in the obvious way, but leave all the rules about implicit returns as they are (except that a form ending in (return \u2026) need not have an implicit return added after it, of course). The implementation of this may lead to complications with our logic that turns off implicit returns when there's a yield in a function for old Pythons, but hopefully I can work around that.. This probably isn't worth implementing before 1.0 is out and we've added major features since then, which aren't in 1.0.. No, unfortunately we don't. Our developers are too unpredictably available for such a plan to be realistic.. I can't reproduce this, but reopen if you can.. I'm closing this in favor of #605.. This works now..  The \"simpler example\" above now works. I believe the underlying bug is covered by the a-list test in native_macros.hy. Could you close this, @gilch?\n. I don't think the original is any less correct than your proposal.. I say yes; it would be a huge amount of work for almost no benefit.. Paul pointed out that you can hit this with a standard Python module, string:\n=> (import string)\n=> string.digits\nAttributeError: 'function' object has no attribute 'digits'. Tested in [`test-try-else-return`](https://github.com/hylang/hy/blob/eeb0be8fb0bdbd9d7d23dc908be2d24d4e475d0a/tests/native_tests/language.hy#L1174).. Looks like everybody's happy here.. Seems like everybody's happy here.. I don't think we support Cython, anyway.. You can try whatever you want. I just can't guarantee it will work, and we probably won't fix Cython-specific bugs.. `(import lxml.etree)` works for me, too, with PyPy 5.4.1+dfsg-1 on Ubuntu 16.10. I'm closing the issue.. This can be closed. Nullary `and` and `or` now work, and are tested in native_tests/language.hy.\n\n. I think this is correct behavior. (string? :keyword) is interpreted as trying to calling the function string? with a keyword argument keyword, but you didn't provide a value for it, hence the exception Keyword argument :keyword needs a value. You can still do (setv x :keyword) (string? x); that works fine, and returns True. Is it really worth making string? into a macro to cover the specific and not-very-useful case of trying to call it on a literal keyword?. Keep in mind that using a callable keyword literal to a higher-order function would require quoting it, since (map :key foo) would be interpreted as map(key=foo).. Man, I completely forgot that was implemented. I wonder if it's even documented.. But keywords are available in macros. Do you just mean that macros can't have keyword arguments (in the Python sense of the word \"keyword\")? In that case, yes, #1581 doesn't change that as #1581 currently stands.\n\n\nKeywords as (invalid) strings are kind of weird. They're awkward in macros.\n\nWhy is that?\n\nThis is no longer the case since #1543. What was annoying about it was that it meant keywords didn't evaluate to themselves (as in other Lisps), and so you had to distinguish between HyKeyword objects and the result of evaluating a keyword, which was a string distinguished from ordinary strings by its value rather than its type.. @gilch's argument seems even better now that nil is gone in place of None. That said, I never use lif myself, so I can't say I have very strong preferences here.. Fulfilled by #1626.. Seems as good a place as any. The documentation is poorly organized, anyway. You could rename the section \"Notes on Syntax\" to \"Literals\" and go from there.. That sounds fine to me. Also, if you're going to continue working intensively on py2hy, it will be more convenient for it to be in another repository where you can push at your leisure, instead of here where you need two approvals for every change.\nNote that I recently implemented return, although it's not merged yet (#1380).. > While that's going on, would it be OK for me to push this on PyPI? I haven't pushed to PyPI before but I was wondering if it wouldn't cause unwanted conflicts with Hy.\nSure, that shouldn't be a problem.\nI would advise you to make sure that the bytecode for your Hy code is either included in the source package (and the wheel, if you make one) or generated at installation time. Bytecode makes a big speed difference, so you don't want the user to install the code in a place where only the superuser can write without the corresponding bytecode.. Since this feature request is being fulfilled as a separate project, at least for now, I guess we should close this issue.. I'm going to close this since #356 is about the same thing.. nil is gone as of #1156. Are you interested in resurrecting it as some kind of empty iterable object? Or do you just want to change the default \"else\" value of if?. Pinging @glich.. Do you want to keep this PR open, Gilch?. For what it's worth, I think True and False are better than true or false, merely because that's what Python does. But T and F are even better. I am perfectly okay with keeping the original True and False despite the redundancy, because sometimes it's nice to be able to be more explicit, but I wouldn't mourn them much if they were removed, either.\n. So it looks like folks' preferences are:\n- For T and F: gilch, algernon, me\n- For true and false: kirbyfan\n-  For True and False: arrdem\nI think T and F are the closest we have to consensus, unless anybody else wants to pitch in.\n. If we're not doing T and F, True and False seem better to me than true and false. All other things being equal, it's better to imitate Python than Clojure.\n\nIt's not like we're asking the user to memorize dozens of obscure one- or two-character names like in Ruby and especially Perl.\n\nI don't know about Ruby, but the only two-character names a Perl programmer needs to know are $_ and @_, and the only one of those you really need to know is @_. (I don't think there are any built-in one-character names, unless you count operators, like * and x.)\nI've noticed Python programmers talk about Perl a lot, usually as an example of what not to do, but it seems that most people who complain about Perl don't know it very well in the first place.\n. @gilch Years ago, I was a Perl 6 developer, but I eventually lost interest when I felt it simply wasn't getting anywhere. The odds were too far against it from the start because of the sheer variety of features that were desired for the core language. It's a victim of the second-system effect (even though Perl was big and ugly (and proud of it!) to begin with).\nPerl 5 is still alive and well even though it's much less popular than it was in previous decades, presumably from competition with Python, Ruby, PHP, and even JavaScript now  that server-side JS is a thing. The famous camel book, Programming Perl, deserves its good reputation. You might also want to check out Modern Perl. I haven't read it, but I understand that it makes a clear case for how Perl ought to be used in modern times, in contrast to the troublingly common practice of writing Perl in the 2010s as if it were the 1990s (using local where my would do, calling every user-defined subroutine with &, not using strict, not using English, etc.). The Perl team's heroic successes in maintaining backwards compatibility has the side-effect of enabling this kind of thing. Of course, in the Python world, we have a similar problem, of the community kicking and screaming to resist the pretty minor backwards incompatibilities of Python 3.\nBack on topic. Ideally all serious Hy users would show up here and we could poll them all, but since that's not happening, I guess we should give Paul the deciding vote. Besides, this is clearly the sort of ugly bikesheddy issue where reaching a decision at all is more important than what choice we make.. @gilch If you want to review #1156 and approve it, I think we can merge it and then close this issue, unless you want to wait a bit longer to see if anybody else votes, or something.. > So what's the status here?\nYou mean @gilch's proposal 2? Nobody's been working on it that I know of, but not for any special reason. I like it, for what that's worth. Or at least, I'd appreciate an optional feature that requires you to declare variables before you use them and checks this at compile-time, like Perl's use strict 'vars'.. I believe that that's the proposal 2 I was just talking about.. I guess I like Option A the best. Using sigils in Lisp is always a bit weird.. Does #1050 meet your need here?. Yeah, I think going by our new policy for hy.contrib, it should stay in hy.contrib for a while, till it's been battle-tested and we're fairly sure we like it how it is. Then we can move it to core.. Is hy-repr sufficient for this? It uses Hy syntax, but doesn't generate indents or newlines.. > IIRC the result of macroexpand is already formatted correctly\nNot with repr, since HySymbol.__repr__ quotes the symbol like a Python string:\n=> (macroexpand '(+ 1 2))\n('+' 1 2). Perhaps `hy-repr` should have an option for adding appropriate whitespace. Or Hy could have a separate pretty-printer that takes code as a string.\n\nHydiomatic's last commit was over a year ago, so any code stolen from it would probably need updates.. Okay, I think those could be reasonable compromises.. Is eval-when-compile, which we now have, equivalent to what you asked for here?. I was wrong; eval-when-compile doesn't expand to anything, so it doesn't do this. It's only for changing the state of the compiler, presumably to affect macro expansions.. I think you want eval-and-compile, not eval-when-compile.. I don't think it makes sense for us to try to make this sort of thing (importing a core module as a string) work. In your case, it's probably the build system that needs patching.. @berkerpeksag approved this and so do I, so that's two, so I'm merging, even if we're a few months too late for this pull request's one-year anniversary. It's a very small change and has obvious utility. That said, I'm still happy to consider any PRs for alternative approaches to the same problem, such as @algernon's suggestion.. nonlocal is important, but I don't think new features for Python 2 are worth the maintenance overhead, let alone the effort needed to implement them to begin with. People should be switching to Python 3.. GitHub no longer supports this, so at least it's not broken anymore!. Common Lisp's intern function is about package variables, not local variables. The Python equivalent of a package variable is a module global variable, which is set or get with getattr(module, \"variable\") or globals()[\"variable\"]. I don't think a shortcut for one of these one-liners would be of much use, but reopen this issue if you disagree.. You can also just write (setv addition (inc-decorator (fn [a b] (+ a b)))).. Hy has no equivalent to fn for classes, but you can say (setv MyClass (mydecorator (type \"MyClass\" (,) {...}))).. @huckl3b3rry87 It doesn't look like you're using Hy. This is the GitHub repository for Hy, so it's not the place for your question.. Since Hydiomatic does this, I think we can close this issue.. I guess the simplest approach would be to give money to @paultag and leave it up to him how to spend it. Right now, I don't think we have any hosting expenses (since we're using gratis sites like GitHub), and we can't expect to get enough donations to support a developer working full-time (that would be something like 15k USD a year at minimum). Maybe we could use money to send developers to conferences.. Yeah, I don't like it, either. Let's close it.. It seems at home there to me. Namespace pollution isn't an issue now that we have selective macro import.. Yeah, I think we can close this.. I've verified that the tutorial is currently up to date. In the future, the code samples there, like elsewhere in the documentation, should be checked automatically (#1019).. This feature was removed in #1590.. I've confirmed that the bug still exists, and there are no merge conflicts, but trying to launch Hy (with Python 3.5.2) raises AttributeError: 'FullArgSpec' object has no attribute 'keywords' in macros.py. Want to update it, Ryan?. Do you think that's a limitation that we should report upstream to the Python folks?. > Might still run it by python-ideas though.\nI think you should. If the idea is shot down, then apparently, we'll have to restrict ourselves to parameters that are legal Python identifiers. If it isn't, then we can open an issue to remind ourselves to fix this bug once Python allows us to. . Yeah, we'd have to gate the tests for this by Python version.. Since nobody's been able to reproduce this bug, I think this PR can be closed.\n. The bug still stands as of 11481ab, and it's pretty darn mysterious.\n. Yeah, that should suffice. I knew GUIs were good for something.. It doesn't look like any core members have approved this. While it would be great to have docstrings, I don't want to have the same documentation appear in two different places in the codebase, like @kirbyfan64 was talking about. I think we need to have a way for docstrings to update the manual  (e.g., #1044) or vice versa. Copying and pasting is no good even as a temporary solution.. Actually, I'm inclined to think this a bug; if we need to import a name that isn't a Hy builtin, it should be imported with a gensym. But it would make sense to make HyList etc. builtins.. Gilch (https://github.com/hylang/hy/pull/1360#issuecomment-320123883) mentioned that HyCons isn't auto-imported in the way that the other Hy model types currently are. I'm guessing that's just an oversight.. Hey Tuukka, it looks like everybody's happy with the new code, but I don't think we can in good conscience kill the old defmulti unless we know nobody's using it. I recommend simply reverting the relevant deletions, and having both defmultis coexist for now.. @gilch Eh, good point. Shall I merge?. I believe the underlying bug could be titled \"setv may try to return an lvalue that no longer exists\". The issue is that in general, we allow setv to return its lvalue, but some assignments, such as assigning the name attribute of a BeautifulSoup element that we're accessing by attribute at the same time, will make the lvalue invalid.\nA minimal example with Beautiful Soup is:\n```\n(import [bs4 [BeautifulSoup]])\n(setv root (BeautifulSoup \"\" \"xml\"))\n(setv (. root meek name) \"defl\")\n```\nThis throws AttributeError: 'NoneType' object has no attribute 'name'. The equivalent Python doesn't produce an error, because there's no attempt to access tco.meek.name after the assignment:\nfrom bs4 import BeautifulSoup\nroot = BeautifulSoup('<meek/>', 'xml')\nroot.meek.name = 'defl'\nSo long as we allow setv to return lvalues at all, I think the only way to fix this is to make sure it only tries to do this if the user actually tries to use setv's return value.\n. It isn't. Nobody's working on it right now.\nSpeaking for myself, I have no interest in this feature and hence no plans to add it. I did get rid of let, though.. rcarmo has left the building.. You're missing a lot of bugfixes and performance improvements if you stick with an old version. Remember that it's easy to write let as a macro that works in 99% of actual use cases. It's because we can't get the semantics exactly right, due to Python's scoping rules, that we removed it.. @rcarmo Currently, comprehensions in general are being overhauled; see #1437 and #1468.. @gilch How are we doing here?. Since there's been no progress on this PR for about a year, I'm going to close it. Feel free to reopen it once work has resumed.. > compile with hyc and get a normal .pyc file. Import said .pyc. Does this still work?\nYes, it does.\n\nDo you have to install Hy too, or does the .pyc include that?\n\nUsually, you will need Hy, because if you use any of a variety of Hy's builtins, an approriate import statement will be added to the top of the generated Python code.. I'd recommend appending the Git hash or a 7-character prefix. That way, the version number alone tells us exactly what commit a user is running.\nRegarding the \"0.12a0\" style, what would increment the alpha number \"a0\"? How would one translate from alpha numbers to commits?\n. > I don't think we can just hardcode the git hash in the version string, since the hash doesn't exist until after the commit has been made. Perhaps there is some way for Python to generate it programmatically though.\nRight. I figured the way to do it is to call git log -1 --format=%H at build-time, putting it in a generated file.\n\nHave you seen any other projects that can do this?\n\nCataclysm DDA comes to mind. That's C++, though.\n. I think the need's covered.. #1126 is the issue for this now.. Provided by #1269.. @gilch That's not a bad idea, but it's worth its own PR.\nAt any rate, it seems that consensus is against this PR, at least as it stands.. I think you could rewrite this to use setv internally rather than let, so that it's unaffected by let's removal.. Closing, since changes don't seem to be forthcoming.. I think the question is, should (defn ~x [] ...) work when x is just a str or unicode? That is, should strings automatically be wrapped to HySymbols in this context? Since defn is currently just a macro that uses setv, we may as well ask the same question of (setv ~x ...) while we're at it.\n. The parity version of variadic XOR is the only one I've seen in a programming language, and is both commutative and associative. (You said that \"(xor a b c) is not (xor (xor a b) c) in general\", but unless I'm missing something, this is indeed true for the parity version.) I don't know why anybody would expect the one-hot version.\n. > The parity xor has no possibility for shortcutting behavior. Therefore, it's not a branch control form like and, cond, if, and or. It's just a function. So why go the the trouble of returning the last true or last false input instead of a simple boolean?\nReturning the input value instead of a Boolean isn't (just) for flow control; it's so you can do things like (setv dessert (xor cake ice-cream)). But the chief reason it strikes me as important is that otherwise, we would have a needless surprising inconsistency of xor with the other logical operators.\n\nHave you seen another language that actually does this?\n\nNo, but there aren't many languages that have a built-in logical (as opposed to bitwise) xor operator to begin with, perhaps because of the influence of C.\nI seem to have overseen the most important reason to prefer the parity version of variadic xor: because it satisfies (= (xor x1 x2 x3 \u2026 xn) (xor (xor \u2026 (xor x1 x2) x3) \u2026 xn)). That is, it's what you get when you iterate binary xor, so xor is generalized to more than two arguments the same way or and and are.\n. Since nobody likes this PR except me, I'll put it out of its misery.. I was just reading a logic textbook (Wolfgang Rautenberg's Concise Introduction to Mathematical Logic) that points out that exclusive or is equivalent to addition modulo 2. This makes the parity interpretation yet more natural, since we already treat (+ a b c \u2026) as a + b + c + \u2026, and the latter with the addition performed modulo 2 is a parity detector.. I noticed when I was reading hy.core.shadow this weekend that + demands an argument but * doesn't. That is, we provide the empty product but not the empty sum. I thought about it and realized that the problem with nullary + is that Python uses + for both addition and concatenation, so in a nullary context, we should return [], (), \"\", or 0, but we can't know which. It seems best to just disallow nullary +. So I think the shadowed version is right and the operator version is wrong.\nFor /, there's again inconsistency between the operator (which returns 1.) and the shadowed version (which requires two arguments). It's not clear which is right, though. I'm leaning towards requiring the arguments, because although 1. is the only sane value for the \"empty quotient\", I can't think of a context where asking for an empty quotient wouldn't be a mistake.\nFor -, the operator and shadowed version both require an argument, which seems fine, but not consistent with allowing nullary / if we decide to keep doing that.\nHere's what some other Lisps do for - and /:\n- In Clojure and Common Lisp, both - and / require an argument. Unary / is allowed, and returns the reciprocal.\n- In Emacs Lisp, nullary - returns 0, but nullary / isn't allowed. Unary / returns its argument unchanged.\nI think we should follow Clojure and Common Lisp. (We already have unary / return the reciprocal.)\n. > You could make the same argument against *.\nThe difference is that 1 is the identity element for both uses of * (multiplication and replication), whereas 0 isn't the identity element for concatenation.\nWhat do you think about the cases of - and /?\n. Yeah, I think you've convinced me. Let's keep nullary + returning 0, and make the shadowed version consistent.\n. > What exactly is wrong with (.c x.a.b)?\nIt's fine when it works, but it doesn't work if x is any expression other than a identifier. (.c (foo 1 2).a.b) doesn't work (and it would be kind of confusing if it did).\n\nYou can also already avoid the syntactic sugar altogether with ((. x a b c)), which is easier to manipulate programmatically.\n\nThat puts the method after rather than before the object. I assume that the whole reason we have (.a x) is to avoid that, because of the preference for prefix notation in Lisp.\n\nThere should be one-- and preferably only one --obvious way to do it.\n\nThat principle has never been adhered to in Python, and Hy defies it even more blatantly, and for good reason. It's a fine philosophy for machine code, I guess (if you like RISC better than CISC), but human programmers benefit from having a wide variety of tools, just like human languages benefit from having a wide variety of words.\n. > It has been a major influence for Python itself (to Python's great credit), which is very clear when you compare it to a language with the opposite philosophy, like Ruby or Perl, which is widely derided as a \"write-only\" language.\nFor what it's worth, I've been a Perl programmer since 2005, and the rigidity of Python was the primary reason I resisted switching. I only switched once I found something even more pathologically eclectic, which is Lisp. So yes, I admit it, I am The Enemy.\nIf this PR is rejected and I still wanted the feature badly enough (I have found myself really aggravated that (.a.b.c x) doesn't do the right thing a few times over the past year or so), I could probably still wrap a macro around my files that implements it in Hy itself. But this seemed to me like an obvious bug in the implementation of (.foo \u2026) constructs that was better fixed once and for all then left for every new user to trip over.\n. > \u30ab\u30d0\u30cd\u30ea\nI beg your pardon?\n\nConsider what happens when you have to call a method in your access chain: x.a.get_b().c(an_arg). How should this look in Hy?\n\nI would use (.c (.a.get-b x) an-arg), so functions and methods go in prefix order as usual.\n\nClojure can do it with the .. macro: ((.. x a (get-b) c) an-arg).\n\nI'm not familiar with Clojure, but that looks like it would accept arbitrary expressions except for bare identifiers, which are quoted. That seems confusing.\n\nIf you don't like Python's way, why such interest in Hy?\n\nOn the contrary, I think Python is quite a nice language, even if I don't like it quite as much as Perl. To be sure, I would like it a lot less if the Zen of Python were actually adhered to. But that shouldn't be held against the actual language.\n. @hylang Could somebody take a look at this?\n. Is this ready to merge?\n. @hylang Could some core members take a look? I think it's nothing complicated; just a simple solution to a simple bug.\n. I think this just broke:\nhttps://travis-ci.org/hylang/hy/jobs/166872848\n. You're right that that inconsistency is no good, but it can also be addressed by altering mangling rules as follows: the \"generated\" is or is_ is put after any leading underscores.. Although the practical use for this is slim, it would definitely be nice to have for the sake of completeness.\nTo be clear, you want this to not only prevent manging (e.g., hyphens to underscores), but also to allow things like spaces and parentheses in symbols, right? Then it's probably worth thinking about exactly what characters are allowed. For example, can ASCII nulls be quoted? And in the context of Unicode, does a backslash apply to a single character, a single glyph, a single byte, or what?\n. > Complexity has costs. Lisp gets its phenomenal macro powers precisely by being as regular as possible.\nI don't see how the proposal would interfere with macros.\n\nThe case for the third :^ syntax is much stronger, but I think we could come up with better options that don't require changing syntax.\n\nSuch as?\n. > (def T true  F false)\nI like this, although I would expect adding builtins with one-character names to rustle a lot of jimmies, so presumably this would have to be in a contrib module or not in core Hy at all.\n. Yeah, that's not very helpful without an easy way to include punned keyword arguments and regular keyword arguments in the same call. It also forces use of apply.\n. As I understand, HySet is supposed to represent set literals, not sets themselves. So having duplicates, having a fixed order, and deriving from HyList is fine. HyDict does the same thing.\n. I can't speak for Clojure, but executing the body exactly once makes no sense. How does that follow from the nonempty case, why would a user expect it, and when would it be useful? Raising an error makes more sense.\n. @zackmdavis @arrdem Do you approve of this PR? The thumb reactions you put on some past comments suggest so, but it's not clear.. @gilch So far as I can see, renaming for to doiter or doseq doesn't make the behavior of executing the body exactly once make sense. If Clojure does that, too bad for Clojure. So the issue stands even if for is renamed.. Awesome, thanks for doing this. It would also make sense to close outstanding pull requests (that aren't too complicated) before the release.\nIf #1135 is merged, you won't need to edit version.py manually.\n. We certainly haven't dropped support for 2.6 yet, and we intend to support 3.6 given that we're testing it and it's the newest stable Python 3.\nEdit: No, wait, by 2.6, I was thinking of 2.7. I'm not sure about 2.6.. Are we ready to make announcements? It would make sense to make a post to /r/lisp, for example.. Sure thing: https://www.reddit.com/r/lisp/comments/5ouno4\n(Huh, I didn't know that Twitter account existed.). I guess nobody knows how to do the Docker image or the Debian package, huh? Maybe we should just pass the buck on those, since we already have two official release channels, GitHub and PyPI.. @tuturto, if you do the last checkbox (writing release instructions), I'll handle a new release, say 0.13.0, around June.. I'm wondering if I should work on this, so we can get rid of apply, rather than fixing #647. Personally, I like the :* and :** syntax you introduced first rather than #-prefixed symbols, but I guess it shouldn't make much of a difference.. No, I mean making :* and :** magic, so you can write (f :* a :* b) or whatever. It doesn't require any changes to the reader; it's just another special case for how to interpret literal keywords when they appear in a function call. * and ** are crummy names for keyword arguments, so no loss there.. Good point. #* and #** it is, I guess.\n\nI'm also not certain how #1127 should look, but it seems like a similar idea, so it would be nice if they had common syntax.\n\nI assumed you'd use the identical syntax, like (setv [a #* b c] x) for a, *b, c = x.. Thanks for catching that, Gilch. I'd been ignoring Travis because of the nightly bug.\n. @gilch Travis is happy; is this ready to go?\n. Self-import doesn't work, either. Compare\na = 1\n\ndef f():\n   import foo\n   return foo.a\n\nprint(f())\n\nto\n(setv a 1)\n\n(defn f []\n  (import foo)\n  foo.a)\n\n(print (f))\n\nThe Hy version fails with a similar error.. > > 0.11.0-293-g34304c4-dirty when the working tree is dirty\n\nIs this part really necessary? I normally find it quite jarring when you edit a file and now your version ended up changing.\n\nFew things in this world are really necessary, but this seems useful to me so that we have a warning that the user reporting a bug has altered the code somehow. It may also catch a few of us slipping up (not that I ever make mistakes).\n. I'm not familiar with how Git hooks work, but keep in mind that we still want to generate it at build-time if we want to be able to flag the build as dirty.\n. @tuturto Do you have any concerns about #1135? version.py will indeed be there so long as you run setup.py before uploading to PyPI.\n. Yeah, I think that makes sense. (I want (. \"foo\" format) rather than (.format \"foo\") in this case because I want to put the bound method in a list rather than call it immediately.)\n. You're fast!\nFor completeness, I would add tests for 2.foo, \"hello\".foo, and [2].foo.\n. It looks like the test fails because 2.foo compiles, which happens because Hy interprets the 2 here as a reference to a variable named 2. Is that a parser bug?\n. I don't think there's any reason to use easy_install rather than pip.. I would recommend settling the issue of the names for True and False (#908, #1147) first. That's likely going to be another big ol' breaking change, like my require PR.\nI'd be grateful if you could merge #1105, too.\n. @paultag It would be awesome if you could return to #1147 so maybe we can settle this before 0.12.0.\n. All right! I think we're ready to go now.. I thought a bit about how __version__ will be handled in the case of installing from PyPI or downloading a GitHub tarball and I came up with these changes. I haven't opened a PR because I'm not sure if it's necessary or it will work. Let me know if you have any __version__ issues in any case.. > We should fix the bug introduced by #924 first.\nThat doesn't seem forthcoming, since both #989 and #1114 (in addition to previous, closed attempts) have run into trouble, and the bug has been around for over a year. In any case, it's a rather obscure bug that, so far as I can tell, only means that when you incorrectly call a macro that has a funny parameter name, you won't get a useful error message. I don't think 0.12.0 should be held back for it.\nIt would make sense to create an issue for the bug, though, since it doesn't seem to have one.. Making an old pull request break isn't a major bug. It need not even be a bug (your pull request may not have been properly adapted to changes in Hy). And even if this were a major bug, we have no fix in sight after over a year and several attempts, so if we wait for a fix, we could be waiting for another year. We're already nearly at the one-year anniversary of 0.11.1; we've waited far too long for a new release. Lastly, 0.11.1 already had the bug, so our new release won't be a regression. It will just continue to contain a bug that so thoroughly escaped notice by users that nobody's created an issue for it.. I don't think we need to settle the question of flip for this release, so everything should be ready. Shall we get this out before 2017?. @kirbyfan64 Are you happy with the changes I've made? Regarding the \"e.g.\" in the comments, zackmdavis thumbed your comment down, and I guess I agree with him, although it's not very important in any case.\n. Okay, I'll take a stab at the docs now that everybody's happy with the feature itself.\n. Done.\n. You're welcome. :)\n\nif we have a module with several macros that depend on each other, we either need to make sure all needed macros are actually required. This means that client code has to require them explicitly or with *, or that the macros themselves have to require them. This can make code somewhat ugly. What do you think, how big problem this is?\n\nThat's just the same problem as I described in \"Macros that call macros\", right? I think having the macros themselves require their dependencies is the right thing to do, as I said in the documentation. But you can reduce repetitive code by writing a function like:\n(defn require-me [&rest body]\n  `(do (require mymodule) ~@body))\nwhich you'd use like:\n(defmacro foo [n]\n  (require-me `(mymodule.repexpr ~n (raw-input \"Gimme some input: \"))))\nAnd in general, actually, if you're writing some code specifically to be a subroutine for one or more macros, it's more convenient and less error-prone to write it as a function than a macro.\n. a.2 seems to be handled correctly.\nBy contrast, 2.a should probably treat 2 as a literal instead of an identifier. In particular, 4j.imag doesn't work. Although, \"a\".join yields the error cannot access attribute on anything other than a name (in order to get attributes of expressions, use\u2026), so maybe this is intentional.\na/b and 1/2 seem correct.\nThe other cases are discussed in #1168.. I'm Kodi Arfer and I approve this message.\n. @paultag Any updates on this?. @paultag, are you arguing for T and F or True and False?\n. It makes sense to me that a programming language's most fundamental constants should have concise representations.\n. Making it a syntax error would prevent me from making (geti x : 1) in Hy work like x.iloc[:, 1] in Python.\n. Presuming our choice is between treating it as a keyword or as a syntax error, the only downside to treating it as a keyword that I can think of is that if you mistype a keyword argument :foo as : foo, you'll get an error at run time instead of compile time.\n. The two-core-approvers-other-than-the-submitter rule is a little tough when there's only four of us who are really active. Eight dubloons to anybody who can shanghai some fresh blood into core.. > I still think the rule is important.\nAgreed.\n\nIf you can talk to people on IRC that might help get things moving.\n\nThe IRC channel doesn't seem to be very active, but I guess the chief troublesome thing is that there are no logs, so I can't see what anybody's said when I'm gone. On the other hand, if there were logs, it would promote splitting the already limited community attention into the IRC channel and the mailing list. (Perl 6, which is much bigger, had a particularly bad version of this problem last time I checked, with completely different people on the IRC channel and the mailing list.) I'm inclined to say we should axe the IRC channel and promote heavier use of the mailing list. Mo' fora mo' problems.\n\nWe could also try to make assignments.\n\nThat's not a bad idea.. Ah, I had no idea how defclass is actually supposed to work. Feel free to rename this issue if you can think of a better description.\n. This shouldn't really be an issue with the new special-form parsing.. Very nice! I'll give it a closer look tomorrow. Don't forget about the 0-argument case. Have you tried it against the or tests we already have?\nWhile using the native or when possible is nice, it's not a big deal, in my opinion. It's not even obvious to me that it would actually be faster.\n. Turns out that we only have a few or tests already, in native/language.hy, and they do pass when I replace or with -or. But I found a case that fails:\n(print (list-comp (-or (< x 5) (foo)) [x (range 10)]))\nThis compiles to:\n:G_1235 = (x < 5)\nprint([(:G_1235 if :G_1235 else foo()) for x in range(10)])\nIf we replace -or with or, we get:\nprint([((x < 5) or foo()) for x in range(10)])\nArguably, this is more of a bug (or unavoidable Python limitation) in list-comp than -or. List comprehensions are always going to be second-class citizens in Hy compared to filter and map (short of automaticallly generating intermediate functions, or compiling list-comp to map and filter instead of a real list comprehension), because Python doesn't permit statements in them. So I'm inclined to just let this break.\nI think we should make a PR using this macro, or a HyASTCompiler method based on it, and using something similar for and. Would you like to do it, or shall I?\n. Knock yourself out.\n. Not really a problem for this issue, since #1152 doesn't create the bug I described.. Excellent! I think it should be supplemented by tests for both or and and that try using a variety of Python statements (e.g., raise, for, defclass) in the arguments. Would you like to write those or shall I? \n. The Travis failure is just Flake8 whining about whitespace, and in some files you didn't change. I'm not sure what that's about.\n. More tests: https://gist.github.com/Kodiologist/52da5fd25d558e31f2259e980d1945a1. It isn't. It's complaining about a bunch of files you didn't change, as in #1152.. I agree. The tracked .gitignore should be for files related to the project's own toolchain. Individual developers can ignore files that their own tools generate by using .git/info/exclude.. Maybe this is just a consequence of  #1174.. The most recent patch release is what's already on PyPI. Believe me, I'm as eager to get 0.12.0 out the door as you are.. My very unofficial guess would be: about a month from now. You can follow its progress at #1140.\nI'm going to close this issue, since #1126 is on the same subject.. @gilch I just searched for true, false, and nil in docs/style-guide.rst and I didn't find anything.. Good question. It's in the default of --ignore and it's mentioned in passing a few times in the Flake8 documentation. Perhaps it's a check that used to exist but has been removed.. That would be my guess.. Makes sense, I guess.. It seems to work for me. Can you get this to happen again if you uninstall and reinstall? Is there anything unusual about your environment? What versions of Python and pip are you using? Did you get any error messages while installing?. Python 3.5 should be fine.\nYour pip is kind of old, so you might want to upgrade.\nCheck out http://stackoverflow.com/questions/1550226. True, but that executes the code, which one doesn't always want to do.. Huh, I didn't realize that Bash here documents worked like files. I expected them to work like strings because that's what they do in Perl.\nAnyway, I guess supporting standard input would be nice if only because that's how most Unix filter-like programs work, like the GNU versions of cat, head, and expand.. Oh. Huh.. > Eg is useful as it shows some examples of how to use the language for various tasks. We could have a wiki, blog or something else too, but then the examples would be dead in a sense that they wouldn't be tested when hy itself changes.\nUnless I'm missing something, they already aren't being tested. I can see that several of them haven't been updated for changes in Hy.. @hylang/core Any other comments before I make a PR to rip these guys out?. \"Experimental candidates for the standard library\" isn't a bad use for contrib, I guess. Let's run down the list of what's there now and see whether it belongs:\n\n\nalias: I don't see why you'd put this in the standard library. I guess it could be useful for when you're maintaining a library and you want to change the name of a function or macro but keep the old name around for a while so people's code doesn't break immediately. But that's a pretty limited purpose. I say remove it.\n\n\nanaphoric: This should be ready for inclusion in the standard library, although it should probably require a require rather than polluting the default namespace.\n\n\nbotsbuildbots: Apparently a joke about the Portal 2 soundtrack (3f01ed5014). We ain't gonna need it. Also, it causes a test failure if you don't have an Internet connection.\n\n\ncurry: Undocumented and of dubious value. I say remove it.\n\n\ndispatch: Just a utility class used by contrib/multi, so it should probably be moved there.\n\n\nflow: Not tested, and sure enough, a glance at the code suggests that case and switch will evaluate their first argument once for every clause, which is unlikely to be desirable. I say remove it, but if anybody wants to fix and test and re-add case (and change it to a square-bracket syntax like cond), be my guest.\n\n\nloop: A replacement is in progress over in #1166. In the meantime, I guess it can stay in /hy/contrib.\n\n\nmeth: This seems to be specific to Flask, a web framework, so it should go.\n\n\nmulti: Stay in /hy/contrib.\n\n\nprofile: Stay.\n\n\nsequences: Stay.\n\n\nwalk: Stay.\n\n\nWhat do y'all think of that?. Why does this needed to be gated with an (import [__future__ [...]]) form? Does enabling it break anything? If so, that should be documented. If not, the feature should presumably be on by default.. > And the argument for this being gated, regardless of whether it breaks anything, I think boils down to the performance arguments made in the previous request #728\nI don't see what argument you're referring to. Could you quote it?. Okay, then, that warning needs to go in the docs. But we should also fix the bug you mentioned earlier before merging.. Great work. Now let's hunt for more bugs.\nWith Python 3.5.2, I added (import [__future__ [TailRec]]) to the top of tests/native_tests/language.hy and got HyTypeError: Empty list not allowed in 'try' from test_exceptions. Can you take a look at that?. This would fix #609.. This has stalled again, so I'm closing it for now. We can reopen it or start a new PR once work resumes.. Yes, I think that's fine. What's needed is to fix the outstanding bugs, and to make sure it merges into the current master without conflicts.. @adamfeuer Did you fix the bug mentioned here? More broadly, did you try all the the test files with TailRec enabled?. I guess I was too hasty to reopen this. Let us know when you're ready, @adamfeuer.. As an example from my own code, I'd like to write\n(.sort-values :ascending False (.append\n  (.mean\n    (getl obs1 : (filt (.startswith it \"race_\") obs1.columns)))\n  (pd.Series :index [\"race_hispanic\"] (.mean\n    (= (ss ($ obs1 race_hispanic) (pd.notnull $)) \"Yes\")))))\n\ninstead of\n(.sort-values\n  (.append\n    (.mean\n      (getl obs1 : (filt (.startswith it \"race_\") obs1.columns)))\n    (pd.Series :index [\"race_hispanic\"] (.mean\n      (= (ss ($ obs1 race_hispanic) (pd.notnull $)) \"Yes\"))))\n  :ascending False)\n\nor something of that ilk. It's annoying to have to strand the keyword argument and its value at the end, long after .sort-values .. > That said, there are cases when it doesn't work. For example, a builtin written in C might not have named arguments\nYes, and, aggravatingly, the Python documentation doesn't mention which methods and functions can't accept keyword arguments. Worse, it probably varies among implementations of Python.\n\nI need to double check how Clojure and Common Lisp do it.\n\nDunno about Clojure, but CLOS uses multiple dispatch, so there's no one specially designated invocant. In fact, there's no syntactic difference at all between calling a function and a method. I think this is the right thing to do in a Lisp, but trying to make Hy do it is out of the question because it would involve screwing with Python's name resolution rules.\n\nIf we do put this in Hy, I think there are some other things that also need to change to match.\n\nI'm not sure what you mean. What other things need to change?\nFor what it's worth, my old kwc macro that I used for calling functions with keyword arguments had this feature (it treated method calls and plain functions the same way) and I never hit any weird surprises with it.. Yep, that works in Hy (although not in Python 2, where it raises TypeError: unbound method doo() must be called with Foo instance as first argument (got nothing instead)):\n (defclass Foo [] [\n   __init__ (fn [self foo]\n     (setv self.foo foo))\n   doo (fn [self bar]\n     (+ self.foo bar))])\n\n (setv spam (Foo \"spam\"))\n (print (.doo Foo :bar \"eggs\" :self spam))\n\nWithout testing it too thoroughly, I would guess that this doesn't use the same method resolution order as (.doo spam).. Why does (dict :a-b 1) produce {'a_b': 1}, anyway? Are keywords already partly mangled if they happen to be used as keyword arguments?. And look at this disgustingness:\nhy 0.11.0+379.ged930ed using CPython(default) 3.5.2+ on Linux\n=> (defn foo [a?] a?)\ndef foo(is_a):\n    return is_a\n=> (foo :a? 3)\nfoo(a?=3)\nTraceback (most recent call last):\n  File \"/usr/lib/python3.5/code.py\", line 91, in runcode\n    exec(code, self.locals)\n  File \"<input>\", line 1, in <module>\nTypeError: foo() got an unexpected keyword argument 'a?'\n\n. They seem to be orthogonal issues to me. This issue is about what gets mangled, whereas #1173 is about, given a thing to be mangled, what we do to it.. Okay, you can merge them if you like.. Currently, I and another maintainer are thinking of removing eg/ from this repository (#1162), since none of that code seems to belong in the core language. Similarly, I suspect your contribution may be more at home in its own repository or in that of highlight.js.. Hmm\u2026 right now, the hylang organization has separate repositories for Vim and Emacs. That would suggest having yet another repository for highlight.js, but you do indeed have some code for listing Hy keywords that's more generally useful. I'm thinking perhaps we can use that for a standard module of Hy hy.keyword that gives the user a list of keywords, like Python's own keyword module. The stuff specific to highlight.js can live in highlight.js or its own repository, possibly under the hylang organization. I can probably take a crack at adapting your code into hy.keyword. How does that sound to you?. If my new PR doesn't meet your needs, comment there.. @profitware I gave you write access to the repository; can't you push to it yourself?. It looks like you haven't accepted the invitation yet. Try going to https://github.com/hylang/hyghlight/invitations. > I'm not sure I can be the one to merge this since many of the commits are mine.\nYou have my blessing to do that, for what that's worth. Let's keep things moving on the road to 0.12.. > Python since version 3.0 allows much of Unicode in its identifiers.\nBy Lisp standards, it's pretty idiosyncratic. For example, \u03bb is legal but \u2698 isn't.\nPunycode mangling seems to be broken or inactive at the moment, since '\u2698 returns \u2698, not hy_w7h as documented.\nI never use earmuffs, so I would support that removal. Lisps are traditionally case-insensitive, but Python and hence Hy is case-sensitive, so names in all caps are just fine.\nThe conversions of trailing ? and ! seem fine to me except for the annoyance you mentioned in #1115, and to be honest, I feel as if we ought to send a bug to the Python people pointing out that the inconsistency. It seems pretty obvious that Python should either have is_integer and is_lower, or isinteger and islower, but not one of each.. My understanding is that in most Lisps, any character other than the handful that have special meaning (like parentheses and whitespace) are legal characters in a symbol. By contrast, Python 3 permits only characters with certain Unicode character properties. See https://docs.python.org/3/reference/lexical_analysis.html#identifiers. I created http://bugs.python.org/issue29088.\n. It was closed in record time. I would've thought they could create temporary aliases to the old names if backwards compatibility was a concern, but hysterical raisins strike again.. That's how mangling is supposed to work. In Hy, you can write TEST as *test* whether you defined it originally in Hy or in Python. Would you have a name TEST imported from a Python module renamed to *test*, so that (import [foo [TEST]]) would be compiled to something like from foo import TEST; globals()[\"*test*\"] = TEST; del TEST; ? Then it would be very hard to access the imported name in Hy, because the symbol *test* wherever it appears in Hy code is translated to TEST: Hy's mangling gets in the way of accessing a variable actually named *test*.. The thing is that we have autoboxing for macro expansions, but not for eval. So (eval `~\"a\") raises an error (Exception: Unknown type: `<class 'str'>') but (defmacro m [] `~\"a\") (m) works fine.. @kirbyfan64 I'm thinking you're right. More precisely, ~ and ~@ inside backticks should recursively autobox their arguments. I can't think of a case where you wouldn't want this to happen. Note that we'll need to keep the existing autoboxing feature, too, in order for things like (defmacro m [] (setv n (+ 1 1)) n) (print (m)) to keep working.. Come to think of it, we might as well go even further and just have the evaluator itself autobox. That would eliminate this kind of problem once and for all.. Note the following:\n=> (eval `(repr ~\"a\"))\nTraceback (most recent call last):\n  [...]\nhy.errors.HyCompileError: Internal Compiler Bug \ud83d\ude31\n\u2937 Exception: Unknown type: `<class 'str'>'\nCompilation traceback:\nNo traceback available. \ud83d\ude1f\n=> (eval `(repr ~[]))\n'None'\n\nWhy doesn't a list create the same error as other non-HyObjects? Because lists are treated specially by the compiler: see compile_raw_list, which is decorated @builds(list). This seems to mean that we can't make the compiler autobox lists without replacing the usage of lists here with some other bespoke datatype.. Point-free programming is nice in Haskell, where support for it is baked deeply into both the syntax and semantics, but in Hy I've found myself happier just using anaphoric macros and lambdas, so I don't see myself getting much use out of any of these. And flip seems the least useful of the four. Does anybody have an example of where it would be nice to have?. Enthusiasm for flip seems low, and we have the other three now, so I'm going to close this issue.. I believe readline should always be installed. It's a standard module. Was your environment perhaps corrupted somehow?. I agree that Clojure's order is the right one, since in mathematics, (g \u2218 f)(x) usually means g(f(x)).. The idea is that the identity function is the identity element for the composition operator. That is, (comp f identity) is equal to f. That's why it's the right choice for the nullary case.. @gilch I think a benchmark or example showing an improvement should be a minimum requirement for a performance-motivated change.. Yeah, the nested for loop is needlessly weird. I'd write your version, @pyx, without the extra variables, like this:\n(defn comp [&rest fs]\n  (if (not fs) identity\n      (= 1 (len fs)) (first fs)\n      (fn [&rest args &kwargs kwargs]\n        (setv res (apply (get fs -1) args kwargs))\n        (for [f (reversed fs)]\n          (setv res (f res)))\n        res)))\n\nThis has similar performance to @gilch's version.. Oh, right, whoops, I meant (cut fs -2 None -1), not (reversed fs).. @pyx, this PR is for only the three functions named in the title. Those should be in their own PR if you want them.. @pyx Wait until this one is merged. Not because of a merge conflict, but because pipe depends on comp.. @gilch I sort of regret even bringing up the subject of benchmarks because any discussion about performance is speculation outside of profiling a real program. Premature optimization is the root of all evil. Anyway, in my opinion, any of the three versions is fine for now. Do you approve this PR?. @kirbyfan64 Good thinking; comp not is shorter than complement, anyway.. > If I remember correctly, you have an issue or milestone regarding this and in, etc. But it does not work as of today.\nYes, #1103. I'm guessing it will be pretty straightforward.. Should now be fixed.. From the comment @kirbyfan64 linked to, it looks like the bug is in pyenv on Mac OS not requiring GNU Readline, and thus producing a broken Python.. @kirbyfan64 Ugh, fine.. @rwtolbert, I disagree. Each of the commits is a logically separate change.. The new require syntax is a feature of bleeding-edge Hy (which should be released as 0.12.0). try-hy uses 0.10.1.. You can find the documentation for the latest stable release at http://hy.readthedocs.io/en/stable/ . To answer your question, in the latest stable release, just say (require hy.contrib.multi) and that will import every macro in hy.contrib.multi.. It's great that you ask, since the documentation needs work but nobody's paying it much heed at the moment. Just fork this repo, make your changes in a new branch, and open a pull request. The docmebro tag ( https://github.com/hylang/hy/labels/docmebro ) shows open issues about documentation.. Whoops, this site has its own repo (https://github.com/hylang/tryhy). I'll close this issue.. Whoops, this site has its own repo (https://github.com/hylang/tryhy). I'll close this issue.. After thinking about this, I'm actually going to suggest kind of the opposite of this change, which is to stop shadowing comparison operators at all. The problem is that comparison operators can short-circuit, but a pure function can't; you need a macro for that. So it seems to me that (setv f <) should just be an error, since we can't possibly make this do the right thing.. Hmm\u2026 my inclination right now is to keep on shadowing these operators, and to add shadowing for other possible short-circuiters like and. A user who's clever enough to try to use < or and as if it were a plain function should also be clever enough to see that (setv f and) (f (g) (h) (i)) can't possibly short-circuit. It's probably worth a mention in the documentation, but overall, I'd rather provide a logical feature with somewhat counterintuitive consequences than withhold the feature and force people to write boilerplate lambdas. Sorry I'm being so wishy-washy.. I've having a lot of trouble understanding your description. Are you trying to request a new feature or report a bug? If the former, how exactly should the proposed feature work? Why are your examples missing names for the new macros? Are you aware that multiple &optional keywords in one parameter list is currently illegal, and if so, what semantics are you proposing for them? And so on.\nPlease edit your issue to be more precise.. I've having a lot of trouble understanding your description. Are you trying to request a new feature or report a bug? If the former, how exactly should the proposed feature work? Why are your examples missing names for the new macros? Are you aware that multiple &optional keywords in one parameter list is currently illegal, and if so, what semantics are you proposing for them? And so on.\nPlease edit your issue to be more precise.. Yes, thank you, that's much clearer. Using a problem to motivate a feature request is fine; it's just that you have to clearly state the feature that you want, too.\nMacro definitions can't use &kwargs, by the way.\nIn bleeding-edge Hy, multi-arity functions are available as a macro named defn in hy.contrib.multi. defmulti now provides something more like a Common Lisp generic function. So I guess the way we would get what you want is to add a macro named defmacro to hy.contrib.multi that works similarly to its defn.. I forgot to mention that you can get something close to this right now by defining your macro as simply\n(defmacro m [&rest args]\n  (apply f args))\n\nand writing a multi-arity function f with the defn from hy.contrib.multi.. We'll miss you!\nI don't have the administrative powers needed to remove you from the GitHub team, but you can do it yourself by going to https://github.com/orgs/hylang/teams and clicking \"Leave\".. I kind of assumed we can reuse whatever automation script already exists, but since I don't know how the automation works, it's hard to say.. There's a switch to turn it on there, but no configuration options that I can see.. Ah. I guess that comes to show that we either need to move away from readthedocs, or use it in some way other than GitHub's automatic integration, in order to get the kind of control we need over our own documentation site.. It does. This issue is about the names of the two documentation versions, and which is the default.. @paultag If you don't want to deal with this, could you give the Read the Docs credentials to me or to one of the other Four Horsemen of Hy Maintenance, namely @kirbyfan64, @gilch, or @tuturto?. I hope senpai notices us.. Thanks, @paultag. I've created a Read the Docs account called \"Kodiologist\".. I've changed the default version to \"stable\", removed advertising, and replaced \"latest\" with \"master\" (but, unrelatedly, building documentation is broken at the moment, so there's nothing there at the moment).. > a module named a-b.hy, which seems like a perfectly reasonable naming scheme for source files.\nI disagree. Such a file can't be imported from Python with a regular import statement. So you should name your Hy files with underscores, even if you like to import them with hyphens.\nHence, in my view, this is not a bug.. If there are no objections, I'll close this.. Try read-str:\n(eval (read-str \"(+ 1 1)\")). How does [this patch](https://github.com/Kodiologist/hy/commit/a98fabecb2145b526ce9e0d441d6dbb90bd4aeb7) work for you? . Fixed by #1209.. The first Travis check was probably triggered by me accidentally pushing the branch to hylang/hy instead of Kodiologist/hy, so it can be ignored.. I made the same mistake again. I reset the remote for my tracking branch to `version-gen-updates`, so it shouldn't happen a third time.. @hylang/core Somebody approve this so @paultag can merge it.. @paultag The failure is just because Travis tried to test a branch after I'd removed it. (I had accidentally pushed to hylang/hy instead of Kodioloigst/hy.) You can click through to read Travis's logs of the attempts.. @gilch Nope, it doesn't. See #1208.\n\n@paultag I'm asking you to not accept Travis's reports on faith. Look at what commits the two Travis jobs are trying to test, look at how the fails arose (fatal: Remote branch version-gen-updates not found in upstream origin), and try the PR on your own machine (in particular, check that it fixes the bug it's supposed to, which the test suite doesn't include a test for). Travis can be a nice convenience, but it's fragile. It's already broken once before in the few months I'm been working on Hy.. @gilch That's what I did. The old Travis job hung around for its own inscrutable reasons.. I officially disapprove of this careless use of Travis reports, but since I seem to be in the minority here, I'll try pushing to hylang/hy, so Travis can check the branch it's trying to check.. It didn't work (Travis didn't re-run the check), so a new PR it is.. I don't think that's related to this issue, although it is another example of #818.. Tested in test-macroexpand-with-named-import.. The log says that git clone --depth=50 --branch=version-gen-updates https://github.com/hylang/hy.git ran successfully in that case. Presumably that job happened to start early enough that the git clone ran before I deleted the wrongly pushed branch.. @paultag @gilch All green here.. #1134 is the bug for circular imports and self-imports. That ought to be implemented, no question, and so one might logically think the same for macros and require, but I'm not quite sure this makes sense: is a sensible semantics possible for circular requirement or self-requirement, given that macros change the code that's ultimately imported? I haven't thought it through. It could be worth checking whether other Lisps can do that.. I'm not asking why one would want to do it (your first example shows that pretty clearly), but how exactly one would want it to work.. But they are:\n$ hy -c '(defmacro m [] 5) (print (m))'\n5\n\nThe reason your code at the top crashes is not simply that you're calling a macro in the same file as it's defined, but that calling foo generates a form (require m), so calling foo inside m.hy leads to m.hy trying to require itself. That's why I renamed this issue what I did.. > the generated code is somehow not in the scope that have local macros\nBut that's a pretty important property of macros, that the generated code ends up in the same scope as if you wrote it in that spot (where you called the macro, not where you defined it). That's what allows things like anaphoric macros.. No, you don't need the (require m) if you're calling the macro in the same file. That trick is for when you want to call the macro in a different file where bar isn't already in scope. This works:\n (defmacro bar [expr]\n   `(print ~expr))\n\n (defmacro foo [expr]\n   `(bar ~expr))\n\n (foo 42). No problem. I think macros are hard and I haven't even looked at how Hy implements them yet.. It's not obvious to me that getting circular imports to work will suffice to get circular requires to work.. I'm going to bump up removing `let` entirely (#1056) on my to-do list. I think we should've done that a long time ago.. See also #1119. What I do these days is use `(setv T True  F False)` so I can write, e.g., `(func :a T 123)` or `(func :a F 123)`.. > You can just as easily use `1` and `0` instead of `True` and `False`\n\nThere's nothing preventing a function from treating True differently from 1, and indeed this happens pretty often.. To be precise, it returns None, which is the second argument. I believe this is the correct behavior; remember that None is false in Boolean context. So it does return false; it just doesn't return False. This is the same thing that or does.. Well, no wonder you were confused; the documentation is just plain wrong. I'll make a pull request.. While I'm at it, let's make xor return the true argument instead of True, for consistency.. Done in #1215.. @tuturto Good idea. I've also added an instruction to do that in CONTRIBUTING.rst.. @tuturto We good?. Travis says something's broken on Python 2. I'll look into it.. @kirbyfan64 We good?\nIncidentally, while you're changing your username and stuff, I miss your old avatar that actually had Kirby in it.. Sure, let me know when you're done (or do the merge yourself).. TFW you close 10 issues with one merge.. @svetlyak40wt In that case, it seems like we shouldn't be tracking reformat-changelog in the repository; you can just open a PR to replace the NEWS file with a ChangeLog, and we'll update the ChangeLog directly henceforth.. If we release semi-annually, which I'd like to do, then we could drop Python 2 in mid-2019 or in early 2020. That sounds reasonable to me, although I hope we hit Hy 1.0 before then, so we might need to make that release Hy 2.0.. It looks like this won't be happening soon, despite some support. So I'll close this.. The Python people will officially end Python 2 support in 2020. So, presuming we'll continue our practice of making two Hy releases a year, one around the middle of the year and one around January, the last Hy release with Python 2 support can be in mid-2019, and we can start removing it immediately after.. > You can also compile your module with hyc. Then you can import it directly (Hy still has to be installed)\nThis isn't always true. If you edit the example greetings module by renaming the parameter name to addressee, then the resulting greetings.pyc no longer requires Hy. Using name makes Hy add from hy.core.language import name at the top of the file because name happens to be the name of a builtin. (Is this a bug or an unavoidable limitation of Hy? It's not obvious to me.)\nMore generally, I think that fulfilling #1061 calls for adding discussion of lots of gory details. Your additions here don't suffice. @gilch filed that issue, so maybe he can chime in.\nIt looks like this is your first pull request. Please don't be scared away by how I've received it; we do need more contributors, to both the code and the documentation. Thanks for pitching in.\n. > In that case, maybe this should be completely moved away from the tutorial, which would still contain general interop instructions without the \"gory details\".\nYeah, that makes sense to me. We've generally agreed that the tutorial should be fairly short so it isn't too intimidating.\n\nWhat I have understood so far is that if anywhere in the code, the name of a Hy builtin is found, it is imported.\n\nI think that's how it works, yeah. I've never read the part of the codebase that does this. . Oh, and don't forget to add yourself to AUTHORS.. > I'd suggest documenting mangling in a separate PR.\nAlthough, you may not want to do this now since mangling may change soon (#1173, #1115), anyway.. Yeah, a link would make sense.. Yeah, adding some syntactic sugar for these things to hy.contrib seems fair enough, but making [1 2 3] create something other than a plain list by default is asking for trouble.. Although, PVector and PSet seem equivalent to Python's built-in tuple and frozenset, respectively.. > this change would prevent that backport from working in the older versions of Python.\nNot so: the code getattr(mod, e) is not getattr(builtins, e, '') checks that the builtin really is the same function as the one we'd otherwise import. We do in fact have some backports right now, such as Python 2's filter getting replaced by itertools.filter, and the tests I added check that the import statement is generated when and only when it's necessary.. Requiring a review seems fine. Requiring a checkmark from Travis is a Bad Idea because Travis gets confused sometimes.. I don't know why those assertions are failing on Travis; they work on my own machine with CPython 2.7.12.. > Wouldn't it then still be an identifier?\nNo. See the tests.\n\nmaybe you ran yours on 3?\n\nLike I said, they pass with CPython 2.7.12.. Okay, phew. It looks like my virtualenv was playing tricks on me and running the tests with Python 3 even though just typing hy at the command line got me Python 2. And there was indeed a Python 2 bug, but it's fixed now.. Come to think of it, humorously, this makes [1, 2, 3] legal Hy.. > The docs would also have to be updated to match the new structure.\nOh, whoops, I assumed that none of it was documented. I'll do that now.. Done.. I made it into three separate commits because I think it's nice to have the reorganization separate from the slightly more meaningful changes.. Also, @paultag, the LICENSE refers to \"The above copyright notice\", but there is no copyright notice. I think d206e327a92250616970410cf90184ce4f97c36b was a mistake.. It's kinda annoying sometimes when I look at a file. And, like I said, we'd a policy for exactly which people and years get credited in each file, whereas right now they're inconsistent. And we'd need to add a header to all the files that are missing one.\nIt seems like a fair amount of pain for dubious gain.. I'm pretty sure the MIT license is enforceable, since the FSF's lawyers has no objections to it; I'm just talking about the headers.\nI don't think \"the Hy developers\" are legally the copyright holders. With nobody having signed any copyright assignments, everybody probably still holds individual copyright on their individual contributions, as on Wikipedia.. Here is GNU's description of the license, which they call the Expat license.. Consensus seems to be to keep the headers, but now y'all have to decide on a policy for what files should have them, who should be named as the copyright holders, and what the copyright years should be.. Nobody wants to bell the cat, eh? All right, I'll make a proposal. Every Git-tracked file that is conceivably copyrightable (i.e., has more than 10 lines of non-boilerplate code; if in doubt, consider it copyrightable) should have the following header:\n# Copyright 2017 the authors.\n# This file is part of Hy, which is free software. See the LICENSE.\n\nwith the copyright year for all files bumped after each new year, and the comment syntax altered as necessary.\nWhat do you think of that?. The reason I'm inclined to write \"the authors\" instead of \"the Hy authors\" is because it's not authorship of Hy in some general sense that confers copyright but authorship of the particular additions and changes to that file or its ancestors.\nNaming the license is a good idea, although we should probably call it just \"the Expat license\" rather than \"the MIT Expat license\".. Even then, the copyright applies to each author's individual contribution to the file rather than the whole file.\nI got the idea of just attributing copyright to \"the authors\" from a scientific journal that did it, although now I can't remember which journal it was.\n\"The authors\" isn't a pronoun. learn2grammarnerd, pleb. :P. I thought it would be pretty hard, but it turned out to be easy once I thought of making a new HyBytes model instead of trying to making HyString accommodate both.. It is admittedly pretty pointless. Probably the reason it's implemented is just that Python 3 allows it. So keeping it increases Python 3 compatibility, sort of.\nThe relevant bit in Python 3's language reference is \"As of Python 3.3 it is possible again to prefix string literals with a u prefix to simplify maintenance of dual 2.x and 3.x codebases.\". That could be implemented, but why would you write (with-decorator double (fn [x] x)) when you could just write (double (fn [x] x))? What's the point?. My argument isn't specific to your test case. It applies no matter how complex the decorator or the decorated (fn ...) is: (with-decorator d (fn ...)) can always be written as (d (fn ...)), so with-decorator is wholly redundant when using fn. The reason decorators exist is so you can use them with def (defn in Hy) and defclass, not with expressions. Indeed, the fact that (with-decorator d (fn ...)) worked was untested and undocumented.\n. Like the commit message says, \"it's necessary to allow defn to create a lambda instead of a def.\" For example, if you do (with-decorator d (defn f [x] (+ x 1))), the (defn ...) gets compiled to something like f = lambda x: x + 1, so with-decorator needs to be able to handle ast.Assign, which in Hy usually appears from a (setv ...) form.. So technically, supporting (setv ...) forms isn't necessary; it's just an immediate consequence of supporting ast.Assign.. Or, putting it another way, the (setv ...) produced by defn used to always lead to ast.FunctionDef downstream. Now it might be an ast.Assign. . And that's commit 2,000. This calls for celebration!. Definitely, I think tags of that sort wouldn't be hard, since the macro gets run at the same time as ordinary macros.. I think I'm going to make a PR to just rename them to \"sharp macros\" (and make the documentation less misleading). The extension to symbols longer than 1 character can be done later if desired.. Duplicate of #1104. Thanks for reporting, anyway.. Hmm, sounds like I might've created a bug with #1221. But are you sure that you're using the same version of Python in both cases?. For that matter, what's your Hy version?. I can reproduce this. Looks like hy.core.shadow tries to use reduce from hy.core.language even though the compiler doesn't call load_stdlib() for files in hy.core. And usually, for some reason, this works, even though it shouldn't. Gross.. Good detective work.\nI think the second idea is fine, assuming it's possible without big changes\u2014I'm not 100% sure it is.. I think option 1 is perfectly acceptable, too.. I can no longer reproduce this bug. I probably fixed it by accident as part of #1269.. Duplicate of #1103.\n\nWould it have the same definition as / (the only difference being operator.floordiv instead of operator.truediv and the docstring)\n\nI believe so.\n. I guess this is a trivial change, so I can merge it.. Good find. Since cycle is just from itertools whereas partition is ours, the bug is probably in partition.. Note that in practice, (partition (cycle [1 2 3]) 3) is better written as (repeat (, 1 2 3)).. @gilch Hold it. I've almost got a fix done myself.. It seems that the replacement can be most any Python expression (possibly followed by format specifiers):\n>>> f\"{(lambda p: p + 'b')('a') if 1 else 2 !r:5}\"\n\"'ab' \"\n\nFor Hy, It would perhaps make more sense to allow a Hy expression instead of a Python expression.. I figured that f\"{1 + 1 !r:5}\" would be written in Hy as f\"{(+ 1 1) !r:5}\" or something.. @kirbyfan64 You might try implementing only forms like {foo !r:5} first, where the expression has to be an identifier, since that could be easier to implement but will cover most uses.. It occurs to me that you could get the same effect on any version of Python with a pretty simple macro:\n(deftag f [string-literal]\n  (import re)\n  (setv exprs [])\n  (setv string-literal (re.sub :flags re.VERBOSE\n    r\"\\{\n      (?P<expr> [^}!:]+)\n      (?P<suffix> [!:] [^}]+)?\n      \\}\"\n    (fn [m]\n      (.append exprs (read-str (.group m \"expr\")))\n      (+ \"{\" (or (.group m \"suffix\") \"\") \"}\"))\n    string-literal))\n  `(.format ~string-literal ~@exprs))\n\n(setv a 3   b 2000)\n(print #f\"The sum of {a} and {b} is {(+ a b):,}.\")\n\nIt would take work to make this permit things like nested fields and backslash-escaped :s and !s, but it could probably be done.. I would encourage attending to  #1230 first.. Most (get x 0)s could probably be replaced with first. I opted for a more literal translation so I didn't have to check that first doesn't prematurely eat up an iterator or something. Do you want me to use first where I can?\nhead-tail is an orthogonal bit of refactoring to the removal of car and cdr, but it was an obvious opportunity for refactoring, which I took when I noticed.\nIncidentally, I hate iterables. In practice, the laziness is of no benefit, I have to convert them to a list or tuple in order to do most any operation on them, and I get bitten by subtle bugs that arise because iterators drop each element once it's accessed. Python 3 was in the wrong to make map, range, etc. produce iterables. I'm of half a mind to make Hy's iterable-producing functions (map, rest, etc.) automagically produce a collection instead when they're given a collection.. I tend to use macros (e.g.) that are both anaphoric and always return lists.\nYou haven't approved this; what else needs to be done?. How does this proposal compare to @tuturto's hy.contrib.sequences?. I found a very similar bug in eval, so I added a fix for that. Remember not to squash.. Thanks. I'm not going to ask you to undo the merge or reopen the PR, but I think this wasn't a trivial change, so it should've gotten a second review.. Are you saying you would approve this if I made the changes you've requested, or not?\nI don't understand your point or your example about \"this only half-way works with Python classes\". Can you be a bit more explicit?\n\nThe prepending of (do is going to make column numbers off.\n\nCan you give an example of how this appears to the user?. > Python's reprs in general are never going to work in Hy.\nYes, that's one reason I think that this change is better than trying to make more Python syntax into valid Hy syntax.\n\nWe could try to auto-convert reprs from Python, but I don't think it'll ever be 100%.\n\nYeah, that sounds like a bad idea.\n\nRemember that Hy libraries can also be used from Python.\n\nYes, that's why __hy-repr__ is different from __repr__.\n\nI'd rather have valid Python reprs in all cases\n\nWe don't already have that, nor is it likely to be possible. For example, at the Python prompt, x = [1]; y = [2, 3]; y[0] = x; y[1] = x; y prints [[1], [1]] even though the two elements of y are the same object. And lambdas get repred as <function <lambda> at 0xdeadbeef> instead of disassembled. hy-repr, like repr, can only be an approximation.\n\nThat means we should adjust Hy toward Python, not the other way around.\n\nThat would seem to require making Python syntax into valid Hy syntax, which we just rejected.\nI don't like your compromise because it will add a lot of visual noise to REPL output, which needs to be easily readable to serve its function of convenience.. > It's inconsistent. And it'll stay that way unless random library authors add __hy_repl__ implementations (but they probably won't).\nIt seems that our options are either to allow the inconsistency or to use a generic placeholder syntax for classes with no __hy_repr__, which merely names the class. To me the inconsistency seems a better option, since it provides more information.\nIn your example, the column number and the caret position seem to be correct.. HyExpression((([] + [HyInteger(1)]) + [HyInteger(2)])) seems like more of a problem than a solution, but <Hy  '(1 2)> seems pretty reasonable.. In any case, I think that what you're proposing is orthogonal to this PR. You're proposing how to make Python representations for Hy models, and this PR is about Hy representations for all sorts of values, including Hy models. The only way to see any of this PR's changes in the Python REPL would be if you did from hy.core.language import hy_repr; hy_repr(whatever).. @hylang/core Anybody else want to chime in on this? (Assume I'll be able to fix the bug Ryan mentioned that --spy doesn't work when the code raises an exception. I don't anticipate any problems there.) I think it's obviously a big improvement on what we had. But if nobody else likes it, I can submit another PR with just the first of these two commits, adding hy-repr but not using it automatically in the REPL.. Another idea is to have a command-line option that enables use of hy-repr in the REPL. However, making this feature the default seems wise to me because it will make the REPL much less surprising for newbies.. @gilch @kirbyfan64 What do you think of using a command-line option for this, as I mentioned above? If you're against the feature being on by default (with an option to disable it), how about off by default (with an option to enable it)?\n@tuturto Can you chip in?. Then you'd have to remember to use the prefix or reader macro or whatever for every command, which again reduces newbie accessibility.. > Even with a separate hy-repr and repr, you can still get weird hybrid representations that are neither fully Python nor fully Hy.\nLike I said, there's no reason one couldn't put a generic placeholder in place of an object with no __hy-repr__; it just seems that the Python representation is more likely to be useful. Some __repr__s themselves aren't Python code, like Pandas data frames.\n\nI do not approve of trying to hide the Python that is in Hy\n\nSpitting out values in a syntax that you can actually use as input is hiding? I mean, you don't think the fact that the input syntax isn't Python is hiding, do you?. I don't think that's a bad idea. We can at least mention it in the tutorial to maximize the chance it will actually see use in the wild.. Okay, I fixed the --spy bug, added a command-line option, added tests, etc. Take a look. Don't squash, since the middle commit is mostly unrelated.. I've removed lots of features so far in the few months I've been working on Hy, and I have my eyes on more. (Cons cells, your days are numbered!)\nYes, if you want a nested tower of objects to have Hy representations at lower levels, then you need to add Hy representations at higher levels, too. The only way around that would be to hack method lookup so that repr calls __hy-repr__ in certain cases, which to me sounds like much more trouble than it's worth, if Python is even dynamic enough to allow that.\nI guess I'm just not frightened enough of Python-in-Hy representations to think we should give up on any attempt at Hy representations. We're providing Hy representations of common classes, and ways for the user to create their own Hy representations. It's not going to work out of the box with every case, but them's the breaks. It still seems a lot better than the status quo, which provides no way to produce Hy representations at all.. >  Any competent Hy user should be able to translate Python reprs into Hy on the fly, in their heads.\nYes, but I don't have a telepathic link to my computer. I need to delete or add commas, delete colons, change single quotes to double quotes, etc.\nHy representations round-trip when possible, but they can't when somebody didn't write a __hy-repr__ usable for that purpose, just as in Python with __repr__. If you don't think it's worth giving a programming language the ability to write values out in its own literal syntax, because we can't get it to work without configuration every time, then I don't know what to tell you.. > Or you could just Python eval the string and let the computer worry about that part.\nIf I go and paste (py-eval \"[1, 2, 3]\") or whatever back into my source file, then I have source code which has Python and Hy intermingled, which is needlessly distracting, in my opinion, when the object in question has a straightforward Hy representation, namely [1 2 3]. I would sooner translate the REPL output into Hy with regexes and by hand so my source file is neater.\nI think the elephant in the room with my conversations with you is that I'm more liberal, in a programming sense, than you are. That is, I would rather have features that make a programming language more convenient, even if they create traps for the unwary. This is of course the primary reason I'm using Hy rather than Python, because I don't have much patience for Guido van Rossum's idea of what programming-language constructs are safe for me to use. Macros are a good example of a feature that's very powerful but allows you to create completely illegible code with many subtle and nefarious bugs.. I don't see how you would use _ to put the result in a source file.. I would characterize that description of your views as moderate. Beauty and simplicity aren't liberal values, and \"beautiful simplicity\" is particularly illberal, but on the other hand, you find Java and Go too restrictive.. @tuturto @kirbyfan64 Is this ready to merge?. > Expecting a merge is kind of premature.\n@kirbyfan64 said \"I guess I wouldn't mind it if it were disabled by default...\" and I did what @tuturto proposed. That's why I asked them if it was good to merge.\n\nIf you really want to write Lisp to help you edit your code, just use emacs. Or write a Hy macro to edit your code and put that in your source file instead.\n\nI'm not talking about writing code in the source file and then pasting it into the REPL, transforming the code, and pasting the transformed code back into the source file. I use Emacs, so I indeed would do syntactic transformations like that in Emacs Lisp, if I ever wanted them.\nI'm taking about doing some kind of computation and then pasting the computation result in a source file. For example, I might find the unique values of a variable and then put them in the source file with an assert to check that no more unique values have crept in once I've gotten a new version of the dataset. I'm a statistician, so I mostly use interactive mode for data analysis. That and debugging Hy itself are all I use interactive mode for, pretty much.. I've done another rebase to add support for quasiquote and unquote and refine the tests a bit.. If we move the hy-repr function to contrib, then hy.cmdline will have a dependency on a contrib module, which doesn't seem right. Your second paragraph seems to suggest writing an entirely separate implementation of the REPL for the sake of using hy-repr, which seems like a lot of duplicated code. We might avoid both of these things by implementing something like\n$ hy --repl-output-fn hy.contrib.hy-repr.hy-repr\n\nwhich would make the REPL import hy-repr from the module hy.contrib.hy-repr and use that in place of repr. Fancier methods are also imaginable, such as giving the REPL functions in hy.cmdline public interfaces with an argument to choose the output function, so one could say something like\n$ hy -c '(import hy.contrib.hy-repr hy.cmdline) (hy.cmdline.run-repl :output-fn hy.contrib.hy-repr.hy-repr)'\n\nTo me all of this seems like needless complexity, because it's hard to see many people wanting to use a REPL output function other than repr or hy-repr, but it's a reasonable compromise.. Would you approve hy --repl-output-fn hy.contrib.hy-repr.hy-repr, then?. Wouldn't a shell alias be better for that?. Okay. In the spirit of YAGNI, I'll just implement --repl-output-fn and move the hy-repr function to hy.contrib for now.. @gilch Done.. Okay, this should finally be ready to go.. Thanks, folks. I redid the merge without squashing so the changes between commits are differentiated.. The last idea is just shorthand for (list ...), right? Were you thinking of anything in particular? Perhaps #l, so that\n(list (map inc [1 2 3]))\n\ncould be written\n#l(map inc [1 2 3]). How is Clojure's `mapv` different from Python's `map`?. Oh, I see.\n\nFor what it's worth, I usually use a macro I wrote called amap, which is both anaphoric and always produces a list. It turns out to be pretty rare that an existing named function does exactly what I need, and I usually want a list at the same time.. On Python 3, the return still isn't suppressed. For example, hy2py compiles\n (defn f []\n   (with [(open \"README.md\")]\n     (yield 123)))\n (assert (= (next (f)) 123))\n\nto\ndef f():\n    with open('README.md'):\n        _hy_anon_var_1 = yield 123\n    return _hy_anon_var_1\nassert (next(f()) == 123)\n\nIs this on purpose (because Python 3 allows this, whereas Python 2 doesn't), or a bug?. Looks like it is on purpose:\n        if body.contains_yield and not PY33:\n            # Prior to PEP 380 (introduced in Python 3.3)\n            # generators may not have a value in a return\n            # statement.\n\nIn this case, your docstring for test-context-yield should say \"before Python 3.3\".. Thanks! In the future, please create a new branch for each of your PRs rather than committing on top of master.. This issue indeed seems to be Windows-specific, or at least, I can't replicate it on Linux.\nI have a hunch that #459 is related.. Yes, this is complicated. I feel like FStringParser could be greatly simplified, but that's easy for me to say since I haven't tried writing it.\nI think it's fine to totally disallow ! and : in identifiers inside an fpart, so that {a!r} does what you'd probably want.\nI'm kind of surprised Python doesn't allow fb or fu (heh, F U) string prefixes, but if they don't need them, we don't need them, right?. Could we simply allow ! or : to be escaped with a backslash?\nWe could always change defmacro! to use something other than ! in its special prefix. That's the nice thing about not being 1.0 yet, right?. True. It helps that we can write our parser in Python instead of C.. We can get this into the next release if you finish it by June.. This PR seems to be inactive, so I'm closing it. Please reopen it once work resumes.. > or is the document does not match to the current hy version?\nYep. See #1198.. This bug still exists in master but is fixed by pull request #1246. I'm hoping that will be merged soon.. @kirbyfan64 No, that's the right PR. Try it. Apparently, the bug was fixed as a consequence of how I changed the internals of the HyREPL class.. I first read this issue as being about embedding Python code in Hy (which is something that's been mentioned and I'd like to see, but I don't know if we have an issue for it), but now I see you're talking about the reverse. Well, we can't alter Python's syntax, so true embedded Hy in Python is out of the question. But you can put your Hy code in a string literal, and then use some of Hy's internal functions to read and evaluate it:\n>>> from hy.lex import tokenize; from hy.importer import hy_eval; hy_eval(tokenize(\"(+ 1 1)\")[0], globals(), \"__cmdline__\")\n2\n\nOne might reasonably expect documented, public functions for this.. I'd recommend providing separate functions for reading (i.e., turning a string into a HyModel) and evaluating a HyModel.. I think you should be able to export read_str or read (or both) from hy.core.language, in which case you should use the same name.. Yes, if it doesn't lead to some kind of circular-dependency issue. Try it out.. Aborting per the votes in #1225.. @kirbyfan64, did you forget to approve this or have you simply not finished reading it?. /me pokes @kirbyfan64.. Since this change only adds tests, I guess it's trivial enough for one review.. Thanks, I forgot this documentation page existed.. We have some in test_bin.hy, but they're not much. However, I'm soon going to submit a PR to make Hy read and write bytecode automatically, which will make bytecode issues much more visible in general.. Dangit, still failing on CPython 3.3 and PyPy 2. I'll take a look at them later.. Well, there's not much I can do about Travis's complaint, since I was able to coax PyPy into no longer creating that error for a nonexistent test on my own machine, with Ubuntu 16.10, but Travis's Python VM runs Ubuntu 12.04. (As has previously been noted, we need to move away from the dated Nose.) I have no real way to debug this. Unless anybody happens to have a machine running Ubuntu 12.04 sitting around, I'll have to disable testing PyPy compilation on Travis, I guess by checking the environment variable TRAVIS.. > @Kodiologist I've been able to reproduce the same failures using PyPy 2.5.0 (binaries are here).\nThanks. I see that these binaries don't have the PEP 3147 backport. Perhaps the reason for the Travis failures is that Ubuntu 12.04 (and possibly also Debian at the time) hadn't yet included the backport. All this suggests that I should be setting DEBIAN_PYPY_2 only if we're using a sufficiently recent build of PyPy. I have /usr/share/doc/pypy/changelog.Debian.gz on my machine, but it doesn't seem to indicate at what version the backport was added. So I have no idea what check I should use.\nEdit: Ah, no, I found how to get older changelog entries. I'm working on it now.. It turns out although Python 3.3 and the backported PyPy don't have importlib.util.cache_from_source, they do have imp.cache_from_source. That should make things a lot easier.\nEdit: nope, Ubuntu 12.04 still hates me. I got nothin'.. I was able to install the Ubuntu 12.04 package for PyPy on my own system, but I can't create a virtualenv because of a crash from, suitably enough, imp.cache_from_source (ValueError: Not a .py file: /tmp/pip-build-zd1NUk/six/six-1.10.0.dist-info/DESCRIPTION.rst).. Finally passing. To summarize what I learned, Travis does not use Debian PyPy. It uses a specific PyPy nightly, which I was able to get from here. I could then replicate the bug on my own machine, but I didn't find a way to really fix it. Instead, I've just changed hy.importer not to compile __init.hy__ files when running PyPy under Nose. (It works fine when you don't use Nose.). /me pokes @kirbyfan64. > Why?\nTo reduce the sheer number of things we have to test and work around. Speaking of which, we still have a bunch of if PY33:\u2026 bits although we're not testing Pythons 3 older than 3.3.\nWe're not testing PyPy 3 at all at the moment, only PyPy 2.. According to this table, 3.3 will be officially retired this September. I'll make a note on my calendar and close this issue, since no action is currently required.. raw_input is a Python 2 builtin and hence available in Hy running under Python 2. Changing the tutorial to use Python 3 would make sense, so I'd encourage you to do that if you're interested, but we probably shouldn't switch versions mid-tutorial without warning.\n(Actually, in Hy under Python 2, input is aliased to raw_input a.k.a. raw-input, but this is pretty confusing and hence probably not a good idea to spring on the reader of the tutorial at this point.). Misclick there; sorry.. > I don't know...I'm still against dropping all 3.x releases until the release reaches EOL.\nWhat's your definition of end-of-life? I don't see any such announcements regarding 3.2. The first release of the 3.2.x line was in 2011 and the most recent was in 2014. There was supposed to be a 3.2.7 release in February 2016, but it doesn't seem to have ever happened.. That page is handy, thanks.. An interesting question. For Hy, as for many programming languages, nearly all the important communication occurs in writing, so there's no natural tendency to come to an agreement about pronunciation.. In any case, this doesn't seem to really be in scope for Hy's documentation, so I should close this issue.. In the HTML, the section is given an empty id:\n<h3><a id=\"\" ...\n\nThis looks like a bug in how GitHub renders reStructuredText. By contrast, Read the Docs creates an ID id1: https://hy.readthedocs.io/en/latest/language/api.html#id1 . So does Sphinx, which is what we use when you do make docs.\nSince this seems to be GitHub's bug, I'm going to close this issue, but feel free to report it to them.. >> Polish up CONTRIBUTING.rst\n\nLooks fine to me...?\n\nIt could use a bit more organization and explanation, and a bit fewer ampersands, slashes, and exclamation points.. That's not a bad idea, Ryan. Also, the right way to handle these problems is probably not to write explicit checks for every case but to implement a concise way to declare the right syntax, which automatically produces a sane error message for each possible error.\n@hrehfeld If you're not sure whether to report a given bug, you could send me an email instead of creating an issue.. This seems to be a duplicate of #818.. No problem; finding duplicates is often difficult.. Blimey, it actually works!. The hack in conftest.py can be removed once pytest-dev/pytest#2374 is in a released version of pytest.. Also closes #72, since we're abandoning Nose.. Thanks for reviewing and merrging. Please don't squash when a PR is split into logically distinct commits. I've going to redo the merge.. Hmm. I wonder why the existing code works with Python 3.4 on Travis, but not for you. Did you try installing in a clean virtualenv?. That's the 666th closed PR. :smiling_imp:. No, because that changes forward slashes to backslashes rather than the reverse. Likewise the Python 2 equivalent,os.path.normpath.. I'll just unlock the old one.. @tuturto @kirbyfan64 Let's get this moving if possible, because it touches so many files that merge conflicts are inevitable with any other PRs.. @kirbyfan64 Poke.. Thanks!. That's a lot of italics; is it very important that #q be free for the user to define?. > There's no point in supporting paired delimiters like that unless you can also nest them like Perl does. All or none.\nI don't see how you came to this conclusion. In any case, nested delimiters could be added, but it seems like a lot of lexing complexity (particularly if you also allow escaped delimiters per Perl) for little benefit; it's better to just choose a delimiter you're not using in the string.\nIt looks like proposal D is similar to C but allows the delimiter to be multiple characters, and in exchange requires an extra character at the front and back (and also there's this stuff about newlines, but I don't think that's important because you seem to intend it solely for docstrings, so one could get the same behavior by making Hy strip docstrings when compiling fn, fn*, or defclass). To me it seems better to use Unicode delimiters, which are more visually compact and just as easy to type if you edit your .XCompose (or whatever the equivalent is outside Linux) appropriately. Or use $ or % or & or something.\nIf you're still keen on the possibility of multiple-character customizable delimiters at the expense of brevity, though, we could make #qC fancier to accommodate this. For example, C could be special-cased such that if it's =, then you can use as many = characters as you want to start the string and then the same number to end it, a la Lua's long brackets. Or if C is :, then you can write any string followed by another :, and that's your end string. Whatever floats your boat. I don't see myself using these, so it's no skin off my nose.. Also, I should say that I'm against proposal D because it requires double quotes, which is a problem if you wanted this syntax to help you get Hy code into a string that's double-quoted, as in a shell, for example.. > hy unknown\nAre you sure the test is running the right version of Hy? If you ran setup.py, the version file should've been generated and Hy should be able to read it. Of course, the new version of Hy needs to be in your PATH, or whatever it's called on Windows, in order for these tests to work. \n\nAlso, http://docs.hylang.org/en/latest/hacking.html is still showing instructions to use nose instead of pytest. Why isn't that updating?\n\nRead the Docs build failures. I haven't looked into them because I still don't have edit access. I just sent Paul an email about that.. > I thought that the pip install -e . step was supposed to run setup.py?\nIt should, yeah.\n\nThe version file doesn't seem to have been generated, but where exactly should it be located on Windows?\n\nSee VERSIONFILE in setup.py. Also, you can remove the except block there to see what error is preventing the version file from being generated.\n\nWhat other Hy version could the tests possibly be finding?\n\nYou could try putting something like this in one of the failing test functions:\nprint(run_cmd(\"hy\", \"(import hy) (print hy.__file__)\")). No, that's supposed to suffice. pytest-dev/pytest#2374 is supposed to allow the native tests to be run, and you have a sufficiently new version of pytest, and it looks like the pytest people do run their tests on Windows, using AppVeyor. So, I got nothin'.. Well, you also need to install it, but you probably already did that. I often say `git clean -dfx . && pip install -e . && pytest --ignore=tests/test_bin.py` to make sure everything's up to date.. > Why ignore the `test_bin.py`? Is is just because it's slow?\n\nYes. I don't mean to suggest you should literally ignore test_bin. I just don't usually run it, unless I'm working on something related or I'm about to push.\n\nCan we fix that?\n\nPossibly. I haven't explored this because my guess is that most ways of speeding these tests up would avoid running a real process for each subtest and hence wouldn't quite test everything that the current test_bin does.. This is on purpose. See #1216.. Duplicate of #683.\n. You can preview the result at http://docs.hylang.org/en/docs-update/. Come to think of it, this is a documentation change, so all I need is Ryan's ACK to merge it. So I will.. I noticed that, but I figured that starting with a capital letter is better for symmetry with False, True, and None, and the meaning of NaN is clearer when written in CamelCase.\nAlso, I'm not 100% sure that the Python repr is platform-independent.. I'm all for concise implementation, but surely you don't mean to suggest that we should interpret all of Nan, nan, nAN, etc. as the special floating-point value, in defiance of the case-sensitivity of the rest of the language, do you? Surely a bunch of code is a reasonable price to pay for avoiding that.. C'mon, guys, nothing will happen if you don't make any decisions.. @kirbyfan64 Is this good to merge?. @kirbyfan64 Poke.. Yep, I'll take care of it and merge. Thanks.. Good catch; it's embarrassing how long that's hung around. Could you open this PR against master instead of docs-update? docs-update is for a separate PR, namely #1293.. @kirbyfan64 @gilch @tuturto I can has review?. Thanks, Ryan.. @kirbyfan64 Done.. @tuturto Poke.. Confirmed. Thanks for reporting.. That sounds like it could be the start of a great first PR, if you'd like to get involved in Hy.. I'm afraid there's a bug, which is that the branch is evaluated twice:\n$ hy\nhy 0.12.1+104.g30d456c using CPython(default) 3.6.1 on Linux\n=> (setv x 0)\n=> (cond [(do (+= x 1) True)])\nTrue\n=> x\n2\n\nYou should be able to fix this with or or gensym. Don't forget to add a test for it, too.\n. Great work, thanks a lot, and welcome aboard. I'm going to reorganize the commits a bit and merge this.. I removed a few trailing spaces, too. Try not to commit those; git diff is helpful for finding them.. I choose reviewers to request pretty much arbitrarily.. I should've thought of that; whoops.. Awesome, thanks!. @gilch Done. Yes, the new tests still fail without the change.. > This was misleading\nDo you also write the name of the programming language C# as \"C\u266f\"? :P. > How would you approach this?\nRewind to the first commit (in an interactive rebase, or with git reset --hard, or even with just git checkout HEAD~, although then you have to reconstruct the branch when you're done). Amend it to make the same substantive change to the documentation that you made in the second commit, but say \"sharp macro\" instead of \"tag macro\". Now reapply the second commit, resolving the merge conflict by just ignoring the first commit's version. It should now be the case that renaming the feature is all that the second commit does.\nIt may actually be easiest, overall, if you put the name-change commit first. This will oblige you to change less stuff as you add tests and so on,  whether you make your changes by adding new commits or amending. (My own PRs often have some kind of cleanup in the first commit or commits and the change that the PR is really about in the later commits.)\n\nSomething like #foo5 means the tag symbol is foo5, but #foo 5 means the tag symbol is foo and the tagged form is 5, which is an integer, not a symbol (\"identifier\")\n\nActually, in Hy, 5 is an identifier at the lexical level; see e.g. t_identifier in parsers.hy. That's how we got #1143. But even in Python, 5 is a legal identifier character. It's just that, in Python as in other C-like languages, an identifier can't solely consist of digits.. So to clarify, in Hy's case, I use the term \"identifier\" to describe a lexical entity, whereas a \"symbol\" is a Hy model object of type HySymbol.. I don't think that inferring what \"identifier character\" means requires understanding the internal distinction between identifiers and symbols. You can write \"symbol character\" if you prefer. 5 is a symbol character, too. But listing out all the characters that aren't identifier characters is brittle.\nSpeaking of characters, I notice that you use the term \"hashtag character\" in the documentation. A hashtag is some sort of special token on Twitter that consists of a hash followed by an identifier. I think you mean \"hash character\".. > I'm inclined to remove the offending sentence altogether.\nSounds fine to me.\n\nHeh, haven't you heard? That what all the kids are calling them nowadays.\n\nBut only because they aren't familiar with the terms \"hash\" or \"tag\" and so they think the word \"hashtag\" refers to the funny character rather than the whole construct. Right?\n\nI think we should just call it # in the docs and let the users worry about how to pronounce it.\n\nThat's fine, too. I did close #1274 for more or less the same reason.. Good work!\nYour test macro #foo should do something less trivial than returning its argument unaltered, so we test that the macro is actually run. (Optionally, make such a change to the other trivial test macros in the file, too.)\nIt's also worth testing:\n- Calling a single-character tag macro with whitespace after the tag\n- Calling a multi-character tag macro with whitespace after the tag\n- Defining and calling a macro whose name is subject to mangling\n- Calling a tag macro (that's defined in the test file, not the built-in #@) on a non-literal expression. Keep allowing strings to define tags. You can disallow uncallable tag macros in this PR if you like, but I wouldn't require that to approve this.. Looking good. Don't forget about the case of mangling (bullet point 3 above).. Great. By the way, you can change the commit message for \"Change sharp macros to tag macros\" to say \"rename\" instead of \"change\" now that you've separated the functional changes out of it.\nOne other thing I noticed. On master, there's a pretty error message for using an unrecognized sharp macro:\n=> #a 1\n  File \"<input>\", line 1, column 1\n\n  #a 1\n  ^^\nHyTypeError: b\"`a' is not a defined sharp macro.\"\n\nNot so with your changes:\n=> #a 1\nTraceback (most recent call last):\n  File \"/home/hippo/Desktop/hyenv/hy/hy/macros.py\", line 220, in tag_macroexpand\n    tag_macro = _hy_tag[None][tag]\nKeyError: 'a'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  [ ... ]\n  File \"/home/hippo/Desktop/hyenv/hy/hy/macros.py\", line 224, in tag_macroexpand\n    \"`{0}' is not a defined tag macro.\".format(tag)\nhy.errors.HyTypeError: <exception str() failed>\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  [ ... ]\n  File \"/home/hippo/Desktop/hyenv/hy/hy/errors.py\", line 46, in __str__\n    line = self.expression.start_line\nAttributeError: 'HyString' object has no attribute 'start_line'\n\nCould you look into this?. Thanks a lot. I'd be chuffed if you reviewed some of my open PRs as well (particularly ones that already have a review, so I can merge them).. So be it. Farewell!. I can't seem to remove you from the GitHub team. Presumably @hylang/owners can do that.. @tuturto Is this ready to go?. 0.7.4, the latest on PyPI. Can you reproduce this?. This is a bug in rply (alex/rply#52) that is fixed in master but not yet in any release.. I think #919 and inline Python (which I, too, would like to see) are orthogonal to this PR. And yeah, I think it would make sense to have builtins.eval exported from hy.core.language as py-eval, although that too would probably be better in a separate PR.\nI'll look into the merge conflicts and disassemble. The latter is presumably running into problems because it does its own faking of source positions, which isn't playing nicely with how I do that in the compiler.\n\nIs the compiler really the right place to put this?\n\nI'm pretty sure that the answer is yes. It's the last chance to do it, so doing it then should mean that we only have to implement it in one place in Hy.. @gilch Done.. Aaaand it's broken on Python 2. I'm working on it now.. It was an easy fix; I'd forgotten about the trailing Ls of long literals.. I'm inclined to think that trying to document the implementation was a mistake in the first place. But I don't see anything on that page that's been made obsolete by these changes.. > hy-eval needs a good docstring explaining its use and parameters now that we're using it as a function\nDone.\n\n\ndocument the implementation was a mistake\n\nNo, the Hy model system is important enough for macro writing that it should be considered part of the public API.\n\nI agree. I'm sorry I was imprecise. What I don't think we should be documenting is the stuff under \"Hy Internal Theory\".. Confusingly, GitHub doesn't seem to display the commits in parentage order, like Git itself does.. I've noticed this, but haven't looked into it closely. It seems that order to get that last bit of speed, we need to delay importing various parts of Hy until we need them, which I'm afraid will be annoying to implement, but since I haven't tried, that's only a guess. It might be worth it, anyway.\nAt the same time, I'm more concerned about the speed of one-liners (hy -c '(print (+ 1 1))') than starting a program in a file, since we can't byte-compile a one-liner we haven't seen yet. I'm hoping that caching the lexer or something will help with this.. Confirmed:\n$ echo '(defmacro m [] `(print `macro-m))' > a.hy\n$ echo '(require [a [m]])' > b.hy\n$ hy -c '(require [b [m]])'\n$ hy -c '(require [b [non-exist]])'\n\u2026 ImportError: cannot require names: ['non_exist'] \u2026\n$ hy -c '(require [b [m]])'\n\u2026 ImportError: cannot require names: [m] \u2026\n\nIt's a weird one, too. Thanks for reporting.. Wait a minute, I get it now. The problem isn't trying to require a macro that doesn't exist. The problem is trying to require a macro that isn't loaded when the bytecode is loaded. (require [b [m]]) works when b.hy hasn't been byte-compiled yet, but doesn't once it has:\n$ echo '(defmacro m [] `(print `macro-m))' > a.hy\n$ echo '(require [a [m]])' > b.hy\n$ hy -c '(require [b [m]])'\n$ hy -c '(require [b [m]])'\n\u2026 ImportError: cannot require names: [m] \u2026\n\nSo this is a duplicate of #1268, although it shows that the problem of require not compiling to anything has worse consequences than for eval.. It's not that bad, and there's an easy workaround: require each macro you want from the module in which it's defined (a, in this case) rather than a module that itself gets the macro with require (b, in this case). defmacro compiles to something; it's require that's more troublesome.. Using a symbol in these positions is simply one of the syntactic conventions that the compiler doesn't enforce, like using square brackets instead of parentheses around the second argument of for. If you want a stricter compiler, you should probably make an umbrella issue for that. Fixing this would probably entail more declarative machinery for the compiler that would produce better error messages in situations such as #1277.. Actually, this issue turns out to be due simply to using HyString in some cases where we should be using HySymbol.. I think that would be a pretty niche feature for a macro of such central importance. Why not write your own macro to implement this? You can see the implementation of the standard defn in hy/core/bootstrap.hy.. > Macros are not even required for this. A Python decorator could theoretically do this\nIt might be worth checking for existing Python libraries for this first, then.. There is no function, macro, or special form named doc. Perhaps Kirby was thinking of help.\nFor what it's worth, I use Emacs's Inferior Lisp mode as a REPL. It's nice.. Probably the right solution to this is to define with as returning None when it's jumped out of with an exception, which can be implemented by putting _hy_anon_var_[N] = None before the with statement.. We both bugged Alex at the same time, oops. Well, great minds.. This would be nice to have for debugging.. I can't reproduce this with Hy 0.13.0 and Python 3.6:\n$ echo '(print \"hello\")' > foo.hy\n$ hy foo.hy \nhello\n$ hy foo.hy\nhello\n$ echo '(print \"bye\")' > foo.hy \n$ hy foo.hy                     \nbye\n\n. The fact that macros are only run when a file is byte-compiled is a feature, not a bug. As you note, there's no way to check that a macro would expand to something different from last time without actually running it.\n$ echo '(defmacro m [] (import random) (random.random)) (print (m))' > foo.hy\n$ hy foo.hy \n0.9039111761737755\n$ hy foo.hy\n0.9039111761737755\n\nSo I'm inclined to regard this as a gotcha that the programmer needs to be aware of, not a bug in Hy itself.. > I'm going to claim that we ought to not magically write out pyc without a human saying they should\nAs of f2278cf2f0297b5223828228311f8ac01c5b36bc, Hy respects Python's environment variable PYTHONDONTWRITEBYTECODE. I wouldn't recommend having it the other way around, though, where the programmer has to opt into bytecode. That's forgoing a major speedup that you're going to want 99% of the time. People who really hate bytecode can always put alias hy='PYTHONDONTWRITEBYTECODE=1 hy' in their .bashrc.\n\nBut how do Clojure and Common Lisp handle this kind of situation?\n\nThat's a good question. I was always pretty mystified about how Common Lisp handles these issues.. > Can't Hy just track the hashes of both the main file and its requirements?\nNo; e.g., https://github.com/hylang/hy/issues/1324#issuecomment-315565440. Similarly, a macro can choose a file to import randomly.. > @Kodiologist did your fix support this flag in Hy too?\nNo, it did not. The environment variable is what's checked.. I'm going to relabel this issue, since the compiler is working as designed, although the design is questionable.. Oh great, Travis is showing that it segfaults on 3.3 and 3.4 for some reason. Probably because PEP 448 only made it into 3.5. I'll gate those tests appropriately and see what happens.. Nope. I guess this won't be so easy. There were probably changes to Python's expectations for the AST.\nBut please do take a look at this before I start hacking away at that.. > Is there a non-reader syntax for these special forms, like quote is for '? \nYes, #* foo is just shorthand for (unpack-iterable foo), and #** foo for (unpack-mapping foo).\n\nA tag macro can be any symbol\n\nNot if you want to be able to call it. Here are two examples:\n=> (deftag \"{b\" [x] \"hello\")\n<function <lambda> at 0x7f579c0d2d08>\n=> (setv b \"foo\")\n=> (print #{b 1 2})\n{1, 2, 'foo'}\n=> (deftag \"[b\" [x] \"hello\")\n<function <lambda> at 0x7f913d8e0048>\n=> (print #[b 1 2])\n[\u2026] NameError: name '#' is not defined\n\nSo the effect of this change is that a tag macro's name can't begin with an asterisk, the same way it can't begin with { or [. Because such a macro would look like unpacking, it's a bad idea anyway.. >  But it should be fine to put it directly before a list with no space #*[..., likewise, a #** would work on a dict display #**{..., but not before a symbol.\nBeyond testing Hy itself, why would you construct a literal list or dictionary only to unpack it?. > In the case of a dictionary, even in Python, you can use dictionary unpacking to put the kwarg name in a variable.\nOh, that's a good point.. > > Not if you want to be able to call it.\n\nI said any symbol, not any string. I meant the kind of symbol you can type in directly, without going through a HySymbol call to convert a string.\n\nOkay, here's another counterexample:\n=> (deftag \"!a\" [x] \"hello\")\n<function <lambda> at 0x7f83b0b8ef28>\n=> #!a 3\n[Returns None]\n=> (repr #!a 3)\n  File \"<stdin>\", line 1, column 7\n\n  (repr #!a 3)\n        ^\nLexException: Ran into a HASHBANG where it wasn't expected.. So, to be clear, you want `#*b` to be parsed as calling a tag macro named `b` instead of the same way as `#* b`?. All right, that makes sense.. Okay, Pythons 3.3 and 3.4 should work now. However, I learned the hard way that the `#*` and `#**` syntax can't be enabled with tag macros alone. The implementation of unpacking requires peeking into the not-yet-compiled HyModel for `(unpack_iterable \u2026)` and `(unpack_mapping \u2026)` forms, and `#* x` appears as `(dispatch_tag_macro \"*\" x)` at that stage. So we'd need to treat these particular `dispatch_tag_macro` forms as magical, which seems unwise.. >  b\"`unquote' can't be used at the top-level\"\n\nYou get this error because quasiquote is getting interpreted as a function. See hy.compiler line 1960.\nNote that it would do you no good for me to add quote or quasiquote as an exception to the rule that unpack_iterable and unpack_mapping cause their parent form to be interpreted as a function, because (star x) still wouldn't get expanded early enough.\n\nMacros are supposed to recursively expand before special forms are applied.\n\nThat isn't quite true. A macro is only expanded once compile_expression gets to it (the first statement of compile_expression is expression = macroexpand(expression, self)). So when a form is being compiled that contains a macro call as one of its children (direct or indirect), the macro hasn't been expanded yet.. > That worked.\nNot in general. The case you tried doesn't require the compiler to see the unpack_iterable in advance. Here's an example with Python 2:\nhy 0.13.0+39.g38ef9c2 using CPython(default) 2.7.12+ on Linux\n=> (defmacro star [form] (import hy) (hy.HyExpression ['unpack-iterable form]))\n<function _hy_anon_fn_1 at 0x7f30b058b5f0>\n=> (f (star [1 2 3]))\n  File \"<input>\", line 1, column 4\n\n  (f (star [1 2 3]))\n     ^------------^\nHyTypeError: `unpack-iterable` isn't allowed here\n\nThe compiler sees star instead of unpack_iterable, so it doesn't set oldpy_starargs in _compile_collect.\n\nBreaking quasiquote is not okay though.\n\nIt's not broken. Quasiquote can't do what you want it to do here because of Hy's basic strategy for compilation. The most that can be done is to produce a more informative error message.\n\nI know some macros in Common Lisp will recursively macroexpand their body before acting on it\n\nThat's out of scope for this PR.\n\nAre you sure we can't implement it as a tag macro?\n\nYes, nor with a regular macro.\n\nWhich part is failing?\n\nAny part that requires looking at child forms. Check where I've used the function is_unpack in compiler.hy.. Also, I pushed https://github.com/Kodiologist/hy/tree/unpacking-tag-macro if you want to experiment with my attempt.. I got that far by treating the dispatch_tag_macro forms as magic by making is_unpack detect them. You could make this code work by also having the compiler bits that use is_unpack extract item 2 instead of item 1 when we've detected dispatch_tag_macro rather than is_unpack. The point is, you can't do it without magic in compiler.hy.. > Why does the Python translation have a None key?\nI noticed that, too. I think it's a bug (or rather, a missing feature) in astor's code generation. The way the Python 3.5 and 3.6 AST represents dictionary unpacking is indeed with a None key, although it doesn't work if you write {1: 2, None: {3: 4, }} as Python code, because the None has to be an unboxed None value instead of an identifier named None. It's pretty confusing.. Sorry, that was a typo for 3.5 and 3.6. Fixed.. To answer the obvious question, in earlier Pythons, dictionary unpacking is represented by passing the kwargs argument to ast.Call.. Well done. But, making it work for all uses of the unpacking operator will require rejiggering the order in which child forms are compiled in several places in the compiler. Where the compiler currently inspects the HyModels of child forms and compiles them after, you'll have to compile them first and then inspect the Python AST. As an analogy, the following doesn't work\n=> (defmacro m [] :hello)\n<function <lambda> at 0x7ff1ed3838c8>\n=> (dict (m) 3)\nTypeError: dict expected at most 1 arguments, got 2\n\nbecause the compiler looks for a literal HyKeyword when it's compiling (dict \u2026) and before it's gotten to compiling (m).\nIn all, it seems like a lot of work for the mere bragging rights of being able to say that we implemented #* and #** as tag macros. You realize that the easiest way to re-enable tag macros whose names start with * is just to make my HASHSTARS regex require whitespace (or other non-identifier character) at the end, or to make HASHOTHER specifically exclude #* and #**, right?\n. > Was that all of them?\nYes, that's everything I implemented.\n\nFirst, it would keep those special cases out of the lexer, which should be kept as simple as is reasonable. A DSL could use #* and #** tags for something else.\n\nRedefining a core macro seems like a really bad idea. Python lets you assign something to list, but that's a mistake, in my mind.\n\nWe might want to upgrade tag macros to true reader macros or Clojure-like tagged literals some time.\n\nSo we'll cross that bridge when we come to it.\n\nThe new special forms are not well-behaved now. They break quasiquote, and probably break in macros in ways a user would find hard to predict\n\nBut they are well-behaved and work consistently with the way the rest of the compiler works. For example, look at all the instances in compiler.hy of isinstance(something, HySomething).\nIf you want to change the compiler in deep ways, I'm certainly open to such a PR, but again, it's out of scope for this PR.. All right, this is ready for review now.. But tuple unpacking is among what's implemented here. Or did you mean something other than Python's one-star unpacking?. So the opening syntax would be something like q[foo[. You said that the closing syntax could just be foo, but shouldn't it be ]foo] so that text editors don't think there are unmatched opening brackets?\n. A bold idea. I'll try it out.. It works! (https://github.com/Kodiologist/hy/tree/hashstrings-recursive-regex) The catch is that regex contains C code and has ambivalent support for PyPy. So I don't think we should do this. Even if we weren't supporting PyPy, recursive matching of delimiters probably isn't worth adding a C dependency to a project that otherwise uses only pure Python.. Maybe I could achieve this instead with a Rule subclass that uses procedural code instead of a regex in its matches method. Do you think it's worth it?. > Is a rule subclass like that part of rply's public interface?\nIt isn't, but I'm not too worried about that, because I'll only be making assumptions about a small amount of the code, and the author of rply seems pretty responsive.\n\nI think we should do q<foo> with foo instead. (And strip one initial newline, if present.)\n\nSounds good to me.. Okay, #q<foo> and balanced delimiters are in there now.. (Kek, I can't keep my own syntax straight.). > I just realized, this will prevent us from using an other tag macro symbols that start with q.\nQuite so.\n\nThe obvious fix is to make them use the same rules as other tag macros, so #q X with X, and #q <foo>. But #q[, still works.\n\nI would rather not allow or require this whitespace. It looks weird and leads to a construct like #q X having non-significant whitespace (where all runs of whitespace are treated the same) on the left of the delimiter (X) and significant whitespace (where each whitespace character is preserved literally) on the right. If we must have tag macros whose names begin with q, how about removing the plain style of q-string (#qXfoobarX) and leaving the balanced style (#q(foobar)) and pointy style (#q<X>foobarX)?\n. Even if the only change from what I have now is to remove the plain style, the only way you could get your tag macro shadowed is if its first character is q and its second character is < or one of the bracket or quote delimiter characters, which would make a strange name for a macro.\n\u00ab (and the others) ought to stay identifier characters so long as they have no special meaning outside of #qC. My proposals A and B in #1287 were to use a fixed character for quoting rather than a pick-your-own-quotes operator, but they didn't seem very popular.. @kirbyfan64 @tuturto Can you guys weigh in on what you would accept?. @tuturto Yeah, but see the back-and-forth between me and Matthew above. Would you accept dropping the plain style but still not requiring or allowing whitespace after the q?. Okay, thanks. @kirbyfan64?. Looks like we're Ryanless for this PR. @gilch, would you accept a spaceless balanced style with all the delimiters allowed here? You're proposing a different PR that will prevent calling tag macros whose names begin with _ (#1354), so perhaps you'll also allow restriction of weirder prefixes like q\u2045 and q\u2e0c. If not, I'll take your compromise in which #q(, #q[, #q{, and #q\u00ab are the only forms of the balanced style.. Surely the editor modes exist to support the programming language rather than the reverse, and hence we should be modifying the modes to suit the language rather than modifying the language to suit the modes. And it's nice if Clojure tools also work for Hy, I guess (I've never used one), but it doesn't make much sense to hold back the development of the language to maintain this quasi-compatibility with Clojure. Clojure compatibility has never been a goal for Hy.\n\nThe Balanced Style would work in most cases, but for arbitrary strings, we need some kind of custom delimiters.\n\nIsn't that what the pointy style is for? We were talking about dropping the plain style, but keeping the pointy style as well as the balanced style, so far as I understood.\n\nI think we need to discuss it more\n\nWhat would you like to discuss?. What exactly do we mean by the Lua style? Like, openers of the formq[===[ for some number of = signs, or with any string for the === other than an opening square bracket?\n@gilch I doubt that ParEdit, Parinfer, etc. are what have attracted most people to Hy so far, and I doubt that most existing Hy programmers use them. Hy is perfectly writable in Nano or Gedit or whatever. Nor are they the most obvious motivation for a heavily parenthesized syntax.\n@kirbyfan64 Are you saying you wouldn't support allowing any of the other styles, or merely that the Lua style should be supported among others?. Regarding the leading indent, I don't care too much. I'd lean against it, because it's easy for the programmer to remove but annoying to re-add if you have to, but I'd accept this either way.. It's a fine replacement for the pointy style, where flexibility is the chief concern, but somewhat verbose, so it's not a great replacement for the balanced style or the plain style. Even the shortest form, #[[ \u2026 ]], is a character longer than the already weighty #q( \u2026 ). Hence my proposals A and B back in #1287.. > I'm still not okay with requiring Unicode as in Proposal A.\nIt's not required; we'll have the Lua style too. :)\nBut B is probably just as good because in the case that you need to use a backtick, you can escape it or use the Lua style.. Right, proposals A and B both need escaping and the ability to use the r prefix (and we might as well throw in the other prefixes while we're at it) because you can't customize the delimiters. In the case of B I imagine the prefix would go before the #.. Don't worry, I've gotten myself utterly confused, too.. >  I still have no clue what the hell \"pointy style\" is.\nIt looks like #q<FOOEY>my stringFOOEY.\n\nMy understanding is that the current state of the code is that is looks like #q{delim}STUFF delim, right?\n\nNo. The current state of the code allows three styles, none of which allow #q{delim}STUFF delim:\n\nThe plain style: qXmy stringX.\nThe balanced style: q{my string {still part of my string}}.\nThe aforementioned pointy style, #q<FOOEY>my stringFOOEY. It's called the \"pointy\" style because you have to use ASCII angle brackets in the opening delimiter.\n\n\nAlso, I'm not sure what this has to do with list syntax.\n\nMatthew wants a syntax that does not restrict what tag macros you can call, compared to what's already the case. #[ currently isn't a valid tag macro call, whereas (e.g.) #\u00ab is, because [ lexes as the start of a list.. > #[ currently isn't a valid tag macro call, whereas (e.g.) #\u00ab is, because [ lexes as the start of a list.\nActually, that's not quite true. The real reason #[ can't lex as a tag macro call is because a tag macro call can only contain identifier characters, and [ isn't an identifier character (the regex that defines identifier is in fact [^()\\[\\]{}'\"\\s;]+).. I endorse this proposal and will implement it if it gets sufficient traction.. Although, I think that allowing unescaped nested guillemets is probably a bad idea because (1) it complicates the lexer, (2) it will complicate syntax coloring (which will no longer be possible with non-recursive regexes alone), and (3) you're much less likely to need nested guillemets than you would nested parentheses or square brackets or whatever, and if you do, there's still the Lua style. But if we really need it, at least I've already gotten most of the code down.. @gilch It looks like at least the three of us (you, me, and Ryan) agree on your proposal. Can you just comment on the question of nested guillemets? Then I'll write it up and make a new PR for it.. > Both Perl and Ruby have balanced-style strings with the same issue. How much of a problem is it for them, really? How does their tooling handle it?\nI can't speak for Ruby, but the complexity of Perl's quoting forms tends to be behind the corner cases that Perl syntax highlighters have trouble with. That's probably the hardest Perl feature to highlight, except perhaps the magic variables with weird names like $' (and modern Perl should generally use English; so you can use the longer names instead, anyway).\n\nIf we're using Unicode anyway we could have used the English-style 66/99 quotes with \u201c U+201C and \u201d U+201D. But they might be harder to distinguish than the guillements in some fonts.\n\nAgreed, and hard to distinguish from ASCII double quotes, too.\n\nUnfortunately, some languages (like German) like to use them backwards, \u00bblike this\u00ab. The other way is more common, but we could support both, by allowing guillement strings to start with \u00bb too.\n\nOh dear, that sounds like a recipe for insanity. If annoying or confusing people who use guillemets in the opposite direction in their native language is a concern, it's probably better to choose different characters, like \u2039 and \u203a or \u2045 and \u2046.\nMy first objection to quoting with vertical bars would be, how does the parser tell whether (foo | x |) is a function of one argument, the symbol named \" x \", or three arguments, the first and third of which are the | function (the shadow version of the bitwise OR operator from Python)?. I'd rather not rename a bunch of operators when we could just use other syntax. So, if there are no objections, I'm going to implement Lua style and a guillemet style supporting nesting. We've rather drawn this out, so it will be nice to conclude it.. > A change in grammar is a much bigger deal than renaming some core operators.\nThe grammar has to change in any case in order to implement a new form of symbol quoting or string literal or whatever.\nWouldn't it be better to quote with some syntax that doesn't require changing an operator from the Python name, like \\ \u2026 \\ or #( \u2026 ) or #` \u2026 ` or \u00ab \u2026 \u00bb?\nAnd seeing as people are going to use funny characters in strings more often than in symbols, shouldn't we have the default for the syntax be a string rather than a symbol?. Related to that last point, easier entry of symbol with weird names doesn't actually need a new quoting syntax\u2014it would suffice to add another prefix to string literals that makes the result a symbol instead of a plain string.. > FWIW is there a reason we can't just use PLY?\nI don't know, not having used it, but rewriting the lexer and parser is out of the scope of this PR.. For what it's worth, I use the bitwise operators much more often for vectorized logic with NumPy or Pandas objects than for actual bitwise logic.\n\nIt feels like we're quibbling over saving one character.\n\nYeah, we've been bikeshedding mercilessly about this since the beginning. Somebody's gotta give in order for this to end. So, I give. Would you accept a PR that adds the Lua style (without nesting of the customized delimiter) and doesn't do anything else?. > Which version exactly are you proposing? I'd accept the version like #[foo[ (remove one newline, if present) string body ]foo], where foo is any string not containing [ nor ], including the empty string, and the foo is available as metadata in the HyString model.\nYeah, that one.. This looks cool. I'll hunt for bugs.. ### Design\nIt would make sense to make =: support any even number of arguments, with the same meaning as for setv.\nWhat is the macro dest for?\nYou can't destructure an iterable that can't be subscripted (e.g. (=: [a b c] (genexpr i [i (range 3)])) doesn't work). Is this a bug or a necessary limitation?\nNeither of (=: {:from [\"hello?\"]} {\"hello?\" 5}) nor (=: {:from [\"is_hello\"]} {\"is_hello\" 5}) binds to hello?. It's not obvious which should work, but it seems clear that at least one should work.\nIt's confusing that keys for dest-dict come after the variable, particularly since the magical destructuring keywords (:as, :from, and :&) come before the variable. That is, {a :a  b :b  :as all} should instead be {:a a  :b b  :as all}. If you want to make sure that :as, :from, and :& can still be used as regular keywords, try denoting the magic words with & instead of :, so :as would be &as, :from would be &from, and :& would be &rest or something.\nImplementation\nException should probably be TypeError.\n(with-gensyms [x]) x works, but I don't think it's supposed to; that is, x is supposed to be out of scope outside the with-gensyms. with-gensyms is a holdover from when we had let and expected to make it work someday. (setv ddict (gensym)) does basically the same thing.\nExpressions like `[~ddict ~expr] can be written like [ddict expr] now that we have #1314.\nfor* can be for. (There's no reason to use for* outside Hy core.)\nTesting\n(= [0 1 2 3 4 5] all) is a Yoda condition.\nAvoid all as a variable name, since it's a Python builtin.. > I realized I put this up before I implemented :or for mapping defaults. I'm not quite sure how to implement that. What should it expand to?\nI would presume something like `(.get ~ddict ~v ~default).. >  it would have to be (setv ddict (gensym ddict)) to get the more meaningful symbol for debugging\nThat's what I mean by \"basically\".\n\n\nfor* can be for. (There's no reason to use for* outside Hy core.)\n\nSee #1125.\n\nI don't see what you're trying to say. for will still work in all these cases if the change you requested there were made.. I'm sorry, I was imprecise. By hello?, I mean the symbol which is written in Hy source as hello?, and whose name is actually is_hello. Neither (=: {:from [\"hello?\"]} {\"hello?\" 5}) nor (=: {:from [\"is_hello\"]} {\"is_hello\" 5}) binds this symbol. In particular, the latter binds the symbol whose name is is-hello. So \"is_hello\" is only partly unmangled. Surely this isn't how you meant to design things.. And in addition to the unmangling being only partial, it's going the wrong direction. You could justifiably mangle in this context, but not unmangle.. For the issue of strings in :from, I think the right thing to do is just avoid the unmangling (which is currently being done with name, I think). Then (=: {:from [\"is_hello\"]} {\"is_hello\" 5}) will bind to the symbol usually written hello?.\nFor the issue of iterators, how about something like what I just pushed?. Hmm, wait, I see the problem with this. :as can't bind something to exactly what's passed in if it's an iterator. However, why not make :as listify? Python's *foo on the left-hand side does the same thing.. Are you still working on this?. Oh, that makes sense.. We have #1338 now.. It looks like dest-list and dest-iter share a lot of code. Do you think refactoring would help?. It doesn't seem that you're buying much by implementing ifp for internal use instead of using if or cond.\nIs vals@ a leftover internal function, or is it intended for public consumption?. I think making a public ifp is perfectly reasonable, but it seems to belong in a different PR and a different file (either core or a different contrib module), since it's not about destructuring.. So, do you want to remove ifp from this PR?. I'm closing this for inactivity. Please reopen it when you'd like eyeballs again.. @kirbyfan64 Are we cool?. That's how the method works in Python, too:\n>>> '{0} {0}'.format(('hello', 'world'))\n\"('hello', 'world') ('hello', 'world')\"\n\nPerhaps you mean (apply .format (+ (, \"{0} {0}\") words)) (or, with Hy master, (.format \"{0} {0}\" #* words)).\n. In Hy, *words is just a variable whose name begins with an asterisk. But (, \"hello\" \"world\") is indeed a tuple.. http://hy.readthedocs.io/en/master/ is the bleeding-edge version of the documentation, for use with bleeding-edge Hy.. Yep, it seemed clear to me that (= x) and (is x) should be true whereas (!= x) and (is-not x) don't make much sense. These details of the operators aren't documented (yet), but tests/native_tests/operators.hy has lots of examples.. > Wasn't there an Admin opt-out?\nThat's the setting the commit message refers to.\n\n...is this even allowed?\n\nI have no idea. If they don't like it, we can move.\nI don't think advertising in our own documentation is something we should tolerate. If you guys don't want this PR, then let's move.. > Where would you move to?\nIn terms of the domain, let's use hylang.org, but as the true domain rather than just a redirect. Then we should never have to change domains again.\nIn terms of hosting, we can use the same VPS I use for Arfer.net, or perhaps GitHub, depending on what's possible with GitHub Pages or whatever.. Yeah, all we need is static pages. One can always use Google site search.. This is a 1337 pull request.. No, it probably just means I'm old. ;_;. Aww, boo. Fine.. Done.. @gilch Is this ready to go?. I think that pushing a style fix (or any other commit) onto somebody else's PR is fine. If the author reverts your change, you shouldn't make it again (the reviewers are gatekeepers for the repository, but authors are bosses of the content of their own PRs). But I don't see myself often reverting a change to indentation or semicolons or something. (Not on purpose, anyway. It could easily get blown away by a rebase to change the PR in some other way; in that case, you're free to make it again.)\nStyle-fix commits should generally be melded into other commits before the merge.. > To be clear, I should add and push a new commit after all the others, with the style fixes, rather than a force-push with an amended commit? Then someone else will meld it before the merge?\nEither seems fine to me.\n\nFor one so strict about commit structure, it's surprising you're so lax about formatting.\n\nFormatting can always be changed, but the commit history is forever. I guess that's why I feel paranoid about it. Arguably, I'm unnecessarily picky, but nobody's complained yet.\n\nmembers that actually use other Lisps\n\nI do use Emacs Lisp (and so do you, right?). To which you might reply that Emacs Lisp is a crummy Lisp anyway, which would be harsh but fair.\n\nI certainly felt deterred from participating by this dispute, to the point of contemplating a hostile fork.\n\nThat seems like cutting off your nose to spite your face, but it is free software, so it's always an option.. Thanks. Don't worry about it; I'll fix the conflict and merge.. Sounds like a plan.. - You're not supposed to touch another module's name that begins with _.\n- _42 is a really bad name for a variable.\n- x._42 still works (just like x.42).\nSo, it's hard to see how this would be a problem for Python interoperability in practice.. It's not as if being able to start an integer literal with an underscore is very useful, either. So I doubt that whether or not this change is made will make much of a difference.. _ is now *1 as of #1517.. This is unquestionably counterintuitive, but what else would you have [foo (del foo)] compile to? Hy's general strategy for expression-ifying a statement is to move the statement before the expression. For example,\n(f (g) (with [(E)] (h)))\n\ncompiles to\nwith E():\n    _hy_anon_var_1 = h()\nf(g(), _hy_anon_var_1)\n\n; notice that h gets called before g. Would you instead have something like\n_hy_anon_var_2 = g()\nwith E():\n    _hy_anon_var_1 = h()\nf(_hy_anon_var_2, _hy_anon_var_1)\n\nand for [foo (del foo)], something like\n_hy_anon_var_1 = foo\ndel foo\n[_hy_anon_var_1, None]\n\n? It's not obvious to me that this strategy will work in general. Think hard about what you want.\n. >> what else would you [...] compile to?\n\nI don't have to know the answer to that to report it as a problem.\n\nCertainly, but it's a question we have to answer if we want to ever fix a bug.. Not to be confused with\n. No, #* causes the parent expression to be interpreted as a function. It doesn't work with special forms. That was the issue we got hung up on in the PR comments.. Done and done.. Thanks, Ryan. Recall that the new policy is to create a merge commit when merging. You don't have to back this out, but remember that for next time.. Probably, but you should make a new issue for it if you want it.. Feel free to open a separate issue on that matter, but I don't think this is the place to argue about it. My own preference is to use if only with three arguments and cond for everything else, but the point of this PR is that cond isn't kosher in the definition of a core macro.. It makes no sense to make a PR wait for a formatting-policy change that may or may not happen. When and if it happens, the codebase can be updated to match it.. I don't know why you're convinced it's already an implicit policy. And I don't know why you closed this PR.. Can you quote the relevant passage?\nWhat's more, I honestly don't know what the conventional Lisp indentation rule would be for this situation, and the guide doesn't have an example for if with more than three arguments. I think most Lisp ifs interpret arguments after the third as part of a single else clause, which is why in Emacs Lisp (e.g.) you see stuff like\n(if something\n     then1\n   else1\n   else2)\n\nwhich the style guide describes as \"hysterically ridiculous\". Admittedly, because our if works differently, most of the motivation for this style is gone.. All right, I understand those rules, but how are you saying that they should apply to many-argument if? I'm taking it for granted that you're not recommending something like \n(if\n  (odd? (len args))\n  (macro-error args \"`for' requires an even number of args.\")\n  (empty? body)\n  (macro-error None \"`for' requires a body to evaluate\")\n  (empty? args)\n  `(do ~@body ~@belse)\n  \u2026)\n\nbecause then the relationship between conditions and outcomes isn't visually clear.. Okay, thanks. I did the first one.. > assoc should also work with slices.\nWhat exactly do you mean? Can you give an example?\nGood catch regarding partition; I forgot it existed.\n\nBut why was assoc a special form in the first place?\n\nI don't know. Possibly by mistake, possibly because (setv (get x k) \u2026) hadn't yet been implemented. Arguably it doesn't provide much of an advantage over setv and get in the first place and is hence superfluous.\n\nIt's not the only one that could be implemented as a function instead.\n\nI would generally advocate changing special forms to macros or functions when this is possible, so let me know if you find any others.\nDo we really need the micro-optimization of assoc being a macro? Most, maybe all, of Hy's core functions could conceivably be implemented as macros; just as macros are better than special forms, I think functions are better than macros.. > So (assoc spam (slice 1 None 2) [-1 -2]) should work the same as (setv (cut spam 1 None 2) [-1 -2]). But a test wouldn't hurt.\nSounds good to me.\n\nWhy not eliminate all the operator special forms and just use the functions? Performance.\n\nWhile I agree with the performance consideration in the case of math operators, I think that being able to produce real ast.BinOp nodes is the more important reason we have special forms for them. I'd like it to be possible to produce the AST corresponding to any Python program with pure Hy (although, admittedly, we're not there yet).\n\nIt is considered an operator in Python, just like + is. It's a variation of operator.setitem, written with [] and =.\n\nI see what you mean, but then how do we decide which core functions are a variation on an operator and which aren't? Is last a variation on getitem? Is inc a variation on +? Is zero a variation on =? . Yeah, if we want to go down that route, it seems that we should be generating the code rather than maintaining two versions (shadow and macro) of every function. One can imagine a macro or special form inline that takes a function definition and creates a corresponding macro with the same name.. Can we leave the macro version and shadowing and so on for a later PR for defshadowed or whatever, and let assoc be just a function for now?. Or let it be just a macro for now. One or the other.. Okay, I'll check on my first, macro version and PR that instead.. Nice! I was imagining generating the macro from the function, but the other way around makes a lot more sense.\n. Cool, thanks. Don't forget tests. Also, change your commit message and PR title to be more descriptive. It's hard to remember what #1335 is.. Looking good!\nFor legibility, would you please edit your new tests to use ` and ~@ instead of quasiquote and unquote-splice? I realize this will be inconsistent with other tests in the same functions; you change those too if you like.\nWould you please update the documentation, namely the section on unquote-splice in api.rst?. Yes, all seems fine to me. I'll merge.. Good find; this is a strange one.. To be precise, both symbols and keywords are subclasses of str (or unicode) and hence can be used as keyword arguments, but the keyword :foo has the string value \"\\ufdd0:foo\", not \"foo\". The reason that (total-purchase 10 15 :vat 1.05) works is that a literal keyword in a function call is magical: it compiles to a keyword argument (in the Python sense of the word \"keyword\"), and the leading \"\\ufdd0:\" is stripped.. I think so. The trick is that in Hy, unlike most Lisps, keywords don't evaluate to themselves. They evaluate to strings, not HyKeywords. So the expression `(print-args ~@[:key 42]) evaluates to (print-args \"\\\\ufdd0:key\" 42); if you evaluate this, the compiler will see the string \"\\\\ufdd0:key\" instead of a literal keyword. By contrast, `(print-args ~@[':key 42]) evaluates to (print-args :key 42). If you want to pass a real HyKeyword to print-args here, you need two single quotes (i.e., `(print-args ~@['':key 42])) because you're evaluating :key twice, once with ~@ and once with eval.. First of all, despite what it may seem, Hy is effectively ready for general use. I among others use it for most of my everyday programming tasks. The breaking changes do occasionally require you to update your code, but I've never found this difficult, even for the relatively large Rogue TV.\nOne easy way to keep up with changes to the language is to watch the NEWS file. It gets updated with every pull request that has a user-visible change. If you want more detail, look at the Git commit log. As for future changes, you can look at the outstanding pull requests to see what's coming down the pipe. Further out in the future, it's tough to give a good prediction. In my own case, I've written most of the changes to the code for the last 9 months or so, and I don't plan very far ahead\u2014I just work on what feels most pressing or most doable. I have a vague idea of releasing Hy 1.0 in one or two years, but ultimately I'm only going to push for 1.0 once (a) there are no known major bugs, (b) all the major features I want are in, and (c) I'm happy with the documentation. The last one in particular is probably going to take an annoyingly long time.. Whenever 1.0 happens, though, I'm aiming to release a new stable version once every 6 months.. @hylang/core Does anybody want to maintain a blog? I don't. We do have a Twitter account, but I don't know who controls that.. Oh, that makes sense. Well, I guess this issue could be interpreted as a request to post more frequently.. Great, then, I guess we're done here.. I think the simplest way to do this is with postprocessing. Allow HASHSCORE to parse as a kind of term that leaves a special object, say DeleteWithNextToken, behind. When you're done parsing but before compiling, run through the token stream and delete each instance of DeleteWithNextToken and the following token.\nN.B. I'd recommend against changing HASHSTARS to r'#\\*\\*?', because then Hy will parse something like #**** as #** ** without complaint.\n. Seems pretty cool to me.. It doesn't matter very much so long as you commit documentation, NEWS, and tests after (or at the same time as) the corresponding changes to the code. Everything in one big commit is also a reasonable option.\nAs for the order in which you actually write stuff, the order you listed seems like the most natural one, with \"tests for comment\" added after comment itself.. I thought that comment was to have the same effect as #_, but it results in a None rather than discarding itself entirely. Is that on purpose? If you wanted to not evaluate a form and return None, I'd expect you to write (when False FORM).. \u00af\\_(\u30c4)_/\u00af Okay, it's got a dead-simple implementation in any case.\nOtherwise, everything looks good to me. You might want tests for #_ in a function call and a dictionary display.. Shouldn't that be sudo -H pip3 install hy?. > Still, why should this install something directly to /usr/local and not, say /tmp?\nNo installation directories are named in setup.py, so this is likely a Pip setting.\n\nIs get_version.py required for Hy to run?\n\nNo, it just generates hy/version.py.\n\nCan I configure this somehow, e.g. with an environment variable?\n\nProbably. Check Pip's documentation.. No, or else get_version would have to be in the hy package, in which case importing it would import hy/__init__.py, leading to the import of several other files, and thus making it such that building the documentation would depend on the rest of Hy.\nIt's difficult for me to see how this could be our bug. That's why I closed the issue.. Very good.\nPer CONTRIBUTING.rst:\n- Would you put the second sentence of the commit message on a line on its own, after a blank line?\n  - Make sure the first line is 50 characters or less.\n- Add yourself to AUTHORS in a new commit.. Yes, but now the TypeError is no longer raised when you really do call a function with no matching signature:\n=> (require [hy.contrib.multi [defn]])\n=> (defn fun ([a] \"a\"))\n=> (print (fun 1 2))\nNone\n\n. Great! Now please update NEWS and add yourself to AUTHORS. Also, rebase to remove the first commit (bf3f4da) since it's not doing anything now. Finally, clarify the commit message of 61fb432; per CONTRIBUTING.rst, ensure its first line (which will probably still be its only line) has 50 characters or less.\n. I forgot to mention: in the future, create a new branch for each PR rather than using master.. Nice!\nI don't think hy-repr should be hard to fix. But first let's see some tests for the change itself.. Pretty cool. It might make sense to separate the pretty-printing code from the __repr__ code. Python's native pprint might be useful.. Okay, then, are we ready for tests?. hy-repr should be working now. (I amended the first commit and removed the xfail commit.). I made two edits: I added the name clean in the documentation about Clint, and I added the comment \"str should be pretty, even under pretty(False)\" to explain a test.. Yeah, it seems best not to have trailing commas in reprs.. Because it was removed in #1325.. > If the while with a break in the condition is nested inside another loop, then it will break the outer loop on the first iteration, but the outer loop after that, which is weird and inconsistent.\nRight, that's what I was thinking.\nI'm not too worried about this in any case because putting a loop-control statement in a loop condition is a weird thing to do in the first place. \"Doctor, it hurts when I do this\", etc.\nHere's another version I thought of that's similar to your version:\nx = 3\n_hy_anon_var_1 = True\nwhile _hy_anon_var_1:\n    # Condition\n    print('hi')\n    _hy_anon_var_1 = bool(x)  \n    if _hy_anon_var_1:\n        # Body\n        print(x)\n        x -= 1\n\nThe bool is so the anon var stays the same even if the truth value of the object referred to by x changes (e.g., if x is a list and it's emptied).. Oh, jinx!. True. You could also write not not x.. We don't create anonymous functions when we don't have to because each function creates a new scope, meaning that setv won't set the variable that the user expects. Also, now that we have return, we need to make sure it returns from the right function.. The fact that (= 'foo \"foo\") has created a lot of strange bugs.. All right, how about some tests and documentation?. By \"documentation\", I mean the manual, not docstrings. Think of people like the guy who wrote #1256. How would they know without asking that using these functions is how you can use Hy in Python?. Sure, that makes sense.. > But I wonder if there's a way to tweak the compiler to make (->> ... (foo #*)) work.\nPossibly, using more compiler peeking into child forms. The thing is that #* x parses to a single form (unpack_iterable x), which (on Python 3) compiles to a single node of type ast.Starred. (f a #* b c) compiles to a function call with 3 arguments, not 4. That's why the parser requires a term after the #*. What you'd want is to have #* parse to its own object, like a new HyModel type called HyIterableUnpack, and then make it the compiler's job to join HyIterableUnpack with a following form into an ast.Starred in the cases where Python allows this.. Is there any __future__ import that's useful in Hy, though? print_function is on by default in Hy on Python 2; it may not show up in the hy2py output, but hy2py is intended as a debugging tool and there's currently no guarantee that it produces working code (see in particular #970).. Yes, but what I'm saying is that (import [__future__ [print_function]]) is not useful in Hy anyway.. I reviewed the various __future__ features. On Python 3, all of them are already on. On Python 2.7 (which is the only version of Python 2 we support), nested_scopes, generators, and with_statement are forced on by Python itself, and Hy enables division and print_function. That leaves absolute_import and unicode_literals. I propose we turn these on and ban __future__ statements in Hy code. We already fake the effect of unicode_literals; we might as well use it for real. So the only substantive effect this should have on the language is to enable absolute_imports for Python 2.\n. > Does PyPy have any __future__ imports that CPython doesn't?\nNot any documented ones that I can find.\nIf Python 3 or PyPy add other __future__ features, or if we decide to support more implementations, in the future (yuk yuk yuk), we can add support for them then. But in the meantime, it's easier and probably less confusing to users to just ban __future__ with an informative error message.. Aw shoot, the Python 3 documentation shows that there is in fact a __future__ feature that doesn't exist in Pythons < 3.5 and won't be forced on till Python 3.7, namely generator_stop (PEP 479). So I guess we need to support __future__ after all, unless we want to force it on in Pythons 3.5 and 3.6 (the only versions in which it is available but not mandatory).. I say that the README is part of the documentation.. Generally, this looks good.\n\nSee CONTRIBUTING.rst for guidelines about commit messages, NEWS, and AUTHORS.\nIn test_importer, import read_str and hy_eval directly from hy, since that's the interface you want to test.\nDefine eval_str inside test_eval, since it's only used there.\n. Also, could you describe the eof parameter of read in its docstring? Alternatively, read could perhaps be rewritten without it. The current implementation looks kind of weird.. Cool. Don't forget about https://github.com/hylang/hy/pull/1369#issuecomment-320468126.. I thought that might be it. It happens to the best of us.. This doesn't need to be a separate PR; just put this commit on top of the other one in #1369.. I'm surprised you're not advocating a more parenthesized (or square-bracketed) syntax, considering your concern for indentation. I know that, in Common Lisp, one of the reasons that iter was created to replace loop was that loop's syntax wasn't deemed Lispy enough. loop is definitely less Lispy than this proposal, though: it has bits that look like infix operators, among other things. At any rate, a keyword-based design seems fine to me.\n\nI also agree with moving the body to the end. That bit of right-to-left-ness in Python's comprehension syntax always seemed odd to me, and looks even odder in Lisp.. > Maybe most of this happened before we brought you on\nThat's right; I only joined core in November 2016.. I've thought about this a bit. There are lots of natural ways to extend the idea of comprehensions, like your :let proposal. But, trying to simulate comprehensions (which we'd need to in order to compile the extended versions) seems error-prone because of scoping issues. I propose instead that we have fairly restrictive special forms that always produce real comprehensions, and encourage the use of generators and nested loops for anything that can't be accomplished with a comprehension.\nFor parallelism and brevity, suppose the comprehension forms are called compl for list comprehensions, compd for dictionary comprehensions, comps for set comprehensions, and compg for generator expressions. The following\n (compl\n   :for x (range 5)\n   :for y (range 8)\n   :if (!= x y)\n   :for z [x y]\n   (* x y z))\n\nwould compile to\n [x*y*z\n     for x in range(5)\n     for y in range(8)\n     if x != y\n     for z in [x, y]]\n\nSo only the keywords :for and :if (or maybe we should spell :if as :when, since there's no else clause) are supported. The generation value is the last form, except for compd, in which case it's the last two forms. It is an error if, during compilation, a statement is produced at any step; every part needs to compile to a pure expression.\nThe generator equivalent to the above is (without nested indents, to make the parallelism clearer):\n(list ((fn []\n  (for [x (range 5)]\n  (for [y (range 8)]\n  (when (!= x y)\n  (for [z [x y]]\n  (yield (* x y z)))))))))\n\nSince defining and immediately calling a function is often useful, particularly now that we have return, it could make sense to add a macro such as (defmacro cfn [&rest body] `((fn [] ~@body))) to core.. So, as of Python 3, there is no semantic difference between comprehension syntax and an anonymous function (except for return, continue, and break, which aren't legal in Python comprehensions anyway)?\nIn that case, is there any reason to support comprehensions beyond the rule that it should be possible to produce any valid Python construct with Hy?. Aw geez, I didn't realize that stuff like [(yield x) for x in range(3)] is legal Python. I know [x for x in range(3)] is a list comprehension and (x for x in range(3)) is a generator expression, but the form with yield is a strange hybrid with no clear use case.\nAnyway, given that scoping in a comprehension works just like function scoping, I guess we can use a special form that automagically produces a function instead of a comprehension when necessary. If we keep the :for and :if/:when keywords, we can let the user insert arbitrary forms in the middle, in which case they're inserted into the corresponding parts of the nested loop. For example,\n(compl\n  :for x (range 10)\n  (setv y (* 2 x))\n  :for z (range y)\n  (foobar)\n  (+ x y z))\n\nbecomes\n(list ((fn []\n  (for [x (range 10)]\n    (setv y (* 2 x))\n    (for [z (range y)]\n      (foobar)\n      (yield (+ x y z)))))))\n\n. Wouldn't it be better to provide compl etc. as fairly literal equivalents of Python comprehensions and doseq as a macro using compl, rather than the reverse? We want the special forms to be equivalents of Python constructs and fancier stuff to be moved to macros, right?. It should not. I'm sorry if I seemed to suggest otherwise.. To be clear, none of the Hy code you've quoted here includes a function definition. In Hy, def is just a synonym for setv, or in Python terms, =. Functions are defined with defn or fn.\nThe behavior of your code does seem weird, but I wouldn't know where to look in Hy without a way to replicate this bug that uses only Hy itself.\nIf Calysto Hy didn't have this issue with previous versions of Hy, the changes to the REPL that occurred in #1246 are probably the culprit.. I'm going to close this, but let's reopen it if a way is found to replicate the bug with Hy alone, or if it's otherwise verified that the problem is with Hy.. In the future, remember to make a feature branch rather than asking to pull from master.. We forgive you. Thanks for contributing. :). > Not sure how to test this though...\nThe first thing to try would be can_compile(\"(defmacro foo [] (try None (except [] None)) `())\") in test_ast. Be sure it fails without the change, of course.. There should indeed be 534 tests, and that's what Travis got as recently as this job. Odd.. Looks good to me. Would you please\n\nPut the new test in test_ast.py, rather than putting it in a different file and importing can_compile from test_ast.py\nPut the URL https://github.com/hylang/hy/issues/1350 in a comment at the top of the test\nUpdate NEWS. So far as I can tell, the only reason test_compiler.py exists separately from test_ast.py is that historically they had different implementations: test_ast.py used Python's built-in facilities whereas test_compiler.py used Nose. There isn't a very meaningful difference in what is actually tested, although the names of the files suggest there might be such a difference.. At any rate, given the tests that are already in the files, this test is more like the ones in test_ast.py and hence seems to belong there. In the future, we should probably move the handful of tests in test_compiler.py into test_ast.py, then get rid of the compilers directory, and perhaps rename test_ast.py to test_compiler.py.. Okay, could you change the second commit message to explain what is tested, or just meld the commits together?. Sure, use git rebase -i master, or git reset HEAD~ followed by git commit -a --amend.. Aww, don't feel bad. Learning this stuff can be an uphill battle.. You know, we could also get rid of the if macro, rename if* to if, and make cond a bootstrap macro. There's no real reason to have both cond and multi-branch if in the same language, right?. > We should also consider removing if* from the docs to discourage people from nesting it in their own macros.\n\nAgreed; the starred special forms that are supposed to be internal to Hy shouldn't be documented for users.. > In Hy, cond has an implicit do after the condition, which is really only good for side effects in the imperative style.\nAnd for setv, since there's no let.. Travis is showing a failure because the Python 3.5 job was canceled before it ran. You can probably get it to run the tests again with something like git commit --amend --reset-author && git push -f. Or just test Python 3.5 locally.. > Is this even really possible right now?\nMy guess is yes. You can try making a test in test_ast.py that runs can_compile and recursively walks through the output counting the number of ast.Assign nodes.. Yay, it does.. I'll take a crack at testing.. Actually, I don't think it works. (if 1 1 (if 2 (setv x 2) (if 3 3))) and (cond [1 1] [2 (setv x 2)] [3 3]) still use two anon vars, not one. This might be related to how setv now returns None.. @kirbyfan64, are you still working on this?. If you haven't already, I would try putting print statements in compile_if to ensure that it's seeing the Hy model tree you're expecting it to see.. It still doesn't seem to work:\n$ echo '(cond [1 1] [2 (setv x 2)] [3 3])' | hy2py\nif 1:\n    _hy_anon_var_2 = 1\nelse:\n    if 2:\n        x = 2\n        _hy_anon_var_1 = None\n    else:\n        _hy_anon_var_1 = (3 if 3 else None)\n    _hy_anon_var_2 = _hy_anon_var_1\n\n. I'm closing this for inactivity. Please reopen it when you'd like eyeballs again.. I'm super impressed that you managed to pull this off, and py2hy would be awesome to have, but I'd rather have Hy's lowest-level bits implemented in Python rather than Hy. Self-hosting comes with a lot of necessary complications. If the alternative is writing a compiler in assembly or C or something, it can be worth it. But Python is already a powerful language. I don't think we're going to much improve the readability or maintainability of the codebase, or even make it much shorter, by replacing all the Python with Hy.\n. Hydiomatic was last updated in March 2016, and Hy has changed a lot since, so it probably won't be useful without updates.. I don't think this is correct, because HyModels may carry mutable attributes representing their source position.\n>>> import hy\n>>> x = hy.HyComplex(\"3+4j\")\n>>> x\n(3+4j)\n>>> x.start_line = 5\n>>> import copy\n>>> y = copy.copy(x)\n>>> y\n(3+4j)\n>>> y.start_line = 6\n>>> x.start_line\n6\n\n. @kirbyfan64, I should ask if you still approve, since the implementation has changed completely.. How's that?. I see the motivation for using partition instead of zip, but why take the [`(get ~c ~k1) v1]) out of the list-comp?. That's true about sum, and we do indeed have shadow + here. Would you accept this?. Okay.. I don't like to keep merge commits inside a PR (as opposed to the merge commit that brings the PR into master), so I rebased it away.. Thanks!. @gilch @kirbyfan64 Is there any reason you guys aren't reviewing this? I thought we settled on the Lua style.. > There are competing priorities, that's all. I can make this a priority since you think it's important.\nMy own philosophy is that I should try to review PRs (that are ready for review, to my knowledge) before anything else (like writing issues, working on my own PRs, etc.), because PR reviewing seems to be the primary bottleneck for Hy development.\n. I think what you're seeing in the first example is a limitation in how quoting works. The generated code is HyString('bar'), which doesn't set the attribute. It seems clear that this isn't right, but I'm not sure what needs to be fixed.. I think HyASTCompiler._render_quoted_form needs an upgrade to set the attribute. I'm looking into it now.. Done.. > Seeing those elif isinstance statements in a super-long method makes me want to move that logic to methods in the individual Hy models themselves. It's another issue though. For now, it's more consistent this way.\nAgreed on both counts.\n\nBut perhaps it should have a shorter name than hashstring_delim now?\n\nIt doesn't make a difference to me. hashstring_delim just seemed like the most obvious choice. Is there any particular alternative you'd prefer?\n\nWe also need news and docs\n\nWill do.\n\nwhich should also specify that some number of ='s are the preferred delimiters when #[[ won't do, and there's not a specific reason to use something else.\n\nI disagree. I don't want to count =s. Let's let the reader decide, or at least defer this debate until a style-guide PR.. Done.. @gilch This good? I wasn't sure whether you wanted me to change hashstring_delim to brackets or you were just thinking out loud.. @gilch Done.. \"Bracket string\" seems as good as anything. I will likely get around to the mild inconvenience of editing this tomorrow.. Both changes made.. @kirbyfan64 How's that?. Whoops, I hadn't written the NEWS item or documentation yet. I probably should've done that after the first approval. I'll do it in a new PR.. Duplicate of #647, which is in fact fixed, but bugs don't get fixed in old releases.\n\nAre you planning a minor release soon?\n\nI'm not, no. I think twice a year is a good schedule, so I'm aiming to release 0.14.0 in January.. If you want the bleeding edge, why not install from master? That's what all the cool kids (i.e. me) do.. True, but you can refer to a particular Git commit. Then, pull and upgrade whenever you're ready.. If you're interested in contributing to Hy (and we do always need more contributors), this would be a good first pull request. It shouldn't be hard to do.. > Shouldn't we add this to tox too?\nGood point. Done.\n\nIs Travis actually running flake8 and coverage?\n\nCurrently, no.. And it looks like the last commit that Coveralls detected was in 2014.. Aye-aye, rebased.. Duplicate of #1272. It's probably best to make the whole tutorial Python 3 instead of switching versions mid-tutorial. (But in general, you're not wrong; the documentation isn't very good.). Looking good, thanks. There's still at least one raw-input in Hy code hanging around, so don't forget that. Also, you don't need a separate commit for each change when the changes are this small and to the same purpose. You can meld all your commits together with git rebase -i master.. Ah, yes, I missed the fact that you worked on master instead of using a feature branch. You should indeed use a feature branch in the future.. > (1L 2L 3L)\nThere shouldn't be trailing Ls when you're running Hy on Python 3. Are you sure this is correct? It's worth running through the code and making sure it all works and produces the right output, if you haven't already.. It would also be wise to say something like \"This tutorial assumes you're running Hy under Python 3; things are a bit different under Python 2\" near the top.. > I wasn't sure if you want these in the same pull request. Should I try to fix those examples anyway?\nIt's your choice. When you're ready, add yourself to AUTHORS in a new commit and I'll merge.\n\nThere are also more issues I wanted to discuss first before changing more of the tutorial, but maybe it's better to discuss that on the mailing list.\n\nWhichever you like, although I think issues and PRs are read more widely than the mailing list. I rarely look at the mailing list.\n\nOr is there already a plan to work on improving the tutorial?\n\nNope, no plans right now.. Sorry, when I said \"a new commit\", I meant a separate one. See CONTRIBUTING.rst.. I'll do it.. I couldn't push (\"permission denied\"; perhaps you unchecked \"Allow edits from maintainers\"), so I merged it manually.. I guess this is a trivial change and hence one approval suffices.. I probably created this bug when I redid the REPL. It shouldn't be hard to fix: put a try around the part of the code that calls the repl-output-fn and display any error message in a user-friendly way.. >  But then, wouldn't 0 be simpler?\nYeah, that's true.. Yeah, Hy is written in pure Python (and Hy), so it should be architecture-independent. I don't think there's anything to do here. Although, @longquan7, if you write any Android programs in Hy, that would be super cool, so totally let us know.\n\nthe inevitable AI toilet seats\n\nNow that's what I call /r/shittyprogramming! [Laugh track.]\n. Is this ready for review?. As I understand, this macro is meant to let you write something like\n(ifp f x\n  y1 :>> g\n  y2 z2\n  z3)\n\nand have that work like (ignoring issues of evaluation order and evaluation count):\n(cond\n  [(f y1 x)\n    (g (f y1 x))]\n  [(f y2 x)\n    z2]\n  [True\n    z3])\n\nIt seems better to have a more general construct like the following, which lets you specify the test directly rather than obliging you to use a binary operator and a starting value:\n(ifp (fn [y] (f y x))\n  y1 :>> g\n  y2 z2\n  z3)\n\nSince you'd usually need a fn, it would be convenient if it were anaphoric:\n(ifp (f it x)\n  y1 :>> g\n  y2 z2\n  z3)\n\nAnd if we use brackets like cond, then we get implicit dos and clearer grouping of conditions and outcomes. By using special syntax for the default value, we can ensure that the default value looks like an outcome instead of a condition.\n(condp (f it x)\n  [y1 :>> g]\n  [y2 z2]\n  [&else z3])\n\nI'd also like to see an econdp that raises LookupError instead of returning None when none of the clauses match, which is useful when you mean to be exhaustive.. > Clojure's condp does throw an exception when none of the clauses match, and so does my ifp. I used a TypeError though. If you want a default None you have to make it explicit.\nOh, that works, too.\nI don't see the point in forcing Hy's core to imitate that of other languages (beyond providing Python's preexisting builtins, which we do). We can take inspiration from other languages, by all means, but what's the sense in limiting ourselves to them? Where we can do better than Clojure or Common Lisp, let's do better. Besides, if you want to use Clojure, why not use Clojure? Compared to Hy, it has better performance, a more stable implementation, a bigger community, and comparable library support.. > I do use Clojure.\nSo, why use and improve Hy?\n\nobjective\n\nI don't see how there can be an objective argument for some design choice being better than another without a formalization of the goals of the language and how to evaluate proposals.\nBesides, I see no reason to presume that Clojure's or Common Lisp's (or Python's) choices were good ones. Some of them seem good, to be sure, but some seem bad. The people who worked on these languages had lots of experience, but experience doesn't guarantee good choices, either.\n\nA zero argument \"predicate\"\n\nI don't know what you mean by that.\n\nThinking about actual use cases, when would you ever need to use a single-argument predicate? When you have a partially applied binary operator handy.\n\nI shouldn't think so; it seems that one most commonly tests a single value at a time when testing different possibilites for suitability. Something like:\n(condp (clean? it)\n  [shelf ...]\n  [desk ...]\n  [floor ...])\n\n\nThat just leaves the extra brackets. They're the norm in Common Lisp. Either approach has tradeoffs (many of which are subjective), but Hy prioritized Clojure style over Common Lisp's. It would be more consistent to stick with that.\n\nI don't understand; more consistent how? We have both the bracketed cond and the unbracketed if.. Not actually relevant, but funny:\nhttps://twitter.com/planetclojure/status/908752041207414784. > Looks like NEWS doesn't mention deftag change.\nhttps://github.com/hylang/hy/blob/062e24d71f5582d12c06aaf549c3adcbb8b067c4/NEWS#L8-L9\nTo be clear, in line with what has been said above, tag macros are also documented, but only in the documentation for the versions of Hy that actually have this change.. Having it always return None does somewhat reduce the motivation for providing a shadow function.. > Why did we stop?\nIt looks like I forgot to add back flake8 when I redid the Travis configuration for pytest. As for Coveralls, that seems to have stopped running in 2014, which is before my time.. Huh, it looks like the redundant arg argument to some nodes is required by Python 3.3 but not later versions nor Python 2. Dumb old 3.3 is going to officially go out of its support window in a month anyway. Do you guys think it's okay if we just drop 3.3 now? If I fix this, we'll just have to remove the fix again in October.. > Make a separate PR to drop 3.3, and we'll discuss it there.\nOkay, it's #1401.. Rebased for the merge of that PR.. @kirbyfan64 The commit \"General compiler refactoring pass\" has most of the change in terms of sheer line count, but not much interesting is going on there. You could just review this PR on the basis of the other commits, if you like.. Yeah, it's not surprising that nobody seemed to notice it in real Hy code. The missing @checkargs in the implementation is more visible.. I think you've been confused by Hy's implicit return. Notice that in\ndef hi():\n    return 'Hello'\n\n'Hello' is not a docstring. If you want a function that has a docstring, does nothing, and returns None, you need to write that in Hy as (defn hi [] \"Hello\" None).\n. > Is there some reason the else in for* doesn't have an implicit do?\nNope, sounds like a bug to me.. To what end, speed? I doubt that compilation times for real code would benefit much from this.. > Woudn't you rather write (.popleft foo) instead of (setv foo (cut foo 1)) in your macros?\nUsually, I use (defn shift [l] (.pop l 0)). (The name shift for this is from Perl.) But on Python 3, (setv [a b #* the-rest] foo) works too.\n. > This is not just about speed. It's about providing the right interface for the use case.\nBut the interface is distinct from the implementation, right? For example, we can give HyExpression a method popleft even if it's a list internally.. 600 builtins is too many. Perl has around 200 (depending on how you count), which is also too many (many of them are no longer very useful, and I suspect they predated the implementation of modules in Perl). Arguably, Hy already has too many. There's no shame in moving things to hy.extra or so.. The most straightforward solution to auto-importing woes is to replace the current auto-importing magic with from hy.core.language import * at the start of the REPL and the top of each source file. Then Hy core functions would work very much like Python builtins.\nThings like dynamically scoped variables and protection against shadowing of core function names in macro expansions would be nice. But it's hard for me to guess in advance whether your plan would work and what the side-effects would be.. > Importing everything at the top doesn't help with #1367.\nYes, Hy will still need to correctly position future statements, module docstring, and core imports.. > You wouldn't expect this to work, but it does. Maybe it shouldn't\nPresumably, it's not supposed to, and whoever wrote the \"Can't assign to a builtin\" feature forgot about function parameters etc. as ways to change those names. We could conceivably ban assignments to + everywhere (more precisely, everywhere except Hy core) or nowhere, but the status quo makes no sense.. I think we might be best off with the shell option of subprocess.Popen off. Then we don't have to worry about this stuff.. With shell off, you need to pass Popen a list of the command and its arguments instead of a shell command as a single string.. Confusingly, it looks like even when you turn shell off, a single string, rather than a list, will be interpreted in a platform-dependent manner. By contrast, if you pass a list, the library will automatically convert it back into a string in the format Windows expects when running on Windows. It seems best to provide a list in any case, although we can still give run_cmd some syntactic sugar that the individual tests can use, of course.\nI know this would be a bigger change than you were planning when you wrote this PR, so I'll do it if you want.. So it does! I didn't read your latest changes closely. Sorry.\nIs the change of quotation marks still necessary?. Sounds like a plan!. > development on Windows\nThere's your problem.\nBut seriously, Hy is mostly frozen whenever two Horsemen are inactive, and that seems to be the case right now.. It makes sense that this happens: we need to make sure the generated destructuring code is placed after the docstring when there is one.. > Strangely, this requires a compiler anon var, even on Python 2, which should just be able to do it.\nIt's not worth implementing Python 2's native support, in my opinion. Python 3 is the future and all that.. Yep, no reason to do with a special form what we can do with a macro.. > AttributeError: 'HySymbol' object has no attribute 'start_line'\nIt looks like x isn't getting position information set.\nHave you seen a way to replicate this without using macro-error in user code?. In particular, I don't believe macro-error is designed to take a quoted form, just an argument to the macro (or None).. Fair enough; that's why I think this and #1413 are properly the same bug.. Hmm. Perhaps what's needed is a try for self.showtraceback(), then.. Looks like a duplicate of #818.. Any exception raised while printing an exception will crash the REPL, because the REPL tries to show the user the exception.. I don't disagree. But it seems that that's your bug of interest. Beyond that, this seems to be a duplicate of #818, and #1412 seems not to be a bug (you're not supposed to use macro-error like that). So I say you should close one and retitle the other.. @gilch Would you object if I did that?. Minimal example: (raise (type \"x\" (, BaseException) {\"__str__\" (fn [self] (/ 0))})) crashes the REPL with __console__.x: <exception str() failed>. The bug is probably catching Exception instead of BaseException here or here.. That's pretty weird. x should indeed be in scope. By the way, running the file directly, instead of importing it, gives the same error.\n\nlooks like the do isn't required.\n\nIt shouldn't affect much of anything\u2014import_buffer_to_hst already wraps its argument in do.. Wait a minute, I didn't think this through. x is in fact not in scope in the examples that don't work. Take, for example,\n(setv x \"Spam!\")\n\n(defmacro foo []\n  `(print ~x))\n\n(foo)\n\nIf the macro were defined to expand to '(print x), it would work fine. But the ~ causes x to be evaluated at compile-time, not runtime, and x isn't defined at compile-time, because (setv x \"Spam!\") hasn't been run yet.\nThe reason the REPL example works (when the statements are entered separately) is that it forces (setv x \"Spam!\") to be evaluated before (foo), contrary to the usual procedure of expanding macros before running any non-macro code.\nSo, everything seems to be correct here.. So how are we feeling about this?. Delegating the expansion process to helper functions in the same module works fine, provided you only invoke the macro after the file is compiled, rather than inside the very same file:\n$ echo >foo.hy '(defn f [] `3) (defmacro m [] (f))'\n$ hy -c '(require foo) (print (foo.m))'      \n3\n\nHere, f exists by the time m is called. By contrast, the only way (defn f [] `3) (defmacro m [] (f)) (m) can work is if the defn is executed before (m) is expanded into (f). What semantics would you propose here? The way Hy currently works is that macro expansion happens during compilation, and only after a file is compiled is any regular code executed.\nI've never figured out how these gory details work in other Lisps, so I can't speak for them.. > At minimum, compile the files incrementally, one top-level form at a time.\nThat already happens. What you'd need is to execute the top-level forms incrementally, too, rather than compiling the whole file and then executing it.. In any case, this seems to be a design question rather than a bug, so I'm retagging to complaint / disgust.. You mean, what does it allow you to do? To call the macro in the same file it's defined in. The macro will work when called like this provided it doesn't rely on normal code in the same file (like defns) having already been executed.\nBy the way, I don't think the distinction between globals and locals is relevant here. You can't use what would be a local variable, because it isn't defined yet, either. For example, (defn f [] (setv x 1) (defmacro m [] x) (m)) raises NameError.\n. I included an example in #1430 showing how to use eval-and-compile or eval-when-compile to make macro subroutines.. Indeed.. N.B. You can use eval-and-compile for variables, too.. We all agree that it's desirable, all things being equal, but it seems to entail deep changes to Hy's compilation process that I think would be worse than the original problem.\nAs things are now, macro expansion happens at compile-time, and a whole module is compiled before any of it is run. This means that you can translate a file that calls macros into Python, or compile it into bytecode, and all the macros have been resolved by the time you have your Python code or bytecode. The Python or bytecode doesn't have the macro calls; it has the actual expanded code. I think that's cool. It means you can move some long-running computation that only needs to happen once to compile-time. It also means you can do arbitrarily fancy things with macros and, if you're careful, still produce Python code that doesn't depend on Hy at all.\nIf we instead move to an incrementally compiling system, then the produced Python code or bytecode, in order to be equivalent to the original Hy, would need to keep all the macro calls, wouldn't it? I think that's what other Lisps do when you compile a file.. Wrapping the whole file in eval-and-compile doesn't work; you'd need to put each top-level form in its own eval-and-compile instead.\nIt may well be at this point that your understanding of Hy's compilation process is beyond mine (because you've been working with it so intensely recently, whereas I've cooled it with the PRs since I started at Mount Sinai). Let's consider an example to make some of the complexities here concrete. I'll call it sandwich.hy:\n(print \"Top\")\n(setv x [1])\n\n(defmacro m []\n  (import time)\n  (time.sleep 3)\n  (.append x 2)\n  x)\n\n(print (m))\n(print x)\n(print \"Bottom\")\n\nCurrently, this program doesn't work (because m can't see x). What if we wrap each top-level form in an eval-and-compile? This yields wrap.hy:\n(eval-and-compile (print \"Top\"))\n(eval-and-compile (setv x [1]))\n\n(eval-and-compile (defmacro m []\n  (import time)\n  (time.sleep 3)\n  (.append x 2)\n  x))\n\n(eval-and-compile (print (m)))\n(eval-and-compile (print x))\n(eval-and-compile (print \"Bottom\"))\n\nhy wrap.hy prints:\nTop\n[1, 2]\n[1, 2, 2]\nBottom\nTop\n[1, 2, 2]\n[1]\nBottom\n\non its first run, including two sleeps of 3 seconds, and\nTop\n[1, 2, 2]\n[1]\nBottom\n\non its second (using the bytecode), including no sleeps.\nWhat do you think sandwich.hy ought to do on each of its first and second runs?. Are you saying that sandwich.hy would still crash with your proposed changes? If so, how would it crash? I presume it wouldn't be the same as what currently happens, a NameError for x during the expansion of m, because allowing that kind of reference is the purpose of the change.. In order for (print x) to print [1, 2], the macro would have to have been expanded recently enough for the (.append x 2) to still be in effect. That's the sort of thing that (so far as I can see) can't happen if bytecode has already had macros expanded. Instead of (print (m)), the effective code at that point will be (print [1 2]), so the bytecode doesn't even contain (.append x 2).. > I don't see why we couldn't make it produce the later, if desired\nI assume you mean produce something like (print (do (import time) (time.sleep 3) (.append x 2) x)). That's why it's undesirable: the program needs to do the work of expanding macros (represented in this case by the sleep time) every time you run the program.\n\nbut I also don't see the issue with the current result (relative to this topic). How would it affect our ability to resolve x during macro expansion, or vice versa?\n\nIf m can see x, it can modify it. If m can modify x, later expressions, like (print x), can be affected by whether m was expanded during the current run. If (print x) can be affected by whether m was expanded during the current run, then either (print x) can print different things on the first run and the second run, or m needs to be re-expanded on every run. Does that make sense?. The subsequent sentence states the two problematic possibilities: \"either (print x) can print different things on the first run and the second run, or m needs to be re-expanded on every run\".\nIf you can think of a way for m to see x without such things happening, I'm all ears.. Huh. So, it sounds like, of the two \"problematic possibilities\", you're taking the first (\"(print x) can print different things on the first run and the second run\"), and so you would have hy sandwich.hy print\n Top\n [1, 2]\n [1, 2]\n Bottom\n\n, with the sleep, on its first run, but\n Top\n [1, 2]\n [1]\n Bottom\n\n, without the sleep, on its second run. (Taking possibility 2, expanding macros on every run, would print [1, 2] twice on both the first and second run. Which is what you previously said should be expected.) Is that correct?. And eval-always does a sort of partial expansion where the macro body is inlined, but not fully evaluated until control actually reaches the point of the macro call.. I guess I just can't tell what you're envisioning. But at any rate, if you can program a design that works better than anything I can think of, so much the better for Hy!. What would you think of a help macro or function that asks for disambiguation if necessary? That is, it would recognize an ordinary value, a macro, or a tag macro, and if more than one of these existed, it would prompt you to choose one.. > Why make the user take a second step when they already know what they want?\nFor when the user doesn't. Functions and macros aren't visually distinct, and accepting #foo as a request for documentation on the tag macro foo seems useful for newbies. Asking for disambiguation also provides a useful warning of things sharing names when the user wasn't previously aware of this. If you also want users to be able to jump immediately to the one they want, you could have an optional second argument to indicate the type.\n\nPrinting off all three would be a better approach, but if the docstrings are long enough, that would make the user scroll back to find the right one, which is a second step again.\n\nRight, and Python help strings can be very long (usually for classes, since every method's docstring appears when you call help on the class). So I recommend against this.. True. (You'd think that would be more obvious to me given how much I've mucked about with lexing octothorpe stuff.) Allowing (help \"#foo\") makes sense. You could still get documentation for str or unicode with (help str) or (help unicode), assuming we're special-casing string literals.. We could also go further and make the REPL treat lines beginning with help magically.. This makes sense prima facie, and could help choose something for require to compile to (#1268).. That's an A+ issue title.\nWe have hy.extra.reserved, so we should probably be using that.. Okay, I don't use this feature, so it's a non-issue for me. If anybody else wants this, reopen the issue.. You can leave the matter of making the else of for* accept multiple statements to #1419, but for this PR, we might as well accept multiple statements from the beginning.\nOtherwise, this looks great. Well done!. Looks good. Just meld your changes back into the first commit. (I think this can be done directly with rebase -i.). Yep. Thanks a bunch, and welcome aboard the Hy-pe train.. I think it should be merged after such an addition.. Looks good to me. @gilch?. > In Hy, special forms always take precedence over any other use of the symbol when in function position.\nWith the exception of when you use #* ~~or #**~~ in the form, in which case it's interpreted as a function unconditionally. But I think that's the only exception.. Yeah, that's strange. (print (if #* [1 2]) :sep \"/\") ought to try to call a function named if, I think.. On second thought, #* need not force its parent not to be a macro. The only reason I created the exception was so that special forms like + will get their shadow function called, because Python's native operators don't allow unpacking. Thus, (+ #* a) calls hy.core.shadow.+ and works. This shouldn't be an issue for any macros, whether core macros or user macros.\nPerhaps it would make sense to restrict the exception further to only apply to special forms that actually have shadow functions.\n. Travis suggests it works on Python 3, but not 2.. I guess that's right. It would be similar to how for (and now while) have an implicit do possibly terminated by else.. This way madness lies, but if you're brave enough to try, far be it from me to stop you.. Probably the reason that defmacro and deftag are special forms instead of macros is that they need to call _compile_time_hack (so you can call the newly defined macro later in the same file). It might be neater to use a generic special form that causes an expression to be evaluated at compile-time.. > With #1414, and #1416, would we still need _compile_time_hack?\nI'm not sure. It would probably depend on the details of the new semantics. For example, if each top-level form were executed after being compiled, then _compile_time_hack would still be necessary if you wanted a macro defined in a form to be available later in the same form.\n\n\ncauses an expression to be evaluated at compile-time.\n\nDoes eval-when-compile or eval-and-compile do that?\n\n\u00af\\_(\u30c4)_/\u00af\nUnrelatedly, if you're still interested in symbol namespacing (#277), it's probably worth thinking about how that would interact with let. There may even be a nice to way implement let in terms of it.. If you haven't already seen it, #1216 has a list of let-related issues that could be useful.. You seem to still have a few issues listed under ;;;; deferred.\nThe documentation should explain that the let is implemented by mangling variable names, since this breaks introspection (e.g., (let [x 1] (get (locals) \"x\")) does the wrong thing). Similarly, it seems worth mentioning that the variable exists at least until its parent function terminates, so leaving a let won't trigger a destructor (__del__), and let variables bound outside a function will hang around as globals. (You might want to begin mangled names with an underscore so import * won't bring in let bindings.) Finally, the complex way that let interacts with macros is not obvious.\n\ndefclass will assign the class to the Python scope, even if it shares the name of a let binding.\n\nThis is true for the class name, but class member definitions will neither assign to the unmangled name nor the variable introduced by let, but instead, to a class variable with the let-mangled name. For example, (let [x 2] (defclass C [] [x 4])) compiles to :let_1235::x = 2; class C: :let_1235::x = 4. Likewise with (defclass C [] [] (setv x 4)). Is this a bug?\nIs it a bug that (let [x 2] (defn f [] (setv x 3) x) (print (f)) (print x)) creates a new local x for f? Given, that's how Python usually works, but I thought let was supposed to override the usual scoping rules. The inner x does get mangled, but without an injected nonlocal or something, it still ends up as a new variable.\n. The new changes sound good to me. I'm impressed you managed to make defmacro a macro. Yeah, we can kill most of #1430.\n\nI think I should make import and requrie protected from any let mangling.\n\nFor require, agreed. let isn't supposed to touch macro names. For import, you don't want to mangle the original module name, since that would cause the import to fail, but you want (import foo) compiled to import foo as _;let|1235['foo'] or so when foo is let-bound, right? Similarly for from foo import.\n\nI don't understand what scope eval_and_compile/eval_when_compile use. Should I let-mangle symbols in them or not?\n\nThey're pretty much the same as creating a macro and then immediately calling it. So, they're in the compile-time global scope. Your strategy, as I understand, is to expand all macros in the body of let and only then mangle. So I think the logical thing to do is expand eval-and-compile and eval-when-compile, and then mangle the results in the case of eval-and-compile (for eval-when-compile, there's nothing to mangle).\n\nHy special forms with anon vars also have this issue, and so do a lot of other macros that create gensyms with setv. Is the let documentation really the right place to put this?\n\nThat's a good point. It may be an important difference that no specific lifetime is implied for our other anonymous variables and gensyms, whereas for (let \u2026), it seems to be expected that the created variables are no longer around once the let is done. Ultimately, our let isn't going to have the exact same semantics as that of any other Lisp (because so it is with Hy as a whole), so it's up to us what to do.\n\n\nFinally, the complex way that let interacts with macros is not obvious.\n\nWhat do you mean?\n\nChiefly that let expands the macros inside it before doing anything, unlike all other Hy macros, which treat macro calls like any other form. Consequently, e.g., (setv x 1) (defmacro m [] 'x) (let [x 2] (print (m))) prints 2, not 1 as you'd expect if you expected a more literal notion of lexical binding. Also, (eval-when-compile (setv x 1)) (defmacro m [] x) (let [ignored (eval-and-compile (setv x 2) \"ignored\")] (print (m))) prints 1, not 2 as you'd get if the (eval-and-compile \u2026) in the binding list was expanded before (m); most of the time, macro calls and eval-X-compiles are expanded in the order they appear. I don't think any of these things are bugs, but they might be surprising.. Wait a minute, guys, are you sure this is ready to merge? import hasn't yet been tended to and the unusual way let treats macros isn't documented. I'd back this out till it's all done.. @kirbyfan64 Also, you should rebase rather than leaving a merge commit inside the branch, per CONTRIBUTING.rst.. The other project wants you to include a merge from master into the PR's branch, rather than the reverse? I wonder what the point of that is.\nOkay, I'll open issues.. @rkday Did you see @kirbyfan64's comment above?. Extending try to take multiple body forms means that we now need to be a bit more careful about identifying the except, else, and finally clauses. Consider\n => (try 1 (\"except\" [ValueError] 2)) \n 1\n\nThis should try to call the string \"except\" as a function, but instead the string literal is recognized as the start of an except form. You may wish to use some of my code from #1432 (or just use it as a reference).. By the way, a rebase doesn't trigger notifications to PR participants, so you might want to add a comment that's just \"Done\" or something in that case.. @kirbyfan64 Look good?. @rkday Did you see @tuturto's comment above?. Looks good to me. @tuturto?. It looks like -> is working as intended.. Typing (repr '[1 2 3]) at the command line is requesting a repr of a repr, so that makes sense, but ValueError expects a string, so the additional layer of repr imposed by HyMacroExpansionError doesn't seem to be helping. Contrast with:\n=> (raise (ValueError (repr '[1 2 3])))\nTraceback (most recent call last):\n  File \"/home/hippo/Desktop/hyenv/hy/hy/importer.py\", line 198, in hy_eval\n    eval(ast_compile(_ast, \"<eval_body>\", \"exec\"), namespace)\n  File \"<eval_body>\", line 1, in <module>\nValueError: HyList([\n  HyInteger(1),\n  HyInteger(2),\n  HyInteger(3)])\n\n. No idea; it's pretty weird. :/. Actually, ValueError will take a non-string and stringify it, but this doesn't seem much better:\n=> (defmacro m [x] (raise (ValueError x)))\n<function _hy_anon_var_1 at 0x7fcd279f1400>\n=> (m [1 2 3])\n  File \"<input>\", line 1, column 1\n\n  (m [1 2 3])\n  ^---------^\nHyMacroExpansionError: b\"expanding `m': ValueError(\\x1b[36m\\x1b[22mHyList\\x1b[39m\\x1b[22m\\x1b[36m\\x1b[22m([\\x1b[39m\\x1b[22m\\n  HyInteger(1)\\x1b[36m\\x1b[22m,\\x1b[39m\\x1b[22m\\n  HyInteger(2)\\x1b[36m\\x1b[22m,\\x1b[39m\\x1b[22m\\n  HyInteger(3)\\x1b[36m\\x1b[22m])\\x1b[39m\\x1b[22m,)\"\n\n. I've updated this; it's ready for review now.. @kirbyfan64 How do you feel about my reply?. What's the status of this?. Okay, I'll close the PR, but open a new issue for those things if you want to and we don't already have one.. > compl and comps need to set a [] or #{} to a gensym, and then .append or .add to it (instead of yield) and finally return that; or it won't behave consistently with the expression version.\nI think those two strategies should have the same effect. Can you provide an example of inconsistent behavior under the current implementation?\n\nlist-comp and friends should be removed\n\nYep, it's on the to-do list.\n\nBut then compl could be named list-comp. I don't might having a shorter name for something we expect to use often, but s-comp seems a lot less confusing than comps, which could easily be confused with comp.\n\nSo you'd prefer l-comp, s-comp, d-comp, and g-comp? (Honestly, I just picked the current names so they'd be alphabetized next to each other in the documentation etc.)\n\nAnd finally, the syntax doesn't seem to be compatible with for, which means only the comprehensions get it.\n\nRight. I'm not suggesting any changes to for here.. I think those kinds of constructs are actually a bug.. >> I think those kinds of constructs are actually a bug in CPython.\n\nI think that's part of the spec.\n\nThe language reference for Python 3 says \"The yield expression\u2026 can only be used in the body of a function definition.\" Besides, it's hard for me to see why this construct would've been designed to work seeing as it serves no apparent purpose.\nBut there's no reason I can't switch to .append / .add / dictionary[key] = \u2026 instead of yield, I think. It will just be a bit more verbose to implement, possibly.\n\nCouldn't (compl :for x [1 2 3] (* x x)) be written like (for-list x [1 2 3] (* x x))?\n\nYes, but not, e.g., (compl :for x [1 2 3] (f) :for y [1 2 3] (* x y)).\n\nI've thought for some time now that Hy's for should act like doseq, including the modifiers\n\nI guess I've never seen the logic in that, beyond \"Clojure did it\".\n. > (for [x [1 2 3], y [1 2 3]] (* x y))\nWhere did the (f) go?\n\nIf you'd prefer to get rid of for altogether and just use for* (we'd rename it to for) that works for me too, I guess.\n\nThat works for me too, I guess. It's out of scope of this PR, though.. > it's certainly not out of the scope of #1371, which this PR purports to implement.\nOkay, it's your issue. Removed above.\nSo you aren't on board with this PR because it doesn't implement the same keywords for for. Is that correct? I ask because I wouldn't want to make other changes you request only for you to reject it anyway.. > These aren't the changes I requested in #1371.\nCorrect. I meant changes to this PR.\nTo clarify, if I change to an .append / .add / dictionary[key] = value implementation, and change the names to lcomp, scomp, dcomp, and gcomp (the hyphens weren't necessary, come to think of it), would you approve this PR? You mentioned that you didn't like how compd uses its last two arguments as the final values, but you didn't seem to settle on an alternative you liked. Maybe the most obvious choice would be to require the last argument of compd to be two forms in a pair of square brackets; the brackets would be interpreted as special syntax like in for or defn or your let rather than a list display.. @gilch What do you think of the proposal?. > Approving this would probably prevent me from doing #1371, which adds Clojure's :let and :while modifiers to comprehensions, and to our nested for macro.\nI can't speak for for, for which I have no intention of adding additional features, but there is no reason that :while could not be added to the current implementation, and :let would be redundant with a regular (setv ...), if I understand correctly.\n\nThe first :for in the proposed syntax is redundant.\n\nCoincidentally, this will no longer be the case if we add :while.. So in place of what is currently (for [x xs] (foo x) (bar x)), you'd write (for x xs :body (do (foo x) (bar x)))? That seems like a lot of boilerplate for a plain for loop.. To be honest, it makes me feel a little faint to think of rewriting every for loop in every one of my Hy programs. I know we're young enough that we don't have to maintain backward compatibility, but it seems like a lot of heat for a little light. So I would suggest we stick to comprehensions and leave for alone for now.. Hmm, I like that better. Two suggestions:\n\nFor the versions other than plain for (a.k.a. fordo), remove the square brackets. They're redundant, because there can be only one returning form.\n\nIf you want :let x 5 to work like :do (setv x 5), which seems like the most obvious way to do it to me, let's call it :setv or something instead of :let, so as not to suggest a connection with your new let, which is quite a different animal.. Also, be aware of the fact that to maintain continue and break behavior in for loops, we'll need to compile for loops as something like\nfor x, y in hy_anon_generator():\n     [ body of the loop ]\n\n\nwhich means that the body won't be in the same function as the earlier parts of the (for ...) construct. I guess we'd choose the variables on the left side of the in by taking each variable from a for clause and each variable from a :let clause.\nAre you okay with that?. Okay. So (for ...) will generate nested loops, with no function declarations, whereas forlist (or lfor) and the other comprehensions will make an anonymous function, and hence, Python 3's distinction between leaky for loops and non-leaky comprehensions will be maintained. But in both cases, break and continue will refer to the innermost loop.\nShall I go ahead and implement this, then?\n. That sounds like a \"yes\". Very good.. Yeah, I think for will have to be a special form.. I'm rethinking the issue of implementing lfor with .append, sfor with .add, etc. instead of using a generator for everything. The only behavior this seems to make a difference for is yield in a comprehension, which, if it isn't a bug (and I'm pretty sure it's a bug, even if implementations other than CPython do the same thing), still has no use I know of and defies the specification. So I don't see the benefit. And the cost is more complexity in the compiler logic for these constructs, which is already complex, as well as longer and more complex generated AST. It's a lot of overhead for nothing.. As I'm writing it now, for uses pretty much the same compiler code as all the comprehension forms. I don't think you'd be able simplify the compiler much by farming out comprehensions to macros. But you can take a look for yourself once I'm done.. Closing in place of #1468.. You also have the misspelling \"peform\" and comma splices in the docstrings of the shadow functions.\nOtherwise, this looks good.. > breaks code introspection\nWhat do you mean?. I see.\n\nI dislike xi as a macro and think implementing it as a compiler construct like was done with the unpacking generalizations would be better.\n\nWhy's that? We always try to implement things as macros rather than special forms when possible, to make the language more flexible and the compiler simpler.. You seem to be concerned by the syntax of xi rather than whether it's implemented as a macro or as a special form. The choice of implementation, when something is possible to implement either way, should make no difference for syntax and little difference for semantics.. Currently, flatten uses coll? to decide whether to flatten something. This example constitutes a good argument that coll? isn't the right criterion. But it's not clear what we should use instead. Checking for the existence of __getitem__ is perhaps the most obvious choice, but this wouldn't flatten sets and frozensets, which we probably do want to flatten.. By the way, if you just want to concatenate one level of iterables in x, without recursive flattening, you can use  (reduce + x) or (sum x []).. To clarify, @tuturto, did you expect [{:one 1 :two 2} {:three 3 :four 4}] because you forgot that flatten was recursive, or because you thought it would leave dictionaries in particular untouched?. Yes, it's allegedly an implementation detail, but it's an obvious desideratum. I doubt it will ever be removed.. > How do you want this to work?\nRight; that's the hard part about choosing the right criterion, I think.\nPerhaps, using the types of collections.abc, we could flatten all Iterables that aren't Mappings, ByteStrings, or strings.. I would think it better to change how the @builds methods work so that they actually receive separate arguments instead of just an expr argument. This might be a little tricky because we need to keep the position information of expr around, but it should be doable, perhaps by continuing to pass in the original expr as the first argument.\nAlso, I would caution against writing docstrings for @builds methods before we have to a way to automatically synchronize docstrings and the HTML documentation. We already have such a documentation-duplication problem for core functions and macros.. >> keep the position information of expr around \n\nYou are referring to [\"start_line\", \"end_line\", \"start_column\", \"end_column\"] in HyObject right?\n\nRight.\n\nRight now it is pretty easy to write the docstrings\n\nPerhaps so, but redundant documentation that isn't up to date is worse than a single source of documentation.\n. It's probably possible to write a macro that works like defn but evaluates default arguments when the function is called instead of when it's defined. I know I'm not the only one who thinks that this isn't one of Python's better features.. I think this doesn't account for mangling properly. I can't complete to numeric?, is_numeric, or numeric!, although I can complete to is-numeric and defmacro-bang. hy.extra.reserved.names exists for this sort of purpose, so try using that.. The thing about is-numeric, like defmacro-bang, is that it's an incompletely mangled form. The original is numeric? and the fully mangled form is is_numeric. Either would be a reasonable choice for a completable name, but not is-numeric.. This is cool. I like it. Is it ready for review? Still, I would finish up your outstanding PRs (and review those of others) before starting new ones like this.. A lot of the diff is whitespace changes to old code. If you want to include them in this PR, could you put them in a separate commit?\nInstead of \"presence of a % parameter\", I would write \"presence of symbols named %*, %**, or %i for some number i\".\nThe tests seem to pass without the (import hy) in anaphoric.hy, despite the use of HySymbol. So I think you can remove it.\n(if (coll? expr) (flatten expr) (, expr)) can be written (flatten [expr]).\nYou have a commented-out require at the bottom of anaphoric.hy. I'm guessing it's old debugging code.\nOtherwise, all looks good.. I think astor should support NaN, but as a stopgap measure, we can compile NaNs to an expression that evaluates to NaN such as 1e1000 - 1e1000. This will get constant-folded to NaN in the compilation of AST nodes to bytecode.. > @Kodiologist I've allowed edits from maintainers if you want to use this as a starting point to try compiling NaN to expression.\nSure, I'll take a stab at it.. I think I did it. The tricky part was complex numbers.. Sounds like a bug in my code for checking the capitalization of Inf.. @kirbyfan64 So what you're saying is, unittest.main imports its calling module, triggering #1134?. Why not use the more powerful and less verbose pytest? Hy's own conftest.py shows how to use pytest with Hy code.. Yes.. @gilch Bug or feature?. > Python syntax doesn't allow dict lookup targets in import statements.\nDang, I didn't know that. Stupid arbitrary Python limitations.\n\nit was documented to work that way\n\nSomehow I missed that. Well, that's on me. Let's close this and hope nobody complains. __import__ is a good workaround, anyway.. Matthew was referring to my suggestion to compile (let [foo 5] (import [math :as foo]) \u2026) to \u2026 import foo as _;let|1235['foo'] \u2026. It turns out that Python doesn't allow this: the right-hand side of as has to be an identifier.\n  . I agree with @tianon's diagnosis. The setup.py of Hy 0.13.0 is now broken because it allows newer versions of astor, but you can either pip install astor==0.5 or run Hy master, which supports astor 0.6. Perhaps we should release Hy 0.14.0 immediately so people don't encounter this every time they try to install Hy from PyPI. Or we could just release Hy 0.13.1, which would just change setup.py. That's probably the way to go for a quick fix.. @h8hawk, that strategy won't work because astor 0.6 introduced several backwards-incompatible changes, not just a change to a module name. Use  pip install astor==0.5 for now.. I added a 0.13.1 release on GitHub. @paultag, could you post it to PyPI?. Even if 0.13.1 is no longer necessary, it should be on PyPI for consistency.. It's now uploaded.. The use of macroexpand-all means that recur in macro expansions will be replaced with the generated symbol:\n(require [hy.contrib.loop [loop]])\n\n(defmacro m []\n  '(do\n    (defn recur [x]\n      (print \"in m:\" x))\n    (recur 3)))\n\n(loop [i 1]\n  (cond\n    [(= i 1)\n      (print \"branch 1\")\n      (m)\n      (recur 2)]\n    [(= i 2)\n      (print \"branch 2\")]\n    [(= i 3)\n      (print \"branch 3\")]))\n\nThis prints:\nbranch 1\nin m: 3\nin m: 2\n\nBug or feature?\n. For comparison, if you change back to the old variable-setting syntax and run the example with master, you get:\nbranch 1\nin m: 3\nbranch 2. In that case, I think `recur` can be a regular function. For example, if you replace the whole of hy/loop.hy with:\n\n(defclass E [Exception] []\n  (defn __init__ [self args]\n    (setv self.args args)))\n\n(defn recur [&rest args]\n  (raise (E args)))\n\n(defmacro/g! loop [bindings &rest body]\n  (setv fn-args (cut bindings None None 2)\n        init-args (cut bindings 1 None 2))\n  `(do\n    (import [hy.contrib.loop [E :as ~g!E]])\n    (setv ~fn-args ~init-args)\n    (while 1\n      (try\n        (setv ~g!output (do ~@body))\n        (except [~g!e ~g!E]\n          (setv ~fn-args (. ~g!e args)))\n        (else\n          (break))))\n    ~g!output))\n\nand add (import [hy.contrib.loop [recur]]) to the tests, all the tests pass except for test-recur-in-wrong-loc, which is a feature that was already broken if the TODO comment in the original loop.hy is to be believed. I don't know; it's a thought.. Perhaps the best thing to do is, rather than forbidding a non-tail position, explain that putting recur there will cause any parent function calls or later statements to be ignored, since recur always jumps to the top of the loop.\nThis means you can use recur more like return, as in:\n(loop [...]\n  (when (some-condition?)\n    (recur ...))\n  ; Statements below this point are only executed when (some-condition?) is false.\n  ...). Okay, it makes sense that you'd want to preserve that aspect of variable scoping. Why don't you add a test for it? Otherwise, this PR looks good to me.. The shadowing test looks good, but I have questions about the other commit.\n\n\nWhy document and test fnr and defnr? Aren't they just part of the implementation of loop?\n\nThe documentation file says \"If recur is used in a non-tail position, an exception is raised.\" The docstring of loop says \"If recur is used in a non-tail-call position, None is returned, which causes chaos. Fixing this to detect if recur is in a tail-call position and erroring if not is a giant TODO.\" Which is correct?. 1. Okay.\n\n\nI see. If you don't want to do the full rewrite for this PR, you can just remove the claim that this feature works from the documentation.. Although, if you care about tail-call elimination, your time might be better spent getting the automatic version to work, rather than working on hy.contrib.loop. On the other hand, people who start work on that have historically not been able to finish it, so I guess it's harder than it sounds.. What happens when you rewrite the simple test file in Python and test it the same way? If the same thing happens, then your issue can't be with Hy.. I don't think logger.py and test.hy are equivalent\u2014the Python version has a lot more code.. Sorry, I'd gotten confused and thought that logger.py was supposed to be a Python translation of test.hy rather than a library imported by it. Anyway, try rewriting test.hy in Python and see if you get the same error.. > I have rewritten it in python and it works as expected.\n\n\nOkay, good, so this should indeed be a Hy bug. Can you provide the Python version?. Thanks. I've replicated this with Hy master. I guess we aren't correctly emulating Python's search path. #459, our oldest outstanding bug, might be related.. Oh wait, we can replicate this without cron:\n$ cd /tmp/\n$ mkdir foo\n$ cd foo\n$ echo 'print(\"in mymodule\")' > mymodule.py\n$ echo 'import mymodule' > testpy.py\n$ echo '(import mymodule)' > testhy.hy\n$ cd\n$ PYTHONDONTWRITEBYTECODE=1 python3 /tmp/foo/testpy.py\nin mymodule\n$ PYTHONDONTWRITEBYTECODE=1 hy /tmp/foo/testhy.hy\n[ \u2026 ]\nModuleNotFoundError: No module named 'mymodule'\n\n. It seems like a reasonable workaround, if nothing else. Fixing #459 might fix this, too; I'd focus on that first if I were you. Also, I wonder why the empty string appears in sys.path under Hy. Perhaps somewhere in Hy we're already doing sys.path manipulation to fix some related bug, but we got it wrong, so now it's adding the empty string instead.. By the way, some of the underscore-to-hyphen edits in \"Mangle symbols at compile-time instead of parse-time\", particularly in @build(...) expressions, can be undone if desired, thanks to the later commit that mangles the names of special forms.. > I thought about how we could change how we construct the gensym names and realized that it's better to change the mangling system.\nI do see one way it could make sense to change the gensym format: instead of _;foobar|1235, use _;foobar_1235. I see why you want the leading underscore (to prevent automatic import) and the ; (to create an illegal Hy identifier), but you don't need the |, right? Then this mangles to _hyx_X3bXfoobar_1235, which seems pretty reasonable.\nWe could also have the ; do double duty as the digits separator, yielding _foobar;1235, which mangles to _hyx_foobarX3bX1235.\nI think your suggestion of putting Base16 UTF-8 at the beginning works, too, even if we also make one of the aforementioned changes to the gensym format.\n\nActually, it might be even better to use _ as the elision marker instead of X.\n\nBut _ is a common identifier character, whereas X is uncommon. \n\nWe could use *1 *2 *3 as the repl history variables like Clojure instead of _.\n\nThat sounds reasonable.. > True, but why does that make X a better choice?\n\n\nBecause it means fewer characters have to be escaped. So, some_l\u221eng_identifier becomes hyx_E2889E_some_lXng_identifier instead of hyx_5FE2889E5F_some_l_ng_identifier.\n\n\nBecause when you see an X in a hyx_\u2026 symbol, you can be pretty sure it's something else, whereas a _ is as likely to be a _ as something else.\n\n\nAlso, not related to the rarity of X, it's easier to count Xes than underscores. (This isn't important for my original proposal, where you never have more than two Xes (or rather, underscores) in a row, but could become a pain point with your Base16 UTF-8 method.)\n\nI picked the current gensym format for legibility when debugging macro output with astor. I'd certainly consider improvements to it after we settle the encoding format. But what's best for gensyms depends on that, so let's figure it out later.\n\nOkay, sure.\n\nI think it makes sense to treat a symbol containing a hyx__ prefix like an illegal identifier. That is, encode it again.\n\nThat was my original plan, but I realized it wouldn't allow you to use the unmangled form in Hy. That is, you can write foo? as is_foo or foo-bar as foo_bar, but you wouldn't be able to write an identifier with illegal characters in its pure-ASCII hyx_ form.\n\nMake it a 1:1 invertable function, so there would always be an unambiguous unmangling for any identifier.\n\nThat would be nice, but we can't have it so long as foo-bar and foo_bar in Hy both get mangled to foo_bar. Which I like and want to keep.. I agree that hexadecimal is a better choice than Base64 for this, whether we're using a quoting method or an elision method.\n\nIt's true that X is a rare letter in English, but it's a common letter in mathematics\n\nI don't think it's common as an uppercase letter in a Python identifier, because of how uppercase tends to be used. It also happens to fit with the use of \\x to quote a character by its hex code.\nUsing a non-ASCII character is a pretty good idea, though. I don't think we should use \u2054, because it seems to be some sort of combining character (in Emacs, it's being influenced by characters that I put around it in weird ways), but what about the Greek letter \u0394?\nUsing Unicode character names is something that occurred to me but I didn't think about it much. How about, per your implicit suggestion, illegal characters get replaced with a CamelCase version of the name? So the identifier # becomes hyx_\u0394NumberSign\u0394, + becomes hyx_\u0394PlusSign\u0394, and some-l\u221eng-identifier becomes hyx_some_l\u0394Infinity\u0394ng_identifier? ~~For a bit of brevity, we could use another \u0394 at the beginning instead of hyx_. Thus, + becomes \u0394\u0394PlusSign\u0394.~~ (Nah, because then you can't have a variable named \u0394, or we have to have another exception for it or something.). Oh, gross, I didn't realize that some Unicode characters don't have names. There are aliases, like \"NULL\" for U+0000, but private-use characters don't even have those. If we use hexadecimal for some characters, then we need a way to distinguish the hex codes from character names. I guess we can use a leading lowercase x, because names will always start with a capital letter.\n\nA variable named \u0394 would mangle to \u0394\u0394GreekCapitalLetterDelta\u0394, I suppose.\n\nIn Python 3, it's a legal identifier, so it doesn't need mangling.\nSpeaking of which, Python 2 only allows ASCII in identifiers, so we can't use a non-ASCII escape character. I guess we'll fall back on \"X\" then, unless you still want to use \"_\", which would produce things like hyx_LowLine_some_LowLine_l_Infinity_ng_LowLine_identifier. \nI've checked that for every Unicode character with a name, the name matches r\"\\A[-A-Z0-9 ]+\\Z\". So, are we good with \u0394 delimiters for Python 3, X delimiters for Python 2, names for characters with names, x followed by hex digits for characters without names, and hyphens in names replaced with underscores?. > Do the Unicode names match r\"\\A[-A-Z ]+\\Z\" too? \nSurprisingly, no. Even though digits don't appear in the names of the ASCII digits, they show up in the names of some higher characters.\n\nThe last one doesn't round trip!\n\nAh, true. X quotes can't work for Python 2 if we're using character names. Nor can we use underscores, since we need those for hyphens in character names. That seems to leave us with my original plan of using hex for every character. I'd rather just use that for Python 3, for simplicity, but if you wouldn't accept that, and you would accept that for Python 2 and delta quoting of character names for Python 3, I'll add delta quoting for Python 3. What do you say?. But we'd still have the problem of \"X\" in other names, right? Like U+2423 OPEN BOX, \u2423.. > Python2 is a pain. \nIt always is. ;_;\nI was 95% sure that space-hyphen and hyphen-space wouldn't occur, but it turns out that a handful of Tibetan letters have them (e.g., U+0F0A, \"TIBETAN MARK BKA- SHOG YIG MGO\"). So I think we have to go with H for hyphens. Then the only way that Python 2's and Python 3's mangling rules will need to be different, other than the fact that Python 2 needs more things escaped to begin with, is that Python 2 will use X and Python 3 will use \u0394. Sound good?. > I still want to test the resulting code before final approval\nYes, that goes without saying.\n\nAlso what about the special case XX and \u0394\u0394 to mean X and \u0394?\n\nThey're both pretty rare, and it's only an issue when other characters have to be escaped, so the additional mangling rule doesn't seem worth it to me.. Rebased. See the edited PR description for the new rules. I used U instead of X for hexadecimal code points to make parsing easier in the case of Python 2.. Are you sure that this is a bug in Hy instead of a bug in your lstm.hy script?. Okay, I'll close this, then. Let us know if you discover a bug in Hy itself that's causing your issue.. Because this is the Hy issues list, not a help forum.\nYou could ask the author of the program in question. Other than that, you can try our IRC channel or mailing list, or Stack Overflow.. Fixed by #1386. You'll see the change in the stable version of the documentation when a new major version of Hy is released. For now, you can see it in http://docs.hylang.org/en/master .. Looks like the ayes have it. @paultag, I think I don't have the permissions to add him, so could you?. Thanks, @paultag. While I have your attention, would you mind providing PyPI credentials so I and the other maintainers can release new versions?. Done: #1463. Thank you, my dude.. Welcome aboard!. Huh, I didn't even know this Python feature existed. #459 might be related. Thanks for reporting.. I don't think hy.macros._hy_macros is intended for public use.. No, I don't think so. We've never worked on introspection of the macro system beyond Hy's own internal needs.. @gilch What do you think?. for/a seems like the simplest option. I imagine it would make all the nested loops asynchronous as well, but to be honest, I don't use the asynchronous stuff nearly enough to guess whether that's the desirable behavior.. @gilch What do you think of that, and what I've done so far?. You can always nest constructs manually. I'm not sure what the alternative to for/a is unless you want to allow inserting :async in various positions, complicating the already somewhat complicated rules by which elements are grouped in these constructs, and creating an asymmetry with the other /a forms. Or, let's forget about it for now, since neither of us actually make much use of this feature and this PR is ambitious enough already.. > Though to be clear, that policy only applies to newly opened issues, right?\nYes, it would only apply for these changes if I closed this PR and opened a new one for them.. I'm closing this in favor of updating #1437.. What do they do?. I'd support putting it in a hy.contrib or hy.extra module if you'd like. I wouldn't put it in core because core is a bit bloated right now and should have some things removed or moved to hy.extra, although, admittedly, the bloat is mostly from functions rather than macros.. Why don't you write some tests before we review the implementation? That will make it plainer what you intend to implement.. There might, but it's not so important as the feature itself, and that's what mass search-and-replace is for, right?. This looks like a decent start. Remember to make name changes consistent (e.g., you renamed asyncdefn to defn/a but there are still appearances of \"asyncdefn\" in error messages and names).. I would vote for naming things by putting async- in the front, so for example Python's async def becomes (async-defn \u2026).. Okay. I don't have a strong opinion about the name.\nDon't forget to simplify compile_yield_from_or_await_expression; it is now guaranteed by @checkargs that len(expr) > 1. \nInclude a test for #1472, since you're fixing it.\nI don't think #a should be a core macro. It has a desirable name and it doesn't save many characters.\n. Try to avoid duplicated code, like the implementations of for and for/a. In that case, for example, you can use a function that each macro calls as a subroutine.\n\nI can't see any examples where we test for syntax errors.\n\nTake a look at tests/compilers/test_ast.py.. Make the subroutine (_for or _with) a function rather than a macro, calling it at macro-expansion-time. Then it doesn't have to be added to the scope of the calling module.. Do you want help, or to keep working at it for now?. Sure, take a look at what I just pushed. It's the sort of thing that's hard to understand from a description but probably easier to get an intuition for once you've seen it done.. And documentation. That's the annoying one. But since you're only providing Python features, you need not do much more than link to the appropriate parts of the Python documentation. The current Hy documentation often re-explains Python concepts, which I believe is a mistake, based on a mistaken idea we had earlier in Hy's development that you could master Hy without mastering Python semantics.. For the record, I'd still prefer not to have these notices at all (#1225), but everybody else seemed to want them. If you want to further shorten the notices to not even include a year, I would support that.\nHowever, even if we remove dates from all the source files, there's still a date in the license file. I presume we wouldn't want to remove that because these licenses are written and approved by lawyers and the lawyers presumably know what they're doing.\nSince the files frequently change, new versions are repeatedly published for the first time. I'd rather bump all the years in one commit than remember to do it every time I change an existing file.. @hylang/core C'mon, folks, let's merge this and then I'll put the next release together.. I disagree with this change. I think (fn [] return) should remain legal, and in fact, (setv return 1) should be legal as well. My PR #1458 makes the latter change as well as mangling such variable names so as to produce valid Python code.. > @Kodiologist valid code as in it emits a return or returns a manged \"return\" variable? I'm taking it as you mean the later.\nRight. return gets mangled to hyx_return.\n\nCan we assign to our other special form names now? With #1458?\n\nYep. Mangling occurs not when you use the name of a special form, but when you use the name of a Python reserved word (other than True, False, or None).\n. Incidentally, if we're willing to change def, it should probably be an alias of (or replace) defn. It's unduly confusing that the name Python uses to define functions is used for something different in Hy. Then, for annotating variables, we can use annv or var or whatever.. I'm not concerned with a speed bump for learners so much as the tight relationship between Hy and Python that often requires the programmer to mentally switch between syntaxes. The changing meaning of def is one more complication to this, and its only benefit is to remove a speed bump for people who already know Clojure.. I don't really want def and defn as synonyms, either, but it might be a good temporary measure to keep for one major release, with a deprecation warning for defn, because of the sheer amount of code that will break if we remove defn. We're still entitled to break backward compatiblity, but a change this big could be worth showing our poor early adopters a bit of mercy.\nThe ^ options don't seem so great because, presuming the proposal is to make ^ read as an operator rather than having setv treat symbols beginning with ^ specially, we're relinquishing the character ^ for a very limited purpose.\nSo I like proposal 3 best, although we might want to use annv or something instead of defv in case we want to reserve defv for some future feature of declaring variables a la Perl's use strict, as you discussed in #911. Of course, we may need to shake up the annotation syntax in that case regardless of what name we choose here, since we'd need to make sure annotations play nicely with declarations.. Since only one other form needs that, namely defn, let's, again, try not to change the lexer just to accommodate it.\n  . > Not just one, setv, defn, fn, and many macros based on them, like defmulti or let might want to use these.\nSure, but they're ultimately going to take advantage of it by calling the same code (which presumably would live in the compiler's definition of fn and fn*), right? So we should still only need to handle this syntax in one place.\n\nBut the #^ and ^-space alternatives wouldn't have to change the lexer.\n\nRight. Or, you could still obtain syntax like\n(defn ^str foo [^int x]\n  (str (* x x)))\n\nby having defn treat symbols beginning with ^, as well as ^ itself, specially. This would be similar to how &optional is an ordinary symbol from the lexer's and parser's perspectives, but magical in a lambda list.. > > ... defn treat symbols beginning with ^, as well as ^ itself, specially. This would be similar to how &optional is an ordinary symbol from the lexer's and parser's perspectives, but magical in a lambda list.\n\nHow would that interact with macros? Wouldn't it be desirable to allow type hints to be a macro argument for doing code generation? For example (contrived):\nclojure\n(code-gen my-helper ^str)\n\nThat should work fine, with no special effort: code-gen treats ^str as an ordinary symbol and passes it down to defn, which treats it specially.\n. If you end up using this PR to add variable annotations in a way that doesn't affect def, then yeah, you don't need to worry about def in this PR.. So what's the status of this now, @vodik?. I guess that depends on what counts as \"something new going into the language\". Like I was saying, you can get ^ to work like that by only changing how defn treats symbols beginning with ^.. > If we agree it should be ^int, then I want to use that form in as well annv.\nThat seems fine.. The async forms should be identical to their non-async equivalents so far as syntax and variable scoping are concerned, so let should be able to treat them identically.. Why do you say that pip \"can't meet up our need\"? What would your proposed plugin make pip do that pip can't already do? And why don't you think PyPI is a suitable community repository? Users should be able to use a Hy module as a Python module without even being aware it was written in Hy.. Don't be frightened; I very rarely bite. :P\nHy isn't a fully independent language. It's ultimately just another way to write Python code, similar to how CoffeeScript is to JavaScript. One of the advantages of this is that we can reuse a lot of Python tools, like pip.\n\nso\uff0cmaybe need a chapter about it usage ?\n\nI don't know what you mean. What aspect of Hy's usage do you think is not covered in the existing documentation?. Fixed in #1464. You'll see documentation updates in the stable version of the documentation once a new stable version of Hy is released.. In the title of this issue, you mention a mangling rule mapping => to to, and in the body, you mention a rule mapping -> to _to_. Are you proposing both of those, or only one?\nYou might want to check out #1458, where I'm currently proposing some sweeping changes to mangling.\n  . I'm not sure I understand you. Mangling, as currently conceived, is applied to entire symbols, but defined in terms of its effects on individual characters. After all, the whole point is to remove characters that aren't legal in Python identifiers. So, mangling camelcase->snakecase requires deciding how to treat - and >. Under what I'm proposing in #1458, - would become _ (as Hy already does) and > would become \u0394greater_than\u0394.\nAt any rate, I agree with Gilch in that I would prefer not to add more mangling rules.. If you want to explicitly define a Python-friendly name for a value, it suffices to say e.g. (setv camelcase_to_snakecase camelcase->snakecase).. At any rate, it looks like we're not going to add a special mangling rule per se for -> or =>. Duplicate of #712. Don't forget to check for duplicates before submitting an issue.. Looks pretty cool. It is a bit weird that square brackets, which are usually used to define a list, end up defining a tuple here. But the same criticism applies to Python, so that's not our fault.. I think we should decide what we're going to do with it before removing it; for example, replacing defn with it (as I'd like to do).. That's true, and this alone is more likely to get consensus. So let's go with it. Just update the def / setv section of api.rst and update NEWS and I think it's good to go.. I'm guessing you tried something like (try (require foo) (except [...] ...)). The try can't catch an exception raised by require because require takes effect at compile-time, not run-time.\nThere is a minor bug here, though, which is that the error message (\"cannot require names\") is raised as an ImportError instead of a HyTypeError, yielding the ugly stack trace and the message \"Internal Compiler Bug \ud83d\ude31\".. No. There is currently no way to conditionally require a macro.. Ah, I hadn't thought of that. Well done.. No such feature is implemented, but see #740 for a preexisting feature request.. But then I'd have to run icky proprietary software.. We have a [good first issue] label. Maybe somebody renamed it and forgot to update the documentation. In any case, nobody's really stewarding issue labels, so my inclination would be to remove the mention from the documentation, so as not to give the impression that a label is a reliable source of good first issues.. @Alex-Keyes How about fixing this error message? https://github.com/hylang/hy/issues/1486#issuecomment-356675221. Does this distinction matter at all in Python 3, or is it effectively a Python 2 issue?. Don't forget about those test failures.. One issue with this approach is that slice isn't a reserved word, so there's no way to tell at compile-time that the symbol slice corresponds to __builtins__.slice.. slice is already a builtin, because Hy inherits Python's builtins. Making slice a special form just so we have the right of always defining what (slice ...) means, when in fact we intend it to expand to a regular function call whenever the compiler actually gets to a @builds(\"slice\") method, is probably overkill. Perhaps the best approach is to check for __builtins__.slice instead. It's probably best to make cut emit this instead of a bare slice, anyway. While it's technically possible for the user to set __builtins__ to something weird, the double underscores in the name mean that this is officially a bad idea.\n. No, I don't think you need to; I think it will suffice to check for the symbol __builtins__.slice. This won't work for something like (get foo ((. __builtins__ slice) ...)), but that's probably okay. It's just an optimization, after all.. It should be possible to compile it first and check the AST instead of checking the symbol, but the code will probably be a bit wordier that way.. It's true that both the name __builtins__ and the attribute slice of the referent have to be looked up at runtime. But what I'm saying is, the double underscores in the name imply that the user isn't supposed to reassign the name. So it's fair of us to assume it hasn't been reassigned. Does that make sense?. > Okay, so let me see if I'm following: you're suggesting that the cut macro emits __builtins__.slice instead of slice. Then I'll look for __builtins__.slice and emit ast.Slice in that case?\nBingo.\n\nIs this on top of rewriting slice too, but just to make it more bullet proof?\n\nNo, leave slice as a Python builtin.\n\nJust need to fix the tests and add new ones...\n\nSounds good. Let us know when you want us to take a look again.. > the following equivalent Python:\n\npython\nfoo[1][2][3:4][...][5:6]\nfoo[(1), (2), 3:4, (...), 5:6]\n\nThese don't seem to be equivalent:\nimport numpy as np\n\nfoo = np.ones((7, 7, 7,  2, 2, 7))\n\nprint(foo[(1), (2), 3:4, (...), 5:6])\n# prints: [[[[ 1.]\n            [ 1.]]\n\n           [[ 1.]\n            [ 1.]]]]\nprint(foo[1][2][3:4][...][5:6])\n# prints: []. Yes, it is. I'll take a closer look tomorrow.. @vodik, how are we doing here?. Closed for lack of response.. I would be against this change because it means that failing to set the attributes properly will cause Hy to point to the wrong line and column instead of raising an error. Hence, it will make bugs harder to find. Note that `hy.compiler.hy-compile` and `hy.importer.ast-compile` are internal functions.. > Python exposes these things as builtins\n\nI'm not sure what \"these things\" are. In Hy, as in other Lisps, if you want to run code objects (HyModels), you eval them. There's no need to compile them to Python AST first. eval does that on its own. Of course, it's better to eval an appropriately parametrized function than to eval inside a loop.\nTo evaluate Hy code from a Python program, you can use hy-eval, which is the same function, provided by hy.\n\nthe above snippet works just as well with hy-compile, compile and exec\n\nI'm not sure what you're trying to do, or how you'd do it with only public functions.. Oh, very good, then. No problem.. The code works as expected for me. You seem to have a few commits that aren't on master, so try switching back to the HEAD of master. Also make sure that you can't replicate this with Python; your copy of Python might be buffering more aggressively than you expect. Also, what version of Python are you using?. Finally, I notice that Ubuntu 17.10's python3-sh is a bit behind PyPI's latest sh (1.11-1 vs. 1.12.14).. No problem. Happy Hying.. You could have a file in native_tests import from ..resources.tlib.. Add a bit more to the test to make sure we're importing the right file; for example, you could add x = \"hello\" to tlib.py and then check the value of x after the import. Otherwise, looks good to me.. @hylang/core. > this works now since python 3.1.0\nI presume you mean pytest.. You're on fire lately!\nI had been under the impression that return and return None were interchangeable; mea culpa.\n\nAll these warning came from pytest\n\nI don't see any warnings when I run pytest. Do you have to turn them on somehow?. -q didn't do it for me, but adding this passage to setup.cfg (mentioned in the linked page) did:\nfilterwarnings =\n    once::DeprecationWarning\n    once::PendingDeprecationWarning\n\nThat change should probably be committed once we've tended to all the warnings.. Lookin' really good. Just see that one comment.. You could use \"Unreleased\" as the new header.. > astor breaks because it uses async as a keyword argument\nWe should probably give the Astor folks an issue for that, if they don't already have one.. We should consider Python 3.7 support, and testing of it on Travis, a blocker for 0.15.0. It'll be one of the first things I work on next.. Since the workaround also works with CPython, I don't think there's any need for this. You could just add a comment to the existing code pointing out that it's a workaround, or you could make a reminder for yourself to clean this up once Travis has upgraded its PyPy.. if-python2 is only for internal use. I don't think there would be much of a benefit to expanding it to handle PEP 508 in general, but I guess it's hard to forsee.. > Maybe this is my hubris, but I haven't seen good use case to support it.\nThe loose equality was never deliberately chosen, I think. At any rate, we'll all be happy to see it gone, all other things being equal.. I may not be very available for Hy stuff till Tuesday, thanks to the NIH grant deadline. Sorry about that.. What's the status on this now? It looks like you finished it and then I completely neglected it, but now we have some conflicts, presumably from #1517, that might take work to unsnarl.. In case you missed it, I was accusing myself of neglecting it, not you. ;). Looks good. Why not put the new tests in py3_only_tests.hy and py36_only_tests.hy instead of their own files?. It's only two new tests, so it seems a little silly to make two new files. When (or if) the version-specific files get large, then we should start breaking them up, by all means. We already have some test files that are probably too big, like language.hy and core.hy.. @gilch, do you approve?. @gilch, do you approve?. Decorator syntax is not necessary in this case. You can write simply\n(defclass Foo []\n  [from-string (classmethod (fn [cls str] ...))])\n\n. Works for me.. If I'm not mistaken, this complicates the generated code: what could be a lambda will now take an extra assignment. Also, I'd like Hy to be able to generate every Python construct, even if it's not strictly necessary to do so (Python has a lot of constructs that are semantically redundant). Given, we don't have that yet (we're missing, e.g., variable annotations), but if we eliminate lambdas, we're taking a step back.. But it doesn't make sense to decorate a fn. You can just use a regular function call for that. You can decorate a defn, but that's already guaranteed not to produce a lambda.. > As far as I'm concerned, conceptually, fn generates a function but may choose to pick the more \"optimal\" representation of a lambda.\nIt may be more useful to think of it the other way round. fn produces an anonymous function and returns it. That's the reason we have fn. If you want to assign your function a name from the beginning, instead of passing it as an argument or putting it in a list or something, you should probably be using defn. It is an implementation detail that sometimes fn needs to produce a Python def statement because of Python's limitations on what can go in a lambda.. > But there's also a lot of effort put into rewriting setv + fn\nThis might have been a mistake. I mean, it would be more intuitive if defn were a special form, replacing fn*, rather than fn* and defn both existing just to guarantee the creation of a Python def. I'm not sure how we got here. Full disclosure: I created fn*, but that was as part of a change from an earlier even less sensible design, which included lambda as a separate special form (#1228; see also the follow-up #1259).\n\nWell, what about if we promoted #% and supported it first party to generate lambda's instead like in Clojure?\n\nI think that would just pass the buck, in a sense: like fn does now, #% would be able to produce a lambda in some cases and forced to produce a def in others.\n\nAnyways, its no hill I want to die on, what do you guys think about my ideas on augmenting with-decorator then?\n\nYou can see how in #1228 I generalized with-decorator only to revert it in #1259. Since it's only necessary for def blocks, it makes sense to only support def blocks.\nIn conclusion, it looks like what got us down this path was the fact that (#@(foo (fn \u2026))) works inconsistently. The easiest solution to that would be to make #@ or with-decorator raise an error saying that you can just write (foo (fn \u2026)).. A month seems really slow, but this policy with a one-month delay is still much better than the status quo.. It looks like there's acceptance of the policy, but we're 2-to-2 on whether the delay should be two weeks or one month. @kirbyfan64 @rkday would you care to weigh in and break the tie?\n. We now have 3 votes for a two-week delay versus 3 votes for a one-month delay (2 of which have the caveat that a two-week delay could be okay if there's one approval). \nRegarding the compromise Rob offers, I'm afraid that reviewers would have little interest in going back and indicating approval of old PRs that have been in master for a while, and releases would never happen. But I appreciate the point that we should be more conservative about releases than about master. So how about we keep the 2-week interval, but say that release PRs themselves are not eligible for the \"absence of disapproval\" method, so they need two approvals other than the author, per the traditional policy?. Okay, great. That will be our new policy.. Why not? That seems like a fine behavior to me.. They seem very string-like to me, is all I can say, I guess. Certainly I wouldn't have expected (list 'foo) to do something else.. See also #1429.. > And as a heads up, the Finder API (what we've incorrectly named MetaImporter) as also deprecated.\n1085 and #1188 might be related.. Does this change anything with respect to #459 or #1134?. > Not sure\nThe other issues referencing that one have some example code you could try.. The proposed change, as it currently stands, adds a good 400 lines of code, so the proof is in the pudding: does it fix all the bugs it's intended to fix? Until then, it's hard for me to judge your code.\nThe benefits of switching to our own bytecode format seem meager:\n\nIt's a Bad Idea to have both foo.py and foo.hy in the first place, because how would (import foo) know which to use?\nCompilation is inherently nondeterministic in Hy because of code like (defmacro m [] (import random) (random.random)) (print (m)). This is why checking whether required files have changed isn't a general solution to the problem of stale bytecode (#1324).\n\nBut if switching to our own bytecode format substantially simplifies the new code, it could be worth it.. >> It's a Bad Idea to have both foo.py and foo.hy in the first place...\n\nI agree, but its technically possible.\n\nCome to think of it, it might be worth having Hy's importer check for a corresponding *.py file and raise an error if it's there.. That was the 777th closed PR, for those of you keeping score at home.. > This really should have had a link to #1458 where much of the original discussion happened.\nFair enough.\n\nOne-approval merges should say so here in the conversation, for the record.\n\nIt isn't hard to figure out if something was validly merged (and, if so, under what rules it was merged), is it?\n\nAs a courtesy I'd like to ask that you give a one day warning before such merges.\n\nBut the creation of a PR is itself a 14-day warning. In theory, if you wanted a 1-day warning, you could set an alarm for yourself for 13 days hence (we could even write a bot that does this automatically; in Hy, no less), but why wait to do whatever it is you were going to do?\n\nNow that we've got the mangling makeover format settled, it's time to rethink the gensym format as discussed in #1458. I'd have mentioned this in time for the merge had I gotten warning.\n\nNo worries, that can be done in a new issue or PR. This PR is already big, anyway.. > we could even write a bot that does this automatically\nCome to think of it, this could be useful as a reminder to PR authors to check that the PR is in a mergeworthy state.. \"Be careful\" in the sense of warning users to remove stale bytecode? NEWS could be a good place to put such a warning.. I'm not sure what unmangle should do with an empty string, but mangle errors on an empty string because it's supposed to always return a valid Python identifier, and we have no mangling rule to produce a Python identifier for the empty symbol.. @brandonwillard vodik hasn't been active on Hy lately, so if you want to work on these changes and see them happen, I'd recommend opening a new PR.. I think this was superseded by #1672.. > Using a mutable data structure for Hy code is a bit dangerous\nIn fact, it created #1537, and probably a lot of other subtle bugs we haven't found yet.\n. The ayes have it. @paultag, would you do the honors?. @paultag pls.. >  it seems like repl output doesn't lex nicely\nThat's odd, seeing as code like => (import [hy.contrib.walk [postwalk]]) is lexically valid Hy; the => would be an ordinary symbol.. I wonder what Pygments uses the name hy for.. Hybris? Isn't that what you get when your mohel smokes marijuana?\nI'll be here all week.. Come to think of it, we should probably set highlight_language to hylang rather than explicitly marking every block as hylang.. Huh. Don't we still have more blocks that are in Hy than blocks that aren't? In which case, the switch will take a bigger diff, but we'll have fewer total code-block markers than if we mark every Hy block explicitly.. I think highlight_language is the way to go if it means fewer total code-block markers.. This is cool, but seems likely to conflict with #1518.\nDoes this help with #712?\nIs there any reason the test uses f.close instead of a with block?. > > This is cool, but seems likely to conflict with #1518.\n\nHow far from completion is that?\n\n@vodik?. It's a documentation change, so one approval is enough, anyway.. Sounds cool. I'd lean toward option 1 because otherwise we'd create a lot of organization and boilerplate (a GitHub repo, a PyPI package, etc.) for a one-liner. Users will already have to add \"hy.contrib.pytest_plugin\" to their pytest_plugins, which seems explicit to me.\nI would name it hy.extra.pytest_plugin or just hy.pytest_plugin rather than hy.contrib.pytest_plugin.. Oh, okay, I misread the compiler method. In any case, it needs to be documented.. That seems fair.. The methods of the hytest fixture are functions we use for testing the compiler itself, so why would they be used by other projects?\nShouldn't the Hy plugin have to be somehow enabled, as by adding it to pytest_plugins?. Yeah, the fixture is probably not necessary, at least, not yet.\n\nSee setup.py. So long as you use tox (which installs hy) or you do a development install, the plugin is registered with pytest.\n\nSo, supposing some user is writing a Hy-based package (other than Hy itself) and wants to run some Hy tests with pytest, it suffices just to have Hy installed?\nWhen I do git clean -dfx && pip install -e . && pytest, I get 586 tests, compared to 545 on master. You didn't add 586 - 545 = 41 tests, so perhaps you're running some non-test functions as if they were tests.. Are you aiming to merge this roughly as-is, or do you want to add that more control first?. Okay, pytest with no arguments seems to be collecting the right tests now, but pytest --ignore=tests/test_bin.py runs test_bin.py despite the argument.. That last option seems okay to me.\n\nWe don't want gensyms to be lexically valid symbols\n\nConsider that we've already implicitly staked claims on names beginning with hy_ (and hyx_, in a different way) even though they're lexically valid. It doesn't seem too unreasonable to use lexically valid gensyms, too, so long as they begin with hy_ or _hy_ or so.\n. What do you think of something like the following?\n\n(gensym) \u2192 _hy_G_1235\n(gensym \"foo\") \u2192 _hy_Gfoo_1235. > So it's now pointless to make gensyms lexically invalid, which means we're free to make them more readable.\n\nRight.\n\nMaybe it's enough to tell the user not to use certain prefixes. But we could make this much more robust. For example, the HySymbol constructor could use unmangle to always return an unmangled symbol if passed a string containing the r\"_*hyx_.*\" prefix. This way it would raise an error if the user attempted to construct a gensym, since (unmangle \"_hyx_X1235X_\") is an error.\n\nI don't want to prevent users from constructing a gensym on purpose, just by accident. They may want to do something sneaky with some Python code that was previously Hy-generated, or something.\nI didn't think about the double prefix that would result from something like (gensym \"|\"). In practice, I don't think it will be much of a concern because you would typically write just (gensym), providing an argument only if you're interested in debugging the generated Python code or something, and if you're going to do that, it stands to reason you should use an argument that doesn't need mangling.\nIf you really want to avoid a double prefix, we could forget about the _hy_ and instead try something like beginning gensyms with an underscore followed by a Unicode private-use character. This means that every gensym's mangled name will start with _hyx_ and collisions are very unlikely. This would look like (in mangled form)\n\n(gensym) \u2192 _hyx_XUefafX_1235\n(gensym \"foo\") \u2192 _hyx_XUefafX_foo_1235\n(gensym \"+\") \u2192 _hyx_XUefafX_Xplus_signX_1235\n\n\nIt does beg the question though, should mangle always be reversible?\n\nIt's never going to round-trip properly because e.g. a-b and a_b both mangle to a_b. But unmangle shouldn't crash if you pass in a mangled name, no. It should only crash if given a string that looks mangled but isn't actually a valid mangled name, or if given the empty string.. > we often debug macros using macroexpand works on hytrees, which is pre-mangle, right?\nThat's right.\n\nSorry, to be more clear, with reversible, I really was aiming at stable. Don't know the appropriate math term - its almost idempotence\n\nmangle is indeed idempotent, or ought to be, but the property you wrote down should be true as well.. In Rogue TV, I wrote a macro set-self that does the same thing as Tuuka's set-attributes. The fact that we independently came up with this macro is a hint that it would be a useful addition to Hy core. But maybe a more general form like Matthew's local-to-attr or insert-better-name is a better idea.\n1119 is also related.. > I feel like it shouldn't be this hard.\nModel patterns (#1593) would help. ;)\n\nHyKeyword's __str__ shouldn't include the colon so I don't have to cut it off like that\n\nIt's better to use (name kw) or kw.name than (cut (str kw) 1).. >     => \"\"\"test\"\"\"\n\n\"\"\n\n\nI don't know if you meant to imply otherwise, but just to be clear, this example is correct. The input is parsed as \"\" \"test\" \"\" and the REPL prints only the final value.. > I'm wondering if we should mangle with X's instead of \u0394's even on Python3\nThat was my original suggestion, and I still support it, although it presumably wouldn't fix the underlying problem here.. @gilch, would you veto a PR to change the delimiter to X on Python 3?. Right, that's probably something to do with pyreadline, either a bug in pyreadline or a misconfiguration on our part.. Could you rebase this and check that Python 3.7 now passes?. A smaller example:\n$ hy --spy\n=> (defmacro m [] (->> x (f)))\nimport hy\nhy.macros.macro('m')(lambda hyx_\u0394ampersand\u0394name: f(x, x))\n\nNotice the two copies of x.\nI'm working on a PR now.. > Immutable Hy Models would fix all of this, but that's a very breaking change.\nIt would probably be more of a hassle for us, in terms of rewriting parts of the compiler, than for users, who I expect are only relying on mutable Hy models in a minority of macros. Macros typically use the syntax quote to construct new models.. Yes, I think that either a mutation, or an expectation that something won't mutate that actually can mutate, somewhere in the compiler, is also at fault. Well, lots of such issues, actually. But finding and fixing them is another matter. Probably the way to make progress on that is to make Hy models immutable and see what breaks.. And before we do that, we should probably take a stab at writing the compiler more in terms of pattern matching of some kind, in place of all the manual inspection and modification of trees.. I might as well do it here.. Done.. There's no rule that says core membership doesn't apply retroactively (just like there's no rule that says a dog can't play basketball), so I'm going to merge this.. while and for return None in every other case. I see no reason to make an exception for an empty body.\nI don't see the point of a try with no body. If I understand correctly, none of the except clauses can run, and any else or finally is run just the same as if you didn't have a try.. Yeah, that makes sense. . #1575 does at least make the copying step that we currently depend on more obvious.. A thought: traditionally, Lisp expressions are built out of cons cells, which are mutable (they're just plain old linked lists). I can't remember ever getting into trouble in Emacs or Common Lisp by mutating a macro argument that I shouldn't have. Does Hy have some other feature that makes mutable models a problem, or have I simply not used other Lisps enough to be bitten by mutability?. Thanks, that's a good description.. This is great work, my dude. Fix or remove the parts of the documentation that are wrong now, update NEWS, and we're good to go.. I share your discomfort with __init__ rewriting, at least to some degree, but I feel like it wouldn't be much easier to remember to use definit than to include the explicit None.. I don't have any better ideas, no. Although, I guess it's not a big problem if you forget the None or the definit, because you'll get a clear error message (TypeError: __init__() should return None) when you try to instantiate the class.. This PR looks pretty good to me as is (but don't forget NEWS, of course).\nI don't think the new promotion semantics for generators are strictly necessary, because you can always write (, ~@foo) or [~@foo] and then it's explicit what you're getting, but I'm okay with them.\nYour example is kind of inevitable considering that iterators in Python mutate whenever you take items from them.\n\nThe problem is that we should probably be calling wrap_obj in HyList constructor. I think we probably want to do that anyways as other Hy objects (like HyCons) do wraps on construction.\n\nI don't think we should promote things to Hy models in the model constructors because promotion should happen in only one place, which is just before compilation. HyCons is the only exception, and even that may ultimately be wrong, because HyCons has always been pathological (#568).. You're basically objecting to #1314, then.. I mean, making the user promote everything by hand to the appropriate Hy model type would be pretty annoying. Right?. (.imag x) in Hy means x.imag() in Python. You want x.imag or (. x imag).. What exactly did you try? In what sense did it fail to work?. The GitHub issues list is for bug reports and feature requests. For support, try our mailing list, IRC channel, or Stack Overflow.. You can still review and approve this PR if you like it, and the PR can get merged with two approvals. What the veto means is just that the PR can't get merged under the two-week rule. For what it's worth, I fully expected Matthew to veto this because he disapproved the same thing a year ago, when I first wrote hy-repr (#1246).. That sounds reasonable. Tuukka and I are for and Matthew is against. @vodik, are you for? Does anybody else (developers or users) have an opinion one way or the other?. To be clear, the point of most controversy here is using hy-repr, rather than Python's repr, as the default method for printing results in the Hy REPL.. @tuturto, it doesn't look like anybody else is weighing in, so the majority vote as it stands is aye.. To be clear, hy-repr uses registered functions, rather than methods, as of #1516.\n\nI would suggest that (if we want Hy reprs at all) we automatically convert Python reprs to Hy syntax.\n\nI don't think this is a good idea. It seems error-prone. But if I did it, would you approve this pull request?. I don't think it's the test that's wrong, but the mangle function. \ud83d\ude02 is Unicode code point U+1F602, so on Python 2, presuming the character name isn't available, it should be mangled to hyx_XU1f602X, not hyx_XUd83dXXUde02X.. A mangled name isn't just an internal representation, though. It's what you have to use to access the variable in Python. We do unfortunately have to tolerate some inconsistency here in terms of Python 2 vs. Python 3, because of the changes in Python's own identifier rules, but let's not tolerate an inconsistency caused by an esoteric detail of one's Python build.. I doubt it will make a perceptible speed difference, but you can always benchmark and find out.. Okay, this should only affect Python 2, then.. >  Would it maybe make more sense to mangle to the utf8 representation?\nI don't think so. It would be longer and harder for the casual user to figure out what character is being represented. Code points are the most widely used numeric identifiers for Unicode characters.. Great work.\n\nconvert_to_ucs4_list, despite being mangle's subroutine, should probably be defined outside it, since we don't need to redefine it every time we call mangle.\nconvert_to_ucs4_list would be better named convert_to_ucs4 or something, since it might return a unicode or str instead of a list.\nI think you should write 0xD7FF < ord(u) < 0xDC00 rather than 0xDC00 > ord(u) > 0xD7FF.\nI would reword the comment for UCS4 to \"The value of UCS4 indicates whether Unicode strings are stored as UCS-4. It is always true on Pythons >= 3.3, which use USC-4 on all systems.\"\nAdd a NEWS item.\nRebase your work into one commit.\nAs a separate commit, add yourself to AUTHORS.. > checked the NEWS, I feel \"Mangling rules have been overhauled, such that mangled names are always legal Python identifiers\" is already good. Since the Mangling change hasn't been release yet, this commit will be part of it.\n\nOh, okay, that makes sense.. @vodik What do you think?. Yes, since str on Python 2 is always a sequence of bytes.. It might be better to get the reprs (r!) than the stringifications. Also, you don't need the numbers in the format string.. This is interesting, but it might be overkill, seeing how long it took us to create a bug related to UCS-2.. @waigx By the way, you might want to avoid slashes in branch names because of how Git uses slashes for remotes. git checkout feat/travis could mean checking out a branch named feat/travis or it could mean checking out a branch named travis (actually, the commit that's the tip of travis) from a remote named feat.. I didn't know that Git prints a warning message in that case. That's good.. I thought about it and ultimately, I disagree with this change. We already have a lot of Travis jobs, meaning that Travis builds already take a while, and all this one is doing is checking for an extremely unusual kind of bug.. I'm not too familiar with the innards of Travis, but my impression is that rather than every job running in parallel, only 3 or 4 jobs at a time actually run while the rest wait.. It looks like this isn't happening. Sorry.. Also, @waigx, I didn't realize you went to Stony Brook. I got my PhD in psychology there. Small world.. What do those files do and what would we accomplish with them?. The documentation for Pipfiles says they're a work in progress, whereas requirements files are stable. And we don't seem to need anything we can't get with requirements files. So let's stick with requirements files for now.. Okay, I doubt it'll make too much of a different either way.. Seeing as it doesn't work, we can close this, yes?. Even an issue seems premature. Python 3.7 isn't even out yet.. Looks like we've got test failures.. Looks good to me. How about adding some simple tests to test_bin.py?. Don't forget another commit to update AUTHORS, by the way.. Pssh, Perl is so 10 minutes ago. We need to rewrite Hy in a modern language like Rust or Go.. Duplicate of hylang/tryhy#6.. I think you should allow completion of the mangled form, too. Thus, if you imported a symbol is_foo from a Python module, is_f will be recognized by the completer, as a user would probably expect.. That's cool. Perhaps the completion parts should be moved into Hy, or perhaps its own completion should be replaced with Hy's.. Where should I be seeing the results you saw? https://ci.appveyor.com/project/hylang/hy gives the error \"Project not found or access denied.\". The addition of AppVeyor seems to have already taken effect (see #1570 and click \"Show Details\"). Ideally we wouldn't have this as an automated check till we actually have all the tests passing on Windows with master.. Can you turn off the automatic AppVeyor check for every new PR?. Why not use .replace or something instead of conditionalizing the format string?. > @Kodiologist style mostly. IMHO format strings should be treated as constants as much as possible - though I guess it would be safe in this case.\nWouldn't it suffice to write something like\n(.replace (.strftime x \"%Y %m %d %H %M %S\") \"  \" \" \")\n\n? Then the format string is a constant, and you don't need to check the platform.. I don't see how that would work. The line I wrote manipulates the return value of .strftime, which doesn't exist till runtime.. This can probably be rewritten as\n(.replace (.strftime x \"%Y %m %d %H %M %S\") \"  \" \" \"). N.B. GitHub won't detect \"Fix issue #1571\" properly; [you need the issue number right after the word \"fix\"](https://help.github.com/articles/closing-issues-using-keywords/).. Looks good.\n\n\nDon't you mean \"Throw when codec can't decode some bytes\"?\nUpdate NEWS, unless you know this to be a regression since the previous release.. Exactly.. I've changed this to a more direct approach that quits macro-expansion as soon as there's nothing left to expand instead of comparing outputs.. It is perhaps silly that #* and ~@ do very similar things but look completely different.. Sounds reasonable.\n\n\nAnd similarly, (print . (1 2)) becomes (print #* [1 2]). But in this case we're deferring it to runtime.\n\nYou could write (defmacro m [] `(print ~@'[1 2])) (m), but there probably ought to be some variation on eval-and-compile to let you do that kind of thing without making you write a macro that you only use once.\n. What would that imply? Making the compiler automatically recognize and simplify such constructs? I'm not sure how often they're actually used.. Clojure also has some short names it uses to munge punctuation characters, if I recall. We could use those.. Let's cross this bridge when we come to it.\n\nwe should try and always emit the same AST that Python would\n\nThat seems like a tall order. . I did say that Hy should be able to produce any given Python construct. For example, Hy should have a way to produce lambda expressions and decorators even though these aren't semantically necessary. Making sure that the complete AST tree matches what Python would produce for the equivalent code goes a lot further, because of issues like the management of Hy's temporary variables, and backwards-compatible AST changes that happens between Python versions but we don't attempt to track in Hy. I bet that in some cases we'd even have to reproduce some of Python's bugs.. Whoops, that was probably my typo.\nInterestingly, however, the error message for using ~@ outside backticks is HyTypeError: `unquote' can't be used at the top-level, and this PR doesn't change that.. Ah, all right, then.. Don't our fancy error messages already do that, by pointing to the part of the code where the programmer tried to unquote something?. That's technically enough to merge, but let's give it a grace period of a few days just in case.. Okay, very good.. Sure, seems innocuous enough. I'd write default is _sentinel, though (and note the spelling of \"sentinel\").. Replaced by #1656.. Yep, this is a bug and it's in master. (Remember to check master, not the last release, for bugs before reporting.) It looks like statements are kept ((try (raise 1) (raise 2) (finally 1))) but expressions are dropped ((try x (raise 2) (finally 1))).. Yes, I forgot that's okay here because I'm working on #1573 where I have to be a bit more careful with boolification.. Yeah, that's what I mean. I didn't even realize you could write it as (defn foo [(, bar baz)] \u2026) as well as (defn foo [[bar baz]] \u2026).. > One very common usecase is mapping a lambda over an enumerate.\nThat should be doable more easily with a comprehension (#1626).. Right.. Two reviews would definitely be nice, but the chances of getting them seem slim.. @gilch Sure enough, here we are two weeks later with no reviews. If you have any objections to the changes, then let's by all means discuss them, but a veto with no actual opposition to the changes defeats the purpose of the two-week policy, which is to allow uncontroversial PRs to be merged even when reviewers aren't available.. > Not objecting to the concept is different than approving this implementation of it.\nI'm asking for objections to the implementation of it, not just the concept.\nThe problem is not that the team is hindering me (or anyone else). The problem is that the team is often not there, because we're all volunteers who are maintaining Hy without pay in our spare time, and Hy is one of many priorities competing for our time and energy. That's why I pushed for the two-week policy, which largely solves the problem of non-availability of reviewers. To veto because nobody has the time to review a PR recreates the problem.\nI really don't want to fork, because that would fragment the already small core team.. Thanks!. > Question is should we maybe make another small release before merging this, or just going for it?\nI want to go for it. It'll be at least a few weeks till the next release, and I'll be running Hy master in the meantime, so at least I'll find any big new bugs if nobody else does.. Okay. If you find something bad, you can just post an issue and I'll probably be able to make PR for a fix promptly.. @vlasovskikh Oh, cool, good to talk to you. The change I'm proposing is to store the token that failed to match every time an alternation (|) switches to another option. Then, if the parse fails, the parser can report all the token types that would have been legal at the final position, and we can provide error messages like \"expected symbol or number\".. See vlasovskikh/funcparserlib#52.. I'll merge the first one, but the second one would get clobbered in #1593, so I'd rather just rebase there.. I'm closing this for lack of response.. The GitHub issues list is for bug reports and feature requests. For support, try our mailing list, our IRC channel, or Stack Overflow.. You need ~(HySymbol funcname). This should probably be better documented.. Or exploit Python's dynamism and write `(setv (get (globals) ~funcname) (fn ~args ~@body)).. You're welcome. I'm keeping this open as a documentation issue.. Fixed by #1517. Please only report bugs in master.. I don't think byte-compilation should be the issue, because Hy's call to write_code_as_pyc is wrapped in a try that catches IOError and OSError. The quoted error message doesn't include a stack trace, but the presence of an errno suggests it's an OSError.\nBy the way, @daniel-severo, this probably isn't your problem here, but it's a Bad Idea to have a Python module and a Hy module with the same name in the same directory, especially when that name is __init__.. > The quoted error message doesn't include a stack trace\nThe first thing to do here is probably to see how to convince AWS Lambda to give you the stack trace.. Did you get a traceback? https://docs.aws.amazon.com/lambda/latest/dg/python-exceptions.html. I was able to get a stack trace by putting the import hy inside the function called by AWS Lambda instead of the mainline code.\n{\n  \"errorMessage\": \"[Errno 30] Read-only file system: '/home/sbx_user1065'\",\n  \"errorType\": \"OSError\",\n  \"stackTrace\": [\n    [\n      \"/var/task/handlers.py\",\n      2,\n      \"hello\",\n      \"import hy\"\n    ],\n    [\n      \"/var/task/hy/__init__.py\",\n      11,\n      \"<module>\",\n      \"import hy.importer  # NOQA\"\n    ],\n    [\n      \"/var/task/hy/importer.py\",\n      7,\n      \"<module>\",\n      \"from hy.compiler import hy_compile, HyTypeError\"\n    ],\n    [\n      \"/var/task/hy/compiler.py\",\n      11,\n      \"<module>\",\n      \"from hy.lex.parser import mangle\"\n    ],\n    [\n      \"/var/task/hy/lex/__init__.py\",\n      9,\n      \"<module>\",\n      \"from hy.lex.parser import parser\"\n    ],\n    [\n      \"/var/task/hy/lex/parser.py\",\n      374,\n      \"<module>\",\n      \"parser = pg.build()\"\n    ],\n    [\n      \"/var/task/rply/parsergenerator.py\",\n      194,\n      \"build\",\n      \"os.makedirs(cache_dir, mode=0o0700)\"\n    ],\n    [\n      \"/var/lang/lib/python3.6/os.py\",\n      210,\n      \"makedirs\",\n      \"makedirs(head, mode, exist_ok)\"\n    ],\n    [\n      \"/var/lang/lib/python3.6/os.py\",\n      210,\n      \"makedirs\",\n      \"makedirs(head, mode, exist_ok)\"\n    ],\n    [\n      \"/var/lang/lib/python3.6/os.py\",\n      220,\n      \"makedirs\",\n      \"mkdir(name, mode)\"\n    ]\n  ]\n}\n\nIt seems that the guilty code is in rply.parsergenerator, which tries to write out a cache of the generated parser without catching any errors. I've opened an issue at alex/rply#74.. @daniel-severo Did upgrading rply solve your problem?. That sounds like it could be another bug. Try opening a new issue for it. Let's keep this one open till a new rply is out.. This is a real bug, which presumably arose from #1582.\n@hylang/core, would anybody mind if I finally put botsbuildbots out of its misery?. What's a creator error?. Fixed in master (as of #1517). Don't forget to check whether a bug still exists in master before reporting.. What's the point of ap-compose in the first place? The value of the typical composition operator is that given some existing named functions f and g, you can write (compose f g) instead of (fn [x] (f (g (x))). But an anaphoric composition operator only lets you write something like (ap-compose (+ it 1) (* it 3)), which you could just as easily write (fn [it] (+ (+ it 3) 1)). You can't do point-free programming with an anaphoric function.. Actually, ap-pipe seems no more useful than ap-compose, for the same reason.. Would you like to open a PR that just removes ap-compose and ap-pipe?. Just make your changes at the command line and say git push -f to replace this PR with your local branch.. I've never used Mercurial before, but the feature you're looking for in Git terminology is a force push. So if you Google \"How do I force-push in Mercurial?\" or something, that might get your answer.. Unfortunately, you need the --process-dependency-links option to pip install in order for the dependency link to actually work. I don't know a way around this, but hopefully there will be a new astor release before Hy 0.15.0.. > @Kodiologist even with the --process-dependency-links option I'm getting 0.6.2. How have you installed 0.7.0?\nDid you see something like this?\n$ pip install --process-dependency-links -e .\nObtaining file:///tmp/tenv/hy\nDEPRECATION: Dependency Links processing has been deprecated and will be removed in a future release.                                                         \nCollecting rply>=0.7.5 (from hy==0.14.0+132.geec4a17)\n  Cache entry deserialization failed, entry ignored\n  Using cached https://files.pythonhosted.org/packages/02/e9/05c04324d1bd0581df638d34415d5549f054830534dda60ddc1976f41006/rply-0.7.5-py2.py3-none-any.whl\nCollecting astor (from hy==0.14.0+132.geec4a17)\n  Cloning https://github.com/berkerpeksag/astor.git to /tmp/pip-install-i7jo09mj/astor\nDEPRECATION: Dependency Links processing has been deprecated and will be removed in a future release.                                                         \nCollecting clint>=0.4 (from hy==0.14.0+132.geec4a17)\n  Cache entry deserialization failed, entry ignored\nCollecting appdirs (from rply>=0.7.5->hy==0.14.0+132.geec4a17)\n  Using cached https://files.pythonhosted.org/packages/56/eb/810e700ed1349edde4cbdc1b2a21e28cdf115f9faf263f6bbf8447c1abf3/appdirs-1.4.3-py2.py3-none-any.whl\nCollecting args (from clint>=0.4->hy==0.14.0+132.geec4a17)\n  Cache entry deserialization failed, entry ignored\nBuilding wheels for collected packages: astor\n  Running setup.py bdist_wheel for astor ... done\n  Stored in directory: /tmp/pip-ephem-wheel-cache-t1h8d6wc/wheels/1b/17/42/63a7a063e0be10a2e32871c9cbb423ba837bac9af6478ff03e\nSuccessfully built astor\nInstalling collected packages: appdirs, rply, astor, args, clint, hy\n  Running setup.py develop for hy\nSuccessfully installed appdirs-1.4.3 args-0.1.0 astor-0.6.2 clint-0.5.1 hy rply-0.7.5\n\nEven though the installed package is detected by pip as being 0.6.2, you're actually getting astor's current master, which you can verify by looking at the installed code. I put egg=astor-0.7.0 at the end of the dependency link to make it possible to upgrade from the real 0.6.2, although I'm not sure this works. There is no real astor 0.7.0 (at least, not yet).. Otherwise, looks good.. True, but it's always nicer to be able to implement new features with things like macros rather than extending the lexer and parser. It helps to advertise the utility of metaprogramming.. Seems reasonable..     (defmacro \u29bb [&rest x] (tuple (~@x)))\n    (print (\u29bb map inc [1 2 3])). That seems like a feature. Wouldn't you rather see the same sequence of characters everywhere rather than one in Emacs and something different elsewhere?. Fortunately, that's easy now thatimportandrequireare parsed with the same code..org.python.lang.python.util.time.dates.datetime.dateime.now.AbstractHandlerFactoryManagerFactoryDecoratorProxy`. Thanks!\nI think we should stick with square brackets. Special forms tend to use parentheses only for inner elements that look like special forms themselves, such as (except \u2026) and (else \u2026). Otherwise, they use square brackets for grouping.\nAlso, are you sure that (import foo :as bar) is better than (import [foo :as bar])? With (import foo :as bar), related elements among the arguments of import are no longer grouped.. Okay, we can lose the extra brackets for :as.. > That's not really true of macros though, even in Hy. To the end-user, the distinction is kind of fuzzy.\nYou mean we have core macros that use parentheses for grouping? We should probably fix that. Although, most macros that expect groups won't distinguish between square brackets and parentheses; you need some code to check for that explicitly. Unless you're using model patterns, but that's not a thing yet.. Oh, those cases make sense, since the parenthesized groups end up compiled as regular expressions (typically function calls).. We already disagree how to indent Lisp, so I'm not sure what rhetorical strategy you were aiming for there.\nBut, I will admit that parens do suggest more than square brackets that the head is special and not a peer. I can only reply that the rule that a parenthesized expression is like a function call (it's a special form, or it's a macro call, or it becomes one of these things, or the like), whereas brackets are used for everything else, seems more salient to me.\nHowever! I think I like your original proposal, #851, best. If we're going to break the world to remove unnecessary punctuation from import and require, we might as go the whole way. The two guys who seemed opposed to that are no longer active on Hy. @vodik, what do you think of it?. > You refuse to learn the standard and won't let your editor do it for you either, you mean. Maybe you enjoy counting brackets. As a meditative exercise. Or maybe you feel the need to write code no-one else can read. For job security.\nI don't accuse you of indenting code in the way you like for some stupid or nefarious purpose, so please don't do that to me. It's evident (from when you threatened a \"hostile fork\", from when you unilaterally closed one of my PRs an hour after I'd opened it, and from this) that indentation is a sensitive matter for you. I don't know why that is, but it's not appropriate to take it out on me or anybody else.. Well said, guys.\n\nWe seem to have agreed that #851 is the nicest syntax. Does anyone else (at least, anyone who's actually working on Hy right now) want to object?\n\nIt looks like we're all cool with it. My guess is that Simon would have no objection, but he just hasn't had the chance to return to this PR. Maybe I'll pick it up myself if he doesn't.. Presumably you would write it in one line as\n(import sys  sys [stdin])\n\nor so, using double spaces to separate pairs.. > How about dropping the space for the one-line version (import sys sys[stdin]) as a matter of style?\nThat makes sense, too.\n\nI'd approve my original proposal from #851 too.\n\nThat's what Simon has done now, right?. @vodik, could you rebase onto the new master?. Looks like you hit an internal PyPy bug! Nice.. @vodik, how are we doing here?. I've never used the debugger. I don't know much about it.. > TL;DR: If the decision for Python were made today, they probably wouldn't be insensitive.\nYeah, that's what I'd think. It seems like a clear design mistake. The question then becomes whether we want to fix or retain this peculiarity of Python.. Should we reopen with [docmebro]?. Don't mind if I do.. Yep, this is on my personal to-do list.. How about a test?. Pass in (+ 1 1) and check that you get 2 back. It shouldn't be hard if you temporarily redirect standard input and output.. >  I believe decorating (fn ...) is useful sometimes.\nIt shouldn't be, or else something is wrong. Instead of (with-decorator f (fn ...)), just say (f (fn ...)).. Yeah, you need to put decorated, or equivalently (return decorated), at the end of the definition of the-answer.with-decorator returns None, not the decorated function. If you want to be more concise, you can write\n(defn the-answer [f]\n  ((functools.wraps f) (fn [] 42)))\n\n. > returning None makes nesting with-decorator impossible (not that I think that is a good idea).\nNo, nesting with-decorator still works:\n(defn dec1 [f]\n  (fn []\n    (print \"in dec1\")\n    (f)))\n\n(defn dec2 [f]\n  (fn []\n    (print \"in dec2\")\n    (f)))\n\n(with-decorator dec1\n  (with-decorator dec2\n    (defn foo []\n      42)))\n\n(print (foo))\n\nThis prints:\nin dec1\nin dec2\n42\n\n. Right, it has to be a special form because it directly modifies attributes of AST nodes.. > lisp-comp, set-comp, genexpr, dict-comp will be replaced by lfor, sfor, gfor, dfor in the future, is it correct?\nIf this gets merged, yes.\n\nIf so, will they be in next release?\n\nIf this gets merged, no, list-comp etc. will be gone, since lfor etc. replace them.. Ideally there will be a new release of Hy this month or next month.. I'd rather not punctuate names that I expect to use heavily.. One theoretical advantage of the lfor names is that if the Python people add asychronous generator comprehensions, as rumor states they may, the new operator will have an obvious name (gfor/a) instead of being one of for/a/g, for/g/a, for/ga, or for/ag.. I'd prefer short names, but I'll change the names if there's a consensus for a specific alternative.. Actually, since there are no objections, I'll work on the to-do list now.. > I'm still concerned that this will break let\nI think let already didn't work correctly with comprehensions, since they're not mentioned in contrib/walk.hy, so at least this change won't make things any worse.. Done.. I've belatedly realized that async for in comprehensions has in fact been implemented in Python, as of Python 3.6. I think the simplest way to implement this is to remove for/a and just allow :async LVALUE ITERABLE as a comprehension clause, so the asynchronous equivalent of\n(lfor x (range 10) x)\n\nwould be\n(lfor :async x (range 10) x)\n\nand likewise, instead of\n(for/a [x (range 10)] (print x))\n\nyou'd write\n(for [:async x (range 10)] (print x))\n\nAny objections?. Yep, nested loops work exactly like your example. I've made and pushed the changes, so feel free to try them out.. Can you provide a reproducible example?. That could be an Emacs issue. Does it work in a real terminal? Also, have you checked that the equivalent Python code works okay in Python's native REPL?. > Also, have you checked that the equivalent Python code works okay in Python's native REPL?. Okay then, presumably this is an issue with Python, not Hy.. You realize that /.* refers to the attribute hyx_XasteriskX of the shadow / operator, right? You shouldn't be setting attributes of shadow operators. And Hy doesn't implement importing dotted names. I'm not sure what exactly (import [foo [bar.baz]]) would do if it worked.. The change in the syntax of import shouldn't affect this because all it will do is make (import test [/.*]) work like (import [test [/.*]]) currently does.\nDo you still believe there is a bug here? If so, what exactly do you think should be different?. Okay, it would make sense for import and require to protest if you try to import a name with a dot in it.. @hylang/core, it would be good to get this in soon since otherwise every Travis build will fail.. Thanks!. This is intentional, yes.. This looks like a duplicate of #1134.. See #1625.. Using pytest on Hy code isn't something we officially support or document at all, right now; the existing support is only for Hy's internal use. But see #1529.. I have to admit that I never considered the possiblity of beginning a name with ->; when I've seen that digraph in Lisp names before, it's been in the middle of the name.\n\nI propose we revise the mangling rules to distinguish leading -s from leading _s. Any internal - will continue to mangle to _ as now, but if they're in the lead, it becomes XhyphenHminusXs, or preferably something shorter like XsubXs if we do the short names #1577. But leading _ won't change.\n\nThat sounds reasonable.\n\nWe could also distinguish non-leading _s from -s for full reversibility by converting them to Xlow_lineX (or XscoreX).\n\nBut in that case, the user is no longer allowed to write a Python name that contains an internal underscore, like string.ascii_lowercase, with a real underscore. The rule that any Python name is also a valid Hy name with the same meaning will be broken, and mangle will no longer be idempotent. The same goes for https://github.com/hylang/hy/issues/1634#issuecomment-396004072.. > So which property is more important? I thought it was invertiblity, since we're defining and using an inverse function, unmangle.\nunmangle isn't a real inverse, because mangle is many-to-one. Its purpose is to produce a pretty \"Hy-like\" name for the input, with \"hyx_\" prefixes gone and \"XfooX\" replaced with the character it indicates etc.\n\nWhy is idempotence better for this use case?\n\nWhen I think about it, \"idempotence\" in this case is just a fancy way to say the earlier thing I said, \"any Python name is also a valid Hy name with the same meaning\"; i.e., every Python identifier mangles to itself. This property is equivalent to idempotence because mangle is also guaranteed to always return a Python identifier.\nSo to answer your question, I would rather have Python names work unchanged as Hy names than have unmangle be a real inverse.. Ryan, did you mean to attach those comments to particular lines of the file?\nMatthew, I don't personally like the style you've advocated here, but I didn't like the previous version, either, so I see no reason to object to the changes. My only serious objection to merging this is that #1612 isn't in yet. Ultimately, my preference would be not to include any style guide in the reference manual, since style is idiosyncratic and liable to change over time. Personal blog posts, like Paul's original post, are an example of a better medium for this subject.\nWhile you're editing the style guide, though, here are some more suggestions:\n\nRemove the epigraphs. I'm not against epigraphs or humor, but I don't think these quotes are good choices because they have no apparent relation to the content except for containing the word \"style\".\nIf we're going to include that koan in the manual, let's explain what it's supposed to mean. I for one have no idea what it means.\nDescribing the design goals of Hy (here listed under \"The Tao of Hy\") is good, but a style guide isn't the right place for it. Let's move this material to elsewhere in the manual.. > Perhaps fix a recommendation for unused arguments (setv [x -] x-y) as I\ncould see _ being a reasonable choice.\n\nCareful, assigning to - or _ will shadow the shadow - operator. So while it's handy in Python, it's probably unwise in Hy.. @kirbyfan64, I think the ball's in your court to assess whether you're happy with the changes.. I don't understand your example. I don't know what you expect the lambda list [[sym o!expr] then else] to mean, and when I try to run the example form with your change, I get HyTypeError: parse error for special form 'fn'.. > The tests didn't pass before I started. :P\nWe're removing Python 3.7 on Travis (#1631), but all other Pythons should still pass.. Ah, so you meant to do unpacking. That makes sense. But as Matthew points out, unpacking in lambda lists was recently removed, and if you want to look for o-parameters in &optional lists, you should be checking only the first element of each &optional list.\nIn any case, be sure to add a test for your new feature.. There's been some work on fancier unpacking (#1328), but nothing has landed yet.. Try adding a test.. It's not just you. That's a regression I introduced that #1625 fixes. Sorry about that.. Oh wait, I already mentioned defclass docstrings in #1527.. The way tag-macro calls are parsed is that a HASHOTHER token is combined with the following token into the model (dispatch-tag-macro \"tagname\" expr). If you could call a tag macro without an argument, then presumably that would parse as HASHOTHER alone, which would produce (dispatch-tag-macro \"tagname\"). But if a tag macro could be called with one argument or none, how is the parser supposed to tell which you mean? It can't just check the parameter list of the tag macro because that's not known until compile-time.\nIn short, does (f #a foo) mean (f (dispatch-tag-macro \"a\" foo)) or (f (dispatch-tag-macro \"a\") foo)?. Nobody did. I merged it under the two-week rule.. Contrast with #1045.. Python 3.3 is no longer supported since Hy 0.14.0. Its end-of-life for the Python development team was on 2017-09-29.. Could you spin out the indentation changes into their own commit? That would make it easier to see the substantive changes.. While it occurs to me to ask, does let and its subroutines use destructive modification of models, and hence need to be updated if we do #1542?. You know that a version of let was added back in in 0.14.0, right?. Right.. That's fixed in #1517. Make sure to check that a bug still exists in Hy master before reporting it.. > Is there a list anywhere of projects written in Hy?\nWe have this wiki page, but nobody's been updating it.\nLike Gilch says, we're still a while away till 1.0. The language is definitely mature enough for serious use: I'm a scientist and I've been using it for data analysis for years, and my website is written in Hy using CherryPy. Still, I have to go back and regex-replace code when there are syntax changes, which is annoying.. I'd like to release 1.0 in about a year, but that's probably not realistic.. Not that I know. Especially with the latest Hy, since hy2py should now be 100% accurate, so you can compile your Hy code to Python and use that if you need to. It's even possible to write Hy programs this way that don't have Hy itself as a dependency.. > Even using Hy Core or similar namespaces\nNo. (Unless you copy the relevant bits into your own code, of course.). Automatically determining which macros a piece of code depends upon is, I suspect, undecidable. But there's no reason in principle that we couldn't make require able to pull in macros that are themselves required by the named file. #1268 is related.\nGenerally, macro subroutines are better written as functions than macros. Unfortunately, that's not an option when you're using a preexisting macro like let. You could try using macroexpand.. Not scalable? Do you mean you expect there to be some kind of performance problem with allowing require to take macros that are required by the named file? Why so?. I don't anticipate a performance issue, no, and the resulting Hy programs will obviously not be more complex. I don't think the implementation will be complex, either, but figuring out how to do it could take some work.. #1634 should already be fixed as of 498a54e770610c1af720a91ffaec0e46669a4b02.\nI'm not a fan of removing is_ or removing the mangling prefix from most mangled names.\nI think a private Unicode character is a better choice than ASCII NUL so that the user can type it, if desired, without weird stuff happening like Unix tools mistaking the source code for binary.. > 498a54e only fixes it for Hy's internal use though.\nSee https://github.com/hylang/hy/issues/1634#issuecomment-396006222.\nI would want to avoid situations where whether an identifier is mangled (in the narrow sense of having an escaped Python-illegal character) isn't easily discernible, or where an identifier that looks as if it were mangled were generated by something other than Hy. That's the value of an explicit prefix.\nI don't think U+FFFF is the best choice because it's designated as a non-character, so data that isn't Unicode can be more readily identified. I'd recommend instead a Unicode private-use character such as U+E000 or U+EFAF. This is the sort of thing the Private Use Areas are for, I think.. Thanks for the link. This is a more complex issue than I realized, and I think Wikipedia misled me. Yeah, U+FFFF or another noncharacter seems fine.. I see where you're coming from. You make some good points. Still, mangling seems weird enough that I would prefer an explicit prefix and a fail-noisy unmangle, although this has the cost of the user needing to keep in mind that a Python identifier may start with a different character than the corresponding Hy symbol. And that's already the case because of the \"is_\" rule, which I also want to keep.. @hylang/core, let's try to get this out soon, since it provides Python 3.7 compatibility, and Python 3.7 is out.. @hylang/core, is there a problem? We all want a new release, right?. Thanks. I'll rebase and do the release tomorrow.. Can you reproduce this issue on Hy master? The following works for me (Hy master has replaced list-comp with lfor, which has different syntax):\n(defmacro my-switch-case [var cases]\n  `(cond\n    ~@(lfor x cases `[(= ~var ~(first x)) ~(second x)])))\n\n(setv x 1)\n(my-switch-case x\n  ((1 (print \"first condition\"))\n   (2 (print \"second condition\"))))\n\n. Good, then all's well. Don't forget to check whether a bug still exists in master before reporting.. I could see that, but it would probably be better in a new PR (or just a new issue, for now).. I'd rather not have pull requests merged automatically. Even when there are two approvals, for example, there might be some minor tweaks to be made. Merging is an important enough thing that it should require a human explicitly pressing a button.. Anyway, I think @gilch's diagnosis of why the idea of letf doesn't really make sense (at least in Python and with a lexical let) is spot on, so I'm closing this issue.. Because of #1360.. 1. Spin out the unrelated style edits to walk.hy into their own commit.\n2. Put the test macro into one of the existing files in tests/resources instead of its own file.\n3. I think the test is too brittle because it depends on require expanding to None. Instead, try something like (assert (= (last (macroexpand-all '(require-macro))) '(setv blah 1))).\n4. Update NEWS and AUTHORS.\nOtherwise, this looks good.. Right. Don't attempt to remove it for now.. I don't know anything about IPython, but you can evaluate Hy code from Python with hy.eval and hy.read-str, and I'm guessing that IPython is itself written in Python.. If we ever want to implement reader macros, we'll probably have to ditch rply, but we'll probably also end up with a slower parser because we'll need to abstract things more.. 1. This is not a bug. Notice that even at the first print, each of the elements is underneath two levels of quoting; it's just that the outer quote is applied to the whole list instead of each element. Your flatten_list function accumulates elements into a list, not a HyList, so hy-repr doesn't print an outer quote mark, and so in order to return e.g. a string that evaluates to '(identity), it must return \"''(identity)\".\n\n\nI don't know why you'd want that, but start with the string \"[(identity) [(/ 2) (np.ceil)]]\" instead, or convert the result to a HyList.\n\n\nNo, flatten flattens a much broader class of objects than HyList.\n\n\nN.B. In place of (lfor item x (iter1 item)), you probably want (for [item x] (iter1 item)), so as not to build a list you won't use.. I don't think I understand your question. Try one of Hy's support channels.. I don't think we're ready to drop Python 2 support, sorry. The Python folks are still supporting it till 1 Jan 2020.. I should add that even if you want to drop Python 2, it's a big enough change that it should get its own PR.. Okay, that sounds like a decent thing to try.. Can you specify which bugs these changes fix, and add tests for them? (I see you added a test for reload, which is good.) I don't know much about the guts of Python's import system, so it's hard for me to judge how much of an improvement these changes are without tests showing fixed bugs.. Don't forget keywords (but it's probably best to wait till you have a test for a bug before declaring it fixed).\n\nOtherwise, PEP compliance should be a high priority regardless, no?\n\nNot exactly. I'm not against violating a PEP if by so doing we can fix a bug, add a feature we want, shorten the code, or the like. PEP compliance per se is academic.. > Unfortunately, not even CPython makes consistent use of these (e.g. runpy and py_compile do not completely use the existing loaders and are a lot less applicable as a result), so not all those benefits are actually present\nThat's the sort of thing I was afraid of. If you can implement these things in passing, that's fine, but don't write a lot of code that CPython can't actually use. Unimplemented standards often end up being ignored or changed.. There are issues with require that will probably need additional work, but this PR is probably already ambitious enough, so I wouldn't take them on here if I were you. At any rate, this is a very promising PR. I'll review it soon.. Hmm, I see. Since Hy didn't already have a deliberate policy with respect to coexisting .py and .hy, you don't have to worry about it for this PR if you don't want to, sure.. In Hy, it's important that hy foo.hy read and write bytecode, because compilation can be arbitrarily slow (because it involves macro-expansion). I'm sorry; I missed the fact that you removed hy {fpath} from test_bin_hy_byte_compile.. Sounds good. Try it out.. def is gone as of  #1483.. This is Hy's issue list. For help using Hy, try elsewhere.. Yeah, I think it's reasonable to expect a .hy file extension of Hy files that are imported, but hy SOMETHING should always interpret SOMETHING as Hy\u2014unless, perhaps, it both has a file extension and that extension is .py or .pyc.. We also presumably want shebang lines to work:\n$ printf '#!/usr/bin/env hy\\n(print 1 2)\\n' > myprog\n$ chmod 755 myprog                                  \n$ ./myprog\nTraceback (most recent call last):\n  \u2026\n  File \"./myprog\", line 2\n    (print 1 2)\n           ^\nSyntaxError: invalid syntax\n\n. We should probably avoid trying to interpret shebang lines (that's the shell's job) or detect Hy syntax. I think that hy FILENAME will need an exception from the usual import rules, and perhaps it shouldn't use runpy.. I don't think this is the right way to address #1677. For example, if there's a syntax error for both Python and Hy interpretations of the file, which error do you show?\n\n@Kodiologist, the one failure on Travis \u2014 for pypy3 \u2014 is really weird; do you mind retrying that check manually?\n\nI don't think that's an option on Travis, but you can trivially change your top commit (e.g. git commit --amend --reset-author to change the timestamp) and then force-push.\n. > For Travis, I've been able to retry with this before.\nOh, I didn't notice that button. I've pushed it.\n\nOtherwise, do you think Python should never even be tried for unknown filetypes?\n\nIn the case of invoking hy FILENAME, indeed it shouldn't be tried. runpy.run_path, on the other hand, should probably assume Python. Otherwise you'll see Hy syntax errors when you try to run a Python script that you made a typo in, right?. Neat! Try adding a test where the shebang line is used by running the file as an executable, too. Assuming it's possible to arrange for that in pytest.. Not quite, since this failed even though my shell didn't have a relevant bug.. Nah, forget it, it's probably overkill. I'll review this soon.. Sorry I forgot about Hy for a few days there. I'll merge this now.. I didn't realize we had the empty? function. It seems a little pointless, since not should do the same thing in most cases where you'd use empty?.. > I think this bug was introduced by the use of importlib.import_module (via #1672)\nOh, okay, there's no need for a NEWS item if this bug was a new regression.\n\nAlso, I was thinking of putting in a PR that rewrites the doc macro so that it simply works with everything (i.e. tags, macros, functions). It's much less confusing to get documentation in Hy that way, so, if anyone else is interested, we could entirely obviate this PR with that one.\n\nThat sounds fine to me.. I don't think I understand what you want. If there's a function, macro, and tag macro with the same name, and you don't want doc (or help) to print out all the options, and you don't want to let the user select which to print out, then what is it supposed to do?. Oddly, it seems that no Travis run is showing for this PR.\n\n\u2026however, there might be other work-arounds available that allow those functions to handle Hy source strings as a special case.\n\nYou're certainly welcome to try.. This is just how Python 2 works, I'm afraid:\n$ python2\nPython 2.7.15rc1 (default, Apr 15 2018, 21:51:34) \n[GCC 7.3.0] on linux2\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> xrange(10)[:]\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: sequence index must be integer, not 'slice'\n\n. Those examples are from Hy running on Python 3. Please upgrade.. Sounds pretty exciting. Want to add some tests?. At a high level, how does calling test-macro-module in a file other than the file it was defined in work? How does Hy now know that let refers to the let that was required in the module where test-macro-module was defined? How would this interact with any new macro named let in the calling file?. Interesting; thanks for the explanation. As the system gets more mature, we'll probably also want to change the order of checks so that the macro's defining module is checked first. Otherwise, a macro user can inadvertently shadow one of the macro's subroutines.. Nice. Are you done with this PR or are you planning more changes?. > Otherwise, I have some AST/source line numbering fixes to make.\nAre these regressions introduced by this PR, or preexisting issues?. I tried the test I suggested at the top of #1268 with Python 3.6.6. Running hy foo.hy once crashes:\n Traceback (most recent call last):\n   File \"/home/hippo/Desktop/py36-env/bin/hy\", line 12, in <module>\n     sys.exit(hy_main())\n   File \"/home/hippo/Desktop/hyenv/hy/hy/cmdline.py\", line 382, in hy_main\n     sys.exit(cmdline_handler(\"hy\", sys.argv))\n   File \"/home/hippo/Desktop/hyenv/hy/hy/cmdline.py\", line 368, in cmdline_handler\n     runhy.run_path(filename, run_name='__main__')\n   File \"/usr/lib/python3.6/runpy.py\", line 263, in run_path\n     pkg_name=pkg_name, script_name=fname)\n   File \"/usr/lib/python3.6/runpy.py\", line 96, in _run_module_code\n     mod_name, mod_spec, pkg_name, script_name)\n   File \"/usr/lib/python3.6/runpy.py\", line 85, in _run_code\n     exec(code, run_globals)\n   File \"/tmp/foo.hy\", line 1, in <module>\n     (require [hy.extra.anaphoric [ap-if]])\n   File \"/home/hippo/Desktop/hyenv/hy/hy/macros.py\", line 106, in require\n     target_module = importlib.import_module(target_module)\n   File \"/home/hippo/Desktop/py36-env/lib/python3.6/importlib/__init__.py\", line 126, in import_module\n     return _bootstrap._gcd_import(name[level:], package, level)\n   File \"<frozen importlib._bootstrap>\", line 994, in _gcd_import\n   File \"<frozen importlib._bootstrap>\", line 971, in _find_and_load\n   File \"<frozen importlib._bootstrap>\", line 955, in _find_and_load_unlocked\n   File \"<frozen importlib._bootstrap>\", line 665, in _load_unlocked\n   File \"<frozen importlib._bootstrap_external>\", line 678, in exec_module\n   File \"<frozen importlib._bootstrap>\", line 219, in _call_with_frames_removed\n   File \"/tmp/foo.hy\", line 2, in <module>\n     (print (eval '(ap-if (+ \"a\" \"b\") (+ it \"c\"))))\n   File \"/home/hippo/Desktop/hyenv/hy/hy/importer.py\", line 145, in hy_eval\n     return eval(ast_compile(expr, \"<eval>\", \"eval\"), globals, locals)\n   File \"<eval>\", line 1, in <module>\n NameError: name 'ap_if' is not defined\n\nLikewise on master (in fact, that code I wrote hasn't worked, as written, since several releases ago). On master, running it again makes no difference, but with your PR, running it again prints:\nabc\nabc\n\nOnly one abc is expected.\nSo I'm not sure that your PR is fault given that the code was already broken\u2014all your PR has done is make it a bit less broken\u2014but perhaps it's something to think about?. What's the purpose of the include_require option? Would it hurt to effectively always have it on?. > The most recent commit produces require AST in all cases and does not raise an exception when a module contains no macros/tags. I think the latter should be changed, since it will surely confuse people, but something needs to be done about the situation demonstrated by the new test.\nThe reason I would expect (require foo) to work when foo has no macros is because (import foo) works even when foo is empty. require doesn't give you a macro or something named foo like import does, but that never happens for macros; even if foo had a macro bar, (require foo) would create only foo.bar, not foo.\nThat said, it's hard to imagine a situation where you'd want to require a module with no macros, so it shouldn't matter much.\nThe behavior of the new circular_macro_require.hy is definitely weird. You say that \"Even though we've already compiled the forms defining the macros, since the resulting AST hasn't been evaluated yet, they effectively do not exist\u2026\", but \n(defmacro bar [expr]\n  `(print ~expr))\n\n(bar 42)\n\nworks, and has worked on master for a long time. The reason it works is that defmacro uses eval-and-compile internally, so it gets evaluated immediately after the form is compiled as well as at run-time.\nSo, we already collect macros at compile-time. All we should need to do to make circular_macro_require work is to make sure macros are immediately added to their parent module after picking up their definitions.\nOr am I missing something?. Right on. We definitely want an error when trying to require by name a macro that doesn't exist.. circular_macro_require.hy is still printing 42 twice, though, so is this the method you're settling on?. I think so; it's more straightforward to implement it like that, right?. Very good. Take a look at my older comments and add something to NEWS and I think we're good to go.. You may need to click \"Load more\u2026\" above to show some comments that GitHub hid.. Hey, my dude, sorry for the incredibly long and slow review process. I haven't forgotten about this. I'm going through the PR and finding more concise ways to do things, spinning off unrelated changes, etc. The end result should be substantively the same, but I'll be sure to let you take a look before merging.. Okay, take a look. The biggest change is that when the compiler needs to add a call to the require function (now called requiref) to the AST, it uses a recursive self.compile call instead of building the call out of raw AST nodes. Hy trees are much more concise than AST nodes.\nMost of the changes occur in one giant commit now, which isn't great, but there's no longer so much of commits undoing previous commits in the same PR.. I think your comments are supposed to be attached to some lines, instead of being free-floating comments, but GitHub, in its infinite wisdom, doesn't seem to be showing the lines. Anyway, hopefully these remarks answer your questions:\n\"Integrate hy.inspect into hy._compat\" solves the same problem that you solved by adding from __future__ import absolute_import, because you needed to use the real inspect module in places where we were using hy.inspect. I'm not against absolute_import by any means, but we shouldn't have caused this problem in the first place.\n\"Rename hy.macros.require to hy.macros.requiref\" is to avoid self.compile(HyExpression([HySymbol('require'), ...])) being treated as a special form (and hence leading to an infinite loop) instead of a function call.\n\"Remove an unused function get_arity\" is separate from \"Integrate hy.inspect into hy._compat\" because the latter just moves some code whereas the former actually deletes something.. > \"Rename hy.macros.require to hy.macros.requiref\" is to avoid self.compile(HyExpression([HySymbol('require'), ...])) being treated as a special form (and hence leading to an infinite loop) instead of a function call.\nThat's the collision I'm referring to, and it didn't affect your implementation that used real AST nodes, just my implementation that uses self.compile on a Hy tree.. > Did you remove the absolute_import?\nYes, because it isn't necessary now, although it doesn't hurt.\n\nIf that solves the problem, then why are those commits needed?\n\nI think that having those functions in their own file, and giving that file the same name as a standard module, was a mistake in the first place. That is, this is a change worth making even if not strictly necessary to get the other parts of this PR to work. It's better to fix our mistakes than work around them.\n\nBesides being technically more efficient\n\nYou mean faster? It's hard for me to imagine a situation in which this change would make a noticeable speed difference (and if so, that would probably point to deeper speed problems regarding starting and stopping the compiler).\n\nits output/result is also exceedingly more transparent.\n\nTrue, in the sense that you don't need to look elsewhere in the compiler, but I'd rather have the logic for compiling a function call in only one place, even though this means you need to scroll down to @builds(HyExpression) to see how it works. In theory, you could argue that my version makes the code more robust to changes in how the AST represents function calls, but such changes are unlikely. It's really about conciseness.\n\nAlso, which commits were undoing other commits?\n\nI don't mean to say that there were commits that completely undid a previous commit, but there were a lot of changes that overwrote previous changes, such as an include_require parameter for the compiler being added in one commit and removed in a later one.. I see your point that in various senses the compiler is doing more work than it needs to, but overall, this approach seems to suffice. The various abstractions we've already implemented appear to suffice to make everything work. You could try to factor the function-call-building logic out of compile_expression so it can be used here without going through the whole compiler, but I doubt this would lead to meaningful speed or RAM improvements or head off any bugs. Besides, the technique of recursive compilation is more general and can also be used for much more complex cases such as compile_while_expression when cond_compiled.stmts is true. It's worth ensuring that recursive compilation works.\n\nSpeaking of macroexpand, will a user-defined requiref interfere with compilation of requires?\n\nI think so. In your implementation, this would happen for functions named require instead of requiref. This is a general problem related to Hy's auto-imports which will probably require (a) more mangling or prefixes, or (b) shifting to the user the burden of managing most things that we currently import automatically. I don't recommend trying to address it in this PR.\n\nthis approach starts to negatively conflate two distinct operations: the general act of generating Python AST (as ultimately emitted by the compiler), and the generation of AST for Hy trees (which involves language-specific logic affecting Python AST generation).\n\nSeeing as this is the Hy compiler we're talking about, I doubt we'd buy much by enforcing a distinction between those things.\n\nInstead of having the compiler generate and immediately compile a Hy tree for a require, why not turn require into a built-in/core macro?\n\nTranslating special forms into macros, when possible, is almost always a good idea. If you're interested and you think it can be done, go for it.\n\nAnyway, these changes don't appear to be directly related to the functionality addressed by this PR.\n\nIf by \"these changes\" you mean my use of ret += self.compile(HyExpression([HySymbol('requiref'), ...])), then it has to do with the functionality addressed by this PR because this PR introduced the idea of adding a function call to require/requiref as part of the AST. Before your work in this PR, require didn't compile to anything.. > I do not see how that could happen in the original implementation, and, having just tried it, it doesn't.\nUsing the REPL makes the automatic import happen later, so the issue doesn't appear in your example. Here's how you can see it with a script file:\n(defn require [x] (print \"wrong require!\"))\n(require [hy.contrib.walk [let]])\n(let [x 1] (print x))\n\nRunning that yields TypeError: require() got an unexpected keyword argument 'assignments'.\n\nNo, I mean the inspect and requiref-related changes. I don't understand what they're specifically addressing that wasn't already addressed by the original commits in this PR.\n\nThey're addressing the same things. I didn't add or remove features from your PR; I just changed the implementation.\n\nfixing the indentation is definitely warranted and not a superfluous style change.\n\nYou're free to futz with indentation if you like, but in PRs this large, you should do in a separate commit. Otherwise, the substantive change (adding __macros__) gets buried in the diff for a style change (reindenting).\n\nIn contrast, unnecessarily long, compound one-liners provide nothing noticeable, yet easily hinder readability and debuggability.\n\nI don't know what to say except that I don't see how breaking a large nested expression into several assignments aids readability. It's an extra step to the same destination. It creates a variable that leads the reader into thinking that the saved value will be used more than once, and hence the reader needs to keep another variable in mind while reading the rest of the code in scope.\nTo be clear, adding or removing intermediate variables shouldn't make a meaningful performance difference, since Python passes everything by reference anyway.\n\nThen there's this reversion that puts _stdlib back into module scope\n\nI think your idea to make _stdlib an instance variable makes perfect sense, but if you want it in this PR, put it in a separate commit.\n\nWhat's the reason for these test changes?\n\nThere's no special reason for the order of the tests; that was probably just how they ended up while I was shuffling other changes. Presuming the \"more informative explanation\" was a comment I removed, that sounds like a mistake on my part.. > In contrast, unnecessarily long, compound one-liners provide nothing noticeable, yet easily hinder readability and debuggability.\nI forgot to address the \"debuggability\" part. I admit that when I'm debugging or profiling a line, I take my existing code at that line and break it into a separate assignment for every intermediate value. This is very verbose, though, so I'd recommend keeping such a change temporary.. > I just made an update that uses the fully qualified name for the require function\nOh, well done; I should've thought of that. In theory, there's an issue of shadowing the name hy, but it's reasonable to expect the user not to do that.\nI would suggest my old name for the commit \"Integrate hy.inspect into hy._compat\" rather than \"Remove hy.inspect\" because the new name suggests all the code was actually deleted, instead of part of it being moved and part of it being deleted. Also, be sure to separate the deletion of get_arity into its own commit. Putting both the move and deletion into one commit makes it not so obvious that one function doesn't end up surviving the move. But in retrospect, I moved first and deleted second, when it probably makes more sense to delete first and move what's left over second.\n\nThere's still the matter involving macro shadowing. I don't know of a simple work-around in the current state, but I imagine we could add a separate require function to core/language.hy (or change the existing one) so that it too can be called \"interactively\" via its fully qualified name\u2014or simply re-imported.\n\nI don't understand how that would help. A user-defined macro can still shadow a core function.\n\nThis brings up a bigger question: why do we have import and require logic in the compiler?\n\nimport, at least, needs to generate AST nodes that no other special forms generate, so it needs to be a special form (or implemented in terms of a special form that creates those AST nodes). require seems more readily doable as a macro, but its unique compiler logic at this point is very simple, anyway; it calls macro.require and produces a function call that's compiled instead. Its other logic is parsing, which it shares with import.. That sounds reasonable.\nOne idea I've thought about a little but not explored is making a system so that Hy macros can produce AST nodes instead of just more Hy code, and using this to replace a lot of the compiler with macros. But a lot of the special forms provide very basic features, like setv, that you'd need to write those macros, so this would lead down the rabbit hole to self-hosting, which I suspect is way more trouble than it's worth.. Ah, whoops, I didn't notice you'd changed the target module. That's fine, since the functions are only used there. So make that \"Integrate hy.inspect into hy.macros\" instead.\n\nAre there external API expectations (e.g. Hy-dependent packages) that should drive us to more granularly track these changes and/or keep them in hy._compat?\n\nNo, it's just a matter of making the history readily comprehensible.. There have been several attempts. I think #1166 is the latest.. Sorry, I'd assumed you were working on writing require as a macro and were either going to change this PR a lot or replace it. I'll look at it again tomorrow.. It looks like you've undone the separation of deleting get_arity and moving the other functions. Is there a reason you want to keep those changes in one commit?. Putting the functions in hy.macros instead of hy._compat is fine.\n\nMore importantly, why would we want to be so granular?\n\nBecause the two things being accomplished in the combined commit are independent. One is deleting dead code. Another is moving code from one place to another, changing only what's necessary to support the move. With each change as its own commit, it's clear what's going on. On the other hand, putting both the move and deletion into one commit makes it not so obvious that one function doesn't end up surviving the move.\nThis is the same reason why indentation changes to a large body of code should in a separate commit from functional changes to a small portion of that code. The changes are independent, and the reader will know to look at the functional-change commit much more closely than the indentation commit.. > removal of hy.inspect necessitates the relocation of its functions used within hy.macros (to hy.macros), so those are also not independent.\nI'm with you there, to be clear.\n\nget_arity's removal occurs as a direct result of hy.inspect's removal (i.e. the focus of the commit), so those two are not independent.\n\nI don't see this. You could as easily delete get_arity in a separate PR, which could be merged before or after any PR in which the other functions are moved, and all the individual changes would still make sense. That seems like independence par excellence.\nThe only reason that I deleted get_arity here, in the same PR as I was moving those functions, is that I noticed get_arity was never actually used while I was moving the functions.. > deleting hy.inspect necessarily deletes get_arity\nOn the contrary, you could keep the function while getting rid of its original file, as I did originally.\n\nWhether or not the changes can be made independently is not relevant, since, for that matter, every character change could justify its own commit on such \"independence\".\n\nI don't see that, either. Suppose you spun off the first change of a single character in this PR into its own commit, making it the new first commit of the PR. I'd ask you to squash it into the following commit, because on its own, the one-character change would make no sense. The change only makes sense as part of the larger change in the commit it was split off from.\n\nI don't see how its irrelevance is a reason for an unnecessary commit.\n\nCommits exist to group related changes together. If two changes are irrelevant to each other, then in general, they should be in different commits.\n\nAlso, decoupling get_arity's removal from the rest of the changes serves no apparent functional purpose. \n\nThe purpose is not function but the legibility of history. Many sequences of commits can lead to the same final code, and are hence functionally identical, but some are more intelligible than others.\n\nIf the purpose of the separate commit is simply logging, and nothing particularly functional, then it's best to mention the removal explicitly in the commit message.\n\nIt's better to indicate a sequence of changes in the code itself, with a sequence of commits, than in prose, with the commit message.. Maybe in some cases? I guess it depends on the actual situation. If an entire file is dead code, for example, then I could certainly imagine it making sense to delete the whole file in one commit. #1189 is an example I did.. Similarly, in this case, if we were just deleting hy.inspect instead of moving some of its code, it would presumably make sense to delete all three functions in the same commit.. I guess the core problem is that Git doesn't have a notion of moving code. It can only track additions and deletions. So when you move code, make sure that in the commit where moving happens, only moving happens. When you want to make less superficial changes to that moved code (which is common, because you probably moved it because you're making related changes), do it in another commit, whether before or after the move.. Woohoo!. Whoops, I forgot to merge this.. @paultag. It's three additional lines in the compiler. Four if you count the comment explaining what it is. I'm sure we'll manage.. Okay, I'll redo it as a macro.. I wouldn't say it's experimental (it's a very simple macro), and the inclusion criteria for contrib and extra have nothing to do with Common Lisp or Clojure.. We never decided on any. In practice, it contains macros that are short and are of general use, and we should probably stick to that.. @gilch To be clear, are you vetoing this as-is?. It's clear that lots of time and people and thinking went into previous languages, but none of those things imply that the results are any good. People's decisions are subject to inertia and groupthink, and there's no group so large that anything important is guaranteed to be thought of by somebody in the group. How things have been done previously is not any indiciation as to what should be done.\n\nAre we sure we want a macro rather than a tag?\n\nThe distinction doesn't seem important. I could switch it to a tag macro if you'd prefer that.\n\nHow do we work around it?\n\nWith mangling, as you just realized and as already tested. It's clumsy, but it's hard to see how the clumsiness will matter considering the sheer weirdness of beginning a function parameter's name with a caret, and the coincidence of wanting to use pun in the same call.\n\nMaybe (pun spam :^foo :^bar :XhatXq q) oh, but you've vetoed those mangle improvements #1651\n\nTo be clear, I'm not against mangling nicknames for ASCII characters, just the absence of a clear marker of whether a name has been mangled (which is currently the hyx_ prefix).\n\nI don't know how well this would work in practice. And, emphatically, neither do you.\n\nI'd anticipated this problem you thought of, but if you can think of any other potential problems with the macro, by all means mention them and I can fix them and add tests. It's appropriate to hold up a PR for known problems, but not for problems they might have but we haven't even thought of yet.. @gilch Have you thought of any potential problems?. @gilch So what's the word? Do you want it as a tag macro instead?. It looks like a PrematureEndOfInput exception will display the whole file, or at least, a lot of it. Also, what's the arrow pointing at?\n$ perl -E 'say foreach \"a\"..\"z\"; say \"(\"' >/tmp/test.hy && hy /tmp/test.hy\nTraceback (most recent call last):\n  File \"/home/hippo/Desktop/hyenv/bin/hy\", line 12, in <module>\n    sys.exit(hy_main())\n  File \"/home/hippo/Desktop/hyenv/hy/hy/cmdline.py\", line 368, in hy_main\n    sys.exit(cmdline_handler(\"hy\", sys.argv))\n  File \"/home/hippo/Desktop/hyenv/hy/hy/cmdline.py\", line 354, in cmdline_handler\n    runhy.run_path(filename, run_name='__main__')\n  File \"/usr/local/lib/python3.7/runpy.py\", line 261, in run_path\n    code, fname = _get_code_from_file(run_name, path_name)\n  File \"/home/hippo/Desktop/hyenv/hy/hy/importer.py\", line 221, in _get_code_from_file\n    code = _hy_code_from_file(fname, loader_type=HyLoader)\n  File \"/home/hippo/Desktop/hyenv/hy/hy/importer.py\", line 200, in _hy_code_from_file\n    code = loader.get_code(modname)\n  File \"<frozen importlib._bootstrap_external>\", line 860, in get_code\n  File \"/home/hippo/Desktop/hyenv/hy/hy/importer.py\", line 246, in _hy_source_to_code\n    hy_tree = hy_parse(source, filename=path)\n  File \"/home/hippo/Desktop/hyenv/hy/hy/importer.py\", line 76, in hy_parse\n    reraise(type(e), e.args, None)\n  File \"/home/hippo/Desktop/hyenv/hy/hy/_compat.py\", line 5, in reraise\n    try:\n  File \"/tmp/test.hy\", line 1\n    a\nb\nc\n[ and so on ]\ny\nz\n(\n\n    ^\nhy.lex.exceptions.PrematureEndOfInput: Premature end of input\n\n. Would you please:\n\nTry to split the big commits into smaller logical units.\nSeparate out refactoring and other code changes unrelated to the purpose of a commit (e.g., adding object to the base classes of HyREPL) into other commits.\nGenerally speaking, don't make a commit that undoes or alters changes that were introduced by a previous commit in the same PR. Instead, change the previous commit itself.\nAvoid intermediate variables that are used only once (e.g., instead of x = a + b; z = x + y, write z = a + b + y).\nRemove comments with XXX, TODO, FIXME, or questions, or any other comments that do something other than describe the current state and usage of the code. If you wish, make issues out of these removed comments or post them to this PR.\n\nLet me know when the PR is ready for review.. It's okay. There will at least be fewer added lines once you introduce a helper for HyTypeError's new parameters.. You mean like this?\nraise HySyntaxError.from_expression(\n    \"Pythons < 3.5 allow only one \"\n    \"`unpack-mapping` per call\",\n    expr, self.filename, self.source)\n\nWhy not something like this?\nraise self.error(\n    \"Pythons < 3.5 allow only one \"\n    \"`unpack-mapping` per call\",\n    expr)\n\nThen you don't have to pass in self.filename and self.source every time.\n. Much nicer.. Sorry, I didn't know this was ready. I'll look at it soon.. New conflicts, woo.. Regarding my earlier point:\n\nGenerally speaking, don't make a commit that undoes or alters changes that were introduced by a previous commit in the same PR. Instead, change the previous commit itself.\n\nIt looks like your first commit (\"Retain compiled source and file information for exceptions\") introduces many changes like:\nraise HyTypeError(\"Keyword argument {kw} needs \"\n                  \"a value.\".format(kw=expr),\n                  self.filename, expr, self.source)\n\nwhich, in a later commit, are then changed to use self._syntax_error, like:\nraise self._syntax_error(\n    \"Keyword argument {kw} needs \"\n    \"a value.\".format(kw=expr),\n    expr)\n\nCan you rebase to use self._syntax_error the first time? This should eliminate lots of lines of diff.. Why's this one a HyTypeError instead of a HySyntaxError? I'm not sure I understand the difference.\npython\nif level == 0 and op in (\"unquote\", \"unquote-splice\"):\n     if len(form) != 2:\n         raise HyTypeError(\"`%s' needs 1 argument, got %s\" % op, len(form) - 1,\n                           self.filename, form, self.source)\n     return set(), form[1], op == \"unquote-splice\". ```python\n_source = re.sub(r'\\A#!.*', '', source)\nOffset for removed shebang (if removed).\nlineno_offset = 1 if _source != source else 0\n```\nThe re.sub will only blank the first line, not remove its trailing newline, so shouldn't lineno_offset stay at 0 in any case? . It looks like there are still some unrelated indentation changes buried in your commits, such as\ndiff\n     if s.startswith('hyx_'):\n         s = re.sub('{0}(U)?([_a-z0-9H]+?){0}'.format(mangle_delim),\n-            lambda mo:\n-               chr(int(mo.group(2), base=16))\n-               if mo.group(1)\n-               else unicodedata.lookup(\n-                   mo.group(2).replace('_', ' ').replace('H', '-').upper()),\n-            s[len('hyx_'):])\n+                   lambda mo:\n+                   chr(int(mo.group(2), base=16))\n+                   if mo.group(1)\n+                   else unicodedata.lookup(\n+                           mo.group(2).replace('_', ' ').replace('H', '-').upper()),\n+                   s[len('hyx_'):])\n     if s.startswith('is_'):\n         s = s[len(\"is_\"):] + \"?\"\n     s = s.replace('_', '-')\nProbably this is the fallout of an overly aggressive auto-indenting tool. You've worked plenty hard on this PR already, so I can go back and undo these myself, but in the future, remember to revert these or put them in their own commits (with --patch or so) before you git commit. (This particular example would be a bad idea to keep since it's no longer clear where the body of the lambda ends.). Kind of a shame that we have to add a state parameter to every single parser when we rarely need it, but I guess that's an rply limitation.. So, do you want to rebase out the introduction of lineno_offset and its management, since (if I understand correctly) it should always be 0?. Okay, I think the first commit's done. I spun out the introduction of _syntax_error into its own commit, reverted the argument flip of macro-error, reverted some unrelated indentation changes, reverted an introduction of a local variable that was made obsolete by a later commit, etc. I'll look at the next commit tomorrow.. I'm working through the second commit and thinking that the new tests may be too brittle. You're testing for the exact text of error messages, which means that if we reword an error message, the test breaks. Is that really what you intend to do, or do you just want to test that the new filtering mechanism succesfully removes internal Hy bits from the stack trace? Some of the tests don't even seem to be using the new filtering mechanism.. The whole point is that nothing interesting is happening in the new commit. By making the split, the gigantic commit in which several meaningful things are happening is made less gigantic, by removing a large number of repetitive changes.. Do you see why I want to avoid situations in which a commit that does meaningful things also makes a lot of changes of whitespace, variable names, or something like that? I want to divide the signal from the noise.. Sure, but they're cosmetic in the sense that, before _syntax_error does something other than raise HyTypeError with exactly the same arguments, its introduction has no effect. The change in logic can be easily separated from the change in calling convention. So I separated them.\n\nYou'll have to be more specific about which tests you're talking about, because some are specifically for the exception messages.\n\nConsider for example:\ndiff\n     \"Ensure tokenizing \\\"' \\\" throws a LexException that can be stringified\"\n     # https://github.com/hylang/hy/issues/1252\n-    with lexe() as e: tokenize(\"' \")\n-    assert \"Could not identify the next token\" in str(e.value)\n+    with lexe() as execinfo:\n+        tokenize(\"' \")\n+\n+    expected = ['  File \"<string>\", line -1\\n',\n+                \"    '\\n\",\n+                '    ^\\n',\n+                'LexException: Could not identify the next token.\\n']\n+    output = traceback.format_exception_only(execinfo.type, execinfo.value)\n+\n+    assert output[:-1:1] == expected[:-1:1]\n+    # Python 2.7 doesn't give the full exception name, so we compensate.\n+    assert output[-1].endswith(expected[-1]) \nWhat's your goal for this test change? (Intuitively, I think your change is right, or at least mostly right, but I've lost track of what's going on.). Okay, that makes sense.\n\nHow exactly is this confusing?\n\nThat I am confused by something in no way implies that it's confusing. ;). Okay, review of the next commit's done; the edits are:\n\nFactored out some copied-and-pasted code into a function\n__tb_hidden_modules \u2192 _tb_hidden_modules (you don't need Python's mangling here, right?)\nRemoved trailing :1 in slices. The commit message for \"Make colored output configurable\" mentions HY_FILTER_INTERNAL_ERRORS where I think you meant HY_COLORED_ERRORS (right?).\n\nIt seems that HY_FILTER_INTERNAL_ERRORS only has an effect when set to the empty string. I think it's counterintuitive that a binary environment variable would distinguish between an empty string and absence. How about inverting the variable and calling it HY_SHOW_INTERNAL_ERRORS or something?\nAt least at the tip of the PR, there's a regression such that a return value of None is no longer silenced at the REPL.. I'm sorry, Brandon, I've only just noticed that you updated this. It seems that GitHub doesn't send a notification for force-pushes. I'll continue review soon.. > Is it by design that it doesn't display None?\nYeah, the non-display of None has to be implemented separately, since None doesn't str or repr to the empty string (and then there's the matter of the newline). I think it helps keep the output neater.. So do that, if you don't mind, and then I'll look again.. Thanks. I just reviewed more of these commits and made more changes and I'm getting a \"Permission denied\" error when I try to push. Do you have the option to accept changes from reviewers switched off?. Can you turn it back on? Otherwise, I don't think there's a way for me to cleanly rewrite history. You can make a copy first with git branch clean-up-exceptions--backup or so.. I could save up all my edits till I'm done reviewing the entire PR, but I thought you'd rather get them as I make them, rather than get a giant stack of them all at once after a long time.\nI've pushed my current version of clean-up-exceptions to my own fork. If you'd prefer to wait till I've finished reviewing the whole PR (which hopefully won't be that much longer), I can let you know when I'm done.. So far, at any rate, I've reviewed up to and including \"Improve correspondence with Python errors and console behavior\", and made the following notable changes:\n\nReplaced usages of  future_builtins.filter with generator expressions (and removed the import of future_builtins.map since it seemed to have no effect).\nMoved the introduction of _initialize_env_var back to the first commit where it's useful, and moved it from compat.py (since it doesn't have anything to do with portability) to __init__.py.\nShortened the implementation of test_bin_hy_macro_require.\n\nRemoved the following comment:\ndef can_eval(expr):\n     # XXX: filename and source are needed to avoid ridiculous pytest\n     # issues.\n     return hy_eval(hy_parse(expr))\n. Okay, all done. Sorry for the long delay. I had a busy week and I expected there'd be a lot more work to do here, but I made only minor changes to the last two commits.. If all looks good to you, replace your version of the branch with mine and we should be good to merge (pending the final Travis check).. Okay, I'll do it this afternoon. There will probably be some merge conflicts, but if those can be smoothed out without major issues and Travis has no surprises in store, I'll merge.. Because we're currently running Travis for PRs only, rather than both PRs and pushes, the badge probably won't work in any case. If so, we should just remove it.. I suspect so. But it might also be referring to the last commit that was tested before being pushed (currently https://travis-ci.org/hylang/hy/builds/435140822), which is a reasonable backup. I'm not sure how to tell.. The reason I turned off push builds originally was because of a longstanding Travis bug where if you accidentally push a PR branch to origin instead of your own fork, then it gets another redundant build, and if you remove the branch, the new build line sticks around in a permanent failure state. But branches: {only: master} could fix that. It's worth trying.. One thing to keep in mind is that in at least one way, we're currently taking advantage of this: hy.core.shadow works by defining functions with the same names as special operators, so wherever you can't use a special form (e.g., in (reduce + foo), the symbol + can't be a special operator), the shadow function gets used instead.\n\n\nIt wouldn't be too unreasonable to forbid users from giving a macro the same name as a special operator. That could be part of a solution, perhaps.. Pretty mysterious, but it sounds like your Python might be misconfigured somehow. I know that Mac OS X has a default Python that can sometimes compete with user-installed Pythons. Which version of the OS are you running? Can you (or anybody else) replicate this issue on another system?. I don't know; you'd probably have to look into the innards of setuptools or fastentrypoints.. Did this issue lead to a user-visible bug in mangle or something? If so, could you add a test?. Unfortunately, it looks like there's another bug: \\n shouldn't be mangling to XUnX. Indeed, (unmangle (mangle \"\\n\")) crashes. I think you'd better either (a) fix that bug, too,  or (b) write a test for your original fix that's independent of that bug.. Looks good. Update NEWS, squash everything to one commit, and we're good to go.. I think that's fine. Two of those functions are one-liners and the third isn't that big.. I like the way you're thinking. I've been bitten by this before. It ought to be possible to access pure-Python parts of the hy namespace without invoking the compiler.\nThere are currently four imports from hy.core.language in __init__.py:\n\nmangle\nunmangle\nread_str\nread\n\nThe first two can just be imported from where they're actually defined, hy.lex, instead of hy.core.language. The latter two could be written in Python instead of Hy.. That's a decent idea. I usually run the tests with --ignore tests/test_bin.py anyway because they're so much slower than everything else.. > In other words, would we like to have a lightweight compiler that exclusively translates Hy AST to Python AST and implicitly relies on the current state of its target module for macro and function dependencies? \nMaybe. I see your argument, but it's hard to guess how things would shake out in practice.. Probably.. In the commit message, can you specify which functions go where?. I'm afraid this isn't rebasing cleanly after merging #1699. Could you take a look?. Nice. One more thing: the documentation of eval in core.rst. I know, it's a problem that we have both docstrings and the redundant documentation in those files.. Replace \"fifth\" with \"fourth\" and I'll merge.\nYep.. This feature was removed by #1590.. Oh right, I missed that part of this issue. Sorry. Default arguments work the same as before except that the compiler is stricter and you can no longer use parentheses where square brackets are expected (#1582), so that has to be written as (defn herp [&optional [a 1]] \"derp\").. I don't think we can do that, because Python AST can't.. How to best space code is subjective and depends on things like what you want to bring the reader's attention to. Rigid rules that are automatically applied defeat the purpose.. Related: #972.. What's FHS?. Okay. And you've checked that, with this change, Hy installs okay on Homebrew, right?. I guess not. Somebody who uses Homebrew, verify that this works and I'll reopen.. A direct translation into Hy of the first example here works fine for me on Python 3.7 and Hy master. Are you sure your code is right? Are you using Hy master?\n(import [multiprocessing [Pool]])\n\n(defn f [x]\n  (* x x))\n\n(when (= __name__ \"__main__\")\n  (with [p (Pool 5)]\n    (print (p.map f [1 2 3]))))\n\n. > What is Hy master? Is it different from the one I installed with pip install hy?\nYes, it's what you get by clicking the big green \"Clone or download\" button here. Install that and try again.. > Well, I tried the master version, it would not load any .hy codes, after tinkering for couple of hours I decided to stay on stable release.\nWe only fix bugs on master, so if you go back, you're on your own.\nWhat error message did you get from python -mhy? Or, if that doesn't raise an error, hy -c 1?\n\nWhat would be the reason multiprocessing support would be on the master version but not available on the stable version?\n\nI doubt that any of the errors you've seen have to do with multiprocessing.. I'm closing this due to lack of response, but we can reopen if you look into it.. Why add the &optionals by force? The programmer can add it if they want it.. How about improving the error messages?. > There are none, so we're actually talking about adding some.\nThere are no custom error messages for defmain, but if you define (defmain [x y] \u2026) and call the program without arguments, you get TypeError: <lambda>() missing 1 required positional argument: 'y', which is an example of the cryptic error messages you were referring to, right?\nRegarding your second paragraph, yeah, it's surprising that the first argument is the executable name, and indeed that's part of why it's surprising that (defmain [] \u2026) doesn't work. The documentation should be clearer about this, and perhaps we should change it.. I would bind the &rest to a gensym, or else you'll override the shadow subtraction operator.\nI would use pytest.raises for the tests instead of try. Or does that not work with SystemExit?. I made the case against HyCons in #1576. The warts I mentioned could be removed in a fresh implementation, but it's still not clear to me if there are any circumstances where cons cells are more convenient than all the other data structures Python already has. The justifying example can be just as easily accomplished with ~@.. > your statements\u2014and parts of #1576\u2014are actually asking about the meaning and/or purpose of cons, car and cdr. Explanations/answers for those are largely context dependent and already well covered elsewhere\nIt's clear to me what cons cells and the cons, car, and cdr functions are good for in Emacs Lisp and Common Lisp. It's not clear to me what they would be good for in Hy.\n\nFor example\n\nCan you provide an example that's concrete? You say that \"recommendations to use ~@, +, extend, #*, etc., completely miss the point\", but the one concrete example I've seen has a one-to-one reimplentation with ~@.. > Emacs and Common Lisp both have list construction and manipulations functions nearly equivalent to Python's/Hy's, so what exactly are they \"good for\" in those languages?\nProbably the clearest example is that in those Lisps, expressions are made up of cons cells. So, you need to deal with cons cells in order to do much metaprogramming at all. In Hy, by contrast, expressions are implemented as Python lists.\n\nMore importantly, by what measure are you judging Lisp conventions to be \"good for Hy\"?\n\nWhat I mean by a feature being \"good for something\" is just that there's some circumstance or problem where it would be helpful. Having a practical purpose of some sort, in other words.\n\n\nCan you provide an example that's concrete? ...\n\nadderall and hydiomatic are excellent concrete examples\n\nThose are entire libraries. Can't you be more specific?\n\nplease, do not be so unproductively dismissive.\n\nDude, I'm just asking for a concrete example. What's your problem?\n\nWhat example are you referring to?\nIf it's the one in #1576 recommending that (~?fn ~?name ~?params . ~?body) be replaced with (~fn ~?name ~?params ~@?body), then there's definitely no one-to-one reimplementation.\n\nYes, that's the one. Am I wrong in thinking that `(~a ~b . ~c) is equivalent to `(~a ~b ~@c)? If so, what exactly does `(~a ~b . ~c) return? What is a \"partially constructed sequence\" in terms of Python objects?. At least in Hy 736426fc, right before #1580,  `(~a ~b . ~c) differs from `(~a ~b ~@c) in terms of boxing: given (setv a 1 b 2 c [3]), it returns [HyInteger(1), HyInteger(2), 3] instead of HyExpression([1, 2, 3]). I'm not sure if that's the behavior you would want, or indeed why one would want it.. > you've been implying that this cons stuff isn't necessary or necessarily advantageous, but now you're implying that they sometimes are\u2014even in the presence of Python-equivalent list construction and manipulation functions?\nI don't mean to imply that Emacs Lisp or Common Lisp would be worse off using their other data structures for their expression type. Maybe they'd be fine. But currently, they use cons cells.\n\nAnd what exactly is the \"metaprogramming\" you're referring to? Is it something that can just as easily be done using Python lists?\n\nYes, since in Hy, expressions are Python lists.\n\nFurthermore, it's not apparent to me that all, more, or even some current hy.contrib offerings surpass the demands for justification and relevance leveled against these cons elements.\n\nThat's fair. I weeded it once (#1189) and more weeding could conceivably happen. Certainly, any module that has no practical purpose whatsoever has no place in our repo. (Lookin' at you, botsbuiltbots.) I'm too much of a Perl programmer at heart to set more than a slight bar to new features.\n\nSure, start by trying to rewrite this function without some form of cons pairs and car, cdr abstractions.\n\nAll right, thanks. What exactly is the function intended to do? (unify ['a 'b 'c] ['a (LVar 'b) (LVar 'c)] (tuple)) is given as an example call, but what should that return? I presume that LVar is a generic encapsulating operator.\n\nThat approach also seems much more in-line with the deprecation process of most other mature software projects.\n\nWe're still 0.x, so we don't deprecate stuff, we just burn it.. In other words, we are not a mature software project. Yet.. We're still unstable and still have many major bugs. That's why I say we're not mature; it has nothing to do with respecting efforts or fairness or standards or transparency. So long as we're still unstable and have many major bugs, I think that worrying about backwards compatibility is premature. I'm sorry this is something you wanted that we haven't done, but this is an all-volunteer project, so things only happen when someone is personally interested in doing them, especially unglamorous things like maintaining backwards compatibility.\nCertainly I've never intended the version numbers of the Hy releases I've done to serve any communities. I've never served a community in my life, and I don't intend to start now! :). I'm closing this for lack of response, but let me know if you want to pick it up again and I'll reopen it.. I haven't used that program, and Hy includes no special support for it, but you can certainly try and post whatever issues arise.. I think C4 and the blog post in question are advocating different practices. C4 says \"A patch MUST compile cleanly and pass project self-tests on at least the principal target platform\" whereas Hintjens's post says \"I recommend to merge quickly, without waiting for Continuous Integration testing to finish\". So which is being recommended here, automatic unconditional merges, or quick merges of C4's idea of a \"correct patch\"?. I see. So while PRs are expected to pass the existing tests, they're otherwise supposed to be merged, and problems should be fixed (including, presumably, reverting the whole patch) through a new PR instead of editing the old one in place. I can see the logic to that, but what do we do in the case of Wikipedia-style edit wars where person 1 submits a PR, person 2 undoes that PR, person 1 undoes the undoing, and so on?. My concern isn't trolls who are pushing outright terrible commits. We haven't had that problem (yet?). My concern is legitimate disagreements, where I for one wouldn't be comfortable with banning either participant, especially given that, in a project this small, every contributor is precious.\nThe Wikipedia policy is that in a situation of clear good-faith disagreement, the page should be left as-is until a consensus is reached. That, I think, would make sense. Maybe the end result of such a policy would be little different from the status quo, but it's worth a shot, at least.\nIt's interesting to note the rule \"Maintainers SHOULD NOT merge their own patches except in exceptional cases, such as non-responsiveness from other Maintainers for an extended period (more than 1-2 days).\" Hy is much slower than ZeroMQ. Non-responsiveness from maintainers (other than the author of the PR) is the norm for much longer than 2 days. Half the reason I pushed for #1508 was that I was making PRs that got no response of any sort for months. Now that we have the two-week rule, uncontroversial PRs can at least be merged after two weeks.. Does anybody know if this ever worked with a previous version of Hy? I'm inclined to say that the HTML output is all we really need.. Closing per https://github.com/hylang/hy/pull/1718#issuecomment-451056964.. It's interesting that HTML output works anyway. I wonder if that's a Docutils bug.. @alphapapa If you'd like to use Brandon's patch instead of yours, you can make a commit out of it (with him set to the author) and force-push it to this branch.. Whichever way you like, because I have no idea how long it will take for a new Sphinx release with this change.. I like it, except that it should be written as a function (since it need not be a macro), and it should also provide ways to pass arguments to the ArgumentParser constructor and to parse_args. . > Since this doesn't quite seem possible in practice currently, does anyone have advice for mixing Hy in to an existing Python team? Assuming that co-workers want to continue to use Python syntax and I want to use Hy syntax, what is the best way at this point in time to facilitate it?\n\nI was thinking that I could \"own\" any modules I write in Hy, be responsible for any feature or modification requests to them and if at some point in time others take a keen enough interest in it, do a one-way translation to Python and let them \"takeover\". Would that work?\n\nShort of getting your co-workers interested in Hy themselves, that's probably the way to do it, yeah. The code produced by hy2py isn't always the prettiest, but it's an excellent starting point for a Python translation of a Hy program, if nothing else. And it should be 100% semantically equivalent to the Python original, as of Hy 0.15.. Recapitulating the fine details of Python's argument handling is not a good idea\u2014we should link to the relevant parts of the Python language reference instead\u2014but there are definitely some outright errors and omissions in the current descriptions, such as the implication that &optional affects a single parameter.. That's not a bad idea. I think the status quo is just because that's how Lisps have traditionally specified optional parameters.. More generally, these forms look like:\n(for [clause1 clause2\u2026] body)\n(lfor clause1 clause2\u2026 result)\n(dfor clause1 clause2\u2026 [key val])\n(gfor clause1 clause2\u2026 result)\n\nAre you asking for every iteration clause to get a pair of square brackets, or for the whole set of iteration clauses to get square brackets even when it's not necessary (e.g., for forms other than for itself)? In other words, do you want\n(for [x xs  y ys] foo)\n(lfor [x xs  y ys] foo)\n\nor\n(for [[x xs]  [y ys]] foo)\n(lfor [x xs]  [y ys] foo)\n\n? Neither really seems like an improvement to me.. (It's okay. Everybody's new to Hy except for the small handful who stick around.)\nI don't think we can have for without the mandatory brackets because then you couldn't tell body forms from iteration clauses; that is, (for a b c d e) could be interpreted as (for [a b  c d] e) or as (for [a b] c d e). You could remove the ability to include an arbitrary number of body forms, so (for [a b] c d e) would have to be written (for a b (do c d e)), but I'm not a big fan of that. for loops tend to have only a few iteration clauses and a lot of body forms, so setting off the iteration clauses, rather than the body forms, makes sense to me.. Generally, lfor is used to produce a list rather than for side-effects; if side-effects were the point, you'd use for. So, why would you want more body forms in lfor?. But that's what :setv is for. Have you read the documentation for these forms?. But that's what :do is for.. > Personally I would prefer a natural way of writing these things, i.e just being able to use the standard(setv ... ) form, instead of using a specialized DSL with :setv , :do etc. clauses that don't exist elsewhere in the language.\nThat was my original plan; the default clause type would be to just evaluate the given form, like :do clauses, and you'd mark iteration clauses with :for instead of not having to mark them, as is currently the case. @gilch was against this, primarily on the argument that one uses iteration clauses a lot more than do-clauses. I relented once we hit on a syntax for for that doesn't require a bunch of :dos but still lets you use the other clause types.. Sounds like a good idea to me. We were following Clojure here, but Common Lisp's interpretation makes more sense to me.. Actually, if we do that, perhaps we should use Common Lisp's names, incf and decf, so as not to trip up Clojure programmers.. > there's no equivalent concept in Hy of a \"generalized place variable\"\nBut there is; it's the same concept of lvalue that Python uses. Just as you can put a variety of things to the left of = in Python other than plain variables, you can do the same in Hy with setv.. > I'm betting that setv was only called what it was because Python has the built-in set function (@Kodiologist confirm?)\nIt looks like it (73695881a9b69bab9d10a356258e78cf0ec6afa3).\nYeah, it's not clear how #! would detect the lvalue in general.. I think you mean (in :c foo), or more verbosely, (foo.__contains__ #* [:c]). It's not clear to me what #* in a (. \u2026) form would do, if it were allowed. But, admittedly, there should be a proper error message.. None of Python's standard operators that we use unchanged are documented (yet?).. Actually, this should stay open because there isn't a proper error message.. Oh, that seems fine, actually. I should've checked on master first. Thanks, Brandon.. I don't think that belongs in Hy's own documentation, so this isn't an issue for the hylang/hy repo.. Perhaps. It would probably be better to use instance? than (is (type \u2026) \u2026), and to allow a default case.. How would you expect this to work, if it did work? Imagine a less trivial case, like (defmacro m [a b c] (+ a b c)) (m #* l).. That's even weirder than I expected, but to be clear, I was using a lowercase letter L there. (Consider switching monospace fonts.) In other words, what would (m #* l) do?. I presume you meant that (m #* l) would be an error, then, since the macro call would be missing two required arguments. In any case, it sounds like you want the unpacking forms passed in as single arguments, not for any actual unpacking to occur at macro-expansion time. But this is exactly what already happens. (id #** {}) expands to #** {}, which is illegal at the top level, as the error message indicates. Look at (macroexpand '(id #** {})).. Hmm, that's a good point. By contrast, (defmacro foop [x] `(print ~x)) (foop #** {}) does what you probably expected. I think it has to do with how support for #** is implemented (and, before Python 3.5, #*). In order for (print #** x) to work, the compiler checks the arguments for unpacking forms while compiling the print form (in _compile_collect). By the time id has expanded, it's too late for _compile_collect to see the unpacking form. I don't think there's a way around this short of changing Hy's macro-expansion semantics to be inner-first instead of outer-first.. Either that, or some kind of multi-pass compilation.. You mean, to have the compiler expand all macros before compiling special forms? Perhaps, although you'd need to make an exception for special forms that are needed to collect macros.. > Related, am I correct in saying that Hy does \"no\" evaluation? Hy expressions are compiled to the Python AST which is then evaluated?\nMostly, yeah, but eval-when-compile and eval-and-compile are important exceptions, and they're used to implement macros.\n. Maybe changing this is as simple as making sure the loop in _compile_collect tries to compile each expression before checking whether it's an unpacking form (is_unpack(\"mapping\", expr)). But an adjustment to compile_expression might be necessary, too, to allow the unpacking form.. The addition for unpack-iterable and unpack-mapping makes sense.\nI don't think your addition regarding &optional really helps with #1722. The text before your addition (\"Parameter is optional. The parameter can be given\u2026\") still makes it sound like &optional affects only one parameter. Instead of adding an explanation that you don't need a separate &optional for each optional parameter, we should rewrite the documentation for the ampersand symbols to be clearer and more correct, and refer to the Python language reference for details. Also, an example that uses all the ampersand symbols in one function would probably be helpful, and that example should probably include two &optional parameters, one with a default value and one without.\nI don't think the addition for constantly is very helpful because this item is listed under \"Core Functions\" and the description doesn't imply delayed or repeated evaluation.. Yeah, I don't see that being a common mistake. That said, constantly does seem like it would be more useful as a macro, so you could change the implementation if you wanted to.. New, because if you add nontrivial code changes to this PR, it can't take advantage of the policy that lets documentation changes get merged quickly.. The core functions are all functions, whereas api.rst lists special forms and macros (which should probably be separated).. Looks good. Squash this PR into two commits, one for the ampersand parameters and one for the unpacking operators, and I'll merge.. Squashing is just one of several ways to rewrite history. When you can get the rewritten history that you want with any of several options (rebase -i, filter-branch, manually recommitting, etc.), just use whichever option you find most convenient. At any rate, you did a fine job here.. Why didn't I merge this? Well, better late than never.. This seems fine to me. Don't forget to add tests. But, the approval of an additional core developer would be necessary to override gilch's veto, if that's the way you want to go.. It's a weird situation. I think that what happened is that this backport was originally made upstream, and then was reverted when folks realized it created problems, but Debian or Ubuntu used a commit before the revert for its package.. Did you forget to paste your issue description into the body?. Good catch. I'd say it's probably best not to get into mangling here, so we can just write \"(e.g. dashes turn to underscores)\".. So, do you want to change it per my comment?. I can just rebase it for you if you agree to the change.. All done, thanks.. I'd agree that the question mark is not necessary.. I see; I wasn't aware that returning a truthy value, as opposed to a real bool, was considered to disqualify a function as a predicate. When possible, I think it's better for a testing function to return a meaningful value than to return a bool , because doing so allows for cute tricks like (setv output (or saved-result (computation))). So every?, or rather every, should probably return the last true or the first false output of the predicate argument, anyway. In other words, every should be (reduce and (map pred coll) True) instead of (all (map pred coll)).. Did you forget to add a description of your issue?. It sounds like you're under the impression that we don't have a website, and intended this issue to be a request for one. We do have one. It's http://hylang.org .. Okay, a hard-selling website is a valid feature request. I'm not personally interested in it (I think the kind of rhetoric currently shown on http://www.rust-lang.org is asinine, and encourages the naive chauvinism that some Rust programmers espouse), but perhaps other people feel differently.. Fair enough. I guess the chief features distinguishing Hy from Python are:\n\nFree-form, homoiconic syntax\nMacros and arbitrary compile-time computation\nErasure of the distinction between statements and expressions (mostly). Implementation-wise, the chief goal here is to get feature parity with Python 3.6, but I think it may be easy to generate equivalent AST for earlier Pythons, effectively backporting f-strings to as far back as Python 2.7.. Okay, I'm now starting to work on this.. Psst, @brandonwillard, this would be a good first PR to review. You wouldn't have to merge it or prepare the new release for PyPI and GitHub; I'll take care of that in any case.. Noice.. Good point. :P I more or less write R for a living these days, but it is\u2026 not the best language.. Haskell is very cool, no doubt about that. Just here for the libraries, huh?. All righty, it's done. Welcome aboard!. Couldn't this be implemented as just (defn llist [&rest args] (list args))?\n\nMore to the point, I don't really see the motivation. Why would one use (llist a b c) instead of [a b c]?. No problem. Happy Hy-ing.. Sorry, which debug mode do you mean? Should HY_DEBUG print such messages?. I don't seem to get any messages about compilation from python3 -d -m hy.core.language.. I think you forgot a trailing backtick. Did you try rendering the file?. Looks good, but the backtick fix should be in the first commit, and the underline fix should be in its own commit (if you want it in this PR). Try\ngit reset HEAD~\ngit commit --amend --patch\ngit commit -a. If you wish, sure.. Okay, I'll clean up the commit structure and merge.. @digikar99 I'm getting \"Permission denied\" when I try to push. Don't forget to turn on editing of your PR branches. (And in the future, make a new branch for each PR rather requesting a pull from `master`).. Ah, I got it. I was pushing to the wrong branch name because my local tracking branch wasn't named `master`.. Fun. Do you have any experience with alternatives, like CircleCI?. I think that by \"array indexes\", you mean \"slices\". Relatedly, `get` should be mentioned before `cut`. Otherwise, it seems to be implied that `foo[3]` would be written `(cut foo 3)` in Hy, rather than `(get foo 3)`.. Okay, good, but I would avoid the word \"array\" because [it means something else in Python](https://docs.python.org/3/library/array.html). How about \"collection\" instead?. One step forward, one step back. I'd remove `assoc` or else show that it's equivalent to `(setv (get array 1) 42)`. Otherwise, the novice reader gets the impression that `get` is only a function and doesn't have the same flexibility as Python indices.\n\n. Cool, looks good.\nWriting documentation is hard; ideally, you want an encyclopedic knowledge of the part of the language you're documenting. Writing a tutorial is even more demanding because it needs to cover a lot of the language.. I  think that the use of __slots__ is basically a micro-optimization, anyway, so perhaps we should drop it.. Not a bug; see #1590.. A minimal example is:\n(defn factory [upper]\n  (eval '(fn [] upper)))\n\n((factory 9))\n\nwhich raises NameError: name 'upper' is not defined. I guess eval isn't looking as hard for applicable names as it ought to. Intuitively, (eval '(fn [] upper)) and (fn [] upper) should be equivalent.\nThis may be related to #1041, but unlike this case, I don't think the examples in #1041 ever worked.. I think #1757 is pointing out a bigger issue not addressed here, which is that (some kinds of) errors during macro expansion cause the REPL to quit.. > Would this be a good time to add explicit 3.7 tests?\nI don't think we're missing any tests, but we're not testing 3.7 on Travis for historical reasons that probably don't apply anymore. \n\nis there a reason we aren't using six for most of those compatibility functions and constants?\n\nI don't think there is. But at this point, it's probably not worth changing, because we can start removing Python 2 support after the next release of Hy.\n. @brandonwillard Do clarify, does your hooray emoji indicate you approve this PR?. I'd say we should probably just delete this list. It's redundant with the list kept by GitHub itself, so it's just another thing we can forget to update, as I did in your case.. That makes sense. Just link to the core team (https://github.com/orgs/hylang/teams/core/members) specifically.. @tianon That should be fixed now. I think it was marked as a \"secret\" team.. It seems that GitHub won't even let you see a list of teams without logging in. So now I see the value of coreteam.rst.\nBrandon, could you edit the whole list so that coreteam.rst matches https://github.com/orgs/hylang/teams/core/members (e.g., @gilch is also missing from coreteam.rst), preferably in the same order? Then I'll merge this.. Because I'm dumb and I left in a variable I used for debugging. :)\n. That's what I thought, but when I noticed that (zero? \"foo\") returns False instead of raising an exception, I remembered that Python has no notion of numeric equality that's separate from general-purpose equality. So zero? should accept pretty much anything.\n. Calling setup.py outside of its own directory seems not to have worked in the first place. (Notice how VERSIONFILE was defined.) Is this something we want to support?\n. Yes, the version file is generated when you run setup.py, so you need to rerun setup.py if you want to refresh it.\n. Wouldn't that re-create the possibility of somebody thinking (or leading us to think) that they're on 0.11.0 (or whatever) when they're not?\n. I'm not familiar with the process of deployment to PyPI, but I figured it involved running setup.py. Am I wrong?\n. Probably it depends on exactly what method we decide to use to put a package on PyPI. However, I think this ought to include a build step, as in this example, which uses setup.py itself to do the upload.\n. Done.\n. They use the same syntax but do pretty different things because import actually emits code and require just changes the state of the compiler. I think trying to unify the implementations wouldn't make the compiler code much nicer.\n. (1) Regarding repetition, I don't think there's enough of substance to factor out, because each branch is small but requires small differences; can you specify what kind of refactoring you'd like to see? (2) What should (require [x [* *]]) do? Import a macro named * twice? * is a terrible name for a macro.\n. So the difference between the two test macros is clearer, and both actually do something, so we can catch a bug in which the macro isn't being called and its argument is returned unaltered.\n. Embarassingly, I had no idea that from foo import bar as baz is legal Python, let alone supported in Hy. I'll add that form for require.\n. Yes, you're right.\n. Done.\n. Ryan, while I'm thankful that you're looking out for typos, I think that when it comes to minor changes like writing issues, it's better to provide a patch than to write comments. (You can also push directly to the author's branch if the author has enabled that, which is the default, I think.)\nAnd yes, GitHub is best written as \"GitHub\".. All right, but let it be known that I discourage naming a Hy program with the empty string.. But import_file_to_hst and import_buffer_to_hst are different functions.. But pretty_error_partial would have only one use, on the line starting hst = ..., so what's the point? You realize that _ast = ... uses another two functions, namely import_file_to_ast and import_buffer_to_ast, not import_file_to_hst and import_buffer_to_hst, right? Or maybe I'm just having a brain fart. I'd recommend just pushing the edit you want to make instead of trying to explain it to me.. There's no basestring in Python 3.. Cool, I didn't know you could do that.. @kirbyfan64 Any updates?. No, that returns true when a and b are both true.. Okay. It passes the tests, and I can always appreciate a round of golf.. Added below.. See the description of  6efe918.. I don't know. I can't get a version of Hy that old to run in order to try to reproduce the bug without let.. Done.. The version of nif you commented on here seems to work for me, both with this branch (let-it-be) and with master.. Great, thanks. I'll rebase and merge.. \"single element\" should be \"successive elements\".. n = 0 used to work, but tee raises an exception when it gets an argument of 0. That's why I added the check.\nI agree with you that n < 0 should just be an error, but come to think of it, shouldn't n = 0 return a list of empty tuples?. Yep, I meant an infinitely long iterator of empty tuples, as Clojure seems to do.. Sorry, I misread the error message. tee complains about negative n, not zero. So shall we have partition with n = 0 return infinitely many empty tuples, and raise an exception on negative n?. Done.. Yeah, I guess that makes sense. I've done that.. If you passed in an object that is neither exactly a list, nor a HyObject, the below conditional in the assignment to spoof_tree would do the wrong thing.. Also, this is an internal function. If it receives an argument that's of a type we didn't expect, that's a bug.. Although Python has no or=, |= seems to do the right thing with bools, so this can be written ret.contains_yield |= body.contains_yield. You don't have to do that if you think it's too wacky.. In the current implementation, (do ...) already doesn't appear. (Your example above no longer has do in its output.). Hmm, but the underline from a HyMacroExpansionError seems to be misaligned. I'll take a look at it.. Done.. Fixed.. The string is currently \"\\x1b[33m\\x1b[22mLexException: Could not identify the next token.\\n\\n\\x1b[39m\\x1b[22m\". If we check for equality against that, we're testing the use of ANSI escape codes, which doesn't seem right.. How would \"LexException: Could not identify the next token.\" in str(e) tell us whether str(e) contains a weird error message, in addition to the one we expect?. Okay.. Would it be better to check the magic number explicitly, the way I check the mtime?. This is the same as master. Let's not futz with it in this PR.. Evidently, everything still works, since hy.core is such a package. I'm not sure why, but I don't really know what module.__package__ does, anyway.. The code is supposed to function fine when bytecode is missing or can't be written. I've tested that in test_bin.py.. Either that or use Nose directly as I did here. Tox is kind of overkill on Travis because the whole point of it is to juggle multiple environments and versions of Python, which Travis already does.. @kirbyfan64 You still get notified when I reply to one of your review comments without @-mentioning you, right?. Okay, all should be good now.. Okay, changed.. But if you ran Sphinx from a different directory, the Makefile would break.. It's legal Python with indents of spaces in a multiple of 4. How would you indent it?. Good idea. I'll do it tomorrow.. Before this PR, did running sphinx-build manually from a different directory work? What's the exact command?. Done.. Done.. My thinking is that this behavior, albeit possibly surprising, will be useful for situations such as the programmer commenting out all the except clauses, or accumulating except clauses programatically. In general, it seems good for Hy to provide base cases of this kind that Python doesn't. I'm not sure about this one, though.. Fixed.. I don't feel strongly on this subject, so I'll remove this feature.. That would be a huge swarm of noqa comments, but besides, I don't think these style rules are useful. I've been bitten by the newline one, in particular, dozens of times in writing Hy patches, and in each case the organization of the code only became less clear when I added more space, because I was using the lack of space to visually group related constructs. Likewise I don't see the value in banning with ...: ... or if ...: ... or whatever. I agree that in most cases you want the newline after the colon, but sometimes you don't.. Done.. Evidently that was some kind of leftover I forgot about. Fixed.. Good point. I've restored them.. unicodedata can tell which characters are Pi, but not identify the matching end-quote characters, nor does it seem to have BidiBrackets.txt.. Throughout this function, I opted for checking type equality rather than subclasses or instances so that if somebody makes a subclass, it won't get hy-repred to look exactly like an instance of its parent class.. It has the potential to be used many other times throughout this file. Probably I'll apply it more broadly in a later PR. But I found myself already wanting it, so I saw no reason to wait.. It's not for performance reasons but to ensure a minimum of two arguments. The test for this is (forbid (f \"hello\")).. > In the case of zero keys it might make sense to just return the thing. But we'd have to make the special form do that too.\nRight. It wasn't clear to me that the 1-argument form would ever be useful, so I left that as-is.. Using a shadow function in the first place is only going to worsen performance, but okay. What exactly is your version?. Oh, I thought you meant some version using reduce. But why use the if?\n(defn get [coll key1 &rest keys]\n  (setv coll (get coll key1))\n  (for* [k keys]\n    (setv coll (get coll k)))\n  coll). I don't think this kind of micro-optimization is worth grubbying up the code. I'll use a leading `setv` instead of tuple addition, but I would only support adding an `if` for a performance rationale if I had good reason to believe that this function is going to be a CPU bottleneck in real code and the `if` makes a meaningful difference.. I'm familiar with this convention, but I've never seen the point of it.. Real talk. I sincerely appreciate how you've resumed work on Hy. You're working on a lot of cool PRs and you're often helpful. But, I don't think it's a good use of my time, or your time, to fuss over spacing and semicolons, and I don't think any hard-and-fast rules about code formatting should be enforced. Rules that are useful most of the time are occasionally going to be less than useful, as the `noqa`s sprinkled throughout the codebase and the weird thing I had to do with `if` in #1345 can attest. And some rules have no discernible value at all, like this one about one versus two semicolons. This is why, although I too use Emacs, I don't use auto-indent for any language.\n\nIt's not hard for me to add a semicolon here, and one versus two semicolons makes no difference to me. But I don't want to spend time editing every PR for style issues that are more about tradition and fussy editors than about human legibility.. Please include an example, and write out \"Extensible Data Notation\". I didn't know what \"EDN\" stands for, and I bet that most other readers won't, either.. An example of comment would be good, too.. Did you mean to say HyInteger here? There's a HyFloat test just a few lines down.. You don't need a separate line for the close parenthesis. It can go at the end of the preceding line.. Eh, no biggie.. Oh, right.. It's indented with two spaces, same as everything else.. I just realized that I can get rid of one of the assignments, because ret.force_expr works, so I did that.. Please stop.. If I make the editor indent automatically, then I have to wrestle with it when it's making a bad decision.\n\nLisp must be indented correctly to be legible. That particular rule is absolute.\n\nI think this code is legible (or at least, it was when I started). I know that's inherently subjective, but you and the other two Horsemen of Hy Maintenance have approved my PRs in the past, so I don't see what's changed. I'm not asking for new standards in reviewing PRs; I'm asking for what I'm used to.\nAnyway, if things like the number of semicolons for a comment, or whether the indent lines up with the immediate parent form instead of an ancestor form without other hanging children, are going to be a blocker for you from now on, then I guess you're not going to approve my PRs. It's a shame, since you're whip-smart and notice genuinely important things that others miss, but enforcing style rules for their own sake is counterproductive.\nI think the review process here is a good model. The author indented something in a nonstandard way (for Python and our codebase), I pointed it out, the author said \"I prefer it that way\", I said \"Eh, no biggie\" and @kirbyfan64 said \"it's not really a blocking issue\" and merged it.. Well spotted. How do you like this wording?. Oops, I must've been in a Christmassy mood (\"He's makin' a string, he's checkin' it twice\u2026\"). Fixed.. I was working around Flake8, but I forgot about triple quotes.. Yes, it is unrelated. I put that commit in because I noticed the bug while reading through the compiler. I figured that adding an xfail test wasn't worth its own PR.. Yeah, good idea.. Did you read the commit message?. :). Okay, changed and rebased.. What do these comments with the text \"odd\" mean?. Oh, interesting. That makes sense.. Why does this docstring end with a question mark? (To be fair, the docstrings of tests no longer have much effect since we switched from Nose to pytest. You can just not use one at all if you want.). It looks like there's an accidental whitespace change here.. The reason I used getattr(x, whatever, None) is not None instead of hasattr was that I didn't want this branch to trigger if an attribute existed but was None. We don't have anything written down saying when the attributes shouldn't exist and when they should exist but be None, so it seems safest to treat the two cases the same. That's my thinking, anyway.. This is a comma splice, if I'm reading it correctly. And what's this stuff about three conditions? There's no elif in Hy, anyway.. I think you've got a stray backtick and args here.. Stray comma.. @kirbyfan64 The problem with that design is that break skips its loop's else clause. As for the not-not, that's for the case in which cond produces a mutable value and its truth value changes. See the tests in this PR and the discussion in #1432.. @kirbyfan64 That doesn't seem to exist in Python 2.. @kirbyfan64 Not every class defines __nonzero__.. @kirbyfan64 Done.. (await) should be illegal, since await needs an expression in Python.. Maintaining contains_yield is not necessary here, since the method can only trigger in Python 3.. -> isn't necessary; this can be written (.run-until-complete (get-event-loop) (coro)).. These sorts of comments are not necessary. I think they exist because they were somehow desirable when we were using our previous Nose-based testing infrastructure.. Write @checkargs(1) instead of @checkargs(max=1) and simplify the method body accordingly. In Python, nullary yield is equivalent to yield None, so (yield) should work similarly. On the other hand, the fact that (yield-from) is allowed is apparently a bug; yield from None will never work (#1472).. That would be fine, I think.. None of the three types of comprehensions, nor generator expressions, leak their variables into the surrounding scope in Python 2 or Python 3, with one exception: list comprehensions in Python 2. This exception seems more like an artifact than a feature, so I didn't try to retain it.\n  . The output should probably be __builtins__.Ellipsis, since Ellipsis isn't a reserved word.. So why not use ast.Ellipsis, just like in Python 3?. Possibly Python 2 will only allow ast.Ellipsis inside a slice. In that case, you'll probably need to edit compile_cut_expression to peek at its arguments and make an ast.Ellipsis itself, whereas compile_symbol  will need to create __builtins__.Ellipsis or raise an error.. So we'll need to produce an ExtSlice under Python 2, right?\n\nIf it where up to me, I'd be seriously looking at dropping Python 2 support\n\nMe too, but it isn't.. This will trigger on the string \"slice\" instead of just the symbol.  You may also need to check that expr[1] is nonempty.. Shouldn't this be x[0] == \"__builtins__.\" + kind? You don't want to allow kind alone because then you'll trigger on slice alone, which might be rebound. Also, you need the period, and note the \"s\" in __builtins__.. Is there any reason not to always use ExtSlice instead of a tuple? That would simplify things a bit, if we could use ExtSlice for any multidimensional index.. __builtins__.slice. The error message might be better worded as \"in Python 2, ellipsis is only supported in slices\".. > Well __builtins__.slice doesn't work because __builtins__ is a dictionary, not an object.\nAre you sure?\n$ python2\nPython 2.7.14 (default, Sep 23 2017, 22:06:14) \n[GCC 7.2.0] on linux2\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> __builtins__.slice\n<type 'slice'>\n\n$ python3\nPython 3.6.3 (default, Oct  3 2017, 21:45:48) \n[GCC 7.2.0] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> __builtins__.slice\n<class 'slice'>\n\n. Huh, that's a bizarre bug. We don't set __builtins__ anywhere in our code and yet Hy still sees a different object than Python does.. Oh shoot, that's a feature. Since we hope to be setting __main__ appropriately someday, we can't safely use get nor attribute lookup. I'm afraid I'm not sure what design would make sense, then.. > We already prevent slice from being assigned to.\nAre you sure?\n hy 0.13.0+211.g5c34296 using CPython(default) 3.6.3 on Linux\n => (setv slice \"foo\")\n => slice\n 'foo'\n\nAnyway, if we want to make get recognize a magic symbol, why not use : rather than slice? So you'd write e.g. (get foo (: 3 4)) to mean foo[3:4]. This is concise, and literal keywords are already magical as function arguments.. Okay.. Update this line for the change to :.. Shouldn't test-cut be removed from native_tests/langauge.hy now that it's in native_tests/native_macros.hy?. The reason we call this sort of parameter expr rather than exprs is because it's set to a single HyExpression.. I get how the nature of ast.slice really bit you during the development of this PR, but will this check really be useful for later programmers?. Unfortunately, this check isn't strict enough (it allows (get [1 2 3 4 5] (\"\\ufdd0:\" 1 2))) because equality of Hy model objects is very loose about type (#1363). You probably need to check the type of expr explicitly.. You can try, but it's a deep rabbit hole to go down because the compiler currently depends on that \"feature\" in certain ways. Changes to that may also conflict with #1458. I'd advise waiting for #1458 before you do that, and finishing this first in any case.. I think the try includes too much code. It would catch an AttributeError raised anywhere in those three functions.. Or maybe not; maybe it's only in effect when the functions are defined, not called. Still, the code looks confusing in that way, so it seems ideal to just include that first statement in the try block.. Easy solution: put everything after the first statment in an else block.. I don't see a change. Did you forget to push?. Do you need both .replace and spoof_positions here? Shouldn't one be enough?. The comment doesn't match the test.. Why the use of double underscores? __swallow__ isn't a special Python name, which is what double underscores on both sides of a name are typically reserved for, and it doesn't trigger the automatic Python mangling that a name like __swallow would, which we probably don't need for this test, anyway.. If all you want to do is distinguish swallow from a similar but distinct variable, how about swallow_?. Such cases might also be redundant, couldn't they? (Not that I'm expecting you to fix them in this PR.). I can confirm that I would be fine with that.. It seems an unnecessary complication. It would bring up issues such as what code gets run when both a __hy_repr__ and a registered function apply.. I doubt it would be that simple\u2014for example, there's nothing stopping somebody from monkey-patching a __hy_repr__ onto a class after a function for it has been registered.\nA priori, __hy_repr__ does make more sense than registered functions, but Hy is a second-class citizen in the Python world, and so a Hy programmer is likely to want a Hy representation of a type from a package written by somebody who doesn't care about Hy. . If you're crazy, by the way, you can always register a function for object that looks for __hy_repr__. ;). I made hy foo.hy produce bytecode on purpose. The speed boost is a lot bigger for Hy than Python, so you shouldn't have to import from the file rather than running it directly in order to get bytecode.. Done.. I'm fine with using pytest plugins, sure; just make sure everything works.. I'm getting no test failures locally with a patched astor.. Try it without your modification, just with my PR and a fixed astor, and see if you still get test failures.. I used docstring=(None if docstring is None else str_type(docstring)) so that empty docstrings are still recognized.\nI thought all the tests were passing because I forgot to run test_bin. I added your patch and everything should be good now (except for astor).. Right, oops. Done.. Eh, I dunno. I forgot a space at the beginning of line 2, though, so I've fixed that.. This will trigger on the string literal \"setv\" without #1504.. (. set-sentinel set) is better written set-sentinel.set.. And yes, it's spelled \"sentinel\". :P. So that you have access to the literal symbol that was entered, in case you want it. If you want to compare things post-mangling, you can always write code like (= (mangle symbol) (mangle 'foobar?)). By contrast, before this PR, when symbols were mangled at read-time, there was no way to tell whether the user entered foobar? or is_foobar, if you wanted to do that. After all, not every symbol ends up as a Python name, so not every symbol eventually needs to be mangled.. The specific feature request was #360.. If you don't replace this line, then we're no longer testing whether (.method :keyword) is interpreted as intended.. You might also test (is (type :foo) (type ':foo)).. Shouldn't you return False here? For example, in Python, 1 == \"1\" is false.. Shouldn't the empty keyword be built with value set to the empty string instead of \":\"?. I don't think this is right, since :foo doesn't evaluate to the string \":foo\"; it now produces a HyKeyword.. You can remove the building parameter, since you're not using it.. Oh, you're right, I think. With your code, (= :hello \"hello\") returns false instead of throwing an error.. I tried enabling this for Python 3.5 and I got a weird crash inside pytest, so I've changed it back.. That makes sense to me.. The colon is mandatory, so I think HyKeyword('foo') should produce :foo, whereas HyKeyword(':foo') would produce ::foo.. We only use this once, so we don't need the assignment.. I don't think that's necessary, or even particularly desirable.. Is this line (and the corresponding one in unmangle) returning the same type as the rest of the function?. Shouldn't you copy namespace (or set the default argument of namespace to None and then assign {} in the body)?. Why use ->> and write these lines backwards when you could just write them forwards?. Actually, it might be helpful to explain why I wrote these assertions in the first place. My thinking is, mangle should always return a legal Python identifier. But the empty string isn't a legal Python identifier, and while we could think up a mangling rule to make it one, trying to compile an empty symbol into a Python identifier is probably a mistake to begin with.. I think this form would be better written\n(unless match\n  (return))\n(setv [expr attr] (.group match 1 3))\n\nbecause the return means that the setv is effectively part of the mainline code of the function.. Even better, take a cue from Perl and make the first line (setv match (or (re.match r\"(\\S+(\\.[\\w-]+)*)\\.([\\w-]*)$\" text) (return))).. The other uses of -> and ->> in this file don't seem very helpful, either.. This doesn't seem to allow for attributes with weird characters (that would need to be mangled) in their name.. That sounds reasonable to me.. @waigx You can use make flake to run flake8 on the Hy codebase.. Sure, changed.. Any reason for the newline and indent here? You have plenty of room for the 1 on the previous line.. That's #1542. Basically we'll just need to remove the remaining mutating code from the compiler.. square or squareb? brackets is perhaps obvious, but people sometimes use that word to mean bracketing characters in general, including parentheses. Maybe sbrackets or sqbrackets or sqbrack.. All right, I'll do a git filter-branch to change it to brackets.. Good point.. Changed.. I made that typo on purpose, so I could write \"[sic]\", so I could get square brackets into the string.. Sure.. Not a bad idea, but it can be done in a separate PR.. You mean, testing a macro that returns NotImplemented? It doesn't work (TypeError: Don't know how to wrap a <class 'NotImplementedType'> object to a HyObject).. The comment is perhaps misleading. The detection for _bad_roots doesn't distinguish between forms inside a function and forms at the top level; it just triggers for any attempt to use one of the given names as a special operator. except is illegal at the top level in the sense that it isn't a true special operator; it's handled inside @special(\"try\", \u2026) instead.. I've made the comment more descriptive.. I think you missed some parentheses here.. I'm a fan of DejaVu Sans Mono. Before that, I stuck to Andale Mono.. It seems more direct to have if pkgpath is None as the condition, with this part in the else.. This function doesn't seem to need any local variables of pytest_collect_file (except for _fspath_pyimport, which is constant), so it could be defined outside of pytest_collect_file instead of being defined on every call.. These sorts of purely aesthetic changes are best done in separate commits from functional changes.. Your first commit has an extra commented-out line hanging around here (which isn't visible in GitHub's final diff for the whole PR).. It's better to use parentheses than backslashes.. The outer parens here are no longer necessary.. This change isn't necessary.. In Hy code, it's better to write import-module.. Why not fname.endswith('.hy')?. This could be written more concisely as return (code, fname) if PY3 else code.. I think it's clearer to let open, unqualified, refer to the builtin, not to io.open. Or, use builtins.open or io.open explicitly every time.. Why the \"XXX\" in this comment?. Why?. Is it one of those bugs that appears on Travis but you can't replicate locally?. You know, I think I saw that once, but I couldn't reproduce it. I say let Travis use the new version for now and let's try to fix that issue when we get the opportunity.. You can just append or None to the end instead of using if.. Use parens instead of a backslash.. It's best not to use the name of a builtin, like file, for a local variable.. Instead of having the test write a temporary file, why not commit this file into tests/resources?. NEWS is for users, so it doesn't need items for internal changes.. This change is already listed below as a bug fix.. I'd say that each of these fixes is notable enough to get its own item.. Hmm, yeah, that could lead to trouble. You could try writing a test with a source file that has non-ASCII characters in it.. Or is this already implicitly tested by all the other native tests that have non-ASCII characters?. Couldn't you just write something like key=lambda x: not (isinstance(x, ast.ImportFrom) and x.module == '__future__')?. I think it would be a better test to add a module docstring to resources/pydemo.hy and check for it in test_hy2py.. It uses an internal function (import_buffer_to_hst), and it relies on the structure of Python AST, to test for a bug that's readily visible in user space. So I'd say we should get rid of it if we don't need it.. I think the condition here is equivalent to line.startswith('!'), which seems like a clearer way to write it.. I think you could just write t if isinstance(t, str) else t.__name__ instead of defining exc_type_name.. Likewise, there's no need for a local exc_info.. You probably don't want to commit this big block of commented-out code.. In that case, you should attribute the source of the copied code in the commit message.. For this test file, it may be wiser to require from resources.macros or resources.tlib, since let is itself unstable.. I think this test is wrong: (nonlocal-test-macro 1) should have been expanded before (setv module-name-var \"tests.resources.macros\") was evaluated, because the former is a macro expansion while the latter is ordinary code and they're in the same file. See my comments on #1414.. Such an incremental approach would not allow one to expand all macros before compiling to bytecode or translating to Python.. If you're sure you want this change, put it in its own commit.. All these transformations from comments to docstrings are good, but should also get their own commit. (A lot of important stuff is going on in this commit that we don't want crowded out by minor stuff like this.). The refactoring diffs in this file are big enough that they should get their own PR. I'm not sure they're all improvements, though. For example, you moved _loopers away from where it's used.. Much better, but you still have some stray unrelated style changes, like this one\u2026. \u2026and this one.. Oh, no wait, you actually did have to change how we call macroexpand. You can avoid the temporary variable, though.. I corrected myself; see above. Sorry.. Don't forget this one.. I think it would be clearer to write this conditional the other way around (i.e., if assignments == \"ALL\": \u2026 else: \u2026).. This can be written as ast_prefix = prefix and ast_str(prefix).. The same could presumably be said for every call to asty.Name to get a constant, and we don't want to comment every use, so this comment probably shouldn't stay. . Neither of the temporary variables here seems to be necessary.. Did you mean to leave this comment in the PR?. Should this commented-out line stay in?. Or this one?. And this one.. Should this be \"Locals must be a dictionary\"?. Should \"when\" be \"with\"?. How about these comments?. And this one.. I think you could write this as not source_module.__macros__  and not source_module.__tags__. But actually, I don't see the point of this check. Shouldn't requiring a module with no macros just not pull in any macros? Or would that have some unexpected consequence?. More possibly forgotten comments.. This could be written assert not compiler or compiler.module == module.. I'm an unconventional sort of fellow, and I don't think PEP 8 says anything one way or the other about this anyway, but the way I figure, there's no reason to use if for expressions that can be written more directly with and or or.. I asked you to stop this. Twice. Then you insulted me about it. Please don't comment on my indentation again.. There's a lot of very similar code here for the source and target modules. Try a loop or a subroutine.. It seems dangerous to catch any Exception.. Why's this marked resolved? The test is still there.. These two methods are very similar. Is it possible to factor out the common stuff?. Also remove the corresponding bit in docs/langauge/cli.rst.. Having to say (self.filename, expr, self.source) every time is a drag. Try a helper function or method, like\ndef err(self, expr, msg):\n    return HyTypeError(msg, (self.filename, expr, self.source))\n\n. Again, except Exception might be too broad.. I should ask: are TODO comments like this meant for yourself or for future readers and editors of the codebase?. Is there any reason you chose to take filename, expression, and source as a tuple instead of as separate parameters? (Likewise for HySyntaxError.). Lots of commented-out code here.. I see. I think an idea about how the code should change in the future, like that, is better as a GitHub issue than a comment. Otherwise we're kind of tracking things we want to do in two different places.. Oh yeah, looks like it's dead code. I vaguely remember making it obsolete when editing the lexer a while ago. Why not just add another commit to this PR (rebased to before the other commits) deleting it?. What I'm afraid of is silencing an error that would alert us of a bug. That seems worse to me than weird crashes from unanticipated but meaningless errors we should've ignored. I'd say, just list the exception types you've been able to provoke so far. We'll add more later if we need them. Does that sound reasonable?. Ouch. Would it suffice to add TypeError to the list?. Why's this conversation marked resolved? Do you feel that the deleted comment is unhelpful? I added it originally because I figured it wasn't obvious why the method was gated to not PY3. But whether we end up removing the comment or not, removing it seems beside the point of this commit.. GitHub is attaching this conversation to different lines depending on which part of the interface I view it in (oy), so to clarify, I'm talking about this deletion\n-  # Under Python 3, `exec` is a function rather than a statement type, so Hy\n-  # doesn't need a special form for it.\n\nwhich occurs in the commit \"Produce Python AST for require statements\" (11e19adba56c7b8578311c15ec17b7e6f7cc3eaa).. Right. Sorry, I was sloppy.. \"Applying suggestions on deleted lines is not supported.\" :(. Right; no need to get rid of them entirely, but you might be able to put parts that are common to both into an internal function or method.. ",
    "berkerpeksag": "I've found this: https://github.com/rcarmo/hy-there/blob/master/nose/hosetests.hy\n. Hi, @cereal. Sorry for the late response!\nThere is no bug here:\n``` sh\n$ hy -v\nhy 0.9.11\n$ cat t.hy\n(print \"\u0131\u00e7\u015f\u011f\u00fc\")\n$ hy t.hy\n\u0131\u00e7\u015f\u011f\u00fc\n$ cat content.txt \nhy hy hy\n\u0131\u00f6\u00e7\u011f\u00fc\n$ cat t2.hy \n(import codecs)\n(print (.read (codecs.open \"content.txt\" \"r\" \"utf-8\")))\n$ hy t2.hy \nhy hy hy\n\u0131\u00f6\u00e7\u011f\u00fc\n```\nI've changed your script to use codecs.open:\n``` clj\n(import codecs)\n(import lxml.html)\n(import lxml.html.builder)\n(setv tostring lxml.html.tostring)\n(setv builder lxml.html.builder)\n(setv contentpath \"content.txt\")\n(with [content (codecs.open contentpath \"r\" \"utf-8\")]\n  (setv htmlEle\n    (builder.HTML\n      (builder.HEAD\n        (builder.TITLE \"Hi\"))\n          (builder.BODY\n            (kwapply \n              (builder.DIV (.read content))\n               {\"style\" \"background-color: #000000;font-color: #FFFFFF;\"})))))\n(print (kwapply (tostring htmlEle)\n   {\"pretty_print\" True\n    \"encoding\" \"unicode\"}))\n```\nAnd:\nsh\n$ hy lxmltest.hy \n<html>\n<head><title>Hi</title></head>\n<body><div style=\"background-color: #000000;font-color: #FFFFFF;\">hy hy hy\n\u0131\u00f6\u00e7\u011f\u00fc\n</div></body>\n</html>\n. :+1: for defmain.\n. There is a small bug in hydoc. It shows hy.core.language functions like is_empty or is_float instead of empty? or float?.\n``\n(is_empty coll) \n    Return True ifcoll` is empty\n(is_even n) \n    Return true if n is an even number\n(is_float x) \n    Return True if x is float\n```\n. I'm closing the bug because I can't reproduce it on 0.9.11.\nsh\n$ hy -v\nhy 0.9.11\n``` sh\n$ cat setup.hy \n(import [distutils.core [setup]])\n(kwapply (setup)\n {\"name\" \"foo\"\n  \"version\" \"0.1\"\n  \"py_modules\" [\"foo\"]})\n```\n``` sh\n$ hy setup.hy check\nrunning check\nwarning: check: missing required meta-data: url\nwarning: check: missing meta-data: either (author and author_email) or (maintainer and maintainer_email) must be supplied\n```\n. This is done now. (see #374)\n. Fixed now: https://travis-ci.org/hylang/hy/builds/11727424\nThanks @tuturto.\n. > Please only put # NOQA on the lines that trigger flake8 warnings. We want to keep the other checks (you can take a look at hy/init.py for inspiration).\nDone. Thanks.\n. I rebased the branch against upstream/master.\n. You're right and \"readability counts\" :) I've updated the branch.\n. What about adding CO_FUTURE_UNICODE_LITERALS to hy.importer.ast_compile (see https://github.com/hylang/hy/blob/master/hy/importer.py#L41)?\nand just add a bytestring helper:\nclj\n(defn bytestring [x]\n   (bytes x))\n. You won't need a string helper if the default string type is Unicode in Hy (both Python 2 and 3 - see for more info http://docs.python.org/2.7/library/future.html) and you will use the bytestring helper when you have to deal with 8-bit strings (e.g. HTTP).\n. > If you're in the mood, adding virtualenvwrapper would be killer! (if not, I'll add it later :) )\nDone :) https://github.com/hylang/hy/pull/306\n. LGTM.\n. I've rebased and merged it in https://github.com/hylang/hy/commit/f9a1995be8641867612761e95b66200b103823e1.\n. Wow! Didn't expect that, thanks :)\n. I've contacted the author of astor to take over the maintainer role. Hopefully, I will merge https://github.com/pmaupin/astor/pull/2 soon :)\n. I've released astor 0.3 and rebased the branch. A quick review would be great :)\n. Ah, great catch! Thanks, I will update test_bin.py.\n. Thanks :)\n.  I've squashed your commits and merge into master. Thanks! https://github.com/hylang/hy/commit/63a9e35f7fd5cb4e8bf8aa72fecb2443df2f407e\n. > I'll be +1 this instead of the other (#340) as its simpler then the other.\n:+1:\n. Thanks :)\nhttp://docs.hylang.org/en/latest/language/api.html#quasiquote\n. Hi, could try with Git master?\nsh\n$ pip install git+https://github.com/hylang/hy.git\n. I've opened #397 for #344, but it needs more work: https://gist.github.com/berkerpeksag/513a3cc58ab6109b577c\n. > Maybe we should add this in quickstart of the docs as well?\nGood idea :+1: \n. I've merged @copyninja's branch and my script into one branch and opened #379.\n. :+1:\n. Thanks for the patch. Could you also update setup.py?\n. Thanks! :) https://github.com/hylang/hy/commit/8970662dcb694d0bdc585f8b213c03c1b64c6b9a\n. The patch also needs documentation.\n. To make flake8 happy\ndiff\n+                                     \"for reader macro name\" % \\\n+                                     type(name).__name__))\nshould be\ndiff\n+                                     \"for reader macro name\" % (\n+                                     type(name).__name__)))\n. Good point. I will use httplib (and probably will rewrite the script in Hy).\n. LGTM.\n. https://github.com/hylang/hy/commit/0f96c249659a90324524fa016af1985ee90b90c8 and https://github.com/hylang/hy/commit/799c39ffad8e51f99d2c9ddea617ec95c68a356f\n. I've also changed the version to 0.9.12.\n. I've tweaked the docs a bit and merge it. Thanks! :) https://github.com/hylang/hy/commit/c69c14cc7d107018d22032d7fb063fb1cd4a222b\n. Superseded by #410.\n. Thanks! :)\n. Committed in https://github.com/hylang/hy/commit/8cabf22749478751911ebb69816b600f0165e5c7.\n. Could you wrap the lines to 80 columns?\n. LGTM.\n. Thanks again! :) https://github.com/hylang/hy/commit/426d34288f37c61182c7c0ef054a127dfbd83c6d\n. LGTM.\nI've also added a rule for __pycache__ directories.\nhttps://github.com/hylang/hy/commit/715158c7dbddd222a5bc3e80266dd648ce47e0d5\n. done s/0.10.0/0.9.13/\n. LGTM.\n. I just tested this locally, thanks :)\n. Thanks! :heart:\nhttps://github.com/hylang/hy/commit/d18e752d335b1e7f454e82239061a13e001ba0ec (test and doc https://github.com/hylang/hy/commit/78f6301e272d8664e1261e57f20026e11d5261bd https://github.com/hylang/hy/commit/5017e3c21176303cce2eb3a1ec12d1476a689948)\n. You probably need to add native_tests.contrib.loop to hy/tests/__init__py. See https://github.com/hylang/hy/blob/master/tests/init.py#L16 for example usage.\nThank you :)\n. :+1:\n. LGTM.\n. LGTM.\n. LGTM.\n. I only moved the example in contrib.meth to a more visible place. contrib.meth and test_meth don't need to move anywhere IMO.\n. Ah, thanks @Willyfrog, I've opened #454.\n. There are a couple of warnings in the documentation:\nWARNING: Inline interpreted text or phrase reference start-string without end-string.\n\nYou need to add a newline after ::. Something like\n``` rst\n::\n# foo bar\n\n``\n. Could you also add documentation for merge-with? (seedocs/language/core.rst`)\n. Thanks! I've also added you to AUTHORS.\nhttps://github.com/hylang/hy/commit/e50ca4fc078df08c5a8bd9c45e8eb19bc176f4a9\n. LGTM.\n. LGTM.\nThanks! :) https://github.com/hylang/hy/commit/8ec2719e2d814471e5dfc834d9e1a6c68a20e43e\n. :+1:\n. This is done now. See #506.\n. I've rebased the branch against upstream/master.\n\nwhat about kwonly args, here we do an (apply foo [] {some-dict})\n\nI don't understand your question. Could you elaborate?\n. Fixed that typo @theanalyst, thanks!\n. Also, we probably need to move Hy style guide to the main docs.\n. LGTM. :+1:\n. Well, I think we should implement that trick in Hy in the future. Hy users should not deal with changing the value of sys.executable and passing the extra_files parameter to Werkzeug in the app.hy. It is a bit of black magic right now, so I prefer a seperate Python script.\n. Ping! :)\n. Yes, but we need a cleaner API for that. Maybe adding a defapp macro to contrib.meth would help. Closing this for now. I'll open a new issue.\n. LGTM :+1:\n. Copying from IRC:\nolasd | because j_king reset his master branch                        \nolasd | and his master branch is now == to hylang/hy's master branch  \nolasd | that must've confused github's pull request management thinger\nolasd | (and kids, this is why you don't PR from your master branch)\n. Fixed in https://github.com/hylang/hy/commit/75748eb05dc5e38a88da2fa3789e9aa629ac65fc.\n. LGTM.\n. LGTM. :+1:\n. LGTM.\nTwo nitpicks:\n- Docs needs a .. versionadded:: 0.9.13 directive\n- Could you squash the commits into one?\n. LGTM.\n. LGTM.\nThanks! :)\n. Could you open a new PR?\n. LGTM.\n. The test failed on Python 3.2 and 3.3:\n```\nERROR: NATIVE: testing the zipwith function\nTraceback (most recent call last):\nFile \"/home/travis/virtualenv/python3.3/lib/python3.3/site-packages/nose/case.py\", line 198, in runTest\nself.test(self.arg)\nFile \"/home/travis/virtualenv/python3.3/lib/python3.3/site-packages/nose/util.py\", line 613, in newfunc\nreturn func(arg, **kw)\nFile \"/home/travis/build/hylang/hy/tests/native_tests/core.hy\", line 477, in test_zipwith\n(setv res (zipwith operator.add [1 2 3] [3 2 1]))\nFile \"/home/travis/build/hylang/hy/hy/core/language.hy\", line 352, in zipwith\n(map (functools.partial apply func) (apply zip lists))))\nNameError: global name 'apply' is not defined\n```\n- https://travis-ci.org/hylang/hy/jobs/19292323\n- https://travis-ci.org/hylang/hy/jobs/19292325\n. LGTM, thanks!\nCould you squash the commits? (or I can do that for you if you want :)\nhttp://ariejan.net/2011/07/05/git-squash-your-latests-commits-into-one/\n. > Could you do it? I'm using hg-git, so the instruction are probably completely different.\nI've opened #514. Thanks again! :)\n. LGTM. The patch lacks documentation, but that can be done in a separate pull request.\n. LGTM (except the typo in docs). Could you also squash your commits?\n. LGTM. Thanks!\nhttps://github.com/hylang/hy/commit/ec4607d644f130c0ceef26a862e58c36a4f1c8b9\n. LGTM.\n. Hmm, this probably won't work on Read the Docs?\n. Ignore me :) The latest build is passed: https://readthedocs.org/builds/hy/1229998/\n. From Travis CI logs:\ntests/test_bin.py:27:1: F401 'SkipTest' imported but unused\ntests/test_bin.py:134:80: E501 line too long (83 > 79 characters)\nhttps://travis-ci.org/hylang/hy/jobs/20766540\n. LGTM.\n. LGTM.\n. This should be fixed by now.\n. > Except for the versionadded thing, but that can easily be patched up after merging this.\nDone. I also added a missing __future__ import.\nThanks for the reviews!\n. Thanks for the patch, @akaptur! https://github.com/hylang/hy/commit/3f9ae9122e077d0d2b5350fffe562262c75443fb\n. Duplicate of #72? :)\n. Thanks for the patch! Could you also add sphinx_rtd_theme to requirements-dev.txt?\n. > Do you want me to squash the commits since they're all ~5 lines long?\nThat would be great. Thanks!\n. Fixed in #615.\n. > Travis didn't build this for 2.7 correctly. That should be checked and sorted out before merging too.\nI've just restarted the job and Travis looks happy. Thanks!\n. Thanks again @kirbyfan64! I've resolved the merge conflict and pushed it to master.\n. +1 for the idea but I prefer just \"hy 0.10.0 using Python 3.4.0\". \"Python\" should not be hardcoded since Hy is also work on PyPy.\n. platform.python_implementation() will do the trick: https://docs.python.org/2/library/platform.html#platform.python_implementation\n. sys.implementation can also be used on Python 3.\n. Thanks @theanalyst! I think the \"[default]\" part is a bit redundant for CPython. What do you think about this?:\nhy 0.10.0 using Python 2.7.3\nhy 0.10.0 using PyPy 1.8.0 [Python 2.7.2]\n. I used sys.pypy_version_info for PyPy: https://gist.github.com/berkerpeksag/0e944d6cdf8a89d060d5\n. LGTM.\n. LGTM.\n. hy2py has been added recently. You need to run the following command in your venv first:\n``` sh\n$ pip install -e .\n$ python -V\nPython 3.4.0\n$ nosetests tests/test_bin.py\n...........\n\nRan 11 tests in 19.905s\nOK\n```\n. LGTM. Thanks! :)\n. Fixed in #615.\n. Thanks!\n. LGTM.\n. LGTM.\n. LGTM.\n. LGTM :+1:\n. +1 for using the timeit module.\n--Berker\nOn Tue, Jul 22, 2014 at 3:42 PM, Gergely Nagy notifications@github.com\nwrote:\n\nWouldn't it be better to use the timeit\nhttps://docs.python.org/2/library/timeit.html module available in\npython 2.3+?\nEven though timeit.timeit requires code to be passed as a string, we\ncould work that around in a macro (put the code in a function, and\nconstruct a string that just calls that, and pass that to timeit).\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/pull/625#issuecomment-49733268.\n. - hy/contrib doesn't get too much commit/traffic right now (last two commits made 2 and 4 months ago for example).\n- Most of the contrib modules are undocumented: http://docs.hylang.org/en/latest/contrib/index.html\n- Git submodules are really bad, we should avoid to use them :)\n  - http://uttamkini.com/2012/12/01/sharing-code-and-why-git-submodules-is-a-bad-idea/\n  - http://somethingsinistral.net/blog/git-submodules-are-probably-not-the-answer/\n  - http://slopjong.de/2013/06/04/git-why-submodules-are-evil/\n- It's not easy to setup a new development env for new contributors and/or git newbies. Keeping submodules up-to-date is also PITA.\nWe also get much more flexibility inside contrib to make rapid changes and do more iterative development (if wanted).\n\nCPython tried something like that for their stdlib. See PEP 413.\n. One more problem: You'll need to move contrib tests to the new repo.\n. LGTM.\n. Thanks! :)\n. LGTM. (needs to rebase and versionadded directives)\n. > In my opinion, it should return None instead rather than raising the IndexError like that.\n+1\n. LGTM.\n. LGTM.\n. LGTM (it would be great if you could squash these commits into one)\n. Oh, the patch also needs a documentation update, but you could open a new PR for that.\n. I couldn't reproduce this with the following commands:\nsh\n$ cd hy/\n$ . venv/bin/activate\n$ pip install -e .\n$ make -C docs/ html  # or cd docs/ and make html\n. Just update version number to 0.10.2(or 0.11? I'm not sure :)) in the versionadded directive and LGTM.\n. It's the old PyPy failure. We can merge this safely :)\n. This can go into scripts/ directory.\n. Thanks!\n. PyPy version:\nsh\n$ python --version\nPython 2.7.8 (f5dcc2477b97, Sep 18 2014, 11:33:30)\n[PyPy 2.4.0 with GCC 4.6.3]\nHere is the output:\nsh\n$ make travis\nnosetests -s --with-coverage --cover-package hy\nmake: *** [travis] Segmentation fault\nhttps://travis-ci.org/hylang/hy/jobs/39709437\n. The latest happy build https://travis-ci.org/hylang/hy/jobs/37454848\nPyPy version:\nsh\n$ python --version\nPython 2.7.6 (32f35069a16d, Jun 06 2014, 11:20:40)\n[PyPy 2.3.1 with GCC 4.6.3]\n. I've just looked the PyPy 2.4.0 release notes. Quoting from it:\n\"Classes in the ast module are now distinct from structures used by the compiler\"\nI didn't investigate further, but it could be related to our test failure.\nhttp://doc.pypy.org/en/latest/whatsnew-2.4.0.html\n. Some tests are passing in my computer with PyPy 2.4.0 and hy master(of course unittest couldn't find many of them):\n``` sh\n$ python -m unittest discover -v tests/\ntest_builds_with_dash (compilers.test_compiler.CompilerTest) ... ok\ntest_compiler_bare_names (compilers.test_compiler.HyASTCompilerTest) ... ok\ntest_fn_compiler_empty_function (compilers.test_compiler.HyASTCompilerTest) ... ok\n\nRan 3 tests in 0.002s\nOK\n``\n. Or you can just add the following code to.travis.yml`:\nyml\nmatrix:\n  allow_failures:\n    - python: \"pypy\"\n. Yes, but downloading a nightly binary build of PyPy(~20 MB tarball) and extracting it will take a while. Anyway, I'm +0 on your idea. Please open a PR :)\n. PyPy build is failing again:\nDownloading/unpacking pip\n  Downloading pip-1.5.6-py2.py3-none-any.whl (1.0MB): 1.0MB downloaded\nRPython traceback:\n  File \"rpython_jit_metainterp_optimizeopt_optimizer.c\", line 6945, in get_constant_box__rpython_jit_metainterp_optimiz\n  File \"rpython_jit_metainterp_optimizeopt_unroll.c\", line 29077, in UnrollableOptimizer_ensure_imported\n  File \"rpython_jit_metainterp_optimizeopt_optimizer.c\", line 5904, in OptValue_import_from\nFatal RPython error: AssertionError\nAborted\nmake: *** [python] Error 134\nhttps://travis-ci.org/hylang/hy/jobs/44429339\n. Travis is happy now, thanks @kirbyfan64.\nhttps://travis-ci.org/hylang/hy/jobs/44533916\n. LGTM\n. LGTM. Thanks!\nCould you please silence this flake8 warning:\nhy/_compat.py:59:30: E701 multiple statements on one line (colon)\n. I'm not an hy/compiler.py expert, but LGTM. Could you add a test? Thanks!\n. > anyone object to eol'ing py 3.2?\n+100 (and also 2.6)\n. LGTM. Could you also update the documentation.\n. LGTM. Ping @rwtolbert.\n. Thanks! :)\n. I can update your email address if you want.\n. Done in https://github.com/hylang/hy/commit/b78f0e3b7972e2cd9d63beb9fa31d43e93a9ef9a. Thanks again! :)\n. LGTM.\n. Great patch, thanks! :)\n. LGTM.\n. Thanks!\n. Thanks for the patch! If you have more time to work on the documentation, you can update it to follow CPython's documentation guideline:\n- https://docs.python.org/devguide/documenting.html#restructuredtext-primer\n- https://docs.python.org/devguide/documenting.html#id3\nTo summarize it:\n- Functions parameters should use parameter_name\n- Current foo markups should be updated to use foo instead\n- True, False, None, and other inline code samples should use True, False etc.\n. Great patch, thanks! :)\n. LGTM.\n. LGTM. Could you squash the commits?\n. +1 for a new release. Already merged changes:\n- #795\n- #773 \n- #762\n- #763\n- #756\n- #795 \n- #753\netc.\n. Added and reviewed #796. Zack's patch LGTM.\n. Good patch, thanks! Please add your name to AUTHORS.\n. Sorry for the delay. There are a couple of minor issues with the current approach. I'll take a look at this in a week or two if no one beats me to do it.\n. Looks a reasonable request. Do you want to write a patch?\n. Fixed in #763.\n. Test failure looks unrelated:\nDownloading/unpacking pip\n  Downloading pip-1.5.6-py2.py3-none-any.whl (1.0MB): 1.0MB downloaded\nRPython traceback:\n  File \"rpython_jit_metainterp_optimizeopt_optimizer.c\", line 6945, in get_constant_box__rpython_jit_metainterp_optimiz\n  File \"rpython_jit_metainterp_optimizeopt_unroll.c\", line 29077, in UnrollableOptimizer_ensure_imported\n  File \"rpython_jit_metainterp_optimizeopt_optimizer.c\", line 5904, in OptValue_import_from\nFatal RPython error: AssertionError\nAborted\nmake: *** [python] Error 134\nhttps://travis-ci.org/hylang/hy/jobs/44428809\n. Thanks!\n. I was referring to https://github.com/hylang/hy/pull/719/files#diff-db08340954b7d946bf05866170bf1d65R224 Those tests are can be skipped, right? :)\n. Thanks! :)\n. This looks like a duplicate of #513.\n. I'm not a hy/compiler.py expert, but LGTM.\n. :+1:\n. Since we support u\"foo\", I think we should also support b\"foo\". Also, b\"foo\" is easier to write.\n(I had a WIP branch for this, but I couldn't find it now :/)\n. This looks like a duplicate of #305.\n. +1\n. Thanks @ALSchwalm :)\n. We can create a new section \"Editor plugins\" in tutorial, or better we can create a new page \"Tools\" and add our editor plugins, IPython kernels, HyREPL, Sublime plugins etc. and then we can add cross references to http://docs.hylang.org/en/latest/tutorial.html and http://docs.hylang.org/en/latest/quickstart.html (see item 7)\n. > Cross reference from where to these pages? \"Tools\", you mean?\nSorry, yes I meant \"tools\" :)\n. @iKevinY please go ahead and send a PR :)\n. Thanks for the PR!\n\nDoes anyone know if this is a Sphinx issue or if I just formatted the code blocks incorrectly?\n\nIt's a docutils/reST feature. Whitespaces are important in reST. So, the markup should be like the following example:\n` rst\n+ Vertically alignlet`` blocks.\n.. code-block:: clj\n (let [[foo (bar)]\n       [qux (baz)]]\n    (foo qux))\n\n```\n. Yes, this is a bug.\n``` py\n$ python\nPython 2.7.3 (default, Feb 27 2014, 19:58:35) \n[GCC 4.6.3] on linux2\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n\n\n\nexec(\"a=2\")\na\n2\n```\n. Thanks!\n. Oh, sorry, I will add you in a minute :)\n. LGTM. Thanks!\n. Whoa, amazing! Could you fix this warning?\n\n\n\nhy/completer.py:89:71: E202 whitespace before ']'\nLGTM.\n. And please add your name to AUTHORS :)\n. Yeah, could you replace them with except Exception?\n. Thanks!\n. LGTM. Could you please squash the commits? Thanks!\n. LGTM. Errors on Travis are unrelated.\n. Opened #764 for flake8. Feel free to send another PR to fix it :)\n. Great, thanks!\n. LGTM.\n. I'm going to merge this since mostly @theanalyst and I are touched the travis/tox/Makefile files and the changes look good to me.\n. I didn't know python -i file.py works too. +1 for being consistent with python.\nCould you also fix PEP 8 errors?\n. LGTM. Could you also squash the commits? Thanks!\n. Thanks!\n. Thanks!\n. Thanks! :)\n. Nice catch, thanks!\n. Nice to have: Updating tutorial for keyword-only only args would be great, but that can go in a new PR of course.\n. Looks great to me, thanks!\n. LGTM. Could you add documentation and add your name to AUTHORS?\n. LGTM.\n. Thanks @acron0 :)\n. Thanks for the patch! I'm not sure about the API. Most of the time you will decorated your views in Flask. It would be better to add a decorator option to the existing *-route macros.\n. Looks good to me. Can you add some tests and update the docs?\nThanks!\n. Thanks! Can you fix this?\nFile \"/home/travis/build/hylang/hy/tests/native_tests/language.hy\", line 1159, in test_argument_destr\n    (defn f [[a b] [c]]) (return (, a b c))\nNameError: global name 'return' is not defined\n. LGTM.\n. Thanks! \n. Hi! You can use &rest:\nhy\n=> (defn count-args [&rest args]\n...  (print \"You passed\" (len args) \"args:\" args))\n=> (count-args 1 2 3)\nYou passed 3 args: (1L, 2L, 3L)\n. And see also http://docs.hylang.org/en/latest/language/api.html#defn-defun\n. LGTM\n. Thanks @zackmdavis :)\n. LGTM\n. Amazing work, thanks!\n. LGTM. Also, PEP 492 is probably(I haven't reviewed the patch yet) going to brake some things in Hy.\n. I like documentation patches :) You can add 0.11.1. We can update it later. Thanks!\n. I don't have numba installed, so didn't tried, but looks like:\n(with-decorator jit (defn sum x y))\nshould be\nclj\n(with-decorator jit (defn sum [x y] (+ x y)))\n. I think it's easy enough to implement in your code via using decorator syntax or macros :)\n. Thanks! (also thanks for the review @farhaven :))\n. LGTM. I think you can delete the (global --name--) line.\n. Thanks for the patch! :)\nLGTM. It would be nice to add a simple test case.\n. https://github.com/hylang/hy/blob/master/tests/compilers/test_ast.py looks like a good place to me. Thanks!\n. Welcome Zack! :)\n. +1, is there a test for the new behavior?\n. Looks good to me, too. +1 to @paultag's suggestion.\n. Squashed and merged in https://github.com/hylang/hy/commit/c94c0e8b5084dbc873301becc591f5a2077ae9e9.\n. You can also use the web version at http://docs.hylang.org/en/latest/language/cli.html#hy\n. Hi @acekingke, you can use the tuple builtin:\n=> (tuple [1 2 3])\n(1L, 2L, 3L)\nor\n=> (, 1 2 3)\n(1L, 2L, 3L)\n. +1\n. Wow, amazing! :) I really like the new method syntax. LGTM.\n. LGTM\n. Thanks! :)\n. Yes, ipython, pip and others do the same thing. Patch LGTM.\n. I'm the chosen one :)\n. I think we need to move the exclude_lines setting to a new [report] section. See http://coverage.readthedocs.org/en/latest/config.html#report\n. I'd say go ahead and push if it creates too much noise :)\n. Thanks! :)\n. Since the version info is 0.11.00 on both /stable/ and /latest/ I think we also need to bump the version to 0.11.0+ or 1.0.0-dev or something else on master.\n. +1\n. Thanks!\n. Last successful build: https://readthedocs.org/projects/hy/builds/3255318/\n. I think we can close this now.\n. LGTM.\nTwo minor suggestions:\n1. I'd tweak the exception message from ... assign / delete ... to ... assign or delete ...\n2. It would be nice to add a small test for this\nThanks!\n. LGTM.\nTwo minor suggestions:\n1. I'd tweak the exception message from ... assign / delete ... to ... assign or delete ...\n2. It would be nice to add a small test for this\nThanks!\n. flake8 looks unhappy :)\nhy/compiler.py:1354:80: E501 line too long (80 > 79 characters)\nCan you fix that and squash your commits?\n. I wouldn't bother to support multiple PyPy versions. If it's working on the latest PyPy, I'd say just drop the PyPy specific code.\n. Perhaps we can add a new \"Hy Cookbook\" chapter to docs.\n. https://github.com/hylang/hy/pull/999 has merged, closing this.\n. Could you also update trove classifiers? https://github.com/hylang/hy/blob/master/setup.py#L91\nA little bit off-topic, but we should not duplicate the testing logic in both .travis.yml and tox.ini. I'd prefer to handle all things in tox.ini and use TOX_ENV in .travis.yml. See https://github.com/benoitc/gunicorn/blob/master/.travis.yml and https://github.com/benoitc/gunicorn/blob/master/tox.ini for example.\n. Sorry for my late response. Yes, let's use tox in .travis.yml. Please squash your commits when you're done :)\n. LGTM (just asked a question above)\nThanks @felixonmars :)\n. I'd prefer print(e, file=sys.stderr) over sys.stderr.write(\"%s\\n\", str(e)).\nEdit: str() can also be removed.\n. Also, I don't fully understand how this solves #982. I think the main problem is in clint and we need to encode self.message before passing it to colored.yellow(): https://github.com/hylang/hy/blob/master/hy/errors.py#L104 I don't have a development environment right now so I might be horribly wrong :)\nThanks!\n. Looks great to me, too. Could you please squash your commits?\nThanks!\n. LGTM\n. LGTM, thanks!\n. I don't use PyPy, but I guess it's safe to merge (since tests are green in PyPy). \n. (The flake8 commit needs to be squashed.)\n. Thanks!\n. LGTM\nThanks!\n. Thanks!\n. Fixed in https://github.com/hylang/hy/commit/a820d8ee39f484cd4680a95224f74c0d97968bbc.\n. Fixed in https://github.com/hylang/hy/commit/a820d8ee39f484cd4680a95224f74c0d97968bbc.\n. Thanks to https://github.com/blog/2141-squash-your-commits, we can now do the work via GitHub's UI.\n. I agree with @kirbyfan64. Perhaps we can document briefly what compile_* functions do in HyASTCompiler docstring or in the internals docs at http://docs.hylang.org/en/latest/language/internals.html\n. This was done in https://github.com/hylang/hy/commit/6a452d70a46f00fa521cc543e321d8efa391baa8.\n. +1 for 0.12a0.\n. @Digenis good question :) https://docs.python.org/dev/library/importlib.html#examples has some examples, but I don't know if there's a fully working example (I'd suggest to open an issue at bugs.python.org). As for iter_importer_modules, if I remember correctly, it's a semi-official undocumented API and it looks for an iter_modules method implicitly. \n. We might drop 2.7 support in a next feature release (even critical software like Gunicorn will drop 2.7) I'd suggest to make it work in Python 3 first then we can discuss 2.7 :)\n. Thanks!\n. Thanks!\n. Thanks! :) The build failure wasn't related to this PR.\n. Thanks!\n. Perhaps we can change the first sentence to:\nPrint equivalent Python code before executing it in the REPL.\n. Thanks!\n. Thanks!\n. LGTM\n. I think user-specific values should go into your global .gitignore file. I'd like to keep the scope of .gitignore small and only cover things that are specific to hylang project itself.. BTW, thanks for the PR, @jakirkham! I thought we already have a MANIFEST.in somewhere in the repository :). +1. I think we need more time to discuss and review the new importer.. I agree with @rwtolbert. 3 commits for a trivial patch creates too much noise. https://github.com/hylang/hy/pull/1187 was another example. \"Split changes into logically separated commits\" is preferred for medium or huge sized patches, not for trivial ones. Please use GitHub's \"squash and merge\" feature next time.. Thanks!. Thanks!. Thanks for all of your work, @rwtolbert!\nWe don't need to remove @rwtolbert from the GitHub team. He can always come back and add himself to docs/coreteam.rst again (of course, he can also always remove himself from the GitHub team)\n(Sorry, I'm pretty bad at remembering names :)). Thanks for all of your work, @rwtolbert!\nWe don't need to remove @rwtolbert from the GitHub team. He can always come back and add himself to docs/coreteam.rst again (of course, he can also always remove himself from the GitHub team)\n(Sorry, I'm pretty bad at remembering names :)). +1 for dropping Python 2 support now. Note that some super popular Python projects like Django and Gunicorn will drop Python 2 in their next major release this year. I think we can be more aggressive since we have much smaller user base than these projects :). By the way, I just released astor 0.6.1 so the current hy release no longer raise an ImportError when you invoke hy.. (Also, you can ping me on IRC or open an issue at berkerpeksag/astor if you notice an obvious compatibility error like this one in a new astor release.). +1 from me, but I'd make the threshold a month rather than two weeks (or require one approval after two weeks and no approval needed after a month). +1. FYI, I want to fully support Python 3.7 in astor 0.7 and the only blocker for now is https://github.com/berkerpeksag/astor/pull/102.. parser.exit(0) can be used here.\nSee for the doc: http://docs.python.org/2/library/argparse.html#argparse.ArgumentParser.exit\n. argparse is provided in the stdlib in Python 2.7+, but not in 2.6.\n``` py\ntry:\n    import argparse\nexcept ImportError:\n    argparse = None\nsetup(\n    # ...\n    install_requires=['argparse'] if argparse is None else None\n)\n. `_compat.PY3` can be used here.\n. Ops, done. Thanks :)\n. A very minor nit, but the parentheses are redundant here.\n. Thanks. Please drop the dependency_links attribute (no longer needed).\n. It would be good to mention that this is a backwards-incompatible change (with a `.. versionchanged:: 0.9.12` directive).\n. py\nparser.exit(1, parser.format_help())\n. Needs a `versionadded` directive.\n. Could you also update the CLI documentation? http://docs.hylang.org/en/latest/language/cli.html\n. Is this for https://github.com/kennethreitz/clint/pull/95?\n. py\nexcept Exception:\n```\n. I'm big fan of context managers :)\npy\nwith open(fpath, 'rt') as fp:\n    # spam eggs\n. \"...written in a subset of Python called rply\"\ns/rply/RPython/\n. We could also add dist/ and *.egg-info.\n. We can use hy._compat.PY33 here.\n. We can use hy._compat.PY33 here.\n. We don't support Python versions older than 2.7. You can  safely remove this line.\n. ``` py\nstdlib\nimport ast\nimport cStringIO\nimport codecs\nimport encodings\nimport sys\nfrom encodings import utf_8\nthird party\nimport astor.codegen\nlocal\nfrom hy.importer import import_buffer_to_hst, incr_import_buffer_to_ast\nfrom hy.lex import tokenize, LexException, PrematureEndOfInput\n. py\nexcept Exception as exc:\n. py\nelif in_lisp:\n. py\nif not in_lisp and prv_char == \"@\" and char == \"(\":\n. py\nfrom future import print_function\nprint(exc)\n. py\nif encoding != 'hy':\n    return None\n```\n. Ah, you're right :(\n. Needs a versionadded directive:\nrst\n.. versionadded:: 0.9.13\n. Looks like you forgot to add true :)\n. codegen -> codegen\ntrue -> true\n. Shouldn't (on lists) be (on lists and tuples)?\n$ hy\nhy 0.9.12\n=> (setv x (, 1 2 3))\n=> x\n(1L, 2L, 3L)\n=> (. x [1])\n2L\n=> (. x [42])\nTraceback (most recent call last):\n  File \"<input>\", line 1, in <module>\nIndexError: tuple index out of range\n. This should be (thanks to PEP8)\n``` py\nimport argparse\nimport sys\nimport astor.codegen\n. or just `print()`\n. Is there a specific reason to write this class in Hy? I can barely read the code! :P We can write the `MultiDispatch` class in Python and use it in the `defmulti` macro.\n. Ah, good catch. Will fix that, thanks!\n. dict.keys() always return a list.\n. Well, it probably don't return a list on Python 3. You can ignore my last comment :)\n. py\nisinstance(iexpr, (HySymbol, HyList))\n```\n. We could follow CPython documentation convention. Something like:\nAvailability: Python 3.3+\nhttp://docs.python.org/2/library/sys.html#sys.dllhandle\n. You could remove this directive.\nChanging is the equivalent of: to is the equivalent of:: will do the trick.\n. s/type/isinstance/\n. py\nif PY33:\nworks for both 3.3 and 3.4.\n. py\nexcept ImportError:\n. Fair enough :) but I would use except Exception.\n. We could use nose.plugins.skip.SkipTest here.\n. It would be good to mention about squashing commits here.\n. You can move this to requirements-dev.txt.\n. I think this (line 355-362) could be a function and could be used below to avoid duplicate code.\n. We could move this to hy/models/keyword.py (or to a better location)\n. This will return bytes in Python 3. You probably need to decode it.\n. Unused import\n. Can't you write this(and probably the other checks) like assert isinstance(wrapped, HyInteger)?\n. Can't you just check $TRAVIS_PYTHON_VERSION == 'pypy' and do the magic here instead of Makefile?\n. See https://github.com/twisted/klein/blob/master/.travis/install.sh for example.\n. I think \"contrib\" is fine here.\n. Thanks!\n. True\n. hy_\n. ->>\n. Can't you remove the str_type call since you already added unicode_literals above.\n. This causes implicit coercion on Python 2:\npy\nfoo = str_type(\"foo\")  # unicode\n\"expanding \" + foo  # returns u'expanding foo'\n. I'd remove this line.\n. You can check the actual message here: assert e.message == \"fooo\".\n. Same as above: isinstance(e, str_type) perhaps?\n. If we going to add unicode_literals here, we should add to all files in hy/. Otherwise this can cause weird unicode bugs.\n. Nitpick: \"\"\" -> \"\"\"\\\n. Oh, I understand the problem. I think the code is correct(thanks!), but it would be good to have __unicode__ methods in exception classes. So, HyTypeError.__str__() should be implemented like:\npy\ndef __str__(self):\n    return self.__unicode__().encode('utf-8')\n. Since you catch HyTypeError in line 431, we could remove  assert False, right? \n. You can do assert \"Exception()\" in e.message if you prefer.\n. > You want current HyTypeError.str() code moved to HyTypeError.unicode()?\nYes, correct.\n\nSprinkle 'u's everywhere?\n\nI'd go with the unicode_literals approach.\n\nCan you please link to some documentation or examples of handling unicode in python2/3 in correct and compatible way?\n- https://docs.python.org/3/howto/pyporting.html#text-versus-binary-data\n- http://python-future.org/compatible_idioms.html#strings-and-bytes\n- http://python3porting.com/\nI think I got myself in something I'm not qualified to do :)\n\nI don't think so, the patch is good and makes the codebase consistent :)\n. We can just rename the test's name(e.g. test_unicode_exception_messages or test_unicode_handling), and tests unicode handling instead. In general, we should test against the correct behavior, not the current one. That way, tests will still be useful after we fix the bug.\n. Yes, we can copy the decorator to hy._compat.\n. No need to squash them for now.\n. Sort of unrelated to the patch: Is there a way to skip these tests on Python 2? @unittest.skipUnless(PY3) won't work with nose I guess?\n. You could make this a # comment.\n. Please alphabetize imports.\n. Could you delete these empty lines?\n. So matches can be both a list and a dict, right? Could you add a comment about this?\n. Please remove this empty line too.\n. Nitpick: dict() -> {}.\n. Yes, please revert it and squash your commits. Otherwise LGTM.\n. No idea :) I'm not a native speaker. Ping @paultag @cwebber.\n. Ignore my comment, I just saw IndexError :)\n. str -> six.text_type. Did you test it with non-ASCII names? https://github.com/algernon/adderall/ has a couple of examples like flattenrev\u1d52.\n. If you want to check for both str and unicode and to be commpatible with Python 2 and Python 3, you can use isinstance(k, six.string_types).\n. Oh, by the way, we don't use six :)\n. You can add the following snippet to hy/_compat.py:\npy\nif PY2:\n    string_types = basestring,\nelse:\n    string_types = str,\n. We don't need to add six in my opinion. Just add the following snippet to hy/_compat.py and import it from hy._compat import string_types.\npy\nif PY2:\n    string_types = basestring,\nelse:\n    string_types = str,\n. Can we move all these _wrapper[foo] = ... stuff into hy/models/__init__.py?\n. py\nfrom hy._compat import builtins, string_types\n. I'd prefer to split stdlib and hy imports with an empty line.\n. Could you change this to import contextlib and update its usage to @contextlib.contextmanager in line 131?\n. What  does \"pip\" mean here? An executable or a directory?\n. Great! Thanks @algernon.\n. if len(expr) != 2: looks better to me.\n. clj\n. We could turn this to a \"Availability: Python 3\" note like https://docs.python.org/3/library/os.html#os.ctermid\n. Could you add a Python 2 only test to test this behavior?\n. also needs .. versionadded:: 0.10.2 or 0.11 I'm not sure :) ping @paultag @Foxboron \n. Can this be return _type?\n. Thanks for the explanation! I think I should test my suggestions before sending :)\n. > Yeah, I'm OK leaving them in the modules.\n+1 :)\n. Can't we write this like the following\npy\nif k == HySymbol(\"__init__\"):\n    v.append(HySymbol(\"None\"))\nnew_args.append(k)\nnew_args.append(v)\n. I'd also add a test for the actual return value of __init__, but it's not really important (and writing such a test in Hy might be dangerous for your eyes :))\nFor example, in Python:\n``` py\n\n\n\nrepr(A.init(A()))\n'None'\n```\n. Thanks! I just skimmed the PR quickly, but I think we can avoid monkeypatching iter_importer_modules by implementing an iter_modules method in HyFileFinder.\n. Indentation is inconsistent with the rest of the file.. \n\n\n",
    "kirbyfan64": "Doesn't matter anymore: #1279. Can this be closed now?\n. @vodik That's been brought up somewhere else (though I don't recall where). We really need a way to suppress auto returns...\nMeanwhile, I think a good solution would just be disabling auto-returns completely when in a generator.... How the heck did this get closed? @Kodiologist showed other manifestations of this issue that #824 did NOT solve. :(\n. @Kodiologist Well, your second example isn't really an issue; you're supposed to use (setv y (assoc l (f 0) \"A\")).\n. So I think the main issue remaining is just that the mutating operators (+=, -=, etc.) need to return a value.\n. @chr15m Wouldn't that be slower, though? You're copying the entire dictionary to update one key.\nHy has the ability to implement this the correct way, similarly to setv and the try expression.\n. I think I have a really simple solution. Basically, this:\nhy\n(print (assoc d 1 2))\nturns into:\npython\nd[1] = 2\nprint(d)\nand this:\nhy\n(print (assoc (f) 1 2))\nturns into:\npython\n_hy_anon_var_x = f()\n_hy_anon_var_x[1] = 2\nprint(_hy_anon_var_x)\n. After the discussion in #1246 and #1257, I'm going to close this. I don't see it happening now that setv also returns None.. I'm -1 for removing true, false, and nil because:\n1. The argument that \"users of other Lisps will be confused by the behavior of nil\" doesn't matter, since one pretty much always learns Python before Hy.\n2. They look really cool!\nNow, I guess one of None aliases could be removed, since maybe 3 is a bit much...\nBut true and false pretty much don't introduce any confusion, since it's the same word as the uppercase True and False.\n. Yeah, null isn't really used in Python or any Lisp: no objection there.\n. What about making def force its target to always be a global? I never was too fond of:\npython\nglobal x\nx = 1\n. What about making def force its target to always be a global? I never was too fond of:\npython\nglobal x\nx = 1\n. That would also align nicely with the current usage.\n. That would also align nicely with the current usage.\n. Ah, I missed that. :)\n. I thought too...\n. I'm not a Hy developer, but what about something like this:\nclojure\n(my-func :key=value)\nIt looks \"lispier\" that (my-func key=value) and is a tad easier to read than (my-func :key value).\n. If you agree on a keyword argument syntax, I would be happy to open a PR for it.\n. @cwebber I like that, especially since it doesn't really use a new character:\nclojure\n(defn abc [&optional [a 1]])\n& is already used to signify similar concepts. The compiler would just have to only treat it as kwargs when inside a HyExpression.\n. :(. Fixed by stronger error checking in replace.\n. I changed it! If you want, I'll upload docs or something for it, too.\n. Fixed the formatting! Docs are in progress...\n. Added the docs! It should be good to go.\n. It works now! I used a lambda similar to what paultag said: https://github.com/hylang/hy/issues/512.\n. Could you do it? I'm using hg-git, so the instruction are probably completely different.\n. Oh crap...\n. I'll do that tomorrow when I get a chance. Can't there be a private compiler builtin and a public wrapper? i.e. turn apply to apply and add a rendition of the above function.\n. What about a macro?\n. @jakirkham I believe you can do:\nhy\n(setv (cut mylist a b) [1 2 3])\nI do that in HyTest.\n. @jakirkham\nI believe your code is actually compiled to:\npython\na[slice(1, 3):]\nwhich doesn't make much sense. Try:\nhy\n(cut a 1 3)\nTip: whenever something seems odd, use hy2py (given a Hy script, prints the generated Python code) or hy --spy (prints the Python code after everything entered into the REPL). They're super handy for figuring stuff out.\n. To convert a single expression into a Hy quoted expression:\n``` python\nfrom hy.lex import parser, lexer\ndef string_to_quoted_expr(s):\n    return parser.parse(lexer.lex(s))\n```\nFor running the resulting Hy tree, the only thing I could find was hy.importer.hy_eval:\n``` python\nfrom hy.importer import hy_eval\nhy_eval(string_to_quoted_expr('(+ 1 2)'), globals(), '')\n```\n. @algernon: Right...well, technically, if you are evaluating a single expression, you don't need the HyList call, but it does make it safer. Technically, this is still safer:\npython\nres = parser.parse(lexer.lex(s))\nreturn HyList(res if isinstance(res, list) else [res])\n. @algernon Ack...you're right! I had a slightly older version. Whoops...\nI just wish there was a hy_eval_string and a hy_quote_string. hy_eval doesn't even have a docstring, and I can't help but feel like I'm using internal functions that might change in the future.\n. Well, I'm not sure if this helps, but in my project, I used a try...except clause to check if it was installed. Something like this in conf.py:\npython\ntry:\n    import sphinx_rtd_theme\nexcept:\n    html_theme = 'default'\nelse:\n    html_theme = 'sphinx_rtd_theme'\n    html_theme_path = [sphinx_rtd_theme.get_html_theme_path()]\n. @paultag Sure! Just give me a few moments.\n. Check! Adding...\n. Ummm....\n. Will do. Give me a bit; not home right now.\n. Done! Do you want me to squash the commits since they're all ~5 lines long?\n. Done!\n. Actually, I think I completely destroyed the commit history. Would you all mind if I closed this and opened it as another pull request so I can start from scratch(Git-wise)?\n. I re-opened as #570. Closing...\n. ....\n. It actually is. From what it seems, itertools.product == nested for loops. Here's the docstring:\n```\nproduct(*iterables) --> product object\nCartesian product of input iterables.  Equivalent to nested for-loops.\nFor example, product(A, B) returns the same as:  ((x,y) for x in A for y in B).\nThe leftmost iterators are in the outermost for-loop, so the output tuples\ncycle in a manner similar to an odometer (with the rightmost element changing\non every iteration).\nTo compute the product of an iterable with itself, specify the number\nof repetitions with the optional repeat keyword argument. For example,\nproduct(A, repeat=4) means the same as product(A, A, A, A).\nproduct('ab', range(3)) --> ('a',0) ('a',1) ('a',2) ('b',0) ('b',1) ('b',2)\nproduct((0,1), (0,1), (0,1)) --> (0,0,0) (0,0,1) (0,1,0) (0,1,1) (1,0,0) ...\n```\nIt results in nicer code at the expense of not being able to do what you're doing. You can just use nested for loops yourself, though.\nFor reference, here's a comparison of the code generated with 0.9.12 and 0.10.0:\n0.9.12:\npython\ndef _hy_anon_fn_1():\n    for x in [[1L], [2L, 3L]]:\n        for y in x:\n            yield y\n0.10.0:\npython\ndef _hy_anon_fn_1():\n    import itertools\n    for (x, y) in itertools.product([[1L], [2L, 3L]], x):\n        yield y\n. FY, this is related to #634, too.\n. @xcthulhu They actually serve slightly different purposes. hy.contrib.curry lets you create a function that curries itself. defp is for creating a function that returns a function and letting you call the second with the arguments that weren't taken by the first. If you don't mind, I can look into merging the two, adding hy.contrib.curry into the language.hy and macros.hy modules, and documenting it.\n. If this isn't going to be merged, could you let me know so I can close it and delete my fork? I usually like to keep my account free of various forks for projects I contribute to.\n. I'm just going to assume this was a disaster and close it...\n. I was looking into adding a Py.test plugin for HyTest, to support mixed projects. Then I got bored and distracted and forgot all about it...\n. It's also worth noting submodules are usually more trouble than they're worth. Nim recently made the C sources a submodule, only to remove it a few days later.\n. For functions, I was thinking of something like this:\nclojure\n(defn my-func [[a int] [b int]]\n    (print 123)\n)\nBTW, Hy has no way of representing function annotations, does it? If it did, then it could be used on top of mypy.\n. Maybe that same syntax could be used for annotations? That way, people can use libraries like plac from Hy, too.\n. It would be cool but a bit pointless. You wouldn't be able to type-check any code yet.\nWe'd probably have to make a lightweight mypy frontend that compiles Hy files to typed_ast (which is identical to the ast module, but with type comment support).... My one gripe is that now, all my Hy programs have to check the current version and then decide to use either slice or cut.\n. @rcarmo You could always use setv as a workaround. Or:\nhy\n(defmacro multi-setv [&rest args]\n  `(do\n    ~@(map (fn [[a b]] `(setv ~a ~b)) (zip (slice args nil nil 2) (slice args 1 nil 2)))))\nWhich would let you do:\nhy\n(multi-setv [x-inc (+ width spacing)\n                   y-inc (+ height spacing)\n                   ...])\n(continue work here)\n. I'm seriously saying: just dump this form of let and compile down to a try...finally block.\n. @paultag Try putting del x in the finally block.\n. @paultag Like:\npython\ntry:\n    a = 5\nfinally:\n    del a\nprint a\n. @paultag Well, one could do something like:\npython\ntry:\n    try:\n       _some_magic_symbol = a\n    except:\n        _a_present = False\n        _some_magic_symbol = None\n    else:\n        _a_present = True\n    a = 123\nfinally:\n    if _a_present: a = _some_magic_symbol\n    else: del a\n    del _some_magic_symbol\n    del _a_present\n. There are a bunch of let-related issues open right now. I think we should probably make a new issue that condenses a TL;DR of each of these in order to clean up the issue tracker a bit.\n. This might be useful. I'm working on a PR that would implement it.\n. @Foxboron But changes to locals aren't guaranteed to have any effect.\n. This is actually a bug in Python 2.7. See Issue 22530 and the mailing list thread I started.\n. This has been fixed in the Python source repo.\n. Aw, man.\n. I just tested Hy master with PyPy master (2.5 alpha, compiled yesterday) and all the tests pass. Could this be a Travis issue?\n. This is a PyPy issue; a version compiled from tip works, while the 2.4 binaries segfault. In the meantime, you could always explicitly check if PyPy is running the tests (python --version | grep PyPy) and, if so, manually download the nightly builds and use those instead.\n. 2.4 segfaults, tip (2.5) doesn't. I'm going to open a PR that downloads a custom version of PyPy until this gets fixed. I also contacted the PyPy mailing list to see if they know anything.\n. But that defeats the purpose of having PyPy in the tests to begin with.\n. @paultag No, I did a development build of tip. No special config options. Works fine. A pre-built PyPy 2.3 and PyPy nightly work fine. Pre-build PyPy 2.4 fails. It probably isn't config options.\nI'm working on a fix using the Makefiles. It's messy, but it looks like it might work.\n. @berkerpeksag That's my fault. I shouldn't have used the nightly builds. PyPy has a \"push then fix\" mentality. I'm opening a PR to fix this.\n. See #726.\n. MOVE IT, DON'T DELETE IT! PLEAASEE!!!!\n. @Foxboron Seriously...\nI just fixed the issue. Flake 8 passes now.\n. @paultag In Python 3, unless you put raise ... from None, it will print the \"During handling of...\" thing. Earlier versions of Python don't support the syntax, so I had to do the exec hack in _compat.py.\n. I can't reproduce the PyPy errors. Can anyone else figure out what's going on?\n. Now the tests are failing for a completely different reason. Looking into it...\n. Seriously...I'll probably have to finish tomorrow. CURSE YOU, TRAVIS!!! At least it doesn't segfault...\n. Looks like it works! Now's to squash (and probably open a new PR since I never squash correctly...)!\n. Replaced by #682.\n. No positive comments? Come on, it took me half the day yesterday to do this!\n. Done.\n. What about 2 versions of let? Right now, another thing bugging me is the stack traces:\nhy 0.10.1 using CPython(default) 2.7.6 on Linux\n=> (let [[x \"abc\"]] (raise (ValueError x)))\nTraceback (most recent call last):\n  File \"<input>\", line 1, in <module>\n  File \"<input>\", line 1, in _hy_anon_fn_1\nValueError: abc\n=>\nThose _hy_anon_fn_1's in the stack traces are bugging me and can be annoying, especially in unit tests.\nUsing something like try could also potentially be faster.\n. @gilch With all those restrictions, though, this'll probably end up just as confusing as what's there right now...\n. But you still have lambda arguments to worry about...\nI wasn't in favor of it before, but now I'm starting to agree that removing let may be a good idea.\n. hy\n(let [x [1 2 3]]\n  (map (fn [x] (inc x)) x))\n. @davexunit Because of Python 2's variable scoping:\nhy\n(defn outer []\n  (setv x 1)\n  (defn inner []\n    (setv x 2))\n  (inner)\n  x)\n(outer) ; returns 1, NOT 2\n. Not going to work out. Closing.\n. If you just want to check for syntatical/macro errors:\n$ alias hycheck=\"python -c \\\"import hy.lex, hy.compiler, sys; hy.compiler.hy_compile(hy.lex.tokenize(sys.stdin.read()), '__console__')\\\"\"\nFrom then on, you can just do:\n$ hycheck < myfile.hy\n. What happens is that, when you receive \"GET\" as an argument, it's a HyString with a special replace method. When you use the map, you have regular strings, so everything gets goofed up. Change the macro to:\nhy\n(defmacro def-trello-method [methodname path verb other-verb]\n  (import [hy.models.string [HyString]])\n  (setv http-method (get {:get \"GET\" :post \"POST\" :put \"PUT\" :delete \"DELETE\"} verb))\n  (quasiquote (setattr Hyello ~methodname (fn [self] (self.execute ~path ~(HyString http-method))))))\nNotice that I'm importing HyString and converting http-method to a HyString.\nHonestly, I kind of wish that Hy checked the types of objects with an assert before calling replace on them, to prevent weird, uninformative errors like this.\n. Fixed. Forgot which PR, but this now throws a sane error.\n. If I may be crazy...what's the status of something like #740? I'd implement it, but no one said anything...\nIt would be nice to have before any breaking changes/more additions!\n. This would also be consistent with for loops. \n. +1 Pytest is much nicer than nose (which isn't even a test framework).\n. Would adding assoc to hy.core.shadow work?\n. @paultag Actually, it doesn't work. I just tried. Same error appears. Here's the change:\n``` diff\ndiff --git a/hy/core/shadow.hy b/hy/core/shadow.hy\nindex e68c4ec..8f4b7f3 100644\n--- a/hy/core/shadow.hy\n+++ b/hy/core/shadow.hy\n@@ -60,5 +60,9 @@\n         (operator.truediv 1 (get args 0))\n         (reduce operator.truediv args)))))\n+(defn assoc [seq key value]\n+  \"Shadow assoc for when we need to import / map it against something\"\n+  (assoc seq key value))\n-(setv exports ['+ '- ' '/])\n+\n+(setv exports ['+ '- ' '/ assoc])\n```\nUsing 'assoc instead of assoc doesn't help, either. What's wrong?\n. @paultag https://github.com/kirbyfan64/hy/tree/shadow_assoc\n. @paultag But...\n```\nryan@DevPC-LX:~/stuff/hy4$ python -c \"import hy.cmdline; hy.cmdline.hy_main()\"\nhy 0.10.1 using CPython(default) 2.7.6 on Linux\n=> (apply assoc [{} \"a\" 1])\n  File \"\", line 1, column 8\n(apply assoc [{} \"a\" 1])\n         ^----^\nHyTypeError: `assoc' needs at least 3 arguments, got 0.\n=> \n```\nthe issue still isn't solved.\n. @paultag How is that cloned? I tried:\ngit clone https://github.com/paultag/hy.git -b bugfix/fix-apply\ngit clone https://github.com/paultag/hy.git -b fix-apply\ngit clone https://github.com/paultag/hy.git -b bugfix\n. @paultag Got it! It works! Do you want me to merge it into the changes I made and open a PR?\n. Calling a Git-savvy user...\nI can't find this branch. At all. Is there a reason a branch wouldn't appear with git branch -va?\n. @zackmdavis I had it as a remote, but I didn't think about running git fetch. That did the trick. Thanks!\n. FYI, would this remove the ability to pass symbols preceded with a colon to macros? Or does this just affect function calls?\n. Pretty sure this can be closed now.\n. Can this be closed now? Evidently, this did not go well...\n. @algernon Same here. I'm indifferent either way. In Lisp languages, explicit returna are rarely used anyway, since you break up problems into smaller functions.\n. @gilch Huh...That's an interesting idea.\nI'm personally torn. On one hand, implicit returns are awesome. On the other hand, they do have problems like you said.\nOne idea could be to make returns explicit inside a generator and make a clear distinction via defgn/gn like you said in another issue. Problem? It still doesn't account for the whole __init__, and defining context managers via decorators would be a pain in the neck.\n. :+1: for @gilch's latest idea!\n. I'm probably just going to implement this and open a PR, then you guys can discuss it there, considering the fact that I opened this 7 months ago and there's only 1 comment...\n. Last time I tried hdb, it removed the concept of newlines from my terminal. And crashed.\nI rarely use debuggers; I only touch them when doing assembly programming. Usually, I just shove print calls everywhere.\nAlso, my best friend while writing HyTest and Hyskell has been hy2py. It really helps.\n. @cwebber I put the (assert 0) in this file right before line 323.\n. HA! FIGURED IT OUT! (Not really, but close.) Here's a simple shell script that can be used to figure out line numbers. See here. Basically, if you get a crazy ridiculous line number, the real line number can be found using:\ncrazy_line - (crazy_line / 256 * 256)\nwith integer division. Then find:\ncrazy_line + 256*0\ncrazy_line + 256*1\ncrazy_line + 256*2\n...\nuntil the number being added to crazy_line is greater than the number of lines in the file.\n. What happens is that Hy expects you to only subsitute in a Hy model into a macro. Every Hy model has a method named replace that handles line numbers. When Hy encounteres the nil value, it assumes it's a model and still calls replace on it.\nThe solution? Set the parameter's default value to `nil.\n. Fixed by https://github.com/hylang/hy/commit/2375392962760c621342106c68208256ec221136.\n. IMO, couldn't the macros be in the rST file with all the other macros?\n. RPython doesn't support the print function; it only supports the print statement.\nAlso, I would just advise you don't use Hy with RPython. There are so many restrictions that there's bound to be other conflicts, probably with Hy's aggressive iterator usage (e.g. using itertools' i* functions.\nI don't think RPython would play nicely with Hy's use-anything-as-an-identifier ability, either.\n. Idea: add a print2 function. It would only compile under Python 2 and would represent an actual print statement.\n. Because the Python version of Hy code isn't always syntactically valid.\n. What about writing it in a subset of Hy that compiles down to normal Python code? For instance, this:\nhy\n(def + 1)\nwould generate wrong Python code when given to hy2py but this:\nhy\n(def x 1)\nwould work. Then the generated Python source files could be distributed with the Hy source.\n. Should this be closed now?\n. I'm slightly curious as to why you're overriding built-in Python functions. That's almost never, ever a good idea. Would it kill you to import it as cmap (for \"curried map\")?\n. Can this be closed now? This actually works in actual programs.\n. @gilch Two ideas:\n- \"Magic\" imports could add a check first:\n``` python\n  # before\n  from hy.core.language import map\n# now\n  try:\n      map\n  except NameError:\n      from hy.core.language import map\n  ``\n1. My preferred solution: import everything fromhy.core.language` on REPL start and tell the compiler to not insert any imports in the REPL. Remember, this is only a problem in the REPL; in normal scripts, the functions are imported at the top of the file, so any other imports override them anyway.\n. This is pretty simple to implement yourself:\n``` hy\n(import [hy.models.symbol [HySymbol]] [hy.models.list [HyList]])\n(defmacro fnd-base [inv ext args body]\n  (setv skipx false)\n  (setv argr [])\n  (for [arg args]\n    (argr.append arg)\n    (when skipx\n      (setv skipx false)\n      (continue))\n    (when (isinstance arg HySymbol)\n      (setv skipx true)\n      (continue))\n    (when (isinstance arg HyList)\n      (setv oldarg arg)\n      (setv arg (gensym))\n      (assoc argr (dec (len argr)) arg)\n      (setv body (+ [(setv ~oldarg ~arg)] body))))(~inv ~@ext [~@argr] ~@body))\n(defmacro fnd [args &rest body]\n  `(fnd-base fn [] [~@args] [~@body]))\n(defmacro defnd [name args &rest body]\n  `(fnd-base defn [~name] [~@args] [~@body]))\n```\nPop it into a file named fnd.hy and use it like so:\n``` hy\n(require fnd)\n; fnd instead of fn\n((fnd [[x y]] (print x y)) [1 2])\n; defnd instead of defn\n(defnd myfunc [[x y]]\n  (print x y))\n(myfunc [1 2])\n```\n. #793\n. @jaredly @paultag That's Python 2-only. It was removed in Python 3. See PEP 3113.\nI could add a Python 2-only one, but it'd be kind of useless and put little gain, IMO.\n. Commits squashed and ready for merging!\n. @berkerpeksag Fixed. I guess that's what I get for not running the tests myself...\n. Let's try this again...\nCommits squashed and ready for merging! :|\n. Bump...\n. @paultag I lost you...could you try to say all that again?\n. @paultag \n\nThe generated AST has a stray [x, y], which I'm assuming is for expr-asignment on the code-branch in the fn. I think if we use the Result object, and let the as_expr handle the return, that block won't result in the code branch.\n\nSorry, I'm a newbie to the Hy world. The last 10 times I toyed with the compiler, I broke completely unrelated things in the process somehow.\nI think it might be this code:\npython\nexpression = HyExpression([\n    HyExpression([\n        HyString(\"setv\"), arg, var\n    ])]\n) + expression\nIt's definitely something here...but I don't know what. Maybe my use of two nested HyExpressions is causing it to do that?\n. @paultag Also, doesn't that happen anyway with assignments:\nryan@DevPC-LX:~/bfort$ hy --spy\nhy 0.10.1 using CPython(default) 2.7.6 on Linux\n=> (defclass X [] [])\nclass X:\n    pass\n=> (fn [] (setv a (X)) (setv a.a 1) (setv a.b 2))\ndef _hy_anon_fn_1():\n    a = X()\n    a.a = 1L\n    a.a\n    a.b = 2L\n    return a.b\n=>\n. Bumpza!\n. ???\nIf you're referring to getting the numbers from 0 to 4, just use (range 4)...\n. @paultag Yeah, you're right; Clojure's range is an infinite stream of numbers. I've never used Clojure, so I misunderstood the statement.\n. The reason is that macros get expanded before the program is run. Therefore, the exception occurs before the program even begins.\n. You should mention that this is Python 3-only.\n. @wuxianliang It doesn't need to be a keyword:\nhy\n(defmacro defn-jit [&rest args]\n  `(with-decorator jit (defn ~@args)))\n. Why doesn't the message show the bad keyword argument anymore?\n. Heh, I actually tried this once in Python 2 and 3. The main issues stemmed from two things:\n1. Sometimes you actually don't want a variable to be nonlocal.\n2. Being a dynamic language, Python makes it a pain to do analysis like this. It's definitely possible, but there are many, many corner cases.\n. @olasd Well, it doesn't wrap everything. Just when one of the sides is a statement.\nOf course, if Python 2 had nonlocal, I could just do what @paultag said and aggressively nonlocal everything.\nIMO, the issue with things as they stand is when macros get involved. This:\n(and 0 (abc))\ncould be bad if abc is a macro that returns a series of statements, and the results would be even more surprising. Even though this only fixes part of the issue, it's better than the current state.\n. @gilch I can try updating the PR with that.\n. @paultag @gilch @olasd All complaints/issues fixed! Short-circuiting operations are now compiled into if-else branches. Example:\nryan@DevPC-LX:~/stuff/hy$ hy --spy\nhy 0.11.0 using CPython(default) 2.7.6 on Linux\n=> (print (and (setv a 1) (setv a 0) (setv a 1)))\na = 1L\n_hy_anon_var_1 = a\nif _hy_anon_var_1:\n    a = 0L\n    _hy_anon_var_1 = a\n    if _hy_anon_var_1:\n        a = 1L\n        _hy_anon_var_1 = a\nprint(_hy_anon_var_1)\n0\n=>\n. @gilch Done. :) (Note that the apparent presence of 3 commits is just GitHub getting confused by a rebase; I referenced this PR instead of the issue you opened.)\n. @gilch I prefer using both false and nil as falsey values. Having (and) return true but (or) return false feels weird, IMO.\nOf course, if anyone objects, feel free to mention it. :)\n. @glich You're right; I said it backwards. I meant that having (or) return nil seemed weird.\nThen again, every other Lisp does this, so I should probably just use nil.\n. @gilch Fixed.\n. @gilch I produce the same AST as an elif statement produces. That's actually an issue with the prettt printer hy2py uses, not this itself. To Python, this:\npython\nif a: b\nelif c: d\nis the exact same thing as:\npython\nif a: b\nelse:\n if c: d\nThen again, I tested it with Python 2. Does Python 3 have an explicit node for elif clauses?\n. If there are no more objections, I can squash this now.\n. Uhhh...I tried to squash it...and I think I messed something up...\nI love Git. But I hate it. Is this even mergeable now?\n. @Foxboron It worked!!!! Thank you!!! I'll remember git cherry-pick next time a freak accident like this happens.\nThe exact commands I ran were:\ngit checkout -b short-circuit2\ngit cherry-pick b131500a53d80514b655258031b263ee8cf7a501\ngit cherry-pick d6c1b72a54e47e6293015dffb603f6d61014f0a8\ngit push -f fork short-circuit2:short-circuit\nNow it's ready!\n. What I'm envisioning (here I'm going to use \\ for a fraction literal):\nhy\n(/ x) => (/ 1 x) ; reciprocal, like K\n(\\ x y) => (Fraction x y)\n(\\ y) => (Fraction 1 y)\n. @paultag \n\nI'm mostly worried about how this interacts with code that expect a Long or\nsomething.\n\n?? I'm not quite sure why (= (/ 2) 0.5) would cause any more trouble with longs than Python 3's float division. Or are you referring to something else?\n. @gilch @paultag Ah! I personally do not like \\; I was just using as an example. :)\n. Taking a stab at this: do you guys want a model for this (e.g. HyFraction) or just return a HyExpression that constructs a fraction from t_identifier?\n. Done. #829.\n. @danceasarxx You need to install the development version from Git in order to use set literals:\n$ pip install git+https://github.com/hylang/hy.git. @Foxboron I knew I forgot something!\n. Now everything's good!\n. Was there anything else that needed to be addressed? I'd try resolving the merge conflicts, but, considering how the last time I tried that went, I doubt that would be a good idea...\n. @zackmdavis Well, if you're already going through the pain^H^H^H^Hawesomeness of git rebase, you might as well squash them all into one commit. ;)\nOf course, I can just do it myself later, too.\n. Squashed and rebased!\n. @Foxboron Where?\n. @Foxboron Fixed.\n. @Foxboron Yeah, I just noticed. :O I did put a test in test_lex.py.\n. @Foxboron Actually, is a test in tests/models really necessary? I mean, unlike HyDict, HySet adds no new methods to be tested. It's just a (sorted) HyList.\nI also realized that Python 2.6 has no set literals, so I have to work around that.\n. YESSS!! THE TESTS PASS!\n. Bump?\n. @zackmdavis Squashed.\n. @paultag @berkerpeksag Fixed.\n. @gilch Well, the bug isn't too high-priority, considering it only really affects the REPL.\nAlso, it's not your writing style. There were bugs that I opened a year ago that only got fixed recently. I actually kind of like the way you put the part that shows the REPL issue with raw strings. :)\n. @gilch Huh..interesting...\nI should take a look.\n. I think the issue stems from the fact that string? is just a normal function:\nryan@DevPC-LX:~$ hy\nhy 0.10.1 using CPython(default) 2.7.6 on Linux\n=> string?\n<function is_string at 0x7fc6555f0de8>\n=>\nAnd HyKeywords are converted to Unicode:\n=> :abc\nu'\\ufdd0:abc'\n=>\nSo you're really calling string? on a string with a technically invalid Unicode character.\n. #725 should fix this; I need to figure out why the tests were failing.\n. Well...\n1. If assoc returned a new dict, I would be mad. Issue is that Hy <=> Python.\n2. I believe this would be partly fixed by #725?\n. @paultag I have a fix \"ready\" here, but it's giving a really weird error:\nryan@DevPC-LX:~/stuff/hy$ ./run\nhy 0.11.0 using CPython(default) 2.7.6 on Linux\n=> (setv x {})\n=> (assoc x 2 2)\nTraceback (most recent call last):\n  File \"<input>\", line 1, in <module>\n  File \"/media/ryan/stuff/hy/hy/core/language.hy\", line 301, in assoc\n    (is x None))\nNameError: global name 'v' is not defined\n=> \nryan@DevPC-LX:~/stuff/hy$\nThis is what hy2py outputs for hy/core/language.hy:\nhy\ndef assoc(tgt, *args):\n    if (not is_even(len(args))):\n        raise TypeError(u'expected an even number of key-value pairs')\n        _hy_anon_var_2 = None\n    else:\n        _hy_anon_var_2 = None\n    it = iter(args)\n    for [k, v] in zip(it, it):\n        tgt[k] = v\n    return tgt\nIt looks like it should work. What's wrong?\n. @paultag https://github.com/kirbyfan64/hy/blob/7eb1353e09aca6db78223e828b741bbe8b293e01/hy/core/language.hy#L40:\nhy\n(defn assoc [tgt &rest args]\n  (if (not (even? (len args)))\n    (raise (TypeError \"expected an even number of key-value pairs\")))\n  (setv it (iter args))\n  (for [[k v] (zip it it)]\n    (assoc* tgt k v))\n  tgt)\n. I'm toying with just fixing up ifs to avoid useless assignments.\n. @gilch Seems like this was broken by #962 (in f4afb0ca7efd76cb3bc4a99bc3c719c1ef96584a)...still investigating further.. Actually, no. When the compiler looks at the code, it's unexpanded, so it needs to now be checking for if and if*.. AFAIK cond uses if, so it's just the same core issue.\nIMO I wouldn't find moving if into the compiler. I was toying with a rewrite of if that used reductions instead of recursion, but it was kind of confusing and IMO wasn't worth the pain.. So does this mean Hy no longer supports 2.6?\n. @paultag Hahaha, I hate 2.6 just as much as everyone else. :O\nI was just curious because I had to add an explicit call to make set literals work on 2.6 so the tests could pass.\n. > we wouldn't have to port nonlocal to Python 2.\nI feel like that'll end up being necessary regardless...\n. First, can I try implementing a better version. If that fails, then deprecation is an option. How does that sound?\n. I think you guys keep forgetting that you can implement let via a try...finally block with completely normal, not-crazy semantics. I've been working on it. The reason people using Python don't do that is simply because it would take more typing than it's worth. But, this is Hy. Which means there are macros!\n. @gilch I got around that, too. Just requires a little more boilderplate.\n. Is there a reason we can't just make it a compile error to use keywords outside of a keyword context or macro? IMO I really can't think of a major use case for them that wouldn't be complicated by their existing usage.. @gilch @algernon Test added (to same commit: no squashing needed).\n. This, along with #850 and #852, is going to break a lot, including quite a bit of my own code (which is probably going to be affected more by #850).\nI would really like something like #740 in before this happens.\n. But right now for let's you do the Cartesian product:\nhy\n(for [a x b y]\n    ...)\nI totally agree with the implicit do, though. Drives me nuts.\nAlso: is there a reason we need do notation for cond:\nhy\n(cond\n    [b (do ...)])\nI mean, is there a reason why I can't put more than one expression in a branch body without do? That also drives me crazy, and, after looking through Hy's code, I see no reason why.\n. Ack, I skewered my history again. Hold on...\n. All fixed!\n. @gilch Fixed.\n. But list comprehensions already have the Cartesian product:\n``` python\n\n\n\n[(x, y) for x in [1,2,3] for y in [4,5,6]]\n[(1, 4), (1, 5), (1, 6), (2, 4), (2, 5), (2, 6), (3, 4), (3, 5), (3, 6)]\n```\n\n\n\nHaving a multi-argument for that does the same thing seems more consistent, and having it use zip is just confusing.\n. There's an easy way: add something like:\n(python-code print(1, 2, 3))\nPython code needs to follow matching brackets and such anyway.\n. Wow....I love this! Question: should there be an optional boolean argument that determines what to do with the rest of collection? For instance, name it rem and, if true, have it return two arguments, the second being the remnant?\n. I like the idea...\n...but doesn't Hy already have enough syntactic sugar (e.g. lambda vs fn, 'defunvsdefn`, etc.)?\n. > Removing stuff seems a lot easier than adding it.\nNot really. Once you add it, there's a good chance that removing it will break code. Of course, Hy is still in beta, so code breakage is \"technically\" ok, but it should still be avoided when possible.\n. Also, one person said this about Clojure's lambdas:\n\nAs much as I love Clojure I have to say, that\u2019s an ugly lambda. It looks like a child mashing the top row of the keyboard.\n\n:/\n. I just feel like you save just a few characters for little benefit, and it's harder than it looks to compile. You can't just recurse through the AST:\nhy\n(,\\ (x ,1 (,\\ ,2))) ; (fn [a] (x a (fn [_ b] b)))\n(,\\ (,\\ (,\\ ,3))) ; (fn [] (fn [] (fn [x] x)))\nAlso:\n\nYes, and Java's tedious verbosity is made much more tolerable with a good IDE.\n\nVery true (I hate Java :). However, then you also have the APL extreme, which produces an insanely weird programs, like (in K):\n/ reads a number from input and prints its factorial\n`0:$*/1+!0$0:`\nLanguage design is all about compromise, really.\n. Just to say: I like having both def and setv: the former is primarily used for globals, and the latter for locals.\n. You know both examples are invalid, right? (Try running them through hy2py.) ;)\nAlthough the idea is neat, '() doesn't go nicely with most Python libs, and I don't really like if now returning '(). Feels kind of out-of-place.\nThe main thing I love about Hy is that it's ultimately Python, not Lisp. This doesn't really feel too Pythonic...\n. What version of Python do you have?\n. Try deleting your folder containing Hy and re-cloning it.\n. On Python 2, the error is:\nTraceback (most recent call last):\n  File \"hy/compiler.py\", line 2529, in hy_compile\n    result = compiler.compile(tree)\n  File \"hy/compiler.py\", line 432, in compile\n    ret = self.compile_atom(_type, tree)\n  File \"hy/compiler.py\", line 424, in compile_atom\n    ret = _compile_table[atom_type](self, atom)\n  File \"hy/compiler.py\", line 623, in compile_raw_list\n    ret = self._compile_branch(entries)\n  File \"hy/compiler.py\", line 488, in _compile_branch\n    return _branch(self.compile(expr) for expr in exprs)\n  File \"hy/compiler.py\", line 316, in _branch\n    results = list(results)\n  File \"hy/compiler.py\", line 488, in <genexpr>\n    return _branch(self.compile(expr) for expr in exprs)\n  File \"hy/compiler.py\", line 444, in compile\n    raise_empty(HyCompileError, e, sys.exc_info()[2])\n  File \"hy/_compat.py\", line 66, in raise_empty\n    raise t(*args)\nHyCompileError: Internal Compiler Bug \ud83d\ude31\n\u2937 SyntaxError: invalid syntax (<string>, line 1)\nCompilation traceback:\nFile \"hy/compiler.py\", line 432, in compile\n    ret = self.compile_atom(_type, tree)\n  File \"hy/compiler.py\", line 424, in compile_atom\n    ret = _compile_table[atom_type](self, atom)\n  File \"hy/compiler.py\", line 1935, in compile_expression\n    expression = macroexpand(expression, self.module_name)\n  File \"hy/macros.py\", line 147, in macroexpand\n    tree = macroexpand_1(tree, module_name)\n  File \"hy/macros.py\", line 170, in macroexpand_1\n    m_copy = make_emtpy_fn_copy(m)\n  File \"hy/macros.py\", line 132, in make_emtpy_fn_copy\n    empty_fn = eval(fn_str)\n. Found out the issue:\n```\nryan@DevPC-LX:~/stuff/hyg$ git bisect bad\nf18007955dfa5fe294883159a4b7835bb2aa2252 is the first bad commit\ncommit f18007955dfa5fe294883159a4b7835bb2aa2252\nAuthor: Adam Schwalm adamschwalm@gmail.com\nDate:   Sun Aug 30 13:14:16 2015 -0500\nBetter error messages on invalid macro arguments\n\n:040000 040000 2e790e21a05e3bee2c469bf5fb692ee29c883f66 d6d9afab796071735ad03b8a582380161a38fffd M  hy\n:040000 040000 d54507c2031419361d99c258395d8bd4f28cbfbb c1ba372f55127e1014b444ea8b58ec7633d64704 M  tests\nryan@DevPC-LX:~/stuff/hyg$ \n``\n. https://github.com/hylang/hy/commit/f18007955dfa5fe294883159a4b7835bb2aa2252\n. @gilch Yup.\n. Got a working patch. Opening a PR...\n. @gilch It's not the string that's the issue.getargspecdoesn't like the callable it's being passed.\n. @gilch #956\n. @gilch Does #989 fix it? If so, I can try rebasing it and getting it ready to merge again (even though I never figured out what was really going on...).\n. @gilch Does #989 fix it? If so, I can try rebasing it and getting it ready to merge again (even though I never figured out what was really going on...).\n. I like the alternative better. :) I was never much of a fan of Python's uppercaseTrueandFalse.\n. I'm on the same side as @olasd.\n. Well, the error could be a bit nicer (!), but the reason is simple. Hy automatically converted the list returned fromlist-compinto aHyList` model. It doesn't know how to do that with generators and therefore proceeds to explode. :)\n. I prefer being explicit here. It's happened to me before where I passed the wrong type that happened to be an iterable to an API that implicitly converted it to a list.\n. The assertion in proposal 2 should be a runtime assertion, IMO. It could be compiled to:\nhy\ntry:\n    foo\nexcept NameError:\n    foo = 'footwo!'\nelse:\n    # error\nAlso, what about the proposal for def always making the target global?\n. I had proposed that already, but it broke in the case of closures, e.g.:\n```hy\n(defn f []\n  (let [x 1]\n    (fn [] x)))\n((f))  ; ERROR: x was deleted when f ended\n```. Would it really help that much? IIRC the result of macroexpand is already formatted correctly, it's just a pain in the ass to read.. @gilch Done.\n. So, I feel really stupid right now, because in the original comment I wrote:\n\nThis took me a whole 60 minutes!!\n\nIt was supposed to be a joke; I meant to write:\n\nThis took me a whole 60 seconds!!\n\nMy programming skills aren't awful enough to make this take an hour... :(\n. Bump? I would've thought @gilch would like this.\n. Rebased and ready to merge!\n. Uhhh...I have no clue what those test failures are. They have nothing to do with this PR!?\nAnyway, I already have what @gilch just described in working form, so I can commit it if you want. :)\n. Well, it should work, but now some completely unrelated mathematics test is failing? Because that makes perfect sense...\n. ...more freaking test failures. Turns out, eliminating if True and if False branches is surprisingly difficult...\n. Ok; now all the tests pass!! :D\n. I think the first error is referring to:\nhy\n(defmacro macro-error [location reason]\n  \"error out properly within a macro\"\n  `(raise (hy.errors.HyMacroExpansionError ~location ~reason)))\nhy is ending up as None for some reason...I think...\n. The error's the same in the REPL (although it's admittedly much prettier):\n```\nryan@DevPC-LX:~$ hy\nhy 0.11.0 using CPython(default) 2.7.6 on Linux\n=> (defn + [] 0)\n  File \"\", line 1, column 7\n(defn + [] 0)\n        ^^\nHyTypeError: Can't assign to a builtin: `+'\n=> \nryan@DevPC-LX:~$ \n``\n. @tmbdev This is known and intentional.hy2pyis really just a debugging tool (which is really handy when writing macros).\n. Whenever someone introduces a PR to make the macro errors better, I hear angels singing.\n. Yeah, this was entirely my fault. Up till then, I had used C++ and Haskell more than Python (even though that's changed), so I never realized thatmapalready took multiple iterables. (And I'm guessing the people that liked thezipwithPR didn't realize it either...)\n. Doesn't IPython also do this? I have anipython3` on my computer.\nI have to like this idea. It seems fine but gets REALLY irritating when you need to run Hy with the separate Python versions. I have both 2 and 3 (Anaconda) installed, so I tend to greatly appreciate the projects that care of this for me. :)\n. (BTW, has anybody else noticed that I tend to do the PRs that are insanely controversial?? :D )\n. Bump?\n. There are other ways to have nonlocal on Python 2: http://code.activestate.com/recipes/578965-python-2-nonlocal/.\n. @gilch \n\nUnderstanding that link will take some more study, but it looks like those decorators are rewriting the Python bytecode.\n\n...did you even read the description? :D\n\nWill the bytecode approach still work in PyPy?\n\nYes.\n. I seriously doubt that eithee Shedskin or Cython would work: the former is very, very restrictive; and the latter, I believe, uses a custom parser.\n. Doesn't Python 2 still use the other octals though: http://stackoverflow.com/questions/11620151/what-do-numbers-starting-with-0-mean-in-python.\n. @paultag I was using that as an example to why it should be documented. :)\n. GitHub's Linguist uses a submodule pointing to language-hy...which hasn't been updated in almost a year...\n. Maybe hylang could maintain a custom fork of language-hy?\n. @gilch is right. Try grabbing Hy from master or using the docs for 0.11.\n. @gilch is right. Try grabbing Hy from master or using the docs for 0.11.\n. Is this really worth it? Python has some pretty scoping rules, and there are half-a-dozen wrong ways to do this.\n. @gilch Well...I was referring to the idea of an intern function, not what you had posted above. ;)\nDoes checking the caller's scope like @paultag showed work with nonlocals? Otherwise, this is pretty much dead. Note that @paultag's approach would probably cause issues with globals and things like:\n``` hy\n(defn f []\n  (setv a 1)\n  (g))\n(def a 2)\n(defn g []\n  (intern :a)) ; Will pull f's a instead of the global one!\n```\nA simpler solution could potentially be:\n(defn intern [sym]\n  (setv frame (-> (inspect.stack) (cut 1) (get 0)))\n  (setv scope (frame.f-globals.copy))\n  (scope.update frame.f-locals)\n  (-> sym str (scope.get)))\nNot sure how this works with nonlocals.\n. I still think the reader macro looks a tad uglier...\n. Still not a syntax fan, but it'd probably be pointlessly stupid to argue further, since my suggested syntax would require more special-casing. Closing!\n. The same error was occurring before, but it was being ignored for some reason.\n. @paultag or another organization member can go to the Admin tab of the Hy RTD page and, in Advanced Settings, change the path to requirements.txt.\n. IMO, the warning should only be inserted if the identifier ends up in the actual generated Python, as this might be wanted for some sort of DSL or something.\n. @tuturto @gilch Please try this!\n. (FYI, this doesn't work with Python 2 yet, hold on a sec...)\n. Ok, now it works with Python 2.\n. @gilch @tuturto Fixed. Git screwed my commit history so it doesn't appear correctly on GitHub...but, other than that, the actual code works.\n. Hmm...this is a GitHub issue. It's showing up correctly in my Git history...\n. @gilch Uhh...this is weird...\nI can't reproduce the original issue anymore, even without the try...except clause. I'm guessing it was something to do with the string eval?\nCould you try merging my branch with your defmacro! branch and see if the original issue is still there?\n. @gilch Uhh...this is weird...\nI can't reproduce the original issue anymore, even without the try...except clause. I'm guessing it was something to do with the string eval?\nCould you try merging my branch with your defmacro! branch and see if the original issue is still there?\n. ...and this got killed. Hold on...\n. @gilch Done.\n. @zackmdavis git pull --rebase origin master...\nI think it should still merge cleanly, though. Or at least GitHub says it's even with master. I think the duplicated commits are just a GitHub issue with showing rebased commits.\n. @zackmdavis Oh well. I'll just open another one...\n. I would say that macros should simply not allow &kwonly, since a lot of macros (including several of my own!) rely on :x being passed as a symbol model.\n. @gilch #960\n. BTW, is there a way to test this? I looked in the tests, but it seems there are no tests for anything like this...\n. @gilch Test added.\n. @gilch Test added.\n. @gilch But &optional and &key work as expected with macros:\nryan@DevPC-LX:~$ hy\nhy 0.11.0 using CPython(default) 2.7.6 on Linux\n=> (defmacro x [&optional v] (if v `\"v was given\" `\"v was not given\"))\n^[[\nryan@DevPC-LX:~$ hy\nhy 0.11.0 using CPython(default) 2.7.6 on Linux\n=> (defmacro x [&optional v] (if v `\"v was given\" `\"v was not given\"))\n=> (x 1)\nu'v was given'\n=> (x)\nu'v was not given'\n=> (defmacro y [&key {\"v\" nil}] (if v `\"v was given\" `\"v was not given\"))\n=> (y 1)\nu'v was given'\n=> (y)\nu'v was not given'\n=> \nryan@DevPC-LX:~$\n. @gilch But I did add &kwargs.\nTell me when to squash the commits!\n. @gilch Fixed. I also squashed the commits.\n. @gilch Fixed.\n. @gilch Done.\n. > there are no examples\nUhhh...\nhttp://docs.hylang.org/en/latest/tutorial.html\nBasically:\nhy\n(defn func [&key {\"a\" \"b\" \"c\" \"d\"}] (+ a c))\nis the same thing as:\nhy\n(defn func [&optional [a \"b\"] [c \"d\"]] (+ a c))\n. Outside of the realm of documentation: is there a reason &key allows anything other than identifiers in the mapping? For instance:\n```\nryan@DevPC-LX:/media/ryan/stuff/hy$ hy --spy\nhy 0.11.0 using CPython(default) 2.7.6 on Linux\n=> (defn func [&key {1 \"b\"}] (+ 1 2))\ndef func(1=u'b'):\n    return (1L + 2L)\n=> (defn func [&key {a \"b\"}] (+ 1 2))\ndef func(a=u'b'):\n    return (1L + 2L)\n=> \nryan@DevPC-LX:/media/ryan/stuff/hy$ hy --spy\nhy 0.11.0 using CPython(default) 2.7.6 on Linux\n=> (defn func [&key {a \"b\"}] (+ 1 2)) ; ok\ndef func(a=u'b'):\n    return (1L + 2L)\n=> (defn func [&key {\"a\" \"b\"}] (+ 1 2)) ; quotes work but are useless\ndef func(a=u'b'):\n    return (1L + 2L)\n=> (defn func [&key {1 \"b\"}] (+ 1 2)) ; why the hell would I want to do this\ndef func(1=u'b'):\n    return (1L + 2L)\n=> (defn func [&key {True \"b\"}] true) ; uh oh\ndef func(True=u'b'):\n    return True\n=> (defn func [&key {[1 2] \"b\"}] true) ; this doesn't even work\n  File \"\", line 1, column 19\n(defn func [&key {[1 2] \"b\"}] true) ; this doesn't even work\n                    ^---^\nHyTypeError: Can't assign or delete a HyList\n=> (defn func [&key {# \"b\"}] true) ; this doesn't work either\ndef func():\n    return True\n=> (defn func [&key {\"b\"}] true) ; useless again\ndef func(=u'b'):\n    return True\n=> (defn func [&key {~ \"b\"}] true) ; this is pointless\ndef func(~=u'b'):\n    return True\n=> (defn func [&key {+ \"b\"}] ((setv f +) 1 1)) ; this may not end very well\nfrom hy.core.shadow import +\ndef func(+=u'b'):\n    f = +\n    return f(1L, 1L)\n=> (defn func [&key {= \"b\"}] nil) ; and this looks stupid\ndef func(==u'b'):\n    return None\n=> \nryan@DevPC-LX:/media/ryan/stuff/hy$ \n``\n. Wouldn't this require wrapping every single function call to test forgetitem`? That would likely be a major speed issue for little gain.\nI think a better solution would be to have curried operators. Basically, for get, there would be a curried version getc or something like that. That way, you could do (getc [1 2 3]) to create an indexing callable.\n. Wouldn't this require wrapping every single function call to test for __getitem__? That would likely be a major speed issue for little gain.\nI think a better solution would be to have curried operators. Basically, for get, there would be a curried version getc or something like that. That way, you could do (getc [1 2 3]) to create an indexing callable.\n. @gilch \n\nYou don't have to do the check first.\n\nThat would mean (any 1) would be compiled to something like:\npython\ntry:\n    _hy_anon_var_1 = any(1)\nexcept TypeError:\n    _hy_anon_var_1 = any[1]\nwhich prints:\nTraceback (most recent call last):\n  File \"call.py\", line 4, in <module>\n    _hy_anon_var_1 = any[1]\nTypeError: 'builtin_function_or_method' object has no attribute '__getitem__'\nwhich would likely be the most confusing error message on earth.\nOf course, you could do things like error message checks, but that still would fail in weird ways:\n``` python\ndef f(n):\n    l = []\n    l() # oops\ntry:\n    _hy_anon_var_1 = f(1)\nexcept TypeError as ex:\n    if str(ex).endswith('is not callable'):\n        _hy_anon_var_1 = f[1]\n    else:\n        raise\n```\nTraceback (most recent call last):\n  File \"call.py\", line 9, in <module>\n    _hy_anon_var_1 = f[1]\nTypeError: 'function' object has no attribute '__getitem__'\nThe best thing I can think of would be:\n``` python\ndef f(n):\n    l = []\n    l() # oops\ntry:\n    _hy_anon_var_1 = f(1)\nexcept TypeError as ex:\n    if callable(f):\n        raise\n    else:\n        _hy_anon_var_1 = f[1]\n```\nBut watch the results of the following speed test:\n``` python\nfrom future import print_function\nimport timeit\nprint('Base version:', timeit.repeat('f()' , '''\ndef f():\n    return any([1, 1, 1])\n'''))\nprint('Exceptions with direct return', timeit.repeat('f()' , '''\ndef f():\n    try:\n        return any([1, 1, 1])\n    except TypeError:\n        if callable(any):\n            raise\n        else:\n            return any[[1, 1, 1]]\n'''))\nprint('Exceptions with indirect return', timeit.repeat('f()' , '''\ndef f():\n    try:\n        _hy_anon_var_1 = any([1, 1, 1])\n    except TypeError:\n        if callable(any):\n            raise\n        else:\n            _hy_anon_var_1 = any[[1, 1, 1]]\n    return _hy_anon_var_1\n'''))\n```\nPython 2:\nBase version: [0.28238892555236816, 0.2855241298675537, 0.2818140983581543]\nExceptions with direct return [0.29772210121154785, 0.29675912857055664, 0.2970468997955322]\nExceptions with indirect return [0.31590700149536133, 0.3146848678588867, 0.31568408012390137]\nPython 3:\nBase version: [0.40082355300000927, 0.4072187689999964, 0.40149685299991233]\nExceptions with direct return [0.41813028399997165, 0.4186033580000412, 0.423580343000026]\nExceptions with indirect return [0.43899454200004584, 0.43792077899991, 0.4359661139999389]\nNot bad...until you realize a major chunk of the average Hy program consists of function calls.\n. @gilch \n\nYou don't have to do the check first.\n\nThat would mean (any 1) would be compiled to something like:\npython\ntry:\n    _hy_anon_var_1 = any(1)\nexcept TypeError:\n    _hy_anon_var_1 = any[1]\nwhich prints:\nTraceback (most recent call last):\n  File \"call.py\", line 4, in <module>\n    _hy_anon_var_1 = any[1]\nTypeError: 'builtin_function_or_method' object has no attribute '__getitem__'\nwhich would likely be the most confusing error message on earth.\nOf course, you could do things like error message checks, but that still would fail in weird ways:\n``` python\ndef f(n):\n    l = []\n    l() # oops\ntry:\n    _hy_anon_var_1 = f(1)\nexcept TypeError as ex:\n    if str(ex).endswith('is not callable'):\n        _hy_anon_var_1 = f[1]\n    else:\n        raise\n```\nTraceback (most recent call last):\n  File \"call.py\", line 9, in <module>\n    _hy_anon_var_1 = f[1]\nTypeError: 'function' object has no attribute '__getitem__'\nThe best thing I can think of would be:\n``` python\ndef f(n):\n    l = []\n    l() # oops\ntry:\n    _hy_anon_var_1 = f(1)\nexcept TypeError as ex:\n    if callable(f):\n        raise\n    else:\n        _hy_anon_var_1 = f[1]\n```\nBut watch the results of the following speed test:\n``` python\nfrom future import print_function\nimport timeit\nprint('Base version:', timeit.repeat('f()' , '''\ndef f():\n    return any([1, 1, 1])\n'''))\nprint('Exceptions with direct return', timeit.repeat('f()' , '''\ndef f():\n    try:\n        return any([1, 1, 1])\n    except TypeError:\n        if callable(any):\n            raise\n        else:\n            return any[[1, 1, 1]]\n'''))\nprint('Exceptions with indirect return', timeit.repeat('f()' , '''\ndef f():\n    try:\n        _hy_anon_var_1 = any([1, 1, 1])\n    except TypeError:\n        if callable(any):\n            raise\n        else:\n            _hy_anon_var_1 = any[[1, 1, 1]]\n    return _hy_anon_var_1\n'''))\n```\nPython 2:\nBase version: [0.28238892555236816, 0.2855241298675537, 0.2818140983581543]\nExceptions with direct return [0.29772210121154785, 0.29675912857055664, 0.2970468997955322]\nExceptions with indirect return [0.31590700149536133, 0.3146848678588867, 0.31568408012390137]\nPython 3:\nBase version: [0.40082355300000927, 0.4072187689999964, 0.40149685299991233]\nExceptions with direct return [0.41813028399997165, 0.4186033580000412, 0.423580343000026]\nExceptions with indirect return [0.43899454200004584, 0.43792077899991, 0.4359661139999389]\nNot bad...until you realize a major chunk of the average Hy program consists of function calls.\n. @gilch But I'm confused. What's the point of callable collections if they're literals? Is there a reason to do:\nhy\n([1 2 3 4] 1)\ninstead of just:\n1\n?\n. Is there a reason standalone :x is compiled to have some weird Unicode character in front anyway? I crashed the Hy repl:\nryan@DevPC-LX:~/stuff/hy$ hy\nhy 0.11.0 using CPython(default) 2.7.6 on Linux\n=> (:f)\nTraceback (most recent call last):\n  File \"/usr/local/bin/hy\", line 9, in <module>\n    load_entry_point('hy==0.11.0', 'console_scripts', 'hy')()\n  File \"/usr/local/lib/python2.7/dist-packages/hy-0.11.0-py2.7.egg/hy/cmdline.py\", line 347, in hy_main\n    sys.exit(cmdline_handler(\"hy\", sys.argv))\n  File \"/usr/local/lib/python2.7/dist-packages/hy-0.11.0-py2.7.egg/hy/cmdline.py\", line 342, in cmdline_handler\n    return run_repl(spy=options.spy)\n  File \"/usr/local/lib/python2.7/dist-packages/hy-0.11.0-py2.7.egg/hy/cmdline.py\", line 240, in run_repl\n    os=platform.system()\n  File \"/usr/lib/python2.7/code.py\", line 243, in interact\n    more = self.push(line)\n  File \"/usr/lib/python2.7/code.py\", line 265, in push\n    more = self.runsource(source, self.filename)\n  File \"/usr/local/lib/python2.7/dist-packages/hy-0.11.0-py2.7.egg/hy/cmdline.py\", line 113, in runsource\n    sys.stderr.write(str(e))\n  File \"/usr/local/lib/python2.7/dist-packages/hy-0.11.0-py2.7.egg/hy/errors.py\", line 104, in __str__\n    self.message))\n  File \"build/bdist.linux-x86_64/egg/clint/textui/colored.py\", line 108, in __radd__\nUnicodeEncodeError: 'ascii' codec can't encode character u'\\ufdd0' in position 24: ordinal not in range(128)\nryan@DevPC-LX:~/stuff/hy$\n. (and I have no clue what keywords you guys are talking about...)\n. I still feel like it's an ugly effort (as @paultag said) for little gain. It only saves 4 bytes: get.\n. FWIW can this be closed now? I doubt this is ever really going to happen.... @berkerpeksag Done!\n. @berkerpeksag Done.\n. @algernon \n\nI'll drop by on IRC tomorrow and explain, if anyone's interested\n\nI am, but I don't hang out on IRC. :(\n. Bump?\n. Try:\nryan@DevPC-LX:~$ hy\nhy 0.11.0 using CPython(default) 2.7.6 on Linux\n=> (require hy.contrib.anaphoric)\n=> (def add-10 (xi + 10 x1))\n=> (add-10 2)\n12L\n=> \nryan@DevPC-LX:~$\n. Bump?\n. I would argue against that being the default for hy --spy, since my own main goal of using that is to see exactly what Python code is generated.\nThis is a great idea; I've had it on my mind for a year or so. Do note that it's more complicated than it seems. You can't just mangle every name you see:\n(defn $ [a b]) ; this can be mangled to whatever\n(reduce + [1 2]) ; this would add an extra import from `hy.shadow`, and mindlessly mangling that will give an ImportError\n(import x [$$]) ; same here\nBasically, in particular, imports need extra attention.\n. Only problem is that that breaks any usage of globals and locals:\npython\n(setv + 123)\n(print (get (globals) \"+\"))  ; BOOM!!\nThough I guess we already mangle ! and ?.... Do you mean argument destructuring (like (defn f [[a b]] (+ a b))) or value destructuring (like (setv [a b] c))?\n. Related to #742. I created a shell script that, given the invalid line number and the file name, returns the correct line number. That way you can still use Hy.\nI keep feeling like this is a CPython issue, since it never happens under PyPy.\n. Yeah, that's because Hy currently sets all the line numbers under PyPy to line 1. Try commenting out lines 2611-2614 of hy/compiler.py, and you'll see what I mean.\n. Yeah, I really think this could potentially be a CPython issue. Again, see #742.\n. Closing as duplicate of #742.\n. http://stackoverflow.com/a/33678354/2097780\n. I like Gitter a lot. It's like IRC, but any messages you miss get emailed to you, and there's always a persistent log, which I find to be two major deficiencies of IRC (missing messages).\n. @paultag \n\nand I flat out won't pay for a nonfree service\n\nFYI, Gitter is free for public GitHub organizations...\nYou can also do things like reference GitHub issues from within Gitter and use syntax highlighting.\n. Here's a smaller test case:\n(defmacro f [@] `nil)\n(f)\n. All cleaned up and merged!\n. Ugh...this isn't going to work. Remember the unsupported callable error? It's because, on Python 3, getargspec raises an error on invalid parameter names.\nSo now we'd also have to remove support for non-identifier arguments.... @Kodiologist It's an explicit check though. I think it's just an intentional limitation...\nMight still run it by python-ideas though.. @Kodiologist  FWIW, wouldn't this fail then on Python versions <3.7?. What if you add the lineno and col_offset fields here and here?\n. I think the error was actually from loading hy.core, since it's loaded when you first use it.\n. Not core...but I have a feeling this may break with nonlocal and global...\n. :D :D :D :D !!!\n. :+1:\n. So it's that macroexpand isn't expanding recursively?\n. Bump?\n. @berkerpeksag Done!\n. This is basically a bit of a circular dependency issue: hy.core.macros depends on helpers from hy.core.language, which in turn depends on hy.core.macros, etc.\n. Maybe importing hy.core.macros directly should just be an error...\n. I think this can be closed now!\n. :+1:\n. Well, the tests failing seemingly has nothing to do with this...not sure why?\n. :+1:\n. What about http://gitready.com/advanced/2009/02/10/squashing-commits-with-rebase.html?\n. IMO, I disagree with this. Sometimes, there's a feature that doesn't get into Hy for one reason or another, and the PR ends up getting closed. If you open an issue first:\n1. The community has a chance to give input on the idea before it's implemented. This avoids 10k commits while the PR is open as everyone changes their mind on semantic issues.\n2. You don't end up with wasted work if the PR ends up not being accepted.\n. > That's why I wrote \"in general\", but maybe we should expand that a bit with something along \"Generally there is no need to open an issue before submitting a PR, but feel free to open one if you're unsure about the proposed change or it is a major change to Hy as a language (changed syntax for example).\"?\nAgreed. Maybe something more specific, like:\n\nIf you are contributing a major change to the Hy language (e.g. changing the behavior of or removing functions or macros), or you're unsure of the proposed change, please open an issue in the issue tracker before submitting the PR. This will allow others to give feedback on your idea, and it will avoid constant changes or wasted work. For other PRs (such as documentation fixes or code cleanup), you can directly open the PR without first opening a corresponding issue.\n. :+1:\n. Based on reading the Hy docs, I think it's OK for me to merge this (one ack for documentation stuff), so please don't shoot me...\n. :+1:\n. I'm not sure about this...the majority of these are duplicated from the main docs, resulting in having to update them in two places, and the compile_* functions seem pretty self-explanatory (e.g. compile_while compiles a while expression).\n. I guess that makes sense...but it would first require the ability to even auto-generate the docs (which isn't possible ATM).\n\nBut I still think some of the docstrings, like compile_complex, are a little overkill, since the function names are rather self-explanatory.\n. @jkitchin Good point about doctest; that would be really useful, since the documentation examples frequently go out of date.\n. @jkitchin That should work outside the REPL. When you call name, Hy re-imports it from hy.core.builtins, which overrides anything you had assigned to it.\n. Have a fix in the works; just writing the tests.\n. @gilch Well that sucks...\nThere's only one true solution I can think of: do it like shown in this PR, but also merge it with the result of a new function, hy.?.get_freevars, which would go something like this:\npython\ndef get_freevars(func):\n    closure = func.__closure__\n    freevars = func.__code__.co_freevars\n    return dict(zip(freevars, (cell.cell_contents for cell in closure)))\nNow, fn could be amended do always do an assignment like this as the first part of the function:\npython\ndef _hy_anon_fn_1(): # Or whatever...\n    _hy_current_function = _hy_anon_fn_1\nthen eval could pass _hy_current_function to get_freevars. The assignment would only be necessary in the case of eval being used; otherwise, the compiler wouldn't need to put it.\n. @gilch At this point, I would just deem assignment broken, especially since it's virtually impossible under Python 3 (in Python 2, you could just put eval '' at the top).\nBack to the topic...\n...\n...actually, can't we just define eval in user space in hy.core.macros? It would have code duplication with hy.importer.hy_eval, but it would also be pretty much 100% guaranteed to work, since it's just a macro.\n. @gilch You can't even do that right now; Hy will pass Python's eval instead. Maybe Hy's eval should be named hy-eval to make a distinction?\n. Can't figure this out, and sadly don't have the time. :(\n. Each of the classes in within a module in hy.models:\n- HyDict is in hy.models.dict.\n- HyList is in hy.models.list.\n- etc.\n. Odd behavior, but intentional. I'll just close this for now.. Not really a bug. Hy returns the result of the last expression; in this case, the attribute.\n. Ah, that's definitely fishy.\n. The break/continue removal sounds nice in practice, but that would likely have serious performance issues.\nAlso, it actually isn't hard to detect yield, break, or continue inside a let expression. What if let were implemented in the compiler instead of in the bootstrap file? That would allow a simple the creation of an instance variable to determine whether or not a let expression is currently being compiled. The majority of fn's code is to handle arguments and yields, but let wouldn't need to deal with any of that.\n. :+1: let is cool and all, but ATM it's ridiculously broken and needs to die in a very, very large and hot fire.\n. Try (. df.iloc [(slice 0 100)] [4] values). See the docs for more info.\nNote that this only works with the version of Hy from Git, not the version on PyPI.\n. If you text editor has Clojure support, you can probably just use whatever your editor has for commenting blocks. In Howl, you select the text and press ctrl+/.\nOtherwise, you could always define a macro like this:\nhy\n(defmacro discard [&rest x] `nil)\nThen you could do:\nhy\n(discard (print 123)) ; Does nothing.\n(discard (. nil error)) ; Also does nothing.\n. :+1:\n. Nice idea!\n. :+1:\n. @egregius313 Classic doc issue: the documentation is pointing to the Hy version from Git (i.e. the development version), but you're probably using the release version (maybe from PyPI). Try:\n$ pip install git+https://github.com/hylang/hy.git\nThis should give you the dev version, which supports these.\n. Also, here are the docs for the stable version:\nhttp://docs.hylang.org/en/stable/\n. Not easily. AFAIK Python disallows a lot of stuff like this due to the way its internals work, therefore making it really hard for Hy to do anything about it.\n. @Jiehong Like @gilch said, Python simply doesn't allow you to easily assign a variable known at runtime. It's not as much a voluntary \"hey, we should do this\" as it being the only way on Python 3.\n. You can install the latest version using:\n$ pip install git+https://github.com/hylang/hy.git\nAlso, please don't write the issue titles in all caps. There really isn't a need for it.\n. What exactly would be the use case, though? This almost seems kind of random...\n. Well, those Python 2 test failures are certainly bizarre...\n. Aaaaah...this has conflicts. :/. Can't you just access sys.argv?\n. Hy performs no optimizationss over Python, FYI.\n. Ah, ok.\nIf you write your code exactly like Python, then it should be minimal performance impact, pretty much all from implicit results that Hy generates.\nIf you go more Lisp-y, before of statements in short-circuiting expressions (e.g. (and (setv a 1) 2) and, in particular:\nBEWARE OF let. It's not fast.\nOther than that, I don't recall anything else of interest.\n. :+1:\n. @weakish You can add yourself to the AUTHORS file; see here.\n. I'm a bit unsure about this one, considering how let's future is uncertain at the moment (ref. #1000, #1056).\n. @EMayej You're using the docs for the in-development version of Hy, but you have installed the stable version. Try either:\nthe docs for the stable version:\nhttp://docs.hylang.org/en/stable/language/api.html?highlight=with#with\nor installing Hy from source:\n$ pip install git+https://github.com/hylang/hy.git\n. Related: #1082\n. I'm personally -0.5 on this. It seems like a great idea, but I really don't see this being used that often, and the behavior seems a bit odd to me.\nNot -1 because adding this would give serious bragging rights.\n. > So yes, I admit it, I am The Enemy.\nQUICK, CALL MUMEI!! (Kudos to the 0 people who will get that reference.)\nIn all seriousness l, though, I'm +1 to this.Although I'm a BIG fan of \"one way to do it\", this is a natural extension of the attribute calling syntax.\n. :+1:\n\nI beg your pardon?\n\nGoogle it.\n. Wow I didn't even realize this was a thing. Personally, I prefer either option 1 or 2.\n. Wouldn't it be better to have something like '\"text here\", i.e. a single quote following the text in double-quotes. The syntax is less weird and easier to read.\n. Wow, I must've been delusional when I wrote that code. Sets have nothing to do with lists, yet I had the latter derive from the former...\nSo you basically end up with sets. That can have duplicates appended. Out of order. And can be indexed. Ugh...\n. I think an error should be thrown. Regardless of how this is implemented, people are going to have different ideas of how is should behave, and the Zen of Python does say:\n\nIn the face of ambiguity, refuse the temptation to guess.\n. > We certainly haven't dropped support for 2.6 yet\n\nUhhh...\nI'm guessing @paultag just forgot to update the classifiers.... Dang, there are a lot of phony targets... :O\n. As a side note, I have no clue how the heck this went unnoticed for so long...\nAlso, I'm having way too much fun with GitHub's PR reviews. :D\n. :+1:\n. (I was literally going to fix it right now./\n. > 0.11.0-293-g34304c4-dirty when the working tree is dirty\nIs this part really necessary? I normally find it quite jarring when you edit a file and now your version ended up changing.\n. As a side note, I'm personally -0.5, since these things have a tendency to explode in weird ways (like I mentioned, setup.py develop), though I wouldn't really be against it if the \"bigger\" @hylang/core members wanted it in.\n. In the future, I think I would like to see a commit hook that does this so that setup.py develop still works. For now, though, this works.\n. Just to check, the releases, are going to come with version.py already generated, right?\n. Crazy thought: what if re-generating version.py was a commit/receive hook? No one would need to remember to run it, it would automatically be updated, and it would work with setup.py develop.\n. IMO this isn't really a bug because of Lisp's notion of expressions. The main bug would be that doing .x as an expression is possible. It should be a syntax error.\nMaybe the error message could read more like cannot have attribute without a name (in order to get attributes of expressions, use(.format )). @Kodiologist would that be good enough?\nFor your use case, (.format \"foo\") works well enough.\n. Aaaaaand that's what happens when I write the tests and don't run them...\n@Kodiologist I think that probably would be classified as a bug, since I can't think of a single reason why someone would do something that stupid, and I think this is the only way you can use a number as a variable.\n. Meanwhile, I just removed the test.\n. Anyone else want to approve this? :heart:. Release time!!!\n(God, I hope I did that correctly...). :+1:\n. FWIW, I really like the idea behind this change, but this is quite literally going to one of the biggest breaking changes that have been done...\n. @Kodiologist Whoops, forgot about this.\n. @hylang/core Does this count as two acks now, since @tuturto said he agrees with the changes, or does someone else have to actually hit the \"Approve\" button?\n. @Kodiologist Actually, no, I take that back: you forgot to update the docs!\n. :+1:\n. (I was literally about to make this same issue!)\n. I'm sorry I basically just gave a mega-review consisting mostly of commas, but the grammar nerd in me couldn't help it.... @gilch What if, for metaclasses, we went the Python 3 route:\nhy\n(defclass X [:metaclass Y] ...)\n. @gilch Why not just automatically detect the metaclass keyword and then set the __metaclass_ attribute?\n. Huh...here's a smaller test case:\nhy\n(setv x (or z (do y y)))\nCan I have a few moments to look into this a bit more first? This just seems really, really bizarre, and I'm curious as to why the heck this is happening.\n. #1152\n. @Kodiologist Thanks!. ```\nryan@DevPC-LX ~ $ echo '(print 123 [456] \"789 \")' | hy --spy\nhy 0.11.0 using CPython(default) 2.7.6 on Linux\n=> print(123L, [456L], u'789 ')\n123 [456L] 789 \n=> ryan@DevPC-LX ~ $ \n``. FYI, I made some small code formatting and code fixes for you!. I dunno...I find this one a bit confusing. When you see(.myfunc ...)`, the eye immediately looks right after to see what the method is being called in.. Can we collapse this into #1173? Seems to be a really similar idea.. #1173 is also covering whether or not some mangling rules should be removed, and how Unicode characters should behave. This seems like a fitting addition.\nAlso, if mangling were to be changed, I would think this would all end up happening at the same time.. Eh, everybody was taking too long.. Maybe quoted expressions should be auto-boxed in general?. I'm not really seeing a use case for compliment... what's the difference between that and (comp not f)?. > not is not a normal function (pun not intended)\nI wonder...not should probably be shadowed just like operators like +< , right?. Might be related to the other one, since I know pyc issues can cause segfaults.. I wonder is this is related to the new importer (#1085). What happens if you switch to some commit before https://github.com/hylang/hy/commit/13b484ce460352f74e844f208efb845bacdd7127?. What do you get if you run this script on the .pyc files.. For some reason I feel like this has something to do with the new polyloader code.... I'm starting to get the vibe that readline on OSX is flat-out broken (#1177).. Wait, do you have pyreadline installed?\nhttp://stackoverflow.com/questions/32608232/valueerror-type-v-not-supported-error-after-installing-pyreadline. Hy probably shouldn't even try to import pyreadline on Windows.. @asimjalis https://github.com/hylang/hy/pull/1177#issuecomment-267808182. As a side note: what if we leave Botsbuildbots, but just remove it from the tests? Seems kind of silly that that's tested, but it's still a fun little easter egg. I personally kind of see it as akin to Python's import antigravity.. TBH, this is mostly just a lose-lose scenario. :(\nIf we use shadow operators everywhere, that would give a really bad performance hit. Python already isn't the fastest language around, and making that worse would likely be a bad idea.\nAs a result, the option left would be to make the shadow operator behavior match the normal operator by using and.. Thanks! Want to add yourself to the AUTHORS file?. RTD says this can be changed to point to a stable version, so...@paultag want to take a look?. > Four Horsemen of Hy Maintenance\nI like this.. @paultag cough cough. . I'm kirbyfan64sos.. Not really a bug. There's no need to surround the body of a defn with parens. This works:\nhy\n(defclass Log []\n  (defn write [&optional [msg \"Moo\"]]\n    (setv x (time.strftime \"[%Y.%m.%d|%H:%M:%S] \"))\n    (setv y (str msg))\n    (setv z (+ x y))\n    (print z)))\nWhat's happening is that parens are (usually) syntax for some kind of function call. So, here, since you surrounded the whole thing with parens, Hy sees it like this:\nhy\n(  ; Function call\n    (setv x (time.strftime \"[%Y.%m.%d|%H:%M:%S] \"))  ; This is the target\n    (setv y (str msg)) ; argument #1\n    (setv z (+ x y)) ; argument #2\n    (print z) ; argument #3\n)\nHy then lifts out the assignments, and you get the code you posted.. @handicraftsman Only other sites I visit with a similar username are Reddit and GameFAQs.... @handicraftsman Yup!. WTF is going on with Travis.... Regardless of what goes wrong in your script, I'm pretty sure the second one (the \"import ... halted\") shouldn't be happening.. Actually, I'm just an idiot and ignored that you had just opened #1211.... Closing as a dup of #1134.. Come to think of it, is there a reason we're not compiling let into just:\nhy\n(let [x 1] (stuff) x)  ->  (do (setv x 1) (stuff) x)\nI know x still stays in scope, but in general Python doesn't have any blocks that open up new scopes.. Nice idea, but it has a bit of potential for confusion. Since Hy allows positional arguments to come after keyword arguments, you end up with some ambiguity. If someone writes:\nhy\n(func :a 123)\ndo they mean to set :a to True and also pass 123, or set :a to 123.. @Kodiologist Haha, I actually changed my username, but then I changed it back. Too many memories. :). Also, this gets my :+1:, but would you mind letting me check out that test a sec first? Just to be on the safe side!. Eh... I'd say Python 2 is still used widely enough to make this harder to justify.\nWe should probably make it clear which ones exactly we're supporting, though. Didn't we drop 2.6 at some point.. +1 to the idea of using reader macros, -1 to changing Hy's defaults. Part of the awesomeness of Hy comes from the fact that it's ultimately still Python, and changing that would partly lose that benefit, along with slowing things down quite a bit.. @Kodiologist True.... Done.. > Any number of underscores or commas can be placed anywhere, even at the start.\nWouldn't it then still be an identifier?\nAlso, looks like the tests are only for failing for Python 2, so maybe you ran yours on 3?. I don't know, it now seems kind of odd that this would happen:\nhy\n,,,  ; Identifier\n,,1  ; Number\n,1,  ; Number\n,_,  ; Identifier\n__,  ; Identifier\n___  ; Identifier\n__1  ; Number\nBut I guess it's generally a lose-lose scenario... :/\nEhh, get's my +1.. IMO it is: the models are rather short, and placing them in separate files really didn't do much except make it a little trickier to maneuver through.. I'd personally stick with the headers. Maybe just shove \"The Hy developers\" as the copyright owner?\n(FWIW, though, the MIT license has little legal bearing...but I still would prefer leaving it there, just in case. Legal matters are confusing, and every little bit can help.). > Copyright 2017 the authors.\nMaybe \"the Hy authors\" would make a bit more sense?\n\nThis file is part of Hy, which is free software.\n\nI think it could be:\n\nThis file is part of Hy, which is free software licensed under the MIT Expat license.\n\n+1 to the idea, though!. > The reason I'm inclined to write \"the authors\" instead of \"the Hy authors\" is because it's not authorship of Hy in some general sense that confers copyright but authorship of the particular additions and changes to that file or its ancestors.\nHow about then the authors of this file? The grammar nerd in me just keeps screaming \"AMBIGUOUS PRONOUN\"...\n\nNaming the license is a good idea, although we should probably call it just \"the Expat license\" rather than \"the MIT Expat license\".\n\nReason for that was that a lot of people know of it as just the \"MIT license\", though I guess it wouldn't be a big deal.... > \"The authors\" isn't a pronoun. learn2grammarnerd, pleb. :P\nNote to self: try to avoid writing GitHub messages when sleep deprived and mindlessly roaming the mall.... Never realized this had never been added?. FWIW this also wasn't caused by #1221.... AHA!!\nWhen you run the code using hy, Hy compiles it by instantiating a HyASTCompiler for the module __main__. During the initialization, load_stdlib is called. This means that, by the time hy.core.shadow is loaded, the entire stdlib is already loaded, and the reduce import is added.\nHowever, when hyc is used and the code is then run using Python, the no HyASTCompiler is instantiated for any non-core modules. Therefore, when hy.core.shadow is loaded, the stdlib dict is empty.\nIdeas for solutions:\n\nAdd an extra check to compiler.py when compiling symbols that will never import them in a hy.core module, and update hy.core.shadow to manually import reduce.\nAllow hy.core modules to use auto-imports. This can make room for circular import errors, but they'd be pretty obvious to fix the second they came up. hy.core.shadow would remain untouched.\n\nBoth of these would be pretty simple fixes. Thoughts? @hylang/core . Anyone else? Right now I'm supporting option 1, and @Kodiologist is supporting option 2, so we need a tie breaker!! :D. It would really be nice if Hy supported this other Python versions, too...it seems like it wouldn't he too hard to compile.... FWIW I've started work in this, but it'll be a while before it's done.... IMO iterables can be really useful (try filtering over a collection of ~2000 items and you'll see what I mean), but using them with collections can be annoying sometimes. In Python, it's less of an issue because those functions aren't even used too often, but in Hy, which has more of a functional leaning, it gets more annoying.\nI kind of wish sometimes that Hy had a set of functions (e.g. map-c or something) that specifically return collections instead.... Sorry, forgot about this. I guess the whole list vs iterator thing is more suited for another issue.. This would be pretty great, and it seems like it wouldn't cause any trouble with Python integration.. Actually there is one thing that worries me: how is the memory usage here? Often in Python, iterators are used when processing large data sequences, and I'm just not sure how the storage of numerous attached functions and such would work out.... Dammit, that was an accident...\nGitHub mobile is killing me here.... Haha, this is gold. ;)\n(FWIW, I'm just gonna merge this, since it's a really minor change: just adding an import.). Ehhh...I'm not really a fan of this one...\nIMO part of what I love about Hy is that it's just Python, except different. If someone starts using Hy, they likely already know Python. Using the Python syntax in the repr isn't going to be confusing.\nMore importantly, though, this only half-way works with Python classes. Imagine a Python class that reprs with Python collection syntax. You'd probably end up having to look at something like this:\n```\n{MyClass(val={1, 2, 3})\n```\nwhich is worse than the current behavior.\nIn addition:\n\nThe prepending of (do is going to make column numbers off. They have to be fixed.\nThis changes the behavior of --spy: if an exception is thrown, then the AST is never printed. IMO this removes a lot of its usefulness for me...\n\nBoth of these could be fixed by separating the parsing and code execution (which would allow you to put (do at the AST level).\nYeah...not a big fan... :O. > Are you saying you would approve this if I made the changes you've requested, or not?\nDepends on what everyone else says.\n\nI don't understand your point or your example about \"this only half-way works with Python classes\". Can you be a bit more explicit?\n\nfoo.py\npython\nclass Foo:\n    def __init__(self):\n        self.items = [1, 2, 3]\n    def __repr__(self):\n        return 'Foo(items=%r)' % self.items\nin repl\n```\nhy 0.12.1+28.g484daaf.dirty using CPython(default) 2.7.6 on Linux\n=> (import foo)\n=> #{(foo.Foo)}\n{Foo(items=set([1, 2, 3]))}\n=> \n```\nIt's inconsistent. And it'll stay that way unless random library authors add __hy_repl__ implementations (but they probably won't).\n\nCan you give an example of how this appears to the user?\n\n```\nhy 0.12.1+28.g484daaf.dirty using CPython(default) 2.7.6 on Linux\n=> ]  File \"\", line 1, column 5\n(do ])\n      ^\nLexException: Ran into a RBRACKET where it wasn't expected.\n=> \n```\n. I guess I wouldn't mind it if it were disabled by default...\nThat being said, what if we put a prefix? e.g prefixing the command with something (no clue what yet) would use this repr...or maybe a reader macro?. ...so, as for the use cases, is there a reason someone can't just use _ to reference the previous calculation? FWIW I've never, ever had to use copy-paste in any half-decent REPL. Hy already has _ and readline and a cool prompt, and there's an open issue for making the REPL fancier (e.g. bpython/IPython).. I think I'd rather see if there's at least one other person here who has a really strong opinion on this this first. Right now, my second vote (@tuturto already gave +1) is pretty much what either merges this or puts this on hold, which makes this a really awkward situation...\nIn particular: @paultag do you have any opinion on this?. @tuturto Do you have any objections since you last approved 8 days ago, or are we good to go?. ...and I didn't mean to hit \"Submit\" yet. Dammit, Android!!!!\nAnyway, I have a couple of ideas:\n\n\nMake all the functions return something like @gilch's seq. Problem: it's not an iterator, but it still isn't a list. Even if fancier things like lazy concatenation were to be added, it still wouldn't work when you try to pass it to something expecting a list.\n\n\nImplement a list subclass that behaves like a \"lazy list\". Problem: I have a feeling that behaving like a list but being lazy would give some really surprising behavior from time to time.\n\n\nCreate anaphoric functions. Problem is, sometimes you still don't want a list.\n\n\nCreate a reader macro for making a list. My personal favorite choice, since everything stays normal, but now you don't have to put all the long list conversions.\n\n\nI would love a mix of the first and last points, personally.. @Kodiologist Fixed!. First thing: how does the second command actually work? IIRC Hy doesn't register any file extensions under Windows...? Hashbangs flat-out don't do anything under Windows.\nAlso, are you sure this isn't a side effect of however you did the first question?. @massmy Try running:\nftype Hy=hy.exe \"%1\" \"%*\"\nassoc .hy=Hy\nand then try again.. (FWIW maybe Hy on Windows should have a script to install this?). > Yes, this is complicated. I feel like FStringParser could be greatly simplified, but that's easy for me to say since I haven't tried writing it.\nThat's what I thought until I wrote it...it seems like it should be simple, but there are a lot of corner cases/oddities to handle. Once you add position tracking (to make all the positions relative to the outer source), everything goes downhill.\n\nI think it's fine to totally disallow ! and : in identifiers inside an fpart, so that {a!r} does what you'd probably want.\n\nOnly problem there might be if someone uses an f-string in a gensym'd macro, since then they couldn't use the g!xxx forms...\nI've been trying to think of some sort of \"middle ground\", but I don't have anything thus far.. > Could we simply allow ! or : to be escaped with a backslash?\nThat's actually a pretty good idea...\nAlso FWIW, for comparison purposes, CPython's f-string parser is around ~700-800 LOC. I'd say this one isn't too bad!!!. @Kodiologist Wrong PR #? The issue here is that the docs are showing a single integer as the return value instead of a tuple, which doesn't really have much to do with your REPL PR.... As a side note, I'm starting the get the vibe that we need some tests specifically for hyc. This is around the third issue we've had recently involving something that either doesn't work or is just plain broken.. @Kodiologist I've been able to reproduce the same failures using PyPy 2.5.0 (binaries are here). No Ubuntu 12 needed!. (FWIW, I haven't reviewed this yet, but so far I'm super glad this has happened; IME the main slowdowns with Hy were always due to the compilation times anyway.). @Kodiologist Hmm...I think maybe I can try it on a Ubuntu Docker image...Let's see.... Why? 3.3's not nearly that old, and it's the only version PyPy has support until very, very recently.. Yeah, this I can stand behind. Pretty sure it also reached its EOL already...\nIIRC there was actually a semi-decision by @paultag to drop Py2.6 support, but it was never actually...done.... I don't know...I'm still against dropping all 3.x releases until the release reaches EOL. FWIW the code hasn't even been simplified or anything. IMO Python 3.2 and PyPy3 should be tested (not sure why it wasn't already that way?)...though I'm pinging @paultag since he might feel differently.\n2.6 can definitely die in a fire, though. No one's arguing with that.. HAHAHA I'm an idiot and 3.2 is end-of-life: https://docs.python.org/devguide/#status-of-python-branches. Usually I just call it \"attribute dot thingy\" or something.... > Change our test infrastructure to use something other than Nose (probably pytest)\nAgreed. FWIW the tests mostly run already under py.test, though I don't recall if anything didn't work.\n\nUse travis-tox, or don't use Tox on Travis at all\n\nhttps://github.com/berkerpeksag/astor/pull/56\n\n1230: Reader macros aren't\n\nWhat was the consensus on this? It seemed to stall at \"either change readers to tagged literals or rename them to something else\"...\n\n1198: Docs versioning and readthedocs.org\n\nping @paultag \n\nPolish up CONTRIBUTING.rst\n\nLooks fine to me...?. Reminds me of #634. Sometimes I wonder if it'd be worth it to have a giant mono-issue just dedicated to missing checks. (IIRC genexpr might have had some missing checks, too.)\nAlso, wow, that was a looong time ago!. Or contact the mailing list.. FWIW can't you just call os.path.normalize first?. - Proposal A: -1. Unicode characters are hard enough to type already...\n- Proposal B: Ehh...I mean, it kind of makes sense, but it's also kinda weird. +-0\n- Proposal C: ...I kind of like this one, but a bit cautiously...so...+0.5?\nPersonally, I don't mind Python's triple-quoted string literals, though, because they fit in pretty well with the rest of the language. They make logical sense in the context of everything else, and they wouldn't require barring off another possible character from sharp macros.. IMO Lua's style fits more with the Python readability goals.. My only question is whether or not it's actually worthwhile to add so much extra code just to check the inf and NaN capitalization.... @Kodiologist can you rebase this?. @Kodiologist FYI this has conflicts.. :+1:! I made a couple of language and grammar changes/fixes, so @Kodiologist please look them over before this is merged to make sure there's nothing that you disagree with.. My 2\u00a2:\nThis should be exec*, and exec itself could be defined conditionally in the core modules, that way semantics are identical for both.. Great job!! :+1:. Thanks!!. FWIW I don't think every compatible feature should be removed, but it didn't work too well anyway.. This feels awfully...familiar? What version of rply are you using?. I think part of the general problem is simply that Hy is written in Python. Therefore, it is physically impossible for Hy's startup to be just as fast as Python's. When you start Hy, this happens:\n\nPython starts. There goes 0.01s.\nAll the libraries are imported. Even when compiled to bytecode, this can take a bit, since some of the libraries can have bigger-ish import chains.\nThe bytecode for the program has to be checked (to make sure it's valid) and loaded. You've got mtime comparisons and the like here.\nThe bytecode has to be run. Along with that, it will bring in the Hy core libraries, whose bytecode also needs to be checked and run.\n\nSo the times really aren't too far off.. As cool as this idea may seem...it seems a bit like a niche use case. After all, this is Python: all of these could be replaced with basic assertions:\nhy\n(defmacro check [&rest conds]\n  `(do\n    ~@(map (fn [cond] `(assert ~cond ~(str cond)))))\nThen you could just run:\nhy\n(defn abs [x]\n  (check (int? x) (something-else x))\n  (setv ret (if (< x 0) (- x) x))\n  (check (>= ret 0))\n  ret)\nAdmittedly, you lose a bit of functional-ness here, but this could easily be expanded on.. Hey there!\nThis was already being discussed in #324, and it ended up being closed as out-of-scope for this project. There's a bphython, but it hasn't been updated in a long time and has gotten out-of-sync with both vanilla bpython and Hy itself (FWIW I have an unfinished, updated version that actually works, but it's...errr...unfinished).\nThat being said, does doc not work for you? That might be a bug.. Uh, yeah, I was thinking of help.... Can't Hy just track the hashes of both the main file  and its requirements?. IMO this is an incredibly bad bug that violates one of the core features of Hy.... Also @paultag is alive :D. > Correctness should always trump speed\nThis. This is Python, not C++. The developer expects full correctness first.\n\nAs you note, there's no way to check that a macro would expand to something different from last time without actually running it.\n\nBut if the required file changes, it's decently likely that the macro will have changed in some way. So just track the hashes of required files, as well as the hashes of the files that are required by the required files and so forth. This is what C build systems do with headers anyway.\nIMO this is a pretty horrible gotcha.... (FWIW I wonder if we can use the same syntax ideas to implement tuple unpacking such...). and such. Note to self: I need to stop mass-marking-as-read GitHub issues... (It was going to bite me eventually anyway...)\nI'd still prefer the Lua style. After working with a crapton of different languages with different ways of having multi-line not-strings, the Lua style is the only one that I really don't dread using.\nFWIW automatically removing indent would just be a textwrap.dedent call, but I'm not sure everyone would always want it, even though it's certainly the more common scenario.\n call. Hold on I need to re-read this thing. I just got super lost.... Yeah, this is a mess. I still have no clue what the hell \"pointy style\" is. I think we just need to start from the top. How about we start from the top...\nMy understanding is that the current state of the code is that is looks like #q{delim}STUFF delim, right?\nHere's my belief:\nWhy is the Lua syntax awesome?\nFor starters, it's dead-simple if you're not using custom delimiters (which is the case most of the time). e.g. #q[[abc]]. On the other hand, the current syntax always requires a delimiter, e.g. #q{EOF} stuff EOF. My stance (partly from using heredocs for a long time) is that:\n\n99% of the time the delimiter will either be EOF or some weird character, where everyone uses a different one\nThere are too many choices. Not only can you pick any delimiter, but you can also pick what delimits the delimiter (e.g. #qAdelimiterA is valid). Really, I don't see any use for using a custom character after the q, since the delimiter can be whatever you want anyway.\n\nIn addition, it plays nicely with Python's one way to do it philosophy: it allows just enough flexibility, but most of the time it'll end up being roughly the same thing.. Also, I'm not sure what this has to do with list syntax. Isn't everything handled in the lexer anyway?. Same. (TBH I still don't really grasp the use case for proposal 2, but I don't feel like figuring out anything else...). FWIW is there a reason we can't just use PLY? It works much better with things like this.. ...is this even allowed? I would think those who don't like (e.g. me) would already have an ad blocker, and I'm not sure RTD would be too happy with the idea...\n(TBH I whitelisted RTD anyway, since the ads are pretty non-intrusive, and they're providing a great service.). GitHub Pages is pretty flexible. I host my own site there, and since client-side JS is as powerful as ever, you can do pretty much anything with it.. Not really much of a trick TBH...I think a simple re.replace('^#!.*', '', file) should do the trick; since .* removes everything up to the newline, the line numbers will stay intact.. > This is a 1337 pull request.\nIs it weird that I had to Google that..?. > If you think the design change merits separate discussion, we could postpone Asty and use the old style here instead.\nYeah, I'd really prefer it this way.. Wait, why not compromise?? For minor style issues, the person who notices, when they can, just pushes a fix themselves? At least for now until we can actually reach some kind of consensus.... > I certainly felt deterred from participating by this dispute, to the point of contemplating a hostile fork.\nPlease don't. That literally never ends well, we're short-staffed as it is, and IMO formatting, although important, isn't important enough for something that drastic.. ...I think this actually seems like a pretty nice idea. :+1: from me!. IMO Hy is ultimately still Python, so there's no reason to not accept anything that Python accepts.. ... probably. It would have to be a bit different, but I'm pretty sure it would work.. > Therefore, I think assoc should be a macro for performance\n+1 to this. Using a plain function will likely be a performance killer.. FWIW usually it's best to let everyone know that you're starting work on something, that way wasted efforts are avoided. Sorry about that.. So...is there a reason we can't just do (list ~(or f_contents [])).. {:vat 1.05}\nThis doesn't do what you think it does!! Try running Hy with --spy and you'll see what I mean.\n(But the short version is that :val in any context other than keyword arguments is compiled to \\UNICODECHARCTERval, including here.). Wait, this isn't right. Nothing should be installed into /usr/local directly like that, let alone something with the generic name generic_version.... Can't we use package_data for get_version.py?. 99.9% of Unix systems have /usr as owned by root. Many login managers and other applications store configuration in /usr, so it's a security hazard to change the permissions of it in its entirety. (You also run into the issue of having writable directories in your path.)\nTo begin with, placing stuff in /usr is just as ugly as a global variable, especially if it's a file that's never going to actually be used.\nTBH I'm pretty sure this can be solved with some distutils hackery. Messy, sure, but everyone does it anyway (!).. Yes, yet the bug has been open for 10 months...\nIMO regardless of whether or not data_files is broken, Hy still shouldn't fail installation.. TBH I think we should be using Gitter or Discord anyway, but ehh. ;). TBH is there a particular reason we're using IRC, over something like Gitter (which has great GitHub integration and is used by a ton of projects) or Discord (which is user by RPCS3)?. Although I like the idea, is there a reason why the HyCons repr is totally different in style from the others (e.g. <xxx yyy> vs xxx(yyy))?. Touche.. IMO the last is the best (which is basically the current version but with indents, right?).. Looks great to me!. I mean, I'd prefer the latter, provided it's not too difficult.. @gilch I changed the implementation like you said.\n\nI'd also like a test to make sure the wasted assignment isn't in the AST.\n\nIs this even really possible right now?. Let's see if Travis works now.... I should probably just check the number of elifs.... I mean, I'm not sure what exactly is wrong because of the setv interactions.... Whoops, my test case was wrong. \u00af\\(\u30c4)/\u00af. Eh... I'm with @gilch on this. Especially since everything is still in a state of flux, it'd be a lot easier to just wait it out until at least 1.0.. Glad to see this finally getting in!. ...huh? Hy should run anywhere that Python runs on, including arm64, airplane infotainment systems, and the inevitable AI toilet seats. Not sure exactly what we'd need to do here.... Ahhhh... @longquan7 is that what you had in mind?. @longquan7 Uhh...what exactly do you mean by authorities? Can you start from the top explaining what it is you want?. @longquan7: @tianon already did that:\nhttps://hub.docker.com/r/arm64v8/hylang/. Will probably be a lot easier.... I'd review, but this is a huge PR, and I have neither the time nor energy right now to go through it, and it'd be silly for me to approve for the sake of approving.... hold on, manually testing and merging.... I mean, as much as I don't see a problem with this proposal, I'd also like to see concrete evidence that this actually helps. Yes, x.pop(0) is bad, but Python stores lists internally as a bunch of pointers. Expressions are pretty much never over 10 elements, so an expr.pop(0) would end up shifting around 80 bytes. CPython's pop delegates to list_ass_slice (this basically means x.pop(0) is the same thing as x[:] = x[1:]; also, don't ask about the name...), which uses the mem* operations. glibc's memcpy uses careful prefetching to move roughly 64 bytes at a time (8 per instruction, for 8 instructions, but the memory's already been prefetched).\nSo TL;DR: Literally everything else in the Hy compiler, as well as in Python itself, probably takes more time than the expr.pop(0) calls. Expressions aren't long enough for a shift to actually be significantly slow, and we'd probably burn through more time with the direct indexing now having to go through multiple blocks.. I mean... I'm still skeptical. I could try moving it over, then benchmark the compiler on some typical programs and see if there's even a difference.. Steps 1 and 2 sound great, though I personally don't think using __import__ here would really be a problem.\nI got totally lost at step 3 though.... FWIW the reason for Python 2 using anon vars was also because tuple destructing seriously screwed with the inspect module.. Ah, damn it...another repo I work with mandates merge commits, and I keep mixing these up...\nAlso it seems done enough. @gilch had already requested my review to be the second, this isn't in core, it's tagged as experimental, and it'll be easier reviewing two PRs than one mega-sized one.. HyMacroExpansionError: b\"\nWait...why are we using bytes here?. Yeah, I'm pretty sure this has to have something to do with the whole bytes thing here.... Maybe not using bytes would help? I mean, off the top of my head I know special characters in byte strings aren't evaluated, so switching to str might fix the problem.. I mean, I guess it's not that bad... the internal micro-optimizer in me is just yelling extra bytecode, extra bytecode!.... > I've implemented highlighting python code\n...huh? I mean, I'm not sure what exactly this would have to do with --spy...is your code available for viewing anywhere? (FWIW roll-your-own syntax highlighting is a bit trickier than it sounds...). Ah, that added context would have been really helpful in the issue description.... What about following the path of the Dart analysis server? It reads a one-line JSON response from stdin and writes an output JSON response to stdout. It's significantly easier to implement and work with than sockets, but it gets the job done.. Duplicate of #1134, which is probably one of the longer-standing nasty bugs tbh.. Yup.. What do you mean by \"dict lookup targets in import statements?. Did you download this via pip, or did you clone the GitHub repo? Sounds like you have an old version of astor installed.. Try running python -c 'import logger' from your cron job.. \ud83d\udc4dWe need more actually active core devs.... Personally, I prefer for/a, because it's actually doing something entirely different.... Agree with @Kodiologist, but anyway...\nasyncdefn just feels wrong. What about an a abbreviation? (e.g. adefn).\nPersonally I always felt like something like this would be cool:\nhy\n(fn async [a b] ...)\n(defn async [] ...)\nI mean, Hy's Lisp, so might as well take advantage of the loose syntax, right?. Personally I love the /a proposal. \ud83e\udd37. Actually, it generates invalid Python syntax, but the AST runs perfectly and treats return as an identifier.. Well, for starters, require is basically import for macros, so (require file) will import any macros inside file.hy. You don't run (require macro-name).\nThat being said, the bug here is just that the raised exception isn't being handled properly.. Because it only has an effect on Windows and macOS, which are \"icky\" proprietary systems... . What about:\n\n1 month if no one has expressed disapproval.\n\n2 weeks if someone has approved, but no one else has yet.. :+1: . I will say that seeing another loader change that touches bytecode is a bit concerning; the last one had to be reverted because it seemed to work but broke under some hard-to-trace cases. . One thing to note: compile times are pretty slow to begin with, so we'd have to be pretty careful using immutable data structures, and definitely not linked lists. . Just going to go merge, since @vodik already expressed approval.. Thanks! . I'm a bit confused by this...in Python 2, strings are basically byte strings, which means that only the unicode type would use UCS-2? . I just squashed + merged. . Why not both? . Ok, one of:\n\n\nHy.js - Written in React using a purely functional, statefulness NoSQL bytecode cache. \n\nHy.rs - Now the compiler can check our code to make sure it doesn't violate lifetimes, human rights, or the Amazon rainforest. \niHy - Written in Swift, and integrates with Apple's BodyOdorKit to tell you when you need to take a break, stretch, and get a life. . When I tried sorting priorities, import antigravity came out on top, so we should probably stick with Python. . 2. Because the cuttlefish is adorable. . You can disable bytecode compilation by setting the environment variable PYTHONDONTWRITEBYTECODE. The real bug here is that we're ignoring sys.dont_write_bytecode, which is set via python -B, which AWS probably uses. . Well, in Botsbuildbots' defense, it was a creator error.... I mean that it was a misuse of () over [] in the defn arguments list. Creator error because the person who wrote it should've used [] to begin with. . Superceded by #1604 (sorry). . Yeah, you can probably guess what I'm going to pick here...\n\nIf this breaks again though, it will literally ascend into meme territory. . Note: I used to try to use Mercurial to manage my Git repos too (my very first PR to Hy was done through Mercurial). In the end, though, I just gave up: I felt like I was stuck with all of Mercurial's cons (e.g. slow clone speed, smaller community) with none of Git's advantages. . Okay, okay, I think we've all had our fun, but just to be clear: indentation is purely, at the end of the day, nothing other than opinion, and I wouldn't consider it something worth seriously debating outside of academic circles.  At minimum, it's not worth accusations that will likely be forgetting by next week. . We seem to have agreed that #851 is the nicest syntax. Does anyone else (at least, anyone who's actually working on Hy right now) want to object?. Might be a random issue... Out of curiosity, I'll try restarting it just to see. . Given that we're already restricting the case of NaN and such, IMO they shouldn't be case insensitive. This fact actually comes up every time someone proposes an additional prefix, since the number of permutations is so high.\nTL;DR: If the decision for Python were made today, they probably wouldn't be insensitive.. Ehh, I'm not too sure about these names... I know everyone's going to hate this, but IMO something like (for->list) (for->gen) would still work nicely with /a but also be more readable.. Yeah, I personally think this is probably an Emacs issue. I'm not at a computer right now, but it'd probably be easy to repro by using asyncio.ensure_future on a future that sleeps and then prints stuff. . > Ryan, did you mean to attach those comments to particular lines of the file?\nWTH my mobile GitHub client is screwing with me. :neutral_face: I'll delete them and re-add them to the proper lines.... I think the idea behind using #_ is that it behaves less like a normal comment and more like a compile-time version of _ = xyz in that it discards something. . #; would also be harder for editors to highlight. Not too much more difficult, but a bit. . We could always import hy automatically, which also pollute the global scope a bit less. . @gilch Ready for merge...based on your comment, it seems like there's nothing else to really do? (Just checking first.). I doubt it'd really be any slower than Python's imports already are TBH. . Try ~(list-comp instead of ~@(list-comp. The latter is passing each of the models from the list directly to cond. It's a bit like the difference between func(x) and func(*x). . Huh, this might be an issue with model wrapping. What happens if you wrap the (list-comp call with (HyList ...)? (I think you have to import hy.HyList first.). Minor change, so I just merged with one approval. :+1: . Two ways to see this:\n\n() in many functional languages is a unit value, so it would make sense by this logic to make it the empty tuple. (Based on the unit definition, it would actually be None, but that makes literally no sense here...)\nOn the other hand, this is a Lisp, where () signifies expressions, but the concept of an empty expression doesn't really make sense. Therefore, it should be disallowed.\n\nIn all honesty, based on the latter definition (an \"empty expression\"), I'm REALLY tempted to say that it should be a pass-like item, but that (again) wouldn't really make much sense.\nAll that to say: it should probably be disallowed.. I also prefer the manual merging, and our pull request volume is hardly that of e.g. CPython's, so it's not like PRs are going idle and getting buried. . @spiderbit As already stated above, Hy has a let implementation that mostly does what you want. Using del has been discussed before but rejected because it interferes with closures. . FWIW I actively monitor the mailing list.\nAs a side note, personally, I'd like to see some medium of message-based communication instead of IRC, since the lack of message persistence kind of hurts it a bit and bouncers are a PITA to set up. Maybe try something like Zulip or Matrix? (The former is more like a mix of Slack and email, and the latter is more like IRC.)\nThere are other services too, of course, but @paultag would probably prefer something OSS.... Matrix's IRC bridge is known to be a bit finnicky, though. Apparently they're working on an improved version, but it's not ready yet. \nThere are also some niceties that native Matrix has that can't be matched by IRC, like Markdown support (for e.g. embedded code blocks). Zulip also has a neat ability to create drafts, kind of like email. . I think anything passed via the command line should be automatically assumed to be a Hy module. Other than that, the import rules could probably stay intact.. Well IMO if someone's using Hy to run a non-Hy file, they're doing something very wrong... . Ah, I remember this from another site. Can't find the RTD issue #, but here's how gunicorn fixed it. . ...why though? The main bottleneck with Hy is pretty much solely lack of developer time, and I don't see how adopting a contribution process that would have to be read by new contributors (which would increase the barrier anyway) would be beneficial. This project is a lot smaller than ZeroMQ is.... > When people learn that their contributions are delayed for months and years, they will leave.\nWe already have policies in place for this. This is usually the person's own lack of time, and our contributor's don't really have enough time to go through fixing/reverting everything. \nI understand stuff like this has merit, but I just think we aren't at the size or even PR count where that's even necessary, and the last thing we need is to have merged code that doesn't work. . Now that I think about it, should we really have &optional? It seems a bit awkward given how defaults work otherwise...maybe just allow someone to omit the default but still use inner brackets to imply a default of None?\n(Also hey look, I'm not dead.). Maybe helpful, but IMO if you're doing something like this in Python, your APIs aren't really well-designed.. Always fun when downstream messes with major packages this much.... Hmm, if no one else is interested I might try tackling this.. I was able to make them work on older Python versions too, you can compile them to individual format(xyz) calls and add the results together. . > Since you and are the official big boys now, Ryan.)\n\ud83d\udc40\nJoking aside, this sounds great to me! . Merged with one ack because it's a pretty minor and non-controversial change. . Personally I'm a huge fan of Azure Pipelines, since their free OSS tier is pretty liberal and is pretty fast.. @berkerpeksag  Well, the basic idea was that 'default' will be used whenever RTD fails with anything, that way the user won't get crazy error messages related to stuff they don't care about if they're building the docs themselves.\n. @berkerpeksag I had to pick between putting the magic crap in the Makefile or .travis.yml. Since the Makefile already had testing code, and I had to set Make's environment variables, it was just easier to do it there. That is, when I actually remembered to put tabs instead of four stupid spaces.\n. @zackmdavis Yeah...that was a brainfart. :)\n. @zackmdavis Makes sense. Would it go in native_tests/language.hy?\n. @zackmdavis I had intentionally used the Python 2 version to show the difference between the similar-looking dict literal. Of course, if you want to change it, I'll do it. :)\n. @zackmdavis Fixed.\n. @zackmdavis Fixed.\n. @paultag @zackmdavis Fixed.\n. @zackmdavis Fixed.\n. @gilch getargspec won't work on functions Python thinks are builtins. Ultimately, the rest of this is needed anyway because of non-alphanumeric argument names (e.g. (defn f [@@])).\nHowever, I probably should look into what the issue is regarding the getargspec call itself.\n. @hylang/core Come to think of it, maybe Hy should alias input to raw_input under Python 2, kind of like it does map.\n. There are already some tests for dot application here; try adding these there instead.\n. @gilch Oops. Then this whole change is unneeded.\n. This is kind of confusing. Maybe, in the earlier sections of the tutorial, it should mention the int <> long difference and how Hy handles it, and then, down here, just refer to that section.\n. Uhhh...foo is a really odd name here. What if you just put the whole thing in the call to self.compile? e.g.:\nfunc = self.compile(HyExpression([HySymbol('.').replace(fn),\n                                  expression.pop(1)] + attrs))\n. Normally, when testing for an exception, the following style is used instead:\nhy\n(try (f x)\n      (except [TypeError] true)\n      (else (assert false)))\n. Shouldn't this also be assert-requires-num?\n. Now I wonder if this whole thing can be reduced to:\npython\nif expr in (\"&optional\", \"&rest\", \"&key\", \"&kwonly\", \"&kwargs\"):\n    if len(defaults) > 0:\n        # ...\n    lambda_keyword = expr\n(This isn't necessary for this PR; it's just me wondering out load.)\n. @Kodiologist True.\n. Pretty sure this won't work outside the original directory , like python ../setup.py. You should pass working_directory=os.path.dirname(__file__) to check_output.\n. This whole \"unknown version\" thing kind of icks me a bit. Here's a thought instead:\n- version.py contains something like this:\npython\n  __version__ = '0.12.0' # Or equivalent!\n  try:\n     from hy._version import git_hash as _git_hash\n  except ImportError:\n      pass\n  else:\n      __version__ += 'g' + _git_hash\nAnd then setup.py just writes _version.py. That should get rid of the whole issue with version.py being non-existent.\n. Just to make sure, will this point to an old hash if I do setup.py develop and then change the Git hash?\n. @Kodiologist Oh wow, I didn't realize that. I'd prefer supported it personally, since it just adds one extra keyword argument. Though I suppose it's an extremely rare use case...\n. tuple? (Also, missing the before REPL.)\n. ...this is kind of confusing. I mean, I'm guessing that there will likely never be a \"simple\" explanation for something like this. I think maybe at minimum the example should use something more descriptive than x; maybe assigned_name?\n. Maybe this should be surrounded by double-backticks for formatting? The sentence could also be worded a bit differently, like:\nIn these examples, the REPL will report a tuple (e.g. `('Sepia prashadi', 'Sepia prashadi')`) as the result, but only a single value is actually returned.\n. REALLY minor nitpick, but this would be a little easier to read without the e.g., since I think it's obvious that it's an example.\n. ???\n. This branch and the two that follow repeat a lot of code and don't handle stuff like (require [x [* *]]) correctly.\n. It seems kind of odd that require and import handle a pretty much identical syntax in completely different ways. Would it somehow be possible to somehow merge the two?\n. @Kodiologist Probably be an error, though (import [x [* *]]) works for some weird reason.\n. Should this just be worded \"makes each requested macro available\"?\n. The sequences module. I know this is SUPER nit-picky...but there's a missing comma after generators.... accessing the same element. allows for?. Missing comma after macros.. The simplest\n(Also, the colon is unneeded.). Colon shouldn't be there.. to signal the end. Missing comma after sequence.. returns the amount in the sequence , and negative indexing is supported. the whole sequence. Sequences or The sequence or A sequence\nThe/a canonical example. results with a/the sequence of. Out of curiosity, is there a reason this isn't (setv self.func func) (same for the others)?. And don't forget the colon at the end of the line!. with the bleeding-edge\n(Also, do people normally capitalize GitHub?). if options.FILE is None\nOtherwise, this will end up reading from stdin with the empty string as an argument.. This is kinda bugging me. I mean, it just feels a bit weird to duplicate such similar calls. What if you did a function partial, like pretty_error_partial = partial(pretty_error, ...) and then used that? (I should've said this before, shouldn't I... :/ ). @Kodiologist I meant:\npython\nif stdin_text is None:\n    pretty_error_partial = partial(import_file_to_hst, options.file)\nelse:\n    pretty_error_partial = partial(import_buffer_to_hst, stdin_text)\nand then replace all these with pretty_error_partial(whatever_other_args).. It would be a bit helpful if you went into more detail on what trampoline and recur are referring to here.. If all you're doing here is removing the TailRec element from the list, just do iexpr[1].remove(\"TailRec\")...unless I'm missing something?. Also, it should probably be ensured that __future__ imports are at the top of the file, just like Python does.. (is _cache None)?. Can be shortened to (. sys.modules [\"hy.lex.parser\"] hy_symbol_unmangle).. Whole thing can be shortened to (isinstance k basestring).. @Kodiologost My bad. It should be hy._compat.string_types.. Oh right, sorry, I just apparently have no ability to read. facepalm. We already have something like this here. Anything here should probably go over in docs/hacking.rst.. Should the indentation on these be adjusted now to line up better?. As a side note: why exactly was this changed?. How much of this test was actually do to let? It was added in this bugfix commit, yet the bugfix didn't seem to have anything to do with let. Was this fixing another bug that just happened to be easy to reproduce using let?. @Kodiologist Got it. Here's a test case that still applies to the latest Hy:\n```hy\n(defn test-if-return-branching []\n  \"NATIVE: test the if return branching\"\n                                ; thanks, algernon\n  (defn f []\n    (if true (setv x 1) 2)\n    1)\n(assert (= 1 (f))))\n```. @gilch Hy re-exports them in the main module: https://github.com/hylang/hy/blob/master/hy/init.py. How about changing all the in lists and dictionaries to just in collections, since it's a bit simpler and handles more built-in cases (e.g. tuples, strings).. Second and is redundant (though I feel like this might be easier to read if the section on empty literals was a separate sentence).. How about:\n\nrest takes the given collection and returns an iterable of all but the first element.. Is this really that useful? IMO part of the charm of Python is duck-typing, where someone can pass a custom but API-compatible list subclass, and it \"just works\". Can't you just do isinstance(tree, list)?. Fair enough.. I'd rather not, since other parts of the Hy source code use the full, more drawn-out or.. Last thing, I swear!! :O\n\nWould this be better as:\npython\ntokens = tokenize(source)\ndo = HyExpression([HySymbol('do')] + tokens)\ndo.start_line = do.end_line = do.start_column = do.end_column = 1\ndo.replace(do)\nthat way the (do ...) doesn't appear in the stack traces/compile errors?. Why is the outer list here necessary? [::-1] should already be returning a list anyway.. == '...'? To prevent a weird error message coming up without anyone realizing it.... @Kodiologist ...which is why the in operator is also equally as awesome as ==. ;). @Kodiologist Yeah, but it's better than nothing!. This part should be encased in a try...except and treat an ImportError as a cache miss. If you switch from one version of Python 2 to another, this will break due to a magic number mismatch, and you have to run find . -name '*.pyc' -exec rm {} ';' as a workaround.. This can also fail with OSError in some (admittedly rare) cases.. Maybe also wrap this in a try...except? In the theoretical case where a source file disappears before the error is shown (don't laugh; I've accidentally un-plugged my external HDD and run into trouble before), this would outright crash, while maybe just printing a warning or just doing nothing would be a bit better.. What happens here if you have a package containing Hy files but with an __init__.py?. Won't this outright break if you run Python with -B or PYTHONDONTWRITEBYTECODE=yes?. Actually, nvm; I just saw you byte-compiled everything in setup.py. Still, maybe there should be a double-check to make sure the bytecode file's there, with a nicer error?. I don't really envy you right now... ;)\n(FWIW maybe we should think about using travis-tox)?. Uhh...yeah...I guess I got distracted by another comment?\nYeah, checking the magic number would probably work.. Why not just put these both under the same point?\n\nImporting or executing a Hy file will automatically byte-compile it and use the compiled version ...\n\nor something?. sigh We really need to work on our mangling...\nFWIW pytest lets you override the test prefix. Maybe it'd be worth it to do that with something like:\n```ini\n[pytest]\ninsert comment lamenting state of world, etc.\npython_function = test_ is_test_\n```\nAlthough it's a hack:\n\nIt's not much more hacky than a questionable (haha!) q suffix on every single test function.\nIt's a bit less weird to read. (random person looking through code: Why are there random qs everywhere?)\nThe test names will make more sense. This is testing coll?, not collq.... Should be something like:\n\npython\nimport os\nversion_file = os.path.join(os.path.dirname(__file__), 'hy', 'version.py')\ninstead, to support running Sphinx from a different directory.. Bikeshedding, but the indentation here is causing physical pain. :O. In conf.py you're allowed to import the main modules, so maybe this could just be shoved in hy/version_gen.py or similar? (Not a blocking issue by any means, but still something to think about.). Or even just a top-level version_gen.py, since it would only be used by setup.py and conf.py anyway.. I was mostly just referring to that the indentation on the last three lines should line up with the s on the first line.. I was referring to running sphinx-build manually. Admittedly something odd to do, but there isn't really any reason why it shouldn't work.. IMO this should be an error instead, rather than silently omitting the error handling.. Missing space in expression><attr.. If these new error ignores are solely for the single-line defs and close-together withs in the tests, maybe it'd be worth it running flake8 on just that file separately, or using # noqa comments (which is what I think would be better).. True, but I personally feel like the surprising worst-case behavior is a lot more confusing than the benefits from the best-case behavior.... PY3 seems like a randomly added import here.... TBH now that I'm looking at this again, it should probably be (issubclass t float).... ...uhh, is this really necessary for this PR? I know it makes things a bit shorter, but it's also only used a few times and seems rather off-topic.... FWIW most Python style guides prefer the closing paren on the same line.. Slightly bikeshedding, but here value is switching types which is kinda confusing. Usually in the compiler code, this would just be something like:\npython\ncompiled_expr = self.compile(expr[1])\nret += compiled_expr\nvalue = compiled_expr.force_expr\nor maybe another name still.. Minor issue, but this would read a lot better as:\n\nreturning either its argument or None if called without\n\ne.g. adding either and a comma. Right now it's ambiguous which clause the or None is attached to.. FWIW this probably would never happen, but I think it'd be safer (and more descriptive) to use ast.literal_eval here.. ahem... in my defense I'm on a phone right now.... Sorry for the delays, but...adding an extra argument args= that's really...odd (you can pass arguments through both cmd and args) for just one test case feels really wrong. A simpler change would be:\npython\noutput, err = run_cmd(\"hy2py -s -a \" + shlex.quote(os.path.join(dirpath, f)))\n(Of course, using pipes.quote instead on Python 2.) Then you can drop the whole args mess.. Leftover debugging statement?. I feel like this would be a lot shorter and easier to read as just:\npython\nif hasattr(self.expression, 'start_line') and ...\nOr even if you decide to stick with the all route, switching to hasattr would still be best.. IMO for simplicity purposes (also because (not (not ...)) is pointless), this should be compiled to something like this instead:\nhy\n(while True\n  (setv anon-var expr-here)\n  (if-not anon-var (break)))\nRight now the condition is being tested twice, and again the double nots aren't necessary.. @Kodiologist touche. Couldn't you still do anon-var.__bool__() though?. It's __nonzero__ on Python 2.. FWIW I'd at least prefer a comment explaining the not not.. @gilch Uh, yeah...did I miss something? Using a mobile app, so I'm not sure if I screwed something up...\nIMO considering the previous step was closing the REPL, and this one looks like a shell command, it seemed obvious to me. . and a syntax error. Maybe be explicit that these few examples are for commenting out list items? Took me a few moments to realize it.. ( and }?. These two bullet points should probably be together to make it easier to see the connection.. Was the extra indentation accidental or intentional? I don't see anything here really justifying that.. Maybe mention that semicolon count guidance is below?. ",
    "khinsen": "Oops, I messed up my branches... there are tests, and I just fixed the bug jd spotted, but they are on the float_and_complex branch. I don't know if there is a way to move them to the lexer_extensions branch.\n. That was the occasion to learn about \"git cherry-pick\"... So this branch should be fine now, waiting for @olasd to have a look at it.\n. I agree that atoms as expressions are practically useful only at the REPL, which is where I really missed them. However, both Python and Clojure allow atoms as expressions in scripts and modules, so this is not an unusual feature. Moreover, it doesn't do any harm as far as I can see.\nBTW, allowing (+ 2 2) as a top-level expression makes just as little sense outside of the REPL. Expressions must have side-effects in order to make sense in a program. It's probably highly non-trivial to decide if an expression has side-effects just from its syntax.\n. I based this by mistake on my branch lexer_extensions. I will close this request and submit a new one based on master, with tests as a bonus.\n. Personally I'd be happy with returning fractions, which have been part of the Python standard library since 2.6. But for a Python-compatible language I prefer following Python habits as much as possible. We can always provide a more lispy math stack with fractions etc. in the Hy standard library ;-)\n. Non-first and also outside of a parenthesized form, to allow returning + as a function value.\nThat's why my first idea was to actually make + just a symbol for operator.add, and then have the compiler optimize calls to operator.add at the AST generation stage. That covers all the cases because it's just what any other Lisp does.\n. Actually, not operator.add, because that function takes only exactly two arguments. Sometimes Python is more limited than I expect... So we'd have to provide our own functions, something like\ndef add(*nums):\n      return sum(nums)\n. OK, I volunteer to do a prototype. Which doesn't mean that no one else should try in parallel.\n. Looking at manglers and hoisters... Could someone please explain how \"if\" is related to scopes? \"fn\" is pretty evident, but \"if\"?\n. That particular case could become \"print 1 if True else False\" in Python, but I see the point. When I saw \"scope\" I thought of name binding scopes.\n. The code generated by the example you give looks pretty inefficient: function calls are expensive in Python. A more efficient transform would be to something like\nif True:\n    print u'foo'\n    _hy_value_1 = 1 + 1\nelse:\n    _hy_value_1 = False\nprint _hy_value_1\nI do realize that this is (1) premature optimization and (2) off-topic for this thread, but I prefer to write down ideas before I forget them ;-)   And yes, I also realize that this is more difficult to do as a transformation.\n. All that sounds very promising, but I haven't seen anything that would resolve the number of arguments issue for operators. What we really want is variable argument lists. Performance aside, is there any reason not to do that?\n. No star-apply, but we can make a lambda that uses reduce and operator applied to two arguments. Yes, I know, it's going to be slow.\n. Fixed. This actually worked because of the \"build\" decorator.\n. I am not very happy about the \"print hack\" either, but overall I prefer an ugly hack in the exceptional operation (decoding the AST) to an ugly hack in regular operations (expression and statement evaluation).\nAdding the import to the AST cannot be a general solution because the future imports must happen in the first line of a module, because there's an impact on code generation. So AST modification is only an option when we treat the source code of a complete module. BTW, it's perfectly OK to do that /in addition/ to the change in the compile call. Twice future division is still future division.\nThis whole future business is a pretty ugly hack in Python, if you want my opinion. There are plenty of unpleasant surprises lurking. For example, if you write a module loader in a module using \"future division\", then unless you are very careful the loaded module inherits the division setting. Which I think is one more reason to use \"future division\" everywhere in Hy. We may tear out some hair but our users will have eternal peace ;-)\n. How about mangling\n(foo (if condition true-branch false-branch))\ninto\n(do\n    (if condition (setv__temp__var__ true-branch) (setv __temp__var__ false-branch))\n    (foo __temp__var__))\nwith a generated unique __temp__var___, and then make the compiler handle\n(setv foo (do ...))\ncorrectly? That should (1) solve the if problem and (2) make (setv foo (do...)) work correctly (which is not the case at the moment), without introducing a new keyword. I do realize that modifying (do ...) to return a value in all circumstances is not trivial, but I think it's a worthy goal in itself.\n. Sounds good. Could we then move the hoisting code in the if-mangler to a more general place? The same problem occurs wherever an expression uses the value of a do-form, and the same solution (introducing a temporary variable) should work everywhere. An example would be\n(+ (do 2 3) 1)\nwhich right now crashes Hy.\nUnfortunately I don't understand the mangling and hoisting mechanisms well enough yet to propose something more concrete, such as working code.\n. My point is that (+ (do 2 3) 1) is nothing special - it's the use of (do ...) where a result value is required that needs to be handled in general. That's perhaps best done at the compiler level rather than the mangler level.\n. I see a more fundamental issue for which the edge cases are merely illustrations: Python makes a difference between statements and expressions, which Lisps don't make. We are thus trying to compile a more general language into a more restrictive one, which is the cause of all the problems mentioned in this thread. I wonder if we can solve the fundamental problem once and for all.\n. OK for occasional use, but it's cumbersome (extra import, longer name, one more level of parentheses) and inefficient (two extra function calls plus one object creation).\n. Maybe I am missing something.. is that in Hy? \n. The idea of auto-import is worth exploring, I had a similar wish recently for auto-importing operator.\nMoreover, it looks doable with reasonable effort and without littering the generated code with import statements. Instead of building and returning a plain AST, the compiler could build and return an AST plus a set of modules to be imported. Just before compiling the AST to bytecode, the set is converted to import statements that precede the compiler-generated AST.\n. Having done this before in Clojure (see https://github.com/clojure/tools.macro/blob/master/src/main/clojure/clojure/tools/macro.clj), I am sure it can be done. One approach is the one I took in Clojure to implement macrolet and symbol macros: do a full recursive macroexpansion of an expression before passing it on to the compiler. This requires that the macro expansion code knows about all special forms that create bindings. This is probably the approach that is easiest to do in Hy, since it already does complete macroexpansion before compilation.\nThe other approach is what most Lisp compilers do: do macro expansion in the compilation phase. When the compiler gets to a specific s-expression, it checks what the current binding of the first symbol is and does either macro expression or compile a function call.\n. There is one additional complication. Consider the code fragment\n(setf rev math.sqrt)\n(rev 2)\nIn principle it sounds OK to treat each top-level form separately. The above code fragment would thus use the rev macro and would probably be considered buggy. However, in the context of issue #181 this becomes a problem: The author of these lines might never have imagined that rev is defined as a macro elsewhere.\nIn my opinion this is best handled by fixing issue #181.\n. Interesting. My own experience is with Lisp-1 dialects (Scheme and Clojure), which I think is what Hy tries to be, given that Python works that way too.\nI really know very little about Common Lisp, but wouldn't you have to use flet to get the equivalent of my example? If so, how does that behave when shadowing a macro name?\n. I think I found a nice way to implement correct macro expansion - stay tuned :-)\n. Commit 099e78d is my first attempt. It is pretty straightforward to handle all of Hy in this way. There are two downsides to this approach:\n1) The macro handler for each non-standard expansion has to know the detailed syntax rules and thus duplicates much of the information in the compiler.\n2) The macro handler must gracefully handle syntax errors and pass them on to the compiler, which emits the error message.\nThe obvious way around these limitations is to integrate macro expansion more tightly with the compiler (like \"real\" Lisps do). I am playing with such an approach as well, but I keep running into weird exceptions raised in the \"compile-time hack\" for defmacro.\n. The compiler does indeed do macro expansion before compiling a subexpression, which is why I tried to simply remove the recursion from hy.macro.process (see commit ae2646d). However, that leads to a weird crash when using defmacro:\n=> (defmacro foo [] 42)\nTraceback (most recent call last):\n  File \"<console>\", line 1, in <module>\nTypeError: _() takes exactly 1 argument (0 given)\nI have no idea where and why this crashes, there is no function call _() anywhere in the code. The crash happens in the \"compile-time hack\" that evaluates a defmacro at the same time it compiles it, so I suspect the _() is in the generated code. PDB isn't very helpful in analyzing this, unfortunately. That's what got me started on #186, the hope being that cleaning up the recursive macro compilation first would make this simpler to analyze.\n. I started to investigate how to implement this. It doesn't look particularly difficult, but it requires a simple but fundamental change to how Hy expressions are compiled: every expression needs to be accompanied by the module that defines its compilation context. That requires an additional argument to lots of functions in hy.importer. Does anyone see a problem with that?\n. There are many changes in many files, but nothing particularly fundamental or complicated. I'd appreciate a critical look from those who have worked on the macro implementation before.\nThere is one debatable aspect from a language design point of view. To use macros defined in another module, a require must be used, even if the module is already imported. I like to keep compile-time macro use and run-time function/data use separate. But one can argue for doing an implicit require after every import.\n. Thanks for the great suggestions. I'll push a cleaned up version.\n. After much thought, I figured that we should consider Hy a Lisp compiler and thus distinguish between compile time (Hy to Python-AST) and load/eval time (import of the Python module), just like Scheme does. And then the solution is obvious: introduce eval-when-compile for definitions that are accessible from macros. It's perhaps less elegant than the solutions I had envisaged earlier, but also clearer (to those who understand the problem) and a lot simpler to implement. Plus there are respected precedences in the Lisp universe.\n. I actually stole both the name and the semantics from elisp. I agree that the name suggests that the evaluation is limited to compile time.\nI don't see a point in evaluating something only at compile time but not at runtime, so I'd like to keep the semantics of the current version, but I am open to suggestions for a clearer name.\n. Oops, you are right, it's eval-and-compile that I tried to imitate. And now I am hesitation about whay I want, because in elisp it's eval-when-compile that is used much more frequently.\nLooking at my own use cases, all I need is eval-when-compile but it never does any harm to use eval-and-compile instead. I can easily construct use cases that require one or the other, but they are made up. My real-life Lisp experience is mostly Clojure, which doesn't have the distinction between compile and load/eval time.\n. I am not sure this is the right way to fix this. When Python executes a script, it puts the script name into sys.argv[0], replacing the name of the Python interpreter. It makes sense to have Hy do the same, and then the bin/hyc script should work just fine. With that point of view, the bug is in bin/hy.\n. Lazy sounds interesting, but I am on vacation without a computer until end of July,  so I can't look at this right now.\nKonrad\n-----Original Message-----\nFrom: Paul Tagliamonte notifications@github.com\nTo: hylang/hy hy@noreply.github.com\nCc: khinsen konrad.hinsen@fastmail.net\nSent: mer., 10 juil. 2013 0:49\nSubject: Re: [hy] Add set of new core functions (#236)\nI very much ACK the lazy versions of functions showing up in core. I'm mildly in favor of ^, but something a bit more sensible would be interesting.\nI summon @jd @agentultra @algernon @khinsen and all the other Lispers to comment\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/hylang/hy/pull/236#issuecomment-20711037\n. After some quick tests, I wonder why we have hy.core.macros at all. We can move the macros to hy.core.language. That's one file less, one special import mechanism less, and Bob's problem is solved as well. But I didn't write the current import stuff for the standard library, so I may have overlooked something.\n. What you need to add to bang.hy is (import [mac [foo]]).\nExplanation: (require mac) makes the macros defined in mac.hy available in bang.hy at compile time (more precisely, hy-to-python compile time). It doesn't make foo available at run time. Wrapping the definition of foo in eval-when-compile would allow to call foo in the definition of the macro bar, but it doesn't magically import it into another module.\nSo far for how Hy works right now. The example shows a common Lisp idiom consisting of a macro expanding into an expression involving a call to a function defined in the same module. Hy should have some nice way to express this. This is less straightforward than in other Lisps due to the way symbols and namespaces work in Python.\nProblem #1 is deciding how symbols used in macro expansions should be taken from by default. For now, they are taken from the namespace in which the macro is used, not the one in which the macro is defined. Worse, there isn't any way to specify that they should be taken from the macro-defining namespace. There should be one, and probably it should be the default. But doing this is not trivial.\nThe fundamental issue is that Python provides no way to refer to a symbol inside a given namespace directly. What a symbol means is always defined by the import statements of the module it appears in. We could make macro expansions include some imports, of course, but then we risk a name clash with explicit imports made in the module that uses the macro. One possible but ugly solution is to use gensyms to refer to such automatically imported names.\n. There is one solution I thought of but I don't like it.\nAfter the require, we know that the module has been loaded and is in memory. That means it's in sys.modules. So we could replace the symbol by an explicit lookup in the original module starting at sys.modules. That's ugly, and that's slow, but it should work.\nAnd there's of course the gensym approach which is also ugly, but at least not slow.\n. I thought we already had gensym, but didn't check. It's pretty much compulsory for non-trivial macros (once you start caring about hygiene), so I'll create an issue for that immediately.\n. For the record, I get the same failures under MacOSX, so it's not just Windows.\n. As usual the devil is in the details...\nMy first reaction is to proclaim that using a namespaced symbol implies the same responsibilities as importing a module. So if the module doesn't exist, that's a bug and the just punishment is an ImportError. But I think it's better to look at corner cases once there is a working implementation for the standard ones.\n. I have a first working implementation. Everybody is welcome to rip it apart ;-)\n. Looks good to me overall, except for the multithreading issue.\nOf course, the chance of concurrent invocations of gensym is extremely small, since in normal use it is called only the first time any module is imported. But when there is a race condition, the consequences are subtle and irreproducible bugs in the Hy program being run. So I propose protecting gensym by a lock. Performance shouldn't be a problem for anything run only at compile time.\n. I changed my mind about the multithreading issue. We haven't cared about it elsewhere, so I propose we open an issue where we note all the global state that can potentially create trouble and find a global solution one day. Thread-local storage is perhaps a better solution than locks.\n. @Willyfrog : I don't see in what circumstances I would use this macro with any default arguments. It's used where different code is needed for Python 2 and Python 3. True/False are the same i both.\nYou can definitely use macros inside other macros. Your example doesn't work because your macro calls itself recursively. This one works:\nclojure\n=> (defmacro test-if-python2 [is2 is3] `(if-python2 ~is2 ~is3))\n=> (test-if-python2 True False)\nTrue\n. +1\n. I suspect it's an historical accident that macros and functions of the \"standard library\" were in separate files loaded by different mechanims at different times. But only the original authors can confirm. Do so, please!\n. @paultag Yes, functions in language.hy can use macros defined in the same module. Bob's new functions are the best evidence. For now I can't see where else in the Hy code base these macros might be needed, which is why I am tempted to believe that this patch is OK. Unfortunately the code base has become too complicated for any level of certainty :-(\n. Indeed. I just saw Travis CI even checks with PyPy.\n. I am trying to catch up with this thread - and my first reaction is to agree with @olasd: please, everyone, keep this a pragmatic issue rather than an ideological one.\nNext, some background considerations. True and False are relatively new additions to the Python language, and are in fact little more than syntactic sugar for 1 and 0. Even in Python 3, you can use False as a substitute for 0 everywhere, and True for 1. This is a feature of the Python bytecode interpreter, so we are not going to change it. There is also the issue of dealing with None, which tests as False in Python. Implementing is_truthy in a sensible way is probably a non-trivial job. Which means that getting this right requires a lot of practical testing. And that raises the question if it's really worth the effort.\nOn the Lisp side, there are already different approaches. Scheme and Common Lisp have different conventions, and newcomers like Clojure add other variants. I don't see any philosophical problem with introducing a Lisp that adopts Python's conventions for booleans, given that they are consistent and reasonable.\n. @noprompt: The problem is not writing the implementation, but being sure what the best semantics are. You propose that every value other than False and None should test as True. How much code did you write to validate this choice in practice? We do have to interoperate with Python code, and the transition should be fluent. We don't want lots of \"truth converters\" at the Hy-Python interface.\nConcerning your judgement of Python's conventions for booleans, I think you are too quick in extrapolating your Lisp habits to other languages. Kenneth Iverson, the inventor of APL, has made a good case for not having booleans at all and use 0/1 instead. He showed that the common boolean operators become just special cases of more general arithmetic operators with this choice, and that those arithmetic operators are useful in their own right. You can see this approach at work in a lot of NumPy code. For example. numpy.repeat is most often used as filter for arrays, but it is a useful generalization of filtering.\nThe choice we are discussing is not between a \"good\" and a \"broken\" definition, but between the conventions of our target platform (Python) and those of our source of inspiration (Lisp).\n. The question of how to handle the historical mess of the Lisp universe is not a simple one. Ideally, we'd all be better off with a single Lisp dialect. But it's so easy to personalize the language that many people did it and more will do so in the future.\nIntroducing \"flavors\" conveys the message that we are aware of the existing diversity and don't want to exclude anyone. Presenting a single language conveys the message that we want to do better than the mess of the past. I'd prefer the second message but I am not sure it would be credible. It would easily be understood as \"this is our language and if you don't like it, make your own\".\n. In between \"core language\" and \"third-party libraries\", we could have flavours as separately distributed libraries in the \"hylang\" organization. A bit like Clojure's \"contrib\" libraries, which are not part of the language but still have the stamp of \"recommended by the community\". The message would be \"if you want to program scheme-style, please adopt our scheme style rather than making your own schemish style\".\n. LGTM\n. ",
    "garyposter": "Sorry for being dense, but how does the kwapply change allow reader macros?\n. Heh, ok. Thanks for the clarification.\n. \"Real life\" might be a stretch, since I'm just looking curiously at Hy at the moment, but I looked into this because I was curious to see how tightly something like http://pythonhosted.org/pysistence/ might be integrated into a Hy environment (without baking it into the parser).  For example, #p[1,2,3] for a plist and #p{'foo': 'bar'} for a pdict might be cool.\n. Very cool.\nDoes a reader macro on a list like #^(foo) work also, so that the list, and any nested lists, are escaped?  That would be just about as nifty as I could hope for. :-)\n. thanks, awesome :-)\n. ",
    "gekailin": "What's the status of this issue now? I'm so eager to see reader macros in Hy, cause I can use them to do awesome things :)\n. For example, I can do this in Common-Lisp by 'set-macro-character' and/or 'set-dispatch-macro-character':\ne 2_3+1/3 end        --->             (+ (_ 2 3) (/ 1 3))\nThis actually can change the grammar as what I want, and I want a similar thing in Hy.\n. ",
    "berdario": "In the Hy repl it's possible to redefine builtin, and the builtin will still be used in the expected places (so there shouldn't be any performance hit), not sure why there's this difference (I've been playing with Hy only for 1 hour).\n. ",
    "vladimir-g": "I don't know how to properly test this thing, but I've tried to write simple test here: vladimir-g@cf37bba421440f25c4c944195c4a27f8f3fc60ca\n. ",
    "waucka": "Fair enough.\n. ",
    "jpanganiban": ":+1:\n. :+1: \n. ",
    "cereal": ":+1: Good idea dude, do you have an idea how this could look like? :)\n. Hey, yeah dude this sounds totally legit to me since even bash does\nsomething like this.. only syntactically uglier\nAm 24.06.2013 12:14 schrieb \"Gergely Nagy\" notifications@github.com:\n\nI like the lambda, but an all unicode prompt is a bit awkward for my\ntaste. \u00eb > or something similar I would be happy with. Or even better,\n~/.hy-repl (or something else, like ~/.config/hy/repl.hy) being\nauto-imported and evaluated when launching the repl. Then everyone could\nset the prompt whatever way they like.\n\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/pull/200#issuecomment-19898798\n.\n. Oh damn and sorry for my stupidity :(!\n. hy 0.9.8\n=> (defn foo [n]\n...   (if (< n 10)\n...\n...     (let [old-n n]\n...      (setv n (+ n 1))\n...      old-n)))\n=> (foo 2)\nTraceback (most recent call last):\n  File \"\", line 1, in \n  File \"\", line 4, in foo\n  File \"\", line 5, in _hy_anon_fn_1\nTypeError: unsupported operand type(s) for +: 'NoneType' and 'int'\n\nNot over here .__.\nOn Tue, Jun 25, 2013 at 12:22 AM, Gergely Nagy notifications@github.comwrote:\n\nJust an interesting tidbit, if you want to return a value after changing\nit, let is your friend:\n(defn foo [n]\n  (if (< n 10)\n(let [old-n n]\n (setv n (+ n 1))\n old-n)))\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/issues/205#issuecomment-19940405\n.\n. \n",
    "mattl": "jd -- paultag asked me to add any ideas I have for hy-named things here.\n. ",
    "eigenhombre": "ok, thanks, I misunderstood our exchange on IRC.  I'll see what I can do about tweaking core/bootstrap appropriately.\n. OK, PR updated as per, above.  I still wonder if there is a place for functions, implemented in Hy itself, rather than in Python.  E.g, take would just be (defn take [n coll] (slice coll 0 n)) in this core library.  Not necessarily for these functions, but for some functions which implement core language functions, bootstrapping from the nice Python implementation, but leveraging Lisp, in the same way that most Python standard libraries are written in, you said it, Python.  Just a thought.  At any rate, let me know if this looks OK.  Thanks!  --John \n. One concern is that we do want to minimize the runtime / startup overhead of the core language (a problem that IMO Clojure suffers from at startup), so perhaps these would best be addressed via an import mechanism rather than automatically inflicting them on all users...?  Not sure how to slice-and-dice this....\n. If someone wants to +1 this and tell me where to put the functions, I'm happy to start the effort moving forward.\n. I'm still struggling as to how to do the auto import thing exactly.  I've been pursuing the approach of adding something in bin/hy early on, such as:\n```\nfrom hy.importer import import_file_to_module\nstandardlibs = ['nicelib']\nfor lib in standardlibs:\n    print \"importing lib...\", lib\n    mod = import_file_to_module(lib, lib + \".hy\")\n    sys.modules[lib] = mod\n```\nhere nicelib.py is in the project toplevel just to try and get something to work.  But, this approach hasn't worked for me yet.\nAm I barking up the right or the wrong tree?\nAnyways, will keep at it now and again when I have time...\n. I guess we collided there.\n. No worries - do I have to be in the Hylang organization to 'take' issues on GitHub?  It's not clear to me how that's done.\nOn Apr 23, 2013, at 9:16 PM, Will Kahn-Greene wrote:\n\nSorry about that. It didn't look like any one was working on this, so I assigned it to myself, tossed a comment in and then implemented it.\n\u2014\nReply to this email directly or view it on GitHub.\n. Sounds good!\n. Where should this be documented?\n. Whelp, we sure collided there.  Oh well.\n. Much appreciated, folks. Plenty of us are still stuck on 2.6 for a while to come. \n\nSent from my iBrick\n\nOn Nov 10, 2013, at 8:08 AM, Paul Tagliamonte notifications@github.com wrote:\n@willkg I agree, but this is a minor thing to change\n\u2014\nReply to this email directly or view it on GitHub.\n. It looks like this is still up for discussion...?  As a full-time Clojurian coming back to Hy after a few years away, I'm still playing catch-up as to how let is broken in Hy (Python); but after getting over my initial visceral reaction (\"you'll have to pry let from my cold, dead hands\"), I would like to +1 what @algernon wrote in favor of let, above.  Almost every Lisp I've used has a let, or several.  Aside from providing a certain kind of scoping behavior, let, especially in Clojure, usually signals the following intentions:\n1. I'm going to take a value and bind it to a name;\n2. I'm not going to change its value (generally; OK Clojure is immutable by default, but generally I'll program that way in Python too if I can help it); \n3. I only care about this binding in the scope of this form.\n   (I could also add:\n4. My binding might shadow another binding in the outer scope\n   but this seems less critical to me.)\n\nI'll be a little sad if Hy loses a shared (very Lisp-y) idiom for this most common of patterns.  If one can work around Python's strange scoping, all the better.\n. ",
    "rwtolbert": "cleared in #246 \n. I believe this PR can be closed. The changes to how CL scripts are created and run means there is no longer a bin/hyc script.\nAdditionally, \"hyc\" works with the new script changes. \n. This does look useful. Could be re-arranged to be a new entry point like hy/hyc. and then the tests updated to use it that way. \n. This \"take\" swaps the order of arguments both from the existing \"take\" as well as from the clojure version.\nLove the language idea, will add stuff as soon as it is ready.\n. As with take, this only works on actual iterables, not other iterators.\nI've added drop2 and drop3 as alternate versions in hyroad for you to take a look at.\nhttps://github.com/rwtolbert/hyroad\n. Yes, I think drop3 is the best version.\nthe problem with the previous drop is with iterators/generators:\n=> (.join \"\" (drop 2 (iter \"Hello, World\"))))\nTraceback (most recent call last):\n  File \"<console>\", line 1, in <module>\nTypeError: 'iterator' object is not subscriptable\n. Oh, i don't care about the license. I'd just like it if you can get your stuff in, then I can add to it if that's ok.\nKind of bummed no one liked the name. \nI thought \"hyroad.take\" (or hy.road.take) was kind of cute.\n. Plus, after thinking about the need for startup speed, it occurred to me that maybe all these functions could go into a hy-er level API, that is imported to make things feel 'lisp-y' (for those new to Hy). So the 'hyroad' seemed like a good name for a higher level API. \nWhether it is auto-imported or not could be a runtime decision. Yes for ease of use, or no for speed of startup.\n. I resorted to using (list) as an empty list.\n. Because I am blind. And was tired. And had too many square brackets to count in a let.\n(let [ [seen [] ] ] ...\n. 'pip install pyreadline' provides readline for Windows\nhave to figure out how to make a Windows-only dependency, but otherwise this should just work.\n. I have no problem just dropping this if there is a new parser coming. And I really didn't like this way to look ahead  anyway. \nRaw strings are just a feature I'd like to see. \n. Would've liked to get #215 in to fix the CL args handling. And a second one (that needs #215 in) that would allow complete Windows support. Or I can merge the Windows changes into #215 and make it one bigger PR.\nOr we can ignore Windows for now. ;-)\n. And #213 only fixes the import of readline on Windows. The 'bin' tests all fail on Windows. I have a branch with this all fixed but my branch will conflict with #213. I think the path to getting this all fixed and having Windows be a first-class citizen (no snide remarks) is to merge in #213 first. I can update #215 with those changes and then we merge #215.  After that I can merge all into the final branch that fixes Windows and we merge that. \nAnd as I said above, I can merge my two parts together into #215 (after #213 is merged) but it won't be a pretty set of commits, but the diffs are easy to look at.\n. ok, then I'm done till then.\n. OBE 0.9.10 released.\n. Fixed in #231 \n. Yes, I have a complete fix for this but since it is a change on all platforms @paultag wanted to put Windows off until after the 0.9.9 release. I've just been waiting for the release churn to complete before submitting it. \nNote that I will probably cancel #215 and make one complete PR that both fixes command line handling and brings Windows up to a first class citizen. I even have a make.bat file that parallels the Makefile.\n. Just added #231 that fixes this one.\n. Maybe should have added a new comment instead of editing the top comment. \nThe latest push fixes the problem of running \"hy foo\" in two important ways. The error above was due to a missing \"foo\", with hy dropping the user into the REPL. Turns out that if \"foo\" had existed and was a valid Hy script, it still would have failed since my naive arg splitting was looking for a file that ended in \".hy\" only.\nargparse provides the desired feature of splitting the command line into those are destined for \"hy\" and the script file and subsequent args meant for it. Instead of my original naive splitting, argparse does it correctly out of the box. \n. This needs a merge with master to fix conflicts in setup.py.  I've done this in a quick test on a local branch and I think it brings in a boostrapping problem in setup.py\nIn setup.py we import hy to get version and appname, but this import invokes a chain that tries to import \"rply\", which of course is likely not installed yet since we have it in the install_requires section. This is the error I get\n```\n\npython setup.py develop                                                                                    [10:28:10]\nTraceback (most recent call last):\n  File \"setup.py\", line 23, in \n    from hy import appname, version\n  File \"/Users/bob/Dev/github/hy/hy/init.py\", line 37, in \n    import hy.importer  # NOQA\n  File \"/Users/bob/Dev/github/hy/hy/importer.py\", line 24, in \n    from hy.lex import tokenize\n  File \"/Users/bob/Dev/github/hy/hy/lex/init.py\", line 21, in \n    from rply.errors import LexingError\nImportError: No module named rply.errors\n```\n. I agree that this is not pretty, but hard-coding the version into setup.py is probably worse.\n\nAll the tests pass now (:+1:) and all my personal odd tests work as well.\nGood to get this in and then we can look at cool new things that depend on this.\nHas my ACK.\nOver to you @paultag since this is a pretty big change. \n. This is interesting.\nDo you have a model for this? And do you think there will be the chance to abstract away the GUI bits so there might also be a PySide version possible? Not asking you to write that one, just thinking about the possibilities.\n. You know, I forgot that Python had a built-in filter. I went to write a reduce and found the Python one, so I should probably remove filter. The only advantage of the overloaded version is if we want the lazy-seq behavior, we can't get it with the Python built-in.\nWhile I agree that the lazy-seq stuff uses some memory, I don't know how bad it will be in practice. Note, that in a method like:\n(list (take 4 (drop 100 (repeatedly foo)))\nany temporary caches all go away and the only memory footprint is the final list of 4 items.  All this allows is being able to assign the result and reuse it. So the cache is only there to help you when you'd like to reuse stuff, I think. \nI know it is a bit different, and we can pull it all out. But I think it solves an interesting intermediate problem between always re-running a generator and always creating a full list (when you may only want part of it).\n. @paultag, a couple of other thoughts:\n1. Even without the cache these are all \"lazy\" in that they use yield. So (repeat \"s\") does do anything unless something else consumes it. In fact (take 5 (drop 2 (repeat \"s\"))) does nothing until you pass it to (list...) or (for ...)\n   The question is more about the cache, i think.\n2. I like the cache when I need it. I guess we could have \"take\" and \"cached-take\" although that name is an eyesore. But I think this does require the decorator magic as opposed to say a (lazy-seq ...) user-space function.\n. @paultag a strong argument for replacing the builtin \"filter\" is that with or without the cache, the Hy version as written is also lazy, whereas the Python filter is not. In fact, I'd say this is a strong case for also creating our own version of \"map\" that is also lazy.\nI think this is a decision point for general design. Leaving behind the caching for now (which I can easily remove), the real question is whether we make all methods that work on collections (or sequences) lazy by replacing Python builtin ones with our own. \nOr we leave Python builtins alone and move all these alternate methods to their own (not auto-loaded) module\nand do something like:\n(import [hy.core.lazyseq :as lz])\n(list (lz.filter even? (lz.take 5 (lz.iterate inc 5))))\nAnd then just not have autoloaded versions of take, drop, etc. \nI think it might feel weird for newcomers looking for these basic things, but it would allow more Python built-in stuff to show through at the default layer.\n. Since there is some discussion about the always-on usefulness of the caching, another option is to provide two versions, differentiated by some symbol/name so that one is non-caching while the other is. And both are always lazy. For example, using \"^\" to denote the lazy version:\n; non-cached version\n(take 5 (filter even? (iterate inc 5))) \n; cached version \n(take^ 5 (filter^ even? (iterate^ inc 5)))\nUsing \"^\" is just an example. Need a good choice here that doesn't conflict elsewhere.\n. @agentultra, can you be more specific? Do you think the cached versions should be in a separate namespace from the non-cached versions, instead of a wart on the name? Or do you mean we should have non-lazy versions of say \"take\" and \"drop\" in the core?\nWhen I say lazy (and I know this gets convoluted with the clojure lazy-seq) I mean they work on iterables or iterators and use yield instead of returning a concrete list.\nI think the core versions should be just what we have here, with the decorator removed, since the decorator (despite its name) only adds the cache. \nThen it is a separate decision whether the cached versions have warted names like \"take^\" or if they live in a separate namespace, with totally different names.\nSo, just to be clear, in my mind there are three versions of these possible.\n1. Versions that take a list and return a new concrete list. \n2. Versions that take a list or an iterator and return a generator, making them lazy and able to handle infinite sequences. \n3. Take number 2. and wrap the decorator around them so that they maintain a cache and are thus re-usable.\nI think 1. is not ideal. I think the best choice for core is 2. and then 3. is either names with a wart or new namespace. \n. I really appreciate all the discussion here and I think it has cleared some things up. \nFirst, I went down this road while looking at what clojure does (and conflated the laziness with the cache). But the more I think about it, I don't even think we need cached versions of these things at all. I think these methods should just be lazy. And we should provide the decorator (probably renamed to generator-cache or cached-generator) to users. \nMost of these methods aren't expensive, unless in the core of a long chain there is an expensive bit. For example, imagine a method that generates expensive items, maybe like a streaming version of fib. Doing something like, (list (take 5 (drop 1000 (filter even? (fibber))))), really only requires that if \"fibber\" is expensive, then it should cache its values, not filter or drop or take. \nSo instead of a whole bunch of methods that can cache, we just show people how to surround the expensive method with a caching decorator and then they can make the rational decision trading memory for time or vice versa. \nI think @paultag has the right thing working with the current LazySeq/LazySeqIter, it just needs a better name and a place to put it some people can import it and use it.\nAnd since we are trying to keep in sync with the good (and bad) of Python, I also noticed last night that in Python 3.2, functools added an lru_cache decorator. http://docs.python.org/3.4/library/functools.html, which kind of confirms this idea that our core functions should just be lazy and we provide/help/teach users how to cache if they need to. I also think that based on the design of the lru_cache, we can also add some helper methods to the current LazySeq class to introspect the cache size, to drop it, etc. \n. @paultag This brings back the original drop, but had to add a try...catch for this case\n(drop 6 [1 2 3 4])\n. i have several new ones to add once this first pass is in.\n. @olasd @paultag \nA bunch of updates based on the IRC discussion. Fixes include:\n(cycle [])\nfilter, remove, etc with lists containing None\nChanged most implementations from \"while\" to \"for\" except for obvious infinite loops like \"repeat\"\nAdded many new tests for these cases.\nThanks for all the helpful feedback.\n. +1 for the comment on nested loops with for\n. ok, I see now. \nBut then, if I write a different yield then return, in both hy and py I get a compile failure on Python2\n```\ndef kruft2():\n  for i in range(5):\n    yield i\n  return 1+2\n(defn kruft2 [] \n  (for [i (range 5)]\n    (yield i))\n  (+ 1 2))\n```\n. ok, this appears to be the change that now allows return after yield:\nhttp://docs.python.org/3/whatsnew/3.3.html#pep-380-syntax-for-delegating-to-a-subgenerator\n. @paultag, that's what I finally figured. \nSorry for breaking you here, but the third test fails now. For some reason the last yield is ignored. Still don't know why.\n. Doh, yeah good catch. Unfortunately, fixing that, the tests fails since the result is missing the \"end\" from the final yield.\n. ACK\n. This behavior is idiomatic in Clojure (and from Java) to run a main method in a class if the class itself is executed on the command line.\nPython only really has the if __name__ ... idiom.\nSo the challenge is to find a middle ground for idiomatic Hy that is in line with Python.\nand this really isn't that bad.\n```\n(defn main [&rest args]\n  (print args))\n(if (= name \"main\")\n  (sys.exit (main sys.argv)))\n```\n. after looking at this more, i think it is pretty tame and yet quite useful.\nNeed to get it cleaned up a bit, probably based on new error messages branch, or wait until that is merged.\nProbably need to add the same logic to hy.cmdline.run_command.\nand it needs docs.\nbut after that, i really like this approach.\n. i second the (defmain ...) macro idea. This is a good idea that avoids a lot of the previous objections.\nMight finally be able to put this PR to rest.\n. I agree that the function name should definitely not be \"main\" but a gensym instead.\nand you can use \n(if (integer? ~retval) ...\n. Fixed in #251 \n. Sorry, i was comparing this literally to assignment in Python, which does appear to return None.\nNot sure how to \"print x=1\" in Python\n. Yes, in the middle of the night I woke up realizing the inefficiency of the current mode. Working on a cleaned up version now.\n. This has my ACK. I can merge it, if needed.\n@paultag \n. Just updated to be able to do:\nhydoc hy/cmdline.hy\nfor any arbitrary Hy file, as well as the previous\nhydoc hy.cmdline\nto get help for a module on PYTHONPATH \n. Fixed the problem of calling with no args. \n. Fixed in PR #265\n. +1 from me\n. Thanks for a good fix. This has my ACK.\n@hylang/core please merge\n. Looks like you are correct. Good catch.\nHas my ACK to merge.\n. This appears to be based against the wrong SHA. These diffs appear to be removing the set of changes i had to add back and push last week for the hy/core/language.hy. An example function that got missed in that first merge is (numeric? ...) and its use by many of the other functions. \nSo don't merge this until we understand that.\n. LGTM\nI say merge it and have a :cocktail: \n. There is a simpler version, still no while, but much simpler. I'll change it in a jiffy.\n. The last change adds a local copy of the if-python2 macro since hy/core/language.hy can't see macros in hy.core.macros.  Normally I wouldn't copy code like this, but since this PR is held up because of the desire to change the Python version check to a macro (for performance) then this appears to the only way to resolve this and get these functions merged.\n@paultag\n. That is an interesting alternative. And easy for me. But I have no idea what/where this could be a problem later.\n. Haven't figured out the cause yet. But that does sound like a possibility.\n. More weird behavior:\nOn Windows, when running 'make tox' all the tests pass. These failures only occur when running \"make test\". Note that 'make test' still does work on Linux, hence most devs are seeing this problem.\n. Tests now pass on Windows.\nI test on Windows before I push and we are good as of Sunday\nBob\n\nOn Dec 18, 2013, at 12:44 PM, Nicolas Dandrimont notifications@github.com wrote:\nWhat's up with this, do tests still fail?\n\u2014\nReply to this email directly or view it on GitHub.\n. Travis uses an old version of PyPy that seg faults running flake8. This is apparently fixed in PyPy 2.1.\n\nLooking now for a way to only run flake8 on one of the Python versions instead of all of them.\n. Ok, this latest change will ignore flake8 for pypy on Travis. \nOnce Travis-CI upgrades to PyPy 2.1 or later, we can remove this and run flake8 there as well.\nBut at least now, we get flake8 run as a real CI test. \n. This seems reasonable and does make the macros available in hy/core/language.hy \nBut is there some other reason not to fold them in here?\n. I think Konrad's change does show that there is no obvious downside from putting all the hy.core.macros directly into hy.core.language and then all the core funcs can use the core macros. \nIt is a bit too bad from the notion of keeping the files smaller and simpler, but it does seem to function just fine.\n. Closing as unnecessary for now. Functions in language.hy can see the core macros via a standard require as shown in #269.\n. @paultag \nThat is kind of crazy. doesn't look like any LISP I've ever seen, but it might work.\nI might be a trick for the parser. Does it work if it is (foo x = 1) as well?\nAll previous versions put some wart on the variable name, but this would be different from that for sure.\n. I'm working on this one. \nEasy fix in the general case but it does beg for better compile failure messages, which is what I am working toward.\n. Fixed by #389\n. I like this, even the name. Gensym is now merged, so this can use them.\n. actually, hyprofile isn't a terrible name either. \n. i have a version of hytime and hybench\nwe could make a contrib module for all of them together.\n. Any more thoughts on moving to a contrib module?\n. Oh, no problem. Just really like the idea of having timing/profile available. Nice to have to make sure a change doesn't really slow things down.\nAnd I've not found a good place for the other timer macros...\n. if i have this in a file:\n``` clojure\n\ncat ~/Desktop/foo.hy                                                                                                                   [16:34:23]\n(require hy.contrib.profile)\n(profile (foreach [x (range 1000)] (inc x)))\n```\n\ni get:\n```\n\nhy ~/Desktop/foo.hy                                                                                                                    [16:35:21]\nTraceback (most recent call last):\n  File \"/Users/bob/.virtualenvs/hy-test/bin/hy\", line 8, in \n    load_entry_point('hy==0.9.11', 'console_scripts', 'hy')()\n  File \"/Users/bob/dev/github/hy/hy/cmdline.py\", line 261, in hy_main\n    sys.exit(cmdline_handler(\"hy\", sys.argv))\n  File \"/Users/bob/dev/github/hy/hy/cmdline.py\", line 249, in cmdline_handler\n    return run_file(options.args[0])\n  File \"/Users/bob/dev/github/hy/hy/cmdline.py\", line 170, in run_file\n    import_file_to_module(\"main\", filename)\n  File \"/Users/bob/dev/github/hy/hy/importer.py\", line 75, in import_file_to_module\n    eval(ast_compile(_ast, fpath, \"exec\"), mod.dict)\n  File \"/Users/bob/Desktop/foo.hy\", line 2, in \n    (profile (foreach [x (range 1000)] (inc x)))\nNameError: name 'foreach' is not defined\n```\n\nunless i change the signature to:\nclojure\n(defmacro/g! profile [&rest body])\n                      ^^^^^\nso defmacro/g! may need some error checking.\n. actually, i think using &rest body is just the way we seem to write macros, so maybe that is a change to profile and not any error checking in defmacro/g!\n. While i get the basic idea that 0 being a value is a good thing, i do worry about one case.  Python is used to wrap a ton of C extensions. If these C extensions use 0 and 1 for False and True, how is that manifested in Python (and Hy) land?  Will that cause issues if 0 doesn\u2019t mean to False in Hy? Or can we head that off at the interface layer? \nI don\u2019t think we can know for sure.  It may be defined as \u201cbroken\u201d for C to do this, but we do need to think about how that interop would work?\nWe use SWIG a ton at work, but we no longer wrap C code, only C++ with proper boolean support that maps to Python bools and will not be affected by this 0 issue. But we are only one case.\nAnd I think fear is too strong a word, but there is cause for care and consideration.\nBob\nOn Dec 18, 2013, at 1:48 PM, Joel Holdbrooks notifications@github.com wrote:\n\nHow much code did you write to validate this choice in practice?\nIn Hy or in general? I've mostly been evaluating Hy for scripting purposes so, admittedly, not much. In general, I've written a lot of code in other languages to verify it's value from a pragmatic stand point. I will not restate my position or provide further examples.\nWe don't want lots of \"truth converters\" at the Hy-Python interface.\nCan you demonstrate (with code) an example of what you're worried about here? Everyone keeps talking about this and not providing examples.\nConcerning your judgement of Python's conventions for booleans, I think you are too quick in extrapolating your Lisp habits to other languages.\nIt's not a Python convention anymore than it is a JavaScript or PHP convention. This \"convention\" has historical roots as has discussed above. It is also not a \"Lisp habit\" of mine. Ruby, for example, also thinks of 0 as truthy and I was programming with it long before coming to Lisp. I've had a couple years to think about the benefits of this property so, no, it is not a quick extrapolation.\nThe choice we are discussing is not between a \"good\" and a \"broken\" definition, but between the conventions of our target platform (Python) and those of our source of inspiration (Lisp).\nI understand that. But consider meditating on this for a while. Clojure targets no less than three platforms, each of which considers 0 to be falsey, and yet maintains the Lisp tradition. That being said I am not disregarding your argument. If someone were to write a Lisp targeting Haskell it would be reasonable to expect the predicate position of the if expression to be valid only when that expression is of type Bool. In the case of Hy, however, I simply have not seen any evidence so far that warrants the sort of fear people are expressing (ie. code).\n\u2014\nReply to this email directly or view it on GitHub.\n. @olasd @paultag \n\nI think this addresses all the points in the original comments. \nThis is a quite literal translation of the code from the letoverlambda link and I am pretty impressed not with my work but with the fact that we are far enough along to actually pull this off. \nIt really is very little code. \nBut boy do we need a user-space macroexpand.\nwhat do you think of extending hy2py to also do hy2hy?\n. One thing occurs to me before we finalize this.\nWe chose \":\" as the leading character in the generated symbols somewhat arbitrarily. But will this pose a problem when we (hopefully) finally support CL keyword args instead of having to use kwapply?\nAdmittedly it is an implementation detail that could change down the road, but just thought I'd ask. \n. working on a branch as we speak\nOn Dec 22, 2013, at 11:48 AM, Berker Peksag notifications@github.com wrote:\n\nWe need to document the gensym macro (see #374) as part of the 0.9.12 milestone.\n\u2014\nReply to this email directly or view it on GitHub.\n. Closed with #400\n. @olasd \n\nI have an update to this on the way. The current version puts too much effort on getting the output.\nWhile the main problem here has been access to the source when the exception is thrown, it turns out we do have access on the way up the stack. So instead of having a special method (dump) that is called with the source, i attach the source on the way up the stack.\nThen, the str method works like it should and an uncaught exception gives the complete backtrace along with the prettier error at the bottom.\nThen, in the REPL, or on the command line we can selectively turn on or off the tracebacks to get simple errors by default but complete tracebacks is desired\nSomething like:\n```\n\nhy foo.hy                                                                                                   [9:48:24]\n  File \"foo.hy\", line 5, column 5\n\n(if (= (print \"a really long\"))\n      ^-------------------------^\nHyTypeError: `=' needs at least 2 arguments, got 1.\n```\nor with tracebacks turned on:\n```\n\nhy --show_tracebacks foo.hy                                                                                 [9:48:03]\nTraceback (most recent call last):\n  File \"/Users/bob/.virtualenvs/hy-test/bin/hy\", line 8, in \n    load_entry_point('hy==0.9.11', 'console_scripts', 'hy')()\n  File \"/Users/bob/dev/github/hy/hy/cmdline.py\", line 289, in hy_main\n    sys.exit(cmdline_handler(\"hy\", sys.argv))\n  File \"/Users/bob/dev/github/hy/hy/cmdline.py\", line 277, in cmdline_handler\n    return run_file(options.args[0])\n  File \"/Users/bob/dev/github/hy/hy/cmdline.py\", line 184, in run_file\n    import_file_to_module(\"main\", filename)\n  File \"/Users/bob/dev/github/hy/hy/importer.py\", line 72, in import_file_to_module\n    _ast = import_file_to_ast(fpath, module_name)\n  File \"/Users/bob/dev/github/hy/hy/importer.py\", line 64, in import_file_to_ast\n    return hy_compile(import_file_to_hst(fpath), module_name)\n  File \"/Users/bob/dev/github/hy/hy/compiler.py\", line 1963, in hy_compile\n    result = compiler.compile(tree)\n  File \"/Users/bob/dev/github/hy/hy/compiler.py\", line 470, in compile\n    ret = self.compile_atom(_type, tree)\n  File \"/Users/bob/dev/github/hy/hy/compiler.py\", line 461, in compile_atom\n    ret = _compile_tableatom_type\n  File \"/Users/bob/dev/github/hy/hy/compiler.py\", line 616, in compile_raw_list\n    ret = self._compile_branch(entries)\n  File \"/Users/bob/dev/github/hy/hy/compiler.py\", line 501, in _compile_branch\n    return _branch(self.compile(expr) for expr in exprs)\n  File \"/Users/bob/dev/github/hy/hy/compiler.py\", line 361, in _branch\n    results = list(results)\n  File \"/Users/bob/dev/github/hy/hy/compiler.py\", line 501, in \n    return _branch(self.compile(expr) for expr in exprs)\n  File \"/Users/bob/dev/github/hy/hy/compiler.py\", line 470, in compile\n    ret = self.compile_atom(_type, tree)\n  File \"/Users/bob/dev/github/hy/hy/compiler.py\", line 461, in compile_atom\n    ret = _compile_tableatom_type\n  File \"/Users/bob/dev/github/hy/hy/compiler.py\", line 1553, in compile_expression\n    ret = self.compile_atom(fn, expression)\n  File \"/Users/bob/dev/github/hy/hy/compiler.py\", line 461, in compile_atom\n    ret = _compile_tableatom_type\n  File \"/Users/bob/dev/github/hy/hy/compiler.py\", line 404, in checker\n    return fn(self, expression)\n  File \"/Users/bob/dev/github/hy/hy/compiler.py\", line 966, in compile_if\n    cond = self.compile(expression.pop(0))\n  File \"/Users/bob/dev/github/hy/hy/compiler.py\", line 470, in compile\n    ret = self.compile_atom(_type, tree)\n  File \"/Users/bob/dev/github/hy/hy/compiler.py\", line 461, in compile_atom\n    ret = _compile_tableatom_type\n  File \"/Users/bob/dev/github/hy/hy/compiler.py\", line 1553, in compile_expression\n    ret = self.compile_atom(fn, expression)\n  File \"/Users/bob/dev/github/hy/hy/compiler.py\", line 461, in compile_atom\n    ret = _compile_tableatom_type\n  File \"/Users/bob/dev/github/hy/hy/compiler.py\", line 389, in checker\n    \"`%%s' needs at least %d arguments, got %%d.\" % (min))\n  File \"/Users/bob/dev/github/hy/hy/compiler.py\", line 376, in _raise_wrong_args_number\n    len(expression)))\nhy.compiler.HyTypeError:   File \"foo.hy\", line 5, column 5\n\n(if (= (print \"a really long\"))\n      ^-------------------------^\nHyTypeError: `=' needs at least 2 arguments, got 1.\n```\n. ok, dang it. this is simpler but introduces a new corner case.\nIf I run \"hy bar.hy\" and bar.hy tries (import foo) and foo.hy contains a HyTypeError, then instead of the HyTypeError in foo.hy, I just get an ImportError, no such module foo.\nMore tests needed.\n. Ok, there is no problem. \nThat failure was a true ImportError, foo.hy was missing.\nDoh.\n. I'll have a look at this one. I'm sure we can make it work (and probably many other single functions in the core)\n. this is not paint at all, (for ) and and all the builtins that are macros will suffer a similar problem, (car) (cdr), etc.\n. This also includes a change to put the error messages back to stderr instead of using print(e) to stdout.\nAnd this includes a fix for #366, (.abc) no longer crashes the compiler.\n. @olasd, first build failed with Travis error, but was able to trigger a new one.\n. ok, maybe there is no way to do that without a lambda?\n. Never mind, now I get it:\nclojure\n=> (apply .replace [\"bar\" \"b\" \"\"])\n'ar'\ni somehow managed to conflate apply and map.\n. want me to replace all uses of null with nil before we merge this?\n. while I like this style access (and especially the .. for recursive calls) it really brings up a bad asymmetry when trying to set an attribute.\ni feel like if we have to do \nclojure\n(setv foo.bar \"blue\")\nthen we might as well just use:\nclojure\n(print foo.bar)\nto get the value. \nSo it seems to me that part of solving this problem is coming up with a decent, consistent access for setting attributes as well.\nThis might look like CL, I'm not sure we can make it work.\nclojure\n(setv (. foo bar) \"blue\")\nIn fact, doing them all the same is not all that bad:\nclojure\n(setattr foo 'bar \"blue\")\n(hasattr foo 'bar)\n(getattr foo 'bar)\n. The ClojureScript syntax was discussed, but we have a problem that it is quite normal for objects to have attributes that start with \"\", and since Hy translates \"-\" => \"\", you would write something like (.--bar foo) to get foo._bar. \nnot the end of the world, but not great either.\n. dang i missed that.\nI\u2019m on it.\nOn Dec 30, 2013, at 2:52 PM, Abhishek L notifications@github.com wrote:\n\nShould we just add docs to flatten as well\n\u2014\nReply to this email directly or view it on GitHub.\n. LGTM. No brainer fix.\n. thought there might be more, but i couldn't find them.\n\nadding now.\n. ok, have another look\n. LGTM\n. This is great. But it shouldn't be contrib, it should definitely be in core macros, no?\n. +1 from me\n. Been trying to figure out how to comment on this.\nI think the whole \"flavor\" idea is a bad idea. I think a language needs some core tenants and then should stick to them. Having the ability to be everything to everyone sounds great, but in practice is probably not realistic.\nI'm not trying to get into Scheme vs CL language wars here. I'm not on either side specifically. I just think trying to be both is very hard.\n. Thanks to @agentultra for saying what i was unable to put into words.\nDidn't mean my previous message to start a war, but i wasn't articulate enough to voice my thoughts.\n. So should this PR be closed in deference to #524? \nThat seems to be the case, but it is still open, so I don't want to do the wrong thing.\n. Looking good. Needs tests and some docs and then I think it is ready to merge.\n. It is very odd that the else clause would cause a problem.\nThe reason I mentioned adding it was to prevent calling code in the file added after (defmain...)\nIf there is code lower in the file, it will get run. While I agree that is probably programmer error, clearly without the alternate exit, the (defmain ...) is required to be last in the file, so we should say that. \n. Ah, good catch. Easy fix. Also noticed that the flake target only tests 'hy' and not the 'tests' directory. I'll fix that too.\n. While I understand that we are stuck with variable scoping based on Python rules, I'm not sure I understand the distinction between Python 2 and Python 3 in this case.\nIn Python 3, this example gives identical results. The Python 3 distinction (I think) is limited to a change the loop comprehension variables no longer leak. But for loops are seem to be unchanged from 2 to 3 in this regard.\n. I've extracted the duplicate code to a simple function as suggested.\n. Yes, I find that odd behavior as well. Seemed like if we could prevent it, we should, hence this change.\n. I'm not sure \"filterfalse\" is the one to keep. \"remove\" is common elsewhere, while filterfalse is kind of an annoying name. \n. Maybe this is a good reason to drop Python 2 support, but that has some real ramifications.\nand why does this work in Python 2?\n``\n(defun test []\n  (setv outer {'foo true})\n  (let []\n       (if (get outer 'foo)\n           (setv (get outerfoo) false)))\n  (print (get outer `foo)))\n(test)\n```\nlifted from here: http://technotroph.wordpress.com/2012/10/01/python-closures-and-the-python-2-7-nonlocal-solution/\nSeems odd that dicts are accessible but variables are not, but then i just must misunderstand Python 2.7\nBut I guess implementing this in the compiler for variables would break Python interop.\nI tried porting some of the Realm of Racket/Land of Lisp code to Hy, and without auto-magic nonlocal behavior, it is pretty ugly. \n. Closed by #693 \n. @paultag \nThis is a really good question. Seems to be no current way to know what the 'next' version is going to be in order to get this :versionadded thing right.\n. 0.10.2 it is. And I squashed it down to a single commit.\n@Foxboron: good catch\n. I'm looking at this now. It is not quite ready to merge.\n. This fixes a silly bug. I think we might do even better in formatting an exception inside a MacroExpansion error, but this is a good fix. \n. Been a bit quiet here lately, but I agree with this one-true-way cleanup.\nI think I've unknowingly run into these let issues and so I have code that already just uses a bunch of setv. \nWhile I like the Lisp philosophy of let, if we can do it right, we shouldn't do it at all. \nGetting rid of things like the double brackets is just extra goodness that we can deal with since we are making a big change.\n. :+1: :+1:\n. :+1: to just using reader macros as the short-hand.\n. Try this:\npip install pyreadline==2.1\nPython 3.5 needs an update to the latest pyreadline. Thy Hy requirements haven't quite caught up.\n. I know I've been quiet around here, +1 from me.\nAfter the experiment with uvloop I just got sent from a colleague, I'd really like to see us be able to support the good parts of 3.5+ instead of a very old, broken construct.\nI wonder if we finally make this leap, if a bunch of past backlog might come unstuck.\n. I know I've been very quiet lately, so don't have much say. \nI agree with the general sentiment that we need to get 0.12.0 out.\nThe general idea of defmacro! is a really good one, so we should push to get it working post 0.12.0. I worked on defmacro/g! but could never get a version of defmacro! working, so please keep at it.\n. one simple question about using __future__.\nTo me the implication is that a feature imported from the future is intended to become native at some point. If this will always be an optional feature the programmer has to enable and never turned on by default, then I think a different import name should be used.. I've now tested this on Anaconda 4.2 Python 3.5 on Ubuntu.\nI'm beginning to think that how we have implemented \"hy -m\" might be THE problem. Note that python -m tests.resources.bin.main actually works fine.\n$ hy -m tests.resources.bin.main\n/home/bob/anaconda3/envs/hy-conda/lib/python3.5/site-packages/IPython/kernel/__init__.py:13: ShimWarning: The `IPython.kernel` package has been deprecated. You should import from ipykernel or jupyter_client instead.\n  \"You should import from ipykernel or jupyter_client instead.\", ShimWarning)\nOMP: Error #100: Fatal system error detected.\nOMP: System error #22: Invalid argument\n[1]    1620 abort (core dumped)  hy -m tests.resources.bin.main\n$ python -m tests.resources.bin.main\n('/mnt/c/Users/cohor/dev/github/hy/tests/resources/bin/main.hy',)\nHello World. ok, this seems to be the new importer. \n$ git checkout 21f958929\n$ hy -m tests.resources.bin.main\n('/mnt/c/Users/cohor/dev/github/hy/tests/resources/bin/main.hy', '')\nHello World\nwe need to either back out #1085 or figure out how to fix it. ```\n\npython compiled_file_python_version.py tests\\native_tests\\contrib__pycache__\\anaphoric.cpython-35.pyc\nFile \"tests\\native_tests\\contrib__pycache__\\anaphoric.cpython-35.pyc\" is compiled with: Python 3.5b2\n```\n\nSo it is the same Python that I am using.\nNot sure what this tests/proves.. Although I have no idea why, it appears that this behavior might be related to the changes introduced in #1085. \nif i revert to 21f9589, this problem of a test failing the second time it is run disappears.\nI have no idea what we modernized in the importer, but it appears to have side effects we were not prepared for.. There is clearly something broken with the new import mechanism and using \"hy -m\".\nFor some reason, using that tries to import all kind of crazy modules other than the one you ask for. Maybe I don't understand the purpose of the import modernization.\nFor example, even trying to run a module that doesn't exist crashes:\n$ python -m foo.bar\n/home/bob/anaconda3/envs/hy-conda/bin/python: Error while finding spec for 'foo.bar' (ImportError: No module named 'foo')\n$ hy -m foo.bar\n/home/bob/anaconda3/envs/hy-conda/lib/python3.5/site-packages/IPython/kernel/__init__.py:13: ShimWarning: The `IPython.kernel` package has been deprecated. You should import from ipykernel or jupyter_client instead.\n  \"You should import from ipykernel or jupyter_client instead.\", ShimWarning)\nOMP: Error #100: Fatal system error detected.\nOMP: System error #22: Invalid argument\n[1]    798 abort (core dumped)  hy -m foo.bar\nThe fact that python -m doesn't throw this IPython.kernel warning and just fails instantly makes me think we've not quite got hy -m to where it needs to be.\n . While I can't check all the changes individually since I didn't review the original #1085, this change does fix the problems I've seen in both #1182 and #1183.\nI can give this my approval but hopefully another person who approved #1085 can also check this so we can get it merged.. This looks good but should be squashed to a single commit.. i changed this to make the behavior consistent in reality not behavior. For better or worse, I wanted all of these to consistently return a generator object, where this one would return a 'listiterator'. \n. After further inspection, I think we can return the iterator directly.  From some reading, it appears that generators are iterators but not the reverse. So changing the docs to say each method returns an iterator seems the most accurate and complete. \nAlso, if we add/wrap methods with the caching, that returns a class that is in fact an iterator.\nAnd thanks for the note on catching Exception.\n. Extra 's' in namespaces on the 3rd line above.\nAnd more importantly, this appears to be the first mention of the concept of 'namespace' in all the docs. Is there a Hy-specific definition of 'namespace' that differs substantially from a 'module'?\n. +1\n. I will if this is deemed useful. I am under the impression this bit might not fly.\n. Yes and no. First, clint needs that PR to be useful for Python 3.3\nBut i also thought that I didn't (yet) want to force another dependency, even if clint worked well everywhere.\nFinally, I can envision a day where both colored errors as well as the tracebacks are settable as options in a .hyrc file or some such thing.\n. good call. Fixing now.\n. actually you are right, I'll put it in and we can always change or remove it\n. good point. I'll add that change.\n. ",
    "vodik": "I'm still noticing problems with yield when mixed with with blocks in the latest release:\n```hy\n(import contextlib)\n(with-decorator contextlib.contextmanager\n  (defn test-file-open [filename]\n    (with [fp (open filename)]\n          (yield fp))))\n```\ngenerates\n```python\nimport contextlib\n@contextlib.contextmanager\ndef test_file_open(filename):\n    with open(filename) as fp:\n        _hy_anon_var_1 = yield fp\n    return _hy_anon_var_1\n```\nand fails to load:\nSyntaxError: 'return' with argument inside generator\nAnd I see it in both python2 and python3.. @kirbyfan64 played around with your fix, seems to do a comprehensive job, can't seem to break it.. Any further thoughts on this? It be cool to be able to support typing.NamedTuple and the upcoming data classes. Okay, thought a little bit about this, read more details where Python is going, and played with some code. Apologize upfront if my terminology is off.\nFirst is we should be able to get away with always emitting strings for annotations. With PEP 563 coming, this is effectively going to become python's default behaviour anyways. Tools relying on annotations should already support deferred evaluation.\nAnd I think we have two options in how to implement it, one which might be easier than the other:\nEmit annotations in the AST:\nThis means syntax support, so that something like this:\nclojure\n(def foo ^int)\n(defn bar ^int [x ^int] ...)\nWould turn into:\npython\nfoo: int\ndef bar(x: int) -> int:\n    ...\nWe'd have to teach the compiler to emit ast.AnnAsign and set the annotation attribute on other entities like ast.arg. And we probably have to add another HyObject: HyAnnotation.\nManually build __annotations__:\nThe above example could also be implemented as the following Python:\n```python\ndef bar(x):\n    ...\nannotations = {\"foo\": \"int\"}\nbar.annotations = {\"return\": \"int\", \"x\": \"int\"}\n```\nAnd now there's no need to change the compiler as we should be able to solve the problem by generating more python instead. However, this could be prove to be slower...\nPossibly do the whole thing with just macros\nI think I'd much prefer inline annotations, but its also possible we might be able to implement with macros. Basing this off cojure's core.typed, for example:\nclojure\n(ann bar [ int -> int ])\n(defn bar [x] ...)\nBut the problem (and I don't know if this can be done cleanly), needs to attach the annotation after the definition. It also doesn't solve annotated assignment (foo: int). We could use (ann foo int) for that, but could that mean a function foo with no arguments?\nAnother possibility would be to just have this live in a standalone project too: hy-typed maybe?.\nWhat should HyAnnotation be (if there is one)?\nA possible representation is as a string, much like HyKeyword (see justification above) but without the prefix. But how do we interact with the typing library? For example, to annotate a function takes a list, we'd end up with this monstrosity:\nclojure\n(import [typing [List]])\n(def foo [data ^(get List int)] ...)\nWhere it might be more desirable to write:\nclojure\n(def foo [data ^ints] ...)\nThis could be implemented as:\npython\nfrom hy.types import ints  # where ints = List[int]\ndef foo(data: ints): ...\nBut I would rather see the full List[int] there, especially if introspecting, so probably want to expand it first.\nBut then we have an issue: if there's a layer of rewriting/interpretation, how to we simultaneously support arbitrary annotations from type hints?\nMaybe a possible solution is to support both the ann technique for arbitrary annotations and reserve ^annotation for a set of for known types.. @kirbyfan64 another option, but bare minimum, would be to just generate stub files of the function calls.. Oh, an for what its worth, emitting __annotations__ manually works for the case of stuff like named tuples or dataclasses, so that could be macroed away:\nclojure\n(defmacro deftuple [name &rest fields]\n  `(do\n     (import [typing [NamedTuple]])\n     (defclass ~name [NamedTuple]\n       (def __annotations__ (dict ~fields)))))\nNot sure if you guys would take something like this, polished up, into contrib though.. The right solution to this, if we want to put a reload in, is to remove the module from sys.modules and then import the module again.\nThis is what IPython's reloader does - but the reason it doesn't work with Hy is that the reloaded explicitly checks if __file__ ends with \".py\". Patching that, it works\nNow there are a lot of issues with how Hy manipulates sys.modules, and they're addressed with #1518. I really need to get that done, but the patch works. Its a matter of unit test coverage and documentation that's holding it back.\nSoon! I promise. My free time is at a premium at the moment for personal reasons, but I want to make it a priority.. I guess another option could be to use a keyword like how import uses :as:\nclojure\n(def foo 42 :as int)\nI also played around taking a symbol as an annotation: (def foo 42 'int) but that feels a little weird.\nI do kinda like how racket does it with (: ...) but that's not really workable here as it collides with keywords. The Racket syntax is really close to Pythons.\nThat said, something worth noting is how painful type annotations are possible going to be as they've been implemented in the typing library. For example, consider the following Python stub:\npython\ndef get_users(id: int) -> Generator[User, None, None]: ...\nThat Generator expression is effectively (get Generator (, User None None)) which is going to get unwieldy fast. This was the biggest reason for in #640 I was musing if it was possible to completely separate annotations and functions, but I don't think its going to be workable - as far as I can tell.\nBut this problem makes me wonder if Option B is best, and instead provided a mechanism for defining new type aliases and types as a practical solution - and one admittedly probably too tied to the current Python implementation of types. I do like how Clojure offers ^ints for a list of ints, for example, instead of (get List int), I wonder if we could do something like (defalias ints List [int])...\nAnother option is to only support string annotations, in which case the annotation would litterally be \"List[int]\". Maybe that's the best/least surprising. Especially as deferred evaluation is around the corner anyways. The catch here would be that List still needs to be imported from typing though, as I understand it, and maybe that's going to be surprising.\n  . > Does (. Generator [(, User None None)]) look any better? It's equivalent in Hy. Tuples inside [] come up a lot in Python, especially with numpy slices. Maybe Hy just needs better syntax for this. But how would you want it to look in general?\nIt does actually. Didn't know that.\n\nI thought Python could already do type aliases via the Typing module. So ints = List[int] is (setv ints (. List [int])) in Hy. I'm not sure what else you want here.\n\nMy concern was that ints would show up as the type hint. But I tested it and it works as expected:\n```\nIn [1]: import typing\nIn [2]: ints = typing.List[int]\nIn [3]: def foo(bar: ints) -> None:\n   ...:     pass\n   ...: \nIn [4]: foo?\nSignature: foo(bar:List[int]) -> None\nDocstring: \nFile:      ~/\nType:      function\n```\nSo I'm completely happy with that. No need for anything special then. Should have tried that first.\n\nIt seems a little weird to me to write annotations in Python when we're writing everything in Hy.\n\nJust musing out loud. I was worried about potential complication of PEP 563, but I somehow missed this line my first few glances through it: \n\nThe string form is obtained from the AST during the compilation step, which means that the string form might not preserve the exact formatting of the source. Note: if an annotation was a string literal already, it will still be wrapped in a string.\n\nWhich means its really a non-problem as well and this is a lot more straightforward than I was worried it be.. @Kodiologist the hole left is how to do class decoration though.. Yeah, I realize, but do you really want that to be the official suggestion?\nThough you do have a point... it wouldn't be too hard to provide a class form in the standard library to paper over this and turn the defclass form into an equivalent type or appropriate metaclass call.\nNot sure how PEP 487 would fit in, but its an idea.. > I wonder if the class form could return itself instead of None. Then you could just (setv MyClass (mydecorator (class MyClass [] ...))). Actually, that doesn't seem that much easier.\nI was musing out loud about the later (not really anonymous but more like expressions), and yeah, its not great.\n\nIt probably shouldn't have any more ceremony than Python does. I don't really have a better idea than adding them to the function and class forms.\n\nWe can revisit this again when #1482 lands. I did start on it, just got stuck needing to fix the importing system (specifically just need self imports to work).\nclj\n(defn addition\n   {:decorate inc-decorator}\n   [a b]\n   (+ a b))\nIsn't too bad...\n. I managed to hack something together, I'll put up a PR shortly as I clean it up as I'd like to see this added, but I have no idea if anyone will like the syntax I've chosen, nor have I written any tests:\nhy\n=> (import asyncio)\n=> (setv loop (.get_event_loop asyncio))\n=> (asyncdefn test [] \"Hello World\")\n=> (.run_until_complete loop ((asyncfn [] (await (test)))))\n'Hello World'. @rcarmo await inside list-comp works with my patch, but async for inside comprehension isn't implemented yet. I'll see what I can make work once the comprehension changes land.. Thanks!. I'm honestly not a fan of how (= 'foo \"foo\"). Sure getattr is a neat trick but its also technically represents a slight deviation away from the Python object model (though if you're stuffing arbitrary data in there, I think you got bigger issues to worry about :wink:)\n\nIt's got all the weirdness of implicit type conversion:\n=> (+ 'foo \"bar\")\n'foobar'\nIt leads to more verbose and error prone macros (if (and (symbol? x) (= x \"foo\")) ...) vs just (if (= x 'foo) ...)\nI think its somewhat surprising and non-intuitive\n\nI've been playing with a branch that makes (= 'foo \"foo\") false and similar strictness on HyKeywords. I'll put it up once I'm done fixing tests.. @waigx let me first see if its fixed if i run it under #1518 . Nope\n@waigx I think that's a red hearing. Dig into the __code__ object first, you'll see some inconsistencies.\nIn python:\n```\n\n\n\nfoo.code\n\n```\n\n\n\nand in Hy:\n=> (. foo __code__)\n<code object foo at 0x7fd2d2c470c0, file \"<eval_body>\", line 1>\nIf you want my opinion on what's likely happening, Python imported that file, but Hy evaled it instead.. If you like, I can add this into #1518 since a lot of this stuff is already getting overhauled in that PR. I'm actively working on it currently. I appreciate the enthusiasm, but this probably overlaps.. > I would like to see how do we map lines between .hy and .py \n@waigx its part of the AST. Every AST entry needs to have line_no and coll_offset. Have a look at compiler.py - notice how theres this Asty object? Its part of the secret that helps us nicely propagate line number information from the lexer's output into the AST.\nThere's more to this, but its a good starting point to dig into it.\nBut because its part of the AST, Python just makes it work. On printing the traceback, it loads the source file (from __file__ - if present) and finds line_no and prints that line. It doesn't care at this point if its a python file or not. Remember, Python already heavily relies on files of different extensions, like .pyw files which have a special meaning for Windows (suppresses the Terminal window for stdout for GUI apps). Oh, which is why its not working with the -i flag. These lines are inside hy_eval:\nhttps://github.com/hylang/hy/blob/6c25fc23df62cf0bd4cd16d034c6e8d088d6bef9/hy/importer.py#L187-L206\nWhich trashes the line numbers. This is because typically hy_eval is used in this context:\nclj\n(eval '(1 + 1))\nAnd that quoted expression doesn't properly have line numbers associated with it, and thus its thrown away.\nEDIT: Well, actually, its another detail related to it being evaled inappropriately. There's also no file information associated here. Specifically there's no __file__ attribute to load, so tracebacks can't work.\nHope this clears up a lot.\n. I personally started using kwonly arguments without default liberally, and making those harder to understand at a glance does the feature a misservice, imho (requiring the extra .).\nAlso think its weird that &* can, depending on context, mean either variable number of positional arguments or keyword only arguments. Technically also a problem with Python, but its much easier to distinguish\nYou also really should be forward looking a bit here as there's a good chance positional only arguments will come. They're already a thing in the CPython core, just without syntax for Python to leverage this - for now. It'll likely look like this def foo(a, /, b): .... You can already see it in use in IPython signatures:\npython\nIn [1]: range?\nInit signature: range(self, /, *args, **kwargs)\nI think we really only need a few things:\n\nA way to specify a default value\nA way to separate positional-only from positional-or-keyword args\nA way to separate positional-or-keyword args from keyword-only args\nA way to specify *args\nA way to specify **kwargs\n\nBuilding on Option 6, embracing tuples for optional arguments, as they're already done, does simplify things. Then &* can be reserved for keywork-only and &/ for positional only.\nAnd technically, we don't really have to allow the end user to choose the variable name for *args and **kwargs :wink:\nclj\n(defn foo [a [b 1] [c c] [d None] &args x [y 2] z &kwargs])\n(defn akw [&args &kwargs])\n(defn only [&* x [y 2] z])\nAnd to add, it would be easy to add positional only after the fact:\nclj\n(defn my-range [self &/ &args &kwargs])\n. Looks good to me.\nAnd I don't think the is_ mangling is worth keeping because Python isn't consistent with is_foo or isfoo. I don't mind filling it in one this lands. await inside comprehensions should work - I've used it with list-comp - a special form is only necessary for working with __aiter__.. @gilch I think maintaining a separate syntax for now makes sense, as they are different underlying mechanisms with different-ish uses.\nI personally interpret having multiple for expressions rolled together as effectively the same thing as an implicit itertools.product.\nBut that analogy kinda breaks down with async code. async for typically ends up being used more like a message or event bus (e.g. notify me as background tasks finish, as websocket messages come in, etc.), and I'd go so far to argue having multiple async for expressions rolled together is actually kinda weird conceptually and probably won't be of much practical use - you'd typically want to join/merge different iterators together instead.  . I got async variants working on a dev branch, so this works for me.. Well, you confused me for a bit as I didn't realize the last comment on both issues link to each other :wink: . And I overlooked the lack of AsyncFunctionDef missing in older versions of python, I'll dig into this.. I can certainly get on that. I was more concerned if there would be any nitpicking over asyncfn.. Okay, tests pass, and added two basic tests to make sure it works, but I don't really know the depth at which I should be going for.\n@kirbyfan64 I like the look of that, but I guess the issue is how well will that generalize. Technically there's also async with, async for and async generators to worry about too.. Oh, didn't mean to push it, but I'll leave it up I guess then, I added a tag macro for await because I found myself writing a lot of (->> ... await) and found this a little cleaner.. How about fn/a and defn/a?. I'd second that, as, looking again into hy and where its going, the async stuff feels more like variants than its own set of things. Especially since we can support async lambda.\nFor example, looking at #1468, and assuming it lands, would we rather have async-lfor or lfor/a for PEP 530 coverage? Rather async-with or with/a?. Sorry, I keep tripping up that normalization happens before the compiling.... I've been kicking around async with support, and got something working:\n```hy\n(import [asyncio [get-event-loop]]\n        [aiohttp [ClientSession]])\n(defn/a query [url]\n  (with/a [session (ClientSession)\n           resp (.get session url)]\n    #a(.text resp)))\n(defmain [&rest args]\n  (->> (query \"https://google.com\")\n       (.run-until-complete (get-event-loop))\n       print))\n```\nStill need to write tests for it, so not pushing it just yet. I went back to using the /a suffix for this which I'm liking more and more as I keep adding support. And to reiterate myself, I think it'll also be cleaner when looking to add comprehension/for support.. @Kodiologist how would you have me writing a test, since I can't see any examples where we test for syntax errors.. Fixed things up, added with/a and for/a support and tests.. @Kodiologist got a naming convention for private macros? Or is there a better way to do what I just did?. @Kodiologist not sure how to make that work, but I'm not super competent with macros just yet. I got into this to learn how this all works.. I would really appreciate some help. Ahh, thanks. Looks like I was close then (but I don't think I would have solved it quickly) - I think I understand. The main problem I was hitting was forcing _with to resolve at expansion time.\nAnything else needing to be done? I would like to look at comprehension support, but I don't think it makes sense until the other PRs are in. Just NEWS and AUTHORS I guess?. Yeah, but I still think its worth addressing since it isn't really meaningful, catches a possible error at compile time more clearly, and we already validate names on assignment.. I guess I should probably remove \"ast\" from the test name, you're right, its valid AST.. @Kodiologist valid code as in it emits a return or returns a manged \"return\" variable? I'm taking it as you mean the later. In which case, yeah, that's a much better fix. Retracting this.. I like that idea. Lets see what I can do with that.. @gilch quickly threw together something that implements Option A.\n```clojure\n(import [typing [NamedTuple]])\n(defclass Person [NamedTuple]\n   (def name str)\n   (def age int))\n(defmain [&rest args]\n  (setv person (Person \"Jeff\" 30))\n  (print person))\n```\n~~I wonder if something like this makes sense:~~\nWell, guess you might not have any way to determine if something is an array or an definition - not without changing the syntax further...\nclojure\n(defclass Person [NamedTuple]\n   (def [name str]\n        [age int])). It does. I need to clean it up and write tests, but at work. Will do it in the evening.. Didn't have enough time to finish tests yet - need to go to sleep, but I replaced def with setv everywhere and did an initial draft of documentation changes.. > Not just one, setv, defn, fn, and many macros based on them\nAnd don't forget defclass - it also takes a list of attributes.\n\n... defn treat symbols beginning with ^, as well as ^ itself, specially. This would be similar to how &optional is an ordinary symbol from the lexer's and parser's perspectives, but magical in a lambda list.\n\nHow would that interact with macros? Wouldn't it be desirable to allow type hints to be a macro argument for doing code generation? For example (contrived):\nclojure\n(code-gen my-helper ^str)\nI can't think how else to add annotations nicely, while keeping them optional and backwards compatible, without adding new syntax:\n```clojure\n(defn ^str foo [^int x]\n  (str (* x x)))\n(setv [^int x] 42)\n(defclass MyClass []\n  [[^int x] 42]\n(defn --init-- [self]))\n``\n  . For what its worth, Python also reuses operators as syntax too:@is used for matmul and decorators.. Should I split thedef` removal into a separate PR?. I can continue on with this, but I figured I'd wait to see what we decide for #1482. Or if we'll accept a new type annotation form. The more I've been reflecting on this, the less confident it can even be done without something new going into the language.\nFor example, I've seen this proposal thrown around for function argument annotation:\nclojure\n(defn foo [test ^int] ...)\n; or\n(defn foo [[test ^int]] ...)\nBut without the ^ in there, you can't distinguish between two arguments, or tuple unpacking support.\nBut if that's how its going to have to be, I'd like to see that added first rather than adding annv to later remove it/adjust it.. Yes, but I just want some sort of agreement. If we agree it should be ^int, then I want to use that form in as well annv.\nAnd I just want to know ahead of time if people are okay enough with the idea that its worth spending time on and would be at least considered and not rejected immediately.. I'm significantly more comfortable with Hy and how the internals work now - and I see where I was tripping up in my various musing and proposals on how to implement this (thanks for the patience!).\nI think implementing #1482 would be great and I think I understand how to tackle it now. @gilch if you don't mind, I think I can handle it, unless you wanted to do it.. They are, it can basically be considered a \"special case\" of generators with different syntax.. How about, as an alternative, using metadata (#1482) you could override the mangling? Something like: \nclojure\n(defn ^{:export \"camelcase_to_snakecase\"} camelcase->snakecase [name]\n    ...)\nIts certainly wordier, but could improve python/hy interop without having to add more and more mangling rules.\n  . Very good point!. I managed to get hy to support Ellipsis:\nhy 0.13.0+196.g0cd4df3 using CPython(default) 3.6.4 on Linux\n=> ...\nEllipsis\nIts actually a very small patch, I'll put up a PR shortly.. Yup, that's fair, but that should be easy to add on top of this.. Done. I'm pretty sure def has been removed everywhere now.. Oooh, reviewing -E made me think of something.\n@Kodiologist might want to test how case insensitive the mangler is: https://docs.python.org/3.2/using/cmdline.html#envvar-PYTHONCASEOK. Oh right, this is only going to work for Python 3... Well that still works for me.. Okay, I'm working on cleaning up slice generation, I'll add this as part of that work to make it both py2/py3 compatible.. @Kodiologist as far as I can tell, yes, but we get away with it because we never emit multidimensional slices anywhere with ast.Slice, always with a call to the slice constructor.\nAs far as I can tell, only cut emits ast.Slice, but its single dimension.. And for what its worth, its probably worth implementing - even if its an optimization when we notice slice construction inside indexing - because it performs much better:\n```python\nIn [1]: class Demo:\n   ...:     def getitem(self, key):\n   ...:         return key\n   ...: \nIn [2]: demo = Demo()\nIn [3]: %timeit demo[1:2]\n183 ns \u00b1 0.666 ns per loop (mean \u00b1 std. dev. of 7 runs, 10000000 loops each)\nIn [4]: %timeit demo[slice(1, 2)]\n266 ns \u00b1 2.23 ns per loop (mean \u00b1 std. dev. of 7 runs, 1000000 loops each)\n``. I don't know how you could properly disambiguate it without usingslice`:\nSay we chose to represent (cut foo 1 2) as (cut foo [1 2]), and then support taking in variable number of arguments. Well, problem is getitem, including at higher dimensions, isn't limited to just slices. It can take any arbitrary object. So the problem becomes determining if (cut foo [1 2]) is actually 1:2 or [1, 2].. I think I'll experiment with addressing this by trying to peek into contents of Index AST expression and start by trying to transforming (slice ...) into actual slice AST.\nI don't think there's any real need to \"fix\" this by looking at how we approach representation, and instead look at it as a optimization instead. I think (get foo (slice 1 2)) is perfectly fine and readable, and probably preferable anyways. We could instead remove cut and replace it with a macro.. See #1492, but still not there yet as this is only concerned with a single dimension. Maybe the nicest would be to let get take a variable number of arguments.... ~~Oh, so like itemgetter?~~ Interesting, didn't know that.\nBeyond that, though, any complains with this approach?. > One issue with this approach is that slice isn't a reserved word, so there's no way to tell at compile-time that the symbol slice corresponds to __builtins__.slice.\nOh right, is there any suggestions on how to deal with this? Should I promote slice to a builtin? Or is there another trick that I might not be aware of?. > Perhaps the best approach is to check for __builtins__.slice instead.\nSo if I understand this correctly, I should compile the expression and then peek inside the results of that?. Right, so I'm not seeing an easy way to do this. Either I check the HyExpression/HySymbol for \"slice\", or I compile it first and look into the resulting ast.Name. But my understanding, and maybe this is where I'm missing something, but ast.Name is still going to result in runtime lookup, so there is no sensible to know for sure if builtins has been messed with.\nMaybe I should add slice* to force a slice object to be emitted?\nOr maybe this idea isn't workable then and we'll just have to live with the slightly less optimal code generation.\n\n... to check for __builtins__.slice instead. It's probably best to make cut emit this instead of a bare slice, anyway.\n\ncut still compiles to ast.Slice as it used to, so it doesn't matter what anyone has done to builtins. That's the only reason I moved it to a macro.. Ah, sorry, I've misunderstood you entirely.\nOkay, so let me see if I'm following: you're suggesting that the cut macro emits __builtins__.slice instead of slice. Then I'll look for __builtins__.slice and emit ast.Slice in that case? Is this on top of rewriting slice too, but just to make it more bullet proof? . Okay, so if this is acceptable, I'll continue working on it. Currently get will either accept its current list of keys, or a single slice. I need to do some deeper refactoring to make the slice optimization work as expected, and then additionally dealing with #1492 and #1491 should be easy.. Okay, merged #1491 into this PR, need to just rework tests, but I think this should do the trick.\nThe following code compiled as expected on both 2 and 3:\nclojure\n(get foo (slice 1 2 3) ... bar)\nwill compile to\npython\nfoo[1:2:3][...][bar]\nThe optimization currently falls apart when we use a tuple to have a multidimensional slice, but I think we can merge this and leave that as a separate PR.\nJust need to fix the tests and add new ones.... I think it can stand for review now. The code now properly emits the exact same AST that python does, multi or single dimension.\nI took another step further and I deconstruct tuples when used as arguments to get to turn them into multi dimentional slices. This, as I understand it, is safe as Python represents them internally as tuples so there's no room for ambiguity. That means we now have the following code working:\nclojure\n(get foo 1 2 (slice 3 4) ... (slice 5 6))\n(get foo (, 1 2 (slice 3 4) ... (slice 5 6)))\ngenerating the following equivalent Python:\npython\nfoo[1][2][3:4][...][5:6]\nfoo[(1), (2), 3:4, (...), 5:6]\nThe second example generates the following AST:\npython\nModule(\n    body=[\n        Expr(\n            value=Subscript(value=Name(id='foo'),\n                slice=ExtSlice(\n                    dims=[Index(value=Num(n=1)),\n                        Index(value=Num(n=2)),\n                        Slice(lower=Num(n=3), upper=Num(n=4), step=None),\n                        Index(value=Ellipsis),  # and just `Ellipsis` on PY2\n                        Slice(lower=Num(n=5), upper=Num(n=6), step=None)])))])\nThis should put in place all the groundwork for the proposed #1481 change.. I think you misunderstood - I'm not saying those two lines of Python are equivalent. Let me rephrase, and remove some noise from that complicated expression:\n(get foo 1 2)               ;; foo[1][2]\n(get foo (, 1 2))           ;; foo[1, 2]\n(get foo (, 1 2) (, 3 4))   ;; foo[1, 2][3, 4]\nThere is now support for multidimensional slices while also preserving chaining. I do it by destructing the tuple - which should be safe __getitem__ interface will present it as a tuple in the first place.. Is this more to your taste then?. I won't be able to get this done till tomorrow, but I'm thinking of adding some examples to the documentation as well citing numpy.. Python exposes these things as builtins, and considering our relationship with the language, I don't see why we should shy away from supporting something similar. Especially since we're in the position to do it better. Its effectively a runtime \"unquote\".\nAnd I get that these are internals, but when ast-compile is just a thin wrapper around the compile builtin - the above snippet works just as well with hy-compile, compile and exec - I don't know if that's a particularly compelling argument against it.. Maybe the right thing to do is make sure lineno and col_offset are correct with quote, but it does leave us with a question:\nWhy shouldn't a fully run-time specified HyExpression not be compilable?\nI think its also worth noting that, as far as I know, this patch brings Hy's behaviour inline with Python's.. > I'm not sure what \"these things\" are.\nJust meant commenting that exec and compile are Python builtins.\nBut looking back, I think I misunderstood your point and I'm talking past you. I never noticed hy-eval (or read-str / disassemble), which is functionality that I was looking for and was trying to implement by hand.\nThanks for the help and sorry.. Yeah, that's a good idea, but it looks like that doesn't work unless the package contains __init__.py - __init__.hy isn't good enough. I wonder if that's something we can fix.. Ah, no, this is another bug - but looks like the bug is specifically inside the pytest glue code.. Yeah, its this function in particular that causes a problem from _py.path which pytest uses to figure out the import. So unless we want to maintain much, much more pytest code (subclass pytest.Module to replace the import logic), not much that can be done about this constraint.\npython\n    def pypkgpath(self):\n        \"\"\" return the Python package path by looking for the last\n        directory upwards which still contains an __init__.py.\n        Return None if a pkgpath can not be determined.\n        \"\"\"\n        pkgpath = None\n        for parent in self.parts(reverse=True):\n            if parent.isdir():\n                if not parent.join('__init__.py').exists():\n                    break\n                if not isimportable(parent.basename):\n                    break\n                pkgpath = parent\n        return pkgpath. Yes, opps. All these warning came from pytest, so we could also turn that on in our CI build too, for what its worth.\nOh and I guess I should have probably added a test with return inside a generator.... > I don't see any warnings when I run pytest. Do you have to turn them on somehow?\npytest -q since about 3.1.0: https://docs.pytest.org/en/latest/warnings.html\n. I've just dealt with everything and turned on the warning reporter.. Updated NEWS -> NEWS.rst, not sure what you want to put as a header for the next version.. Done. Yeah, was planning on doing it later tonight. Just got some work stuff I need to wrap up first. Fair enough, I thought it be a stretch. But it did lead me to another idea. There's PEP 508... what if we exposed that instead if if-python2 and family? It would capture all that information and more.. Fair enough, I'll see how easy it is to implement as maybe there's already something exposed that handles most of the workload when I got some down time.\nIn the meanwhile, I'll withdraw this.. Starts off #1501, this gets the ball rolling that we can at least monitor progress towards full support.. Well it frees us up from having to merge all changes at once. For example, I suspect the docstring AST change is going to be big enough to be worth considering separately.. Keywords as arguments could fit in nicely anywhere positional only arguments are taken, which is thus far only in the standard library, but I can't think of a nice way of implementing it without adding function introspection overhead.... Still working on some refactoring as I think I can do something nice to counteract the verbostiy of needing to specify HySymbol everywhere now explicitly.\n@Kodiologist this now works in the repr as expected:\nclojure\n=> `(print-args ~@[':key 42])\n'(print_args :key 42). No worries, gives me plenty of time to chew on this slowly.. I'm happy with this. I got some more work for dealing with all the tables, but I'll put that aside for now. I think we should get #1458 in first and rebase this on top of that.. Couple of notes:\n\nI'll pull out the repl work and put it up separately.\nI think it makes sense to start treating HySymbol like how I handle HyKeyword.\nI've also got mypy coverage for most of the compiler and its working really well.. Not neglecting, just don't have the free time. Hopefully will go through everything pending on the weekend.. Just taste. pytest doesn't require that we have to put them all together and I like having the file name reflect what's inside of it.\n\nCan do though, just a sec.. No worries, I get it.. Fixed up NEWS... finally. I have a patch for this, should we agree its desirable, but I'll wait for #1504 so its significantly cleaner.. Actually, another option is to drop lambdas altogether and only ever emit functions. They have the same performance characteristics anyways.... Should I close this then?. But I think its weird that fn then may generate a function, if it detects it contains statements. Its certainly deterministic, but its an internal that leaks outwards.\nAs far as I'm concerned, conceptually, fn generates a function but may choose to pick the more \"optimal\" representation of a lambda. But when you can't use a lambda everywhere you'd use a function, small weird things arise.\nAnyways, there is another approach to the other issue which I have a proof of concept: have a mechanism to promote fn to fn*.. Okay, so this is going to be a little on the stream of consciousness side, I apologize in advance.\nRight, let me be clear, I understand that is how its intended to be interpreted, and its how the docs present it as well.\n\nBut it doesn't make sense to decorate a fn...\n\nBut there's also a lot of effort put into rewriting setv + fn. This example:\nclojure\n(setv foo (with-decorator bar (fn [x] (import x) x)))\nemits equivalent code to:\npython\n@bar\ndef foo(x):\n    import x\n    return x\nTreating Hy like a black box, when I seeing this much effort in emitting optimal AST, I can't help but start to think of it the other way: that lambda is the optimization.\nIf we're going to say fn shouldn't be decorated, maybe we shouldn't let it be decorated at all. But I honestly don't see anything wrong with allowing fn to be decorated:\n\nWe can force a function expansion\nWe can make with-decorator work with function calls instead of decorator syntax when its a lambda (maybe this is the best solution #@(classmethod my-decorator foobar) -> classmethod(my_decorator(lambda ...))\n\n\nPython has a lot of constructs that are semantically redundant\n\nMy understanding is that that they're literally the same thing since Python 3 - internally at least.\n\nAlso, I'd like Hy to be able to generate every Python construct, even if it's not strictly necessary to do so\n\nWell, what about if we promoted #% and supported it first party to generate lambda's instead like in Clojure?\nAnyways, its no hill I want to die on, what do you guys think about my ideas on augmenting with-decorator then?\n. Because its an implicit type coercion that makes no sense imho:\n=> (list 'foo)\n['f', 'o', 'o']\nA symbol was turned into a string that was iterated on. I mean, if this behaviour showed up, how much more likely is to have been a bug than the intended behaviour?\nBut imho I'm really not a fan of treating symbols as strings.. Honestly, I would have expected a TypeError or ValueError. I think its more the type cohesion to string that's happening is what's bothering me (e.g. (= (string? 'foo) True) also rubs me the wrong way).\nI think I can understand why it was done intentionally, when getattr and co take strings, and python objects are really just tables, but they're not really the same thing. Attributes are a subset of valid keys. so I have no expectation for them to be interchangeable. I guess Hy is also not limited to Python's rules for identifiers.\nI mean, I can live with it.. I think turning it on by default inside the REPL is great, but my concern is more so that it leaks outside the context and creates a something less readable. Hy objects will cross the Python boundry:\n```python\n\n\n\nfoo = hy.HyExpression([hy.HySymbol('foo')])\nrepr(foo)\n\"\\x1b[33m\\x1b[22mHyExpression\\x1b[39m\\x1b[22m\\x1b[33m\\x1b[22m([\\x1b[39m\\x1b[22m\\n  HySymbol('foo')\\x1b[33m\\x1b[22m])\\x1b[39m\\x1b[22m\"\n```\nWhat happens if I'm logging exceptions with context and there's a Hy expression? Now there's noise I have to strip out\n\n\n\nHere's another example where it creates noise in pytest:\n```\n\n  assert not hy.HyExpression([hy.HySymbol('foo')])\n\nE       AssertionError: assert not HyExpression([\\n  HySymbol('foo')])\nE        +  where HyExpression([\\n  HySymbol('foo')]) = ([HySymbol('foo')])\nE        +    where  = .HyExpression\n```\npytest correctly strips escape sequences, but the newline characters are literally printed and, imho, impede understanding. Because technically we're abusing repr.\n\nAnd looking at #1360, @kirbyfan64 properly points out this: \n\nPython reprs that are known to not round trip are conventionally contained in <>, for example:\n\nBut the escape sequences prevent round tripping from working.. And as a heads up, the Finder API (what we've incorrectly named MetaImporter) as also deprecated. Looking into this.. I'm knee deep in this now, and I think there's some really interesting potential with a reworked importer... I got some ideas I'll put up in a proposal, if this work pans out.. Yeah, digging into this and #1513 got me looking under the hood and I think I've been effectively nerd snipped. \ud83d\ude09 \nI've got something that's working on both python 2 and python 3, using only 3.4 and newer importlib API on python 3, and much simpler than the reverted polyloader.\nI've also took the opportunity to deal with some of other bugs like #1466. The following application:\nclojure\n\"Tool to dump __spec__, __loader__, and other metadata\"\n(print \"name:\" __name__)\n(print \"doc:\" __doc__)\n(print \"package:\" __package__)\n(print \"loader:\" __loader__)\n(print \"spec:\" __spec__)\n(print \"file:\" __file__)\n(print \"cached:\" __cached__)\nprints\n$ hy .\nname: __main__\ndoc: Test tool to dump __spec__, __loader__, and other metadata\npackage: \nloader: <hy.importlib.bootstrap.HyLoader object at 0x7f7c2ff00c88>\nspec: ModuleSpec(name='__main__', loader=<hy.importlib.bootstrap.HyLoader object at 0x7f7c2ff00c88>, origin='/home/simon/src/hy/dumpers/__main__.hy')\nfile: /home/simon/src/hy/dumpers/__main__.hy\ncached: /home/simon/src/hy/dumpers/__pycache__/__main__.cpython-36.hyc\n(I'm also playing with changing the bytecode cache extension to .hyc at the moment. I won't try to get that merged in - well, unless you guys like that idea - but I've got some ideas on some extra information we can store in the cache that would justify changing the extension).\nShould get a PR with substantially more test coverage tomorrow.. Going to close this in favour of a bigger issue.. Fixes #1134. Not sure about #459 - while I don't touch sys.executable, I haven't seen __name__ to be incorrect yet anywhere.. Yeah, the code in #1134 works now. I assume you're referring to:\n$ echo '(import b) (print \"in a\")' > a.hy            \n$ echo '(import a) (print \"in b\")' > b.hy\n$ echo '(import a b) (print \"done\")' > main.hy\n$ hy main.hy\nTraceback (most recent call last):\n  ...\n  File \"/tmp/b.hy\", line 1, in <module>\n    (import a) (print \"in b\")\nImportError: import of 'a' halted; None in sys.modules. I've got a large refactoring of the importer to properly support python2, python3, and properly implement the necessary APIs that allow runpy to work on both platforms (which in turn solves #1466). Another issue worth reporting: Hy injects sys.path.insert(0, \"\") but can't load from that path.\nThis is because the way find_on_path was implemented that causes it to construct, when processing import foo, /foo/__init__.hy and /foo.hy. Still a little more work to do. Found one more issue, we don't properly interact with sys.path_importer_cache. But I have something that, with one kludge related to that cache, integrates properly with Python now.\nI've made one more big change that I think is worth bringing up: I've switched the bytecode file from .pyc to .hyc and added a HY_MAGIC_NUMBER header to the start of that file. There are two immediate benefits from this:\n\nModule names can already collide (e.g. foo.py and foo.hy can exist side by side). There's no reason that the bytecode has to share a filename.\nSimplifies supporting multiple versions of Python - we no longer have to worry about differences between python versions, all versions of Hy can read and write the same format. What's nice is that if we add support for PEP 552, we can support it across the entire Hy ecosystem, it doesn't have to be gated to Python 3.7.\n\nNow I realize this means you can't distribute a Hy project as pure .pyc files anymore, but you couldn't really do that anyways as Hy is pretty tied to its standard library. And if the standard library is present, then an .hyc only distribution should work just fine as well.\nAnd, this change also lets us add Hy specific features to the bytecode file structure independent from Python, which I think can see some innovations. Imagine if we stored information about the macros that where used in compilation. We might be able to make Hy automatically invalidate bytecode whenever those macros change - even when the macros as defined in a different file.. > The proposed change, as it currently stands, adds a good 400 lines of code, so the proof is in the pudding: does it fix all the bugs it's intended to fix? Until then, it's hard for me to judge your code.\nI'm planning on building a large test coverage for it - at the very minimum copy Python's own test set around its importlib - so lets wait for that before I make any concrete promises of correctness. But, at the very least, as far as I can tell:\n\n__name__, __file__, __path__, __package__, loader`, etc, are set correctly and as expected.\nrunpy.run_module and runpy.run_file work as expected when pointed at Hy code\nProperly recover when a module fails to load. Reloading modules works as expected now. Haven't tested IPython autoreload yet though.\n\n\nIt's a Bad Idea to have both foo.py and foo.hy in the first place...\n\nI agree, but its technically possible. As for order, Hy would always load first because we put our loader first, but that's besides the point...\nThat second point is a really good point I didn't consider. Should have realized it too because I've done it to have literal includes from files and that, while at least deterministic, suffers from a similar problem.\n\nBut if switching to our own bytecode format substantially simplifies the new code, it could be worth it.\n\nAt the very least, and the strongest argument for it, is it means one loader for everyone and one less place where we need to chase Python.\n\nadds a good 400 lines of code\n\nFortunately, end delta is going to be smaller. I uploaded some temporary files by accident. Currently looking at a 200 line increase. I uploaded two versions of the Python 2 support...\nPart of this is stuff I have to backport from Python 3, like atomic_write, to try and make file writing more robust. This is new behaviour that goes beyond what the old code did, but matches Python's own behaviours. Its probably desirable to have, as technically having multiple processes writing our the same Hy bytecode is potentially racy.. Yeah, maybe, but it might get complicated to do right when we're looking at the interaction between modules and packages. A foo.hy would overshadow foo.py, foo/__init__.py, and, depending on the situation, foo/__main__.py.. > I wouldn't approve of a change that breaks hy2py.\nAs far as I can tell, hy2py doesn't work at the bytecode level though.\n\nI expect we'd get it working at the level of mypy's typed AST, or a perfected hy2py via astor, not directly from bytecode, but I'm not sure.\n\nYes, this is probably how it would work in practise, no need for bytecode. There has also been talk of adding a plugin system to mypy: https://github.com/python/mypy/issues/1240 We might be able to just teach mypy how to read Hy definitions. At the very least, I was considering trying to add stub file support to hy2py with #1482 \n\nIt also means losing compatibility with any Python tools that directly act on .pyc files\n\nIt would also have consequences for packaging, actually. While I think Hy could really benifit if we add some setuptools integration, until that's done, maybe its best to revert it for now and reconsider it in the future.. I've dug into #1085 and I think the bytecode issue is actually a red herring. The problem is in how that patch replaces the default FileLoader. If you look at the contents of sys.path_importer_cache, you'll notice that patch effectively trashes a virtualenv: it goes from this:\n=> (pprint sys.path_importer_cache)\n{'/home/simon/.local/share/virtualenvs/hy-eeIqtnUk/bin': FileFinder('/home/simon/.local/share/virtualenvs/hy-eeIqtnUk/bin'),\n '/home/simon/.local/share/virtualenvs/hy-eeIqtnUk/bin/hy': None,\n '/home/simon/.local/share/virtualenvs/hy-eeIqtnUk/lib/python3.6': FileFinder('/home/simon/.local/share/virtualenvs/hy-eeIqtnUk/lib/python3.6'),\n '/home/simon/.local/share/virtualenvs/hy-eeIqtnUk/lib/python3.6/collections': FileFinder('/home/simon/.local/share/virtualenvs/hy-eeIqtnUk/lib/python3.6/collections'),\n '/home/simon/.local/share/virtualenvs/hy-eeIqtnUk/lib/python3.6/encodings': FileFinder('/home/simon/.local/share/virtualenvs/hy-eeIqtnUk/lib/python3.6/encodings'),\n '/home/simon/.local/share/virtualenvs/hy-eeIqtnUk/lib/python3.6/importlib': FileFinder('/home/simon/.local/share/virtualenvs/hy-eeIqtnUk/lib/python3.6/importlib'),\n '/home/simon/.local/share/virtualenvs/hy-eeIqtnUk/lib/python3.6/lib-dynload': FileFinder('/home/simon/.local/share/virtualenvs/hy-eeIqtnUk/lib/python3.6/lib-dynload'),\n '/home/simon/.local/share/virtualenvs/hy-eeIqtnUk/lib/python3.6/site-packages': FileFinder('/home/simon/.local/share/virtualenvs/hy-eeIqtnUk/lib/python3.6/site-packages'),\n '/home/simon/.local/share/virtualenvs/hy-eeIqtnUk/lib/python3.6/site-packages/astor': FileFinder('/home/simon/.local/share/virtualenvs/hy-eeIqtnUk/lib/python3.6/site-packages/astor'),\n '/home/simon/.local/share/virtualenvs/hy-eeIqtnUk/lib/python3.6/site-packages/clint': FileFinder('/home/simon/.local/share/virtualenvs/hy-eeIqtnUk/lib/python3.6/site-packages/clint'),\n '/home/simon/.local/share/virtualenvs/hy-eeIqtnUk/lib/python3.6/site-packages/clint/packages': FileFinder('/home/simon/.local/share/virtualenvs/hy-eeIqtnUk/lib/python3.6/site-packages/clint/packages'),\n '/home/simon/.local/share/virtualenvs/hy-eeIqtnUk/lib/python3.6/site-packages/clint/packages/colorama': FileFinder('/home/simon/.local/share/virtualenvs/hy-eeIqtnUk/lib/python3.6/site-packages/clint/packages/colorama'),\n '/home/simon/.local/share/virtualenvs/hy-eeIqtnUk/lib/python3.6/site-packages/clint/textui': FileFinder('/home/simon/.local/share/virtualenvs/hy-eeIqtnUk/lib/python3.6/site-packages/clint/textui'),\n '/home/simon/.local/share/virtualenvs/hy-eeIqtnUk/lib/python3.6/site-packages/pkg_resources': FileFinder('/home/simon/.local/share/virtualenvs/hy-eeIqtnUk/lib/python3.6/site-packages/pkg_resources'),\n '/home/simon/.local/share/virtualenvs/hy-eeIqtnUk/lib/python3.6/site-packages/pkg_resources/_vendor': FileFinder('/home/simon/.local/share/virtualenvs/hy-eeIqtnUk/lib/python3.6/site-packages/pkg_resources/_vendor'),\n '/home/simon/.local/share/virtualenvs/hy-eeIqtnUk/lib/python3.6/site-packages/pkg_resources/_vendor/packaging': FileFinder('/home/simon/.local/share/virtualenvs/hy-eeIqtnUk/lib/python3.6/site-packages/pkg_resources/_vendor/packaging'),\n '/home/simon/.local/share/virtualenvs/hy-eeIqtnUk/lib/python3.6/site-packages/pkg_resources/extern': FileFinder('/home/simon/.local/share/virtualenvs/hy-eeIqtnUk/lib/python3.6/site-packages/pkg_resources/extern'),\n '/home/simon/.local/share/virtualenvs/hy-eeIqtnUk/lib/python3.6/site-packages/rply': FileFinder('/home/simon/.local/share/virtualenvs/hy-eeIqtnUk/lib/python3.6/site-packages/rply'),\n '/home/simon/.local/share/virtualenvs/hy-eeIqtnUk/lib/python36.zip': None,\n '/home/simon/src/MonkeyType': FileFinder('/home/simon/src/MonkeyType'),\n '/home/simon/src/hy': FileFinder('/home/simon/src/hy'),\n '/home/simon/src/hy/hy': FileFinder('/home/simon/src/hy/hy'),\n '/home/simon/src/hy/hy/lex': FileFinder('/home/simon/src/hy/hy/lex'),\n '/home/simon/src/hy/hy/models': FileFinder('/home/simon/src/hy/hy/models'),\n '/usr/lib/python3.6': FileFinder('/usr/lib/python3.6'),\n '/usr/lib64/python3.6': FileFinder('/usr/lib64/python3.6'),\n '/usr/lib64/python3.6/ctypes': FileFinder('/usr/lib64/python3.6/ctypes'),\n '/usr/lib64/python3.6/email': FileFinder('/usr/lib64/python3.6/email'),\n '/usr/lib64/python3.6/json': FileFinder('/usr/lib64/python3.6/json'),\n '/usr/lib64/python3.6/urllib': FileFinder('/usr/lib64/python3.6/urllib'),\n '/usr/lib64/python3.6/xml': FileFinder('/usr/lib64/python3.6/xml'),\n '/usr/lib64/python3.6/xml/parsers': FileFinder('/usr/lib64/python3.6/xml/parsers')}\nto\n=> (pprint sys.path_importer_cache)\n{'/home/simon/.local/share/virtualenvs/hy-eeIqtnUk/bin': FileFinder('/home/simon/.local/share/virtualenvs/hy-eeIqtnUk/bin'),\n '/home/simon/.local/share/virtualenvs/hy-eeIqtnUk/lib/python3.6': FileFinder('/home/simon/.local/share/virtualenvs/hy-eeIqtnUk/lib/python3.6'),\n '/home/simon/.local/share/virtualenvs/hy-eeIqtnUk/lib/python3.6/lib-dynload': FileFinder('/home/simon/.local/share/virtualenvs/hy-eeIqtnUk/lib/python3.6/lib-dynload'),\n '/home/simon/.local/share/virtualenvs/hy-eeIqtnUk/lib/python3.6/site-packages': FileFinder('/home/simon/.local/share/virtualenvs/hy-eeIqtnUk/lib/python3.6/site-packages'),\n '/home/simon/.local/share/virtualenvs/hy-eeIqtnUk/lib/python3.6/site-packages/astor': FileFinder('/home/simon/.local/share/virtualenvs/hy-eeIqtnUk/lib/python3.6/site-packages/astor'),\n '/home/simon/.local/share/virtualenvs/hy-eeIqtnUk/lib/python36.zip': None,\n '/home/simon/src/hy': FileFinder('/home/simon/src/hy'),\n '/home/simon/src/hy/hy': FileFinder('/home/simon/src/hy/hy'),\n '/home/simon/src/hy/hy/core': FileFinder('/home/simon/src/hy/hy/core'),\n '/usr/lib/python3.6': FileFinder('/usr/lib/python3.6'),\n '/usr/lib64/python3.6': FileFinder('/usr/lib64/python3.6')}\nI tried to load some code with -m with that patch and I got this:\nhy -m dumpers.lvl2\n/home/simon/.local/share/virtualenvs/hy-eeIqtnUk/lib/python3.6/site-packages/IPython/kernel/__init__.py:13: ShimWarning: The `IPython.kernel` package has been deprecated since IPython 4.0.You should import from ipykernel or jupyter_client instead.\n  \"You should import from ipykernel or jupyter_client instead.\", ShimWarning)\nTraceback (most recent call last):\n  File \"/home/simon/.local/share/virtualenvs/hy-eeIqtnUk/bin/hy\", line 11, in <module>\n    load_entry_point('hy', 'console_scripts', 'hy')()\n  File \"/home/simon/src/hy/hy/cmdline.py\", line 344, in hy_main\n    sys.exit(cmdline_handler(\"hy\", sys.argv))\n  File \"/home/simon/src/hy/hy/cmdline.py\", line 318, in cmdline_handler\n    return run_module(options.mod)\n  File \"/home/simon/src/hy/hy/cmdline.py\", line 201, in run_module\n    if mod[1] == mod_name), None)\n  File \"/home/simon/src/hy/hy/cmdline.py\", line 200, in <genexpr>\n    mod = next((mod for mod in pkgutil.walk_packages()\n  File \"/usr/lib64/python3.6/pkgutil.py\", line 107, in walk_packages\n    yield from walk_packages(path, info.name+'.', onerror)\n  File \"/usr/lib64/python3.6/pkgutil.py\", line 92, in walk_packages\n    __import__(info.name)\n  File \"/home/simon/.local/share/virtualenvs/hy-eeIqtnUk/lib/python3.6/site-packages/matplotlib/tests/__init__.py\", line 17, in <module>\n    'The baseline image directory does not exist. '\nOSError: The baseline image directory does not exist. This is most likely because the test data is not installed. You may need to install matplotlib from source to get the test data.\nThis is a very similar problem to what was reported in the first place, and it happens even if there's no bytecode on the system. And, for completness this is the contents of the file that's run:\nclojure\n\"Module to dump __spec__, __loader__, and other metadata\"\n(print \"Welcomd to Hy\")\n(print \"name:\" __name__)\n(print \"doc:\" __doc__)\n(print \"package:\" __package__)\n(print \"loader:\" __loader__)\n(if-python2 () (print \"spec:\" __spec__))\n(print \"file:\" __file__)\n(if-python2 () (print \"cached:\" __cached__))\nI think those changes just broke module resolution, and a side effect of that might have been loading different code (bytecode or source) than expected.. But yes, we should be careful. I'm not going to be comfortable letting it get merged until I get around to writing a full test suite just for it. I just won't have time till the next weekend.. @kirbyfan64 dug into it a little bit, I'm not exactly right - for some reason that polyloader tries to load everything run we try to load a package with -m:\nAdded a print statement above that __import__ line and we see this:\n$ hy -m dumpers.lvl2\n!!! collections\n!!! distutils\n!!! distutils.command\n!!! distutils.tests\n!!! encodings\n!!! importlib\n!!! asyncio\n!!! concurrent\n!!! concurrent.futures\n!!! ctypes\n!!! ctypes.macholib\n!!! ctypes.test\n!!! curses\n!!! dbm\n!!! email\n!!! email.mime\n!!! ensurepip\n!!! html\n!!! http\n!!! idlelib\n!!! idlelib.idle_test\n!!! json\n!!! lib2to3\n!!! lib2to3.fixes\n!!! lib2to3.pgen2\n!!! lib2to3.tests\n!!! logging\n!!! multiprocessing\n!!! multiprocessing.dummy\n!!! pydoc_data\n!!! sqlite3\n!!! sqlite3.test\n!!! test\n!!! tkinter\n!!! tkinter.test\n!!! tkinter.test.test_tkinter\n!!! tkinter.test.test_ttk\n!!! turtledemo\n!!! unittest\n!!! unittest.test\n!!! unittest.test.testmock\n!!! urllib\n!!! venv\n!!! wsgiref\n!!! xml\n!!! xml.dom\n!!! xml.etree\n!!! xml.parsers\n!!! xml.sax\n!!! xmlrpc\n!!! IPython\n!!! IPython.core\n!!! IPython.core.magics\n!!! IPython.core.tests\n!!! IPython.extensions\n!!! IPython.extensions.tests\n!!! IPython.external\n!!! IPython.external.decorators\n!!! IPython.kernel\n/home/simon/.local/share/virtualenvs/hy-eeIqtnUk/lib/python3.6/site-packages/IPython/kernel/__init__.py:13: ShimWarning: The `IPython.kernel` package has been deprecated since IPython 4.0.You should import from ipykernel or jupyter_client instead.\n  \"You should import from ipykernel or jupyter_client instead.\", ShimWarning)\n!!! IPython.lib\n!!! IPython.lib.tests\n!!! IPython.sphinxext\n!!! IPython.terminal\n!!! IPython.terminal.pt_inputhooks\n!!! IPython.terminal.tests\n!!! IPython.testing\n!!! IPython.testing.plugin\n!!! IPython.testing.tests\n!!! IPython.utils\n!!! IPython.utils.tests\n!!! _pytest\n!!! _pytest._code\n!!! _pytest.assertion\n!!! astor\n!!! attr\n!!! click\n!!! clint\n!!! clint.packages\n!!! clint.packages.colorama\n!!! clint.textui\n!!! colorlog\n!!! dateutil\n!!! dateutil.tz\n!!! dateutil.zoneinfo\n!!! ipykernel\n!!! ipykernel.comm\n!!! ipykernel.gui\n!!! ipykernel.inprocess\n!!! ipykernel.inprocess.tests\n!!! ipykernel.pylab\n!!! ipykernel.tests\n!!! ipython_genutils\n!!! ipython_genutils.testing\n!!! ipython_genutils.tests\n!!! jedi\n!!! jedi.api\n!!! jedi.common\n!!! jedi.evaluate\n!!! jedi.evaluate.compiled\n!!! jedi.evaluate.context\n!!! jupyter_client\n!!! jupyter_client.blocking\n!!! jupyter_client.ioloop\n!!! jupyter_client.tests\n!!! jupyter_core\n!!! jupyter_core.tests\n!!! jupyter_core.utils\n!!! lxml\n!!! lxml.html\n!!! lxml.includes\n!!! lxml.isoschematron\n!!! matplotlib\n!!! matplotlib.axes\n!!! matplotlib.backends\n!!! matplotlib.backends.qt_editor\n!!! matplotlib.cbook\n!!! matplotlib.compat\n!!! matplotlib.projections\n!!! matplotlib.sphinxext\n!!! matplotlib.sphinxext.tests\n!!! matplotlib.style\n!!! matplotlib.testing\n!!! matplotlib.testing._nose\n!!! matplotlib.testing._nose.plugins\n!!! matplotlib.testing.jpl_units\n!!! matplotlib.tests\nTraceback (most recent call last):\n  File \"/home/simon/.local/share/virtualenvs/hy-eeIqtnUk/bin/hy\", line 11, in <module>\n    load_entry_point('hy', 'console_scripts', 'hy')()\n  File \"/home/simon/src/hy/hy/cmdline.py\", line 344, in hy_main\n    sys.exit(cmdline_handler(\"hy\", sys.argv))\n  File \"/home/simon/src/hy/hy/cmdline.py\", line 318, in cmdline_handler\n    return run_module(options.mod)\n  File \"/home/simon/src/hy/hy/cmdline.py\", line 201, in run_module\n    if mod[1] == mod_name), None)\n  File \"/home/simon/src/hy/hy/cmdline.py\", line 200, in <genexpr>\n    mod = next((mod for mod in pkgutil.walk_packages()\n  File \"/usr/lib64/python3.6/pkgutil.py\", line 108, in walk_packages\n    yield from walk_packages(path, info.name+'.', onerror)\n  File \"/usr/lib64/python3.6/pkgutil.py\", line 93, in walk_packages\n    __import__(info.name)\n  File \"/home/simon/.local/share/virtualenvs/hy-eeIqtnUk/lib/python3.6/site-packages/matplotlib/tests/__init__.py\", line 17, in <module>\n    'The baseline image directory does not exist. '\nOSError: The baseline image directory does not exist. This is most likely because the test data is not installed. You may need to install matplotlib from source to get the test data.\nBut I think it makes my point that the problem's with that loader is it too was incorrectly implemented and loads weird things, rather than a problem with bytecode persay.\nI mean, I'd be really surprised if we where emitting incorrect bytecode in the polyloader since it defers to Python internals.... Fiddling with the loader further, I think I'm getting really close to something really nice and simple, and as close to correct as I understand Python's loading mechanism to be, but I think there are some interesting corner cases that need to be documented.\nI initially tried to subclass as much as possible from importlib.machinery, but I think I'll have to provide my own implementations for a few things interntionally.\nFor example, say I had the following package:\npep420/\n\u2514\u2500\u2500 __init__.hy\nAnd I open python and try to import it without first importing hy (Python 3.3 and newer):\n```\n\n\n\nimport pep420\npep420\n\n```\n\n\n\nWe've loaded it successfully, but not as Hy code. This is because Hy packages slip under the radar and trick python into thinking we're defining a namespace. See PEP 420.\nNow this PEP is is interesting, and suff introduced in there would probably be the backbone for emulating clojures namespaces, should we go down that road (as I understand them, at least - I'm also a clojure newbie).\nBut it does lead to some interesting pitfalls that a beginner to Hy might fall into (heck, I didn't know about PEP 420 until yesterday, and I consider myself experienced) when trying to glue into Python.\nIts also something that complicated the new loader because it means I can't just subclass the default importlib machinery and change the appropriate bits. When I promote the Hy sys.meta_path entry to first, suddently Python code starts showing up as namespace modules.\nThe Hy loader must specificly be first and not directly support the scheme established in PEP 420.\nAnother potential issue I've not fully dug into is how safe is it to even mix Python and Hy code inside a single module at all.\nPython, as I understand it, recusrively imports packages, so import foo.bar causes both foo and foo.bar to be loaded. But as it does it, the \"foo\" loader is used to determine the loader to use for \"foo.bar\". Meaning if \"foo\" is Python, and \"foo.bar\" is Hy, because the Python loader loaded \".bar\", we can end up in the PEP 420 trap again.\nWe've gotten around this in the past because the current Hy loader doesn't handle relative imports the same way Python does and treats everything as a fully qualified module. It looks like a valid workaround, but I can't speak for its overall correctness.\nThat said, if we make the Hy loader preferential, and intentionally break PEP 420 support, I'm 99% sure we'll mitigate most things, but this seems \"antagonistic\" enough to maybe warrent documentation.  \nI'm still investigating, learning, so expect things to change. But if I'm saying something obviously wrong, please correct me.. Okay, got it working for Python 3 in a way that's, as far as I know, 100% compliant to how the Python module system works.\n\nWe need to have the first entry in sys.meta_path - well, we just need to be in top of the _frozen_importlib_external.PathFinder - as our custom HyPathFinder. The custom HyPathFinder has similar logic to PathFinder, but needs to have its own path_hooks and path_importer_cache (independent of sys).\nWe then load a custom HyFileFinder into our internal path_hooks that implements pretty much the same logic as FileFinder sans namespaces (otherwise we'll swallow python modules as namespace modules - we want to fail here and let the next sys.meta_path entry try instead).\nThe HyFileFinder is then responsible for finding files and generating module specs with the HyLoader loader. This then allows python to generate the right modules.\n\nOn top of this, we support the file system caching system, so imports should be faster, and we can independently extend the Python 3 module loader without worrying about clobbering Python at all.\nTests are almost done (most of these problems cropped up when writing tests), so hopefully tomorrow, barring any other major underestimations of how the system works.. I think the new loader is now correctly implemented for both Python 2 and Python 3, and is the simplest implementation it can be.\nStill not happy with the module structure, still needs a few cleanups, still needs tests written.. Going to close and reopen once done under the new PR guidelines. Thanks for everyone's patience.. Heads up, we'll have to be careful with this at release time. I found I had to flush all my compiled pyc files.. Yes.. Well, its not only about Hy, right?\nLets say I package Hy for Arch Linux (which there exists a package in AUR), and some other useful Hy library/tool (honestly don't know of any, but for examples sake, suppose there is).\nBecause the best practice for packaging Python like this is to also package the .pyc files, the eventual update to Hy to 0.15 would also mean all other Hy packages have to be rebuilt.\nNot the worst thing in the world to require, but its a kind of change that really needs to be announced.\nI'll put something up for adding it to the NEWS file tonight.. This one has been sitting on the sidelines too long, hopefully I can wrap this one up today.\nMoving documentation to org and a gist, I'll convert it to rst before merging: https://gist.github.com/vodik/efe2310b8d0e5c065a1a38e582d4e580. This is still coming along, I just hate writing documentation.. > I m not yet familiar with hylang, but it looks like you reimplemented an importlib... \nHey, yeah. So most of the reimplementation is for Python 2 compatibility. Drop Python 2 and 3/4 of that codebase disappears - I can rely on importlib directly. My intention was to reuse the loader between Python 2 and 3, and then implementing the corresponding import protocols.\nI might have done stuff wrong, but the loader should respect Python 2 conventions, like how submodules as supposed to be loaded recursively, while also leveraging Python 3.4+ semantics on Python 3 with the new module spec system. Bytecode generation and related stuff is there because, as far as I can tell, its not exposed in Python 2. Only in 3.\n\nIt might be necessary or not, not sure how much you want to deviate from python import semantics (namespaces packages, bytecode location and all that...)\n\nI only deviate with namespace packages.\nMaybe you can help me here, but as far as I can tell, I have to break namespace modules. This is a Python 3 bug. In theory, Hy should work just fine if I add a new Path/File finders paired with the appropriate loader. But this actually breaks Python. Here's the problematic function inside importlib dealing with package detection:\nhttps://github.com/python/cpython/blob/master/Lib/importlib/_bootstrap_external.py#L717\npython\ndef is_package(self, fullname):\n    \"\"\"Concrete implementation of InspectLoader.is_package by checking if\n    the path returned by get_filename has a filename of '__init__.py'.\"\"\"\n    filename = _path_split(self.get_filename(fullname))[1]\n    filename_base = filename.rsplit('.', 1)[0]\n    tail_name = fullname.rpartition('.')[2]\n    return filename_base == '__init__' and tail_name != '__init__'\nNotice how its not actually checking for __init__.py? Python is happy to accept __init__.hy as a sign we're inside a Python package (or another extension, really). Hy code gets loaded as a Python namespace module. \nThe workaround is to that Hy must have its own meta loader, which needs to come first, and - to avoid the problem of then loading __init__.py as a Hy namespace module, we have to explicitly break namespace module support. I've been meaning to open a CPython bug for this. I should just do it. I'll get something prepped....\n(Well, strictly speaking, meta loader isn't necessary here - but its convenient for being able to handle overlapping Py/Hy packages when different submodules are in different languages - which we rely on internally.)\n\nBut I though you might want to know about filefinder2, which I maintain, as I need custom imports (py2/py3) for other projects. The goal is to eventually phase it out when py3 takes over, but it currently is a good base to start when writing a custom importer.\n\nSo long as you do a good job of matching Python 2's expected behaviour (instead of backporting 3), I'm game for trying to merge what I've learned here back. And if there's interest in using it besides me, I don't see a problem with it then.\n. Oh right, part of my slowness here is I'm trying to draft documentation covering how all this works, the why, and the gotchas. Might as well relink it:\nhttps://gist.github.com/vodik/efe2310b8d0e5c065a1a38e582d4e580\nFeedback is welcome if I got anything obviously wrong.\nBut this is certainly a topic where resources as scarce and I kinda wish I found your stuff earlier. Having a single project for this probably makes a lot of sense.. \nOkay, writing this in a rush, so hopefully I'm clear. Sorry if not.\n\n\nI might have done stuff wrong, but the loader should respect Python 2 conventions, like how submodules as supposed to be loaded recursively,\n\nI would be more careful about respecting python3 conventions... because the end is near.\nWhat do you mean submodules are loaded recursively ? They should be loaded if and only if the init.py import them, no ? Maybe something I am not aware of (or already forgot about) regarding python2.\n\nDid you mean respecting Python 2 conventions?\nYes, I realize the end is near. If it where up to me, we'd drop Python 2 tomorrow. But in the meanwhile, I have to support it. And, in my humble opinion, the best way to do it is to match Python 2's loader's behaviour (not backport Python 3's behaviour), and do it in such a way that a simple patch will drop code, rather than requiring rewites.\nAs for recursive:\n\nIf it is a package, as in the second line import pkg.module, the pkg is first imported using the steps above, and \u201c__path__\u201d is set on it, and later passed into find_module(\u201cpkg.module\u201d, path=pkg.__path__) to import pkg.module, this is called a submodule import. Submodules are imported this way recursively (As a result of importing pkg.module, the sys.modules will contain both pkg and pkg.module).\n\nSource: https://chaobin.github.io/2015/06/22/understand-import-system-of-python/\n^ Python 3 doesn't do this anymore. I forgot where this changed, its been about 3 months since I've last had the time to dig into this. I think it came with the newer module spec logic that came with 3.3/3.4.\n\n\nBytecode generation and related stuff is there because, as far as I can tell, its not exposed in Python 2. Only in 3.\n\nYes, and it is good to have it (if you need it). I didn't implement that in filefinder2 because I had no usecase for it. Meaning, filefinder2 will use the one in python interpreter (2 or 3, the one that is available), I had no need to modify it yet, so no need to reimplement it there. Also I don't care much about having bytecode or not in python2. Talking about it now, I wonder if I even have test cases for it...\n\nIt's not actually modified at the moment. I toyed with the idea and reverted it. But I've been meaning to propose reintroducing it. For example, if we where to embed a small header at the start of the bytecode file, we can choose to invalidate bytecode between Hy releases that would break things. For example, we recently went through a mangling scheme change. But this change meant all pre-existing bytecode files had the old names and thus broke. If we had control over the bytecode header, we could have at least forced Hy to invalidate.\nI have a few other ideas here, but its not a simple topic and needs to be hashed out with everyone here, so I'm not making that change yet.\n\nIf hylang needs bytecode, it would be great if you can find some time to integrate that in filefinder2( with test cases !). That package is specifically for python 2/3 compatibility, and deviation from py3 will need to be implemented outside of filefinder2 (inheriting from filefinder2 where suitable). Implementing that might be quite an adventure however...\n\nI only deviate with namespace packages.\nMaybe you can help me here, but as far as I can tell, I have to break namespace modules.\n\nI don't think so (or I don't get the problem yet...)\nThe code you refer to is in the Loader. Deciding for a namespace package or not, is at the PathFinder level. Because python is happy with a init.hy to be a normal package and load it, we should just add this logic into the PathFinder.find_spec method. I've put more details in https://gist.github.com/vodik/efjke2310b8d0e5c065a1a38e582d4e580, so let's keep discussing about it there.\n\nYeah, you're right. Its been a while since I last digged into it - its not there. Its here: https://github.com/python/cpython/blob/master/Lib/importlib/_bootstrap_external.py#L1388\nIts not in the PathFinder, its in the FileFinder. The FileFinder looks for \"__init__\" + suffix and gives up if its a directory. So you can't really chain FileFinders (either within the same PathFinder or across PathFinders) without them all sharing the same the same concept of a module (denoted by __init__.py as decided by the first FileFinder). The idea that a namespace module is blankly returned here prevents the rest of the file finders from getting a chance to see if they know how to provide a loader.\nNamespace module should be designated last, after all loaders give up. \nIf we had that behaviour, we could embed Hy as just another FileFinder in the standard sys.meta_loader loader instead of making our own PathFinder (which is really just a workaround - force Python to consider us first, then to explicitly break namespace packages, so FileFinder chaining will continue working).\nThis is why I think we're sitting on a Python bug. The current implementation of namespace modules violate spirit of PEP 302.\nLet me devise a small example to demonstrate the problem:\n```python\nimport contextlib\nimport os\nimport sys\nfrom importlib.machinery import FileFinder, SourceFileLoader\nSo, this is counter intutive, but we're going to add a new loader,\nthat we want to go first, before .py.\n\nIts easier to highlight the problem this way\nsys.path_hooks.insert(0, FileFinder.path_hook((SourceFileLoader, [\".badpy\"])))\nwith contextlib.suppress(FileExistsError):\n    os.mkdir(\"good\")\nwith contextlib.suppress(FileExistsError):\n    os.mkdir(\"bad\")\nwith contextlib.suppress(FileExistsError):\n    os.mkdir(\"contrast\")\nWe'll always be able to directly find modules if we don't do\npackages: good/demo.py -> good.demo works. We fall though our loader\nand the standard ones afterwards do their thing\n\nThis works because the full filename matches, so init stuff is bypassed.\nThat's the fallback behaviour when an exact match isn't found\nwith open(\"good/demo.py\", \"w\") as module:\n    module.write(\"\"\"print(\"Hello World\")\"\"\")\n    import good.demo\n    print(good.demo)  # \nBut, we can no longer import packages!\n\nThis loads as a namespace module now. Why? Because the first loader\n(.badpy one) will now will look for bad/init.badpy, doesn't find it, but\ndecides that since we're insider a folder, we a namespace\n\nNo more chaining of loaders anymore, we shutdown too  early - even\nthough the next one afterwards would be more than happy to do its thing.\nwith open(\"bad/init.py\", \"w\") as module:\n    module.write(\"\"\"print(\"Hello World\")\"\"\")\n    import bad\n    print(bad)  # HA! \nBut we can still load modules if we use __init__.badpy.\nwith open(\"contrast/init.badpy\", \"w\") as module:\n    module.write(\"\"\"print(\"Hello World\")\"\"\")\n    import contrast\n    print(contrast)  # \n```\n\n\nSo long as you do a good job of matching Python 2's expected behaviour (instead of backporting 3),\n\nI do backport python3, to match its behavior by default, but another goal is for anyone to be able to modify (by inheritance) the behavior where needed, to :\n\nminimize the cost of porting custom importer systems to (latest) python3.\nmake it simple to implement a custom importer with proper behaviors when no deviation is explicitely required\nmake it obvious where a custom importer deviates from python3 import logic\nmake it obvious in the code where importers are enabled or not (using context managers)\n\n\nHave a look at my design - most of the stuff is literally pulled out from Python 3.6 CPython's code base. The compat.py module does a good job of taking Python 3's machinery and making it Python 2 compatible. You don't actually need to compromise here and ignore Python 2.\nI haven't had the chance to audit your code yet, but I am interested in digging into it.\n\n\nI'm game for trying to merge what I've learned here back. And if there's interest in using it besides me, I don't see a problem with it then.\n\nOh yes, please do.\nI think it is beneficial in general to push all the python2 backward compatibility code to external packages (2to3 or six), I just didn't find one that was allowing to also do custom imports. Doing that will really reduce the code complexity in hylang.\n\nWell, it just shunts it around :wink:\n\nAlso there are tests there to validate many usecases in all (supported) python versions, and that can help a lot not to break someone's python because of a small import statement on a python version that wasn't tested.\nAlso the more use cases we have for filefinder2, the cleaner it will be, and python3 import upgrades will be less messy, when we will have to finally let python2 die.\n\nFinding the time to write test cases and documentation is actually what's I haven't found time to dig into at the moment.\nBut all things aside, this seems to be an archaic topic, with barely any good comprehensive resources, and ended up having to dig into CPython 2.7/3.6 source code to understand how the systems worked. Having a high quality, well documented library would be a boon.\n. Please, double check my work. Now that I put the effort together to write a concrete example, I should be in good shape to open a Python issue.\nIts been three months since I really dug deep into this and I was already finding myself rediscovering the importlib mechanisms to explain this.. I think making replace return a new object is likely going to work well enough. We can be a bit more aggressive with __slots__, and maybe also consider backing HyList with tuple instead of list - that should also be a slight performance improvement.\nYou shouldn't see any loops in the data structures, so the Python reference counter should be just fine. \nThe mutation was a quick hack to see what would happen. For all I knew the everything would have outright blown up.. Yeah, but immutable should be faster, not because immutable datastructures are faster, but because using pop to iterate through a list is slow:\n```\nIn [1]: def consumelist1(x):\n   ...:     while x:\n   ...:         x.pop(0)\n   ...:         \nIn [2]: def consumelist2(x):\n   ...:     for _ in x:\n   ...:         pass\n   ...:     \nIn [3]: %timeit consumelist1(list(range(100)))\n21.2 \u00b5s \u00b1 1.13 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\nIn [4]: %timeit consumelist2(list(range(100)))\n2.24 \u00b5s \u00b1 332 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n```\nI suspect making HyExpression an immutable tuple, and dealing with the occasional mutability when needed will perform a lot faster than constantly mutating lists.\nSome initial work I've done seems promising like it might improve compile times, but I haven't quite got Hy working fully yet.\nWhere we need lookahead, we can built it into the iterator instead: https://github.com/erikrose/more-itertools/blob/master/more_itertools/more.py#L135 (we could always borrow the code too instead of adding another dependency). Yeah, you know what, you're right and trying the lexer manually on various rejected snippets and they all pass. I'll dig a bit deeper.. For Hybris: http://pygments.org/docs/lexers/#pygments.lexers.scripting.HybrisLexer. Ah, the problem is in the filter, not the lexer:\nThe (deftag \u21bb [code] ...) example fails like this:\n```\n$ cat demo.hy | pygmentize -l hylang -F raiseonerror\n Error while highlighting:\npygments.filters.ErrorToken: \u21bb\n   (file \"/home/simon/.virtualenvs/hy/lib/python3.6/site-packages/pygments/filters/init.py\", line 196, in filter)\n If this is a bug you want to report, please rerun with -v.\n=> (deftag \n```\nand the postwalk demo:\n``` \n$ cat demo2.hy | pygmentize -l hylang -F raiseonerror\n Error while highlighting:\npygments.filters.ErrorToken: :\n   (file \"/home/simon/.virtualenvs/hy/lib/python3.6/site-packages/pygments/filters/init.py\", line 196, in filter)\n If this is a bug you want to report, please rerun with -v.\n=> (import [hy.contrib.walk [postwalk]])\n=> (setv trail '([1 2 3] [4 [5 6 [7]]]))\n=> (defn walking [x]\n...  (print \"Walking:\" x :sep \"\\n\")\n...  x)\n=> (postwalk walking trail)\nWalking\n``. And no, I can't read, the lexer is indeed failing. I missed it in the output (e.g.(Token.Error, '\u21bb')`). Opened a pygement issue around the unicode literal: https://bitbucket.org/birkenfeld/pygments-main/issues/1422/hy-doesnt-lex-unicode-literals. Tried it, and it actually causes more issues. Look a little closer at the fine print on that configuration setting:\n\nThe default is now 'default'. It is similar to 'python3'; it is mostly a superset of 'python'. but it fallbacks to 'none' without warning if failed.\n\nSetting it to \"hylang\" means we lost the \"none\" fallback, which means we have to make even more adjustments.\nFor example, consider this snippet insider tutorial.rst:\n```rst\nNotice the last two lines: Hy has a fraction literal like Clojure.\nIf you start Hy like this (a shell alias might be helpful)::\n$ hy --repl-output-fn=hy.contrib.hy-repr.hy-repr\n```\nAll these bits needs to now be made into explicit code-block's\nNot sure if its worth the effort, and/or going to be surprising to anyone contributing documentation.\n. So I'd be comfortable with merging this as is (unless people disagree with my opinion that its not worth perusing setting up highlight_language).\nI'm going to open a separate issue about fixing the Hy pygments lexer, and once fixes there are upstreamed, all remaining warning should disappear.\n. @Kodiologist i'll merge this tomorrow if there's no other complaints. All remaining warnings are pygment issues now, both with tickets open upstream.. If you're interested, dig into #1514 and #1518. I started digging into this a few weeks ago and there's a lot of problems with the loader.. Close. The hard parts are done, the branch works. I just need to revert some of my experiments (patching run_path to support Hy might not have been the best idea), and write some documentation on it.\nBut I got a busy week ahead of me with renovations, so I'll probably not have too much programming time. I'd have no problem merging this in the meanwhile. No point making this painful when the fix is just a few lines.\nAnd on that note, if you guys decide to merge this in the interim, have a look at #1513 as well, @etanol, and add that to this PR. Might as well work around two issues at once.. We can start with option 1 and move to option 2 if it ever becomes a problem with it being a default.. Off-topic, but +1 with removing the attribute list. Especially if we reintroduce def (or some other form) for declaring an attribute with type annotations - then the attribute list ends up also lacking useful functionality.\n. Look really good, just think we can simplify the AST generation a touch.. Technically class docstrings also go in the AST:\npython\nIn [3]: print(astor.dump_tree(ast.parse('''\n   ...: class foo():\n   ...:     \"test\"\n   ...: ''')))\nModule(\n    body=[ClassDef(name='foo', bases=[], keywords=[], body=[], decorator_list=[], docstring='test')],\n    docstring=None)\nI approved it since we don't currently do class docstrings correctly. I'd say merge this as it is, and I'll address the class changes in #1536. . > The methods of the hytest fixture are functions we use for testing the compiler itself, so why would they be used by other projects?\nYeah, now I think about it, it might not make sense. I was rushing though it. I was thinking it be useful for testing macros and these kinds of things downstream projects might write.\n\nShouldn't the Hy plugin have to be somehow enabled, as by adding it to pytest_plugins?\n\nSee setup.py. So long as you use tox (which installs hy) or you do a development install, the plugin is registered with pytest.. > So, supposing some user is writing a Hy-based package (other than Hy itself) and wants to run some Hy tests with pytest, it suffices just to have Hy installed?\nCorrect. See https://docs.pytest.org/en/latest/writing_plugins.html#setuptools-entry-points for more details\n\n... so perhaps you're running some non-test functions as if they were tests.\n\nProbably running under slightly different collection rules. Thanks, I'll look into that.\n. Okay, so this is now the bare minimum required to make Hy code collect under pytest. Now its just a matter of having Hy installed in your environment to get things working.\nI added support for setting a hy_files ini variable to override the default collection pattern for Hy files, since \"tests_*\" is a sensible default, but we don't follow that structure (nothing wrong with that, just figured out of scope).\nI started playing a little bit with trying to add some deeper pytest integration as I'd like to see a bit more control over how Hy tests themselves are collected, but doesn't look like the pytest Collector is customize enough to support it (yet...)\nA good friend of mine is a pytest maintainer, I'll see if I can get something useful out of him with over a beer.\n. I'm aiming to leave it as is, as its \"good enough\" - as in, works for our use cases and lets me drop comparable code with the one major project I've started using Hy with.\nNow for what I think is possible, having working on pytest itself in the past, is much deeper integration. All this is hypothetical, but should be doable:\nMost practically, fix up the corner cases around test collection. For example, its weird that there's hy_files but not hy_tests ini field. With our own collection logic, we could add it in, and make it work so it considers pre-mangled names - making it less confusing to use.\nWe could also, for example, support something closer to 'clojure.test' package with our own way of specifying fixtures, tests, and have it all integrate nicely with pytest. It lets us also hook into suppressing parts of the stack from the traceback and hook into the assert rewriter.\nI've actually done work like this in the past (pytest-sipp, for example, creates a new kind of test item for pytest to collect), but wasn't satisfied that I wasn't relying on too many pytest internals that weren't part of its public API. So I'd like to see if my buddy has any ideas on the topic.. It does beg the question though, should mangle always be reversible?\nSent from my Android device with K-9 Mail. Please excuse my brevity.. Sorry, to be more clear, with reversible, I really was aiming at stable. Don't know the appropriate math term - its almost idempotence:\nclojure\n=> (= (-> \"foo-bar_baz\" (mangle) (unmangle) (mangle))\n...   (-> \"foo-bar_baz\" (mangle)))\nAs I was reading some of the ideas tossed around as toying with the idea of somewhat marrying gensym and mangle somewhat, but going back over the thread, I don't think anyone really suggested that.. Also thinking aloud, Maybe we could also look at borrowing something from attrs package? https://github.com/python-attrs/attrs\nConsidering its partially made it into Python proper with PEP 557, might not be a bad way to do stuff.\n. I don't think that has anything to do with docstrings though, this fails the same way:\nclojure\n(defclass Foo [] \"doc\" 42)\nAnd then there's some other weirdness in how classes compile:\n```\n$ hy - <<<'(defclass Foo [] \"test\" test)'\nclass Foo:\n    doc = 'test'\n```\nWhere did test go?. This might be the root of the problem:\n=> \"\"\"test\"\"\"\n\"\". Oh that makes sense. I expected it to fail (or work like Python), but I guess there's no requirement for white space between expressions.. @saketh I think I know. The error gives a bit more information:\nTypeError: 'HyInteger' object does not support indexing\n\nAnd its tripping up here:\nif expr[0] == HySymbol(\"setv\"):\n\nIn https://github.com/hylang/hy/blob/b023ebd0b5340a666df83e3fc0b72d7734636e04/hy/compiler.py#L2033-L2048\nWhich is probably called from here lower in the defclass compiler:\nhttps://github.com/hylang/hy/blob/b023ebd0b5340a666df83e3fc0b72d7734636e04/hy/compiler.py#L2085-L2086\nmacroexpand is probably a red herring as it should have no effect in this case:\nclojure\n=> (macroexpand \"test\")\n\"test\"\n=> (macroexpand 42)\n42\nThe problem is likely that we expect expressions inside classes to be all HyExpressions, but don't actually check for it. Note we dig right into expr[0] without first checking of isinstance(expr, HyExpression) and len(expr) >= 1 as you'll see it lots of other places in the code base.. @saketh got a fix, let me put it up:\n```\n=> (defclass Foo [] \"test\" 41)\n  File \"\", line 1, column 25\n(defclass Foo [] \"test\" 41)\n                          ^-^\nHyTypeError: expected an expression.\n```. Closing and making a new PR, as I've modified it further and this one is already improved.. Might not be a bad idea to add appveyor CI. Thanks!. Yeah, lets get this fixed, so I'll get this one out the way.. Aaand I broke something. I'll look into it in the evening.. @Kodiologist working as expected.. Probably does overlap with #1519.\nI found lots of bits that suddenly start working when that's fixed. For example, unquote-splice can be make to work on iterators without needing the list(expr or []) rewrite that's in there.\nI was planning on digging into it once I got a few of my pending stuff merged and some free time, but feel to dig into it, there seems to be a lot of shallow improvements to be made digging into that.\nI really think it would make sense to change HyExpression to be a tuple instead of a list, its just a lot of work.. Something else worth noting about making HyExpression immutable: debugging could be easier.\nI've hit this enough times: while trying to dig into something in the core with pdb, go up the stack trace and try to see what was passed in, only to realize that I can't because we've popped entries off it.. > What we really want is our own builtins module for Hy. But Python doesn't have an easy way to add that.\nIt does... we just have to drop Python 2 :wink: See BuiltinImporter (and get #1518 in...). Digging into this a bit more, looks like the hylang pyments lexer has specific problems with lexing symbols with colons in the middle of them (trailing or embedded). These are both legal identifiers and valid for Python output, so easy patch to the lexer.\nAfter that's done, there's still the issue of unicode literals, which I don't know how to fix.. Also related to this, I think this could improve hy2py as well with macro output. It be nicer to see this:\npython\nHyExpression([HySymbol('setv'), HySymbol('x'), HyInteger(1)])\ninstead of \npython\nHyExpression([] + [HySymbol('setv')] + [HySymbol('x')] + [HyInteger(1)]). It does, I tested it. Also related to #846 but I didn't implement __call__, so didn't know if its worth marking as fixed.. I did start working on #1482, musing outloud, I wonder if a metadata attribute could help here:\nclojure\n(defmacro definit [argslist &rest body]\n  `(defn ^:noreturn __init__ ~argslist ~@body)). Just a note, I was hoping to bring def back as a way to declare a variable with type annotations/metadata.. I don't know if this is a big problem to worry about. 90% of __init__, at least in my cases, is setting attributes on self. setv returns None already. What else do people practically do?\nMaybe the rewrite can be dropped any nobody will even notice :wink: . Guess the doto problem might not be a problem with #1532? Though it probably still makes sense for that to have a result.. So the big use case for this patch is letting map and unquote work well together.\nI started hitting this when looking at some Clojure macro tutorials to brush up. The following snippet doesn't work currently on Python 3 because map is a generator:\n``clojure\n(eval-and-compile\n  (defn criticize-code\n    [criticism code](print ~criticism (quote ~code))))\n(defmacro code-critic\n  [bad good]\n  `(do ~(map (fn [x] (criticize-code #* x))\n        [[\"Cursed bacteria of Liberia, this is bad code:\" bad]\n         [\"Sweet sacred boa of Western and Eastern Samoa, this is good code:\" good]])))\n(code-critic (1 + 1) (+ 1 1))\n```\nBut it feels natural to write. I understand tossing an explicit list in there will make it work, but it also makes it noisier.\nI think we should embrace the strengths of Python and try to leverage generators like this.\n. And I've been trying to think what would be the best wording for the NEWS entry because of the generator handling:\nclojure\n=> (eval-and-compile\n... (defn numbers [] (yield-from [1 2 3])))\n=> (quote (sum (unquote (numbers))))\n'(sum ~(numbers))\n=> (quasiquote (sum (unquote (numbers))))\n'(sum <generator object numbers at 0x7ff6050f5bf8>)\n=> (eval *1)\n6\nOr if that generator object needs to be expanded directly, but not sure how to do it.. Yeah, something interesting is happening here for sure: it works, but:\nclojure\n=> (setv sym `(sum ~(genexpr x [x (range 10)] (odd? x))))\n=> sym\n'(sum <generator object <genexpr> at 0x7fa63dc589e8>)\n=> (eval sym)\n25\n=> sym\n'(sum [1 3 5 7 9]). Okay, so addressing the generator rewriting, I have a fix for it, but its not trivial and I can only make it work by completely breaking line numbering...\nThe problem is that we should probably be calling wrap_obj in HyList constructor. I think we probably want to do that anyways as other Hy objects (like HyCons) do wraps on construction.\nBut that opens a whole different can of worms.\nIt seems we throw away line numbering information on a lot of intermediate forms inside the compiler (for example, slicing a HyExpression results in a new HyExpression without line numbers) which is fixed up later. Wrapping forms in HyList.__init__ starts exposing lots of missing line number bugs for reasons I haven't determined yet.\nSo probably there are some subtle bugs here related to #1542.\nDon't know how to proceed. I'd be comfortable merging it with the mutation and then trying to fix these issues as I really would like to see the functionality work.\nAny ideas?\n. I actually really like that idea, should we do both? Or are you suggesting this as an alternative?\nI mean, ~#,(map ...) seems a little noisy to me, and I think its inconsistent that ~@(map ...) works just.\nI do think we should embrace generators in the core like this considering all the extensive places that Python 3 uses them and everywhere they're accepted.. Never mind, right, I forgot its unicode only though because its a backport.. Python does it with tuple unpacking, so you need to do the same thing:\nclojure\n=> (setv a 1 b 2)\n=> (setv [a b] [b a])\n=> a\n2\n=> b\n1. Shame, because I was going to suggest doing it too.\n\nI don't mind changing eval back to Python's, so we don't have to use builtins.eval. But I'd prefer we keep the old name.\n\nI need to jig it around a bit more, and maybe as my time frees up this week I'll pull it out and do it a separate PR, but the importer rework has this change included. But its not just hy.eval - it tries to expose Hy equivalents to Python's parse, compile and exec as well.. Just a quick reminder we don't actually support 3.3. Its 3.4 and newer.\nExpanding support to 3.3 has implications that complicates the importer work I'm doing.\nSent from my Android device with K-9 Mail. Please excuse my brevity.. Yeah, good point.\nWould it maybe make more sense to mangle to the utf8 representation?\nOn March 27, 2018 8:36:58 PM EDT, Kodi Arfer notifications@github.com wrote:\n\nOkay, this should also affect Python 2, then.\n-- \nYou are receiving this because you commented.\nReply to this email directly or view it on GitHub:\nhttps://github.com/hylang/hy/pull/1552#issuecomment-376720597\n\n-- \nSent from my Android device with K-9 Mail. Please excuse my brevity.. @tuturto heads up in case you didn't know, \"{!r}\".format(foo) does repr (and !s forces str, which is the default).. I also agree its overkill - but honestly, might as well.... Oh, and for what its worth, any opinions on including Pipfile and Pipfile.lock files?  Its personally won me over and I use it in all my new projects.. Pipfile is a toml based replacement for requirements.txt that does a nicer job of describing the environment\nThe lock file pins the very specific package versions for reproducible builds\nhttps://github.com/pypa/pipfile/blob/master/README.rst\nSent from my Android device with K-9 Mail. Please excuse my brevity.. @Kodiologist technically true, but its as a point where its very stable. I doubt they'll remove that warning until Pipfile support ends up in pip itself.\npipenv has become the officially recommended Python packaging tool now, and it creates and manages a Pipfile for you, by reading requirements.txt and other sources. So we don't need to check it in technically, but it does give us some nicer control.\nIf you're not familiar with the tool, I'd really suggest having a look whenever you got the moment.. Yeah, I just mainly want this in for my sanity :grin: . So the 3.8 build failed with a 404, but the travis docs promise its available. Ah, it was pulled because of OpenSSL issues: https://github.com/travis-ci/travis-ci/issues/9069\nAnd looks like it has possible implications for 3.7 as well.. Yeah, let's move it to an issue.\nSent from my Android device with K-9 Mail. Please excuse my brevity.. > A nicer repl, like IPython, stores all of them and updates the prompt to show the current entry number. @ekaschalk has discussed some about how we would integrate that into emacs. I've also mentioned that IPython is quite extensible, and could be adapted to Hy.\nAnother option, and one I've been meaning to try as a weekend project: build something on top of the python prompt toolkit. Looks good, just needs some work. And yeah, getting *e in there would be awesome!. Well, with #1570 merged, lets merge this.. Nice, been meaning to deal with that.\nSent from my Android device with K-9 Mail. Please excuse my brevity.. How about target rpython and build our own JITed runtime? (e.g. like pixie). Aaah, didn't realize its a different project. Sorry.. @ekaschalk I'd be in favour of it, and we always leverage optional dependencies for it. The Python repl doesn't  have any autocomplete and we can always keep a minimal install by default. Do something like pip install hy[autocomplete] or something.. This should be stable: https://ci.appveyor.com/project/vodik/hy/build/1.0.8\nOnce merged I can turn it on for hylang/hy. @waigx yeah, just waiting until its green and merged.. I set it to skip branches without appveyor.yml present, so its on but shouldn't spam every PR anymore until this gets merged. Sorry!. @Kodiologist style mostly. IMHO format strings should be treated as constants as much as possible - though I guess it would be safe in this case.. @Kodiologist Is the strftime macro acceptable? Similar idea but we shunt it to compile time.. ~~Yeah, I think I'm going to have to do that... %- is strictly a glibc extension and I don't think OSX supports it either~~\nNo, man pages claim its supported (FreeBSD too) - guess I'll see if I can try it.. On this note, and something I think I'll distract myself with - we should probably leverage astor and ast.parse to write more tests that assert we generate the same ast as a known, target python expression:\n``clj\n=> (import ast astor)\n=> (defn py/disassemble [expr]\n... (-> expr (ast.parse) (astor.dump-tree)))\n=> (= (disassemble '(+ 1 1))\n...   (py/disassemble \"1 + 1\"))\nTrue\n. I'd be okay with it, honestly I've never found a use for it.. To further expand on this, and I've been meaning to comment on/come back to #1545, but I  the~@...` maps conceptually better to Python's generalized tuple unpacking support:\nclj\n[#*(range 10) #*(range 10)]\nAnd while I find this super useful, I think because of that, I tend to build my stuff around that style.. Maybe it makes sense to change ~@ to ~*?\nMaybe it even makes sense to have a ~**? unquote keywords? Does that even make sense?\nI need to think about this. I got some thoughts on #1545 as a rebuttle to @gilch that I just haven't had a moment to get composed.. Could we also treat (print #* [1 2]) as an optimization problem?. Well, technically, something like (print #* [a b c]) should always be compilable as (print a b c). It gets more complicated when we're looking at something like (print #* foo), but we can shunt that to runtime.. I swear you said that on another PR... Oh well, no strong feelings either way, figured it doesn't hurt. Feel free to close it if you want then.. @Kodiologist probably because its ambiguous: (quote @) a.k.a. matmul. Lets see what can be done though.\nEDIT: yup:\nclj\n=> `( ~@)\nHyExpression([\n  <function @ at 0x7fd59cfe9a60>]). @Kodiologist hmmm, wonder if it makes sense to list the expression we failed to unquote though.. Yeah, its a good point. Its just harder to interpret with ~@. But yeah, I rest my case.. Clojure allows providing an optional default argument. Should we support that? Its a small patch:\n```diff\n--- a/hy/models.py\n+++ b/hy/models.py\n@@ -121,6 +121,7 @@ _wrappers[bool] = lambda x: HySymbol(\"True\") if x else HySymbol(\"False\")\n _wrappers[type(None)] = lambda foo: HySymbol(\"None\")\n+_sentinal = object()\n class HyKeyword(HyObject):\n     \"\"\"Generic Hy Keyword object.\"\"\"\n@@ -151,8 +152,10 @@ class HyKeyword(HyObject):\n     def bool(self):\n         return bool(self.name)\n\ndef call(self, data):\nreturn data[self]\ndef call(self, data, default=_sentinal):\nif default == _sentinal:\nreturn data[self]\nreturn data.get(self, default)\n``. Oh man, this looks awesome. I'll make some time to review this tomorrow.. I'll open an issue with the other import syntax change suggestion then (and maybe try to implement it to see if I really understand how this works now). @kirbyfan64 not respectingsys.dont_write_bytecode` is fixed in #1518 . I just did the basic implementation for now.\n\n\nBut this potentially breaks the \"preferably only one obvious way to do it\" rule, since you can now use either a . or a new expression\n\nIt might not be worth it as Python doesn't typically tend to have deeply nested namespaces - its instead tends to being broad.\n\nRemoving the . separator is an option. We could even nest in more () to replace the . prefix for relative imports. But for common, simple cases, it gets ugly.\n\nNot a bad idea, but I think I see two problems:\nMultiple dots are valid as a indicator to go up. Now I guess you can just toss in more parenthesis, but the question is how clearly indent level is that conveyed:\n(import [...foo.bar [baz]])\n(import (...foo.bar baz))\n(import ((((foo (bar (baz)))))))  ; Much harder to understand at a glance\nThe other problem is I have no idea how you'd express this:\n(import [... [foo]])  ; translates to `from ... import foo`\n(import (... foo))\n. > I think we should stick with square brackets. \nNo strong opinion either way. I'll wait till we have consensus before spending the effort fixing that up.\n\nAlso, are you sure that (import foo :as bar) is better than (import [foo :as bar])? With (import foo :as bar), related elements among the arguments of import are no longer grouped.\n\nI was a little skeptical of the change at first, but I do think its an improvement. Your concern is fair, but it just took a little bit of use to learn how to read it quickly, and most of the issues here can be addressed with style guidelines.\nHere's where I see there's an issue with writing (import [foo :as bar]) is that we introduce two different internal inconsistencies with the syntax:\n\nWe write (import [foo :as bar])\nAnd we write (import [foo bar :as baz])\nWe don't write (import [foo [bar :as baz]])\n\nWe either should put them in on both cases or in neither case (leaning towards neither).\nThe other important thing to note is that if we force someone to write (import [foo :as bar]), they might not understand what's going on behind the scene and assume that something like (import [foo :as bar baz]) will work to effectively be import foo as bar; from foo import baz, but that won't work. By removing those inter braces, its no longer possible to make that mistake.\nAs for reading it:\nI think its a matter of style. Doing this kind of convention is actually pretty clear imho.\nclj\n(import (os.path exists\n                 isdir :as dir?\n                 isfile :as file?)\n        sys :as systest\n        re)\n. :+1: on looking nice.. Done.\nMy only concern with the new syntax, after playing with it, is that maybe this is a little visually ambiguous if the import causes a particular name to be imported or not:\nclj\n(import sys           ; imports sys\n        sys [stdin])  ; imports stdin, not sys - the second expression changes the meaning of the first one\nAnd while I can live with it (so I don't protest too hard but I am officially voting for my original syntax), my previous iteration I think was immune to this problem. And I think its mostly a style issue anyways, as its only really weird when presented like this: (import sys sys [stdin]) - the double sys might throw newbies off in this form - when done as one line, I think (import sys (sys stdin)) is clearer.\n. @gilch like it. Okay, I'll do another pass where we make all the imports have a consistent style then, if we agree on this.. So something that's always been bothering me about this stuff is the following snippet doesn't work as expected:\nclj\n(eval '(do\n   (import pdb)\n   (pdb.set-trace)))\nI mean, it works, but there's no reason is has to be detached from where in the file it was defined. We throw out that information and spoof it to make it function (always says line 1, column 1):\n```\n\n(1)()->None\n(pdb)\n```\n\nI'm bringing this up as I think we're getting to a position where the line numbers can properly propagate, so I want to see what other people thing. Getting that working, though, would only be a partial fix - we'd need to be okay with hauling around filename as well (maybe even the module spec, somehow).\n. Well, its nothing strictly about the debugger. The problem is the stack trace is useless. But I don't think it has to be the case.. Hmmm, what if we did a hy-language-server?. The language server protocol is a spec that came from Microsoft and was I think first implemented in vscode, but it has caught on in the general editor community, with there being good vim, neovim, and emacs support. Emacs, in fact, will likely ship with support out of the box soon (rms himself advocating for it).\nThe idea is you spin up a companion process that receives information about changes in the file. It, then, takes on ide functionality on your behalf across a standard protocol, covering style checking, code completion, code navigation (e.g. jump to definition), and auto formatting.\nThis, in turn, reduces the need to maintain otherwise duplicates functionality in hy-mode/vim-hy, and would help us give a good out of the box support to other editors with language server support.\nI've personally switched from using anaconda-mode to lsp-mode with the python-language-server and I think its a major improvement.\nSent from my Android device with K-9 Mail. Please excuse my brevity.. Yeah, I'd volunteer working on it once I get my backlog dealt with.. Vote for case sensitivity.\nWe already deviate enough from Python here that it doesn't make sense to match Python just because. Triple quotes don't work, multi line strings are done differently (#[FOO[ ... ]FOO]), format strings - if we get them - will likely by Hy expressions, not Python expressions, etc.\nAnd I can't see what this fixes.\nEDIT and for what its worth, I've never seen this \"misfeature\" in the wild either.. What does async printing mean here? asyncio? threads?. I have no problem merging this, but just a heads up, Python 3.4 is the minimum version.. Hey, really happy to see this work continued!\nSorry I haven't had the time or energy to keep up my open source work. I'll try and give you a good code review tomorrow.\nOn August 20, 2018 12:59:47 AM EDT, \"Brandon T. Willard\" notifications@github.com wrote:\n\nClosed #1671.\n-- \nYou are receiving this because you were mentioned.\nReply to this email directly or view it on GitHub:\nhttps://github.com/hylang/hy/pull/1671#event-1796760320\n\n-- \nSent from my Android device with K-9 Mail. Please excuse my brevity.. How do I do that? I based this block on yield/yield-from, so wouldn't they share that problem then?. Maybe I should adjust this so that yield is its own block with await and yield from sharing their implementation instead?. Won't this possibly cause some NameErrors? I see you do this in examples:\nclojure\n(lfor x \"abc\" :do (setv y 1) x))\nIs y expected to be accessible to the outer scope? In Python it would be, but because of the function call added here, it won't be. . Right, I see you point. The \"for\" naming and emitted ast threw me off. Thanks.\n  . Good call. Unfortunately, it doesn't work. When you try to use Ellipsis inside a slice in python 2 that's been generated this way, python throws ValueError: invalid integer value: None when trying to load the ast.\nThe reason, I think, is because that patch generates code to load Ellipsis: \nslice=Index(value=Tuple(elts=[Num(n=1L), Name(id='Ellipsis', ctx=Load()), Num(n=6L)], ctx=Load()))\nHowever, Ellipsis is a thing an Python 2's ast. This is what I get from ast.parse -> ast.dump on Python 2:\nslice=ExtSlice(dims=[Index(value=Num(n=1)), Ellipsis(), Index(value=Num(n=6))]). Now, the reason I gated this to Python2 is that there's some deeper issue with constructing Ellipsis on Python2:\n\u2937 TypeError: Can't add <hy.compiler.Result object at 0x7fc4c1834e30> with non-compiler result <_ast.Ellipsis object at 0x7fc4c17caa50>\nI'll dig into what's going on.. Yeah, so the problem is in python 2, ast.Ellipsis is a subclass of ast.slice, not ast.expr, and Result.__add__ then doesn't know what do with it.\nBut the problem with that is it means its only valid as a dim inside ExtSlice, which we don't generate.\nI think this is only going to work on Python 3. Which personally I'm fine with. If it where up to me, I'd be seriously looking at dropping Python 2 support \ud83d\ude09 . @Kodiologist yeah, I think so. With @rkday proposed patch, the following snippet only partially works:\n```clojure\n(defn test-slice []\n  (defclass EllipsisTest []\n    (defn --getitem-- [self [start ellipsis end]]\n      (assert (= ellipsis Ellipsis))\n      (list (range start end))))\n(assert (= (get (EllipsisTest) (, 1 ... 6))\n             [1 2 3 4 5])))\n```\nWhen manually copy and pasted into hy's REPL, it works as expected. When imported, Python decides it doesn't like the generated AST.\nWhich really gaslighted me while trying to dig into it, heh.\n\nMe too, but it isn't.\n\nMaybe I should pipe up on there, but I think its worth reconsidering now. Do one more release for both Python 2 and Python 3, then drop Python 2 for the next one.\nPython 3 only has got some serious momentum now (http://www.python3statement.org/) and maybe it makes sense to follow the scientific computing's timeline. I mean, IPython is Python 3 only now, and IPython Notebook is going to be as well by June this year.\nBut alas, that's neither here nor there.. Well __builtins__.slice doesn't work because __builtins__ is a dictionary, not an object. So we'd have to either change that too or write (get __builtins__ \"slice\"). And I'm not particularly eager to use that large expression down every time I want a slice to be slightly faster (and to be honest, same for __builtins__.slice).\nIf we don't feel comfortable with rewriting slice, I can just drop that entire part of the PR.. Not sure, but I suspect its fine. I figured it made the most send to match exactly what Python does.. hy complains though:\n=> (cut [1 2 3] 1 2 3)\nTraceback (most recent call last):\n  File \"/home/simon/src/hy/hy/importer.py\", line 201, in hy_eval\n    return eval(ast_compile(expr, \"<eval>\", \"eval\"), namespace)\n  File \"<eval>\", line 1, in <module>\nAttributeError: 'dict' object has no attribute 'slice'\n=> (type __builtins__)\n<class 'dict'>. I'm honestly quite comfortable letting slice mean slice here and just documenting the behaviour. We already prevent slice from being assigned to. Overriding __builtins__.slice in Python also won't change the behaviour of the : operator.\nI could also add a check to make sure no slice macro has been defined and/or add slice* to force the construction of a slice object and that probable covers 99% of weird use cases.. I do like this better. My concern was that : is HyKeyword(\":\"), but there's less room for things to blow up.\n\nAre you sure?\n\nYes your right.\nI think I was playing @builds(\"slice\") at the time I tested it and forgot that I had put that in there.. Oh, to expand on this, its probably worth at least merging the identical behaviour. If a simplification works, that's awesome, but that can be added next and at least there's always something more technically correct to revert to.. Has to be evaluated as the outputted AST is fine. Python rejects it only on import. And it does fail on master, did check that.. Would it maybe make sense to have a crack at #1363 and fix that first?. Done. Yeah... ssh key wasn't loaded and didn't notice.. I can wait, honestly. I'd rather see it some in on a more solid foundation.. Yeah, I thought it was weird when I looked at it, replace should be enough and ideal. But I copy and pasted the approach and elsewhere both are used:\nhttps://github.com/hylang/hy/blob/10cd36d13d71010c38e8b411ebf13390f80b9542/hy/compiler.py#L414-L424. No good reason. Honestly, I'm not married to this particular test case at all, in case you can think of a better example as well. The other two came from their respective PEP's, this one I derived.. Yeah, agreed. Just pointing it out so we know. I'm certainly going to investigate it.. I'd be fine with this if everyone else is.. Dropped this test since I pulled Python 2 support.. Fixed. And gone. Right, Python 2 doesn't support this. Something worth noting: python foo.py won't emit bytecode for foo.py. We now match that behaviour.. You should prefer io.StringIO/io.BytesIO over the StringIO package. Why not check for __hy_repr__ as well? I don't think defining that as a protocol was a bad idea, tbh.. What if you just threw an exception registration in there's a __hy_repr__?\nNot a strong opinion either way, but __hy_repr__ feels like it fits into the Python way a bit better, and its easier for first class support, leaving registration for everything else.. Good points. I'm comfortable with registration, so don't let me stop this.... Noted, I'll revert that and add documentation for it.. @Kodiologist what would you think about starting to use the pytester plugin for this kind of stuff? Comes stock with pytest for this kind of stuff, just needs to be turned on:\n```python\ndef test_import_failure_retryable(testdir):\n    testdir.makefile(\"hy\", again=\"\"\"(import sys)\"\"\")\n    testdir.syspathinsert()  # magically cleans up post test too\nimport again\n\n```\nKeeps current working directory clean and makes sure everything is fresh each pytest run. I suspect stale .pyc files could cause a false pass here.. Probably better to do:\n```python\nwith pytest.raises(HyTypeError):\n    import again\n...\nimport again\n``. Okay, in which casepytest_plugins = \"pytester\"needs to go in ourconftest.py` and its loaded.\n. Just doing docstring=str_type(docstring) should work. The ast module's API is basically all self, /, *args, **kwargs, and drops unknown kwargs. Might make this stuff a little simpler to maintain.\nEDIT: needs to be docstring=str_type(docstring) if docstring else None. Actually, I tested it on your branch. All tests passed on py27 and py36. py37 fails for a few tests (running a patched astor, its not that) - but the macro tests start passing. Haven't dug into it yet.\nIt also seems like Python 3 always sets docstring to None as a default, so its probably best to match that behaviour.\n```python\n\n\n\nprint(astor.dump_tree(ast.parse('''\n... def test():\n...     pass\n... ''')))\nModule(\n    body=[\n        FunctionDef(name='test',\n            args=arguments(args=[], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]),\n            body=[Pass],\n            decorator_list=[],\n            returns=None,\n            docstring=None)],\n    docstring=None)\n``\n. Just to be clear, I mean testing it with a modification on top of your patch to always setdocstring, not sure if that was clear.. I havetest_bin_hy_byte_compile` failing, with or without my changes, on py37 only. Everything else is working. Weird...\n\n\n\nOkay, so something that needs to get investigated but doesn't need to block this PR.\nI can't reproduce the failures from Travis either.. Aaaah, I fixed the bytecode serializer for PEP 552, but I forgot to fix the loader.\nI patched it: https://github.com/vodik/hy/commit/34929ec7ba3252fdc13fa5c59b7dbd01fd0af1de.patch\nFeel free to borrow it if you want, or, write it as you see fix.. Nice. If you notice from the above snippet ^ python also sets docstring=None on the Module, so you can get rid of that spat trick everywhere.. No, that's a very good point. But that, I think, makes this PR simpler.. Is this idiomatic style with the join on the same line as defn?. Put an isinstance check. Don't have the time at the moment to dig into Hy stuff (very soon though), but might as well try and get these bug fixes in as things work currently.\n. @Kodiologist what's the rational for late mangling?\nJust asking because its easier to make #1504 nice if I mangle symbols before comparing:\nclosure\n(defmacro foo [symbol]\n  (if (= symbol 'foobar?)\n      ...\n      ...))\nMeans this macro work on either 'foobar? and is_foobar. Not sure if there's something I'm missing, so asking.\n. Thanks.. That's actually got different semantics, as I understand it.\nBecause, abstractly, when running a == b, python tried first a.__eq__(b), and if NotImplemented is returned, it'll try b.__eq__(a).  Returning False here means we'll break code that might want to test equality with a HyKeyword (I don't know why you would, but I don't think that justifies breaking that intentionally).. Good catch. So long as c is unicode, ord should work:\npython\nor 'U{:x}'.format(ord(c)). Mutating a list while iterating over it fields always irks me a bit. Using a generator here with an accumulator might be cleaner, but I suspect this would be faster. Hmmm.. This works on PY35 as well, for what its worth. spec_from_file_location came with 3.4 and module_from_spec with 3.5. Oh of course it be the same problem.. You know what? I don't think its worth putting a lot of effort in. Whatever is cleanest.\nWe don't support 3.3, and if its just for Python 2 support - well, that's also rapidly approaching EOL. And I just noticed the old code did ord. Okay. So I just have one more suggestion to make and I'm happy with this:\nI have a feeling someone is going to come along, look at this, and say someone \"Wait... isn't this ord?\" and break this all over again. Not to mention we have to remember to pull it out once we finally drop Python 2 support.\nSo may I suggest adding a multibyte_ord helper?\npython\ndef multibyte_ord(ustr):\n    if UCS4:\n        return hex(ord(ustr))\n    return ustr.encode('unicode-escape').decode('utf-8').lstrip('\\\\U').lstrip('\\\\u').lstrip('0')\nMakes it clearer that this klugde is in there intentionally?. python\nfor key in list(os.environ.keys()):\n    # ...\nYou only need to copy the key view, not the whole mapping.. Yeah, probably won't work until #1518 is in. I tested it there. We don't implement the importlib APIs correctly.. Yeah, I left that in because of this assert:\nclj\n(assert (= (hy-repr (str ':mykeyword)) \":mykeyword\"))\nBut I guess that doesn't make sense, we're breaking that. Removing the tests instead.. I did this as its the easier repr function. I think your right that it makes sense, so I'll work on it, but what would we prefer to see: HyKeyword(':foo') or HyKeyword('foo')?\nCurrently they're actually equivalent, but maybe I should put some extra effort into making sure there's only one way.. Done. :+1: was thinking the same but I think thats a deeper change it seems. Might as well fix it though.. Stick to Python 3 isms (in this case, prefer range over xrange) and leave Python 2 a second class citizen.\nIts harsh, and I wish we could drop Python 2 support, but I also don't think any of the maintainers are running Hy on Python 2 either.. Fair enough. This is technically a PEP8 style violation. Should be i=1.. Why not, instead of going through a range of numbers and redoing the mangling every time, do it once ahead of time?\npython\nself._repl_results_vars = [mangle(\"*{}\".format(i) for i in range(3))]\nThen its just a mater of going through the list:\npython\nvalue = ...\nfor var in self._repl_results_vars:\n    self.locals[var], value = value, self.locals[var]\n. @waigx you sure?\n```\n$ ipython\nPython 3.6.4 (default, Jan  5 2018, 02:35:40) \nType 'copyright', 'credits' or 'license' for more information\nIPython 6.2.1 -- An enhanced Interactive Python. Type '?' for help.\nIn [1]: _\nOut[1]: ''\nIn [2]: None\nIn [3]: _\nOut[3]: ''\n``.Noneor''` works for me. And sorry, I thought you where talking about IPython, not the Python REPL. . Be careful of how positional arguments work here. The default value is created once and shared between all function calls:\n```python\n\n\n\nTEST = \"Hello!\"\ndef foobar():\n...     global TEST\n...   \n...     def inner(test=TEST):\n...         print(test)\n...       \n...     inner()\n...     TEST = \"ANOTHER MESSAGE\"\n...     inner()\n... \nfoobar()\nHello!\nHello!\n```\n\n\n\nTechnically this should be fine because we only read from it, but its something linters will complain about.\nI think it be best to just make it an explicit argument always, since you rely on the implicit default twice and explicitly set it twice.. Its a matter of style, but I prefer using brackets over \\:\n```python\noutput, _ = run_cmd(\"hy\", (\n    '(+ \"a\" \"b\")'\n    '(+ \"c\" \"d\")'\n    '(+ \"e\" \"f\")'\n    '(.format \"1: {}, 2: {}, 3: {},\" 1 2 3)'\n))\nTechnically Hy doesn't care about the newlines either, so no need to have the visual noise.\n. Yeah, so I don't mind putting an error back in (probably should raise a ValueError though) and handling the edge case inside the completer.\nI did this because the completer was crashing if we did this:\nfoo.<tab>\nAs the mangled attr would be \"\". Yeah, good catch. I ported over the old code without thinking hard enough.. Do this across two lines cough cough PEP8 :wink: \nThat said, I'd suggest renaming e to execinfo. Its consistent with other unit tests, and I think also better names what's provided as it isn't the exception itself.. Forget to update e.value? :wink: . On the topic of immutablity, it seems like we count on replace_hy_obj for its side-effects, but it also returns the replaced obj.\nMight be easier for future work if we start using its return value: return replace_hy_obj(obj, tree). Slightly annoying that HyObject.replace collides with str.replace.. Nice. If we're going to do this, maybe it makes sense to go ahead and remove the second level nesting of arrays: (import [foo bar baz]) now means from foo import bar, baz, instead of the existing (import [foo [bar baz]]). Just an observation, but maybe it makes sense to add another test for NotImplemented. Its another special value that, while it works fine in Hy, we never test.. Would it make sense to add return, yield, yield-from and await here?\nTop level, these forms are currently accepted by the hy compiler, but generate invalid AST and thus causes Python's compile to crash with \"SyntaxError: '...' outside function\", which is completely detached from the source code.\nMaybe it makes for a better user experience to catch it early.. This is cool. Nice work.. ",
    "thomasballinger": "I'll take a look tomorrow, I hadn't look through the tests yet. Probably should integrate with the main cli while we're at it.\n. @Foxboron points out this wouldn't be that complicated a change if it's desirable: https://github.com/hylang/hy/blob/master/hy/compiler.py#L1030\n. ",
    "joehakimrahme": "I should also mention that I'm using the version 0.9.8:\n$ hy --version\nhy 0.9.8\n. Note that there's already a separate one for emacs.\n. Hey, I haven't followed the discussion. What's the idea behind this lib?\n. Same issue with Python 2.6.6 on Debian Squeeze.\nWe should really look into a Peer Review system and some sort of Continuous Integration to avoid these annoying problems.\n. ### Fixing the bug\nFollowing the documentation link given by @Foxboron, I replaced:\npython\n__builtins__.quit = HyQuitter('quit')\n__builtins__.exit = HyQuitter('exit')\nwith this:\n``` python\ndef quit():\n    return HyQuitter('quit')\ndef exit():\n    return HyExitter('exit')\n```\nIt fixes the problem. I'm not sure that having it at the top of hy/cmdline.py makes sense though.\nI also wonder if someone else faces this bug? Or is it just something wrong on my build?\nAre you guys doing anything more than python setup.py install when installing?\nWriting tests\nI'll admit I have no idea how to test a code that quits the current program! o.O\nPeer reviews and CI\nI hate to be that guy, but I feel like we're rushing into pushing the randomest code into the repo right now. Can we take a moment to set up some sort of quality control before going frenzy on merging pull requests? \nThere's a possibility that this is not a bug, and I'm doing something wrong. But there's also the possibility that there's a regression on certain platforms here. \nAgain, I don't want to be a party pooper, but please let's be more cautious before merging. Have you guys heard of Gerrit? We use it when working with OpenStack and it's a real life changer. I cannot stress enough on how great work becomes when you trust that a patch has been reviewed and tested by more than one person.\nWhat do you think about adding this on top of our CI?\n. I tested the pull request. Adding the import __builtin__ does not solve the issue :( \n. @Foxboron: I tested that branch and it does work. Sorry for the false alarm.\nIt fixes the bug as far as I'm concerned.\n. This pull request solves the bug.\n. Hey, I'm not familiar with the past conversations you guys had about cons, but one thing is unclear to me.\nMy understanding of cons (coming from this book if it's any reference) is that it's a simple pair of values. Therefore I have a question about this:\n``` python\n    def getitem(self, n):\n        if n == 0:\n            return self.car\n        if n == slice(1, None):\n            return self.cdr\n    raise IndexError(\n        \"Can only get the car ([0]) or the cdr ([1:]) of a HyCons\")\n\n```\nWhy is cdr [1:]? Why isn't it only [1]? A cons cannot, by definition, hold more than 2 elements anyway. Am I missing something?\nBug at hand\nI'm referring to @paultag's comment above\nTo me, this expression: (cons (cons 1 2) (cons 2 3)) evaluates to a single cons where each element is a cons in turn. This should evaluate to:\n```\n            +----------+-----------+\n            |          |           |\n        +--------+     |     +-----------------+\n        |   |          |           |           |\n        |   +----------+-----------+           |\n        |                                      |\n        |                                      |\n        |                                      |\n        |                                      |\n\n+----------+-----------+               +----------+-----------+\n |          |           |               |          |           |\n |    1     |    2      |               |    2     |      3    |\n |          |           |               |          |           |\n +----------+-----------+               +----------+-----------+\n```\nWhich I would represent as:\n((1 . 2) . (2 . 3))\nTherefore for this: (for [x (cons (cons 1 2) (cons 2 3))] (print x)), I would expect:\n(1 . 2)\n(2 . 3)\nAnd for this: (list (cons (cons 1 2) (cons 2 3))), and considering that list refers to the Python builtin lists, I would expect a list of a single element, like this:\n```\n=> (list (cons (cons 1 2) (cons 2 3)))\n[((1 . 2) . (2 . 3))]\n=> (len ((list (cons (cons 1 2) (cons 2 3))))\n1\n```\nIsn't this how we should implement cons? If that's not the case, can you explain to me what you're going for so I can write some documentation for it?\n. How does try-hy deal with this issue?\n. Thanks a lot for the work done. It looks great! I noted a few remarks on the file that need to be addressed before merging.\n. Thanks. I hadn't noticed for the alphabetical order. It agree with you that it's best kept that way.\n. Would it be possible to rebase all the commits into one before merging?\n. Awesome. Thanks!\n. I don't know how to use hy2py (can you point me to a doc or even show me how to install/run it?) but I'm pretty sure you'll get a separate behavior in Python3 where print is a function.\nWe could circumvent the issue by importing the function from __future__ (cc @olasd) but it won't solve the issue for yield and/or other statements.\nShould we care that we have the same behavior for all versions of Python?\n. Thanks. It's worth mentioning that hy2py won't work with Py3 because astor isn't Py3-ready :-(\nSo what's your take on the discrepancies between Py2/Py3? Does it justify confirming this bug?\n. > I'd say that writing `and' as a macro might be a way to fix it.\nIs it just a problem with and (and or)? Aren't there other ways of deferring evaluation where statements might get \"accidentally\" executed?\nWhat's the issue with transforming statements into a function?\n. Awesome! I'll take a look as soon as I get some time. Hopefully today.\nThanks!\n. @tuturto Thank you very much for this. I have one suggestion for the explanation of decorators and one remark about else in foreach blocks (see comments inline). Another thing is, why do you add this many blank lines? Any particular reason? I don't like it because it pollutes the diffs and make them harder to read.\nThe other remarks were more directed @paultag and other core devs, and were not necessarily pertaining to your patch.\n. I added for/foreach, but I'm not sure. Is there anything that for can do that foreach cannot?\n. I added 3 new pairs. I prefer raise and except, because of Python.\n. Are you sure you want to implement a Hy feature that would only be available for Py3?\n. :-1:  -1 for me.\nI think this behaviour is not very consistent with Python. It could hurt the Hy <-> Python bi-directional compatibility, not to mention it would trip up newcomers to the language, simply to remove a few characters (if (= __main__ \"__name__\") which are now idiomatic Python.\n. Not really voting, I just want to say I like the HorizontalRule trick :)\nAlso, and maybe that's just a wild idea, would it be better if hydoc could detect Python code and launch pycode instead? I think it'd make a lot more sense.\n. FWIW, you can still nest contexts this way:\nclj\n=> (with [f (file \"/tmp/foo\")]\n... (with [g (file \"/tmp/bar\")]\n... (print \"hello world\")))\nhello world\nBut I agree with the syntax you're suggesting.\n:+1: on the suggestion from me. \n. I would mention that the function raises a TypeError if the argument is non numeric in the documentation (I love it when the doc tells me which exceptions to expect).\nOther than that, :+1: for me.\n. All 3 links work for me:\n- http://hy.rtfd.org/en/latest/quickstart.html\n- http://hy.readthedocs.org/en/latest/quickstart.html\n-  http://hy.rtfd.org/quickstart\n:+1: for the 3rd one, for pure aesthetic reasons.\n. :+1: for me.\nGood catch!\n. @Foxboron: It was issue #253. I guess either this one or the other should be marked as duplicate and closed.\n. :+1: LGTM but someone else must approve.\nI tested locally by evaluating this expr:\n(cond () ())\n. This is the beginning of a style guide here: http://notes.pault.ag/hy-survival-guide/\n. :+1: LGTM\n. :-1: Adding this to the doc is going to be a nightmare to maintain.\nI agree we need a list of core members written down somewhere, but not in the source.\n. @agentultra +1. I agree with the idea. If someone implements it, I could also review it.\n. Not necessarily against it, but can you please explain what motivated the change?\n. I confirm I still get the same bug with the latest version.\n. That's not the behavior I get on my system:\nclj\n=> (and True (print \"hello\"))\nhello\n=> (and False (print \"hello\"))\nhello\nFalse\n=> (and True (do (print \"hello\") True))\nhello\nTrue\n=> (and False (do (print \"hello\") True))\nhello\nFalse\nI think that all params are evaluated. \n. It may return None:\nclj\n=> (and True None)\n=> (is None (and True None))\nTrue\n. small typo: a conditional. Coming from Scheme I would prefer the use a predicate.\n. (dict {}) is redundant. I would suggest replacing this line with:\nclj\n(let [[collection {}]]\n. Why is and in the beginning of the file, while or and not are here? Shouldn't we group them?\n. I wonder if it's not confusing to mention the expression -> statement conversion in a paragraph explaining and. But I don't think it's that big of a deal, and the example given makes a good case of explaining the issue.\n. Is there any reason to keep both setf and setv? Isn't this redundant?\n. I don't understand what the else block/expression does\n. Again, any reason to have 2 keywords doing the exact same thing?\n. One thing I like to mention, in Python at least, is that a decorator is syntactic sugar for an assignment statement. (I'm a bit more reticent to use the term \"syntactic sugar\" in the case of Hy).\nYou could mention something like: \n\nThe two following expressions are equivalent:\nclj\n(with-decorator inc-decorator\n  (defn foo )\nand\nclj\n(defn foo )\n(defn foo (inc-decorator foo))\n\nI think this can be improved further to be made clearer, but I like to show that it's just an assignment.\nWhat do you think?\n. There you go: https://github.com/hylang/hy/issues/240\n. It's a tiny detail, but (honest question) wouldn't it be better to check if the return value is not None? Checking for len() reminds me too much of Java.\nclj\n(assert (not (is None (read-file \"README.md\"))))\n. ",
    "hcarvalhoalves": "Related: https://github.com/hylang/hy/pull/354\n. This goes well with Hy:\nhttps://github.com/Suor/funcy\n. I messed up the PR earlier by pushing other things to master, it's ripe to merge now.\n. Not sure if it's a problem/possibility at that point, but will break at multiple '?'.\n```\n\n\n\ndef conv(obj):\n...   if obj.endswith(\"?\") and obj != \"?\":\n...      obj = \"is_%s\" % (obj[:-1])\n...   return obj\n... \nconv(\"foo?\")\n'is_foo'\nconv(\"foo??\")\n'is_foo?'\n``\n. @Willyfrog makes all the sense, I just replaced thereprbuiltin because I was lazy and wanted it to just work for recursiverepr`s after wrapping in those model classes. I've pushed a cleaner implementation.\n\n\n\nWhen do you think a __hyrepl__ magic method would be used?\n. Havent touched in a while. Does it still aplies cleanly?\n. Some tests don't pass on Py3K:\nhttps://travis-ci.org/hylang/hy/jobs/34653758#L424\nApparently it's expecting repr to only return the new string type. I don't know how to fix this in a compatible way though.\n. Pleeeeeeease\n. See https://pypi.python.org/pypi/xlocal to implement the equivalent of Clojure's with-bindings\n. Yeah, but that way of detecting keywords is weak anyway. I'm wondering if HyKeyword should really add a string with a magic to the AST, or a specific type (with the same interface as hy._compat.str_type)...\n. ",
    "gilch": "\nit makes it impossible to have the same for the other familiar and loved Python literals.\n\nPython's reprs in general are never going to work in Hy. Adding commas to enable a few exceptions to this doesn't seem worth it.\n\nSets literals are cool and useful enough to be considered. Tuples could be added in the mix too, since commas would remove any possible confusion.\n\nWe didn't before, but we have set literals now--#{}. We also have a pretty good tuple form using , as the symbol.\nI'm also in favor of closing this issue with no changes. The original arguments don't seem to apply.\n. Even if assoc is a better alternative, double-calling the function is unexpected. I wonder if this can happen in other cases.\n. @kirbyfan64 the mutating operators returning values seems like a separate issue from unexpected execution of statements in this issue. If you want to open a new issue for that we can all discuss it, but I think implementing this correctly is going to be more trouble than it's worth. (Also don't forget that setv is a mutating operator)\n. How about compiling assoc to something more like this?\n``` Python\ncurrent assoc\nspam[i] = y\nproposed assoc\n(spam.setitem(i, y) or spam)\nor even like this?\n(spam.setitem(i, y), spam)[1]\n```\nWhich of the two we use depends on if we want to allow custom __setitem__ implementations on user classes to return something.\nIf we want the old behavior, for performance reasons, we can rename the current assoc to something more intuitive, like setitem or set-item. \n. A possible issue with my approach:\n``` Python\n\n\n\nspam = [1,2,3]\n[1, 2, 3]\ndef getspam():\n...   print(\"side effect!\")\n...   return spam\n...\ngetspam().setitem(0,\"zero\") or getspam()\nside effect!\nside effect!\n['zero', 2, 3]\n```\n\n\n\nI'm still not familiar enough with Hy's AST manipulation approach to know if this is easily avoidable.\nThe obvious way around this problem in handwritten pure Python has the overhead of a function call:\n``` Python\n(assoc (getspam) 0 \"zero\"))  ; compiles to:\n(lambda x: x.setitem(0, \"zero\") or x)(getspam())\n```\nBut this doesn't appear to work automatically, since then the x is not gensym'd and could shadow something important:\n``` Python\n(def x \"something important\")\n(assoc (getspam) 1 x)  ; compiles to:\nx = \"something important\"\n(lambda x: x.setitem(0, x) or x)(getspam())  # probably not what you meant.\n```\nI would also like to point out that Python already has an operator.setitem function. We don't need a new one, do we? Maybe we should import it by default though.\n. On second thought this should work:\nPython\nx = \"important\"\n(lambda x,i,y:x.__setitem__(i, y) or x)(getspam(), 0, x)\nI noticed assoc is not considered a function now:\n=> assoc\nassoc\nTraceback (most recent call last):\n  File \"<input>\", line 1, in <module>\nNameError: name 'assoc' is not defined\nSo there's a possible performance reason to duplicate the operator.setitem behavior as a macro. I don't know if Python can do any kind of in-lining optimizations.\n. We also have \ndefn/defun\ndefn-alias/defun-alias\nfirst/car\nlif/lisp-if (and -not)\nrest/cdr\nThis redundancy also bothers me. If there actually is a meaningful difference in how things are compiled/optimized, (lambda/fn? def/setv?) then it should at least be documented, so we know which one to use when. But even then I'd prefer not to have to choose. Hy should use Clojure forms rather than Common Lisp forms when there are near equivalents to choose between.\nIn cases the above doesn't apply, I generally prefer the shorter names.\n. @algernon Can we also have this one in the \"Grand Language Cleanup\" milestone?\n. > The \"which one to use\" is a funny can of worms.\nsigh\nI think Python3, then Clojure, then Common Lisp, in that order, is a good preference heuristic for which to use. In fact, I think it resolves all of them. Hy really does not need to be compatible with Common Lisp (or Clojure for that matter). Hy is its own Lisp dialect, and We're still Python(TM).\n\nLast time this came up, one idea was to have a namespace that sets up the aliases. \n\nHere's an idea for ya, import hy.style will not change the language, but instead print out friendly error messages whenever you attempt to use the wrong Lisp dialect. Like say you start a form with a progn symbol and Hy replies, \"you meant to use a do here, didn't you, dear?\" That way people will actually learn Hy, and will use a mutually intelligible version of it ;)\n. Found some more.\nTrue/true\nFalse/false\nNone/nil/null\nI'll admit to using the easier-to-type aliases almost exclusively. But going by the heuristic, the clear winners are True/False/None. \nThese have to be reserved words anyway for Python interop, e.g. even if we decided to use nil exclusively to mean None, we still couldn't do (setv None 42), because this isn't compatible with Python None = 42  # error, whereas the reverse, nil = 42 is perfectly valid Python.\nCommon Lisp programmers unfamiliar with Clojure will be confused by nil != []. This will be less of an issue if we don't call a None a nil.\n. OK, we've got most of #880 merged (except the last commit, The -alias functions were moved instead of removed.). Now the following duplicates have been fixed:\nraise / throw\nexcept / catch\ndo / progn\ndefn / defun\nlif / lisp-if and lif-not / lisp-if-not\ndefn-alias / defun-alias\nThe remaining duplicates (I know of) are:\nTrue / true\nFalse / false\nNone / nil / null\nfirst / car\nrest / cdr\nlambda / fn\ndef / setv\nI'd like to start with the first of the two remaining groups. In #880, @paultag said he's \"OK with purging true false null and nil.\", and my rationale is just above that. If another core member approves, I can try to put together a pull that purges these from Hy. If not, I'd rather not waste the time. It looks a little more difficult than the last fix.\n. I should just make a pull purging null, I doubt anyone would object, because it's hardly ever used. The others seem a bit more controversial, as anticipated.\n. This wasn't supposed to get closed yet, can we re-open? Did Github do it automatically again?\n. > If one of the two has to go, I'm in favor of removing def\ndef cannot simply be removed, since it's reserved in Python. I suppose we could rename defn to def though. That way it would do the same thing as in Python, and have the advantage of not confusing Python users.\nAnother option. We could also make def and setv both do assignments, but behave differently:\n``` Python\n\n\n\nx = y = 1\nx\n1\ny\n1\n```\n\n\n\nSurprisingly, the above works, despite y=1 not counting as an expression with a return value. Python has special grammar rules for assignments. We could support this by redefining def, but keep the current behavior of setv.\nHy\n=> (def x y 1)\nx = y = 1\n1\n1\n=> [x y]\n[x, y]\n[1, 1]\n=> (setv x 2 y 3)\nx = 2\ny = 2\n(x, y)\n(2, 3)\nI'm not sure if I like this approach though. There may be better ways of getting the chained assignments. Maybe give setv a kwonly argument like this:\nHy\n=> (setv x y := 1)\n1\nThe presence of the := keyword changes it from pairing to chaining.\nCurrently, by convention, def is used for global constants, but setv is used for variables. The problem is, this is only a convention, and Python has no way to enforce this. This seems redundant when using caps/earmuffs anyway. We could alter the convention slightly, and make def create globals. So you could use a def inside a function but it would use the global keyword on its variable.\nOn the other hand, globals are considered harmful. Maybe we shouldn't go out of our way to support them. Renaming defn keeps sounding better and better.\nEdit: or we could just remove setv and always use def, even if it feels weird at first, you'll get used to it.\n. > What about making def force its target to always be a global?\nI already said that:\n\nWe could alter the convention slightly, and make def create globals. So you could use a def inside a function but it would use the global keyword on its variable.\n\nAnd kind of rejected it:\n\nOn the other hand, globals are considered harmful. Maybe we shouldn't go out of our way to support them. Renaming defn keeps sounding better and better.\n. > That'll break when you're at module level :(\n\nI thought Python actually allowed global declarations at module level.\n. let may also end up aliasing setv / def, depending on implementation. I'd rather we not call it let if we can't do it properly.\n. I propose removing car and cdr.\nrest / cdr are not quite the same, but still redundant. (cdr coll) is a macro that expands into a slice like coll[1:]. rest is a partial application of the function islice that does about the same thing as cdr. As a function, rest can be assigned to variables, passed to other functions, etc. As a macro, cdr cannot. Slices also don't work on generators so cdr doesn't work, but islices do, and so does rest. rest will do in almost all cases we currently use cdr. \nThe main problem with replacing all slices with islices, is that islice will always be a generator, but slices return another instance of the same collection type. Most of the time this isn't a problem. Python's libraries are very good about generally accepting iterables where you might have used a collection before. The main exception is strings, which really need to stay as strings.\nIf you do run into a case like this, you can still use (cut coll 1) for the same effect.\nThe case for dropping car in favor of first is even stronger. car is a macro like coll[0], while first is a function like next(islice(coll, 0, None)), which should perhaps be simplified to next(iter(coll)). Either way, you get the first element. Except car doesn't work on generators, and can't be passed as a higher-order function, etc. There is absolutely no reason to keep car except for symmetry with cdr, which we should also drop.\n. Does cons even make cons cells?\nHy\n=> (cons 0 [1 2 3])\nfrom hy.core.language import cons\ncons(0, [1, 2, 3])\n[0, 1, 2, 3]\n=> (type (cons 1 None))\nfrom hy.core.language import cons\ntype(cons(1, None))\n<class 'hy.models.expression.HyExpression'>\nSeems to mesh with lists just fine.\nHy\n=> (cons -1 (range 4))\nfrom hy.core.language import cons, range\ncons((-1), range(4))\n(-1 . range(0, 4))\n=> (list (cons -1 (range 4)))\nfrom hy.core.language import cons, range\nlist(cons((-1), range(4)))\n[-1, 0, 1, 2, 3]\n=> (type (cons -1 (range 4)))\nfrom hy.core.language import cons, range\ntype(cons((-1), range(4)))\n<class 'hy.models.cons.HyCons'>\nMaybe that's a cons cell. It seems to work with generators too.\n. >> Inside a quasiquote, plain symbols are converted to namespaced ones. Each symbol is first looked up in the \"hy\" namespace, if it isn't there, it is attributed to the namespace in which the macro is defined.\n\nThen how would you write an anaphoric macro, or otherwise refer to a symbol in the module where the macro expansion ends up, rather than the module it was defined in?\n\n@Kodiologist: they're talking about using Clojure's namespace system, which is quite well thought-out and certainly capable of handling anaphoric macros, even across namespaces. I've done it before. If you emit an unqualified symbol, the current namespace is assumed:\n```Clojure\n\nx  ; inside syntax quote, so current namespace is applied\nclojure.core/x~'x  ; literally emit 'x. Use this for anaphoric macros.\nx\n`foo.bar/x  ; you can also explicitly pick a namespace.\nfoo.bar/x\n```\nThere's been something of a holy war about lisp-1 vs lisp-2. Clojure's namespace system is the best of both worlds. Hy is just a lisp-1 currently, but Namespaces are one honking great idea -- let's do more of those!\n\nIt's not entirely clear how this should interact with Python's module system, but it's far from clear that require is good enough. I think this merits further discussion.. Yes, that is what Lisp-1/Lisp-2 means. But the Lisp-1/Lisp-2 issue is about the consequences of that design choice, which is not orthogonal at all. Some of the trade-offs are pretty subjective, but I'm talking about the ones that pertain to Clojure's syntax-quote.\nTo illustrate these consequences, I use some examples from a well-known paper on the subject\nLisp\n (DEFUN PRINT-SQUARES (LIST)\n   (DOLIST (ELEMENT LIST)\n     (PRINT (LIST ELEMENT (EXPT ELEMENT 2)))))\nThis works fine is a Lisp-2. When a symbol is used in the function position it's looked up in the function namespace so there's no collision. But in a Lisp-1, oh noes! You shadowed the LIST function with your LIST parameter. In a Lisp-1 you'd have to do something like this:\nLisp\n(DEFUN PRINT-SQUARES (LST)\n   (DOLIST (ELEMENT LST)\n     (PRINT (LIST ELEMENT (EXPT ELEMENT 2)))))\nWe couldn't use the more natural LIST, so we called it LST instead. Modern sytnax highlighting can help you spot when this is necessary. But Clojure can use an explicit namespace instead:\nClojure\n(defn print-squares [list]\n  (doseq [element list]\n    (println (clojure.core/list element (* element element)))))\nIt's still not as nice as a Lisp-2, but you do have more opitons than you'd expect from a Lisp-1. I think in this case the difference is a pretty minor issue. A more important advantage of a Lisp-2 is in macros. Lets look at a related example.\nConsider the following simple macro.\nLisp\n(DEFMACRO MAKE-FOO (THINGS) `(LIST 'FOO ,THINGS))\nSuppose the user of this macro writes (DEFUN FOO (LIST) (MAKE-FOO (CAR LIST))) in a separate file.\nYou have to know the expansion to see the problem:\nLisp\n* (MACROEXPAND '(MAKE-FOO (CAR LIST)))\n(LIST 'FOO (CAR LIST))\nT\nAgain, this works fine in a Lisp-2. The first LIST is looked up in the function namespace, so there's no collision. But in a Lisp-1 like Hy, that's a bug. It can be hard to avoid, since it's hidden behind the macro. I can't call this case minor. This is the main advantage of a Lisp-2, but as noted in the paper, it's not immune to this kind of issue either (e.g. FLET). It just comes up less in practice.\nClojure doesn't have this problem though:\nClojure\n(defmacro make-foo [things] `(list '~'foo ~things))\n(defn foo [list] (make-foo (first list)))\nClojure\nuser=> (foo '(1 2 3))\n(foo 1)\nuser=> (macroexpand '(make-foo 1))\n(clojure.core/list (quote foo) 1)\nThat demonstrates the real power of Clojure's syntax quote, which automatically inserts the explicit namespaces for you.\nOne could argue pretty persuasively that Clojure is a Lisp-1. As noted in the paper, however, these are not well defined terms. (Common Lisp, for example, probably has seven namespaces and is flexible enough for the user to define more.) But I would call Clojure a Lisp-n. You get as many namespaces as you want, including for functions. This capability is built in; you don't have to implement it yourself. Clojure has the main advantages of both worlds.\nScheme is a Lisp-1, but can avoid this problem by using its hygenic macro system, which doesn't capture symbols like that. You can't do anaphoric macros that way though.\nHy has none of this. No Clojure-like syntax-quote, just Common Lisp's quasiquote (with clojure-style ~). No Scheme-like hygenic macro system. And no Common Lisp/Lisp-2 function namespace.\nOf the three, I like Clojure's solution best, but I'm not sure how Clojure's absolute namespaces should fit into Python's mutable module system. Hy needs a solution.\n. I'm not completely sure what makes the with form unparse-able, but can't we handle this in a way analogous to &optional in function definitions? Or to :as in imports?\nFor comparison, the Common Lisp-style, what we're using now:\n(with [[cm (Clamm)] [(Class)]] ...)\nUsing the &optional-style, the inner [] are only required when there's an \"as\" target. Otherwise, it gets the default name:\n(with [[cm (Clamm)] (Class) ] ...)\nRemember we already do something like this for function bindings.\nUsing import :as-style, the expression following the :as is the target, the one after that (if any) is the next with_item.\n(with [ (Clamm) :as cm (Class) ] ...)\nThis translates pretty directly to Python.\nEither of these options would be unambiguous, and wouldn't come with the cost of abandoning the original Clojure-style bindings in the rest of the language for consistency.\n. I agree with @Kodiologist on this one. A single underscore suffices. Hy should just do it Python's way, rather than re-implementing something that already works in a slightly different way.. It seems worth a reader macro to me. I think the cut form should support this, and be aliased as #:. I'm just not sure how multidimensional slices should look in a Lisp, but the above doesn't look too bad. I don't like that we have to insert Nones, but I'm not sure how else to do it.\n. On second thought, perhaps #: should be a slice literal?\nSo\nHy\n(cut arr (, 0 #:(1 10 2) Ellipsis 3))\narr[0,1:10:2,...,3]\nMaybe the tuple part should be implied:\nHy\n(cut arr 0 #:(1 10 2) Ellipsis 3)\nBut then the more common one-slice cut would be:\nHy\n(cut arr #:(1 10 2))\n``` Python\narr[1:10:2]\nor equivalently?\narr[slice(1,10,2)]\n```\nA better option might be a cuts macro that puts in the tuple, so the current cut is unchanged.\nMaybe we could set up an internal reader macro to use :[1 10 2] instead of #:(1 10 2) for slice. This shouldn't interfere with keywords, because [] isn't allowed in keywords anyway.\nHy\n(cuts arr 0 :[1 10 2]  Ellipsis 3)\nAlso Ellipsis is a lot harder to type than ..., so perhaps we could have :[] stand for that.\nHy\n(cuts arr 0 :[1 10 2] :[] 3)\n. That tip really ought to be in the docs somewhere.\n. Maybe in docs/tutorial.rst \"Protips!\".\n. I came up with\nHy\n(deftag $ [expr]\n  `(slice ~@(list-comp (if (= x '.) None\n                           (= x '...) 'Ellipsis\n                           x)\n             [x expr])))\nIt makes slice objects much more concise, e.g., #$[.] instead of (slice None) and #$[. ... -1] instead of (slice None Ellipsis -1). It's still not quite as compact as Python though. Even with #1481 eliminating the extra tuple x[1:5, 1:2] would be (. x [#$[1 5] #$[1 2]]).\n~You could do something similar with a normal macro~ [Edit: no, dots do weird things to HyExpressions.]\nHy\n(defmacro $ [&rest args]\n  `(slice ~@(list-comp (if (= x '.) None\n                           (= x '...) 'Ellipsis\n                           x)\n             [x args])))\nThen x[1:5, 1:2] would be (. x [($ 1 5) ($ 1 2)]). This actually seems pretty good to me, but it's still not as concise as Python. I'm not sure we can do much better.\nPerhaps . or : (or both) inside [] could be special-cased in the . DSL macro somehow. (Though . is currently a special form, it shouldn't be.) I'm not sure how it should work though. It needs to be completely unambiguous where one slice starts and another ends.\nPerhaps (. x [(: 1 5) (: 1 2)]) or (. x [:[1 5] :[1 2]]). Macros can do this sort of thing, but it's not really better. How do we want this to work?\n  . I stumbled upon this https://qiita.com/riktor/items/cd914612673fe7828a8d our slicing is inadequate so someone fixed it with a macro. (warning, Japanese). But that's one possible syntax we could have.. Did #1314 fix this one?. Here's a similar example:\nHy\n=> (print (list-comp (assert x) [x [1 2 3]]))\nassert x\nprint([None for x in [1, 2, 3]])\nTraceback (most recent call last):\n  File \"<input>\", line 1, in <module>\nNameError: name 'x' is not defined\nSurprising behavior like this is unacceptable, but what should this even compile to?\nMaybe something like this:\nPython\n_hy_anon_var_1 = []\nfor x in [1, 2, 3]:\n    assert x\n    _hy_anon_var_1.append(None)\nprint(_hy_anon_var_1)\nThis leaks x into the surrounding scope, which was actually correct for Python 2.\nThe above won't work for a genexpr, which is also broken:\nHy\n=> (list (genexpr (assert x) [x [1 2 3]]))\nassert x\nlist((None for x in [1, 2, 3]))\nTraceback (most recent call last):\n  File \"<input>\", line 1, in <module>\nNameError: name 'x' is not defined\nIt must be lazy to work correctly. Maybe something like this:\nPython\n_hy_anon_var_1 = [1, 2, 3]\ndef _hy_anon_fn_1():\n    for x in _hy_anon_var_1:\n        assert x\n        yield None\nlist(_hy_anon_fn_1())\nNo leak this time. You can use genexpr to implement all the other comprehensions. This seems like an improvment over the status quo, but compiling to a function like this introduces the same problems we had with let.\n. Probably relevant: https://stackoverflow.com/questions/32139885/yield-in-list-comprehensions-and-generator-expressions#32139977\nBasically, Python compiles generator expressions to generator function objects anyway. Therefore, it won't cause problems (beyond what problems Python already has) if we do the same in Hy, as I suggested in my previous comment.\n. Here's an even simpler example.\n```Python\n\n\n\n[(lambda: x)() for x in range(5)]\n[0, 1, 2, 3, 4]\nPython\n=> (list-comp ((fn [] x)) [x (range 5)])\n[(lambda : x)() for x in range(5)]\n[0, 1, 2, 3, 4]\n=> (list-comp ((fn [] \"boo!\" x)) [x (range 5)])\ndef _hy_anon_fn_1():\n    'boo!'\n    return x\n[_hy_anon_fn_1() for x in range(5)]\nTraceback (most recent call last):\n  File \"c:\\users\\me\\documents\\github\\hy\\hy\\importer.py\", line 198, in hy_eval\n    return eval(ast_compile(expr, \"\", \"eval\"), namespace)\n  File \"\", line 1, in \n  File \"\", line 1, in \n  File \"\", line 1, in _hy_anon_fn_1\nNameError: name 'x' is not defined\n```. Digging this up because of the recent #1342 and #1362 which have similar problems.\n\n\n\nI think we have a good solution. I'm proposing that generally, if there are any expressions we have to pull out, that\nHy\n(genexpr <expression> [<binding> <sequence>] <condition>)\nShould compile to\n```Python\n statements naturally go here.\n_hy_anon_var_1 = \ndef _hy_anon_fn_1():\n    for  in _hy_anon_var_1:\n        # Pull out any  statements here.\n        if :\n            # Pull out any  statements here.\n            yield \n_hy_anon_fn_1()\n```\nFor a list-comp, change the last line to\nPython\n[_hy_anon_var_2 for _hy_anon_var_2 in _hy_anon_fn_1()]\nWe shouldn't use list(_hy_anon_fn_1()), because list might be shadowed by a local.\nSimilarly for the set-comp, but use {} instead of [].\nA dict-comp is a little different:\nHy\n(dict-comp <key> <value> [<binding> <sequence>] <condition>)\n```Python\n statements.\n_hy_anon_var_1 = \ndef _hy_anon_fn_1():\n    for  in _hy_anon_var_1:\n        #  statements\n        if :\n            # Pull out any  or  statements here.\n            yield , \n{_hy_anon_var2: _hy_anon_var3 for _hy_anon_var2, _hy_anon_var3 in_hy_anon_fn_1()}\n```\nBut it's the same basic idea.\nThis list-comp doesn't leak the binding into the local scope in Python2. I'm not sure if there's any point to that. It was undesired behavior due to an optimization. Generator expressions, and set- and dict-comprehensions don't have this problem even in Python2. And we won't be supporting Python2 much longer anyway.\nBut the leaky Python2 list-comp could instead be compiled to\n```Python\nPull out any  statements here.\n_hy_anon_var_1 = \n_hy_anon_var_2 = []\nfor  in _hy_anon_var_1:\n    # Pull out any  statements here.\n    if :\n        # Pull out any  statements here.\n        _hy_anon_var_2.append()\n_hy_anon_var_2\n. I forgot the case with multiple bindings:Hy\n(genexpr \n         [ \n \n            ...\n           ])\nBut the compilation is straightforward. Add more loops:Python\n statements\n_hy_anon_var_1 = \ndef _hy_anon_fn_1():\n    for  in _hy_anon_var_1:\n        #  statements\n        _hy_anon_var_2 = \n        for  in _hy_anon_var_2:\n             ...\n            #  statements\n            _hy_anon_var_N = \n            for  in _hy_anon_var_N:\n                #  statements\n                yield \n_hy_anon_fn_1()\n``. Can we renamecutto:instead? Or perhaps add an alias reader macro#:that translates tocut`?\nAlso, if we could use the : as keyword separators, it could look more like Python's slices and we wouldn't have to insert nils so much.\n. I think a fairly straightforward extension of my proposal in #664 would also work for yield inside let. Here's a possible Python translation for a contrived example.\n``` Python\n(defn test-yield []\n  (setv foo 2)\n  (setv bar 3)\n  (let [[baz 5]]\n    (yield foo)\n    (yield bar)\n    (yield baz)\n    (setv foo ( 10 foo))\n    (setv bar ( 100 bar))\n    (yield foo))\n  (yield foo)\n  (yield bar))\n(list (test-yield))\ndef test_yield():\n    foo = 2\n    bar = 3\n    def _hy_anon_fn_1(foo=foo,bar=bar):\n        baz = 5\n        yield foo, (foo, bar)\n        yield bar, (foo, bar)\n        yield baz, (foo, bar)\n        foo = 10 * foo\n        bar = 100 * bar\n        yield foo, (foo, bar)\n    for _hy_anon_var_1, _hy_anon_var_2 in _hy_anon_fn_1():\n        foo, bar = _hy_anon_var_2\n        yield _hy_anon_var_1\n    yield foo\n    yield bar\nlist(test_yield())  # [2, 3, 5, 20, 20, 300]\n```\nA generator is not like a normal function. You don't just call it. Here when a yield is detected, Hy would invoke it with a for loop which updates the simulated nonlocals, then yields the intended value from outside the let. Notice that compiling it this way could also work for yield inside nested lets. Nonlocals and yield values will propagate out.\n. We don't have to fix scoping in general just to get the let form working, do we? The function in a let form is defined once, and immediately called once. In and out.\nPython\ndef test():\n    foo = True\n    def _hy_anon_fn_1(foo=foo):\n        if foo:\n            foo = False\n            _hy_anon_var_1 = foo\n        else:\n            _hy_anon_var_1 = None\n        return _hy_anon_var_1, foo\n    _hy_anon_var_1, foo = _hy_anon_fn_1()\n    return _hy_anon_var_1\nIsn't it feasible to generate AST like this? Here, any assigned-to nonlocal is passed in as a default argument. The updated nonlocals are returned in a tuple, and reassigned all at once. It so happens that in this example there is only one nonlocal assinged, and it's the same as the tail return, but they needn't be:\nPython\n=>(defn test2 \n      (setv foo 1)\n      (setv bar 2)\n      (print (let []\n               (print foo)\n               (print bar)\n               (setv foo \"spam\")\n               (setv bar \"eggs\")\n               \"baz\"))\n      (print foo)\n      (print bar))\ndef test2():\n    foo = 1\n    bar = 2\n    def _hy_anon_fn_1(foo=foo, bar=bar):\n        print(foo)\n        print(bar)\n        foo = \"spam\"\n        bar = \"eggs\"\n        return \"baz\", foo, bar\n    _hy_anon_var_1, foo, bar = _hy_anon_fn_1()\n    print(_hy_anon_var_1)\n    print(foo)\n    return print(bar)\n=> (test2)\n1\n2\nbaz\nspam\neggs\nI think this would accomplish everything we want, even for nested lets.\n. Is this working already? Can we close this?. I do think that special forms and macros should be clearly marked as such in the documentation. Shadowed forms should be labeled both.. @ekaschalk The shadowed apply thing is off topic, and probably belonged in #647. It may be moot since the unpacking operators replaced apply in #1325. I'm also not sure if removing apply was a good idea or not, but if you have more to say about it, open a new issue.\nThe probem with shadowing Hy's get is that it does not correspond to only one operator in Python, but three: getitem, setitem, and delitem.\n=> (def spam {})\nspam = {}\nNone\n=> (setv (get spam \"a\") \"A\")\nspam['a'] = 'A'\nNone\n=> (get spam \"a\")\nspam['a']\n'A'\n=> (del (get spam \"a\"))\ndel spam['a']\nNone\nMaybe we should just add these three operators to core.\n. No, the obvious implementation is from operator import getitem as get. \nYour implementation does more than getitem. It's more like Clojure's get-in, but without the optional default.\nClojure\nuser=> (get-in [:a [:b [:c]]] [1 1 0] :absent)\n:c\nuser=> (get-in [:a] [1 1 0] :absent)\n:absent\nI'm not opposed to adding something like Clojure's get-in to Hy, but Toolz already has one #1339.. That is a good point. I forgot our special form can take multiple keys.\nI'd like to have the defaults of Clojure's get-in, but that's no reason not to shadow get. Clojure's get does take a default like get-in, which is different than Hy. I thought about changing it, but Hy's version of the special form lets us use it like a Common Lisp setfable place, which makes more sense for Python's mutable data structures. If we added a the default logic to the compilation of the special form, it would be difficult to use it in setv or del statement.\nI think generalized places for use in a setv or del could be done in a macro by using the __setitem__/__delitem__ magic in a custom place class, but that's probably not what we want by default for a simple get.. Running with @farhaven's suggestion, what possible good does renaming the bindings to gensyms do? I mean as opposed to just using a setv. The answer: it creates the illusion of the variables leaving scope. I think that's about it, but please tell me if I missed another advantage over setv. This is just an illusion, though, and it litters the namespace with gensyms. Like just using setv, it doesn't break statements like yield continue break etc.\nSince farhaven has just demonstrated the feasibility of mangling the symbols inside the let body, how about this instead?\nFirst, make an empty object type we can assign attributes to:\nPython\nclass namespace(object):\n    pass\nThen, and this is the trick, let will mangle the symbols to contain a dot (.). Starting with that last example:\nHy\n(def foo\n  (let [x 'bar]  ; new let ditches extra brackets.\n   (fn [] x)))\nWould expand to:\nHy\n(def foo\n  (do\n    (setv _hy_anon_var_1 (namespace)\n          _hy_anon_var_1.x 'bar)\n    (fn [] _hy_anon_var_1.x)))\nThis still litters _hy_anon_var_s, but Hy was doing that anyway. It might even be safe to use at the module level. This way we don't need gensym, and lets with multiple bindings only create one new variable, instead of many:\nHy\n(let [x 1 y 2 z 3] (print x y z))\nBecomes\nHy\n(do\n  (setv _hy_anon_var_1 (namespace)\n        _hy_anon_var_1.x 1\n        _hy_anon_var_1.y 2\n        _hy_anon_var_1.z 3)\n  (print _hy_anon_var_1.x _hy_anon_var_1.y _hy_anon_var_1.z))\nFurthermore, unlike gensyms, we could use this kind of mangling to support a kind of nonlocal in Python2.\nHy\n(defn make-counter []\n  (let [count 0]\n    (lambda [] (setv count (inc count)))))\nWhich expands to:\nHy\n(defn make-counter []\n  (do\n    (setv _hy_anon_var_1 (namespace)\n          _hy_anon_var_1.count 0)\n    (lambda [] (setv _hy_anon_var_1.count (inc _hy_anon_var_1.count)))))\nThis works because the entire lambda is in the body of the let macro, so its symbols get mangled too. Python lets you read variables in enclosing scope, you just can't assign to them. Mutating _hy_anon_var_1 doesn't count as an enclosing scope assignment!\n. Ugh, globals. I hadn't thought of that. nonlocal would also break. Please tell me if I missed any other cases.\nFor let to work, it would have to avoid mangling exactly the symbols global or nonlocal apply to. But it would still have to mangle nonlocal if the variable referred to is also inside the let. It could be done. There are deterministic rules, and Python does it. But yeah, that's re-implementing Python's scoping rules. Not exactly sure how hard that would be.\nThe easy way out would be to disallow nonlocal and global from appearing in a let if they apply to symbols let is using. The let would just raise an error and refuse to compile. I don't really like it, but it would be easier to just detect this case than to fix it. I suppose we could do it this way first, and think about supporting global/nonlocal later.\n. \"With all those restrictions\"? global is not even used that much. And you can still use global, just not if let is already binding that symbol. With a good error message, you could easily fix it in most cases by making let bind some other symbol instead. Similarly with nonlocal. In fact, if nonlocal's target appears inside the body of the let you don't even need the nonlocal keyword, because let already does the lexical scoping for you. \nI still think it's a dramatic improvement over the old let. While the let macro may be complex, the expansion is rather simple. yield,break, and continue will work, while they wouldn't inside of a function, and they would be extremely difficult with that approach. nonlocal is not even available in Python 2, and this let would give you that kind of capability.\nActually, I wonder if it would be better to have two versions of let. The Python2 version would use the namespace objects and dot mangling as discussed, while the Python3 version would just nonlocal its bindings.\n. > But you still have lambda arguments to worry about...\nNot sure what you mean, can you show me an example?\n. And a naiive implementation expands into\nHy\n(do\n  (setv _hy_anon_var_1 (namespace)\n        _hy_anon_var_1.x [1 2 3])\n  (map (fn [_hy_anon_var_1.x] (inc _hy_anon_var_1.x)) _hy_anon_var_1.x))\nBut to get the old behavior, needs to be\nHy\n(do\n  (setv _hy_anon_var_1 (namespace)\n        _hy_anon_var_1.x [1 2 3])\n  (map (fn [x] (inc x)) _hy_anon_var_1.x))\nAgain, easier to detect and raise error than to fix. But, I agree, this restriction is much more serious than for global. It would be more worthwhile to fix it in the macro.\nThe fix given an error would be the same: change the name of the let binding.\nHy\n(let [xs [1 2 3]]\n  (map (fn [x] (inc x)) xs))\nHy\n(do\n  (setv _hy_anon_var_1 (namespace)\n        _hy_anon_var_1.xs [1 2 3])\n  (map (fn [x] (inc x)) _hy_anon_var_1.xs))\n. A sketch of how the dot-mangle let macro might work:\nThe bindings part is easy:\n- create a do block around a setv for a namespace instance to a generated variable, and dot-mangle the let bindings to that namespace variable. As in my examples.\n- remember the binding-symbols for later.\nThe body part is not easy:\n- recursively pre-expand macros in its body\n- deep-traverse code, mark binding-symbols affected by global\n- deep-traverse code, mark binding-symbols affected by nonlocal\n- deep-traverse code, mark binding-symbols that are parameters in a fn.\n- deep-traverse code, mark binding-symbols that are parameters in a lambda.\n- deep-traverse code, replacing each of the unmarked binding-symbols with the dot-mangled equivalent.\n- deep-traverse code, unmark any marked symbols.\n- append new body to do form and return it.\nMarking merely has to be reversible. You could replace with a gensym prefixed symbol. Or if Hy symbols allow any kind of metadata or Python setattr, you could mark it that way, again, more safely with a gensym.\nHow you detect which symbols are affected by global, nonlocal or are parameters is the interesting question. The Python compiler does it. And it's open-source, so we can look. I'm not sure if AST has useful metadata for this kind of thing, but if it does, this might be easier to implement at the Python level.\n. > I wasn't in favor of it before, but now I'm starting to agree that removing let may be a good idea.\n@kirbyfan64 I agree, but I'm not the one you need to convince. @algernon closed #844, based on what appeared to be a loose consensus in a discussion with nine other participants besides us three.\nThe issues I pointed out in #844 are still a problem. A function is not just a block scope. It can also sever multi-part control statements in surprising ways. As implemented now, a break or continue won't work inside a let unless the entire loop is inside the let. Worse, a yield will work inside a let, but doesn't do what you want unless the entire generator function is inside the let.\nTherefore we can't use a function to implement let.\nFurthermore, let is supposed to be able to create closures, but only a function can do this in Python. \nTherefore we must use a function to implement let.\nBut closures in Python don't even work like closures in Lisp. You can't assign to the closed-over variable. It's read-only. You could get around this with nonlocal but that doesn't work in Python2. Actually in Clojure it's also read-only. If you want to mutate something like that you would use an \"atom\", which would not be hard to implement in Python2 (I've pretty much done it in DRYthon).\nSo, given that we can't use a function and must use a function, what are the options?\n- Get rid of let. Use a setv or nested class declaration instead, or explicitly create and call a lambda.\n- Make a version of let that uses a function and another that doesn't. Call them something else to avoid confusion. (So we still get rid of let).\n- Re-implement break, continue and yield so they aren't severed from their containing statement by functions. I've pretty much done this with exceptions in DRYthon for break and continue (and return). They work with labels now too. yield, though, is going to be tricky. I once implemented a Python-like yield in Java using threads. Something like that might work. Perhaps it would only need co-routines (i.e. using the generator's .send()), but I'm not sure how to do it that way.\n- Re-implement closures without using functions, or at least not directly. I'm not sure how to do this either.\n- Make let a complicated macro that always expands into a generator function, plus any bridge code to make it work like the old let, and to make break/continue/yield work.\n- Get rid of break/continue and refactor loops to use if/cond or explicit exceptions. Get rid of yield and refactor generators into Haskell-like compositions with itertools, and/or implement Clojure's lazy-seq macros? Use an explicit Clojure-like \"atom\" instead of nonlocal where required.\n. No, Python3 gives us nonlocal, but it doesn't help with break/continue/yield. nonlocal isn't even the biggest problem. Clojure's locals are also effectively read-only. If you need to change an identity in an enclosing scope in Clojure, you'd use an \"atom\", and mutate the \"atom\" rather than overwriting it. We can do that in Python2 with a single-item list.\n\nComplete Hy noob here, but why does \"explicitly create and call a lambda\" not have the same issues as let\n\n@davexunit: It does have the same issues, since that's pretty much how let works now. The difference (and it's a big difference) is that if you do it explicitly, you expect it to work like Python, so you aren't surprised when a yield automagically turns the inner function into a generator, but if you use let, you expect it to work more like a block-scoped local variable (because let is how that's done in Lisp) which just doesn't do that.\nSimilarly for severing break or continue from its containing loop. If all you wanted was a \"local variable\", this is surprising behavior. If we got rid of let, no-one would attempt to use a function just to create a local, they'd just use a setv instead (and perhaps a del if necessary, but with gensyms who cares?). If they really needed a closure, then the explicit approach can still do that.\n. This still hasn't been fixed? PEP-380, mentioned above defines the yield from statement in equivalent Python. It's not simple, but it should be straightforward to directly translate this into Hy and put it in the macro. The relevant code, in Python:\n``` Python\nThe statement\nRESULT = yield from EXPR\nis semantically equivalent to\n_i = iter(EXPR)\ntry:\n    _y = next(_i)\nexcept StopIteration as _e:\n    _r = _e.value\nelse:\n    while 1:\n        try:\n            _s = yield _y\n        except GeneratorExit as _e:\n            try:\n                _m = _i.close\n            except AttributeError:\n                pass\n            else:\n                _m()\n            raise _e\n        except BaseException as _e:\n            _x = sys.exc_info()\n            try:\n                _m = _i.throw\n            except AttributeError:\n                raise _e\n            else:\n                try:\n                    _y = _m(*_x)\n                except StopIteration as _e:\n                    _r = _e.value\n                    break\n        else:\n            try:\n                if _s is None:\n                    _y = next(_i)\n                else:\n                    _y = _i.send(_s)\n            except StopIteration as _e:\n                _r = _e.value\n                break\nRESULT = _r\n```\n. A proof of concept in Python 2:\n``` Python\nimport sys\ndef f():\n    yield 1\n    try:\n        yield 2\n    except ValueError as e:\n        yield 3\ndef g():\n    EXPR = f()\n    # RESULT = yield from EXPR\n    _i = iter(EXPR)\n    try:\n        _y = next(_i)\n    except StopIteration as _e:\n        _r = _e.value\n    else:\n        while 1:\n            try:\n                _s = yield _y\n            except GeneratorExit as _e:\n                try:\n                    _m = _i.close\n                except AttributeError:\n                    pass\n                else:\n                    _m()\n                raise _e\n            except BaseException as _e:\n                _x = sys.exc_info()\n                try:\n                    _m = _i.throw\n                except AttributeError:\n                    raise _e\n                else:\n                    try:\n                        _y = _m(*_x)\n                    except StopIteration as _e:\n                        _r = _e.value\n                        break\n            else:\n                try:\n                    if _s is None:\n                        _y = next(_i)\n                    else:\n                        _y = _i.send(_s)\n                except StopIteration as _e:\n                    _r = _e.value\n                    break\n    RESULT = _r\nx = g()\nprint next(x)\nprint next(x)\nprint x.throw(ValueError)\n```\n``` Python\n\n\n\n================================ RESTART ================================\n1\n2\n3\n```\n\n\n\nIt actually does seem to work. The macro would probably replace the _x (for various x) with gensyms. Also, Python 3 didn't get yield from until version 3.3. Are we still supporting Python 3 older than that?\n. A pretty direct translation to Hy.\n``` Hy\n(import sys)\n(defn f []\n  (yield 1)\n  (try\n    (yield 2)\n    (except [e ValueError]\n            (yield 3))))\n(defn g []\n  (setv EXPR (f))\n  ;; (setv RESULT (yield-from EXPR))\n  (setv _i (iter EXPR))\n  (try\n    (setv _y (next _i))\n    (except [_e StopIteration]\n            (setv _r _e.value))\n    (else\n      (while 1\n        (try\n          (setv _s (yield _y))\n          (except [_e GeneratorExit]\n                  (try\n                    (setv _m _i.close)\n                    (except [AttributeError] pass)\n                    (else (_m)))\n                  (raise _e))\n          (except [_e BaseException]\n                  (setv _x (sys.exc_info))\n                  (try\n                    (setv _m _i.throw)\n                    (except [AttributeError] (raise _e))\n                    (else\n                      (try\n                        (setv _y (apply _m _x))\n                        (except [_e StopIteration]\n                                (setv _r _e.value)\n                                (break))))))\n          (else\n            (try\n              (if (is _s nil)\n                (setv _y (next _i))\n                (setv _y (_i.send _s)))\n              (except [_e StopIteration]\n                      (setv _r _e.value)\n                      (break))))))))\n  (setv RESULT _r))\n(def x (g))\n(print (next x))\n(print (next x))\n(print (x.throw ValueError))\n```\nIt seems to work, but I might have missed something. @hylang/core More eyeballs please.\nThis will not be simple macro, but it should be a simple matter of inserting gensyms and such now that we have a Hy translation.\n. The macro version.\n(EDIT: see new version below)\nAgain, eyeballs. I could probably drop this into Hy proper. How well are we testing this already? Do we need to support Python3 < 3.3?\n. I hesitate to suggest, but with this macro, we could probably support < 3.3 again. Unless there's something else that breaks.\n. Fixed more errors, new proposed drop-in:\nEDIT: actually this one.\nHy\n(if-python2\n  (defmacro/g! yield-from* [EXPR]\n    `(do\n       ;; (setv RESULT (yield-from EXPR))\n       (setv ~g!i (iter ~EXPR))\n       (try\n         (setv ~g!y (next ~g!i))\n         (except [~g!e StopIteration]\n                 (setv ~g!r (. ~g!e value)))\n         (else\n           (while 1\n             (try\n               (setv ~g!s (yield ~g!y))\n               (except [~g!e GeneratorExit]\n                       (try\n                         (setv ~g!m (. ~g!i close))\n                         (except [AttributeError] pass)\n                         (else (~g!m)))\n                       (raise ~g!e))\n               (except [~g!e BaseException]\n                       (setv ~g!x (sys.exc_info))\n                       (try\n                         (setv ~g!m (. ~g!i throw))\n                         (except [AttributeError] (raise ~g!e))\n                         (else\n                           (try\n                             (setv ~g!y (apply ~g!m ~g!x))\n                             (except [~g!e StopIteration]\n                                     (setv ~g!r (. ~g!e value))\n                                     (break))))))\n               (else\n                 (try\n                   (if (is ~g!s nil)\n                     (setv ~g!y (next ~g!i))\n                     (setv ~g!y (~g!i.send ~g!s)))\n                   (except [~g!e StopIteration]\n                           (setv ~g!r (. ~g!e value))\n                           (break))))))))\n       ~g!r))\n  nil)\n. @zackmdavis I can't reproduce #691 with my macro. Maybe it's working now?\n. +1\nI understand this is easy to fix with macros, but I would prefer that the core forms like let be more consistent with the way we write dictionaries in Hy, like {'x nil 'y 1} rather than {['x] ['y 1]}\nGuidelines say we should borrow from Python3 first, Clojure second, and Common Lisp third. \nRemember from Zen of Python: \"Flat is better than nested.\" \"Simple is better than complex.\" As for having to spell out nil, \"Special cases aren't special enough to break the rules.\" and \"Explicit is better than implicit.\" \nI much prefer Clojure's let to Common Lisp's anyway and usually use a macro that behaves that way in Common Lisp. \nPaul Graham's Arc Lisp, noted for it's conciseness, also has a with form that works more like Clojure's let. Arc's let form is even simpler: it only binds one symbol and doesn't even need extra parantheses. Most of the time when you use let you only bind one symbol, so this makes a lot of sense. It was such a good idea that I made a let-1 macro in Common Lisp that does the same thing.\n. Don't we have one of those? https://github.com/hylang/hy/blob/master/eg/flask/meth_example.hy \n. Can I also vote for the return expression? I think Hy should be able to do anything Python can. I should be able to translate any Python code I see into near-equivalent Hy. Automatically even, with some kind of py2hy (de)compiler. This would be really hard without return. You would have to rewrite any Python code with multiple exits.\nI'm fine with having an implicit return at the tail position. I'd prefer not to have to spell it out if I don't have to.\nThe return statement is Rossum's recommended way of breaking out of nested loops. This isn't possible with only an implicit return.\nIf I'm writing the code myself from scratch, I'd prefer using higher-order functions over explicit nested loops anyway, but that doesn't mean I want to translate someone's working algorithm into that style just to insert some Hy macros.\n. I really don't think explicit returns are any more confusing than break or continue inside loops, or the whole exception system. You aren't proposing we cut those out too? You'll get used to it. As for mixing explicit and implicit, well, Ruby might be a bad example, but I'll point out that Rust also does it this way. Even Python has an implicit return in lambda expressions, but explicit return in function defs.\n. I feel pretty strongly that Hy functions really ought to have multiple exits, because this is something Python already does, and \"We're still Python(TM).\".\nAfter re-reading my last comment I had another idea. While I have absolutely no problem with mixing implicit and explicit returns, if that's the main sticking point preventing Hy from having multiple exit capability then, then why not offer both, but cleanly separate them to avoid any mixing?\nWe could have defn/fn require an explicit return even in the tail position, while lambda disallows any return and has the implicit return at the tail. Python users will not be surprised by this behavior.\nUnlike Python, the lambda in Hy already has the implicit progn feature, or as near as we can get, I guess, so it's still OK to use \"statements\" in a Hy lambda. We would only have to change it to complain if there's a return form.\nOne complaint I would have with this arrangement is that if we ideally want to prefer and encourage the implicit forms in Hy code, then between fn and lambda, the preferred form should not have the longer name. This is easy to fix; we just need a shorter symbol for lambda. The possibilities la, lam, /\\, \\, .\\ and ,\\ come to mind,\n. > We wouldn't have to have multiple different forms for almost same thing.\nI am generally opposed to having multiple forms for almost the same thing, at least in the core. Adding new forms is easy with macros. Subtracting cruft, not so much. But I do think it's okay in this case because Python already has lambda even though def does almost the same thing. Rather than adding complications, it would make Hy fit Python even better. And after all, We're still Python.\n\nI really like building code where last value of function is returned, without having to have return there.\n\nMe too, but in neither of my proposals would you lose this ability.\n\nSo far I haven't had a case where I had needed to return a value from middle of a function.\n\nOne can always work around such cases, but that doesn't mean we should have to. Writing new Hy from scratch is one thing, but this commonly comes up when translating existing Python into Hy. For most of Python this is easy, but it's a pain to rewrite the flow so there's only one exit. Python has no goto, and no labeled break--even though it's helpful for nested loops. I think the main argument for not adding this to Python is that you can break out if any amount of nesting with a return. So that's how it's done. But in Hy I can't even do that. The only thing left in Hy to penetrate deep nesting is to raise an exception.\n\nI think a neat idea would be to have metadata inside functions. ...\n\nIf that's the only way I get multiple exits, I can live with that, but I still like either of my proposals better than this. Metadata has to live somewhere. More runtime overhead I suppose. Python already allows getattr/setattr for functions, so you can store metadata that way. It seems like a better, more Pythonic approach than tacking on a new Clojure-style metadata system. \n. Thus spake @paultag:\n\nMy main objection is not ascetic. Two ways to do something is something I'd\nprefer to avoid :)\n\nOr as stated in the Zen of Python:\n\nThere should be one-- and preferably only one --obvious way to do it.\n\nIf you're willing to break this rule, you get Perl. I get it. \nWe should be very reluctant to add feature bloat, and should remove as much cruft as we can given this rare opportunity to break API. But don't forget, Hy is a Lisp. There's a lesson we've learned from the history of Scheme: the users will build what they need (using macros if necessary!) when the language doesn't have it--in a myriad of incompatible ways! There should be one-- and preferably only one --obvious way to do it. Zero is not one either.\nI think we should be very cautious about deciding to diverge from Python itself. We're dependent on Python. Python does add features from time to time--features that may depend on existing Python syntax, like return.\nIf Python gets too far past us, Hy becomes more and more obsolete as new software is written that depends on these features that Hy can't use. Why use Hy at all when we already have Common Lisp, Scheme, and Clojure? The main reason: Hy is a Lisp that can work with Python's libraries as easily as its own. Hy must be able to do anything Python can to remain relevant. Anything Python can do that Hy can't do is a reason not to use it. Sometimes it only takes one good reason. Hy doesn't have a big enough ecosystem to compete on its own.\nThose are the principles. I'm less certain about the solution, but I'm open to ideas.\nMy best idea so far: Add a return form. Keep lambda's implicit return as-is, and disallow return directly inside a lambda, even when Hy translates it to multiple statements. Add a deflambda with the same rules. Require an explicit return in fn/defn, and allow Python's None return to happen if an explicit return isn't provided.\n- Python's lambda already has an implicit return, so this is familiar to Python users.\n- We don't have to remember to return nil when defining a method like __init__, or rely on fragile automagic to do it for us.\n- generators don't break in older Python versions when Hy decides to automatically insert a return in a function that already contains yield.\nIt's a little troubling that the special-case syntax fn (requiring return) is shorter than the common case lambda. There's always more than one way to do it, but we can make the preferred method more obvious. For example, we could rename lambda to ^ and defn to define-function or something like that.\n. > Would it be stupid idea to have a separate form, like defn-r that would require explicit return?\nThat's pretty much what I suggested before with different names, though to be clear, the explicit-return form would still allow Python to implicitly return None. It would still compile without a (return) and Hy wouldn't insert a return statement.\n. Another option:\nKeep the implicit tail return, but modify the compiler to suppress the return statement if pass is in the tail position. Add a (return ...) form to Hy that inserts a return ... statement. Thus both an implicit and explicit return could happen in the same form.\nIt's not that confusing; other languages (like Rust) have both explicit and implicit returns. I don't think an optional explicit return is any worse than the optional explicit yield we have now. No way we're getting rid of yield.\n. Three's a quorum/three's a veto. Unless someone has a better idea, we can push this through. \nBut how exactly is this supposed to compile? I don't think Hy has ever had a pass form. It's obvious when there's only one exit, but what if there are multiple tails, like this?:\nHy\n(defn foo [x]\n  (if x\n    pass\n    \"spam\"))\nI think this is a sensible output:\nPython\ndef foo(x):\n    if x:\n        pass\n    else:\n        return 'spam'\nBut, given the way Hy already works it might be easier to do this:\nPython\ndef foo(x):\n    if x:\n        pass\n        _hy_anon_var_1 = None\n    else:\n        _hy_anon_var_1 = 'spam'\n    return _hy_anon_var_1\nBut we still need to suppress the return when pass appears in all of the tails:\nHy\n(defn foo [x]\n  (if x\n    pass\n    pass))\nPython\ndef foo(x):\n    if x:\n        pass\n        _hy_anon_var_1 = None\n    else:\n        pass\n        _hy_anon_var_1 = None\nNow we have a wasted assignment. Hy already seems to do that though.\n. @Tritlo, @larme: @Kodiologist claims this has been resolved, so I'll close this for now, but if it's not resolved, I can re-open it.\n. @jaredly, I agree it's surprising behavior and should be corrected. You can override built-in Python functions in Python.\n``` Python\n\n\n\nsum\n\nsum = 1\nsum\n1\n```\n\n\n\n@kirbyfan64: Given that Hy is a Lisp-1 without Clojure's namespaces, and without Scheme's Hygienic macros either, I can see why you think the ability to override builtins is a really bad idea:\nHy\n=> (defmacro sums [&rest xs] `(sum ~xs))\n=> (sums 1 2 3)\n6\n=> (def sum 1)\n=> (sums 1 2 3)\nTraceback (most recent call last):\n  File \"<input>\", line 1, in <module>\nTypeError: 'int' object is not callable\n=>\nBut actually, Python's functions have the same issue:\n``` Python\n\n\n\ndef sums(*xs):\n...   return sum(xs)\n...\nsums(1,2,3)\n6\nsum = 1\nsums(1,2,3)\nTraceback (most recent call last):\n  File \"\", line 1, in \n  File \"\", line 2, in sums\nTypeError: 'int' object is not callable\n```\n\n\n\nPython doesn't have true globals, only module-level globals. Redefining builtins won't break functions using them from another module. Macros are different since they expand into code executed in the present module. This is a good argument for adding something like Clojure's namespace qualification in syntax quotes (probably using Python's module system), but it's not such a good argument against redefining builtins.\nHy also disallows reassignment of special forms:\n``` Hy\n=> (def if 1)\n  File \"\", line 1, column 6\n(def if 1)\n       ^-^\nHyTypeError: b\"Can't assign to a builtin: `if'\"\n=>\n```\nBut at least it gives you a clear error messsage instead of failing silently like the example in the op.\nIn Clojure, you don't even have to include the core (builtins) in a new namespace (module).\n. Does Hy always import everything in every script, or only the things it needs for that script? hy2py doesn't, but I'm not certain about Hy internally. Would this noticeably impact repl startup time? Even on a mobile device?\nIf we do do everything up front, then hy --spy won't show the imports happening? Or will it only show from hy.core.language *? This seems less useful for learning about how Hy works than your first idea.\nI wonder if there's a way to make hy.core.language work more like Python's __builtins__?\n. I'm also concerned about how this might affect Hy's ability to support doctests #1019. We might need to be able to eval (exec?) Hy code from strings to make this work.\n. Python's builtins are in the builtins module. This module is mutable, though altering it is frowned upon. If we put all of Hy's core into builtins, then they would be available in every module. There's a lot to like about this approach. It would fix this issue, for one thing. It would remove the weird autoimports in the compiler. It could make macros more reliable. It would also make Hy's core more discoverable, since you could find everything in __builtins__ with dir. It's an option that we should seriously consider.\nBut I'm reluctant to do it that way. The problem is that importing hy from Python will pollute the builtins module for all other modules, even those written in Python. These are true globals, with all their problems. Projects that do this can interfere with each other if they try to set builtins with the same name. That's why most don't, and those that do get well-justified complaints.\nOne way to mitigate the damage would be to use Clojure-style namespacing of symbols. #277 We'd then only put HySymbols containing a / into builtins, which would be unlikely to interfere with any other Python use of the builtins module, since these are valid dict keys, but not valid Python identifiers. If you want the shorter alias without the /, then you simply def a shorter alias. We could even make a macro to automate this for a given namespace e.g. (using core) would def all core/foo symbols in builtins to foo in the current module (for whatever foo). But we'd write our macros to always use the namespaced / form so we don't have to depend on this.\nIt's a real option.\nBut there might be a way to create a hy_builtins module that works in Hy modules like builtins does for Python modules. Then we wouldn't have to have it at all on the Python side. I'm not exactly sure how Python modules are able to delegate to builtins when their own dict doesn't have a requested identifier. Maybe we could do it the same way.\nSuppose if all Hy modules had a custom dict implementation. It could override __getitem__ to delegate to hy_builtins whenever a symbol wasn't found in the module. One possible approach might be to subclass ModuleType to use this custom dict, and then use import hooks to make sure all loaded Hy modules are of this new type, before they are executed. I'm not sure how best to do this, especially considering how much import hooks have evolved over the Python versions we're still supporting.\nI was considering something like this anyway for dynamic variables #1089. With dynamic variables we could even have the *ns* var and implement something like Clojure's namespace macros and the cool features that come with it, like the auto-expansion of ~ to use namespaced symbols and ::foo for auto-namespaced keywords.. Let's turn to Clojure for guidance. Clojure is using Java's try/catch/finally exception system like Hy is using Python's try/except/finally statements.\nClojure\nuser=> (try :foo (catch Exception e :caught!)(finally (println \"FINALLY!\") :returned?))\nFINALLY!\n:foo\nuser=> (try (/ 0) (catch Exception e :caught!)(finally (println \"FINALLY!\") :returned?))\nFINALLY!\n:caught!\nWe see that the finally form is only evaluated for side effects as returned? is never returned. On the other hand, the catch form can return a value, as in the second example, but we would lose this if finally returned something else. So I also agree that finally ought not to return its value in Hy.\nI don't think Clojure has an equivalent of the optional else part, so that's no help. But consider that as with do/progn, try can evaluate multiple expressions for side effects and will return the value of the last one. If there are no exceptions raised, the else part is kind of a continuation of the try block in Python. Therefore, I would argue that in the usual case that no exceptions are raised, the try should evaluate to the value of the last expression in the else form (if present).\n. Wrapping statements into a function call might not be the right approach, because of the aforementioned scoping issues. Why not make Hy use a macro like this instead?\nLisp\n(defmacro -and [&rest args]\n  (cond [(empty? args) True]\n        [(cdr args) `(if ~(car args)(-and ~@(cdr args)))]\n        [True (car args)]))\nSome tests with hy --spy:\nPython\n=> (-and)\nTrue\nTrue\n=> (-and 0 (assert 0))\nif 0:\n    assert 0\n    _hy_anon_var_1 = None\nelse:\n    _hy_anon_var_1 = None\n=> (for [i (range 9)] (-and (= i 2)(break))(print i))\nfrom hy.core.language import range\nfor i in range(9):\n    if (i == 2):\n        break\n        _hy_anon_var_1 = None\n    else:\n        _hy_anon_var_1 = None\n    print(i)\n0\n1\nHy doesn't appear to introduce any unexpected scope issues this way. As with the proposed function wrapping, Hy need only use the macro when the arguments to and contains a statement, since the old behavior works correctly with expressions. It should be possible to implement or in a similar way.\n. When looking over this commit I noticed and and or have a minimum of 2 arguments, which is pretty strange for a Lisp. I opened a new issue #835 for this. This might be a good time to fix it.\n. Hm. If I'm reading this right, (or) now returns False? That's better than an exception, and is, in fact, how Scheme does it:\n``` Scheme\n;;; R5RS\n\n(or)\n\nf\n```\nI realize that interactive Python suppresses printing None while False doesn't have this problem:\n``` Python\n\n\n\nNone\nFalse\nFalse\n```\n\n\n\nBut now that we have a lisp-if/lif that only accepts nil as falsey, I think (or) must return nil instead of False for consistent behavior.\nOn the other hand, this might be a good argument for making lif accept both False and nil as falsey, (and nothing else) as Clojure does.\nClojure\n;;; Clojure\nuser=> (if false 'truthy 'falsey)\nfalsey\nuser=> (if nil 'truthy 'falsey)\nfalsey\nuser=> (if 0 'truthy 'falsey)\ntruthy\n. > Having (and) return true but (or) return false feels weird, IMO.\nThen why not change (or) to return nil anyway? Or did you mean \"(or) return nil feels weird\"? Because this is exactly how both Clojure and Common Lisp do it:\nClojure\nuser=> (or)\nnil\n``` Lisp\n* (or)\nNIL\n```\nCommon Lisp doesn't even have a false, just NIL.\nAnother special case to check:\nClojure\nuser=> (and nil)\nnil\nuser=> (and false)\nfalse\n. @kirbyfan64 Looks pretty good, though that compile function is getting long-winded. One minor nitpick: the hy2py output could be prettier if it compiled using elifs instead of deeply indenting blocks. Even if we're only using it for debugging purposes, readability helps. I don't know how much you guys care about that sort of thing at this point, but anyway it's much better than how it was before. @paultag @olasd thoughts?\nI would like to get this merged, but it's not really up to me.\n. Dunno, lemme check:\n``` Python\nPython 3.4.3 (v3.4.3:9b73f1c3e601, Feb 24 2015, 22:44:40) [MSC v.1600 64 bit (AMD64)] on win32\nType \"copyright\", \"credits\" or \"license()\" for more information.\n\n\n\nfrom ast import dump,parse\nw_elif = dump(parse(\"\"\"\nif x:\n    pass\nelif y:\n    pass\nelse:\n    pass\n\"\"\"))\nno_elif = dump(parse(\"\"\"\nif x:\n    pass\nelse:\n    if y:\n        pass\n    else:\n        pass\n\"\"\"))\nw_elif\n\"Module(body=[If(test=Name(id='x', ctx=Load()), body=[Pass()], orelse=[If(test=Name(id='y', ctx=Load()), body=[Pass()], orelse=[Pass()])])])\"\nno_elif\n\"Module(body=[If(test=Name(id='x', ctx=Load()), body=[Pass()], orelse=[If(test=Name(id='y', ctx=Load()), body=[Pass()], orelse=[Pass()])])])\"\nw_elif == no_elif\nTrue\n```\n\n\n\nI think it doesn't.\nSounds like a separate issue then. I wonder if this can be fixed easily in the pretty printer. \nI have no further objections. I can haz merged?\n. Wait, it does print elifs? Or it's already supposed to? Are we talking about the same version here?\nhy --spy\n=> (if 0 \"zero\" (if 1 \"one\" (assert 0)))\nif 0:\n    _hy_anon_var_2 = 'zero'\nelse:\n    if 1:\n        _hy_anon_var_1 = 'one'\n    else:\n        assert 0\n        _hy_anon_var_1 = None\n    _hy_anon_var_2 = _hy_anon_var_1\ncond is no better\n=> (cond [0 \"zero\"]\n...      [1 \"one\"]\n...      [True (assert 0)])\nif 0:\n    _hy_anon_var_3 = 'zero'\nelse:\n    if 1:\n        _hy_anon_var_2 = 'one'\n    else:\n        if True:\n            assert 0\n            _hy_anon_var_1 = None\n        else:\n            _hy_anon_var_1 = None\n        _hy_anon_var_2 = _hy_anon_var_1\n    _hy_anon_var_3 = _hy_anon_var_2\nWe just established that the AST should be the same as if I had used an elif, yes? I don't see an elif in the \"Python\" hy --spy got from the AST. There could have been an elif 1: line there.\n@kirbyfan64 can you show us the hy --spy output of your new or form with several arguments, including a statement? Something like (or 0 false nil \"\" (,) [] (assert true))? Let's see an and form too.\n. You're right, of course. I see it now. There couldn't have been an elif 1: line as written. I'm still not sure how the or form turns out though.\n. In the case of the if and cond forms, the problem is indeed in Hy's AST, not the pretty printer.\nI think Hy could have done this instead with the same effect:\n=> (cond [0 \"zero\"]\n...      [1 \"one\"]\n...      [True (assert 0)])\nif 0:\n    _hy_anon_var_1 = 'zero'\nelif 1:\n    _hy_anon_var_1 = 'one'\nelse:\n    assert 0\n    _hy_anon_var_1 = None\nPresumably, the current version was easier to implement. It does result in some wasted assignments though.\n. @kirbyfan64 @olasd @paultag Are we good to merge this now, or do you guys want to deal with #842 first? Even if the AST is a little ugly at this point, it does seem to short-circuit statements as expected, which fixes a pretty serious problem. We can clean it up later.\n. I have one more suggestion, perhaps for later, and more related to #842. Even in the case that and/or contains a statement, it may have several expressions in a row that don't need to be converted to if branches. Hy could avoid redundant assignments by keeping those runs as expressions and only assigning the result to an anonymous variable.\n. For example:\nPython\n(print (and 1 2 3 (setv x 1) 4 5 6))\n_hy_anon_var_1 = 1 and 2 and 3\nif _hy_anon_var_1:\n    x = 1\n    _hy_anon_var_1 = x and 4 and 5 and 6\nprint(_hy_anon_var_1)\n. @algernon good enough for me. Opened #854\nLet's merge this already.\n. I'll submit another one for the ratio literals.\n. I opened #826 Ratio Literals.\n@kirbyfan64 I don't think we need a new divide operator, since Python's fractions aren't exactly the same as Lisp ratios anyway:\nClojure\n;;; Clojure\nuser=>(/ 3 1/2 )\n6N\nNotice it was coerced into an integral type (I think that's a BigInt? I'm still learning Clojure).\n``` Python\nPython\n\n\n\n3 / Fraction(\"1/2\")\nFraction(6, 1)\n```\n\n\n\nNotice it's still a Fraction.\nI think it should work like this:\n=> 1/1\nFraction(1, 1)\n=> (/ 1/1 2)\nFraction(1, 2)\n=> (/ 1 2)\n0.5\nThe 1/1 is an \"atom\" not an operation.\n. I would suggest a literal syntax for Fraction \"atoms\" (oxymoron?). Like so:\n; >>> # Python equivalents\n; >>> Fraction(\"1/1\")\n=> 1/1\nFraction(1, 1)\n; >>> Fraction(\"1/2\")\n=> 1/2\nFraction(1, 2)\n; >>> Fraction(\"2/4\")\n=> 2/4\nFraction(1, 2)\n; >>> 2 * Fraction(\"-1/2\")\n=> (* 2 -1/2)\nFraction(-1, 1)\nAny symbol with an included / that has valid integers on either side would be passed to the Fraction constructor as a string behind the scenes. Fraction will have to be automatically imported if used.\n. I believe #828 addresses this. I'm closing it.\n. > note that Hy does support docstrings\nYes, I gathered from the hy2py output that the reason my docstring attempt failed was that the triple quoted string was instead interpreted as three strings and thus the docstring was actually empty. Sorry for not being clear. This is obvious to anyone who can read Python, but you couldn't assume I knew that. I shouldn't have assumed that everyone knew that I knew. Phew.\nI was merely suggesting that there should be a note of this in the documentation, because it could confuse other Python programmers the same way.\n\nI agree that your last example looks like a bug in the REPL\n\nPerhaps just in the reader? It doesn't have to be in interactive mode. I attempted to use hy2py on a file containing the offending string. It failed because the string wasn't terminated. Hy seems to consider this a syntax error, but I think we can agree this is not the expected behavior. This seems to happen anytime a newline immediately follows a backslash in any Hy string literal. As a workaround you could use a \"\\n\" after the backslash, but, of course, this doesn't work in raw strings.\n. > I was merely suggesting that there should be a note of this in the documentation\nOn second thought, I think hy --spy and disassemble should be more prominent in the documentation instead. The docstring problem was immediately obvious once I saw the Python Hy generated.\n\n(it would be redundant, because newlines are allowed in ordinary string literals)\n\nNewlines aren't the only reason to have triple quotes. It also lets you insert ' and \" without escapes:\nPython\n\"\"\"He said, \"It doesn't work in Hy.\".\"\"\"\nIt isn't possible to avoid these escapes in Hy.\nPython will also concatenate adjacent string literals:\n``` Python\n\n\n\n\"He \" \"said, \" '\"It ' \"doesn't work in \" 'Hy.\".'\n'He said, \"it doesn\\'t work in Hy.\".'\n('A line that is much too long to fit on one line, '\n \"doesn't actually have to fit on one line\")\n\"A line that is much too long to fit on one line, doesn't actually have to fit on one line\"\n```\n\n\n\nUnlike + between strings, this happens at read time, not run time. Hy can't do this either.\nI think Hy's string literal support could be better. It's not up to Python's level. Triple quotes are one option, but we could do even better by supporting arbitrary strings as terminators, like in Perl or C++. I've also seen this done in Common Lisp with reader macros, but Hy's reader macro's aren't powerful enough to do it.\nBut what's most concerning here is that I reported a bug in Hy months ago but it seems to have been completely forgotten.\n. I didn't mean to pick on you in particular, Zack. I'd be inclined to fix it myself if I understood Hy's internals better. Most of the other minor issues like this that I filed around the same time have already been dealt with.\nI assumed that bugfixes like this were higher priority than new features. When that didn't happen I thought it was my fault for writing a meandering OP that took too long to get to the point. I shouldn't have included the surprising lack of triple quotes in the first place--it's distracting from the more important reader bugfix. It seemed that none but you, Zack, noticed my main point. I tried to correct my error (and, perhaps, get the attention of a third party better prepared to assist) with a more focused title (twice).\nPerhaps I should just close this issue and replace it with a better-written one.\n. > Also, it's not your writing style.\nThanks, Kirby, that makes me feel better.\nIt doesn't just affect the REPL though. Try putting a string like that in a .hy file and see what happens. That's why I thought it was in the reader (lexer?) and not just the REPL.\n. Thanks, that's exactly what I was looking for. My inferior-lisp is now using hy --spy. \nI didn't realize github can't render .rst files or I might have seen it before.\n\n. Yes I see it now. I have some reading to do.\n. And the Unary case too.\n. Or it could return false. I'm not sure if that's better, but I do think crashing the string? predicate on such a common datatype is the wrong answer. Python is duck-typed; no static type checking. Sometimes you have to check these things at runtime to avoid causing errors. Therefore the act of checking should not itself cause errors. It's also not at all unusual when writing Lisp macros to step through a list and do different things depending on what type of element you find.\n. @Kodiologist yup, you've convinced me. Keywords in Hy function calls behave differently than in other Lisps, since it gets translated into a Python keyword argument. If you actually want to pass a keyword as data to a function in Hy (unlike other Lisps) you have to quote it.\nHy\n=> (string? ':keyword)\nfrom hy.core.language import is_string\nfrom hy import HyKeyword\nis_string(HyKeyword('\\ufdd0:keyword'))\nTrue\nThis behavior of keywords is in function calls what needs to be documented more clearly, since in other Lisps keywords always evaluate to themselves and thus are self-quoting. The string? function is fine as-is.. Duplicate of #647. I thought #920 was supposed to fix this, but it seems to be broken again. After that PR, we had\nPython\n=> (if 1 1 (if 2 (setv x 2) (if 3 3)))\nif 1:\n    _hy_anon_var_1 = 1\nelif 2:\n    x = 2\n    _hy_anon_var_1 = x\nelse:\n    _hy_anon_var_1 = (3 if 3 else None)\nBut now, on master,\nPython\n=> (if 1 1 (if 2 (setv x 2) (if 3 3)))\nif 1:\n    _hy_anon_var_2 = 1\nelse:\n    if 2:\n        x = 2\n        _hy_anon_var_1 = None\n    else:\n        _hy_anon_var_1 = (3 if 3 else None)\n    _hy_anon_var_2 = _hy_anon_var_1\n_hy_anon_var_2\n1\nThough now we'd use => (if 1 1  2 (setv x 2)  3 3), which compiles exactly the same way.\nThis seems like a regression that our testing didn't catch. @kirbyfan64 do you know what happened here?. That doesn't seem right. The equivalent cond has also regressed:\nPython\n=> (cond [1 1] [2 (setv x 2)] [3 3])\nif 1:\n    _hy_anon_var_2 = 1\nelse:\n    if 2:\n        x = 2\n        _hy_anon_var_1 = None\n    else:\n        _hy_anon_var_1 = (3 if 3 else None)\n    _hy_anon_var_2 = _hy_anon_var_1\n_hy_anon_var_2\nBut #962 didn't touch cond, nor the compiler--it just added a macro in bootstrap? Wait, no, it renamed if to if* in the compiler. If you were checking for an if, in the compiler, it should look for if* now.. Special-casing a macro name seems bad. It might be better to move if into the compiler. But then, how did cond work before? Maybe we could re-implement cond in terms of pure if* and if in terms of cond?. Or maybe we could rewrite the if macro to be non-recursive. That might be easier. But then what if the user wanted to implement his own branching macro based on if*? It won't be named if in that case. Maybe the compiler needs to expand macros first. Or maybe it's easier to just move it into the compiler. Hmm.. Actually there's a really easy way to make that unnecessary: Drop support for Python 2. Not saying we should necessarily, but Python2 is supposed to go away eventually anyway.\n. > One alternative is to provide let to preserve backwards compatibility, but fully document that it's mostly broken and why it is unlikely that a real let will never exist, and not use it in any example code.\nA major failure mode for design-by-committee (historically) has been cruft. That's why C is a pretty good language, but C++ is crazy scary. Also compare Common Lisp to Clojure. Languages with a single designer or benevolent dictator don't have such a cruft problem. Compromise leads to compromised language. I think the move to Python 3 was a good thing because it got rid of cruft. But it did cause some other problems (putting it mildly). Mainly because there was so much software written in Python 2 already. That means the best time to clean up cruft in Hy is as soon as possible. While we're still in alpha and not too much depends on the current version of the language. (We are still in alpha, right?)\nIt already bothers me that Hy has so much duplication polluting the default namespace because it's trying to be Clojure and Common Lisp (and Python) at the same time. We don't need both do and progn etc. do alone will do. We don't need both True and true. We can put Python first, it's True. Hy does not need to be compatible with Clojure or Common Lisp, and certainly not both.\nIf we want to take the route of deprecating let as you suggest, can we at least move it out of Hy's core, and into a contrib. library or something? It would take a simple import statement to fix the old scripts. We could do the same for the other duplication and keep Hy's core simpler.\n\nOr just implement it as a convenience macro for setv'ing a bunch of variables. It's just Python under the hood.\n\nBetter yet, just extend setv to work on multiple pairs simultaneously. In Common Lisp, setf already does this. (quoting from the hyperspec)\nLisp\n(setf place-1 newvalue-1\n       place-2 newvalue-2\n       ...\n       place-N newvalue-N)\nis precisely equivalent to\nLisp\n (progn (setf place-1 newvalue-1)\n        (setf place-2 newvalue-2)\n        ...\n        (setf place-N newvalue-N))\nWe could make setv work the same way:\n(setv spam 1\n      eggs 2\n      bacon 3)\nspam = 1\neggs = 2\nbacon = 3\nbacon\nPython can already do simultaneous assignment using tuples. So we can already do something similar to psetf like this:\n(setv (, spam eggs bacon) (, 1 2 3))\n(spam, eggs, bacon) = (1, 2, 3)\n(spam, eggs, bacon)\nIn many cases the parallel/sequential distinction makes no difference though and we already have tuples.\n. I was (and am) honestly not certain if getting rid of let is a good idea to begin with. But I'm also not certain it's a bad one. I have proposed some fixes, after all. I do think we have a better chance of creating a sane let implementation if we keep in mind the viable alternative of not having one at all. Especially the costs of using any kind of let as compared to the more natural (for Python) setv. \nCosts include implementation/maintenance work, user confusion, and performance issues from making Python do extra things to simulate simple things it was never designed for.\n. @agentultra \n\nIf we come up with a progn implementation we could do it but I suspect we\u2019ll have to eval code in the enclosing lexical scope and that might make some Python programmers uncomfortable (even though we use eval in some of the builtin libs\u2026). It also might make us uncomfortable since Python\u2019s eval takes strings\u2026 :(\n\nPython's eval doesn't cut it. It only does expressions, not statements. You need exec. Also, these don't have to take strings. They work on code objects, which we can compile() from AST.\n. Clever, but no. A finally/del is nowhere near a proper let, because it breaks closures. For example:\n``` Lisp\n; Common Lisp\n (defvar foo\n    (let ((counter 0))\n      (lambda () (incf counter))))\n (funcall foo)\n1\n* (funcall foo)\n2\n* (funcall foo)\n3\n*\n```\nNow let's try that with finally/del in Python.\n``` Python\n\n\n\ntry:\n    counter = 0\n    def _hy_anon_fn_1():\n        global counter\n        counter = counter + 1\n        return counter\n    _hy_anon_var_1 = _hy_anon_fn_1\nfinally:\n    del counter\nfoo = _hy_anon_var_1\nfoo()\nTraceback (most recent call last):\n  File \"\", line 1, in \n    foo()\n  File \"\", line 5, in _hy_anon_fn_1\n    counter = counter + 1\nNameError: name 'counter' is not defined\n```\n\n\n\nYou see the problem? If this were in a function we could use nonlocal instead of global, but it still wouldn't work. And let is allowed outside of functions.\n. The documentation indicates that with-gensyms depends on let, should we rework this to use setv instead, or should we remove with-gensyms to the contrib. shim as well?\n. > My plan is to have a let, that follows python scoping rules.\nWouldn't redefining let like that collide with the same name in the planned contrib shim?\n. Which would mean any macro expecting the new let now expands to the old shadowed version in any context where the shim has been imported. Clojure has symbol namespaces and fully qualifies quasiquoted symbols to avoid this sort of problem, but to my knowledge Hy has no such protection.\n. After #1352, I want to think about this some more. Keywords as (invalid) strings are kind of weird. They're awkward in macros. Leaking \\ufdd0 into Python isn't that nice either. A proper object would be better-behaved even in Python. We can already leak HySymbols but without much issue.\n\nThe other alternative is to not have keyword objects. Python doesn\u2019t have keyword objects.\n\nI think Python could have used a good symbol type. But keywords on top of that actually don't seem that useful in Hy. But then how would kwargs work? Clojure does have a separate keyword type, but in other Lisps, keywords are just symbols that start with :, and these are special-cased to evaluate to themselves. We can still have a predicate to tell if a symbol starts with :.\nUnifying keywords and symbols would probably simplify the compiler and macros.\nWe could also make symbols callable, so (foo {'foo 42}) would call the function named by foo, but ('foo {'foo 42}) would call the symbol itself and return 42. Clojure actually does this. But since keywords would just be self-evaluating symbols, (:bar {:bar 42}) would also work.\n. > Is there a reason we can't just make it a compile error to use keywords outside of a keyword context or macro?\nI don't understand how that could possibly work.\nHy can use keywords to name kwargs in function calls, and as control words special forms, like :as in import. These won't always follow the same key/value format used by kwargs. See, for example, #1371 which can usefully repeat the same keyword multiple times in a list.\nMacros should at least be able to do the same as special forms.\nMacros must be able to build any HyExpression. And we have to have some object to represent keywords for macros to be able to build HyExpressions that contain keywords. And they have to be first class. That is, functions must be able to take these keyword objects as arguments and return one as a result, or macros won't be able to delegate work involving them to functions. The only way to avoid this is to get rid of keywords altogether. But then how do you write Python kwargs in Hy? We need that for interop.\nWe could use a separate HyKeyword Hy model type, following Clojure, or we could make it a special case of HySymbol somehow, like Emacs Lisp and Common Lisp do.. Now that #1543 is merged, what do we think about making them callable like in Clojure? We can do the same for symbols, but strings and displays would be harder, requiring compile-time hacks that might not even work that consistently #963. An alternative might be a tag macro that makes the basic collections callable. E.g.\n``\n=> (deftag ? [form](. ~form getitem))\nfrom hy import HyExpression, HySymbol\nimport hy\nhy.macros.tag('?')(lambda form: HyExpression([] + [HySymbol('.')] + [form] +\n    [HySymbol('getitem')]))\n at 0x0000019D4FB927B8>\n=> (#?[10 11 12] 2)\n[10, 11, 12].getitem(2)\n12\n=> (tuple (map #?[10 11 12] [1 0]))\ntuple(map([10, 11, 12].getitem, [1, 0]))\n(11, 10)\nOf course, this would make a string work like a list of characters.\n=> (#?\"spam\" 2)\n\"\"\"spam\"\"\".getitem(2)\n'a'\n```\nWhich may or may not be what the user expects. Strings are not callable in Clojure, unlike symbols and keywords.\nBut if keywords become callable, perhaps they could look up the equivalent string instead of itself?\n```\n=> (:spam {\"spam\" 1  \"eggs\" 2})\nHyKeyword('spam')({'spam': 1, 'eggs' 2})\n1\nBut since a symbol is-a string in Hy, if we make symbols callable, they'll do that naturally. So keywords could be restricted to looking up keywords as in Clojure. Another option is to make HyString callable. This way you can use a string literal as a lookup function if you quote it.\n=> ('\"spam\" {\"spam\" 1  \"eggs\" 2})\nHyString('spam')({'spam': 1, 'eggs' 2})\n1\n```. Ah, yep. That does make them seem a bit less convenient as functions, since that would be easy to forget. Until you do it a lot. But it would certainly be possible to pass them to higher-order functions.\nBut I think we're already using a compile-time hack to make them seem callable.\n```\n=> (:a {:a 1  :b 2})\nfrom hy import HyKeyword\n{HyKeyword('a'): 1, HyKeyword('b'): 2}[HyKeyword('a')]\n1\n```\nI think we could remove that special case from the compiler without losing the functionality if keywords were properly callables.\nIt seems weird that the above works, but not as higher-order functions and not with symbols.\nI'm not sure how useful keyword-keyed dicts are in Hy anyway. Python nearly always uses strings for this kind of thing. Maybe it's a bit easier to type, but I'm not really seeing an advantage over using symbols, which count as strings anyway.. Sorry guys, but I've mislead you. After further research I'm going to have to revise my recommendation. It's actually harder than I thought.\n``` Python\n\n\n\ndef expensive_generator():\n    print('churn!')\n    yield 1\n    print('chug!')\n    yield 2\n[(x,y) for x in range(10) if x%5 == 0 for y in expensive_generator()]\nchurn!\nchug!\nchurn!\nchug!\n[(0, 1), (0, 2), (5, 1), (5, 2)]\n[(x,y) for x in range(10) for y in expensive_generator() if x%5 == 0]\nchurn!\nchug!\nchurn!\nchug!\nchurn!\nchug!\nchurn!\nchug!\nchurn!\nchug!\nchurn!\nchug!\nchurn!\nchug!\nchurn!\nchug!\nchurn!\nchug!\nchurn!\nchug!\n[(0, 1), (0, 2), (5, 1), (5, 2)]\n```\n\n\n\nSame answer, but so much less efficient. The programmer must be allowed to insert the predicates as soon as possible in comprehensions. As Hy is now, the predicate is always at the end, even if there are multiple for terms. With my original proposal, multiple predicates are allowed, but all the predicates have to be at the end. This is unacceptable.\nSome possibilities:\n; look ma, no brackets!\n(list-comp (, x y) \n           x (range 10) :if (= 0 (% x 5))  ; one :if per predicate. Kinda like Python.\n           y (expensive_generator))\n; we'll just be explicit. Really looks like Python.\n(list-comp (, x y) \n           :for x :in (range 10) :if (= 0 (% x 5))  ; the :in seems so pointless. Use :for-in ?\n           :for y :in (expensive_generator))\n; a la Clojure?\n(for-list  ; also for-set, for-dict and for-each?\n  [x (range 10) :when (= 0 (% x 5))  ; can we do a :while by raising StopIteration or something?\n   y (expensive_generator)]\n  (, x y))  ; kinda less confusing at the end, but not how Python does it. Nor mathematicians.\n. The :if isn't really necessary, is it?\nHy\n(list-comp (, x y) [x (range 10) (= 0 (% x 5))]  ; [target iterable &rest predicates]\n                   [y (expensive_generator)])\nI think the above is not bad, but something more like Clojure, except with Python ordering and words seems better:\nHy\n(list-comp (, x y)\n  [x (range 10) :if (= 0 (% x 5))\n   y (expensive_generator)])\nBut then, what are those brackets even doing? There's no implicit do in comprehensions; it's just one expression. And we're back to my first option:\nHy\n; look ma, no brackets!\n(list-comp (, x y)\n  x (range 10) :if (= 0 (% x 5))\n  y (expensive_generator))\nAfter you trivially pop the (, x y) off the front of the arguments list, you're parsing exactly the same structure Clojure does. Clearly this is doable, because Clojure does it. The arguments are the same order as the Python, and I assume, the AST. Just step through the list. I don't know what more highlighting you expect than what's already showing in this comment.\n. You can easily cut the first clause with paredit: (the | is the cursor)\nHy\nx (some-expression-that-makes-the-line-long-enough-t\no-wra|p 10) \n; slurp backward (C-(), now paredit handles it just the same.\n(x some-expression-that-makes-the-line-long-enough-t\no-wra|p 10)\n; backward-up-list (C-M-u)\n|(x some-expression-that-makes-the-line-long-enough-t\no-wra|p 10)\n; kill-sexp (C-M-k)\n|\n; move, then yank (C-y)\n(x some-expression-that-makes-the-line-long-enough-t\no-wrap 10)|\n; left, barf backward (C-{)\nx (some-expression-that-makes-the-line-long-enough-t\no-wrap 10|)\nWasn't hard. hy-mode not required. This is even easier with evil-mode when you can just da( to kill the sexp without moving the cursor.\nThe first predicate works the same way:\nHy\n:if (= 0 (% x 5))\n; backslurp\n(:if = 0 (% x 5))\n; etc\n\nOne of the reasons I prefer brackets & parens around distinct parts of an expression is because it makes it easier to navigate the source programmatically.\n\nYou're not the first to tell me that, but the community seems to prefer Clojure-like forms over Common-Lisp-like forms. There are a lot of other places in the language we could add (or keep) the extra []. I don't like the visual clutter, and it's harder to remember how to produce a nested form than a flat one.\nThe ideal [] form by the programmatic argument seems to be:\nHy\n(list-comp (, x y)\n  [x (range 10)]\n  [:if (= 0 (% x 5))]\n  [y (expensive_generator)])\nThe :if is required to distinguish the predicates from the for clauses. Now it's just pairs.\nBut if we write it like this:\nHy\n(list-comp (, x y)\n  x (range 10)\n  :if (= 0 (% x 5))\n  y (expensive_generator))\nThen it's trivial to transform it back into the [] pairs with (partition 2 coll) whenever you have to manipulate it programmatically.\nWhat? Hy doesn't have partition?\nHy\n(defn partition [n coll]\n  (->> coll (iter) (,) (* n) (apply zip)))\nDoes now.\nThe reverse operation, flattening one layer, is also trivial with itertools.chain.\n. @kirbyfan64 This is supposed to be sequential, right? Can you add a test something like \n(setv y False\n      x True\n      y x)\n(assert y)\n. @paultag I don't think we need braces here.\n. (defclass Cat []\n  --doc-- \"Kitty kat says Meow\"\n  age None\n...)\nJust pointing out that the brackets are not required for docstrings. \nWhich is better? I don't know. \n--doc-- is five whole characters longer than the [] we just got rid of. It's arguably the more common case to have docstrings in classes than not. It's also more consistent with functions to have an implicit --doc-- instead of an explicit assignment.\nOn the other hand, \n    Explicit is better than implicit.\n    Simple is better than complex.\n    Flat is better than nested.\n    Special cases aren't special enough to break the rules.\nOnce you start using macros to define classes anyway, isn't it just easier not to deal with the special cases?\nI honestly hadn't thought of the docstrings when I made that simplification. I wonder if I'm missing anything else. Do class declarations in Python do anything else special (i.e. that isn't like an assignment)?\n. Doesn't --init-- look equally terrible? We're not getting around that one, are we? I don't think it looks that bad though.\n. I'm beginning to think that the entire defclass form is flawed. It's too different from the way Python does it to fit well.\n``` Python\n\n\n\nclass definitions can have side effects\nclass C:\n    print('side effect!')\n\n\n\nside effect!\n\n\n\ncan contain loops\nclass C:\n    for i in range(3):\n        print(i)\n\n\n\n0\n1\n2\n\n\n\nC.i\n2\ncan clean up with del\nclass C:\n    for i in range(3):\n        print(i)\n    del i\n\n\n\n0\n1\n2\n\n\n\nC.i\nTraceback (most recent call last):\n  File \"\", line 1, in \n    C.i\nAttributeError: type object 'C' has no attribute 'i'\ncan refer to outer scope\ndef foo():\n    spam = 42\n    class C:\n        nonlocal spam\n        spam = 24\n    print(spam)\nfoo()\n24\neggs = 2\nclass C:\n    global eggs\n    eggs += 1\n    print(eggs)\n\n\n\n3\n\n\n\neggs\n3\ncan catch exceptions without failing\n1/0\nTraceback (most recent call last):\n  File \"\", line 1, in \n    1/0\nZeroDivisionError: division by zero\nclass C:\n    try:\n        1/0\n    except ZeroDivisionError:\n        pass\n    msg = \"still good!\"\nC.msg\n'still good!'\ncan build differently on conditions\ndef makeC():\n    class C:\n        if raining:\n            __umbrella = True\n        else:\n            __sunglasses = True\n    return C\nraining = True\ndir(makeC())\n['_C__umbrella', 'class', 'delattr', 'dict', 'dir', 'doc', 'eq', 'format', 'ge', 'getattribute', 'gt', 'hash', 'init', 'le', 'lt', 'module', 'ne', 'new', 'reduce', 'reduce_ex', 'repr', 'setattr', 'sizeof', 'str', 'subclasshook', 'weakref']\nraining = False\ndir(makeC())\n['_C__sunglasses', 'class', 'delattr', 'dict', 'dir', 'doc', 'eq', 'format', 'ge', 'getattribute', 'gt', 'hash', 'init', 'le', 'lt', 'module', 'ne', 'new', 'reduce', 'reduce_ex', 'repr', 'setattr', 'sizeof', 'str', 'subclasshook', 'weakref']\ncan do internal imports\nclass C:\n    import re\nre\nTraceback (most recent call last):\n  File \"\", line 1, in \n    re\nNameError: name 're' is not defined\nC.re\n\ncan contain nested inner classes\nclass C:\n    class D:\n        spam = 42\nC.D.spam\n42\n```\n\n\n\nBasically, a lot of what we miss for want of proper let, we could do with Python classes. But I can't do ANY of this with defclass!\nWe don't need special square bracket syntax for setting attributes. setv can do multiple pairs now. Just use one of those.\n(defclass Cat []\n  \"docstring\"\n  (setv age None\n        colour \"white\")\n  (defn speak [self] \n    (print \"meow\"))\n. Typically, the only shared class attributes are the methods. While it's common for Python classes to have instance variables assigned in __init__, it's relatively rare to have class variables shared by all instances (shared variables are not particularly object-oriented).\nIs it really worthwhile to have a special syntax for such an uncommon case? My vote would be for the class that doesn't do much sugar, and forget about the macro on top of that.\n. @algernon I like this suggestion. I had actually considered it before settling on the :as proposal, partially for consistency with import.\nThe _ isn't a good choice though. I know it's commonly used as a dummy variable in other languages. In Prolog and Lua, for example. It's not such a good choice in Python, however. In the Python shell, _ is like * in the Common Lisp repl or *1 in Clojure's repl. It's the value of the last input.\nHow about this instead:\n(with [arg (expr)\n       nil (expr)]\n  block)\nRather than insert junk into the AST because Hy requires a variable we're not going to use, (be it _ or otherwise), the nil will make it clear that no assignment is being made. Since obviously you can't assign to nil. It's a literal. This may lengthen the implementation just a little bit, but it's not hard to check a list for nils.\n. For comparison, this is what Hy is doing currently to the above example. (#824 has been merged)\nHy\n=> (print (and 1 2 3 (setv x 1) 4 5 6))\n_hy_anon_var_1 = 1\nif _hy_anon_var_1:\n    _hy_anon_var_1 = 2\n    if _hy_anon_var_1:\n        _hy_anon_var_1 = 3\n        if _hy_anon_var_1:\n            x = 1\n            _hy_anon_var_1 = x\n            if _hy_anon_var_1:\n                _hy_anon_var_1 = 4\n                if _hy_anon_var_1:\n                    _hy_anon_var_1 = 5\n                    if _hy_anon_var_1:\n                        _hy_anon_var_1 = 6\nprint(_hy_anon_var_1)\n6\nNotice there are eight assignments, but the optimized version only needs three.\n. I guess the most obvious syntax would be.\n(defclass Foo [Parent :metaclass Meta :spam \"spam\"]\n...)\n. No, you can't put the args after the kwargs in a Python class definition, because it uses the same grammar rule as a function call. Why would we want to allow this in Hy? This would get even more confusing when you use more keywords. Let's just be consistent with Hy's function call syntax and do it the same way.\n. Maybe I should explain myself better. Metaclasses are really not that hard, but they're perhaps an arcane topic.\nIn Python, a class definition is just syntactic sugar for a function call:\n``` Python\nX = type('X', (object,), dict(a=1))\nsame as\nclass X(object):\n    a = 1\n```\nLike everything else in Python, classes are themselves objects, and they are returned by calls to type() (the 3-arg version; 1-arg just names the class).\nMetaclasses just let you change which function you're calling. Here we've changed the default metaclass--from type, to my_meta:\n``` Python\n\n\n\ndef my_meta(name,bases,namespace,**kwargs):\n    print(\"in my_meta!\")\n    print(name,bases,namespace,kwargs)\n    return \"Not even a class!\"\nclass foo(metaclass=my_meta):pass\n\n\n\nin my_meta!\nfoo () {'module': 'main', 'qualname': 'foo'} {}\n\n\n\nfoo\n'Not even a class!'\nclass foo(str, int, spam=\"spam\", metaclass=my_meta):pass\n\n\n\nin my_meta!\nfoo (, ) {'module': 'main', 'qualname': 'foo'} {'spam': 'spam'}\n\n\n\nmixing order not allowed!\nclass foo(str, metaclass=my_meta, int):pass\nSyntaxError: non-keyword arg after keyword arg\n```\n\n\n\nSee, just a function call. There is one more trick with the __prepare__ attribute:\n``` Python\n\n\n\nmy_meta.prepare = my_prepare_func\n```\n\n\n\nThis lets you call an additional function to pre-populate the class attributes before the class body statements are executed. This function also gets the same kwargs that the metaclass gets.\n. > No, you can't put the args after the kwargs in a Python class definition, because it uses the same grammar rule as a function call. Why would we want to allow this in Hy?\nTo answer my own question, it appears that Hy actually does allow positional arguments after keyword arguments.\nHy\n=> (defn test [arg &kwargs kwargs])\ndef test(arg, **kwargs):\n    pass\n=> (test :foo \"bar\" \"before\")\ntest('before', foo='bar')\nEven though this is expressly forbidden in Python:\n``` Python\n\n\n\ndef test(arg, **kwargs):\n    pass\ntest(foo=\"bar\", \"before\")\nSyntaxError: non-keyword arg after keyword arg\n```\n\n\n\nI wonder if this was intentional. This strange behavior is potentially useful given the tail-threading macro ->>, but also potentially confusing.\nThe helper function responsible for handling kwargs in function calls begins on line 445 in compiler.py. This might be a helpful reference for kwarg support in defclass.\n. Folks, I've made a discovery:\n=> (take-give ':spam)\nfrom hy import HyKeyword\ntake_give(HyKeyword('\\ufdd0:spam'))\n'\\ufdd0:spam'\n=>\nYou just have to quote it. This really needs to be documented.\nAlso, the Internal Compiler Bug is not a good sign. Can we detect these cases and get a friendlier error message, please?\n. Wait a second. In Python, the decorators are pure syntactic sugar. What is this doing that the threading macros don't do already?\n. > But right now for let's you do the Cartesian product:\nThat's news to me, is that in the docs anywhere? How does the else part work with that?\n. The character that says \"generator expression\" to a Python programmer isn't G, but (. I'd hoped to hear some more opinions before running with this, but assuming we go with @algernon 's plan of a reader macro alias for genexpr, can we just use #() instead? I think it's possible because we did #{} for sets. \nI know this dashes any hope of Hy eventually using that syntax for an equivalent of Clojure's #(%) lambdas, but might I suggest #%(%1) instead for that purpose? (In Hy, unlike Clojure, the % can't be an alias for %1, because it's already the Python % operator.) The #% will be easy to remember, since the implicit parameters start with %.\nIf we do create a reader macro alias for genexpr there's no reason we couldn't implement the ordinary gencall macro as well.\n. How is the else clause supposed to work in the new for? I can't get it to work.\nCurrent:\nHy\n=> (for [x (range 3)] None (else (print \"done\")))\nfrom hy.core.language import range\nfor x in range(3):\n    None\nelse:\n    print('done')\ndone\nProposed:\nHy\n=> (for [x (range 3)] None (else (print \"done\")))\nfrom hy.core.language import range\nfor x in range(3):\n    None\n    else(print('done'))\nTraceback (most recent call last):\n  File \"<input>\", line 1, in <module>\nNameError: name 'else' is not defined\n. This breaks augmented slice assignments.\nCurrent:\nHy\n=> (setv spam (* 10 [0]))\nspam = (10 * [0])\n=> spam\nspam\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n=> (print (+= (slice spam 2 5)[1 2 3]))\nspam[2:5] += [1, 2, 3]\nprint(None)\nNone\n=> spam\nspam\n[0, 0, 0, 0, 0, 1, 2, 3, 0, 0, 0, 0, 0]\nProposed:\nHy\n=> (setv spam (* 10 [0]))\nspam = (10 * [0])\n=> spam\nspam\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n=> (print (+= (slice spam 2 5)[1 2 3]))\nspam[2:5] += [1, 2, 3]\nprint(_hy_anon_var_1)\nTraceback (most recent call last):\n  File \"<input>\", line 1, in <module>\nNameError: name '_hy_anon_var_1' is not defined\n=> spam\nspam\n[0, 0, 0, 0, 0, 1, 2, 3, 0, 0, 0, 0, 0]\nSimilarly breaks augmented subscript assignments:\nHy\n=> (print (+= (get spam 0) 12))\nspam[0] += 12\nprint(_hy_anon_var_1)\nTraceback (most recent call last):\n  File \"<input>\", line 1, in <module>\nNameError: name '_hy_anon_var_1' is not defined\nAnd augmented attribute assignments:\nHy\n=> (setv foo (lambda [] nil))\nfoo = (lambda : None)\n=> (setv foo.bar 2)\nfoo.bar = 2\nfoo.bar\n2\n=> (print (+= foo.bar 1))\nfoo.bar += 1\nprint(_hy_anon_var_1)\nTraceback (most recent call last):\n  File \"<input>\", line 1, in <module>\nNameError: name '_hy_anon_var_1' is not defined\n. More than two parameters is confusing if you call it xor. Note that (xor a b c) is not (xor (xor a b) c) in general. But this does hold for + etc. It should be called one-hot or parity, depending on which interpretation you're using, or else limited to two arguments.\n. A possible Python implementation:\nPython\nxor = lambda a, b: bool(a) ^ bool(b)\nIn Hy:\nHy\n(defn xor [a b] (^ (bool a) (bool b)))\nEdit: never mind, your version seems faster.\n. I'll admit the [] version is prettier than ,/product, however, the same readability complaint applies whenever assigning to tuples, such as (setv (, x y z) (, 3 2 1)), or (for [(k,v) (some-dict.items)] ...). Why are these OK? I don't think we should change all of these to use [] and pairs, do you? \nUsing product is much more consistent with the rest of the language. We could import itertools.product as something shorter, if you prefer, like prod, cart, or nest.\nIt's FAR more common to iterate over two collections in parallel, than over their Cartesian product. That's why zip is a builtin, but you have to import itertools.product. If you insist on retaining a macro with [] syntax, a much better translation is from:\nHy\n(for [x it1\n      y it2]\n  (print [x y]))\nto\nPython\nfor x,y in zip(it1,it2):\n    print([x,y])\nYet we have to write it as\n(for [(, x y) (zip it1, it2)]\n  (println [x y])\nWhich presents exactly the same readability issue. And this is the more common case!\nBut still, this is consistent with the way you iterate over dictionaries:\n(for [(, k v) (some-dict.items)]\n  (println [k v]\nI don't even know how to fix that one with [], do you?\nEven with [] for product, you can't get away from tuples in the more complex cases:\nHy\n(for [(, x y) (zip it1 it2)\n      (, z w t) (product it3 it4 it5)  # same readability issue here!\n      (, k v) (some-dict.items)]\n...)\nAnd, of course, assignments to tuples can nest:\nHy\n(setv (, a (, b c) d) (, 1 (, 2 3) 4)\nSame readability issue, but you can't fix it with []. Tuples are valid assignment targets in many places, not just setv and for loops.\nLet's just be consistent, call a Python a Python, get rid of the [] and be done with it.\n. > On the other hand, teaching the for macro to use product underneath instead of nested for* loops may worth a try. We'd need some approximate numbers though, to see if its worth it.\n@algernon It looks like the current implementation uses a genexpr, not nested for*, and actually used to use itertools.product. This is so break/continue/else work properly on the whole loop instead of just the inner part. \n@kirbyfan64 The Python example doesn't really apply here, since it uses muliple for keywords. That makes it analogous to\nPython\nresult = []\nfor x in [1,2,3]:\n    for y in [4,5,6]:\n        result.append((x, y))\nand not analogous to\nPython\nresult = []\nfor x,y in product([1,2,3],[4,5,6]):\n    result.append((x,y))\nWhich is what we were actually talking about.\nThe equivalent list comp in Python is actually:\nPython\n[pair for pair in product([1,2,3],[4,5,6])]\nOn the other hand, if you meant that for should be consistent with Hy's list-comp form, that is a much better argument. Clearly (list-comp (x,y) [x [1 2 3] y [4 5 6]]) looks a lot more like the current for.\nBut I don't buy this either, because we're changing the comprehension syntax anyway for #848. We have to change it because we have to be able to put the predicates in between the for clauses. This will break the symmetry anyway. \nTherefore, I don't think that translating to zip will remain confusing with the new comprehension syntax (except for inertia from existing users, same as any language change). Those coming from Python rather than Clojure will find the zip form more intuitive than the current product-like behavior. But this is not my first choice anyway, which is just to get rid of the [] altogether, and use zip, product, dict.items etc. explicitly as we do in Python.\n. Ah, I see @paultag's point referencing #573. The for bindings, as implemented with a genexpr, are sequential, not parallel as they would be using product, thus arg2 of product can't depend on a variable bound from the result of arg1, because it hasn't happened yet, but this is possible with a genexpr, which (unlike product) is not a function.\nSo, @algernon teaching the for macro to use product underneath instead of the genexpr it uses now will break anything that depends on sequential assignments working. Maybe it's worth a try if it's significantly more efficient, but understand it does change the current behavior.\n. This seems like a good time to fix #855.\n. See #739 about the return statement. We might end up adding one.. Do you guys have some way of auto-documenting from Hy docstrings with Sphinx, or do you want me to add it manually?\n. @kirbyfan64 the easiest way to keep the remainder would be with zip-longest instead of zip. This way the tuples are always the same length. You could have an &optional fillvalue argument to partition.\nOf course, Clojure's partition does this completely differently.\n. Two LGTM's. Hold up, I'll manually add the doc for this too. Then you want me to squash it?\nThis is my first pull request for this project. Do I put my name in the AUTHORS file in this pull request?\n. OK, I think I'm ready. Double-check me if you feel like it.\n. > There's a difference between multimethods (defmulti) and arity overloading (same function, different number of arguments). What you want is the latter, not the former.\nI thought of using &rest. I think I do want the former though.\nHy\n(require hy.contrib.multi)\n(import [itertools [islice]])\n(defmulti multi-partition\n  ([n coll]\n   (->> coll (iter) (,) (* n) (apply zip)))\n  ([n step coll]\n   (apply zip (list-comp (islice coll start nil step)\n                         [start (range n)])))\n  ([n step fillvalue coll]\n   (apply zip-longest\n          (list-comp (islice coll start nil step)\n                     [start (range n)])\n          {\"fillvalue\" fillvalue})))\nThis way it keeps the ordering we want, and we're still free to change that order using keywords:\nHy\n=> (list (multi-partition 3 2 \"x\" (range 6)))\nfrom hy.core.language import range\nlist(multi_partition(3, 2, 'x', range(6)))\n[(0, 1, 2), (2, 3, 4), (4, 5, 'x')]\n=> (list (multi-partition 3 2 :coll (range 6) :fillvalue \"x\"))\nfrom hy.core.language import range\nlist(multi_partition(3, 2, coll=range(6), fillvalue='x'))\n[(0, 1, 2), (2, 3, 4), (4, 5, 'x')]\n=>\nBut with &rest this isn't possible.\n. We can't import Python yet in core?\n. I wouldn't call that sugar so much as pointless aliasing, which I was hoping to get rid of per #240. Maybe I should just make a pull request for that to get the ball rolling. Removing stuff seems a lot easier than adding it.\n. After playing with Iverson's J, Clojure's anonymous function literal doesn't look so bad to me. But the example you linked to isn't a fair comparison, Clojure's equivalent lambda actually looks like this: \nClojure\n(fn [x] (+ 1 x))\nThe #() anonymous function literals are just an abbreviated syntax that lets you omit the argument list and a pair of parentheses. It can't replace the true lambdas (fn). You can't even nest them.\nIs this version (,\\ + ,1 ,2 ,&) less ugly? I'm not sure of your aesthetic here, but I can change most of it pretty easily.\n. > ,\\ looks a bit weird to me.\nIt's not unusual for a programming language to substitute ASCII digraphs for other characters not easy to type, so \u2192 becomes ->, for example. Similarly, \u03bb could become ,\\, or perhaps .\\. Haskell doesn't even bother with a digraph and just uses \\ for lambda. That's really the only reason I chose ,\\. The choice of characters is not that important, and easily changed. It just has to be short.\n\nWhy, oh why, do we need syntax for anonymous functions? lambda is perfectly fine and legible.\n\nWhy, oh why, do we need a Hy? Python is perfectly fine and legible ;) \"Need\" is a relative term. One may as well ask, \"Why does Clojure need #(...) when it has the perfectly fine and legible (fn [...] (...))?\". For something so \"unnecessary\", it sure seems to get used a lot. The #(...) syntax is different from fn in that it doesn't need extra () in the body and does not require a parameter list. It's implied by special names for the parameters themselves. \nA major use case for this syntax is partial function application with a minimum of ceremony. This is something one uses quite a lot when writing code in the functional style, especially in a language that does not have automatic currying. This is so important that Python added functools.partial, despite already having the perfectly fine and legible lambda that could easily be used for this purpose. See PEP 0309, for exactly this argument.\n\nIf it\u2019s too much to type, ... learn to use your text editor.\n\nYes, and Java's tedious verbosity is made much more tolerable with a good IDE. Any language you have to excuse via editor has serious issues. A good Lisp should need little more than parentheses-balancing and indent support.\nI'm surprised by the lack of enthusiasm here. I do understand (and support) the need to guard against cruft in the language, but this can be taken too far in the other direction. After all, Hy is a Lisp, and if some things are missing in the language, the user will add them. With macros, if necessary. (Like how I just added a macro for function literals.) \nIf a standard is too minimal for too long (e.g. Scheme, Lua), then the community will fragment because everybody has to re-invent the wheel, but they all do it independently and in incompatible ways. Hy avoids a lot of this kind of problem by supporting Python's libraries, just as Clojure does with Java's. But Clojure still has both fn and #(), and a large core (~600 forms vs Python's 68 builtins), because Java is not a Lisp, and can't help with that part. Python is not a Lisp either. Domain-specific macros will be in Hy libraries, or individual applications. That can't be helped. But the general-purpose macros that might otherwise get re-invented a lot belong in Hy proper, to combat fragmentation.\n. > I just feel like you save just a few characters for little benefit, and it's harder than it looks to compile.\nThey don't support nesting! Neither does Clojure's. This was never meant to replace lambdas altogether. And I have a working macro. It might be improved by error checking, but it does work.\n. > I wouldn\u2019t want to when I have emacs + slime + paredit.\n+ Evil :smiling_imp:. I do appreciate a good editor. But if you find that you're tempted to write a new emacs function to help you with writing repetitive/boilerplate Lisp (like IDEs do for Java), you're better off writing a macro so it's not repetitive instead.\n(lambda [,1 ,2 ,3] (+ ,1 ,2 ,3 -1)) repeats the ,1, the ,2, and the ,3. \nThe (,\\ + ,1 ,2 ,3 -1) macro it was expanded from doesn't.\n\nThe problem I have with introducing Clojure\u2019s syntax for LAMBDA is that I find it superfluous for the following reasons:\n1. Python users already type \u201clambda\u201d (or have their editor do it for them) \n2. CL, Scheme, Racket, and innumerable other Lisps use \u201clambda\"\n\nWe already have Clojure's syntax for LAMBDA! It's spelled \"fn\" in Clojure as well as Hy. (Which is superflous given that we have lambda in Hy.) This is not the same as Clojure's function literals #(), which we do not have. Note, the macro expands into an ordinary lambda form, thus it cannot take lambda away from Hy.\n\n\nLike DEFN and DEFMACRO, LAMBDA introduces a new form. In contrast QUOTE and friends are only interesting to READ and are only moderate interest to a human reader \u2014 ergo reader macros such as ' and , in CL or Scheme.\n\n\nWe can put the ,\\ inside the parentheses instead of the #% outside of them, if you prefer. This makes it a macro form, instead of a reader macro.\n\n\nParsers would have to be written to support structural editing and highlighting of short-hand lambda syntax (hy-mode in Emacs land for example)\n\n\nParsers general enough to support macros will support this macro too. Hy does use macros. A lot. \n\n\nSpecial syntax requires beginners to become experts and is non-transferable rote knowledge. \nIn the case of Hy there is no real benefit other than forcing new users to learn more syntax.\n\n\nOh, I agree syntax should be kept as simple as possible... but no simpler. \nHy has an entire contrib section dedicated to anaphoric macros, and even has defmacro/g! built-in. ,\\, as proposed, is just another anaphoric macro like these. It's not meant to get rid of lambda. It's meant to get rid of repetition, same as any macro.\n. > As near as I can tell fn and lambda being aliases for the same thing is redundant and worth cleaning up.\nAgree with this part, though they don't behave exactly the same now. I would be in favor of removing fn altogether, and using lambda for both cases. But what does that have to do with this issue?\n\nI still don't understand the benefit this would bring to Hy. I know Clojure. I still don't see the appeal or the benefit it brings users. ... I'd be more in favour for making better reader macros. Then this discussion would be moot.\n\nI'm not certain we're even talking about the same thing at this point. You seem to be saying that you're not in favor of adding an alias for lambda like, (lambda [x y z] (+ x y z -1) to (\u03bb [x y z] (+ x y z -1)) or to #\u03bb([x y z] (+ x y z -1)).\nBut this is not what is being proposed here at all.\nI'm suggesting an anaphoric macro like the defmacro/g! we already have, that expands into a lambda. I'm not sure of the exact word or prefix to use (part of what I wanted to discuss), but if you're more familiar with defmacro/g!, it would be something like this:\n(fn/p! list p!3 p!1 p!2  \"spam\"), which would expand into\n(lambda [p!1 p!2 p!3] (list p!3 p!1 p!2 \"spam\")).\nHere p! stands for \"parameter\", just like g! stands for \"gensym\" in defmacro/g!. Except we'd choose something easier to type than p! for the prefix. The suffix indicates what order the parameters appear in the lambda's parameter list once it gets expanded.\nI really don't know what defmacro/g! and the like has to do with reader macros, so that doesn't make any sense.\n. > Why is this useful for Hy?\n\n(ap-map (+ it 10) [1 2 3]) \n(ap-filter even? [1 2 3 4 5 6 7 8])\nWhat\u2019s the win here for adding this special syntax? \n\nThese do indeed fix the verbosity problem in the particular cases of map and filter. And the other ap- functions have their own uses. But when using the functional style, you need to pass higher-order functions as arguments a lot, not just to builtins like map/filter, but to other functions you may define yourself. An anaphoric lambda will fix the verbosity problem in every case.\nThe biggest win is for partial function application, as I mentioned before. You need this all the freaking time in functional programming. That's why pure functional languages like Haskell automatically curry their arguments. For example, in Haskell, if you define something equivalent to the Python \nfoo = (lambda a, b: [a, b])\nand then call it without enough arguments:\nfoo(42)\nThen rather than getting an error, it just returns a partial application, like\nlambda b: [42, b]\nwhich you can then call later with the remaining arguments, perhaps multiple times with different remaining arguments.\nIt's never going to be that automatic in Python, but this capability is important enough that Python got functools.partial in PEP 0309. To make this anywhere near as usable as auto-currying, the syntax must be as short as possible. Clojure's form is good enough, but fn/p!, while clearer to you, is too much.\nBut an anaphoric lambda is even more general than this. It's very common in functional programming to create a pipeline of lazy generators by composing functions. For those who use Unix derivatives, this is very similar to the pipelines one would build in a bash one-liner, for example. But for a pipeline to work the output of one function must match the expected input for the next. Sometimes you need an adapter. Say you need to reverse the order of a binary operator? Anaphoric lambda does it: #(- %2 %1); functools.partial can't do it. Maybe you need convert one argument to a string? Anaphoric lambda does it: #%(list (str %1) %&); functools.partial doesn't. It's nearly as general as lambda itself, but much less verbose.\n. > Parameters tend to be given descriptive names (be it x, y, z or something else) that are dependent on the given case.\nWe don't have to use a prefix, though maybe we should. Our defmacro/g! takes the prefix approach, but the other anaphoric macros just use a special word (it). It would be possible to treat the symbols x,y,z,w as special this way without a prefix. They would always appear in this order in the parameter list, as in mathematics. This is even shorter. It would kind of limit us to four arguments though. Unless you want to pull them from the &rest arg, but then we're getting verbose again and might as well just use a normal lambda.\nActually, this reminds me of something from my linear algebra course. Vectors of up to four dimensions sometimes used x,y,z,w, but when generalizing to any number of dimensions, it was usually written as all x's with a subscript, like x\u1d62. We could use x as the prefix and use x1 x2 x3 x4 x5 etc. for positional arguments. We could even use xi for the &rest parameter. The macro name could be something suitably short, like \\ or perhaps even xi, which isn't ambiguous with the &rest part because you can't nest anaphoric lambdas anyway.\nWhat do you guys think of that?\n. > Why does this have to go in core and not in a contrib module? I\u2019m not saying it isn\u2019t useful I just don\u2019t see it being useful in core. Python is not a functional programming language and probably never will be.\nYou don't need a pure functional language to use the functional style. Just like you don't need an object-oriented language to use the object-oriented style. GTK+ is a great example of object-oriented C. Python supports multiple paradigms. It has lazy generators (yield, genexprs, itertools), higher-order functions, and functools. I use functional style quite a lot in Python.\nLisp is not a functional language either, but it is very multi-paradigm, and Clojure in particular tries to support functional style well. Hy inherits quite a lot from Clojure, thus I assumed supporting functional style with Clojure idioms was a design goal for Hy.\nNo, we don't have to put it in core. Consensus seems to be, put it in anaphoric and not in core, at least for now--answers one of the main questions I asked in the OP, \"would you prefer I put it in core or contrib?\"\n\nOh, neat. x1, x2, xi and so on would work I think. \n\nOK, I'll try to put together a pull using the xi syntax in hy.anaphoric.\n. > If we wanted to be fancy, could even use x\u2081, x\u2082, etc. as aliases.\nI believe it's possible to set up vim/emacs to render it this way. This is probably a cleaner solution than supporting it directly as aliases in Hy, which is also possible, but would complicate the macro a bit.\nWe could even use x\u1d62. The \"Latin Subscript Small Letter I \u1d62\" is at U+1D62, which is in Phonetic Extensions, and uncommonly used plane. If your font doesn't have it, you could use \"U+00A1: Inverted Exclamation Mark \u00a1\" as a substitute (x\u00a1). I would expect almost all the Unicode fonts to have this. (And if you want to be punny, just call x\u1d62 \u03be).\nThe digit subscripts \u2080\u2081\u2082\u2083\u2084\u2085\u2086\u2087\u2088\u2089 are at U+2080 through U+2089.\n. xi-forms are merged and working. Try them out. \nWas anaphoric the appropriate location? Do we need the Unicode aliases in Hy? Did you notice any bugs? Is the documentation on xi confusing?\nIf nobody speaks up about further changes in a few days, then I'm going to close this issue.\n. > ... defn-alias and defmacro-alias. They're very useful when you're doing - arguably crazy - stuff ...\n...\n\nI'd also like the alias functions to stay. They are usefull even tho the core lib won't be using them much.\n\nMaybe I should just move them to contrib. It would keep the core more focused, but you could still import (require) them if you want. On the other hand, it's pretty easy to alias a function even without the macro:\nHy\n(def firsto\n  (defn first\u1d52 [l a]\n    (fresh [d]\n           (cons\u1d52 a d l))))\nThis way it's clear which is the standard function name and which is the alias.\nI feel like there ought to be a similar way to alias a macro after it has been defined, but it doesn't look easy. The defmacro-alias form just rewrites the whole thing using a new name. This approach seems less than optimal.\n. > I'd also keep the true, false, null and nil aliases (because I use them a lot, and shift is far away). \nSee, I knew the other groups would be more controversial. This pull (so far) only targets the first group, and we don't have to agree to fixing the other two before merging this part. \nWe can still talk about them though.\nAs for the second group, I'll admit to using the easier-to-type aliases true/false/nil almost exclusively in my own code, and they're used a lot in Hy proper. But I still think this is extra complexity for marginal benefit.\nEven if you're not convinced by the following, can we at least get rid of null? It's hardly ever used, and not easier to type than nil.\nCorrect me if I'm wrong about this assumption, but Python keywords have to be reserved in Hy, because Hy compiles to Python and can be imported from Python. They don't have to mean the same thing in Hy as in Python, though this can get confusing. def (for example) has a pretty different meaning, but there's no other good meaning for True and False that we could use instead. True/False/None are reserved in Python3. They cannot be assigned to in Python, and it would be problematic to allow this in Hy. Thus, if we have to choose, the clear choice is the Python words.\nI am unconvinced by the argument that true and false are easier to type. True and False literals are actually not used as much as you might expect. Sure, Booleans are used all the time, but usually you type in an expression that evaluates to a Boolean rather than forcing one or the other yourself.\nThe case where Boolean literals get used the most is in testing. If you're testing at the REPL and just need a generic truthy or falsey value, admit it, you're going to use 1 and 0 over even true and false, because it just does not get any easier to type than that.\nUnit tests, on the other hand, also serve as a kind of documentation. It's worth making them readable. Now if we decide that it's idiomatic in Hy to use 1/0 for unit tests, then people will be used to it and it will not be considered hard to read. (Many of Hy's unit tests already do this by the way.) On the other hand, True and False are no less readable, and they even stand out more.\nI am also unconvinced by the argument that true and false are used all the time. It's a simple one-line fix:\nPython\ntrue, false = True, False\nThe first group in the pull (which we do seem to agree on) breaks stuff a lot harder than this. Yes, the Grand Language Cleanup will break stuff. Best get it over with now. If removing true/false turns out to be a mistake, it will be an easily correctable mistake. If NOT removing true/false turns out to be a mistake, it will only get harder to fix.\nThere's a better argument for keeping nil, I suppose. This really does get used a lot. None could perhaps be used for something else, but I don't know what. But nil may cause confusion for Common Lisp programmers expecting it to be the empty list. None wouldn't have that connotation. I'd still prefer we be consistent and get rid of nil, but I'd be more willing to make an exception here.\n. > I'd also keep the true, false, null and nil aliases (because I use them a lot, and shift is far away). \nSee, I knew the other groups would be more controversial. This pull (so far) only targets the first group, and we don't have to agree to fixing the other two before merging this part. \nWe can still talk about them though.\nAs for the second group, I'll admit to using the easier-to-type aliases true/false/nil almost exclusively in my own code, and they're used a lot in Hy proper. But I still think this is extra complexity for marginal benefit.\nEven if you're not convinced by the following, can we at least get rid of null? It's hardly ever used, and not easier to type than nil.\nCorrect me if I'm wrong about this assumption, but Python keywords have to be reserved in Hy, because Hy compiles to Python and can be imported from Python. They don't have to mean the same thing in Hy as in Python, though this can get confusing. def (for example) has a pretty different meaning, but there's no other good meaning for True and False that we could use instead. True/False/None are reserved in Python3. They cannot be assigned to in Python, and it would be problematic to allow this in Hy. Thus, if we have to choose, the clear choice is the Python words.\nI am unconvinced by the argument that true and false are easier to type. True and False literals are actually not used as much as you might expect. Sure, Booleans are used all the time, but usually you type in an expression that evaluates to a Boolean rather than forcing one or the other yourself.\nThe case where Boolean literals get used the most is in testing. If you're testing at the REPL and just need a generic truthy or falsey value, admit it, you're going to use 1 and 0 over even true and false, because it just does not get any easier to type than that.\nUnit tests, on the other hand, also serve as a kind of documentation. It's worth making them readable. Now if we decide that it's idiomatic in Hy to use 1/0 for unit tests, then people will be used to it and it will not be considered hard to read. (Many of Hy's unit tests already do this by the way.) On the other hand, True and False are no less readable, and they even stand out more.\nI am also unconvinced by the argument that true and false are used all the time. It's a simple one-line fix:\nPython\ntrue, false = True, False\nThe first group in the pull (which we do seem to agree on) breaks stuff a lot harder than this. Yes, the Grand Language Cleanup will break stuff. Best get it over with now. If removing true/false turns out to be a mistake, it will be an easily correctable mistake. If NOT removing true/false turns out to be a mistake, it will only get harder to fix.\nThere's a better argument for keeping nil, I suppose. This really does get used a lot. None could perhaps be used for something else, but I don't know what. But nil may cause confusion for Common Lisp programmers expecting it to be the empty list. None wouldn't have that connotation. I'd still prefer we be consistent and get rid of nil, but I'd be more willing to make an exception here.\n. Also,\n``` Hy\n(defclass Something []\n  (def --init-- (fn [self] ....)))\n(defclass Something [])\n(def Something.--init-- (fn [self] ...))\n;; and setv instead of def\n```\nAnd don't forget that --new-- must also return None.\nI'm not sure an explicit return is so bad here, but how about creating a definit macro that just appends a None?\nHy\n(defclass Something []\n  (definit [self] ...))\nWe could make a similar defnew macro.\nOr, if you prefer, a defnil macro for both cases:\nHy\n(defclass Something []\n  (defnil --init-- [self] ...))\nNot really sure if this is better.\n. __new__ isn't supposed to return None. Who said that? Oh, right that was me. I must have misread the docs. It returns the instance. __new__ will break if you force it to return None. Change it back.\n. The other kwargs are not working properly. Sometimes metaclasses need them.\n``` Hy\n=> (defn my-meta [name bases namespace &kwargs kwargs]\n... (print \"name\" name)\n... (print \"bases\" bases)\n... (print \"namespace\" namespace)\n... (print \"kwargs\" kwargs))\nfrom hy.core.language import name\ndef my_meta(name, bases, namespace, **kwargs):\n    print('name', name)\n    print('bases', bases)\n    print('namespace', namespace)\n    return print('kwargs', kwargs)\n=> (defn foo [:spam \"spam\" :meta my_meta])\nTraceback (most recent call last):\n  File \"C:\\Python34\\Scripts\\env-hy\\lib\\site-packages\\hy\\cmdline.py\", line 81, in\n print_python_code\n    print(astor.codegen.to_source(_ast_for_print))\n  File \"C:\\Python34\\Scripts\\env-hy\\lib\\site-packages\\clint\\packages\\colorama\\ans\nitowin32.py\", line 34, in write\n    self.__convertor.write(text)\n  File \"C:\\Python34\\Scripts\\env-hy\\lib\\site-packages\\clint\\packages\\colorama\\ans\nitowin32.py\", line 115, in write\n    self.write_and_convert(text)\n  File \"C:\\Python34\\Scripts\\env-hy\\lib\\site-packages\\clint\\packages\\colorama\\ans\nitowin32.py\", line 142, in write_and_convert\n    self.write_plain_text(text, cursor, len(text))\n  File \"C:\\Python34\\Scripts\\env-hy\\lib\\site-packages\\clint\\packages\\colorama\\ans\nitowin32.py\", line 147, in write_plain_text\n    self.wrapped.write(text[start:end])\n  File \"C:\\Python34\\Scripts\\env-hy\\lib\\encodings\\cp437.py\", line 19, in encode\n    return codecs.charmap_encode(input,self.errors,encoding_map)[0]\nUnicodeEncodeError: 'charmap' codec can't encode character '\\ufdd0' in position\n8: character maps to \n```\nThe equivalent Python works:\n``` Python\n\n\n\ndef my_meta(name, bases, namespace, **kwargs):\n    print('name', name)\n    print('bases', bases)\n    print('namespace', namespace)\n    return print('kwargs', kwargs)\nclass foo(spam=\"spam\", metaclass=my_meta):\n    pass\n\n\n\nname foo\nbases ()\nnamespace {'module': 'main', 'qualname': 'foo'}\nkwargs {'spam': 'spam'}\n\n\n\n```\n\n\n\nNote that my_meta received the spam kwarg.\n. > I suppose kwargs is python3+, yes?\nYes, including the metaclass kwarg itself. Attempting to use any kwargs in a class definition is a syntax error in Python 2.\n. Hrm, I guess I'm not using tox properly. I see the problem now though, max only has a default argument in Python 3. I can fix it.\n. Hy\n=> (defn foo [&rest args] (print args))\n=> (apply foo (+ [1 2 3][4 5 6]))  ; works\n(1, 2, 3, 4, 5, 6)\n=> (apply foo (+ [1 2 3](, 4 5 6)))  ; fail\nTraceback (most recent call last):\n  File \"<input>\", line 1, in <module>\nTypeError: can only concatenate list (not \"tuple\") to list\n=> (apply foo (+ [1 2 3](genexpr x [x [4 5 6]])))  ; fail\nTraceback (most recent call last):\n  File \"<input>\", line 1, in <module>\nTypeError: can only concatenate list (not \"generator\") to list\n``` Python\n\n\n\ndef foo(*args):\n    print(args)\nfoo(1,2,3,[4,5,6])  # works\n(1, 2, 3, 4, 5, 6)\nfoo(1,2,3,(4,5,6))  # works\n(1, 2, 3, 4, 5, 6)\nfoo(1,2,3,*(x for x in [4,5,6]))  # works\n(1, 2, 3, 4, 5, 6)\n```\n\n\n\n+ no help enough.\napply not good enough. \nYeah, the kwargs make it more difficult than in other Lisps, but just a little bit. I still think we can do better than what we've got.\n. Here's option one:\nHy\n(apply foo 1 2 3 :* (, 4 5 6) :** {\"this is key\" 42})\n;; They're optional\n(apply foo 1 2 3 :** {\"this is key\" 42})\n(apply foo 1 2 3 :* (, 4 5 6))\n(apply foo 1 2 3)\n;; the other order would also work\n(apply foo 1 2 3 :** {\"this is key\" 42} :* (, 4 5 6))\nIn this version, the args and kwargs are optional keyword-only arguments to apply. The keywords (:* and :**) are easy to remember if you're familiar with Python. I think I like this one best.\nHere's option two:\nHy\n(apply foo 1 2 3 (, 4 5 6) {})\n(apply foo 1 2 3 (,) {})\nIn this version, the last two arguments are always the args and kwargs, but they can be empty if not needed. Just like how an apply works like a funcall in Common Lisp, when you give it a nil list at the end. apply would thus have a minimum of three arguments.\nOption three.\nHy\n(apply foo [1 2 3] (, 4 5 6) {\"k\" \"v\"})\nHere, apply can have a maximum of four arguments. The one, two, and three argument versions behave as they do now. This has the advantage of not breaking code, but it's also my least favorite option. When you want to add arguments in the front, they go in square brackets, but you still have to pass it an iterable and dictionary, even if they're empty, as in option two.\n. > Short of adding vectors around args and kwargs\nSomething like this?\nHy\n(apply foo 1 2 3 [(, 4 5 6) {\"k\" \"v\"}])\nYou'd still need an empty args if you only wanted to unpack kwargs. \nHy\n(apply foo 1 2 3 [(,) {\"k\" \"v\"}])\nThis doesn't seem any better than option two.\n\nI don't know how to do this in a clean and predictable way.\n\nOption three might be a little confusing, but the other two are very predictable.\n\nAnd if + isn't good enough when you mix types, try itertools.chain.\n\nchain does work. Still kind of a pain to need it and to import it.\n. String's an iterable and it spliced the characters... edit/fixed with []. Usually, you're splicing in code, not strings into macros, so I think the point stands.\n. :-1: I approve of removing the extra [] from let, but not of making it a mere alias for setv, which is counter to #240. The body has no special meaning, which is still confusing. let is marginally more useful as it is now, despite its problems.\nAs for with, can we use nil/None as a dummy variable, as discussed in #852? I haven't tested it, but from looking at the code, it doesn't appear to work.\n. What happens if with's [] has an odd number of arguments? Can you add an error check?\n. We could support both with a variadic if, see #830.\n. > I think maintaining the analogy to def, defn, and defmacro that Algernon mentions is more important \nBy that logic we should have class as an anonymous class by analogy to fn.\n\nWe do that, but you know, I don't think we need to do that.\n\n...\n\nPerhaps we should allow Python keywords to be used in Hy? Or at least, some of them.\n\nYou know, maybe we should. This would let us get rid of True/False in favor of the preferred true/false. And also get rid of None in favor of nil should #896 be rejected.\nI was under the impression that this would break Hy<->Python interop, but maybe it doesn't have to if we provide workarounds? For example, we allow Unicode symbols because Hy treats the equivalent Punycode as the same symbol, and this alias also works in Python.\nPython actually does allow reserved words as attributes, so that's not a problem either.\n``` Python\n\n\n\nclass namespace:\n    pass\nnamespace.foo = 2\nnamespace.foo\n2\nnamespace.class = 42\nSyntaxError: invalid syntax\nsetattr(namespace,'class',42)\nnamespace.class\nSyntaxError: invalid syntax\ngetattr(namespace,'class')\n42\n```\n\n\n\nYou don't get the sugar, but it does work.\nI think imports might even work.\n``` Python\nfrom class import class as Class\nfrom importlib import import_module\nClass = getattr(import_module('class'), 'class')\n```\nI would want this tested though.\nThe reverse is also a concern, e.g. can Hy import a Python module named defclass? I think the same workarounds work.\nAre there other cases interop would break that I'm not thinking of? Are there workarounds?\n. I saw #902, which looks like a better fix for setv than what I have here. It should be an easy merge.\n. I think it's just you.\n`` Python\nhy 0.11.0 using CPython(v3.4.3:9b73f1c3e601) 3.4.3 on Windows\n=> (defn expensive-get-number [] (print \"spam\") 14)\ndef expensive_get_number():\n    print('spam')\n    return 14\n=> (defmacro! triple-3 [o!n](+ ~g!n ~g!n ~g!n))\nfrom hy.core.language import gensym, interleave\nimport hy\nfrom hy import HyExpression, HySymbol\n@hy.macros.macro('triple_3')\ndef _hy_anon_fn_2(o!n):\ndef _hy_anon_fn_1():\n    g!n = gensym(HySymbol('g!n')[2:])\n    return HyExpression(((([] + [HySymbol('do')]) + [HyExpression((([] + [HySymbol('setv')]) + list(interleave([g!n], [o!n]))))]) + list([HyExpression((((([] + [HySymbol('+')]) + [g!n]) + [g!n]) + [g!n]))])))\nreturn _hy_anon_fn_1()\n\n=> (triple-3 (expensive-get-number))\n:n_1235 = expensive_get_number()\n((:n_1235 + :n_1235) + :n_1235)\nspam\n42\n=> (macroexpand '(triple-3 (expensive-get-number)))\nfrom hy.core.language import macroexpand\nfrom hy import HyExpression, HySymbol\nmacroexpand(HyExpression((([] + [HySymbol('triple_3')]) + [HyExpression(([] + [HySymbol('expensive_get_number')]))])))\n('do' ('setv' ':n_1236' ('expensive_get_number')) ('+' ':n_1236' ':n_1236' ':n_1236'))\n```\nHy\n;; the macroexpand with manual pretty-printing\n(do (setv :n_1236 (expensive_get_number))\n    (+ :n_1236 :n_1236 :n_1 236))\nThe Travis CI build passed.\nTry uninstalling Hy altogether before re-installing this branch in your virtual environment. Or create a new virtual environment without Hy in it, then install just this branch. It should work.\n. tuturto said:\n\nhy 0.11.0 using CPython(default) 3.4.0 on Linux\n\nI said:\n\nhy 0.11.0 using CPython(v3.4.3:9b73f1c3e601) 3.4.3 on Windows\n\nClearly, something about our setup differs.\n. We have tox to test against multiple Python versions. I think Travis does this too.\n@tuturto I installed it using pip install -e . from the repository's root folder, and it worked for me.\nMake sure you have no Hy installed outside of a virtualenv.\n. Try hy --spy and see if there's anything wrong with the Python output.\n. Very strange. I wonder if the other macros are affected on your setup. Does defmacro/g! work for you? Also try entering the (defmacro defmacro! ...) code at the hy --spy repl using the master branch, and see if that functions.\n. You should be able to use pip install git+https://github.com/gilch/hy.git@defmacro! to install this branch directly from github. It should rule out any corruption of your local repository.\n. I updated a local defmacro! branch with the latest hylang/master. I can confirm the same error.\n`` Python\nhy 0.11.0 using CPython(v3.4.3:9b73f1c3e601) 3.4.3 on Windows\n=> (defmacro! triple-3 [o!n](+ ~g!n ~g!n ~g!n))\nfrom hy.core.language import gensym, interleave\nimport hy\nfrom hy import HyExpression, HySymbol\n@hy.macros.macro('triple_3')\ndef _hy_anon_fn_2(o!n):\ndef _hy_anon_fn_1():\n    g!n = gensym(HySymbol('g!n')[2:])\n    return HyExpression(((([] + [HySymbol('do')]) + [HyExpression((([] + [HySymbol('setv')]) + list(interleave([g!n], [o!n]))))]) + list([HyExpression((((([] + [HySymbol('+')]) + [g!n]) + [g!n]) + [g!n]))])))\nreturn _hy_anon_fn_1()\n\n=> (triple-3 3)\n  File \"\", line 1, column 1\n(triple-3 3)\n  ^----------^\nHyMacroExpansionError: expanding `triple_3': unsupported callable\n```\nIt does appear that a recent change to master has broken this. Since it was working before, I don't think the error is in my code (at least not my code from this branch; some of the recent PRs were mine). This means that a recent change in Hy has not been tested adequately. We should isolate this bug before it causes further problems.\n. Is that the error check from #924?\n. It's evaling a string. But Hy AST isn't always valid Python. I wonder if we could rewrite this to generate the lambda using AST instead of using a string.\n. I don't think we can merge this before #989 gets resolved. All checks passed at the time, but I'm not confident they'll still work after #924 broke it. I think we can have Travis re-check this if I close it and re-open.\n. I don't think we can merge this before #989 gets resolved. All checks passed at the time, but I'm not confident they'll still work after #924 broke it. I think we can have Travis re-check this if I close it and re-open.\n. @hylang/core, failed as expected. LGTM is premature. I propose reverting #924, since our attempts to save it have not worked well.\n. @hylang/core, failed as expected. LGTM is premature. I propose reverting #924, since our attempts to save it have not worked well.\n. Rebased on #1114 and it's still not working. Either I did the merge wrong or something else has changed.\n. @Kodiologist, yes, it was working before. I don't think there's anything wrong with this PR, but there's a bug in Hy we still haven't fixed.. closed by #1172 . Alternate Proposal:\nRemove True/False in favor of true/false\nObviously incompatible with the above, but I do think we should pick one or the other. I like the status quo least of all.\nAs pointed out in the discussion of #899, Python keywords don't have to be reserved in Hy. Hy can be set up to treat True/False the same as any other symbol. While potentially problematic for Python interop, there are workarounds.\nThis has the advantage of keeping what appears to be the more popular alias.\n. A third option from #1119:\nRemove both pairs and use T/F instead.\nThere's plenty of precedent for T meaning \"true\" in other lisps. (Common Lisp uses T/nil, Scheme uses #t/#f.) The main argument for keeping Clojure's true/false over Python's True/False is that it's easier to type. Well, T/F is even easier than that. It would pretty much remove the temptation to use 1/0, (which works the same in almost all cases).\n@hylang/core, what say you?\n. Wow, T/F seems pretty unpopular huh? I thought it was perfectly readable, but I also thought Scheme's #t/#f was perfectly readable, if hard to type. It's not like we're asking the user to memorize dozens of obscure one- or two-character names like in Ruby and especially Perl. It's two values, with very obvious mnemonics.\nThe conciseness is also nice. I do think that things that get used a lot should have concise representations. With a short representation like T/F you can write lists of Booleans just as easily as lists of 0/1, like [T F T T] etc. I feel that kind of thing is much less readable with the current true/false when it gets even a little long. That's when I expect to use Boolean literals the most: in lists of them. \nFor most other uses of Booleans, I'd expect to see computed values more often, like (< x 10) etc., instead of the literal true and false.\nI doubt this will change anyone's mind (but if it does, speak up!), so I'm going to consider the T/F option dead unless the vote changes dramatically. I'll just have to def some aliases when I make my long lists.\nBut all that said, I think it's more important that there be one-- and preferably only one --obvious way to do it. This is a good principle for many reasons, including ensuring that Hy users speak a mutually intelligible dialect.\nIf we had started with only Python's style True/False/None, would anybody have complained? I doubt it. I think we should pretend that happened if we can't reach a consensus for something else. The priorities for Hy have been Python>Clojure>Common Lisp.\nIf we had started with only Clojure's style true/false/nil, would anybody have complained? I still kind of doubt it, since that's what everyone seems to be using, but there's a stronger case against it, because Python's reserved words should probably still be reserved in Hy. Even so, languages can (and do) have reserved words that they don't use. goto and const in Java, for example. Hy already does this. You can't assign to elif. We could disallow True/False/None, just like elif, and Hy users would use a more consistent language.\nThe Clojure option seems to be the de facto status quo. Does anyone seriously dispute that even if Hy allowed both Clojure and Python style, then future Hy style guides would eventually settle on one or the other? Then why not just enforce it at the compiler level?\n. Vote for the de facto Clojure-style true/false/nil.\n. Vote for the default Python-style True/False/None.\n. @hylang/core The above is more of an opinion poll than any kind of binding decision process, by the way. We can still discuss the details of how to implement whatever we decide on.\n. I was including operators, actually. Ruby also has some arcane global names. ($! $@ $_ $. $& $~ $n $= $/ $\\ $0 $* $$ $?). I have to use Ruby some at work. It seems to be something of a cross between Smalltalk and Perl. So the weird parts of Ruby that I don't recognise from Smalltalk I've been blaming on Perl. But Matz also cites Eiffel and Ada (and Lisp) as influences, so perhaps some of that is undeserved?\nIt's not like I know Perl well enough to hate it. Learning more Perl is actually on my to-do list. Any recommendations for good textbooks or something? Should I look at Perl 6 first? Or at all? It doesn't seem ready, and hasn't for a very long time.. That poll is actually really close. I thought we might see some kind of consensus, but it looks more like a stalemate.\nI feel like we need some kind of decision process to keep progress on Hy from getting stuck like this. Do we just go with @paultag's vote? Does anyone know a system that works really well from your other projects?. @Kodiologist Thanks, I'll look at Modern Perl then. It was actually my best guess about where to start.\n@paultag Thanks for that weigh in. I think that argument gives us some good direction for other issues too.. I'm getting a strange \"internal compiler bug\" error I haven't been able to pin down when I try to replace list-comp with genexpr in #903.\nhy.errors.HyCompileError: Internal Compiler Bug \\U0001f631\n\\u2937 TypeError: Don't know how to wrap a <class 'generator'> object to a HyObject\n(long stack trace omitted for brevity)\nI'm worried that attempting to remove cdr will cause similar blowups if this isn't fixed first.\nThis is the version that causes the error:\nHy\n(defmacro defmacro! [name args &rest body]\n  \"like defmacro/g! plus args that start with o! will automatically evaluate\n   once only and be bound to the equivalent g!\"\n  (setv os (genexpr s [s args] (.startswith s \"o!\"))\n        gs (genexpr (HySymbol (+ \"g!\" (cut s 2))) [s os]))\n  `(defmacro/g! ~name ~args\n     `(do (setv ~@(interleave ~gs ~os))\n          ~@~body)))\nI'm not absolutely certain that this is an error in Hy, and not just in defmacro!, but the version with list-comp seems to work:\nHy\n(defmacro defmacro! [name args &rest body]\n  \"like defmacro/g! plus args that start with o! will automatically evaluate\n   once only and be bound to the equivalent g!\"\n  (setv os (list-comp s [s args] (.startswith s \"o!\"))\n        gs (list-comp (HySymbol (+ \"g!\" (cut s 2))) [s os]))\n  `(defmacro/g! ~name ~args\n     `(do (setv ~@(interleave ~gs ~os))\n          ~@~body)))\n. A lot of Python's sequence manipulation tools return generators, not lists. You need sequence manipulation (LISt Processing) in macros most of all, but you're telling me that they're completely incompatible? It would be a pain to have to use (list ...) calls all the time in macro definitions. I'm not even sure I understand where they're required, and the error message isn't helping there. \nCan we teach Hy to \"do that\" with generators? Clojure seems to be able to use lazy sequences without this problem. Maybe a HyModel for anything not already covered with hasattr(object,\"__iter__\")?\n. I'm a lot more confused with the way Hy isn't working now than I would be if something implicitly became a list, and like I said, I haven't run into this kind of problem with Clojure's lazy sequences. At the very least this needs to be better documented. I still don't understand what's triggering this error. Can you demonstrate with a minimal example?\n. Alternative proposal:\nMake lambda different enough from fn to be worth another keyword\nJust filling up a keyword quota is not good language design. But I already had a good suggestion for this for #739: Require explicit (return ...) expressions in fn, but use automatic tail returns in lambda. This is how Python does it anyway, so it's not confusing. To be clear, multiline lambdas would still have to translate to \"anonymous\" Python functions, in which case the return is inserted automatically at the tails, as now.\nWe would also add a deflambda form as defn would now require explicit (return ...). This is actually advantageous for class definitions, because we would no longer need to remember to put nils in every tail position for defn --init-- and defn --new--. Python automatically returns None if you don't return anything else.\nThis would also probably make #876 easier to implement, or at least make py2hy translations easier to do by hand.\n. If deflambda is too long, we could just call it def. setv already does the same thing anyway, so this will clean up another redundant keyword.\n. Alternative proposal 1:\nget rid of BOTH def and setv\nAnd replace with := (a la ALGOL). Now they both feel like what they are--an assignment to a variable. \nWhy :=? Well = was already taken to mean ==. Confusing the two is a common source of errors in C. (Not using ALGOL's := is widely considered one of C's historical design flaws.) \nPython fixed this by not counting = statements as expressions, so they can't accidentally be used as one. Hy has unfixed this since everything works as an expression, but mostly made up for this by having setv/def for assignment instead. \nEdit: We should probably rename Hy's = to == in this case, just so the problematic default typo of = when either := or == was intended isn't allowed.\n. Alternative proposal 2:\nMake def and setv different enough to be worth another keyword.\nLike I said before, filling keyword quotas is poor language design.\nBut there have been proposals to kind of enforce the existing convention for def, so perhaps we could try to enforce that better.\nThe best I've come up with is to make def a macro that asserts the target hasn't been assigned to yet. This is what you want for a constant. So you can only def any given symbol once. At least not without using an explicit del on it in between redefs. You can still setv a defed variable though.\nMany languages distinguish between delcaring a variable and assigning to it, and also variables vs constants--both points Python kind of glosses over. You could use the new asserting def for either purpose.\nWe could have our linter (hydiomatic) emit a warning whenever an earmuffed symbol was setv'd, but not when defed.\nWe could also have a convention that variables are declared with def and altered with setv, though this seems terribly unPythonic to me.\nOne question I still have is\nHy\n(def foo \"foo!\")\n(defn foonorf []\n  (def foo \"footwo!\"))\nShould the above case trigger the assertion or not? You're not overwriting the global, so I'm inclined to answer \"not\". But this assertion would be a bit more difficult to implement in the def macro. We also have nonlocal and attributes to worry about.\n. I suppose runtime could work. We could even have a def macro expand into the equivalent Hy, if that's easier. But remember that def also works on attributes when the target symbol contains a dot. So you also need to catch AttributeErrors.\nI didn't understand how this works in nested scopes at first, but it does seem to work. I was expecting UnboundLocalError rather than NameError if anything, but it turns out that UnboundLocalError is a NameError. So I'm not confident I can predict how this will work in other cases, like nonlocals or class definitions. It would need more testing at least. (AttributeErrors, don't count as NameErrors, btw.)\n\nAlso, what about the proposal for def always making the target global?\n\nI'm including that in the \"But there have been proposals to kind of enforce the existing convention for def...\", from the OP. The reason I'm not considering this as an alternative is that I don't approve. \nGlobal variables are considered harmful. It scatters state dependency throughout the program. This is a problem OO encapsulation was made to address, though (in practice) mutable fields can be almost as bad if you aren't careful. We really don't want to encourage this in Hy by giving it dedicated syntax. We already have global, and that's (bad) enough.\nGlobal constants, on the other hand, are not so bad. Every top level class, function, and macro name is effectvely used as a global constant anyway. We can manage these pretty well with namespaces. We don't need global or a global def syntax to use read-only global constants, since Python already allows you to read from enclosing scopes without any special syntax. You just can't assign to them.\n. A variation on alternative 2:\ndef creates a local (locals are still global at toplevel)\nsetv can't create a new variable. It assigns to a nonlocal. It would macroexpand into a nonlocal statement followed by an assignment, e.g.\nHy\n(setv a 1 b 2)\n;; expands to\n(do\n  (nonlocal a b)\n  (def a 1 b 2))\nPython\nnonlocal a, b\na = 1\nb = 2\nI don't think multiple nonlocal statements with the same variable are allowed in Python, but we could allow it in Hy by filtering duplicates from the AST. So multiple setvs on the same variable will still work.\nAnd, of course, nonlocal doesn't work in Python2. We could simply disallow setv the same way we disallow nonlocal. If we somehow port nonlocal to Hy in Py2 before Python2 becomes too obsolete to bother, we can enable it again.\n. ## Update\nAfter my original proposals, Python has added a new option to declare a variable before assignment. See PEP 526 -- Syntax for Variable Annotations These do have runtime effects, so Hy will need to support them anyway for compatibility.\nI think it's likely that Python's new optional static type checker, mypy, will be able to declare constants python/mypy#1214. This would have no runtime effect, but the static type checker could catch a violation in most cases. Once we've added variable and function annotation syntax to Hy I'd like to see if mypy is compatible. I think it can check the AST in Python 3 instead of the text, so it should work.\nThese annotations can also be used by metaclasses and decorators, and are already being used in the standard library--see the workaround for NamedTuple I had to use to answer this StackOverflow question. So Hy needs a syntax for this to fully support the standard library, not just for the linter.\nSo rather than expand to some awkward runtime assertion for constants, let's just do it Python's way when it's available.\nThen how should an advance type declaration look in Hy? From the PEP, we can see that it can be done  either in an assignment statement, or in advance of it. So it might make sense to put it in the def form somehow. (And perhaps not in setv.) So (def foo str) would compile like the foo: str declaration in Python, and (def foo str \"Foo!\") would compile like the declaration with assignment foo: str = \"Foo!\". This means it can't take multiple pairs like setv anymore.\nBut mypy uses both variable and function annotations. They should have a consistent syntax. We should seriously consider adopting Clojure's ^ metadata syntax to mean Python's annotations in both cases. We'd want to rename the bitwise operators to free up ^ for the metadata syntax. And also | for symbol quoting #1117, and & instead of &rest (like Clojure), and we can make the grammar for ~ more consistent. (It currently depends on whitespace to distinguish an unquote from a bitwise-not.)\nWe're only using def in the first place to be like Clojure. def starts a function declaration in Python, which is a completely different meaning. If we want to support dynamic/special variables (#1089),  we should probably reserve def for that purpose, since Clojure's special variable equivalent is its \"thread-local var\" ref type, which it defines using def.. @kirbyfan64 do you know what happened after python/mypy#590? Could mypy be made to work on Hy on Python 3.6+ if we put the type annotations in the AST? Would stub files work now?. @hylang/core @vodik I'm uncomfortable dictating new syntax without feedback. Variable annotations could be coming in #1475. \nThe current proposal.\n(def foo str)  ; foo: str\n(def foo str \"Foo!\")  ; foo: str = \"Foo!\".\nThat means def can't do multiple pairs like setv anymore. If you want to declare multiple pairs we either have to use multiple defs or distinguish the type from the variable name somehow.\nOption A\n(current proposal--multiple defs)\n(def foo str)\n(def bar int 42)\nOption B\n(Clojure-like--use ^ to distinguish type from variable name)\n(def ^str foo\n     ^int bar 42)\nB may be more consistent with function annotation proposals. #656, which follow Clojure syntax for this kind of thing (like we're already doing for most of Hy). It would be nice if these were consistent.\nBut Option A gives us an excuse to keep both def and setv.\n~Option C~\nmake def work as in option A, and make setv a macro using the ^ annotations that expands to def(s).\n(setv ^str foo\n      ^int bar 42)\nexpands to\n(do\n  (def foo str)\n  (def bar int 42)). Wait, def in Option A has no way of assigning a variable without a type, so we can't expand setv to that as in Option C. It still has to be a special form.. > Using sigils in Lisp is always a bit weird.\nLike the ' ` ~ ~@ : \"sigils\" we already use? Clojure does it with ^.\n\nThat Generator expression is effectively (get Generator (, User None None)) which is going to get unwieldy fast.\n\nDoes (. Generator [(, User None None)]) look any better? It's equivalent in Hy. Tuples inside [] come up a lot in Python, especially with numpy slices. Maybe Hy just needs better syntax for this. But how would you want it to look in general? Hy's tuple sytnax has an overhead of (,) three characters, but then we never need a comma between elements. For four or more elements, Hy's syntax is more compact that Python's. Maybe the . DSL could implicitly add a tuple if the lists have multiple elements, e.g. (. Generator [User None None]).\n\nprovided a mechanism for defining new type aliases and types\n\nI thought Python could already do type aliases via the Typing module. So ints = List[int] is (setv ints (. List [int])) in Hy. I'm not sure what else you want here.\n\nonly support string annotations\n\nIt seems a little weird to me to write annotations in Python when we're writing everything else in Hy. We want our code to be made of data structures so we can manipulate it with macros. If we have to manipulate strings to do our metaprogramming, we might as well just use Python.. I think it does. I did implement the improved partition #928, but had to change the argument order from Clojure's, since Clojure-style arity overloading still isn't available in core. I'm not sure we should move it into core just yet though.. It seems to work for me, strange.\n``` Python\n(env-hy2) C:\\Users\\ME\\Code>py\nPython 2.7.10 (default, May 23 2015, 09:44:00) [MSC v.1500 64 bit (AMD64)] on win32\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n\n\n\nimport hy\ndef hyeval(code,env,name):\n...   hy.importer.hy_eval(hy.lex.tokenize(code),env,name)\n...\nhyeval(\"\"\"(defn foo [] (print 'fnord))\"\"\",globals(),'repl')\nfoo()\nfnord\n```\n\n\n\n@fragrans, did you get your Hy from github or PyPI? Hy has changed significantly since the last release, but I don't know what would explain this.\n. > That will not break the existing API \nI'm not too worried about that at the moment. We've been breaking API every release, and have more breaking changes planned.\nThat said, Hy's get is not the same as Clojure's get-in, which puts the keys list in brackets and also takes a default afterwards. Rather, it's the special form that corresponds to Python's [] (subscript) operator. Like + (and many other Python binary operators) it's been adjusted to be variable-arity to better work in a Lisp. Note that Python's operator module calls this getitem/setitem/delitem. So perhaps item would be a better name for it.\n\nClojure's get, which OP mentioned, doesn't rely on exceptions, but checks map's keys and length of an array or a string.\n\nExactly how would you compile that? Catching the exception might actually be easier. Both IndexError and KeyError are instances of LookupError, so we could catch them both. But I'm worried we might catch an exception we shouldn't.. Thinking about this some more, we could probably write a macro to do this, and avoid catching extra exceptions with gensyms.\nHy\n(defmacro/g! get [coll key &optional default]\n  `(do\n     ;; eval coll & key outside try\n     (setv ~g!coll ~coll\n           ~g!key ~key)\n     (try\n       (. ~g!coll[~g!key])\n       (except [LookupError]\n         ~default))))\nBut this doesn't really seem better than a simple function. The only advantage is that it doesn't have to evaluate the default expression.\nPython\ndef get(coll, key, default=None):\n    try:\n        return coll[key]\n    except LookupError:\n        return default\nBut by then why not use .get?. >  tests took the longest because I kept messing up the slashes.\nPython's raw strings should help with that. The test would be a lot more readable as:\nPython\nobjs = tokenize(r'''\nr\"a\\\nbc\"\n''')\nassert objs == [HyString(r'''a\\\nbc''')]\nThis way you can see the intended Hy exactly as written. Future readers of the tests won't have to be as confused. Also a comment mentioning the DOTALL flag in Python's re might better clarify the purpose of the change.\n. :+1: \n. Maybe. It's not documented, so I'm not sure. And many of my use cases would need a shorter alias.. The Emacs docs on eval-when-compile says it's kind of similar.\n\nElsewhere, the Common Lisp \u2018#.\u2019 reader macro (but not when interpreting) is closer to what eval-when-compile does.\n\nUnlike Hy, in Emacs\n\nThe result of evaluation by the compiler becomes a constant which appears in the compiled program. \n\nBut since Hy's version doesn't expand to anything, it can't be used that way.\nBut how can we make a constant appear in the compiled program? As my first attempt demonstrated, only certain data types have a Hy model. To get an arbitrary object into the compiled file, it would have to be serialized somehow. Sounds like a job for pickle.\nAs a first attempt,\nHy\n(deftag \".\" [expr]\n  (import pickle)\n  `((. (__import__ \"pickle\")\n       loads)\n    ~(pickle.dumps (eval expr))))\nThis does have some runtime overhead. It's not a big deal at the toplevel, but in a nested loop, that would be pretty bad--and that was a major motivation for doing #. in the first place.\nI think we can overcome this problem with memoization.\n```Hy\n(import pickle)\n;; you can memoize with functools in Python3...\n(defn loadstatic [bytestr &optional [_memo {}]]\n  (try\n    (get _memo bytestr)\n    (except [KeyError]\n      (assoc _memo bytestr (pickle.loads bytestr))\n      (loadstatic bytestr))))\n(deftag \".\" [expr]\n  (loadstatic ~(pickle.dumps (eval expr))))\n```\nThis way it would only get unpickled once.loadstaticcould be a core function, or we could have the compiler do it with a special form or a newHyStatic` Hy model type or something.\nThere's two more problems with this though.\nFirst, if you pickle two equal mutable objects, then the memoization will make them point to the same instance. We can avoid this by adding a gensym to the lookup key, e.g. (loadstatic ~(pickle.dumps (, (gensym) (eval expr))))). This gives a different instance per expansion.\nAnd secondly, pickle is also limited in the data types it can serialize. It can't even do lambdas. But there are more capable third-party serializers, like dill. But that's another dependency. Maybe we could try importing that, and fall back to pickle if it's not available.\n. >  I would've thought @gilch would like this.\n:+1: \nI might have said so sooner if you had an example of what it changed, but it took a while to figure out what you were talking about. As it was it had to wait until I had the free time to test it.\nSomething like this...\nBefore:\nHy\n=> (if 1 1 (if 2 (setv x 2) (if 3 3)))\nif 1:\n    _hy_anon_var_2 = 1\nelse:\n    if 2:\n        x = 2\n        _hy_anon_var_1 = x\n    else:\n        _hy_anon_var_1 = (3 if 3 else None)\n    _hy_anon_var_2 = _hy_anon_var_1\nAfter:\nHy\n=> (if 1 1 (if 2 (setv x 2) (if 3 3)))\nif 1:\n    _hy_anon_var_1 = 1\nelif 2:\n    x = 2\n    _hy_anon_var_1 = x\nelse:\n    _hy_anon_var_1 = (3 if 3 else None)\nI should probably just set up another virtual environment so I can compare a new branch side by side with the current version.\n. Also, put the reference #842 in the comment not just the title, so we can click the link instead of copy-pasting. It makes it easier to follow.\nI also noticed that this improves cond because it's implemented in terms of if.\nOne other thing I think mentioned in #842, in Common Lisp, cond has an else part too, so\n``` Lisp\n* (cond (nil 0) (1))\n1\n```\nis the same as\n``` Lisp\n* (cond (nil 0) (t 1))\n1\n```\nbut without a wasted check at the end. Hy should support this to, so\nHy\n=> (cond [nil 0] [1])\n(0 if None else 1)\nshould work, instead of the nearest approximation we have now:\nHy\n=> (cond [nil 0] [True 1])\n(0 if None else (1 if True else None))\nWhich has the wasted if True. Since this closes #842, now would be a good time to fix it. Or I can open it as new separate issue if you prefer.\n. Can we merge this yet? Travis says the build failed, but I think that was a different issue. Is there some way to force a retest?\n. I'd merge it myself, but the failed check is making me uncomfortable. The false positive could be masking a real positive.\n. hy2py would certainly be more useful if the output was valid Python. With that we could use Hy with things that expect Python code instead of compiled Python. (Cython?) \nI wonder if we could add a switch to the tool to make it convert all the identifiers to their punycode equivalents? Would that be enough to make all the output valid Python?\n. In #934 @kirbyfan64 pointed out that Cython uses a custom parser, so it needs source code, not just a compiled module. Hy doesn't support Cython's type annotations, but you supposedly get considerable speedup even without them. If you just imported a Hy module from a Cython program, there wouldn't be any speedup for the Hy module, but if hy2py could generate valid Python, then you could compile that output with Cython and get the speedup.\nI also wonder about Pyjamas, which lets you run Python in the browser. It's supposed to generate JavaScript from Python AST, but they're probably making assumptions about it containing valid Python identifiers. I haven't actually tried it, but I don't think Hy would work. But if hy2py could generate valid Python, then you could translate that output to JavaScript using Pyjamas, and use Hy in the browser.\n. #929 will also remove zipwith.\n\nI never realized that map already took multiple iterables.\n\nI imagine that most Hy users not familiar with Python would miss that. Maybe even some Python users haven't noticed. I'm not sure what to do about that. It's still redundant and should be removed. Perhaps we could point it out in the tutorial or something. Perhaps we should re-document all Python builtins, or at least feature link to that page in the Python docs prominently.\nHaskell's prelude and Clojure's core have a lot of useful functions for FP. I wonder if we should port more of them to Hy core. I also wonder how much of that Python already supports somehow.\n. I should also point out that xi can be used to re-order arguments if necessary.\n. Understanding that link will take some more study, but it looks like those decorators are rewriting the Python bytecode. It also looks like the functions could run faster with the bytecode approach, though it might take longer to create them than with my AST approach.\nWill the bytecode approach still work in PyPy? I thought one of the main advantages of generating AST over writing bytecode was better compatibility with other Python implementations and versions numbers.\nIronPython's and Jython's bytecodes are supposed to be very different from CPython's. (Does Hy's AST approach even work on those?) If it does, you'd have to rewrite the nonlocal decorators for each implementation of Python2. The alternative Python implementations are slower to adopt Python3 and thus stand to benefit the most form a Hy nonlocal implementation.\n. I was away today and trying to read the Python on a tiny phone screen. I'm afraid I didn't quite get that far. Re-read description:\n\nThis module is a nonlocal patch for Python 2.7 and PyPy. \n...\nThis is very hackish and plays with CPython internal implementation stuff that PyPy just happens to be compatible with. YOU WERE WARNED!!!\n\nIt looks like our tox isn't set up to test IronPython nor Jython. If Hy wasn't compatible with them in the first place, perhaps it's a moot point, but it looks like rewriting bytecode won't work with them. (Or at least not in the same way.)\nDo the bytecode decorators work if you skip over a nested function?\nPython\n@export_nonlocals('var')\ndef outer():\n    var = 0\n    def middle():\n        @nonlocals('var')\n        def inner():\n            print var\n            var = 1\n            print var\n        inner()\n    middle()\nouter()\nTraceback (most recent call last):\n  File \"<pyshell#162>\", line 1, in <module>\n    outer()\n  File \"<pyshell#161>\", line 11, in outer\n    middle()\n  File \"<pyshell#161>\", line 5, in middle\n    @nonlocals('var')\n  File \"nonlocals.py\", line 104, in func\n    freevars[freec:])))\nKeyError: 'var'\nNope. That's a problem. The equivalent Python3 works.\nPython\ndef outer():\n    var = 0\n    def middle():\n        def inner():\n            nonlocal var\n            print(var)\n            var = 1\n            print(var)\n        inner()\n    middle()\nouter()\n0\n1\nIs it possible to use both the @nonlocals and @export_nonlocals decorators on the same function?\nPython\n@export_nonlocals('var')\ndef outer():\n    var = 0\n    @nonlocals('var')\n    @export_nonlocals('var')\n    def middle():\n        @nonlocals('var')\n        def inner():\n            print var\n            var = 1\n            print var\n        inner()\n    middle()\nouter()\nTraceback (most recent call last):\n  File \"<pyshell#165>\", line 1, in <module>\n    outer()\n  File \"<pyshell#164>\", line 13, in outer\n    middle()\n  File \"<pyshell#164>\", line 7, in middle\n    @nonlocals('var')\n  File \"nonlocals.py\", line 104, in func\n    freevars[freec:])))\nKeyError: 'var'\nThat doesn't work either. The AST approach can do this though.\n. I also wonder about mobile Python implementations. For Android, I'm aware of SL4A and Kivy (actually the sister project https://github.com/kivy/python-for-android). I think someone (Edit: xikuuky) mentioned getting Hy working on Android over IRC, but I don't know which one. I'm not familiar with any Python on iOS, but that possibility might also be worth looking into.\n. I thought we unit tested this? I suspect that you're using an older version of Hy that had a different syntax for defclass. Try getting the current version of Hy from github if you haven't already. It should work.\n. locals() is effectively read-only due to optimizations. I don't think this helps with that. Perhaps if we combined it with the piggyback stack from #933.\n. :open_mouth: I found a way to make locals() writable:\n``` Python\n\n\n\ndef foo():\n...   locals()['spam'] = 42\n...   return spam\n...\nfoo()\nTraceback (most recent call last):\n  File \"\", line 1, in \n  File \"\", line 3, in foo\nNameError: global name 'spam' is not defined\ndef bar():\n...   exec \"pass\"\n...   locals()['spam'] = 42\n...   return spam\n...\nbar()\n42\n```\n\n\n\nThis doesn't work in Python 3, but we do have nonlocal there. Is this enough to make let work!?  \n. I was referring to @Foxboron's insufficient coffee idea: #664.\n\nThis isn't really hard. We could just pass along **locals() into the function.\ndef _hy_anon_fn_1(**locals()):\n\nI don't think this would fix let's yield issues though. At best we could use it to backport nonlocal to Python2, and maybe only CPython2. let is still dead to me.\n. Yes it does work, but you're not the first to notice this \"problem\". (See #940, #942.) We've been making changes that break backwards compatibility. \nUse the docs that match the version of Hy that you're using. Since you got Hy from PyPI, you should be using the stable docs. But you're reading the latest docs, (which would work fine if you got Hy from github). Find the green link at the bottom-left and change from latest to stable, or get the latest Hy from github.\n. Waiting for my approval?\n:+1: \n. > true for all but !=, which would be false\nStrange, Clojure and Common Lisp seem to disagree on this point.\n``` Lisp\n* (/= 1)\nT\n```\nClojure\nuser=> (not= 1)\nfalse\n. Remember decorators can also apply to classes. I think I like the reader macro better.\n. I'm starting to reconsider this one now that I've started using the #@ version with git. I'm coming around to @kirbyfan64's first suggestion:\n(defn [inc-decorator] addition [a b] (+ a b)\nWe would also need to do that for classes.\n(defclass [some-decorator] Foo ...\nThink about how lines will change in version control if you have to wrap the whole function. It will mean re-indenting the whole thing when you just added a decorator on top. Python decorators don't have this problem. You could also spread the list over multiple lines to have a good way of changing and re-ordering decorators with version control.\n(defn [\n       foo\n       bar]\n  some-function [args]\n  .... Another reason to change it is for code folding. If you fold everything in your editor, you'd really want the first line of the top level form to have the class or function name. Look what the current decorator syntax does to an excerpt of #1328 when folded:\n```\n@((_dest-setup 'destructure-dict)...)\n@((_dest-setup 'destructure-dict)...)\n@((_dest-setup 'destructure-dict)...)\nWe can't tell them apart anymore. With the proposed syntax, the first one folds like\n(defn [_dest-setup] dest-dict [ddict result extend found binds gsyms]...)\nYou could even add multiple decorators on the same line, like\n(defn [_dest-setup foo bar] dest-dict [ddict result extend found binds gsyms]...)\nIt's an improvement, but once you take multiple lines, the name disappears when folded.\n;; top level fold\n(defn [_dest-setup...)\n;; unfolded one level\n(defn [_dest-setup\n       foo\n       bar] dest-dict [ddict result extend found binds gsyms]...)\n```\nSo perhaps the function name should still come first. But then where do the decorators go?\nIf you put it right after the name, it looks like the arguments list. And a function needs to be able to return a list, so it probably shouldn't go next (even though we do that with docstrings, because Python). So how about putting it first and using @ to distinguish it from the arguments list like this?\n(defn dest-dict @[_dest-setup foo bar] [ddict result extend found binds gsyms]...)\nWhen folded and the decorators list is spread over multiple lines, you'd still lose sight of the arguments list--\n(defn dest-dict @[_dest-setup...)\n--but decorators can change that anyway, so they're more important to put first. Of course, this is optional. When there's no @ after the name, the compiler doesn't add any decorators, and the next list is the args list.\nClasses would have to work the same way.\n(defclass foo-class @[foo-decorator bar-decorator] [foo-superclass]...). Or you can define the class as normal and then afterwards (setv MyClass (mydecorator MyClass)), which is basically what the decorator syntax is sugar for.\nAn anonymous class doesn't really make sense, since you often need to refer to its name in methods and for inheritance. Even type requires a name argument. It's awkward enough that Hy sometimes gives fn output a .__name__ like '_hy_anon_var_1'. Hy is smart enough to handle (setv foo (fn[] \"doc\" None)), but not e.g.\n (setv (, foo) [(fn[] \"doc\" None)]). It doesn't come up because it's not used much, but I think this kind of mismatched metadata would be much worse for classes.\nI wonder if the class form could return itself instead of None. Then you could just (setv MyClass (mydecorator (class MyClass [] ...))). Actually, that doesn't seem that much easier.\nWhen interfacing with Python libraries, decorators and metaclasses could come up a lot. It probably shouldn't have any more ceremony than Python does. I don't really have a better idea than adding them to the function and class forms. I'm reluctant to make the special forms any more complex than they already are because that complicates let. But these could certainly be implemented as macros that expand to the with-decorator form. We probably don't even need decorators for fn (just nest it). defn and defclass will do.. Thinking aloud again.\nAnother syntax idea: just list the decorators after the name and before the []. E.g.\n=> (defn foo bar (baz x y) [a b c] ...)\n@baz(x, y)\n@bar\ndef foo(a, b, c):\n    ...\nDecorators are either symbols or HyExpressions. The list is terminated with the arguments HyList. A macro can tell the difference.\nThis re-orders the same way as ->, which is opposite the order Python writes it. Might be confusing.\nIf you do it the other way, you lose the obvious function name, especially when code folding:\n(defn (baz x y) bar foo [a b c] ...)\nMaybe you just indent it differently as a matter of standard style:\n(defn (baz x y) \n      bar\n      foo [a b c]\n  ...)\nThat looks more like Python, but doesn't help with the folding.\nMaybe you could just wrap the name to make it look like a call.\n(defn ((baz x y) (bar foo)) [a b c] ...)\nThat's pretty explicit (reminds me of scheme functions) I feel like rewriting it to use -> because I don't think it's that easy to read.\n(defn (-> foo bar (baz x y)) [a b c] ...)\nBut this isn't quite what -> means. It would expand to (baz (bar foo) x y), which is wrong.\nMaybe we could use a @: macro (can't just use @, that's an operator) instead of the #@ tag macro, which could dump its body into a defn or defclass, depending on which keyword is specified:\n(@: (baz x y)\n    bar\n    :defn foo [a b c]\n  ...)\nNote that the body indent need not be changed now, even if the decorators are removed. This makes it play more nicely with version control. It also looks more like the Python.\n(@: :defn foo [a b c]\n  ...)\n;; same as\n(defn foo [a b c]\n  ...)\nIt's also a bit easier to add decorators this way in the editor, since you don't have to wrap more parentheses. Just insert @: : before the defn or defclass then add the decorators in between the :'s.. > {:decorate inc-decorator}\nMetadata could work, I suppose. Macros can see it after all. But what if you want to attach more than one? The above syntax doesn't quite work. You'd have to wrap it in a list or something.\n{:decorate [(baz x y) bar]}\nIt would be shorter if you just called it :@.\n{:@ [(baz x y) bar]}\nThat's still a lot of brackets.. An issue from #924, uncovered by testing #903, rather, for the record.\n. I think we've lost our purpose here.\n```\n=> (let)\n  File \"\", line 1, column 1\n(let)\n  ^---^\nHyMacroExpansionError: expanding `let': missing 1 required positional argument:\n'_0'\n```\nWhat's a '0'? The whole point of #924 was to _improve the error messages. At least the TypeError we had before said the missing argument is named \"variables\". This is worse. As it stands, we'd be better off reverting #924 altogether than accepting this fix for it.\nWhy exactly was it failing for Python2? Can we make it work in Python2 by building the lambda from AST instead of a string? Do we know why exactly the getargspec was failing for only certain macros? Can we fix the macro system so it returns supported callables instead of giving up on unsupported callables? (Whatever \"supported\" means?)\n. The question is how to distribute it fairly. I'm sure we're not the only project with this \"problem\", so maybe somebody has solved it. I stumbled across https://whispersystems.org/blog/bithub/ recently, which looks like an option. I have no idea how well it works in practice because it seems like it might create some perverse incentives.. Checks are failing. Also needs unit tests.\n. @kirbyfan64: Can you rebase on current master (for testing)?\n. I was inclined to agree with that. For maximum flexibility macros have to get everything quoted, including keywords themselves.\nI thought it would be simple enough to include an inner function to handle keyword arguments in a macro definition. Something like this:\n`` Hy\n=> (defmacro foo [&rest args] (apply (fn [&kwonly b](print ~b)) args))\nimport hy\nfrom hy import HyExpression, HySymbol\n@hy.macros.macro('foo')\ndef _hy_anon_fn_2(*args):\ndef _hy_anon_fn_1(*, b):\n    return HyExpression((([] + [HySymbol('print')]) + [b]))\nreturn _hy_anon_fn_1(*args)\n\n=> (foo :b 42)\n  File \"\", line 1, column 1\n(foo :b 42)\n  ^---------^\nHyMacroExpansionError: expanding `foo': TypeError('_hy_anon_fn_1() takes 0 posit\nional arguments but 2 were given',)\n```\nBut that doesn't work.\n. I wonder if we should reconsider the all the other & parameters. Clearly we need &rest. I'm not sure about how &key works, because it's not documented. What about &optional? It should work positionally, but we can't skip over an optional arg with a keyword. And what about &kwargs? I don't think macros can use that properly either?\n. I think you could put an invalid macro declaration in a try form and catch the HyTypeError. Something like this:\nPython\ntry:\n    <test code>\n    raise Exception(\"HyTypeError expected\")\nexcept HyTypeError:\n    pass\nThe testing framework might even have a decorator for this kind of thing. I'd have to look at the docs.\n. I checked, and nose does have a decorator for this: nose.tools.raises. We don't seem to be using nose.tools in any tests, but I did see the try pattern I mentioned above. This should also work as a native Hy test.\n. This test won't fail if defmacro starts accepting &kwonly again. Read it carefully. It only asserts that if there's a HyTypeError, that it has the stated message. If there's not an error it doesn't complain.\nHy\n(try\n    (eval '(defmacro f [&kwonly a b]))\n    (except [e HyTypeError]\n      (assert (= e.message \"macros cannot use &kwonly\"))))\nYou need to detect the case where no exception happens, something like this:\nHy\n(try\n    (do \n      (eval '(defmacro f [&kwonly a b]))\n      (raise (Exception \"HyTypeError expected for &kwonly in defmacro\")))\n    (except [e HyTypeError]\n      (assert (= e.message \"macros cannot use &kwonly\"))))\n. We've got merge conflicts now, can you fix those?\nThere's a good enough case for keeping &optional, I think. I'm still not sure about &key though. The only documentation on &key says:\n\nThe difference here is that since it\u2019s a dictionary, you can\u2019t rely on any specific ordering to the arguments.\n\nYet we must rely on ordering of the arguments in a macro because we can't supply them using keywords.\n. What possible use is &key in a Hy macro? That still doesn't appear to be disallowed by this PR. Show me a good use case and I'll merge it now, otherwise, can you give an error for &key too?\n. Okay, so it's a little bit documented. The tutorial is not a reference. There's nothing under the &key heading in the reference for defn, and there should be.\n. Just realized this kind of breaks lif. The 2- or 3-arg versions work as before, but truthiness is Pythonic for the elif (ellif?) clauses, which would be surprising. I wonder if there are other unintended consequences. I think I'll have to rewrite lif, but it doesn't look difficult.\n. Hm. Why is this failing? I ran nosetests before committing \"variadic lif\" without trouble. What was merged between my two commits? #920 \"if-no-waste\" (05857544f1cedadf69cb3393ec4d4a42eee64b61) and #950 \"f/one-arg-comparators\" (b875feccff5943a51df9e81ce7b4906e8acbcea5).\nThe complaint is \nHyMacroExpansionError: expanding `cond': UnboundLocalError(\"local variable '_hy_anon_var_1' referenced before assignment\",)\nThat is not supposed to be possible just from writing a macro. Something's wrong with the compiler.\n. I think I found it. The \"if-no-waste\" is looking for 'if', but should look for 'if*' now.\n. @hylang/core variadic if looks ready, but need second ack to merge.\n. There's really no need for getc since you can pass around _getitem__ itself, so you could do (. [1 2 3] __getitem__) for the same effect. Because the dot access is on an instance, not the class, the implicit self argument is automatically curried.\nIs the speed issue really that bad? Somehow we've got \"callable\" keywords, even though they're just strings to Python. How does that work?\nYou don't have to do the check first. Assume that it's a callable if it starts a Hy expression. If the call fails, catch the exception and retry with __getitem__.\n. There's really no need for getc since you can pass around _getitem__ itself, so you could do (. [1 2 3] __getitem__) for the same effect. Because the dot access is on an instance, not the class, the implicit self argument is automatically curried.\nIs the speed issue really that bad? Somehow we've got \"callable\" keywords, even though they're just strings to Python. How does that work?\nYou don't have to do the check first. Assume that it's a callable if it starts a Hy expression. If the call fails, catch the exception and retry with __getitem__.\n. No, I didn't mean to put the try check in at run time, but at compile time like the :keywords. But I guess with Python's duck typing this information isn't available yet. An arbitrary symbol could be anything at compile time (but then how do macros work?).\nThe best we could do at compile time is detect if the literal syntax [] or {} is in the function position, which still seems worth doing, since \"callable\" collections are commonly used that way anyway. If you need to pass a callable collection to map or something, you can still use the __getitem__ trick.\n. > What's the point of callable collections if they're literals?\n@kirbyfan64 just because the collection is a literal doesn't mean the argument to it has to be:\nHy\n;;  contrived example just to show how it works, I wouldn't actually use it this way.\n=> ({\"January\" 1 \"February\" 2 <etc.>} (get-current-month-name))\n{'January': 1, 'February': 2, <etc.>}[get_current_month_name()]\n10\nEasy inline lookup tables with minimal ceremony. In some circumstances this is a simpler alternative to cond.\nAlso note, only the fact that it's a collection literal must be known at compile time, not what's in it. Elements can be computed at run time:\nHy\n=> [(+ 2 3) (* 2 3)]\n[(2 + 3), (2 * 3)]\n[5, 6]\n. I think the tuple special form (,) should also support this. It could also be detected at compile time.\n. Ref #967\n. Squashing the minor fixes into the first commit would be good. We like to keep minor fixes like that out of master to make it easier to navigate.\nIn case you're not familiar with the git command line, make sure you have this branch checked out and use git rebase -i HEAD~3 to squash them into one commit, then git push origin anaphoric-import-info-missing --force to make your github branch match your local repo so we can merge it.\n. Looks like one of them squashed though. It should pop up a script for you to edit. The script comments explains how it works: change \"pick\" to \"squash\" except for your first commit. Then save the script and git will use it when you close the editor. There's only two commits now, so use HEAD~2 this time. \n. I think I saw extra brackets in a with. The style guide following the tutorial also has extra brackets in a let. We should probably work through the pre-reference part of the docs (Quickstart, Tutorial, Style Guide) with a repl to make sure everything still works. I doubt we'll catch everything just by looking.\nSome of the pending Grand Language Cleanup changes may break this again, so maybe we should wait until that's completed.\n. Maybe a cookbook is not a bad idea once we finish the Grand Language Cleanup, but before that it's premature, since we'd have to update it with every change. This will be hard enough as it is. I don't think we've updated anything in eg/ for a while.\nA cookbook is not a substitute for a basic reference. It's too hard to find more basic things like \"how destructuring works\" if the recipes are things like \"how to use Hy with Django\".\nHy depends a lot on Python's documentation. It would be a waste of time to reproduce the documentation for Python's standard library, for example. But perhaps we could make more explicit references to Python's documentation where appropriate.\n. Hy\n(defmacro defmethod [name &rest rest]\n  `(def ~name (fn ~@rest)))\n. In the new version you can just use defn directly in the class body, so there's no need for defmethod.\nHy\n(defclass X []\n  (def a 1)\n  (def b 2))\n. Using your example:\nhy --spy\n``` Hy\n=> (defclass X []\n... (defn --str-- [self] \"123\"))\nclass X:\ndef __str__(self):\n    return '123'\n\n```\n. I can confirm the error on master. It doesn't just throw an exception, but crashes the repl and kicks you back out into the shell. But only with Python2. It works fine using Python3:\n``` Hy\n=> (:)\n  File \"\", line 1, column 1\n(:)\n  ^-^\nHyTypeError: \\ufdd0:' needs 1 arguments, got 0\n```\n. should also add to tox?\n. Merge conflicts now. @kirbyfan64 have you figured out what's causing thegetargspecproblem?\n. It's a lot of complexity for marginal benefit over pre- #924. There's sixifs and atry/except`. All code paths need unit tests. Testing is maybe not as hard as it sounds, since it takes different Python implementations to reach these anyway, so a lot of the paths could be reached from one test.\nI'm still concerned about that try/except, since a the generic lambda it returns defeats the whole purpose of #924. Can you be more specific with the caught exception? Can you avoid generating an exception in the first place?\nYou can test #903 from that branch just by pasting the macro code in the repl.\n. The code to paste in:\n`` Hy\n(defmacro defmacro! [name args &rest body]\n  \"like defmacro/g! plus args that start with o! will automatically evaluate\n   once only and be bound to the equivalent g!\"\n  (setv os (list-comp s [s args] (.startswith s \"o!\"))\n        gs (list-comp (HySymbol (+ \"g!\" (cut s 2))) [s os]))(defmacro/g! ~name ~args\n     `(do (setv ~@(interleave ~gs ~os))\n          ~@~body)))\n(defn expensive-get-number [] (print \"spam\") 14)\n(defmacro! triple-3 [o!n] `(+ ~g!n ~g!n ~g!n))\n(triple-3 (expensive-get-number))\n```\n. > So now we'd also have to remove support for non-identifier arguments...\nThis is just for improved error messages, right? #924 introduced this problem. I don't think its worth restricting Hy like that just for better diagnostic information. We can come up with some other way to debug macros.. Closed by #1172. Checks passed with a new unit test; I approve. Docs may be getting easier anyway #1044. LGTM. @hylang/core \n. I'll merge it then. Closes #977\n. I'll merge it then. Closes #977\n. What would it take to adapt doctest to use a Hy repl instead of the Python one? The main reason you put tests in docstrings is to show examples of intended use. If the examples are in a different language it kind of defeats the purpose. You might as well just use normal unit tests.\n. Is this necessary anymore? GitHub has \"squash and merge\" button now. We can squash at merge time.\n. I like the idea of auto-generating the reference docs from the docstrings. They're not identical currently, so for each we'd have to pick the best of the two or merge them somehow. The examples could also be doctests, once we get that working for Hy code. (see #1019.) This way, we can always be sure the examples work as intended, and we can easily access the references from the repl.\nThe rest of the docs will still have to be updated by hand, but we should be able to automatically test the examples there too.\n. We could override Python's help function with a macro that checks if the symbol is a macro or built-in hy special form, and if so, fetches the appropriate docstring. If not, it can defer to the built-in Python help. This would help with #356 and #892.\n. Maybe more like this?\n``` Hy\n(defn hydoc* [sym]\n  (import hy)\n  (. (or (->> false\n              (.get hy.compiler._compile_table sym)\n              (.get (get hy.macros._hy_macros nil) sym)\n              (.get hy.core.shadow.dict sym)\n              (.get hy.core.language.dict sym))\n         (eval sym))\n     doc))\n(defmacro hydoc [sym]\n  `(hydoc* '~sym))\n```\n. You could override Python's interactive help using these too:\nHy\n(defmacro help [item]\n  (if (symbol? item)\n    `(print (hydoc ~item))\n    `((get __builtins__ \"help\") ~item)))\n. > Just curious is the hydoc* an indication it is a function (the * at the\n\nend) to differentiate it from the macro by the similar name?\n\nNot exactly. In mathematics, you often talk about some object g and some related object g' (g prime). In Lisp, the apostrophe is already taken to mean quotation, so we use * for this purpose. Usually you have a * form that is syntactically annoying to use doing the real work, and some nicer interface to it without the *. This is often, but not necessarily, a macro. Hy inherits some design philosophy from Clojure, where you see this pattern a lot internally. In Hy, for example we have for that uses for* and if that uses if*.\nIn this case, the macro lets us avoid quoting the symbol when calling the function, but we still have the function when we need it to e.g. map over a list of symbols and return all of their docstrings. This would be more difficult with only the macro.\nI'm less confident this is the right approach for Hy (at least in this instance), because of #1041, (Hy's eval doesn't work like Clojure, we might change that #1043.). We wouldn't need that eval if it was all in the macro. You could just unquote it.\n. The \"TODO\" docstrings in this PR are for:\n- [ ] except (used in try)\n- [ ] with* (used in with)\n- [ ] for* (used in for)\n- [ ] HyList (a Hy Model)\n- [ ] HySet (another Hy Model)\n- [ ] dispatch-reader-macro (used for reader macros)\n- [ ] eval-and-compile\n- [ ] eval-when-compile\neval-and-compile and eval-when-compile were never documented. I didn't know what these do either. I don't see them used anywhere but tests. My best guess is that they were borrowed from Emacs Lisp. The blame shows @khinsen creating them in #187, which confirms this. That PR, and the related issue #186, could help us document them.\n. The \"TODO\" docstrings in this PR are for:\n- [ ] except (used in try)\n- [ ] with* (used in with)\n- [ ] for* (used in for)\n- [ ] HyList (a Hy Model)\n- [ ] HySet (another Hy Model)\n- [ ] dispatch-reader-macro (used for reader macros)\n- [ ] eval-and-compile\n- [ ] eval-when-compile\neval-and-compile and eval-when-compile were never documented. I didn't know what these do either. I don't see them used anywhere but tests. My best guess is that they were borrowed from Emacs Lisp. The blame shows @khinsen creating them in #187, which confirms this. That PR, and the related issue #186, could help us document them.\n. It's not just modules. I found a simpler illustration:\n``` Python\n=> (def spam 42)\nspam = 42\n=> (eval 'spam)\nfrom hy.importer import hy_eval\nfrom hy import HySymbol\nhy_eval(HySymbol('spam'), locals(), 'console')\n42\n=> ((fn [] (eval 'spam)))\nfrom hy.importer import hy_eval\nfrom hy import HySymbol\ndef _hy_anon_fn_1():\n    return hy_eval(HySymbol('spam'), locals(), 'console')\n_hy_anon_fn_1()\nTraceback (most recent call last):\n  File \"\", line 1, in \n  File \"\", line 1, in _hy_anon_fn_1\n  File \"c:\\users\\me\\code\\repos\\hy\\hy\\importer.py\", line 134, in hy_eval\n    return eval(ast_compile(expr, \"\", \"eval\"), namespace)\n  File \"\", line 1, in \nNameError: name 'spam' is not defined\n=> ((fn [] (eval 'spam (globals))))\nfrom hy.importer import hy_eval\nfrom hy import HySymbol\ndef _hy_anon_fn_1():\n    return hy_eval(HySymbol('spam'), globals(), 'console')\n_hy_anon_fn_1()\n42\n```\nThe equivalent Clojure works:\n``` Clojure\nuser=> (def spam 42)\n'user/spam\nuser=> (eval 'spam)\n42\nuser=> ((fn [] (eval 'spam)))\n42\nuser=>\n```\nCommon Lisp too:\n``` Lisp\n* (defvar spam 42)\nSPAM\n* ((lambda () (eval 'spam)))\n42\n*\n```\nEven Racket Scheme (if anyone cares about Racket):\n``` Racket\n\n(define spam 42)\n((lambda () (eval 'spam)))\n42\n```\n. Heredocs usually require a newline at the end of the opening delimiter. This includes Racket's here strings. For a docstring this is what you want. For a short regex, maybe not. Other possibilities to consider are Lua's long brackets, which can do both. (Long brackets can be as long as you want.)\n\nLua\n[[\nspam]] -- same as \"spam\" (ignores first char if it's a \"\\n\")\n[=[\n[[spam]] ]=] -- same as \"[[spam]] \"\n[==[ [=[[[\"spam\"]]]=] ]==] -- same as \" [=[[[\\\"spam\\\"]]]=] \" etc.\nAnd C++11's raw strings, which let you pick arbitrary delimiters in between the quote and parens.\nC++11\nR\"foo(spam)foo\" // same as \"spam\"\nR\"bar(R\"foo(spam)foo\")bar\" // same as \"R\\\"foo(spam)foo\\\"\"\n. Travis is complaining. Also globals+locals isn't the current environment, since nonlocals don't work e.g.\nHy\n(((fn []\n    (setv spam 42)\n    (fn [] (eval 'spam)))))\n;; NameError\nBut something similar in Clojure would work:\nClojure\nuser=> (((fn [] (let [spam 42] (fn [] (eval 'spam))))))\n42\nIt also works in Hy without the eval:\n``` Hy\n=> (((fn []\n... (setv spam 42)\n... (fn [] spam))))\ndef _hy_anon_fn_2():\n    spam = 42\ndef _hy_anon_fn_1():\n    return spam\nreturn _hy_anon_fn_1\n\n_hy_anon_fn_2()()\n42\n``\n. Another potential issue:evalshould be able to mutate a global or local withsetv`. It currently can't mutate locals, but it can for globals. If you make a new dict with globals+locals, then eval can't update globals by writing to it either.\nOverall, Hy's eval seems to work more like Python's than like Lisp's. I wonder if this is the wrong approach. How does our REPL even function without a proper eval? Can we just use that for eval instead?\n. There's still the problem of assignment. What happens if you (eval '(setv foo 42))? I'm also not sure if that __code__ trick will work in non-CPython implementations (pypy? jython?), or at least not the same way. \nI'm not sure how well the _hy_current_function will work. I can see that if you can access a closure like that, can you could implement nonlocal in Python 2, but what happens in this case?\nPython\ndef _hy_anon_fn_1():\n    _hy_current_function = _hy_anon_fn_1\n    foo = 42\n    def _hy_anon_fn_2():\n        _hy_current_function = _hy_anon_fn_1  # used in _hy_anon_fn_3, so compiler put it in.\n        new_hy_eval(HySymbol('foo'),_hy_current_function)  # oops\n        def _hy_anon_fn_3(): ...\n. That does sound like a better plan, if it works. However, that would mean you can't pass eval to higher-order functions, like map. Is there a workaround for that? Maybe we need two evals.\n. I'd have to re-read the Sphinx documentation. We might have to experiment to find the best approach.\n\nI expanded some code you posted earlier\n\nI used the or/false short-circuiting trick to avoid evaluation. You don't need it in your macro (you evaluate sym anyway for do-import), so It could be simplified:\nHy\n(defmacro get-python-object [sym]\n  \"Get the Python object for the symbol SYM.\n  SYM is a function or module.\n  If SYM has a . in it, import the base module, unless the dot is the first character. We can't get these yet.\"\n  `(do\n     (do-import ~sym)\n     (try\n       (->> ~sym\n            (.get hy.compiler._compile_table '~sym)\n            (.get (get hy.macros._hy_macros nil) '~sym)\n            (.get (get hy.macros._hy_macros \"__main__\") '~sym)\n            (.get (get hy.macros._hy_macros \"__console__\") '~sym)\n            (.get (vars hy.core.shadow) '~sym)\n            (.get (vars hy.core.language) '~sym))\n       (except [e NameError] None)))\n. I tried out autodoc a bit. It can get us surprisingly far, but it chokes on function names that are not valid Python identifiers. Sphinx is supposed to be pretty extensible though. We might be able to implement our own extension for Hy files. This would also be useful tooling for third-party Hy users to have.. Hy doesn't always import things until it needs them. You can use hy --spy to see what's going on. (--spy attempts to show you the Python code that would generate the same AST Hy has generated.)\n=> HyDict\nHyDict\nTraceback (most recent call last):\n  File \"<input>\", line 1, in <module>\nNameError: name 'HyDict' is not defined\n=> '{}\nfrom hy import HyDict\nHyDict([])\n{}\n=> HyDict\nHyDict\n<class 'hy.models.dict.HyDict'>\nThe key line is from hy import HyDict. You can do this yourself if you prefer.\n. Let's add the Hy models to core then.. I can think of one possible reason to restrict it to one character. Say we have a simple an example reader macro:\nHy\n(defreader % [x] `(print '~x))\nThen, with the current restriction, you can apply the reader macro directly to a symbol, like this:\nHy\n=> #%Hy!\nHy_bang\nBut if we allowed longer symbols, Hy would try to look up the %Hy! reader macro instead. This is easy to fix. Clojure simply requires a space in such cases, and Hy already allows this:\nHy\n=> #% Hy!\nHy_bang\nIt's probably good style to use a space when applying reader macros to symbols anyway, but what if we applied it to a number instead?\nHy\n=> #%42\n42\nAgain, Hy would look for the %42 reader macro. I think this feels nicer without the space, but I still think the change would be worth it.. Maybe something like this?\nHy\n(defmacro as->\n  [head name &rest rest]\n  `(do (setv\n         ~name ~head\n         ~@(interleave (repeat name) rest))\n     ~name))\n. Some example uses from ClojureDocs: https://clojuredocs.org/clojure.core/as-%3E\n. #1048 was merged, perhaps prematurely. There's still a typo in its docstring. #1052 or #1049 might have required a change in the implementation of as->, had they been dealt with first. It still needs docs and probably a test.\n. I suppose I should add tests.\n. > It seems like the behavior may have changed since this was originally opened. \n@shellhead No, it's the opposite. setv has changed to allow multiple pairs from only one pair in the old PyPI version that you still seem to be using. Use the current github version for the new setv.. @Kodiologist I disagree, we broke API pretty seriously already for the Grand Language Cleanup (still pending). The time for more breaking changes is now, not later.. > Ah yes! Thats a better idea honestly. Should i make a another PR or should we include the rename in this?\n@Foxboron I never saw that other PR? You can do the rename in this if it's easier, otherwise can we merge this yet?. Python doesn't enforce any kind of consistency between __setattr__ and __getattr__ (or __delattr__ or __getattribute__), so Hy shouldn't assume this either.\n``` Hy\n=> (defclass Foo []\n... (defn setattr [self attr val]\n...  (print attr val)))\nclass Foo:\ndef __setattr__(self, attr, val):\n    return print(attr, val)\n\n=> (setv (. (Foo) eggs) 13)\nFoo().eggs = 13\nFoo().eggs\neggs 13\nTraceback (most recent call last):\n  File \"\", line 1, in \nAttributeError: 'Foo' object has no attribute 'eggs'\n```\nMutating methods in Python's standard library conventionally return None. Python's assignment statements, being statements, similarly have no return value. This is annoying in a Lisp, but Clojure has an elegant workaround called doto, which Hy has inherited.\nMaybe setv should simply return None. This is much more consistent with Python. If you need to use the value in an expression, use setv inside a doto.\n. Here's another failing example:\nHy\n=> (setv (get {} 'x) 42)\nfrom hy import HySymbol\n{}[HySymbol('x')] = 42\n{}[HySymbol('x')]\nTraceback (most recent call last):\n  File \"<input>\", line 1, in <module>\nKeyError: 'x'\nThis time it's asking a new dictionary for the value put in the first, which makes no sense.\n. We already have that problem with yield #663. I still think removing let altogether is our best option.\n. > However, we have to remember that this is just a one project and out there might code that uses let differently. At the minimum, I would like to see let macro like I described before.\nWe've totally broken API already. It's not just let. I sympathize, but we should just expect that all old code will break. let has very confusing behavior now if you think it should work like Lisp. Merely introducing a local should not break await/break/continue/yield. That's confusing. The macro replacement you propose would also be confusing, but for different reasons. No closures. No scoping. Why does it even have a body?\nIf we do put in a let macro that translates to setv, it had better be in contrib and marked as deprecated. I would rather fix old code or just use legacy Hy than have a core let that still makes no sense forever. If we don't have a let in core and we do eventually get it working, we can add it back in without breaking API again. If the setv let is already in core, we can't do that.\n\nBut I would be totally thrilled to see yield, await and co. work. Sorry for hijacking the ticket.\n\nSo would I, but nobody's figured it out after a year, not that we haven't tried #1055 #1000 #844 #688 #673 #664 #663.\nI have ideas on how it might be possible, but I still can't make it work. Keeping let as-is requires us to remove or replace the the things it breaks. I got a break/continue replacement working in #1055. Removing await and yield means giving up coroutines (I'd sooner give up let, wouldn't you?). Re-implementing await and yield might require some kind of functional coroutines. Maybe we could re-implement coroutines using something like Scheme's call/cc? Maybe someone who knows more Haskell or category theory than me could do it with a monad or something. Maybe it's enough to backport await to Hy on Python 2 using yield-from. I haven't used the new await coroutines enough to tell.\nIf we keep the things let breaks, then we have to remove or replace let. You already know what I think of that. But considering replacement possibilities, I think Emacs Lisp somehow managed to make a lexically-scoped let using dynamic-scope-only macros. Maybe if we had macroexpand-all we could do something similar. It could perhaps be done with our contrib walk module. I don't understand how they did it well enough to be sure.\n. @rcarmo I think we'll get around to it eventually, but (given our limited resources) it's not a hy-priority, since you can still use the old @asyncio.coroutine decorators. We do consider PRs if you want to try to speed things up.. > The break/continue removal sounds nice in practice, but that would likely have serious performance issues.\nA valid point if true, but I'm not convinced. Python does use exceptions internally for break-like behavior, like the StopIteration exception terminating an iterator in an ordinary for loop. A Python try has virtually no overhead when no exception is raised, but actually catching an exception does.\nI'm a bit more concerned about using an inner label as a continue, since that could happen nearly every loop. You could easily refactor that to a cond in most cases though. And also, like 97% of the time performance doesn't matter. You can always profile and rewrite the 3% bottleneck in Python (or C or Cython).\nPython was never about performance to begin with. Furthermore, if performance is such a concern, we really should get rid of let instead. Macros can use setv on gensyms to get most of the benefit of a local scoping provided by let. Locals are much faster in Python than the extra function call let requires. Explicit closures would still be possible with fn instead of let, but won't be surprising when you add a yield, and you won't be tempted to add a break or continue where it doesn't belong.\n\nAlso, it actually isn't hard to detect yield, break, or continue inside a let expression. What if let were implemented in the compiler instead of in the bootstrap file?\n\nAgain not convinced, but you're more familiar with Hy's ast generation than me. Can you just as easily detect these things when it's nested in other fns? In classes in fns? Can you allow a loop totally contained inside a let to break/continue? Wouldn't you have to re-implement Python scoping rules? It's definitely worth considering if it actually works. I could still add the label macro as a contrib library or something.\n. On second thought, just detecting break/continue in the compiler and raising an error isn't going to help at all. Hy (or Python, rather) already does this:\nHy\n(while 1 (let [] (break)))\n;; SyntaxError: 'break' outside loop\nEven given this error, it's still a problem, because macros tend to use let a lot in their expansions, so even if users know better than to break through a let (they learned from the error message), they won't know which macros wrap their code in a let. break and continue just mysteriously break in Hy code. But with label, (and without break/continue) all this will just work.\n. For the same reasons as above, just raising an error on encountering a yield inside let isn't good enough either. Because macros. But it is, at least, better than what happens now:\nHy\n=> (let [] (yield))\n<generator object _hy_anon_fn_1 at 0x000000000376C090>\nWhich makes no sense. It should be an error, since it's a near equivalent to this:\nHy\n=> (do (setv) (yield))\nSyntaxError: 'yield' outside function\n. As @zackmdavis pointed out in #1054, await won't work in let either. It will have the same problem as yield.\n. I got a yield coroutine replacement working in my Drython project, similar to the way I had done it in Saccharin, but Drython's version is two-way.\nIt could perhaps be adapted for Hy. It works through a let, and for the same reason makes yield from unnecessary. It uses a Thread object to create an independent stack that stores the position of the interrupted generator function, and a pair of queues to communicate between threads. The thread is marked as a daemon so that even if it is never exhausted, it won't persist past program exit.\nIt potentially has some serious problems, however. I think a normal yield generator can get garbage collected, even if it's not exhausted, as long as the object is unreachable. I'm not sure a blocked daemon thread can be collected like that, so it's a memory leak, which would be really bad in a long-running server process. Another issue is that because the generator is running in a separate thread, it might cause race conditions if it has side effects (though the queues should be safe). And finally, daemon threads get killed instantly on program exit, without a chance to resolve try/finally blocks and context managers. If the generator was used to read some of the lines in a file or something, it might not get released. Threads seem like more trouble than they're worth.\nIf we could translate this into single-threaded coroutines, it might be a viable option, but I haven't figured out how to do it without threads. Is there a general way to translate threaded programs into coroutines? It seems like Javascript would need something like this. Or maybe someone with more Python threading experience could fix the problems with the threaded version.\n. I think Drython's zombie daemon generators are getting properly killed now.\n(These are technical terms.)\n. Your discard macro becomes nil which is equivalent to Clojure's comment macro, but that's different than #_, which doesn't even become nil.\nClojure\nuser=> (println (do 1 2))\n2\nnil\nuser=> (println (do 1 (comment 2)))\nnil\nnil\nuser=> (println (do 1 #_2))\n1\nnil\nYou see the difference. Sometimes you need a nil placeholder and comment is what you want, but usually you want the entire form to not exist temporarily. I think it's worth adding #_ to Hy proper.\n. @zackmdavis, I think see why yield isn't detected: defmacro/g! expands to a let form. So the yield isn't in the function we think it is in. If I redefine defmacro/g! in terms of setv, the yield detection should work. I think I'll add that to the PR. We were considering getting rid of let anyway #1056, and that means removing all of its uses from the core macros.\n@pyos, yeah, the PEP-380 \"Formal Sematics\" section that I translated this from specifically said \"Python 3 syntax is used in this section.\". I figured something would break in Python 2, but I didn't uncover it in my limited initial tests.\nWhen deviating from the direct translation though, I'd prefer to have a unit test to ensure your proposed changes are actually doing what we want. (Ideally we'd test all the branches.) I'm not sure how thorough our current yield-from unit tests are, but (if it's not covered already) can you also come up with some concrete examples illustrating the need for these changes? As you pointed out, the compiler is also doing the wrong thing in some cases.\n. > Even so, why does the function that let creates contain a return when it also contains a yield? The exception is pretty unambiguous.\nI double-checked the expansion of defmacro/g!. I miscounted the quotes. While it does use let internally, it doesn't appear in the expansion at all, so yield wouldn't be wrapped in another function. defmacro/g! is not the reason for this problem.\n. A hy --spy with the new version. Note the erroneous return at the end.\nPython\n=> (defn f[x] (raise (StopIteration x))(yield))\ndef f(x):\n    raise StopIteration(x)\n    yield\n=> (defn g[x] (print (yield-from (f x))))\ndef g(x):\n    :i_1235 = iter(f(x))\n    try:\n        :y_1236 = next(:i_1235)\n        _hy_anon_var_1 = :y_1236\n    except StopIteration as :e_1237:\n        :r_1238 = next(iter(:e_1237.args), None)\n        _hy_anon_var_1 = :r_1238\n    else:\n        while True:\n            try:\n                :s_1239 = yield :y_1236\n                _hy_anon_var_2 = :s_1239\n            except GeneratorExit as :e_1237:\n                try:\n                    :m_1240 = :i_1235.close\n                    _hy_anon_var_3 = :m_1240\n                except AttributeError:\n                    _hy_anon_var_3 = pass\n                else:\n                    :m_1240()\n                raise :e_1237\n                _hy_anon_var_2 = None\n            except BaseException as :e_1237:\n                :x_1241 = sys.exc_info()\n                try:\n                    :m_1240 = :i_1235.throw\n                    _hy_anon_var_4 = :m_1240\n                except AttributeError:\n                    raise :e_1237\n                    _hy_anon_var_4 = None\n                else:\n                    try:\n                        :y_1236 = :m_1240(*:x_1241)\n                        _hy_anon_var_5 = :y_1236\n                    except StopIteration as :e_1237:\n                        :r_1238 = next(iter(:e_1237.args), None)\n                        break\n                        _hy_anon_var_5 = None\n                _hy_anon_var_2 = _hy_anon_var_4\n            else:\n                try:\n                    if (:s_1239 is None):\n                        :y_1236 = next(:i_1235)\n                        _hy_anon_var_6 = :y_1236\n                    else:\n                        :y_1236 = :i_1235.send(:s_1239)\n                        _hy_anon_var_6 = :y_1236\n                    _hy_anon_var_7 = _hy_anon_var_6\n                except StopIteration as :e_1237:\n                    :r_1238 = next(iter(:e_1237.args), None)\n                    break\n                    _hy_anon_var_7 = None\n    return print(:r_1238)\nTraceback (most recent call last):\n  File \"c:\\users\\me\\code\\repos\\hy\\hy\\importer.py\", line 44, in ast_compile\n    return compile(ast, filename, mode, flags)\nSyntaxError: 'return' with argument inside generator (<input>, line 1)\n=>\n. There are conflicts now, but this change is pretty localized, so it shouldn't be hard to resolve. \nThis is waiting on #739, or something. Since there's currently no way to suppress that spurious return at the end of the Python expansion, this will always fail. We need a way to suppress that implicit return. We haven't done so (so far) because in most cases, you can simply return None and it's effectively the same as if you had no return statement, but that doesn't work here, because it's a generator. return must not appear in the output at all. I suggested adjusting the compiler to use a pass in the tail position for this purpose, but that's not the only approach we've discussed.. We might drop Python 2 support before that happens. Then this will be obsolete. Like I said before, it's waiting on another problem, (the spurious return) which might still be trouble after that. I'll leave this closed for now.. How to launch the Hy REPL from Python:\n```Python\n\n\n\nimport hy.cmdline\nhy.cmdline.run_repl()\n``. Since no-one has commented, I'll propose what makes the most sense to me. \n- Private names shall be prefixed with an underscore, not a dash.\n  -_x, not-x, to avoid confusion with negated literals like-42or-4/2.\n- Python's magic dunder names shall be written the same as in Python.\n  - likeinit, not--init--or otherwise, to be consistent with the private names rule above.\n- Private names should still separate words using dashes instead of underscores.\n  - like_foo-bar, not_foo_bar, to be consistent with non-private parameter names and such that need the same name sans prefix, likefoo-bar, notfoo_bar`.\n- Mangled attrs shall likewise be prefixed with two underscores.\n- Mangled attrs should likewise separate words using dashes instead of underscores.\n  - again here it's more important to be consistent with how you would have named it sans prefix.\n\n\n\nWe could put this in the style guide, and clean up Hy's source to use this style consistently.\n@algernon, is this something you could put in Hydiomatic?\n. @algernon, so you could do it if we fix #360?\n. The documentation is correct.\nHy\n=> (defn test-if [n]\n...   (print (if (< n 0.0) \"negative\"\n...              (= n 0.0) \"zero\"\n...              (> n 0.0) \"positive\"\n...              \"not a number\")))\n=> (test-if -1.0)\nnegative\n=> (test-if 0.0)\nzero\n=> (test-if 1.0)\npositive\n=> (test-if nan)\nnot a number\nI suspect you're still using the old version of Hy on PyPI, but are using the unstable/development version of the docs. Use the docs that match your version of Hy.\nIf there's a link somewhere that pointed you at the wrong docs, that's what should be fixed. Where did you find them?\n. I think it's coming out some time last September.\nWe're a little behind schedule :)\nWe do accept pull requests (sometimes), if you think you can help us with our issues.\nI can't fix Google, but you're certainly not the first to find the wrong docs. It got better when we put up both links in the README.md. Maybe we could rename the \"latest\" docs to \"unstable\" and give it a red color scheme or something. I don't know. We should probably just release the next version already, but it's really not ready yet.\n. This is expected. Hy's repeat is not based on Clojure's but is simply an import of Python's repeat from the standard itertools module. Technically, Clojure's repeat doesn't return a list either, though objects supporting the seq protocol are printed that way by default. Python's printed representation has the advantage of terminating even when the iterable is infinite. You can show its contents by constructing a tuple with it, like so:\nHy\n=> (tuple (repeat 2 3))\n(2, 2, 2)\nDon't do this with an infinite iterable or the tuple constructor will never return!\nThe difference in argument order is due to the difference in the way Clojure and Python handle default arguments. Clojure functions can have overloaded arity, so completely different functions may have the same name, as long as they have a different number of arguments. Hy has experimental support for this style in a contrib module.\nPython (and thus Hy), on the other hand, behaves more like Common Lisp where some arguments are optional because they have default values, but they must appear after the required arguments. In both Clojure and Python, repeat can be called with one argument to repeat the element infinitely. Since the element to be repeated is not optional, it must come first in Python.\nYou can use => (help repeat) to display its Python docstring, and information about its arguments and so forth. This is a feature of Python, not Hy, so some Hy features (like macros) with docstrings don't work with help yet. This is similar to (doc repeat) in Clojure.\n. The easiest way to accomplish this is probably to simplify assoc in the compiler to only accept one pair, then rename to assoc*, and then re-implement the multi-pair assoc as a macro in terms of assoc* with a gensym. The common case of one pair need not expand to use a gensym, unless we want to change assoc to return the dict instead of nil.\n. The repr for HyDict should also add the space. (Also hy-repr?). That's fine with me, but we need to agree on the rules for when exactly we change the version number and how. Do we increment with every pull request? I think Python's versioning rules are here: https://www.python.org/dev/peps/pep-0440/\nOur rules may not need to be that complex yet.\n. Although I suggested it in the first place, I don't think we can just hardcode the git hash in the version string, since the hash doesn't exist until after the commit has been made. Perhaps there is some way for Python to generate it programmatically though. Have you seen any other projects that can do this?\n. The documentation is correct. #898 dropped the extra brackets. \n. @haskellcamargo try cloning the current version of Hy directly from github.\n. set does exist, but it doesn't do that--it makes set objects:\n``` Hy\n\n\n\n(set [1 2 2 1 2])\n{1, 2}\n```\n\n\n\nAssignments to function locals in Python must be defined at compile time due to optimizations. (There's a workaround, but it was removed in Python 3). You can, of course, create a dictionary as a local and use whatever symbols you want in that. \nPython does let you compile new functions at runtime in various ways. Hy can also expand macros into function definitions.\nAssignments to other namespaces don't have this limitation though. Normal classes, modules, and other instances are backed by a simple dictionary. There are exceptions, see __slots__ and __prepare__ in the Python docs. See also vars, globals, and setattr for how to use these instance dictionaries.\n. If you need faster startup for scripts, try using the included hyc tool. You'll get a pre-compiled .pyc file that you can launch with Python.\n. First, a quick demonstration of dynamic variables in Emacs Lisp, so we're on the same page:\n``` Elisp\nELISP> (defun greet ()\n         (format \"Hello, %s!\" the-name))\ngreet\nELISP> (defvar the-name \"World\")\nthe-name\nELISP> (greet)\n\"Hello, World!\"\nnil\nELISP> (defun greet-alice ()\n         (let ((the-name \"Alice\"))\n           (greet)))\ngreet-alice\nELISP> (greet-alice)\n\"Hello, Alice!\"\nnil\n```\nThis is not just a global, you can shadow an earlier binding with a later one, and it returns to its previous value:\n``` Elisp\nELISP> (defun greet-multiple ()\n         (greet)\n         (greet-alice)\n         (let ((the-name \"Bob\"))\n           (greet))\n         (greet))\ngreet-multiple\nELISP> (greet-multiple)\n\"Hello, World!\"\n\"Hello, Alice!\"\n\"Hello, Bob!\"\n\"Hello, World!\"\nnil\nELISP> (let ((the-name \"Everyone\"))\n         (greet-multiple))\n\"Hello, Everyone!\"\n\"Hello, Alice!\"\n\"Hello, Bob!\"\n\"Hello, Everyone!\"\nnil\n```\nHow do we do this in Python? A naiive translation wouldn't work because Python doesn't have dynamic variables. We have to emulate them using Python's lexical variables. Here's a rough proof of concept:\n``` Python\nfrom contextlib import contextmanager\n_sentinel = object()\nclass DefDynamic:\n    def init(self, value=None):\n        self.bindings = [value]\ndef __call__(self, value=_sentinel):\n    if value is _sentinel:\n        return self.bindings[-1]\n    @contextmanager\n    def manager():\n        self.bindings.append(value)\n        yield\n        self.bindings.pop()\n    return manager()\n\n```\nIt's basically a stack object that plays nice with with. Now we can do something similar in Python:\n``` Python\n\n\n\nTHE_NAME = DefDynamic(\"World\")\ndef greet():\n    print(\"Hello, %s!\" % THE_NAME())\ngreet()\nHello, World!\ndef greet_alice():\n    with THE_NAME('Alice'):\n        greet()\ngreet_alice()\nHello, Alice!\ndef greet_multiple():\n    greet()\n    greet_alice()\n    with THE_NAME(\"Bob\"):\n        greet()\n    greet()\ngreet_multiple()\nHello, World!\nHello, Alice!\nHello, Bob!\nHello, World!\nwith THE_NAME(\"Everyone\"):\n    greet_multiple()\n\n\n\nHello, Everyone!\nHello, Alice!\nHello, Bob!\nHello, Everyone!\n```\nPretty good, but this version has one glaring problem:\nElisp\nELISP> the-name\n\"World\"\n``` Python\n\n\n\nTHE_NAME\n<main.DefDynamic object at 0x0000000003E3AF28>\nTHE_NAME()\n'World'\n```\n\n\n\nYou have to call them to get the value! I don't think this is possible to fix in raw Python. But Hy is not quite Python. We could probably automate the call if we implemented symbol macros. But here's another option:\n``` Python\nimport builtins\nclass DynamicDict(dict):\n    def init(self, *args, kwargs):\n        super().init(*args,kwargs)\n        self['_dynamic'] = {}\ndef __getitem__(self, key):\n    try:\n        item = super().__getitem__(key)\n        if isinstance(item,DefDynamic):\n            item = item()\n    except KeyError:\n        item = builtins.__dict__[key]\n    return item\n\ndef __setitem__(self, key, value):\n    super().__setitem__(key, value)\n    if isinstance(value,DefDynamic):\n        self['_dynamic'][key] = value\n\nscope = DynamicDict()\nscope.update(globals())\nexec('''\nY = DefDynamic(\"Foo\")\nprint(\"Y:\", Y) # look Ma, no call!\ndef dynamic_greet():\n    print(\"Hi\", Y)  # Not here either\ndynamic_greet()\ndef dynamic_greet_alice():\n    with _dynamic'Y':\n        dynamic_greet()\ndynamic_greet_alice()\n''', scope)\n```\nY: Foo\nHi Foo\nHi Alice\nHow is this possible? I've customized dict to intercept reads to the global dict to call the function for us. It's not unusual to do this kind of thing with descriptors in Python classes, but you can't monkey patch the globals dict. I had to exec a string instead. This works because you can pass exec an arbitrary globals dict. So it doesn't work in raw Python, but Hy compiles to AST! There might be a way for Hy to use a customized globals dict like the above.\nDespite mine epistle, I still consider this a rough sketch. There are other details that must be dealt with.\nEmacs is single-threaded. The simple stack objects will get tangled if Python is threaded. This is easy to fix. We can take advice from Clojure and give each thread its own stack. This could be a dict with thread keys. (Maybe a weak dict to prevent leaks.)\nThere's also the question of modules. You may need to set a dynamic in a different namespace. How do you import these properly? Clojure's namespaces are a clue. How do you use a Hy dynamic if you import it in Python? It can't be quite as pretty, but as demonstrated, you can use calls.\nI only tested it in CPython3. It should work in other implementations though.\nThere's also the question of what should happen when you yield from inside the with. This breaks the normal stack-based flow and might lead to surprising behavior. I don't know if there's anything similar in Clojure, Elisp, or Common Lisp. This was one of the main problems with our lexical let. But at least we don't have to implement closures.\nIf you mutate the DefDynamic object outside of a context manager, then the last context manager might not pop the same binding it pushed. Maybe it's enough to tell the user to not do that.\n. > But I'm not completely sure if I understand (or even can think of) all possible cases for this. Variables with dynamic scope would only be available inside a let form that referes to them? Or would they be available somewhere else too? Could one define a function with defn, bind it to dynamically scoped variable and then call it later during program execution? How would the definition part and calling part look like in Hy code? Any idea (rough sketch is enough) what the resulting Python code would look like?\n@tuturto \"Inside\" is in the dynamic sense, not the lexical one. Think stack frames, not code blocks. You could use the above DefDynamic as a decorator on a defn to make the function variable dynamic, or you could just put a lambda in the with statement.\n``` Python\nrequires the custom globals dict\n@DefDynamic\ndef foo():\n    return 'did a foo'\ndef dofoo():\n    print('doing a foo: ', foo())\ndef dodofoo():\n    print('doing a dofoo')\n    dofoo()\nwith _dynamic'foo':\n    dodofoo()  # notice the shadowed form applies through an intermediate call\ndofoo()\n```\ndoing a dofoo\ndoing a foo: foo for you too\ndoing a foo: did a foo\nI'm not sure what the Hy code to generate the above Python should look like. Actually it probably shouldn't generate exactly the above Python, because this is just a rough sketch with a number of problems.\nWe may want to rethink the def vs setv #911 and *foo* vs +foo+ #383 questions. In Clojure and Common Lisp, it is the dynamic variables that have the * form, not constants. Maybe we could have def make the DefDynamic objects, and setv be only for the normal lexical variables.  \nDefDynamic and DynamicDict could perhaps be called something else. They could also be made more efficient.\nWe need a way to access the DefDynamic object itself, similar to the way Clojure has #'/var to get the var object itself. The above example has a custom dict that puts it in a _dynamic global dict so the with form can get to it. Perhaps it could live in the appropriate HySymbol instead, but that might not work as well with namespaces. Maybe call the global _hy_dynamics or something.\nI'm not sure if the form creating the with should be called let as in Elisp (giving us a sensible let), or binding as in Clojure to avoid confusion with the old lexical form.\nDoes that answer your questions?\n. See also the argparse module.\n. The beautiful thing about macros is that they've already expanded by \"runtime\". This only happens once, so they have no further impact on performance.\nIf you write a DSL in Python, your program normally becomes a kind of interpreter for that DSL. But if you use Hy macros to define the DSL, your program acts more like a compiler for that DSL. Using macros in this way can actually improve performance compared to the alternative.\nUse the $ hy --spy option or (disassemble) to see what the Hy code is turning into. If you're accustomed to how Python performs, this can clarify the relative impact of various Hy forms.\nEarly optimization is evil. Program in a way you can get right and maintain first. Then profile it and optimize where it counts. Hy can import arbitrary Python modules, even those written in C for performance.\n. I think the docs should use Python3 by default and only mention Python2 as a special case when necessary.\n. See #872 for why I can't approve this. Is your interpretation one-hot or parity? Why not call it one of those instead of xor to avoid confusion, and leave our current xor as-is?\n. The parity xor has no possibility for shortcutting behavior. Therefore, it's not a branch control form like and, cond, if, and or. It's just a function. So why go the the trouble of returning the last true or last false input instead of a simple boolean? I can't think of a use case for this. Have you seen another language that actually does this? Or did you just want the binary case to work the same as before?\nThe one-hot interpretation can shortcut, if you see a second true, you're done. It also has a more sensible choice for a non-boolean return values, like the one true found in the true case, but it's less clear to me what it should return in the false case.\nWhen using pure booleans, xor has the same truth table as !=, and ^, so xor seemed kind of pointless to me in the first place. I'm tempted to remove it altogether. Python doesn't have it, and neither does Clojure or Common Lisp. A reduce using ^ will give you the parity behavior. If they're not already booleans, you can map bool over the iterable first. Of course it doesn't return a non-boolean this way, but that seems to be pointless anyway.\n\nI don't know why anybody would expect the one-hot version.\n\nThe parity interpretation does appear to be more common, but I've seen the one-hot interpretation more than once before.\n. On second thought, if we fix #1109, then the shadowed '#{+ -} operators should just work as unary when applied to a single argument. There's no need to import neg and pos.\n. > I thought about it and realized that the problem with nullary + is that Python uses + for both addition and concatenation, so in a nullary context, we should return [], (), \"\", or 0, but we can't know which. It seems best to just disallow nullary +. So I think the shadowed version is right and the operator version is wrong.\nYou could make the same argument against *. It also works on strings, tuples, and lists:\nHy\n=> (* 3 \"1\")\n'111'\n=> (* 3 [1])\n[1, 1, 1]\n=> (* 3 (, 1))\n(1, 1, 1)\nIn fact, any class can implement operators using dunder methods.\nI don't think that's a good reason to disallow nullary +. Look at what ClojureScript does:\nClojure\ncljs.user=> (+ \"a\" \"b\")\n\"ab\"\ncljs.user=> (+)\n0\nI'm inclined to do things Clojure's way when Python doesn't object.\n. That's a fair point. But every Lisp I've asked says (+) is 0, including ClojureScript, which uses + for more than numbers. I think that's good enough. We could conceivably create an additive identity singleton that returns whatever it's added to and have (+) return that, similarly for (*). But then does it break when you use other operators that 0 understands? Maybe it could be a special case of 0 the same way false is. I'm not sure it's worth the trouble.\nI don't know why nullary / is allowed in Hy. That doesn't really make sense. @kirbyfan64, was this a mistake when you added the unary reciprocal case I asked for? If so, we should probably remove the nullary case. If there's an argument for it I'd like to hear it, since it may also apply to -.\n. Hy already has a good syntax for this. What exactly is wrong with (.c x.a.b)? It makes the first argument (self or cls) explicit, while keeping the function name in the function position where it belongs. \nYou can also already avoid the syntactic sugar altogether with ((. x a b c)), which is easier to manipulate programmatically.\nThere should be one-- and preferably only one --obvious way to do it.\n:-1: from me.\n. > > What exactly is wrong with (.c x.a.b)?\n\nIt's fine when it works, but it doesn't work if x is any expression other than a identifier. (.c (foo 1 2).a.b) doesn't work (and it would be kind of confusing if it did).\n\nThat's a better argument and I'd like to know what the rest of the @hylang/core team thinks of it. But that example should be (.c (. (foo 1 2) a b)), which does work. self is the b you got from a that you got from (foo 1 2). Clojure would do it basically the same way for a similar Java interop case, wouldn't it? Hy has a perfectly good syntax for this.\n\n\nYou can also already avoid the syntactic sugar altogether with ((. x a b c)), which is easier to manipulate programmatically.\n\nThat puts the method after rather than before the object. I assume that the whole reason we have (.a x) is to avoid that, because of the preference for prefix notation in Lisp.\n\nYes, Lisp strives to avoid special cases to make it easier to manipulate code with code (like the -> macro, for example). But my example was perfectly valid prefix notation, as always. I'll add an argument to make it more explicit:\n((. x a b c) an-arg)\n;; becomes x.a.b.c(an-arg)\nPython lets you fetch a bound method as an object, and Hy lets you use an expression in the function position. The above expression fetches a bound method object, i.e. with self baked in. Partially applying functions is a common practice in functional languages, so I think this suits Hy just fine.\nPython also lets you get the unbound method, and therefore so does Hy: (.lower (. Series str) x), or (.lower Series.str x), if you insist on sugar.\n\n\nThere should be one-- and preferably only one --obvious way to do it.\n\nThat principle has never been adhered to in Python, and Hy defies it even more blatantly, and for good reason. It's a fine philosophy for machine code, I guess (if you like RISC better than CISC), but human programmers benefit from having a wide variety of tools, just like human languages benefit from having a wide variety of words.\n\nIt has been a major influence for Python itself (to Python's great credit), which is very clear when you compare it to a language with the opposite philosophy, like Ruby or Perl, which is widely derided as a \"write-only\" language. Python may not have followed this principle perfectly, but that's no excuse to make it worse.\nI also think you've misunderstood. It is not that there should only be one way to do anything (impossible, since you can always write a longer program to do the same thing in any Turing-complete language), but that it's preferable when exactly one of those ways is more obvious. Clojure, Hy's other major influence, also takes simplicity as a pillar of its culture. \nI've been trying to clean up some of Hy's more blatant violations (but I think the dot sugar is here to stay). If you've noticed other violations, do tell, and I'll see what we can do about removing them, or at least making the preferred option more obvious.\nThe variety of words belong in libraries, not in the grammar, which should be kept very simple, like Clojure.\n. \u30ab\u30d0\u30cd\u30ea\n\nbetter fixed once and for all th[a]n left for every new user to trip over.\n\nAlso a good point. Sometimes all or none is better than halfway. I'd be okay with none, but I don't think that's happening in this case. Perhaps it is a natural extension.\n\nit doesn't work if x is any expression other than a identifier.\n\nYour approach doesn't work if b is any expression other than an identifier either. Consider what happens when you have to call a method in your access chain: x.a.get_b().c(an_arg). How should this look in Hy?\nClojure can do it with the .. macro: ((.. x a (get-b) c) an-arg). I think that would be a better extension to Hy than this proposal, since Hy doesn't have .. (and its more powerful . can't do it either), but look at this: ((-> x (. a) (.get-b) (. c)) an-arg). Hy can pretty much already do it with the threading macro.\n\ncould probably still wrap a macro around my files\n\nConsider a reader macro for this kind of thing. It's only one extra character: #.a.b.c.\n\nthe rigidity of Python was the primary reason I resisted\n\nIf you don't like Python's way, why such interest in Hy? CljPerl might be what you're looking for. If it's due to Python's greater popularity (or the resulting ecosystem), remember that Python is more popular because of its ways.\n. @Kodiologist, no it isn't. I'm still not sure how I feel about this, but you've persuaded me enough to withdraw my downvote to an abstention. You'll still need another approval from @hylang/core.\n. Duplicate of #1106\n. The compiler could be simplified if we keep special forms as close as possible to the Python AST.\nI think we should simplify the . special form to just do a single dot access, then make a core .. macro built on top of that that can chain access, including with [] and (). This is also more consistent with Clojure.. @tianon, @zackmdavis, I think it's working now. I'll close this issue.\n. Can we add a 3.6 build to Travis first?\n. Let's try it.\n. Ah, that is strange--only flake8? @zackmdavis was this because of #1112 / #1113?\n. Took off too much? Maybe a later commit was using that line.\n. @paultag looks like getargspec was used by macro(). and only formatargspec was unused.\n. All checks have passed.\n@hylang/core. It was too late to auto-revert, so I did it manually. This increases risk of errors. Can I get some eyeballs, approval?\n. This revert isn't enough to fix #903. (I tried rebasing on this branch.) Something is still very broken here, and I suspect it's getargspec, but I might not have merged #903 properly.\n. Closed by #1172. Yup, you can see all the conversions here. Note also that a ! suffix becomes a _bang suffix. Hy also uses punycode, but that's in the docs.\nAutomagic really should be documented. \nAnother trick--since it happens at the parser level, it is possible to keep the question mark:\nHy\n=> 'query?\nfrom hy import HySymbol\nHySymbol('is_query')\n'is_query'\n=> (HySymbol \"query?\")\nHySymbol('query?')\n'query?'\nThis kind of automagic makes me uncomfortable (it causes headaches, like #1100, etc.), but it really does make common Hy method names easier to use from Python.\nBut if it's not a suffix, it doesn't count:\nHy\n=> 'fo?o\nfrom hy import HySymbol\nHySymbol('fo?o')\n'fo?o'\nIt's really awkward to use a method named like that in Python.\n. On second thought, the first two options are no good. Neither is the status quo. \nRecall that underscore prefixes have meaning in Python.\n\n_single_leading_underscore: weak \"internal use\" indicator. E.g. from M import * does not import objects whose name starts with an underscore.\n\n-- From PEP-8\n\nAny identifier of the form __spam (at least two leading underscores, at most one trailing underscore) is textually replaced with _classname__spam, where classname is the current class name with leading underscore(s) stripped. This mangling is done without regard to the syntactic position of the identifier, so it can be used to define class-private instance and class variables, methods, variables stored in globals, and even variables stored in instances. private to this class on instances of other classes.\n\n-- Python docs\nHy behaves the same way, except when the identifier ends with ?! This could definitely confuse users for no good reason. Why? Because the mangling adds an is_ prefix, and it's therefore no longer a _ prefix.\nThis inconsistency is unacceptable.\nOption 3 still works. \nOption 4\nTake the Canadian approach and use an _eh suffix instead.\nOption 5\nTake Clojure's approach and replace all ? with _QMARK_. We could also do this kind of thing for other characters.. On third thought, _QMARK_ and friends could also introduce a leading underscore where none was intended, if the symbol begins with a special character. We could special case that, so ?foo? becomes QMARK_foo_QMARK_ and not _QMARK_foo_QMARK_. You'd also have to take care that _?foo retains exactly one leading underscore, and __?foo has at least two.. I don't think so. That particular syntax isn't going to work, since it already means (quote \"text here\") to the reader. We already have the HySymbol function to convert strings into quoted symbols. That's not the point. The point is, you should have a read syntax for not-quoted symbols that contain special characters. ('\"my func\" '\"my var\") wouldn't do anything; it's just a list of symbols. If we don't quote them, (\"my func\" \"my var\") is now just a list of strings. But (|my func| |my var|) is executable code in Common Lisp--it applies |my func| to |my var|.\nWe could perhaps do a reader macro on a string like Clojure does for regex, but I didn't pull this syntax out of my nose. It is how Common Lisp does it and Scheme too. I think we need a better reason than \"kirby doesn't like it\" to break established convention with some other syntax, or we're just making things harder on Hy's users who may already be familiar with it.\n\nThe syntax is less weird and easier to read.\n\nIt's perfectly readable.\nTechnically the \\ escape alone is enough. We don't need the | also, but I think quotation marks like\n|I'm a symbol!|\nlooks a lot nicer than escapes like\nI\\'m\\ a\\ symbol\\!\nbut maybe that's just me...\n. What's allowed depends on Python. I especially want to be able to prevent manging (without giving up manging), but any \"attr\" that Python's getattr/setattr/delattr can use on an object should be a valid symbol. I'm pretty sure that's any Python string whatsoever. What \"Python string\" means changed in Python 3, however. I also think the globals dict can take arbitrary strings without trouble, even Unicode in Python2, since u'foo'=='foo'. (Just because you can put Unicode in a string doesn't mean your terminal will print it.) Even Hy's locals will presently tolerate more characters than Python will:\nHy\n=> ((lambda [fo?o] fo?o) 42)\n(lambda fo?o: fo?o)(42)           ; not valid Python!! AST doesn't care.\n42\nLocal names get optimized to integers in bytecode anyway.\nPython already lets you name classes anything:\n```\n\n\n\ntype('bang-A rang!',(),{})\n\ntype('\u2665',(),{})\n\n```\n\n\n\nIf Python can have such names, Hy should be able to evaluate them as symbols.\nBackslashes should escape anything that would otherwise cause Hy's reader to end the token. We could also let Python handle any remaining backslashes with the same rules as a Unicode string.\n. @Kodiologist pointed out in #1327 that we could implement this as another prefix to string literals. E.g. s\"foo bar\" could be a Symbol instead of a string. We're already using letter prefixes like Python does, like r\"foo\\bar\", so this is not a dramatic change. This would still potentially let us use #\"foo\" syntax as regex literals like in Clojure. I am worried about what happens if Python adds another string prefix. It doesn't seem to happen often though.\nWe can almost do this with tag macros. Something like (deftag s [name] (HySymbol (str name))) would mostly work. Then #s\"foo bar\" would expand to the literal, non-quoted symbol with the name foo bar. But when quoted, like '#s\"foo bar\", it becomes\nHyExpression([ HySymbol('dispatch_tag_macro'),\n  HyString('s'),\n  HyString('foo bar')])\nInstead of HySymbol(\"foo bar\") as desired. This could make it fail in some macros, which are looking for the HySymbol model. We'd need true tagged literals or reader macros for this to work.\nAnd if we want to use arbitrary symbols in the tag macros themselves, it's not good enough. Something like #|foo bar| baz or #foo\\ bar baz could work as the \"foo bar\" tag applied to baz, that is,\n[HyExpression([ HySymbol('dispatch_tag_macro'),\n  HyString('foo bar'),\n  HySymbol('baz')])]\nBut I don't think it could work at all with the s prefix.\nThe #s\"foo bar\" baz syntax would instead tokenize as\n[HyExpression([ HySymbol('dispatch_tag_macro'),\n  HyString('s'),\n  HyString('foo bar')]),\n HySymbol('baz')]\nThe | and \\ syntax does seem superior, and has a long tradition in other Lisps. But the cost is that we can't use | to mean a plain symbol anymore. We're using it for the bitwise-or operator now. We could use \\| instead, but I'd rather rename it. We'd also want to rename ~``^``& to be consistent. But this would also be a good thing, since it would clean up an ambiguity with \"unquote\", give us Clojure's metadata syntax for annotations #640 #656, and let us use the shorter Clojure-style & instead of &rest in arguments lists.. Yeah, I'm inclined to agree that's a problem. \nI'm not sure yet of that solution, but it seems reasonable at a glance. I'd like to look deeper at how Hy's macros are implemented, maybe treating them as living in modules isn't appropriate, and something like Clojure namespaces is better. Someone more familiar with that part of Hy's internals might have more to say about it.\nI'm not sure I'd bother with the deprecation warning at this time, since we're breaking everything for the Grand Language Cleanup anyway.\n. Here's a better idea: \n(def T true  F false)\nNow it's :foo T instead of :+foo, and :foo F instead of :!foo. Your version is only one character shorter than mine, but mine doesn't have to change the rules.\nComplexity has costs. Lisp gets its phenomenal macro powers precisely by being as regular as possible. As demonstrated above, the benefit of the new syntax is marginal, and thus not worth the cost in complexity.\nI'm much more willing to consider new syntax if there's precedent in Python, Clojure, or Common Lisp, but as far as I know, you made this up.\nThe case for the third :^ syntax is much stronger, but I think we could come up with better options that don't require changing syntax.\n. I didn't mean to suggest we put this in core, or even in contrib (It's one line, c'mon.), but come to think of it, that actually might not be a bad idea.\nThe relevant precedents for booleans:\n- Common Lisp (and Emacs Lisp) T/nil\n- Clojure true/false\n- Python True/False.\nHy supports all of the above but T. (I think this is pointless redundancy.) So there's a fairly strong case for making T mean Python True. I've argued in #908, that we should have only one obvious way to do it, but nobody seems to like the default first choice of Python's True/False (not even me), so I thought we'd probably end up with Clojure's true/false. The case for making F false is not as strong, but it has a sensible symmetry to it, also, Scheme uses #t/#f, so it's not that strange for Hy to use T/F.\n. > Such as?\nBesides something like your kwc macro? Python has a vars function that can collect locals into a dict. I've sometimes used it it Python to avoid the repetition of local variable names. I've just written a macro that can collect only those variables in scope that you name:\nHy\n(import [hy.models.string [HyString]])\n(defmacro vars-of [&rest vs]\n  `{~@(interleave (map HyString vs) vs)})\nThis will write a dict literal with string keys and symbol values with the same name (that eval in the current scope):\nHy\n=> (def spam 1  eggs 2  bacon 3)\n(1, 2, 3)\n=> (vars-of spam eggs)\n{'eggs': 2, 'spam': 1}\nNote I didn't say bacon, so it's not in the dict (unlike Python's vars). You can use apply to make a dict the kwargs in a call (like Python's **).\nHy\n=> (defn foo [&kwargs kw] (print \"got:\" kw))\n=> (apply foo [] (vars-of spam bacon))\ngot: {'bacon': 3, 'spam': 1}\nNow the apply syntax itself could perhaps be improved. #891. It's not as flexible as Python3 which now lets you use multiple ** in the same call, so we have precedent for changing it. But this approach does eliminate the common repetition of :foo foo.\n. I feel like there should be an easy way to do that. See #1128.\n. Hy's for macro appears to have been based upon Clojure's doseq, which behaves the same way:\nClojure\nuser=> (doseq [x [0 1]\n  #_=>         y '[a b]]\n  #_=>   (println [x y]))\n[0 a]\n[0 b]\n[1 a]\n[1 b]\nnil\nuser=> (doseq []\n  #_=>   (println 42))\n42\nnil\nHy\n=> (for [x [0 1]\n...      y '[a b]]\n...  (print [x y]))\nfrom hy import HyList, HySymbol\nfor (x, y) in ((x, y) for x in [0, 1] for y in HyList((([] + [HySymbol('a')]) + [HySymbol('b')]))):\n    print([x, y])\n[0, 'a']\n[0, 'b']\n[1, 'a']\n[1, 'b']\n=> (for []\n...  (print 42))\nprint(42)\n42\nTherefore, I'm not willing to call this a bug. I do agree it's confusing, and could be better documented.\nYou could argue that Hy's for should behave more like Python's for instead of Clojure's doseq, in which case an empty binding vector should be an error, not a no-op. But we already have for* for that, see #874. Perhaps we could rename for to doseq and for* to for.\nIn any case, this is not the right solution. \ud83d\udc4e from me.\n. @arrdem, you're getting confused by the name \"for\".\nHy's for is not named after Clojure's for. Hy's for's semantics are the same as Clojure's doseq. This is a good reason to rename Hy's for to doseq, or since Python (and Hy) use iterables where Clojure would use the sequence abstration, rename it to doiter instead.\nClojure's for is not like Hy's for. Clojure's for is a lazy list comprehension. Hy already has one of these, and it's called genexpr. genexpr should not be renamed for, because that would confuse Python users.\nIn conclusion, we should keep genexpr's name, and tell Clojure users to use it in cases where they would have used Clojure's for.\nWe should rename Hy's for to doiter by analogy with Clojure's doseq.\nWe should then rename Hy's for* to for, so that Hy's new for behaves like Python's for.\n. I'm closing this in favor of #1125. We don't have enough core downvotes for an absolute veto, so this could be reopened at a later time, but there's been no further arguments either way for months.. We also need to update the docs with this. In particular, mention in the documentation of for (formerly for*), that Clojure users who want a list comprehension should use genexpr instead.. We're still in the process of making breaking changes. We were reluctant to make a release, since that would break everyone's code twice instead of once. But perhaps incremental changes are easier to deal with than big changes? Just saying.\n. Which versions of Python do we support? I thought we stopped supporting 2.6 #843 and added tests for 3.6 #1133? That's not what the pypi page shows.. Do we also need any non-CPython classifiers?. It looks like Travis is also running PyPy tests. It's still showing 3.6-dev, but Python 3.6 has been released now. Can we update that yet? We also might want to consider supporting other Python implementations officially #934. . Can we update the try-hy app too?. See Clojure's destructuring guide.. Hy would need its own syntax for this kind of thing. We are already used to doing similar things with reader macros and syntax quotes, ~@ is very similar to Python's * when you think about it.\nI propose  #* and #:, for example:\nHy\n;; hy --spy\n=> [1 #*[2 3 4] 5 6 #*[7 8 9]]\n[1, *[2, 3, 4], 5, 6, *[7, 8, 9]]\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n=> {#:{1 10} #:{2 20} 3 30} \n{**{1: 10}, **{2: 20}, 3: 30}\n{1: 10, 2: 20, 3: 30}\nThe # makes it clear that this is reader syntax, and * because that's how Python does it. The : has two dots like Python's equivalent **, and also reminds you of Python's {:} syntax and Hy's :keywords. But I suppose we could use #** instead. We don't have to restrict reader macros to one character. #1046.\n. An improved apply form could use :* and :** as kwargs. (This could even be done as a macro in terms of the current apply.), but using that syntax for all unpacking would be inconsistent, since it blocks what would otherwise be valid kwarg names in function calls. They would also only work once each per form, since a kwarg can only take one value per call.\nThe unpacking generalizations, on the other hand, can be used multiple times per form. Like quote/' in most lisps, they could be special forms with a macro shortcut. It has to be #-prefixed, unless we want to use up another dispatch character.. The Python unpacking generalizations can appear not just in function calls, but in tuple, list, set, and dictionary displays. (And they may also appear in comprehensions in the future.) So Hy would also need them in the equivalent special forms, but keywords aren't magic there--they're data. It seems a lot more consistent to me to use #-something. You wouldn't have to add so many exceptions and special cases.\nI'm also not certain how #1127 should look, but it seems like a similar idea, so it would be nice if they had common syntax.. Let's retest this one too.\n. Numpy compatibility is a good argument. General Python duck typing is also a pretty good argument. I'm inclined to approve this change. Who put those checks in there in the first place? I'll check the blame...\n@rwtolbert, is this just for better error messages? I don't think that's worth it. Was there some other reason?\n@Kodiologist, checks are failing, and it's not just Python: nightly. I don't want to merge this while 2.7 and pypy aren't working.\n. I'm forcing a retest, now that #1133 is merged.\n. @zackmdavis, wasn't this working before? #1113 \n. So it needs to say 3.6-dev? Because @kirbyfan64's change only says 3.6.\nAlso, since nightly points to 3.7-dev now and nightly is failing, does this mean 3.7 will break Hy again?\n. Since it's such a minor fix and I have access, I just changed it myself with another commit to the nightly36 branch. As you can see, it's working now, so I hope you don't object. @kirbyfan64, @zackmdavis, can I get an ack and merge?\n. We should fix the bug introduced by #924 first. That should never have made it into Hy in the first place, and certainly not a release.. > In any case, it's a rather obscure bug that, so far as I can tell, only means that when you incorrectly call a macro that has a funny parameter name, you won't get a useful error message.\nNo, not that minor. It actually broke #903, which was working fine before #924. It's too late to automatically revert #924. Another change must have been applied on top of it. It will only get worse until its fixed, but I'm not sure exactly what's broken now.. This might be a good time to fix that typo in the last word of the as-> docstring (or even rewrite the whole thing to make it clearer). Not that we can even access those for macros #892.\n. The : appears to be a syntax error in both Clojure and Common Lisp. Emacs Lisp allows it though, and both (keywordp :) and (symbolp :) return t.\nI think NumPy support is very important for the future of Hy, #541. I'm not sure of the right approach yet, but it might be nice to use : in slicing macros.\n. @tuturto, it's not that hard in Python. (foo : 'bar) would be written foo(**{'':HySymbol('bar')})\n. > But of course the usual way to write that would be ': instead of :\nWe mainly wanted to use : in macros. And in macros, it doesn't have to have the quote. You could also assign a function to it or some other value if it's a symbol. Keywords always evaluate to themselves though. A symbol seems more flexible, but a leading : means \"keyword\" for everything else. I'm not sure which is better.. > The two-core-approvers-other-than-the-submitter rule is a little tough [...]\nI still think the rule is important. You can do anything you want in your own fork, but you have to convince a couple of core members that it's a good idea before we accept a pull request. \n\n[...] when there's only four of us who are really active. Eight dubloons to anybody who can shanghai some fresh blood into core.\n\nI don't know of anyone we could recruit at the moment. The more people who are interested in Hy, the more people will contribute. If we put more projects written in Hy up on GitHub we might get more attention. Pullum, et ovo. Ergo, bootstrap.\nThere are more of us that are less active, but not inactive. We're not all in the same time zone, so our availability varies. If you make a change when we're too busy we might forget about it when we have the time. If you can talk to people on IRC that might help get things moving. Github also has a new Projects tab that might be worth looking into. It might help prioritize things. We could also try to make assignments.\n. Your expectations don't match the specification for defclass. The first [] is for superclasses, the second is supposed to be like a setv, and the third should just be a normal HyList.\nI argued against treating the second [] specially, #850 since a setv would do here and is closer to the way Python works. \nThat said, the hy2py output doesn't seem to meet the spec either. The list you created might have a side effect and thus should appear in the class definition. I don't think the compiler could possibly be smart enough to omit this only when it doesn't matter.\ndefclass needs some work to get metaclasses working properly anyway. Python 2 and 3 handle this very differently.\n. @kirbyfan64, I agree that's how it should work when Hy targets Python 3. It will cause fewer problems if Hy uses the exact same keyword as Python, since metaclasses are free to use any other keyword arguments.\n@algernon's first pass at this #887 used the :meta keyword instead. I think that's misguided, since there are better ways to avoid typing a few extra characters that don't make Python compatibility more difficult. For example, you could do something like this in Python:\n``` Python\nfrom mystuff import my_metaclass, args, kwargs, Baz\ndef mc(a_metaclass):\n    return dict(metaclass=a_metaclass)\nclass Foo(Baz, *args, kwargs, mc(my_metaclass)):\n    ...\n```\nI think Hy needs something similar to Python's multiple ** and *. #1128. Hy also has macros to help with this kind of thing.\nI don't think it will be easy to backport this to Python 2 though. It wouldn't be the first Hy feature that depends on the underlying Python version. I think the Python 2 metaclass syntax already works, but only when targeting Python 2, of course. I already think supporting Python 2 is more trouble than it's worth, and this will only become more true over time.\nWith a metaclass, a class declaration doesn't have to \"return\" (i.e. assign to the class name--it's a statement, not an expression) an actual class. It could be any type of object. Python libraries may (ab)use this feature, and Hy needs to support that.\n. You could do that, but it wouldn't be enough. I don't think it's worth the trouble. They completely redid the metaclass system for Python 3.\nWould you also do the reverse, and set a :metaclass keyword argument when the attribute is detected? A macro could do that, but only if it could be determined at compile time, since a metaclass call happens before the class body is executed. It's not worth it. Python 2 also lets you set a __metaclass__ attribute at the module level. Python 3 doesn't have a good equivalent. Injecting it into the whole module would be tricky even with macros, and it still only works at compile time.\nPython 2's metaclasses are much weaker than Python 3's. You can do pretty much everything a Python 2 metaclass does with a class decorator. Python 3 can do this much, but also gives you a deeper hook. A metaclass can prepare the class dictionary before it executes the class body. You could, for example, use an OrderedDict instead and preserve the order of all assignments in the class body. If you're using a class declaration to represent something other than a class (like an XML file, say), this ordering might be important information. \nYou could even create some kind of custom dict class and declare multiple methods (or other attrs) with the same name in the class body. The custom dict could save all of them. In Python 2, they'd get overwritten before the metaclass can get to them and you'd only see the last one.\nThere are ways to approximate these capabilities for any given use case in Python 2, but you'd have to write the class declaration differently to avoid losing information. Making this work the same way in Hy targeting Python 2 and 3 seems really difficult without creating a bunch of weird edge cases, and if we can't do that, why bother going halfway?\n. I've developed a macro that appears to do the right thing. See if you can break it. If it's all working properly this is a good starting point for what the AST should look like.\n``` Hy\n=> ;; hy --spy\n=> (defmacro -or (&rest args)\n...   (if (empty? (cdr args))\n...       (first args)\n...       (do\n...         (setv g (gensym))\n...         `(do\n...            (setv ~g ~(first args))\n...            (if* ~g\n...                 ~g\n...                 (-or ~@(cdr args)))))))\nfrom hy.core.language import first, gensym, is_empty\nimport hy\nfrom hy import HyExpression, HySymbol\n@hy.macros.macro('_or')\ndef _hy_anon_fn_1(args):\n    if is_empty(args[1:]):\n        _hy_anon_var_1 = first(args)\n    else:\n        g = gensym()\n        _hy_anon_var_1 = HyExpression(((([] + [HySymbol('do')]) + [HyExpression(((([] + [HySymbol('setv')]) + [g]) + [first(args)]))]) + [HyExpression((((([] + [HySymbol('if')]) + [g]) + [g]) + [HyExpression((([] + [HySymbol('_or')]) + list(args[1:])))]))]))\n    return _hy_anon_var_1\n=> (import [random [random]])\nfrom random import random\n=> (setv x (or (< (random) .5) (do (setv y 1) y)))  ; with original broken version\n_hy_anon_var_1 = (random() < 0.5)\nif (not x):\n    y = 1\n    _hy_anon_var_1 = y\nTraceback (most recent call last):\n  File \"\", line 1, in \nNameError: name 'x' is not defined\n=> (setv x (-or (< (random) .5) (do (setv y 1) y)))  ; with new macro version\n:G_1235 = (random() < 0.5)\nif :G_1235:\n    x = :G_1235\nelse:\n    y = 1\n    x = y\n=>\n```\nWe could just use the macro, honestly. The choice of true special form vs. macro makes little difference to the end user, but I think the built-in version can be more efficient, since it can compile to Python's or in some cases and avoid wasted assignments.\n. The nullary case works:\nHy\n=> (or)\nNone\n=> (-or)\nNone\nI didn't test it that way, but it's probably a good idea to use the existing tests. I'm not sure how easy that would be. I wonder if the tests would just work if you changed the macro name from -or to or. (Don't forget to rename the recursive part). You might want to disable compilation of or just to be sure we're testing the right thing, but that would break the world, so you'd have to define the macro pretty early. (i.e. actually implement the macro version in Hy) Maybe it's easier to just do a find and replace in the tests and keep the name -or.\nThe performance difference might not be noticeable most of the time, but there is a gensym assignment statement that isn't always necessary:\nHy\n=> (or 1 2)\n(1 or 2)\n1\n=> (-or 1 2)\n:G_1235 = 1\n(:G_1235 if :G_1235 else 2)\n1\nSee the difference?\n@kirbyfan64, you implemented the current or version, is this an easy fix?\n. The three argument case makes the difference even more obvious:\nHy\n=> (or 0 1 2)\n(0 or 1 or 2)\n1\n=> (-or 0 1 2)\n:G_1236 = 0\nif :G_1236:\n    _hy_anon_var_1 = :G_1236\nelse:\n    :G_1237 = 1\n    _hy_anon_var_1 = (:G_1237 if :G_1237 else 2)\nNow that I think about it, I'm not sure we could reasonably detect the cases were a gensym isn't required. Correctness outweighs performance. \nPython's expression/statement distinction just makes things awkward. Python requires local assignments to be statements. We could use a method call expression to set a dict item or attr instead, but that's less efficient than a local.\nMore reasons to use a special form instead of a macro if we can: \n- (macroexpand) output may be a bit prettier, \n- and similarly, hy --spy output is more readable when we can use Python's or.\n- If future Python versions expand on the uses for the or word (as they've done for other reserved words in the past), it could be a problem if Hy can't output a Python or. Maybe we could have a binary-only or* for that, but statements are still awkward, so I'm not sure that helps. I guess we can cross that bridge if we come to it.\nThese are not very strong reasons though. A lot of other Hy forms aren't pretty when compiled.\n. > Arguably, this is more of a bug (or unavoidable Python limitation) in list-comp than -or. List comprehensions are always going to be second-class citizens in Hy compared to filter and map (short of automaticallly generating intermediate functions, or compiling list-comp to map and filter instead of a real list comprehension), because Python doesn't permit statements in them. So I'm inclined to just let this break.\nWell I'm not okay with this. I'd sooner remove list-comp and friends than keep the current surprising behavior. I don't see how compiling to map and filter helps though. See #588.\n. Let's force a recheck.. \ud83d\ude15 why is flake8 complaining about .gitignore?. @Kodiologist you missed some in the style guide.. My bad, I was on the wrong branch.. Ignoring this is the easier fix and perhaps we should do that for now, but we might want to consider fixing our spacing later and enabling that check again. @Kodiologist has also pointed out that we're using the nonstandard spacing for grouping things. We could replace this with header comments.. \ud83d\udc4d I'm not sure this is the right solution long term, but I'll approve this for now, since it's kind of holding up other PRs.. Here's the table for the error codes, if that helps anyone.. Wait, what's W504?. Did I find the wrong table? Does everything still work if you delete W504, then? If so, you should probably leave it out.. Maybe we should also bug the flake8 people about this inconsistency. Or maybe the pycodestyle people. They may have neglected to update their docs.. https://github.com/PyCQA/pycodestyle/pull/502\nLooks like W504 isn't ready yet. The meaning could still change though. Best leave it off for now. We can always put it back later if we have to.. >The construct <(...) only works in Zsh, anyway.\nBash has heredocs and herestrings\n```Bash\nHerestring\nhy2py <<<'(print \"hello\")'\nHeredoc\nhy2py <<END\n(print \"a string\" 'a-symbol)\nEND\n``\nAdding stdin seems like a fairly easy change but I'm not sure why we need it.. No, not like files, like streams.hy2pywould have to accept stdin as you propose for the heredoc examples to work. Your zsh example actually does work in bash, even now..eg/` is useless if not updated for changes to Hy. It might belong in its own repository for now. I don't really want to update it until Hy has stabilized more.\nhy/contrib/ has experimental candidates for the standard library. Perhaps some can be spun off to their own repositories, but other parts might belong in Hy's standard library. I think hy/contrib/ should stay for now.\nWe need more experience with the contrib modules to decide what parts to keep in Hy proper, and what modifications to them are necessary for that step.. I'm still not sure what I think of this one. The argument for it is not as strong as it looks. Python kind of has the same problem. In most cases you can also pass positional arguments as keyword arguments:\n```Python\n\n\n\ndef foo(bar,baz=False):\n    print(bar, baz)\nfoo(baz=True,bar=\"\"\"\nSomething really\nreally\nreally\nlong?\"\"\")\n\nSomething really\nreally\nreally\nlong? True\n```\nHy should already be able to do this.\n\n\n\nThat said, there are cases when it doesn't work. For example, a builtin written in C might not have named arguments:\n```Python\n\n\n\nimport operator as op\nop.sub(b=5,a=7)\nTraceback (most recent call last):\n  File \"\", line 1, in \n    op.sub(b=5,a=7)\nTypeError: sub() takes no keyword arguments\n``\nYou can't pass*args` that way either. So there are some reasons for it. I need to double check how Clojure and Common Lisp do it.\n\n\n\nIf we do put this in Hy, I think there are some other things that also need to change to match.. > Dunno about Clojure, but CLOS uses multiple dispatch, so there's no one specially designated invocant. In fact, there's no syntactic difference at all between calling a function and a method. I think this is the right thing to do in a Lisp, but trying to make Hy do it is out of the question because it would involve screwing with Python's name resolution rules.\nClojure's case is also complicated by Java's class system, but it can do mulimethod hierarchies too. Something similar might work for Hy. We already have defmulti from hy.contrib.multi, but I don't think we have anything like Clojure's hierarchies yet.\nI did some checking and I don't think Clojure has anything like Common Lisp's &key. You can just use & (works like &rest) on a map destructuring bind in the parameter vector. The & gathers naked keyword/value pairs from the call into a list which gets broken up and assigned to the appropriate local names by the destructuring bind (which seems more elegant that Common Lisp's &key approach) but this doesn't allow you to mix \"keyword arguments\" with normal positional arguments, which still have to come first. \nI don't think that was helpful resolving the issue.\n\nI dunno...I find this one a bit confusing. When you see (.myfunc ...), the eye immediately looks right after to see what the method is being called in.\n\n@kirbyfan64 I see your point, but special cases are also confusing. I'm starting to think the status quo is a problem because it's inconsistent. When you consider that defmulti can dispatch on any of the arguments (or combinations of them) then this proposal doesn't seem that bad. The self parameter would be just like any other argument.\nThe other option to make Hy consistent would be to restrict Hy to only accept keyword arguments after all positional arguments like Python does. I'm not sure that's an improvement. What exactly do we gain from that?\n@Kodiologist look what I can doo:\n```Python\n\n\n\nclass Foo:\n    def init(self, foo):\n        self.foo = foo\n    def doo(self, bar):\n        return self.foo+bar\nspam = Foo('spam')\nFoo.doo(bar='eggs',self=spam)\n'spameggs'\nHy should already be able to do this too..Hy\n=> (defn greet [&kwonly a-name!] (print \"hy\" a-name!))\n=> (greet :a-name! \"Bob\")\nTraceback (most recent call last):\n  File \"\", line 1, in \nTypeError: greet() got an unexpected keyword argument 'a_name!'\n```\nDoes anyone else find the above confusing? Because I think the users would find that confusing.\n\n\n\nIt is possible to call greet, but since keywords aren't mangled, you have to do it like this:\nHy\n=> (greet :a-name-bang \"Bob\")\nhy Bob\nWe might want to rethink how we do mangling altogether #1173, but it's not at all obvious to me why keywords shouldn't be mangled with exactly the same rules as symbols. You create keyword arguments with symbols, but you call them with keywords!. >But should we mangle them when they're used as dictionary keys?\nI would argue yes, since we can apply dictionaries as keyword arguments. This is a common Python pattern (the **kwarg syntax). Always mangle them in any context, with exactly the same rules as for symbols.\nIf you don't want to give up the ability to have keyword with certain special characters, see #1117. The quotation can suppress mangling.. closes #903 \ncloses #989 \ncloses #1114 \nI'm not sure I can be the one to merge this since many of the commits are mine. @hylang/core care to take a look? (Remember to squash and merge.)\n\nThis one is somewhat simpler approach and doesn't produce nice error messages on macro expansion when parameters have invalid names (from point of view of Python). In most of the cases, error messages are nice.\n\n@tuturto, can you show concrete examples of the good and bad error messages produced by this version? Perhaps we can take another approach.. The \"bad\" case doesn't seem that bad. The fact that mangling happens cannot be a secret from Hy users, or they'll be confused by more than this. When exactly mangling occurs ought to be documented better though.\nThe \"very-bad\" case has a TypeError instead. That's not good, but it still points the user to a missing positional argument during macro expansion. I don't think it's bad enough to hold up this PR.\nWe already handle UTF-8 entities with punycode. Maybe we could improve the mangling to handle all cases. Perhaps we should encode all invalid Python identifiers into valid Python identifiers. Even though the AST mostly doesn't care as long as it's valid ASCII, it might prevent other problems like this in the future.\nPunycode was a convenient choice, since the encoder is in Python's standard libarary. There are, however, other ASCII characters that are not allowed in Python identifiers. Punycoded strings are not especially readable either, since it's not clear at a glance where in the string the special characters are located. We might want to come up with our own encoding scheme.. > By Lisp standards, it's pretty idiosyncratic. For example, \u03bb is legal but \u2698 isn't.\nUm, which Lisp are we talking about? I don't code in Unicode much. Do we want emojis and such in Hy identifiers? Or just the written word for other languages? Does Python allow any mathematics symbols? We might want those too.\nAre the uncommon extra symbols worth making all the mangled symbols impossible for a human to read for non-latin alphabets?\nIf we really want both human readable mangled symbols and emojis, then punycode is out, since it all has to be ASCII alphabetic. We'd have to come up with some other encoding scheme.\n\nI feel as if we ought to send a bug to the Python people pointing out that the inconsistency. It seems pretty obvious that Python should either have is_integer and is_lower, or isinteger and islower, but not one of each.\n\nFeel free to send that bug, but it's not going to get us anywhere. Backwards compatibility would be more important to them at this point.. The threading macros take care of most of these cases I think. Though macros can be hard to use with HOF, I think they'd be more efficient.\nI didn't see the complement function in the link you provided. Is it in the same file?\nWe should call them comp and constantly to match Clojure's naming.. How is filp supposed to work in Hy? Clojure doesn't have it. I didn't see an example in Hymn either. I think in Haskell's case, flip swaps the order of the first two arguments to a function. But in Haskell, all functions are technically of one argument and it has auto-currying, while in Hy, even normally binary functions like - can have multiple arguments. I don't think it gets you as far in Hy. The usual way to handle this in Clojure is with #(), I think. (Or xi in Hy). But that's macros again.. I agree we should think about this some more.\nI vaguely recall using rotatef in Common Lisp when I needed a flip. For a binary function it does the same thing as a reverse. It might also be more efficient than reversing the whole list. In Python3:\nPython\ndef flip(f):\n    def flipped(*args,**kwargs):\n        it = iter(args)\n        return f(*it,next(it),**kwargs)\n    return flipped\n```Python\n\n\n\nflip(lambda *a: a)(1,2,3,4,5)\n(2, 3, 4, 5, 1)\nimport operator as op\nflip(op.sub)(3,2)\n-1\n```\n\n\n\nHaskell's version (which only affects the first two arguments) may not be that unreasonable. You can sort of do currying with functools.partial. Forth's stack manipulation operators may also be worth looking at. One of them is SWAP and is essentially like Haskell's flip. It also has ROT which rotates the first three.. It looks like comp is applying functions in the opposite order of Clojure's. Hy's comp should work the same as Clojure's comp.. We should really follow Clojure's lead and choose option 1: return identity.. Function calls are kind of expensive in Python I think it would be more efficient to use the imperative style, rather than calling a new function for every pair. Maybe something like this:\nPython\ndef comp(*fs):\n    if not fs:\n        return identity\n    fs = reversed(fs)\n    def composed(*args,**kwargs):\n        for f in fs:\n            res = f(*args,**kwargs)\n            for f in fs:\n                res = f(res)\n        return res\n    return composed. @Kodiologist, that's fair, but I'm starting to think Hy needs a timing macro. The timeit module is proving difficult to use in Hy.\nHere's a Hy version:\nHy\n=> (defn comp [&rest fs]\n... (if (not fs) identity\n...     (= 1 (len fs)) (first fs)\n...     (do (setv fs (reversed fs))\n...         (fn [&rest args &kwargs kwargs]\n...           (for* [f fs] (setv res (apply f args kwargs))\n...             (for* [f fs] (setv res (f res))))\n...           res)))). ```Hy\n(defn comp [&rest fs]\n  (if (not fs) identity\n      (= 1 (len fs)) (first fs)\n      (do (setv fs (reversed fs))\n          (fn [&rest args &kwargs kwargs]\n            (for [f fs] (setv res (apply f args kwargs))\n              (for [f fs] (setv res (f res)))) res))))\n(import [time [time]])\n(setv start (time))\n(for [_ (range 100000)]\n  ((comp inc inc inc inc) 1))\n(print (- (time) start))\n(print \"iterative comp completed.\")\n(defn comp [&rest fs]\n   \"function composition\"\n   (defn compose-2 [f g]\n     \"compose 2 functions\"\n     (fn [&rest args &kwargs kwargs]\n       (f (apply g args kwargs))))\n   (if fs\n     (reduce compose-2 fs)\n     identity))\n(setv start (time))\n(for [_ (range 100000)]\n  ((comp inc inc inc inc) 1))\n(print (- (time) start))\n(print \"functional comp completed.\")\n\n0.6814742088317871\niterative comp completed.\n1.6196417808532715\nfunctional comp completed.\n```. @pyx you could make a new issue first for those.\nFrom the timing data we see that the cut version doesn't perform as well. It can be constructed faster, because it defers some computation to execution. This is not a good trade-off in the common case of creating a composede function once, and then calling it many times in a map over a long iterable. It's better to precompute it once. So far, I like @pyx's implementation of comp best.\nYou could use cut instead of reversed when precomputing. I'm not sure which is faster. We could also test for more lengths in the if, and hard code the short cases while avoiding the loop altogether. I'm not sure it would help much, but the overhead of a loop and assignment is probably more significant when there are fewer functions.. > @gilch Since I am new here, sometimes I don't know which way should I go, e.g, I am not sure if creating a new issue regarding yet-to-be merged PR is a proper way of giving feedback.\nWe don't know either. Don't worry too much about it, you're doing fine.\nI would approve adding juxt to Hy. Clojure has it and I use it. I'd still suggest a new PR. I feel pipe needs more discussion. That's why I don't want it added to this PR. You may open a new issue for discussing that, but I'm not inclined to approve it since Clojure doesn't have it. It mostly duplicates the behavior of the threading macros (->,->>,as->). And comp, but in reverse. It is a good point that pipe can be implemented in terms of comp, but we don't have to do it that way, and it might be more efficient if we don't. It might actually be easier to implement pipe first and then comp in terms of pipe.\nMerge conflicts in this file could probably be avoided if the exports list had only one element per line. The merge conflicts in this case are trivial to resolve though.\n\n@gilch I sort of regret even bringing up the subject of benchmarks because any discussion about performance is speculation outside of profiling a real program. Premature optimization is the root of all evil. Anyway, in my opinion, any of the three versions is fine for now. Do you approve this PR?\n\nI normally agree with that maxim, but I feel you're using it out of context. When developing an application, it's unlikely that any given function will be on the critical path, so it's best to profile and see what's actually the bottleneck. Optimizing other parts is just a waste of time and the optimized code can be harder to maintain too.\nHowever, when developing the standard library, we're not just making one application, but the building blocks of every application written in Hy. Therefore it's much more likely the functions we write will be on the critical path of some Hy applications, especially for something as fundamental as function composition! So I do feel it's worth some effort not to be too inefficient here. That said, proving optimality is probably an undecidable problem in the general case, so we do have to give up eventually. But you do hit diminishing returns pretty quickly in practice for a function this short.\nconstantly and complement are pretty trivial, and appear to be correct. I'll approve those so far. I'll also approve comp if it's changed to @pyx's version.. For maximum flexibility, a macro has to be able to interpret a keyword as as keyword instead of a kwarg pair. This way you can write macros that contain keywords as part of the syntax, even if there are two in a row or one at the end. I think you could simply have the macro call a function that accepts &kwargs. No need to parse it yourself.. A simple example:\nHy\n=> (defmacro foo [x &rest xs] `((fn [s &kwargs kws] (, s kws)) '~x ~@xs))\n=> (foo norf :bar 1 :baz 2)\n('norf', {'bar': 1, 'baz': 2})\nNote that the macro can quote the first symbol and still parse the remaining kwargs.. I think we should at least list all of the symbols. That way the link shows up on a search of the documentation.. In Clojure they're not short-circuiting:\n```Clojure\nuser=> (< 1 2 0 (print 'hi'))\nhi'false\nuser=> (doc <)\n\nclojure.core/<\n([x] [x y] [x y & more])\n  Returns non-nil if nums are in monotonically increasing order,\n  otherwise false.\nnil\nuser=>\n```. > After thinking about this, I'm actually going to suggest kind of the opposite of this change, which is to stop shadowing comparison operators at all.\nAnother option would be to restrict the arity for the shadowed versions to 2. I don't like the inconsistency, but it avoids the short-circuiting problem without removing the shadowed function for the common case.\n. If we do remove the shadowed versions we could also add functions increasing?, decreasing?, non-increasing?, and non-decreasing? to compensate. These would not be expected to short-circuit, but could stop pulling from a lazy generator after the first contradiction, similar to Python's builtin any and all.. If we do add a multi-arity defmacro, we might also want to add multi-arity versions of defmacro/g! and defmacro!.. >I could host it on my VPS.\nGithub can host static pages now. We could use that under hylang ownership, and give Hy Society full access.. Still failing. Maybe it would work if you opened a new pull request. . I meant a new PR with only the one branch.. Travis cached it? Perhaps if you made a new pull with a new branch name?. Why does py34 pass if the branch is supposed to be missing altogether? Is our test setup broken?. Yes, there are reasons, and we've discussed them before, remember? #1056\nThe first reason is that the do block has no lexical closure, while the current function-based version does. In Clojure and Common Lisp, let also does.\nIf we have a let that doesn't work right we can't fix it later on without breaking API. If we eliminate let early, we still have the option of adding it later.\nLeaking into the local scope is only a minor problem, since Hy automatically creates local _hy_anon_vars anyway. Python 2's list comprehensions also \"leaked\" and in most cases this didn't cause problems. If it happens in a function, its scope is pretty limited anyway. It's a bit more of a problem at the module level. You can use del to clean it up though.\nThe other reason is that if you nest lets, an inner variable with the same name should shadow the outer one. This even works in dynamically scoped lisps with no lexical closures like emacs. The do/setv implementation would just overwrite it. Nesting also works now in the current function-based let.\nBut the current function-based let also has severe problems. It breaks async/await, break/continue, and yield. We'd just be trading one set of problems for another. The right solution seems to be to eliminate let.. Python is duck-typed. False is a special case of 0, and True a special case of 1. Hence:\n```\n\n\n\nFalse + True\n1\nFalse * True\n0\n41 + True\n42\n``\nYou can just as easily use1and0instead ofTrueandFalse, (e.g.:a 1) which is just one character longer (the space) than your proposed:a?or:a.Whether this is good style is a different question, but it's arguably better than(def T True  F False)`, since it's more standard. Early versions of Python didn't even have a bool type (see PEP 285), so this almost always works.\n\n\n\nThe :a? suggestion has another problem: :a? is already a valid keyword in Hy. You can define a function now that takes such a keyword argument.\nI would prefer to keep Hy's compiler as simple as is reasonably possible, rather than adding special cases that could just as easily be implemented as a (reader) macro in a library. I'm more inclined to add features if they're already present in Clojure, since Hy's syntax is heavily based on Clojure, and very willing to add features already in Python, since we're trying to maintain compatibility with Python.. @Kodiologist that is true, and enabling that distinction is why bool types were added to Python in the first place. But in the case we were discussing viz. \"Often, functions take a keyword argument with a boolean value, indicating whether a feature should be enabled or not.\", a 0 or 1 nearly always works.\nThe distinction might be more important for adding a bool type in a database rather than an integer type, one of the cases mentioned in the PEP. But in such cases I think it's usually better style to spell out True and False explicitly.. Approved, assuming Travis passes. \ud83d\udc4d I have no further objections. This is an improvement, though I'd just as soon remove xor altogether.\n@hylang/core can we get another ack?. https://pythonclock.org/\nPython 2 support officially ends in 2020. It's open source, so others might continue to support a fork (Red Hat, in particular, has some long-term service obligations out to 2027, but only to paying customers on Linux), but I don't think Hy has any need or obligation to support Python 2 past this date. I think we should remove Hy's Python 2 support by PyCon 2020, to make things easier for us.\nThe only reason I'd like to continue supporting Python 2 now is to get Hy on more platforms. Jython, in particular, hasn't released a version 3 yet. Jython support would open up Hy to most of the Java ecosystem, except, perhaps, Android, which uses an incompatible Java VM.. Something as simple as\n```Hy\n(import pyrsistent)\n(defreader p [form]\n  (pyrsistent.freeze ~form) )\n```\nwould get us pretty far. That's enough forPVectorPMapandPSet. Thefreeze` function is recursive, so it also works on nested structures,\nHy\n=> #p[#{1 2} {1 \"a\"  2 \"b\"}]\npyrsistent.freeze([{1, 2}, {1: 'a', 2: 'b', }])\npvector([pset([1, 2]), pmap({1: 'a', 2: 'b'})])\nbut there are limitations:\nHy\n=> #p #{[1 2] {1 \"a\"  2 \"b\"}}\npyrsistent.freeze({[1, 2], {1: 'a', 2: 'b', }})\nTraceback (most recent call last):\n  File \"<input>\", line 1, in <module>\nTypeError: unhashable type: 'dict'\n=> #p #{#p[1 2] #p{1 \"a\"  2 \"b\"}}\npyrsistent.freeze({pyrsistent.freeze([1, 2]), pyrsistent.freeze({1: 'a', 2: 'b', })})\npset([pmap({1: 'a', 2: 'b'}), pvector([1, 2])])\nThis may or may not be what we want.\nThere's a lot more to Pyrsistent than freeze though.. The interface seems basically the same, but I think PVector/PSet share data between revisions in a trie like Clojure does. I'm pretty sure Python's tuple and frozenset implementations don't do that.. Perhaps we should put this in extra with an optional dependency for Pyrsistent. This would keep Hy's core install smaller.. There's a potential problem with this approach. If a builtin acquires a new feature between Python versions (via an extra optional argument, say), and we decide to backport it by reimplementing the newer version in Hy.core, this change would prevent that backport from working in the older versions of Python. I don't think we're backporting any builtins currently however. I was worried about accumulate, but it's not actually a Python builtin, so it doesn't appear to be affected.. The docs would also have to be updated to match the new structure. Also, is this really an improvement? I'm not sure. There was no discussion. Hy really could use some refactoring though.. I'll approve it then. \ud83d\udc4d \nIs this still small enough to squash? I've seen some disagreement on when that's appropriate.. The names seem to have been taken from emacs lisp. Here's the doc for that.\nhttps://www.gnu.org/software/emacs/manual/html_node/elisp/Eval-During-Compile.html\nThey don't seem quite the same in Hy though. Maybe we could fix that.\nThey appeared with #187 by @khinsen, and the implementation is in the compiler, like you'd expect.\nThere are some tests showing what they can do, in tests/native_tests/native_macros.hy. Something like Clojure's tagged literals #1046 might be easier to implement. Those aren't true reader macros in the Common Lisp sense either. But Hy is more like Clojure than Common Lisp.. See also #1042. I don't know that Perl-style heredocs would work well in a Lisp, but maybe something like Lua's long brackets could work. If we had the better string syntax, then we could apply a tag to invoke an arbitrary reader/interpreter/compiler on a string containing any language we like. I think this would get us most of the power of reader macros, but perhaps there's more I haven't thought of.. It's not just cycle though.\nHy\n=> (list (partition (range 10)))\nfrom hy.core.language import partition, range\nlist(partition(range(10)))\n[(0, 1), (2, 3), (4, 5), (6, 7), (8, 9)]\n=> (list (partition (iter (range 10))))\nfrom hy.core.language import partition, range\nlist(partition(iter(range(10))))\n[(0, 2), (4, 6)]\nI wrote partition in the first place. I'll try to fix it.. Good work @Kodiologist. This is exactly the approach I was taking.. The main advantage of f-strings seems to be the format specifiers. I'm not sure how that should look in Hy. If you don't need that part,  you can get pretty close with a map and join.\n```Hy\n=> (setv a 2  b 3)\na = 2\nb = 3\n(a, b)\n(2, 3)\n=> (defn f [&rest xs] (.join \"\" (map str xs)))\nfrom hy.core.language import map\ndef f(*xs):\n    return ''.join(map(str, xs))\n=> (f \"the sum of \"a\" and \"b\" is \"(+ a b)\"\")\nf('the sum of ', a, ' and ', b, ' is ', (a + b), '')\n'the sum of 2 and 3 is 5'\n```\nIt doesn't look quite as nice in the Python translation, but HyExpressions don't use comma separators.. > Incidentally, I hate iterables. In practice, the laziness is of no benefit, I have to convert them to a list or tuple in order to do most any operation on them, and I get bitten by subtle bugs that arise because iterators drop each element once it's accessed.\nThe solution might be the seq abstraction from Clojure #1242.. They look pretty different to me. They both have the property of caching the calculated values. @tuturto's sequences seems like more of an alternative to generators. My seq abstraction would probably make that obsolete, since you could just use seq on a normal yield generator (or genexpr) to make it cache its values. My seq works on any iterable or iterator.. > gilch's approach takes any iterator and creates a new immutable iterator:\nMore precisely, it takes any iterable and makes a new lazy immutable iterable from it. The iterables are those things that you can use iter() on to get an iterator. It so happens that in Python, all iterators are themselves iterables (their __iter__() method returns self), so you can do things like this:\n```Python\n\n\n\ntuple([1,2,3,4,5])\n(1, 2, 3, 4, 5)\ntuple(iter(iter(iter([1,2,3,4,5]))))\n(1, 2, 3, 4, 5)\nspam = iter([1,2,3])\niter(spam) is spam\nTrue\niter(iter(iter(spam))) is spam\nTrue\n``\nA better optimizedSeqimplementation would similarly avoid creating a newSeqwhen it's created from aSeqor even from an iterator returned by aSeq`. \n\n\n\nYou can use a Seq to convert a (mutable) iterator to an immutable iterable and still use it in any Python function that needs an iterable. So the Python interop is pretty seamless.\nIf you have an iterator, but want to use it more than once, the usual way of handling that in Python is to realize the iterator into a tuple, which is immutable, but still iterable. This doesn't work well if the iterator is sufficiently large. The itertools.tee() function is a lazy alternative, but the iterators it returns are still mutable.\nI think we could also add a cdrs() method to Seq that gets a Seq of all the cdrs, like how {}.items() gives you a different view of the data.\nSee Clojure's seq abstraction for what else we could do with this. The LazyCons class is inspired by Clojure's lazy-seq.. We'd have to design it carefully. My proof of concept might have a bit of a problem there. I haven't tested it enough (and have already uncovered other problems). But in principle, if you don't keep a reference to the head, the garbage collector is free to reclaim any lazy cons cells you've passed. So besides a small fixed overhead for the current value, you're not taking up any more memory than any other lazy iterator.\nI think Python can reuse the function bytecode and only change the values in the closures, so I'm not too worried about the functions taking up too much memory. They're also generated on the fly, so it's still lazy. . I'm also \ud83d\udc4e on this. This has come up before #220 #351 #354. Python's reprs in general are never going to work in Hy. We can adjust our own libraries, but not the whole Python ecosystem. We could try to auto-convert reprs from Python, but I don't think it'll ever be 100%. Often the reprs of collection-like objects defer to the reprs of what they contain. Remember that Hy libraries can also be used from Python. I'd rather have valid Python reprs in all cases than some weird hybrid of the two that doesn't work consistently in either Hy or Python. That means we should adjust Hy's reprs toward Python, not the other way around.. I just thought of a weird compromise, and I'm not sure how I feel about it. If we implemented some kind of Hy string eval that we could invoke from Python, then we could make valid Python reprs that still contain Hy code:\nHy\n=> '(1 2 3)\nhy_eval(\"'(1 2 3)\"). Ah, no. I don't think that's good enough. You'd also need the reverse, Python, eval, since the collection can only represent objects by their Python repr, so:\n Hy\n=> '(1 2 {3 4})\nhy_eval(\"'(1 2 (eval \\\"{3: 4}\\\")\")\nNested quotes like that could get gnarly quickly. I don't think that idea is workable either.. >>That means we should adjust Hy toward Python, not the other way around.\n\nThat would seem to require making Python syntax into valid Hy syntax, which we just rejected.\n\nYou're not getting my meaning. I meant that things like '(1 2) should print out something like HyExpression((([] + [HyInteger(1)]) + [HyInteger(2)])), or <Hy '(1 2)> instead of just '(1 2), which makes no sense from Python.. Yeah, I only wrote it that way because that's what came out of the AST. That really could be simplified in the repr to HyExpression([HyInteger(1), HyInteger(2)]), or even hy([hy(1), hy(2)]) if we had a hy function that dispatches to the right model based on the data type it receives. The problem with something like <Hy '(1 2)> is how to nest them properly. With a dispatch function, it's easy, and it might even work in the Python repl.. > What do you think of using a command-line option for this\n\nThat being said, what if we put a prefix? e.g prefixing the command with something (no clue what yet) would use this repr...or maybe a reader macro?\n\nThis is the kind of thing other Lisps would use a dynamic variable for #1089. It would be nice to toggle other REPL features (like --spy) this way.\nStill, I do not approve.\nEven with a separate hy-repr and repr, you can still get weird hybrid representations that are neither fully Python nor fully Hy. This is because the __repr__ implementation of collection and wrapper types often defer to the repr of what they contain. The __hy-repr__ implementations of collection and wrapper types written in Hy would have to do the same, since hy-repr has to default to just repr when there is no __hy-repr__ implementation--which there won't be for the whole Python ecosystem, save for our own little corner.\nIt's also more work to implement both a __repr__ and a __hy-repr__ for every class.\nThus spake @paultag \n\nHy's failures mostly stem from us trying to cover up the fact it's actually Python\n\nWe should expect Hy users, even newbies, to know Python, at at least a basic level--just as Clojure(Script) users must understand Java(Script). I do not approve of trying to hide the Python that is in Hy, since this is the root of many of Hy's difficulties. I might even be helpful for newbies if we turned on --spy in the repl by default.\n. > (as if any project would remove a feature, ever)\nA serious concern. Once this is in Hy, it will always be easier to just leave it there.\n\nLike I said, there's no reason one couldn't put a generic placeholder in place of an object with no hy-repr; it just seems that the Python representation is more likely to be useful.\n\nI still don't understand how this is supposed to work. Concrete example time. \nSuppose you have some Python objects (foos) from some Python library. They have reprs like foo(1, duck()), but no hy-repr. Now you make some Hy objects (bars) that take some foos as arguments. They have reprs like bar(foo(1, 2), foo(3, bar(foo(4, 5)))). So far, so good, the bar repr defers to the repr of its foo arguments, which defer to the int and bar reprs and the net result is still valid Python, and it will generate an equivalent bar object.\nBut wait, now we have to write a __hy-repr__. Now it prints (bar foo(1, 2) foo(3, bar(foo(4, 5)))), and that's one of those weird hybrids that's neither Hy nor Python. It's not clear at all to the future user how to parse this. Note that bar appears both in the form (bar ...) and bar(...). Why? Because foo is written in Python and knows nothing about __hy-repr__, so of course it has to use __repr__ from bar instead.\nSo what if we use generic placeholders instead? Now you've got (bar <foo instance at 0xXXX1> <foo instance at 0xXXX2>). The user can totally parse this. But, you've hidden important information. Not good. It's not really valid Hy, but at least you know exactly where the holes are.\nOkay, maybe we can auto-wrap the repr with the placeholders. Now you get (bar <Py foo(1, 2)> <Py foo(3, bar(foo(4, 5)))>). It's still not valid Hy, but now we know both where the holes are and what goes in those holes. But look, the Hy repr version only applies to the first layer! We're still getting the form bar(...). What's the point of a Hy repr if we're printing it all off in Python anyway?\nEven though this is a contrived example, it is very representative of the common case. It's very typical in Python for the repr to be a constructor call that defers to the reprs of its arguments. There are more Python libraries written in Python than in Hy, so almost all Python objects will have no hy-repr.. > (Cons cells, your days are numbered!)\nCons cells are actually pretty useful in macros. I see no reason to remove them. This has also been discussed: #240 \n\nThe only way around that would be to hack method lookup so that repr calls hy-repr in certain cases, which to me sounds like much more trouble than it's worth\n\nPerhaps not the only way. You could also make it standard to write __repr__s in Hy that defer to (.__hy-repr__ self) in those certain cases, while the Python __repr__ doesn't have to know about it and just uses repr(bar) as normal. Determining those certain cases would be another use for a dynamic variable. I still think it's more trouble than it's worth, but I think that about hy-repr altogether.\n\nI guess I'm just not frightened enough of Python-in-Hy representations to think we should give up on any attempt at Hy representations. We're providing Hy representations of common classes, and ways for the user to create their own Hy representations.\n\nSo this is where we differ. I already disagree with providing Hy representations of common classes. They're confusing. I think we should rethink them so they make sense from Python, or at least make it clear what you're looking at without a debugger.\nWe should give up on any attempt at Hy representations. It's never going to work right, and there is very little to gain. Python reprs are good enough. Any competent Hy user should be able to translate Python reprs into Hy on the fly, in their heads. (This is actually much easier than the reverse, since Hy is much simpler than Python grammatically.)\nSo what possible use is a Hy repr anyway? It's not easier to understand than the Python repr. Even Python reprs aren't good enough for serialization (and we have pickle for that), so weird hybrid Hy reprs certainly aren't. You can't generally paste a weird hybrid Hy repr it back into the Hy repl, while you actually can with most Python reprs, simply by using Python's eval() on it as a string. We could make this easier than it is currently, and perhaps we should, by\n making Hy's model's reprs valid Python.\n making python's eval() more available. It seems to be shadowed by Hy's (eval), so you have to get it from builtins.\n* adding long bracket strings so we don't have to escape any quotes. #1042.. > Yes, but I don't have a telepathic link to my computer. I need to delete or add commas, delete colons, change single quotes to double quotes, etc.\nOr you could just Python eval the string and let the computer worry about that part. This seems a lot more reliable than your approach.\nWe could even demonstrate this workflow in the Hy tutorial, if you're worried users won't think of it. Unless you're talking about changing what you input instead of what's output, in which case, it's already Hy.\n\nI don't know what to tell you\n\nI still don't really get your use case. Concrete examples might help.. > I think the elephant in the room with my conversations with you is that I'm more liberal, in a programming sense, than you are.\nYou label yourself a liberal? (extremist?) I think we kind of already knew that, but the article clarifies your stance a little. But, your implication here is that I get the conservative (moderate?) label. I think this is a bit off topic (sorry about that), but I can't just be silent and let that stand, or it'll just create further misunderstanding.\nI read the article you linked to. It didn't jive with me at all. The liberal/conservative axis as described is orthogonal to my values (in the programming sense). I looked at the languages example to see where I stand. I don't fit anywhere.\nI like the \"extremist conservative\" Haskell, and the \"liberal\" Smalltalk for the same reasons: simplicity, power, good tooling, minimal ceremony. They're excellent examples, respectively, of static typing done right, and how good tools and runtime transparency can compensate for not having it. I also think the tables from \"hardcore liberal\" Lua gives the language a beautiful simplicity. (Of course, \"liberal\" Python is a better choice than Lua in most cases.) And lists give Lisps in general that beautiful simplicity.\nOn the other hand, I dislike the \"hardcore conservative\" Scala, hate \"moderate-conservative\" C++, and the \"hardcore liberal\" JavaScript for the same reasons: they're too complex to get anything done. I also really dislike \"Moderate-conservative\" C#/Java because of the ceremony, and also Go (in the same category) for lack of power: static typing but no generics. The half-baked static typing in these three languages is more trouble than it's worth.\nSo yeah, I don't fit on your axis. I reject the label of \"less liberal than you\". Our difference in philosophy is something else, if it's even there.. So, back on topic. @kirbyfan64 already kind of said \"no\". Expecting a merge is kind of premature. One more \"no\" from core and I'm closing this. I'm not sure what @tuturto decided, but if you get two \"yes\"es I'm overruled. Three's a quorum/three's a veto.\n\n...so, as for the use cases, is there a reason someone can't just use _ to reference the previous calculation? FWIW I've never, ever had to use copy-paste in any half-decent REPL. Hy already has _ and readline and a cool prompt, and there's an open issue for making the REPL fancier (e.g. bpython/IPython).\n\nI pretty much agree, but \"never\" is such a strong word. Maybe @Kodiologist can come up with some convincing concrete examples of why this is useful enough to consider?\nI'm still not seeing much use for this. Usually when editing Lisp, you paste forms from your source file into the repl. Emacs has commands for this workflow. Not the other way around.\nIf you really want to write Lisp to help you edit your code, just use emacs. Or write a Hy macro to edit your code and put that in your source file instead.. > Lets run an experiment: we could bring this in, have it disabled by default, activated by command line switch and see how it behaves in the wild. After some amount of time, we can get back to the matter and see what we learned. At that point we can adjust things or even remove it completely (as if any project would remove a feature, ever) if this turned out to be a bad idea. How does this sound like?\nHere's a better plan. How about @Kodiologist implements this in Hy, and puts it in contrib. That's already where we're putting experimental features. That way it's not so integrated into Hy, and easy to remove. It's also not any kind of default.\nHow hard is a repl? You read, eval, print, and loop. Easy. You just change the \"print\" part to use hy-repr, if available. You could start it from the normal repl with an import and function call. Or you could start it from the command line using a script that does that for you.. > To me all of this seems like needless complexity, because it's hard to see many people wanting to use a REPL output function other than repr or hy-repr, but it's a reasonable compromise.\nNeedless? Nah. We've talked about making improvements to the repl before. Those efforts could benefit from that kind of modularity. I could imagine uses for hooks in any of the read, eval or print steps. You could add non-Hy commands as shortcuts or to control aspects of the repl itself like IPython has. You could colorize output, or send it to a graphical window or something. Besides hy-repr you could create some kind of graphical-repr like Racket has. We'd be able to put those types of experiments in contrib also, or even an independent library. Third parties could also try such things.\n\nYour second paragraph seems to suggest writing an entirely separate implementation of the REPL for the sake of using hy-repr, which seems like a lot of duplicated code. \n\nA basic repl just isn't that complex, given read/eval/print functions, which we have. If there's additional functionality (readline?) you want to keep then, yeah, adding hooks to our existing repl might be a better approach.. >Would you approve hy --repl-output-fn hy.contrib.hy-repr.hy-repr, then?\nI would not be at all opposed to modularizing the repl. Once that's done, I wouldn't be particularly opposed to contrib experiments taking advantage of it. That invocation does seem long-winded (though I suppose one can always use aliases or shell scripts for such things).\nI wonder what a good interface would be. Perhaps --read, --eval, and --print options would be OK. Or maybe we could just point it to a Hy (or Python) module that exports some subset of Read, Eval, and/or Print callables that can override the defaults. Then it would just be \n$ hy --repl hy.contrib.hy-repr\nIf you want to mix-and match, say Read from one module and Print from another, then you have to write a module that imports each from wherever. Other future repl implementations (GUI? emacs?) could also use the same config module.. I can think of another advantage of the config module approach. You could set state in the module through a special repl command in the Read callable that swaps out the implementation used by one of the other callables without the need to restart the repl. You could even set it up to import new ones on the fly.. #1401 . Disclaimer: I am not a lawyer. I probably don't know what I'm talking about. Neither are the other authors. This seems to be the reason we're not getting much participation on this issue. It's holding us up though.\nCopyright declarations can help avoid confusion about ownership, but are not actually legally required in the United States at the moment. The copyright automatically applies as soon as the work is written down. I don't know about the laws elsewhere.\nI don't think it matters if an individual file is conceivably copyrightable. The copyright and license applies to Hy as a whole, rather than its individual files. And the license itself doesn't appear to require headers at all.\nThe Git repository tracks authorship and dates well enough for legal purposes, but the headers should not contradict this (and they do at the moment). I'm inclined to approve this pull as an improvement to the status quo. If anyone has strong objections, afterwards make another pull I guess.\n. > Perl's q operator, but a little simpler. \n\nunless C belongs to the Unicode General Categories Ps (Punctuation, open) or Pi (Punctuation, initial quote), in which case the character with the code point after C terminates the literal.\n\nThere's no point in supporting paired delimiters like that unless you can also nest them like Perl does. All or none.\n\nPersonally, I don't mind Python's triple-quoted string literals, though, because they fit in pretty well with the rest of the language. They make logical sense in the context of everything else, and they wouldn't require barring off another possible character from sharp macros.\n\nThat was Python, this is Hy. Hy is already using ' for the (quote) form. Sometimes you need a quoted quote in macros, so ''' is also out. That just leaves \"\"\" which just isn't good enough by itself because sometimes you need a triple-quoted string in a doctest. Hy can't do it Python's way and still look like a Lisp.\nIf we had tagged literals #1046, I'd be less reluctant to give up another character. I'm also not sure how I feel about calling them \"sharp macros\" since the \"sharp\" character \u266f is distinct from the \"number sign\" # that we actually use. (I don't want them called \"number-sign macros\" either.)\nI also like Proposal C best so far, but don't think it's good enough. Let's consider the actual use cases our current strings aren't meeting adequately.\ndoctests\nIf any of the code in the doctest has a \" character (a common occurrence), it must be escaped. Proposal C is an improvement here, but still falls short.\nYou have to pick a character you're not allowed to use, and might have to change it as you edit the string. This seems like a pain. Python's triple quotes are easier in this regard: no single character can end the string.\nGiven the sheer number of Unicode characters, any doctest of reasonable length will omit some, so you can quote any reasonable doctest without escapes. But I don't want to force Hy programmers to use characters they can't type on a standard US keyboard, or save in a plain ASCII file. This is also the main reason I rejected Proposal A.\nregex\nSometimes you need a \" and ' in a regex. You also need \\ for nontrivial regexes. Python's raw triple quotes are great for this. Clojure's regexes look like #\"this\". Hy doesn't have a built-in literal (since Python doesn't), but a reader macro helps, and this was specifically mentioned in Hy's docs. How should a regex look under these proposals? Like #^#q/\"don't\"/?\nnew literals\nIf we had proper Common-Lisp reader macros, we could set up any new literal syntax we like pretty easily, including whatever string-quoting scheme makes sense for the application. It also lets you completely change the rules of the language, which is great if you want to make a new language, but can cause Tower-of-Babel problems if you're not careful, both at the team level, and worse, at the ecosystem level. I'm not sure if true reader macros are a good idea for Hy, but I won't oppose it.\nClojure had a compromise solution with the tagged literals. You would usually apply a tag to strings representing individual objects (like the regex example), or a to a Hy data structure. I think we could get at least 80% of the power of reader macros using a combination of tagged literals, strings, and Hy's reader. With the help of the reader, you could put an entire toplevel form (or even the whole file) in a string, with any tweak you like to Hy's syntax. You preprocess it however you like, then if the result is valid Hy, you can pass it to Hy's reader for evaluation.\nFor this to work, you need a string syntax that's both short enough to use for individual atoms but robust enough to contain arbitrary Hy code. Heredocs would certainly work for the larger strings, but are too cumbersome for lists of smaller atoms. Proposal C is not great for either extreme. It's a little too long for atoms (but could work), would be awkward for a toplevel form for the same reasons as doctests and would probably require using Unicode delimiters for the whole file.\nProposal D\nA literal of this form begins with #\", followed by any target string terminated by either : or : and one newline, followed by the body. The body is terminated by the target string followed by a \", unless you opened with the newline, in which case it's terminated by a newline, the target, \". Examples:\n```\n=> #\":foo\"\n'foo'\n=> #\":\ndocstring\n\"\n'docstring'\n=> #\"/:\"don't\"/\"\n'\"don\\'t\"'\n=> #\"END:\nDon't say,\n\"I can't!\".\nEND\"\n'Don\\'t say,\\n\"I can\\'t!'\n=> #\"\"\":\nTriple quotes?\nWe can still begin and end with newlines!\n\"\"\"\n'\\nTriple quotes?\\nWe can still begin and end with newlines!\\n'\n=> #\"\"\":3-\"'s!\"\"\"\n'3-\"\\'s!'\n```\nThis does pretty much everything I want, with a syntax that doesn't look too heavy, and can even resemble Python's triple quotes if you want, by using two quotes \"\" as the target string. Note that empty target strings are allowed. The leading : in #\":foo\" looks like a keyword, so you're already used to glossing over that. Also, the leading :\\n option resembles the same block format from Python, so it doesn't look too weird. It can also work much like heredocs if you need it to, and you don't have to strip the leading \\n, but can still include one if you want.\nI might also like a way to strip out leading indents. Tagging these strings is still a little ugly: \n```\nre #\"/:\"don't\"/\"\n````\nIf anyone has another proposal/modification that meets my requirements, I'd like to see it.. > I don't see how you came to this conclusion.\nThe special case of paired delimiters is extra complexity by itself. I think it's worth the extra complexity if you can nest them, but otherwise don't bother. If the opening character is always the closing character, that's simpler.\n\nand also there's this stuff about newlines, but I don't think that's important because you seem to intend it solely for docstrings\n\nActually docstrings are the one place you don't need it. Python's docstring tools already strip it out. I want this for the cases I'm quoting some other language, but also want its normal formatting without the opening quote screwing up the indentation. I don't want to have to strip it myself. Lua's brackets do strip one initial newline, if present. You can still start with a newline by simply adding another one. Requiring the newline at the end in that case is less important to me, but I do think it looks nicer.\n\nIn exchange requires an extra character at the front and back\n\nActually, we could modify D to do it with only one extra, but the triple-quote trick needs both to look pretty.\n\nIf you're still keen on the possibility of multiple-character customizable delimiters at the expense of brevity, though, we could make #qC fancier to accommodate this.\n\nI like this plan. We get both the single-character brevity we want for atoms, and the long delimiters we need for other language. I'm not sure what form it should take. The = proposal seems reasonable, but once you get up past ===, an arbitrary end string would be shorter. I also don't trust humans to count bigger numbers accurately, but they'd also come up a lot less often. Hmm. I think it's worth getting some more opinions.. On second thought, how do you quote = itself in a #q= string? What if the body starts or ends with =? This doesn't work. \nWe need a pair of delimiters for the special case. We could use Lua's approach #q[[, #q[=[, #q[==[, etc. But by then why not include an arbitrary string (sans []) between the [[? We could also point the inner delimiters the other way like #q<target> a la XML. The closing part could just be target itself instead of <target> or </target>.. @hylang/core the two best options for multiple-character custom delimiters seem to be like q[foo[ and ]foo] or likeq<foo> and foo. I don't have a very strong opinion, does anyone have a preference, and why?. I thought that the pip install -e . step was supposed to run setup.py? There's no instruction to run it directly in the \"Hacking on Hy\" document. And in any case, the version shows up properly on Linux without any extra steps.\nThe version file doesn't seem to have been generated, but where exactly should it be located on Windows? I found it on Linux at <my virtualenv for hy> /lib/python3.5/site-packages/hy/version.py. The equivalent location doesn't seem to exist on a Windows virtualenv either. I found .\\Lib\\site-packages\\, but no hy\\ in there, only hy.egg-link.\nI don't have a global Hy install on this machine, only virtualenvs. What other Hy version could the tests possibly be finding? When the virtualenv is active, the hy command launches the Hy repl as expected. It still says the version is \"unknown\" though. I am, of course, launching pytest from the active virtualenv.. > remove the except block there to see what error is preventing the version file from being generated.\nI figured out why the version wasn't generated. We added the git hash to Hy's version string. I when I ran that first test, I had downloaded master as a zip from github, which it turns out, has no hidden .git folder. It's not a repository. No git, no hash. I think setup.py could handle this better and say hy 0.12.1+unknown instead of just unknown in such cases.\nSo I cloned the repo using Cygwin's git and installed into a new virtualenv. Now I've got the version, but I still get the two failing tests:\n```\n============================= test session starts =============================\nplatform win32 -- Python 3.6.1, pytest-3.0.7, py-1.4.33, pluggy-0.4.0\nrootdir: C:\\Users\\ME\\hytest\\hy, inifile: setup.cfg\ncollected 153 items\ntests\\test_bin.py ......F................F....\ntests\\test_lex.py .................................\ntests\\test_models.py ..............\ntests\\compilers\\test_ast.py .................................................................\ntests\\compilers\\test_compiler.py ...\ntests\\importer\\test_importer.py .....\ntests\\importer\\test_pyc.py .\ntests\\macros\\test_macro_processor.py ...\ntests\\macros\\test_sharp_macros.py .\n================================== FAILURES ===================================\n__ testbin_hy_stdin_error_underline_alignment ___\ndef test_bin_hy_stdin_error_underline_alignment():\n    _, err = run_cmd(\"hy\", \"(defmacro mabcdefghi [x] x)\\n(mabcdefghi)\")\n\n\n  assert \"\\n  (mabcdefghi)\\n  ^----------^\" in err\n\nE       assert '\\n  (mabcdefghi)\\n  ^----------^' in 'hy 0.12.1+87.ga537d33 using CPython(v3.6.1:69c0db5) 3.6.1 on Windows\\r\\n  File \"\", line 1, column 1\\r\\n\\r\\n  (...or: b\"expanding `mabcdefghi\\': missing 1 required positional argument: \\'x\\'\"\\r\\n\\r\\n\\r\\n\\r\\nnow exiting HyREPL...\\r\\n'\n\ntests\\test_bin.py:125: AssertionError\n____ test_bin_hy_byte_compile _______\ndef test_bin_hy_byte_compile():\n\n    modname = \"tests.resources.bin.bytecompile\"\n    fpath = modname.replace(\".\", \"/\") + \".hy\"\n\n    for can_byte_compile in [True, False]:\n        for cmd in [\"hy \" + fpath,\n                    \"hy -m \" + modname,\n                    \"hy -c '(import {})'\".format(modname)]:\n\n            rm(get_bytecode_path(fpath))\n\n            if not can_byte_compile:\n                # Keep Hy from being able to byte-compile the module by\n                # creating a directory at the target location.\n                os.mkdir(get_bytecode_path(fpath))\n\n            # Whether or not we can byte-compile the module, we should be able\n            # to run it.\n\n\n          output, _ = run_cmd(cmd)\n\n\ntests\\test_bin.py:278: \n\ncmd = \"hy -c '(import tests.resources.bin.bytecompile)'\", stdin_data = None\nexpect = 0\ndef run_cmd(cmd, stdin_data=None, expect=0):\n    p = subprocess.Popen(os.path.join(hy_dir, cmd),\n                         stdin=subprocess.PIPE,\n                         stdout=subprocess.PIPE,\n                         stderr=subprocess.PIPE,\n                         shell=True)\n    if stdin_data is not None:\n        p.stdin.write(stdin_data.encode('ASCII'))\n        p.stdin.flush()\n        p.stdin.close()\n    # Read stdout and stderr otherwise if the PIPE buffer is full, we might\n    # wait for ever\u2026\n    stdout = \"\"\n    stderr = \"\"\n    while p.poll() is None:\n        stdout += p.stdout.read().decode('utf-8')\n        stderr += p.stderr.read().decode('utf-8')\n\n\n  assert p.returncode == expect\n\nE       assert 1 == 0\nE        +  where 1 = .returncode\n\ntests\\test_bin.py:55: AssertionError\n==================== 2 failed, 151 passed in 38.34 seconds ====================\nPytest also prints a traceback on stderr:\nError in atexit._run_exitfuncs:\nTraceback (most recent call last):\n  File \"c:\\users\\me\\hytest\\2venv-hy\\lib\\site-packages\\clint\\packages\\colorama\\initialise.py\", line 17, in reset_all\n    AnsiToWin32(orig_stdout).reset_all()\n  File \"c:\\users\\me\\hytest\\2venv-hy\\lib\\site-packages\\clint\\packages\\colorama\\ansitowin32.py\", line 64, in init\n    convert = on_windows and is_a_tty(wrapped)\n  File \"c:\\users\\me\\hytest\\2venv-hy\\lib\\site-packages\\clint\\packages\\colorama\\ansitowin32.py\", line 15, in is_a_tty\n    return hasattr(stream, 'isatty') and stream.isatty()\nValueError: I/O operation on closed file\n```. None of the native tests are running on Windows!\nI just noticed this, but you can see from the output that the last testfile is tests\\macros\\test_sharp_macros.py. The native tests should follow.\nPytest is clearly not set up properly for Windows. Am I running the commands wrong? Once I'm in my venv, at the root folder, I run pytest. Was there something else to it?. Why ignore the test_bin.py? Is is just because it's slow? (Can we fix that?) The failing tests were in that file, so of course that avoids them. I still get an error after the tests though.\nError in atexit._run_exitfuncs:\nTraceback (most recent call last):\n  File \"c:\\users\\me\\workspace\\hy36-gilch\\lib\\site-packages\\clint\\packages\\colorama\\initialise.py\", line 17, in reset_all\n    AnsiToWin32(orig_stdout).reset_all()\n  File \"c:\\users\\me\\workspace\\hy36-gilch\\lib\\site-packages\\clint\\packages\\colorama\\ansitowin32.py\", line 64, in __init__\n    convert = on_windows and is_a_tty(wrapped)\n  File \"c:\\users\\me\\workspace\\hy36-gilch\\lib\\site-packages\\clint\\packages\\colorama\\ansitowin32.py\", line 15, in is_a_tty\n    return hasattr(stream, 'isatty') and stream.isatty()\nValueError: I/O operation on closed file\nI think this is just the colorama problem from pytest-dev/pytest#2465, which is not our issue.\nI tried the git clean -dfx and pip install -e . and still get failing tests in test_bin.py. That part might be more about how those particular tests are written than about Pytest on Windows, but the native tests still aren't running either.. I tried the debugger on conftest.py and see a problem. path.dirname has backslashes in Windows. Therefore, the test--\nif (path.ext == \".hy\"\n        and \"/tests/native_tests/\" in path.dirname + \"/\"\n ...\n--is never going to pass. That's why pytest can't find the native tests on Windows.. get is a special form that translates to Python subscript notation (i.e. (get foo 42) ;>>> foo[42]) not a function. This means you can't map over a collection with it, nor pass it as an argument. We could possibly shadow it with a real function like we do with operators. If you run the Hy repl with the hy --spy option, you can see the equivalent Python to the AST Hy is generating.\nIn the meantime, you can define something like this: \nHy\n=> (defn my-get [coll key] (get coll key))\ndef my_get(coll, key):\n    return coll[key]\nNone\n=> ((tz.flip my-get 1) [0 1 2])\ntz.flip(my_get, 1)([0, 1, 2])\n1. The above is the general process for making a function out of a special form, but it turns out that Python's standard library already has this in its operator module.\n=> (import [operator [getitem]])\nfrom operator import getitem\nNone\n=> ((tz.flip getitem 1) [0 1 2])\ntz.flip(getitem, 1)([0, 1, 2])\n1\nThis makes me think that get should be shadowed like our other operators.. I would also prefer one canonical capitalization, but I'm more inclined to use all-lowercase nan and inf, since that is the Python repr.\n```\n\n\n\nfloat('NaN')\nnan\nfloat('Inf')\ninf\n. I'm not sure what to think. I guess my feelings are not that strong either. @kirbyfan64, what say you?. You're looking for `&kwonly`. The proper invocation follows:Hy\n=> ((fn [&rest args &kwonly target &kwargs kwargs] [args target kwargs]) 1 :target \"bi\" :foo \"bar\")\n(lambda args, kwargs, target: [args, target, kwargs])(1, target='bi', foo='bar')\n[(1,), 'bi', {'foo': 'bar'}]\n. @ekaschalk In that case, you specify the default value, the same way as with `&optional`.Hy\n=> ((fn [&rest args &kwonly [target None] &kwargs kwargs] [args target kwargs]) 1 :foo \"bar\")\n(lambda *args, kwargs, target=None: [args, target, kwargs])(1, foo='bar')\n[(1,), None, {'foo': 'bar'}]\n=> ((fn [&rest args &kwonly [target \"hi\"] &kwargs kwargs] [args target kwargs]) 1 :foo \"bar\")\n(lambda args, kwargs, target='hi': [args, target, kwargs])(1, foo='bar')\n[(1,), 'hi', {'foo': 'bar'}]\n=> ((fn [&rest args &kwonly [target \"hi\"] &kwargs kwargs] [args target kwargs]) 1 :target \"bye\" :foo \"bar\")\n(lambda *args, kwargs, target='hi': [args, target, kwargs])(1, target='bye', foo='bar')\n[(1,), 'bye', {'foo': 'bar'}]\n=> ((fn [&rest args &kwonly [target \"hi\"] &kwargs kwargs] [args target kwargs]))\n(lambda args, *kwargs, target='hi': [args, target, kwargs])()\n[(), 'hi', {}]\n```. > Can you make the first line of the commit message more specific, like \"Use universal newlines in test_bin.py\"?\n\n\n\nDone.\n\nPushing to hylang/hy makes Travis test your branch twice.\n\nNoted. I wonder if we can turn off that Travis \"feature\" though, and only test the PR's and master (or other important branches). I don't think I can change this to my fork without opening a new PR though.\nI've discovered git on Windows is harder than it should be. Cygwin's git doesn't use the \"recommended\" core.autocrlf default, and instead pretends it's on a Unix. Of course, Git on Ubuntu on Windows (WSL) has the same setting--I thought it might be contributing to the error, so I downloaded GitHub Desktop and cloned the hylang repository using that. (No change in the test though.) Of course, Cygwin's git reported every single text file had changed after that, which made the command line version pretty useless for operating on that repository. The GUI is pretty limited compared to the command line, so I just pushed the branch. GitHub Desktop used to have its own command line git installation I could access through the menus. I would have used that but, the new Electron update seems to have removed that feature.. I've got two approvals and no further complaints, so I'll just merge this.. @Kodiologist Conflicting files, can you fix that? News should be easy. #1307 also affected that test file. You wrote #1269 in the first place, and this seems like a simple amendment. The test looks more complex but Travis passed it. Otherwise, it looks okay to me. \nAfter fixing the conflict, try breaking the flag PYTHONDONTWRITEBYTECODE detection to make sure the test still catches it.. I'll merge it then.. These history rewrites are trying my limited git skills. I think I can do this with an interactive rebase, but separating hunks from a single commit like that seems too hard. Maybe I can copy/paste and squash in a new commit. How would you approach this?\n\nDo you also write the name of the programming language C# as \"C\u266f\"?\n\nOfficially, yes. But Unicode is hard to type, and everyone knows the substitution. Hy, on the other hand, actually does support Unicode symbols. Regardless, the stronger argument is really that \"tag\" is closer to what Clojure calls its version.\n\nis a bit vague; you mean something like \"when FORM starts with an identifier character\", right?\n\nNo, I meant what I said. Something like #foo5 means the tag symbol is foo5, but #foo 5 means the tag symbol is foo and the tagged form is 5, which is an integer, not a symbol (\"identifier\"). If you think my proposed version is not clear, OK, let's work on it, but your proposed version is still not right either.\n. > So to clarify, in Hy's case, I use the term \"identifier\" to describe a lexical entity\nAh, I see what you meant. I've also used that internal terminology in the first commit. But I don't think that is appropriate for the documentation, which is intended not just for Hy's developers, but for Hy's users, who can't be expected to be familiar with Hy's implementation details.\nSo, we could instead explicitly say that brackets (, [, {, quotes ', \", or white space (including ; comments), will terminate a tag. Or we could just use more examples illustrating these.\n. > But listing out all the characters that aren't identifier characters is brittle.\nAgreed, that's brittle. So are the examples, honestly, but at least we could potentially test those automatically. #1044. I'm inclined to remove the offending sentence altogether. This is documentation, not specification. The existing examples should suffice. Users can resolve this question pretty quickly in the repl.\n\nyou use the term \"hashtag character\"\n\nHeh, haven't you heard? That what all the kids are calling them nowadays. (And hashtags are used for a lot more than Twitter now.) \"Pound\", \"hash\", \"number sign\", \"octothorp\", and not to be confused with \"sharp\". This thing has too many names. Yeah, \"hashtag\" is arguably not correct for the character itself. I think we should just call it # in the docs and let the users worry about how to pronounce it.. I just noticed that you can define the empty string as the name of a sharp macro on the current master (0.13.0), but there's no way to call it. This seems like a good time to fix that.\nThe ability to define sharp macros with a string name is currently necessary to define sharp macros with certain characters, like #.. With this update, arbitrary strings are allowed as tag names, but they can't be called if empty or if they contain whitespace (or a bracket or quote or semicolon). \n1117 could probably fix this, since any string would have an associated symbol. For now, would it be better to disallow strings to define tags, or just empty strings?. OK, I think I got it working properly.. Okay, I added tests for mangling. I had to add a mangling call to the compiler to make it pass. I amended the first commit with that, since I figured that's where you'd want it. This would probably work better with #1117.. That should fix it. I needed to use .replace() on the mangled symbol to transfer the metadata.. We've got conflicting files now.\nAuto-promotion sure seems like it would make some things easier.\nHow would this affect #919? Tag macros are still at compile time, but I think Clojure's tagged literals are at read time, like Common Lisp's #.. I'd also like easier access to Python's eval in Hy (we already have exec). Currently you have to import it from the builtins module. We could either rename Hy's eval (to hy-eval) or rename Python's eval (to py-eval). I'm imagining in-line Python--something like\n=> (#py\"lambda x: x + 1\" 41)\n42\n--would be possible with no performance impact. Currently, even with a macro, the (py)eval has to happen at runtime.. If we're generally autoboxing unquotes #1174 shouldn't this work?\nPython\n=> (disassemble `(+ ~(+ 1 1) 40) True)\nfrom hy.core.language import disassemble\nfrom hy import HyExpression, HyInteger, HySymbol\ndisassemble(HyExpression(((([] + [HySymbol('+')]) + [(1 + 1)]) + [HyInteger(40)])), True)\nTraceback (most recent call last):\n  File \"c:\\users\\me\\documents\\github\\autobox-hy\\hy\\importer.py\", line 184, in hy_eval\n    return eval(ast_compile(expr, \"<eval>\", \"eval\"), namespace)\n  File \"<eval>\", line 1, in <module>\n  File \"C:\\Users\\ME\\Documents\\GitHub\\autobox-hy/hy/core/language.hy\", line 78, in disassemble\n    (fake-source-positions tree)\n  File \"C:\\Users\\ME\\Documents\\GitHub\\autobox-hy/hy/core/language.hy\", line 182, in fake_source_positions\n    (fake-source-positions subtree)))\n  File \"C:\\Users\\ME\\Documents\\GitHub\\autobox-hy/hy/core/language.hy\", line 185, in fake_source_positions\n    (setattr tree attr 1))))\nAttributeError: 'int' object has no attribute 'start_line'\nIt works if I box it manually though.\nPython\n=> (disassemble `(+ ~(HyInteger (+ 1 1)) 40) True)\nfrom hy.core.language import disassemble\nfrom hy import HyExpression, HyInteger, HySymbol\ndisassemble(HyExpression(((([] + [HySymbol('+')]) + [HyInteger((1 + 1))]) + [HyInteger(40)])), True)\n'(2 + 40)'\nIs the compiler really the right place to put this?. hy/docs/language/internals.rst may need some clarification because of these changes. That file was not modified though. This PR digs pretty deep into some of Hy's internals. I want more time to review it.. hy-eval needs a good docstring explaining its use and parameters now that we're using it as a function. (I think special forms and macros need this too, but that's another issue #356)\n\n\ndocument the implementation was a mistake\n\nNo, the Hy model system is important enough for macro writing that it should be considered part of the public API. See also, this recent stackoverflow question. This PR certainly would have helped.\nIt needs to be documented. And I don't think this PR goes far enough to change that.\nFor example, this works in Clojure\nClojure\nuser=> (eval `(/ 2))\n1/2\nuser=> (eval `(/ ~2))\n1/2\nuser=> (eval `(~/ 2))\n1/2\nuser=> (eval `(~/ ~2))\n1/2\nThere's no distinction between value and model, like Hy has currently. This PR helps--\nPython\n=> (eval `(/ 2))  ; works now\nfrom hy.core.language import eval\nfrom hy import HyExpression, HyInteger, HySymbol\neval(HyExpression((([] + [HySymbol('/')]) + [HyInteger(2)])))\n0.5\n=> (eval `(/ ~2))  ; requires this PR for autobox\nfrom hy.core.language import eval\nfrom hy import HyExpression, HySymbol\neval(HyExpression((([] + [HySymbol('/')]) + [2])))\n0.5\n=> (eval `(~/ 2))  ; Boom.\nfrom hy.core.language import eval\nfrom hy.core.shadow import /\nfrom hy import HyExpression, HyInteger\neval(HyExpression((([] + [/]) + [HyInteger(2)])))\nTraceback (most recent call last):\n  File \"c:\\users\\me\\documents\\github\\autobox-hy\\hy\\importer.py\", line 185, in hy_eval\n    return eval(ast_compile(expr, \"<eval>\", \"eval\"), namespace)\n  File \"<eval>\", line 1, in <module>\n  File \"c:\\users\\me\\documents\\github\\autobox-hy\\hy\\importer.py\", line 159, in hy_eval\n    replace_hy_obj(hytree, foo)\n  File \"c:\\users\\me\\documents\\github\\autobox-hy\\hy\\models.py\", line 50, in replace_hy_obj\n    return obj.replace(other)\n  File \"c:\\users\\me\\documents\\github\\autobox-hy\\hy\\models.py\", line 178, in replace\n    replace_hy_obj(x, other)\n  File \"c:\\users\\me\\documents\\github\\autobox-hy\\hy\\models.py\", line 58, in replace_hy_obj\n    % type(obj))\nTypeError: Don't know how to wrap a <class 'function'> object to a HyObject\n--but only certain basic values can be autoboxed. Even understanding the error message requires knowledge of these \"internals\": There's no Hy model for functions. And custom data types will have the same problem. I don't see an easy way to fix this, so it seems to be beyond the scope of this PR.\n\nBut I don't see anything on that page that's been made obsolete by these changes.\n\nI suppose it can wait then.\n. We might end up going the other way with this. See #1324.. There's no need to alter the compiler. A custom defn macro can replace the one in core/bootstrap. See the defn macro from contrib/multi. \nDomain-specific forms belong in third-party libraries, not Hy proper. General-purpose forms, on the other hand, should be in Hy core or contrib or extra, to avoid fragmentation of the ecosystem. This \"design by contract\" setup is generally useful. That's why Clojure has it built in. Considering that precedent, I'd be willing to put a good implementation in contrib, with our other experimental features.\nMacros are not even required for this. A Python decorator could theoretically do this, but a macro might have less overhead. It would also be nice if the defn from contrib/multi were compatible.. My thoughts as well. I was just looking at that. But decorators have the overhead of an additional function call. It seems like it would be easy to do pre-conditions as a macro without that overhead. Postconditions might be more tricky with multiple returns, exceptions, yield, and async/await. We currently don't have async/await implemented, but that should change. Multiple returns are also controversial, but might happen.. On second thought, a decorator could check if not __debug__ and just return the function without wrapping it when assertions are off. This would eliminate any overhead after loading the module when assertions are off. This makes a macro implementation seem less important to me. But a preconditions macro really would be easy.. A postcondition macro could maybe expand to a try/finally surrounding the function body. That seems like less overhead than wrapping the function. But it might be tricky for the aforementioned reasons. I don't use postconditions enough to know how they're supposed to work in those cases.. I did some looking and found:\n\nhttps://github.com/stefankoegl/python-decontractors (BSD-3) This one looks unmaintianed, but if it's not broken, no need to fix it.\nhttps://andreacensi.github.io/contracts/ (LGPL) This one looks pretty nice. The weak copyleft means we can't just pilfer it, but we could recommend it.\n\nThere's also zope.interface package that looks too complicated, and a PyDBC that's based on a Python 2 metaclass, probably not what we want.\nPEP 316 is also worth mention.\nThese aren't particularly compelling though. Basic pre and post condition decorators would be so easy that I'm tempted to roll my own.. Yeah, this is pretty simple as a decorator.\n```Python\nfrom functools import wraps\ndef contract(, pre=lambda a, kw: True,  post=lambda r: True):\n    def wrap(f):\n        if not debug: return f\n        @wraps(f)\n        def wrapper(*args, kwargs):\n            assert pre(*args, kwargs), f\"\"\"Precondition not met.\n  args: {args}\n  kwargs: {kwargs}\"\"\"\n            res = f(*args, kwargs)\n            assert post(res), f\"\"\"Postcondition not met.\n  returned: {res}\"\"\"\n            return res\n        return wrapper\n    return wrap\nExample usage (also works as a doctest).Python\n    >>> @contract(\n    ...         pre=lambda a,b: a0,\n    ...         post=lambda r: r==42)\n    ... def foo(a, b):\n    ...         return a+b\n>>> foo(40,2)\nTraceback (most recent call last):\n  ...\nAssertionError: Precondition not met.\n  args: (40, 2)\n  kwargs: {}\n>>> foo(1,2)\nTraceback (most recent call last):\n  ...\nAssertionError: Postcondition not met.\n  returned: 3\n>>> foo(2,40)\n42\n\n```\nThe lambdas are a bit awkward, but it seems perfectly usable. The traceback doesn't say exactly what expectation failed, but it points you to the right to the test definition, and prints the failing data. \nFrom its docs, PyContracts appears to use eval'd strings instead of lambdas like I did. This could give you a prettier traceback that includes the test itself, but strings seem more error-prone. It shouldn't affect performance too much, since it would only have to be compiled once, like namedtuple.\nI do think a macro could make this better in Hy. We could use the Clojure syntax and include the test itself in the traceback, unlike my decorator. If we recommended PyContracts, the test strings would have to be written in Python, or use Python's annotations, which we don't support yet #640.. It doesn't work--map takes two arguments. I can guess what you're trying to do though. But the setv ret .../check (... ret ...)/... ret) pattern has to be rewritten every time. Boilerplate like that belongs in the macro. So you could make a post macro that does that for you. That would be better.\nHy\n(defn abs [x]\n  (check (int? x) (something-else x))\n  (post [(>= result 0)]  ; 'result is anaphoric\n    (if (< x 0) (- x) x)))\nBut how often do you use them separately? If you're using design by contract, you test the whole signature pretty often. And they're always right next to each other. So it's simpler to put both pre and post in the macro:\nHy\n(defn abs [x]\n  (contract\n    {:pre [(int? x) (something-else x))]\n     :post [(>= result 0)]}\n    (if (< x 0) (- x) x)))\nThat...looks familiar.\nAgain, if you're using design by contract, you're doing this for every function. The result anaphor is too long. Clojure uses % instead. And that (contract ...) part is more boilerplate. So you make a new defn macro that does that for you. I still think it should be in contrib--so it's only written once.. Python also has an embeddable repl in the standard library, and not just the debugger. It's in the code module. The easiest way to start it up is with code.interact(). You can also pass in the starting locals. Hy ought to have something like it.. I'd start looking here https://github.com/hylang/hy/blob/master/hy/importer.py#L57\n@paultag, a reliable reproduction guide would be helpful. There was a recent automation of hyc #1094 #1269.\n. Is this related to #1268?. > I didn't know .pyc files were being generated\nIt should absolutely be documented. This was bigger change than we thought.\n@Kodiologist is calling this a feature, not a bug.\nI think macros are pointless without compilation. If you're interpreting only, you might as well use fexprs, right?\nBut how do Clojure and Common Lisp handle this kind of situation? We should compare those before deciding. As I recall, some CL implementations have both a compiler and interpreter, but sbcl, for example, is only a compiler.. > I wouldn't recommend having it the other way around, though, where the programmer has to opt into bytecode. That's forgoing a major speedup that you're going to want 99% of the time. \nWe made compilation automatic because Python does it that way. The speedup is considerable and compiling each file by hand seems like a pain. But there might be more nuanced options than global opt in or out. In any case, auto-compiling Hy itself (the libraries) seems like a good idea.\n\nBut how do Clojure and Common Lisp handle this kind of situation? \n\nCommon Lisp compiles forms rather than files. You can compile the contents of a file, but most implementations have no option do this at the command line. The standard way to do it is from the repl with the COMPILE-FILE form. We might want to implement similar functionality in Hy to use in our repl. This would make it easier to recompile things in emacs instead of the shell. You can explicitly recompile an individual file with hyc now. That is, instead of deleting __pycache__/, you could simply $ hyc api.hy.\nPython also has a sys.dont_write_bytecode flag. In Python, you can use this to override the behavior for individual import statements. @Kodiologist did your fix support this flag in Hy too? It probably should.\nThis way we could turn off auto-compilation on a per-import basis while developing, without turning it off for everything else, and then turn it back on for production. Perhaps a context manager or modified import macro could make this easy to do. (This kind of flag would be a dynamic variable in Common Lisp.)\nClojure usually compiles at load time. But it also has an ahead-of-time (AOT) compiler for namespaces. Certain Java interop features require a namespace to be compiled AOT. This is also usually done at the repl using the clojure.core/compile form.. Having written three of those four issues, I approve of the additional syntax. However, I didn't say anything about removing apply. But now that I think about it, if it's made redundant then it should be removed. It would certainly be easy to re-implement in terms of #* and #**, but when would we even need to?\nTo answer my own question, perhaps in macros and higher-order functions? Would we ever need the old apply in -> or doto? Is there a non-reader syntax for these special forms, like quote is for '? Sometimes it's easier if you don't need the reader syntax when writing macros, at least in the case of quote. Our current apply doesn't work as a HOF anyway, but maybe it should be shadowed. I might need to think about this some more.\nOne other issue I take with the proposed implementation is how you lex the tokens. A tag macro can be any symbol, yet the tests demonstrate (setv [a #*b c] \"ghijklmno\") would apply the unpacking operator to b. But what happens if you have a tag macro with symbol *b? Would it apply to c or just be unusable? \nI think whitespace should be required between a #* and a symbol. But it should be fine to put it directly before a list with no space #*[..., likewise, a #** would work on a dict display with no space #**{..., but not before a symbol.\n. > Beyond testing Hy itself, why would you construct a literal list or dictionary only to unpack it?\nI'm saying it should be valid syntactically, not that I had a use case in mind. But think about how this could interact with the threading macros -> and ->>. Could you thread in multiple arguments at once? Macros can do interesting things.\nIn the case of a dictionary, even in Python, you can use dictionary unpacking to put the kwarg name in a variable.\n```Python\n\n\n\ndef bar(*, a=None, b=None):\n    print(a,b)\nfoo = 'a'\nbar({foo: 1})\n1 None\nfoo = 'b'\nbar({foo: 1})\nNone 1\n```. > Not if you want to be able to call it.\n\n\n\nI said any symbol, not any string. I meant the kind of symbol you can type in directly, without going through a HySymbol call to convert a string. Those can't contain things like [ or {. See also #1117.\nWe do have a *map symbol in core. We also have the *earmuffs* convention. It's not that weird for a symbol to start with an asterisk in Lisp.. > HASHBANG\nYikes! I'd call that one that a bug in the lexer. I think we were only using that for the shebang on the first line? We should be able to use #! as a tag macro elsewhere.. It seems much more consistent to me to implement #* and #** as tag macros that happen to expand into the new special forms unpack-iterable, and unpack-mapping, respectively, without messing with the current lexer at all. (I mean, besides fixing that HASHBANG thing in a separate issue.). #* and #** could be implemented like this:\nHy\n(deftag * [form] `(unpack-iterable ~form))\n(deftag ** [form] `(unpack-mapping ~form))\nThen you don't need the special case in the compiler, and don't have to change the lexer. You still need the new special forms.\n\nSo, to be clear, you want #*b to be parsed as calling a tag macro named b instead of the same way as #* b?\n\nNo, #*b should be a tag macro named *b. So #*b c calls the *b tag macro with argument c. But #* b c calls the * tag macro with argument b.\n. > can't be enabled with tag macros alone. \nIt had better, or I don't think we can do it. This setup is causing errors in macros.\n``\n=> (defmacro star [form](unpack-iterable ~form))\n  File \"\", line 1, column 41\n(defmacro star [form] (unpack-iterable ~form))\n                                          ^----^\nHyTypeError: b\"unquote' can't be used at the top-level\"\nThat is *not* supposed to happen. Quasiquote is broken. Let's try that manually.\n=> (defmacro star [form] ('unpack-iterable form))\nimport hy\nfrom hy import HySymbol\nhy.macros.macro('star')((lambda form: HySymbol('unpack_iterable')(form)))\n at 0x000001F921BE81E0>\n=> (setv [a (star b) c] [1 2 3 4])\n  File \"\", line 1, column 10\n(setv [a (star b) c] [1 2 3 4])\n           ^------^\nHyMacroExpansionError: b'expanding `star\\': TypeError(\"\\'HySymbol\\' object is not callable\",)'\n```\nMacros are supposed to recursively expand before special forms are applied. What's going on here?. I did the manual build wrong.\nLet's try an explicit Hy model.\n=> (defmacro star [form] (HyExpression ['unpack-iterable form]))\nimport hy\nfrom hy import HySymbol\nhy.macros.macro('star')((lambda form: HyExpression([HySymbol('unpack_iterable'), form])))\n<function <lambda> at 0x000001F921BE81E0>\n=> (setv [a (star b) c] [1 2 3 4])\n[a, *b, c] = [1, 2, 3, 4]\nNone\nThat worked.\nBreaking quasiquote is not okay though. I know some macros in Common Lisp will recursively macroexpand their body before acting on it. We might need that feature to implement this properly, unless we can come up with a better idea.. Hey, this works too.\n=> (deftag star [form] (HyExpression ['unpack-iterable form]))\nimport hy\nfrom hy import HySymbol\nhy.macros.tag('star')((lambda form: HyExpression([HySymbol('unpack_iterable'), form])))\n<function <lambda> at 0x000001F921BE8510>\n=> (setv [a #star b c] [1 2 3 4])\n[a, *b, c] = [1, 2, 3, 4]\nNone\n=> [1 2 #star[3 4] 5 6]\n[1, 2, *[3, 4], 5, 6]\nAre you sure we can't implement it as a tag macro? Which part is failing?. More weirdness.\n=> {1 2 #**{3 4}}\n{1: 2, None: {3: 4, }, }\n{1: 2, 3: 4}\nWhy does the Python translation have a None key? I would have expected {1: 2, **{3: 4, }, }.. But not 2.7? @berkerpeksag are we doing something wrong with astor to get these None keys? I thought we weren't supporting 2.6 anymore?. > Python code, because the None has to be an unboxed None value instead of an identifier named None. It's pretty confusing.\nExamples work better.\n=> (ast.dump (compile \"{None:1,**{1:2},**{3:4}}\" \"<str>\" \"eval\" :flags ast.PyCF-ONLY-AST))\nast.dump(compile('{None:1,**{1:2},**{3:4}}', '<str>', 'eval', flags=ast.PyCF_ONLY_AST))\n'Expression(body=Dict(keys=[NameConstant(value=None), None, None], values=[Num(n=1), Dict(keys=[Num(n=1)], values=[Num(n=2)]), Dict(keys=[Num(n=3)], values=[Num(n=4)])]))'\nI think I get it now. The NameConstant(value=None) is for an actual None key, but a plain None means \"unpack it\". It's unambiguous, if confusing. This seems like a bug in astor.. > Not in general. The case you tried doesn't require the compiler to see the unpack_iterable in advance. \nOne of the problem cases was unpacking a mapping into a dict display. I've been playing around with this a bit. It's possible to set an arbitrary attr flag in the ast itself. This seems to work in Python 3.6.\n```Python\n    @builds(HyDict)\n    def compile_dict(self, m):\n        keyvalues, ret, _ = self._compile_collect(m)\n    temp = []\n    for kv in keyvalues:\n        if hasattr(kv, \"unpack_mapping\"):\n            temp.extend((None, kv))\n        else:\n            temp.append(kv)\n    keyvalues = temp\n\n    ret += ast.Dict(lineno=m.start_line,\n                    col_offset=m.start_column,\n                    keys=keyvalues[::2],\n                    values=keyvalues[1::2])\n    return ret\n\n@builds(\"unpack_mapping\")\n@checkargs(exact=1)\ndef compile_unpack_mapping(self, expr):\n    ret = self.compile(expr[1])\n    ret.expr.unpack_mapping = True\n    return ret\n\n```\nOlder ast versions will have to build it differently, but it seems like it should work.\nThere's no error checking--an unpack-mapping form where it doesn't belong is simply ignored.\nBut error checking should be possible too. I still think it's possible to implement the operators as tag macros.. > As an analogy, the following doesn't work\nI feel like that would work in other Lisps. Hy makes an unusual distinction between quoted and unquoted keywords, but only in function calls. So that's like calling (dict ':hello 3), but in other Lisps (and elsewhere in Hy), keywords always count as quoted. \nThis is a wart in Hy, but I don't know that we can fix it syntactically to make it always quoted, given how Python works. (Given (foo a :b c) should that keyword be the next-to-last positional argument, or a keyword argument? But with the distinction, (foo a ':b c), is unambiguously the former.)\nThe fact that that macro doesn't work bothers me, but with unpacking, I could mostly work around it. This might be something to fix in the compiler later.\n\nrejiggering the order in which child forms are compiled in several places\n\nI'm not clear on which parts aren't working. Where are the operators used in Python?\nUnpack for mappings is used in\n function definitions. Hy function definitions already use the &-word syntax. \n dict displays. I think I got that working above.\n* function calls. I think it could be done the same way?\nWas that all of them? That's one we can implement as a tag macro, at least.\nUnpack for iterables is used in\n function definitions. Hy has &rest.\n tuple and list displays.\n function calls.\n assignments. Doesn't this case already work?\nWas that all of them?\n\nIn all, it seems like a lot of work for the mere bragging rights\n\nI don't see it as mere bragging rights.\nFirst, it would keep those special cases out of the lexer, which should be kept as simple as is reasonable. A DSL could use #* and #** tags for something else. We might want to upgrade tag macros to true reader macros or Clojure-like tagged literals some time.\nSecond, and more importantly, I want them to work properly as special forms even without the tags. The new special forms are not well-behaved now. They break quasiquote, and probably break in macros in ways a user would find hard to predict. If they worked consistently, they could be (tag) macros.. > Redefining a core macro seems like a really bad idea. \nHa. Now which of us is illiberal? (1246). Yes, this could absolutely be abused and one should be careful. But see the defn redefinition in contrib. That's a core macro name, but calling it that was my idea, and I think it was a good one. #1050. I do think redefinition of those tags should be allowed, if frowned upon without a compelling need and explicit documentation.. I handn't settled because I wasn't that picky and wanted to hear other opinions, but I don't see how = could possibly work. I don't have strong feelings between [ and <, but let's go with [ like Lua.. Good point. So do opening like q[foo[ and closing like ]foo]. I'd also like to strip the first newline, if present, like Lua does.. If we did the opening like q<foo> then the closing could be just foo without the unmatched brackets, but I don't have a strong preference here either at the moment. The q[foo[ version is closer to how Lua does it.. > This is because the lexer is regex-based, and Python doesn't implement recursive regexes.\nPython does have a regex library on PyPI that can do recursive regexes like Perl. It has the same license as Python. I wonder if we can just drop that in without rewriting rply.. > Do you think it's worth it?\nProbably yes. This would make it so easy to quote code from any language with a balanced delimiter pair, which is most of them. (Even J balances parentheses! [Edit: no it doesn't.]). I was even considering gating the feature (e.g. like we do for nonlocal) so only PyPy wouldn't support it. But if we can do it everywhere, that's better.\nIs a rule subclass like that part of rply's public interface? If not, this is a harder call, since it would make updating rply more difficult if its implementation ever changes.. This is making me reconsider the choice of q[foo[ with ]foo]. If we can do balanced pair quoting, maybe it's better not to reserve [, since it would probably be a common choice for short strings. I think we should do q<foo> with foo instead. (And strip one initial newline, if present.). I just realized, this will prevent us from using any other tag macro symbols that start with q.\nThe obvious fix is to make them use the same rules as other tag macros, with whitespace when it would be ambiguous, so it would be #q X with X, and #q <foo> with foo.\nBut #q[ still works fine.. Removing the plain style is fine with me. It seems kind of redundant given the balanced style.\nThe balanced style works fine with #q[, #q(, and #q{, since this does not violate the rules for tag macros. Spaces here would still be allowed, though we could discourage that style for q-strings.\nThe remaining styles are still a problem though. Naked symbols are currently allowed to contain < and higher Unicode, including your other brackets. #1117 would help with a lot of our symbol concerns, since naked symbols could contain arbitrary strings with escapes.\nDo we need to support so many bracket types for the balanced style? Users could be confused about which characters are allowed in tags. Are the three bracket types enough? If not, would the addition of  \u00ab and \u00bb to the other brackets suffice? We could add just one more character, \u00ab, to what ends an identifier. That wouldn't be too hard to remember.\nIs requiring the separation so bad for the pointy style? It's clear what's in the delimiter from the <>, so it's also clear the separating whitespace isn't. It would usually be used for multi-line strings anyway, so the slight extra length is not a big deal.\n. > You're proposing a different PR that will prevent calling tag macros whose names begin with _ (#1354)\nI did notice that, and originally thought about implementing it differently. But Clojure also does it that way. I checked. But I'd rather not add any more exceptions on what's allowed in tags.\n(I think it would be nice if Hy's parser could read EDN. This would make it easier to use a nice exchange format with the Clojure ecosystem. With the addition of the #_ discard syntax, I think it can.)\nI've also become very worried about how any new string syntax will interact with our tooling. Hy is currently similar enough to Clojure that we can use Clojure editors on Hy with fairly good results. It's too bad Clojure doesn't have something like this already. If we add something new, it's very important that vim-hy and hy-mode (with Parinfer!) can support it. So I'd rather keep the new syntax simple. The Balanced Style would work in most cases, but for arbitrary strings, we need some kind of custom delimiters. (Can we escape a terminating bracket?) I think we need to discuss it more, and try out some of these proposals with the editors before we put it on master.\n. > Surely the editor modes exist to support the programming language rather than the reverse,\nI'm not so sure. New languages have a chicken/egg problem. A new language is not very useful without an ecosystem to support it--libraries, tooling, docs, learning material. So no-one uses it. But no-one wants to write libraries, tooling, docs, learning material for a language no-one uses. Chicken/egg.\nThe general solution to a chicken/egg problem is bootstrapping. Hy can use Python libraries. Hy can use Clojure editors. Hy is already useful enough to attract some users, who might start writing stuff in/for Hy.\nBut if you want to use Python libraries, why bother learning Hy? Just use Python. Besides borrowing an ecosystem, we also need to add something to it, or no-one will bother with us. What's our selling point? What's our killer app? Not Python's libraries. Python obviously has easy access to them them, but so does Julia--which is already more popular than Hy. Julia is expression-oriented. Julia even has macros. (And actually, so does Python).\nSo that leaves structural editing. It's the big reason why anyone would use these weird S-expression things. It's hard to implement or use structural editing in other languages because they don't have the regular syntax. Hy is attractive to those who already know another Lisp. They'll expect a good editor, but don't expect them to write it. It's on us here at Hy Society.\n\nIsn't that what the pointy style is for? \n\nYes. I forgot you wanted them all to be raw strings.\n\nWhat would you like to discuss?\n\n@kirbyfan64 was still leaning towards Lua Style instead of Pointy Style. (@kirbyfan64, is that still your preference?) This wouldn't require a space after the #q either, but would remove the #q[ possibility from the Balanced Style, which is the only reason I went with the Pointy Style. But now that whitespace is an issue with Pointy Style, I think Lua Style might be better. @tuturto what do you think about using Lua Style?\nI'm also wondering if we should strip a leading indent somehow, like how Python processes its docstrings. I'm not sure how this should work though. It might be more trouble than it's worth, but I thought I'd throw that out there for discussion.. > What exactly do we mean by the Lua style? \nBy \"Lua Style\", I meant what we had discussed previously, opening like #q[foo[ (possibly with newline) and closing like ]foo], where foo could be any string not containing []. (Commonly #q[[ or #q[=[, I expect.)\nI like the custom delimiters. Besides being shorter when you have to nest code containing its own custom delimiters, editors could also be configured to highlight contents of these strings differently, e.g. a #q[Python[ string could by highlighted like Python code and a #q[HTML[ string like HTML, etc. But Hy's parser will just call it a HyString regardless of the foo. The parser could even add that as metadata to the HyString object, which the compiler would simply ignore. But other static analysis tools, or even macros could use it, since they'd have access to the Hy model.\nAlternatively, we could get closer to Lua's style and drop the #q dispatch with a more extreme change to Hy's grammar. Use a regex like \\[=+\\[ for the start of a string. Unlike Lua, we'd still need [[ to parse as a list in a list, but otherwise they'd work exactly like Lua's long brackets. This does create a strange case where [=[]=] is a string but [= []=] is parsed as HyList([HySymbol('='), HyList(), HySymbol('=')]). We'd have to restring the foo to some number of = in this style, to avoid other strange cases like that. I  really don't like this as much, and we don't get the cool features of arbitrary delimiters in macros, editors, analysis, etc.\n\nI'd still prefer the Lua style. After working with a crapton of different languages with different ways of having multi-line not-strings, the Lua style is the only one that I really don't dread using.\n\n@kirbyfan64 can you elaborate more on why you like Lua's style, and what you don't like about the other languages? We can't have exactly Lua's style in Hy without doing weird things to our list syntax. So I want to know what it is about it that you consider important.\n\nRegarding the leading indent, I don't care too much. I'd lean against it, because it's easy for the programmer to remove but annoying to re-add if you have to, but I'd accept this either way.\nFWIW automatically removing indent would just be a textwrap.dedent call, but I'm not sure everyone would always want it, even though it's certainly the more common scenario.\ncall\n\nThis is fair. And another tag macro could make that dedent call, like #dedent #q(.... Explicit is better than implicit. It might be nice if there were a way to define a different string prefix that did this, like #Q which strips indents, but since #q would be baked into the grammer, I don't see how custom string processing would be possible in general for the end user without a second tag.\nActually, this gives me another idea. Forget the #q dispatch, and use #[ instead. We're not currently using that for anything, and neither does Clojure. So strings would open as #[foo[ (possibly with newline) and close as ]foo], where foo is any string not containing []. And have the parser put the foo in the HyString model as metadata.\n@Kodiologist would #[foo[ suffice for your command-line use case? Or do you need some kind of non-[ delimiter too?. We could still use the balanced style by special-casing #[(, #[{, and maybe #[\u00ab, if we need it. These would close as )], }], and \u00bb], respectively. This is only one character, ], longer than the current proposed Balanced Style. \nBut wouldn't the #[foo[ style good enough by itself? That would simplify things. We might not need a balanced style at all.. I guess the original Proposal B, #`/` would be even more concise than the #q Balanced Style. I'm warming up to B, but I don't think #[[...]] is that bad, since you'd only need it in the rare cases when \" isn't good enough. I'm still not okay with requiring Unicode as in the even shorter Proposal A.\nBut I'd also like to hear what @kirbyfan64 and @tuturto think about the discussion so far.. > It's not required; we'll have the Lua style too. :)\nThat's actually a really good point. Given the #[foo[ raw style, I think I'd be okay with a \u00ab and \u00bb balanced style that worked just like \"/\" otherwise. So \u00ab and \u00bb are allowed inside if balanced, escapes (including \\\u00bb) would work inside unless you use r\u00ab.\nWe could even support the other prefixes--b\u00ab and f\u00ab in the balanced style.. In the case of B, I'd actually put the prefix between the hash and the opening backtick. This would be simpler and more consistent in Hy's grammar.. @kirbyfan64 \nWhat @Kodiologist said.\n\nno clue what the hell \"pointy style\" is\n\nLike #q <END> string END. But @Kodiologist didn't like the space, so he proposed #q<END>, which interferes with tag macros.\n\nwhat this has to do with list syntax\n\nThat's only if we don't have the #q as the dispatch and use [= instead, which looks like a list and a symbol. So I proposed using #[ instead.\n\n\nHow about we start from the top\n\nSo my current best proposal is both\n\n#[ dispatch\n\n#[foo[  string ]foo] where foo is any string that does not contain []. This means both #[[...]] and #[=[...]=] are valid. Like Lua, escapes don't work, since these are raw strings, and it will also strip one newline from the start, if present.\n```\n[[\nspam\neggs]]\n``\nis just like\"spam\\neggs\"`.\nBut unlike Lua, you have to start with #, or it's a list. And also unlike Lua, you're allowed to use a delimiter besides some number of =. This could be parsed into the Hy model as metadata for use with macros. It could also be a hint to editors to use some other highlighting mode when quoting some other language, e.g. #[Python[...]Python] would be highlighted like Python. But most of the time you'd use #[[ or some number of = when nesting like #[===[, if you don't have a better idea for the delimiter. And we could say so in the Style Guide.\nAnd\n\nThe \u00ab and \u00bb balanced style\n\nThis is like Proposal A from #1287. It works just like the normal double-quote style, but since it's paired, you can have \u00ab and \u00bb inside of it as long as it's balanced (or escaped). (And \", of course). It would have the normal string prefixes, like r\u00ab for a raw string.\nIt's really too bad double quotes aren't paired as a historical artifact from typewriters, or we'd already be doing this in Python. But given the #[foo[ style and normal double quotes, Unicode is still not required for developing Hy, so I don't mind adding this as an option.. We seem to agree on the Lua strings, at least.\n\n(1) it complicates the lexer,\n\nNot too much though. And it could get better in the future. I wonder what the chances are of that regex library replacing Python's standard-library re someday. We might also consider a pull request for rply to make the lexer handle this kind of thing better.\n\n(2) it will complicate syntax coloring (which will no longer be possible with non-recursive regexes alone),\n\nA very important concern. We do not want to make tooling for Hy difficult to implement. Yes, we'd need the equivalent power of a pushdown automaton. But PDAs are old technology. This is a solved problem. Both Vimscript and Elisp are Turing Complete. They can handle it even if their regexes can't.\nPython has been called \"executable pseudocode\". We could publish the Python algorithm to match these strings in our docs under a public domain license for future tool writers to copy in whatever language they prefer. We could publish the equivalent PCRE recursive \"regex\" too.\nBoth Perl and Ruby have balanced-style strings with the same issue. How much of a problem is it for them, really? How does their tooling handle it? Any general-purpose editor or syntax highlighting library that can handle those properly could also handle Hy with an appropriate script. If you're using an editor that can't, you could escape them anyway. (And consider getting a better editor.)\n\n(3) you're much less likely to need nested guillemets\n\nTrue, but I think paired string delimiters imply this feature. Not having it would be weird. There might be use for it in i18n. It does seem like a lot of problems for a feature we'd rarely use. I'd also be okay with only the Lua strings though.\nGuillements are an interesting choice. If we're using Unicode anyway we could have used the English-style 66/99 quotes with \u201c U+201C and \u201d U+201D. But they might be harder to distinguish than the guillements in some fonts. And guillements are probably easier to type on most systems. Unfortunately, some languages (like German) like to use them backwards, \u00bblike this\u00ab. The other way is more common, but we could support both, by allowing guillement strings to start with \u00bb too. In that case, the nested guillements would also need to be backwards, or escaped.\nI'd like to think about this some more.. I think I've got a good alternative. Implementing #1117 would allow us to create HySymbols from arbitrary strings using | <string> |. This is a single delimiter like \" is, so we could avoid the need for balancing logic. We could use a tag macro to convert it back to a string at compile time. So, something like #q |foo bar|, or even #q|foo bar| could work, depending on how we set up the lexing for |-quoted symbols. This is still one character shorter than #[[foo bar]], and comparable to the Plain Style. Also, a HySymbol is-a Python string, and will work as one in most contexts, so you often wouldn't even need the tag macro. Just use '|foo bar|, which is even shorter. We could also use a different tag macro to convert it differently, like #b for a bytestring or #f for a format string, etc.. (foo | x |) would clearly be tokenized as HyExpression([ HySymbol('foo'), HySymbol(' x ')]) under #1117.\nThis does mean we can no longer write | as our bitwise or. We could certainly spell it out as bit-or (or bor or or-) instead though. We did that with = to setv. (We'd also want to spell out &, ^, and ~ for consistency, which would also free up those characters for other uses.) \\| could also work, but I don't think it's as pretty.. > I'd rather not rename a bunch of operators when we could just use other syntax.\nWe'd have to do that for #1117 anyway, which is important for a lot of other issues. I'd rather not have three kinds of string literals when two will do. A change in grammar is a much bigger deal than renaming some core operators. And it's confusing that bitwise-not is the same symbol as unquote, so I want to change that one anyway. For example,\n`(~(foo))\nDoes the above immediately call foo and unquote its result, or put (foo) in the expansion and bitwise-negate it? Obvoiusly the repl can tell you. But `(-(foo)) would negate it. That's inconsistent.\nFreeing up & from bitwise-and would allow us to use it in function calls. So we could use the shorter Clojure style (foo [& args]...) instead of (foo [&rest args]).\nAnd if we free up | from bitwise-or, we can have both arbitrary-string symbols and a concise non-double-quote string syntax with only one grammar change instead of two. This would make the guillemet style redundant.\n[Edit: and ^. That's only four. This would give us the Clojure metadata syntax, which we could use to implement Python's annotations. #640 #656, among others uses. And maybe even Cython #934]\nWe can leave the other bitwise operators alone.. So for this PR, it's fine if it's just the #[foo[ Lua style. While a little more verbose that we might like in some cases, that's good enough until we implement #1117 with a #q tag macro to convert the symbol name to a string in another PR. But if you want to do #1117 here too, that's fine.. > FWIW is there a reason we can't just use PLY?\n\nrewriting the lexer and parser is out of the scope of this PR.\n\n@kirbyfan64 PLY has a compatible BSD license, so I don't know of a reason. In what way is it better though? Can it do this kind of nested parsing we've discussed for the balanced styles any better without adding a new regex engine dependency? If so, and if we settle on a balanced style, it might be worth it. But @Kodiologist pointed out that any balanced style would complicate our tooling.. > The grammar has to change in any case in order to implement a new form of symbol quoting or string literal or whatever.\nBut it would be a less complex grammar with only the two string literals and the arbitrary symbol syntax, than with three string literal types and the arbitrary symbol syntax.\n\nWouldn't it be better to quote with some syntax that doesn't require changing an operator from the Python name, like \\ \u2026 \\ or #( \u2026 ) or #\u2026 or \u00ab \u2026 \u00bb?\n\nI actually think the | and \\ syntax is better for symbols. Freeing up those four names from the operators would help with other issues. But if the others also feel very strongly that we must not rename our bitwise-or, then || symbols are not an option. And we'd have to come up with some other syntax for #1117. It's not like Hy has infix notation. Bitwise operators aren't even used that much in Python. But if you are prone to bit-bashing, you'd have to use parentheses and indentation to make the expression readable. So I don't think slightly longer names are a big deal.\nI'd rather keep \\ as an escape character for symbols even if we don't use the | quoting, like in Emacs Lisp. So \\...\\ is out.\n#(...) means xi in Clojure. Using it for balanced strings might confuse the Clojure users, but I think it's actually not an unreasonable choice. It's only one character longer than \"\", without introducing Unicode syntax. It also has a nice parallel with #[[]]. If we wanted a prefix version of xi for the Clojure people, something like #%(f %1 %2 ... %&) would work about as well instead. We also considered it for genexprs #867, which isn't xi either. They could use a slightly longer tag, but it wasn't clear what when we only had one character sharp macros. Maybe #for would work. Balanced strings do have the aforementioned problem with tooling, but if we are doing paired delimiters, I want them balanced. I'm not sure if I like this better than the guillements or not (or both?), but I'm leaning towards #(...). It's fine to allow the users to use Unicode, but I'd rather not add any to Hy itself.\nWe've already discussed A and B, but one of them is paired and the other isn't.\n\nAnd seeing as people are going to use funny characters in strings more often than in symbols, shouldn't we have the default for the syntax be a string rather than a symbol?\n\nNo, because we want to be able to use funny characters in tag macros. We've already got the super-short \"\" notation for strings with an overhead of just two characters. We'd almost always just use that. And we'll be adding #[[]] too for crazy raw strings, which are probably not short.\nIt feels like we're quibbling over saving one character. Compare the overhead of Lua #[[...]] (5) to the overhead of Plain #qX...X (4), which you thought was good enough before (if barely?). Note that tagged symbol #q|...| is also 4.\nWe could perhaps have r|foo bar| be the same as r\"foo bar\". But that would be ambiguous with #tag-r|foo bar|. Is that the tag tag-r applied to symbol |foo bar| or is that tag tag- applied to string r\"foo bar\". If we always assumed a separation before the| then it's unambiguous. And we could do the #q|foo bar| tagged symbol strings.\nI'm still not getting the use case where neither \"\" nor #[[]] is good enough, and neither was @kirbyfan64. Unicode is hard to type on most systems, so it's not like we're saving keystrokes. And an Emacs binding could insert #[[ just as easily as \u00ab. Guillemonts sure are prettier, but you can also have Emacs abbreviate things with Unicode for your reading pleasure, like \u03bb for fn or x\u1d62 for xi. Why not \u00ab for #[[ and \u00bb for ]]? Can we do that last one to the Lua-Style strings without also doing it to nested lists? If not, something like #[;[ ];] should be unambiguous. This way you can read Unicode, but still be compatible with ASCII tools and files.\nSo, compared to Lua Style, it's not easier to read (on Emacs). It's not easier to write (unless you have a foreign keyboard, and even they require AltGr). It's not easier to implement tooling for. Many terminals can't print Unicode, so it's not very good for the command line either, and Unicode is still hard to type. I could maybe see #(...) being better here, but barely. It's only two characters shorter.. > Yeah, we've been bikeshedding mercilessly about this since the beginning.\nI didn't see the discussion as trivial. The grammar is something we should try to keep simple and understandable. Changes here should be carefully thought out in the context of the whole language instead of blindly accepting the first thing that seems like a good idea. I felt like the options have been improving because of the discussion. I saw good points that I hadn't thought of on my own.\n\nWould you accept a PR that adds the Lua style (without nesting of the customized delimiter) and doesn't do anything else?\n\nA single change could probably get approved faster than two.\nWhich version exactly are you proposing? I'd accept the version like #[foo[ (remove one newline, if present) string body ]foo], where foo is any string not containing [ nor ], including the empty string, and the foo is available as metadata in the HyString model for use with macros, etc.\nThis is not a balanced style, so a pure FSM regex engine could highlight it, e.g. #[foo[ #[foo[ bar ]foo] baz ]foo] would end at the first matching, ]foo], and be equivalent to the string \" #foo[ bar \". The remaining baz ]foo] wouldn't get highlighted and might be a syntax error depending on context. No need for a PDA. If you want to nest these, you have to pick a different foo, usually just by adding another =.. I realized I put this up before I implemented :or for mapping defaults. I'm not quite sure how to implement that. What should it expand to?\n1326 was pretty underspecified. We're not following Clojure's version exactly, just trying to give Hy similar capabilities. But I have noticed some differences with Clojure's version.\nClojure uses :keys :syms and :strs (always with a vector of symbols) instead of the :from list with the exact key type. And this :from probably works on anything name does, not just strings, symbols, and keywords, though this isn't in the tests. I'm not sure which it better, but maybe I haven't thought of something.\nClojure only allows one :as in vector bindings (it seems to stop looking after that). This PR allows more than one, and it seems to work sensibly, but this isn't in the tests.\nUnlike Python's unpacking assignments, the iterable destructure will ignore any remaining arguments if you don't provide enough binding names. If you try this directly in a Python assignment (e.g. a, b = [1, 2, 3] that would be an error: ValueError: too many values to unpack. But Clojure also ignores the remainder like this.\nIf you try an associative destructuring on a non-mapping iterable, Clojure will build a map from it, with every other value as a key (like HyDict). This is important for how Clojure functions parse kwargs. The PR doesn't implement that, but I don't think it would be too hard to add. Python already has kwargs for functions and Hy uses it, so I'm not sure if there's a need. But this capability might be useful for some other reason I haven't thought of.. > What is the macro dest for?\nI thought it had to be a macro to work, so I tried implementing it that way first. But when I added =: to wrap setv it turned out to be easier to implement as a function. I originally thought Clojure's destructure was a macro, but no, it's an ordinary function. I don't see the need for dest anymore, so I'll remove it.\n\nYou can't destructure an iterable that can't be subscripted (e.g. (=: [a b c] (genexpr i [i (range 3)])) doesn't work). Is this a bug or a necessary limitation?\n\nUnderspecificaiton again. Python's iterables are not as nice to work with as Clojure's seqs. #1242. But there are ways to do this. If they were seqs we could simply use nth instead of get. But if you use an iterator for the expr, then nth will mutate it.\nIf we anticipate this and assign (iter expr) to the gensym, we can just use first, but then it gets exhausted before :as gets to it. If we went that way, we couldn't support :as.\nThe usual Python workaround for this kind of thing is to realize the whole iterator into a list. (This could also be done at the gensym assignment step.) And indeed, this is how Python's unpacking assignments work. But that's bad for infinite iterators. You might want to bind the whole thing with :as, and only take a few elements off the front. Maybe we could use tee to split the iterator.. > It's confusing that keys for dest-dict come after the variable, particularly since the magical destructuring keywords (:as, :from, and :&) come before the variable. That is, {a :a  b :b  :as all} should instead be {:a a  :b b  :as all}. If you want to make sure that :as, :from, and :& can still be used as regular keywords, try denoting the magic words with & instead of :, so :as would be &as, :from would be &from, and :& would be &rest or something.\nYou get used to it. This is the order Clojure uses, and I think it's better than the reverse. \nThis has probably been debated elsewhere, but off the top of my head, I remember ES6 did it the other way and I wished it worked like Clojure. The assigned names are always on the left in Python. So they should be on the left in the destructure too. Nesting seems to work better this way. The magic keywords are unambiguous in this position, as you pointed out.. > Exception should probably be TypeError.\nI meant to change that to something else, but wasn't sure what. Exception is too vague. I also considered SyntaxError.\n\n(setv ddict (gensym)) does basically the same thing.\n\nNot quite, it would have to be (setv ddict (gensym 'ddict)) to get the more meaningful symbol for debugging. I thought of doing it that way, but it duplicated ddict.\n\n(with-gensyms [x]) x works, but I don't think it's supposed to; that is, x is supposed to be out of scope outside the with-gensyms. with-gensyms is a holdover from when we had let and expected to make it work someday. \n\nI originally tried defmacro/g!, but switched to with-gensyms when I made it a function. If that's how with-gensyms should work we should probably remove or redesign it. It's a separate issue though.\nMaybe remove with-gensyms and replace with something like (gensyms foo bar baz) that expands to (setv foo (gensym 'foo)  bar (gensym 'bar)  baz (gensym 'baz)),\n\nfor* can be for. (There's no reason to use for* outside Hy core.)\n\nSee #1125.. I swapped the yoda condition and changed all to full.. > Neither of (=: {:from [\"hello?\"]} {\"hello?\" 5}) nor (=: {:from [\"is_hello\"]} {\"is_hello\" 5}) binds to hello?. It's not obvious which should work, but it seems clear that at least one should work.\nIt does work:\n=> (=: {:from [\"hello?\"]} {\"hello?\" 5})\nfrom hy import HyString\n:ddict_1256 = {'hello?': 5, }\nhello? = :ddict_1256[HyString('hello?')]\nNone\n=> (get (vars) \"hello?\")\nvars()['hello?']\n5\nAnd you wouldn't have to use the get/vars syntax with #1117. This seems like a manifestations of our complaints in #1168 and #1173. The :from option is working as designed.. * =: can take multiple pairs.\n Removed dest.\n Changed Exception to SyntaxError.\n Removed with-gensyms.\n Remove quasiquotes where it made sense. But that's not all of them.\n Used for instead.. * added :or defaults, with tests.\n :& now uses a cut instead of islice, since destructure uses get anyway.. Added error checking to prohibit duplicate keywords..  So a mangle might have to wait on #1336. I might be able to make it work then.\nBoth keywords and symbols work properly in :from now. It's just strings that cause issues. This is easy to work around by writing both the symbol and the string to look up without using :from in problematic cases.\nClojure uses :syms/:keys/:strs instead of :from. I'm not sure if it's better. But if we had :strs, then we could start with a vector of symbols, and convert them to strings instead of the other way around. It might be easier to type this way, since you don't have to repeat \" around every token. I've streamlined the code enough that it shouldn't be too hard to implement.\nOptions:\n1. Live with it for now, and maybe fix it later depending on #1336 #1173 etc. Warn about the problem in the docs, and explain the workaround.\n2. Add :strs that works like Clojure, and maybe prohibit strings in :from\n3. Get rid of :from altogether, and just do it like Clojure for all three types.\nI'm leaning toward option 1.\nThe other big issue remaining is how to destructure consumable iterables, be they plain iterators or some other kind of Python generator. This would be straightforward to handle with something like Clojure's immutable seq. #1242. There are three big problems with these iterables Python. First, they're mutable, so just looking at them consumes them. And second, they may be infinite, so realizing the whole thing and saving it into a list may not work either (but this is what Python's multiple assignment does).  The third problem is that they may be nested. If they weren't, you could easily work around this by realizing it into a list, with a take call too if it's infinite, on the right side.\nOptions:\n1. Live with the restriction for now, and maybe fix it later depending on #1242. Nested mutable infinite generators are a bad idea anyway. It's not like JSON has these.\n2. Add a :pre magic (to both dest-list and dest-dict) that takes a custom function to preprocess the input before attempting to destructure it. For example, :pre list, :pre tuple or even :pre (comp tuple (partial take 5)). These could be placed at any nesting depth. You could convert to some other structure, like from Pyrisistent. Or do other processing like :pre (comp list partition), or some complex dict-comp or list-comp in a lambda. Thus it seems like general preprocessors like this would be very powerful and it wouldn't even be that hard to implement. But it could be annoying to retype them for a nested structure, though functions could be assigned an alias in advance instead of in-line. It might also be annoying to have to count symbols for take's number though.\n3. Add some kind of :tee foo magic just to dest-list. Maybe it calls (setv (, t0 t1) (tee (iter the-iterable))) on the iterable, and then (tuple (take x (iter t0))) on one of them before destructuring the tuple, where x is the number it would need to unpack. Then foo will have t1. Given :& bar, bar will have the partly consumed t0. Tees seem like a poor substitute for seqs. They're still mutable, and consuming the iterator they're based on makes them skip too. I don't like them for this reason. :as is a gotcha waiting to happen. Implementing this also seems kind of involved.\n4. Add logic to the expansion in dest-list to autodetect when plain get isn't going to work. (Maybe just a getattr check to see if the operator is supported). In that case, just call list on it before assigning it to the gensym. This is fairly similar to how Python does things. But this diverges if the iterable is infinite. And the added check happens after the expansion at runtime, so it's a bit slower even when it doesn't need to construct a list.\nI'm leaning toward option 2.. I didn't expect that to work. I looked into it, and I noticed an \"assert True\" when I did a hy2py on the tests. This was due to a misplaced bracket, since one-arg equality is always true #1332. I amended the test to make it work, and now your new commit breaks it. This never should have passed.\nPython\n=>  (=: [a b :& the-rest :as full] \"abcdefg\")\n:orig_1259 = 'abcdefg'\n:dlist_1260 = list(:orig_1259)\na = :dlist_1260[0]\nb = :dlist_1260[1]\nthe_rest = :dlist_1260[2:]\nfull = :orig_1259\nNone\n=> (= (, a b the-rest) (, \"a\" \"b\" \"cdefg\"))\n((a, b, the_rest) == ('a', 'b', 'cdefg'))\nFalse\n=> the-rest\nthe_rest\n['c', 'd', 'e', 'f', 'g']\nThe nice thing about cut is that it returns the same type. I'd like to keep that feature, but here it got listified. To be fair, Python works similarly:\n```\n\n\n\na, *b = \"abcdefg\"\nb\n['b', 'c', 'd', 'e', 'f', 'g']\nAnd actually so does Clojure, which converts it to a seq:Clojure\nuser=> (let [[a & b] \"abcdefg\"] (println b))\n(b c d e f g)\nnil\n```\n\n\n\nAlso, :& should be able to work on an infinite generator. This approach still doesn't allow it.. I removed the last commit. But I pushed a destructure-iterables branch that still has it, if someone wants to continue from there.. Option 5:\nAdd another destructure type, dest-iter. This supports :& but not :as. Write it with () instead of []. This is similar to the difference between a genexpr and a list-comp in Python, so it's easy to remember. It will work fine on any iterable, but [] requires random access, as now.. I've removed :from and replaced it with Clojure's approach. I also added a test for generated lookup keys like (frozenset [0 1]), since it wasn't evaluating these properly before. That should take care of the mangling issue..  I added a dict=: macro for destructuring directly into a dict. (Using symbol keys, to avoid mangling issues.) This returns a value, unlike the setv-backed =:, which always returns None.\nI also added a vals@ function which looks up multiple things at once.. Yes, but I'd like to wait for #1338 so I can rebase. (And also #1349, but that one's done.) Those will simplify some things in here.. Major refactoring. I was able to pull a lot of the shared code from all three dest- functions out into a decorator. It also inspired #1393. I wanted to make those dispatch ifs less verbose with a macro, but thought we might already have something like that in anaphoric. I didn't see one, but Clojure had it, so I implemented one based on that. We might want to move it to core.. Anything at the toplevel without the underscore prefix is supposed to public. I'm not sure how you'd use the dest- functions instead of the primary dispatcher, destructure, though. They have to recuse to it anyway. Maybe if they took the dispatcher as an argument, users could add more binding form types.\nMy motivation for this design is that Clojure has destructuring built in to most of its binding forms, and a function to help implement this for custom macros. I'm not sure how best to do this in Hy. The destructure function could be useful in other macros. But Hy's functions only have sequential unpacking for arguments built in, like Python2 did. Python's unpacking assignments also work.\nThe =: macro should work anywhere a setv does. dict=: is more contained, so you can use it without clobbering locals. It's also useful for the (.update (vals foo) (dict=: ...)) trick, which lets you unpack things into namespaces other than the local one.\nThe vals@ function will convert any dict to a list so Python's unpacking assignments can work on it (and Hy's argument unpacking too.) It was inspired by Ruby's .values_at Hash method, which is used to \"unpack\" a Ruby Hash.\nYou could combine vals@ with dict=: to destructure into a list (and one of the tests does this), but this seems verbose, since you're using the symbols twice. I'm not sure how a more direct list=: could work, or if we should try.\n\nIt doesn't seem that you're buying much by implementing ifp for internal use\n\nIf that were all we ever used it for, yeah, but it's also public, and useful in general, since reusing a predicate is a very common pattern in a branching form. I had originally implemented a simpler private macro to do this, but it seemed redundant when we could have the more general one from Clojure.\nBut I don't think it belongs here, which is why I suggested moving it to core (in a separate PR #1393). We could put it in a separate contrib file instead, if a core addition is too controversial for the moment. But until that happens, I have to have a local implementation to test any code that uses it.. @spiderbit \nProtip: try running the repl with the --spy option. You'll get an approximate Python translation.\nPython\n=> (defn test (words)\n... (.format \"{0} {0}\" words))\ndef test(words):\n    return '{0} {0}'.format(words)\nNone\n=> (test (, \"hello\" \"world\"))\ntest(('hello', 'world'))\n\"('hello', 'world') ('hello', 'world')\". I think #1329 will fix this. Try pulling from that branch and see if you can install.. It's deftag now on master.. Unlike the old reader/sharp macros, tag macros can be more than one character long. Any symbol, really, but sometimes you have to use a space where you didn't before.. Clojure:\nClojure\nuser=> (= 1)\ntrue\nCommon Lisp\n```\n* (= 1)\nT\n``\nThis is by design.=can take multiple arguments in Lisp. Say you have a list of things you want to make sure don't differ from a known value. You can simply unpack the list, and it works even if it happens to be empty.(= known-value #* list). That's one more special case you don't have to check for, which is even more important when writing macros. Most Lisp \"operators\" are like this, not just=`.\nIf you need a version restricted to two arguments for some reason, write your own function.. In fact, it's unusual that Hy's != requires two arguments. The problem is, it's not clear what the one-argument case should be.\nCommon Lisp\n```Lisp\n* (/= 1)\nT\nBut in Clojure:Clojure\nuser=> (not= 1)\nfalse\nThat's because Clojure's version literally meansLisp\n* (not (= 1))\nNIL\n```. Wasn't there an Admin opt-out? Do we even want to?. I'm not particularly offended by the ads in this case. Moving things creates dead links on other pages we can't control. It's not something we should do lightly or often, but sooner is probably better than later. (Maybe we could make a redirect doc saying \"this doc has moved\".)\nThe community ads are for other open source projects, aren't they? We could also request an ad for Hy.\nWhere would you move to?. I think that's enough for a veto for this particular change. We can discuss other options though.. Many GitHub projects do use GitHub Pages for their docs. That seems like a reasonable option. Last I checked, they only do static pages to save on hosting costs, but that doesn't prevent client-side-only JavaScript from working, so some kind of search function would probably be possible.. By the way, Hy's cons already considers None to be the empty expression, so there's precedent for this kind of special casing. Compare:\n=> (cons 1 None)\nfrom hy.core.language import cons\ncons(1, None)\n(1)\n=> (type (cons 1 None))\nfrom hy.core.language import cons\ntype(cons(1, None))\n<class 'hy.models.HyExpression'>\n=> (cons 1 '())\nfrom hy.core.language import cons\nfrom hy import HyExpression\ncons(1, HyExpression([]))\n(1)\n=> (type (cons 1 '()))\nfrom hy.core.language import cons\nfrom hy import HyExpression\ntype(cons(1, HyExpression([])))\n<class 'hy.models.HyExpression'>. Does anyone here speak L33T?. I'd really like to get #1320 fixed. @kirbyfan64, after @Kodiologist's answer are you okay with that Asty thing in this PR or not?\nI'd certainly consider pure refactoring PRs that do nothing but simplify things like compiler. Technical debt is a thing. If you think the design change merits separate discussion, we could postpone Asty and use the old style here instead.. > Wait, why not compromise?? For minor style issues, the person who notices, when they can, just pushes a fix themselves?\n\nBut I don't see myself often reverting a change to indentation\n\nI can work with that.\nI shouldn't have to, but I can. This could slow down my approvals some, compared to the case where the code is legible in the first place. I have to fix it just so I can read it. I shouldn't have to count brackets just to tell which element belongs with which list. In well-formatted Lisp this would be clear from the indentation. I don't consider bad indentation \"minor\" in Lisp.\n\nStyle-fix commits should generally be melded into other commits before the merge.\n\nTo be clear, I should add and push a new commit after all the others, with the style fixes, rather than a force-push with an amended commit? Then someone else will meld it before the merge? (For one so strict about commit structure, it's surprising you're so lax about formatting.) Also, if the formatting gets removed without comment, I'll assume it's accidental and try again.\n\nAt least for now until we can actually reach some kind of consensus\n\nI'd like to clarify the Style Guide and add an automated check to avoid indentation errors. And I'd like to settle the semicolon style in the Style Guide too. I expect most of the less-active, old-guard, Hy-Society members that actually use other Lisps much would agree with me about the indentation thing. \"Consensus\", in my mind, would have to include some of them. \nI'm very concerned that future Hy contributors that are used to properly formatted Lisp would be deterred from participating by our sloppy code if we don't enforce indents. I certainly felt deterred from participating by this dispute, to the point of contemplating a hostile fork.. How does Toolz compare with funcy?. Hy's core has about 200 symbols. \nClojure's core has like 600 symbols. (Although many of these are not really applicable to Python.) Toolz has a tenth of that. Adding Toolz won't just get it over with. But it has some things Hy doesn't currently. Funcy has more (177) but only some of it overlaps.\nThe two libraries seem about equally popular on github with ~1.5K stars. I don't know if there's some other Python library that does this better. Adding Toolz would certainly be easier, just because there are fewer functions we'd have to evaluate for inclusion.. > toolz.get has reversed arguments order compared to hy.get, I currently use both gets depending on the form. \nToolz ordering actually makes more sense when currying. One would be more likely to want a partial get function with a fixed index than with a fixed collection. By Hy's get is a special form used for the getitem/setitem/delitem operators, and it uses the same ordering as Python and Lisp. \n683 is related. We can't just shadow get because it's actually three operators, not one. I'd like to have both versions, but Toolz's get is not good enough to replace Hy's, since it's only the getitem version.. > Toolz ordering actually makes more sense when currying\nBut it's more Clojure-like to put the collection first because of -> and doto. Currying in Python is less efficient than macros are in Hy due to the overhead of the extra function calls. Therefore, we should prefer Clojure's ordering. This might make it difficult to use Toolz, since they're all backwards.. After looking at these, I don't think adding a dependency is the right way to go. Too many of the functions make more sense in Python than Hy. We'd have to add them to core on a case-by case basis anyway. It's not like it will save much time, so we might as well implement them individually like we've been doing. They're still worth looking at for ideas though.. > You're not supposed to touch another module's name that begins with _.\nUsually. Some modules have their own conventions.\n\n_42 is a really bad name for a variable.\n\nI think it's better than forty_two.\nThis kind of thing can come up in Python metaprogramming. The most direct translation of an integer to a valid identifier is to simply add a leading underscore, and I think that's how it's usually done.\n\nx._42 still works (just like x.42).\n\nIt seems weird that x._42 works, but (. x _42) can't.\nThere's no good reason not to fix this.. This also happens to setv\nPython\n=> [(setv foo 1) foo (setv foo 2) foo]\nfoo = 1\nfoo = 2\n[None, foo, None, foo]\n[None, 2, None, 2]\nThe expected answer was [None, 1, None, 2].. > This is unquestionably counterintuitive\nPython guarantees the sequential order of evaluation in displays and function calls. Programs may rely on this for correct behavior. If Hy is allowed to reorder things this must, at least, be documented. But how do we even document this?\nI notice these things quickly because I almost always have the --spy option on in the repl, and I understand Python well. But other users would be very confused.\nNow that we don't have let, I was thinking about how to clean up gensysms using del. But what if the answer you want the expression to return is in a gensym? I thought maybe if we had PROG1 from Common Lisp, it could be done as (PROG1 ~g!result (del ~g!result)). (A PROG1 returns the result of the first expression, and executes the rest for side-effects.) But we don't have PROG1, just Clojure's do, which is a PROGN, which returns the last result. Clojure doesn't have this either, but there are various approaches to emulate it. One of the simplest is PROG1 with (do (first [...])). So I tried that in Hy and ran into this ordering problem.\n\nwhat else would you [...] compile to?\n\nI don't have to know the answer to that to report it as a problem.\nBut perhaps we should pull everything out of a display expression or function call if we pull one thing out. Examples:\nHy\n[(setv foo 1) foo (setv foo 2) foo]\nPython\nfoo = 1\n_hy_anon_var_1 = None\n_hy_anon_var_2 = foo\nfoo = 2\n_hy_anon_var_3 = None\n_hy_anon_var_4 = foo\n[_hy_anon_var_1, _hy_anon_var_2, _hy_anon_var_3, _hy_anon_var_4]\nHy\n[foo (del foo)]\nPython\n_hy_anon_var_1 = foo\ndel foo\n_hy_anon_var_2 = None\n[_hy_anon_var_1, _hy_anon_var_2]\nHy\n(f (g) (with [(E)] (h)))\nPython\n_hy_anon_var_1 = g()\nwith E():\n    _hy_anon_var_2 = h()\nf(_hy_anon_var_1, _hy_anon_var_2). > It's not obvious to me that this strategy will work in general.\nI think it would always work in the case of display expressions and function calls, since things should be evaluated once each in sequence. We can fix that at least.\nWhen things should be evaluated some other number of times (like zero in the if branch not taken, or more than once in a loop) then we might have to do something else. I have a solution for what a genexpr should expand to #588, at least in Python3.\nAre there other loop or branch cases that have this problem? Or do you have a counterexample for displays or function calls?. Thinking about this some more, I think it would suffice if we pulled out everything before the statement, instead of just everything. Any expressions afterwards should work fine directly in the display or call, so\n[(setv foo 1) foo (setv foo 2) foo]\ncould compile to\nfoo = 1\n_hy_anon_var_1 = None\n_hy_anon_var_2 = foo\nfoo = 2\n_hy_anon_var_3 = None\n[_hy_anon_var_1, _hy_anon_var_2, _hy_anon_var_3, foo]\nIt would save assignments, but I'm not sure if it would be harder to implement.. We'd definitely want to put nested cases in the tests, to make sure things still happen in strict left-to-right order. But it could totally work.\nHy\n[0 (setv x 1) x [1 (setv x 2) x 3 4] x]\nPython\n_hy_anon_var_1 = 0\nx = 1\n_hy_anon_var_2 = None\n_hy_anon_var_3 = x\n_hy_anon_var_5 = 1\nx = 2\n_hy_anon_var_6 = None\n_hy_anon_var_4 = [_hy_anon_var_5 _hy_anon_var_6 x 3 4]\n[_hy_anon_var_1 _hy_anon_var_2 _hy_anon_var_3 _hy_anon_var_4 x]\n[0, None, 1, [1, None, 2, 3, 4], 2]. @kirbyfan64 this seems similar to what we did for and/or short-circuiting when they contained statements. #824 You were able to detect when the form had a statement and compile the whole thing differently (as if/else statements). Couldn't something similar be done here?. Thinking about this some more, the compiler should be able to detect if an element is a simple constant literal (like a quoted symbol or an int). With the possible exception of f-strings (which aren't really constant), literals are not going to change due to side effects. So my last example [0 (setv x 1) x [1 (setv x 2) x 3 4] x] could compile to the simplified:\nPython\nx = 1\n_hy_anon_var_1 = None\n_hy_anon_var_2 = x\nx = 2\n_hy_anon_var_4 = None\n_hy_anon_var_3 = [1 _hy_anon_var_4 x 3 4]\n[0 _hy_anon_var_1 _hy_anon_var_2 _hy_anon_var_3 x]\nFurthermore, certain special forms are known to the compiler to always return None. I don't think we're allowed to override these with custom functions. If these were known never to change, it could be further simplified by detecting the special form at compile time and throwing out the expression context in those cases while inserting a None in its place:\nx = 1\n_hy_anon_var_1 = x\nx = 2\n_hy_anon_var_2 = [1 None x 3 4]\n[0 None _hy_anon_var_1 _hy_anon_var_2 x]\nBut these are just optimizations. Pulling out everything when there's a statement will work correctly.. It's still not the obvious implementation. Couldn't the proposed\nHy\n(defn get [thing &rest keys]\n  (for [k keys]\n    (setv thing (get thing k)))\n  thing)\nbe simplified to\n(defn get [thing &rest keys]\n  (get thing #* keys))\n?\nI think it would still use the special form rather than recurse in that context. Did we test if #* works properly in special forms?. That if indentation style resembles Python, but it breaks a very strong Lisp indentation convention. We should clarify that if should not be written that way in the style guide. Editing tools like Parinfer would try to move the parentheses to match the indent, and aggressive-indent-mode would flatten it instead, to make the indent match the parentheses. You could maybe get away with partially de-indenting the else clause, since nothing follows it hylang/hy-mode#29, but that can't work for the elif clauses.\nWhen my ifs have an elif clause, I put the test and result on the same line if it fits. If not, I've used an extra line break to separate the pairs. The other option would be to use a do block, even for one form, just to get the indent.. Sure it is. I don't want to merge anything that's not properly formatted.. Don't be unreasonable, @Kodiologist. This like asking you to remove trailing whitespace. It's already our policy even if it's implicit. I'm not going to merge it like this just to fix it later.. > Can you quote the relevant passage?\nYes I can, but if you didn't get it the first time, I'll have to clarify with examples.\nFrom https://github.com/hylang/hy/blob/master/docs/style-guide.rst\nFirstly, \n\nLook like a Lisp; DTRT with it\n\nDTRT means \"do the right thing\". This means the conventional Lisp style. I know what the conventional style is, and the fact that the editor wants to correct to it demonstrates that.\n\nIndentation shall be 2 spaces (no hard tabs), except when matching the indentation of the previous line.\n\nThis is it more explicitly. It mentions an accepted 2-space style, and a matching-indent style. This is a guide, not a spec, but anybody used to Lisp knows what this means. So I'll clarify with examples.\nHere's the acceptable matching-indent style.\n(foo a\n     b\n     c\n     d)\nHere's the acceptable 2-space style, which is typically used for special forms (and macros) with a \"body\".\n(foo\n  a\n  b\n  c\n  d)\nAnd, of course, there are no indents to speak of when things are on the same line.\n(foo a b c d)\n(foo a b  ; like a `defn`\n  c\n  d)\n{1 2\n 3 4}  ; still has to match the previous line.\nIn both styles, indented elements at the start of a line from the same list must have the same indentation level. But these can be nested.\n(foo a b\n  (bar 1 2)\n  c  ; same as previous element\n  d)\n(foo a b\n  (bar 1\n       2)\n  c  ; still the same!\n  d). > then the relationship between conditions and outcomes isn't visually clear.\nWithout any elif clause, that would be fine, but yeah, it's not clear with that many. There are various options that don't violate the same-indent condition.\nYou can put pairs on the same line like this.\nHy\n(if (odd? (len args)) (macro-error args \"`for' requires an even number of args.\")\n    (empty? body) (macro-error None \"`for' requires a body to evaluate\")\n    (empty? args) `(do ~@body ~@belse)\n    \u2026)\nHy's if is a lot like Clojure's cond when you think about it. And it looks like one. This is just like putting key-value pairs on each line in a dict display. This is probably preferred.\nIf that's too long to fit on a line, you can use the matching-indent style in any then-clause.\nHy\n(if (odd? (len args)) (macro-error args\n                                   \"`for' requires an even number of args.\")\n    (empty? body) (macro-error None \"`for' requires a body to evaluate\")\n    (empty? args) `(do ~@body ~@belse)\n    \u2026)\nYou could also use a do block just for style. (They don't compile to anything). I'm not sure how I feel about this (it may be more noise than clarity if there are no side-effects before the last element in a do) because if you're using a do for every then-clause, you should probably be using a cond instead, but it doesn't violate the condition. But we don't want to have cond yet here, that's the whole point of the PR.\nHy\n(if (odd? (len args))\n    (do\n      (macro-error args \"`for' requires an even number of args.\"))\n    (empty? body)\n    (do\n      (macro-error None \"`for' requires a body to evaluate\"))\n    (empty? args)\n    (do\n      `(do ~@body ~@belse))\n    \u2026)\nThis way, it's indented like before, but it's a new list, so that's allowed.\nAnd finally, you can separate them with a comment (or even a blank line).\nHy\n(if (odd? (len args))\n    (macro-error args \"`for' requires an even number of args.\")\n    ;; elif\n    (empty? body)\n    (macro-error None \"`for' requires a body to evaluate\")\n    ;; elif\n    (empty? args)\n    `(do ~@body ~@belse)\n    ;; else\n    \u2026). assoc should also work with slices. That should be tested.\nI noticed some awkward zip/cuts in the implementation. partition is defined as a global in that module, so it's available. Or was this performance motivated? Perhaps we should modify core's list manipulation functions to use direct indexing instead of iterators where possible. (It's a separate issue.)\nBut why was assoc a special form in the first place? It's not the only one that could be implemented as a function instead. Therefore, I think assoc should be a macro for performance, and avoid the overhead of an extra function call. There's no need for assoc* as I originally supposed. It can expand to repeated gets in a setv instead. The function version you just wrote can then be moved to shadow so it's still available when a macro wouldn't work.\n. > give an example?\nLook what Python can do.\n```Python\n\n\n\nspam = [0]5\nspam\n[0, 0, 0, 0, 0]\nspam[::2] = [1]3\nspam\n[1, 0, 1, 0, 1]\nspam[1::2] = [-1, -2]\nspam\n[1, -1, 1, -2, 1]\n``\nActually, I think this will work fine even in the function version with explicit(slice ...)objects. (I think Python uses those internally anyway.) So(assoc spam (slice 1 None 2) [-1 -2])should work the same as(setv (cut spam 1 None 2) [-1 -2])`. But a test wouldn't hurt.\n\n\nArguably it doesn't provide much of an advantage\n\nThe advantage is more obvious when setting multiple things at once.\nHy\n(setv (get foo :a) 1\n      (get foo :b) 2\n      (get foo :c) 3)\nSee that repetition of foo and get?\nHy\n(assoc foo\n  :a 1\n  :b 2\n  :c 3)\nMuch more concise, but it compiles exactly the same way.\n\nDo we really need the micro-optimization of assoc being a macro? Most, maybe all, of Hy's core functions could conceivably be implemented as macros; just as macros are better than special forms, I think functions are better than macros.\n\nPretty much all of our operators are both special forms and functions in shadow. Why not eliminate all the operator special forms and just use the functions? Performance. Shadowed forms give us the best of both worlds, and it's the same with assoc. It is considered an operator in Python, just like + is. It's a variation of operator.setitem, written with [] and =.\n\nI would generally advocate changing special forms to macros or functions when this is possible, so let me know if you find any others.\n\nI would be in favor of redefining compiler special forms as macros in terms of more basic special forms, as is the case with assoc in terms of setv and get. Macros are a lot easier to work with, and it's good to keep the compiler simpler, all else equal. Maybe I should just check all of those. But when there's a direct correspondence to a basic Python statement or operator, I'd like to keep the form in the compiler.. > I'd like it to be possible to produce the AST corresponding to any Python program with pure Hy\nI also want this to be possible, at least for the most current version of Python.\n\nI see what you mean, but then how do we decide which core functions are a variation on an operator and which aren't? Is last a variation on getitem? Is inc a variation on +? Is zero a variation on =?\n\nEverything with a direct analogue in operator probably qualifies, even if Hy's version takes more arguments. And assoc is a special form presently.\nI don't think those three examples qualify by that standard, but making, say, zero? a shadowed macro is maybe not such a bad idea. It's one operation. It's the kind of thing a good optimizing compiler would inline. I wonder if PyPy would actually do this. I'd only consider that for trivially short functions like that though, or it would never end.. A basic defshadowed macro wasn't hard. There are certain basic limitations, some of them fundamental to this approach.. So, an assoc macro in terms of setv and get could be implemented like this.\nHy\n(defmacro! assoc [o!coll &rest kvs]\n  \"doc here\"\n  (assert (even? (len kvs)))  ; or equivalant macro-error\n  `(setv\n     ~@(chain.from-iterable\n         (genexpr [`(get ~g!coll ~k) v]\n                  [[k v]\n                   (partition kvs)]))))\n. Making it a macro for now is the more conservative change. I'd approve that alone, but I'd approve both that and shadowing it with a function too.. As for the limitations, in particular, defshadowed doesn't support any &-syntax, like &rest in its arguments list. \nIt only works on simple templates. The function definition expands it in advance, so any kind of conditional expansion won't work right. This limitation is more fundamental to the approach. The only general way around that is to macroexpand in the function at runtime and then eval it, which would perform poorly. But even that would choke on non-hygienic macros, and everything that broke let.\nThere may be certain other special cases we could automate, like when a variadic macro could be implemented as a reduce over the binary case, like most of our operators. Our shadow implementation is pretty repetitive.. I'm trying to think of ways to avoid that extra anon var. If we simply used or, it would work about as well. So you could use `(list (or ~fcontents [])). This is not quite the same, since any falsy value would be allowed to stand for an empty list in a splice. But I think this is fine.\nEmpty sequences are falsy, so it should be fine to substitute the empty list, since that's what they'd generate in a list call anyway.\nIn Common Lisp, NIL is the one false value, and also the empty list. So there is about as good a reason to accept False as there is to accept None as the empty list. \nIt's a little bit strange at first to think that 0 (or any custom falsy type via __bool__) is now also allowed in a splice as an empty list. But I think this is harmless and perfectly consistent with both Python and Lisp.. > I'm trying to write a test that compares (quasiquote (unquote None)) with (quote None),\nThese aren't supposed to be the same though. `~x is just x, not 'x.\nIn a typical Lisp, NIL is the empty list and also a symbol whose named value is itself. But Hy is based on Python, so the symbol 'None is different from its value None. The former is of type HySymbol, while the latter is of the singleton type NoneType--Python's None being the only instance of NoneType.\nPython\n=> (type 'None)\nfrom hy import HySymbol\ntype(HySymbol('None'))\n<class 'hy.models.HySymbol'>\n=> (type None)\ntype(None)\n<class 'NoneType'>. I came up with another option to avoid the anon var. We can use exactly the same rules as cons by actually using a cons.\nHy\n`(list (rest (cons Ellipsis ~f_contents)))\nWhere Ellipsis could be anything.. @kirbyfan64, if I understand you right, you'd try\nto_add = HyExpression([HySymbol(\"list\"), f_contents or []])\nDoes this work?. What is the tests/a_test_bin.py file for? It seems like a duplicate of tests/test_bin.py.. I think it's good to merge now. @Kodiologist, are you still OK with this version and commit structure?. deftag also chokes on this.\n``Python\n=> (deftag foo [] (try None (except [] None))())\n  File \"\", line 1, column 16\n(deftag foo [] (try None (except [] None)) ())\n                 ^-------------------------^\nHyTypeError: b\"Unknown expression intry'\"\n=> (deftag foo [] None `())\nimport hy\nfrom hy import HyExpression\ndef _hy_anon_fn_1():\n    None\n    return HyExpression([])\nhy.macros.tag('foo')(_hy_anon_fn_1)\n\n. Interestingly, this does work with symbols:Hy\n=> (total-purchase # [10 15] #* {'vat 1.05})\n165.375\nIf you were splicing into a function call in a quasiquote (like for a macro), then you do have to use keywords:\n=> (eval `(total-purchase ~@[10 15 ':vat 1.05]))\n165.375\n```. Here's another approach that doesn't change the grammar so much. All term productions now produce a list, and a discarded term produces an empty list. \nWith this approach (so far), there are places where #_ is allowed in Clojure that aren't allowed here, that is, in between other reader syntax and the discarded form, e.g. '#_() x will cause an error, but is just 'x in Clojure. I could probably make it work with this approach, but I don't know that we need it. [Edit: maybe not. And the errors crash the whole repl. Not good.]. I found a simpler grammar change. This time it only adds a few productions and leaves the existing ones alone.. I'll start rounding it out then. Tests, comment, docs, news. What order would you commit those in?. I made this to be Hy's equivalent of Clojure's comment macro, which ignores its arguments and returns nil.\n(when False BODY) or similarly (and None FORM) would work, but static analyzers (like Hydiomatic) would be justified in raising a warning that you've probably made a mistake. With comment the intent is clear. It's also easier to type.\nThat said, why not just use #_ FORM instead? (Usually you would.) I'm not sure, but Clojure hasn't deprecated comment, so it probably has uses. If I had to guess, sometimes you want to \"comment out\" code, but still need a None place holder. In that case FORM -> #_FORM None could also work. But you'd have to wrap BODY in something anyway, because #_ would only get the first term. Or you might still want the contents to show up after parsing for some reason (maybe for some other tool), even though it's semantically a just a comment that should be a no-op in the Python AST. Maybe something that renders docs from comments in HTML or ReST or Markdown, would want to find them with the help of Hy's parser. Normally we'd prefer docstrings for this kind of thing, but in the literate style, you might want markup comments interspersed with code in places that docstrings aren't allowed.. I added more tests.. Thanks for the tip on Matrix. I've started using Riot.im. I'll try MemoServ too.. Looks like MemoServ only works on registered nicks. That makes it a lot less useful. @ekaschalk, I missed you over IRC, but--\nHy\n=> (import builtins)\n=> (builtins.eval \"(1, 2)\")\n(1, 2). This breaks hy-repr for obvious reasons. I'm xfailing for now. This will have to be corrected, but not necessarily in this PR. (Experimental features shouldn't hold up core fixes, and furthermore, reprs are subject to change even between Python versions so should probably not be relied upon for correct behavior.) That test file is also not indented properly. I had to edit it as plaintext mode instead of as a Hy file to avoid excessive changes.. @kirbyfan64, this is so nested conses are still readable as dotted lists, for example\nPython\n=> (cons 1 (cons 2 3))\nfrom hy.core.language import cons\ncons(1, cons(2, 3))\n<HyCons (HyInteger(1) HyInteger(2) . HyInteger(3))>\n=> '(1 2 . 3)\nfrom hy import HyCons, HyInteger\nHyCons(HyInteger(1), HyCons(HyInteger(2), HyInteger(3)))\n<HyCons (HyInteger(1) HyInteger(2) . HyInteger(3))>\nPython reprs that are known to not round trip are conventionally contained in <>, for example:\n```Python\n\n\n\nobject()\n\n``\nNote also, thatconsis automatically converting1toHyInteger(1). I thought it was more important to show what it actually contains, rather than how you'd call it, likecons(1, ...). Althoughcons(HyInteger(1), ...)` should actually be equivalent.\n\n\n\nAnd furthermore, HyCons isn't autoimported like the other models. We're getting from hy.core.language import cons instead. So should it be like HyCons(foo, bar), or cons(foo, bar)? I'd pick the former, but this won't work in the Hy repl as (HyCons foo bar) after autoimport like all the other models do.\nThat said, I don't have very strong feelings about keeping this version of the HyCons repr. I'd consider a better version, but other things might have to change too. How would you want it to work?. @kirbyfan64, Thinking about HyCons some more, I'm not really satisfied.\nPython\n<HyCons (HyInteger(1) HyInteger(2) . HyInteger(3))>\n--should probably be spread over multiple lines like the other compound models. Maybe like this.\nPython\n<HyCons (\n  HyInteger(1)\n  HyInteger(2)\n. HyInteger(3))>\nIf we want it to round trip, then HyCons should be in core (probably all of the Hy models should #1045, but we should rethink autoimports altogether #434) then--\nPython\nHyCons(HyInteger(1), HyCons(HyInteger(2), HyCons(HyInteger(3), HyInteger(4))))\n--is the most obvious. But we'd want that spread over multiple lines too, to be consistent with the reprs from the other models.\nPython\nHyCons(HyInteger(1),\n  HyCons(HyInteger(2),\n    HyCons(HyInteger(3),\n      HyCons(HyInteger(4),\n        HyInteger(5)))\nBut I'm not sure that I like the indent for a single list. So we could just not indent conses.\nPython\nHyCons(HyInteger(1),\nHyCons(HyInteger(2),\nHyCons(HyInteger(3),\nHyCons(HyInteger(4),\nHyInteger(5)))))\nBut how should any of that look with a tree structure made from conses? Something like--\n((1 . 2) . ((3 . 4) . (5 . 6)))\nHy currently renders it like--\n((1 . 2) (3 . 4) 5 . 6)\n--and Common Lisp too. Notice how we lost dots, because it's a valid list prefix when the cdr is also a cons cell.\nThis PR currently renders it like--\nPython\n<HyCons (<HyCons (HyInteger(1) . HyInteger(2))> <HyCons (HyInteger(3) . HyInteger(4))> HyInteger(5) . HyInteger(6))>\n--which is too long to really read. If we spread it over lines it's better. But is it good enough?\nPython\n<HyCons (\n  <HyCons (\n    HyInteger(1)\n  . HyInteger(2))>\n  <HyCons (\n    HyInteger(3)\n  . HyInteger(4))>\n  HyInteger(5)\n. HyInteger(6))>\nThe round-trip version over lines without indents--\nPython\nHyCons(HyCons(HyInteger(1),\nHyInteger(2)),\nHyCons(HyCons(HyInteger(3),\nHyInteger(4)),\nHyCons(HyInteger(5),\nHyInteger(6))))\n--is hard to read.\nWith indents--\nPython\nHyCons(HyCons(HyInteger(1),\n    HyInteger(2)),\n  HyCons(HyCons(HyInteger(3),\n      HyInteger(4)),\n    HyCons(HyInteger(5),\n      HyInteger(6))))\nThis seems less bad. It would be clearer if the cars had their own line though.\nPython\nHyCons(\n  HyCons(\n    HyInteger(1),\n    HyInteger(2)),\n  HyCons(\n    HyCons(\n      HyInteger(3),\n      HyInteger(4)),\n    HyCons(\n      HyInteger(5),\n      HyInteger(6))))\nIt's much easier to see the structure this way. But look what that does to long lists.\nPython\nHyCons(\n  HyInteger(1),\n  HyCons(\n    HyInteger(2),\n    HyCons(\n      HyInteger(3),\n      HyCons(\n        HyInteger(4),\n        HyInteger(5)))\nMaybe this is okay. And it round trips (given HyCons). But the <> version spread over lines handled this much better.\nPython\n<HyCons (\n  HyInteger(1)\n  HyInteger(2)\n  HyInteger(3)\n  HyInteger(4)\n. HyInteger(5))>\nWhich do you prefer? Or do you have a better idea?. I redid the HyCons repr to work like the last example. @kirbyfan64 see if you like that version. If that's good, we'll still need tests and news/docs.. I colorized the reprs of the compound models to make deeply nested structures more readable. Try it out.\nPython reprs are not usually colorized like this. They're not usually indented either. evaling a colored repr is not going to work, but a manual copy/paste would. You can turn off clint's coloring by setting the clint.textui.colored.DISABLE-COLOR flag to True. clint also has a function to strip the color tags from a string. Either way would let us eval one of these. I don't see users doing this much, but I'd do it in the tests to make sure they round trip. Except for HyCons, that one doesn't work even without the color.\nI feel like I'm breaking convention a bit here. Most Python reprs are not colored, are not indented, and have no newlines. But it's much closer to normal Python than the Hy-like reprs we had before, to the point that you could manually copy/paste into a Python repl and usually expect it to work.\nIf this is too much trouble, we could have a module flag in Hy models to turn off coloring just for the models (if we turn it off in clint, errors don't get colored either). Or we could render them without color, indentation (or newlines) by default and have a separate repr-output-fn to indent and colorize them.\nI also noticed that the list* method will build nested conses. I thought we could use that in the repr to avoid the deep nesting problem of the round-tripping version of the HyCons repr. Compare\nPython\nHyCons(\n  1,\n  HyCons(\n    2,\n    HyCons(\n      3,\n      4)))\nlist*(\n  1,\n  2,\n  3,\n  4)\nThe problem is, that won't round trip either, because list* is not a valid Python identifier. Like I said before, other things might have to change. \nOne option is to give the HyCons class a static factory method that does the same thing as list*. (We could then implement list* in terms of that.) Then we could repr it like.\nPython\nHyCons.list(\n  1,\n  2,\n  3,\n  4). > Python's native pprint might be useful.\nI don't see how. Python's native pprint only works on certain Python collection types as special cases. It's not designed to be extensible at all.\n\nIt might make sense to separate the pretty-printing code from the repr code.\n\nA mechanism to disable or enable the coloring and pretty printing would make sense. This is a great use case for a dynamic var. #1089. Until that's implemented, a module-level flag would have to do. But the way the reprs are built, separating them altogether (without adding a lot of duplication) seems harder. It's much easier to add the pretty printing when the string is built than it is after, which would be error-prone. Starting with a pretty string and stripping the color works pretty well, but there might be edge cases where it strips too much. Stripping indents and newlines seems even more error-prone.\nWe could give Hy models a __str__ method (except for HyString and friends), which (by convention) doesn't need to even try to be evalable. So it might make more sense to render a str to look more like Hy code than like Python. __str__ is what print uses instead of __repr__. (But, if you don't override it, object.__str__ will fall back to self.__repr__.) These could also be colored and pretty-printed without much issue.. The hy.models.PRETTY flag now controls if compound Hy model reprs are pretty or a more typical flat, colorless Python repr. Their str will be pretty in either case. (__str__ always sets PRETTY to true while generating its output, so nested compound Hy model reprs will also be pretty.) I'm not sure if PRETTY should be on or off by default, but I'm leaning towards on. It doesn't seem likely to cause problems for most users most of the time, but they can turn it off if they need to.\nI'll need to mention the PRETTY flag in the docs.. Okay, there are docs and tests. Do these tests look sufficient?\nIt should probably have a NEWS entry too, but I'll save that for last after the rest has approval, since it's likely to conflict with other PRs.. Okay, that wasn't too hard. How's that?. You can use the new #* and #** syntax instead.. How should a break/continue work in the condition? I think these statements are only supposed to be valid in a loop body. We'd get a SyntaxError: 'break' outside loop before we even got to the inner one. And this is fine.\nThe problem with the second option is what happens with nested loops. If the while with a break in the condition is nested inside another loop, then it will break the outer loop on the first iteration, but the inner loop after that, which is weird and inconsistent. Similarly with continue.\nThe first option only puts the condition inside the body, so it will only break the inner loop, which is still weird, but at least it's consistent.\nWe could probably disallow (break) or (continue) inside a while condition in Hy's compiler altogether. I don't see a use for it anyway. I'm not sure how easily we could detect this though. We'd need a context stack, since another while should be allowed in the condition, and there's nothing wrong with putting a break in that.\nMaybe there's some other way to compile this that gives us sensible break/continue without corrupting else.. A third option.\nPython\nx = 3\n_hy_anon_var_1 = True\nwhile _hy_anon_var_1:\n    # Condition\n    print('hi')\n    _hy_anon_var_2 = x\n    if _hy_anon_var_2:\n        # Body\n        print(x)\n        x -= 1\n    else:\n        _hy_anon_var_1 = False\nThis is like the first option, but we don't add our own break, so the else clause for the while should work properly. The condition also always happens inside the loop, so break/continue are consistent.\n[Edit: we don't need two anon vars]\nPython\nx = 3\n_hy_anon_var_1 = True\nwhile _hy_anon_var_1:\n    # Condition\n    print('hi')\n    _hy_anon_var_1 = x\n    if _hy_anon_var_1:\n        # Body\n        print(x)\n        x -= 1. Haha. I realized I didn't need two anon vars so I edited it to simplify. I put the original version back for posterity.. Good point about using bool. A mutation in the body could prematurely interrupt the loop, without executing the condition clause again. But since Python builtins can be shadowed in a module, I'd prefer not to rely on them in the compiler when they aren't explicitly asked for, if possible. If we have to use a builtin, it should compile like--\nPython\nfrom builtins import bool as _hy_anon_var_2  # from __builtin__ in Python2\n_hy_anon_var_1 = _hy_anon_var_2(x)\nBut in this case, we could avoid it altogether like this:\nPython\nx = 3\n_hy_anon_var_1 = True\nwhile _hy_anon_var_1:\n    # Condition\n    print('hi')\n    _hy_anon_var_1 = x\n    if _hy_anon_var_1:\n        _hy_anon_var_1 = True\n        # Body\n        print(x)\n        x -= 1. Here's a candidate apply macro.\nHy\n(defmacro apply [expr args &optional [kwargs {}]]\n  `(~@(if (isinstance expr HyExpression)\n        expr\n        [expr])\n     #* ~args\n     #** ~kwargs))\nPython's distinction between args and kwargs made the old apply awkward compared to the usual Lisp version.\nI like this candidate better than our old one. #891. \nIt still works like before:\nPython\n=> (apply print [4 5 6] {'sep \"::\"})\nfrom hy import HySymbol\nprint(*[4, 5, 6], None={HySymbol('sep'): '::',})\n4::5::6\nBut now the final dict is optional, and you can partially apply things before unpacking.\nPython\n=> (setv args [4 5 6])\nargs = [4, 5, 6]\nNone\n=> (apply (print 1 2 :sep \"::\") args)\nprint(1, 2, *args, sep='::', None={})\n1::2::4::5::6\nMy original partition would work with this apply. It still doesn't work well with -> though, since it's not usually the function you want inserted. Maybe the solution is a another version with different ordering.. > Maybe the solution is a another [apply] version with different ordering.\nOn second thought, you can use a ->> anywhere in a -> to thread in the tail for a single form, while threading first for everything else.\nHy\n=> (-> (range 10) iter , (* 2) (->> (apply zip)) list)\nPython\nlist(zip(*((iter(range(10)),) * 2), None={}))\n[(0, 1), (2, 3), (4, 5), (6, 7), (8, 9)]\nYou can also use as-> this way to thread in any position you like.\nHy\n=> (-> (range 10) iter , (* 2) (as-> it (apply zip it)) list)\nPython\nit = ((iter(range(10)),) * 2)\nit = zip(*it, None={})\nlist(it)\n[(0, 1), (2, 3), (4, 5), (6, 7), (8, 9)]\nBut this isn't really required for the candidate apply, even if you're trying to apply to a dict, since you can also thread a dict in the tail position by providing an empty list -- (-> ... (->> (apply foo [])).\nIt's certainly usable like this, but I'm not sure if a different ordering would be better.. I just realized that the as-> macro works even without apply.\nHy\n=> (-> (range 10) iter , (* 2) (as-> it (zip #* it)) list)\nPython\nit = ((iter(range(10)),) * 2)\nit = zip(*it)\nlist(it)\n[(0, 1), (2, 3), (4, 5), (6, 7), (8, 9)]\nThe compilation is not as nice as with (-> (range 10) iter , (* 2) (->> (apply zip)) list), because it leaks the it, but the fact that it works now makes this issue seem much less urgent. But I wonder if there's a way to tweak the compiler to make (->> ... (foo #*)) work.\nWe might also want a shadow apply for use with higher-order functions, like map and comp. Our #*/#** syntax can't do this. (A quick xi would suffice, but that's true of a lot of core functions.) A possible implementation--\nHy\n(defn apply [f args &optional [kwargs {}]]\n  (f #* args #** kwargs))\nThis lacks the partial syntax of the macro, which is not possible for a function, but if you're using HOF anyway, you could just use partial on the f before apply gets it. This version seems useful, but again, I'm not sure if something else would be better. Good design might require more thought about use cases. If that were a common requirement, a higher-order version might be better:\nHy\n(defn apply [f &rest args &kwargs kwargs]\n  (fn [args2 &optional [kwargs2 {}]]\n    (f #* (chain args args2)\n       #** (doto (.copy kwargs)\n                 (.update kwargs2))))). > a new HyModel type ... the compiler's job to join\nExactly what I was thinking.. Turning on all future imports for Python 2 sounds like a good idea. I'm pretty sure this would only affect Hy modules, so it's not like we're forcing anything on the Python side. It will also help with the inevitable migration to Python 3.\nBanning __future__ imports altogether even in Python 3 seems less desirable, but moot at the moment if we've got them all on already. I'm worried about other implementations using these though. Does PyPy have any __future__ imports that CPython doesn't?\nThe real fix would be to get rid of autoimports altogether. #434 / #791. I've been pondering ways to do this. Some kind of hy_builtins would help with a lot of things.. > I'm surprised you're not advocating a more parenthesized (or square-bracketed) syntax, considering your concern for indentation. \nThen you haven't been paying attention. \ud83d\ude09 Maybe most of this happened before we brought you on, but I was the one who advocated removing redundant brackets to make Hy more Clojure-like #853. I'm also the one who wrote Hy's version of Arc Lisp's if #830/#962 when we already had a Common Lisp-like cond. The new if is more like both Clojure's no-bracket cond and Python's if/elif/else statement.\nMy design priorities for Hy have generally been\n\n\nWhen in doubt, defer to Python.\nIf you're still unsure, defer to Clojure.\nIf you're even more unsure, defer to Common Lisp.\nKeep in mind we're not Clojure. We're not Common Lisp. We're Homoiconic Python, with extra bits that make sense.\n\n\n--Hy style guide, explaining Hy's design\nWe can't do everything exactly like Python, or why not just use Python? On the other hand, we're not trying to re-implement Clojure on the Python VM--we're more tightly integrated with Python than Clojure is with Java. Hy is, first and foremost, Homoiconic Python. We're still Python (TM)! And we also need the Lisp bits to make it work. Python's \"batteries included\" philosophy applies to Hy too. We need to fill the Lisp gaps in the standard library. And I'm mostly filling these in with ideas from Clojure.\nClojure was designed with the benefit of hindsight (though some still like Common Lisp's style better), so where Clojure and Common Lisp disagree, I pick Clojure's version. But when Clojure doesn't have a good fit for Python, I look at Common Lisp before I look at other Lisps.\nIn this case, both Python and Clojure use keyword syntax in their list comprehensions. I don't really see a conflict on this point, so it seems like a good fit for Hy. There's no need to defer to Common Lisp this time.\nLisp is read (by humans) by indentation. Once you get used to it, it's as easy to read as Python. But if you don't follow the basic indentation rules, this doesn't work and the alternative is counting brackets, which humans can't do quickly or reliably, especially when you put them all on one line at the end, like we do in Lisp. Proper indentation is, first and foremost, about legibility.\nBut Lisp is edited structurally, with tools like ParEdit, and that's why some prefer Common Lisp's style over Clojure's--because there's more structure to work with. But the more minimal Clojure style is easier to remember, because there's less structure you have to produce. I think this makes it a better cultural fit for Pythonistas, who prefer Python's \"fun and easy\" approach. And I think it's not too hard to add that structure with ParEdit when you need it and then remove it again when you're done.\nPython users are used to defining blocks of code by their indentation. Parinfer infers where the brackets go based on indentation. It's also easier to learn than ParEdit, since you only need to memorize one keybinding (and can get away without even using that). This makes it a great cultural fit for the Python community to edit Hy. I'd strongly oppose any changes to the language or Style Guide that would be incompatible with Parinfer. So proper indentation is also about easy editing.\n. > I also agree with moving the body to the end. That bit of right-to-left-ness in Python's comprehension syntax always seemed odd to me, and looks even odder in Lisp.\nI think Python got it from Haskell, which got it from set theory. I've heard that some like to use math notation in their editors. If we switched it that wouldn't look as mathy. But Lisp forms usually put the body at the end.\nPython does it forwards when building lists in for loops, so it's not hard to understand forwards. I also think it's a better fit for Lisp with the implicit do, but on second thought, how should this work in a dict-comp? The key and value are easier to distinguish positionally without the implicit do. Otherwise we'd have to return a pair as the last form (like (key . value) or [key value]) or separate them with a keyword, (like key : value) which isn't consistent with our dict displays. I don't want to change only the other comprehensions.\nSo maybe we shouldn't add that to be consistent. do is typically used for side effects, which is usually not something we want in generators. If you need a do, maybe you should write your own fn and yield generator. Without the implicit do, I'm less motivated to change it to the end.\nOn the other hand, if we had a :top (:do? :with?) modifier for the bindings list, we could inject any code we like at the top of any loop, including break or continue or even yield. You could implement :if <condition> as :top (unless <condition> (continue)), and :while <condition> as :top (unless <condition> (break)) and :let [<bindings>] as top: (setv <bindings>). This setup seems pretty general, which is making me wonder if we need keywords at all, though Clojure's sytnax is shorter for the common cases. And without keywords, it's longer in the common case when you don't need a modifier, since you'd need a placeholder. And if you need to be that general, why not write your own generator?\nYeah. I'm thinking we should just mimic Clojure's design instead of trying to come up with a new one.\nI'd like to hear more opinions about which end to put the body in though. Clojure and Python disagree here, so I also looked at Common Lisp. But it looks like it doesn't have a standard list-comp. I suppose you'd just use maps and filters. If you try to mimic a comprehension with a Python map, you'd actually put the body first, in the lambda.. I think that special forms should generally be kept as simple as possible (but no simpler) that is, work exactly like Python, plus be able to use \"statements\" as expressions. The extra features should be in a core macro built on top of that instead.\nThe problem is, the macro will have to share a lot of logic with the compiler. Code duplication is bad. One way to avoid this would be for the compiler to expand to the macro invocation when it has to compile statements into a comprehension. But without better macro namespacing, this seems brittle.. > But, trying to simulate comprehensions (which we'd need to in order to compile the extended versions) seems error-prone because of scoping issues.\nConcrete examples, please. These scoping issues don't exist, with the exception of list-comp in Python 2, which uses different rules from all the other comprehensions. Try it out.\nIn Python,\nspam = (foo(x) for x in bar()) is just syntactic sugar for \nPython\ndef anon():\n    for x in bar():\n        yield foo(x)\nspam = anon()\nThey have exactly the same scoping rules. Python already compiles it to a generator function, so we can do the same without issue.\nI'm not sure if we should bother implementing the Python2-scoped list-comp, but\n(in Python2) spam = [foo(x) for x in bar()] is just syntactic sugar for\nPython\nanon = []\nfor x in bar():\n    anon.append(foo(x))\nspam = anon\n\nI propose instead that we have fairly restrictive special forms\n\nThere are good arguments for making special forms as close to native Python as possible. Designing Hy that way from the start might have made sense, but we're currently depending on the compiler to make statements act like expressions, and make binary operators variadic, e.g. (+ 1 2 3) to ((1 + 2) + 3) and (get foo bar baz) to foo[bar][baz]. We could probably re-implement the variadic operators as macros based on binary special forms.\nBut I'm not sure if moving the statement-to-expression logic out of the compiler is such a good idea.. > no semantic difference between comprehension syntax and an anonymous function\nLet's be clear about a function vs a generator function. Between a generator expression and an anonymous generator there's no semantic difference. It has to contain yield. You can see this is true if you add yield expressions to a generator, e.g.\n```Python\n\n\n\nlist([(yield x), (yield x+x), (yield xx)] for x in range(4))\n[0, 0, 0, [None, None, None], 1, 2, 1, [None, None, None], 2, 4, 4, [None, None, None], 3, 6, 9, [None, None, None]]\nIf you think about its \"expansion\", the output makes perfect sense.Python\ndef _anon():\n    for x in range(4):\n        yield [(yield x), (yield x+x), (yield xx)]\nlist(_anon())\n``\nSo, yeah, you could do the same thing withfn/for/yield` in Hy.\n\n\n\nBut I'm pretty sure a list comprehension (in Python 3) like [(yield x) for x in range(3)] actually compiles to something like\nPython\ndef _anon1():\n    _anon2 = []\n    for x in range(3):\n        _anon2.append((yield x))\n    return _anon2\nRather than a generator in a list constructor, like you might expect.\nThat's why this list comprehension returns a generator, not a list:\n```Python\n\n\n\n[(yield x) for x in range(3)]\n at 0x0000025BE19FD308>\nspam = _\nnext(spam)\n0\nnext(spam)\n1\nnext(spam)\n2\nnext(spam)\nTraceback (most recent call last):\n  File \"\", line 1, in \n    next(spam)\nStopIteration: [None, None, None]\n``\nAgain, if you think of the \"expansion\", it this behavior makes perfect sense. Note that the list return value came out in theStopIteration, just like when you use areturn` statement in a generator.\n\n\nbeyond the rule that it should be possible to produce any valid Python construct with Hy?\n\nI wonder if they're better optimized in PyPy somehow. The hy2py output might look prettier. Yeah, I can't really think of another reason. We could implement generators as macros that expand to fn/for/yeild with no loss of expressive power. Similarly, comprehensions could be wrapped in anonymous functions (except list-comp in Python 2, maybe), with no loss.. Clojure's doseq is the equivalent of Hy's for (which is why I proposed renaming it to doiter #1125), and doseq also has the modifiers :while :when and :let, just like Clojure's comprehension.\nI'd like to add them to Hy's for, and for consistency, Hy's comprehensions (and genexpr) should have the same modifier syntax.\ncompl and friends don't seem compatible with an expanded for that way.. What? Hy's for is already a macro, not a special form. It expands to nested for*. And Clojure's doseq is for side effects. It always returns nil, just like Hy's for. Why should Hy's for build a list that you're just going to throw away by expanding into a list comprehension instead?. Are you developing on Windows? It might be related to #1289.. So which tests are missing? Are all the native tests not getting executed on Arch either? . I'd also like a test to make sure the wasted assignment isn't in the AST.\nYou forgot a pair of square brackets in that import #851, but we could avoid the reduce import and avoid re-implementing partition by using two pop/assignments in a loop, which conveniently produces our arguments in the desired reverse order.\n(defmacro if [&rest exprs]\n  \"if with elif\"\n  (setv exprs (list exprs)\n        expansion (if* (% (len exprs) 2)  ; odd?\n                    (.pop exprs)\n                    `None))\n  (while exprs\n    (setv expansion  `(~(.pop exprs) ~expansion)\n          expansion `(if* ~(.pop exprs) ~@expansion)))\n  expansion)\nThis builds it inside-out just like your reduce. It's more imperative than functional, but we don't have all our functional tools yet it bootstrap.\nWe should also consider removing if* from the docs to discourage people from nesting it in their own macros.. I also noticed the tutorial says there's no elif in Hy and you should use cond. We should clarify that if can have \"elif\" clauses. The doc updates don't have to be in this PR though--just the fix and the test.. > There's no real reason to have both cond and multi-branch if in the same language, right?\nHy's multi-branch if is more like Clojure's cond. Hy's cond is from Common Lisp. They're not the same. I don't want to get rid of if, but I'd consider moving cond to extra.\nIn Hy, cond has an implicit do after the condition, which is really only good for side effects in the imperative style. In the more typical functional style, it's just extra brackets. You might as well use an explicit do in the rare branches where you need a side effect and avoid the extra brackets everywhere else.\nHy's cond can also have empty branch bodies, in which case the value of the first truthy condition is returned, like an or. That is, the last expression of the branch is the value of the branch, even if it also happens to be the first expression. (Common Lisp also does this.) cond also has no else clause. It always defaults to None. You can mimic one by using a truthy value, like True or :else as the condition in the final branch, but this doesn't compile to a Python else, because the else always has the default None.. > And for setv, since there's no let.\nYup. That's a real pain point. I wish we could have a proper let in Hy. But setv is a side-effect--albeit a localized one when using (ahem) locals. It helps if you put the if inside the setv instead of the other way around.\nWith the threading macros, unpacking, doto or comp/partial (and sometimes juxt), and small, focused, functions, I've found that I don't actually need let as much as I thought. When I do use a setv, it's usually just one at the top of the function, not in branches. But in the rare case you need it, you can use the do block. It's the exceptional case, not the common one.. > Is this even really possible right now?\nI think so. Even at the native Hy level, we can get the AST compilation of a test form using disassemble, which we can inspect programmatically. How much did the AST change between Python versions in a simple if branch? We could also use astor and see if the word elif appears in the string.. > I don't think we're going to much improve the readability or maintainability of the codebase, or even make it much shorter, by replacing all the Python with Hy.\nYou might be surprised what good macros can do. This might be worth it someday. But I think HyHy should be a separate project from Hy for the foreseeable future. I don't even want to think about self-hosting before we get to Hy version 1.0, get our tooling in order, and drop Python 2 support.. Three's a veto, so I'll close this, but discussion can continue. We might reconsider self-hosting later if HyHy is compelling as a separate project. Consider running it through Hydiomatic. The machine-compiled code is kind of ugly compared to competent human-written Hy. And some of that probably can't be helped before we implement return. I know it's just a starting point.. Not what I meant. Sorry I got it wrong the first try, you probably didn't see the edit. How about like this.\nHy\n(defmacro assoc [coll k1 v1 &rest other-kvs]\n  (if (odd? (len other-kvs))\n    (macro-error (last other-kvs) \"`assoc` takes an odd number of arguments\"))\n  (setv c (if other-kvs (gensym \"g-assoc\") coll))\n  `(setv\n    ~@(and other-kvs [c coll])\n    ~@(sum (list-comp [`(get ~c ~k) v] [[k v] (partition other-kvs)])\n           [`(get ~c ~k1) v1]))). Hmm, yes. I don't like it there either. I think it's clearer to put all the assignments in the order they'd appear in the expansion.\nHy\n(defmacro assoc [coll k1 v1 &rest other-kvs]\n  (if (odd? (len other-kvs))\n    (macro-error (last other-kvs)\n                 \"`assoc` takes an odd number of arguments\"))\n  (setv c (if other-kvs\n            (gensym \"assoc-coll\")\n            coll))\n  `(setv\n     ~@(and other-kvs [c coll])\n     (get ~c ~k1) ~v1\n     ~@(+ [] #* (list-comp [`(get ~c ~k) v]\n                           [[k v] (partition other-kvs)]))))\nThis looks more like a template for the expansion. I like it there better.\nWe shouldn't ever be using sum on lists anyway. It's a mere implementation detail that this works at all. sum's docstring says \n\nThis function is intended specifically for use with numeric values and may\n    reject non-numeric types.\n\n[Edit: the (+ [] is required even given #1349. Though (+ #* []) is 0 which works in the splice, the one-argument case (+ #* [[foo bar]]) uses the unary +, which isn't implemented in list.]\nWe do have the shadow + here, right? If not, chain.from-iterable would also avoid the last [] in the sum altogether, though it's an unfortunately long name for such a useful operation. Maybe we could give it a *chain alias or something, but that's another issue. I see this pattern a lot in macros, so I added a chain-comp macro in my destructure PR. It might be useful in core if we see this kind of pattern a lot there. But again, another issue.. I amended a commit for formatting and I fixed the conflict with NEWS using the web editor, which added a merge commit. @Kodiologist is this commit structure OK?. > I thought we settled on the Lua style.\nI thought we did, or I did, at least. There are competing priorities, that's all. I can make this a priority since you think it's important.\nThis can come later, but we'll want to at least update hy-mode for the new syntax, and vim-hy too, but no-one seems to be maintaining that. Since hy-mode isn't settled even for what we've got so far, I've been de-prioritizing syntax changes that would break it compared to other things.\nBut even before then, both emacs and vim should mostly highlight properly if Hy files if we pick #[\"[...]\"] as the delimiters. I'd also like to get a basic linter going for .hy files #1398. Parlinter looks promising, but it won't work with the new syntax generally, just with #[\"[, which it will recognize as a string inside []. (The other proposed string syntax options probably can't even do that much.) We're not the only Lisp with this kind of problem, so we can probably get that fixed. I'd even translate it to Python and do it myself eventually, but priorities.\n. Python\n=> (. '#[foo[bar]foo] hashstring_delim)\nfrom hy import HyString\nHyString('bar').hashstring_delim\nTraceback (most recent call last):\n  File \"c:\\users\\me\\documents\\github\\hylang-hy\\hy\\importer.py\", line 201, in hy_eval\n    return eval(ast_compile(expr, \"<eval>\", \"eval\"), namespace)\n  File \"<eval>\", line 1, in <module>\nAttributeError: 'HyString' object has no attribute 'hashstring_delim'\nI can't seem to access the delimiter from the model. Is the compiler stripping it out somewhere?. Looks like the macros can get to it though.\nPython\n=> (defmacro foo [s] (. s hashstring_delim))\nimport hy\nhy.macros.macro('foo')((lambda s: s.hashstring_delim))\n<function <lambda> at 0x000001BDD82476A8>\n=> (foo #[x[]x])\n'x'\n'x'. Tested too, that looks good.\nSeeing those elif isinstance statements in a super-long method makes me want to move that logic to methods in the individual Hy models themselves. It's another issue though. For now, it's more consistent this way. The refactor should be in #1399, or at least wait until after that's merged.\nNow that the delimiter is a keyword argument, I think I should put it in the HyString repr in #1360, at least when it doesn't have the default value of None. (This will have to be merged first, so I can rebase.) But perhaps it should have a shorter name than hashstring_delim now? It's not kwonly, so I could just put it second positionally, but it might be clearer with the word.\nWe also need news and docs, which should also specify that some number of ='s are the preferred delimiters when #[[ won't do, and there's not a specific reason to use something else.. > I don't want to count =s.\nI don't want to count more than three, but how often does that come up?\n\nat least defer this debate until a style-guide PR\n\nOK, I guess.\n\nhashstring_delim just seemed like the most obvious choice. Is there any particular alternative you'd prefer?\n\nI didn't have a particular alternative in mind, but I guess brackets could work.\n@kirbyfan64, anything else you'd like to add? Do you have a preference for the HyString reprs?. Go ahead and change it to brackets.. The implementation seems good now.\nI don't like the name \"hashstring\" it makes it sound like it has something to do with hash functions, but it doesn't. It's just from the # character. We could call them \"bracket strings\", unless you have a better idea?. Shouldn't we add this to tox too? Is Travis actually running flake8 and coverage? I can't find the output. I'm not sure how our testing works since we stopped using nose, because #1289.. Conflict. Drop Python 3.3, due to #1401 . This seems related to the ordering problem of #1342, (and #588, #1362). Hy still has trouble compiling statements inside expressions. I'd have expected the wrong order here too, but it's strange that it gets left out completely instead.\nWe should probably check how Hy compiles every type of Python statement when they contain statements. In particular, what happens when sub-statements raise exceptions or have other side effects that care about ordering?\n\nI guess this should compile to:\n\nThat's the right track, I think. It might be easier to compile in some anon vars in a couple places. But how does this interact with Pytest? Will it still print out errors sensibly? I know that pdb will list Hy source, since Hy puts source position information in the ast. And Hy exception tracebacks print Hy source too.\nPython\n        assert not 1, f4()\nWhy not 1 instead of False? On Python 2, I suppose False (or None) could be shadowed by something else (a design flaw corrected in Python 3), not that anyone actually does this. But then, wouldn't 0 be simpler? Any false value will trigger a Python assert. Does it need to be the one true False for some reason?\nIf we do care what particular false value assert gets (does Pytest use this?), then it should compile like\nPython\nif __debug__:\n    f1()\n    _hy_anon_var_1 = f2()\n    if not _hy_anon_var_1:\n        f3()\n        assert _hy_anon_var_1, f4()\n. But, f3() could mutate the [] returned by f2(), preventing the assert from triggering at all, which does not seem correct. I suppose we could use it if possible, and fall back to assert 0 if not.\nPython\nif __debug__:\n    f1()\n    _hy_anon_var_1 = f2()\n    if not _hy_anon_var_1:\n        f3()\n        _hy_anon_var_2 = f4()\n        assert _hy_anon_var_1, _hy_anon_var_2\n        assert 0, _hy_anon_var_2\nThis kind of ambiguity could cause confusion about the cause of that 0 during debugging, since it could either be returned by f2(), or just be the fallback. I don't know if we even need this though.\nI looked at Pytest. It's doing some AST rewriting, so it might not work right. Hy can't be expected to support this kind of thing in all cases. But it also looks like Pytest doesn't rewrite things at all if there's a second expression (the message part) in the assert anyway, so I guess it doesn't matter here.. The failing test is only for enforcing the old behavior. This doesn't seem to have caused any other problems. I'll update it for the new expected behavior.. It looks like the next Python release will break this. It will be an error to do it Python 2's way with an explicit exception. We have to use return. Short of evaling strings conditional on the Python version, I don't see a way to make this work in both versions. We might have to wait until we drop Python2.. A working prototype. I think.\nHy\n(defmacro! ifp [o!pred o!expr &rest clauses]\n  (setv expansion `(if)\n        extend (. expansion extend)\n        clauses (list clauses)\n        default (if (odd? (len clauses))\n                  (.pop clauses)\n                  `(raise (TypeError (+ \"no option for \"\n                                        (repr ~g!expr)))))\n        clauses (iter clauses))\n  (for [test clauses]\n    (setv then (next clauses))\n    (if (= then ':>>)\n      (extend [`(do\n                  (setv ~g!test ~test)\n                  ~g!test)\n               `(~(next clauses) ~g!test)])\n      (extend [`(~g!pred ~test ~g!expr)\n               `~then])))\n  (.append expansion default)\n  expansion). > I'd also like to see an econdp that raises LookupError instead of returning None when none of the clauses match, which is useful when you mean to be exhaustive.\nClojure's condp does throw an exception when none of the clauses match, and so does my ifp. I used a TypeError though. If you want a default None you have to make it explicit.\n\nIt seems better to have a more general construct [...] which lets you specify the test directly rather than obliging you to use a binary operator and a starting value\n\nPython > Clojure > Common Lisp.\nA construction that different from those three standards doesn't go in core. We can try crazy variations of things in contrib or libraries separate from the main project. But if we all try variations in core, we'll never settle on anything. My version works like Clojure's, and will be familiar to those coming from Clojure, which I expect is a sizable segment of Hy's users.\nOne of the main benefits of Python's batteries-included standard library is to avoid the proliferation of incompatible third-party libraries to handle the basics. Hy's core is supposed to extend this for the needs of a Lisp, mostly drawing from Clojure and Common Lisp.\nMaybe your version is better than Clojure's, maybe it isn't. Call it ap-condp or something and put it in with our other anaphoric macros. It seems like it would fit there.\n. I don't see it as a \"limitation\", rather as \"direction\". We can still go our own way in our extra libraries. But Clojure's core was designed by more experienced people with the benefit of decades of hindsight from other Lisps. I do use Clojure. Having used both it, and many other languages, Clojure seems very well designed to me.\nWhere we can clearly, objectively, do better--let's do so. If even the Clojure people say something was a mistake, let's not repeat it. But when the choice is arbitrary, rather than a clear improvement, take direction from Python>Clojure>Common Lisp, to be more familiar to our users. We could all make arbitrary changes, but we'd pick different ones.\nI don't think the rest of the proposal is an improvement at all. It's mere subjective preference.\nClojure's aesthetic is \"minimal ceremony\". Among other things (like eschewing extra brackets), that means we make the common case the easy one, but make the uncommon case possible.\nA binary operator is by far the common case. So let's make that case the easy one. If you need more than two arguments, you can pass in a data structure. A zero argument \"predicate\" is useless here, since it'd be a constant--so why have branches?\nThinking about actual use cases, when would you ever need to use a single-argument predicate? When you have a partially applied binary operator handy. So use > 0 instead of pos?. Not good enough for your particluar predicate? The use case is getting very rare now, but we can still do it. Use #(%2 %1) foo-pred?\n--or (xi x2 x1) foo-pred? in Hy.\nHow much more ceremony is that compared to (foo-pred? it)? How often does that come up? And how much less ceremony is > 0 compared to (> it 0)? How common is that? We don't need it. Make the common case easy.\nClojure's syntax has another benefit. My current macro implementation doesn't do this, but it could be modified to detect (at expansion time) if the predicate is already a symbol, and it could then avoid gensyming it. This means that it could expand to using the faster Python operators instead of requiring the overhead of a function call in all cases.\nThat just leaves the extra brackets. They're the norm in Common Lisp. Either approach has tradeoffs (many of which are subjective), but Hy prioritized Clojure style over Common Lisp's. It would be more consistent to stick with that. The common case in the common functional style does not have side effects, so the implicit do doesn't really help. It's just that much more useless ceremony. And an explicit do calls attention to the side effects, which would help reduce bugs.. The master branch has breaking changes compared to the previous release. More breaking changes are planned. Keep up with the NEWS file and make sure you use the docs that match your version of Hy.. Also, tag macros can be more than one character, unlike the old sharp macros.. We need to fix that NEWS file, but the unstable docs do show deftag now.. I'm not sure about that either, but IPython is actually pretty extensible. I think it would be pretty easy to create a custom %hy magic to make IPython read Hy input for just that line. You'd just have to call Hy's compiler on that line, something like hy.eval(hy.read_str(line)) would probably work. Then you'd get %pdb and all the other IPython magic for free. Even without that, you can certainly import any Hy module during an IPython session.\nI'm actually considering doing it the other way around: make an IHy that reads Hy by default, which would help with #1323 as well as these debugger issues. This would be quite a bit more involved, and use IPython's custom input transformation API. I'm reluctant to include this in Hy proper, at least at first. It would be a separate project. But it might be nicer to use than the default Hy repl, since we'd be able to get nice IPython features in Hy.. Basic line magic is not hard. Here's a basic proof of concept.\n```Python\nIn [1]: from IPython.core.magic import register_line_magic\nIn [2]: @register_line_magic\n   ...: def hy(line):\n   ...:     \"interprets line as Hy\"\n   ...:     import hy\n   ...:     return hy.eval(hy.read_str(line), globals())\n   ...:\nIn [3]: %hy(+ 1 2)\nOut[3]: 3\nIn [4]: %hy(setv foo 42)\nIn [5]: foo\nOut[5]: 42\nIt's pretty limited, but might already be useful. Cell magic would be about as easy.. Make a separate PR to drop 3.3, and we'll discuss it there. I'm okay with it, since it's only a month away. I doubt anyone will care, but they can install Hy from an older commit for a month if they have to. I don't think the date is final, but changes to that seem improbable at this point.. @hylang/core can we get another ack? Any objections?. @Kodiologist, there's a conflict due to #1418. #1419 might cause similar problems.. Good catch.. Python avoids this issue by requiring an explicit return in a function def. Clojure avoids this issue by putting the docstring [*before* the arguments vector](https://clojuredocs.org/clojure.core/defn). It wouldn't be difficult to alter the `defn` macro to do it Clojure's way. I'd be fine with that, but I'm not sure if that would be a popular change, since Common Lisp appears to do it like Hy does.Lisp\n* (defun hi () \"Hello\")\nHI\n* (documentation #'hi T)\nNIL\n* (defun hi () \"Hello\" nil)\nWARNING: redefining COMMON-LISP-USER::HI in DEFUN\nHI\n* (documentation #'hi T)\n\"Hello\"\n```\nAnd it's also more like Python where it is now.\nEmacs Lisp also puts it after, but interestingly, it treats a single string in the function body as both. This may be why Hy's behavior surprised you.\nElisp\nELISP> (defun hi () \"Hello\")\nhi\nELISP> (hi)\n\"Hello\"\nELISP> (documentation 'hi)\n\"Hello\"\nBut because I'd expect the majority of Hy users to have first learned either Python or Clojure (and because Emacs Lisp is the first Lisp for many), we ought to explicitly explain in the docs for defn that the implicit return has priority over docstrings. And, in fact, the existence of docstrings isn't even mentioned there. So I'll reopen this until we've done at least that much.. > it'd be safer (and more descriptive) to use ast.literal_eval here.\n@kirbyfan64 I thought about how to exploit eval here, but it's already got to be accepted by the parser as a string at this point, so I don't see how. F-strings might be a concern when we implement them later, but we could use a separate @builds function for that.. Is there some reason the else in for* doesn't have an implicit do? It does in try.. > real code\nI expect that directly human-written code won't be too long, but aren't you underestimating macroexpansions? Especially when macros expand to other macros. They could be several pages long. That's what the compiler has to chew through. It adds up.\n\nTo what end, for speed?\n\nIt's really hard to judge that without profiling. I have no idea where the bottleneck in the compiler is. I agree, early optimization at the cost of clarity is an evil. Compilation speed is also a lot less important than runtime speed. But since we seem to be using them as deques anyway, wouldn't they be clearer in both the compiler and macros if they were really deques? Woudn't you rather write (.popleft foo) instead of (setv foo (cut foo 1)) in your macros?\nBut a speedup wouldn't surprise me. On a modern system, non-I/O bottlenecks are typically cache misses. CPython's deque takes this into account, and is better at being a deque than a list is.\nDo we ever use random access in the middle of a HyExpression? What about the other compound Hy models? Maybe HyList should stay a list and only HyExpression should be a deque? This is a bit more like how Clojure works.\nWe could use iexpr = iter(expr) and next(iexpr) in the compiler instead of expr.pop(0) when we want to pop from the front. I've done similar things in macros. But this is an extra step we wouldn't need if they were deques to begin with.. > (this basically means x.pop(0) is the same thing as x[:] = x[1:]\nThanks, that's good to know.\n\nExpressions are pretty much never over 10 elements\n\nI dispute this. My destructure macros #1328 can easily make setv expressions longer than this with its intended typical use. And it could get used a lot. The compiler has to worry about arbitrary macroexpansions, not just expressions short enough for humans to type. And that means macros themselves would be using expressions that long.\n\nwe'd probably burn through more time with the direct indexing now having to go through multiple blocks\n\nHow big are these blocks?. I thought they were 64. For your typical 10-element expressions, wouldn't the lookup performance be about the same as a list?\nHow often do we even use direct indexing into the middle of a HyExpression? Most of the direct indexing I've seen is at the beginning or the end, which a deque would handle just fine.\n\nI'd also like to see concrete evidence that this actually helps\n\nIt's status quo bias maybe. Getting enough evidence to satisfy you might be more effort than changing the implementation. What if the status quo was reversed? Imagine, if they had been backed by deques in the first place, how would you feel about changing them to lists? What about with the argument that the performance hit wouldn't matter, because it's not the bottleneck anyway? Why? This is not just about speed. It's about providing the right interface for the use case. Left-appending to a code list is a typical use case in Lisp. That's all a cons list can do well.\nOne thing to be said about the status quo: breaking changes are not good. I don't see this proposal as being as important as some other things we're working on. But the time for any breaking change is sooner, rather than later.. > the interface is distinct from the implementation\nVery true. If the interface is settled, then changing the implementation does not break API, and we're free to do this later, even after 1.0. I think it would be easier to add list methods to a deque subclass  via abc.MutableSequence, than the other way around, but I'm not sure. With the right methods, we could implement slicing for a deque. No existing code would have to change if the old list methods are still available and work the same way.. > I got totally lost at step 3 though\n@kirbyfan64, I was assuming knowledge of Clojure. It might help if you play with Clojure's syntax quote.\nClojure\nuser=> `x\nuser/x\nNotice the prompt. That indicates that the current namespace is user. In the first example, the compiler expands `x to user/x, which is a symbol with a namespace prefix. This serves the same purpose as the __import__(\"builtins\").list trick. So x in the macroexpansion will refer to the x in the current namespace (user), without conflicting with any local in the expansion context.\nIf you need to insert a symbol without the prefix (like it in our anaphoric macros), you can do that too, by unquoting any form that evaluates to a symbol, instead of just writing the symbol.\nClojure\nuser=> `~'x\nx\nThe current namespace lives in clojure.core/*ns*\n```Clojure\nuser=> clojure.core/ns\n\nWe can change it with the `in-ns` function. Notice that the prompt changes to reflect this.Clojure\nuser=> (in-ns 'foo)\n\nfoo=> `x\nfoo/x\n```\nAnd now symbols get a prefix for the current namespace.\n```Clojure\nfoo=> (def x \"Foo!\")\n'foo/x\nfoo=> x\n\"Foo!\"\nfoo=> (in-ns 'user)\n\nuser=> x\nCompilerException java.lang.RuntimeException: Unable to resolve symbol: x in this context, compiling:(NO_SOURCE_PATH:0:0)\nuser=> foo/x\n\"Foo!\"\nHere we defined a `foo/x` and it's not available in `user` unless you use the full name. But you can add the mappings from the `foo` namespace to the abbreviations available in `user` by referring `foo` into `user`.Clojure\nuser=> (refer 'foo)\nnil\nuser=> x\n\"Foo!\"\nuser=> (eval x)\n\"Foo!\"\nuser=>x\nfoo/x\n``\nSee also, the discussion in #911. Does that help?. > The most straightforward solution to auto-importing woes is to replace the current auto-importing magic withfrom hy.core.language import *` at the start of the REPL and the top of each source file. Then Hy core functions would work very much like Python builtins.\nI did think of that possibility, but it doesn't work well.\nImporting everything at the top doesn't help with #1367. And it creates a new problem: module docstrings have to be the first statement, but now that doesn't work in Hy. (I guess you could explicitly (setv __doc__ ...).) And you'd still somehow have to get the __future__ import to the top of the file. The only statements allowed before a __future__ import are other  __future__ imports, and the module docstring.\nI'd also like to make Hy's core more discoverable. With _# or something like it, new users could find the core functions with (dir) (dir __builtins__) (dir _#). If we just dump everything into every Hy module, then the user code is harder to sort through with dir. (Maybe you'd always have to use [s for s in dir() if s not in dir(hy.core.langage)] at the repl.) Similarly, user-created .hy modules imported in the Python side would be harder to sort through with dir().\nFurthermore, all .hy modules will export all of Hy's core to Python when they're imported with *, unless you explicitly set __all__ to something else.\nIt's more trouble than what we're currently doing.\n\nThings like dynamically scoped variables and protection against shadowing of core function names in macro expansions would be nice. But it's hard for me to guess in advance whether your plan would work and what the side-effects would be.\n\nI am also worried about some of this. Some of these steps could be done in a different order, or in slightly different ways.\nIf we did the lookup magic from step 5 first, we can hook anything we please into the globals().__getitem__ lookup. Besides dynamic variables, we could make our own objects behave like __builtins__, but only for Hy modules. This way we wouldn't have to put _# in builtins. In fact, we wouldn't even need that first part of the prefix, since we could make all of our namespaced objects act like a builtin. So _#.builtins.list could be builtins/list or something.\nI'd also like Hy to support mypy for static typing, if possible. But I'm worried that the abbreviated special variables from steps 5 and 6 would confuse it. Those accessed through . should be fine though. Similarly, using the globals().__getitem__() hook for anything else could have the same problem, hence putting _# in __builtins__ might be the better option. But maybe that would confuse mypy too, since mutating builtins simply isn't done by well-behaved Python modules.\nAnother option would be to use symbol macros, but restrict them to names containing a /. So the compiler would treat them differently than normal symbols, just like it does for names containing a .. (/ and // would be special cases, just like . is.) For example, the compiler would expand builtins/list to __import__(\"builtins\").list and hy.models/HyExpression to __import__(\"hy.models\").HyExpression, etc.\nAnother option would be to autoimport _# in every Hy file (and at the start of the repl), instead of putting it in __builtins__. This would still be discoverable via (dir) (dir _#). It wouldn't automatically import from Hy modules, since it starts with _. It wouldn't pollute every Hy module's globals() dict with hundreds of symbols you might not even use (just one). But we still have to make sure it comes after the docstring and __future__ imports. Since it's no longer in builtins, we could use any name that starts with an underscore, not just invalid Python identifiers, like _#. Maybe _hy could work. The users might want to type these, so we don't want it to be too long.\n. Some more concerns. We can shadow special forms.\n```Python\n=> (setv + 42)\n  File \"\", line 1, column 7\n(setv + 42)\n        ^^\nHyTypeError: b\"Can't assign to a builtin: `+'\"\n=> ((fn [+] (+ + +)) 21)\nfrom hy.core.shadow import +\n(lambda +: (+ + +))(21)\n42\nYou wouldn't expect this to work, but it does. Maybe it shouldn't, but then, how are the shadow functions supposed to work? Maybe shadowing special forms should be allowed in general instead of partially disallowed like now. But then, how should a Hy syntax-quote expand +```? Likehy.core.shadow/+or_#.hy.core.shadow.+`?\nLet's look at Clojure--you actually can assign to special form symbols.\n```Clojure\nuser=> (def do 42)\n'user/do\nuser=> do\ndo\nuser=> (do do)\n42\nuser=>(do do)\n(do do)\n``\nand, as you can see, it doesn't expand them in syntax quotes. But, like a macro, it takes priority over a function with the same name, like how shadows work in Hy now. This is probably the right way to handle it. You could still explicitly use the prefixed form, when that's your intent. But it should be explicitly documented, because Hy has a lot of special forms compared to most Lisps.. Considering how Clojure works, no ban anywhere makes more sense. And it would be easier to implement too. Special form names would take priority in the function position, even when they're shadowed, like Clojure.. >  I personally don't think usingimport` here would really be a problem.\nI worry that other implementations don't have it. I'd like to support IronPython3 and Jython3 when (if) they get released. They both appear to have active repositories. I'm also thinking about supporting Stackless, but PyPy3 might make that obsolete. It doesn't run on Windows yet though.\nI suppose we should check out how those implementations do it. Maybe we could special case them somehow if they don't use __import__.\nAnother concern is the issue of creating hidden dependencies. I'm not sure how big a deal this is, but normally, you want all of your imports at the top of the file, so you know what it needs to run properly just from looking at the head, instead of searching through possibly thousands of lines. Except for __future__, Python doesn't enforce this at all. You can put import statements anywhere statements are allowed. But doing this is considered poor style in most cases, because it hides dependencies.\nOne \"advantage\" of using something like _# instead of __import__ is that we could check the module cache, but raise an error if it isn't there, instead of importing it. This would require a module to be imported normally at least once (or put in the cache at least). But importing the module anywhere in the program would put it in the cache, so I'm not sure how much this helps.. Like that?. Hmm, nope. Travis did not like that at all.. Strange, the version Travis choked on seems to work on Windows. It looks like the string interpretation is OS dependent, even with shell=False.\nI added a shlex.split to run_cmd so that any arguments in the cmd string in POSIX format will work as before. I also added an args kwarg, that takes a sequence to extend the list of args with, in case you have to specify them in non-POSIX format for some reason. I had to update one of the tests to do it this way, because shlex.split doesn't like Window's path format, but that's how os.walk provides it on Windows.. > It seems best to provide a list in any case,\nI'd already pushed an update to that last commit. I am passing a list to Popen.\n\n[...] although we can still give run_cmd some syntactic sugar that the individual tests can use, of course.\n\nBut I'm generating that list from a string passed to run_cmd, with shlex.split, which operates in a platform-independent way (i.e. POSIX sh). That's the sugar.\nI could change line 231 from\nPython\noutput, err = run_cmd(\"hy2py -s -a\", args=[os.path.join(dirpath, f)])\nto\nPython\noutput, err = run_cmd(\"hy2py\", args=[\"-s\", \"-a\", os.path.join(dirpath, f)])\nwhich puts all the args in a list, if you think that's clearer.\nI'm not sure what else you want here. It already seems to be doing everything you just asked for.. > Is the change of quotation marks still necessary?\nI doubt it actually. I could change it back and see.. Not necessary. tests\\test_bin.py passed on Windows when I changed it back.\nI could squash the commits and omit the change to the quotes, if you want.. I got pytest running the native tests on Windows.\nNow this PR fixes #1289, assuming Travis approves.. Can someone else look at this? It's making development on Windows difficult.. @kirbyfan64, how's that?. We also need to make sure the first body element is not detected as the docstring if it is also the last. #1402.. > It's not worth implementing Python 2's native support, in my opinion. Python 3 is the future and all that.\nI'm kind of inclined to agree with that much.\nI'm working on a fn=: macro for my destructure branch #1328, which is why I'm finding these issues. It would support the full Clojure-like destructuring syntax, (including dicts) in its args list. If we have that, perhaps we should remove the argument destructuring in the compiler altogether, like Python 3 did. Macros can make up for it.. Closing due to #1590.. ### Option 2\nHy\n(defn foo [a {b 1  c :c  d None} args & x {y 2  z 3} kwargs])\n(defn akw [{} args & {} kwargs])\n(defn only [& x {y 2}])\nPython\ndef foo(a, b=1, c=HyKeyword(\"c\"), d=None, *args, x, y=2, z=3, **kwargs): pass\ndef akw(*args, *kwargs):pass\ndef only(*, x, y=2):pass\nHere, optional args go in {} after the required positional args (like using &key). The *args part is assumed to follow that. So (defn foo [{} args]) means def foo(*args). \nThe & now splits the positional args from the kwargs. So anything following & is kwonly. It similarly uses {} for anything optional. So (defn foo [& x {y 2}]) means def foo(*, x, y=2):pass.\nAnd finally the kwargs follows that dict. So (defn foo [{& {} kwargs]) means def foo(**kwargs):pass, and (defn foo [{} args & {} kwargs]) means def foo(*args, **kwargs):pass. Not as nice as Python, but shorter than what we have now: (defn foo [&rest args &kwargs kwargs]).\nThis gives macros more (and more consistent) structure to work with. I'm not sure how fn=: should look here either, because it's already using brackets a lot.\nThis seems to handle &kwonly more elegantly than Option 1, but I don't think it's pretty overall.. I think it's better to save the brackets for macro destructuring syntax. Can we avoid them in the special form?\n~Option ?~\nHy\n(defn foo [a  b 1  c 'c  d None  #* args  x 1  y  z 3  #** kwargs]])\n(defn akw [#* args #** kwargs])\n(defn only [#*, x  y 2])\nPython\ndef foo(a, b=1, c=HySymbol(\"c\"), d=None, *args, x=1, y, z=3, **kwargs): pass\ndef akw(*args, *kwargs):pass\ndef only(*, x, y=2):pass\nThis version implies defaults by position and Hy model type. Given a symbol foo, if the next element isn't a symbol, it's the default value for foo. You can have symbols as default values by quoting them. #* and #** tag args and kwargs, like Python. & indicates kwonlys, which also have the implied defaults.\nWe'll probably get rid of the destructuring in the special form. #1410. But what about fn=:? It will have to detect what's a value and what's a target by searching the model at expansion time. If it has any non-quoted symbols, it's a target, e.g. in [q [a b] ['a 'b]], the [a b] part is a target, not the default for q.\n[Edit: that's not good enough, since we might want to use a non-quoted symbol as a default to refer to some other value in the environment. [foo ((fn[] bar))] is too awkward for such a common case.]. ### ~Option 3~\nHy\n(defn foo [a & b 1  c :c  d None #* args x & y 2  z 3 #** kwargs])\n(defn akw [#* args #** kwargs])\n(defn only [#*, x & y 2])\nIn this version, & separates required args from optional args, both for positional and keyword. Kwonly args have to follow the *, as in Python, with #*, for an omitted *args, like Option 1.. ### ~Option 4~\nHy\n(defn foo [a &optional b 1  c :c  d None &rest args &kwonly x &kwoptional y 2  z 3 &kwargs kwargs])\n(defn akw [&rest args &kwargs kwargs])\n(defn only [&kwonly x &kwoptional y 2])\nLike Opiton 3, but with familiar &words. Each &word clause is optional, but always goes in that order, like Python.\nWhy is this any better than the status quo? It looks pretty similar.\nThere should be one-- and preferably only one --obvious way to do it.\nNow any given arguments list has a single canonical form, up to the kwonly ordering, which I think doesn't matter. (If it does, then it'll be hard to avoid brackets--but see Option 1, because this version requries the required kwonly to all appear before the optional kwonly. Python does not require this. But I don't think it changes the meaning of the program.)\nIt avoids the special cases of #* vs #*,. &optional no longer uses brackets, avoiding another special case of foo vs [foo None]. &key no longer exists, but &optional's args now looks like &key's, but without the extra {} that didn't do anything, another special case (&optional vs &key) avoided.\nThe single canonical form makes it much easier to deal with in macros.\n. It looks like the ordering of kwonlys is inspectable. So decorator metaprogramming could potentially use that to mean something important. Hy has a lot of edge cases like this that should be corrected, but let's not make it worse. We're back to Option 1, the only option so far without this problem..  ### Option 5\n(defn foo [a &optional b 1  c :c  d None  &rest args &kwonly x .  y 2  z .  &kwargs kwargs])\n(defn akw [&rest args &kwargs kwargs])\n(defn only [&kwonly x .  y 2  z .])\n&kwonly now implies pairs. The . indicates no default. It's not allowed in calls anyway, so this should be fine. It's also no harder than typing brackets.. ### Option 6\nHy\n(defn foo [a &? b 1  c c  d None &* args x .  y 2  z . &** kwargs])\n(defn akw [&* args &** kwargs])\n(defn only [&* . x .  y 2  z .])\nPython\ndef foo(a, b=1, c=c, d=None, *args, x, y=2, z, **kwargs): pass\ndef akw(*args, **kwargs): pass\ndef only(*, x, y=2, z): pass\n&? replaces both &optional and &key. It implies pairs. The explicit None is required for optional args, as in Python.\n&* replaces both &rest and &kwonly. \n The first symbol following &* is the *args. You may omit the *args with a .. \n The remainder are kwonly pairs. Use the . to omit the default for required kwonlies. \n&** replaces &kwargs.\nI like this version best so far, and will probably implement fn=: using it.\nMaybe we could use something other than &?, &*, and &**, but I don't think it will get any clearer.. #### Option 6 b\nUse ., #*, and #**, instead of &?, &*, and &**, respectively. Probably requires #* and #** to have Hy models. #1366.\nOption 6 c\nUse . instead of &?, and change #*/#** to &/&& in all contexts.. macro-error is not documented, #1358, so I had to experiment. My complaint isn't that macro-error crashed, but that the repl crashed.. I think the REPL is crashable in multiple places, but whatever.\nYour minimal example from #1413 is fixable by catching BaseException (or just using an empty except:.) in those two places. But that doesn't fix the macroexpand or macro-error issues.. It actually appears to be from line 105\nI'm thinking we should just wrap the whole contents of this function with a try/except to show traceback.. We should also fix the cause. HyTypeError is assuming its expression has start/end values for line/column. This assumption is wrong, since macros can return expressions that weren't created directly from text. Models created this way will lack those attributes.\nHere's the real minimal example.\nHy\n=> (import [hy.errors [HyTypeError]])\n=> (raise (HyTypeError '[] \"bad\"))\nThis crashes the repl.\nThe easiest solution is to assign a default -1 for these four attrs in the HyObject class.\nThe nicest solution would probably be to find the right line and column values in some kind of source generated from the expression, probably the pretty-printed Hy models #1360 or maybe the astor-generated Python, if possible.. Related, yes. Perhaps fixing that would fix this too, but the repl isn't even mentioned in that issue.. The REPL should catch exceptions raised while printing things, even other exceptions. See how Python handles a similar problem?\n```Python\n\n\n\nclass BadException(Exception):\n    def str(self):\n        1 / 0\nraise BadException\nTraceback (most recent call last):\n  File \"\", line 1, in \n    raise BadException\nBadException: \nEach of the \"read\" \"eval\" and \"print\" steps must catch exceptions and print an appropriate error. The repl should *never* terminate due to an exception.. Here's an interesting illustration.\n=> (do (setv x \"Spam!\")(defmacro foo[] `(print ~x))(foo))\n  File \"\", line 1, column 49\n\n\n\n(do (setv x \"Spam!\")(defmacro foo[] (print ~x))(foo))\n                                                  ^---^\nHyMacroExpansionError: b'expandingfoo\\': NameError(\"name \\'x\\' is not defined\",)'\n```\nThis version fails even at the repl.\nClojure can handle this though.\nClojure\nuser=> (do (def x \"Spam!\") (defmacro foo [] `(println ~x)) (foo))\nSpam!\nnil\nEDIT: looks like the do isn't required.\n``Hy\n=> (setv x \"Spam!\") (defmacro foo [](print ~x)) (foo)\n  File \"\", line 1, column 48\n(setv x \"Spam!\") (defmacro foo [] (print ~x)) (foo)\n                                                 ^---^\nHyMacroExpansionError: b'expandingfoo\\': NameError(\"name \\'x\\' is not defined\",)'\n```. I don't think this is correct at all, considering how other Lisps work, hence the \"bug\" label. If this was the intended design, it's insane. I think we simply didn't notice since we mostly develop small programs at the repl.\nIt's very common and useful to design macros that delegate part of the expansion process to helper functions. Macros don't compose as naturally as functions do, so if you want to reuse macro expansion code, it's often best to put it in a shared helper function. Where are we supposed to put those if not in the same module?. I don't think this is correct at all, considering how other Lisps work, hence the \"bug\" label. If this was the intended design, it's insane. I think we simply didn't notice since we mostly develop small programs at the repl.\nIt's very common and useful to design macros that delegate part of the expansion process to helper functions. Macros don't compose as naturally as functions do, so if you want to reuse macro expansion code, it's often best to put it in a shared helper function. Where are we supposed to put those if not in the same module?. > Delegating the expansion process to helper functions in the same module works fine, provided you only invoke the macro after the file is compiled, rather than inside the very same file\n\n[...] I've never figured out how these gory details work in other Lisps, so I can't speak for them.\n\nGood to know, but Clojure doesn't have that restriction.\n$ echo '(defn f [] `3) (defmacro m [] (f)) (println (m))' > foo.clj\n$ clojure foo.clj\n3\nI don't think Hy needs to have it either.\n\nWhat semantics would you propose here? The way Hy currently works is that macro expansion happens during compilation, and only after a file is complied is any regular code executed.\n\nAt minimum, compile the files incrementally, one top-level form at a time. You don't macroexpand the whole file at once. It's almost like putting each top-level form in its own module, but we'd reuse the same module globals dict for each step. This is basically what the repl does.\nI'm not sure how to handle the case when a defmacro is not at top level, but I don't think you're supposed to do that in other Lisps anyway. They have macrolet for that. #900.\n. Why do we even have _compile_time_hack if we can't use globals from the same file?. Of course macro expansion occurs at compile time instead of runtime, that's the point of having macros in the first place.. I'll have to try that. It might be enough to bring #1328 back.. > asks for disambiguation if necessary? \nThere might be a better approach, but that isn't it.\nIt seems like a pain compared to this version. Why make the user take a second step when they already know what they want? Printing off all three would be a better approach, but if the docstrings are long enough, that would make the user scroll back to find the right one, which is a second step again.\nHow do other Lisps handle this?\nCommon Lisp has it worse because it also has a separate function namespace. You have to remember to supply a second argument specifying which namespace to use, and you have to remember the valid names for the second argument, and you have to remember how to quote the object properly. \nIn Common Lisp, you should be able to use (documentation documentation) to see how it's done if you forget, but this is an error. You might then think that (documentation #'documentation) would work, but that's an error too. You have to remember the proper invocation is (documentation #'documentation T), in order to learn the proper invocation in the first place. Hy could do it this way, but I think it's a really bad design.\nWith my version, all you have to remember is doc--(doc doc) tells you how to use it and the other two---#doc, and help.\nClojure's doc doesn't have this problem, because you can't have a macro and a function with the same name in the same namespace. This is better, but Hy can't work like that if we want to be able to shadow macros with functions.\nNot much help, but I'm open to more suggestions.. > accepting #foo as a request for documentation on the tag macro foo seems useful for newbies.\nLike (help #foo)? That's not going to work. Tag macros take precedence over even macros, so the compiler will try to expand it before help can get to it. Even quoting it like (help '#foo) doesn't work. The best you can do is (help \"#foo\") or #doc foo.. It was just the NEWS. We get conflicts in that a lot, but it's easy to fix.\nThis is probably just a stopgap until #1416. Then Python's help will work for everything.. It might also help Sphinx autodoc find them in the right module #1044.. @ekaschalk yes, the @builds-decorated functions in the compiler are the obvious place to put them. The problem is that one build function can compile multiple special forms. We could document all aspects in the same string, but that's not good for one-line summaries.\nPerhaps the @builds decorator could also take a \"docstring\" argument for each forms it compiles and store them somewhere convenient. (And append them to the decorated function's docstring too.) That would keep the docstring near the code that it documents.. Is this ready to merge yet? There's no NEWS change.. That's weird. Macros still work.\n=> (if #* a)\n*a\nTraceback (most recent call last):\n  File \"c:\\users\\me\\documents\\github\\hy\\hy\\importer.py\", line 201, in hy_eval\n    return eval(ast_compile(expr, \"<eval>\", \"eval\"), namespace)\n  File \"c:\\users\\me\\documents\\github\\hy\\hy\\importer.py\", line 30, in ast_compile\n    return compile(ast, filename, mode, flags)\n  File \"<eval>\", line 1\nSyntaxError: can't use starred expression here\n=> (print (if #* [1 2]) :sep \"/\")\nprint(*[1, 2], sep='/')\n1/2\nBut if you use the special form--\n=> (print (if* #* [1 2]) :sep \"/\")\nprint(if*(*[1, 2]), sep='/')\nTraceback (most recent call last):\n  File \"c:\\users\\me\\documents\\github\\hy\\hy\\importer.py\", line 201, in hy_eval\n    return eval(ast_compile(expr, \"<eval>\", \"eval\"), namespace)\n  File \"<eval>\", line 1, in <module>\nNameError: name 'if*' is not defined\nI don't think the compiler should work like that.. I suspect this is due to a compiler mutation #1542.. I'm confused by that test result. It's only failing on version Python versions 3.4 and 3.5. I only tested 3.6 before I pushed, but that failing test is not testing a file I changed. Did a bug sneak through to master in a recent change?\nIs it the -1 defaults in HyObject? That's a pretty deep change. I just did that to avoid repl crashes when developing. #1412. It doesn't need to be there. I'm going to remove that and see if it helps.. Yup. That was it.\nAny bugs you guys find will need a test. Nested functions have a known issue with default values, I need to expand the value, but protect the argument symbol. That's just not implemented yet.\nI'm also thinking that nonlocal and global should protect a symbol from expansion in the relevant scope. But Python is strangely flexible about where it allows you to put them, so finding them is tricky. That's not implemented yet either.\nThere might be other special cases of special forms that need special treatment that I haven't thought of yet. Python accepts dict lookups in place of plain identifiers in most places though, even in assignments and deletions, so most special forms just work.. Functions should be working now. I haven't tested &kwonly yet, but it uses the same implementation that &opitonal does, so it should work.\nFor now, using nonlocal or global on a let-bound symbol in a let body is an error. But the error message makes no sense unless you know the expansion.. > 12. Smile villainously and sneak off to your hydeaway and do unspeakable things.\nMadness? Bwa ha ha! So many branches in a 100+ line macro makes me uneasy. This is not design. It's organic growth from the vaguest idea of how this could possibly work. Lisp is good at that. But... the tests all pass! \nOnce I round out the test harness a bit, I'll try to factor out the symbol macros. If I can refactor this enough it might not seem so scary to others (or me in three months). And simplifying the compiler would also help a bit. I wouldn't have to check for so many edge cases if our special forms didn't have them. We can move some of the special form functionality into macros.. When pondering how nonlocal should work, I realized that we don't need the dict at all. Clever symbol renaming is enough.\nThis means the let macro creates ordinary locals now, without the overhead of a dict lookup. It's a cost-free abstraction. You can use let without guilt in nested loops!\nI also added more tests. That's almost everything I'd planned, but the global form still isn't supported properly. It will do the wrong thing in some cases.. With #1414, and #1416, would we still need _compile_time_hack?\n\ncauses an expression to be evaluated at compile-time.\n\nDoes eval-when-compile or eval-and-compile do that? #1229 . There's the global form.\nThe semantics were undefined, since let doesn't exist in Python. I think we're free to declare and document our own semantics, as long as they're sensible and consistent. \nNow, a global statement should protect its named symbols from let-expansion thereafter. But that only applies to the rest of the current protection scope. The test demonstrates this.. > symbol namespacing (#277), it's probably worth thinking about how that would interact\nThis let already handles the dot-access symbols. Either of the syntax proposals from #1407 could be made to work. The root _# symbol could be protected, or symbols with a / could be. I don't foresee any problems with that.\n\nThere may even be a nice to way implement let in terms of it.\n\nIt's not obvious how. As mentioned in #1407, we could implement dynamic variables with it, but that's different than the lexical variables implemented here. We'd probably call the dynamic form binding instead of let.. I factored out smacrolet for local symbol macros. It doesn't have its own tests, but let is using it now, and that's tested.. I'll look through those. #180 turned up an issue--macroexpand-all was using the context of the hy.contrib.walk module, not the current module, for expansions. So require wouldn't make a macro available to it, unlike macroexpand and macroexpand-1, which use the context of the calling module.\nI was able to make macroexpand-all work the same was as macroexpand, with calling-module-name, but it doesn't seem to work for let, which needs to call macroexpand-all during expansion, but in the context where the let invocation appears. It needs to know the environment it's being expanded in, or at least the name of the module.\nWe might need to change how defmacro is implemented a little to resolve this, but we were talking about that anyway #1416. I know Clojure macros have a hidden &env parameter. We might need something like that.. Looking at those other let-related issues from #1216--\n576 was about a dynamic let like in Emacs. We'd call it binding if we get around to implementing dynamic variables #1089 #1407.\n664, the motivating example works.\n703 works.\n1000 seems like @paultag was trying to do what I did. That looks a lot like my original dict lookup version. But doing it correctly takes a lot more code, and I've since advanced past that point.\n1055 was my issue, it's obsolete, besides implementing named break/continue. This let doesn't break break/continue/yield, or return. And async/await (though not implemented yet). should similarly have no problems.\n1056, my issue again, and we won't need a shim if we have a working let.\n1212 is still an issue. I'm expanding a binding that doesn't exist yet.. That should fix #1212.\nI also added an xfail for the issue about macros expanding in the wrong module context. The only way I can think of to fix that, short of deferring expansion to runtime (not worth it), is to require the user to pass the name of the current module to let. Not an expression that evaluates to it, the actual name, as a string literal, like (let \"__main__\" [...) I shouldn't have to do this, since that information should be known to the compiler at expansion time.. That last commit adds an implicit &name parameter to all macro definitions. The compiler will set &name to the name of the module it's expanding in, which allows the macro to use the proper context for preexpansions. And the let macro now does this.\nI'm not entirely sure if that's the best way to handle it, but Clojure does something similar.\nThis makes the error messages for macroexpansions less pretty. But we need to overhaul those anyway #1429. It may be a separate issue best handled in another PR. I've xfailed the relevant test.. Okay @hylang/core, I missed things before, but I think the new let implementation is ready. Care to prove me wrong?. > You seem to still have a few issues listed under ;;;; deferred.\ndefmacro deftag defclass import eval_and_compile eval_when_compile require.\nI think I should make import and requrie protected from any let mangling.\nI don't understand what scope eval_and_compile/eval_when_compile use. Should I let-mangle symbols in them or not?\ndefclass could perhaps be made to work like defn--expand to a def and class. But this causes problems with class names, which is why I'm not mangling the class name, nor its variable.\nIf defmacro and deftag become macros instead of special forms, they don't need special treatment. I think I could probably do this.\n\ndocumentation should explain that the let is implemented by mangling variable names, since this breaks introspection\n\nOK, documenting this doesn't hurt. On Python3, (locals) is effectively read only. It also gets polluted with Hy \"anon\" vars, which isn't documented either. It's still readable enough for debugging. That's why I wasn't too concerned with introspection.\n\nSimilarly, it seems worth mentioning that the variable exists at least until its parent function terminates\n\nHy special forms with anon vars also have this issue, and so do a lot of other macros that create gensyms with setv. Is the let documentation really the right place to put this?\n\nmight want to begin mangled names with an underscore\n\nI feel like the gensym implementation should already be doing that. We don't ever want to import * gensyms, since their names depend on the order of evaluation. Many other macros create these, and will have the same issue if used at toplevel. The let macro is the wrong place to fix it. If it's fixed in gensym, let-mangled names will also have the _ prefix. \nUsing the : prefix was a bit of a hack to begin with. Normally you can't create such symbols since it would be a keyword instead. \nThat doesn't stop you from clobbering a gensym with (HySymbol \":G_1235\"). Maybe it's enough to tell the user not to do that (on pain of Bad Stuff Happening), but I'm not sure how to enforce that gensyms are unique short of interning all symbols.\nBut a : isn't the only possibility. We could make gensyms start with _(), for example. You normally can't create symbols like that either.\n\nFinally, the complex way that let interacts with macros is not obvious.\n\nWhat do you mean? let shouldn't break any macros, since it pre-expands them. The bindings are only supposed to be meaningful at runtime, and nested macros only see the original symbols.\n\nbut class member definitions will neither assign to the unmangled name nor the variable introduced by let, but instead, to a class variable with the let-mangled name. [...] Is this a bug?\n\nThat does seem undesirable. The earlier dict implementation of let was better behaved here, as it would at least update the let binding. You can still do that with a nonlocal at the top of the defclass body.\nNote that a let form inside a defclass will also litter names to the class dict, but so would many other macros and special forms. The problem isn't really the extra names (in most cases--__slots__ and metaclasses might complain), but the inability to set a desired name. It's actually still possible using something like (assoc (vars) 'foo foo), but I feel like it shouldn't be that hard.\nPotential options\n1. document this behavior, and explain that nonlocal or (assoc (vars) ... is required.\n2. switch let back to the earlier dict implementation. This adds some runtime overhead for the lookups, (no worse than for self.foo) and changes the scoping rules a bit, but it's easy to do. But then how should nonlocal work on a let-bound name? It could be an error, or protect it thereafter.\n3. magic a nonlocal statement at the top of a defclass for any active let bindings. This would disallow let on Python 2. I'd want to remove the [] assignment block of defclass.\n4. magic a tuple display at the top of a defclass for any active bindings. This has no side effects, so it won't affect the class dict, but it will make assignments to any mangled names an error, since it's referenced before assignment. But this breaks nonlocal too.\n5. protect defclass forms entirely from let mangling. This means you can't read let bindings either, not even in the methods. Also easy, and less undesirable, but makes some legitimate use cases awkward.\n6. protect assignment targets at the top level of a defclass. Complicated. Assignment targets may be unpacking tuples, or a dict index, which may want to use the let binding too, and nonlocal should prevent this protection.\n7. detect if assignment targets are a let binding and raise a macro expansion error. I'm not sure if this is any easier.\n8. make let bindings constants, like in Clojure. Any attempts to assign to one of them would be an error. If you want to \"change\" its value, you have to shadow it with a new let binding. There are various ways to do this.\nI'm leaning towards option 2, with nonlocal on a let-binding an error. I'd make global on a let binding an error too, to be consistent.\n\nIs it a bug that (let [x 2] (defn f [] (setv x 3) x) (print (f)) (print x)) creates a new local x for f?\n\nNo, that is the intended behavior. If you want to assign to the let binding, you have to use nonlocal explicitly. It does get mangled even without nonlocal, but (outside of introspection), this is harmless.\n\nI thought let was supposed to override the usual scoping rules\n\nThe earlier dict implementation of let bindings were implicitly nonlocal in the entire let body. This version is supposed to work more like Python.. I implemented defmacro and deftag as macros. This probably conflicts with #1430.\nI changed the let implementation back to a dict. Applying global or nonlocal to a let-bound name is now an error.\nI changed the gensym format to start with _;.\n. (repr '[1 2 3]) is enough to show that, what does that have to do with HyMacroExpansionError in particular?\n=> (repr '[1 2 3])\n'\\x1b[36m\\x1b[22mHyList\\x1b[39m\\x1b[22m\\x1b[36m\\x1b[22m([\\x1b[39m\\x1b[22m\\n  HyInteger(1)\\x1b[36m\\x1b[22m,\\x1b[39m\\x1b[22m\\n  HyInteger(2)\\x1b[36m\\x1b[22m,\\x1b[39m\\x1b[22m\\n  HyInteger(3)\\x1b[36m\\x1b[22m])\\x1b[39m\\x1b[22m'\n=> (import [hy.models])\n=> (with [(hy.models.pretty False)] (repr '[1 2 3]))\n'HyList([HyInteger(1), HyInteger(2), HyInteger(3)])'. > Wait...why are we using bytes here?\nI have been wondering about that for a while, but priorities. Maybe it was for Python2 compatibility? Can we try not using bytes here, or do we need to have pretty off by default?. @kirbyfan64, the not not seems more reliable than bool or .__bool__ to me.\nBut as discussed in #1362, it can also be avoided in this case with an expansion like\n```Python\nx = 3\n_hy_anon_var_1 = 1\nwhile _hy_anon_var_1:\n    # Condition\n    print('hi')\n    _hy_anon_var_1 = x\n    if _hy_anon_var_1:\n        _hy_anon_var_1 = 1\n        # Body\n        print(x)\n        x -= 1\ncompiled from (setv x 3) (while (do (print \"hi\") x) (print x) (-= x 1))\n```\nif you prefer.. The problem with delimiters is that they may appear in the output.\nA long, random delimiter, like a UUID, is unlikely to cause conflicts, but we probably don't want that to appear in the terminal. If emacs can hide this, maybe it could be enabled via a command-line option.\nYou can already distinguish stdout from stderr, right? Maybe we should open a third pipe just for the --spy output. If emacs can create one, it could be a command-line argument to the hy executable, like --spy-to mypipe or something. I'm not sure how complicated this is to set up in a cross-platform way.\n. @kirbyfan64, we're talking about seting up highlighting for hy-mode in emacs, see hylang/hy-mode#46.. @ekaschalk try this branch. Does this work for #1436? Do the color codes come through on Windows? hylang/hy-mode#46\nI'll add some tests and docs once we settle what this should be doing.. I re-implemented colorama's deinit and amended the commit. See tartley/colorama#145.\n@ekaschalk, does this version show the color codes on Windows?. That's weird. The tests do not fail on my machine. I can't imagine how those changes could cause all those test_bin errors, as none of the old tests use the new features. I wonder if we've corrupted the cache somehow.. I tried it on a Linux VM, and it failed due to import colorama. I guess that only installs on Windows?\nIt should be working now.. > If you want stderr vs stdout italicized, then implementing that as another UUID delimiter would make it trivial, otherwise I will table that addition for now.\nThat probably won't be possible. The user is free to print to stderr. It's not just for exceptions we could catch in the repl. Maybe we could monkeypatch sys.stderr with a custom class, but that would interfere with colorama (and who knows what else). And threaded code could even cause stderr to be interleaved with stdout, in ways not predictable in advance.\nIf emacs can't distinguish stderr, could it read from some other file instead? I think we could probably open a pipe in a cross-platform way on the Python side, even if emacs can't do it. If we can make that work, then we don't need the --spy delimiter either. It could just be another pipe.\nWe could also try a network loopback instead of file pipes. I think that's how nrepl does it.. The UUID delimiter feels like a dirty hack. I'm not particularly attached to it, but I don't really have a better idea that doesn't use either pipes or network sockets. But I think Spy[x]: has the same issue. What if it appears in the output? Maybe you put it last so the Spy[x]: part follows the Out[x]: part and you only count the last one.\nBut say you put a repl session in a docstring for a function, including Spy[x]:. Not an unreasonable thing to do. Then you want to test it out, so you paste it into the repl. Now only the part following the last Spy[x]: in the docstring gets highlighting. And astor outputs the docstring with triple quotes, so the rest of your function looks like a string literal. It's not that easy.. Python\n=> (get Out \"of town\")\nOut['of town']\nIf the Out[x]: has that trailing colon, and you check for strings, I think it works.. Agreed, this PR is obsolete. Move discussion back to #1435 or new issues as applicable.. It looks like only compg has the correct expansion. compl and comps need to set a [] or #{} to a gensym, and then .append or .add to it (instead of yield) and finally return that; or it won't behave consistently with the expression version. And it needs to since it could expand to either. I also expect it will perform better, since this is how Python's authors chose to compile these expressions.\nAnd dcomp returning the second-to-last expression as the key is kind of weird given the implicit do, but I'm not sure what to do about this. A : separator like Python? Hy's dicts aren't written like that. Return a tuple or cons pair? But then we can't expand it to an expression. Get rid of the implicit do? But then how could an explicit one possibly work?\nWe don't need two types of special forms for comprehensions. list-comp and friends should be removed. But then compl could be named list-comp. I don't might having a shorter name for something we expect to use often, but s-comp seems a lot less confusing than comps, which could easily be confused with comp.\nAnd finally, the syntax doesn't seem to be compatible with for, which means only the comprehensions get it.. > I think those two strategies should have the same effect. Can you provide an example of inconsistent behavior under the current implementation?\nPython\n=> (comps :for x [1 2 3] (yield x))\n{yield x for x in [1, 2, 3]}\n<generator object <setcomp> at 0x000001FBC90DFEB8>\n=> (comps :for x [1 2 3] 42 (yield x))\ndef _hy_anon_var_1():\n    for x in [1, 2, 3]:\n        42\n        yield yield x\nset(_hy_anon_var_1())\n{1, 2, 3, None}\nThe 42 is just to force the different expansion. They should produce the same result, but they have dramatically different answers.. > I think those kinds of constructs are actually a bug in CPython.\nI think that's part of the spec. Comprehensions are defined to work that way. It's not just CPython. PyPy does the same thing.\n```Python\n\n\n\n\n{(yield x) for x in [1, 2, 3]}\n at 0x0280bdf0>\n```\nAnd besides, I think it performs better, which is why the Python authors chose to compile it that way.\n\n\n\nSo you'd prefer l-comp, s-comp, d-comp, and g-comp? (Honestly, I just picked the current names so they'd be alphabetized next to each other in the documentation etc.)\n\nI suppose. But I think the current names (list-comp etc.) are fine. If you want them to start the same way, maybe for-list, for-set, etc. could work. It's not much shorter, but the initial :for keyword is redundant. You're putting the generating expression at the end instead of the beginning like Python does. When would you ever not start these with :for? If you eliminate it, that name makes sense. Couldn't (compl :for x [1 2 3] (* x x)) be written like (for-list x [1 2 3] (* x x))?\n\nRight. I'm not suggesting any changes to for here.\n\nBut I am. I've thought for some time now that Hy's for should act like doseq, including the modifiers, and Hy's comprehensions should have them too. They need a consistent syntax.. > Yes, but not, e.g., (compl :for x [1 2 3] (f) :for y [1 2 3] (* x y)).\nI was suggesting (for-list x [1 2 3] (f) :for y [1 2 3] (* x y)). Only the first :for is redundant. But on second thought, special cases like that make macros that expand into comprehensions more difficult to implement. I think Clojure's for comprehensions do a better job here--\nClojure\n(for [x [1 2 3], y [1 2 3]] (* x y))\nThe :for keyword (as compl means it) is implied unless you use another modifier. Make the common case easy.\n\nI guess I've never seen the logic in that, beyond \"Clojure did it\".\n\nWhy do we have a nested for construct to begin with? Python doesn't have it. We got it from Clojure. We just didn't finish it. If you'd prefer to get rid of for altogether and just use for* (we'd rename it to for) that works for me too, I guess. You'd have to sell it to another core member. But when nesting loops, sometimes you need to break/continue early. Hy's current approach is no better than for*. You have to nest the for expressions the same way, losing any advantage over for*.. > It's out of scope of this PR, though.\nNice try, but it's certainly not out of the scope of #1371, which this PR purports to implement.\n\nWhere did the (f) go?\n\nI must have overlooked that when I copy/pasted. Clojure's not that in to side effects, but we can still do them--\n```Clojure\nuser=> (defn f [] (println \"called f!\"))\n'user/f\nuser=> (vec (for [x \"abc\", y (do (f) \"xyz\")] (str x y)))\ncalled f!\ncalled f!\ncalled f!\n[\"ax\" \"ay\" \"az\" \"bx\" \"by\" \"bz\" \"cx\" \"cy\" \"cz\"]\nPython\n=> (defn f [] (print \"called f!\"))\ndef f():\n    return print('called f!')\nNone\n=> (compl :for x \"abc\" (f) :for y \"xyz\" (+ x y))\ndef _hy_anon_var_1():\n    for x in 'abc':\n        f()\n        for y in 'xyz':\n            yield (x + y)\nlist(_hy_anon_var_1())\ncalled f!\ncalled f!\ncalled f!\n['ax', 'ay', 'az', 'bx', 'by', 'bz', 'cx', 'cy', 'cz']\nAnd really, so can Python's expressions.Python\n\n\n\ndo = lambda *a: a[-1] if a else None\nf = lambda: print(\"called f!\")\n[x+y for x in 'abc' for y in do(f(), 'xyz')]\ncalled f!\ncalled f!\ncalled f!\n['ax', 'ay', 'az', 'bx', 'by', 'bz', 'cx', 'cy', 'cz']\n```. >  I wouldn't want to make other changes you request only for you to reject it anyway.\n\n\n\nThese aren't the changes I requested in #1371. It's your own made-up syntax.\nAs for the changes I requested in this PR, #588 is still an issue. This is probably a good start on fixing it even if we stick to something closer to the old syntax for now, and my requested changes would still be needed for that. I'm not suggesting you throw it all away.\nI want Hy to have a coherent, consistent design. I think about changes in the context of the whole language. I'm not on board with the new syntax because it doesn't fit well. Either it has to change, or Hy does.. Hy currently has some bugs.\n\ud83d\udc1bThe current reordering of statements is a bug. Evaluation must happen in the order written, and statements must be repeated properly in comprehensions. #588. The fix probably needs to be at the compiler level, since that's the part of Hy responsible for making statements act like expressions.\n\ud83d\udc1b The current syntax is unable to express early filters in comprehensions. #848. Thus we must change the syntax.\nThe proposal is a clear improvement over the broken status quo because it fixes these two bugs. I'd have to fix these myself (eventually) if no-one else does. We can't (eventually) release Hy 1.0 with these outstanding.\n\u2714\ufe0f The .append / .add / dictionary[key] = value setup is necessary for consistent behavior. Any final solution would have this.\n\ud83c\udd97 The names lcomp, scomp, dcomp, and gcomp are OK. I don't really need the hyphens either. They're reasonably short and less likely to be confused with comp. I think we can do better. \n forlist, forset, fordict, forgen. These have no chance of confusion with comp and are ordered together alphabetically like you originally wanted, but they're a bit longer to type at 6-7 characters instead of 5. I don't think that's a big deal for a special form name.\n lfor, sfor, dfor, gfor. I wouldn't shorten forset to fors for the same reason I wouldn't approve of comps but sfor works, so if you really care about length more than alphabetizing, these are even shorter at 4 characters instead of 5.\n\ud83c\udd97 The square brackets for the dict comprehension pair seems OK to me. I don't particularly have a better idea either, but maybe someone can come up with one.\nBut the proposal is still noticeably sub-optimal and I'm concerned that if I approve this partial fix, we'll lack the will to clean it up ever. Then we'll be stuck with a proliferation of incompatible macros to fix it downstream or just have to live with it.\n\u26a0\ufe0f The proposal makes up a new syntax instead of looking like Python, Clojure, or Common Lisp--the guidelines we've been using for everything else. I'd let this slide if the syntax is sufficiently elegant, but it's not.\n\u26a0\ufe0f The first :for in the proposed syntax is redundant.\n\u26a0\ufe0f Approving this would probably prevent me from doing #1371, which adds Clojure's :let and :while modifiers to comprehensions, and to our nested for macro.\n\u26a0\ufe0f A deep change to syntax like this should probably have input from more of @hylang/core in an issue before a PR. I'd be more confident in our final choice if I'd seen some alternatives.\nBetter late than never. Thoughts people? How do you guys want this to work? Given that we need early filters for full Python compatibility, and want :let and :while capabilities (or equivalent) in both comprehensions and the nested-for (or doiter #1125) macro, what syntax should Hy have for comprehensions?\n. > * When in doubt, defer to Python.\n\n\nIf you're still unsure, defer to Clojure.\nIf you're even more unsure, defer to Common Lisp.\n\n\nI was only looking at Python and Clojure before, but have since discovered that Common Lisp can do comprehensions with its loop macro if you use the collect word. (This is very different from Clojure's loop/recur. It's more of a DSL for loops.) Studying it has been enlightening. For example,\n```Lisp\n (loop for i from 1 to 5 when (oddp i) collect ( i i))\n(1 9 25)\nis likePython\n\n\n\n[i*i for i in range(1, 6) if i%2==1]\n[1, 9, 25]\n``\nThat wasn't too bad, but I don't think we should copyloop` exactly. It's complex, verbose, and Python already does some of it better. But it did give me some ideas.\n\n\nI'd be more confident in our final choice if I'd seen some alternatives.\n\nI've been experimenting with possible syntax. To match Python, we must have, at minimum,\n sequential binding from an iterable (for/in). This is like a map().\n filtering (if). Like a filter(). \n* And the loops can nest and the filters must be allowed between them.  #848\nAdditionally, we want\n early abort (like Clojure's :while) #1371\n new bindings (like Clojure's :let and Haskell's let) #1371\n @Kodiologist wants arbitrary expressions at any point. Not sure why.\n And I want comprehensions to be consistent with for.\nAnd finally, \n* We want the common case to be easiest!\nConcrete example time. If we start with the verbose Common Lisp loop DSL style as applied to Hy, we get something like\nClojure\n(for\n  :for i :in (range 6)\n  :do (f)\n  :if (even? i)\n  :let k (* i i)\n  :for j :in (range k)\n  :while (< k 5)\n  :list [i j k])\nHere I'm using for, since name loop was already taken for loop/recur. It fits because that's what Clojure calls its comprehensions. I'm also using :list instead of Common Lisp's collect, since Hy needs to be able to make a :set too. Genexprs would use :yield. Dict comprehensions could use :key/:val or even just :dict. Normal side-effecting for loops would use a :body. So it doesn't conflict with Python's use of for either and we can get rid of our for macro.\nIn the example, :let k (* i i) is short for :do (setv k (* i i)) and :while (< k 5) is short for :do (if (< k 5) (break)), and :if (even? i) compiles like :do (if (even? i) (continue)). :if would compile to a comprehension filter when possible, of course.\nThe above syntax is too verbose for my taste, but very readable. Can we simplify it?\n:for/:in is redundant. One could imply the other. (Like how :key/:val could be just :dict.) @Kodiologist's current proposal just uses the (longer) :for. Python got comprehensions from Haskell in the first place. Haskell just uses the (shorter) :in (written <-). And Haskell doesn't need the :if, since it's implied when not using <- or let.\nBut let's make the common case easy.\n@Kodiologist's current proposal gets this exactly backwards, making the :do implicit, even though \"arbitrary expressions at any point\" is the least used of all our desired points. So it's noticeably suboptimal for comprehensions.\nI use comprehension for mapping far more than for filtering, so let's make the always-used for/in implicit instead. Besides, (for :for looks awkward.\nClojure\n(for\n  i (range 6)\n  :do (f)\n  :if (even? i)\n  :let k (* i i)\n  j (range k)\n  :while (< k 5)\n  :list [i j k])\nThe next most common is the filter, but :if is quite short, and it matches Python's keyword here.\nI think this is pretty good now, but can we do any better?. Ah, no. I removed a paragraph explaining that better. The :body would collect all remaining expressions in the for. So instead of (for [x xs] (foo x) (bar x)), you'd write (for x xs :body (foo x) (bar x)).\nI considered just using :do, but then you'd need (for x xs :do (do (foo x) (bar x))), hence the :body word.. On second thought, perhaps the final :do could be special-cased to act like the proposed :body if there isn't another collect word (:list, :yield etc.) present. Then you could write (for x xs :do (foo x) (bar x)), which is pretty similar to what we're doing now. Then we wouldn't need :body at all. I'm not sure if that's more confusing or less, since the other :do words would only get one expression.. Regex is your friend.\nWe can mostly keep compatibility with the current for syntax by using Clojure's approach.\nClojure\n(for :list\n  [i (range 6)\n  :do (f)\n  :if (even? i)\n  :let k (* i i)\n  j (range k)\n  :while (< k 5)]\n  [i j k])\nHere we put the collect word at the top, since you only ever need one of them. It might actually be easier to compile. But to distinguish the body from the implicit for/in, we add square brackets. Here's the side-affecting version.\nClojure\n(for :do\n  [i (range 6)\n  :do (f)\n  :if (even? i)\n  :let k (* i i)\n  j (range k)\n  :while (< k 5)]\n  (print i)\n  (print j k))\nBut now that the keyword is right next to the function name, we can just merge them, so\nClojure\n(forlist\n  [i (range 6)\n  :do (f)\n  :if (even? i)\n  :let k (* i i)\n  j (range k)\n  :while (< k 5)]\n  [i j k])\nLikewise forset, fordo, etc. or just plain for instead of fordo, really. Now most loops written in the old style will work. But you do still have to fix the :if filters. But we were proposing that anyway. It can't be helped! The current syntax is inadequate. #848. We need early filters for reasonable performance.. > call it :setv\nThat seems OK to me, if that's how we actually compile it. Python can already emulate :let to some degree by using for in a length-1 sequence. But it might actually be less overhead to use setv in all cases, even if that means creating an explicit generator function.\n\nmaintain continue and break behavior in for loops,\n\nWe currently compile\n(for [x xs y ys] [x y])\nTo\nfor x, y in ((x, y) for x in xs for y in ys):\n    [x, y]\nBut up to about version 0.9 we used to compile it like\nfor x in xs:\n    for y in ys:\n        [x, y]\nThe main reason for the change was Python's lack of a labeled break/continue. Even with 3+ loops, we could only really pick the outer or inner, so which loop should that break? It made more sense to break the outer loop (the whole for form) than the inner one, especially since we didn't have return at the time, which is the usual way of breaking nested loops in Python.\nBut we have return now, and with :if and :while (and :do) available, we can break any of the loops we want. So I think it makes more sense for a break in the body to break only the inner loop now.\nThe old nested-loop style seems to play nicer with the new control words (like :setv?) anyway. If we want a :do available at any point in the loop, it should use the same scope as the body.. A big motivation for updating Hy's for to be consistent with new comprehension features is that it makes it easy to build macros for comprehensions over custom data structures. For example, \nHy\n(defmacro/g! fordoto [coll for-args method]\n  `(do (setv ~g!coll ~coll)\n       (for ~for-args\n         (-> ~g!coll ~method))\n       ~g!coll))\nNow you can emulate a normal list comprehension like\nHy\n(fordoto [] [x (range 10) :if (odd? x)]  (.append x))\nNote that our comprehension control words (like :if) \"just work\" \"for free\", because for has them too.\nWe could just as easily use some custom object instead of [] if it has an .append method. But we can use a different method too.\nHy\n(fordoto [] [x xs :if (odd? x)  y ys :if (even? y)] (.extend [x y]))\nThis version works like my chain-comp. It flattens one layer. (chain-comp is a very useful construct in it's own right, because monads. It appears in many languages with various names.)\nfordoto is pretty general, but expects mutable objects. Immutable collections would be done differently. And if you use them a lot, you might make a dedicated comprehension so you don't have to spell out the method names every time, e.g.  a forvector macro or something.\n\nFor the versions other than plain for (a.k.a. fordo), remove the square brackets. They're redundant, because there can be only one returning form.\n\nIt seems awkward to remove square brackets from the above fordoto. Instead of [coll for-args method] you'd just have [coll for-args]. I guess it could be done though--manually pop off the last for-args. And custom loop macros might want to add custom keywords too. That might actually work better if comprehensions don't have the square brackets. One can always use a keyword instead. I'm not sure how I feel about this, but it seems like it could work.. > Okay. So (for ...) will generate nested loops, with no function declarations, whereas forlist (or lfor) and the other comprehensions will make an anonymous function, and hence, Python 3's distinction between leaky for loops and non-leaky comprehensions will be maintained. But in both cases, break and continue will refer to the innermost loop.\nSounds right.\n\nShall I go ahead and implement this, then?\n\nYes, but details may come up after you start. Once you have the for implemented it seems like you could implement the generator functions using that. But for is a macro now. If you move it to the compiler and get rid of for*, I might have to adjust let. I'm not sure of your implementation approach.\nTry it. I approve of the syntax, even dropping the square brackets, I think.. > Yeah, I think for will have to be a special form.\nIt could probably still be done as a macro. I think the compiler can write code containing for and then do a macroexpansion pass on it. I'm not sure if that's easier, but it wouldn't affect let. But I might have to adjust it for the new comprehension syntax anyway. Hmm.. If it's that difficult, I'm rethinking having comprehensions in the compiler at all. I kind of feel like we should be able to output comprehension AST in case a library uses it (like astor), but we'll always have some small differences from raw Python AST due to Hy anon vars required to make statements expressions and such, so I kind of doubt we'll have 100% compatibility with that kind of deep introspection. In the rare case it's really needed, one can always write that part in Python, I suppose.\nAt the bytecode level (at least in CPython), comprehensions are just sugar for generator functions. If we implement them the same way as the bytecode compiler in macros, there should be no performance impact.\nI think macros are a lot easier to write than special forms. Given the enhanced for macro, I could already implement the base comprehensions in terms of the abovefordoto macro.. I wrote xi in the first place #879. I'd support doing it exactly like Clojure does, but that was controversial. Clojure used #() with % parameters, instead of (xi) with x parameters. One-liners work fine, but indentation makes more sense if the function is in the function position where it belongs.\nHaving worked with it a while, I think xi makes much more sense as a tag macro. The minimal change would be #xi() with the same x parameters. But it would be just as easy to do something like #%() with % parameters. We can't use % as the first argument like Clojure does (since that's already Python's  % operator), but the explicit %1 is fine.\nTag macros currently work about the same as normal macros but I think some edge cases are still broken. How do you require a tag macro from another module? I don't think we've implemented that properly. We can't possibly provide a tag macro in a separate module without that. But we could certainly move it to core.\nI was also thinking of changing them to work more like Clojure tagged literals. But Python doesn't make this easy. We could instead make them more like Common Lisp reader macros, since we have more control at the compiler level. But we don't exactly have a reader to begin with.. > I require them via * though, I'm not sure if they can be required by name.\nIt looks like they can. Maybe that got fixed while I wasn't looking. Or maybe one of my weird experiments made me think it was broken. If you have a normal macro of the same name, you get both though. I'm still not confident we've thought this through properly, but I did the PR for making xi a tag macro.\n\nrequire isn't transitive unlike import\n\nYeah. It alters the state of the compiler, but has no effect on the resulting module object. Unlike import. Macros don't exist after compilation. Maybe #1416 could help with that.\n\nthat xi breaks the rule that you can look at the first sexp of the form and know what's happening.\n\napply kind of does that too. How do other Lisps handle it?\n\nI specify toolz implementation because it will curry kwargs as well.\n\nWhat do you mean? I'm pretty sure Python's functools.partial implementation does that. Maybe we could import functools into core like we do with itertools.\n\nI'd also support flip getting added but saw it was ignored for lack of support. I'd say now that more operators are shadowed, its usecases are a bit more diverse\n\nHow should it work though? Lisp doesn't distinguish operators from functions. Python's binary operators have all been generalized to n-ary operators somehow.\nDo we reverse the arguments list? Do we rotate them? Left or right? Do we swap the first two and leave the rest in place? Do we force it to be a binary function and raise an error if there are more arguments? How do we handle &kwargs? These all do exactly the same thing when n=2, but are completely different when n=3 or more. It's not at all obvious what \"flip\" means to a ternary operator. xi was explicit, at least.. Don't use sum like that.\n\nThis function is intended specifically for use with numeric values and may\n    reject non-numeric types.\n\nIt's a mere implementation detail that this works at all. A type checker has every right to flag that use, and other Python implementations (even later CPython implementations) might not support it.. In Python, dicts are iterables. Their iterator returns the keys. In a for loop, this is more useful, since you can still use the keys to get the values via lookup. If you want the pairs, you have to use .items.\nClojure arguably handles this more consistently.\nClojure\nuser=> (seq {1 2, 3 4})\n([1 2] [3 4])\nThe default iterator is like Python's .items.\nSo how does Clojure flatten maps?\n```Clojure\nuser=> (flatten {1 2, 3 4})\n()\nuser=> (doc flatten)\n\nclojure.core/flatten\n([x])\n  Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat sequence.\n  (flatten nil) returns an empty sequence.\nnil\nuser=> (flatten (seq {1 2, 3 4}))\n(1 2 3 4)\n```\nIt doesn't.\nFlatten should support third-party iterables too. How can you treat them consistently if you only make dicts a special case? This is how Python is. How do you want this to work?. It looks like Clojure keeps maps in one piece when they're not the top level.\nClojure\nuser=> (flatten [10 20 [{1 2, 5 6} {3 4}]])\n(10 20 {1 2, 5 6} {3 4}). Clojure also keeps sets in one piece.\nClojure\nuser=> (flatten [10 #{1 2 3}])\n(10 #{1 3 2})\nI don't think \"iterable\" is the right criterion. The appropriate abc is probably Sequence, which is iterable with a specific ordering.. Except strings or bytestrings.\nIs an OrderedDict a sequence?\n```Python\n\n\n\nisinstance(OrderedDict(), abc.Sequence)\nFalse\n``\nPython says no.. I had to cancel the test build. Thepypy` test was running for over an hour. That's not supposed to happen. All the others passed though, strange.. You mean, \"Does clojure-mode?\" It does, I checked. Should Hy? I'm less certain. This is not builtin syntax. This is not even a core macro. \n\n\n\nBut, if we conventionally used %-prefixed anaphors in other macros (as Clojure does), then highlighting such symbols would make sense. It does improve readability. But some might argue the old xi symbols were more readable, because that's what won out in #879, even though I presented % symbols as an option.\nWe could use #xi with the old xi symbols. Maybe it's more readable, but it's also more likely to interfere with user symbols. Names like x1, x2 could totally come up. Tradeoffs.. I added a %** anaphor for the &kwargs parameter. This makes #% usable for partial application even if the function takes keyword arguments. I also changed the &rest parameter from Clojure's %& to %* for consistency.\nFor example, #%(foo #* %* #** %**) would do the same thing as function foo, regardless of its signature.. Hy can't be my top priority all the time. I'm busy with other things right now, but this seemed like a really easy fix, especially since I wrote the code in question in the first place.\nIt's a tag macro, so I've generalized #% to work on arbitrary expressions. \nFor example, you can just use #%[%1 %2] instead of (xi identity [x1 x2]) like before.\nClojure would have to use #(identity [%1 %2]) or #(vector %1 %2) for that, but it saves the extra % in the more common case of a normal s-expression. We'd have to build function literals into the compiler to do it Clojure's way.\nIt should be ready for review now.. > whitespace\nDone.\n\nInstead of \"presence\n\nI reworded it, but not quite that way.\n\n(import hy)\n\nYep.\n\n(flatten [expr])\n\nMore elegant, I like it.\n\nold debugging code\n\nRemoved.\n@Kodiologist, how about now?. I'd prefer we use 0.6 if possible. It has some nice improvements.. I tried updating Hy to astor 0.6, but it's choking on NaN.. > compile NaNs to an expression that evaluates to NaN such as 1e1000 - 1e1000. \nIt is not as easy as I expected to make the compiler do that. @Kodiologist I've allowed edits from maintainers if you want to use this as a starting point to try compiling NaN to expression.\nAlso @olasd tells me that we've had to patch astor before. I'm not sure how to go about that either.. @Kodiologist, Travis is showing a failing test with your update.. I think I got it. That last failure wasn't due to NaN. Astor 0.6 added an extra terminating newline to our disassemble output for some reason. It's not exactly wrong, so I just updated the tests to expect that.. Feature, in the sense that it was documented to work that way. Imports are always hoisted to Python scope. You can use __import__ instead if you need it to work in the local let scope, though I can't imagine this happening often, it is also documented.\nlet could probably be modified to work differently for import statements if you prefer. This shouldn't interfere with the other forms. But it's not easy. Python syntax doesn't allow dict lookup targets in import statements. You'd have to expand to something else as a workaround, and it would have to be valid for any possible import form.\n  . Can't we close this now that Astor 0.6.1 fixed the compatibility issue?. Feature. That m macro is not hygienic. \nA hygienic macro would have used a gensym for that function name instead of a symbol like recur that could accidentally capture an identifier meant for something else. On the other hand, loop is explicitly documented to be anaphoric--the capture of recur is part of its contract.. That changed the semantics. recur is supposed to be a function call. The old loop/recur can shadow variables. Yours clobbers them.\nIf we add this example to the tests,\nHy\n(loop [x 3]\n  (loop [x x]\n    (when (pos? x)\n      (print x :sep \" \")\n      (recur (dec x))))\n   (when (pos? x)\n     (print)\n     (recur (dec x))))\nMy version (and Clojure's) prints out\n3 2 1\n2 1\n1\nBut yours prints\n3 2 1\nUsing exceptions is an interesting approach. I had proposed something similar with label/break. #1055 \nI'm not sure about the performance overhead of an exception every loop, but Python function calls have significant overhead too. \nMaybe we could add more looping options like these. The loop module seems like a good place for them. But it would be a new PR.. 1. They turn out to be useful in their own right. In the fairly common case that a loop takes up the whole function body, it's easier to tack an r onto the defn (or fn) than to add a loop form. I had originally deleted defnr altogether. It was part of the old implementation, but turned out not to be required, and only added a useless assignment in the expansion.\n\nI'm not sure if either is correct. The doc is the original intent of the author, but the implementation didn't quite meet the spec before being abandoned. I've also found deeper flaws, e.g. \n(loop [] (print 'recur))\nprints a gensym.\n\nI might have to rewrite the whole thing from scratch.. I think this is not the right approach, so I'm closing it. But the issue still needs a fix #1465 . I tried a few symbols, and I think legibility is a problem, especially for gensyms. I thought about how we could change how we construct the gensym names and realized that it's better to change the mangling system.\nFor example, the gensym Hy, world mangles as\n_hyx_X3bXHyX2cXX20XworldX7cX1240.\nBut I think we could instead mangle it to something like\n_hyx_3B2C207C_XHyXXworldX1239\nwhich is much more readable. Here I've moved all the hexidecimal codes to the front, and then replaced the invalid characters with a single X each. The unmangle function could put them back together like this:\n```Python\n\n\n\nfrom base64 import b16decode\n'' + 'XHyXXworldX1239'.replace('X','{}').format(*b16decode('3B2C207C').decode('utf-8'))\n';Hy, world|1239'\n``\n. Actually, it might be even better to useas the elision marker instead ofX. e.g._hyx_3B2C207C__Hy__world_1239.\nAn actualwould have a corresponding5Fin the hex codes.. I'm not sure if the?tois_` mangling is worth keeping either, but I'd like to hear what the others think.\n\n\n\nWe could use *1 *2 *3 as the repl history variables like Clojure instead of _. #1341 \nBut I am worried about the ambiguity introduced by treating - and _ as the same sometimes, but not other times. It's not reversible. If we don't give - special treatment and use my suggested format above, foo-bar would render as hyx_2d_foo_bar, which is quite legible, but not something you'd want to import in Python. Perhaps when producing things for Python's use you simply write foo_bar instead.\nAnother possibility is to swap - with _ before mangling, and swap them back when unmangling. But this means you must write magic dunder/private names starting with -, which is easily confused with negation. See #1062 for a discussion of why _ is preferable as a prefix. Perhaps leading and trailing _ could be special cased (like ? is now) to avoid this issue but still be reversible.. > But _ is a common identifier character, whereas X is uncommon.\nTrue, but why does that make X a better choice?\nUnderscores are more legible than X's.\nI use the astor output from hy --spy all the time and I need to be able to read the identifiers. It's the one non-alphanumeric character allowed in Python2 identifiers. In the common case, you don't have to encode it anyway, and when you do, it still shows up as an underscore in the part you actually read!. > it could make sense to change the gensym\nI picked the current gensym format for legibility when debugging macro output with astor. I'd certainly consider improvements to it after we settle the encoding format. But what's best for gensyms depends on that, so let's figure it out later.\n\nundo hyx_ when necessary\n\nI think it makes sense to treat a symbol containing a hyx__ prefix like an illegal identifier. That is, encode it again. It's just like double-escaping backslashes. So hyx__foo might be encoded as hyx__hyx__foo. Make it a 1:1 invertable function, so there would always be an unambiguous unmangling for any identifier.. > 1. Because it means fewer characters have to be escaped. So, some_l\u221eng_identifier becomes hyx_E2889E_some_lXng_identifier instead of hyx_5FE2889E5F_some_l_ng_identifier.\nAre you concerned about the greater length when using a common character? \nBecause of runtime performance? Identifiers are interned in Python. Length has no effect. \nBecause it causes lines to wrap? That's kind of unavoidable with astor, but we could use base64 instead. I preferred base16 because it's easier to lookup the Unicode by hand if necessary, but I don't feel too strongly about it, since we're providing an unmangle function.\nBecause it's harder to type from Python? Exports to Python should not use such names, but again base64 is an option.\n\n\nBecause when you see an X in a hyx_\u2026 symbol, you can be pretty sure it's something else, whereas a _ is as likely to be a _ as something else.\n\n\nAnd you'd still have to check for a 58 to be sure it's not really an X. It's true that X is a rare letter in English, but it's a common letter in mathematics, so I'm not sure if it's as uncommon as you think it is in code.\nBut if that's your concern, wouldn't a rare Unicode character be a better choice? Python2 requries pure ASCII, but we're using different mangling rules for Python3 anyway. To be legible, it ought to be punctuation mark rather than a letter (or at least look that way), but valid in a Python3 identifier. Perhaps U+2054 \u2054. These are also easier to count than underscores.\nMaybe you want Python3 to use pure ASCII too for some reason? I can kind of understand not wanting force anyone to use Unicode in the command-line dubugger. But you can copy/paste identifiers or even the elision character if you're constructing them. You can even use strings and type out \\u2054 in Python.\nI'm mainly concerned about losing my readable astor output for debugging.\nWe could instead avoid forcing Unicode on those who don't use it, but still use it as the elision character. At least for ASCII, we could replace invalid characters with a more mnemonic underscore-quoted substring via lookup table, e.g. + with _plus_ or _add_ or _t_; (space)/__ or even _sp_; ?/_eh_ or _qMark_, etc. Clojure does something similar to make valid Java identifiers. There may be some tradeoff between obviousness and length, but this is much more readable than meaningless hex codes.\nSuppose you wanted an increment function named X+1 and an inverse function named X-1. Under the proposals they might look like\n X+1/X-1 (status quo output, but invalid Python)\n hyx_X58XX2bX1/hyx_X58XX2dX1 (X quotes)\n hyx_582B_XX1/hyx_582D_XX1 (X elision)\n hyx_2B_X_1/hyx_2D_X_2 (_ elision)\n hyx_2B_X\u20541/hyx_2D_X\u20542 (\u2054 elision)\n hyx_X_add_1/hyx_X_sub_1 (mnemonic lookup table)\nOnly in the first and last case is the meaning clear, but elision seems easier to read than quotes, and X is the least readable of the elision characters.\nPerhaps we'd use \u2054 only if there's a non-ASCII invalid character. But the higher Unicode would still have to use the hex codes, since a lookup table that big is probably not worth the trouble. But maybe we could write a program to convert the official Unicode names somehow, e.g. foo\u2054bar becomes hyx_foo_InvertedUndertie_bar. Some of the names are pretty long though.\n  . I like where this is going. Using the Unicode names is much more legible in most cases.\nYes, combining characters could be trouble, but I'm not sure if \u2054 is one or not. I like the choice of delta better than X, but perhaps we could find a better one. It makes Greek variable names awkward anyway. A variable named \u0394 would mangle to \u0394\u0394GreekCapitalLetterDelta\u0394, I suppose.\nPython's unicodedata module has both a name function and its inverse lookup. So we wouldn't have to make our own Unicode table. But not all characters have names. We could make our own names table for the missing ASCII (the first 32 control characters), and fall back to the base16 representation for any nameless higher Unicode.\nBut Unicode names have spaces, which aren't allowed in identifiers. I figured that the simplest reversible transformation is .replace(' ', '_'), which gives e.g. PLUS_SIGN. The problem is names with hyphens, like  LESS-THAN SIGN. Camel case is also reversible, since Unicode names are all upper case. I had only suggested that so we could use _ quotes, but we need it for the hyphen. So\n```Python\n\n\n\nunicodedata.name('<').title().replace('-','').replace(' ','')\n'Less_ThanSign'\nre.sub('([a-z])([A-Z])', r'\\1 \\2', ).replace('','-').upper()\n'LESS-THAN SIGN'\nunicodedata.lookup()\n'<'\n``\nI hope Unicode names don't have any other special characters. We should write a test enumerating all Unicode to make sure everything round-trips anyway though.. Yeah let's go with that for now. I'm not sure of some of the details, but they should be more obvious when the actual code is available to test.. Do the Unicode names matchr\"\\A[-A-Z ]+\\Z\"too? That means we could replace-with a numeral. We could also count the empty string asas a special case. \n*hyx__LowLine_some_LowLine_l_Infinity_ng_LowLine_identifier(_ quotes)\n*hyx__some__l_Infinity_ng__identifier(_ quotes and empty is)\n*hyx_some_lXInfinityXng_identifier` (X quotes)\n\n\n\n<foo_X>\n hyx__Less1ThanSign_foo__X_Greater1ThanSign_ (_ quotes, empty is _ and 1 is - in names)\n hyx__Less0ThanSign_foo__X_Greater0ThanSign_ (0 is - instead)\n* hyx_XLess_ThanSignXfoo_XLatinCapitalLetterXXXGreater_ThanSignX (X quotes)\nThe last one doesn't round trip!\nIt worked when using hex codes, since X isn't in [a-f0-9]. We can't do X quotes for Python2 like that.. I think we could special-case the empty string for X, so <foo_X> becomes\nhyx_XLess_ThanSignXfoo_XXXGreater_ThanSignX\nWe could do that for Delta too.. > OPEN BOX\nAh, good point. Python2 is a pain.\nWe could try not using camel case. Convert to lower case, replace space with _, and - with two underscores. This could only fail if a Unicode name contains two spaces in a row, which I don't think would ever happen, or if a Unicode name contains a space-hyphen or hyphen-space sequence, which might. Three underscores would be ambiguous.\nhyx_Xless__than_signXfoo_Xlatin_capital_letter_xXXgreater__than_signX\nIf that's a concern, as above, but instead replace - with H (for \"Hyphen\").\nhyx_XlessHthan_signXfoo_Xlatin_capital_letter_xXXgreaterHthan_signX\nWe converted the name to lower case, so H can't appear in the name, and neither can X. And H conveniently contains the horizontal line just like a hyphen, so it's pretty easy to read.\nThere are probably other solutions, but what do you think of this?. Pretty much, but I still want to test the resulting code before final approval.\nAlso what about the special case XX and \u0394\u0394 to mean X and \u0394? Otherwise we have to spell out Xlatin_capital_letter_xX and \u0394greek_capital_letter_delta\u0394 when there are any other illegal characters. e.g. hyx_XlessHthan_signXfoo_XXXgreaterHthan_signX\nIt seems like a bigger problem for Python2 or Greek speakers. X-quoting does seem like the best of bad options for Python2. But I'm not sure about the choice of \u0394. It's legible (at least when you're not writing Greek) and (once implemented) that seems easy to change to some other character if someone has a better idea.. This forum is for issues with Hy itself. We're unpaid volunteers here. We have no obligation to debug your code for you.\nIf you can produce a minimal, complete, and verifiable example, you can ask on Stack Overflow with the [hy] tag, and I may be able to answer your question.\nIf you can't quite get that far, you can try asking us on the #hy channel on freenode IRC.. Maybe related to #1324.\nIt's easy to force a compile at runtime though, just use hy.eval, e.g.\nHy\n(hy.eval '(print hy.macros._hy-macros)). We're going to want async for comprehensions now too, and syntax to go with it. Perhaps an :async control word would work.\nBut then, to be consistent, wouldn't (for/a [x (xs)] (foo)) be written like (for [:async x (xs)] (foo)) instead? There should be only one obvious way to do it.. I don't use asynchronous stuff much either. But my understanding is that nesting an async for inside a for or vice-versa is fairly common. Making them all async or not seems overly restrictive.. I have to preemptively veto this one in light of the new merge policy. (Though to be clear, that policy only applies to newly opened issues, right?) I think this adds too much complexity to the compiler, which will force even more complexity on the already complicated let macro. We should be simplifying the compiler, but this is a step in the wrong direction.\n588 is still a bug so the status quo is unacceptable. I've been pondering alternatives that would let us move more of the logic out of the compiler and into macros. I think I've come up with something workable, but I'll need time to code it.. > Flat is better than nested.\n--The Zen of Python.\nI'm OK with having a fairly large core, but it has to have things that actually get used a lot, like Clojure's core. It's a pain to import these things every time. I'd support putting most of Clojure's core macros in Hy core. I'd also support putting most of Clojure's core functions in Hy extra or even Hy core if they're sufficiently important.\nThat said, I think a large core can make Hy harder to learn, because new users can't find the absolute essentials inside all the other useful stuff. Clojure had the same problem. The solution is probably better documentation highlighting these rather than more nested namespaces.\nWe do have -> ->> and as-> #1047. I also had a condp implementation in #1328 (but it doesn't belong there).. > This is exasperated by require not being transitive\nI am reconsidering the current macro namespace implementation. #1416, we might be able to get transitivity by adding to the __macros__ object.\nIn the meantime, couldn't you write a macro that expands to all your require statements? Then you'd only have to require that (and invoke it). I haven't actually tried this, but I think it would work.. IANAL. Github is accessible worldwide and Hy has contributors from multiple jurisdictions. But in the US, at least, you are not required to declare copyright. The git repository is a sufficient record of authorship. This probably matters less than we think it does.. Can we assign to our other special form names now? With #1458? Let's be consistent here.. I had proposed using def for this purpose. #911. Two arguments would declare a variable's type, and three arguments would also initialize it. Variables with unspecified type would continue to use setv.. Can it do the default arguments too?\nHy\n(defclass Person [NamedTuple]\n   (def name str \"John Doe\")\n   (def age int))\nThe test are failing since you changed the meaning of def but didn't replace the existing usage with setv. This should be easy to fix with a project wide search and replace.\n  . I think the current definitions in the PR are just fine.\nClojure does use def for vars and defn for functions. Hy's syntax was based primarily on Clojure. I don't find the \"unduly confusing\" argument very convincing in this case. This might get you once and then you read the docs. It's really not a problem. For someone coming from Clojure, def meaning \"function\" would be just as confusing--i.e. not that much.\nMaybe we could remove def altogether and use defv for variable annotations, to match setv--short for \"define variable\" and \"set variable\", respectively, which pretty well matches what they'd do. But I don't think it's necessary.\n  . That's fair. Hy users might realistically switch between Hy and Python a lot. I had a similar complaint about symbols containing a trailing comma.\nI've been trying to get rid of duplication (like def/setv) in core, so I wouldn't approve of making def an alias for defn.\nI still think the current proposal is fine. But I'd like more feedback for a major syntax change.\n@hylang/core, thoughts? (@ekaschalk too, we'll need to update the tooling.) Shall we\n1. redefine def for annotations as currently proposed?\n1. remove def altogether and use defv for variable annotations instead?\n2. rename defn to def for functions and use defv for variable annotations? (weird from Clojure)\n4. remove def altogether and just use ^foo in setv forms for variable annotations?\n3. rename defn to def and just use ^foo in setv forms for variable annotations?\nOther proposals?\n  . We'd also use ^ for function annotations, like Clojure does, as proposed in #640. We will want those eventually. The single ^ could be special-cased as an operator, like we do for the ~ meaning both unquote and bitwise-not.\nSo, \nPython\ndef foo(x: int) -> str:\n    return str(x*x)\nwould be written\nClojure\n(defn ^str foo [^int x]\n  (str (* x x)))\nAlternatively, we could use a #^. Clojure actually used to do this, and it still works, last I checked.\nClojure\n(defn #^ str foo [#^ int x]\n  (str (* x x)))\nSymbols are already not allowed to start with #, so we're not losing anything. But a typechecked program would be using these a lot, so I'd prefer the shorter syntax. We'd be relinquishing ^ for something that gets used all the time, similar to : for keywords.\nAlternatively, since Python annotations are only allowed in certain places, we could have ^ continue to be a symbol, but it would have special meaning in certain special forms, like setv and defn. But you'd always have to have a space after the ^.\nClojure\n(defn ^ str foo [^ int x]\n  (str (* x x)))\nThat would make naming the ^ shadow function a little awkward, since you probably couldn't just defn or even setv it, but it could be done with (assoc (globals) \"^\" bit-xor) or something.\n  . Not just one, setv, defn, fn, and many macros based on them, like defmulti or let might want to use these. And they do get used a lot--probably a lot more than the somewhat obscure bitwise-xor operator you seem to be protecting. Clojure uses metadata for a lot more than type hints. I think a lexer update might be worth it if we can get mypy to work with Hy.\nBut the #^ and ^-space alternatives wouldn't have to change the lexer. We could start with one of these and reconsider the question later.\nWe could have the #^ be a tag macro shorthand for the constructor of a new HyMeta model type.. @vodik go for it.. I'm not feeling very enthusiastic about making the mangling rules any more complicated then they already are. I'd even approve removing the ?/is thing. #1458 has pretty straightforward rules though.\nBy the way, Clojure would munge foo->bar to foo__GT_bar. In Clojure, if you're writing methods to be used from Java, you make them easy to write in Java. It's the same with Hy and Python.. hy2py is just the compiler then astor. If we want valid symbols in Python, the compiler has to put them in the AST in the first place. And what should ->> mangle to? _to_\u0394greater_than\u0394? How does that make any sense? And it introduces a leading underscore, which can mean something in Python. Maybe hyx__to_\u0394greater_than\u0394? Or do we ignore the -> to _to_ conversion when it happens to be in front? when we have to introduce hyx_? It's not clear you've thought this through.. Using metadata is an interesting approach. It could work on any symbol and this would allow the user to specify a more appropriate name for the AST than the automatic mangling rules ever could. But names have to be used more than once, otherwise there's no point to assigning names. And the same symbol name can have different metadata attached. That means every use of that name would need the same metadata to refer to the same value/compile to the same name in the AST. So there's no benefit on the Hy side whatsoever. You might as well use the Python-side name in the first place. It would be shorter. That particular approach is not going to work.\nYou could perhaps allow the user to create a lookup table of custom translations that apply to a single module, which the compiler would use when naming things in AST. But you'd have to use the translated name outside the module, unless you imported the table somehow. But then there could be collisions. It seems like more trouble than it's worth, unless it's a coherent part of a better namespacing system, which I've considered before. #277 #434 #1407.\n\nIf you want to explicitly define a Python-friendly name for a value, it suffices to say e.g. (setv camelcase_to_snakecase camelcase->snakecase).\n\nThat works fine for module-level things that you'd import directly by name, but for method names, this amounts to monkeypatching, which has other problems. You could pull the method off the class and rename the resulting function but then you lose polymorphism. You could use some object to translate on your behalf, but this doesn't seem any better than using getattr with the Hy name.. Technically, it's the comma that makes a tuple in Python, not the parentheses (with the single exception of the empty tuple). It's just that syntactically, you often need them. Inside a subscript operator is one of the cases where you don't. But foo[(i, j, k)] is also valid Python.. I just demonstrated that in #541. In the context of the tag macro, it's an alias. But dots do weird things to Hy expressions, since they interfere with our syntax for dotted lists. You can't just (setv ... Ellipsis). We'd have to special case it in the grammar the way Python does. I agree that spelling out Ellipsis makes slicing numpy arrays too annoying. You could (setv ,,, Ellipsis) though, which is my current workaround.. Not so. You can write a macro to conditionally require macros.\nHy\n(defmacro ifreq []\n  (if (dec (len (input)))\n      `(require [bar [foo]])\n      `(require [baz [foo]])))\n(ifreq)\n(foo)\nOf course, the (input) only happens once, when the above file is compiled.. It's just a stupid example not relevant to the question. You can use any condition you want. All those functions are documented. If you enter nothing, it picks one branch, something the other. I only picked that  condition because it was easy to implement and test.. as-> is not let. It's for nesting forms, just like -> and ->>, but lets you specify where the substitution occurs in each list. The case of (as-> 10 x (print x) (print x)) behaves exactly as intended, like (print (print 10)) Since print always returns None, of course the outer print outputs None. So far, this is the same as Clojure.\nYou can see how the macro accomplishes this with a local variable by using hy2py or hy --spy. Since this is an ordinary Python local, it exists for the normal Python scope for locals. That will exceed the scope of the as-> form itself. Just like a for loop in Python. This is different from Clojure, and we may revisit this if the experimental let gets moved into core.. In the future, read the docs before opening issues.. Possibly related to #1481. If the distinction matters, Hy will have to have special forms for either case, which means . can't just be a macro.. On second thought, we could have a cuts special form for multiple dimensions and .* and implement . as a macro in terms of those. Or we could rethink cut. But how should the syntax look in Hy if we're not using slice?. get does take a variable number of arguments. But that means a chain of lookups, not one slice over multiple dimensions.. >  By default, when in the main module, builtins is the built-in module builtins; when in any other module, builtins is an alias for the dictionary of the builtins module itself.\n\nOh shoot, that's a feature. Since we hope to be setting main appropriately someday, we can't safely use get nor attribute lookup. I'm afraid I'm not sure what design would make sense, then.\n\nAt least in Python3, __import__(\"builtins\").slice should always work, whether or not you're in __main__. Unfortunately, Python2's equivalent module is called __builtin__. But we could explicitly dump the builtins we need into the hy module or something, then it would be __import__(\"hy\").slice in both 2 and 3. We're already normalizing some of the differences in Hy core, e.g. importing izip and renaming it zip. In this case, we'd conditionally import slice from builtins into hy when on Python 3 and from __builtin__ when on Python 2.. > And one last detail, keywords\nRelated to #846, #1352?. Approved. We still have a NEWS conflict though.. I'm thinking of putting decorators inside the defn form itself, instead of wrapping them in another special form. #952. But fn wouldn't have this.. I'd prefer 1 month.. There are probably more things we can do to speed up Hy development.\nWe could add more core members. @vodik seems like the next candidate, considering recent activity. \nWe could add an experimental branch that takes only one approval. Merging that in to master would be more difficult, but less frequent. @hylang/core would a bigger, more difficult, but less frequent review process fit your schedules better?\nWe could try to drum up more interest in Hy via social media, etc. to get more developers. More cool open-source projects using Hy would help, and they don't require approval. We might even consider a little bit of paid advertising. Some have expressed interest in donations #957 and that's a possible use for it, even if it's too small to pay anyone to work on Hy full time. There are various ways to set this up, e.g. Patreon.\nWe could drop support for Python 2 early, or at least threaten to. #1217 This would simplify the compiler a lot, but if developers care enough to protest, we could perhaps recruit them. @ddkn @Rogof any interest in working on Hy issues? Know anyone else who cares?\nWe could prioritize tooling to help with PRs, like a Hy linter and formatter and a Sphinx autodoc plugin #1044. Updating Hydiomatic and adding it to Travis or something might help.\n@hylang/core what is holding you back? Is there any process improvement that could address this?. See also #1360. There are ways to turn this off, but if it wasn't the default, many users would never notice the feature even exists. That was my rationale for making pretty opt-out instead of opt-in. We could also perhaps add a command-line switch or environment variable to turn this off.. > I think turning it on by default inside the REPL is great\nSo, how do you want this to work?\nIt does round-trip if you copy-paste in most terminals, since the coloring doesn't make it into the system clipboard. This is the usual use case for round-tripping. You can also strip the color codes programmatically using clint if you need to eval a string repr for some reason. But this seems rarely useful.\nIn your Python repr example, you're using internal Hy models directly in a python repl. If you're creating Hy modules to be consumed from Python, you won't be exporting this stuff. Even then, making it readable in the console is as simple as >>> print(repr(foo)).\nI said before that managing this kind of thing would be easier with dynamic vars #1089. But until that's implemented we have to settle for a module-level global. We could have hy.models.PRETTY off by default, but make the repl turn it on upon startup.\nHy doesn't have a debugger of its own, but is mostly compatible with pdb, so it would be nice if the Hy model reprs were pretty there too.\nRepl startup activation would prevent the Python repl from getting the pretty reprs. But it might also prevent certain uses of pdb. You can turn it back on every time, of course, but this is inconvenient. Hence my environment variable suggestion.\nThere might also be cases where we'd want to launch a Hy repl from a Python repl. #1323. The embedded Hy repl could also turn PRETTY on, but if you quit back to python, PRETTY would still be on. Maybe you could turn it off at exit. If it doesn't crash.\n. As for the Pytest example, pytest needs special instructions to find Hy files in the first place. Whatever setup code is doing that could also turn off PRETTY. But I don't know that it improves readability that much. For a simple '(foo), sure, but once it gets nested very deeply, you'd have to copy it out, paste into your editor and indent it manually to see the structure. It would be easier to leave PRETTY on, paste it into a string literal and print it at a repl.. #1134 was also related. (As was mentioned in #1513).\n1018 is possibly related.\n712 also looks related. I've noticed that if a module fails to import at the repl, I can't re-import it after fixing it without restarting the repl, even though the equivalent procedure works in Python. I think the corrupted module object remains in the module cache. We're supposed to remove it if it doesn't load.\n\nI don't like coming into a project I've just started contributing to and saying everything is wrong.\n\nYou're not hurting my feelings. I didn't write that part. And you're not saying everything in Hy is wrong, just that the loader doesn't work correctly. But we kind of already knew that, hence the many existing issue reports.. > one loader for everyone and one less place where we need to chase Python.\nIt also means losing compatibility with any Python tools that directly act on .pyc files. I don't know how many of those are important or if they will become so, but astor is important for us now. I wouldn't approve of a change that breaks hy2py.\nI think mypy is also important, but it's designed for Python, not Hy. I expect we'd get it working at the level of mypy's typed AST, or a perfected hy2py via astor, not directly from bytecode, but I'm not sure.\nA custom loader could also give us more natural dynamic variables #1089 and possibly better namespacing and autoimports #1407 by customizing the module object or module dict. And possibly serialization of arbitrary objects at compile time #919, which is nice for a Lisp to have.. Another tool that appears to use bytecode is https://github.com/pybee/voc which would potentially let us use Hy on Android, but probably not if we break compatibility by using our own .hyc format.. This really should have had a link to #1458 where much of the original discussion happened.\nOne-approval merges should say so here in the conversation, for the record.\nAs a courtesy I'd like to ask that you give a one day warning before such merges. I'd have requested that in the original rule change, but never got the chance.\nNow that we've got the mangling makeover format settled, it's time to rethink the gensym format as discussed in #1458. I'd have mentioned this in time for the merge had I gotten warning.. Shouldn't the installer replace all the stale .pyc's automatically? It's fine to warn users about the issue #1324 since it will come up in their own development. But we shouldn't ask the users to do an extra installation step that we could have automated.. Using a mutable data structure for Hy code is a bit dangerous, but convenient in macros. If the compiler has to look at the same code object more than once, but mutates it during the compilation process, that could cause bugs. There's nothing stopping a macro from returning multiple references to the same HyExpression object. The compiler must not break code it hasn't gotten to yet.\nIdeally, we'd be using immutable data structures like Clojure does, so we wouldn't have to worry about it. But relying on Pyrsistent or something would add another dependency. And if we used a simple singly-linked list like most other Lisps, we'd lose most of the nice list methods that Python programmers are used to. That means we need to be very careful about mutations in the compiler, and I'm already not certain if we've tested this well enough.. > using pop to iterate through a list is slow\nSee #1406.\n\nwe'd have to be pretty careful using immutable data structures, and definitely not linked lists.\n\nPerformance claims need actual measurements. I don't know where the compiler bottlenecks are. We could try different approaches and profile, but changing the Hy model interface seems like a lot of work because it's a pretty deep change.\nLinked lists seem to work fine for other Lisps. But maybe they have some kind of background optimizations for that kind of thing. Something like the Clojure seq abstraction might be an option. We could back it with any iterable for performance and still treat it like an immutable linked list by caching the returned values. #1242 Hy also has a cons. We'd be able to integrate that better with seq.\nBut maybe inheriting from tuple is good enough. In macros, you'd usually use the quasiquote syntax anyway. But if you did want to construct code using a listcomp or something, you could use a normal list and still convert it afterwards to the tuple form using the HyExpression constructor. It's a little less convenient, but a lot less error prone than the status quo.. Probably related to #712.\nAs I mentioned in #1514, \"I think the corrupted module object remains in the module cache. We're supposed to remove it if it doesn't load.\". For the record, I was opposed to keeping the old attribute list syntax at all. But it does work according to the intended spec: (defclass <Name> <Base List> [docstring] [attribute list] [class body])\nFor example,\n(defclass Foo [object]\n  \"doc\"\n  [x 1]\n  (defn foo [self]\n    42))\n```\nclass Foo(object):\n    doc = 'doc'\n    x = 1\ndef foo(self):\n    return 42\n\n``\nAs you can see, Hy has no problem using both a docstring and an attribute list. This keeps the statements in the same order they're compiled, so naturally the docstring must come before any assignments in the class body.. But then how would(gensym '!)look? Is it going to get double-mangled?_hyx_hy_GXexclamation_markX_1235`?\nThe double prefix looks weird. I think we have to re-use the _hyx_ prefix and integrate it into the mangling better. Maybe just X-quote the gensym suffix.\n(gensym '!) to _hyx_Xexclamation_markXX1235X\n(gensym 'foo) to _hyx_fooX1236X\n(gensym) to _hyx_X1237X\nBut then the gensym name gets lost in the middle. Maybe put the gensym suffix right after the _hyx_.\n(gensym '!) to _hyx_X1235XXexclamation_markX\n(gensym 'foo) to _hyx_X1236Xfoo\n(gensym) to _hyx_X1237X\nAnd maybe add another underscore for legibility.\n(gensym '!) to _hyx_X1235X_Xexclamation_markX\n(gensym 'foo) to _hyx_X1236X_foo\n(gensym) to _hyx_X1237X_\n\nThe point of using gensyms is to guarantee that accidental capture can't happen.\nI did not realize before, but the mangling makeover gives us a lexically-valid alias for any lexically-invalid gensym we might come up with. E.g. even if we had _;let-1235 in our macroexpansion, _hyx_XsemicolonXlet_1235 would still capture it.\nSo it's now pointless to make gensyms lexically invalid, which means we're free to make them more readable.\nShorter gensyms are more readable, but long names are much less likely to cause accidents than short ones. There never has been a mechanism to stop the user from accidentally colliding with \"compiler\" gensyms, like _hy_anon_var_1.\nMaybe it's enough to tell the user not to use certain prefixes. But we could make this much more robust. For example, the HySymbol constructor could use unmangle to always return an unmangled symbol if passed a string containing the r\"_*hyx_.*\" prefix. This way it would raise an error if the user attempted to construct a gensym, since (unmangle \"_hyx_X1235X_\") is an error.. > I don't want to prevent users from constructing a gensym on purpose, just by accident.\nObviously the gensym function itself would have to do it somehow. Users wishing to construct a gensym on purpose could do it the same way. It could be a simple extra flag to HySymbol, e.g. (HySymbol _hyx_X1236X_foo :gensym 1)\n\nonly if you're interested in debugging the generated Python code or something\n\nOften true, which is why I wanted the mangling to be human-readable in the first place, but we often debug macros using macroexpand works on hytrees, which is pre-mangle, right?\n\ntry something like beginning gensyms with an underscore followed by a Unicode private-use character\n\nThis actually seems like a pretty good solution.\n\nshould mangle always be reversible?\n\nI think that would be nice. We could do it by swapping - and _, unless it's part of a leading or trailing train of underscores/hyphens. e.g. a-b would mangle to a_b like we want, but a_b would mangle to hyx_aXlow_lineXb.\nThe leading/trailing exception means we have to do private and dunder names with underscores like in Python as I recommended in #1062. So __a-b__ would mangle to __a_b__. You'd always have to write __init__ in Hy, not --init-- or _-init-_ or whatever like we can now. Seems cleaner. (--init-- would have to mangle to hyx_XhyphenHminusXXhyphenHminusXinitXhyphenHminusXXhyphenHminusX to be reversible, which is nothing like what Python would recognize as a dunder name.). One more point about reversibility, a symbol entered with the hyx prefix would have to be mangled again for full reversibility, e.g. (mangle 'hyx_XsolidusX) would result in hyx_hyxXlow_lineXXlatin_capital_letter_xXsolidusXlatin_capital_letter_xX. I don't think this would come up often, but it would be another good reason to add the empty character name as an alias for X, which would shorten it to hyx_hyxXlow_lineXXXsolidusXX.. Here's an improved insert-better-name. Call it attach (it starts with  att like attr)\nHy\n(attach self x y :my_foo a_foo)\n;; same as (setv self.x x  self.y y  self.my_foo a_foo)\nThe first argument gets the attachments. The positional arguments come from locals of the same name, and the kwargs let you change the name.. Here's an implementation.\n(defmacro! attach [o!target &rest vs]\n  (setv ivs (iter vs))\n  (import hy)\n  `(setv ~@(chain.from-iterable (genexpr [`(. ~g!target ~(if (instance? hy.HyKeyword arg)\n                                                             (hy.HySymbol (cut (str arg) 1))\n                                                             arg))\n                                          (if (instance? hy.HyKeyword arg)\n                                              (next ivs)\n                                              arg)]\n                                         [arg ivs]))))\nI feel like it shouldn't be this hard. I feel like the hy module is important enough to autoimport, but I don't want autoimports at all. #1407.\nThe models should probably be called things like hy.Keyword instead of hy.HyKeyword. Adding the module name as a prefix seems redundant.\nHyKeyword's __str__ shouldn't include the colon so I don't have to cut it off like that, since converting it to a symbol isn't that unusual in macros. In fact, maybe keywords should just have a .to-symbol method for that. (That or HySymbol should accept a HyKeyword instance in its constructor, or have a static factory method that does.)\nchain.from-iterable is too verbose. A chain #* might be a better alternative. But I see this (chain.from-iterable (genexpr pattern a lot. (It's like the list monad.) I had a chain-comp macro that combined them in my destructure module #1328. It might be worth having something like that in core too.\nExample usage:\n```\n=> (setv a 1  b 2  c 3  spam (fn[]))\na = 1\nb = 2\nc = 3\nspam = lambda : None\nNone\n=> (attach spam a b :foo c)\n_hyx_XsemicolonXtargetXvertical_lineX1235 = spam\nNone\nNone\n_hyx_XsemicolonXtargetXvertical_lineX1235.a = a\n_hyx_XsemicolonXtargetXvertical_lineX1235.b = b\n_hyx_XsemicolonXtargetXvertical_lineX1235.foo = c\nNone\n``\nThe gensyms aren't pretty #1531. We're also getting extraNone`s for some reason #1424.\nI feel like I'm re-implementing &kwargs a little bit. For maximum flexibility, I don't think defmacro should have that &kwargs #960, but maybe core could provide some function to help parse keyword arguments in macros. I'm not sure what that would look like without giving up generality though.. > It's better to use (name kw)\nForgot about that one. Revision.\n(defmacro! attach [o!target &rest vs]\n  (setv ivs (iter vs))\n  (import hy)\n  `(setv ~@(chain #*(genexpr [`(. ~g!target ~(if (instance? hy.HyKeyword v)\n                                                 (hy.HySymbol (name v))\n                                                 v))\n                              (if (instance? hy.HyKeyword v)\n                                  (next ivs)\n                                  v)]\n                             [v ivs]))))\nStill works.\n\nModel patterns (#1593) would help. ;)\n\nThat does look promising. I've been looking through the funcparserlib docs. I will try to make time to review #1593, but have been busy with work lately. The associated small PRs may have to come first.. I am unable to verify. Can you provide a minimal example? Does this appear in the repl, or just .hy files?\nWe've noticed some issues with stale .pyc files after upgrades. Can you reproduce in a bleeding-edge install in a fresh virtual environment?. No wait, I see it. It's only class docstrings, not function docstrings.. Minimal example:\n(defclass Foo [] \"doc\" \"\")\nThat's not supposed to fail.. > Where did test go?\nLook at this:\n```Python\n\n\n\nclass Hi:\n    print(\"hi\")\n\n\n\nhi\n\n=> (defclass Hy [] (print \"hy\"))  ; Nothing!\n=>\n``\nThis is another bug. The statement is completely dropped. Thedefclass` body should execute all statements for possible side-effects, not just assignments.. @Kodiologist, no. I might even approve it. But that doesn't solve this underlying problem.. Possibly related to #1424 and #1423.\nWe can whack-a-mole these mutability bugs as they appear, but we're clearly not testing for them well enough. Immutable Hy Models would fix all of this, but that's a very breaking change. I don't know that rewriting the compiler to copy everything before modifying it is any easier or more efficient though.. I'm not sure I understand why the error only shows up inside defmacro. Doesn't that indicate the problem is a mutation in the compiler itself, rather than a problem with the definition of ->>?. Python takes pass literally anywhere a statement is allowed. (Notably, not in the \"body\" of lambda.) But in Hy everything is an expression. What value should (while (f)) evaluate to? None? or the result of (f)? What should an empty for evaluate to?\nShould we allow empty try forms too like (try (except)) or (try (finally))? A pass is allowed there. But what should they evaluate to?\nI think the other forms corresponding to Python reserved words with bodies already work with empty bodies. We should take a look at our core macros though.. > while and for return None in every other case.\nGood point.\n\nthe point of a try with no body.\n\nIf it's written directly in production that way, yeah, it's got to be an error. But during development, you might comment stuff out like\nHy\n(try\n  ;; (risky-foo)\n  (finally\n    (stuff-I-still-want-running))\nRestructuring the entire form to pull out the finally when you just want to disable one line is a pain. In Python, you'd have to add a pass if it was the entire body though. We actually have a comment macro that substitutes a None for this kind of thing. But the line-wise ; or form-wise #_ would have the same problem. You'd need to add a None or something.\nThere are certain tradeoffs between flexibility and enforcing correctness for this kind of thing, but in Lisp, because of macros, we want to avoid special cases more than we want to enforce correctness for this kind of thing. If a macro expands to a try form, and the body could reasonably be empty for the macro's semantics, then it's an additional special case we're forcing the macro writer to handle unnecessarily.. We can just set the __doc__ global and put module docstrings wherever we please. But I'd rather get rid of autoimports altogether somehow. It's causing a lot of problems and the above is just one of them. Hy's core is not discoverable with dir. We can't easily import * from a Hy module, since the Hy core we happen to use in that module comes with it.\nWhat we really want is our own builtins module for Hy. But Python doesn't have an easy way to add that. And dumping our \"builtin\" stuff into Python's builtins is not nice to the Python side. So we autoimport. #1407 had some ideas on how to deal with that differently.. Wait, what? Does this really do what we need? Python 2.7 also has a \"BuiltinImporter\" class, I checked. But it's not clear to me how to use it or what it's good for from those linked docs.. It's a consequence of the implementation of quasiquoting. We'd basically need the list monad to get the ~@ unquote splice, i.e. if it's already an iterable, just convert it to a list instead of wrapping it in one. E.g.\n`(0 ~@[1 2 3] 4)\ncurrently compiles to\nHyExpression([] + [HyInteger(0)] + list([1, 2, 3] or []) + [HyInteger(4)])\nbut could be\nHyExpression([HyInteger(0), *list([1, 2, 3] or []), HyInteger(4)])\nbut only since PEP 448 in v3.5. We're still supporting 3.4 though.\n[Edit:\nbetter yet, use tuples:\nHyExpression([HyInteger(0), *tuple([1, 2, 3] or ()), HyInteger(4)])\n]\nI'm not sure how immutable models help us here.. Clojure's core data structures are very immutable (not Java's though). That includes its linked list implementation used for code, so you certainly don't need mutability.\nI know that mutability of cons cells can bite you in Common Lisp, though in practice, it doesn't happen often because you usually don't mutate them, even in macros.\nWith real linked lists, you can attach multiple heads pointing to the same shared tail list (using cons) without causing problems, as long as you don't mutate the tail. (Which you can't do anyway in Clojure.)  Mutation is sometimes done as a kind of performance optimization, but you have to be very careful not to mutate a shared tail.\nPython's array-based lists can't do that kind of sharing, and they have a lot of mutating methods that are so tempting to use in macros.\nAnd worse, our compiler mutates the code as it compiles it, which is very weird if your macro points to the same subexpression twice. Other Lisps don't do that.. Fixes #1352. I think.. @vodik I like your thinking, but that's even harder to remember and longer to type the noreturn explicitly. Wrapping it in a definit macro like that seems equivalent to my original proposal.\nIn almost all the cases when you'd want to suppress the auto return, you could explicitly return None instead. The main exception is generators in Python 2. A metadata option like that would have been a great fit, I think. But it changed in Python 3. I think a return None at the end is equivalent now. So I don't think we need this ability in the compiler anymore.. > wouldn't be much easier to remember to use definit than to include the explicit None.\n@Kodiologist I think putting it first instead of last helps a lot, mentally, especially if it's easy to form a habit. Programmers have limited working memory. You have to think hierarchically and do small pieces at a time.\nThe hardest part of writing a method, in terms of cognitive load, is usually the body. When you're thinking at the \"method body\" level, you're not thinking at the \"class outline\" level anymore. Remembering to add None at the end of the body, as a finishing touch, after you've already offloaded your \"class-level\" cache, is probably the hardest time to do it. By comparison, figuring out that you have to write an __init__ method is easy. If your habit in Hy is to write a definit method, you'll think of that first, in the \"class level\" and not have to worry about remembering it while you write the body.\nBut if you've got a better idea for how to do this without automagic, I'd like to hear it. I do think the explicit None is less bad than the current automagic. But it is still bad, which is why we tried to fix it with the automagic in the first place.. > Worse, if some metaclass other than type requires an init method to actually return something, it may be impossible to use in Hy.\n...\nAnd even worse, what if does work, but the decorator requires a return value in the decorated method? It would be difficult to use that in Hy.\nJust use an explicit (return). We have those now, but not when I initially objected to the automagic. Remembering to do this would still be a pain, but these are not impossible cases anymore.\nThe existence of an early return form means the macro is probably better rendered as\n(defmacro definit [argslist &rest body]\n  `(defn __init__ ~argslist ~@body (return)))\nI'm still uncomfortable with the automagic for the other reasons though, like decorators and metaclasses. Look at this:\n=> (defclass Foo []\n... #@(identity\n...    (defn __init__ [self]\n...     2)))\ncompiles to\n```\nclass Foo:\n@identity\ndef __init__(self):\n    return 2\n\n```\nThe return wasn't suppressed. Is that expected? Good? Bad? I don't even know. Automagic is too confusing.\n. > it's not a big problem if you forget the None or the definit, because you'll get a pretty clear error message\nYeah, I guess it's just not that bad even without any solution. It's easy to find and fix. It's just annoying when you forget. I do think it's worth a macro (because of the aforementioned cognitive load), but I'd approve just removing the automagic then.\nAnother option might be a defmethod macro, or something, which requires explicit (return)s. We could call it something shorter, like def.\n(defmacro def [name argslist &rest body]\n  `(defn ~name ~argslist ~@body (return)))\nI really don't like this. There should be one-- and preferably only one --obvious way to do it. I'm just throwing that out there in case it inspires a better idea.. > hoping to bring def back as a way to declare a variable with type annotations/metadata.\nThat was my original plan, and I still support it. @Kodiologist suggested renaming defn to def to make switching between Python and Hy easier. I think that's nothing compared to putting the parenthesis in the wrong place and putting commas in when you shouldn't and getting a completely different symbol (e.g. foo is not foo,)--or forgetting to. In that case we'd probably use annv for annotations, since that's what it's called in the ast. But def is used for declarations in Clojure, and that's closer to what it originally meant in Hy.\n\nsetv returns None already\n\nIt didn't always. Maybe we wouldn't have bothered with the automagic if it had. But I'm not sure if that makes it better, since people will forget they always have to (return) or end with None explicitly. It's harder to build a habit if it's only sometimes. definit would be all the time, so you're not bothered when your last form happens not to return None on occasion.\n\nWhat else do people practically do?\n\nYou can configure self in __init__ using doto and configuration methods. doto would return self in that case, which is not what we want as the auto-return form. But I do think it's better that doto itself return what it's configuring, since it's used in more than just __init__.. We could make a core tag macro to convert to tuple:\nHy\n(deftag , [iterable]\n  `(tuple ~iterable))\nPython3 uses iterators a lot more than Python2 did, so realizing one into a tuple is something we do often. This would make using generators in macros pretty easy.\n```\n=> #,(range 10)\ntuple(range(10))\n(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)\n```. Generators are mutable, may have side effects, and can only be read once. Laziness is great, but iterators are a pain to use compared to Clojure's seq abstraction. #1242.\nI'm confused by your motivating examples. The output isn't using the Hy model reprs, and the code critic isn't indented right. After counting brackets, I get,\n(defmacro code-critic\n  [bad good]\n  `(do ~(map (fn [x] (criticize-code #* x))\n             [[\"Cursed bacteria of Liberia, this is bad code:\" bad]\n              [\"Sweet sacred boa of Western and Eastern Samoa, this is good code:\" good]])))\nSo is the intended expansion is like,\n(do\n  (print \"Cursed bacteria of Liberia, this is bad code:\" '(1 + 1))\n  (print \"Sweet sacred boa of Western and Eastern Samoa, this is good code:\" '(+ 1 1)))\n?\nBut in that case you need to splice with ~@! I don't see how making ~ act like ~@ when it happens to be unquoting a generator is a good idea at all. Let's be consistent here.\nHere's another example with the default pretty repr and --spy.\n``\n=> (setv sym(sum ~(genexpr x [x (range 10)] (odd? x))))\nfrom hy.core.language import is_odd\nfrom hy import HyExpression, HySymbol\nsym = HyExpression([] + [HySymbol('sum')] + [(x for x in range(10) if\n    is_odd(x))])\nNone\n=> sym\nsym\nHyExpression([\n  HySymbol('sum'),\n   at 0x000002B637B10B48>])\nOf course it's a generator here, what did you expect? What bothers me is that `eval` can compile this at all, since it's not a proper hytree. And in fact, it doesn't.\n=> (eval sym)\nfrom hy.core.language import eval\neval(sym)\nTraceback (most recent call last):\n  ...\nTypeError: Don't know how to wrap a  object to a HyObject\nNow suppose we had converted this to a tuple,\n=> sym\nsym\nHyExpression([\n  HySymbol('sum'),\n  (1, 3, 5, 7, 9)])\n=> (eval sym)\nfrom hy.core.language import eval\neval(sym)\n25\nIt works, but it probably shouldn't. Using `cons` shows why.\n=> (cons (, 1 2 3) 1)\nfrom hy.core.language import cons\ncons((1, 2, 3), 1)\n\nThe tuple isn't inserted as a tuple. It's getting autopromoted into a HyList. Hy is strange for a Lisp in that its model types are distinct from the data they represent. In Clojure there's no distinction between, say, `HyInteger` and `int`. Hy can autopromote certain datatypes (it didn't always #1314), but other types are not representable as Hy models. #919. There doesn't seem to be a way to insert arbitrary datatypes into the ast. Only Python code is allowed. I find the autoconversion of tuples to `HyList` a questionable choice to begin with.. Not all of it maybe. The promotion of the atomic types is certainly convenient. But I'm less comfortable with the compound types. We can splice them in like `[~@foo]` when constructing macros, without referring to `HyList` and friends explicitly. This would be more consistent with the generators.. I mentioned in #1542 that (0 ~@[1 2 3] 4)``` could compile toHyExpression([HyInteger(0), list([1, 2, 3] or []), HyInteger(4)]),\nbut it's probably more efficient to use tuples instead of lists,HyExpression([HyInteger(0), tuple([1, 2, 3] or ()), HyInteger(4)])`.\nThere's also a hygene issue that I mentioned in #1407. Shadowing list with a local can break quasiquotes. It's probably safer to use something like __import__(\"builtins\").tuple or __import__(\"builtins\").list here. We have not been careful enough in the compiler. This does add noise to the output, which we were trying to clean up here. We need a better system for macro hygiene.\nHyExpression([HyInteger(0), *__import__(\"builtins\").tuple([1, 2, 3] or ()), HyInteger(4)])\nEven if we don't do the __import__, tuple is less likely to cause an accidental capture than list.. We also have a let macro in hy.contrib.walk, but it's sequential too, like Clojure.. > The GitHub issues list is for bug reports and feature requests. For support, try our mailing list, IRC channel, or Stack Overflow.\n@Kodiologist, I agree. We should probably say so in the readme.. That is in the readme already. The #hy channel on freenode. I also sign in via matrix, (https://riot.im).. Veto. I prefer the Python-compatible reprs as default, so you can see what's actually there instead of having to guess. I think changing the default repl output function to hy-reprs would only cause confusion.\nI don't mind changing eval back to Python's, so we don't have to use builtins.eval. But I'd prefer we keep the old name. So we'd invoke it as hy.eval instead of hy-eval, or hy.hy_eval on the Python side.. I'll reproduce examples from my previous objection below. This is never going to work right except for a narrow subset of data types. This is a niche use that shouldn't be the default. Going our own way makes us less compatible with the Python ecosystem. We cannot afford to do that. Hy's only chance to thrive is to embrace what Python offers. We can find other ways to fill these needs without breaking compatibility. \n\nSuppose you have some Python objects (foos) from some Python library. They have reprs like \nfoo(1, duck()), but no hy-repr. Now you make some Hy objects (bars) that take some foos as arguments. They have reprs like bar(foo(1, 2), foo(3, bar(foo(4, 5)))). So far, so good, the bar repr defers to the repr of its foo arguments, which defer to the int and bar reprs and the net result is still valid Python, and it will generate an equivalent bar object.\nBut wait, now we have to write a __hy-repr__. Now it prints (bar foo(1, 2) foo(3, bar(foo(4, 5)))), and that's one of those weird hybrids that's neither Hy nor Python. It's not clear at all to the future user how to parse this. Note that bar appears both in the form (bar ...) and bar(...). Why? Because foo is written in Python and knows nothing about __hy-repr__, so of course it has to use __repr__ from bar instead.\nSo what if we use generic placeholders instead? Now you've got \n(bar <foo instance at 0xXXX1> <foo instance at 0xXXX2>). The user can totally parse this. But, you've hidden important information. Not good. It's not really valid Hy, but at least you know exactly where the holes are.\nOkay, maybe we can auto-wrap the repr with the placeholders. Now you get \n(bar <Py foo(1, 2)> <Py foo(3, bar(foo(4, 5)))>). It's still not valid Hy, but now we know both where the holes are and what goes in those holes. But look, the Hy repr version only applies to the first layer! We're still getting the form bar(...). What's the point of a Hy repr if we're printing it all off in Python anyway?\nEven though this is a contrived example, it is very representative of the common case. It's very typical in Python for the repr to be a constructor call that defers to the reprs of its arguments. There are more Python libraries written in Python than in Hy, so almost all Python objects will have no hy-repr.\n\n@vodik consider my objections before deciding.\n@kirbyfan64 @olasd @algernon, you seem to have objected before to similar proposals.\n@hylang/core anyone else who wants to stop this, speak up.\nDo we know any other users? @ekaschalk? If we don't have a strong consensus, maybe we should leave this open for a while to hear from them?\n@paultag care to weigh in? Your opinion counts for a lot around here. We might also need an arbiter.. Right, I'm OK with having eval pointing to Python's version. The proposal here was hy-eval. I made a counter proposal of keeping it in the hy namespace and accessing it as hy.eval by convention. We just have to call the two versions different names so we don't lose access to either. We could keep Hy's eval and rename Python's to py-eval. We could even call Hy's evaluate and Python's eval.\nAnyway, the part I'm objecting to most is the Hy repl not printing valid Python reprs by default. If it's valid Python we could at least paste them back in the repl and eval them (using Python's eval) most of the time. With Hy reprs, it's much more fragile, since they can contain Python objects that don't have a Hy repr. Thus, it only works on a very restricted set of data types, or we force the user to write a hy repr for any Python type they might ever use. I don't think this can be automated reliably, not that we've even tried.. We should wait for @paultag. After considering this at length, I've decided that I am not fundamentally opposed to using s-expression output in the REPL. I think it would be nice. But I am vehemently opposed to making this half-baked implementation of it the default. This is nowhere near ready for core.\n\n\nAdding a __hy_repr__ magic method will reduce the compatibility of our entire ecosystem with Python. If that's the REPL default, it will be easier to just write the __hy_repr__ method and forget the __repr__. Except now we're stuck with the default object repr from the Python side.\n\n\nThis implementation easily creates confusing hybrids reprs that are neither fully Python nor fully Hy. We should output one or the other. Currently, that means we output Python.\n\n\nI think we could do better. But if we put this in core now, it may never happen.\nI would suggest that (if we want Hy reprs at all) we automatically convert Python reprs to Hy syntax.\n\nWrap the standard <...> placeholders with strings, like '''<...>''', (escaping any internal as required).\nRun the repr through (an updated) py2hy, or implement an equivalent.\nFind and unwrap the strings. Or don't bother.\nIf any of the above steps fail, fall back to the fully Python repr, and prepend a Python comment indicating that the autotranslation failed.\nPretty print with proper indentation.\n\nThis means that there's no __hy_repr__ magic, only __repr__, which addresses point 1. And the output is only fully Hy when this is possible to do automatically, and fully Python otherwise, which addresses point 2.\nEven if that's the default we should, of course, have an option to always output the Python reprs. There may be special formatting or comments and such that would get clobbered by the auto-translation.\nAnd to complete the loop, we ought to have a macro or something that allows us to write valid Python __repr__s using Hy code. We already have hy2py, so this should not be as difficult.\n@hylang/core somebody stop this before it's too late.. >> I would suggest that (if we want Hy reprs at all) we automatically convert Python reprs to Hy syntax.\n\nI don't think this is a good idea. It seems error-prone. \n\nOh it seems very error-prone, but that still seems a lot better than what you're proposing currently. Especially since we could probably detect most of them automatically and fall back to Python. In cases that don't, they can open an issue and we can try to improve the converter. We could maybe also give the user a hook to the repl output function to manually override the conversion if some case proves especially problematic.\n\nBut if I did it, would you approve this pull request?\n\nYes.\nTo be clear, I would approve that pull request, not this one currently. (Pending other details, of course.). In #1341, I also asked for the last exception (the one caught by the repl not quitting) to be stored in *e. This lets us examine exception objects in the repl without having to write a try form every time to do it. I don't want to close that issue without *e.\nIt would also be nice to store the last three input strings (or forms), like IPython and Common Lisp do. This is less important than *e, since we can copy/paste it.\nA nicer repl, like IPython, stores all of them and updates the prompt to show the current entry number. @ekaschalk has discussed some about how we would integrate that into emacs. I've also mentioned that IPython is quite extensible, and could be adapted to Hy. It might be easier to do that as a separate project that has both IPython and Hy as a dependency, rather than trying to bring Hy's built-in repl up to that level. So the last three results and *e would suffice for this PR.. I'd like to get rid of #@ altogether. #952 . > (if a b NaN) or (if NaN) enters infinite macro-expansion loop\nI don't think the problem is in the if macro.\n```\n=> (macroexpand 'NaN)\nfrom hy.core.language import macroexpand\nfrom hy import HyFloat\nmacroexpand(HyFloat(1e1000 - 1e1000))\nKeyboardInterrupt\n``macroexpandis choking on a nakedNaN.macroexpand-1doesn't seem to have a problem with it.. We had the~@first, and it comes from Clojure, which is equivalent to,@in Common Lisp. The#*we added later (to replaceapply`, which didn't work as well) and came from Python. But Python didn't even have generalized unpacking before 3.5. Not saying it has to be this way, but that's where it came from.\nA big difference is that ~@ unquotes (which means it has to be in a quasiquote to begin with) and #* doesn't. On recent Python, you can do both in a macro, `[~@(range 10) #* ~(range 10)], but note that the first one gets unpacked at compile time, and the second at runtime. Another big difference is that ~@ can also unpack something into function position, but #* ~ can't. `(~@['print 1 2]) works fine, but (#* ~['print 1 2]) doesn't because #* isn't even allowed there. We can't simply unify them.\n\nmakes sense to have a ~**?\n\nNot really? What would it do? You can already ~@ splice into a HyDict, because it's also just a list. The model represents the code that constructs a hashtable, but it's not a hastable itself. It's a Python list. Suppose we could have a ~@@ that would turn, say, `(foo ~@@{:bar 1  :baz 2}) into (foo :bar 1 :baz 2), but then why not put it in a list in the first place and just ~@? `(foo ~@[:bar 1 :baz 2]). Hy code is made of lists, not lists and dicts, even when the code builds dicts when evaluated. We only need ~@.\nAlso, while we're at it, &rest looks nothing like #* either. I actually suggested changing this #1411 .. Clojure doesn't even have dotted lists, that's from Common Lisp. You can do things with dots that you can't with splices like,\n=> (print . (1 2))\n1 2\nI'm not sure how useful that is.\nYou can't splice it because it's not quoted. \n(print ~@(1 2))  ; NameError: name 'unquote_splice' is not defined.\nBecause linked lists made of conses are Common Lisp's primary data structure, used for data as much as code, this capability is more important than for Clojure (or Python or Hy). The auto-boxing also makes it awkward to use Hy models as general-purpose data structures, because it will wrap things it shouldn't when used that way. But the extended unpacking means we don't need this so much either. E.g. instead of,\n(cons 1 [2 3 4])\nWe can\n[1 #* [2 3 4]].\nAnd similarly, (print . (1 2)) becomes (print #* [1 2]). But in this case we're deferring it to runtime.\nClojure does not have dotted lists, but it does have cons, which is also a nice, simple function that we can use in combination with higher-order functions and term-rewriting macros like -> and friends. It's fairly easy to turn an expression into a function with #%. Maybe we should move that to core. It would mostly take care of the HOF complaint.\nBut, #*/#** are still kind of awkward in macros #1366, both in the defmacro body and in later use in things like ->. This should be improved.\nSo I'm not all that opposed to removing the dotted-list syntax. Clojure does fine without it. I'm not satisfied with cons in its present form, and I'm not convinced that #* suffices as a replacement. Maybe we could remove it for now and add back a better version later when we figure out what we want, like we did with let. cons is so closely related to our choice of Hy models that the decision should probably wait for #1542.. I feel like we should leave that type of optimization to the Python runtime, to make our astor output predictable for debugging purposes. I'm not sure how much CPython would optimize that kind of thing, but PyPy probably would.\nHy's compiler should probably optimize the things that are incidental to Hy itself, like not doing the hy_anon_var_1 assignments when they're never used.. > there probably ought to be some variation on eval-and-compile to let you do that kind of thing without making you write a macro that you only use once.\nWell, we can (eval `(print ~@[1 2])), but that's still runtime.\nIt kind of sounds like macrolet. We could probably implement that as a macro without altering the compiler.\nIf you just want one-off splices, maybe a tag macro to eval at compile time would suffice.\n```\n=> (deftag eval [form] (eval form))\nfrom hy.core.language import eval\nimport hy\nhy.macros.tag('eval')(lambda form: eval(form))\n at 0x0000019D4FB92E18>\n=> #eval `(print ~@[1 2])\nprint(1, 2)\n1 2\nI'm still not sure how useful this is.. It does\nuser=> (->> (range 33 126) (map char) vec (apply str) munge)\n\"BANG__DOUBLEQUOTE__SHARP$PERCENT__AMPERSAND__SINGLEQUOTE()STAR__PLUS,._SLASH_0123456789_COLON;_LT__EQ__GT__QMARK__CIRCA_ABCDEFGHIJKLMNOPQRSTUVWXYZ_LBRACK__BSLASH__RBRACK__CARET__abcdefghijklmnopqrstuvwxyz_LBRACE__BAR__RBRACE_\"\n```\nRe-using Clojure's choices might be less arbitrary, but it doesn't fit all that well with Python and Hy. It's more ideas, anyway. I don't think we need a short name for brackets and quotes, since those aren't allowed in lexically-valid symbols anyway. Note that!*+/:<>` already have the same names in my suggested table. Notable differences are _SHARP_/XhashX, _PERCENT_/XmodX, _AMPERSAND_/XandX, _EQ_/XequalsX, _QMARK_/XqueryX, _CIRCA_/XatX, _CARET_/XhatX, and _BAR_/XorX. I do like mine better here, except maybe XeqX and XbarX also seem OK. Python does have an eq operator. I almost went with XqmarkX, XeqX, and XbarX and I also considered XpipeX for |. I think XpercentX and XampersandX would be too long. & is an operator, and it's used in &rest and friends. % is also an operator and it's used in the #% macro for arguments. The %** argument would be particularly long. hyx_Xpercent_signXXasteriskXXasteriskX vs hyx_XmodXXstarXXstarX.. Note also that Clojure doesn't munge , (whitespace in Clojure, thus not in symbols) and $ (valid in Java identifiers, but not Python) but Hy would have to mangle those. We can't just lift it wholesale from Clojure.. I think changing XminusX to XsubX and XplusX to XaddX fits better with Python conventions. I've updated the table. Clojure used _PLUS_ though. And -_ names are moot if they're both mangled as _, but we'd have to distinguish them if we want full reversibility, which is a separate issue. Python calls * both mul (as an operator), and more often star, so I went with that.. Short names are a lot more desirable, but not if we can't read them. \"period\", \"bslash\" and \"dollar\" are six characters each. I shortened \"period\" to \"dot\".\nDollar could be shortened to \"sbar\", \"buck\", \"bill\", \"coin\", or \"dolr\".\n\"query\", \"score\", \"slash\" are five each.\n\"slash\" could be \"over\" or \"per\". I don't know what to do about \"bslash\". Maybe \"esc\", but that might be confused with the control character. \"under\" is not much shorter. Maybe \"bs\". It's just not used that much though.\n\"query\" could be \"eh\" or \"hook\". We've already got the is_ prefix, which takes care of the common case with a short answer, but I'm still kind of uncomfortable with the special treatment.\nEven some of the shorter ones could be shorter. \"and\" could be \"et\". \"hash\" could be \"sh\" or \"tag\".. => `(~@\"mu\")\nHyExpression([\n  'm',\n  'u'])\n=> `(~@ \"mu\")\nHyExpression([\n  <function hyx_Xcommercial_atX at 0x000001FDC787A730>,\n  HyString('mu')])\n=> `(~ @ \"mu\")\nHyExpression([\n  HySymbol('~'),\n  HySymbol('@'),\n  HyString('mu')])\nInteresting that three interpretations are possible since ~ and @ are also both operators (invert and matmul). Be careful with spacing when using these. Probably should be documented better.. @hylang/core this is a major change. If you have objections, speak up.. Probably related to #1542. Whack-a-mole.. Related to #1411.\nI have no objection to removing &key, since I never use it and it makes the let macro more complicated than necessary. If we include this functionality at all, it should be in a macro in terms of &optional, not built into the compiler.. #1328, (or its successor) could pretty much replace this. Let's get it out of the compiler. \nI stalled when implementing that mainly because of #1414. But now that we have a let macro I might do it differently anyway. I intentionally omitted destructuring in let because it would add complexity to an already complicated macro, but I thought it would be relatively straightforward to implement a let=: macro in terms of let and something like #1328.. > I dislike that this change applies to fn as well. \nI intended to replace the lambda-list unpacking with more a more general destructuring macro from #1328, which would also give you the ability to unpack mappings. There are still some open questions though, particularly #1411. \nBut the new pattern matching stuff from the compiler might also lead to an even more general alternative. Think Haskell-style unpacking instead of Clojure, maybe. Though Clojure has an experimental pattern matching library that might be worth emulating. I'll have to look into it more.\n\nI don't see how to fit the new-style comprehensions into the threading macros.\n\nCan you elaborate on that with some concrete examples? The new comprehensions should work in the threading macros about as well as Clojure's for does. Were you fitting the old ones in somehow?. I realize this is not as nice as the pending macro would be, but in the meantime, you can still unpack inside the fn body with a setv.\n```\n;; Mapping over an enumerate\n(map (fn [idx,args]\n       (setv [idx arg] idx,args)\n       (if arg idx))\n     (enumerate foo))\n;; Reductions\n(reduce (fn [acc destruct,n-arity,args]\n          (setv [destruct n-arity args] destruct,n-arity,args))\n        [[foo bar baz] [a b c] ...])\nThough in the case of `map` at least, a `gfor` seems better.. ClojureClojure\nuser=> (read-string \"1 2\")\n1\n```\nIt's the same as Hy, so I'm not willing to call this a bug.\nsbcl\n```Lisp\n* (read-from-string \"1 2\")\n1\n2\n``\nCommon lisp does the whole string at once, returning multiple values. I suppose the Python equivalent of a(VALUES ...)multiple return would be a tuple. But then should the usual single-return also be wrapped? Maybe we could have a separateread-string-all` that always returns a tuple. I think MzScheme had something similar.\nEmacs Lisp\nelisp\nELISP> (read-from-string \"1 2\")\n(1 . 1)\nELISP> (read-from-string \"(+ 1 2) (- 3 4)\")\n((+ 1 2)\n . 7)\nEmacs returns a pair. The car is the OBJECT-READ (parsed code) and the cdr is the FINAL-STRING-INDEX, i.e. where it left off. read-from-string also takes optional START and END arguments, so you could read a string one object at a time in a loop.\nSo there are certainly other approaches.. Veto. It's not that I'm opposed to this pattern matching, it's just that this is a big change that will take a while to review, and as a deep change, it should have two reviewers. (Then we'll have at least three people who still understand how the compiler works.) It does seem like an improvement, and this pattern matching stuff could really help with macros too. I wonder how this compares to the Scheme-style macros.. Not objecting to the concept is different than approving this implementation of it. I'll consider rescinding my veto after I have reviewed it myself, if no-one else is planning to. (@vodik @kirbyfan64 @tuturto you three have been the most active lately, any takers?)\nIf you feel the team is too much of a hindrance to be bothered with, we can't stop you from maintaining your own fork. But otherwise understand that we're all volunteers here. We're maintaining Hy without pay in our spare time. Hy is one of many priorities competing for our time and energy.. I was stepping through this with the debugger today, but looks like @vodik beat me to it. That's two approvals, since we already had one from @tuturto. You're free to merge. If I find anything it will just have to wait for another PR.. OK that should fix it. @srfoster, can you install from master now?. @kirbyfan64  https://github.com/hylang/hy/pull/678#issuecomment-60526381\nThis or #1601. Take your pick.. Looking at astor, I think @berkerpeksag said he'd release 0.7.0 in about a week. This dependency link might not be needed soon. Maybe we should just remove it.. @Kodiologist even with the --process-dependency-links option I'm getting 0.6.2. How have you installed 0.7.0?. I got\nDEPRECATION: Dependency Links processing has been deprecated and will be removed in a future release.\nRequirement already satisfied: rply>=0.7.5 in c:\\users\\me\\envs\\hylang\\lib\\site-packages (from hy==0.14.0+143.g6cc74ac.dirty) (0.7.5)\nCollecting astor==0.7.0 (from hy==0.14.0+143.g6cc74ac.dirty)\n  Cloning https://github.com/berkerpeksag/astor.git to c:\\users\\me\\appdata\\local\\temp\\pip-install-590d2q8j\\astor\n  Requested astor==0.7.0 from git+https://github.com/berkerpeksag/astor.git#egg=astor-0.7.0 (from hy==0.14.0+143.g6cc74ac.dirty), but installing version 0.6.2\nI guess that's master then.. Or you could use quotes.\n```\n=> #d\".1234567890123456789012\"\ndecimal.Decimal('.1234567890123456789012')\nDecimal('0.1234567890123456789012')\n```\nIt's just one character longer, since you don't need the space now.\nReally, for a lot of these tag macro applications, you could even use an unquoted symbol.  Prefix it with a character so it doesn't get parsed as a number.\n(deftag d [x] `(decimal.Decimal ~(-> x name (cut 1))))\n```\n=> #d !0.1234567890123456789012\ndecimal.Decimal('0.1234567890123456789012')\nDecimal('0.1234567890123456789012')\nAgain, just one character longer. You could even dispatch to different constructors based on that first character, so you can reuse the tag.. Actually, in the particular case of `Decimal`, we could extend Hy's literal syntax to use the `M` suffix like Clojure does. We've added more literals that Python doesn't have before, like the fractions `1/2` and `Inf`.. If you drop the inner list like that, I think we should switch to `()` like Clojure. Semantically, `()` means the head is special, and it's highlighted as such, while the tail has the arguments, while `[]` means either the elements are equal status or it contains assignment pairs. I think we used nested `[]` before because this assignment hint holds for many of Hy's forms, with `setv` as a notable exception. But what's weird about `import` is the assignment targets are on the right, which breaks the `[]` pattern anyway.. We should also make `require` consistent with `import` if we change it.. Clojure's approach could perhaps be simplified further, like\n(import\n  bacon\n  (foo.bar\n    (baz quux norlf)\n    spam\n    eggs))\nWhich would be like\nimport bacon\nfrom foo.bar.baz import quux, norlf\nfrom foo.bar import spam, eggs\n```\nSo an expression sets the prefix for all of its children.\nBut this potentially breaks the \"preferably only one obvious way to do it\" rule, since you can now use either a . or a new expression.\n(import\n  bacon\n  (foo\n    (bar\n      (baz quux norlf)\n      spam\n      eggs)))\nRemoving the . separator is an option. We could even nest in more () to replace the . prefix for relative imports. But for common, simple cases, it gets ugly.\n;; from .foo.bar.baz import quux\n(import [.foo.bar.baz [quux]])  ; old way\n(import (.foo.bar.baz quux))  ; proposed\n(import ((foo (bar (baz quux)))))  ; no dots. How bad?\nMaybe it's not worth the trouble. Clojure's way is closer to the Python compilation and it's not too hard to build macros on top of simpler special forms.. Related #851.. > Python doesn't typically tend to have deeply nested namespaces\nA good point. Even though I wished Clojure had something like this, it's probably not worth the trouble in Hy.. clj\n;; Clojure-like\n(import (os.path exists\n                 isdir :as dir?\n                 isfile :as file?)\n        sys :as systest\n        re)\nPython\nfrom os.path import exists, isdir as is_dir, isfile :as is_file\nimport sys as systest\nimport re\nThe closest we could get to Python would be with two special forms, import and from.\nclj\n;; Python-like\n(from os.path :import exists isdir :as dir? isfile :as file?)\n(import sys :as systest)\n(import re)\nIf we reverse the order, we don't need the from form. A keyword will do.\nclj\n(import exists isdir :as dir? isfile :as file? :from os.path)\nThese have no internal brackets, but like Python, you'll need to repeat import.. > Special forms tend to use parentheses only for inner elements that look like special forms themselves\nThat's not really true of macros though, even in Hy. To the end-user, the distinction is kind of fuzzy. And Clojure has special forms that break this \"rule\" too (even though import is a macro in Clojure), like letfn.. ->, ->>, as->, and doto all use () grouping. Like this new import, and unlike try, the possible expression heads are not drawn from a fixed set of pseudo-\"special forms\".. Argh, OK, think about how this gets indented,\n```clj\n;; status quo, note the indents:\n(import [os.path [isdir :as dir?\n                  isfile :as file?\n                  exists]]\n        [sys :as systest]\n        re)\n;; brackets mean editor indents elements as peers (the head is implicit).\n(import [os.path isdir :as dir?\n         isfile :as file?\n         exists]\n        sys :as systest\n        re)\n;; parentheses mean that the head is special and the rest are arguments.\n(import (os.path isdir :as dir?\n                 isfile :as file?\n                 exists)\n        sys :as systest\n        re)\n```\nThe head is special, not a peer. If we drop the nested brackets, we need to change the remaining outer level to parentheses.. > We already disagree how to indent Lisp\nYou refuse to learn the standard and won't let your editor do it for you either, you mean. Maybe you enjoy counting brackets. As a meditative exercise. Or maybe you feel the need to write code no-one else can read. For job security.\n\nHowever! I think I like your original proposal, #851, best.\n\nMy proposed syntax from #851, which drops the outer brackets instead of the inner ones,\nclj\n(import os.path [isdir :as dir?\n                 isfile :as file?\n                 exists]\n        sys :as systest\n        re)\nThe new pattern matching compiler should be able to parse it just as easily.\nThis version does need the square brackets to indent properly, not parentheses. It also means that as you type, you don't have to even think about the brackets until you need them. With the status quo syntax, I'm frequently frustrated when typing imports at the repl because I have to back up and insert more brackets. I think it's slightly nicer that @vodik's current proposal in that regard, but the current proposal is closer to Clojure's import macro, so there's that.. > it's not appropriate to take it out on me\nStop playing the victim, Kodi. Real talk. I can understand your initial mistakes borne of ignorance, but your continued refusal to format your code in a readable way demonstrates that you don't care about wasting our time if it saves you a little. Your hostility toward the rest of the team deserves a response in kind, because you won't care unless someone makes you, by calling you on it. Spinning your personal laziness as a disagreement with me personally was pure spite. Enough of this.. How about dropping the space for the one-line version (import sys sys[stdin]) as a matter of style? This is similar to the dict lookups with the dot dsl. (. spam['eggs']), which also look a little more like Python without the space. It even looks OK for multiple from imports if you think of it as a tuple lookup in the module dict like,\n(import sys sys[stdin stdout stderr]), especially if we do #1481.\nI already approved the first version that dropped the inner brackets (but only because it used () for the outer brackets), but I'd approve my original proposal from #851 too.. > using double spaces to separate pairs.\nThat's my proposal from #1069, which was pretty well-received, but has yet to make it into the style guide. It does make sense to separate semantic groupings this way, like\n(import sys  sys [stdin :as sin  stdout :as sout  stderr :as serr])\nThat is, where you'd use a newline if it were multiple lines.\nI think the no-space variant is prettier in this case, like,\n(import sys sys[stdin :as sin  stdout :as sout  stderr :as serr])\nBut we'd keep the double spaces in the [] groups. The no-space rule makes the parings clear at the import level, so we don't need the double space there anymore.\nWe should probably add the no-space rule for semantic lookups in square brackets to the style guide too.. @vodik can you elaborate more on that?\nAlso, @hylang/core, any takers for maintaining vim-hy? If not, I guess the next candidates would be people who cared enough to make a recent PR to vim-hy.. @vodik interesting. So we could get even more editors than vim and emacs working with Hy without too much extra effort. Good tooling is important for the community. @ekaschalk what do you think of this? Have you used one of these servers with emacs before?. I also find @kirbyfan64's reasoning persuasive. Let's keep enforcing the lower-case string prefixes then. @vodik yes, Hy strings already deviate quite a bit from Python's. We can always use ast.literal_eval if we need to read in a Python string literal in Hy. Well, except for f-strings, but those aren't really literals.\nSince enough of us agree on the status quo, I think we can close this.. Although more docs wouldn't hurt.. @vodik I also want NEWS and docs for this. It can be a separate PR if that's easier.. @Kodiologist It's a single function for user interaction. How would you want this tested?. I'm happy enough with lfor, sfor, gfor, and dfor names, but I'd consider alternatives.\nI'm reluctant to approve incomplete fixes if that means we don't get to complete them later. But the status quo is so broken that I'm inclined to approve this despite my previous veto, since this seems like a better starting point to fix my previous objections than what we have now. This is not finished. But maybe we should merge it anyway. \nAnd I'm still concerned that this will break let, but perhaps that will be motivation enough to follow up.\n. Clarify for me how this would work in nested loops. Can we make some of them async and some not, like\n(lfor :async x (foo/a) :async y (bar/a) [x y])\n(lfor x (range 10) :async y (bar/a) [x y])\n(lfor :async x (foo/a) y (range 5) [x y])\n?\nWe could also consider :await as the keyword. I'm not sure which fits the Python better here, since we seem to be labeling the assignment instead of the for. I also think the (await) keyword needs to work in the comprehension body too now. I'm not sure if the compiler would allow that.. All right this is getting annoying.. Could we make the hyx a suffix instead? Do we even need it at all at this point? It's just a signal to unmangle right? Couldn't we use a condition like \"has an even number of X\" as the condition instead? (not zero). This would minimize interference with that kind of name-reading tool.\nWe could also always treat X as punctuation that must be escaped--mangle any X to Xlatin_capital_letter_xX to maintain full reversibility. (Or just XX #1577). Then the condition could just be \"has an X\".. > The rule that any Python name is also a valid Hy name with the same meaning will be broken\nAn important point, which makes the leading underscore problem something of a separate question from this. The tradeoff is that we don't get full invertiblity. I'd prefer there be one-- and preferably only one --obvious way to do it. That is--always use hyphens internally. Always write the dunder names the same way, like __init__, not --init--. And while we're at it, always mangle ? to XqueryX or something, instead of is_, since Python isn't consistent anyway.\n\nno longer be idempotent\n\nI don't think idempotent functions can be invertible generally (except some trivial cases, like identity or singleton sets), since mapping the result back to itself when it started as something else means it can't be 1-to-1. We can't have both. So which property is more important? I thought it was invertiblity, since we're defining and using an inverse function, unmangle. Why is idempotence better for this use case?. > Can we ditch the shalls? should sounds less intense IMO.\nThe current version uses \"shall\", so I rolled with it. \"Should\" works for me though.\n\nKinda related to the above, one nice thing about Effective Dart is the use of all-caps signal words like DO and PREFER in a consistent fashion to make it easier to break down the guide, and it'd be especially nice in a style guide this big.\n\nPEP-8 is using \"Yes:\" and \"No:\". I can try to make those more consistent and in all caps. Maybe \"PREFERRED\", \"OK\", and \"BAD\"?. > On outlines\nOK, so remove the ;;; and ;;;; styles from the guide altogether then?\n\nOn #_ usage\n\nI'm not sure I understand what you mean. I noticed clojure-mode highlights discarded forms like comments. I'm not sure if we want the editor to have a command to insert #_ for a selection. Does clojure-mode do that? Usually you won't need to insert that many. The editor can do ;; comments already. We just have to be more careful when commenting out closing brackets. Lisp more expression-oriented than line-oriented.\n\nOn indentation\n\nIf you want to be that complete, we should probably go over all the special forms one-by-one. And the core macros too. Maybe even extra and contrib macros. \nI hope I got the \"special indent\" terminology right here. So in a defn, the name and lambda list are special but the body is not, right?\nIn any macro or special form with a body (written &rest body in the macros), the body is not special. If the body is last (always is, I think), then the other args are special. I'm not sure about docstrings. Maybe those should be special too? But the extra indent is not really a good thing inside the string itself, so maybe no.\nYour example was setv. In the proposed style guide so far, acceptable styles would be\n;; extra space\n(setv x 1  y 2)\n;; standard function indent\n(setv x 1\n      y 2)\n;; alternative function indent--1 space past parent bracket.\n(setv\n  x 1\n  y 2)\nAnd the second is preferred over the third, just like for functions, which never have special arguments.\nIn the case of if, I think I've seen the else clause treated as special in emacs lisp, but not in Clojure. I'm not sure which that should be.\n\n(setv square? [x]\n\nHah. That was in the original and I didn't notice.. > DTRT acronym I had to look up, wasn't clear to me.\nSo did I. I'll spell it out then.\n\nI don't agree with 100 char limit. I'd rather defer to PEP8 at 79 lines\n\nWe're still using punchcards. Le sigh. All right. We're based on Python, so let's follow all of PEP-8's rules on that point. (This will include the even shorter limits for docstrings, which could leak to Python anyway. I should have had that in there already.). I don't get the koan macro either. The epigraphs are not my fault. The current version has them, and this PR simply didn't change that. I think removing those or moving the design goals should be done in a separate PR. This one is big enough already.. @kirbyfan64, I tried adding more consistent landmarks, including more headers and all-caps signal words to hopefully make it easier to break down. Let me know if it goes far enough.\nI reworded to avoid \"shall\"s, and I also rewrote a lot of the commentary, but mostly kept the code examples. I also added more rules. So you might want to re-read everything.\nI would still consider most of this tentative even if merged, but the community might not have even thought of some of these issues, so I think we can have a more productive discussion with a framework to start from. So I added \"As in Python, we expect the style of Hy to be refined over time in practice.\" to the conclusion.\nSome of the subsections could be reordered for clarity, but that's best saved for another commit, or it would have made the diff completely unrecognizable.. We've already removed tuple unpacking in lambda lists. #1590.\nWe might still see nested lists in the defmacro lambda list when using &optional, but this proposal wouldn't distinguish key from value. You should only check for the os in the left side of those pairs.\nThe new model patterns might be a better option for defmacro anyway. I'm not sure if we still want &optional. &key and &kwonly are already disallowed since they don't make sense.. > Is there currently an alternative or is this a work in progress?\nPython 2 had this and it was removed in Python 3. We've followed suit, since the implementation would be more complicated in Python 3, we decided this feature belongs in macros build on defn or fn and not in the special forms themselves.\nSo besides my destructure macros, you can work around this the same way as is recommended in Python: with an assignment at the top of the function. Note that in Hy, fn also has an implicit do. I showed an example of doing this in #1589 after it was closed.. #_ is the discard prefix used by Clojure and EDN, which is where we got the idea from in the first place. #; would have been a fair choice for Clojure, I suppose, but we've mostly been following Clojure's syntactic conventions, not Scheme's.. Well, officially, I think it takes three core members willing to revert a change for an absolute veto, but considering the lack of interest so far, the chances of this change getting approved don't look so good. \nClojure gives a stronger precedent for the current syntax, so I don't find the Scheme argument very convincing.\nCurrently _ is an alias for -, which is the shadow subtraction function, so you shouldn't import gettext by that name anyway. (We might change this #1635.) We also changed the repl history variables from _ to *1 *2 *3 like Clojure. \nThis does seem like a good use case for tag macros. But you still have a lot of options. I think __ would work, and #__ should work as a tag macro too. You could also just import gettext and do any number of other tags.\n```\n(import gettext[gettext])\n(deftag \"18\" [str]\n  `(gettext ~str))\n(defn run []\n  (message-box #18\"hello world\"))\n``. What should this even compile to? Whileself_is_ just another argument, we can't know what.foo` means at compile time.\nBut maybe we could get the method at runtime.\nPython\nhy_anon_var_1 = iter(bar)\ngetattr(next(hy_anon_var_1), 'foo')(*hy_anon_var_1)\nOf course, if bar is empty, next will crash with a confusing StopIteration, which would be especially bad in a loop, so this isn't good enough.\nMaybe\nPython\nhy_anon_var_1 = iter(bar)\ntry:\n    hy_anon_var_2 = next(hy_anon_var_1)\nexcept StopIteration:\n    raise AttributeError(\"can't get method .foo from empty iterable\")  # from None on Python3\nelse:\n    getattr(hy_anon_var_2, 'foo')(*hy_anon_var_1)\nwhich is getting a little complicated. Abstracting this into a function would add even more overhead.\nWe could instead provide a sensible default object to next\n```Python\nclass NoAttrsType(object):\n    def getattribute(self, attr):\n        raise AttributeError(\"can't get attribute {} from empty iterable\", attr)\nNoAttrs = NoAttrsType()\nThen import it to avoid accidental capture.Python\nhy_anon_var_1 = iter(bar)\ngetattr(next(hy_anon_var_1, import('hy').NoAttrs), 'foo')(*hy_anon_var_1)\n``. I didn't see who approved this one?. We could also leaveevalin there but not auto importfrom hy.core.language import eval` like we do now. \nThen Hy's eval would be hy.eval, (not hy.hy-eval) and Python's builtin would just be eval.. The only new test is at the bottom test-let-rebind everything else in that file should just be whitespace.\nI also removed the big comment at the bottom of walk. The rest is more substantive.. Rebased so the final commit shows substantive changes.. Oh it was already approved.\n\ndoes let and its subroutines use destructive modification of models\n\nI do not recall in enough detail. It was based on the earlier stuff in the walk module, which was pretty functional-looking. I think it mostly rebuilt everything as it walked over it, which should work fine with immutable models. Unless some of that building mutated the new things. It shouldn't be too hard to adapt anyway.. Yeah, it's just a bugfix, so I don't think we need any change in the docs. I'm not sure if it's worth adding to NEWS, but that tends to create merge confilcts.. I'm just going to merge it. NEWS can go in #1652, if necessary.. The output only looks scary because gensyms haven't been updated for the new mangling rules yet. It used to be a lot prettier. #1531. This might also be improved by #1577.\nWe actually had something like lei originally, but it did weird things to break/continue and yield/yield from and it prevented us from implementing async/await.\nThe current (experimental) version is more like what Haxe does. I'm not completely satisfied with it. It doesn't quite work right inside class definitions. Also an immutable version like Clojure has might be faster. That way we could probably just use gensym'd locals instead of going through a dict.. I don't think Hy is stable yet. It's certainly powerful enough to write a serious project now, but there are still big problems that would probably require breaking changes to fix. I'm not willing to call a version 1.0 until those are resolved.\n1542 and #1342 are critical problems. And we might need something like #277 to get macros working reliably. There are probably others.. > Is there a list anywhere of projects written in Hy?\nNot really, but it's easy to ask GitHub to generate one:\nhttps://github.com/search?l=&o=desc&q=language%3AHy&s=updated&type=Repositories. @alphapapa we do consider pull requests. If you're good at Python (or even documentation) or know people who are, you could help speed things up.. > Given that Hy seems partly inspired by Clojure, how does it handle these things?\nClojure namespaces (\"qualifies\") symbols. So if you do a syntax quote, it automatically prepends the symbol's namespace to prevent conflicts. (Special forms are immune). If we had Clojure's system, then given your example,\nClojure\n(defmacro test-module-macro [a]\n  `(let [b 1] (+ b ~a)))\nIf invoked like\nClojure\n(macroexpand-1 '(test-module-macro q))\nWould expand to something like\nClojure\n(hy.contrib.walk/let [test-module/b 1] (+ test-module/b q))\nLet's try it in Clojure.  First change namespace.\nClojure\nClojure 1.6.0\nuser=> (ns walk)\nnil\nClojure already has let built in, so let's make a new one.\n``Clojure\nwalk=> (defmacro LET [& body](let ~@body))\n'walk/LET\nwalk=> (ns test)\nnil\ntest=> (refer 'walk :only '[LET])\nnil\ntest=> (defmacro test-macro [a]\n         `(LET [b 1] (+ b ~a)))\n'test/test-macro\ntest=> (macroexpand-1 '(test-macro q))\n(walk/LET [test/b 1] (clojure.core/+ test/b q))\nOf course, this doesn't actually work in Clojure.Clojure\ntest=> (test-macro q)\nCompilerException java.lang.RuntimeException: Can't let qualified name: test/b, compiling:(NO_SOURCE_PATH:8:1)\nThat's because it was almost certainly a mistake. The `b` should have been a gensym to avoid accidental capture. That's why Clojure's `let` won't accept a qualified symbol as a target. This is easy to fix.Clojure\ntest=> (defmacro test-macro [a]\n         `(LET [b# 1] (+ b# ~a)))\n'test/test-macro\ntest=> (macroexpand-1 '(test-macro q))\n(walk/LET [b__36__auto__ 1] (clojure.core/+ b__36__auto__ q))\ntest=> (test-macro 41)\n42\n``\nHy usesdefmacro/g!instead of the#suffix. Also+is a special form in Hy, so it wouldn't get qualified (But it would becomehy.core.shadow/+` if not used in the function posiiton.)\nIf you actually want to capture (like for an anaphoric macro), you can do that too.\n``Clojure\ntest=> (defmacro test-macro [a](LET [~'b 1] (+ ~'b ~a)))\n'test/test-macro\ntest=> (macroexpand-1 '(test-macro q))\n(walk/LET [b 1] (clojure.core/+ b q))\ntest=> (test-macro 41)\n42\n```\nOf course, all this is currently Hypothetical in Hy. Heh. But you can see how a proper namespacing implementation would be easier to use than my current recommendation,\nHy\n(defmacro/g! test-module-macro [a]\n  `(do\n     (require [hy.contrib.walk [let :as ~g!let]])\n     (~g!let [~g!b 1]\n       (+ ~g!b ~a)))). > #1634 should already be fixed as of 498a54e.\n498a54e only fixes it for Hy's internal use though. Anything written in Hy will have to re-implement the same workaround. This would remove the need for the workaround altogether.\n\nI'm not a fan of removing is_ or removing the mangling prefix from most mangled names.\n\nIt's not just Pytest that does this kind of thing. The standard library cmd module, for example, gives a special meaning to the do_ prefix in method names. Both hyx_ and is_ will interfere with these. And if the standard library does it, you can bet the same technique is used elsewhere in the Python ecosystem (Pytest itself being one example). We can't predict what prefixes will be significant to special case them. (Special cases aren't special enough to break the rules.) I consider Python compatibility a Hy Priority. So it's better if Hy's mangling doesn't use prefixes at all.\n\nI think a private Unicode character is a better choice than ASCII NUL so that the user can type it, if desired, without weird stuff happening like Unix tools mistaking the source code for binary.\n\nWould \\uffff work better then? It wouldn't be too difficult to change that. But I expect the user will be typing either X__X or \\x00, not a literal NUL. What exactly were you imagining here?. > I don't think U+FFFF is the best choice because it's designated as a non-character, so data that isn't Unicode can be more readily identified. \nThat's not what \"non-character\" means. (At least not according to the current standard.) \"Private-use\" characters can have nonstandard, but widespread, interpretations, e.g. extra Chinese characters. Cooperating parties may have documented interpretations of such private characters. Hy should avoid taking them to avoid interfering with such use.\nNoncharacters, on the other hand, are just like private-use characters (they're still valid in Unicode strings) but the interpretation of them is meant for internal application use, rather than some shared nonstandard interpretation.\nAnd in fact, our old keyword implementation used a noncharacter. Thus a noncharacter seems more appropriate for gensyms.\nI think we can call the gensym format an implementation detail that is subject to change even after Hy 1.0, so we shouldn't worry to much about picking the wrong character if it turns out we have to change it later.. > I would want to avoid situations where whether an identifier is mangled (in the narrow sense of having an escaped Python-illegal character) isn't easily discernible, or where an identifier that looks as if it were mangled were generated by something other than Hy. That's the value of an explicit prefix.\nI mostly agree with this concern, but I think the X-quotes are sufficient to make a mangled symbol distinguishable at a glance and the further restriction that they must contain a valid name make them pretty resistant to accidents in software. Standard Python style uses snake_case, UPPER_CASE, or CamelCase for identifiers. Mangled symbols don't look like any of these, even without the prefix. \nPrefixed symbols are not immune to collisions, they just make them unlikely, but X-quotes already do that. Adding the prefix on top of that doesn't seems to help much, but it does cause the aforementioned compatibility problems. Snake case (or lower-case) and uppercase styles are entirely immune to collisions with X-quotes since mangled symbols always use both cases. Camel case could possibly cause a collision if two words in a row start with X, but this also requires the part between the X's to be a valid symbol name. Not likely. The risk is admittedly higher with the shorter punctuation names, but probably still too low to be concerned with. We could also eliminate that risk without resorting to an identifier prefix, for example, by making the quotes X_/_X instead of X/X, which might even improve readability.\nGenerators are also resistant. Other Python AST generators I've heard of avoid making valid Python identifiers when they don't want collisions, since AST doesn't require it. Our gensyms used to work this way. String generators will likely already be using their own prefix, or at least one of the three standard styles.. We can already make an empty expression with '(), an empty tuple with (,), and an empty list with []. If I had to pick one for () to be, it would be '(). But I agree that [] makes even less sense than (,).\nIn some Lisps it's synonymous with nil. #896. But not Clojure, where those are distinct.\nI think that Hy's special forms that return a default None should be returning some kind of empty/falsey type instead of just a falsey one.. I'm also leaning towards disallowed for the moment. If we do find a good use for it later, it will be easier to add it back if it's not allowed now.. No particular objection, since this is a superior implementation of functionality we already had (now that they're proper callables we can use them in HOFs), but what about making symbols callable too? That also works in Clojure. Although in Python, it might make even more sense for strings to be callable. We can't really alter the builtin str, but we could add that to quoted HyStrings.. The purpose of Hy's let is to create lexical variables. I'm not certain from your example what you want, but I think you're asking for dynamic variables #1089, which is the default let behavior in Emacs.\nPython does this kind of thing with context managers and the with statement, which Hy can also use. If you want to temporarily mutate a dict, then put it back at the end of the block, you want with, not let. You'd have to write the code to both do and undo your assignment, but it will be reusable.\nAnother option might be to use a collections.ChainMap in combination with let, to preserve the underlying dict.\n```\n=> (let [some-dict (ChainMap {} some-dict)]\n...  (setv (get some-dict \"some-key\") 2)\n...  (print some-dict)\n...  (print (get some-dict \"some-key\")))\nChainMap({'some-key': 2}, {'some-key': None})\n2\n=> (print some-dict)\n{'some-key': None}\n``. If you want to permanently update a target, usesetv. And recall that macros can return adoblock (named from Clojure'sdo, which is like the Common LispPROGNor Schemebegin`).\nIf you want to update a target for the duration of a block (and then put it back), use with and a patching context manager.\n```\n=> (import [unittest.mock [patch]])\nNone\n=> (setv a-dict {\"key\" None})\nNone\n=> (with [(patch.dict a-dict {\"key\" 2})]\n...  (print a-dict))\n{'key': 2}\n=> (print a-dict)\n{'key': None}\n``\nSee also:patch.object,patch.multiple, andcontextvars`. This is dynamic scope.\nIf you want some kind of lexically-scoped update of a generalized target, then I don't understand what that means.\nIf you want some kind of destructuring, let doesn't support that, but see #1328. I think a let=: would be possible.. A library is not a fork.\nHy should be as much like Python as possible, but homoiconic with macros and expression-oriented like Lisp, with features mostly taken from Clojure, but also Common Lisp.\nPython does not have arbitrary block scope, but it does have late-binding lexically-scoped function closures.\ndel is a statement/special form, not a function. You could certainly write your own macro to do that with del, but that's not how let works, even in Emacs. Think about what happens if you nest them. \nlet doesn't mean what you think it means. What you're trying to do is dynamic scope. But Hy's let is lexically scoped, like it is in Clojure and Common Lisp, neither of which have a letf. Python doesn't have a separate namespace for function identifiers like Common Lisp and Emacs do. So Hy is more of a Lisp-1, like Scheme and Clojure.\n. http://docs.hylang.org/en/master/contrib/walk.html. I've already demonstrated how to do a line magic. See https://github.com/hylang/hy/issues/1397#issuecomment-325257209. Have you guys seen this yet? https://github.com/yardsale8/hymagic. If you suspect that Hy is doing something weird to the AST, try inspecting it in the debugger.\nPerhaps the run_ast_nodes method expects a different form of ast? Try looking at the source for that method. Try building a simple test ast manually and see if run_ast_nodes does what you expect with that. Maybe you can write a little glue code from Hy's compiler output to whatever format the method wants.\nYou could also try decompiling the ast back into Python and giving IPython that to run.. Did you try #*?\nThis is Hy's issue list (for bugs, complaints, and feature requests), not a help forum. For help with Hy, ask on our IRC channel (may take up to a day), Stack Overflow with the [hy] tag, or on our mailing list.. Because you're running on Python 3.\nThis is Hy's issue list (for bugs, complaints, and feature requests), not a help forum. For help with Hy, ask on our IRC channel (may take up to a day), Stack Overflow with the [hy] tag, or on our mailing list.. @kirbyfan64 I'm already accessing our freenode IRC via Riot.im/Matrix so I don't have to keep a client connected all the time. Maybe we should point them to that somehow. I don't know who has admin rights to #hy or how to set that up.. > rewrites the doc macro so that it simply works with everything\nI'm less convinced. How should (doc foo) behave if foo names both a global and a macro? I implemented doc #1415 (and #doc) more as a stopgap until #1416, which would let us just use help for everything.. @brandonwillard see the discussion in #1415 for why that's a bad idea.. > does not make a clear case for why a type-narrowing option \u2014 or something similar \u2014 is objectively \"bad\".\nThis is moot if we can use help for everything. doc was only ever meant as a stopgap.\nBut it is a serious usability concern, not just a personal preference. The function you use when you've forgotten how to use things should be easy to remember how to use.\nIf you have to switch to your browser and google how to do it, what's the point of having docs in your repl at all? Just google the macro or whatever. If it's not simple, we may as well not have it. That means a single-argument form with a simple name. It's already bad that I made a doc separate from help. As it is now, all you have to remember is doc because (doc doc) will tell you how to use the rest if you forget.\nThere may be other approaches besides the one I chose that would meet this requirement (\"something similar\"? I can think of a few), but making things complicated is not it. Printing out all three is less bad, but still problematic when the docs are long.\n\nthe focus of this topic should probably be on broader pydoc functionality/inter-op.\n\nSure, feel free to open new issues on that point. Also see #1019, and #1044, which are sort of related.. Fixing doc per this PR is fine for the time being.\nIf we put macros in a __macros__ global or something like that #1416, then we shouldn't need the doc macro at all. You'd use help(foo) in the debugger for a runtime foo and probably help(__macros__.foo) for help with the macro foo. (Or (help foo) at the Hy repl or if we get a Hy debugger, etc.) This is like specifying which namespace, but the __macros__ object would be discoverable using dir(), so it's easy to find if you forget. This would be a lot more consistent with how help works in Python currently.\nTag macros might be in a similar __tags__ or something. We do want separate namespaces for macros and global functions for operator shadowing to work, but I'm not sure if we want a third namespace for tag macros or not. If we reworked them to be more like Clojure's tagged literals, instead of sugar for one-argument macros, that might change the answer.. I'm opposed to this approach. The core syntax of Hy must be kept very simple. Each additional special case makes macro programming difficult. We should be trying to make it simpler, not adding more burdensome features.\nWe can accomplish your desired syntax with a tag macro. There's no need to alter the compiler.\nHy\n(deftag ^ [form]\n  `(~@(chain #*(gfor f form\n                     (if (and (keyword? f)\n                              (.startswith (name f) '^))\n                         [(HyKeyword (cut (name f) 1))\n                          (HySymbol (cut (name f) 1))]\n                         [f])))))\nFor example,\n```\n=> (setv sep \"::\")\nsep = '::'\nNone\n=> #^(print 1 2 3 :^sep :end \"$\\n\")\nprint(1, 2, 3, sep=sep, end='$\\n')\n1::2::3$\n```. It's not the additional lines to the compiler that makes it a problem. It's the extra lines required by all the macros that now have to handle a new special case that they wouldn't have had to before.. Putting this in core seems premature. It's an experimental macro not even based on anything from Clojure or Common Lisp, that means it belongs in contrib. I don't imagine I'd use this enough to justify it, but if it proves popular we could then move it to extra.. Yes, vetoed.\n\nI wouldn't say it's experimental\n\nI sure would! By \"experimental\" I don't mean only to say that we're not sure if it meets the intended spec, but also that we're not sure if the spec is even what we want.\nThere should be one-- and preferably only one --obvious way to do it.\nThe above is a good argument for standardizing general-use functions and macros so obvious that they get invented independently anyway, but in slightly incompatible ways. (Like attach, probably #1532.) Those should be in Hy's standard library. And of those, if they get used very frequently, that's an argument to put it in core. Hy doesn't have as many lines of code as older Lisps, but it needs a standard library for that to happen. It's a chicken/egg problem. We can bootstrap that problem by including Python's standard library for the basic functions, but that doesn't give us any macros. Where are we supposed to get those? \nFrom Clojure's core. (And from its core syntax and special forms where Hy is lacking, like let and #%--formerly known as xi.) Hy has always borrowed heavily from Clojure. Clojure was designed by careful thinkers (mostly Rich) with the benefit of hindsight from decades of prior Lisp experience. Maybe also from Common Lisp where they make sense--it unified a lot of older dialects. It has some warts, but even with decades of experience later, the Lisp community mostly agrees that the design committee did a good job.\nSo far, pun doesn't meet the above criteria. It's not in Clojure. It's not in Common Lisp. It's not in any Lisp I've heard of. It wasn't independently invented by multiple Hypsters. It's not addressing a problem I've come across enough for me to even think I want it.\nI'm uncomfortable with the whole approach. Are we sure we want a macro rather than a tag? Yes, a macro is loads better than a compiler extension. But Hy's keyword arguments are already allowed to start with ^. Maybe you have to call (spam :foo foo :bar bar :^q 42) Sounds like a job for pun. (pun spam :^foo :^bar :^q 42) Uh, oh! The 42 is now a positional argument. Runtime error, if you're lucky. Subtle bug, if you're not. How do we work around it? Maybe (pun spam :^foo :^bar #** {'^q 42})? If we're using #** anyway, maybe vars-of #1119 was a better approach. Maybe we can make the macro smarter? But what if we really did want a positional argument there? Maybe (pun spam :^foo :^bar :XhatXq q) oh, but you've vetoed those mangle improvements #1651. It would have to be :_hyx_Xcircumflex_accentXq. pun made it worse. Maybe it doesn't come up enough to be a problem in practice? You certainly don't get parameter names starting with ^ in Python libraries. That's not allowed in Python identifiers. I don't know how well this would work in practice. And, emphatically, neither do you.\nThat's why it's experimental.\nNone of this is enough to keep it out of contrib, by the way, with our other experiments. Maybe the broader Hy community will eventually gain enough experience with it to justify promoting it to core. Eventually. Perhaps with changes, though.. In Clojure, if I recall, a special form in the function position always takes precedence over a macro with the same name. To use a macro with the same name as a special form, you'd have to use its fully qualified name; the unqualified name is assumed to mean the special form.. Maybe related to #919. You could sort of emulate having arbitrary Python objects in the AST using pickle. See also https://stackoverflow.com/questions/51675355/how-to-eval-a-cond-case-and-return-function-object\nThe easiest way for a macro to resolve to a function object defined in another namespace is probably to expand to something like __import__('foo').bar where bar is the function object you want that is defined in module foo.. Also, which operating systems have you tested on? Does your code work if you use hy2py on it and run it with python?. https://github.com/woodrush/py2hy\nI don't think it's up to date though. See #876.. I don't particularly like the status quo here, and have mulled over alternatives. #1411\nIdeally, I'd like Clojure-style destructuring to work in the lambda lists. This may be incompatible with just using brackets instead of &optional. I think that I had originally suggested keeping the square brackets for all the comprehensions to make it match Clojure's for (which would be my vote), but @Kodiologist didn't think they were necessary. I also considered adding a :body clause and dropping the brackets in the normal for.\nBut you shouldn't need multiple :do clauses to make a body. Just use a single (do) form.\nClojure\n(gfor x xs\n      :if (condition x)\n      :setv p (f1 x)\n      :setv q (f2 p)\n      y ys\n      (do (setv r (f3 y))\n          (body1)\n          (body2)\n          (g x y)))\nIf I recall, I was kind of opposed to having a :do clause at all. Even though I suggested it in the first place (inspired by Common Lisp's loop macro), it was only because @Kodiologist wanted arbitrary expressions at any point, though I still don't understand why. By the time you need one, you might as well use an explicit generator function with yield. If you just need to insert a print call, you could always replace any foo with (do (print whatever) foo). This would even work on xs or ys, in the above example, even in Clojure. :do was never necessary, just convenient. And it is convenient.. My vote would be for inc/dec non-mutative like Clojure (status quo). I understand that immutability is not as pervasive in Hy as it is in Clojure, so failing that, we should fall back on the names 1+/1- like Common Lisp for non-mutative instead of succ/pred. Generally we should borrow from Python, Clojure, Common Lisp, in that order.. Opposed.\nThe current version works just like Clojure, which I consider totally valid. Changing it will confuse people coming from Clojure.\nAlso, this new version will re-evaluate the code every time it's called. Why not just use a fn at that point? Did you intend it to evaluate only once and cache the answer?\nWhat exactly was the use case that motivated this change?. I approve of adding @brandonwillard to core.. Shouldn't this be (and 0 (setv a 2)) to short circuit?\n. This one also looks backwards. Should be (or 1 (setv a 2))\n. Depending on how we resolve #959 this might have to be return lambda *arg, **kwarg: None. But why is getargspec failing in the first place? Can we fix that instead? (Edit: I mean fix the callable we give to it, not changing the Python library function.)\n. Why does Python think a Hy macro is a Python builtin? That doesn't seem right.\n. I thought I spelled it out well enough, but if you missed it, that's evidence against my assumption. The value for n that would cause the form to print \"not a number\" is nan, which is, by the way, short for \"not a number\". Try it at the repl. Nan does indeed fail all three comparisons. I thought that those familiar with electronic floating point math would know about this, that's why I compared against 0.0 instead of just 0 as an extra hint.\nI could change the code block to show a repl session that includes defining the form in question in a function and passing nan as a possible n argument, if you think that's preferable. It does make the example longer, though I worry that to someone unfamiliar with the properties of nan it might not be any clearer.\n. Good catch here. I think it would be preferable if Hy were consistent across host implementations, but that seems difficult to fix in this case. I'll mention __bool__ as the default and __nonzero__ as the special case for Python2.\n. I think the point here is to test Hy, not Python, which has its own tests.\n. @kirbyfan64 didn't we fix that already #259?\n. @kirbyfan64 this doesn't seem to be working either. Try 3.6-dev instead.\n. I disagree that assigned-name is better. Perhaps you could use it in the first example just to point out which argument is which, but certainly not for all of them. The whole point of as-> is an alternative to -> and ->>, but where the insertion point can be anywhere in the list, instead of the first or last argument only. For deeply nested calls, this name may have to be repeated many times. Therefore, idiomatic usage is with a very short name, perhaps one or two letters. (This is not a problem for -> and ->> where the point is implied by the position.)\nPerhaps the documentation would be clearer if you demonstrated how to accomplish a -> using as->. You can also look at Clojure's community documentation for clarification.\n. Should say \"None\" now.. This would be less confusing if you said \"removed redundant\", since the equivalent forms are still available.. It should also say true, false, nil.. Couldn't this be simplified to: (if (and a (not b)) a b)?. Yup, sorry. \nThen how about this? \nHy\n(if (and a b)\n  False\n  (or a b)). xor has the same truth table as or, with one exception: (and a b), which should always return False, and you want it to behave exactly like or in all the other cases.. might be clearer as (assert (is (xor False 0) 0)), proving the second argument is returned, rather than the first.. I'm confused by this. Shouldn't it be [hy.models [HyExpression HyList HyString]]? And yet the tests pass. Are we not testing this?. I think this can just be islice instead of itertools.islice now that we're auto-importing everything from itertools. I wrote this before I did that, and they weren't approved in the right order to change it, I think.. Huh. I'm not sure about this part. This kind of feels like a pointless check. It already handles n == 0 properly without this. The n < 0 case doesn't really make sense, so it probably should be \"undefined\" for this function. I know it was the empty list before, but throwing an exception might actually be better. I compared it to Clojure, which also returns () for the n < 0 case, so there's that.\nOn the other hand, Clojure actually diverges in the n == 0 case, which is not good behavior all. This leads me to believe that all n<1 inputs are nonsensical and should be an error.. This looks relavant: http://dev.clojure.org/jira/browse/CLJ-1647\nMaybe an (assert (pos? n)) at the top would suffice.. A list of what length though? Even if you attempt to eat a finite iterator by taking zero-sized bites, you'll never finish the meal. On the other hand, it's lazy. This actually does work in Clojure:\nClojure\nuser=> (take 10 (partition 0 [1 2 3]))\n(() () () () () () () () () ()). Wait, you said tee raises an exception when n is 0? Does it really?\n```Python\n\n\n\ntee([1,2,3],0)\n()\n``\nSeems to work on Python 3.5, at least.. Yes, let's raise an exception on negativen.teealready does that for us. (islicealso ensures thatstep` is positive.)\n\n\n\nAs for n == 0, I'm really not certain. If you actually want an infinite sequence of empty tuples, you'd normally just (repeat (,)), so partition probably doesn't have to be able to do this. And diverging when you thought you had a finite iterator is not nice.\nI'm inclined to just remove this check and let it return [] when n == 0, then see if anybody complains. @hylang/core thoughts? How should this work?. There's no need to list all these out. https://docs.python.org/3.6/library/unicodedata.html. Not the version I thought I approved.\nOkay, so why split off the first key? Is it for performance in the more common one-key case? In that case it should probably be\nHy\n(defn get [thing key1 &rest keys]\n  (setv thing (get thing key1))\n  (if keys\n    (for* [k keys]\n      (setv thing (get thing k))))\n  thing)\nBut complications due to performance optimizations like this need to be profiled to make sure they actually help.. Ah, I see. We want to assert that get has at least one key. In the case of zero keys it might make sense to just return the thing. But we'd have to make the special form do that too. But the slightly optimized version I wrote above might perform better.. The name thing is kind of vague. I think we're using the term coll as short for \"collection\" like Clojure does elsewhere in core.. So, I profiled my version against yours. (It helps that we fixed contrib/profile.) Mine is about twice as fast with one key, and still faster with two. Adding tuples is too slow for something this fundamental.. Hy\n(defn get [coll key1 &rest keys]\n  (setv coll (get coll key1))\n  (if keys\n    (for* [k keys]\n      (setv coll (get coll k))))\n  coll). > version using reduce\nI don't think reduce would be faster considering the overhead for Python's function calls.\n\nBut why use the if?\n\nSo we immediately stop processing if the keys are empty, which should speed up the common 1-key case. I'm actually not certain if that helps. Python might do this check anyway in the for loop. I can profile and maybe disassemble the bytecode to see if it matters.. Looks like Hy is assigning an anon var because of the if. (even though it's not used). That might slow it down more than the equivalent Python would.\nLet's remove the if then. It's not really helping with one key, and it slows down the 2-key case noticeably when I profiled it.. I can't tell what this means.\nA better wording would be \"The unquote-splice or ~@ form now accepts any false value as empty.\". I'd reword this as \nReST\nevaluates to a false value such as ``None``, ``False``, or ``0``, in which\ncase the value is treated as an empty list and thus does not splice anything\ninto the form.\nNote the \"or\" and \"case\".. I'd reword this to \nevaluate to ``None``, because the ``if`` expression here does not have an \nelse clause.. I'd change the last \"symbol\" to \"syntax\". I know that's how it was written before, but the equivalent of (unquote-splice foo) is ~@foo rather than (~@ foo) as the current wording seems to imply.. Python 2 is considered legacy support now. We'll likely be removing support for Python 2 soon. #1217. All outputs in the documentation should be in the Python 3 form by then.\nI'm not asking you to fix it everywhere in this file, just in the section you've added to to make it consistent. I'll even approve the pull without this particular fix, but we might as well do it now instead of making it worse.\n. Lisp convention has ;; for an indented comment on its own line. Single ; is only for margin comments--coments following code on the same line. Lisp editors may expect this. DTRT with it.\nhttps://stackoverflow.com/questions/6365334/lisp-commenting-convention#6365579\nhttps://github.com/bbatsov/clojure-style-guide#comments. As I said, Lisp editors expect this convention to be followed and get confused when you don't. Look what emacs does to it automatically.\n```Hy\n(defn test-exception-suppressing-with []\n                                ; https://github.com/hylang/hy/issues/1320\n(setv x (with [(SuppressZDE)] 5))\n. Since #1349, splice works on any False value. This could be `~@(if other-kvs [c coll])` (or `when`).. `sum` and `zip` are not indented. And is there a reason you're avoiding `partition`? That would be simpler.Hy\n~@(sum (list-comp [(get ~c ~k) v] [[k v] (partition other-kvs)])\n       [(get ~c ~k1) v1])\n. `~@(and other-kvs [c coll])` would also work..~@(sum (list-comp [(get ~c ~k) v] [[k v] (cons [k1 v1] (partition other-kvs))])``` should also work. I should be testing these at the repl.. Hmm, nope. A cons onto a generic iterable doesn't work like that for some reason. It would have to be(chain [[k1 v1]] (partition other-kvs)), or spliced like\n```Hy\n~@(sum (list-comp [(get ~c ~k) v] [[k v] (~[k1 v1] ~@(partition other-kvs))])\n```\n(I'd have used#*instead of the splice, but that doesn't work in older versions of Python.). This is not indented properly, which makes it hard to read. Emacs can do this for you.. No, it is not indented 2 spaces. After bracket counting, I can see that arguments togenexprare indented as if they were arguments tosetv`. It will take 42 more spaces to get it indented two spaces past the start of their list. To avoid excessively wide lines, instead of just inserting 42 spaces at the start of those two lines, add some newlines.\nOne must never put list elements on a column before (or equal to) the bracket opening the list, in any Lisp. Elements must always appear on a column following the opening bracket of the list they belong to. And when I say \"list\", this applies to all Hy models inheriting from HyList.. genexpr is now indented at -7 from the opening bracket of its list. Line it up with the (if, or add a newline and line up both the (if and (genexpr at +2.. It would also look better if #* were on the same line as the thing it's unpacking.. > But, I don't think it's a good use of my time, or your time, to fuss over spacing and semicolons,\n...\n\nThis is why, although I too use Emacs, I don't use auto-indent for any language.\n\nTurn on Emacs aggressive indent mode and you won't have to waste my time fussing over it.\n\nand I don't think any hard-and-fast rules about code formatting should be enforced. Rules that are useful most of the time are occasionally going to be less than useful\n...\nBut I don't want to spend time editing every PR for style issues that are more about tradition and fussy editors than about human legibility.\n\nLisp must be indented correctly to be legible. That particular rule is absolute. The machine doesn't care, but if humans have to maintain it, indent it properly. Code in a team project is read more than it is written. Don't create more work for everyone that follows.\nWe really should have an automated Travis check for proper indentation of Hy. But since Hy is young, we haven't gotten around to writing it.\n\nAnd some rules have no discernible value at all, like this one about one versus two semicolons.\n\nYou don't get to decide this unilaterally. I don't want to break the semicolon convention here without a good reason, and enough approval from Hylang's core to change the style guide to say that we're breaking with Lisp convention on this point. If you get that, then we can do one semicolon everywhere after the change. Not before.\nIt does have a use in Emacs. It will automatically indent it differently in a way that is useful. One semicolon is for margin comments. Over multiple lines it would take more work to align them if emacs didn't do it for you. Two semicolons automatically aligns with the other list elements. Three or more are never indented.. This is not legible, Kodi.\nI cannot approve obfuscated code.\nYou don't seem to understand how to format Lisp, or why it is important to. Please read up on it, or let Emacs do it for you.. > If I make the editor indent automatically, then I have to wrestle with it when it's making a bad decision.\nI no longer trust you to judge when the editor is making a bad decision about formatting Lisp. But if you're using hy-mode and it's indenting things wrong, then it is Hy Society's responsibility to fix hy-mode. That's us.\n\nI think this code is legible (or at least, it was when I started).\n\nThe one-semicolon thing doesn't really affect legibility. I was not talking about the indentation from this PR, but from #1378.\n\nyou and the other two Horsemen of Hy Maintenance have approved my PRs in the past, so I don't see what's changed.\n\nIf I've missed other indentation errors, that's a shame (and it ought to be fixed), but in the meantime, let's not make it worse.\n\nI think the review process here is a good model. The author indented something in a nonstandard way (for Python and our codebase), I pointed it out, the author said \"I prefer it that way\", I said \"Eh, no biggie\" and @kirbyfan64 said \"it's not really a blocking issue\" and merged it.\n\nThat was Python, this is Hy. If a Python block wasn't indented properly, it would fail the tests, because it's syntactically significant in Python. That was about leaving the parenthesis on its own line. It passed our flake8 test, didn't it? If flake8 doesn't complain, then I'm not really worried about the Python side. If they had to turn a test off or add a noqa tag, then it would require more scrutiny and a really good excuse. We need a similar automated check for Hy.. PY3 and building is HyBytes and PY3 checking it twice?. Python does automatically concatenate adjacent string literals, you know, there's no need to join them. And triple-quoted strings can contain newlines without any escapes.. This seems unrelated to the rest of the PR.. shouldn't this be in the @builds_if decorator?. I thought it might get used by future tests though.. It means there's an odd number of elements in your HyDict. This is allowed, since a HyDict is really a list, but it's a mistake if your macro expands to this, because a dict is built from pairs. So I wanted to make it very visible for debugging purposes.\nNote also that # odd only shows up when PRETTY is on.\nYou might legitimately have an odd number in an intermediate stage of the macroexpansion though. So I don't want to add error checking to the HyDict methods to prevent that state.. This is minor, but I'd prefer to avoid single-character names that can be confused with other characters in Python, like lI1 or 0O. These are distinguishable in a good programmer font, but you might have to squint. This is the kind of thing flake8 should be able to catch.. I'm not sure if this is worth the added complexity to the compiler. We can already use metaclasses in Python2 using (setv __metaclass__ foo). Our Python2 support is ending in 2020 at the latest. It's fine to fix bugs, but we shouldn't be adding new features for it.. \"for metaclass for Python 3 metaclass support\"? I think this could be worded better.. Technically, things like 42 are also expressions, so this message is confusing. It should say \"HyExpressions\" if that's what you actually want. But I'm not sure why we'd want to reject such things. Python doesn't.. The docstring of sum says \"This function is intended specifically for use with numeric values and may reject non-numeric types.\" It's an implementation detail that this works at all. Other Python implementations or future Python versions may break this and a type checker has every right to flag this kind of use as a type error for not using numbers. Hy's + special form is already variadic, why not use that instead? Note that the unary + calls __pos__ instead of __add__, but you can force it to use the binary form by starting with an empty list.. @kirbyfan64 Doc fixes only require one approval. Is it clear to a new user that you start the repl with --spy, rather than entering it in the repl itself?. > not sure if I screwed something up\nYou didn't. I just noticed you hadn't merged yet, so I suggested an improvement. (about the same time you merged).\n\nit seemed obvious to me.\n\nCould be. It's hard to tell what's obvious to new people when you're already familiar with it. Don't worry about merging doc fixes that make sense. We have the one-approval rule for docs to reduce friction.\n\nNot sure if it worths another pull request.\n\nI personally don't mind small doc merges if it's a clear improvement. Wiki edits are often tiny, but they seem to accumulate good quality. Others may feel differently about adding noise to Hy's git history. If that's an issue, github does do wikis too. We could also put the docs in a separate branch or separate repository and only combine them for the tagged releases. idk. This is a Lisp formatting convention. (rule 3 here) A closing bracket (or brackets) end the line, unless it's the first part of a semantic pair, like in cond.\nRule 3 is not as strict as rule 2 (Particularly that the contents belonging to an opening bracket must always appear on a column after that bracket's column, which is my primary complaint about your formatting) and for sufficiently short lines like this one, I sometimes don't add the line break, but even then I've noticed errors creep in when I break rule 3.. Should probably just be Inf here to be consistent.. @vodik The import syntax has bothered me for a while. See #851. require too for that matter.. Wow, I think I need a better font. This was barely visible in my Editor. Switching to Source Code Pro.. So like\n+ Macros and special forms can have \"special\" arguments that are indented like function arguments.\n  Indent the non-special arguments (usually the body) one space past the parent bracket.\n?. Yeah we should probably discuss that a bit more. The Clojure Style Guide (linked in the thanks section at the bottom, even in the current version) uses the term \"margin comments\".\n@ekaschalk Emacs likes to indent Hy's ; comments to column 32, but it's column 40 in clojure-mode, and lisp-mode. I'm pretty sure I've seen column-aligned comments like this in Common Lisp code. I think they call them \"column comments\". How would you want to handle these?\nShould \"margin comments\" be a separate idea from the \"column comments\"? Should we forbid continuing margin comments on an otherwise blank line in the style guide? Should we get rid of the 2-space margin comments and only recommend column comments? Something else?. Too long before the example? @ekaschalk was suggesting we ditch the headers altogether, that would make this section shorter. Then we'd only have the ; and ;; styles.. Was using IntelliJ with Python plugins (PyCharm, basically) The one it had before was just called Monospaced. I wonder if that's the default. The curlies looked like parens with a little dot.\nSource Code Pro is the default for Spacemacs, so I'm used to it.. Transpliers are compilers though. And Python AST is a lower-level representation rather than human-readable source code, so \"transpiler\" (usually defined as a \"source-to-source compiler\") isn't really accurate.. This definition isn't indented properly. Make sure it passes parlinter.. ",
    "farhaven": "Since the majority is in favor of keeping the current state of affairs and, as @algernon said there hasn't been much traffic here, I'm closing this one. If the interest comes back, we can always re-open and restart the discussion.\n. For setv/def, I'm not sure whether those should be unified. I often do (def foo 'something) at the top level and use (setv bar 'yes) inside functions. If one of the two has to go, I'm in favor of removing def, since (do (def x 1) (def x 2)) feels weirder than (do (setv x 1) (setv x 2)).\n. While we are there, I'd also suggest removing cons. Cons cells don't mesh that well with lists and generators, which are returned/handled by almost everything else.\n. Okay, I'm convinced :).\n. :+1:, I really like it.\n. Nope, (foo ... is correct if foo is a macro, similar to what defmain does. The error message is confusing anyway :)\n. I have another suggestion:\n(defmacro let+ [vars &rest body]\n  \"Executes `body` in the lexical scope described by `vars`.\"\n  \"Warning: This litters in the current scope, use wisely!\"\n  (defn replace-symbols [expr m]\n    (assert (instance? (, HyExpression tuple) expr) (type expr))\n    (setv rv (HyExpression))\n    (for* [i expr]\n      (.append rv (if (and (instance? HySymbol i) (in i m))\n                    (get m i)\n                    (if (instance? HyExpression i)\n                      (replace-symbols i m)\n                      i))))\n    rv)\n  (setv syms {})\n  (setv init (HyExpression))\n  (for* [v vars]\n    (if (instance? list v)\n      (do\n        (if (!= (len v) 2)\n          (macro-error v \"Scope lists must have exactly two items\"))\n        (if-not (instance? HySymbol (first v))\n          (macro-error v \"First item in scope lists must be a symbol\"))\n        (setv (get syms (first v)) (gensym (first v)))\n        (.append init `(setv ~(get syms (first v)) ~(second v))))\n      (if (instance? HySymbol v)\n        (do\n          (setv (get syms v) (gensym v))\n          (.append init `(setv ~(get syms (first v)) None)))\n        (macro-error v \"Scope items must be lists or symbols\"))))\n  (setv body (replace-symbols body syms))\n  `(do\n     ~@init\n     ~@body))\nThis one works by generating a new symbol for each variable and replacing all references in body with the new symbol.\nWith this, nested lets work, which fixes #664. It also fixes (break) inside loops that look like this (#703):\n(while True\n  (let []\n    (break)))\nThe downsides are that it needs gensym, which isn't available for macros in hy.core.bootstrap. One way around this would be to use the UUID module instead, or moving gensym to bootstrap. While we're at it, we could modify gensym to use the UUID module instead of using a lock to protect the symbol counter: (defn gensym [&optional x] (HySymbol (str (uuid.uuid4))))\nThe other downside is that this \"litters\" in the current scope because it doesn't del symbols it created. This is only an issue if you're using let on the top level though, we can rely on the scope provided by functions if we're using let inside macros/functions. Not calling del on the symbols is needed for stuff like\n(def foo\n  (let [[x 'bar]]\n   (fn [] x)))\nto work. Deleting the generated symbol for x would cause a name error to be raised whenever foo is called.\nDoes this make sense as a PR?\n. The tests seem to run fine here with both Python 2.7 and 3.4. This is based on a git HEAD from today with cfa805c and 41e5175 cherry-picked in.\n. I'd argue that finally is right not to return a value. In my experience it's almost always used for final cleanup operations:\n(try\n  (something-that-might-break)\n  (finally\n    (clean-up)))\nWe're more interested in the return value of (something-that-might-break) than we're interested in the return value of (clean-up).\nThese are my 2 cents, I completely concur on (else).\n. There should probably be a versionadded tag as well, but I don't know what version this will end up in. Do I just add the current version there?\n. Looks good :+1: \n. --name-- is a global name at that point. Without (global --name--), the (setv oldname --name--) causes --name-- to be looked up in the local scope of the macro function, where it causes an UnboundLocalError.\n. The failing tests are fixed by #864 by the way. They fail because #864 changes the semantics for (read)'ing things that are not quotable Hy expressions such as \"foo\".\n. I'd like to get at least one more :+1: before merging this. You are right about that specific example. Something that breaks is this:\n=> (read)\nfoo)\nwhich returns f, o, and o with successive calls on master and hangs once it tries to parse the ). With the patch, we immediately get a LexException once the broken form is passed in.\n. I'm obviously in favor of this, but I might be a tiny bit biased :smile:\n. I'd be okay with \u03bb, but only because my editor shows (fn) as (\u03bb) anyway. I think we'd still need a way to enter function literals for people who don't have \u03bb on their keyboard or a character map stashed somewhere. Something like this:\n=> (def x #f(+ %1 %2))\n; similar:\n=> (def x \u03bb(+ %1 %2))\n=> (x 2 3)\n5\nNow that I'm thinking of it, if we do indeed go down the \"make it a unicode symbol\"-path: what do math people use to denote a parameter? My first intuition would be something like \u03bb1, \u03bb2 (think eigenvalues) or \u03bc1, \u03bc2, etc. \n. > I  think we can just put it in the hy.anaphoric package and those who like it can use it.\n:+1:. Having it in core seems to be a bit overkill indeed. We'd still need to decide on a syntax though. I like @gilch's idea with fn/p! (or lambda/p!?) similar to defmacro/g!. That would also solve the \"what prefix do we use for parameters\" problem.\n. > I believe it's possible to set up vim/emacs to render it this way.\nYep, I pushed a change that does this to vim-hy yesterday. @algernon has a similar setup for emacs, so no need to do this in Hy proper.\n. > This only works for the cases where the keys are directly in the apply\n\nparams. A previously deffed dict, or key through a variable will not be\nmangled.\n\nI think this needs to be documented. Once that's done, LGTM and :+1: \n. LGTM, :+1:\n. LGTM, :+1:\n. LGTM, will merge once travis passes.\n. Gah, this clearly needs more work. \n. Thanks for the hint :smile: \n. Ping @hylang/core . I'd really like to get this in because the current state is broken in a lot of legitimate use cases.\n. LGTM, I like it.\n. Same here, :+1: for removing the keyword checking, :-1: for renaming defclass to class.\n. LGTM, :+1: \n. LGTM, :+1: \n. Can you open a PR for this? :+1: from me.\n. You can do something like this:\n```\nimport hy\nx = hy.lex.tokenize(\"(defn foo [] (print 'fnord))\")\nhy.importer.hy_eval(x, globals(), \"main\")\n```\nthis is extremely brittle though because it digs into stuff that really should only be called manually if you have a good reason to. The canonical way is to import hy in you Python code and place Hy stuff in separate modules which you then import. Since this is not really an issue or bug, I'll close this. If you have further questions, you can stop by in #hy on the FreeNode IRC servers.\n. Hy can import Python modules and Python can import Hy modules, if you do import hy first. I already posted a way to tokenize and eval Lisp code.\n. LGTM, :+1:\n. Looks good. Do we want additional documentation for this or do we assume people familiar with Python know how to specify these integers?\n. With the added docs, I'd say LGTM. Who wants to do the honors of clicking the \"merge\" button?\n. Looks nice. I'm currently playing around with the old let renamed to let* so we don't need things like gensym in bootstrap and this in hy/core/macros.hy. There is a bit of fallout in tests where some test expects the let to call a function, and when running the tests with Python 2, during yield-from, but I think those are expected and can be fixed.\nI've also added\n(setv forms (list (map list (partition forms))))\nto the beginning of the macro so it behaves a bit more than the old let.\n. +1\n. ",
    "oubiwann": "Sure thing, man! Great job on Hy :-)\nSent from an iPad\nOn Jun 25, 2013, at 4:17 PM, Paul Tagliamonte notifications@github.com wrote:\n\nStunning stuff, thank you @oubiwann ! \n\u2014\nReply to this email directly or view it on GitHub.\n. \n",
    "rmoritz": "I've moved all the readline calls into their own module, hy.rl, which exposes wrapper funcs that do nothing if import readline raised an exception. Hope that's good enough?\n. Sorry about the long turnaround time on this; my daughter has been very sick.\nIn any case, Travis is happy again, so that's good.\n@olasd: I've sorted out all the issues you identified, so you should be happy now too.\n@rwtolbert: I've made pyreadline-2.0 a Windows-only dependency. See setup.py and hy/readline_helpers.py for details.\nHooray, we now have readline support everywhere! Thanks for the awesome, constructive feedback guys.\n. Closing: #231 is the better fix.\n. or if os.name == 'nt':\n. ",
    "tuturto": "no problem, glad I can help with this.\nI'll take a look on creating an initial documentation for rest of the builtins.\n. Thanks for the feedback, especially for the (assert) example. I made some changes based on the feedback.\n. Hm.. I think the example with (list-comp) and (do) is not that good. Since (do) is not really needed there.\nI would like to have a better example there, but can not think of a good one.\n. My pleasure, I'm learning a lot while doing this.\n. Very good points, I'll fix them. The reason for and, or and not being spread over the file is that the file is in alphabetical order. I would rather keep it like that.\n. I'll see what I can do about that. I probably have to make a new pull request with the squashed commit?\n. there you go, looks correct to me\n. nah, we rock!\n. I tried poking around the code with no luck.\nI thought the fix should be around _compile_assign in compiler.py, but couldn't figure out what it exactly is. ast_str looked like something I would want to use for that, but I didn't get it working.\n. Ah, good to know, thanks.\n. @rahmu the blank lines are there just to make sure the different sections stand out better in the source, no other particular reason. They used to be in a separate commit, but after squashing everything is of course in a single one, making it harder to read.\nthanks @paultag and @rahmu looking through this.\n. for can build nested loops neatly: (for [x (range 10) y (range 10)] (print x y))\n. :+1: from me. It is different what Python developers have learned to use, but not too drastically. And I suspect that it will help the new developers to get started easier.\n. Any ideas how to continue with this one (pull into master or drop it) in order to close the pull request?\nI'm still in favour of having this in Hy. Makes writing code slightly nicer looking. I would argue that it does not hurt the Hy <-> Python <-> Hy compatibility. There would be just two different ways of declaring the code that gets executed when the program starts up (the old and well-known Python-way and the new Hy-way).\n. I tried this on top of the current master and got output:\n```\nHelp on module hy.core.language in hy.core:\nNAME\n    hy.core.language\nFUNCTIONS\n    Lock = \n    calling_module_name = \n    cons = \n    cycle = \n```\nCould someone else check too and see if there's a problem with the generation now or if I'm just doing something incorrectly.\nOther than that, this looks really sweet. I would get this in even with some wrinkles and warts and fix them after we have something to work with. In this case it's better to have something to improve upon than to concentrate on getting it perfect on the first pass.\n. Thank you :)\n-----Original Message-----\nFrom: Nicolas Dandrimont\nSent: 22/09/2013 16:00\nTo: hylang/hy\nCc: Tuukka Turto\nSubject: Re: [hy] grant commit / review powers to @tuturto  (#257)\n@tuturto, welcome to @hylang/core!\n\u2014\nReply to this email directly or view it on GitHub.\n. With minimal Python example:\nimport sys\nprint(sys.argv)\ninvoking it with python args.py param I get the following output: ['args.py', 'param']\nSimilar program in Hy:\n(import sys)\n(print sys.argv)\ninvoking it with hy args.hy param I get the following output: ['/home/tuukka/programming/python/virtualenvs/hy33/bin/hy', 'args.hy', 'param']\nThis in turn breaks distutils in: http://svn.python.org/projects/python/branches/release32-maint/Lib/distutils/dist.py, in def _parse_command_opts(self, parser, args): where distutils tries to check which command to run, but where it encounters one extra parameter and thus compares the item in wrong position (setup.hy instead of sdist).\nIt looks to me that the fix would be to modify sys.argv and remove hy from there. That could be done in the beginning of setup.hy, but the correct fix should be to change how hy works.\n. This affects to 0.9.10 at least, but it has been fixed in the current development version.\nhy setup.hy check\n```\nrunning check\nwarning: check: missing required meta-data: url\nwarning: check: missing meta-data: either (author and author_email) or (maintainer and maintainer_email) must be supplied\n```\n. looks good and works (unlike the previous version). Thanks for fixing this.\n. Looks useful. Probably would be a good idea to write a line or two in user documentation, so people will know this exists without diving into source code.\n. In my humble opinion, testing for a type is something that Python programs shouldn't be doing most of the time. As long as the object has the attributes that I care about and the methods work as I expect them to work, the type is irrelevant (most of the time).\nWe could convert int to long when overflow happens and continue from them as if nothing had happened. (instance? int x) should fail after that, since it is not an int anymore.\n. ACK, looks like a good and sensible solution to me.\nCan someone else from @hylang/core check this too and merge (provided it's good)?\n. wouldn't the following work?\n(.text (.find dev-node \"DevNo\"))\n. ach, that's true. Hm.. interesting\n. For some reason this breaks tests in my machine:\n```\nFAIL: tests.test_bin.test_hy2py\n\nTraceback (most recent call last):\n  File \"/home/tuukka/programming/python/virtualenvs/hy/local/lib/python2.7/site-packages/nose/case.py\", line 197, in runTest\n    self.test(*self.arg)\n  File \"/home/tuukka/programming/python/projects/hy-master/hy/tests/test_bin.py\", line 139, in test_hy2py\n    assert ret[0] == 0, f\nAssertionError: quote.hy\n    3 += 1\n```\nMost likely it's just me, since Travis passes and there's not that many changes in master that are not here, but I'll look into this today still.\n. As usual, the problem was on this end, between the chair and keyboard.\nMerged it to the master now.\n. I like the idea.\nHow would this affect in cases, where Python code calling Hy-code is still using the print statement, instead of the print function? Or when Hy is calling Python code which is written using print statement?\n. :+1:\nlooks good to me\n. I think this is a good idea (less code means less bugs?), but it also breaks our builds:\nflake8 hy bin tests\nhy/_compat.py:25:1: F401 'builtins' imported but unused\nmake: *** [travis] Error 1\nMaybe mark the offending line to be ignored by flake8 if no better solution exist?\n. :+1:\nack from me\n. http://hy.rtfd.org/en/latest/quickstart.html worked for me after adding a redirect there. Does it work for everyone else too? hy.readthedocs.org works, do we have any preference on one over another?\n@hylang/core care to have a look?\n. Cool\nCould you still fix rest of the fibonacci example? It has setf later on too. And maybe align the code in:\n+.. code-block:: clj\n +    => '(a b c)\n +  (a b c)\n. :+1:\n. I'm a bit unsure of this. In case of if for example it doesn't sound like a bad idea (except it's different than what a python programmer would expect). What I'm more worried about is when Hy code is mixed with python code and calls are made to both directions. Doesn't a programmer have to remember which function has been implemented which function in order to know how they treat the truth value of 0?\n. To move this forward, would it be possible to show some code that shows how this would work under the hood? I'm not sure I understand everything about this and it would help to have some code that shows what happens when calls are made to various directions (hy to hy, hy to python, python to hy) and how truth would be treated in each case.\n(if 0 (fn1) (fn2))\nis translated to\n(if (truth 0) (fn1) (fn2))\nThe above is what we are discussing, right?\n. > @olasd I was sort of joking but my sense of humor can be weird. Sorry if I offended anyone. (@tuturto )\nNone taken, I'm just trying to understand how this should work and what implications it will have.\n. *foo* => foo sounds like something that could cause trouble, if you don't know what is happening behind the scenes. But @Coaldust has good points about following existing conventions (they're in place for a reason). For example, adding any prefixes would mean that Python => Hy interoperability would suffer. So, :+1: from me too, but I would like to hear more opinions before pulling this in.\n. kwapply does not exist anymore and I couldn't reproduce this with apply. I'll close this for now. If the bug still exist, feel free to reopen it and smack me with a bunch of parens.\n. This is really nifty. It automates exactly the type of stuff human should not be writing more than once.\nThere's a merge conflict and versionadded is outdated, but those we can fix, since the PR is 3 months old. :+1: from me and I can do the merge + versionadded fix if nobody has burning passion for that stuff.\nWould it make sense to add couple more tests? Like one for more than two dictionaries and one for just a single one?\n. @xcthulhu : Couple more tests surely wouldn't hurt and the ones at clojuredocs could be used as a base. Good idea.\n. Looks sensible to me. Has my :+1:\n(integer-char? \"0\") evaluating to False in boolean context is kind of gotcha, but anyone who has been working long enough with Python should be aware of that I guess.\n. Heh, funny.\nHow do we get the code into master? Do we start a new PR, try to merge this one? I don't know enough of git to make an informed decision.\n. This looks interesting. All the current tests are passing. :+1: from me until someone can produce a sensible breaking test.\n. So this has two changes: \nbutlast that returns collections, except the last item on it. Currently rest returns a itertools.islice and butlast should do the same? Then they would be consistent.\ndisassemble returns a value instead of printing it out. I like the change, but it breaks current tests. So the tests should be updated to reflect the change.\nI'll update title of the issue to reflect the content.\n. Looks great. Would still need a squash + rebase to clean up the history, but other than that I don't spot anything that would be needing fixing.\nWe need to get another core member to check this and acknowledge it and then we can pull it in.\nRFR @hylang/core \n. Two comments on the content, otherwise looks good. This probably should be rebased before merge, since there's conflicts. After that :+1: from me.\n. I like keywords for the very same reason @schuster-rainer explained. After playing a bit with name and keyword in REPL, I can see how this is useful. name is very generic name though, keyword-name would not be so generic, but it's already a mouthful.\n. :+1: will merge\n. Looks good to me. Travis failure looks something unrelated to me. Has my ACK.\n. Looks good :+1: from me.\nThis is hilarious. I enjoyed playing with hy2py and random hy-code more than I should had.\n. Looks solid to me and fixes the bug. Could use defmacro/g! instead of defmacro, but the current version works and doesn't look bad.\n:+1: from me.\n. In tox.ini, there's line:\n-rrequirements-dev.txt, which looks like a typo to me. Other than that I couldn't spot anything funny. Not that I fully understood everything, so other probably should have a look too. ACK from me.\nTravis didn't build this for 2.7 correctly. That should be checked and sorted out before merging too.\n. I made a simple implementation. Please have a look if it works as it should and if I missed anything.\nRFC @hylang/core\n. good catches, I must have not been paying proper attention there.\n. This looks peculiar and I'm not sure what to think of it.\n=> (setv d {\"a\" 1})\n=> (type d)\n<class 'dict'>\n=> (setv c (cons {\"a\" 1} []))\n=> (type c)\n<class 'hy.models.dict.HyDict'>\nWhen assigning a dictionary directly, the type of it is \"dict\". When doing it via cons we end up with HyDict. Maybe something is leaking all the way back to the calling code. As far as I understand, HyDict should be used only internally by Hy and programs written with Hy should be using dict.\nWhat kind of usage are you thinking of for this? What is the reason you would like to use HyDict instead of regular dictionaries?\n. That sounds like a bug to me.\nThanks for finding it out for us @hooblei \nMinimum example for this (:key (first (cons {:key :value} nil))) gives the aforementioned error, when the expected output is :value\n. I'm closing this in favour of #571 \n. looks good to me, has my ACK\n. This is nifty and works nicely. Has my ACK as @xcthulhu basically rewrote everything I did :)\nCould you still add versionadded - directive as in 2b22c21fde956346f0611c8e5f462fcdb9b70f2c ?\n. versionadded has been updated, so I'll merge this.\nGood stuff.\n. This looks slick, lets pull it in :+1: from me.\n. Looks good to me, has my :+1:\nBut this needs rebase before merging.\n. The test with six-plus I don't understand completely. Other than that the tests look like something we could pull in after dropping changes to let.\n. :+1:\n. (for [i (range 99)]\n  (print (+ (str (- 99 i)) \" bottles of beer\")))\nshould also do the trick.\nThe problem with\n(for [i (range 99)]\n  (print (+ (str (- 99 i))) \" bottles of beer on the wall, \"))\nseems to be that you have extra parenthesis at the end of (+ (str (- 99 i))) That simplifies to (+ (str 99)) on the first loop and + with a single string operand gives the error you described.\nIn the second example it works, because you're essentially doing (+ \"\" (str 99)) which concatenates two strings and that's a valid operation.\nSo, just move the extra parenthesis at the end of  (+ (str (- 99 i))) to the end of print and you're golden.\nIf you have additional questions, we would be more than happy to help.\n. One more thing I forgot. print can take multiple parameters, so your code can be simplified to:\n(for [i (range 99)]\n  (print (- 99 i) \" bottles of beer on the wall, \"))\n. Hm.. the latter example works without problems for me when I run it. If you want, you could mail the whole code to me or use pastebin.com.\nThe way you are doing printing the string twice seems good to me. All other ways I can think of require more code.\n. The reason you are getting the error is that str has been redefined at the beginning of the file (setv str \"  foo bar baz        \\n\"). Now when you are trying to call str function in the beer-section, it is actually trying to call that string (\"  foo bar baz        \\n\"() in Python), which does not work as strings aren't callable.\nIf you use this instead:\n(print (.strip \"  foo bar baz        \\n\"))\n(setv str2 \"  foo bar baz        \\n\")\n(print (str2.strip))\n(print str2.strip)\nThings should get back working. I loved the example of threading macro by the way.\n. I'm glad that I could help. I enjoyed that.\n. Looks legit to me.\n. Looks good, works well. :+1:\nMerge incoming\n. legit\n. Legit, I have had trouble with this exact bug previously and this fixes it perfectly.\n. looks nifty. Import of foo library fails on Python 3.x though.\nThere's difference between Python 2.x and 3.x how relative imports can be done and this should be addressed in the test.\nAlthough, how hard would it be to make relative imports to work in the same way in Hy, regardless of Python version?\n. make d runs flake8, same with tox. Would it make sense to have it as a requirement in requirements-dev.txt? \n. Doh :D\nI overlooked that. Then everything should be fine.\n. looks great, thanks @theanalyst  :+1: from me\nRFR @hylang/core \n. This looks nifty. What is the reasoning behind special cases, like values produced with a single parameter?\nCurrently this fails on Python 3.x: (reduce * (range 1 5)) when the expected result is 24.\nThe reason seems to be that reduce is not defined and you need to add an import for that in Python 3.x.\n. Tests are passing for me locally too, which I find sort of puzzling.\nMaybe we should add Python 3.x specific tests that import reduce from functools and try to run something simple like (assert (= (reduce * (range 1 5)) 24))?\nTo tell the truth, I'm not sure at all that I understand how Hy picks between + operator and + function.\n. sweet work @agentultra all Python versions are now happy.\n:+1: from me, RFR for @hylang/core \n. Good catch, I didn't know that we supported decorating with more than one decorator.\nShould the docs mention the order of decorators? I assume that the first decorator mentioned will be the outermost one.\nThere's few lines that are over 80 character mark:\nIn the following example, inc-decorator is used to decorate function addition\n...\nvalues that are incremented by 1. When decorated addition is called with values\n...\n=> (with-decorator inc2-decorator inc-decorator (defn addition a b))\nMaybe those could be formatted to 80 characters?\n. looks great @theanalyst \nThanks, I'll merge this.\n. looks good to me, so :+1:\nI assume @theanalyst had a look at this too and I will merge this.\n. Looks great :+1: from me.\n. Looks sensible to me.\nI think it's good idea to limit what can be redefined. World gets really complicated when one starts defining what true or false really mean :) Same goes with some of the Hy internals, like get for example.\nCan anyone think of an example, where this implementation would be a hindrance?\n. Works well, looks good. I take having it to start with capital B is deliberate choice, since it is a special kind of macro?\n:+1: from me.\n. looks sensible :+1:\n. Returning a value would be nice, but wouldn't that change the signature of what was timed? That wouldn't matter that much in REPL, but inside of a program it would be different.\nHow are we envisioning this will be used?\n. get isn't available as a function:\nhy 0.12.1+23.g92d5d6b using CPython(default) 3.4.3 on Linux\n=> (reduce get [\"foo\" \"bar\" \"baz\"] a)\nTraceback (most recent call last):\n  File \"/home/tuukka/programming/python/projects/hy/hy/importer.py\", line 146, in hy_eval\n    return eval(ast_compile(expr, \"<eval>\", \"eval\"), namespace)\n  File \"<eval>\", line 1, in <module>\nNameError: name 'get' is not defined\n. While it was really neat thing to support yield-from on Python 2, I think it's too much effort to keep supporting it now. I think we should stop supporting yield-from on Python 2.. I'm also -1 on return. I really like building code where last value of function is returned, without having to have return there. So far I haven't had a case where I had needed to return a value from middle of a function. But, I like to chop things into relatively tiny pieces anyway. All of this is of course just a personal preference.\n. Metadata sounds like a interesting approach, if we indeed want to have explicit return statements. We wouldn't have to have multiple different forms for almost same thing. Just have to make sure, that is somebody for some funky reason wants to return a dict {:return True} it is possible. I still think that explicit return statement is something that the language doesn't really need though.\n. Implicit returns are great in my opinion and most of the time explicit return would just add noise:\n``` hy\n(defn add [a b]\n  (+ a b))\nvs.\n(defn add [a b]\n  (return (+ a b)))\n```\nHowever, there are cases where explicit return is really useful (for example, returning a value from inside of a while) and not having access to one means that you have to work around that with other mechanisms (setv to store result, break to exit loop and then bare result so it gets returned).\nIf we add return, can we do that in a way that doesn't break each and every defn and fn that has been written so far? Would it be stupid idea to have a separate form, like defn-r that would require explicit return?\n. > > Would it be stupid idea to have a separate form, like defn-r that would require explicit return?\n\nThat's pretty much what I suggested before with different names, though to be clear, the explicit-return form would still allow Python to implicitly return None. It would still compile without a (return) and Hy wouldn't insert a return statement.\n\nWhat I tried to explain is that I think it would be good idea to let fn work like they do now, with implicit returns and add another form that requires explicit one. I know next release will break most of Hy programs ever written, but if we change how fn works, we're breaking pretty much each and every one. Although, I suppose it's possible to do search for defn and replace it with define + lambda combination.\nBut @gilch has an interesting point about how def and lambda work in Python in regards to needing return statement. Maybe I'm slowly changing my view on the subject after all.\n. Using last with generator will consume all the generated values, with no way getting them back. Sounds quite rare case to me when it would be useful. But on the other hand, it would be nice if collections and generators/iterators would work in a similar way.\nSo, I'm leaning towards that last should work with iterators and generators too. What are other opinions about this?\n. Would be really cool to have a tool/script that traverses through a directory tree and makes these changes to hy-code. Probably wouldn't be too difficult to write?\n:+1: for cleaning up the language a bit, even when it breaks existing code.\n. We could even do with something as simple as a reader macro #@. That wouldn't conflict with matrix multiplication and would be pretty simple to implement.\n. Looks good and works well :+1:\n. @paultag it used to have different implementation in case of two parameter input, but not anymore. I'll change it to function. Then @kirbyfan64's good point about macroerror gets solver too.\n@gilch hm.. I wasn't aware that there's different views how this should work. Probably best to switch it to work with two parameters only and avoid possible misunderstandings.\n. This looks really nice, I like the new syntax. LGTM.\nMaybe only tangentially related: how hard would it be to have --init-- return nil automatically? Could it be easily done as part of this?\n. How would people feel about \u03bb for this (and then something nice looking for parameters)?\n. > Now that I'm thinking of it, if we do indeed go down the \"make it a unicode symbol\"-path: what do math people use to denote a parameter? My first intuition would be something like \u03bb1, \u03bb2 (think eigenvalues) or \u03bc1, \u03bc2, etc.\nI asked around and did some reading, but didn't find anything that would universally be used to denote a generic parameter. Parameters tend to be given descriptive names (be it x, y, z or something else) that are dependent on the given case. \u03bb1, %1 or $1 don't look too bad to me, but I'm open for other ideas.\n. > Actually, this reminds me of something from my linear algebra course. Vectors of up to four dimensions sometimes used x,y,z,w, but when generalizing to any number of dimensions, it was usually written as all x's with a subscript, like x\u1d62. We could use x as the prefix and use x1 x2 x3 x4 x5 etc. for positional arguments. We could even use xi for the &rest parameter. The macro name could be something suitably short, like \\ or perhaps even xi, which isn't ambiguous with the &rest part because you can't nest anaphoric lambdas anyway.\nOh, neat. x1, x2, xi and so on would work I think. If we wanted to be fancy, could even use x\u2081, x\u2082, etc. as aliases.\n\nI think we can just put it in the hy.anaphoric package and those who like it can use it.\n\nSounds like a plan to me. If it gets super popular and users start complaining about require they have to use, can then think of moving it to core.\n. Catching two first cases if quite an improvement already. I wouldn't worry about macros at this stage (if ever). I played around with this a bit and it works. Tried using old defclass syntax first and got an ugly traceback, but that's probably something we don't want to check for, right?\nCode doesn't look too ugly to me.\n:+1: from me.\n. I second @algernon. Having to remember to use an extra macro, just because I happen to be writing __init__ sounds like a thing that I would forget to do. At least to me it's sensible assumption that __init__ just works without having to return nil or using a special macro.\n. Looking good, :+1: from me\n. LGTM\n. LGTM\n. Looks good :+1:\n. Looks really nifty, took me a while to understand what's going on here. But while testing, I get this error:\n`` hy\n(hy)tuukka@azrael:~/programming/hy$ hy\nhy 0.11.0 using CPython(default) 3.4.0 on Linux\n=> (defn expensive-get-number [] (print \"spam\") 14)\n=> (defmacro! triple-3 [o!n](+ ~g!n ~g!n ~g!n))\n=> (triple-3 (expensive-get-number))\n  File \"\", line 1, column 1\n(triple-3 (expensive-get-number))\n  ^-------------------------------^\nHyMacroExpansionError: expanding `triple_3': unsupported callable\n```\nI haven't yet looked deeper into this, so I don't know how obvious this is.\n. This is funky. I created completely new virtualenv, cloned hy and installed this branch. Still getting the same error. But for you it obviously works and travis is happy too. When trying macroexpansion, I get:\n=> (macroexpand '(triple-3 (expensive-get-number)))\nTraceback (most recent call last):\n  File \"<input>\", line 1, in <module>\n  File \"/home/tuukka/programming/hy/hy/core/language.hy\", line 299, in macroexpand\n    (hy.macros.macroexpand form name))\n  File \"/home/tuukka/programming/hy/hy/macros.py\", line 147, in macroexpand\n    tree = macroexpand_1(tree, module_name)\n  File \"/home/tuukka/programming/hy/hy/macros.py\", line 175, in macroexpand_1\n    raise HyMacroExpansionError(tree, msg)\nhy.errors.HyMacroExpansionError: <unprintable HyMacroExpansionError object>\n. hy 0.11.0 using CPython(default) 3.4.3 on Linux\n. is pip install -e . still the correct way to install editable version?\n. I checked and there's no Hy installed outside of the virtualenv. Tox fails with the same error message. I can try blank virtual machine tomorrow to see if there's something wrong with settings of the one I'm using.\n. Looks similar to me:\n``\n(hy)tuukka@azrael:~/programming/hy$ hy --spy\nhy 0.11.0 using CPython(default) 3.4.3 on Linux\n=> (defn expensive-get-number [] (print \"spam\") 14)\ndef expensive_get_number():\n    print('spam')\n    return 14\n=> (defmacro! triple-3 [o!n](+ ~g!n ~g!n ~g!n))\nimport hy\nfrom hy import HyExpression, HySymbol\nfrom hy.core.language import gensym, interleave\n@hy.macros.macro('triple_3')\ndef _hy_anon_fn_2(o!n):\ndef _hy_anon_fn_1():\n    g!n = gensym(HySymbol('g!n')[2:])\n    return HyExpression(((([] + [HySymbol('do')]) + [HyExpression((([] + [HySymbol('setv')]) + list(interleave([g!n], [o!n]))))]) + list([HyExpression((((([] + [HySymbol('+')]) + [g!n]) + [g!n]) + [g!n]))])))\nreturn _hy_anon_fn_1()\n\n=> (triple-3 (expensive-get-number))\n  File \"\", line 1, column 1\n(triple-3 (expensive-get-number))\n  ^-------------------------------^\nHyMacroExpansionError: expanding `triple_3': unsupported callable\n```\nIt doesn't seem to like the triple_3 decorator.\nSimple macro works correctly though:\n``\n=> (defmacro foo [](print \"foo\"))\nimport hy\nfrom hy import HyExpression, HyString, HySymbol\n@hy.macros.macro('foo')\ndef _hy_anon_fn_1():\n    return HyExpression((([] + [HySymbol('print')]) + [HyString('foo')]))\n=> (foo)\nprint('foo')\nfoo\n=> \n```\n. triple-2 code works without problems for me and tests pass for everything else but this. Defining defmacro! in repl using master branch gives me the same error. Local repository is freshy cloned, but I'll give it another go.\n. Ha, installing directly from your repository worked. That narrows it down nicely.\n. Already tried that earlier without luck, when I was testing clean virtualenv.\n. @kirbyfan64 this PR works for you, right?\n. Because if I do:\ngit checkout 649dd38040378bd32c42cf0e33b400a42b2b44b8 -b baz\ngit pull https://github.com/gilch/hy.git defmacro!\npip install -e .\nThe defmacro! works without a hitch. Is it possible that one of the changes that has been done to master since this PR has been created has broken this? Travis is only run when PR is created and not for every subsequent change to master?\nBecause to me it looks like that checkout out this https://github.com/hylang/hy/commit/920b35f129402f4ecfe9f9a32d7be6ba217a4e8c and pulling defmacro! branch on top of it works fine, but doing the same with this https://github.com/hylang/hy/commit/87ee69e9673809af371b542aa48740009cef4f6a fails.\nCould someone else had a look too and confirm this?\n. I poked this with a stick a bit. Funny thing is that at least in Python 3.5 getfullargspec catched all exceptions and raises TypeError instead. By putting try-except around getargspec call and printing out __cause__ magic attribute, we get: \"'o!n' is not a valid parameter name\". So I guess that's the problem (part of it at least) and we need to mangle the 'o!n' or something?. => (defn expensive-get-number [] (print \"spam\") 14)\n=> (defmacro! triple-3 [o!n] `(+ ~g!n ~g!n ~g!n))\n=> (triple-3 (expensive-get-number))\nspam\n42\n=>\nNo clue what else I just broke though. Tests pass, so I guess it's ok until proven otherwise. There's \"working\" code at tuturto@108e2aef4ce5a\nIt's ugly hack and doesn't address the rootcause. I couldn't figure out how to mangle/punycode macro arguments/parameters so we wouldn't have to add that try/expect - block there.. After poking this a bit more, I have to conclude that there's no way that I could fix this. Might actually be that there's no way in general to fix this as long as we want to have that getargspeccall there. o!n isn't valid parameter name in Python and that's the root cause.\n@gilch and (@hylang/core in general) have a look at merge+hack for #903, containing tuturto@6f37499d39e959b and tuturto@108e2aef4ce5a6 . Maybe we could work around the issue like this for the time being?\nEDIT: never mind, I broke something. Instead of:\nHyMacroExpansionError: b\"expanding `let': missing 1 required positional argument: 'variables'\"\nI get now:\nHyMacroExpansionError: b'expanding `let\\': TypeError(\"_hy_anon_fn_4() missing 1 required positional argument: \\'variables\\'\",)'\nSeems to be broken in 903 already. Code, how does it work?\nOk, one more try. tuturto@3bbae1a includes reverted changes. Now we have better error messages when macro expansion fails, defmacro! works and tests are generally happy. In combination case, like using macro defined with defmacro! and not suplying it with correct amount of parameters, we still get ugly error message. We can solve that in a different pr/bug or just live with it.\nForgot to mention. That nugget branch is based on this PR, so one can just take #903, pull changes from my branch, maybe squash a little bit and it should be good to go into master.. I like the hy-repr but it's not enough when expanding complex macro. I end up counting parentheses or copy/pasting the result into somewhere where I can format it into readable format.. I added the ones mentioned here (except the integer thing) and created a pull request. Should probably go through all the keywords and such and check if they're mentioned in language-hy or not.\n. Interesting. Why would one want to compare if 1 is smaller than? I can understand comparing more than two: (< 1 5 7) to check that they're in ascending order. What would be the actual usage of this?\n. Right, makes sense then. What would value be for each of them, true for all? true for some and false for others?\nin, not in, is, is not I would leave as they are now, unless there's some good reason to do it otherwise.\n. looks good to me :+1:\n. Having decorators declared after the function name makes more sense to me. It makes it easier to spot function name in a glance when reading code and I would argue that the function name is more important than decorators being applied to the function. We have to remember to consider the case where function is being decorated with more than one decorators.\n(defn addition ^[@increment] [a b] (+ a b)) allows multiple decorators, because of the list structure, but (defn addition ^{:decorator increment} [a b] (+a b)) doesn't. Would (defn addition ^{:decorator [increment multiplication]} [a b] (+a b)) make sense? I'm not a big fan of having a list there, but can't think of any other way of specifying multiple decorators.\n@gilch has a good point about being able to decorate classes. It would be nice to have the same syntax on both function and class definition, so one has to remember less of syntax.\n(defclass Foo [Bar] ^{:decorator [Baz]} ...) would work I guess. I would put the decorator list at the end for the same reason as with the function definition.\n. I think that linking to Python's documentation with a brief passage of text would be enough.\n. With this defmacro! is working. Great!\nHowever, something else was broken in defmacro as this doesn't work anymore:\n(defn test-defclass-macroexpand []\n  \"NATIVE: test defclass with macro expand\"\n  (defmacro M [] `(defn x [self x] (setv self._x x)))\n  (defclass A [] (M))\n  (setv a (A))\n  (a.x 1)\n  (assert (= a._x 1)))\nI get a traceback:\nhy.errors.HyCompileError: Internal Compiler Bug \ufffd\n\u2937 IndexError: string index out of range\nCompilation traceback:\nFile \"/home/tuukka/programming/hy/hy/compiler.py\", line 432, in compile\n    ret = self.compile_atom(_type, tree)\n  File \"/home/tuukka/programming/hy/hy/compiler.py\", line 424, in compile_atom\n    ret = _compile_table[atom_type](self, atom)\n  File \"/home/tuukka/programming/hy/hy/compiler.py\", line 1949, in compile_expression\n    ret = self.compile_atom(fn, expression)\n  File \"/home/tuukka/programming/hy/hy/compiler.py\", line 424, in compile_atom\n    ret = _compile_table[atom_type](self, atom)\n  File \"/home/tuukka/programming/hy/hy/compiler.py\", line 366, in checker\n    return fn(self, expression)\n  File \"/home/tuukka/programming/hy/hy/compiler.py\", line 2332, in compile_class_expression\n    expr = rewire_init(macroexpand(expression, self.module_name))\n  File \"/home/tuukka/programming/hy/hy/macros.py\", line 155, in macroexpand\n    tree = macroexpand_1(tree, module_name)\n  File \"/home/tuukka/programming/hy/hy/macros.py\", line 178, in macroexpand_1\n    m_copy = make_empty_fn_copy(m)\n  File \"/home/tuukka/programming/hy/hy/macros.py\", line 135, in make_empty_fn_copy\n    if a[0] == '*':\n. I really would like to see #924 working with #903 and this, since better error messages is always a good idea. If I have time, I'll try poking around the code in the evening.\n. &key, &optional and &kwargs probably don't make sense in the context of macros currently.\nThe code looks solid to me :+1:\n. Looking sweet. Can't wait for this to be available. Can you add docs for this?\n. Looking good. Could you still update import and require use double backtick as in: import so they'll render correctly? Thanks for the doc update, they're always lagging behind.\n. Great, thanks for the updated docs on all PRs. Add yourself in AUTHORS file still.\n. +1\n. This might have changed since I last checked, but I thought there is no way to use Hy macros from python code? So even if importing would work, the result wouldn't be useful on Python. Importing gives you set of anonymous functions that when called return HyExpression.\n. If you're using Hy installed from PyPi, correct syntax is:\nhylang\n=> (let [[x 5]]\n...  (print x))\n5\nSyntax of let will change in the next release. Correct version of documentation can be found at: http://docs.hylang.org/en/stable/language/api.html#let\n. Syntax of let has changed between current stable version and the development version found in master. This will work\n`` hylang\n(defmacro rev [code]\n   (let [[op (last code)]\n         [params (list (butlast code))]](~op ~@params)))\n(rev (1 2 3 +))\n```\nDocumentation for stable is at: http://docs.hylang.org/en/stable/index.html and should be valid. I scanned through the documentation of current stable branch and didn't find errors in macro definitions there. However, if you spot an error there, do let us know about the error and location in docs and it'll get fixed. Or submit a PR for fix, we're more than happy to have help with the project.\n. No problem at all, you aren't the first one do that. Closing this now then, but feel free to open new issues if you encounter more unclear things or bugs.\n. Looks good to me, but I might be biased since I have been taught how to do that.\n. I understand where you're coming from and both are very valid points. That's why I wrote \"in general\", but maybe we should expand that a bit with something along \"Generally there is no need to open an issue before submitting a PR, but feel free to open one if you're unsure about the proposed change or it is a major change to Hy as a language (changed syntax for example).\"?\nHaving to open an issue and then wait for feedback from community will slow things down (granted, which sometimes is a good thing) and probably discourages new contributors from opening their first PR.\n. Agreed, that's much better. I updated the PR.\n. implemented with commit 2caf0cc\n. @levthedev thanks for writing this. I might be mistaken, but I think this is your first contribution to Hy. If that's the case, you could add your name to AUTHORS file.\nWe're looking forward for further contributions and thanks again.\n. Indeed, would make sense to have HyDict and friends available without explicitly importing them.. Looks nifty, but docs and some tests would be nice as I'm not 100% sure I understand all the implications.\n. Functionality similar to old behaviour can be done by using len as dispatch function and using &rest args in function signature. But it does require pretty substantial modifications to existing code. Hm.. maybe we can come up with a different name for new defmulti macro and leave the arity overloading in place? Or just decide to use the same name, but in different module, thus allowing users to require either one, but not both at the same time.\n. How about a name that reflects that it's doing arity overloading? arity-overload or just simple defoverload? I'm finding it hard to find a good name.\n. @Kodiologist I wouldn't want to have two constructs that have same name, but different behaviour in the language (even if they're in contrib module). @gilch suggested that we rename old defmulti to defn and have it detect when we're arity overloading and when it's just a normal function definition. I like the idea, but haven't done anything for it. I try to have a look at that some time soon, hopefully.. I added previous version of defmulti and renamed it to defn. This version of defn detects when it should make an arity-overloaded version instead of regular one. All tests pass, but there might be some corner cases somewhere that don't really work (but that's why it's in contrib anyway).. I went through some of current code of mine to see what would happen if let were removed. Code had 330 (if I did my grep correctly) instances of let. With random sampling, I didn't find any instance where let couldn't have been replaced with setv, as they were mostly used in beginning of the function and never to shadow another symbol with same name. Removing let would break all those 330 places of code, but if we were to replace let with a macro that generates setv instead, it should be (mostly) smoothly sailing.\nHowever, we have to remember that this is just a one project and out there might code that uses let differently. At the minimum, I would like to see let macro like I described before. Documentation would have to point out very explicitly what's going on with it and even then I suspect there would be cases where programmer assumed that let works the same way as in other lisps and didn't check the documentation.\nBut I would be totally thrilled to see yield, await and co. work. Sorry for hijacking the ticket.\n. > If we do put in a let macro that translates to setv, it had better be in contrib and marked as deprecated. I would rather fix old code or just use legacy Hy than have a core let that still makes no sense forever. If we don't have a let in core and we do eventually get it working, we can add it back in without breaking API again. If the setv let is already in core, we can't do that.\nThat would make sense. Then the wart would be hidden away and only used by people explicitly choosing to use it. I would be more than happy with such a decision.\n. I'm in favour of this :+1:. As much as I would like to see let stay in Hy, I think it's time to move forward and get this over with. Having let macro in contrib would be a remedy and give people time to update their code when we release (syntax of many other things will break too, so it'll be pretty substantial change anyway).\n. Is this closed by #1135, or do we want to have more automation in place at this point?\n. With Python's truthiness and collections this could be useful. I imagine it would be used similar to ap-if\nhylang\n(cond [coll]\n  [true []])\nwould be equivalent to\nhylang\n(ap-if coll it\n  [])\nBoth would return coll if it's a non-empty collection. Otherwise an empty list would be returned.\nAnother idea is to return first true value returned by a group of functions (although one could build this with a list of functions and some map + filter and then process wouldn't be so hard-coded):\nhylang\n(defn translate-account-number [acc-id]\n  (cond [(translate-finnish-account acc-id)]\n    [(translate-swedish-account acc-id)]\n    [(translate-norwegeian-account acc-id)]\n    [true (raise-error \"Unknown format\")]))\nThis function would take an account id, try to use three different translation methods and return result of first succesful translation (each function would return nil if they can't perform translation). In case no translation is possible, an error is raised.\n. I don't know why GitHub is showing conflicting files, while doing manual merge didn't show up with any conflicts. But I'm getting really strange error now:\n\nERROR: NATIVE: testing anaphoric if\nTraceback (most recent call last):\n  File \"/home/tuukka/programming/python/virtualenvs/hy/lib/python3.4/site-packages/nose/case.py\", line 134, in run\n    self.runTest(result)\n  File \"/home/tuukka/programming/python/virtualenvs/hy/lib/python3.4/site-packages/nose/case.py\", line 152, in runTest\n    test(result)\n  File \"/usr/lib/python3.4/unittest/case.py\", line 625, in call\n    return self.run(args, kwds)\n  File \"/usr/lib/python3.4/unittest/case.py\", line 585, in run\n    self._feedErrorsToResult(result, outcome.errors)\n  File \"/usr/lib/python3.4/unittest/case.py\", line 516, in _feedErrorsToResult\n    result.addFailure(test, exc_info)\n  File \"/home/tuukka/programming/python/virtualenvs/hy/lib/python3.4/site-packages/nose/proxy.py\", line 143, in addFailure\n    formatted = plugins.formatFailure(self.test, err)\n  File \"/home/tuukka/programming/python/virtualenvs/hy/lib/python3.4/site-packages/nose/plugins/manager.py\", line 99, in call\n    return self.call(*arg, kw)\n  File \"/home/tuukka/programming/python/virtualenvs/hy/lib/python3.4/site-packages/nose/plugins/manager.py\", line 141, in chain\n    result = meth(arg, **kw)\n  File \"/home/tuukka/programming/python/virtualenvs/hy/lib/python3.4/site-packages/nose/plugins/failuredetail.py\", line 45, in formatFailure\n    tbinfo = force_unicode(inspect_traceback(tb))\n  File \"/home/tuukka/programming/python/virtualenvs/hy/lib/python3.4/site-packages/nose/inspector.py\", line 31, in inspect_traceback\n    lines, exc_line = tbsource(tb)\n  File \"/home/tuukka/programming/python/virtualenvs/hy/lib/python3.4/site-packages/nose/inspector.py\", line 101, in tbsource\n    while lines[index-1].strip().endswith('\\'):\nIndexError: list index out of range\n\nAnd it doesn't seem that anaphoric if is to blame. I'll dig around a bit and see if I messed up something.. I haven't touched this in a while, my bad. At the latest during the holidays I'll try to have a look and get it done.. works for me now, so I'll squash/merge. closed by 13b484c . I made some mistake in manual squash and it didn't autoclose this.. This sounds intriguing and useful. Recently I had to hack together something that sounds like this, but it's specifically only for functions and requires extra step for calling them: (call foo bar) instead of just (foo bar).\nBut I'm not completely sure if I understand (or even can think of) all possible cases for this. Variables with dynamic scope would only be available inside a let form that referes to them? Or would they be available somewhere else too? Could one define a function with defn, bind it to dynamically scoped variable and then call it later during program execution? How would the definition part and calling part look like in Hy code? Any idea (rough sketch is enough) what the resulting Python code would look like?\n. Thanks for writing this down. It clears up lots of questions that I had. I would call the new form binding instead of let I think. Would make sure that code written in the old Hy wouldn't accidentally use let without knowing that semantics have changed.\n. Closed by 14fddbe\n. I'll start working on releasing 0.12.0\n. - [x] check news and update it if needed\n- [x] ... (all the missing steps here)\n- [x] Update version.py with new version number (if #1135 isn't merged yet)\n- [x] build and test install packages\n- [x] Write down instructions how to do release for the next time\n- [x] tag release in github\n- [x] let @paultag know that everything is ready for uploading to PyPi (remember setup.py!)\n- [x] Update docker image (or let maintainers to know new release is ready)\n- [x] Update Debian package (or let maintainers to know new release is ready)\n. It'll take some time to go through a year of commits and pull relevant things into NEWS file. But that's probably the most time consuming part. I'll be happy to include all the PRs that are closed into release and we really should aim to release a bit more often anyway.\n. I don't like breaking code more often than absolutely necessary either, but 0.11.0 is over a year old now. I agree with inceremental changes. Easier to fix 2 months worth of changes than 12 months worth of changes.\n. https://pypi.python.org/pypi/hy/0.12.0. So far it's been announced in:\n\nTwitter: https://twitter.com/hylang/status/821786120086290432\nGoogle Groups: https://groups.google.com/forum/#!topic/hylang-discuss/lL0iQmGMP3s\n\n/r/lisp would be good and I'm sure there are still others. @Kodiologist would you do /r/lisp?. We should, but I don't know where or how try-hy is updated. Docker image and debian packages need some love too.. Great, thank you @tianon . Quick and dirty version: https://github.com/hylang/hy/wiki/Release-instructions\nShould cover all the important bits. Not sure if I forgot any forgotten bits, but they can be added later.. To me this looks good. Are there any open issues we need to tackle before merging this in? This adds git as a dependency to setup.py, but I guess that's quite safe bet?\n. That's my understanding based on the code and discussion here. That of course means that the person doing the release have to remember to generate the version.py, otherwise \"unknown\" is reported as version number. Good news is that users won't notice anything different.\n. We could even have both I think. version.py would be updated every time code changes on the main repository and running setup.py would also generate it. But I would do that as a separate thing and get this in first and test how things work in practice. \nOn that note, flagging build as dirty isn't surefire solution. If I want to tinker with internals of Hy, I usually install editable version from github. At that point workarea is clean and I'll get the same version number as the github version has. Only after that I start editing and messing with internals, but version.py won't be updated anymore.\n. Since this has been approved and there aren't open issues, I'll merge this. We can tackle the git hook in separate issue.\n. @Kodiologist nothing anymore, now that I had chance to go through the code with some thought. Looks good to me.\n. uh, why did this closed automatically? I'll check what's going on.\n. Apparently I don't know anymore how to rebase properly :D Will clean up the mess and push changes again to my topic branch.\n. @hylang/core should we include more in this release or is this ready to be cut? I'm inclined to get this out as soon as possible and release next version in 3-4 months from now on. After this has been acked and merged, @paultag can build packages and upload them to PyPi.\n. Looks like #908 and #1147 will take some time still. Not sure if it makes sense to wait for them, but lets see how long they'll take. I'll have a second look at #1105.\n. #1105 was merged, but there isn't much progress in #908 / #1147. Should we rather include it in the next release? Anything else we definitely want in this release? We can always make another release relatively soon.\n. merge+hack for #903 has some changes that make defmacro! to work again. We can even have nicer error messages for macro expansion most of the time.. On a quick glance we don't have anything open that couldn't wait for next release (that hopefully won't take another year to make). :+1: from me for cutting a new release.. nobody in @hylang/core has objected or wanted to add new content, so I'll tentatively tag this in the evening and test that PyPi package can be created and looks/feels correct. @paultag can then create package and upload it to PyPi.. Installed hy from git into a fresh virtualenv, copied tests directory and README.md and run nosetests. All tests pass.\nSo feel free to hit the Squash and merge magic button and tag the release.. Not yet, but hopefully sooner than later.. Good catch with the typo @gilch. I hadn't fixed it in both locations.\n. Polished the documentation a bit again. Anything else that needs some cleaning up here or would this soon be good to go?\n. As this has multiple thumbs up already, I'll merge this one too (even if I'm the originator).\n. This is good change in my opinion. It will be a bit of a pain to fix all of existing code, but it'll be worth it.\n. One implication that I didn't spot, but that was pointed out to me is that if we have a module with several macros that depend on each other, we either need to make sure all needed macros are actually required. This means that client code has to require them explicitly or with *, or that the macros themselves have to require them. This can make code somewhat ugly. What do you think, how big problem this is?\n. It's just something to be aware of I guess. Since this has two acks and no open issues I'm aware of, I'll merge this into master.\n. :+1:\n. Not quite sure what I would expect : to be actually. Why do we want it to be an empty keyword instead of an error?\n. True, that wouldn't work at all. Had to read up a bit about pandas to understand what's actually going on there. Not 100% sold yet though, I'll mull over this a bit.\nTo clarify: treating : as an empty keyword is ok by itself. But I'm not particularly happy that one can call a function with empty keyword: (foo : 'bar). Then one can create Hy code that is somewhat hard to call from Python (not that we aren't already allowing that though), if the called code expects or allows parameter with an empty name.\n. Yes, : looks good and logical in the example, but I'm not sure it has to be keyword. On the other hand, maybe I shouldn't be concerned that users will create some funky code if : is treated as a keyword? What other implications are there, if we decide to go this path? Or rather decide that : being treated as an empty keyword is actual feature and not a bug.\n. We could also treat : merely as a symbol, instead of a empty keyword. But of course the usual way to write that would be ': instead of :. So, looks good to me I say.\n. @hylang/core want to have a look and squash/merge this in?. I would be sad to see irc to go. It's excellent place for informal chat about Hy, projects using Hy and even some unrelated things now and then. But I agree that it's not as active as it used to be. I guess it's one of those things that need to have active users, so that it will attract more active users.. Hm.. completely forgot Python 2.x. I'll have a look and fix this.\n. Thanks @kirbyfan64. I'm not a native speaker and tend to make mistakes like these if I don't pay really close attention.. Looks good, I didn't spot any problems with change (albeit it's lots of change). We can deal with flake8 errors in a separate PR I think.. Ignoring would work too. The whitespace error isn't that major (normally I don't like ignoring errors and saying that it'll be fixed later).. Looks good to me. No problem at all.. Eg is useful as it shows some examples of how to use the language for various tasks. We could have a wiki, blog or something else too, but then the examples would be dead in a sense that they wouldn't be tested when hy itself changes. I would like to keep the examples there and point them out in the docs if they already aren't.\ncontrib on the another hand might be problematic in the future as they tend to grow (at least in quite many projects I quickly checked). I have treated it as sort of experimental side of hy, where one can introduce new features that might not yet be quite there. Eventually they could be pulled into the core if we so decide (I think this hasn't happened ever happened). But definitely, we should put up a guideline what goes here and how.. Good catch. Eg should go then. . This looks really nifty. I like the example with odd and even, never thought it that way. \nIf I read this correctly, importing RailRec will enable this only in that specific module? This would be good, as @bowbahdoe pointed out, some fairly simple pieces of code might break.\nI can't really comment on the code, but the idea, examples and docs in general are in order.. This doesn't seem to work in the interactive mode. Not sure how much hacking that would require, also if we would then need a way to turn it on and off too, but might be a good idea to mention that in the docs?. For Python, keywords are just fancy strings that start with specific symbol (\\ufdd0: to be specific). Symbols are mangled, because foo? isn't valid name for a function for example, while is_foo is. For strings there's no such a restriction. I wouldn't mangle them.. Indeed, had to write some rather nasty code because of this :\n(apply helper [] (dict-comp (cond [(= (first x) :match?) \"is_match\"]\n                                  [(= (first x) :match!) \"match!\"]\n                                  [(= (first x) :no-match!) \"no_match!\"])\n                            (second x)\n                            [x (group funcs)])))\nSo obviously I was wrong earlier and we probably should mangle them in some cases. But should we mangle them when they're used as dictionary keys?. Hy is lisp-1. Functions, variables and such share the same namespace.. Example of a good error message:\n\n=> (let)\n  File \"\", line 1, column 1\n(let)\n  ^---^\nHyMacroExpansionError: b\"expanding `let': missing 1 required positional argument: 'variables'\"\n\nExample of a bad error message:\n\n=> (defmacro bad [bad-param!] \"hello world\")\n=> (bad)\n  File \"\", line 1, column 1\n(bad)\n  ^---^\nHyMacroExpansionError: b\"expanding `bad': missing 1 required positional argument: 'bad_param_bang'\"\n\nExample of very bad error message:\n\n=> (defmacro very-bad [bad-!-very-bad] \"hello world\")\n=> (very-bad)\n  File \"\", line 1, column 1\n(very-bad)\n  ^--------^\nHyMacroExpansionError: b'expanding `very_bad\\': TypeError(\"hy_anon_fn_1() missing 1 required positional argument: \\'bad!_very_bad\\'\",)'\n\nSo as soon as we get to the terroritory of invalid parameter names, this code starts to break apart. Mangling helps a bit, but it doesn't cover all the cases.. Hm.. I don't know why would it do that from top of my head. But, I have found using macroexpand really useful when debugging macros:\n\n=> (macroexpand `(= \".\" ~(get (name numpy) 0)))\n('=' '.' 'n')\n. Rather interesting really. I can't seem to pinpoint why this is happening or what exactly is going on. But maybe this sheds some light into the problem:\n=> (type (first (= \".\" ~(get (name numpy) 0))))\n<class 'hy.models.symbol.HySymbol'>\n=> (type (get(= \".\" ~(get (name numpy) 0)) 1))\n\n=> (type (get `(= \".\" ~(get (name numpy) 0)) 2))\n\n\nFirst two elements of the expression are in internal representation and the third one is plain string. If/why this would cause such an error message, I don't know. Not yet at least.\n. I don't really know what would make most sense. In theory, we could have quasiquote to check for types and cast Python ones to Hy ones where needed. Have to ask if rest of the team has good ideas about this and how it should be handled. Interesting corner case in any case. . complement isn't in the file, that's something @pyx mentioned in email. I asked about the details, but I think it's the same as Clojure's complement.\nFollowing Clojure's naming convention sounds reasonable to me.. I was assuming that for flip we would just reverse the arguments as a whole. Maybe we should prototype it a bit with examples before implementation? Like where it would be mostly used.. heh, that's rather embarrassing. I'll fix that. Good that it was spotted so soon.\nEdit: actually, @pyx, can I just copy your implementation? It's concise and I don't think I can come up with anything like that. It's on a different license of course.. Thank you @pyx. I added the atleast-one-argument version and fixed docs while I was at it.. I find it bit counter-intuitive that comp without any parameters returns identity, but it doesn't really make sense to deviate from other lisps. I added that there too now.. oh, hm.. If you put it that way it makes sense.. Nice work and quite big difference in the speed already :heart: . I updated comp to @pyx version. Happy holidays people \u2764\ufe0f. Thanks for all the help and you're always welcome back when time is right again.. The thing I really like about read the docs is the automation. Documentation for the bleeding edge is up to date (well, as much as we keep it up to date), without us needing to manually update it. We could host it in Github pages (for example), but then we would have to come up with the automation by ourselves. I suppose that's doable though?. It's under settings | integration & services. One of those nifty features that made GitHub so popular (not the readthedocs per se, but support for various services in general).. That's the thing. Configuration is at the readthedocs end. On the GitHub side one can just enable/disable the service. And since we don't have access to readthedocs side, we can't change the default branch. Which in turn has lead to several questions about why example code for let doesn't work.. Can we update NEWS too? It'll make next release easier to do.. it's good, thanks. First thing to come to mind is that lambdas can't be decorated:\n```hy\n=> (defn double [func] (fn [x] (* (func x) 2)))\n=> ((with-decorator double (fn [x] x)) 5)\n  File \"\", line 1, column 2\n((with-decorator double (fn [x] x)) 5)\n   ^--------------------------------^\nHyTypeError: b'Decorated a non-function'\n```\nBut without the changes, example works:\n```hy\n(defn double [func] (fn [x] (* (func x) 2)))\n=> ((with-decorator double (fn [x] x)) 5)\n10\n=> ((with-decorator double (lambda [x] x)) 5)\n  File \"\", line 1, column 2\n((with-decorator double (lambda [x] x)) 5)\n   ^------------------------------------^\nHyTypeError: b'Decorated a non-function'\n```\nIn my opinion, this is big enough drawback not to do this change.. Point of the code was to show a simple testcase which will fail if this change is pulled in. Actual content of the example decorator isn't important. Currently user can be confident that result of fn can be decorated, regardless of how simple or complex it actually is. With the change, they can't anymore. . Right, now I follow. Shouldn't test things before second cup of coffee in morning.\nIndeed, following works as expected:\nhy\n=> (defn double [func] (fn [x] (* (func x) 2)))\n=> (with-decorator double (defn test [x] x))\n=> (test 2)\n4. They're pretty different. Mine is a (possibly recursive) sequence defined in terms of index. Think of fibonacci:\n```\n=> (defseq fibonacci [n]\n...    (if (= n 0) 0\n...        (= n 1) 1\n...        (+ (get fibonacci (- n 1))\n...           (get fibonacci (- n 2)))))\n=> (get fibonacci 6)\n8\nOne can iterate over it, but the iterator is mutable (because it's just a normal iterator):\n=> (setv fibs (iter fibonacci))\n=> (first fibs)\n0\n=> (first fibs)\n1\n=> (first fibs)\n1\n=> (first fibs)\n2\ngilch's approach takes any iterator and creates a new immutable iterator:\n=> (setv fibs (Seq fibonacci))\n=> (first fibs)\n0\n=> (first fibs)\n0\n=> (first fibs)\n0\nHowever, since it doesn't definegetitem``` magic method, indexed access is not supported.\nSo they're solving related, but slightly different problems.. I would really love to see this in Hy. While I like using iterators, I know from first hand that some cases are hard to work with and can introduce subtle bugs. Should come up with good naming though, that separates these two from each other. Since @gilch's is closer to what clojure's sequences are, I would propose to renaming my solution to something different.. Long and good discussion. I love seeing people hashing out some hard problem respectfully \u2764\ufe0f \nI'm having hard time deciding either way though. I would like the idea that I can just copy/paste repl output back to input and have it work. But I'm bit hesitant if it would be confusing to people (old and new to Hy alike) that it sometimes works and sometimes doesn't.\nLets run an experiment: we could bring this in, have it disabled by default, activated by command line switch and see how it behaves in the wild. After some amount of time, we can get back to the matter and see what we learned. At that point we can adjust things or even remove it completely (as if any project would remove a feature, ever) if this turned out to be a bad idea. How does this sound like?\nI didn't look into code really. Just got up and had interesting looking notifications from GitHub waiting \ud83d\ude01 \nOh, and can we fix REPL printing out what setv was used to set? And have --spy print out ast even when exception is thrown?. > Would you approve hy --repl-output-fn hy.contrib.hy-repr.hy-repr, then?\nPersonally I like --hy-repr tons more, but I guess I can live with this. If we add --repl-output-fn, can we still have --hy-repr shortcut? . hm.. true. No need for the shortcut.. Also, realized that macroexpand is really nice now:\nhy\n=> (macroexpand '(if (= a 1) \"one\" (= a 2) \"two\" \"many\"))\n'(if* (= a 1) \"one\" (if (= a 2) \"two\" \"many\"))\nSomehow missed this fact while testing earlier.. @kirbyfan64 we're good to go. There probably should be a mention of f-strings in the docs somewhere, but I already like where this is headed.. Yeah, I'll try to tackle this soon. Having plenty of things on my plate currently. In the meantime, @paultag any comments?. For what it's worth, I get all lowercase inf and nan when doing float('NaN') on my Windows 10 machine or Linux machine, on both Python 2.x and 3.x. That said, I kind of like NaN nicer looking than nan.\nI would be inclined to choose NaN and Inf```` overnanandinf``, but I don't feel about this particularly strongly.. returningNonesounds like a reasonable approach. Out of all options, I like balanced style best.. Plain style can go. I don't have strong opinion about whitespace, but I'm actually slightly leaning towards requiring it. But for me either (whitespace, no whitespace) is ok.. :-1: from me. If we use readthedocs, we should respect their policies.. Would make sense to fix this so Hy would work in the same way as Python (even when_42and similar are really rarely used names).. That's by us (https://github.com/hylang/hy/blob/7c53a07b93084a0970cdf192d4aa2d712d557154/hy/cmdline.py#L116 for relevant spot). I like the idea of1,2and so on. Three should be enough I suppose?. Like @Kodiologist said, it's hard to see what's coming up in the future. We're fairly loosely knit group and don't really have any concrete long term plans and people work on things that they find interesting or most pressing at any given time. For what it's worth, I'm writing about Hy semi-randomly at https://engineersjourney.wordpress.com/category/hy/ but wouldn't really want to commit into maintaining an official blog..defsharphas been renamed todeftag``\n=> (deftag \u2663 [expr] `[~expr ~expr])\n<function <lambda> at 0xb6a317c4>. Looks like NEWS doesn't mention deftag change.. Documentation (the little what we have) for deftag is here: http://docs.hylang.org/en/master/language/api.html#deftag The version of docs depends on the version of Hy (master or stable) and can cause confusion if wrong version is used.. Looks good, can you resolve conflicts still?. Eh, sorry. I should have looked into conflicts before asking you to resolve them.. This looks good, but I would like to see docs to be updated with the same PR. It doesn't have to be anything fancy, just clarify how body of try is constructed.. The latter one, I expected dictionaries be left as they were. And even if dictionaries were flattened, we shouldn't be discarding half of the information (keeping only keys and discarding values) while doing so.. This is due to how Python handles functions. They're first class citizens and come with their own state. I got bitten by this couple of times, before I learned what was going on. In short, test is a function object, that has optional bar argument. Value of bar is initialized when function is defined. Calls to bar then modify that value and cause the effect you observed in subsequent calls. Well written bug report, thanks.\nhttp://effbot.org/zone/default-values.htm explains this in more detail.. Releasing 0.13.1 sounds like a plan to me.. :+1:. But on the other hand, it simplifies code generation. In this case, that's a trade off I would be willing to make. If lambda is supported, we need to work around some special cases like decorating it (#1506).. +1 and two weeks is fine.. Having to review bigger changes would probably mean that I would be reviewing them even less frequently. At least I'm having hard time finding enough time to really look into changes introduced in any given PR and understand what implications they might have.\nHaving more members in the core would be a good idea.. \nSetting attributes of object from parameters in --init-- is so common that I ended up with small macro just for that (excuse the naming):\n(defmacro set-attributes [&rest attributes]\n  \"set attributes of object with respective parameters in --init--\"\n  `(do ~@(genexpr `(setv (. self ~x) ~x) [x attributes])))\nArguably it could be called to init-attrs or even assoc-a, but I never got around it. It's also specific to setting values to self, but that could be fixed by introducing a new parameter. Back when I was thinking about this I couldn't come up with a better way to handle the situation.\nIn any case, I would keep assoc around for future, if for nothing else than for saving couple characters while typing.. I have bunch of macros that rely on mutable Hy models, but it wouldn't be big hassle to rewrite them I suspect. I rather have immutable Hy models, if it will help preventing strange bugs like these (this one had me scratching my head for a while). Looking good to me. I like idea of renaming eval to hy-eval. I most of the time use hy-repr when using REPL, but I recognize that not everyone is doing that. Maybe we'll just vote on this and let the majority decide if hy-repr is enabled by default?. good catch, should be better now. I wasn't aware of that. Thanks for the tip, that's good to know.. Should we aim for Perl 5 or Perl 6?. Just to make sure, this means removing support for following or something completely else?\n=> (defn foo [(, bar baz)]\n...  (+ bar baz))\n=> (setv test (, 1 2))\n=> (foo test)\n3\nIt's handy, but I don't see that so often. I don't have (strong) objections on removing it.\n. I guess one could in theory combine that with optional parameters:\n(defn foo [&optional [(, bar baz) (, 1 2)]] ...)\nBut then we would have to have a special case for\n(defn foo [&optional (, bar baz)] ...)\nis both bar and baz None? Or is the tuple None and unpacking will thrown an error? There might be other special cases too that I fail to think right now. I think it's better to remove it and do unpacking inside of the function.. I'll have a look tonight. True, rather have new release out sooner than later. Personally I don't know any other PRs I would like to see in the next release that wouldn't already be included.\n:+1: for the release from me.. This is exactly one of those things that would confound a person who is not aware of the difference. Thanks for explaining both ways @rahmu and @olasd. I have edited the documentation to include both examples. Could you check that I got it correctly, especially the explanation why this is happening?\n. That's a good idea. It doesn't hurt to know how decorators actually work.\nI tried to make an example (the same contrived inc-decorator) with assignment but couldn't quite get it working yet. I'm probably missing something obvious, so I'll give it another try later today.\n. That's something that I would like to know for sure. As far as I understood it, foreach will iterate over the collection and call the side-effect for each element. After the collection has been exhausted, the side-effect2 will be called. I'll try to find more info on this and clarify the docs.\n. ah, good catch. I'll add that.\n. @paultag what are the plans regarding def? It would be a good idea to mention them in the docs if the change is anticipated.\n. there's now a newer commit (e09a89b) that contains a better explanation.\n. all good points. I have cleaned up the documentation in 6665a2b\n. it is true that your example achieves the same result; however, under the hood the macro is expanded into the version currently shown in the documentation. From the point of view of the user there shouldn't be any difference I think.\n. Hm.. true that. The documentation assumes that the reader is familiar with macros and other little quirks of Lisp. There probably should be a section somewhere that goes more deeply into macros, how they work and what they can be used for. I don't know enough yet in order to write that, but I'll keep working on learning Hy.\n. \"fo;ter\" looks like typo to me\n. I'm getting an error about operator.add not being a package. Should this be:\n(import operator)\n. This is really nifty and readable way of writing tests. I like a lot.\n. Does this test that partial has been rebound only locally? Since isn't six-plus defined at the beginning of the test and after that partial is not called again?\n. You are correct, it is no longer needed. Good catch.\n. extra space in \"styl e\"\n. this should test ap-last instead of ap-first\n. for gensym to work, every instance of n should be ~n. This applies to both ap-first and ap-last\nThis is with n\n=> (macroexpand '(ap-last (> it 10) (range 10)))\n(('fn' [] ('setv' 'n' 'None') ('ap_each' ('range' 10) ('is_none' 'n') ('when' ('>' 'it' 10) ('setv' 'n' 'it'))) 'n'))\nAnd this is with ~n\n=> (macroexpand '(ap-last (> it 10) (range 10)))\n(('fn' [] ('setv' ':n_1240' 'None') ('ap_each' ('range' 10) ('is_none' ':n_1240') ('when' ('>' 'it' 10) ('setv' ':n_1240' 'it'))) ':n_1240'))\n. would it make sense to have test for both cases? one test for - with a single parameter and another one with more than one?\n. this is fb98bf5 Don't really know how to explain that\n. This is e54d4be and the one in language changes is 0a942a0 (If I understood your intent correctly \"One arity comparison operators\"). I would keep them separate I guess.\n. ah, I'll remove that then. It's probably not interesting for users.\n. Right, I should learn to read whole sentences.\n. good catch, tuple is one of those words that I consistently misspell.\n. true, assigned-name is much better. I'll try to think better explanation, but currently I'm drawing a blank.\n. Thanks, I'll update this\n. Instead of assigned-name I could also us it as it's short and generic enough. I'll try to come up with a better examples still, that would highlight usage of as-> better (as now the example could be easily rewritten with ->).\n. If I read the code correctly, following doesn't work:\n(require [foo [bar :as baz]])\nbut similar does work for import though\n(import [foo [bar :as baz]])\n. This is good addition. I got bitten by this multiple times, until I learned it hard way.\n. got it. added, thanks. True, it is. It's just a habit that I picked up at somepoint. If we prefer (setv self.func func) instead of (setv (. self func) func) I can edit that.. Just a small change. I would write \"make sure you check the docs.\".. example is broken. A working version could be:\nhy\n(defmacro nif [expr pos-form zero-form neg-form]\n  (with-gensyms [g]\n    `(do\n       (setv ~g ~expr)\n       (cond [(pos? ~g) ~pos-form]\n             [(zero? ~g) ~zero-form]\n             [(neg? ~g) ~neg-form])))). Yeah, looks like it. My bad. I must have done something extremely silly while testing that.. [] sounds safer option to me. Or even raising a suitable exception (or is that too drastic?) Having a call to partition where n is 0 sounds like a bug to me and Hy probably should report that instead of trying to keep the system limping forward.. Weren't these two tests run for both Python 2 and Python 3? Would it make sense to keep them around for Python 3 still?. Would this benefit from same treatment of else as in https://github.com/hylang/hy/pull/1432 ?. Not necessarily something that needs to be done now, but what would it require to make atoms immutable? I sort of thought that would be the case already.. sb I couldn't parse before reading the definition down here. We don't want to use too long name, because typing it would get annoying, but is there better than sb that isn't too long?. out of those, I like brackets best. But this is nothing we need to solve if good name doesn't come easy. I just thought that since I really like the pattern matching rules we have now, we could have obvious names for them. Now new developer has to check the definition to understand what's going on (not that the code is long).. ",
    "Willyfrog": "On hold, i guess. I don't know of anyone working on it\n. I don't think I'll be able to pull my modifications to kwapply in time, I started them on monday late night and haven't touched them since.\nNot only is #219, also something else that will break existing code (but makes for a nicer syntax, so I'll check with you guys once I get both things working ;) )\n. Ok, didn't know kwapply was a partial application, I was thinking it was a full call operation.\nI'll rename that implementation into call as I still think it might be useful to someone (do you guys agree?) But I'll open a new PR as the title would mislead someone and close this one.\n. Currently I'm looking at the possibility of chaining kwapplys since current implementation would overwrite previous calls to kwapply instead of merging the dictionaries overwriting only the conflicting keys.\nAs soon as I solve the \"no lineno\" bug I'm having I'll take a look to the using keywords possibility.\n. I haven't based the branch on @rwtolbert 's branch as he is still changing it. If it is going stable soon, I don't mind rebasing his work in it to ease the merging.\nApply is defined for py3, kwapply keeps its syntax but it is now a macro on core.language (should we have a core.macros?)\nPlease review carefully kwapply's macros as I am a newbie to it.\nIf there ever is an implementation of clojure's # for making a symbol unique, it should be applied to fun in the macro to prevent possible name clashing.\n. Also, I think a name change should be proposed to kwapply, as it may mislead someone to think it works as apply and it does not.\nIn one of my multiple kwapply's reimplementations I had patch and kwpatch to do the same it is currently doing in hy, leaving apply and kwapply closer to pythons apply\n. Another edit: being a macro, kwapply now does not seem to allow nesting kwapply calls\n=> (defn suma [a b c d] (+ a b c d))\n=> (kwapply (kwapply (suma) {\"a\" 1 \"b\" 2}) {\"c\" 3 \"d\" 4})\nTraceback (most recent call last):\n  File \"<console>\", line 1, in <module>\nNameError: name 'kwapply' is not defined\nany suggestions to fix this?\n. There is the tutorial, which covers most of the syntax comparing Hy and Python and also there is issue #237 which is being worked on documenting most of the builtins.\nIs that what you were looking for?\nHope it helps :D\n. For the pycones I used \n(when (= __name__ \"__main__\")\n    (foo bar))\nand didn't find it too bad! Almost Hygienic\n. shouldn't it use a gensym for the name of the main function?\nI really like the new implementation :)\n. seems to be supported (just did a quick glance) on olasd's rply branch, so I'd wait for that to be finally merged into hy\n. @rahmu it uses the same check as any other function in hy.compiler I don't mind writing a line or two saying it throws an exception, but any other function doesn't specify that.\nAnyway, I leave that open to debate and make the change if people think it's neccesary\n. Seems good overall. Please, consider my suggestions with a grain of salt, since english is not my mother language :wink: \n. :+1: \n. I have tried 2 approaches with this, none of them succeded, but I'll name both so I can hear opinions on them:\n1. Make a HyLong. This would be called when int overflows, so no changes in user code would be needed. But this didn't work due to Python3 not having long (I didn't know it was merged into int)\n2. substitute int with long on python2.x it probably makes programs use more memory, still seemed a simpler solution up until I hit my dreaded long has no replace attribute.\nOpinions and thoughts?\n. minor nitpick: gensym should be moved up, as @rwtolbert ordered it alphabetically. If you do, please add a note at the beggining advising others to keep it that way it is easy to miss.\nI'd prefer there was 2 different arguments for index number and full prefix instead of one that does both jobs depending on what one uses as an argument. I you still prefer to have just 1 arg. it should probably be explained in the docstring.\nIf we are ignoring concurrency and the prefix is fixed it is fine for me, but I'm no hylang/@core so others must judge :wink: \n. @tuturto I also thought the same thing for overflowing the int into long in python2 and I updated my PR #284 accordingly.\nBut there is no \"overflow\" between str and unicode, sadly.\nEdit: by overflow I meant a scenario where it would be useful and not harmful. Thanks @olasd for pointing that it wasn't clear :wink: \n. Oh and it also adds long to the list of stuff a macro can build, wasn't possible earlier. Only for py2.x\n. on a second thought, wonder if it shouldn't be better to just change int to long on overflow as python does\n. I've left the 2 commits just in case it is decided to go back to the previous implementation. This one now uses overflow into long\n. Corrected typo in docstrings (it also happens on HyInteger)\nGracias @alejandrogomez \n. updated to master (I would prefer int_type to long_type, but since it got merged first I adapted this PR to it)\nremoved HyInteger/Hylong dychotomy\n. Now you can call (integer \"3\") knowing it will go to the right type of int\nI also simplified integer?\n. solved in #294 \n. While I like having a macro for checking that, I believe we can't call macros from other macros (or compile time), so we can only test from functions which is a shame\n``` Clojure\n=> (if-python2 2 3)\n3\n=> (defmacro test-if-python2 [is2 is3] `(test-if-python2 ~is2 ~is3))\n=> (test-if-python2 True False)\nTraceback (most recent call last):\n  File \"\", line 1, in \nNameError: name 'test_if_python2' is not defined\n```\nAlso, can I suggest having python2-form and python3-form as optional defaulting to True False if not specified? given the current name of the macro I think it would fit just fine.\n. duh! should have drunk more coffee this morning, sorry about that.\nAbout the default to true/false I was thinking along the lines (if (test-if-python2) (do stuff) (do other stuff)) clearly another case of needs-more-coffee\n:+1: then\n:blush: \n. :+1:  Great job! \n. Rebased, somehow github decided to show a prior commit : S\nI corrected @olasd points about noise and changed keyword symbol to % (easier to type than ^)\n. :foo is a clojure-style keyword and at the time I wrote that, there was no consensus on the whole keyword thing so I dind't remove it and looked for a separate symbol.\nCurrent stance (unless something has changed last month) is that clojure-style keywords should disappear and be replaced for a closer implementation of Common Lisp keywords.\nI'd love to have some spare time to hack on this, but I'm currently having too much stuff to do at the moment (mostly work)\n. :+1: good job @cwebber \n. :+1: \n. I really dig this, I thought about it while doing the keywords stuff\n. :+1: \nminor stuff: having done all the work rewriting them, into macros.hy, yield-from could be rewritten using the short version macros.\n. wouldn't that always return a bytestring? that would be opposite of what I intended as we are using unicode in everything\n. Thanks for the link! I did a quick search on that flag but nothing useful turned up.\nI'll look into it and see how does all that affect\n. rply dependency should be added before release\n. Here is a list of currently merged changes. I have edited the git log but it can probably be edited a bit more into a form better fit for public use\n- Many many many documentation fixes\n- Change virtualenv name to be hy'\n- Rewrite language.hy not to require hy.core.macros\n- Rewrite the bootstrap macros in hy\n- Cleanup the hy.macros module\n- Add comments to the functions and reorder them\n- Translation of meth from Python to Hy\n- PY3 should really check for Python >= 3\n- Add hy._compat module to unify all Python 2 and 3 compatibility codes.\n- Import **future**.print_statement in hy code\n- Coerce the contents of unquote-splice'd things to a list\n- Various setup.py enhancements.\n  - PEP8 fixes\n  - Use setuptools.find_packages()\n  - Update PyPI classifiers\n  - Update website URL\n  - Install the argparse module in Python 2.6 and before\n  - Delete the duplicate rply in install_requires. With the PyPI version, tests are failed.\n- Finally fixed access to hy.core.macros here. have to explicitly require them\n- Slightly cleaner version of drop-while, could use yield-from when ready\n- Added many native core functions\n- Add zero? predicate to check if an object is zero\n- Macro if-python2 for compile-time choice between Python 2 and Python 3 code branches\n- Added new travis make target to skip flake8 on pypy but run it on all others\n- Add \"spy mode\" to REPL\n- Add CL handling to hyc\n- Add yield from via macro magic.\n- Add some machinery to avoid importing hy in setup.py\n- Add a rply-based parser and lexer  \n- Allow quoting lambda list keywords.\n- Clarified rest / cdr, cleaned up require\n- Makewithreturn the last expression from its branch\n- Fix yielding to not suck (#151)\n- Make assoc accept multiple values, also added a even/odd check for checkargs\n- Added ability to parse doc strings set in defclass declarations,\n- Provide bin scripts for both Windows and *nix\n- Removessetfin favor ofsetv`\n. Added @olasd improvements\n@berkerpeksag we have removed the apply defined as only python3, now it is the same implementation available through all hy backends (pypy, py2 and py3)\n. i think it was ready for RFR since @olasd 's improvements\nupdate: the only improvement I can think of is to add some sintactic sugar to lesser the pain of kwapply or get keywords implementation (this is better but will take some more time, probably)\n. @theanalyst Sure! Gensym should be added to kwapply as soon as it is merged\n. rebased to current master (to ease merging into master) and corrected route's docstring\nthanks @olasd for spotting the error\nSnitch wasn't using meth due to this bug (I think)\n. Added some tests to meth. I can't think of testing anything else without importing Flask itself\n. :+1: until better proposal\nthe only other option I can think right now would be a more common-lisp approach of adding a \"-p\" suffix (from predicate) but I don't like that naming convention.\n. should it be added to the docs? or as a separate document?\n. It's late so I'll re-review in a more appropiate hour, but LGTM :+1: \n. There are many characters that can make hy code not interoperable with python like * or / a warning in the docs should be enough to explain that you can run into problems due to this, both with the ones we translate and the ones we don't\n. I was thinking about this this morning! But I was more along the lines of implementing a new magic method __hyrepr__ so if an object implements it, it would be used for displaying in the repl, leaving the python's repr implementation alone. This way we could implement a hyrepr method that looks for it, and falls back to repr if it doesn't exist such a magic method.\nSince some core types of Python are implemented with slots and can't accept new methods in their class definitions without recompiling, there should be some special treatment like what you are currently doing in this branch, withouth affecting repr and thus making it safe for python.\nAlso, it would mean that the hy repl would use  of such a function instead of default repr.\nEdited: __hyrepl__ -> __hyrepr__ and hyrepl -> hyrepr\n. I think it should only be called when the user asks for hy's representation, something roughly like:\ndef hyrepr(obj):\n    try:\n        obj.__hyrepr__()\n    catch AttributeError:\n        if isinstance(obj, dict):\n            do_hy_dict_repr()\n        ......\n        else:\n            repr(obj)\nP.S.: i meant __hyrepr__ instead of __hyrepl__, sorry for any confusion :)\n. It isn't targeting Python, but interoperability with it. Changing the falsy evaluation would render the whole ecosystem of Python libraries unusable since people expects consistency.\nDo you have any idea how to implement it without breaking interoperability?\nI agree with you: it makes sense in a Lisp to have 0 as truthy, but I believe Hy does need to be consistent with the Python way.\n. I'm a bit sleepy so I might have misused the reader macros, sorry if any of this is invalid\n- Trying to overwrite a previously defined reader should either raise an exception or overwrite with the new one. Currently fails silently which is confusing.\n- Giving the reader a name of more than 1 character seems to not register anything (or I might not have found a way) Skimming through the code seems that only the first character is used (why is that? couldn't think of a valid reason of not using a full word) but this also fails\n- Accessing a nonexistant reader should be a simple exception, not a 10 line traceback with a HyCompileError.\n- There should be a warning in the docs (raising an exception would be nice too) that the character : can't be used as it is consumed by the keyword token. This will prevent many future questions. There might be other symbols but this is the only one I found so far.\nOther than that I'm impressed and hope to get some nice stuff out of it : ) \nI've been thinking if we could do a reader macro for apply which could get any pair of :key value and pass it as kwargs to kwapply, leaving the rest as starargs. It is not a perfect keyword implementation but could ease programming in hy while we sort out the keyword implementation.\n. About the length of the reader: I'm fine with it being just one character, but then it should be @checkargs(min=1, max=1). Is there a reason to accept more characters if we are not using it?\n. @theanalyst much better! :+1: \n. Damn! Never review without having breakfast first! :-1: \nDisregard the comment about @checkargs I wasn't fully awake at the moment :(\nIt's in the name where it should be checked for being only 1 character long\n. Current changelog, will need to be modified to add anything fixed during this friday\n-  Define kwapply as a macro\n-  Added apply as a function\n-  Operators + and * now can work without arguments\n-  Instant symbol generation with gensym\n-  Added information about core team members\n-  Fix for readline REPL problem on Darwin\n-  Documentation fixed and extended\n-  Add astor to install_requires to fix hy --spy failing on hy 0.9.11.\n-  Convert stdout and stderr to UTF-8 properly in the run_cmd helper.\n-  Update requirements.txt and setup.py to use rply upstream.\n-  Allow macros to return None\n-  Add versionadded directive to cli.rst.\n-  Adds try-hy to the docs\n-  Document command line options.\n-  Make HyObject.replace more resilient\n-  Fix REPL completions on OS X\n-  Add coveralls token\n-  Adding support for coverage tests at coveralls.io\n-  Add link to try-hy to documentation\n-  Added info about tox, so people can use it prior to a PR\n-  Translate all foo? -> is_foo. \n-  Added the start of hacking rules\n-  Don't test the halting problem anymore.\n-  Non-free file removed\n-  Fixed PyPI is now behind a CDN. The --use-mirrors option is deprecated.\n-  Add anaphoric versions of map, filter, and foreach\n-  Modified eg/twisted to follow the newer hy syntax\n-  Badges for pypi version and downloads.\n-  Added type coercing to the right integer for the platform\n-  Add a method for casting into byte string or unicode depending on python version\n-  OSX: Fixes for readline Repl problem which caused HyREPL not allowing 'b'\nif anyone notices some change missing, please comment on it\nEdit: added latests PRs (2013/12/22)\n. This should fix #378 \n. added @berkerpeksag suggestion and reordered the docs to make clear which one is the one being changed. Thanks berker!\n. It was mostly discussed on IRC, and explained on #378 \nSumarizing:\n*foo* in most lisps means a global variable and +bar+ a constant, since we were translating foo to FOO we were going against the defacto standard in the lisp communities\n. I didn't change it into anything as I don't know any stablished way of naming global variables in python. There is the PEP8 which states to start them with an underscore to prevent them being implicitly imported, but I would ask for ack/suggestions from @hylang/core before submitting such a change\n. That would be as valid as having an underscore in front. Not against it, although it might be harder to remember if you happen to need to use it (which you shouldn't as is private)\n. :+1: \n. LGTM so far\nSorry to introduce such a big bug :( I should be more careful and test more. \nThank you @olasd for the fix.\n. I like this a lot. I'll reread next year ;)\n. there are partial news over here\nFeel free to update, or I'll try to in a couple of days ;)\n. I think @theanalyst means there is a test/contrib and a test/native/contrib and should probably merged, but this could be a different issue/PR\n. looks good! :+1: \n. I thought we had one! :+1: \n. I prefer using the method described in #329 by @Beluki as it doesn't involve having a python script requirement.\n. I like the first idea!\nEl 29/01/2014 15:47, \"Gergely Nagy\" notifications@github.com escribi\u00f3:\n\nWhile working on various tidbits in Hy, I found myself wishing Hy had\nsupport for making functions (or variables) private, so that when I do an (import\n[foo [*]]), they would not get imported. But functions within that module\ncould still make use of them.\nNow, I can work this around in my own modules, by doing the following:\n(def all [\"func1\" \"var1\" \"func2\" \"var2\"])\nBut that's manual, therefore prone to error, and is ugly anyway. Another\noption is to surround functions with double dashes, but that is also ugly.\nWhat we could do, is teach defn, def and similar things to automatically\nadd their thingy to all (and declare that one global, of course).\nThen, we could have (def-) and (defn-), which compile the thing and all,\nbut don't add it to all.\nI have a branch https://github.com/algernon/hy/tree/f/defn-, with a\nproof-of-concept implementation, that covers (defn)/(defn-), but nothing\nelse (and the test suite fails for some reason, the change likely borked\nsomething around importing).\nAn alternative option would be to have (def-) and (defn-) automatically\nwrap the variable in double dashes, and keep an internal mapping, so we can\nreplace references in the AST with the proper name. But that sounds overly\ncomplicated, and involves too much bookkeeping.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/issues/485\n.\n. yes, disregard the issue then:\n\n=> (import temp)\n=> (.test? temp)\nu'working correctly'\n=> (temp.test?)\nu'working correctly'\n. looks good :+1: \nsorry for commenting on the other issue :cry: \n. @tuturto you could tee the iterator and consume the duplicated one\n. I haven't found a good way to update by modifying it in place.\nModifying both lists (keys and values) in place only works if both are explicit dicts and not Names to be loaded (1 of 4 possible cases).\nBut I'm just a novice ast hacker, so I'll happily take any advice anyone has to make it better/faster :smile: \n. do you mean something like zip(expr[::2],expr[1::2]) ? what would be the gain for this? there is already a check for the number of arguments being paired and an extra exception handling (probably superfluous due to the @checkargs).\n. I like this example!\n. I would suggest:\n\"restand cdr returns the collection passed as an argument without it's first element\"\nI feel the term access might be misunderstood, but english is not my mother language\n. Other way to put it:\n(if (not conditional)\n     (do statement))\n. The only reason I wrote that was not for the macroexpansion but for clarity to the reader. I feel (if (not)) is clear for someone not used to read lisp which is probably half of our audience (python programmers wanting to learn lisp)\n. looks like root is not used, you could just return root. It's a minor nitpick\n. shouldn't this be a lstrip? Not that is going to have any other magic_marker symbol in it (although it could have it), but it is not needed to check both ends anyway. \n. yes, current implementation is inherited from ClojureScript.\nAnyway, keywords should change once we have a proper keyword implementation (see #295 ) closer to common lisp instead of clojure so I wouldn't bother too much with them.\n. Regarding some symbols not being accepted could be checked here:\n``` python\nNOT_READERS = [\":\" , \"&\"]  #there might be others\nif name in NOT_READERS:\n   raise NameError(\"%s can't be used as a macro reader symbol\" % name)\n```\n. My only issue with this change is that kwapply can be nested (kwappy\n(kwapply....)) while apply can't, but if that's not useful killing it is\nbetter :)\nOn Tue, Feb 4, 2014 at 12:07 PM, Berker Peksag notifications@github.comwrote:\n\nIn eg/sunlight/party-count.hy:\n\n@@ -12,7 +12,7 @@\n(defn get-legislators [state]\n-  (kwapply (.legislators openstates) {\"state\" state}))\n-  (apply openstates.regislators [] {\"state\" state}))\n\nAh, good catch. Will fix that, thanks!\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/pull/470/files#r9416936\n.\n\n\nI see connected people - The seventh sense\nweb: http://w http://blog.willinux.netww.willyfrog.es\n. ",
    "laarmen": "Yes, if it was easy I probably would have attached a patch :-)\n. ",
    "rcarmo": "...but can we fix it? I keep getting bit by this when context-switching from another LISP :)\n. FWIW, I think bolting in immutable data structures is another matter altogether. I would be very happy if assoc \"just worked\" and returned something besides None/nil even if it mutated the dict. I know I'm using a Python data structure...\n. +1 for this\n. bump\n. Besides the mailing-list (which seems... quiet), where do those discussions take place? :)\n. sigh\nThat requires real-time interaction... (not on a US timezone)\nArchives/logs?\n. Just banged my head on this again...\n. So this means I'm going to have to do stuff like\nhy\n(import [logging [getLogger +debug+ +warn+]])\n...etc. Looks ugly, but manageable.\nStill, why not mangle *foo* to something relatively un-Pythonic like Foo or _FOO? \n. Well, I\u2019m not a fan of the plus signs, FWIW...\n(.log +debug+ \u201cThis is going to look somewhat weird\u201d)\n. bump This is holding up 0.10.1, right? I want to use (defmain) :)\n. Doesn't feel very LISPy to me... Then again, I'm quite used to Clojure hinting, which has spoiled me somewhat.\n. I prefer the (defn foo [^Prefix param] ...) syntax, same as Clojure's. I think it would save people a lot of time trying to figure things out, and that there's a lot to be said for recognizable patterns shared among LISPs.\n(i.e., reinventing the wheel needs very good argumentation, and even clearer documentation for people coming across the idiom)\nOn 10/09/2014, at 13:48, Morten Linderud notifications@github.com wrote:\n\n;; Something like?\n(defn a y ^str)\n(defn a ^str y)\n;; But then\n(defn a y ^\"HEYHO LETS GO!\")\n(defn a ^\"HEYHO LETS GO!\" y)\n(defn a ^(lambda [x](print x)) y)\n(defn a y ^(lambda [x](print x)) )\n\u2014\nReply to this email directly or view it on GitHub.\n. +1 for typed-clojure. Larger \"customer base\" than Racket's.\n. I've since managed to reproduce this in another condition:\n\nhy\n(defn [foo] (+1 foo))\n\"\nThat's right, a \"lost\" quote near EOF will completely screw up the lexer. Fiddling with LexException a bit and removing the guard for positive line numbers, I got this:\n```\n  File \"/Users/rcarmo/.pyenv/versions/2.7.8/lib/python2.7/site-packages/hy/lex/init.py\", line 37, in tokenize\n    pos.lineno, pos.colno)\nhy.lex.exceptions.LexException:   File \"main.hy\", line -1, column -1\n\"\n  ^\nLexException: Could not identify the next token.\n```\nSo it is possible to provide a little more info (and at least point to the offending character). I'm at a loss as to why the line and column are set to negative values here, but I haven't looked at the tokenizer properly yet -- it seems to be a bug in rply, actually, given that getsourcepos() is the one setting those values.\n. bump\nI'm also getting trouble with Hy under PyPy. hy -m foo isn't working for some reason, will investigate that on other issues...\n. sigh yeah, that figures. I was doing Clojure at the same time and forgot about that sort of detail with join.\n. I've just been bitten by something similar - this doesn't work at all - i.e., it prints the debug output, but the function returns None and not a generator:\nhy\n(defn gen-pages [root-path]                                                                                                        \n      ; generate a sequence of page items                                                                                            \n      (for [elements (walk root-path)]                                                                                               \n+         (print elements)                                                                                                           \n          (let [[folder     (get elements 0)]                                                                                        \n                [subfolders (get elements 1)]                                                                                        \n                [files      (get elements 2)]]                                                                                       \n~             (print *base-filenames* files)                                                                                         \n~             ; setting this helps guide os.path.walk()                                                                              \n~             (setv subfolders (filtered-names subfolders))                                                                          \n+             (for [base *base-filenames*]                                                                                           \n                  (if (in base files)                                                                                                \n                      (yield                                                                                                         \n                          {:path (slice folder (+ 1 (len root-path)))                                                                \n                           :filename base                                                                                            \n                           :mtime (get (stat (join folder base)) ST_MTIME)}))))))\n(that's a paste from a terminal with git gutter on the left hand side)\nI can push the items I'm trying to yield onto an array, but it's kind of annoying to do so when I go past the first ten thousand or so...\n. Guys, this is starting to be a bit of a pain... Same issue, same kind of logic. Can we get a fix for this?\nhy\n(defn map-coords [seq &optional[width 11] [height 11] [spacing 3]]\n    (let [[x-inc (+ width spacing)]\n          [y-inc (+ height spacing)]\n          [x spacing]\n          [y spacing]\n          [month-offsets []]]\n        (for [d seq]\n             (let [[wday (% (+ 1 ( .weekday d)) 7)]]\n                (if (= wday 6)\n                    (do\n                        (setv y spacing)\n                        (setv x (+ x x-inc))))\n                (print x y)\n                (yield {:date d :x x :y y :width width :height height})\n                (setv y (+ y y-inc))))))\n. Yeah, I ended up using setv instead. It's just that this is a very common pattern when you're building pipelines of infinite sequences - I get bitten by this bug every other week or so.\n. bump\nThis would be really handy in a couple more instances (I've already turned that reduce with a lambda into a macro for my own use, but...)\n. It does? Wow. Had no idea, never even thought of trying. \nIs this git tip or release? I was kind of hoping for an updated release...\n. Please don't scrap 2.x - IronPython and PyPy still havent caught up, and you wouldn't believe where I'm running Hy these days...\n. awesome.\n. Yay! Thanks, guys, this will make some deployments much easier.\n. Yes, it does:\n\n$ python\nPython 2.7.9 (295ee98b6928, May 31 2015, 07:28:49)\n[PyPy 2.6.0 with GCC 4.2.1 Compatible Apple LLVM 5.1 (clang-503.0.40)] on darwin\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>>> from lxml.etree import Element, tostring, fromstring\n>>>>\n\nI suspect there's something more going on here. Maybe ast_compile strips something away?\n. sigh seeing as I'm doing Clojure again and let is kind of... inevitable, I'm torn. I just know I'm going to have to hack sushy to bits once the new release is out, but if you really have to break Hy, then...\n. Just do it (TM)\n. > On 24 Jul 2015, at 17:18, J Kenneth King notifications@github.com wrote:\n\nPython is not the JVM. Hy is not Clojure for Python. It's apples to oranges. \n\nYeah, well, I am quite aware of that. That is not the comparison I had in mind.\nRather painfully so, since I\u2019ve been using Hy for a fairly extensive set of little things. It\u2019s just that it will be annoying to code some things without let, just like it is to have it partially broken like it is today - and being close to Clojure helps a lot when you\u2019re switching contexts frequently.\n. > On 24 Jul 2015, at 20:59, Ryan Gonzalez notifications@github.com wrote:\n\nI think you guys keep forgetting that you can implement let via a try...finally block with completely normal, not-crazy semantics. I've been working on it. The reason people using Python don't do that is simply because it would take more typing than it's worth. But, this is Hy. Which means there are macros!\nHey that is a neat concept I can completely get behind. But would it work properly with yield? I think it should, but...\n. Same here. T/F are ugly and make no sense.\n. +1 for going with the latest.\n. I'd really like to see async/await support in some fashion (and a new release, but that seems to be coming)\n. Well, so I'm here doing some Python 3.6, using yield from a coroutine, and wondering... How's this coming along?. Yeah, well, at least for the moment. I need async for the Python stuff that I do, and it is true that the lack of let breaks most of my existing Hy code, so I've version-pinned all my projects to an older release and am rewriting some in pure Python and fiddling with ClojureScript and Chez Scheme...\n\nBut don't let that stop you from improving Hy to keep up with mainstream Python - I'll use it if I can. \ud83d\ude09. Yes, I am fully aware of that. But I can't spare the time to experiment - I need to make sure I won't have to rewrite them again, so moving back to normal Python or to a regular Scheme is the safest option.\nRight now, I'm heavily into asyncio, so I can't really use Hy.\nI have other projects I can keep using Hy on, but the question will come up time and again if I want to have a \"pretend\" let or just use a normal Scheme.. Hmmm. Interesting. I\u2019m curious about what sort of syntax would be feasible for async for and await in comprehensions:\nresult = [i async for i in aiter() if i % 2]\nresult = [await fun() for fun in funcs if await condition()]\n. Well, I googled for \u201chylang if\u201d, obviously. :)\nAnyway, when is the new release coming out? It\u2019s been ages.\n\nOn 15 May 2016, at 02:32, Matthew Egan Odendahl notifications@github.com wrote:\nThe documentation is correct.\n=> (defn test-if [n]\n...   (print (if (< n 0.0) \"negative\"\n...              (= n 0.0) \"zero\"\n...              (> n 0.0) \"positive\"\n...              \"not a number\")))\n=> (test-if -1.0)\nnegative\n=> (test-if 0.0)\nzero\n=> (test-if 1.0)\npositive\n=> (test-if nan)\nnot a number\nI suspect you're still using the old version of Hy on PyPI, but are using the unstable/development version of the docs. Use the docs that match your version of Hy.\nIf there's a link somewhere that pointed you at the wrong docs, that's what should be fixed. Where did you find them?\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly or view it on GitHub https://github.com/hylang/hy/issues/1064#issuecomment-219260901\n. Is it on PyPi yet?. Huh. T and F, seriously? .... but.... why?\n. Well, it makes sense to me that they be readable. Racket\u2019s #t and #f is hideous, for instance. Clojure does the sensible thing.\n\nAnd besides, it\u2019s not as if the extra three or four characters take up that much space on a line of code.\n. @kirbyfan64 it is, mostly. I use pyenv and build my own interpreters, but \"fixing\" readline is a common enough affair.. Hmmm. I\u2019m curious.\n\nOn 1 Nov 2017, at 14:37, Ryan Gonzalez notifications@github.com wrote:\n@kirbyfan64 approved this pull request.\nThis is insane. :O\n@rcarmo You're going to like this one...\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Hmmm. Merged already? I wonder... Need to take some time and check this out, I miss Hy.. \n",
    "jmmk": "+1 on this. The current semantics don't make sense having an assoc form that returns None.\n. ",
    "emidln": "I'd prefer to see a set! that uses __setitem__ under the hood and make assoc return the modified dict.\n. I'd like to point out that if-let and when-let are enormously more useful in Hy because of pythonic truthiness vs clojure's truthiness. \nhttps://gist.github.com/emidln/8589060\nhttps://gist.github.com/emidln/8588652\n. If I remember correctly, the argument was for consistency across let-like \"binding points\" (ignoring for a moment that we don't actually have destructuring-bind ala Lisp or destructure ala Clojure), in multiple levels of context managers. Specifically, without CL-style list of lists, we can't handle arbitrary mixing of context managers with and without context. See https://github.com/hylang/hy/issues/367\nAlso, this is just a devil's advocate statement as I'm +1000 on just using a clojure-style (partition 2 ...) on the single vector to break into pairs. \n. In the Clojure Prismatic library, there is a function that converts --> to -> for individual elements: https://github.com/Prismatic/plumbing/blob/master/src/plumbing/core.cljx#L319\nThat said, an anaphoric version would probably read cleaner.\n. Why do you need two macros if you specify positioning with 'it?\n. Right. That makes sense.\n. hy\n(defmacro comment [&rest body] nil)\nedit: sorry, had clojure syntax, switched to Hy\n. Well, yes. To be fair, most things ar valid syntax if they're not being evaluated.\n. You could build your own defmacro that works inside a try/catch if you were so inclined. \n. ",
    "chr15m": "+1\n. Maybe I am missing something but (assoc foo bar baz) could instead translate to:\nfoo = dict(foo, **{bar: baz})\nhttp://stackoverflow.com/a/1453013/2131094\nHm, I should PR shouldn't I.\n. Just tested - yes it is nearly 1000 times slower on my machine.\n. If I introduced an assoc! which changes the dict and also returns it would that tiny PR be accepted?\n. Good point.\nThe immediate situation is that the current assoc doesn't do what anybody expects. In my opinion the name of the current assoc should be something else (maybe fast-assoc or set-key or something better), and a new assoc that is slow but does what people expect should exist and have documentation that says why it is slower than the faster alternative. This gives the user a version of assoc that works as everyone expects it to, and also an alternative when they need a performant way to set dict key-vals inside e.g. a tight loop or whatever.\ntl;dr: rename existing assoc and create a slower assoc that does what everybody expects.\n. @agentultra I ran the following two variations of test code:\nRegular recursive function call:\n(defn fib [n s]\n  (if (< n 1)\n    s\n    (fib (- n 1) (+ s n))))\nUsing loop instead:\n(defn fib2 [t]\n  (loop [[n t] [s 0]]\n    (if (< n 1)\n      s\n      (recur (- n 1) (+ s n)))))\nThe first one triggers Python's maximum recursion depth when run with e.g. 2000.\nI can't get the second one to exceed recursion depth - I run out of CPU first.\nCan you explain the nuance of why this is not \"optimizing away stack frames\"?. ",
    "zackmdavis": "@chr15m I'd be in favor of such a function, but I can imagine the name assoc! being confusing (because the presence of both assoc and assoc! in the language might lead many to expect that assoc returns a new dict and doesn't modify the existing one, almost the opposite of what we actually want to convey). I'm not sure what alternative name to suggest at the moment.\n. @gilch, I like that idea! \nIf assoc were to be renamed, I suggest assoc* (with an asterisk) as the new name, in analogy to how Hy and Clojure define the more-commonly-used for in terms of the more-fundamental for*. (Edit: ah, I see @Foxboron already suggested this upthread the other year.)\n. Reopened; I agree that the way GitHub apparently closes an issue because a pull request mentioning it was merged (and then attributes the closing to whoever did the merge) is a very questionable \"feature.\"\n. @gilch clever!\n. @rcarmo \n\nreduce with a lambda into a macro for my own use, but\n\nIt looks like variadic get already behaves the way you want? \n$ hy\nhy 0.10.1 using CPython(default) 3.4.1 on Linux\n=> (setv a {\"foo\" {\"bar\" {\"baz\" 3}}})\n=> (get a \"foo\" \"bar\" \"baz\")\n3\n. Release. Git blame (git praise?) suggests it was introduced in December 2013 before the 0.9.12 release.\n. > Do we need to support Python3 < 3.3?\nNo; we don't support 3.2 (602f392fe7, 5004e754d3).\n. @gilch The strategy of translating the PEP 380 example might still be vulnerable to #691; at least, I think that's what I observed when I tried this the other year, according to the commit message.\n. (If I may be so bold, I would like to suggest merging #796 before a release\u2014passing anonymous functions as arguments is the sort of thing that one would expect to work in a Lisp, and the three-line patch probably isn't very expensive to review.)\n. @kirbyfan64 It's definitely on your GitHub fork; one can only imagine your local clone doesn't have that ref for whatever reason? Maybe git remote add kirbyfan64 git@github.com:kirbyfan64/hy.git; git fetch kirbyfan64 (add your fork as a remote if it didn't exist, and fetch from it) and git checkout shadow_assoc (git will create a new tracking branch when there's one on a remote with a matching name)?\n. (Well, CI reported failure, but if I'm interpreting it correctly, it's due to Flake 8 style violations in files not touched in this pull request?)\n. This appears to be due to changes in version 1.6 of pep8 (a dependency of flake8), released ten days ago.\n``` bash\ndowngrading to the version just prior to 1.6.0 made the failures go away---\n(hy) zmd@ExpectedReturn:~/Code/hy/hy$ python -c \"import pep8; print(pep8.version)\"\n1.5.7\n(hy) zmd@ExpectedReturn:~/Code/hy/hy$ flake8 hy tests\n(hy) zmd@ExpectedReturn:~/Code/hy/hy$ echo $?\n0\nbut they're present when we upgrade back\n(hy) zmd@ExpectedReturn:~/Code/hy/hy$ pip install pep8==1.6.0\nCollecting pep8==1.6.0\n  Using cached pep8-1.6.0-py2.py3-none-any.whl\nInstalling collected packages: pep8\n  Found existing installation: pep8 1.5.7\n    Uninstalling pep8-1.5.7:\n      Successfully uninstalled pep8-1.5.7\nSuccessfully installed pep8-1.6.0\n(hy) zmd@ExpectedReturn:~/Code/hy/hy$ flake8 hy tests\nhy/completer.py:52:1: E402 module level import not at top of file\nhy/completer.py:53:1: E402 module level import not at top of file\nhy/completer.py:55:1: E402 module level import not at top of file\ntests/compilers/test_compiler.py:30:1: E402 module level import not at top of file\ntests/compilers/test_compiler.py:31:1: E402 module level import not at top of file\ntests/compilers/test_compiler.py:32:1: E402 module level import not at top of file\ntests/compilers/test_compiler.py:33:1: E402 module level import not at top of file\n(hy) zmd@ExpectedReturn:~/Code/hy/hy$ echo $?\n1\n``\n. @berkerpeksag--amended and force-pushed in response to your comments\n. Seems to be a manifestation of #233?\n. Fixed up and force-pushed in response to the inequality-notation and availability-note comments. (I'm imagining that we care more about clean commit history than immutable history given that almost certainly no one has based work on this branch.)\n. @paultag I've rebased this branch off master and added a.. versionadded:: 0.12.0` directive to the documentation (imagining, not entirely without evidence, that that's what the next release will be).\n. @paultag \n\nlet's check in on Python 3.5 - I think there's some advanced unpacking stuff coming down the pipe [...] Can someone check up on that?\n\nAre you perhaps thinking of PEP 448 Additional Unpacking Generalizations, which is Accepted for 3.5 but still in the patch review stage? It's about allowing the splat and double-splat operators to be used more times in more places, but seems to me to be independent of the kind of destructuring proposed here which doesn't really exist in Python (anymore). \n. Many thanks to @berkerpeksag for reviewing the upstream change to astor and putting out a new version; d40405f updates the astor dependency, so I think this should be OK to merge at any time (although the need may not be urgent for another 147 days).\n. @farhaven good point! \n(I had actually started working on this Issue (temporary work-in-progress commit: zackmdavis/hy@5e0c0ae3), but I'm not done yet.)\n. Amended and force-pushed to address @olasd's comment about import location.\n. (I've rebased this branch on master and force-pushed again, because of reasons.)\n. Given the two _LGTM_s from @berkerpeksag and our BDFL @paultag, that the contributor guidelines say that only two are needed, the innocuous nature of the proposed change, and that I've observed the tests still passing on Python compiled from upstream as of eight hours ago, I presume this can just be merged.\n. (rebased and force-pushed because this was by necessity based on the commit in #800 which got rebased before landing, and to add a comment)\n@paultag \n\nHella LGTM [...] let's get this landed. \n\nThanks! But do note the blocking or arguably-blocking issues mentioned in the initial comment: the lack of async-for and async-with (this is trivial and I'll make a note to get to it very soon), the dependency on a new astor release for --spy to work, and the problem with let (which looks pretty hard, especially since we haven't gotten it right elsewhere, either).\n. The minimum dependency on astor got bumped up recently; pip install --upgrade astor might help?\n. Thank you; I am honored by the nomination, and accept.\n(I mean, part of me is a little nervous about the prospect of being Core of anything, because that sounds like a Responsibility that must be Lived Up To, and Hy contributions have to compete with many other possible uses of my marginal minutes. But that's true of everyone, and I was already planning on doing more Hy things on the timescale of weeks or months (like continuing the unfinished quest for full PEP 492 async functionality or taking another shot at the Python 2 yield-from bugs), and I guess it couldn't hurt to add to the core-reviewer bandwidth pool during this period.)\n. :heart: \n. Definitely an improvement over the current behavior\u2014\n;; on master\n=> (walk.walk (fn [x] (* 2 x)) (fn [x] x) [1 [2 [3 [4]]]])\n[2, [2, [3, [4]], 2, [3, [4]]]]\n;; the inner function doesn't get applied to, e.g., tuples!!\n=> (walk.walk (fn [x] (* 2 x)) (fn [x] x) (, 1 (, 2 (, 3 (, 4)))))\n(1, (2, (3, (4,))))\n;; on b/contrib.walk-fix\n=> (walk.walk (fn [x] (* 2 x)) (fn [x] x) [1 [2 [3 [4]]]])\n[2, [2, [3, [4]], 2, [3, [4]]]]\n=> (walk.walk (fn [x] (* 2 x)) (fn [x] x) (, 1 (, 2 (, 3 (, 4)))))\n[2, (2, (3, (4,)), 2, (3, (4,)))]\nIt may be worth editing the docstring, as \"building up a data structure of the same type\" (emphasis mine) would be no longer exactly accurate.\nFor a moment, I wanted to suggest just changing (instance? list form) to (coll? form) and relying on the (type form) in the existing code to construct the right type, but it turned out that that doesn't work because some non-string iterables, such as the itertools.islice mentioned in the pull request (returned by Hy's builtin take and drop), can't be initialized by an existing iterable in the obvious way\u2014\n;; with edit mentioned in preceding paragraph\n=> (walk.walk (fn [x] (* 2 x)) (fn [x] x) (drop 1 [1 [2 [3 [4]]]]))\nTraceback (most recent call last):\n  File \"<input>\", line 1, in <module>\n  File \"/home/zmd/Code/hy/hy/hy/contrib/walk.hy\", line 39, in walk\n    ((type form) (outer (HyExpression (map inner form))))]\nTypeError: islice expected at least 2 arguments, got 1\n_+1\n. I'm _+1 on this. \n@kirbyfan64 This is what I get when I rebase on master, resolve the conflict in docs/tutorial.rst, and squash \"Fix Flake8\", \"Add floor division identity\", and \"Remove bare except clause\" onto the first commit. OK with you?\n. I think it's worth squashing some of the tiny fix commits before merging, but I'm in favor of this proposal. _+1_\n. > Common Lisp had docstrings before Python existed. Hy should totally support this [...]\nAs you've observed, Hy does not have Python-style triple-quoted string literals (it would be redundant, because newlines are allowed in ordinary string literals), but note that Hy does support docstrings\u2014\n=> (defn foo []\n...   \"I am a docstring.\"\n...   42)\n=> (. foo __doc__)\n'I am a docstring.'\nThis is because the Python runtime treats a string literal as a doctstring if it's the first statement in a function, class, or module definition.\nI agree that your last example looks like a bug in the REPL (we expect one of the quotes to terminate the string literal, but it doesn't).\n. > But what's most concerning here is that I reported a bug in Hy months ago but it seems to have been completely forgotten.\nWell, I wouldn't say it's been forgotten so much as that's it's been a victim of one of the little heartbreaking tragedies of our constrained and pitiful world, that even hackers as smart and enthusiastic as those reading the comments on this issue have but only a finite and small amount of time and attention to allocate amongst the vastness of exciting and important things to hack on, that so many bug reports go unanswered, like prayers to an absent God.\n@gilch, if no one else has yet been able to afford to bother, let me thank you for filing this issue; as far as my mortal brain can perceive, you are entirely correct that the Hy codebase is currently wrong on this matter of string literals containing a backslash followed by a newline. (And, incidentally, I was wrong to have prematurely spoken in my previous comment as if I had reason to believe the problem was in the REPL specifically rather than being a farther-reaching lexing problem, for no greater reason than having a vague memory that someone had said something about the REPL and multiline strings in the past.) For none of us should forget that it is only by the grace of those who care enough to file an issue (as you have filed), to write a patch (as you have written), to review a patch (as you have reviewed), that the people of our miserable excuse for a civilization get to enjoy the amount of existing and correct software that they do. \nBut I don't have a fix for this one right now. Not because I don't care, but because\u2014as an empirical observation of fact, as shameful as it is to admit it out loud\u2014I evidently don't care enough (relative to everything else worth caring about) to have already fixed it.\n. @gilch (Speaking of being worried about writing style mistakes, my last comment in this thread was possibly a mistake; I've received a private message that some thought it came across as hostile, which was not my intent!\u2014rather, I just wanted to write some sort of acknowledgement that it can be justifiably frustrating that a lot of bugs don't get addressed promptly, while indulging in a certain dramatic, ornate writing style that perhaps may not be the best choice in all venues.)\n. Does lxml.etree work for you in PyPy without Hy? (I don't have time for a detailed investigation, but at a glance, the Python 2.7 docs mention that the existence of __builtins__ is implementation-specific, and there are some reports of people having trouble getting lxml to work with PyPy.)\n. I couldn't reproduce with PyPy 2.6.0 on Ubuntu Trusty.\n```\n(hypypy2)zmd@ExpectedReturn:~/Code/Misc/hypypy2/hy$ python\nPython 2.7.9 (295ee98b6928, May 31 2015, 07:29:04)\n[PyPy 2.6.0 with GCC 4.8.2] on linux2\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n\n\n\n\nfrom lxml.etree import Element, tostring, fromstring\n(hypypy2)zmd@ExpectedReturn:~/Code/Misc/hypypy2/hy$ hy\nhy 0.11.0 using PyPy(295ee98b6928) 2.7.9 on Linux\n=> (import [lxml.etree [Element tostring fromstring]])\n=> (tostring (Element \"hello-xml-parsing-world\"))\n''\n``\n. (The title of the issue makes me suspect @acekingke meant a list like those in classical Lisps, which might be better analogized to a HyExpression or the chain of cons cells given bylist*`, rather than to a tuple, depending on the intended usage.\n\n\n\n\n=> '(1 2 3)\n(1 2 3)\n=> (type '(1 2 3))\n<class 'hy.models.expression.HyExpression'>\n=> (list* 1 2 3)\n(1 2 . 3)\n=> (type (list* 1 2 3))\n<class 'hy.models.cons.HyCons'>\n)\n. > Can we do the cleanup before ~september?\nSeptember 13 might be appropriate, to match the Python 3.5 release?\n. squirrel\n. Good observation; I agree that this is currently impossible. With the Python 3 metaclass-definition syntax, the metaclass keyword argument ends up in the keywords attribute of ast.ClassDef, which is unconditionally empty in the classdefs we produce.\nin [2]: class the_trivial_metaclass(type): pass\nin [3]: ast.parse(\"class Foo(metaclass=the_trivial_metaclass): pass\").body[0].keywords[0].value.id\nOut[3]: 'the_trivial_metaclass'\n. @gilch nothing, but some may find #@(decorator (defn foo [x] (bar x))) to be a sweeter form of syntactic sugar than (->> (fn [x] (bar x)) (decorator) (def foo))?\n. _+1\n. agreed\n. _+1 Yes, this definitely does behave more reasonably for the examples you mention.\n(Although the commit message seems slightly inaccurate in that on master, the unbalanced-parens example seems to successfully get the expression and then ignore the parsing error, rather than hanging in an infinite loop like the commit message led me to expect\u2014\n=> (read)\n(foo))\n('foo')\n=>\nBut I do observe the hanging with the string literal example.)\n. A counterargument is that there's precedent for the existing behavior in, say, Clojure\u2014\nuser=> (doseq [x (range 3) y (range 2) z (range 1)] (println [x y z]))\n[0 0 0]\n[0 1 0]\n[1 0 0]\n[1 1 0]\n[2 0 0]\n[2 1 0]\nnil\n\nNow we don't need the [] anymore either\n\nThe cause of readability isn't necessarily best served by removing every possible delimiter. The Cartesian-product behavior of for is strictly analogous to the ability to declare more than one binding in a let form; there's an appeal in being able to say that (for [x a-sequence y another-sequence] ... ) should mean the same thing as the nested loops (for [x a-sequence] (for [y another-sequence] ...)) for the same reason that (let [a value1 b value2] ...) means the same thing as the nested lets (let [a value1] (let [b value2] ...)).\n(Okay, #713 is still open, so the latter example isn't valid present-day Hy, but you get the idea.)\n. I like @gilch's idea of providing a definit (and defnew) macro; special-casing the definition of methods/attributes that happen to have a particular name (even a magic name like __init__) could be a pretty surprising behavior from the perspective of someone who doesn't already know to expect it!\n. _+1_\n. Nice branch name, too. :shipit: \n. (A thought prompted by #907\u2014) as long as we're breaking the world in order to favor Clojure-style brace-minimizing implicit pairings, we should probably do cond as well.\n. I think maintaining the analogy to def, defn, and defmacro that Algernon mentions is more important than saving three characters or minimizing the number of keywords, even unfortunate keywords that don't do anything. (Hey, JavaScript gets by with a few of those, right?\u2014although maybe that's not the best role model.) But speaking of which\u2014\n\nclass is a reserved word in Python, and so is already reserved in Hy,\n\nWe do that, but you know, I don't think we need to do that. By bypassing Python's parser and constructing ast nodes directly, Hy has been known to create Python ASTs that aren't legal Python in the respect of using illegal names; that's why, for example, you could name a function set! even before the bang-mangling patch landed.\nzmd@ExpectedReturn:~$ hy --spy  # last released version, no '!' mangling\nhy 0.11.0 using CPython(default) 3.4.0 on Linux\n=> (defn set! [])\ndef set!(): # bad Python (even though `--spy` didn't notice)\n    pass\nA simple experiment suggests we'd likely be able to do the same for class and other Python keywords that we don't need as Hy keywords\u2014\n```\nin [1]: import ast; from ast import *\nin [2]: ast.dump(ast.parse(\"foo = 1\"))\nOut[2]: \"Module(body=[Assign(targets=[Name(id='foo', ctx=Store())], value=Num(n=1))])\"\nWe can't parse the use of class as a variable name ...\nin [3]: ast.dump(ast.parse(\"class = 1\"))  File \"\", line 1\n    class = 1\n          ^\nSyntaxError: invalid syntax\nBut no one objects if we construct the corresponding AST ourselves.\nin [4]: ast.dump(Module(body=[Assign(targets=[Name(id='class', ctx=Store())], value=Num(n=1))]))\nOut[4]: \"Module(body=[Assign(targets=[Name(id='class', ctx=Store())], value=Num(n=1))])\"\n```\n. Straightforward. _+1\n. _+1\n. _+1\n. _+1\n. @kirbyfan64 \n\nUhhh...I have no clue what those test failures are. They have nothing to do with this PR!?\n\nA new version of Coverage got released yesterday; we probably need to update our Travis configuration.\n. @gilch This StackOverflow answer claims that the crude measure of closing and re-opening the pull-request will force a rebuild. Let's try it.\n. I'm in favor of removing zipwith; the duplication with map has been noted previously. 8e4b2110 actually removes the original implementation and replaces it with (setv zipwith map), but somehow we seem to have ended up with both versions on master? (One wonders when and how that happened.)\n. I was not able to install Hy with Jython 2.7.0 due a problem installing our clint dependency (looks likely to be issue no. 2158, the fix for which didn't make the release):\n```\n(jirtualenv)zmd@ExpectedReturn:~/Code/Misc/Jython_Sandbox/jirtualenv$ pip install hy\nCollecting hy\n  Using cached hy-0.11.0.tar.gz\nCollecting rply>=0.7.0 (from hy)\n  Using cached rply-0.7.4-py2.py3-none-any.whl\nCollecting astor>=0.5 (from hy)\n  Using cached astor-0.5-py2.py3-none-any.whl\nCollecting clint>=0.4 (from hy)\n  Using cached clint-0.5.1.tar.gz\n    Complete output from command python setup.py egg_info:\n    Traceback (most recent call last):\n      File \"\", line 17, in \n      File \"/tmp/pip-build-R_NesT/clint/setup.py\", line 12, in \n        import clint\n      File \"clint/init.py\", line 21, in \n        from .arguments import *\n    ImportError: No module named arguments\n----------------------------------------\n\nCommand \"python setup.py egg_info\" failed with error code 1 in /tmp/pip-build-R_NesT/clint\n```\n. works on Android using Termux\n\n. _+1_\n. Updated and fast-forwarded onto master.\n\nOr can I just push that change to master, @hylang/core ?\n\n(It's moot now, but) yes; I don't think a trivial compatibility fix-up like this needs much consensus.\n(Incidentally, my reading of the documentation paragraph that Berker linked makes it look like the actual value of our exclude_lines setting is a no-op (we don't have anything thee other than the standard \"pragma: no cover\"), so maybe I should have first experimented with just removing it entirely. Oh, well ...)\n. For myself, I don't understand the philosophy behind the choices of values. I of course get how the empty sum (+) has to be zero because that's the additive identity, the empty disjunction (or) similarly has to be falsey, &c., but what do one-argument comparisons really mean, such that all of them are true except not-equals?\nBut the patch is fine, and if Clojure and Common Lisp agree (well, mostly), my personal confusion certainly shouldn't obstruct progress. _+1_ :shipit:\n. As of 016557de, there's a #@ reader macro that may alleviate this concern\u2014\n=> (defn increment [f] (fn [&rest args &kwargs kwargs] (inc (apply f args kwargs))))\n=> #@(increment (defn addition [a b] (+ a b)))\n=> (addition 1 1)\n3\n. @kirbyfan64 There are some more duplicated commits on this branch. What specific command are you using to rebase? \n. > I think the duplicated commits are just a GitHub issue with showing rebased commits.\nNo, they're really there\u2014\n``` bash\nmaking sure my local repository has an accurate view of kirbyfan64's repository\nzmd@ExpectedReturn:~/Code/hy/hy$ git remote -v | grep kirby\nkirbyfan64  git@github.com:kirbyfan64/hy.git (fetch)\nkirbyfan64  git@github.com:kirbyfan64/hy.git (push)\nzmd@ExpectedReturn:~/Code/hy/hy$ git fetch kirbyfan64 \ncheck out the tip of this PR's branch\nzmd@ExpectedReturn:~/Code/hy/hy$ git checkout kirbyfan64/fix_macro_err2 \nHEAD is now at 12146a2... Fix issue found by @tuturto in #903\nthe previous two commits have the same SHAs that GitHub's current rendering of the PR shows\nzmd@ExpectedReturn:~/Code/hy/hy$ git log --oneline | head -n 3\n12146a2 Fix issue found by @tuturto in #903\n54e3d26 Add a few tests for various defn corner cases\n820c6fc Trying to setv a callable should raise a nice error\nbut the actual content of those commits already exists once on master\nzmd@ExpectedReturn:~/Code/hy/hy$ git log --oneline --grep \"Trying to setv a callable\"\n820c6fc Trying to setv a callable should raise a nice error\nd3520e5 Trying to setv a callable should raise a nice error\n```\n\ngit pull --rebase origin master ...\n\nHm, I don't seem to have a good intuition for what pull --rebase does with arguments (I've only used it without arguments, when I have new local commits but the upstream tracking branch has new commits, too, and I want to apply my changes on top of those).\nTo get out of the current duplicate-commits situation, I think you want to git rebase -i origin/master and then delete the lines corresponding to the duplicate commits. And likewise git rebase origin/master to update pull requests in the future (assuming you've fetched origin recently and that origin refers to the source repository). The way I think of it is that git rebase foo is going to take all the commits between the-latest-common-ancestor-of-HEAD-and-foo and HEAD and apply them one by one on top of foo (where foo could be anything that Git understands as pointing to a commit, including a local branch name, a remote branch name like origin/master, a short SHA, or a special relative name like HEAD~3, which means \"three commits before the one I'm currently on\").\n. _+1 (I left some quibbling comments, but nothing that can't be addressed in a follow-up commit.)\n. I'm in favor of this.\n. :shipit: On master as 283111b49 (I rebased locally to get rid of the duplicate of 0a942a069 that somehow slipped in to the branch that this pull request is from).\n. _+1 :shipit: \n. _+1_ Code looks reasonable, and, as the PR description says, does away with a (not useful for debugging what was wrong with the input) traceback\u2014\n```\n(hy) zmd@ExpectedReturn:~/Code/hy/hy$ cat error.hy \n(for\n(hy) zmd@ExpectedReturn:~/Code/hy/hy$ hy2py error.hy \nTraceback (most recent call last):\n  File \"/home/zmd/Code/hy/bin/hy2py\", line 9, in \n    load_entry_point('hy==0.10.1', 'console_scripts', 'hy2py')()\n  File \"/home/zmd/Code/hy/hy/hy/cmdline.py\", line 408, in hy2py_main\n    _ast = import_file_to_ast(options.args[0], module_name)\n  File \"/home/zmd/Code/hy/hy/hy/importer.py\", line 68, in import_file_to_ast\n    return hy_compile(import_file_to_hst(fpath), module_name)\n  File \"/home/zmd/Code/hy/hy/hy/importer.py\", line 56, in import_file_to_hst\n    return import_buffer_to_hst(f.read())\n  File \"/home/zmd/Code/hy/hy/hy/importer.py\", line 49, in import_buffer_to_hst\n    return tokenize(buf + \"\\n\")\n  File \"/home/zmd/Code/hy/hy/hy/lex/init.py\", line 33, in tokenize\n    return parser.parse(lexer.lex(buf))\n  File \"/home/zmd/Code/hy/lib/python3.4/site-packages/rply/parser.py\", line 60, in parse\n    self.error_handler(lookahead)\n  File \"/home/zmd/Code/hy/hy/hy/lex/parser.py\", line 325, in error_handler\n    raise PrematureEndOfInput(\"Premature end of input\")\nhy.lex.exceptions.PrematureEndOfInput: LexException: Premature end of input\n(hy) zmd@ExpectedReturn:~/Code/hy/hy$ git checkout pretty_error \nSwitched to branch 'pretty_error'\nYour branch is up-to-date with 'kirbyfan64/pretty_error'.\n(hy) zmd@ExpectedReturn:~/Code/hy/hy$ hy2py error.hy \nLexException: Premature end of input\n``\n. It's unfortunate that these configs make the Travis [build page](https://travis-ci.org/hylang/hy/builds/89031068) make all the individual job listings say \"Python: 3.5\", which is confusing, although I _think_ Tox is actually running the correct versions: theTOXENV=pypyone taking longer and printing the SSLInsecurePlatformWarning` in the output is telling.\n. > green CI now.\nNote that CI is still only testing 3.5.0. But I just built 3.5.1 and can confirm that your fix works. :shipit: \n. @tianon right, I should have inferred from context that previous work had been squashed.\n. _+1_ :shipit: \n. I agree that the error message with the explicit arguments is better.\nBefore\u2014\n```\n=> (ap-if true)\n  File \"\", line 1, column 1\n(ap-if true)\n  ^----------^\nHyTypeError: `if' needs at least 2 arguments, got 1.\n```\nAfter\u2014\n```\n=> (ap-if 2)\n  File \"\", line 1, column 1\n(ap-if 2)\n  ^-------^\nHyMacroExpansionError: b\"expanding `ap_if': missing 1 required positional argument: 'then_form'\"\n```\nThanks @ewaldgrusk!\n. Since pyreadline 2.0 isn't good for all the Pythons/OSes that we want to support (as evidenced by this helpful pull request and the PyPI notes describing 2.1 as a Python 3.5 compatibility bugfix), we might want to say >=2.1 rather than >=2.0.\n. The recent corroborating report makes me wonder if my previous comment\u2014or rather, subsequent inaction\u2014was a little too nitpicky. A not-abandoned (yet??) project should not sit on patches that make things work that currently do not work. But I didn't want to merge without the requirement being tightened to >=2.1, and I didn't want to unilaterally tighten the requirement without actually testing it on Windows, and I didn't want to actually test it on Windows because that would take precious minutes that I don't necessarily have to spare. But between this report, #1022, the pyreadline release notes, and the limited amount of damage you can do to functionality that is already broken, maybe I can trust myself to reason about the correctness of a one-character change without testing the result empirically? It is with this thought that I go ahead and add 888c7efe0 to this branch and merge. (Travis can't help us with this one, all the CI build targets are Linux.)\nThanks, @2alex2! :sparkling_heart:\n. @krysros thanks for the bug report. This should be fixed on master as of a few minutes ago (#1011). There's no PyPI release yet, but you should be able to install master from GitHub with pip install git+git://github.com/hylang/hy.git. (And reopen this Issue if it doesn't work!)\n. @poltak thanks!\u2014cherry-picked d858107 to master as fe4f677e.\n. @lunacodes thanks! :sparkling_heart: :shipit: \n. Yeah, sorry for losing momentum and ghosting on #805 (this time last year!). The blocking issue that I perceived there was await not working inside of let. Since we already know that let is subtly broken in several other ways, maybe we shouldn't regard that as blocking (uh, no pun intended) the coroutines feature? With this issue serving as a reminder, it's possible I'll find time to rebase and finish up my branch soon, but (it should be needless to say) anyone else is welcome to use my commit from the other year (or not!) and submit their own PR first.\n. > Maybe it's enough to backport await to Hy on Python 2 using yield-from\nExcept the yield-from backport is also broken, so we'd have to fix that first/too ...\n. (Continued from discussion on #692)\nIt does look to me like this suffers from #691\u2014\n(hy2)zmd@ExpectedReturn:~/Code/hy2/hy2$ hy \nhy 0.11.0 using CPython(default) 2.7.6 on Linux\n=> (defn fail [] (if some-test (yield-from some-presumptive-generator)))\nTraceback (most recent call last):\n  File \"/home/zmd/Code/hy2/hy2/hy/importer.py\", line 44, in ast_compile\n    return compile(ast, filename, mode, flags)\nSyntaxError: 'return' with argument inside generator (<input>, line 1)\nThe problem seems to be that we sometimes translate a Hy expression in tail position to a Python assign-a-temporary-value-then-return-it maneuver, and mixing return and yield in the same function doesn't work in Python 2; the compiler ostensibly tries to deal with this, but as our BDFL commented on #691, it would seem to be buggy.\n(This pull request might still be a good idea, though! Faithfully translating the \"Formal semantics\" section of PEP 380 probably has fewer bugs than the existing yield-from backport, even if there's another bug elsewhere in the contains_yield stuff.)\n. ack\n. Thanks.\n. 0.12a0, like Python does it?\n. Thanks! :sparkling_heart: \n. thx :sparkling_heart: \n. at a cursory look-over, seems sane to me :+1: \n. a PEP 530 grammar change, grepping suggests we likely just need an is_async=False one place in _compile_generator_iterables()? Patch later\n. my pull request probably also should have mentioned that I locally tested with CPython master (3.7.0a0 python/cpython@174a57d08) and it worked\n. Seems to work? @gilch \n. I mean, ideally we would finish the Grand Language Cleanup and actually release 0.12 (or 1.0??) on PyPI, but since everyone is presumably too busy with their dayjobs and other projects to actually get this done (I certainly am) and this has been the case for months, not actively misleading users is a good idea.\n. _+1_\n. @kirbyfan64 @gilch I chose \"nightly\" in #1113 because (as I recall) the Travis CI docs noted that it pointed to the 3.6-dev branch (and there was no separate 3.6 target). It looks like that page has been updated now, and there is a \"3.6-dev\" target.\n. > So it needs to say 3.6-dev? \nProbably!\n\nAlso, since nightly points to 3.7-dev now and nightly is failing, does this mean 3.7 will break Hy again?\n\nI would bet against it: the specific failure that @Kodiologist  pointed out in the other issue looks like a mismatch between the version Tox expected (3.6) and what was actually on the nightly branch (3.7.0a0).\n. _+1 :sparkling_heart: \n. (To clarify, the :heart: reaction on the parent is for the \"completely forgot Python 2.x\" part.)\n. It's very sad; the right time to change the standard library to uniformly use is_ _would have been in Python 3.0, but now our one and only one chance to backwards-incompatibly break the world has been spent (as the Python community has learned the hard way that the world doesn't necessarily re-form afterwards).. :heart: . (already left team). One also wonders whether it's not a coincidence that the name can be stylized with \u03bb s.. This was actually intentional; I wanted to show the exception when the mandatory keyword argument was omitted, but Sphinx/Pygments didn't do any syntax highlighting when it was all part of the same Clojure-style block (probably because it got confused by the Python stack trace), whereas if just the part with the stack trace is in a separate Python block, I think it looks OK\u2014\n\n. Yes, but it'll have to be a little later after I find more time to think about how to do it properly. I had originally tried something like this (in native_tests/language.hy)\u2014\nhy\n(defn test-kwonly []\n  \"NATIVE: test keyword-only arguments\"\n  (if PY3\n    (do\n      ;; [redacted for brevity]\n    )\n    ;; Python 2\n    (let [[attempt-to-use-kwonly\n           (try\n            (setv this-will-fail (fn [&kwonly foo] (inc foo)))\n            (catch [e [Exception]] e))]\n          [expected-exception-message\n           \"keyword-only arguments are only available under Python 3\"]]\n      (assert (isinstance attempt-to-use-kwonly HyTypeError)\n              (.format \"expected a HyTypeError, got {}\"\n                       attempt-to-use-kwonly))\n      (assert (= (. attempt-to-use-kwonly args [0])\n                 expected-exception-message)\n              (.format \"expected HyTypeError to have message \\\"{}\\\"\"\n                       expected-exception-message)))))\nbut then the entire test run would die on the TypeError (\"Ran 1 test in 13.094s / FAILED (errors=1)\") instead of catching it like I had intended.\n. Added an AST test in 9de19504 which covers the Python 2 behavior.\n. Testing that something compiles isn't the same as testing that it behaves as intended. (For instance, the can_compile(\"(fn [[a b]] (print a b))\") assertion passes on master.) Perhaps it may be worth adding an assertion that the AST object returned by can_compile is what we expect, or maybe adding a native test along the lines of\u2014\n(defn test-argument-destructuring []\n  (defn function-with-destructured-args [a [b c] [d e f]]\n    (, a b c d e f))\n  (assert (= (, 1 2 3 4 5 6)\n             (function-with-destructured-args 1 [2 3] [4 5 6]))))\n(which errors against master with NameError: name 'b' is not defined, but passes against the destruct-args branch)?\n. Forgive me, but I don't understand the purpose of incrementing i here at the end of the loop. Won't i have that value on the next iteration anyway?\n. > Would it go in native_tests/language.hy?\nSure? (said with the intonation of a question, as if to allude to your experience with how things are done around here outweighing mine)\n. No, it cannot (although I'm making a mental note to ask myself that good question next time I find myself writing the identity function).\nThe thought process here was that builds_if is going to be a decorator that takes arguments, which one can think of as a function that returns the \"actual\" decorator that will wrap the function being decorated by the decorator-with-arguments. The indended behavior is that if condition is truthy, we want a function decorated with @builds_if(\"\u2605\", condition) (this example imagines ourselves defining a \\u2605 Black Star operator, perhaps for some hypothetical far-future version of Python) to behave as if it were decorated with @builds(\"\u2605\"), so in that case we return the decorator that we want: builds(\"\u2605\"). But if condition is falsey, we want the @builds_if(\"\u2605\", condition) decorator to be a no-op (that just passes the function being decorated on to the next decorator in the decorator-chain as if it were never there). But the no-op decorator is the identity function; as the pasted output below shows, we don't want to return _type because _type is a string in the actual usage of @builds and @builds_if\u2014\n```\n(hy) zmd@ExpectedReturn:~/Code/hy/hy$ git diff\ndiff --git a/hy/compiler.py b/hy/compiler.py\nindex 8eb2291..7209f82 100644\n--- a/hy/compiler.py\n+++ b/hy/compiler.py\n@@ -123,10 +123,11 @@ def builds(_type):\ndef builds_if(_type, condition):\n+    print(\"MY DEBUG MARKER A\", _type, condition)\n     if condition:\n         return builds(_type)\n     else:\n-        return lambda fn: fn\n+        return _type\nclass Result(object):\n(hy) zmd@ExpectedReturn:~/Code/hy/hy$ hy\nMY DEBUG MARKER A @ False\nTraceback (most recent call last):\n  File \"/home/zmd/Code/hy/bin/hy\", line 9, in \n    load_entry_point('hy==0.10.1', 'console_scripts', 'hy')()\n  File \"/home/zmd/Code/hy/lib/python3.4/site-packages/setuptools-0.9.6-py3.4.egg/pkg_resources.py\", line 378, in load_entry_point\n  File \"/home/zmd/Code/hy/lib/python3.4/site-packages/setuptools-0.9.6-py3.4.egg/pkg_resources.py\", line 2566, in load_entry_point\n  File \"/home/zmd/Code/hy/lib/python3.4/site-packages/setuptools-0.9.6-py3.4.egg/pkg_resources.py\", line 2260, in load\n  File \"/home/zmd/Code/hy/hy/hy/init.py\", line 37, in \n    import hy.importer  # NOQA\n  File \"/home/zmd/Code/hy/hy/hy/importer.py\", line 22, in \n    from hy.compiler import hy_compile, HyTypeError\n  File \"/home/zmd/Code/hy/hy/hy/compiler.py\", line 370, in \n    class HyASTCompiler(object):\n  File \"/home/zmd/Code/hy/hy/hy/compiler.py\", line 1651, in HyASTCompiler\n    @checkargs(min=2)\nTypeError: 'str' object is not callable\n``\n.except ValueError:`\n(In accordance with the platitude that it's usually better to catch only the specific exceptions the programmer actually expects to happen, giving us the opportunity to notice and correct the erroneous program if something else happens,  and a bare except: will swallow even SystemExit and KeyboardInterrupt. Here, we get a ValueError both when obj has a non-one number of slashes, and when lhs or lrs can't be interpreted as an integer; I can't think of any other exceptions to expect.)\n. Floor division needs its identity, too\u2014\n=> (// 2)\nTraceback (most recent call last):\n  File \"/home/zmd/Code/hy/hy/hy/compiler.py\", line 2315, in hy_compile\n    result = compiler.compile(tree)\n  File \"/home/zmd/Code/hy/hy/hy/compiler.py\", line 428, in compile\n    ret = self.compile_atom(_type, tree)\n  File \"/home/zmd/Code/hy/hy/hy/compiler.py\", line 420, in compile_atom\n    ret = _compile_table[atom_type](self, atom)\n  File \"/home/zmd/Code/hy/hy/hy/compiler.py\", line 596, in compile_raw_list\n    ret = self._compile_branch(entries)\n  File \"/home/zmd/Code/hy/hy/hy/compiler.py\", line 483, in _compile_branch\n    return _branch(self.compile(expr) for expr in exprs)\n  File \"/home/zmd/Code/hy/hy/hy/compiler.py\", line 313, in _branch\n    results = list(results)\n  File \"/home/zmd/Code/hy/hy/hy/compiler.py\", line 483, in <genexpr>\n    return _branch(self.compile(expr) for expr in exprs)\n  File \"/home/zmd/Code/hy/hy/hy/compiler.py\", line 440, in compile\n    raise_empty(HyCompileError, e, sys.exc_info()[2])\n  File \"<string>\", line 1, in raise_empty\nhy.errors.HyCompileError: Internal Compiler Bug \ud83d\ude31\n\u2937 KeyError: '//'\nCompilation traceback:\nFile \"/home/zmd/Code/hy/hy/hy/compiler.py\", line 428, in compile\n    ret = self.compile_atom(_type, tree)\n  File \"/home/zmd/Code/hy/hy/hy/compiler.py\", line 420, in compile_atom\n    ret = _compile_table[atom_type](self, atom)\n  File \"/home/zmd/Code/hy/hy/hy/compiler.py\", line 1817, in compile_expression\n    ret = self.compile_atom(fn, expression)\n  File \"/home/zmd/Code/hy/hy/hy/compiler.py\", line 420, in compile_atom\n    ret = _compile_table[atom_type](self, atom)\n  File \"/home/zmd/Code/hy/hy/hy/compiler.py\", line 1733, in compile_maths_expression_mul\n    ]).replace(expression)\n. I think this looks better on versions of Python released during the last half-decade\u2014\n=> #{3 1 2}\n{1, 2, 3}\n(If I didn't have a strict personal policy of never using smiley emoticons, I would insert one here to indicate that this is said in a tone of good-natured humor rather than actual antipathy towards Python 2.)\n. I think this comment could be more descriptive, like #  can tokenize (ignored) backslash-newline. (Source comments occupy valuable real estate; dedicated future readers who want to find an associated ticket can always look for more info in the commit message, but casual readers might be annoyed by the exhortation to look up a magic number on GitHub.)\n. (The standard spelling is octal, with an a.)\n. \"values with a __bool__ method (or __nonzero__ on Python 2)\"?\n. (I don't immediately have an alternative example to propose, but this example is a little awkward in that it's not immediately obvious what input would trigger the \"not a number\" branch\u2014I think it would need to be a custom class for which __lt__, __gt__, and __eq__ return False for input 0.0.)\n. (accidental extra space between yes-branch and the close-bracket) \n. I see integers, nil, and the empty string in this test, but I think we should exercise the paradigmatic conditions true and false here, too. (For exhaustiveness, we could also test nonempty strings, empty and nonempty collections, floats, and custom classes. This is perhaps pedantic\u2014I don't actually expect these extra cases to uncover any bugs in the implementation\u2014but testing paranoia is probably healthy.)\n. Oh, right!\u2014I am aware of floating-point NaN, although its existence would seem to have momentarily slipped my mind while I was writing the grandparent comment. The example is fine.\n. Huh, I don't usually see these written with a space after the shebang.\n. Won't this result in version being \"unknown\" if Git isn't available? (All reasonable development environments will have Git, but we do at least theoretically have actual users who will be installing from PyPI.)\n. I thought pip install more-or-less downloads the source tarball from PyPI and runs setup.py install, such that the setup.py-generated version.py file would not already be present in the source tarball? I'm not sure, either, though.\n. a implementation detail regarding changes to the Python AST; if mentioning in the release notes at all, probably fold under \"Python 3.5 compatibility\"\n. well, Python 3.5 compatibility itself is interesting; Hy 0.11 will misbehave under Py3.5 (see the pull request comment)\n. ",
    "copyninja": ":+1: \n. Nope .text is a string attribute the above can be used to call only functions. This request is basically to access attributes of an object from complex expression rather than methods. Also this is feature request so if some one can tag it with proper label that would be good\n. I could find this PR other than. Coverall ;-) and +1 from my side \n. May be better suited for hy.flavor.clojure than contrib.\n. @algernon Ok the feature as such might be in multiple language but I was talking with respect to defmulti keyword which on searching looks specific to Clojure! Correct me if I'm wrong in assuming that.\n@Foxboron Ok I was just talking about this with keyword naming thats all :-)\n. There is bug (mistake) in the code please don't merge this yet. I will ping back when this is ready\n. So now this PR is ready for review. Some usage example\n``` clj\n=> (null? [])\nTrue\n=> (null? ())\nTrue\n=> (null? [1 2 3])\nFalse\n=>(null? (, 1 2 3))\nFalse\n=>(null? nil)\nFalse\n=> (null? \"Foo\")\nFalse\n```\n``` clj\n=> (pair? [])\nFalse\n=> (pair? ())\nFalse\n=> (pair? [1 2 3])\nTrue\n=> (pair? (, 1 2 3))\nTrue\n=> (pair? \"Foo\")\nFalse\n=> (pair? {})\nFalse\n``\n. Ping.. Any review on this PR?\n. I've rebased the PR with latest master changes.\n. This idea of flavor was proposed by @olasd and seconded by @algernon on IRC. Idea is not to clutter the core with all things, current situation is every one trying to pull hy in their own lisp dialect way rather than that just have core things in language core and move all other functions to respective flavors. I kinda liked the idea when @olasd proposed it and hence moved my functions tohy.flavor.scheme`\n. @khinsen that is what I thought when I closed the PR. I would try to do it soon. Just wondering what should I name it though.\n. :+1: \n. ",
    "ghost": "Awesome, thanks!\n. Thanks.\n=> (import inspect)\n=> (inspect.getmembers hy.contrib)\nreturned too much stuff for me to parse...\n. endrebakkenstovner@endres-MBP ~/c/endre-hy ((f053055...))> git rebase -i HEAD~3\nSuccessfully rebased and updated detached HEAD.\nendrebakkenstovner@endres-MBP ~/c/endre-hy ((f053055...))> git push origin anaphoric-import-info-missing --force\nTotal 0 (delta 0), reused 0 (delta 0)\nTo git@github.com:endrebak/hy.git\n + f053055...633e660 anaphoric-import-info-missing -> anaphoric-import-info-missing (forced update)\nI still see several commits above though...\n. Much obliged, did not read the instructions, just quickly copy pasted the commands. (Off to hack on hy-mode.el ...)\n. Function, I guess that is argument destructuring.\n. https://irc.gitter.im/ claims that the IRC support is beta, so perhaps changing is not the best option (I cannot remember seeing that page when I asked.)\nI know many projects use it successfully, like spacemacs: https://gitter.im/syl20bnr/spacemacs and I'm sure it lowers the bar for participation (whether that is a good thing depends on whether you are Linus Torvalds vs. for example Sylvain Benner.)\nBest discussion of tradeoffs/benefits/IRC integration I have seen: https://github.com/w3c/modern-tooling/issues/16\nFeel free to close btw. If someone else is interested, I'm sure they'll reopen.\n. the result is different, can you help look at it?\nin python\npython\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\ndf = pd.read_csv('https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data', header=None)\n X = df.iloc[0:100, [0, 2]].values\ntype(X)\n=> <type 'numpy.ndarray'>\nX[:50, 0]\n=> array([ 5.1,  4.9,  4.7,  4.6,  5. ,  5.4,  4.6,  5. ,  4.4,  4.9,  5.4,\n        4.8,  4.8,  4.3,  5.8,  5.7,  5.4,  5.1,  5.7,  5.1,  5.4,  5.1,\n        4.6,  5.1,  4.8,  5. ,  5. ,  5.2,  5.2,  4.7,  4.8,  5.4,  5.2,\n        5.5,  4.9,  5. ,  5.5,  4.9,  4.4,  5.1,  5. ,  4.5,  4.4,  5. ,\n        5.1,  4.8,  5.1,  4.6,  5.3,  5. ])\nin hy:\nhy\n(import [pandas [read-csv]]                                                                                                                          \n        [numpy [where]]                                                                                                                              \n        [matplotlib.pyplot [scatter]])                                                                                                               \n(let [df (read-csv \"https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data\" :header None)                                          \n      x (. df.iloc [(slice 0 100)] [[0 2]] values)]                                                                                                  \n  (type x)\n  (. x [(slice nil 50)] [0]))\n=>  <type 'numpy.ndarray'>         \n=> array([ 5.1,  1.4])\n. solved:\nhy\n(let [df (read-csv \"https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data\" :header None)                                          \n      x (. df.iloc [(, (slice 0 100) [0 2])] values)]                                                                                                \n  (. x [(, (slice nil 50) 0)] )                                                                                                                     \n  )\nthanks\n. Thanks!. ",
    "jrabbit": "That works too!\nOn Sep 29, 2013 12:14 AM, \"Tuukka Turto\" notifications@github.com wrote:\n\nhttp://hy.rtfd.org/en/latest/quickstart.html worked for me after adding a\nredirect there. Does it work for everyone else too? hy.readthedocs.orgworks, do we have any preference on one over another?\n@hylang/core care to have a look?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/pull/300#issuecomment-25314641\n.\n. \n",
    "sbp": "Deprecated by #310. Please consider that PR instead.\n. There's a problem with #310 in the console:\nclojure\n=> (defmacro square [x] `(* ~x ~x))\n=> (macroexpand '(square x))\n(u'square' u'x')\nWhich had worked in #308:\nclojure\n=> (defmacro square [x] `(* ~x ~x))\n=> (macroexpand (square x))\n(u'*' u'x' u'x')\n. Okay, this works in the console now:\nclojure\n=> (defmacro square [x] `(* ~x ~x))\n=> (macroexpand-1 '(square x))\n(u'*' u'x' u'x')\nBut at the expense of some really ugly code to get --name-- as a dynamic rather than static variable:\nclojure\n(setv f (get (get (.stack inspect) 1) 0))\n(setv name (get f.f_globals \"__name__\"))\nObviously it would be nice if there were a cleaner solution.\n. Another thing to consider is whether macroexpand should be named macroexpand-all.\n. ",
    "proppy": "Nop, this is slightly different: this PR is an appengine app skeleton, the other PR was for try-hy.\n. ",
    "tianon": "In #docker and #docker-dev we've been enjoying botbot.me which besides\nhaving pretty logs will respond to \"gh#xxx\" messages with the title of the\nissue and a link.  I'd be happy to help get that set up if people are\ninterested (I've helped get them on the hook for other channels before).\n. Any chance we could get a little blurb in the docs about what this is and how to use it?  (Note, I'm just an interested user here, not Hy core or anything.  This looks neat!)\n. Also (and coming as a real green Hy user, so keep my comments in perspective here), I don't think it's at all a problem that if people use a non-descriptive variable like name that it shadows this.  This problem already exists for other bits of the language, and this is just a case where you can't both use such a bad name, and use this cool new core function, from my point of view. :+1:\n. Very tasty.  I think it's prudent to reference paultag/dockerfiles#1 here too, since it led to where this is now.\nLGTM :)\n. console\n$ docker build -t hylang .\n...\n$ docker run -it --rm hylang\nhy 0.10.0 using CPython(default) 3.4.1 on Linux\n=>\n. Does \"timeit\" do enough special logic to warrant not just reimplementing it\ndirectly in Hy instead of doing all this juggling around into Python land,\npotentially screwing up the timing calculations?\n(Not a core developer, just piping in to try and help reason through this.\n:))\n. I've been playing with this PR especially with regards to reading from files (specifically reading and loading Hy files into other Hy files without making them modules, so a little on the crazy side, but a good test for this PR IMO), and I can't figure out a good clean way to detect EOF - it always spirals into infinite loop zone.\nhy\n       (with [[f (open (join dir name))]]\n             (while true\n                    (-> f (read) (eval))))\nI played with doing my own (while (!= (.read f 1) \"\") (.seek f -1 1) (-> f (read) (eval))) nonsense and of course got fun balks on that (io.UnsupportedOperation: can't do nonzero cur-relative seeks; not to mention how nasty and unintuitive that code is).\nNow reading the Python docs, it appears that .read will return the empty string for EOF:\n\nIf 0 bytes are returned, and size was not 0, this indicates end of file. If the object is in non-blocking mode and no bytes are available, None is returned.\n\n(From https://docs.python.org/3/library/io.html#io.RawIOBase.read)\nWould it make sense to emulate this in some way so I could replace that hard-coded (while true ...) with something a little less infinite? :trollface:\n. :heart: so clean:\nhy\n       (with [[f (open (join dir name))]]\n             (try\n               (while true (eval (read f)))\n               (catch [e EOFError] (print \"EOF!\")))\n... and look at that, I've reimplemented the following in straight Hy without calling internal hylang parser functions directly:\nhy\n       (for [form (import_file_to_hst (join dir name))]\n            (eval form))\n:heart_eyes: \n. (not to mention reading the file incrementally instead of all at once)\n. Hmm, thinking about it more, isn't stdin kind of a strange name for the IO object being read?  Wouldn't something like input make more sense, since it really just needs to be something that can be \"read\" from?\n. (I mean, it doesn't matter much for when you call it like (read someioobject), but it does matter for the way presented in the docs update with apply and explicit naming.)\n. :heart: even the tests are pertyyyy :dancer:\n. Consider me just an interested observer here, but I'd definitely +1 to solving this any way other than git submodules; they're such a pain.\n. I certainly think so, especially since you could then do fun stuff like\ndirectly eval a genexpr or list-comp return value directly (not that I have\nan actual use case for that - Paul just mentioned that it might be good for\nhy_eval to be able to properly eval a list of expressions, and I ran with\nit).\n. (See also the current state of http://docs.hylang.org/en/latest/language/core.html#read, which illustrates the example code block problem.)\n. :heart:!\n. ping @paultag\n. Wouldn't a breaking change just be 0.11?\n. Aww, nobody even telling me I'm crazy and this shouldn't be a thing?  No opinions on this at all? :smile:\n. I went with 0.10.2 for now since I personally think it makes sense to assume we don't have breaking changes that warrant 0.11 until we actually get some (in which case, it's not hard to search for 0.10.2 and replace it with 0.11 :+1:).  Happy to change it if there's disagreement though! :smile:\n. There isn't one, that's my point. :)\n. This also improves the \"cacheability\" of the official image, since everything that's outside of \".git\" is easy to get consistent deterministic timestamps on (and \".git\" is much more challenging to stop from having changes).\n. @paultag just to confirm your point:\nconsole\n$ docker run -it --rm hylang/hy\nhy 0.11.0 using CPython(default) 3.4.3 on Linux\n=> (let [[x 1]] (let [[x 2]] (print x)) (print x))\n2\n1\n(ie, the example you provided does work today)\n. I might be showing some of my na\u00efvety here, but couldn't we still get discrete pairs if we just dropped the outer brackets?\nhy\n(let [a 1] [b nil] [c \"42\"])\n. Oh duh, we need the next param to be the code.  /me sulks off into the corner\n. :+1: (sorry, honestly forgot this was my own issue, or I would've closed it myself :confounded:)\n. Being still pretty green to Hy myself, I can say for sure that this is one\nof the first things that turned me off really, really hard -- macros can\nsure look clean and neat when they're working, but when one breaks, abandon\nall hope.\n. I'm totally interested in tackling this if nobody else beats me to it. :innocent:\n. Got a working patch:\nconsole\nhy 0.10.1 using CPython(default) 3.4.2 on Linux\n=> (list (map < [4 7 5 9] [1 9 4 9]))\n[False, True, False, False]\n=> (list (map <= [4 7 5 9] [1 9 4 9]))\n[False, True, False, True]\n=> (list (map > [4 7 5 9] [1 9 4 9]))\n[True, False, True, False]\n=> (list (map >= [4 7 5 9] [1 9 4 9]))\n[True, False, True, True]\nOn to tests!\n. This wasn't as easy as I first thought because (1 < 2) < 3 (which is how the other shadow operator functions operate on their arguments) is very different from 1 < 2 < 3 (which is really parsed as 1 < 2 and 2 < 3).\n. Updated with a better comment about things we can't shadow ATM and with more appropriately comprehensive tests. :+1:\n. Looks like it's the same on master:\nhy\nhy 0.11.0 using CPython(default) 3.5.1 on Linux\n=> (+ 2 2)\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.5/site-packages/hy/compiler.py\", line 2585, in hy_compile\n    compiler = HyASTCompiler(module_name)\n  File \"/usr/local/lib/python3.5/site-packages/hy/compiler.py\", line 383, in __init__\n    load_stdlib()\n  File \"/usr/local/lib/python3.5/site-packages/hy/compiler.py\", line 76, in load_stdlib\n    mod = importlib.import_module(module)\n  File \"/usr/local/lib/python3.5/importlib/__init__.py\", line 126, in import_module\n    return _bootstrap._gcd_import(name[level:], package, level)\n  File \"<frozen importlib._bootstrap>\", line 986, in _gcd_import\n  File \"<frozen importlib._bootstrap>\", line 969, in _find_and_load\n  File \"<frozen importlib._bootstrap>\", line 958, in _find_and_load_unlocked\n  File \"<frozen importlib._bootstrap>\", line 664, in _load_unlocked\n  File \"<frozen importlib._bootstrap>\", line 634, in _load_backward_compatible\n  File \"/usr/local/lib/python3.5/site-packages/hy/importer.py\", line 188, in load_module\n    self.path)\n  File \"/usr/local/lib/python3.5/site-packages/hy/importer.py\", line 76, in import_file_to_module\n    _ast = import_file_to_ast(fpath, module_name)\n  File \"/usr/local/lib/python3.5/site-packages/hy/importer.py\", line 68, in import_file_to_ast\n    return hy_compile(import_file_to_hst(fpath), module_name)\n  File \"/usr/local/lib/python3.5/site-packages/hy/compiler.py\", line 2586, in hy_compile\n    result = compiler.compile(tree)\n  File \"/usr/local/lib/python3.5/site-packages/hy/compiler.py\", line 433, in compile\n    ret = self.compile_atom(_type, tree)\n  File \"/usr/local/lib/python3.5/site-packages/hy/compiler.py\", line 425, in compile_atom\n    ret = _compile_table[atom_type](self, atom)\n  File \"/usr/local/lib/python3.5/site-packages/hy/compiler.py\", line 627, in compile_raw_list\n    ret = self._compile_branch(entries)\n  File \"/usr/local/lib/python3.5/site-packages/hy/compiler.py\", line 489, in _compile_branch\n    return _branch(self.compile(expr) for expr in exprs)\n  File \"/usr/local/lib/python3.5/site-packages/hy/compiler.py\", line 316, in _branch\n    results = list(results)\n  File \"/usr/local/lib/python3.5/site-packages/hy/compiler.py\", line 489, in <genexpr>\n    return _branch(self.compile(expr) for expr in exprs)\n  File \"/usr/local/lib/python3.5/site-packages/hy/compiler.py\", line 445, in compile\n    raise_empty(HyCompileError, e, sys.exc_info()[2])\n  File \"<string>\", line 1, in raise_empty\nhy.errors.HyCompileError: Internal Compiler Bug \ud83d\ude31\n\u2937 TypeError: required field \"lineno\" missing from arg\nCompilation traceback:\nFile \"/usr/local/lib/python3.5/site-packages/hy/compiler.py\", line 433, in compile\n    ret = self.compile_atom(_type, tree)\n  File \"/usr/local/lib/python3.5/site-packages/hy/compiler.py\", line 425, in compile_atom\n    ret = _compile_table[atom_type](self, atom)\n  File \"/usr/local/lib/python3.5/site-packages/hy/compiler.py\", line 1992, in compile_expression\n    expression = macroexpand(expression, self.module_name)\n  File \"/usr/local/lib/python3.5/site-packages/hy/macros.py\", line 143, in macroexpand\n    load_macros(module_name)\n  File \"/usr/local/lib/python3.5/site-packages/hy/macros.py\", line 117, in load_macros\n    _import(module)\n  File \"/usr/local/lib/python3.5/site-packages/hy/macros.py\", line 114, in _import\n    __import__(module)\n  File \"<frozen importlib._bootstrap>\", line 969, in _find_and_load\n  File \"<frozen importlib._bootstrap>\", line 958, in _find_and_load_unlocked\n  File \"<frozen importlib._bootstrap>\", line 664, in _load_unlocked\n  File \"<frozen importlib._bootstrap>\", line 634, in _load_backward_compatible\n  File \"/usr/local/lib/python3.5/site-packages/hy/importer.py\", line 188, in load_module\n    self.path)\n  File \"/usr/local/lib/python3.5/site-packages/hy/importer.py\", line 79, in import_file_to_module\n    eval(ast_compile(_ast, fpath, \"exec\"), mod.__dict__)\n  File \"/usr/local/lib/python3.5/site-packages/hy/importer.py\", line 44, in ast_compile\n    return compile(ast, filename, mode, flags)\n=>\n. I'm definitely in way over my head here, but it appears that TypeError: required field \"lineno\" missing from arg is the real blocking error (so perhaps a new missing field in our AST generation or something?)\n. The thing that seems related from the changelog of 3.5.1 is Issue #25555: Fix parser and AST: fill lineno and col_offset of \u201carg\u201d node when compiling AST from Python objects. (https://bugs.python.org/issue25555)\n. Introducing a list and using for x in ... as above?  Having trouble with what to make the values (although testing just setting them both to 0 for now). :innocent:\n. Adding those fields (set to 0 for now) does appear to fix the explosion:\nhy\nhy 0.11.0 using CPython(default) 3.5.1 on Linux\n=> (+ 2 2)\n4\n=>\nSo now it appears to be just a matter of knowing what they ought to be set to. :smile:\n. Wooot, green CI now. :smile:\n. @zackmdavis yeah, I had a few rounds beforehand where I'd broken 2.7 and 3.3 :innocent:\n. Will rebase for CI once #1007 settles.\n. It might also make sense to include #983 here so we're testing Python 3.5 via CI for the new branch -- thoughts? (Happy to add those two commits if there's some agreement.)\n. How about #843?  If I add that one also, the 3.5 one applies completely clean without any conflicts (although I'm happy to resolve the conflicts instead if you'd rather).\n. Ok cool, will do.\n. Whew, I had to also include #800 for complete Python 3.5 support, but that does it. :+1:  (Only pypy still running in CI now.)\n. Woot, green! :metal:\n. https://github.com/hylang/hy/compare/0.11.0...master It's a handy link for browsing\nI don't feel like the right person to ask :innocent: \nNothing there really jumps out at me, but I don't really understand half of it either :smile:  I know botsbuildbots fails for me in random places like the Debian tests, but not sure whether that's fixed in master or not (I see it moved to contrib at least)\n. cc @jwilk :heart:\n. Arg, I'm on both Docker and Debian -- Debian is at 0.12.1 now (https://packages.debian.org/sid/hy), and I need to look into my Docker automation to figure out why it didn't pick up 0.12.1.  I'll get that fixed ASAP. :+1:. Ok, Docker update is in queue: https://github.com/docker-library/official-images/pull/2781. Seems to work OK: (although @kirbyfan64 looks to have some suggestion for improvement)\nconsole\n$ docker run -it --rm python:3.6-slim bash\nroot@b011412a2806:/# pip install https://github.com/Kodiologist/hy/archive/version-gen-updates.tar.gz\nCollecting https://github.com/Kodiologist/hy/archive/version-gen-updates.tar.gz\n  Downloading https://github.com/Kodiologist/hy/archive/version-gen-updates.tar.gz (376kB)\n    100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 378kB 2.0MB/s \nCollecting rply>=0.7.0 (from hy===unknown)\n  Downloading rply-0.7.4-py2.py3-none-any.whl\nCollecting astor>=0.5 (from hy===unknown)\n  Downloading astor-0.5-py2.py3-none-any.whl\nCollecting clint>=0.4 (from hy===unknown)\n  Downloading clint-0.5.1.tar.gz\nCollecting appdirs (from rply>=0.7.0->hy===unknown)\n  Downloading appdirs-1.4.0-py2.py3-none-any.whl\nCollecting args (from clint>=0.4->hy===unknown)\n  Downloading args-0.1.0.tar.gz\nInstalling collected packages: appdirs, rply, astor, args, clint, hy\n  Running setup.py install for args ... done\n  Running setup.py install for clint ... done\n  Running setup.py install for hy ... done\nSuccessfully installed appdirs-1.4.0 args-0.1.0 astor-0.5 clint-0.5.1 hy-unknown rply-0.7.4\nroot@b011412a2806:/# hy\nhy unknown using CPython(default) 3.6.0 on Linux\n=> (+ 2 2)\n4. :+1: :heart:\nconsole\n$ docker run -it --rm python:3.6-slim bash\nroot@0da57fa95d46:/# pip install https://github.com/Kodiologist/hy/archive/version-gen-updates.tar.gz\nCollecting https://github.com/Kodiologist/hy/archive/version-gen-updates.tar.gz\n  Downloading https://github.com/Kodiologist/hy/archive/version-gen-updates.tar.gz\n     \\ 389kB 1.2MB/s\nCollecting rply>=0.7.0 (from hy===unknown)\n  Downloading rply-0.7.4-py2.py3-none-any.whl\nCollecting astor>=0.5 (from hy===unknown)\n  Downloading astor-0.5-py2.py3-none-any.whl\nCollecting clint>=0.4 (from hy===unknown)\n  Downloading clint-0.5.1.tar.gz\nCollecting appdirs (from rply>=0.7.0->hy===unknown)\n  Downloading appdirs-1.4.0-py2.py3-none-any.whl\nCollecting args (from clint>=0.4->hy===unknown)\n  Downloading args-0.1.0.tar.gz\nInstalling collected packages: appdirs, rply, astor, args, clint, hy\n  Running setup.py install for args ... done\n  Running setup.py install for clint ... done\n  Running setup.py install for hy ... done\nSuccessfully installed appdirs-1.4.0 args-0.1.0 astor-0.5 clint-0.5.1 hy-unknown rply-0.7.4\nroot@0da57fa95d46:/# hy\nhy unknown using CPython(default) 3.6.0 on Linux\n=> (+ 2 2)\n4. I think https://github.com/docker-library/official-images/pull/3353 might be what @longquan7 had in mind. :+1:. ... and the follow-up: https://hub.docker.com/r/arm64v8/hylang/ :metal:. This is https://github.com/hylang/hy/issues/1446 -- if you pip install hy right now, it'll fail in this manner because it'll pull in the newer 0.6 astor which has breaking changes.  If you explicitly install astor 0.5 instead, it works. :+1:. FYI, https://github.com/orgs/hylang/teams/core/members is a 404 for nonmembers.. I'd suggest testing incognito (it still 404s for me).. I suppose this would apply to and and or as well, since I don't believe and can be shadowed either.\n. This should probably include some 3+ arg tests too. :disappointed:\n. Yeah, but then it wouldn't really be a \"shadow\" as much as just a handy way to use and_ hy-style.\n. ",
    "weakish": "Here is a repository:\nhttps://github.com/thomasballinger/bphython\nBut I failed to install it.\n. Thanks. Looking forward better debugging support for macros. #741\n. ",
    "coveralls": "\nCoverage increased (+0.53%) when pulling d82636958b010d5cdf34af22576f04ecb4ffd098 on Foxboron:with-macro2 into f189f0a45774692b284069b9adb1651ea2ac7805 on hylang:master.\n. \nCoverage decreased (-0.19%) when pulling 4fbf30cd78e34a7e344c522d6e4943c705ba00f3 on berkerpeksag:add-astor into 8970662dcb694d0bdc585f8b213c03c1b64c6b9a on hylang:master.\n. \nCoverage remained the same when pulling 9d703f1a47aa2cd7b012d6c9fdba398c7c57c855 on berkerpeksag:add-astor into 8970662dcb694d0bdc585f8b213c03c1b64c6b9a on hylang:master.\n. \nCoverage decreased (-0.86%) when pulling 870c136469d41fb594be1d70bf901ad2776e74a0 on berkerpeksag:add-astor into 8970662dcb694d0bdc585f8b213c03c1b64c6b9a on hylang:master.\n. \nCoverage decreased (-0.2%) when pulling 3e8941cdde01635890db524c4789f0640fe665c3 on berkerpeksag:add-astor into 8970662dcb694d0bdc585f8b213c03c1b64c6b9a on hylang:master.\n. \nCoverage decreased (-0.19%) when pulling aeb0cd4c72ced7aebb0edb5025bbaaecbb684cba on Willyfrog:meth-fix into 8970662dcb694d0bdc585f8b213c03c1b64c6b9a on hylang:master.\n. \nCoverage decreased (-0.18%) when pulling 0109234eb7fea7a3e5307b0ecbae09e7c8975749 on Willyfrog:meth-fix into c11b231c1c1c3bb5a55cc17dbfcb5a63df7d8ca6 on hylang:master.\n. \nChanges Unknown when pulling 76328edd20c1c61047bc4892a58f04c8f9a9679d on hcarvalhoalves:master into * on hylang:master*.\n. \nCoverage remained the same when pulling 5ece62fb16ac102062751cb74c2230026068455d on joehakimrahme:master into 2f845c2a1eaa57596ad692f7e226a1abf72ec8f8 on hylang:master.\n. \nCoverage decreased (-0.19%) when pulling 8a59de64b6846c930bc31e7130c9db7b9da0beef on copyninja:master into 2f845c2a1eaa57596ad692f7e226a1abf72ec8f8 on hylang:master.\n. \nCoverage decreased (-0.19%) when pulling 35d0c328eca13c890af91fe8ea40c7440c8cab43 on copyninja:master into 2f845c2a1eaa57596ad692f7e226a1abf72ec8f8 on hylang:master.\n. \nCoverage remained the same when pulling 1f89feed14a9e6274b4298d20678f62cf51a9e8f on hcarvalhoalves:better-repr into 2f845c2a1eaa57596ad692f7e226a1abf72ec8f8 on hylang:master.\n. \nCoverage remained the same when pulling 7107edd573280128594c43242901ec596e3b1ae1 on hcarvalhoalves:better-repr into 2f845c2a1eaa57596ad692f7e226a1abf72ec8f8 on hylang:master.\n. \nCoverage decreased (-0.44%) when pulling d6ef405b387aedb92cf2665b5df4bceae056b7b7 on hcarvalhoalves:better-repr into 2f845c2a1eaa57596ad692f7e226a1abf72ec8f8 on hylang:master.\n. \nCoverage decreased (-2.65%) when pulling 5145bc64cda1e35d860d5fcf9e777a3b7512c92c on hcarvalhoalves:better-repr into e3646bb8742e467bf19dcda0d4e2e4d873f15c06 on hylang:master.\n. \nCoverage decreased (-2.14%) when pulling 5145bc64cda1e35d860d5fcf9e777a3b7512c92c on hcarvalhoalves:better-repr into e3646bb8742e467bf19dcda0d4e2e4d873f15c06 on hylang:master.\n. \nCoverage remained the same when pulling 70f2e41aaf62132e3bd2a2be8714f57b52662756 on theanalyst:feature/macros-none into f9a1995be8641867612761e95b66200b103823e1 on hylang:master.\n. \nCoverage remained the same when pulling f1c68bd51a7940c9e047f38f8652728af7d0b45e on theanalyst:feature/macros-none into cc147512fc4e25917551bf422dc06d380e60692d on hylang:master.\n. \nCoverage decreased (-0.19%) when pulling d4d0dd985437de9c26da416a5992dd8233ff4cec on berkerpeksag:docs-updates into f9a1995be8641867612761e95b66200b103823e1 on hylang:master.\n. \nCoverage decreased (-0.19%) when pulling f591f484119b2c272f36d3a764ff9483ef598769 on berkerpeksag:docs-updates into f9a1995be8641867612761e95b66200b103823e1 on hylang:master.\n. \nCoverage decreased (-0.19%) when pulling ecd13ef6594326456e9ff42d1041291f937f66f5 on berkerpeksag:spy-versionadded into cc147512fc4e25917551bf422dc06d380e60692d on hylang:master.\n. \nCoverage remained the same when pulling 6d4ca6e5b4b4cce0abe080c93eecabfe22831949 on algernon:f/362-multi-get into 948e6d34c7099e562e6caa51598c6aeb506cfd73 on hylang:master.\n. \nCoverage decreased (-0.18%) when pulling 60251375b244b0e169b7f915b45bc70bda7aad1b on algernon:f/362-multi-get into 948e6d34c7099e562e6caa51598c6aeb506cfd73 on hylang:master.\n. \nCoverage increased (+0.68%) when pulling 62522a5f8693dfb13f589f520739b1281776e379 on algernon:f/362-multi-get into f189f0a45774692b284069b9adb1651ea2ac7805 on hylang:master.\n. \nCoverage decreased (-0.19%) when pulling 3c078105b72847843b5213514bdf7e4243e0371d on kzisme:master into 948e6d34c7099e562e6caa51598c6aeb506cfd73 on hylang:master.\n. \nCoverage decreased (-0.19%) when pulling 74822f58e697c8fd3de5f19146eeef4c209d4883 on kzisme:master into 948e6d34c7099e562e6caa51598c6aeb506cfd73 on hylang:master.\n. \nCoverage decreased (-0.19%) when pulling fef51f9745a8c95131f9d309ba96f6f6d2bc00db on kzisme:master into 948e6d34c7099e562e6caa51598c6aeb506cfd73 on hylang:master.\n. \nCoverage remained the same when pulling f3e9e56b7971c66fce7fa43d3803944237bd1b9f on yminer:master into 8970662dcb694d0bdc585f8b213c03c1b64c6b9a on hylang:master.\n. \nCoverage remained the same when pulling b1df057f2af596027d75e3d6e6bae5750ea62244 on yminer:master into d9d113670ee012f35140d34e2a159d2709c21798 on hylang:master.\n. \nCoverage decreased (-0.18%) when pulling e674eb4b56ae49588e891d5fcd591f71c71fe75e on berkerpeksag:skip-test into 8970662dcb694d0bdc585f8b213c03c1b64c6b9a on hylang:master.\n. \nCoverage decreased (-0.23%) when pulling e674eb4b56ae49588e891d5fcd591f71c71fe75e on berkerpeksag:skip-test into 8970662dcb694d0bdc585f8b213c03c1b64c6b9a on hylang:master.\n. \nCoverage decreased (-0.19%) when pulling 7da3d5cd7703ee4e2f44e994a8747690b79a02ef on theanalyst:feature/prog1 into c11b231c1c1c3bb5a55cc17dbfcb5a63df7d8ca6 on hylang:master.\n. \nCoverage decreased (-0.19%) when pulling bea68bcf0ac1a0f1364ba84101237b25bfbcc8a8 on paultag:paultag/feature/profile into c11b231c1c1c3bb5a55cc17dbfcb5a63df7d8ca6 on hylang:master.\n. \nCoverage decreased (-0.18%) when pulling 15aac9b3cc9bda99ed300596a1e4b875e3e4d3d5 on paultag:paultag/feature/profile into b2bb161cb085a4d8e5c43ace797cfe6f9395d762 on hylang:master.\n. \nCoverage decreased (-0.18%) when pulling c7603890ae0dd83221d65b7107eb7724549ea31b on paultag:paultag/feature/profile into b2bb161cb085a4d8e5c43ace797cfe6f9395d762 on hylang:master.\n. \nCoverage decreased (-0.18%) when pulling 63466d170d16706e1a92679b49e17c342d95f516 on paultag:paultag/feature/profile into b2bb161cb085a4d8e5c43ace797cfe6f9395d762 on hylang:master.\n. \nCoverage decreased (-0.22%) when pulling fb35e286e233c9ab9c01118ed8ce9e9aa2f97061 on paultag:paultag/feature/profile into b2bb161cb085a4d8e5c43ace797cfe6f9395d762 on hylang:master.\n. \nCoverage decreased (-0.18%) when pulling 9656c7f53cca11e7ce92575c539c6c54af68fdb5 on paultag:paultag/feature/profile into b2bb161cb085a4d8e5c43ace797cfe6f9395d762 on hylang:master.\n. \nCoverage decreased (-0.07%) when pulling d0375d6e7c6b6ed27cb8a76027e1ce7a364509a1 on rwtolbert:rwtolbert/features/gensym_take1 into c11b231c1c1c3bb5a55cc17dbfcb5a63df7d8ca6 on hylang:master.\n. \nCoverage decreased (-0.07%) when pulling d0375d6e7c6b6ed27cb8a76027e1ce7a364509a1 on rwtolbert:rwtolbert/features/gensym_take1 into c11b231c1c1c3bb5a55cc17dbfcb5a63df7d8ca6 on hylang:master.\n. \nCoverage decreased (-0.19%) when pulling f4d19f1c5a3358ff56a453668e60a97dea340e16 on rwtolbert:rwtolbert/features/gensym_take1 into c11b231c1c1c3bb5a55cc17dbfcb5a63df7d8ca6 on hylang:master.\n. \nCoverage decreased (-0.19%) when pulling f5d88bb108bb3d5ffa8e54d5f858489f0bbe466f on rwtolbert:rwtolbert/features/gensym_take1 into c11b231c1c1c3bb5a55cc17dbfcb5a63df7d8ca6 on hylang:master.\n. \nCoverage decreased (-0.19%) when pulling c80e3c75a04d07c42987d0881a20d42f62af4075 on rwtolbert:rwtolbert/features/gensym_take1 into c11b231c1c1c3bb5a55cc17dbfcb5a63df7d8ca6 on hylang:master.\n. \nCoverage decreased (-0.16%) when pulling f72ff53f4177a877fa697f6f5242a9f74cba80db on theanalyst:fix/arith-identity into c11b231c1c1c3bb5a55cc17dbfcb5a63df7d8ca6 on hylang:master.\n. \nCoverage decreased (-0.15%) when pulling 294fb8ab19eaea4a5acc01aca22d0151a4099de3 on Foxboron:reader-macros into c11b231c1c1c3bb5a55cc17dbfcb5a63df7d8ca6 on hylang:master.\n. \nCoverage remained the same when pulling 3eacff915f59a89e9b945beab9f93f1b5e028c5c on Foxboron:reader-macros into c11b231c1c1c3bb5a55cc17dbfcb5a63df7d8ca6 on hylang:master.\n. \nCoverage remained the same when pulling 14ae4d6049111a07cceb5ab1790df65d497eb4f3 on Foxboron:reader-macros into c11b231c1c1c3bb5a55cc17dbfcb5a63df7d8ca6 on hylang:master.\n. \nCoverage remained the same when pulling 7585389105da5e2b5e46442ff8832c674cde9b78 on Foxboron:reader-macros into c11b231c1c1c3bb5a55cc17dbfcb5a63df7d8ca6 on hylang:master.\n. \nCoverage decreased (-0.16%) when pulling 0f2033db21adb54eb27818456a0a81ae8e6542d0 on Foxboron:reader-macros into ceb612f385f8d773e6d811a82407ace448bb222c on hylang:master.\n. \nCoverage decreased (-0.84%) when pulling c9fdd40c9f1537e55bb334c49d7aa21e3e29f315 on Foxboron:reader-macros into 1a701d4dc497beeb12ff894dc815384341c8b2dc on hylang:master.\n. \nCoverage decreased (-0.19%) when pulling 7384030067f7e5d4ec6568de7a96069348bc0230 on berkerpeksag:update-authors into c11b231c1c1c3bb5a55cc17dbfcb5a63df7d8ca6 on hylang:master.\n. \nCoverage decreased (-0.19%) when pulling abcd97b1f1aba334a034c7cbfdd2843292a36c46 on berkerpeksag:update-authors into c11b231c1c1c3bb5a55cc17dbfcb5a63df7d8ca6 on hylang:master.\n. \nCoverage decreased (-0.16%) when pulling 3a22116a271ab1a9bc84e72b5528950becbe990a on Willyfrog:global-earmuff into c11b231c1c1c3bb5a55cc17dbfcb5a63df7d8ca6 on hylang:master.\n. \nCoverage decreased (-0.21%) when pulling 0a8c133c0a6e3262f475996f2ec59cff83005f3f on Willyfrog:global-earmuff into c11b231c1c1c3bb5a55cc17dbfcb5a63df7d8ca6 on hylang:master.\n. \nCoverage decreased (-0.23%) when pulling 3204c2a574070b416c1f9848527dec0f1bb89790 on rwtolbert:rwtolbert/bugfix/darwin-readline-sillyness into c11b231c1c1c3bb5a55cc17dbfcb5a63df7d8ca6 on hylang:master.\n. \nCoverage decreased (-0.15%) when pulling 8725fa0286c1a87d5c9763ef82e1f01c9a77434a on olasd:feature/add-del into 3204c2a574070b416c1f9848527dec0f1bb89790 on hylang:master.\n. \nCoverage decreased (-0.15%) when pulling 02847bbbe28221fab72860ad99575cd636dc8266 on olasd:feature/add-del into 3204c2a574070b416c1f9848527dec0f1bb89790 on hylang:master.\n. \nCoverage decreased (-0.15%) when pulling 5677a6c365b49c05da5ae962a070efed05e4eca6 on olasd:feature/add-del into 3204c2a574070b416c1f9848527dec0f1bb89790 on hylang:master.\n. \nCoverage decreased (-0.18%) when pulling 6aa24a2aa22f3d4b38afd21164d66012de6da2dd on theanalyst:feature/more-anaphora into 3204c2a574070b416c1f9848527dec0f1bb89790 on hylang:master.\n. \nCoverage decreased (-0.18%) when pulling 9da88bca861145c7486a7c36f57cc2fe5f24397d on theanalyst:feature/more-anaphora into 3204c2a574070b416c1f9848527dec0f1bb89790 on hylang:master.\n. \nCoverage decreased (-0.18%) when pulling 4137c40b125e9b87dcb6fa628c74f8c5082c8ff0 on theanalyst:feature/more-anaphora into 744cd71171dbdf3953f98d5a73d66eeee4453037 on hylang:master.\n. \nCoverage decreased (-0.18%) when pulling 1ef8b8bf2c3f3e1a9903871f3d7bd416a4e66493 on theanalyst:feature/more-anaphora into 744cd71171dbdf3953f98d5a73d66eeee4453037 on hylang:master.\n. \nCoverage decreased (-2.09%) when pulling b3e5adf1e52a9daaeb348572aa2e255b177430b2 on rwtolbert:rwtolbert/features/new_error_messages into 1a701d4dc497beeb12ff894dc815384341c8b2dc on hylang:master.\n. \nCoverage decreased (-3.03%) when pulling 4030b869b2f8b6e474463a4c01a99336bb270631 on rwtolbert:rwtolbert/features/new_error_messages into 744cd71171dbdf3953f98d5a73d66eeee4453037 on hylang:master.\n. \nCoverage decreased (-3.24%) when pulling 7bec48b475d517996dba3337eb8e30d3debaea62 on rwtolbert:rwtolbert/features/new_error_messages into c69c14cc7d107018d22032d7fb063fb1cd4a222b on hylang:master.\n. \nCoverage decreased (-3.2%) when pulling 06722c1e33b33268c01bc0f8e1ba20d6b10b360f on rwtolbert:rwtolbert/features/new_error_messages into c69c14cc7d107018d22032d7fb063fb1cd4a222b on hylang:master.\n. \nCoverage decreased (-3.44%) when pulling 2664a548419bd4d306534ef54fd05d16d5e12c71 on rwtolbert:rwtolbert/features/new_error_messages into c69c14cc7d107018d22032d7fb063fb1cd4a222b on hylang:master.\n. \nCoverage decreased (-3.13%) when pulling faf782560cbfdfc064744c048e07479c480087cb on rwtolbert:rwtolbert/features/new_error_messages into defbe223492b4f37514923055ec25f7a645777cc on hylang:master.\n. \nCoverage decreased (-0.18%) when pulling 27691e4d821473cf0984c381cea990e0b944acdf on berkerpeksag:reqs-astor into 1a701d4dc497beeb12ff894dc815384341c8b2dc on hylang:master.\n. \nCoverage decreased (-0.26%) when pulling 0d1cb30f4a5ed29f1750fc9c2e0cab6c16a7c7d4 on olasd:bugfix/apply-method-call into 744cd71171dbdf3953f98d5a73d66eeee4453037 on hylang:master.\n. \nCoverage decreased (-0.42%) when pulling 42ca2deb388553c631f6d9429b222e5f5efd987a on olasd:bugfix/apply-method-call into 744cd71171dbdf3953f98d5a73d66eeee4453037 on hylang:master.\n. \nCoverage decreased (-0.29%) when pulling cfbc792957b0ace401e8e2febd01f41fdebb04e8 on olasd:bugfix/apply-method-call into 744cd71171dbdf3953f98d5a73d66eeee4453037 on hylang:master.\n. \nCoverage decreased (-0.18%) when pulling 6172b60e759fba743ada0a4cfaa0a507ce77290a on paultag:paultag/ana/if into 744cd71171dbdf3953f98d5a73d66eeee4453037 on hylang:master.\n. \nCoverage decreased (-0.18%) when pulling c7070f82b5b9a83b67927c8401583dd7739b5c65 on paultag:paultag/ana/if into 744cd71171dbdf3953f98d5a73d66eeee4453037 on hylang:master.\n. \nCoverage decreased (-0.18%) when pulling 29c9e566e18d4df0c86e2d8e4a26e08796ba7a65 on paultag:paultag/ana/if into c69c14cc7d107018d22032d7fb063fb1cd4a222b on hylang:master.\n. \nCoverage decreased (-0.22%) when pulling 81d5f08100fa29f7749cf60cf04792a89a772211 on olasd:feature/only-macroexpand-when-needed into 744cd71171dbdf3953f98d5a73d66eeee4453037 on hylang:master.\n. \nCoverage decreased (-0.18%) when pulling 55a7ab1667583d95a514e33a5df62c376078c2f5 on rwtolbert:rwtolbert/features/add-nil into b2bb161cb085a4d8e5c43ace797cfe6f9395d762 on hylang:master.\n. \nCoverage decreased (-0.18%) when pulling 3f590f89161a504c0de5e99c85bf4fde6d14275b on kenanb:master into f6887ed7c2b2ed2eae89a3fbbe4db8eafc891169 on hylang:master.\n. \nCoverage increased (+0.51%) when pulling ac0b13b8c40aff10410805987afab4d46d0084fc on berkerpeksag:wr_long into f189f0a45774692b284069b9adb1651ea2ac7805 on hylang:master.\n. \nCoverage increased (+0.51%) when pulling 8120a25c0822598c9ed974562f068a94b0097ace on berkerpeksag:wr_long into f189f0a45774692b284069b9adb1651ea2ac7805 on hylang:master.\n. \nCoverage decreased (-0.18%) when pulling 4e3b6fd4cf6d36302bbc7f80c11ca3aa5ac5961b on rwtolbert:gensym-docs into d82636958b010d5cdf34af22576f04ecb4ffd098 on hylang:master.\n. \nCoverage decreased (-0.18%) when pulling 82da71d95ad1d3dd50002633ecb971828fb30ce9 on rwtolbert:document-flatten into 0a80b87b7f289aed77b389928f603b5b8cd8acf1 on hylang:master.\n. \nCoverage decreased (-0.22%) when pulling a5b56be83e732b6589e94c13abe090e587566738 on paultag:paultag/docs/compiler into d7956d03c35d23407172a69663576b5d95a4f892 on hylang:master.\n. \nCoverage decreased (-0.18%) when pulling cea84f9e2c81fee7ecb4146d5f87941c8257b2ac on Foxboron:reader-macro-docs into b011048b419d32135bfe20cf67aa9347cca1e022 on hylang:master.\n. \nCoverage decreased (-0.18%) when pulling 793b0e090314ae9fd6c2755aa54831aacbac789e on Foxboron:reader-macro-docs into b011048b419d32135bfe20cf67aa9347cca1e022 on hylang:master.\n. \nCoverage decreased (-0.18%) when pulling 2afc4b4e9d986adece0764df047bbf9525199010 on Foxboron:reader-macro-docs into b011048b419d32135bfe20cf67aa9347cca1e022 on hylang:master.\n. \nCoverage decreased (-0.18%) when pulling 9b1990901c619d6f8e728d3bed61607dd9d06e83 on berkerpeksag:sphinx-todo-ext into 426d34288f37c61182c7c0ef054a127dfbd83c6d on hylang:master.\n. \nCoverage decreased (-0.17%) when pulling 56946c3987ae1f0370449351f04953a47d0a94a4 on paultag:paultag/bugfix/im-an-idiot into 3774a05d879062bd5f649009ae59aca15a7c48e6 on hylang:master.\n. \nCoverage decreased (-0.17%) when pulling eeef65b505cc0f8b7585db35772428e2b87a24c9 on paultag:paultag/bugfix/im-an-idiot into 3774a05d879062bd5f649009ae59aca15a7c48e6 on hylang:master.\n. \nCoverage increased (+0.46%) when pulling 5941a1c92e657760241307461981c9a49e7e6690 on rwtolbert:rwtolbert/features/add-make-clean into dfbdbdfb73d43c63a6370a1afe2a3e834cbff783 on hylang:master.\n. \nCoverage decreased (-0.17%) when pulling 211175a9953d88bc268bb8c0e665adb8ff89c5dc on rwtolbert:rwtolbert/features/add-make-clean into 032200bcb40a8d007bb1764516039f1ca4d06750 on hylang:master.\n. \nCoverage increased (+0.46%) when pulling 032200bcb40a8d007bb1764516039f1ca4d06750 on rwtolbert:rwtolbert/bugfix/doc-errors-zero into dfbdbdfb73d43c63a6370a1afe2a3e834cbff783 on hylang:master.\n. \nCoverage remained the same when pulling f28bf41f8d95bd1408454f65812cea01e852ba61 on paultag:paultag/bugfix/python3.4 into 77baf3b9f3b621bc94172f4d4162194f39c144a3 on hylang:master.\n. \nCoverage remained the same when pulling f28bf41f8d95bd1408454f65812cea01e852ba61 on paultag:paultag/bugfix/python3.4 into 77baf3b9f3b621bc94172f4d4162194f39c144a3 on hylang:master.\n. \nCoverage remained the same when pulling f28bf41f8d95bd1408454f65812cea01e852ba61 on paultag:paultag/bugfix/python3.4 into 77baf3b9f3b621bc94172f4d4162194f39c144a3 on hylang:master.\n. \nCoverage decreased (-0.48%) when pulling 1d58e5258452e6dd5f60799cf6f1ed017bbd7dab on paultag:paultag/bugfix/python3.4 into 77baf3b9f3b621bc94172f4d4162194f39c144a3 on hylang:master.\n. \nCoverage remained the same when pulling f452558f5e7b795887130891ea0c9fe6fa7022cb on paultag:paultag/bugfix/python3.4 into 77baf3b9f3b621bc94172f4d4162194f39c144a3 on hylang:master.\n. \nCoverage decreased (-1.04%) when pulling c53e43f887eb4db627ed95473a4baae2a8faadc8 on paultag:paultag/bugfix/python3.4 into 77baf3b9f3b621bc94172f4d4162194f39c144a3 on hylang:master.\n. \nCoverage decreased (-0.48%) when pulling 590d3bf1df4bf5ef8d8297dc7a189b4a9f08e747 on paultag:paultag/bugfix/python3.4 into c213a4e12280ac7746ef5cbae79237e346bbe8c6 on hylang:master.\n. \nCoverage remained the same when pulling c5c36e10226ced03af7991b912726da9dc709437 on paultag:paultag/bugfix/python3.4 into a5b37b7b5160258fb57107f2f4a8f92fdba0b55f on hylang:master.\n. \nCoverage remained the same when pulling c5c36e10226ced03af7991b912726da9dc709437 on paultag:paultag/bugfix/python3.4 into a5b37b7b5160258fb57107f2f4a8f92fdba0b55f on hylang:master.\n. \nCoverage remained the same when pulling de31aea5d2d7ffd22ce82ffc609c8cbdccbd4d01 on paultag:paultag/bugfix/python3.4 into a5b37b7b5160258fb57107f2f4a8f92fdba0b55f on hylang:master.\n. \nCoverage decreased (-0.51%) when pulling 85bdd3fe194f113a4c4d2d30103038009e7cdd00 on paultag:paultag/bugfix/python3.4 into 2f54cd0e785ed41558ee3a5e0a9c9174a4f93bb3 on hylang:master.\n. \nCoverage decreased (-0.15%) when pulling c1d5948d73280e61e48cf42f9aed944e87392aa3 on olasd:bugfix/382 into 77baf3b9f3b621bc94172f4d4162194f39c144a3 on hylang:master.\n. \nCoverage decreased (-0.17%) when pulling 5120c67f73087c770f43377b4170bb4b93d9efe2 on berkerpeksag:macroexpand-versionadded into 715158c7dbddd222a5bc3e80266dd648ce47e0d5 on hylang:master.\n. \nCoverage decreased (-0.21%) when pulling 6eea34350256a86488432898a2c36016488f22bc on berkerpeksag:macroexpand-versionadded into 7c2a76f7e6cd242f0b5a4195616e8c3d8192831b on hylang:master.\n. \nCoverage decreased (-0.17%) when pulling 6eea34350256a86488432898a2c36016488f22bc on berkerpeksag:macroexpand-versionadded into 7c2a76f7e6cd242f0b5a4195616e8c3d8192831b on hylang:master.\n. \nCoverage decreased (-0.17%) when pulling 9a128edcb23294f6bb6044dab6431a0253ab9447 on olasd:feature/hy2py-pprint into 715158c7dbddd222a5bc3e80266dd648ce47e0d5 on hylang:master.\n. \nCoverage decreased (-0.17%) when pulling a1895f635c6a17e0a4476af580338aee60fac519 on olasd:docs/internals into 715158c7dbddd222a5bc3e80266dd648ce47e0d5 on hylang:master.\n. \nCoverage remained the same when pulling d3fa1fd1a8cc526fd06a7920833630ebf2a243b4 on olasd:feature/disassemble into a5b37b7b5160258fb57107f2f4a8f92fdba0b55f on hylang:master.\n. \nCoverage remained the same when pulling 6eb4dde111185a0088eb4fe215d7f3d920903ee0 on copyninja:master into 7c2a76f7e6cd242f0b5a4195616e8c3d8192831b on hylang:master.\n. \nCoverage remained the same when pulling 1bdf0d04c33c426221edac69cca17be544fe8ec3 on copyninja:disassemble-docs into 7c2a76f7e6cd242f0b5a4195616e8c3d8192831b on hylang:master.\n. \nCoverage decreased (-0.17%) when pulling 1bdf0d04c33c426221edac69cca17be544fe8ec3 on copyninja:disassemble-docs into 7c2a76f7e6cd242f0b5a4195616e8c3d8192831b on hylang:master.\n. \nCoverage decreased (-0.17%) when pulling 5b3f6879c60f2aa0380a6485aa58a0d22381f1cc on copyninja:disassemble-docs into 7c2a76f7e6cd242f0b5a4195616e8c3d8192831b on hylang:master.\n. \nCoverage decreased (-0.17%) when pulling 3279cd9719a0549cf7d48e1347529273a3cf82cb on Foxboron:readme-fix into 0999886d35a862215fe8b895b56de47f02fa0c88 on hylang:master.\n. \nCoverage increased (+0.07%) when pulling 8b8c7bcf624b42cd2c4f4e5e4431970c414c0ba6 on olasd:feature/attribute-access-dsl into d4357fe35c2540fc5cb03796085b26f5fcbe7e91 on hylang:master.\n. \nCoverage remained the same when pulling 440408b3b4fb817d938b1a8e4d3adde6dafa5e31 on cndreisbach:loop-recur into d4357fe35c2540fc5cb03796085b26f5fcbe7e91 on hylang:master.\n. \nCoverage remained the same when pulling 440408b3b4fb817d938b1a8e4d3adde6dafa5e31 on cndreisbach:loop-recur into d4357fe35c2540fc5cb03796085b26f5fcbe7e91 on hylang:master.\n. \nCoverage remained the same when pulling 11891d641e0a7b497f932925b1390e67f15cca4c on cndreisbach:loop-recur into d4357fe35c2540fc5cb03796085b26f5fcbe7e91 on hylang:master.\n. \nCoverage increased (+0.03%) when pulling 11891d641e0a7b497f932925b1390e67f15cca4c on cndreisbach:loop-recur into d4357fe35c2540fc5cb03796085b26f5fcbe7e91 on hylang:master.\n. \nCoverage decreased (-3.16%) to 84.97% when pulling 3bcb4b945e02d3c96eac9ff139447bc94d23585e on cndreisbach:loop-recur into d4357fe35c2540fc5cb03796085b26f5fcbe7e91 on hylang:master.\n. \nCoverage decreased (-0.67%) when pulling da9930215d0c366db058f8b567fa3fb7a66e2bc4 on cndreisbach:loop-recur into d4357fe35c2540fc5cb03796085b26f5fcbe7e91 on hylang:master.\n. \nCoverage decreased (-0.09%) when pulling a9fb970268ceb2547e09e77ca128fd28c8fee423 on cndreisbach:loop-recur into d4357fe35c2540fc5cb03796085b26f5fcbe7e91 on hylang:master.\n. \nCoverage decreased (-0.16%) when pulling 47d67b006293a3cdec7e0572200f9221f147b2c8 on cndreisbach:loop-recur into 5fc047e77cd68950c7161b42a0460c150786939e on hylang:master.\n. \nCoverage decreased (-0.16%) when pulling 849244f3b42df5590bcd1700dba80ed61a6f8bbe on cndreisbach:first-fn into 5017e3c21176303cce2eb3a1ec12d1476a689948 on hylang:master.\n. \nCoverage decreased (-0.16%) when pulling 977b47d3b4009bae0198494658d40a65af82bfae on cndreisbach:apply-docs into 5017e3c21176303cce2eb3a1ec12d1476a689948 on hylang:master.\n. \nCoverage decreased (-0.04%) when pulling 977b47d3b4009bae0198494658d40a65af82bfae on cndreisbach:apply-docs into 5017e3c21176303cce2eb3a1ec12d1476a689948 on hylang:master.\n. \nCoverage decreased (-1.15%) when pulling c0a654e6cb58df75cd973cd04da50cee39daa36a on paultag:paultag/feature/profile into 5017e3c21176303cce2eb3a1ec12d1476a689948 on hylang:master.\n. \nCoverage decreased (-0.16%) when pulling abd0669911393188de3c45247625dd9054edf2f4 on paultag:paultag/feature/revamp-for-again-sorry-fox into 977b47d3b4009bae0198494658d40a65af82bfae on hylang:master.\n. \nCoverage decreased (-0.16%) when pulling 110476901ca6f0dc7710c0b9dfc240be31530d57 on paultag:paultag/feature/revamp-for-again-sorry-fox into 977b47d3b4009bae0198494658d40a65af82bfae on hylang:master.\n. \nCoverage decreased (-0.41%) when pulling cc2f45be69916247f7493c2f2ae64b940660c681 on paultag:paultag/feature/revamp-for-again-sorry-fox into 977b47d3b4009bae0198494658d40a65af82bfae on hylang:master.\n. \nCoverage decreased (-0.16%) when pulling 3907c5bc5371651c25c54ccc271af4817d3d59dc on cndreisbach:doc-improvements into 64772addce285e9d01768d54349d4fd75890433d on hylang:master.\n. \nCoverage decreased (-0.16%) when pulling bd53416a727f06df702250ad303425578840b9ee on theanalyst:f/is-coll into 48be005fa313125a80946c0c588555790bcc583e on hylang:master.\n. \nCoverage decreased (-0.16%) when pulling 0afbbeb68c88215fc440a0d3f8723f6070f6f658 on paultag:paultag/feature/more-tco into 47d67b006293a3cdec7e0572200f9221f147b2c8 on hylang:master.\n. \nCoverage decreased (-0.16%) when pulling 5a64f187264eef2ef9a8bcffac6ad3adc0ca5a3d on paultag:paultag/feature/more-tco into 47d67b006293a3cdec7e0572200f9221f147b2c8 on hylang:master.\n. \nCoverage decreased (-1.01%) when pulling c95550b06aaadcaa66a143a0f58271a87d92d103 on algernon:feature/class-is-mangling into 47d67b006293a3cdec7e0572200f9221f147b2c8 on hylang:master.\n. \nCoverage remained the same when pulling bd2ae5dfeca3592d8fbd97d6a876cceccafbf51b on algernon:feature/class-is-mangling into 47d67b006293a3cdec7e0572200f9221f147b2c8 on hylang:master.\n. \nCoverage decreased (-0.03%) when pulling cf5119ab877b260157fa6fbd4b455048bea105f6 on algernon:feature/class-is-mangling into 47d67b006293a3cdec7e0572200f9221f147b2c8 on hylang:master.\n. \nCoverage decreased (-0.02%) when pulling afa5d2cfc3bdbd3c72cee0e4ee844e1271b44d8c on algernon:feature/class-is-mangling into 47d67b006293a3cdec7e0572200f9221f147b2c8 on hylang:master.\n. \nCoverage remained the same when pulling 8ef02a54b5f3e6471963eac6c1308f043dfd7e24 on algernon:feature/class-is-mangling into d34c22eeacf1809996aa676f2b96340a91d6075c on hylang:master.\n. \nCoverage remained the same when pulling 8ef02a54b5f3e6471963eac6c1308f043dfd7e24 on algernon:feature/class-is-mangling into d34c22eeacf1809996aa676f2b96340a91d6075c on hylang:master.\n. \nCoverage decreased (-0.16%) when pulling 3af30c4b411278415fb88dae0c27ef5b1068217b on algernon:feature/hy-cmdline-interactive-spy into 47d67b006293a3cdec7e0572200f9221f147b2c8 on hylang:master.\n. \nCoverage decreased (-0.02%) when pulling 5b78735011d43cf4a95e780c4885bfeb8e9123d8 on algernon:feature/hy-cmdline-interactive-spy into 47d67b006293a3cdec7e0572200f9221f147b2c8 on hylang:master.\n. \nCoverage decreased (-0.98%) when pulling eb690a8d519aae6a5e1b64bc69b5174d3dd940eb on algernon:feature/hy2py-params into 47d67b006293a3cdec7e0572200f9221f147b2c8 on hylang:master.\n. \nCoverage remained the same when pulling 6ba2f791181dda0ebd84e64b2d9eae84f0863ea5 on algernon:feature/hy2py-params into 47d67b006293a3cdec7e0572200f9221f147b2c8 on hylang:master.\n. \nCoverage decreased (-0.16%) when pulling a619295dd7807ec75145572979cdaefda7bdc353 on algernon:feature/hy2py-params into da59b20471f36b8ca2c5b1ae12db02656aeba5e4 on hylang:master.\n. \nCoverage decreased (-0.2%) when pulling 25459177ebd380dbf2808a940914bab051439380 on berkerpeksag:meth-updates into 8ababcb905efe14bca982550ae25a644ed6b3f00 on hylang:master.\n. \nCoverage decreased (-0.16%) when pulling 94e1fc40f7117b95ff19dc1f2e9b0efeb52c3be6 on berkerpeksag:sphinx-markup-fix into 8ababcb905efe14bca982550ae25a644ed6b3f00 on hylang:master.\n. \nCoverage decreased (-0.75%) when pulling 2dda54617f25e3c99239d0280c422ff07afeb96d on Foxboron:readermacros-macros into 8ababcb905efe14bca982550ae25a644ed6b3f00 on hylang:master.\n. \nCoverage decreased (-0.75%) when pulling eb3f9b056e653789e640ad2c88b19bd35d790444 on Foxboron:readermacros-macros into da59b20471f36b8ca2c5b1ae12db02656aeba5e4 on hylang:master.\n. \nCoverage decreased (-0.74%) when pulling a35ecc41bd925888b7c6572b556974d2960ba346 on Foxboron:readermacros-macros into d34c22eeacf1809996aa676f2b96340a91d6075c on hylang:master.\n. \nCoverage decreased (-0.16%) when pulling abe4fdefa17d166a9700012de6832c60e212f324 on rubberduckdev:master into da59b20471f36b8ca2c5b1ae12db02656aeba5e4 on hylang:master.\n. \nCoverage decreased (-0.16%) when pulling 9a2953d4648caba6e2c2c462101999b9f401e523 on rubberduckdev:master into da59b20471f36b8ca2c5b1ae12db02656aeba5e4 on hylang:master.\n. \nCoverage decreased (-0.41%) when pulling 595ac1e8bc5e5b9811e0e92ae0de3f7cffe130ce on rubberduckdev:master into da59b20471f36b8ca2c5b1ae12db02656aeba5e4 on hylang:master.\n. \nCoverage decreased (-0.16%) when pulling 5180e06cee6d96ac182c75553e8881b9f3b9a243 on rubberduckdev:master into da59b20471f36b8ca2c5b1ae12db02656aeba5e4 on hylang:master.\n. \nCoverage decreased (-0.16%) when pulling 65e9d5ae7eb33a46bff5c2baba5cb4f126bd04ac on rubberduckdev:patch-1 into da59b20471f36b8ca2c5b1ae12db02656aeba5e4 on hylang:master.\n. \nCoverage decreased (-0.16%) when pulling 7d5399570ca8a92c9fafbb9c24a4a99a4df49406 on rubberduckdev:patch-2 into da59b20471f36b8ca2c5b1ae12db02656aeba5e4 on hylang:master.\n. \nCoverage increased (+0.17%) when pulling 8bfa4f33fc1193941a6bf5c41474f06798b91241 on olasd:feature/genexpr into da59b20471f36b8ca2c5b1ae12db02656aeba5e4 on hylang:master.\n. \nCoverage decreased (-0.35%) when pulling 8bfa4f33fc1193941a6bf5c41474f06798b91241 on olasd:feature/genexpr into da59b20471f36b8ca2c5b1ae12db02656aeba5e4 on hylang:master.\n. \nCoverage decreased (-0.04%) when pulling 6c15f14ff715389d0116dc3d6529a357ed9c02f7 on rubberduckdev:patch-3 into da59b20471f36b8ca2c5b1ae12db02656aeba5e4 on hylang:master.\n. \nCoverage decreased (-0.16%) when pulling cd66f18e2e7adc79acb9f5e4fd42352b38b7a186 on rubberduckdev:patch-4 into da59b20471f36b8ca2c5b1ae12db02656aeba5e4 on hylang:master.\n. \nCoverage increased (+0.01%) when pulling d273ad112f795b79d11879b7189a0600aba84d71 on rubberduckdev:patch-4 into da59b20471f36b8ca2c5b1ae12db02656aeba5e4 on hylang:master.\n. \nCoverage decreased (-0.16%) when pulling a20b2c9f43501f582699bd84b6194e9786ddf12c on f:master into 60e66476f51a0c61483a2549f6e31dc989ffee10 on hylang:master.\n. \nCoverage decreased (-0.16%) when pulling ea8b8b53ce2a133612906709dfa3c8a5390d0b63 on f:master into 60e66476f51a0c61483a2549f6e31dc989ffee10 on hylang:master.\n. \nCoverage decreased (-0.16%) when pulling bc99465e4d226d7336d6dd537b2fc0f57b08ad85 on f:master into 60e66476f51a0c61483a2549f6e31dc989ffee10 on hylang:master.\n. \nCoverage decreased (-0.16%) when pulling 866522fe9f2c5786912d023d42f29f8e1348881e on f:master into 60e66476f51a0c61483a2549f6e31dc989ffee10 on hylang:master.\n. \nCoverage decreased (-0.16%) when pulling 685a1b80fa19e0d91d5e3a7b835587d6cdd2e9a9 on berkerpeksag:silence-title-too-short into 60e66476f51a0c61483a2549f6e31dc989ffee10 on hylang:master.\n. \nCoverage decreased (-0.16%) when pulling db9b9c68765eea2fb766ba2ed3676514ed0e72e6 on berkerpeksag:test-contrib-merge into d34c22eeacf1809996aa676f2b96340a91d6075c on hylang:master.\n. \nCoverage remained the same when pulling 190dad2227b9837c1dbb020fb193ef2a206cadbf on theanalyst:f/cl-dotimes into e71631f48fc77453e85266eabf3b243c561a7f3f on hylang:master.\n. \nCoverage remained the same when pulling 10f1f24a1817d0dd74d2f2677ef929feca921457 on theanalyst:f/identity into e71631f48fc77453e85266eabf3b243c561a7f3f on hylang:master.\n. \nCoverage remained the same when pulling 52144820cadc47c8fe94f8de2530260fa8b70b49 on olasd:feature/cons-to-merge into fad67bd8f5001cdbc963689c7f45c90adad14fd2 on hylang:master.\n. \nCoverage remained the same when pulling 50f0df8be7f2936bbc481864d8944b5255d6c282 on algernon:f/unquote-wrap-value into fad67bd8f5001cdbc963689c7f45c90adad14fd2 on hylang:master.\n. \nCoverage decreased (-0.16%) when pulling 65f8bd2b91539f72ea0805a76183ad2c56b94eeb on berkerpeksag:hyc-doc into fad67bd8f5001cdbc963689c7f45c90adad14fd2 on hylang:master.\n. \nCoverage remained the same when pulling fca5f84c8a6c150ff41231d05f9d74cc22a22cab on agentultra:master into 20d27b23e96dd3a634bc9c047b8129a8cde4a823 on hylang:master.\n. \nCoverage decreased (-0.15%) when pulling f86f9b08a6192d815a9d0bae7f2b59794819a2d1 on copyninja:feature/is_null into e8dfe5bfb20ecd1d19c4913bed2449793ab6204e on hylang:master.\n. \nCoverage decreased (-0.14%) when pulling cdf79f4a2dcdaacefef5a3e9843bec37414608b5 on copyninja:feature/is_null into e8dfe5bfb20ecd1d19c4913bed2449793ab6204e on hylang:master.\n. \nCoverage remained the same when pulling 4432c00c591318ea272382439c8221dfefc18249 on theanalyst:fix/coll into e8dfe5bfb20ecd1d19c4913bed2449793ab6204e on hylang:master.\n. \nCoverage remained the same when pulling a41a3c7edc647d7d9bcb64913c03fae22ef71345 on theanalyst:fix/distinct into e8dfe5bfb20ecd1d19c4913bed2449793ab6204e on hylang:master.\n. \nCoverage decreased (-0.1%) when pulling d758885b6d24c72cce68435a857b3c7fbe067013 on algernon:h/import-error-reporting into fed3ec302cce62b761677263f4eb215feaa96101 on hylang:master.\n. \nCoverage decreased (-0.15%) when pulling c0a514c2f3547f2feab5039b9dd7d76f43380d74 on microamp:master into 6e0486ba78bfafcaa74d455f9455218a29cc08da on hylang:master.\n. \nChanges Unknown when pulling 09dd0386ccb6671a5fb73b2529dcdf122a9ae1ec on calembendell:master into * on hylang:master*.\n. \nCoverage remained the same when pulling 7492a6dcc18151de3891de38ab51468cc8036354 on kirbyfan64:master into b97e0258e16a003bd7e081612987ecdc8bef19c8 on hylang:master.\n. \nCoverage remained the same when pulling 6cc96a3fe9ebe739e1d39e72a8068db0cb1f5a0f on kirbyfan64:master into b97e0258e16a003bd7e081612987ecdc8bef19c8 on hylang:master.\n. \nCoverage remained the same when pulling cad55b98f47deca9520dacd214b008657d9fc996 on kirbyfan64:master into b97e0258e16a003bd7e081612987ecdc8bef19c8 on hylang:master.\n. \nCoverage remained the same when pulling fa84cb3b5a2b9ad2f2dca46b1449fb657e577796 on cwebber:defmain into a11f92da3720f8c21cb98c50a207b2925dbf4527 on hylang:master.\n. \nCoverage remained the same when pulling c9da570faa98b63184279185455723087bb8a7be on cwebber:defmain into a11f92da3720f8c21cb98c50a207b2925dbf4527 on hylang:master.\n. \nCoverage remained the same when pulling 13e02258a7e2db140bacd0c4b389270809356038 on bcj:patch-1 into a11f92da3720f8c21cb98c50a207b2925dbf4527 on hylang:master.\n. \nCoverage remained the same when pulling 13e02258a7e2db140bacd0c4b389270809356038 on bcj:patch-1 into a11f92da3720f8c21cb98c50a207b2925dbf4527 on hylang:master.\n. \nCoverage remained the same when pulling 13e02258a7e2db140bacd0c4b389270809356038 on bcj:patch-1 into a11f92da3720f8c21cb98c50a207b2925dbf4527 on hylang:master.\n. \nCoverage remained the same when pulling 13e02258a7e2db140bacd0c4b389270809356038 on bcj:patch-1 into a11f92da3720f8c21cb98c50a207b2925dbf4527 on hylang:master.\n. \nCoverage remained the same when pulling a19a91740d5a02198214ad5e52c4114f054e5fb7 on bcj:patch-2 into a11f92da3720f8c21cb98c50a207b2925dbf4527 on hylang:master.\n. \nCoverage remained the same when pulling a19a91740d5a02198214ad5e52c4114f054e5fb7 on bcj:patch-2 into a11f92da3720f8c21cb98c50a207b2925dbf4527 on hylang:master.\n. \nCoverage remained the same when pulling a19a91740d5a02198214ad5e52c4114f054e5fb7 on bcj:patch-2 into a11f92da3720f8c21cb98c50a207b2925dbf4527 on hylang:master.\n. \nCoverage remained the same when pulling a19a91740d5a02198214ad5e52c4114f054e5fb7 on bcj:patch-2 into a11f92da3720f8c21cb98c50a207b2925dbf4527 on hylang:master.\n. \nCoverage decreased (-0.01%) when pulling b56a03750f4161462cf4ea5ed1c5883871fb87a2 on akaptur:explicit-exception-chaining into ddcf192da479c0287918d985b41b07c47c031c88 on hylang:master.\n. \nCoverage decreased (-0.94%) when pulling 26307d261279861c2d9c9eca3bb38519f951bea4 on akaptur:explicit-exception-chaining into ddcf192da479c0287918d985b41b07c47c031c88 on hylang:master.\n. \nCoverage increased (+0.35%) when pulling c2982a9ae34d2fe45d962d511f6210c168b7d186 on theanalyst:fix/ap-first into 0f0c4227b687d805b1429c3e98c0041d527e582d on hylang:master.\n. \nCoverage decreased (-1.28%) when pulling 364f4a2c77edbc7479c593331475d7c7d1ff35bd on agentultra:shadow-builtins into 1da6d0af43958a63e5dfc088ebf6db30d6812d9f on hylang:master.\n. \nCoverage remained the same when pulling 8e173937c358e3f53415b3df8ff163a3f524f6a5 on agentultra:shadow-builtins into 1da6d0af43958a63e5dfc088ebf6db30d6812d9f on hylang:master.\n. \nCoverage increased (+0.35%) when pulling 2308cefbda2d59e1cf1607950cf16aef5c397ef5 on theanalyst:docs/decorators into 0f0c4227b687d805b1429c3e98c0041d527e582d on hylang:master.\n. \nCoverage increased (+0.35%) when pulling 1da6d0af43958a63e5dfc088ebf6db30d6812d9f on theanalyst:docs/decorators into 0f0c4227b687d805b1429c3e98c0041d527e582d on hylang:master.\n. \nCoverage decreased (-0.04%) when pulling 277028cdd5990e5cde4a1bfdfe3434fdcec842a2 on agentultra:issues/610 into 1da6d0af43958a63e5dfc088ebf6db30d6812d9f on hylang:master.\n. \nCoverage decreased (-1.88%) when pulling 497d64f2a6eb149cf1155f534f9da6a0ab94c7fc on rwtolbert:rwtolbert/bugfix/fix_return_in_try_with_yield into f8e48628ea04214584cee62c44544467e7f30a19 on hylang:master.\n. \nCoverage decreased (-0.33%) when pulling ea5eba59165df74b36351c1acd54126e08b2ff5a on rwtolbert:rwtolbert/bugfix/fix_return_in_try_with_yield into f8e48628ea04214584cee62c44544467e7f30a19 on hylang:master.\n. \nCoverage decreased (-0.87%) when pulling 959ab4e839b01f648b492c73d90ef0ddac0374f3 on rwtolbert:rwtolbert/bugfix/hy2py_windows_py3 into f8e48628ea04214584cee62c44544467e7f30a19 on hylang:master.\n. \nCoverage decreased (-0.66%) when pulling bd661a3ae8fa54c21166d3601e83d5a0c15d7967 on rwtolbert:rwtolbert/bugfix/hy2py_windows_py3 into 7f350cdc62e0d3af987806e6e622e4eadae2f321 on hylang:master.\n. \nCoverage increased (+0.84%) when pulling 5e0dac07699d76d778d9bc15fd19ce21f5b3dcd4 on rwtolbert:bugfix/assign_to_None into f3ecb9611962ac11ddea73d01f1dc2cb1ce1ce98 on hylang:master.\n. \nCoverage increased (+0.86%) when pulling 01a38f4d1f62099f2d75dc2ac08e022a1789b452 on rwtolbert:bugfix/assign_to_None into f3ecb9611962ac11ddea73d01f1dc2cb1ce1ce98 on hylang:master.\n. \nCoverage increased (+0.87%) when pulling 16e908d56e4b73183a95880df358c1076c89be11 on rwtolbert:bugfix/assign_to_None into f3ecb9611962ac11ddea73d01f1dc2cb1ce1ce98 on hylang:master.\n. \nCoverage remained the same when pulling c8c154f725fd31eadb5d907463fa0efcd557786d on tianon:docker-from-python into fa1c5d851e74c9714b6fe38e738f3b674e6a85f0 on hylang:master.\n. \nCoverage remained the same when pulling d63f0ff8ae2259ea3a80e34eecb29028b5de4f3b on algernon:f/botsbuildbots into 1265f546d1fbcfa9c62b51f3e455c0709be7acc8 on hylang:master.\n. \nCoverage remained the same when pulling 3f01ed5014c8761a9e894f0845bd3634e26e18ff on algernon:f/botsbuildbots into 1c1df745c406e725ee3d32aa725b37bcc272d2a0 on hylang:master.\n. \nCoverage remained the same when pulling 2628653380b1431476479b27e6b749026efe1802 on microamp:master into 1265f546d1fbcfa9c62b51f3e455c0709be7acc8 on hylang:master.\n. \nCoverage remained the same when pulling aa13010651a9a284cafbaefcd3f2619ab2ab3a39 on microamp:master into 2628653380b1431476479b27e6b749026efe1802 on hylang:master.\n. \nCoverage remained the same when pulling 85596e342578574cc4abdae6b7b96e951b27273b on Foxboron:read into 79a1ea6667f77cce08282089da5b3989039ef3e0 on hylang:master.\n. \nCoverage decreased (-0.34%) when pulling 40c9c0421da83605a35b72d170e5b12072eb6060 on Foxboron:read into 79a1ea6667f77cce08282089da5b3989039ef3e0 on hylang:master.\n. \nCoverage remained the same when pulling cb5791eca644d5086206ee9ec67568503e49e457 on Foxboron:read into 79a1ea6667f77cce08282089da5b3989039ef3e0 on hylang:master.\n. \nCoverage remained the same when pulling 8f24c95645e988f5575fb89cfb564bdc442ed3f0 on Foxboron:read into 79a1ea6667f77cce08282089da5b3989039ef3e0 on hylang:master.\n. \nCoverage remained the same when pulling f7675c829efe1a5f376d9eff49c112c0762264ac on Foxboron:read into 45e0ff16ca9b3e1c91463dd8ece9fadc288d7d57 on hylang:master.\n. \nCoverage remained the same when pulling c8adf9b726f166332a1f9462071f81724a24614f on Foxboron:read into 45e0ff16ca9b3e1c91463dd8ece9fadc288d7d57 on hylang:master.\n. \nCoverage decreased (-1.12%) when pulling 688d29326948c22817a79b7f1e94b2e37a9fc378 on theanalyst:misc/mailmap into 79a1ea6667f77cce08282089da5b3989039ef3e0 on hylang:master.\n. \nCoverage remained the same when pulling d5668403aef3868bb4b328daa95ab965f3841efd on theanalyst:fix/typos into 45e0ff16ca9b3e1c91463dd8ece9fadc288d7d57 on hylang:master.\n. \nCoverage decreased (-0.34%) when pulling 3f1a24bfe3cca61eff1e87d7e40c65f31c12120a on microamp:issue-627 into 4dbdfde24daf32ab4be372e61d86a0968bdcd78a on hylang:master.\n. \nCoverage remained the same when pulling 8d893ead073ad1e046ca1c0b8f07c94aecfeebf7 on tianon:read-docs into aafb16d69fd30ff58afdd69036a26047f3aebdc6 on hylang:master.\n. \nCoverage remained the same when pulling 23f31d4ac1ac72ca13005bea218b9c2363fa940e on microamp:fix-butlast into 7e5befa61500eb4b049488093d995f34b83d3d27 on hylang:master.\n. \nCoverage remained the same when pulling ecc664337d25fdc0cefdf7a51eaa54ce5288a653 on microamp:issue-638 into 7e5befa61500eb4b049488093d995f34b83d3d27 on hylang:master.\n. \nCoverage remained the same when pulling 6ca47df34c8c67f3164c62e7b55ad0c18e8cb9b8 on microamp:issue-638 into 7e5befa61500eb4b049488093d995f34b83d3d27 on hylang:master.\n. \nCoverage remained the same when pulling c8985a898b2f0a242cce22717eb4069c7270a0a3 on microamp:issue-639 into 7e5befa61500eb4b049488093d995f34b83d3d27 on hylang:master.\n. \nCoverage remained the same when pulling 325f873f1e0f4e50bcfeded98f11f4bc226e02f4 on Foxboron:read-doc-fix into fbfb51fb6116a6392186b2a5145997cc9e68baef on hylang:master.\n. \nCoverage remained the same when pulling 66e3cdcb99d8ac85bd6ec472b715b7c45f71ca85 on Foxboron:rename-slot-attr into bc0ef3ea14e4c2af8e3e7fa2fe97fec042966adf on hylang:master.\n. \nCoverage remained the same when pulling 99db02668b08f950d8cffe0a710618e0e6a1a39e on microamp:issue-644 into c52cff8245b50e71d1bcd01503ed48581034f2cb on hylang:master.\n. \nCoverage remained the same when pulling 4a4bfd8699c2a0205c3ff3f1202b2c4170815632 on theanalyst:fix/authors into c0ea1308bfd3ca4dba7d3732bec5be30691733c2 on hylang:master.\n. \nCoverage decreased (-0.34%) when pulling 19aa9f4b1183deb94bab4906cc3dade8bb6e2f33 on calben:sliceovershadow into 41c4f1a781b2d819a5c25fe4309d54cd7e08e260 on hylang:master.\n. \nCoverage decreased (-0.34%) when pulling 89cdcc4ae035f42c08dbe222a694d5d967ff8542 on calben:sliceovershadow into 41c4f1a781b2d819a5c25fe4309d54cd7e08e260 on hylang:master.\n. \nCoverage remained the same when pulling 696ad508628d0c9f8a5fbee97984fc0fa5cca3c0 on calben:sliceovershadow into 41c4f1a781b2d819a5c25fe4309d54cd7e08e260 on hylang:master.\n. \nCoverage remained the same when pulling 2d60aa678153de5b67e161cfb6a87f7d5bab4557 on Foxboron:mailmap-fox into e3646bb8742e467bf19dcda0d4e2e4d873f15c06 on hylang:master.\n. \nCoverage remained the same when pulling 89dec9ef4487ef541438840be4682848afc145fa on Foxboron:fix-defmulti-docs into 38b9ae61b51afa8748ff0212f7b971a6547ff6d8 on hylang:master.\n. \nCoverage decreased (-2.7%) when pulling 5f54dbedb4e30ba1cb120c71751d926175779732 on Foxboron:defn-type-annotations into 28c046c18005bcddd6d66c4cfb8fcd286ebbad5a on hylang:master.\n. \nCoverage decreased (-0.87%) when pulling 2f400e46ccef4c774753ba4e39797e91c504bb77 on Foxboron:defn-type-annotations into 28c046c18005bcddd6d66c4cfb8fcd286ebbad5a on hylang:master.\n. \nCoverage decreased (-0.14%) when pulling 69ae2cf58d8d204d5cc0a4f1450b910849b867bb on Foxboron:defn-type-annotations into 28c046c18005bcddd6d66c4cfb8fcd286ebbad5a on hylang:master.\n. \nCoverage remained the same when pulling c9684ffe78deee26191aa8d029287ec48ae19f5c on tianon:lisp-if-not into 28c046c18005bcddd6d66c4cfb8fcd286ebbad5a on hylang:master.\n. \nCoverage remained the same when pulling 3503ed902728b5cfaa58d7b6fc028310a3e7b3b4 on zenhack:_wrap_value-HyExpression into 28c046c18005bcddd6d66c4cfb8fcd286ebbad5a on hylang:master.\n. \nCoverage remained the same when pulling 8ba547c4cf66e71058fe5be91be8cebf6be75438 on svetlyak40wt:debian-changelog into 28c046c18005bcddd6d66c4cfb8fcd286ebbad5a on hylang:master.\n. \nCoverage remained the same when pulling 76d7e3479a23d37bcf34940763d107bba1a4ab4b on bismigalis:merge-with into 28c046c18005bcddd6d66c4cfb8fcd286ebbad5a on hylang:master.\n. \nCoverage remained the same when pulling bfd1cf188b41f9a36a2d017664a6e7074b5a7c3b on kirbyfan64:travis_fix into f5f4384722520fe519e0c3a76599c18ec639ea12 on hylang:master.\n. \nCoverage remained the same when pulling d674dbed5aaccafb45da8295c87393140dd57f14 on kirbyfan64:travis_fix into f5f4384722520fe519e0c3a76599c18ec639ea12 on hylang:master.\n. \nCoverage remained the same when pulling def689642fe2357ec1bfe2290f8cc54bf2beae8a on kirbyfan64:travis_fix into f5f4384722520fe519e0c3a76599c18ec639ea12 on hylang:master.\n. \nCoverage remained the same when pulling 8f3b65ff50a28710ff5bb92545342d88e07b5b71 on kirbyfan64:travis_fix into f5f4384722520fe519e0c3a76599c18ec639ea12 on hylang:master.\n. \nCoverage increased (+0.34%) when pulling 6d4d4ac02651de5a5af94f5606c3d45795231481 on Tritlo:master into 7d0fe31ebe44defee2345a6cc58a93c4b6d49766 on hylang:master.\n. \nCoverage decreased (-7.6%) to 76.008% when pulling 8839bbebe3d44582bcdbf33ac0a782f20fb72975 on unmerged:master into f4afb0ca7efd76cb3bc4a99bc3c719c1ef96584a on hylang:master.\n. \nCoverage remained the same at 82.36% when pulling 0fd6ed052c872120a78e51285d230234b323ed41 on zackmdavis:appease_flake8 into 5edcdd26b817aecfd309b21c05c5ba637f1cdc07 on hylang:master.\n. \nCoverage remained the same at 82.55% when pulling 0fd6ed052c872120a78e51285d230234b323ed41 on zackmdavis:appease_flake8 into 5edcdd26b817aecfd309b21c05c5ba637f1cdc07 on hylang:master.\n. \nCoverage remained the same at 82.39% when pulling 750d7b51bec01a59abeb23d868781175f4b1b46f on nikete:patch-1 into 55d4d20f79407f8cbca804170d2984dce8c23be0 on hylang:master.\n. \nCoverage remained the same at 82.39% when pulling 750d7b51bec01a59abeb23d868781175f4b1b46f on nikete:patch-1 into 55d4d20f79407f8cbca804170d2984dce8c23be0 on hylang:master.\n. \nCoverage remained the same at 82.39% when pulling 750d7b51bec01a59abeb23d868781175f4b1b46f on nikete:patch-1 into 55d4d20f79407f8cbca804170d2984dce8c23be0 on hylang:master.\n. \nCoverage remained the same at 82.39% when pulling 387723593327517cf444f61e381cd17109963d00 on tianon:compare-shadows into 55d4d20f79407f8cbca804170d2984dce8c23be0 on hylang:master.\n. \nCoverage increased (+0.07%) to 82.46% when pulling 2cc59aac0a710c6b9bf65ff886da416346a830cf on zackmdavis:kwonly_connect into 3d41630219ed6c3d28a37d3c3919636e0e842a4d on hylang:master.\n. \nCoverage increased (+0.07%) to 82.46% when pulling 1bac950d9b6f6cda408ac396d9ae3340c79148e5 on zackmdavis:kwonly_connect into 3d41630219ed6c3d28a37d3c3919636e0e842a4d on hylang:master.\n. \nCoverage remained the same at 82.39% when pulling 0496b7f7b6a477c437d7989644128d9b98ae54fa on acron0:last-core into 3d41630219ed6c3d28a37d3c3919636e0e842a4d on hylang:master.\n. \nCoverage remained the same at 82.39% when pulling 0496b7f7b6a477c437d7989644128d9b98ae54fa on acron0:last-core into 3d41630219ed6c3d28a37d3c3919636e0e842a4d on hylang:master.\n. \nCoverage decreased (-0.05%) to 82.34% when pulling 2824547ffc31812c8b2c8f2fa3524013b783c29c on nicolas-p:ap-pipe-ap-compose into 3d41630219ed6c3d28a37d3c3919636e0e842a4d on hylang:master.\n. \nCoverage increased (+0.07%) to 82.45% when pulling f19f685e55a8746ad0b4b2c42155754994dddfc6 on kirbyfan64:destruct-args into 3d41630219ed6c3d28a37d3c3919636e0e842a4d on hylang:master.\n. \nCoverage remained the same at 82.4% when pulling 82b68da88ce707968c32a41e616ef4cc1dcc28d4 on zackmdavis:draft_news_for_0.10.2 into 42983d173fdabab098d586e8dc599065b8f209b7 on hylang:master.\n. \nCoverage decreased (-0.14%) to 82.27% when pulling c9e4677084a76deaa0d49d078b97ae8b026a7f45 on zackmdavis:additional_unpacking_correctness into 42983d173fdabab098d586e8dc599065b8f209b7 on hylang:master.\n. \nCoverage remained the same at 82.4% when pulling 9ed9bc5e1153d434b217a328287252984f4f3987 on farhaven:nonlocal-doc into 685688f04cee7901c20d87112570fe8a377b16b7 on hylang:master.\n. \nCoverage remained the same at 82.4% when pulling 802ef0cd0d1215b4697abd776d87335bfb9bac15 on farhaven:nonlocal-doc into 685688f04cee7901c20d87112570fe8a377b16b7 on hylang:master.\n. \nCoverage decreased (-0.64%) to 81.76% when pulling 46115fc9f9db2e5f9aab475b39a4b2cb1204e234 on zackmdavis:async_awaits into 685688f04cee7901c20d87112570fe8a377b16b7 on hylang:master.\n. \nCoverage decreased (-0.64%) to 81.76% when pulling 46115fc9f9db2e5f9aab475b39a4b2cb1204e234 on zackmdavis:async_awaits into 685688f04cee7901c20d87112570fe8a377b16b7 on hylang:master.\n. \nCoverage decreased (-0.04%) to 82.37% when pulling 4adddbbf25b97660fffe3b38d681833a64d816ad on farhaven:eval-args into 685688f04cee7901c20d87112570fe8a377b16b7 on hylang:master.\n. ",
    "Beluki": "Here is a Hy-only workaround:\n``` clojure\n!/usr/bin/env hy\n(import [flask [Flask]])\n;; Change the interpreter executable.\n;; Werkzeug will now run Hy instead of Python on restarts.\n;; This should work as long as \"hy\" is in the path.\n(import sys)\n(setv sys.executable \"hy\")\n(def app (Flask name))\n(setv app.debug True)\n(with-decorator (app.route \"/\")\n    (defn get-index []\n        (str \"Hello World!\")))\n;; Run the app, but also restart when this file changes:\n(kwapply (app.run) {\"extra_files\" file})\n```\n. \nHello\nI am Marisa, Beluki's wife. I'm sorry but I have to tell you that he died last year.\nSent:\u00a0Monday, March 27, 2017 at 1:51 AM\nFrom:\u00a0\"Kodi Arfer\" notifications@github.com\nTo:\u00a0hylang/hy hy@noreply.github.com\nCc:\u00a0Carlos beluki@gmx.com, Comment comment@noreply.github.com\nSubject:\u00a0Re: [hylang/hy] running a flask server in debug mode breaks hy and drops to Python (#329)\nThis still doesn't work in 2017 with Python 3, but it just crashes now:\nhy 0.12.1+50.g741b9b9 using CPython(default) 3.6.0 on Linux\n=> (import [flask [Flask]])\n=> (setv app (Flask \"main\"))\n=> (setv app.debug True)\n=> (.run app)\n * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)\n * Restarting with stat\n/usr/local/bin/python3.6: can't find 'main' module in '\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub, or mute the thread.\n. He loved his work and one important part of him still lives in the things he made, so thank you to all people that keep that part of him alive.\n\u00a0\nSent:\u00a0Tuesday, March 28, 2017 at 5:20 PM\nFrom:\u00a0\"Kodi Arfer\" notifications@github.com\nTo:\u00a0hylang/hy hy@noreply.github.com\nCc:\u00a0Carlos beluki@gmx.com, Comment comment@noreply.github.com\nSubject:\u00a0Re: [hylang/hy] running a flask server in debug mode breaks hy and drops to Python (#329)\nThanks for letting us know, Marisa, and sorry if I bothered you. Feel free to mute this thread, as mentioned in the email you got from GitHub.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub, or mute the thread.\n. \u00a0\nHello\nCarlos (Beluki) died last year, he had cancer, so I cant help you with his work and commentaries. Sorry.\nMarisa\nSent:\u00a0Friday, April 28, 2017 at 12:55 AM\nFrom:\u00a0\"Kodi Arfer\" notifications@github.com\nTo:\u00a0hylang/hy hy@noreply.github.com\nCc:\u00a0Carlos beluki@gmx.com, Comment comment@noreply.github.com\nSubject:\u00a0Re: [hylang/hy] running a flask server in debug mode breaks hy and drops to Python (#329)\nActually, the same sequence of calls fails with the same error in Python's own REPL. I'm going to close this until somebody can show an example that works in Python but not a recent version of Hy.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub, or mute the thread.\n. \nHello\nI am sorry I cant help you, Beluki has died two years ago. Lung cancer.\nMarisa\nSent:\u00a0Monday, September 03, 2018 at 1:37 PM\nFrom:\u00a0\"Kodi Arfer\" notifications@github.com\nTo:\u00a0hylang/hy hy@noreply.github.com\nCc:\u00a0Carlos beluki@gmx.com, Author author@noreply.github.com\nSubject:\u00a0Re: [hylang/hy] Using hy as sys.executable and the correct main module. (#459)\nClosed #459 via c022abc.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub, or mute the thread.. ",
    "joefromct": "Not sure if the issue belongs here or at arch, but I just pip installed hy with my latest arch setup and 3.4 isn't working correctly with the same error:\nFile \"/home/yeoj/temp/lib/python3.4/site-packages/hy/importer.py\", line 22, in \n    from py_compile import wr_long, MAGIC\nImportError: cannot import name 'wr_long'\n. This worked for the time being:\npip install --upgrade git+https://github.com/hylang/hy.git\nI'll wait for the new release also, thanks. \n. ",
    "alex": "Again, sorry it took so long!\n. ",
    "kzisme": "That should be good I think.  Let know know if anything else needs updated in relation to this issue as well.\n. Removed that attribute, thanks for letting me know.\n. ",
    "noprompt": "The [] in Clojure's let, fn, and loop represent places where binding occurs. They're special places in special forms. It's why you're able to destructure in any of these places (it's also why you can destructure in several others). You can read here under the section \"Binding Forms\" for more information (assuming you haven't already). \nI'm not working on the reader code, however, it seems to me if you have control over the reader -- which you do -- you could convert this to whatever form is suitable to make the Python VM happy in the compiler. Since with looks like a special case (I'm not a Python programmer) it probably make sense to treat it as such. let or any place where binding occurs shouldn't be penalized.\n. Yes, @algernon, has the right idea. Clojure has much better naming for this sort of thing ie. do and the do prefixed gang. prog1 and prog2 doesn't do much for anyone but suggest there are at least 2 prog prefixed macros. :laughing: \n. Actually, after looking at this one should be asking why is there emphasis on the importance of the first or the second form here? That is, what common pattern is this macro abstracting that couldn't be done with vanilla code?\n. It would probably make more sense as just profile with the signature ([expr]) where profile is understood to be a macro.\nhy\n(profile (do (print \"hey there\"))\nClojure, for example, doesn't have a profile macro but it does have a time macro for (surprise!) timing how long a block of code takes to run. \nclj\n(time (do (print \"hey there\"))\n. For context:\nhy\nhy\nhy 0.9.11\n=> (if 0 1 2)\n2\nOther lisps\nEmacs lisp\nel\nELISP> (if 0 1 2)\n1\nClojure\nclj\nuser> (if 0 1 2)\n1\nCommon lisp\nlisp\n* (if 0 1 2)\n1\nRacket\n-> (if 0 1 2)\n1\n. @paultag You should not be so quick to close this issue. This is actually a real problem beyond the silly examples I shared above. It will add an extra layer of complexity and a source of subtle bugs in places where list processing is important. For example: macros.\n\nChanging the falsy evaluation would render the whole ecosystem of Python libraries unusable since people expects consistency.\n\nWat? No it wouldn't. It wouldn't render them useless anymore than Clojure renders Java libraries useless by the same logic.\n\nDo you have any idea how to implement it without breaking interoperability?\n\nI do. Read on.\n\nWhat will we use? hy.core.lang.if ?\n\n@paultag  @Willyfrog Create a simple utility function, call it hy.core.lang.truth or something, that returns False if the value of the expression is False or None and True otherwise. Then when you emit if in the AST wrap the expression with a call to this function (ie. you emit hy.core.lang.truth(expr)). This is similar to what ClojureScript does when it compiles if. That should be fairly trivial given complexity of some of the other code.\n\nWhat happens if you give a Truethey 0 to Python? Should something I think is True be evaluated to False by Python?\n\n@paultag You wouldn't give Python a \"Truthy 0\", you would give it True or False which will be based on the result of calling hy.core.lang.truth as I've suggested above.\nHave an ice cream. :ice_cream: \n. > What I'm more worried about is when Hy code is mixed with python code and calls are made to both directions. \n@tuturto You're worried about the wrong thing.\n\nDoesn't a programmer have to remember which function has been implemented which function in order to know how they treat the truth value of 0?\n\nNo! Why would that matter? If you tell Hy or Python code to do something, how truthiness is interpreted on either side should be irrelevant. If you're lying in bed awake at night because you're afraid of what will happen when Hy finds a 0 in the predicate position of an if expression and returns the result of the first branch, then you should see a therapist because it's really not that big of deal. Instead what you should be doing is rejoicing that you will not have to babysit a language who's designer did not think for more than a second about the consequences of 0 having false semantics and how great it will be when you do not have to worry about defending yourself against the hoards of bugs this one decision causes.\n\nTo move this forward, would it be possible to show some code that shows how this would work under the hood?\n\nThis code should be generated in the AST as I've suggested above.\n. > Statements like \"you should see a therapist\" or \"you're doing X a disservice\" are not helping you to get your point across. Please calm down.\n@olasd I was sort of joking but my sense of humor can be weird. Sorry if I offended anyone. (@tuturto )\n\nOther lisps do it that way so it must make sense. I tried, but I can't find why.\n\n0 is a value\nIt should not be thought of as False anymore than 1 should be thought of as True. The fact it is considered as such in Python is baggage. Other than familiarity and old habits, I can't think of a good reason to defend this.\n\nTechnically conflating a numerical value with a boolean is mixing apples with oranges\n\nThis everyone. :+1: \n\nlanguage who's designer did not think for more than a second about the consequences of 0 having false semantics\n\nI was referring to the creator of Python. Not you. :smile:\n\nwhat's the usecase?\n- It prevents a ton of subtle bugs. \n- You can safely use predicates that might return 0 with if.\n- Code such as (if (first xs) ...), (if (index-of xs \"pie\") ...), or (if (get map key) ...)\nImplementing is_truthy in a sensible way is probably a non-trivial job.\n\n@khinsen Is it really that hard to write a function that returns False if the x is False or None and True otherwise? Tell me what I'm missing here.\n\nI don't see any philosophical problem with introducing a Lisp that adopts Python's conventions for booleans, given that they are consistent and reasonable.\n\nI wouldn't either except that virtually every Lisp in existence doesn't do this. Python's \"conventions\" are really bad in this instance. Just because Hy emits Python code doesn't mean it has to have the same semantics.\n. > How much code did you write to validate this choice in practice? \nIn Hy or in general? I've mostly been evaluating Hy for scripting purposes so, admittedly, not much. In general, I've written a lot of code in other languages to verify it's value from a pragmatic stand point. I will not restate my position or provide further examples.\n\nWe don't want lots of \"truth converters\" at the Hy-Python interface.\n\nCan you demonstrate (with code) an example of what you're worried about here? Everyone keeps talking about this and not providing examples.\n\nConcerning your judgement of Python's conventions for booleans, I think you are too quick in extrapolating your Lisp habits to other languages.\n\nIt's not a Python convention anymore than it is a JavaScript or PHP convention. This \"convention\" has historical roots as has discussed above. It is also not a \"Lisp habit\" of mine. Ruby, for example, also thinks of 0 as truthy and I was programming with it long before coming to Lisp. I've had a couple years to think about the benefits of this property so, no, it is not a quick extrapolation.\n\nThe choice we are discussing is not between a \"good\" and a \"broken\" definition, but between the conventions of our target platform (Python) and those of our source of inspiration (Lisp).\n\nI understand that. But consider meditating on this for a while. Clojure targets no less than three platforms, each of which considers 0 to be falsey, and yet maintains the Lisp tradition. That being said I am not disregarding your argument. If someone were to write a Lisp targeting Haskell it would be reasonable to expect the predicate position of the if expression to be valid only when that expression is of type Bool. In the case of Hy, however, I simply have not seen any evidence so far that warrants the sort of fear people are expressing (ie. code).\n. I've done a bit of thinking and realize there is a deeper problem here that goes beyond the scope of this issue; the reliance on 0 (and others) being equivalent to False. If one is writing a predicate function (one which returns a boolean value) and relies on this property they're doing it wrong. Consider:\n``` py\nBad!\ndef is_empty(xs):\n  return len(xs)\nBetter\ndef is_empty(xs):\n  return len(xs) == 0\n```\nAlthough the behavior in the context of an if statement will be the same when xs contains no elements, the first is_empty is merely and alias for len and not a predicate. I'm being pedantic here, yes. But this is the sort of thinking that leads to blurry code, strange bugs, and inconsistent APIs.\nI hope I'm in the ballpark here when I assert this is the type of thing I think people are worried about. And rightly so. It reflects poor craftsmanship and, I too, would be concerned if the APIs I were consuming relied on the falsiness of 0, {}, [], and so forth to determine the outcome of my program.\n\nHy has an opportunity here to minimize the JavaScript level of insanity with regard to truthiness by defining a simple notion of truth. 0, {}, [], (), and \"\" are all considered equivalent (==) to False in Python. Those are five places where a programmer has the opportunity to shoot themselves in the foot. It isn't necessary.\nI'm updating the title of this issue.\n. @rwtolbert \n\nIf these C extensions use 0 and 1 for False and True, how is that manifested in Python (and Hy) land?\n\nBy writing wrapper code that handles these situations appropriately. Many Java APIs return -1, 0, and 1 to signify various things. In Clojure this is worthless so the API is wrapped in something that is meaningful. \n\nWill that cause issues if 0 doesn\u2019t mean to False in Hy?\n\nWhy would it? If 0 doesn't mean False in Hy it doesn't mean False. Where's the issue?\n\nOr can we head that off at the interface layer?\n\nNo. This should only concern Hy's if expression (which should be the base for all conditional macros). Values should be interpreted as expected by the platform in consideration. If a Hy function returns 0 and hands that to  Python, expect Python's semantics and vice versa.\n\nI don\u2019t think we can know for sure.  It may be defined as \u201cbroken\u201d for C to do this, but we do need to think about how that interop would work?\n\nYes, but also no. Hy simply needs to determine what it considers to be truthy and move forward.\nThis is more or less what I'm proposing Hy use to make this determination:\npy\ndef boolean(x):\n  return not (x is False or x is None):\nUnder the covers (if expr ...) would behave as (if (boolean expr) ...).\n. @Coaldust \n\nHy's current behavior is the correct behavior. I'm stating this as a fact, rather than a opinion, because making the suggested change will cause bugs.\n\nEveryone keeps saying this with no examples or code to back it up.\n\nThese Python programmers will expect None 0 and empty containers to be considered False.\n\nAs I've pointed out this should be a problem. Look at the boolean function I discussed. What if a Python library  employed that technique privately in it's API, would you still be worried? Also I never said None should be considered truthy.\n\nA Python programmer doesn't have to go through any effort at all to use code written in Hy. They just import it and call it as if it was all written in Python.\n\nI've written ClojureScript code meant to be called from JavaScript and it works just fine with the semantics I have proposed.\n\nSo the proposal suggests replacing bad Python semantics with bad Lisp semantics.\n\nHaha! Touche! But I'd prefer \"better Lisp semantics.\" :laughing: \n\nThis creates the opportunity to use it in the workplace. It could resurrect the, seemingly extinct, Lisp job.\n\nHave you heard of Clojure? It's pretty much filling that role. :smile_cat: \n\nyou can always use macros\n\nYes, I suppose there's always that escape hatch.\n. @paultag is right, there's likely no sense in furthering this debate.\n\nFirst is to shadow if, and to add a hy core function that tests if the\nfunction is not either False or None.\n\nThis is the Lisp tradition and what I personally think is the right way to go. No one has demonstrated an example where this could be a problem outside of a Python programmer's initial expectations. Beside no one should be using Hy's if directly from Python code.\n\nSecond is to create a new function (something like truth?) that you can use\nin filter and friends. We can talk about adding if-truth? as well.\n\nThis solution will also work. If someone wants \"real\" Lisp semantics for if they could always write a macro using this function.\nclj\n(defmacro if+ [test success fail]\n  `(if (boolean ~test) ~success ~fail))\nHowever, the downside to this is if the first solution is not the default, the behavior of if will be misleading when the core functions that verify truthiness have a different notion of what truth is. Hy needs to settle on it's interpretation of truthiness and implement if to satisfy it. Regardless of what decision is made, consistency is paramount.\n. None being equivalent to nil makes sense.\n. ",
    "lmatthieu": "I have updated the hy extension with your comments. In the repo https://github.com/lmatthieu/myemacs, you will find an example of emacs configuration handling hy/python code-mixing.\n. ",
    "bitemyapp": "Is this a transpiler for s-expressions into Python bytecode or is it a Lisp?\nIf you stick with these terrible truth semantics you're doing Lisp a disservice.\n. ",
    "goldnd": "That does work, but the real power of the numpy arrays is being able to select ranges across multiple dimensions.\n. I wrote two simple python functions that produce the desired results.  It's not too pretty, but it's a start.  The first one provides a make-slice in hy that exposes the builtin slice function.  There's probably a better way to handle the lists but at least this works for arrays, tuples and lists.\n```\ndef make_slice(slice_info):\n    return slice(slice_info)\ndef slice_array(a, slices):\n    slice_list = []\n    for s in slices:\n        slice_list.append(slice(s))\n    try:\n        return a[tuple(slice_list)]\n    except TypeError:\n        return a[slice_list[0]]\n```\n. It works for a slice in one dimension, but you can't do things like this:\nIn[1]: a[:,0]\nor\nIn[2]: a[1,0]\nOn Sun, Dec 22, 2013 at 12:38 PM, Nicolas Dandrimont \nnotifications@github.com wrote:\n\nHmm. The behavior is just the same as with the corresponding python code.\n=> (import numpy)=> (setv a (numpy.array [[1 2] [3 4]]))=> (slice a 0)array([[1, 2],\n       [3, 4]])\nIn [1]: import numpy\nIn [2]: a = numpy.array([[1L, 2L], [3L, 4L]])\nIn [3]: a[0:]Out[3]: array([[1, 2],\n       [3, 4]])\nWhat's the issue?!\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/issues/381#issuecomment-31094174\n.\n. \n",
    "torsten": "Hi All,\nSorry for the unsolicited feedback. I am very interested in hy and was just reading through the issues, I have a suggestion to this one:\nWhy not do it similarly to Clojure? To represent *yay? as a Java symbol they convert it to _STAR_yay_QMARK_, could that work for hy, too?\n``` clojure\nuser=> (defn *yay? [] (println \"YAY\"))\n'user/*yay?\nuser=> *yay?\n\n```\n. ",
    "emre": ":+1: \n. ",
    "kenanb": "+1 for the above syntax, but it seems to be problematic because of not being able to dereference problem, so if there is no way to make the above work, I suggest this:\nif baz is a variable:\n(setv foo 1)\nif baz is an attribute like foo.bar.baz:\n(setv (.. foo bar) baz 1)\nor if baz is an attribute like foo.bar.bla[\"bla1\"].fub.enuf.baz :\n(setv (.. (get (.. foo bar bla) \"bla1\") fub enuf) baz 1)\nand I think we better directly use (. foo bar baz) for the recursive form, instead of .. dots. but it doesn't really matter much in my opinion.\n. @theanalyst @rwtolbert @algernon \nOK, new proposal. I realized we have \"setf\". So why not use it for extra functionality. CL uses setf for that. Less surprise for newcomers.\nbaz=1\n(setf baz 1)\nfoo.bar[2].baz=1\n(setf (foo bar :2 baz) 1)\nfoo.bar[\"some_bar_element\"].baz=1\n(setf (foo bar :\"some_bar_element\" baz) 1)\nfoo.bar[var_that_evals_to_some_bar_element_name].baz=1\n(setf (foo bar :~var-that-evals-to-some-bar-element-name baz) 1)\nIf the first arg to setf is an atom it will (setv atom value) but if the first arg is a list, it will first getattr (or get if beginning by \":\") recursively in list, except the last element, then it will (setattr result-of-recursive-get/getattr-op \"last-element\" value). The list in setf will be quasiquoted by default.\nThis also defines a syntax for keywords and can be used with a sugar for kwapply with keywords:\n(.bazfunction (. foo bar :some-bar-element) :kw1 \"value-of-kw1\" :kw2 \"value-of-kw2\")\nor\n((. foo bar :some-bar-element bazfunction) :kw1 \"value-of-kw1\" :kw2 \"value-of-kw2\")\nwhich I find simpler.\n. Great work! Thank you @olasd !\n. @theanalyst I believe it will be ((. foo method) args) which I find pretty suitable since AFAIK scheme does a same thing, the first argument to the s-exp can be another s-exp that returns a reference to a procedure, then the procedure is run with the rest of s-exp being arguments to that procedure.\n. ",
    "cndreisbach": "Tests and docs now added!\n. Thanks, everyone! I've added the appropriate line in the tests so that it works correctly.\n. @rwtolbert @algernon That's a good question. I'm not sure how the Hy team prefers to introduce new language features. I made it contrib, assuming that people could try it out and if the core team felt like it, they'd pull it into core in a rev or two, after it became a bit more polished.\n. My only issue putting it in core is the behavior when you put recur in a non-tail-call position. The behavior is, um, unpredictable. I haven't come up with a good way to catch it, or even better, to detect it on macro use. Until the iteration in trampoline is finished, recur returns None, so what you usually end up seeing is a TypeError.\n. Oh, and a further bit:\n=> (def a '(kwapply (total-purchase 10 15) {\"vat\" 1.05}))\n=> (def b ((fn [&rest args] `(kwapply (total-purchase ~@args) {\"vat\" 1.05})) 10 15))\n=> (= a b)\nTrue\nOk, these things are true, so they will eval exactly the same for sure.\n=> (eval a)\n165.375\n=> (eval b)\nTraceback (most recent call last):\n  File \"<input>\", line 1, in <module>\n  File \"/Users/clinton/Projects/hy/hy/importer.py\", line 106, in hy_eval\n    hytree.replace(foo)\n  File \"/Users/clinton/Projects/hy/hy/models/list.py\", line 31, in replace\n    x.replace(other)\n  File \"/Users/clinton/Projects/hy/hy/models/list.py\", line 31, in replace\n    x.replace(other)\nAttributeError: 'long' object has no attribute 'replace'\n. +1 to this. Very useful.\nOn Jan 12, 2014 5:26 AM, \"Abhishek L\" notifications@github.com wrote:\n\ncoll? function is added which checks whether a given argument is a\ncollection ie. whether the given argument is an iterable and not a string.\nAlso updated the flatten function which does this check\nYou can merge this Pull Request by running\ngit pull https://github.com/theanalyst/hy f/is-coll\nOr view, comment on, or merge it at:\nhttps://github.com/hylang/hy/pull/431\nCommit Summary\n- Adding a simple coll? function to the core\n- docs: update docs with coll? functionality\nFile Changes\n- M docs/language/core.rsthttps://github.com/hylang/hy/pull/431/files#diff-0(23)\n- M hy/core/language.hyhttps://github.com/hylang/hy/pull/431/files#diff-1(10)\n- M tests/native_tests/core.hyhttps://github.com/hylang/hy/pull/431/files#diff-2(8)\nPatch Links:\n- https://github.com/hylang/hy/pull/431.patch\n- https://github.com/hylang/hy/pull/431.diff\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/pull/431\n.\n. Hey, thanks everyone!\n. WHAT IS THIS SORCERY\n\nIn seriousness, that seems like a smart way to handle it.\n. such ack; so terse\nThis seems cleaner and a better overall API.\n. @bismigalis The tests are all failing on this: looks like you forgot to add merge-with to *exports*.\n. Code-wise, this gets a thumbs-up from me. I don't understand the utility of it (I mean, I understand what it does, just not why you'd want to do it), but if it's a feature others want, then +1.\n. Looks good to me. Like with defn-alias, not sure if it's necessary, but it's well-executed and tested.\n. I'm going to have a hard time not saying this is a good idea.\n. ",
    "xcthulhu": "Hey, I'm a hy n00b, but the docs aren't updated so this was kind of tricky to learn.\nHy is awesome, btw, I've already replaced all of my python development with it!\n. @tuturto : It might make sense to have tests analogous to the clojure.docs documentation for merge-with \nhttp://clojuredocs.org/clojure_core/1.2.0/clojure.core/merge-with\n. This looks correct, I'll give it my +1\n. Well, if we want this to be API compatible with Clojure, we should have behavior like:\nclj\n=> (doto (set) (.add 2) (.add 1))\nset([1L, 2L])\n(see http://clojuredocs.org/clojure_core/clojure.core/doto )\nAlso, there's a typo in the docs.\nI'll make the changes and make a pull request.  Thanks a ton, tuturto for the quick turn around on this...\n. Closed by #571 \n. Looks like this was introduced in 2167c2112 ...\nNow\nclj\n=> (macroexpand '(for [x [[1] [2 3]] y x] x))\n`(do (import itertools') (for* [(, x y) (itertools.product [[1L] [2L 3L]] x)] x))\nThis doesn't seem like the right thing...\n. Well, so I could see that this might be a good design if itertools.product was more efficient somehow than nested for loops.\nI was curious about this so I decided to run a few micro-benchmarks to find out:\nHere's itertools.product\nshell\n$ python -mtimeit -s'a,b=(range(20),range(20)); import itertools' 'for (x,y) in itertools.product(a,b): x*y'\n10000 loops, best of 3: 39.2 usec per loop\nHere's nested for-loops\nshell\n$ python -mtimeit -s'a,b=(range(20),range(20)); import itertools' 'for x in a:\n   for y in b: x * y'\n10000 loops, best of 3: 33.6 usec per loop\nNested for-loops appear to be 1.16x faster.\nI recognize that pressing this issue is annoying, but I just don't understand why there's this regression in 0.10.0 if it's both slower and less general than the implementation in 0.9.12 .\nThis regression broke some real world code for me, which is why I bring this up...\n. Gotcha; let is usually dynamically scoped so this was a bit of a gotcha. I'd argue that setting attributes should be forbidden from let forms, since it just leads to confusion and foot-shootingness, IMHO.\n. This is still outstanding, my pull request doesn't actually fix this anymore.  Should I fix it?\n. Thanks for your patience with me, Paul :D\nI'm not sure what to say to them.  I tried the following:\n```\n=> (disassemble '(do (import [numpy :as np]) (defn mycos [x] (np.cos x)) (setv np.cos (fn [x] 1)) (mycos 2)) true)\nimport numpy as np\ndef mycos(x):\n    return np.cos(x)\ndef np.cos(x):\n    return 1L\nmycos(2L)\n```\nAnd the code generated doesn't run in the ordinary python interpreter ; it appears that Hy is generating a function with a \".\" in its name in this case?\nThe other code-block compiles to something which can run in the python interpreter:\n```\n=> (disassemble '(do (import [numpy :as np]) (defn mycos [x] (np.cos x)) (setv foocos (fn [x] 1)) (setv np.cos foocos) (mycos 2)) true)\nimport numpy as np\ndef mycos(x):\n    return np.cos(x)\ndef foocos(x):\n    return 1L\nnp.cos = foocos\nnp.cos\nmycos(2L)\n```\nMaybe an epicycle is in order when setv is called to assign a function to an attribute?\n. > Maybe an epicycle is in order when setv is called to assign a function to an attribute?\nie, I am volunteering if you think this is okay\n. To elaborate:\n$ hy\nhy 0.10.0\n=> (disassemble '(setv a.b (fn [x] x)))\nModule(\n    body=[\n        FunctionDef(name='a.b',\n            args=arguments(args=[Name(id='x')], vararg=None, kwarg=None, defaults=[]),\n            body=[Return(value=Name(id='x'))],\n            decorator_list=[])])\nThere's no way to generate this AST using valid python; here's what happens when I try: \n```\n$ python\nPython 2.7.5 (default, Jun  4 2013, 12:00:06) \n[GCC 4.2.1 Compatible Apple LLVM 4.2 (clang-425.0.24)] on darwin\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n\n\n\ndef a.b(x): return x\n  File \"\", line 1\n    def a.b(x): return x\n         ^\nSyntaxError: invalid syntax\n```\n\n\n\nThis throws a syntax error before ever compiling to an AST.  However, setv jumps the python parser so it can write AST for  functions with periods in their name; is this really a good feature for Hy?\n. @tuturto Just AUTHORS, which I just fixed.\n. Reflecting on this, the old let behavior passes all of the tests I introduce here, so the hacks to the let macro are useless.  The tests are good though...\n. Okay, I have no idea why this is failing\n. For reference, PEP 328: http://legacy.python.org/dev/peps/pep-0328/\n. Is this the same bug as #572 ?  We should check other version of python...\n. Looks good to me... think you could write some tests to make sure it's working as intended?\n. No need to apologize!\nunittest is doing its some introspection, trying to load the __main__ module by default.  You can chase the source here if you want (lines 752, 775, and 808 are relevant):\nhttps://pythonhosted.org/gchecky/unittest-pysrc.html\nThe problem is that in hy, the __main__ module isn't the same as in python\nhy\n; Run me with `hy test.hy`\n(when (= --name-- \"__main__\")\n  (print (help  (--import-- \"__main__\"))))\nOutputs\n```\nHelp on built-in module main:\nNAME\n    main - # EASY-INSTALL-ENTRY-SCRIPT: 'hy==0.10.0','console_scripts','hy'\nFILE\n    /usr/local/bin/hy\nDATA\n    requires = 'hy==0.10.0'\n``\n. Now's my turn to apologize - I honestly don't know how to crack this one.  I'll ask around on irc...\n. This is nice, but I think that$` is a bad name for the partial function application combinator.\nFor one thing, ($) :: a -> (a -> b) -> a really has the wrong type signature in Haskell.  If we defined a partial function application function like this:\nhaskell\npartial f a = (f a)\nThen partial :: (a -> b) -> a -> b, and moreover partial == flip ($), which is pretty confusing.\nWhy not name just name the partial function application combinator partial?  That's what its called in clojure and in python...\n. After playing around with hy.contrib.curry, it looks like that module pretty much does everything proposed here, and has behavior I was wondering about...\n. I had been playing around with macros like this for with-redefs:\nhy\n(defmacro with-redefs [bound-vars vals &body]\n  (let [[make-bindings\n         (fn [vars vals] (map (fn [x y] `(setv ~x ~y)) vars vals))]\n        [syms (map gensym bound-vars)]]\n    `(do\n      ~@(make-bindings syms bound-vars)\n      ~@(make-bindings bound-vars vals)\n      ~@body\n      ~@(make-bindings bound-vars syms))\nBut then gensym can't be relied on to make a valid symbol name, so this doesn't work...\nMaybe inside of a gensym, U+0020 (' ') could be replaced with either U+00A0 or U+2007, and U+002E ('.') could be replaced with U+FF0E ?\nOn May 13, 2014, at 6:44 AM, Paul Tagliamonte notifications@github.com wrote:\n\nImpossible where? \nThey run fine :) \nThe idea is to create names that won't clash with local vars :) \nOn May 13, 2014 8:31 AM, \"Morten Linderud\" notifications@github.com wrote: \n\nWell, the quickest solution is to maybe just add a try/except clause and \nyell out about the impossible variable name. Might not be the best behavior \ntho? \n\u2014 \nReply to this email directly or view it on GitHubhttps://github.com/hylang/hy/issues/597#issuecomment-42948492 \n. \n\u2014\nReply to this email directly or view it on GitHub.\n. Thanks for diagnosing the problem with this for me.  To my shame, I was unaware of the differences in relative imports between 2.x and 3.x .  I will look in to fixing this, but I couldn't tell you how big this problem is.  #583 is related...\n. > Does this test that partial has been rebound only locally?\n\n\nThat's what it's trying to do, but it's not succeeding :(\nThe intent is to enforce dynamic-scoping + mutation behavior \u00e0 la scheme/lisp, like this: https://gist.github.com/xcthulhu/f87fe133f56071b72a45\nWhich inspires a much simpler test for the correct behavior, which I'll go do now.\nThank you for the review!\n. ",
    "bismigalis": "ok now I added merge-with in exports but anyway, when run nosetests I get error\nFile \"/home/user/code/hy/hy/core/language.hy\", line 467, in merge_with\nNameError: global name 'when' is not defined\nwhy is that?\n. ?\n. Closed  b/c clone repo was deleted. See #667 \n. ",
    "microamp": "versionadded needs to be updated in docs.\nAlso, it currently returns nil when no maps are supplied to the function (which is fair). An empty dictionary, {}, would've also been a valid option. Either way, it would be nice if it were mentioned in docs in my opinion (especially if we are going with nil).\n. How about this version (ported from here)? Arguably more concise and clearer than the current implementation.\n``` hy\n(import itertools)\n(defn nth2 [iterable n &optional default]\n  \"Returns the nth item or a default value\"\n  (if (neg? n)\n    default\n    (next ((. itertools islice) iterable n None) default)))\n```\nThe only difference from the Python version is that nth2 takes care of negative indices as well.\nExamples:\n=> (nth2 [\"a\" \"b\"] 0)\nu'a'\n=> (nth2 [\"a\" \"b\"] 1)\nu'b'\n=> (none? (nth2 [\"a\" \"b\"] 2))\nTrue\n=> (none? (nth2 [\"a\" \"b\"] -1))\nTrue\nYou can also specify a default value (None by default).\n=> (nth2 [\"a\" \"b\"] 2 \"nooooooooo!\")\nu'nooooooooo!'\n=> (nth2 [\"a\" \"b\"] -1 \"nooooooooo!\")\nu'nooooooooo!'\nAny feedback would be much appreciated. Thanks.\n. No problem. I also forgot to remove (print \"...\") in the test file. They will be removed in the next pull request - hopefully later today. Thanks.\n. Can anyone please tag this as 0.9.13?\n. Thanks. Good to know!\nBy the way, first2 above can be reimplemented in terms of nth. For example,\nhy\n(defn first2 [iterable]\n  (nth iterable 0))\nwhere nth is nth2 explained in #493. It would still work with the current implementation ofnth but I'd argue that nth2 is nicer and clearer. If you're happy with nth2, I will include it in my next pull request along with the new versions of first, rest and second. \nThanks!\n. Hello, is anyone available/interested to do a review? =)\n. @theanalyst and @paultag,\nThanks for your time doing a review on it. The reason I added not-any? and not-every? is that Clojure has them, along with some and every?. The idea was to be consistent.\nHowever, if we decide not to go with them, that's fine. In that case, I'd suggest close this pull request and go with #524. Although my pull request was submitted before his, I don't mind which one goes in. Let's get this over with. =)\n. Nice!\n+1 on plain function. No need to write a macro when it can be implemented as a plain function.\nI personally like the use of (functools.partial apply func) although some people might prefer something more explicit like (fn [lst] (apply func lst)).\n. Nice, I like this. I have wondered if it were necessary to have our own versions of some of the above.\nJust a few things:\n- nth has been reimplemented in #507, also works with infinite/lazy sequence\n- first and rest (along with second) in #507 to work with infinite/lazy sequence\n- filter is eager in Python 2 but lazy in Python 3. We already have a few proposals to deal with this inconsistency (see #331 and #523). We just need some consistent way of using it, for example, (list (filter pred seq)) would make sense in Python 3, but rather unnecessary in Python 2 because filter would return a list anyway in Python 2. The trade-off is that we'd lose the eager version of filter which does not exist in Python 3 anyway, and also the fact that we have our own version of lazy filter overriding it in hy.core.language means that the decision has already been made on that. Same goes with map and xrange/range.\n. By the way, remove in hy.core.language seems to do what itertools.ifilterfalse/itertools.filterfalse does in Python 2/3.\n. While they are not quite the same, it may be okay to treat items in Python 3 like iteritems in Python2. PEP 3106 says items/keys/values in Python 3 are designed to replace iteritems/iterkeys/itervalues in Python 2.\nIf that is the case, we can do something like\n=> (setv d {\"a\" 1 \"b\" 2})\n=> (list ((getattr d \"iteritems\" d.items)))\n[(u'a', 1L), (u'b', 2L)]\nwhich works in both versions. But that's a bit tedious because you have to call the method like that every time you use it. Alternatively, you can define a custom function like below.\n=> (import operator)\n=> (setv items (operator.methodcaller (if-python2 \"iteritems\" \"items\")))\n=> (list (items d))\n[(u'a', 1L), (u'b', 2L)]\nYou just have to call (items d) where you'd call (d.iteritems) and (d.items) in Python 2 and 3 respectively.\n. Duplicates #502, #507 and #524.\n. Just letting you know that #635 is tagged as 0.10.1 in the docs, which can be changed to a later version if desired. Let me know if so.\n. What @algernon said. (Thanks!)\nI admit that the title can be a bit misleading. What I removed is the implementation of remove, not the name. Hence, the unit tests and the documentation are unaffected.\nThe reason I removed such implementation is because it's essentially the same as filterfalse. I believe we no longer have our own implementation of functions such as take-while and drop-while in the core for the same reason.\n. Thanks for reviewing and suggestions. I'll look into using the 'timeit' module inside the macro.\n. My apologies on my lack of update on this. I just had a look at this, but not sure if I'm on the right track. Any advice would be appreciated.\nIdeally, the macro would take some Hy code unevaluated (as a macro would), and convert it to its Python equivalent (in string, so that it can later be passed on to timeit.timeit). I found a way to do it to an extent, but unfortunately it has to take the input (Hy code) as a string. Consider the following function (mostly borrowed from 'cmdline.py').\nhy\n(defn hy-to-py [expr]\n  (do\n   (import [ast]\n           [astor]\n           [hy.lex [tokenize]]\n           [hy.compiler [hy_compile]])\n   (let [[tokens (tokenize expr)]\n         [astd (hy_compile tokens \"hy.core\")]]\n     (do\n      (setv temp (ast.Module))\n      (setv temp.body astd.body)\n      (astor.codegen.to_source temp)))))\nhy\n=> (hy-to-py \"(+ 1 2 3 4)\")\n'(((1L + 2L) + 3L) + 4L)'\n=> (import timeit)\n=> (timeit.timeit (hy-to-py \"(+ 1 2 3 4)\"))\n0.04331398010253906\nI'm not sure if I like this approach. Note that a macro would no longer be needed as the input being a string, not the actual Hy code. More importantly, would this be an accurate measure of Hy runtime? Because what I'm measuring here instead is the amount of time it would take to evaluate the Python equivalent of some Hy code given. Please correct me if I'm on a wrong track here.\n. @Foxboron, thanks for the reply! I'll take a closer look at your PR again, but I think that would help.\nIn the meantime, I'd like to hear more about what the core team (including yourself) think of this approach to the problem. In particular,\n\nMore importantly, would this be an accurate measure of Hy runtime?\n\nThanks in advance.\n. Here using CPython 2.7.8.\nhy\nhy 0.10.0 using CPython(default) 2.7.8 on Linux\n=> (list (interleave (range 10) (range 10 20)))\n[0, 10, 1, 11, 2, 12, 3, 13, 4, 14, 5, 15, 6, 16, 7, 17, 8, 18, 9, 19]\n=> (list (interpose \"a\" (range 10)))\n[0, u'a', 1, u'a', 2, u'a', 3, u'a', 4, u'a', 5, u'a', 6, u'a', 7, u'a', 8, u'a', 9]\n. If I understand it correctly (and judging from their unit test), toolz's version would continue until all of the sequences are exhausted, whereas the version I posted above would stop as soon as one of the sequences reaches the end.\nLooks like Clojure's interleave does the same thing as mine, but doesn't necessarily mean that's how it should be in Hy. Does anyone prefer one over the other?\n. I can add interleave and interpose as I posted earlier for the time being. Someone else can add round-robin if the Hy Core team think it's worth it.\n@algernon, have you considered using zip_longest for the interleave function in 'adderall'? (I'll call it round-robin here to avoid confusion.)\n``` hy\n(defn round-robin [&rest seqs]\n  (remove none? (apply itertools.chain (apply zip_longest seqs))))\n=> (list (round-robin (range 10) (range 10 15)))\n[0, 10, 1, 11, 2, 12, 3, 13, 4, 14, 5, 6, 7, 8, 9]\n```\nThis would not work properly if a sequence has None in it, but maybe good enough depending on the context. I don't particularly find either toolz's implementation or the itertools recipe overly intuitive, hence the question.\n. In addition to the above, I've added docs/tests for butlast (previously missing).\n. Cool. I noticed empty? would have the same issue explained above since it's again using len to determine the length of a collection. I'll open a new issue/pull request for that one.\n. first is basically (nth coll 0), and nth can be reimplemented with nil as the default value.\nhy\n(defn nth [coll index]\n  \"Return nth item in collection or sequence, counting from 0\"\n  (next (drop index coll) nil))\n(Note: try/catch is no longer needed)\nhy\n=> (assert (nil? (first [])))\n=> (assert (nil? (nth [] 0)))\n=> (assert (nil? (nth [] 1)))\n=> (assert (nil? (nth [] 100)))\n. > I'd love to get you into core after a few patches.\nI am totally speechless (never expected it to happen). Thank you!\nSubmitting a PR for this shortly.\n. By the way, it works as expected if I replace + with operator.add.\nhy\n=> (import operator)\n=> (reduce operator.add [\"a\" \"b\" \"c\"])\n'abc'\n. This currently blocks #644. Anyone had a look by any chance?\n. Docs updated accordingly. Thanks!\n. Here is the new version of some. (Currently blocked by #638/#641. I need nth fixed in advance.)\nhy\n(defn some [pred coll]\n  \"Return the first logical true value of (pred x) for any x in coll, else nil.\"\n  (first (filter nil (map pred coll))))\nSome examples to follow:\n1.\nhy\n=> (nil? (some (fn [k] (.get {:a 0 :b 1 :c 2} k \"\")) [:d :e :f]))\nTrue\nNo keys found. (.get <dict> <key> \"\") returns \"\" (empty string) if key is missing in dict, and \"\" is logical false in Python, hence nil returned.\n2.\nhy\n=> (nil? (some (fn [k] (.get {:a 0 :b 1 :c 2} k \"\")) [:d :a :f]))\nTrue\nKey found (:a). But (.get {:a 0 :b 1 :c 2} :a \"\") returns 0 which is logical false.\n3.\nhy\n=> (some (fn [k] (.get {:a 0 :b 1 :c 2} k \"\")) [:d :a :c :f])\n2\n2 is logical true, hence the value returned.\n. Thanks, Hy Society. This made my day!\n. I'd like to add that you can find good step-by-step instructions in the docs here.\n. Hello, thanks for the contribution! Hy in production for a few months? I envy you!\nBy the way, I'd suggest updating the docs too.\nOne question (to the core team) is whether last should work with generator/iterator objects too or not.\n. It's because len would only work with strict collections (e.g. list) or iterators that implement __len__.\n. @tuturto @Willyfrog\nThat's similar to the approach I took when implementing drop-last. Also, I just remembered that the previous version of butlast(fixed here) wasn't working with generators/iterators because of the len issue mentioned above.\nYour thought on this, @paultag?\n. @acron0 \nMy apologies on getting back to you late.\nI'd go with the second implementation (the one with (list coll)). I realised that itertools.tee is irrelevant here since it doesn't stop the original iterable from being exhausted anyway. It is the case with butlast too.\nMind doing another commit for this when you can?\nBy the way, you can do something like (get aslist -1) (think of it as Python's aslist[-1]) instead of having to reverse the collection (then get the first item).\n. +1 from me\nWe'll wait for one more vote to get it merged since the implementation is now a bit different from what @berkerpeksag signed off previously.\n. @theanalyst, thanks for pointing it out. \nAt present, there are different ways keyword/optional arguments are specified in the docs. Please consider the following code-doc pairs.\nhy\n(defn disassemble [tree &optional [codegen false]]\n  ...\nUsage: ``(disassemble tree &optional [codegen false])``\nvs\nhy\n(defn read [&optional [from-file sys.stdin]\n                      [eof \"\"]]\n  ...\nUsage: ``(read [from-file eof])``\nI don't want to complicate the matter, but maybe @hylang/core can come up with a standardised way of doing this? I'll follow whichever is decided.\n. ",
    "f": "<3\n. ",
    "icholy": "@Foxboron @olasd Updated code as suggested. Seems to be working :+1: \nhttps://github.com/icholy/hy/compare\nAny chance of this getting merged?\nEDIT: doesn't have to be my code. That macroexpand is all I really want.\n. I need to figure out the conversion between _ and - still. I'll reopen when that's working.\n. @berkerpeksag I think it's ready.\n. @berkerpeksag @Foxboron done\n. botched the squash ...\n. @berkerpeksag @Foxboron done. Pls review.\n. Can this get merged?\nSeeing my broken code in master is giving me an OCD attack.\n. @berkerpeksag I don't think so?\n. A dict has a falsy value when it's empty. So we have to check with is not None.\n. We could also just have the default value for namespace be {}\n. Unicode completion works for python 3.\n. When using python 2, matches that contain non-ascii characters get ignored by readline.\n. Where should I add this dependency?\n. ",
    "jackhooper": "Fixed the closing bracket. \nRegarding my email address, GitHub should have provided a fake one for me (I set it up that way to avoid spam). I can provide my real one if you like. If no email address was visible at all, then I'm not sure what's going on there... might it be a GitHub bug? Let me know if you need any other info from me.\nJH\n. Okay, so what do you want me to do regarding my real email address?\n. @theanalyst my email address is contact (dot) jhooper (at) gmail (dot) com. Let me know if you need anything else.\n. ",
    "JacobGood1": "cffi is the new hotness for me...\n. Well, I suppose that would return (eval '(b c d)).  In clojure if I were to invoke (a + 1 2) I get 3.\n(defmacro a\n  [& xs]\n  xs)\n=> (var user/a)\n(a + 1 2)\n=> 3\n. ",
    "puffnfresh": "@olasd done both, I would have liked to write a property-based test but it doesn't look like Hy uses any testing library for that currently.\n. Woo, Travis is finally happy now!\n:cake: \n. ",
    "JoePython1": "Yes it does. Thanks\n. ",
    "halit": "@paultag Hi, i am really glad. I thank you for all!\n. Hey, sorry for that. I will be more careful at the next time.\n. ",
    "ivan": "Wouldn't you need to use an io.BytesIO on Python 2?\n=> (import [sys] [io [StringIO]])                \n=> (.write (StringIO) (.encode \"\\ucccc\" \"utf-8\"))\nTraceback (most recent call last):\n  File \"<input>\", line 1, in <module>\nTypeError: unicode argument expected, got 'str'\nAlso, if you put (setv sys.stdout (BytesIO)) into the REPL, you might be inconvenienced by the lack of output to the terminal.\n. I see that this also happens with do\n=> (if True (do 1 2 3))\n1\n2\n. I've learned that the compilation of\n```\n(if True (do 1 2 3))\n(def x (if True (do 1 2 3)))\n```\nis\n```\nif True:\n    1L\n    2L\n    _hy_anon_var_1 = 3L\nelse:\n    _hy_anon_var_1 = None\nif True:\n    1L\n    2L\n    x = 3L\nelse:\n    x = None\n```\nBecause they're at the \"top level\", code.InteractiveConsole prints the 1L and 2L.\nWhat do you think about wrapping each REPL form the user inputs in a ((fn [] ...))?  That would make the return value get printed, without printing any top-level expressions like 1L and 2L.\nNote that if the user inputs multiple forms at the REPL, e.g. 1 2 3, each form would have to get wrapped in its own ((fn [] ...)).\n. Duplicate of #305\n. ",
    "wbolster": "fwiw, issue #732 has comments worth reading. woohoo :). ",
    "calben": "Pull request #508 has been created to fix this issue.\n. It would certainly be a simpler solution as far as changing the code from its current state.\nHowever, after reviewing all the code it seemed best to keep the Python compiler slim and implement core language features as either a Hy function or as a macro where possible because this potentially makes the code simpler to edit and test down the line, a Hy function being simpler than a function with 2 decorators and embedded in a pipeline.\nSince macros are a bit slower and there is no need to implement cut as a macro, I implemented it as a function instead.\ncut can be implemented to behave exactly as slice did before, as slice was, I think, implemented by creating an ast.Slice object.\nRight now cut behaves just like slice except these cases:\n(cut (range 10) None) -> slice allowed the \"None\" to be explicit.  Sometimes people use something like this to return a copy of a list in Python, but it's often considered better practice to use the list constructor.  Other than to copy a list, this has no real function so far as I know.  This can be changed to behave as slice does.\n(cut (range 10) 4) -> slice would return everything after the 4th index whereas cut returns everything before.  Common Lisp's subseq behaves as slice does, which may justify changing this back to the way slice handles it.  Python's slice built-in behaves as the cut function does.  \nMoving the functionality back to compiler.py would be easy enough.\nWhether or not the function should return in a Pythonic or Lispy fashion regarding behaviour with only one argument I'm not sure.\n. I left the cut function such that (cut collection value) will slice return the list up to the value rather than starting from that value since rest can be used to return the list without the first element, which is the most frequent instance of getting a list starting from a value.\n. thanks @paultag!\nchanges the arguments of slice, and cut doesn't work exactly as slice did.\nthis might trip people up.\nif core thinks it cut should behave just as slice did, i'll roll out the change this weekend.\n. did a quick merge to check on things- seems one of the macros is now broken, but i think this is a good opportunity to review all of the changes again and find a solution for multi-dimensional slicing in #541.\nwould it be appropriate to solve both #541 and #505 in one pull request, being related?\nthe current solution doesn't support the multidimensional slices, and, while i think it's best to have slicing in language.hy, it may be necessary to keep it as a special form in compiler.\n(i'm asking about appropriateness because i'm still new to github and getting used to best practices with github and git, please be patient wth me here!)\n. that'd be great!\ni'll be on the IRC most of the evening and would love to learn me how to stuff :smiley:\n. I can switch cut to be a compiler builtin and will push that shortly.\n(note: full reasoning has been given elsewhere.  makes a lot of sense performance-wise and making cut a function call kills its \"settable\" status)\n. @Foxboron, pong!\ncan't believe i let this fall by the wayside; i'll redo this work and get this done as @olasd suggested by renaming the existing slice function.\n. This branch has replaced the slice function with cut and has corrected all of the tests with a few clean commits:\nhttps://github.com/calben/hy/tree/sliceovershadow\nI'm not sure how to switch the pull request to that branch, though :-/\n. After a helpful StackOverflow question pointed out the obvious, multidimensional Numpy arrays can be sliced without the [] like so:\nx = np.array([list(range(5)) for x in list(range(5))])\n    x.getitem(slice(1,4))\n    array([[0, 1, 2, 3, 4],\n           [0, 1, 2, 3, 4],\n           [0, 1, 2, 3, 4]])\n    x.getitem(tuple([slice(1,4),slice(1,4)]))\n    array([[1, 2, 3],\n           [1, 2, 3],\n           [1, 2, 3]])\nYea... that turned out to be as simple as it should be.\nAsked on StackOverflow after missing the obvious when trawling through C code and Python wrappers to figure it out.\nThis can be applied in Hy directly using get:\n=> (def x (numpy.array [[1 2 3] [1 2 3] [1 2 3]]))\n    => x\n    array([[1, 2, 3],\n           [1, 2, 3],\n           [1, 2, 3]])\n    => (list (get x (slice 0 3) (slice 1 3)))\n    [array([1, 2, 3]), array([1, 2, 3])]\nIf support for this is to be added to the standard library, the cut function could be extended to support it, but this might either make calling the cut function more awkward or make its behaviour surprising with this added functionality.\nShould another function be added to support this?\nShould a note somewhere be added that this is how you perform multi-dimensional cuts and the code left as it is?\nShould the cut function support this?\n. I'll look into adding a note about this in the docs, but I'm not quite sure where it would go right now.\n. Commits have been squashed.\nI should have the moment to update the documentation (how could I forget?!) within 24 hours, for which I will open a new pull request unless there's a reason to prefer keeping it on this pull request.  In this case I'll squash all the changes into a total of 2 commits, one for the code and one for the documentation.\n. Sure thing!\nWill follow with documentation ASAP\n. the docs are now corrected, as well as a line in parse-tumblr\n:thumbsup: \nthis ship, she be ready to sail! (so far as i know...)\n. It's definitely a language breaking shituation :-/\nWould it suffice/help to write a little script people can use to check their programs and convert slice to cut where appropriate?\n. a reader macro could work well, but binding cut to : instead may have nasty consequences when using packages like numpy.\n(i can double that on my branch later)\n. Any work done on this?\nThinking I might raise this sucker from the dead and implement- seems like a really good idea.\n. ",
    "pyos": "I'm a bit late, but doesn't standard library map do that already?\nhy\n=> (import operator)\n=> (list (map operator.add [1 2 3] [4 5 6]))\n[5, 7, 9]\nAlso, zipwith(fn, xs, ys) in Python would be equivalent to itertools.starmap(fn, zip(xs, ys)), not map(fn, zip(xs, ys)) as the docs say.\n. > filter is eager in Python 2 but lazy in Python 3.\nOh, so that's what the point of having a custom implementation of filter was. I've got to admit, I forgot some of the differences between 2 and 3 as I haven't used 2 in a long time.\nSince we're talking about backporting Python 3 versions of built-ins, is there anything that can be done about dict.keys, values, and items? These return set-like objects in 3 which, AFAIK, have no equivalent in 2 at all.\n. In short, the status is this: this pull request now fixes #493, #502, #331, and #523. In addition to that, it makes take-while, drop-while, zipwith, repeat, cycle, take, drop, iterable?, and iterator? much cleaner. The documentation for zipwith is now in the correct place, and all functions that work on iterables raise proper errors on invalid indices instead of silently returning nil.\n. Fixed, rebased, and squashed. Should be good to merge now.\n. Perhaps it would be better to implement exec in Python 2 as a macro instead of using ast.Exec? exec(code[, globals[, locals]]) in Python 3 is exactly the same thing as eval(compile(code, '<string>', 'exec')[, globals[, locals]]), which can be done in Python 2.\n. > mixing return and yield in the same function doesn't work in Python 2\nAnd in Python 3, return x inside a generator is equivalent to raise StopIteration(x) (the argument is accessible as the value attribute on the resulting exception object), so even if yield detection works, the compiler still does the wrong thing. Without this, coroutines would be much less useful.\n. @gilch,\n\nI think see why yield isn't detected: defmacro/g! expands to a let form. So the yield isn't in the function we think it is in.\n\nEven so, why does the function that let creates contain a return when it also contains a yield? The exception is pretty unambiguous. There's still a bug somewhere else, and it has to be fixed in order to reliably replace returns with raise StopIterations on Python 2.\n\nWhen deviating from the direct translation though, I'd prefer to have a unit test to ensure your proposed changes are actually doing what we want.\n\nWell, it looks like there's already a test that fails due to absense of StopIteration.value in Python 2 (check the Travis logs). No test ensures that coroutines/generators actually return a value in StopIteration, though; such a test should do something similar to this Python code: http://ideone.com/hqD1py\n. @superbobry makes a good point. Here's a concrete example of where the semantics differ:\nhy\nhy 0.10.1 using CPython(default) 2.7.8 on Linux\n=> (defn f []\n...   (yield 1)\n...   (try\n...     (yield 2)\n...     (catch [e ValueError] (yield 3))))\n=> (defn g []\n...   (yield-from (f))\n...   (assert true))  ; see issue #691\n=> (setv x (g))\n=> (next x)\n1L\n=> (next x)\n2L\n=> (x.throw ValueError)\nTraceback (most recent call last):\n  File \"<input>\", line 1, in <module>\n  File \"<input>\", line 257, in g  ; note that ValueError didn't even reach `f`\nValueError\nas opposed to\nhy 0.10.1 using CPython(default) 3.4.2 on Linux\n...\n=> (next x)\n2\n=> (x.throw ValueError)\n3\nThis would pose a problem, for example, if one was to reimplement asyncio on top of yield-from, as it uses task.throw(CancelledError) to abort running tasks. Obviously, if this is not fixed, only the outermost task would be aborted; any tasks it may be waiting on will completely avoid being cancelled.\n. This should be (setv ~g!r (next (iter (. ~g!e args)) nil)). StopIteration instances don't have the value attribute in Python 2.\n. ditto\n. same\n. ",
    "whilo": "Thanks for pointing out!\n. Still disassemble should return a value imo and butlast is a nice declarative complement to rest. Minor stuff though.\n. butlast as a declarative complement to rest and the removal of print side-effects in exchange for a pure return value in disassemble. Imo this should be default for all core functions, to avoid side-effects for return values where possible.\n. Ok, should be fixed now. Anything else?\n. ",
    "schuster-rainer": "Some code to meditate on ... I used this functions in clojure for reading a csv. But anything dynamic doing IO is the target of this function. Another approach is to create a shim wrapper for APIs with strings but using keywords. Or creating more abstract functions and not using strings for parameters where I only pass them on the lower level, existing APIs but keywords, or the other way round... To create keywords, where an Python API (with dicts or what ever you can imagine of) is returned but I wanna have a more clojuresque approach. I like using keywords over strings as I can use them as function to the map for the lookup. I like keywords in general more than using strings. So I think there are even more use cases. As I always try yo use a function first this is my approach. Obviously no macro needed (maybe for performance optimisation). I'm open for suggestions to massage and improve the code. \n. As this is only the first draft feel free to make suggestions for improvement. I only added the use cases obvious to me.\n. Anything I should change in this patch to get accepted? Or will you derive or completely replace my work by something already existing? Would like to have this name and keyword thing in. \nI disagree on KEYWORD-NAME, really should be name. Maybe I have to add more code the implementation to satisfy the specification.\nhttp://clojuredocs.org/clojure_core/clojure.core/name\nhttp://clojuredocs.org/clojure_core/clojure.core/keyword\nI know that name already exists in python. But basically that should be the names for the functions.\n. Oh, you are right ... Don't know why I'm confusing everyone. For me it absolutely makes sense, as functions and objects already have a name attribute, which I'm accessing in the implementation. It's more than need for the purpose I intended, but I wanted a pythonic approach, so when im passing in the a function or object there should be some meaningful result. Its a generic function that works on  every type of thing you are throwing at it. Another good thing I love in clojure. The generic functions for every type of data structure. I think keyword-name would limit its use to only keywords. I don't really care about its data type (fact to the dynamic nature of what we are using, luckily). What I'm really interessted in is the name of \"some thing\". Don't know what it is. I may be in a generic algorythm, function. So testing/sensing would always apply. Why not the put it into a function that is doing it for me by convention? Less typing, less code, less errors.\nRegarding make-keyword:\nThats exactly the reason why I created the functions. using make-keyword is more verbose ... therefore error prone, and tedious if I use this keyword all the time. You may not run into this problem, but most of the time I'm exclusively using maps and lists as my datastructure, no classes at all.\nBeing explicit all the time is good for configuration. For behaviour I'm not so sure. So while I'm used to _ in python I don't like it. The - does an excellent job. So how would you call into python function which expects an underscored version of a war, but want to use keywords with '-' of course. Imagine of using the keyword :my-special-keyword all the time in your code... \nThat's was my intention for using this 2 functions. So you may disagree and. That's also fine. I think we should discuss the semantics. Whether I got this right. I don't see any problem in using name. What would be confusing to a user when using name? Maybe its now clearer what the intention was after my explanation. \nFurther considerations, ideas or suggestions?\n. And as I'm not reinventing the wheel here, similar stuff for java interop, as you already know. Just to mention for everyones reference.\n. So consensus over the whole thread right now is keyword. The discussion point as I understand it is 'name' vs. 'keyword-name'. Maybe @agentultra didn't read the implementation carefully, as the code should be really generic, as he supposed  KEYWORD-NAME. I'm fine expanding the implementation to match the needed criteria for being name a first class citizen.\n. oh you mean due to conflicts shadowing a variable called name ... \n. So I guess you would also disagree with key as a function name. I wanted to stay to the clojure impl. But lets consider to just use something else ... how about 'name-of'. Or another plain postfix. 'name->' as name attribute accessor. just 'name-' ... Maybe you get a better idea. I still think name is the most appropriate... but I'm fine using some short postfix... which adds to its nature of being a function which returns the name 'name'. What I dislike, but would be better than just using KEYWORD-NAME is 'get-name' ... something else you would consider usefull?\n. ",
    "bcj": "Definitely a mistake. I've updated the commit so that it no longer is doing crazy things.\n. ",
    "nlfiedler": "Another example: (setv (a b) '(1 2))\nResults in a similar stack trace.\n. ",
    "Womble": "I'm not sure if this is the best place to put this, but as the linked issues seem more general about replacing splice I'll leave it here\nWould it be worth introducing a reader macro for creating complex slices? I've had a look around and there doesnt seem to be an easy way of doing this in hy at the moment. After a bit of playing around I came up with \n(defreader | [expr]\n(let [[sl (get --builtins-- \"slice\")]]\n    `(get ~(car expr) (, ~@(list-comp (if (= (type x) HyExpression)     \n        (+ '(sl) x)\n        x)\n    [x (cdr expr)])))))\nwhich takes e.g. #|(arr 0 (1 10 2) Ellipsis 3) and converts it into the equivalent of arr[0,1:10:2,...,3]\n. ",
    "jakirkham": "Related question to this. How should one going about assign a value to an array slice?\n. Thanks @kirbyfan64 and that does work with a numpy.ndarray.\nI was also wondering how this might be expanded to more dimensions or would this simply be a drop in replacement of cut with @gilch's proposed changes? \n. Related question, given this (setv a (np.zeros (tuple [10 10]))), why does this happen? \n=> (slice 1 3)\nslice(1L, 3L, None)\n=> (cut a (slice 1 3))\nIndexError: invalid slice\nI thought maybe if I made it was a singleton tuple this would help (given numpy frequently takes these).\n=> (tuple [(slice 1 3)])\n(slice(1L, 3L, None),)\n=> (cut a (tuple [(slice 1 3)]))\nIndexError: invalid slice\nOn the other hand, using __getitem__ and __setitem__ works in these cases.\n=> (a.__getitem__ (slice 1 3))\narray([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n   [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])\n=> (a.__getitem__ (tuple [(slice 1 3)]))\narray([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])\n. It would be nice if we could get the license file included in the next PyPI release.\nxref: https://github.com/hylang/hy/pull/1186. No worries. Thanks for the quick merge. :). ",
    "troilusc": "One way to do x[1:5,1:2] is (get x (slice 1 5) (slice 1 2)) in hy.. ",
    "josiah14": "I think since LISP is supposed to center on LISt Processing, I think it makes sense that the Hy community should be somewhat concerned about having excellent support for Python's #1 vector and matrix processing library (NumPy, and the superset of that, Pandas).  I'm happy to see this discussion is still ongoing and hasn't died quite yet.\nI want to stress that when coming up with a good syntax for slicing to keep the machine learning and data science oriented Pythonists happy, that we don't forget about the third parameter one can throw into a slice which can define the step (and also the direction), and also the ability to reference multiple specific indices at once (and even mix both ranged and specific indices in the same statement) and also use a mask, because those are a powerful and oft-used shorthand for a lot of Pythonists and data scientists.  I didn't see this third \"step\" parameter referenced at all at the Japanese article, but I'm very glad to see it in an example further up in this discussion (here) and also in the example given in the original post.\nI also think brevity should be emphasized because this is something that would be as common for many people who might want to use Hy + Pandas as using conjunctions and articles in English.  For that reason, I think the idea listed above of slice literal is really attractive.  I'm a bit new to LISP (but I'm loving it!) so I don't know how possible it would be to do this in a performant way... but I would like to see a concise syntax that can handle something as complex as the below from this example of the SciPy Lectures\n```\n\n\n\nimport numpy as np\na = np.array([[0,1,2,3,4,5],\n...    [10,11,12,13,14,15],\n...    [20,21,22,23,24,25],\n...    [30,31,32,33,34,35],\n...    [40,41,42,43,44,45],\n...    [50,51,52,53,54,55]])\na[(0,1,2,3,4), (1,2,3,4,5)]\narray([1,12,23,34,45])\na[3:, [0,2,5]]\narray([[30,32,35],\n           [40, 42, 45],\n           [50,52,55]])\nmask = np.array([1,0,1,0,0,1], dtype=bool)\na[mask, 2]\narray([2,22,52])\n```\n\n\n\nWhat seems like a decent starting point to me for dreaming up a decent syntax might be something like the following:\n```\n:(a (, 0 1 2 3 4) (, 1 2 3 4 5)) ;; indexing\n:(a (: 3 _) (, 0 2 5)) ;; mixing ranges and indexing\n:(a (: 3 10 2)) ;; a range with the step size included\n(setv mask (np.array [1 0 1 0 0 1] :dtype bool)\n:(a mask (, 2))  ;; or even better, #:(a mask 2)\n```\nOf course, I haven't been super active in the Hy community, yet, so I wouldn't blame anyone for completely disregarding my thoughts on this, but I also really like Hy and thus felt the desire to provide my perspective as someone in the big data analytics world working closely with data scientists every day.\n. That solution worked perfectly for me, @guanyilun.  Thanks!\nI just wrote a little extra code to provide a Tag Macro:\n``\n(deftag s [code](nget ~@code))\n(comment example usage, below)\ns(a 3: (, 1 2 3 4))\n```\n. ",
    "guanyilun": "Just want to share my implementation (based on the Japanese article),\n```\n  (defn parse-colon [sym]\n    (list (map (fn [x]\n                 (if (empty? x)\n                     None\n                     (int x)))\n               (.split (str sym) \":\"))))\n(defn parse-indexing [sym]\n    (cond\n      [(in \":\" (str sym)) `(slice ~@(parse-colon sym))]\n      [(in \"...\" (str sym)) 'Ellipsis]\n      [True sym]))\n(defmacro nget [ar &rest keys]\n    `(get ~ar (, ~@(map parse-indexing keys))))\nIt should work for the cases mentioned above. For example,\n(setv a (.reshape (np.arange 36) (, 6 6)))\n(setv mask (np.array (, 1 0 1 0 0 1) :dtype bool))\n\narray([[ 0,  1,  2,  3,  4,  5],\n       [ 6,  7,  8,  9, 10, 11],\n       [12, 13, 14, 15, 16, 17],\n       [18, 19, 20, 21, 22, 23],\n       [24, 25, 26, 27, 28, 29],\n       [30, 31, 32, 33, 34, 35]])\narray([ True, False,  True, False, False,  True])\n\n(nget a (, 0 1 2 3 4) (, 1 2 3 4 5))\n(nget a 3: (, 0 2 5))\n(nget a 1:-1:2 3:5)\n(nget a ::2 3 None)\n(nget a ... 0)\n(nget a mask 2)\n```\narray([ 1,  8, 15, 22, 29])\narray([[18, 20, 23],\n       [24, 26, 29],\n       [30, 32, 35]])\narray([[ 9, 10],\n       [21, 22]])\narray([[ 3],\n       [15],\n       [27]])\narray([ 0,  6, 12, 18, 24, 30])\narray([ 2, 14, 32]). ",
    "andrewchambers": "Perhaps the final bound value in the loop should be the value of the for expression in case someone wants access to it (instead of leaking it out and covering globals).\n(print (for [x (range 10)] \"foobar\")) ; prints 9\nthat way you can check for breaks by the value of the expression if you so choose.\ne.g.\n(print (for [x (range 10)]\n            (when (= x 5) (break))))\nprints 5\n. I figured emitting a del x after the loop would stop the leakage. \nedit - Hmm, wait, i just tested that and it doesn't seem to work.\nx = 5\ndef fn():\n    for x in range(10):\n        pass\n    del x\n    print x\nfn()\nprint x\ngives an error about the local x being referenced before assignment, this behaviour seems strange to me since i thought the del would remove the local x, and the global x would remain visible, apparently not.\nedit -- Looking at how let is implemented, i guess the only way to fix this is using a closure anonymous function to wrap for loops, though thats kind of inefficient.\nanother edit -- olasd had a good idea where the for variables are transparently renamed to a gensym so they never clash. \n. \"After all, this leakage does have an advantage\u2014namely, that you can tell where the loop stopped\u2014so it's not as if we would be unconditionally better off without it.\"\nMy original suggestion was to make the value of the for expression this value so its still available. If nobody else complains i don't mind this being closed though.. ",
    "matzeatze": "Thanks, this already helped me a lot!\nIs it also possible to build the expression in python or maybe to build an ordinary string there and convert it to a quoted s-expression to be used in hy?\nSo in the given example \"input\" would not be set in hy language but in python code instead. I\u00b4m using iPython with hymagic, so what I am actually trying to do looks somethink like:\ninput = \"(+ 2 3)\"\n%hylang (print (eval input))\nwhich of course does not work this way\n. ",
    "kaitlin": "yup that's pretty much it. Can install with pip install sphinx_rtd or something like it.\n. ",
    "timmartin": "I've written a very simple coverage module here that does line coverage of Hy files. There's no integration with pygments yet, but the output HTML seems usable anyway.\n. I'm not sure how I close this ticket, or if I even can.\n. I agree about arguments that aren't identifiers. This isn't specific to &key, it applies to &optional as well. I've written a simple patch that seems to deal with this, and doesn't regress anything.\nI'm not sure if I've got the terminology right, though. My code allows HyString and subclasses thereof, which includes HySymbol. This seems like the correct behaviour, but it means that the error message mentions strings, which makes it sound like they keyword name needs to be a quoted string literal.\n. Is there anything left to be done for this issue?\n. The proximate cause appears to be this code in compiler.py:\npython\n        if body.expr:\n            if body.contains_yield:\n                body += body.expr_as_stmt()\n            else:\n                body += ast.Return(value=body.expr,\n                                   lineno=body.expr.lineno,\n                                   col_offset=body.expr.col_offset)\nIt looks like it should be enough to weaken the condition so that the ast.Return is always generated in Python 3 (actually, Python 3.3+ I think?)\n. FWIW, I don't remember why I originally hit this, but it was related to my Hy plugin for pycov (https://github.com/timmartin/hy-coverage).\nThe original problem was a little more complicated than importing hy.core.macros directly, but I was importing one of the Hy modules that implicitly led to importing hy.core.macros, which failed. I simplified the problem down to hy.core.macros but couldn't get any further with it.\nThe coverage plugin needs to include every module that's included (directly or transitively) by the code that it's assessing coverage on. However, I don't seem to be hitting this any more, perhaps because of another fix I made to the way my code imports modules (I forget the details), so I assume I no longer have a need to import hy.core.macros.\n. ",
    "hooblei": "oh man, wish had seen --spy hours ago :) \n=> (defn f [] (try (yield 1) (finally (print \"fin\"))))\ndef f():\n    try:\n        _hy_anon_var_1 = yield 1L\n    finally:\n        print(u'fin')\n    return _hy_anon_var_1\nTraceback (most recent call last):\n  File \"/home/maresp/workbench/cbf/cbf-venv/lib/python2.7/site-packages/hy/importer.py\", line 42, in ast_compile\n    return compile(ast, filename, mode, flags)\nSyntaxError: 'return' with argument inside generator (<input>, line 1)\n. > What kind of usage are you thinking of for this? What is the reason you would like to use HyDict instead of regular dictionaries?\nI have no need for a HyDict. I don't know about HyDict, but after reading your response, maybe the better bug would be: Hy casts dict into a HyDict when used in cons ... ?\n. ",
    "kadu-vido": "Guess I got lost in the stupid parentheses. Thanks for your time.\n. I had figured that out afterwards, it became clear from the fact that my wrong code was still printing everything. I kept that notation because I meant to change it to:\n(print (* 2 (+ (str (- 99 i)) \" bottles of beer on the wall, \")))\nMaybe I should explain what I'm doing. I was going through the tutorial, slightly changing and enhancing the examples to make sure I understood how to use everything, and most was fine.\nWhen I arrived to control flow, at first I struggled a bit with the ternary and if-elif-else structures, but found what was wrong. Then I moved to for loops and had some difficulties, so decided to make a file with the beer song:\n(for [i (range 99)]\n  (print (* 2 (+ (str (- 99 i)) \" bottles of beer on the wall, \")))\n  (print \"Take one down, pass it around, \" (- 98 i) \" bottles of beer on the wall!\")\n)\nThis worked fine with the correction you suggested, but then I copy-pasted the exact same code to a different file,\n; other stuff before, I checked and all the parentheses before were closed\n(for [i (range 5)]\n  (print (* 2 (+ (str (- 99 i)) \" bottles of beer on the wall, \")))\n  (print \"Take one down, pass it around, \" (- 98 i) \" bottles of beer on the wall!\")\n)\n(print \"...\")\nI get this when I run:\n(print (* 2 (+ (str (- 99 i)) \" bottles of beer on the wall, \")))\nTypeError: 'unicode' object is not callable\nIs there any better way to do this without explicitly writing the string twice?\n. I put both on Dropbox: https://www.dropbox.com/sh/chf35nr9m7ygs5g/Lo5_xGjZ--\n(Sorry for the silly prints, I try to amuse myself while learning the basics)\n. Oh, of course! Damn, such a rookie mistake, I always forget python lets you do that!\nThank you very much. I'm glad I didn't have any other embarrassing mistakes.\nAnd thanks, I had the stupid song stuck in my head for two days.\n. ",
    "akaptur": "The 3.2 error was coming from a bad treatment of yield-from, not the raise-from stuff. I didn't realize yield-from was 3.3+.  Fixed now.\n. This looks to be the same issue as #563 and #600.\n. ",
    "198d": "I'll look at a test or two this week!\n\nOn May 12, 2014, at 5:49 PM, Paul Tagliamonte notifications@github.com wrote:\nLooks great. Tests? Has ack!\n\u2014\nReply to this email directly or view it on GitHub.\n. \n",
    "mattjmorrison": "Alright, that makes sense. So how would I go about actually running unittests in hy?\n. @Tordmor Thanks!\n. ",
    "cathray": "unfortunately hy cannot import the command line script as  main in sys.modules which is why unittest.main cannot find it. As a workaround you need to put your tests in a module different from the one passed on the command line and then import that module and pass it to unittest.main. For example\nin testing.hy:\nhy\n(import unittest)\n(defclass MyTests [unittest.TestCase]\n  [[test-example\n    (fn [self]\n      (self.fail \"oops\")\n      None)]])\nAnd in runtests.hy:\nhy\n(import sys unittest testing)\n(unittest.main (get sys.modules \"testing\"))\nThen hy runtests.hy will run your tests.\n. ",
    "benauthor": "Thanks, getting my bearings in here, sorry for the noise!\n. I can't stop giggling. :monkey: :monkey: :monkey: \n. ",
    "zenhack": "I managed to reproduce this without the recursion:\n(defmacro foo [x] `(~0))\n(foo 0)\n...on the release (on python 2.7.8) and the current HEAD (both python 2.7.8 and 3.4.1).\nAdditionally @algernon's workaround doesn't actually solve the problem for me, although the error I get in that case is slightly different (infinite recursion):\nhttps://gist.github.com/zenhack/bb9206c6bda76be374db\n. Another test case:\n(defmacro foo [&rest args] `(~args))\n(foo)\nThe error is similar, but with tuple instead of long - which is the type python passes in when you do varargs.\n. I seem to be able to reproduce this with basically anything of the form:\n(defmacro NAME [ARGS...] `(~BODY))\nProvided that the expression BODY on its own evaluates to something sensible.\nIf my understanding is correct, Things like:\n`(foo)\nEvaluate to HyExpressions, but most things, e.g. 0, :hello,  (fn [] 1), evaluate to \"native\" python types. My guess is that in things like:\n`(foo ~(+ 4 2))\nThe (+ 4 2) is being evaluated before the HyExpression is \"built,\" so you end up with native python types wherever you use unquote. To make this work you'd have to convert the native types back into HyExpressions when doing the unquote. I think I've pinned down where this needs to happen, and I'm up for trying to do this myself. A few questions though:\n1. Does that seem like a sensible approach?\n2. Are there already routines for converting native types to HyExpressions somewhere in the codebase, or would those have to be written?\n. I think I've got a fix for this sitting on my hard drive; need to write some tests/clean up the code/sanity check my logic when I've had some sleep, but I'll submit a pr in the next few days.\n. @paultag, ping.\n. ping\n. Quoting Berker Peksag (2014-10-24 17:31:08)\n\nCan't you write this(and probably the other checks) like assert\n   isinstance(wrapped, HyInteger)?\n\nIf that's preferable I can do that when I get a chance.\n. ",
    "stormcoder": "I have it installed system wide but I started it in the environment. Maybe the script for the repl needs to be tweaked?\n. So I installed hy in the env and it works correctly. Problem is that if you're in an env that doesn't have hy installed it is going grab the system hy and things won't work correctly. It might be good to have the start scripts be sensitive to the current env.\n. No worries. I think the project is great. I'm planning on switching over to Hy for work. Tired of the syntax wars with 2.x vs 3.x. This was the last hurtle to allow me to use Hy at work. Now that I know what was wrong I'm good to go.\n. My bad\n. Well damn. I just ran into this.\n```\n(defun testGen []\n  (let [[x 0]]\n    (while True\n      (let [[y 0]]\n      (+= x 1)\n      (yield x)))))\n```\nUnfortunately, the ylet macro doesn't work. I get \n```\nAttributeError: 'generator' object has no attribute 'replace'\n```\n. ",
    "reillysiemens": "I just encountered this issue. Any word on where it's at? I can work around it, but it'd be nice to know if something can be done on hy's end.\n. Yeah, that was definitely the issue as mentioned above. Installing hy into the virtualenv fixes the problem. Here's the behavior I see:\nWith no system-level hy and hy instead installed in a virtualenv made with virtualenvwrapper's mkvirtualenv I get\n=> (import sys)\n=> sys.path\n['', '/home/tucker/.virtualenvs/hy/bin', '/home/tucker/.virtualenvs/hy/lib/python3.4', '/home/tucker/.virtualenvs/hy/lib/python3.4/plat-x86_64-linux-gnu', '/home/tucker/.virtualenvs/hy/lib/python3.4/lib-dynload', '/usr/lib/python3.4', '/usr/lib/python3.4/plat-x86_64-linux-gnu', '/home/tucker/.virtualenvs/hy/lib/python3.4/site-packages']\nIf hy is installed at the system level (i.e. sudo pip install hy) I get\n=> (import sys)\n=> sys.path\n['', '/usr/local/bin', '/usr/lib/python3.4', '/usr/lib/python3.4/plat-x86_64-linux-gnu', '/usr/lib/python3.4/lib-dynload', '/usr/local/lib/python3.4/dist-packages', '/usr/lib/python3/dist-packages']\nThe second example is also true for using a system-level hy inside a virtualenv without hy installed into the virtualenv. Running python3 in the same virtualenv gives the appropriate search path.\n```\n\n\n\nimport sys\nsys.path\n['', '/home/tucker/.virtualenvs/hy2/lib/python3.4', '/home/tucker/.virtualenvs/hy2/lib/python3.4/plat-x86_64-linux-gnu', '/home/tucker/.virtualenvs/hy2/lib/python3.4/lib-dynload', '/usr/lib/python3.4', '/usr/lib/python3.4/plat-x86_64-linux-gnu', '/home/tucker/.virtualenvs/hy2/lib/python3.4/site-packages']\n```\n\n\n\nThis leads me to believe (as @stormcoder suggested) that there might be something that can be done RE sensitivity to the current env. It might also be related to the virtualenv's utter indifference to hy.\n. @Foxboron: Thanks for checking up on this. The behavior I mentioned above it still exactly what I'm seeing.\n. ",
    "signalpillar": "Sorry guys, my fault. Got into own trap - globally installed hy.\n. I think this error happens due to the same reason\n```\n=> (def x (set [1 2 3]))\n=> (def y (set [1 2]))\n=> (def z (set [1]))\n=> (& z y x)\nset([1L])\n=> (apply & [x y z])\n  File \"\", line 1, column 8\n(apply & [x y z])\n         ^^\nHyTypeError: `&' needs at least 2 arguments, got 0.\n```\nPlaying with operator.iadd but it has different signature so seems like reduce required. \n. ",
    "ghufransyed": "There's a version? :-)\nThe hy files are from a fresh fork of the github hy repo. how do I install what's needed?\n. the python setup.py install\n but the\npip install -r requirements-dev.txt\ndid the trick, thanks!\nOn 7 September 2014 23:16, Morten Linderud notifications@github.com wrote:\n\n@ghufransyed https://github.com/ghufransyed use python setup.py install\nThe deps are listen inn\nhttps://github.com/hylang/hy/blob/master/setup.py#L48-53\nyou could also use the requirements-dev.txt by doing pip install -r\nrequirements-dev.txt\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/653#issuecomment-54780141.\n. \n",
    "Tritlo": "+1, I really like the type annotation syntax, with the \"ann\" decorator.\n. I added some explanations on how to use functions with keyword arguments, and squashed them into the original commit.\n. You can define the following macro, and use that instead of let.\n(defmacro/g! clet [bindings &rest code]\n  (setv g!argli [])\n  (setv g!bindings bindings)\n  (while (not (empty? g!bindings))\n    (setv g!argli `(~@g!argli [~(car g!bindings) ~(car (cdr g!bindings))]))\n    (setv g!bindings (cdr (cdr g!bindings))))\n  `(let [~@g!argli] ~@code))\nThen you can do:\n(clet [x 1 y 2]\n      (print x y)\n      (print y x))\n. So, any news?\n. This is actually more powerful than loop, since it allows mutually recursive functions. I'm not sure that this can be moved into contrib, since we need access to the expressions themselves when we convert the return into an exception. This is needed to break out of the stack, and avoid a stack overflow. This also allows us to have tail recursive functions within other tail recursive functions, without any additional overhead.\nThe overhead can definitely slow this down, which that is why we use the from future expression, to avoid the overhead where we can.\n. Oofh. I've been very busy the last year, and haven't had time to take care of this pull request. It's been ready for about 2 years now, and there never seems to be interest in actually getting it into the Hy language. I'll try to look into it over christmas if possible, but I'm afraid that I haven't been following Hy's development for a long time, so I might need some help. Is there still interest for this feature, @paultag @Foxboron ?. I'll see whether I can patch this up real quick.. Line 1796 in compiler.py is failing the flake test, as it is 3 characters too long.\nchanging it to:\nargs, ret, kwargs = self._compile_collect(expression[1:],\n                                          with_kwargs)\nshould do.\nThe pypy bug seems to be pypy itself failing somehow (note how early it is, and in a function that's not in Hy).\n. Keywords were very recently added properly, which is why it's yet not very\nwell documented.\nOn Sat Dec 27 2014 at 10:50:36 AM Greg Knapp notifications@github.com\nwrote:\n\nI was about the raise this same issue when reading the hy docs. keywords\ndon't get much coverage and no examples, just a mention in Hy Models\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/730#issuecomment-68175199.\n. This could be implemented with a decorator and an Exception, like the tail\ncall. I.e. return is a function that raises a \"HyReturnExcption\" and the\nwrapped function just catches this and returns that value.\nOn \u00feri., 30. des. 2014 at 18:31 Christopher Allan Webber \nnotifications@github.com wrote:\nHeresy? But maybe we should provide:\n(defn try-this arg\n   ;; bail out early\n   (return arg))\n ;; a whole bunch of code in-between\n ;; [...]\n ;; The end-of-function return\n (something-something arg blah))\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/739.\n. It would indeed encourage a non functional style, but I still think this\nshould be an option. Maybe a future import, like in #728\nOn \u00feri., 30. des. 2014 at 20:08 Morten Linderud notifications@github.com\nwrote:\n@Tritlo https://github.com/Tritlo you can implement this using the\nreturn AST form. Not really hard, but @paultag\nhttps://github.com/paultag have been against explicit return statements.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/739#issuecomment-68392830.\n. Larme on irc seems to have a solution though.\n. Simpler example of failure:\n\n(defmacro/g! collf2 [liorstring]\n  (if (coll? liorstring)\n    (setv g!a liorstring)\n    (setv g!a [liorstring]))\n    `(print ~g!a))\n(collf2 \"str\")\n. yes, I'm starting to suspect that myself\nOn lau., 24. jan. 2015 at 08:00 Zhao Shenyang notifications@github.com\nwrote:\n\nI think\n(if (coll? routes)\n      (setv g!b [routes])\n      (setv g!b routes))\nshould be\n(if (coll? routes)\n      (setv g!b routes)\n      (setv g!b [routes]))\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/758#issuecomment-71304547.\n. Switch binds to a variable like:\n\n(switch a\n      (= 3 ) (print \" a was three\")\n                (print \"a was not three\"))\nThough guard is almost exactly like cond, except for the use of [] for each cond, code pair, i.e.\n(cond [(< value 5) (print \"value is smaller than 5\")]\n        [(= value 5) (print \"value is equal to 5\")]\n        [(> value 5) (print \"value is greater than 5\")]\n        [True (print \"value is something that it should not be\")])\nwould be\n(guard (< value 5) (print \"value is smaller than 5\")\n         (= value 5) (print \"value is equal to 5\")\n         (> value 5) (print \"value is greater than 5\")\n         True (print \"value is something that it should not be\"))\nBetter example for switch is probably:\n(switch value\n             (< 5) (print \"value is smaller than 5\")\n             (= 5) (print \"value is equal to 5\")\n             (> 5) (print \"value is greater than 5\")\n                      (print \"value is something that it should not be\"))\n. If we can ensure the correctness (at least for the compiler itself) of the\ngenerated python code, this could be done. We'd just ship the generated\ncode, and use that to bootstrap the system.\nOn \u00feri., 24. mar. 2015 at 18:21 Morten Linderud notifications@github.com\nwrote:\n\nWe have discussed if it's possible to generate a .pyc file with everything\nhy needs.\nThat would be interesting.\nOn 03/24/2015 06:41 PM, Nemanja Trifunovic wrote:\n\nWhy not using Hy to develop Hy instead of Python :smiley: ?\nPython sources could be generated for packaging and distribution.\n\u2014\nReply to this email directly or view it on GitHub <\nhttps://github.com/hylang/hy/issues/786>.\n\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/issues/786#issuecomment-85630462.\n. This might be a little late to the party, but:\n\nMathematically, + and 'or' are similar and * and 'and', i.e.\n0 + 0 = 0, 1 + 0 = 1, 0 + 1 = 1 and 1 + 1 != 0 (i.e. 1),\nwhereas\n0*0 = 0, 0*1 = 0, 1*0 = 0 and 1*1 = 1.\nIn formal boolean algebraic ring, this is even how the + and * operators are defined.\nIn math, an empty product is usually defined as a 1, and an empty sum is usually a 0. This is why it makes sense for an empty or to return 0 and an empty and to return 1.\n. I fixed up my pull request #728, and I'd prefer that that would be accepted rather than this one, seeing as it is my code.\n. Hmm. @bowbahdoe, do you understand the error that we get from travis?. Ok, I think I found the bugs. The main logic for this was written in Hy itself, but apparently the syntax for try catch and defining classes had changed. I fixed that, and I think it'll pass now.. Ok, I fixed the bug for expressions with '.' in them (and a test for that), and added some documentation of the drawbacks, to clear up confusion on why it is gated.. So, I fixed the bugs from language.hy.\nI tried turning it on for all files, but ran into some bugs due to macros, specifically that it tries passing more keyword arguments than desired during macro execution. I'll look better into it soon, but if you could help with finding a way to disable TailRec for macros, that would be nice.. Thanks @kirbyfan64.\n@rwtolbert good point. We might name it \"extension\", since this is in the vein of a Haskell language extension in that it doesn't change the language, but makes new things possible. The extension could then of course be made native and on by default at some point.\n. @adamfeuer I've given you access to my fork of Hy. You can finish the work there and push to master to update this PR.. Sure, if that is what you prefer, as long as my original commit is still\nthere :) Just ping me in an issue on your fork if you have any questions :)\nOn Thu, 15 Jun 2017 at 02:53 Adam Feuer notifications@github.com wrote:\n\n@Kodiologist https://github.com/kodiologist @Tritlo\nhttps://github.com/tritlo I think I'd rather work on my own fork - will\nthat be ok?\nI cloned from hy/master into my account adamfeuer/hy and then merged\ntritlo/master into it. Then I fixed the merge conflicts.\nI'm working on getting all the tests running.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/hylang/hy/pull/1166#issuecomment-308598045, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/ABlw16jGLS46Lwl2l8x2WUrzvdQND1BQks5sEIBwgaJpZM4LIKac\n.\n-- \nMatth\u00edas P\u00e1ll Gissurarson\n. \n",
    "philiparvidsson": "This needs to be fixed as it is still an issue. I did some manual \"binary search\" by deleting chunks of code in a source file until finding the issue, but that is not always viable either. How about at least outputting the file, row and column of the previous token!?. So what's the status here? Why can't we bring back let for some sane scoping? Couldn't you just del varname at the end of the scope?. I usually use def for constants and setv for variables. Could we change def to prevent further assignments? Absolutely breaking change but we're still pretty early.. Perhaps it could be combined with some other character denoting it to be a boolean defaulting to true. Some ideas:\nlisp\n(func :a? 123)\n(func :a. 123). yes, we definitely want to allow hy expressions:\n(setv a 3 b 3)\n(print f\"the sum of {a} and {b} is {(+ a b)}\")\nI think we have the advantage of being to bring this feature back to python 2.7 (by generating old code), ie:\na = 2\nb = 3\nprint \"the sum of {} and {} is {}\".format(a, b, a + b)\nit's very close to the code that needs to be generated for python 3.6:\na = 2\nb = 2\nprint(f\"the sum of {a} and {b} is {a + b}\")\nthat is, we just insert the generated code in the {} in the string and replace the .format call with an f prefix.. ",
    "svetlyak40wt": "Is there a way in hy to write a function which returns nothing? If so, let macro could analize if there are yields in the args tree and if there are, then return nothing.\n. Another way is to pretend all structures are immutable and don't use setv.\n. I disagree. Why Hy translates my integers into longs on python 2.7?\n\nOn 02 \u00ee\u00ea\u00f2. 2014 \u00e3., at 8:59, Abhishek L notifications@github.com wrote:\nLove issues that close themselves :)\n\u2014\nReply to this email directly or view it on GitHub.\n. Paul, thank you.\n\nBut idea was to convert NEWS file into a standart debian changelog and then get rid of the NEWS and this script. What do you think about this?\n. By the way, I've checked under pypy 4.0.1 and hy 0.11.1, the problem is similar though line numbers are not:\nThe Header\nDo something useful here\nTheFooter\nTraceback (most recent call last):\n  File \"/Users/art/projects/hy-macros-problem/pypy-env/bin/hy\", line 9, in <module>\n    load_entry_point('hy==0.11.1', 'console_scripts', 'hy')()\n  File \"/Users/art/projects/hy-macros-problem/pypy-env/site-packages/hy/cmdline.py\", line 347, in hy_main\n    sys.exit(cmdline_handler(\"hy\", sys.argv))\n  File \"/Users/art/projects/hy-macros-problem/pypy-env/site-packages/hy/cmdline.py\", line 335, in cmdline_handler\n    return run_file(options.args[0])\n  File \"/Users/art/projects/hy-macros-problem/pypy-env/site-packages/hy/cmdline.py\", line 210, in run_file\n    import_file_to_module(\"__main__\", filename)\n  File \"/Users/art/projects/hy-macros-problem/pypy-env/site-packages/hy/importer.py\", line 78, in import_file_to_module\n    eval(ast_compile(_ast, fpath, \"exec\"), mod.__dict__)\n  File \"check.hy\", line 1, in <module>\n    (defmacro run-section [header body footer]\n  File \"check.hy\", line 1, in foo\n    (defmacro run-section [header body footer]\nZeroDivisionError: long division or modulo by zero\n. The same for pypy3 2.4.0:\nThe Header\nDo something useful here\nTheFooter\nTraceback (most recent call last):\n  File \"/Users/art/projects/hy-macros-problem/pypy3-env/bin/hy\", line 9, in <module>\n    load_entry_point('hy==0.11.1', 'console_scripts', 'hy')()\n  File \"/Users/art/projects/hy-macros-problem/pypy3-env/site-packages/hy/cmdline.py\", line 347, in hy_main\n    sys.exit(cmdline_handler(\"hy\", sys.argv))\n  File \"/Users/art/projects/hy-macros-problem/pypy3-env/site-packages/hy/cmdline.py\", line 335, in cmdline_handler\n    return run_file(options.args[0])\n  File \"/Users/art/projects/hy-macros-problem/pypy3-env/site-packages/hy/cmdline.py\", line 210, in run_file\n    import_file_to_module(\"__main__\", filename)\n  File \"/Users/art/projects/hy-macros-problem/pypy3-env/site-packages/hy/importer.py\", line 78, in import_file_to_module\n    eval(ast_compile(_ast, fpath, \"exec\"), mod.__dict__)\n  File \"check.hy\", line 1, in <module>\n    (defmacro run-section [header body footer]\n  File \"check.hy\", line 1, in foo\n    (defmacro run-section [header body footer]\nZeroDivisionError: division by zero\n. @kirbyfan64 you said this never heppened on PyPy for you. Which version of pypy are you using?\n. Checked today how it works now. I've installed HyLang from fb9a97a7e5310eac1ae356d2571287b25832f949 commit.\nSeems, everything is fine now under PyPy 2.4.0, 4.0.1 and 5.0.1.\nBut it still broken for CPython 3.5.1 and 2.7.10.\n. @Kodiologist scripts/reformat-changelog was intended to reformat NEWS file into more conventional ChangeLog in debian format, where a version number is followed by it's description because a line like Changes from 0.12.1 says nothing about what current version is. Whether it is 0.13.0 or 0.12.2.\nThat was the purpose \u2013 to use this script \u2013 reformat changelog and drop NEWS file.\nBut I see, nobody cares except me :(. Actually not. What read-lines-from-file does is return a function without arguments which on each invocation return a next line from a file.\n. I used it for (pdb.set_trace) debugging. It still could be useful.\n. No, this function is passed around during recursive calls, and it is much more convinient to call just (next-line) than as (next-line.next)\n. ",
    "raymestalez": "Oh, awesome, thank you!\n. ",
    "ekaschalk": "I noticed apply is also not shadowed and didn't see any reference to it in #1261.\nI have several use-cases. One such is hypothesis which exposes .map as a way to apply map to a strategy, but exposes no .*map.\nSo with a reader macro curry as #$ I cannot do:\n(->> x\n  (.map #$(apply (fn [x y]))\nAnd so I instead shadow apply myself.\nIs there any reasoning not to have all such hy functionality shadowed? Is there any list of hy api components not availible as functions?. It's useful when you have a higher-ordered function that you want it to apply the passed function variadically (like *map).\nNone of the examples are simple but the use-case I have is similar to:\n```\n(-> [[[x1 x2 ...] [[y11 y12 ...] [y21 y22 ..]]]\n         ....]\n;; dont have access to *map\n   (.map #$(apply (fn [x unpack] (+ x (reduce + unpack)))\n(= [[x1 x2 y11 y12 y21 y22 ...]\n        ...])\n```\nAnd then another I have a function that applies a function to a list. I want to merge the lists but merge-with is variadic so I would do (func #$(apply merge-with))\nThe alternative to apply here is uncurry like in Haskell, however variadic functions are often easier to read, especially so with lambdas, than their uncurried counterpart.. My apologies it should be -> thread first.\nHypothesis generates data with the following shape. So it isn't actually a list, it is a function that generates a list with that shape. So to modify the generated list you can't map over it as it is a function, not a list.\nSo this generator exposes .map for updating the to-be-generated result, but no .*map for variadically updating the to-be-generated result.. Hopefully this illustrates more clearly:\n```\n(setv stuff [[[1 2] [[1 2 3] [1 2 3 4]]]\n             [[2 3] [[2 3 4] [2 3 4 5]]]])\n(tuple (map (fn [x] (sum (get x 1) (get x 0))) stuff))\n\n\n\n([1, 2, 1, 2, 3, 1, 2, 3, 4], [2, 3, 2, 3, 4, 2, 3, 4, 5])\n\n\n\n(tuple (*map (fn [x unpack] (sum unpack x)) stuff))\n\n\n\n([1, 2, 1, 2, 3, 1, 2, 3, 4], [2, 3, 2, 3, 4, 2, 3, 4, 5])\n\n\n\n(tuple (map (fn [x unpack] (sum unpack x)) stuff))\n\n\n\nTypeError: _hy_anon_fn_1() missing 1 required positional argument: 'unpack'\n\n\n\n(tuple #$(apply map (fn [x unpack] (sum unpack x)) stuff))\n\n\n\nname apply not found\n\n\n\n(tuple #$(shadowed_apply map (fn [x unpack] (sum unpack x))) stuff))\n\n\n\n([1, 2, 1, 2, 3, 1, 2, 3, 4], [2, 3, 2, 3, 4, 2, 3, 4, 5])\n```\n\n\n\nNeed *map to apply it otherwise need to get the components. . Oh that's a very nice feature of hy, thanks! Knew it did matching in assignments (like python) but not parameters (unlike python). Is this documented anywhere, I don't see it in docs for defn or through a search.. Thanks it works but it is still not a 1-1 correspondence with Python as the build defined above could be called eg. build() while hy requires explicit (build :target None).. It installs, but the reader/sharp macros aren't working? Says version: 0.11.0+549 and neither defsharp/defreader are defined in the repl.. I use toolz as much as hy builtins, +1 here. It would be great to see eg. valmap and variants first-class.\nFYI there are some differences between toolz and hy overlap. toolz.get has reversed arguments order compared to hy.get, I currently use both gets depending on the form. Also merge-with accepts **kwargs and toolz.do is different than lispy do.. Can cut be shadowed as well?. Bracket string literals are now fully supported in hy-mode master branch.. I also wanted to add, is it possible to have something like IPython's %pdb toggle in hy repl (when error is encountered set trace and pdb at point)? I have no idea how involved that feature would be.. I'm trying to support macros in eldoc-mode.\nI was working through hy.compiler and noticed the @builds forms don't have docstrings/any extractable arguments.\nIf they had docstrings I could do: (. (get hy.compiler.-compile-table \"try\") --doc--) to extract them for Emacs and they could contain the argspec as a string within the docstring.\nAlternatively I could do this emacs-side and maintain such a table of compiler forms and their eldoc representation, though it would make it more difficult to keep current.. Sort-of overlapping is #1441 for inspecting their arguments. Ideally each (or the whole) would take another argument for the @builds function's arguments, or the more involved adjustment Kodiologist mentioned of rewriting @builds functions to take their arguments rather than an expr.. This issue can be closed unless you specifically want Hy itself to have full completion.\nI've implemented full (ie. same as python/jedi) autocompletion as a Hy module emacs-side.. >  roll-your-own syntax highlighting\n@kirbyfan64 It doesn't, it takes highlighting from python-mode and takes results from applying font-lock-mode.\n\nIf emacs can hide this\n\nEmacs can, I'm processing the raw string and transforming it to whatever I want, not just applying face properties. A command-line flag might be reasonable in this case, like --spy-emacs that uses specified UUID to start and end a python block.\n\nYou can already distinguish stdin from stderr\n\nThat sounds complicated, an emacs flag would be much easier.. @kirbyfan64 My apologies. If you work in emacs, feel free to suggest features or things you would like improved. I'm working on improving hy's tooling.. This works for delimiting --spy. I have it setup so you can replace the uuid with any string of your choosing, or replace with nothing. It doesn't solve color codes for erros on Windows however.. See https://github.com/hylang/hy-mode/commit/64397082d5ced6b1dc01129601ef84b4397c8b6c\nSet hy-shell-use-control-codes? true to have font-locked python blocks.. If you want stderr vs stdout italicized, then implementing that as another UUID delimiter would make it trivial, otherwise I will table that addition for now.. It's not that it's impossible to use pipes here (I think), it's that I can't leverage current work. comint-mode provides some nice utilities, in particular hooks for modifying the process output. There are a number of other low hanging, high value fruit (like full auto completion and linting integrated) that I'd like to attack before going into any particular feature in too much depth.. I'm considering representing shell output similar to ipython, namely the prompt input has In [x]:, stdout is printed, and then the return is Out [x]:.\nIn this case, we could have an additional response, say Spy [x]:, with the python representation.\nWhat if the REPL output was of this form? The UUID delimiter would then be unneeded.. I've been trying to determine how ipython handles it in Emacs.\nPrompts are detected by comint-prompt-regexp, namely a regex, on which a match occurs, comint performs bookkeeping and start/end markers and etc... \nIn print(\"In [38]: print(\\\"hi\\\")\"); 1+2, somehow it knows that the printed line is not a prompt. Similarly, doing so with Out instead yields no issues (but interestingly the Out gets prompt output highlighting while the In gets no prompt highlighting).\nI'll keep investigating. I'd ideally like to use pipes/sockets, but that means reimplementing comint-mode (for example cider-mode doesn't use comint).\nAnother alternative is some control code/unprinted-but-there character in front of the [Spy] block. I'm not familiar with such codes, if that might be reasonable or not.. Actually outputting Spy [] right after the prompt will work. The first spy unambiguously identifies the beginning. Since it is python source, a newline Out [] block can only occur there if captured in a string, which I can check, so we can always identify the end of the spy block.. I meant for the x within In/Spy/Out[x]: stuff to be the prompt number like ipython. We could use the old prompt right arrow or the In, but the Spy/Out would be required.. I misunderstood your example, you're right the colon should do it for source blocks. . I haven't, and I assume no one else, has worked on it yet.\nDoing the In/Spy/Out[x] in the shell would be nice on its own, but additionally allow for significant improvements emacs-side, including:\n\nSyntax highlighting Spy output.\nConcatenating spy (also in/out) output for things like sending files/regions/more than one form at a time.\n\nI'm somewhat stuck, unable to merge the dev branch https://github.com/hylang/hy-mode/tree/new-shell-2 containing nice stuff like send-defun-to-shell until this is addressed, either by someone else or me.\nI consider this tied to other (imo also important) shell usability improvements like formatting+coloring errors (I believe lexer errors only ones covered currently?), filepaths, and other traceback components.\nThey could be tied together in a single issue outlining shell improvements.\nThe code in this PR isn't relevant anymore and could be considered for discarding.. Fixed your comments.. At the moment I'm referring to just eldoc. Because it's a lambda, unlike currying, I cannot make assumptions on its further sexps. In the tag macro case eldoc works already and the funcall case it can be made to work as a special case (by prepending \"curried\" to the eldoc output of the eldoc for the second sexp).\nI dislike xi as a macro and think implementing it as a compiler construct like was done with the unpacking generalizations would be better. Much quicker/easier would be just porting curry.. One reason is the above case.\nAnother is a bit more vague/personal - that xi breaks the rule that you can look at the first sexp of the form and know what's happening. The code being \"conceptually evaluated\" starts at the second sexp. This often results in a double-take whenever I glance at code I wrote using it. \nThis is relative but to me currying is a fundamental operation on par with eg. unpacking. I feel a tag macro/compiler construct is the natural representation as the form is not polluted by the curry call. Even better the x1..xn would be something special/that stands out like clojure's %1...%n. Then we could possibly highlight the % (or whatever character) args to make obvious the form's intent. with-decorator as #@ isn't all that different imo.. You're right, I didn't think through the compiler construct portion (I meant removing the tag part like %(func %1 %2) which might not be worth the trouble).. > How do you require a tag macro from another module?\nUnless I'm misunderstanding, require works for tag macros already, I certainly import them in my projects. I require them via * though, I'm not sure if they can be required by name.\nAlso, a good time as any to bring up that require isn't transitive unlike import. The effect of this is that I maintain a macros.hy file which requires the anaphorics, however in every file which I do (require [src.macros [*]]) I must require the anaphorics once again.. > How should it work though?\nI'd suggest it be the same as curry but pass arguments in reverse order. That operators are n-aray doesn't really matter, it's still well-defined.\nI wasn't aware that partial works with keywords. However curry is still nicer as it collapsed partial and partialmethod.\nOverall though the new xi syntax is nice enough that I'm not convinced flip is worth it.. With the new %i and specifically the `%* construct curry/flip aren't needed, this can probably be closed.. > keep the position information of expr around\nYou are referring to [\"start_line\", \"end_line\", \"start_column\", \"end_column\"] in HyObject right?\n\ncaution against writing docstrings \n\nWe gain a lot by having the docstrings, if you haven't yet check out eldoc-mode and autocompletion that also uses eldoc, it's getting pretty great. Right now it is pretty easy to write the docstrings, it took very little time to update all of hy.core. I'd rather not wait on the html sync which will be more involved.. I'll look to fix the mangling - but isn't completing is-numeric but not is_numeric intended? Replacing the underscore with hyphens was already being done. As far as autocompletion goes - I only want to present the hyphenation as a candidate.. Yes you're right I missed the question mark.. Is hy.extra.reserved.names even used anywhere? Trying to use it by sending it to a shell will throw AttributeError: 'function' object has no attribute 'kwlist'.\nAnyway, it has overlap with the current completion but the current completion catches all symbols. Simply importing and using hy_symbol_unmangle is sufficient.. I've added support for completion of symbols with module member access like pd.DataFrame.add or itertools.tee.\nI've also added tests for completion, there didn't seem to be any before.\nIt is strange that _hy_macros remains an empty dict python-side. This means I can't test that macros complete in python tests (though they do complete in Hy as it is nonempty).. Due to complexities with the namespace, I'm reimplementing completion entirely as emacs-side setup code and scrapping this PR.\nThis is how Eldoc works, where a simple (.eval builtins obj (globals)) plus a macros/compiler-table check catches everything. Importing the Completer breaks the globals containing the imports.\nIt also lets me skip the readline specific functionality that's irrelevant and format the return results in a manner that allows skipping regex extraction of candidates from printed list.\nMore importantly I can also then extract the type of the object (eg. class/func/variable/keyword/macro) in some manner and have autocompletion display the type of the candidate, like python and all other autocompletion implementations.. Do you have thoughts on whether to highlight the %i? I don't know how clojure does it.. I meant \"does and what face\", I can check into it.\nA middle-ground is to implement is as an option, your call whether to enable it by default or not.. Ok thanks a simple (hy.eval '(import hy.macros)) in the module being tested does the trick.. Is there a better way to access all defined macros? doc takes the same approach (and has the same error on a second run). It's for code introspection for Emacs, not sure if that qualifies as public use.. It is a builtin threading macro in clojure, along with -> and cond->.\nhttps://clojuredocs.org/clojure.core/some-%3E\nIf a form evaluates to None then short-circuit the thread and return None.\nEg.\n(assert (none? (some-> None inc)))\nand\n(assert (none? (some-> 1 ((constantly None)) inc))). > It's a pain to import these things every time.\nThis is exasperated by require not being transitive so one cannot just collect all macro requires they use project-wide in a single module.\n\nHy harder to learn.\n\nI see your point with core functions like trampoline and with-in-string.\nI'd argue that some-> is core as the use-case its addressing, the same as the Maybe monad, is a core concept.. > couldn't you write a macro that expands to all your require statements?\nYes I realized that while writing that comment. It's a bit funny to have such a macro though.. Somewhat related - how do you all feel about implementing ... as an alias for Ellipsis?. The new mangle has different behavior on the empty string, namely an assertion error whereas before it returned back the empty string.\nIs there a reasoning for this? Note that unmangle on an empty string doesn't fail, returning back an empty string.\nIf not, the blank string assertion error would be helpful to have dropped.. Have you all seen: https://github.com/ekaschalk/jedhy? Example usages here: https://github.com/ekaschalk/jedhy/blob/master/tests/test_models.hy\nIt performs completion on all constructs (macros, compile table, module members, etc...), among other actions.\nI use it in the develop branch of hy-mode, pending merge while I'm still learning how to manage its auto-installation.. It would be straightforward to collapse the relevant bits to a single module. It would introduce a dependency for toolz however http://toolz.readthedocs.io/en/latest/.\nReplacing jedhy's completion isn't necessary, completion comes more-or-less free as a result of its other capabilities.. I dislike that this change applies to fn as well. One very common usecase is mapping a lambda over an enumerate. Less commonly, accumulation of multiple arguments.\n```\n;; Mapping over an enumerate\n(map (fn [[idx arg]]\n       (if arg idx))\n     (enumerate foo))\n;; Reductions\n(reduce (fn [acc [destruct n-arity args]])\n        [[foo bar baz] [a b c] ...])\n``. OK so it would be(lfor [idx arg] (enumerate foo) ...)` if I'm reading right.\nI'm still hesitant as I don't see how to fit the new-style comprehensions into the threading macros.. It never occurred to me to use a comma. Your post gave me the idea for a ,map variant. \nAnyway it would be useful for at least me.. Also FWIW I'm thinking about adding a Hy reciprocal to clojure-enable-fancify-symbols option (by default disabled).\nThen the tuple tag macro can look pretty sweet:\n\nI already do this in my code.. But then you have to type (and other's see): \u29bb instead of #,. If it isn't clear, the commented text is the actual text in the buffer, the below is how it's seen.. Sure I would, but plenty wouldn't, and this way doesn't enforce anything on the reader. Now it's just an option to set on.\nImagine if in github this image of my code was the real text:\n\nI only bring it up here because of the cool translation to #,.. Yea there are a few implementations of LSP for emacs, I've went through them before. The emacs-specific work for integrating LSP components is trivial.\nI've considered rewriting jedhy to use the LSP. But the gains for Emacs users are minimal, rather it would enable pleasant Hy development for VSCode, vim, and others and centralize ide development.\nMaking Hy as pleasant as possible in Emacs specifically is my goal, and there is work I rate higher before a LSP rewrite.\nIf someone wants to write an LSP, I recommend working with me to refactor jedhy rather than start a project.. Few comments.\nOn outlines:\n\nOutlines in-general are not ;;;-styled. Only emacs-lisp has that and\n   would've been changed if not for historical compatibility (see\n   outline-regexp). Outlines in Hy are ;; *-styled. This is the same for\n   clojure-mode and common-lisp-mode.\nI don't think it should be mentioned or recommended explicitly as it is Emacs\n   only. \n\nOn #_ usage:\n\nThis recently has syntax highlighting support. But no editing support, I see\n   (un)-capturing the current/next/prev/containing-defun forms in #_ as\n   possibilities.\n\nOn indentation:\n\nIf indentation is being finalized, then which symbols yield special\n   indentation should be finalized. I'm not sure if this list should be\n   referenced in the style guide, but at a minimum it should correspond to\n   Emacs's defaults (eg. setv isn't specially indented).\n\nOn - vs _:\n\n\nI really don't like __ prefixed dunders/private methods. One of my favorite\n   parts of lisp not having to reach for the shift key as often. \n\n\nLess joking, why is the line drawn at dunders? What about imports, they\n   reference specific files that are underscored. I'd prefer us to go all-in on hyphens.\n\n\nI don't find the negative argument convincing. (+ -foo 1) doesn't add the\n   negated foo, and this is imo obvious.\n\n\nPerhaps fix a recommendation for unused arguments (setv [x -] x-y) as I\n   could see _ being a reasonable choice.\n\n\nOn everything else:\n\nI think a very short section on mangling might be appropriate. It is relevant\n   when designing hy code that is to be imported and ran within python.\nDTRT acronym I had to look up, wasn't clear to me.\nNot personally a fan of leading with the koan.\nTypo, your coding style section has (setv square? [x] ...).\nI don't agree with 100 char limit. I'd rather defer to PEP8 at 79 lines.. Ah that's a silly mistake, thanks for pointing that out. I suppose I will switch to -- instead.. > OK, so remove the ;;; and ;;;; styles from the guide altogether then?\n\nI think so, the people gaining utility from that, wouldn't need to be told about it.\n\n_\n\nOur existing support is very similar to Clojure's. I was considering a binding that would, say, insert (or remove) a #_ before the containing form at point. Simple QOL stuff, not sure if Clojure has anything like it, but I don't think that matters.\n\nI hope I got the \"special indent\" terminology right here.\n\nAnything other than a normal indent is special. A normal indent is right now: no args on same line of form opener -> 1+ indent used, args on same line of opener -> indent at first arg.\nAnything at the same depth as the defn is indented specially (1+ regardless if whether args on same line as defn or not). Indentation is entirely determined by the symbol opening the form (atm).\n\nIf you want to be that complete, we should probably go over all the special forms one-by-one. And the core macros too. Maybe even extra and contrib macros.\n\nI think this is a useful discussion to have. The sooner we finalize indentation, the better. . > We're still using punchcards. \nI choose my zoom level on my laptop/desktop to fit 2/4 windows open respectively side by side assuming 80 characters. I'm sure I'm not the only one who bases their layouts with that assumption.. @alphapapa Hy can be used for serious projects, but you have to consider the tradeoff of increased productivity versus handling breaking changes when they occur (relatively often up to this point, but no fix that difficult). I use it at work for a medium-sized algorithm at 2800+ commits now, which I assume is by far the largest Hy project. This project is a solo one (though this is changing) - so I cannot comment on team reception.\nWas it worth it? It's made work unquestionably more enjoyable and, now, quick, but the startup cost associated with building out hy-mode to support myself muddies it.\nOnce let and friends are solid and a few key issues are resolved, I think Hy has a chance at becoming more mainstream.\n@gilch @Kodiologist I'm building a front-end demo-only to my work through Django and am debating whether to use Hy for it.\nI'm already aware Hy can be dropped in /almost/ seamlessly, example repos exist and I've done so myself in the past already. I'm more concerned about integration with container and compute technologies, which I know very little about.\nIs there any technology that Hy's approach is not compatible with?. I misread the documentation, I've never used if with more than one condition. I'll fix that up.. Fixed it.. ",
    "davexunit": "Complete Hy noob here, but why does \"explicitly create and call a lambda\" not have the same issues as let, given that let in every Lisp I know can be implemented as syntactic sugar for the corresponding lambda expression?\n. ",
    "kozross": "@kirbyfan64 This will only check syntax - not invalid imports, undefined functions, etc. I guess that stuff is all done at runtime, which basically means that I'd have to write a linter for Hy if I wanted that stuff checked. Well, I guess I can do that - in Hy!\nI have three ideas for names:\n1. hylite (oh god, the puns, plz stop)\n2. crazyrap (source)\n3. back2school (source)\n. ",
    "rakete": "I would like to have error checking for hy with flycheck as well, so I tried to make pylint work with hy:\nhttps://gist.github.com/rakete/2699be18d4218685c66d\nThis seems to actually work. Pylint just uses an python ast, and it takes one created by hy just fine. Some of the warnings don't make much sense though and I have not spend a lot of time playing with different (and more complex) hy sources yet. Basic things like getting told when I use an undefined variable or unused arguments and stuff like that are already a huge success for me.\n. ",
    "xificurC": "Is there anything done on this part? It's marked as good-first-bug but it seems like a bigger project (to write a full-blown linter). @gilch that indeed takes the time down to the same as python. The fact that one needs to now compile makes it a little bit less convenient, nevertheless the drastic startup time improvement is worth it. Thank you for your input, I will close the issue.\n. Hey, great to see more action on this. Thanks!. See https://github.com/sfermigier/awesome-functional-python for a list of interesting libraries. I started using pyfunctional in a python codebase and worked quite well for now. Not exactly a hy candidate though I think.\nMy 2 cents - don't bring in another dependency. I like it when the core is lean and mean.. Thanks for the quick response. I'm not sure where and how to get a cloak. But if the problem is only the one web client I don't mind switching to another one. Unfortunately I have to go through a web client since the IRC ports are blocked here.. @paultag thanks, I can connect with The client again. Hope for no more spambots. @paultag I can use freenode's web irc client, sure. The only reason I used kiwi was because when I lock my PC I get disconnected (no idea why exactly) and kiwi reconnected me automatically.. Discussion on IRC landed that this works\n(apply hy.core.shadow.+ [1 2 3])\nUp to discussion whether this is a bug or a feature :). > I think twice a year is a good schedule, so I'm aiming to release 0.14.0 in January.\ntoo bad, with the lively development I could even take monthly. Thanks for the quick response!. I'm using hy in some company scripts, I can't just reference master blindly :). I'll have to read up on that. Thanks. ",
    "Singletoned": "Really sorry, but I didn't realise until you put me in authors that I had done this from my work computer.  It's probably safest to revert this and I'll do it again from home.\n(I'm sure I'll find more things to fix as well.  I'm pretty excited about Hy.  I'm reading through the docs with the hope of using it for all of my personal projects.)\n. That would probably be fine (it's singletoned@gmail.com).  I was just concerned about any problems arising from copyright etc, because of it being from work.  But realistically I doubt anyone cares.\n. ",
    "typedweb": "Ok, now i see what's going on.  Incorrect for the code, but correct for hy ATM.  Thanks.\n. In Common Lisp a loop builds a 'nil' block and break is implemented as (return-from nil ...).  This could be simulated in Python by putting an enclosing try/except block like so:\n(while condition\n    (if something\n        (break)))\nwhich would compile to something like:\ntry:\n    while condition:\n        if something:\n           raise Break\nexcept Break:\n    pass\nThat could help fix the scoping problem but would require all loop constructs to use such a wrapper scheme. The compiler would have to stop using the regular python 'break' statement and always use the 'raise Break' construct to exit the loops. This also can be nested and will only break out of the innermost loop as well.\nCould this help in this situation?\n. Here's some example code I was working on to demonstrate the concept:\n``\n(defmacro block (name &rest body)(progn\n     (defclass Block (BaseException)\n       ((--init--\n     (fn (self value)\n         (setv self.value value) \n         nil))\n    ))\n     (defclass ~name (Block))\n     (try (progn ~@body)\n      (catch (e ~name) e.value))))\n(defmacro return-from (block-name &optional return-value)\n  `(throw (~block-name ~return-value)))\n(defmacro break2 () `(return-from Loop nil))\n(defmacro while2 (condition &rest body)\n  `(block Loop\n     (return-from Loop (while ~condition ~@body))))\n(defmacro for2 (var-in &rest body)\n  `(block Loop\n     (return-from Loop (for ~var-in ~@body))))\n(while2 true\n    (let ((y false))\n      (if (not y)\n          (break2))))\n(for2 (i [1 2 3 4])\n      (let ((y false))\n    (if (not y)\n        (break2))))\n```\n. ",
    "iKevinY": "@Foxboron I think it's a distinction between commenting on the commit in my fork vs. commenting on the diff itself (as part of the pull request).\n@berkerpeksag Sure, I can get around to doing that. I'm actually a lot more familiar with that style of markup but I wasn't sure if there was a specific motive behind the way it's currently formatted.\n. Caught a few more changes on my second pass through the documentation. I believe it matches up with CPython's documentation guidelines now \u2013 at least the majority of it does.\n. Added the aforementioned changes and rebased.\n. No worries! Once I learn more about Hy's internals (hopefully in the near future) I'll look to hack on some things that are more codebase-related.\n. @Foxboron Those changes look good to me. I wanted to avoid making any drastic changes to the formatting of the document in case it was chosen for certain stylistic purposes, but I agree with how you've reformatted it. Your introduction to Hy would also be a great addition since I feel the README is a little enigmatic in its current state.\n. @Foxboron You could always use a blockquote if you don't like the code block implementation:\n\nI wrote Hy to help people realize one thing about Python:\nIt's really awesome.\nOh, and lisps are neat.\n\u2014 Paul Tagliamonte, Hy creator & BDFL\n. @Foxboron Haha, I wouldn't say the PR has derailed quite yet \u2013 it's still README-related after all.\n\n@berkerpeksag Done!\n. @Foxboron Thanks for the merge! I've left a comment on the Gist.\n. I agree with migrating the style guide to the main Hy documentation; it seems a little strange to have a separate repository containing a single Markdown file just for the style guide. I can work on this migration if no one has already started doing so.\n. Done! Having strange issues with some code block formatting, though.\n. Oh whoops, I forgot to put the code blocks on the same indentation level as the bulleted list items \u2013 changing that right now. I was more concerned with the fact that the square brackets in the lines 1 and 2 of the above code block don't line up properly, though.\n. All credit for the style guide content goes to @theanalyst!\n. Well, I did a little digging and it seems the alignment issue stems from the fact that the \"let\" is bolded, and the bold text is wider than the normal text. Using Web Inspector to manually set the font weight of \"let\" to normal causes the lines to align properly. Not sure if there's anything we can do about this.\n. Oh, I just used the name that the artist gave the image on DeviantArt. If Cuddles wants to be addressed as a cuttlefish rather than a hacker, I can change it.\n. ",
    "NathanW2": "Woot! Thanks.\nOn Mon, 8 Dec 2014 5:21 am null notifications@github.com wrote:\n\nNice one! Thanks, @NathanW2 https://github.com/NathanW2 !\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/pull/705#issuecomment-65949596.\n. Is it worth wrapping it in a new exception type when IOError should already do what is needed?\n. If this looks good I can add a unit test for it. \n. Added a unit test. Created a new test_files folder with a test file that gets run.\n. No worries. Fixed those pep8 errors.  Just going to see what travis says. The tests pass on my machine.\n. Squashed them real good :P\n. Thanks\n\nOn Sun, 1 Mar 2015 3:07 am Berker Peksag notifications@github.com wrote:\n\nThanks!\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/pull/773#issuecomment-76534822.\n. \n",
    "mcktrtl": "I thought it was something along those lines (hence the troubleshooting with other-verb) but didn't make it all the way. Thanks for the help!\n. ",
    "dmarteau": "This occurs when replace is called with HyList containing bare type:\n(defun getn [&optional [n 0]] `~n) ; here n is int , not HyInteger\n(defmacro test [] `[~(getn)]) ; should resolve to: [0]\n(test)\nResult in:\n...\nAttributeError: 'int' object has no attribute 'replace'\n...\nNote that adding wrapper for HyList in macros.py may solve the issue, i.e adding line like:\nHyList: lambda l: HyList(_wrap_value(x) for x in l)\n. ",
    "unmerged": "Not sure if this is the correct/best way, but seems to be minimum changeset that fixes these problems.\n. Added and squashed tests. Testing for this stuff is not as trivial as it seems...\n. If i remove it, \"test_unicode_compile_error\" fails with UnicodeEncodeError.\ncolored.yellow() returns 'clint.textui.colored.ColoredString', which calls str() when concatenating result with itself and fails.\nMaybe there is more proper way to fix it, but I don't understand how.\n. You want current HyTypeError.__str__() code moved to HyTypeError.__unicode__()?\nI think unicode_literals can be removed from errors.py, but then we get \"impllicit coercion\" here too. You mentioned it elsewhere, but I'm not sure what to do with it. Sprinkle 'u's everywhere? Can you please link to some documentation or examples of handling unicode in python2/3 in correct and compatible way? I think I got myself in something I'm not qualified to do :)\n. Will do\nassert e.message == \"expanding `\u2764': Exception()\"\ni didn't want to depend on exact message.\n. The idea is to trigger HyTypeError.__str__() code which fails. Here there is also a problem with depending on exact message formatting...\n. Sorry, which line exactly?\n. But what if this code runs without error? Of course, this case should be tested elsewhere, but still. I'll remove it if needed.\n. Then, we should keep\n    assert False\nbecause here it's correct behavior to fail with exception.\nShould I push my recent changes as separate commit? Or should I squash them into current?\n. About\npython\ndef __str__(self):\n    return self.__unicode__().encode('utf-8')\nThis will work in python2 and break python3.\nI've found this in your links http://python-future.org/compatible_idioms.html#custom-str-methods\n``` python\nfrom future.utils import python_2_unicode_compatible\n@python_2_unicode_compatible\nclass MyClass(object):\n    def str(self):\n        return u'Unicode string: \\u5b54\\u5b50'\n```\nThis looks like more clean way to do it. Should we add dependency or just copy-paste this decorator?\n``` python\ndef python_2_unicode_compatible(klass):\n    \"\"\"\n    A decorator that defines unicode and str methods under Python 2.\n    Under Python 3 it does nothing.\nTo support Python 2 and 3 with a single code base, define a __str__ method\nreturning text and apply this decorator to the class.\n\"\"\"\nif not PY3:\n    klass.__unicode__ = klass.__str__\n    klass.__str__ = lambda self: self.__unicode__().encode('utf-8')\nreturn klass\n\n```\nfuture module is MIT licensed... and I can't find any other use for it now.\n. Looks like unittest2 and @unittest.skipUnless(PY3, \"Requires python 3\") should work in theory with nose and all pythons. But in practice I'm having troubles getting it to work.\nhttps://pypi.python.org/pypi/unittest2\n. ",
    "asimjalis": "Here is a solution in Hy for reloading a file using its path. Useful for reloading from the REPL.\nclojure\n(defn slurp [path] (with [f (open path)] (.read  f)))\n(defn hy-wrap-with-do [s] (+ \"(do\\n\" s \"\\n)\\n\"))\n(defmacro hy-load [path] `(->> ~path (slurp) (hy-wrap-with-do) (read-str) (eval))) \nTo reload the file \"dir/script.hy\" use (hy-load \"dir/script.hy\") on the REPL.\nThe reason for wrapping with (do ...) is that read-str only reads a single expr. \nThe reason for using defmacro instead of defn is that a defn limits the scope of the eval to its function\u2014the definitions loaded from the script file are lost when we exit this function. Using defmacro loads the definitions into the global namespace.. The problem is that on line 50 in completer.py it assumes readline was imported. This should add a check for docomplete which is True when readline is not imported.\nI can submit a pull request if this change looks ok.\nIn https://github.com/hylang/hy/blob/master/hy/completer.py#L50\nReplace:\nif sys.platform == 'darwin' and 'libedit' in readline.__doc__:\n\nWith:\nif sys.platform == 'darwin' and docomplete and 'libedit' in readline.__doc__:\n\n. Here is a fix that works if I paste it into the REPL. This should probably be done in Python in the hy history code.\n(import atexit readline os)\n(def hist-file (os.path.expanduser \"~/.hy-history\"))\n(-> hist-file (open \"a\") (.close))\n(atexit.register readline.write_history_file hist-file). ",
    "minghu6": "I find It's hard to limit the scope, inner function can limit it, but can't works with eval.\nwe may need  let or let with limit its scope.. en, I wonder how long before 1.0, do you have some plan about it. (it takes more than 5 years from initial project to v0.13.1 :anguished: , I  guess it should have v0.2 v0.3 ...)\n. All rights, seems that I should write some monkey patch myself for new feature.. wow, so scary, maybe you misunderstand my meaning because my poor expression. I am just not sure that if hylang is a independent language,  I guess it\u2018s like clojure, or just a python module.\nIf it is the former, It seems to need what I mentioned\uff0cor else that\u2018s okay.\nso\uff0cmaybe need a chapter about it usage ?Othewise it is confused if emphasized it is a lisp dialect and called hy-lang.\nTo be honest, I agree with you, however, I misunderstand your means before your comment.. @Kodiologist actually, what I am concerned is there is some way to mangle this symbol  camelcase->snakecase, no mater the rule.\nThe name scope of  Hy is larger than Python, mapping every special character perfectly is hard and make the variable name legible which is worried by @gilch.\nIn my opinions, we can only be care about specific case (mangle based on the whole name other than single character):\nIn fact, most symbol whose name contans special character writen and expected to use inner hy module, such as func* (and maybe no one wants to using Hy, hello world  in python). \nWe can only mangle the symbol name which can be exposed from  hy module to py module (the naming rule is part of coding style), for example: *global-and-constant*, func-no-special-char, returnbool? sideeffect! a->b\n and ignore such as *!!no-obvious-meaning?!*. (maybe can use (sub r\"^(\\w[a-zA-Z0-9]*)\\?$\" r\"is_\\1\" symbol-name) to match returnbool?)\n. Let me rephrase that, #1458 isn't releated about my issue. How to mangle each single char is hy2py's work.\nIf we can set some convention about name mapping bettwen py and hy. And in other case, we use mangle rule.. You mean I should require whole file (including other macro), if I am not certain some specific macro exist?. I don't understand the usage of if (dec (len (input)) @gilch \n. And anyway, using require bring risks of critial error. We can't do anything except let it crash :(.\nI am not sure it's proper that raise Exception instantly during compile-time for a bad request, if we can delay the exception until the run-time, so we can handle it? . And\nhy\n(as-> 10 x)\n(print x)\n(print x)\n;; 10\n;; 10. ",
    "gknapp": "+1 to remove these extra square brackets\n. Coming from Clojure, I feel the same.\n. I was about the raise this same issue when reading the hy docs. keywords don't get much coverage and no examples, just a mention in Hy Models\n. Their most prominent use in other Lisps like Clojure are as map keys, require statements (Hy has (require ...) as well as (import ...)?) and in argument destructuring ([{:keys [a b] :as all} hashmap])\n. ",
    "mpenet": "used to do a lot of CL/Scheme, but since having used clojure anything else than this style feels odd: \nclojure\n(let [x 1 \n      y 2 \n      z nil]\n  ...)\n. ",
    "jebberjeb": "+1 removing the extra [ ]\n. ",
    "ALSchwalm": "I think I was trying to keep it similar to the other error message from let: \"let lexical context must be a list\". Maybe referring to it as a varlist or binding list would be better. Something like: \"let binding list must contain only symbols and symbol-value pairs\"\nAs for testing, would test_ast.py be a good place? It seems to be where most of the bad macro  usage tests are.\n. Is exec the de facto way to evaluate python code from hy (without using a separate module)? Or should we change it to be more consistent with eval?\n. Added a simple test and rebased\n. Added and rebased\n. ",
    "fjarri": "Based on my very limited understanding of how parsing works, I don't think you can represent full Lisp reader with a lexer-parser pair. So, no amount of tinkering with rply will help. \nOf the two solutions I mentioned, I'd prefer the latter one: keep rply as a parser for the \"static\" subset of Hy, and then adopt some existing reader implementation (for example, Clojure reader written in Clojure). \nWhat also slightly worries me is that a full reader reads input stream character by character, as opposed to rply lexer which uses regexps on the full string, so there will be some performance drop (can't say how significant, though).\n. ",
    "bowbahdoe": "Is there any reason that this has been neglected for a year? It seems like a tremendously useful feature.. Looking at the source now, the actual areas this changed haven't been updated that much. I'm not well versed in git, but if I insert the changes again on an updated branch that should get rid of merge conflicts.. I'm fairly certain the error is arising somehow from the code in 1230-1235, but other than that I'm not sure yet.. while len(pairs) > 0:\n    k, v = (pairs.pop(0), pairs.pop(0))\nI'm not sure this error is because of this. Logically, if pairs is of length 1 it will enter this loop, but it will still try to pop 2 items off of a list of length 1. Maybe try changing that 0 to a 1 and see what the tests do?\nIf this bug is arising because of the behavior added in compiler.py, I am pretty far out of my depth in terms of understanding the logical ramifications.. Hate to bring down the mood, but the following code segment\n```\n(defn copyString [str1]\n    (.join \"\" str1 ))\n(print (copyString \"this will break things\"))\n``\nfails to compile with(import [future [TailRec]])` enabled.\nAnd the argument for this being gated, regardless of whether it breaks anything, I think boils down to the performance arguments made in the previous request #728 . > \"The overhead can definitely slow this down, which that is why we use the from future expression, to avoid the overhead where we can.\"\n(okay, maybe that isn't comprehensive.)\nBasically, using this method adds some amount of overhead for every non-recursive function call, so the future expression is to allow people to turn it on selectively and avoid that overhead.\nAn equally valid approach I think would be to do the opposite and have it always on by default and let users turn it off selectively.. ",
    "justuswilhelm": "For the sake of brevity: How does a sample Flask project look like? For ORM it could use SQLAlchemy et al. The advantage is that it will fit in one module, whereas with Django it would typically be spread out over many modules.\n. ",
    "shrayasr": "This probably makes most sense to be in the Protips section? \n. > We can create a new section \"Editor plugins\" in tutorial, or better we can create a new page \"Tools\" and add our editor plugins, IPython kernels, HyREPL, Sublime plugins etc. \nIf there are these many things to add, I think a \"Tools\" page makes sense.\n\nand then we can add cross references to http://docs.hylang.org/en/latest/tutorial.html and http://docs.hylang.org/en/latest/quickstart.html (see item 7)\n\nCross reference from where to these pages? \"Tools\", you mean?\n. > the second one, not so sure\nThe second isn't really an error. In the before section, the function is defined as optional-arg and then later it is used as optional_arg. I changed it to the former for consistency sake :)\n. Since Python doesn't support using of - in function names, does it make sense to change the example to use _ in the place of - for consistency sakes?\n. @paultag @cwebber, Shouldn't the last section in the Tutorial be Pro tips instead of Protips ? cc @theanalyst \n. No problem :) Should I add myself to the AUTHORS file? It says so in CONTRIBUTING but doesn't specify if docs changes qualify to add myself there\n. No problem, I will send a PR for that as instructed :smile: \n. Thank you :)\n. Ah. Then I think it should be optional_arg everywhere since Hy supports it, no?\n. Ah. I see. \nAllright, I'll remove the commit then ? \n. All right. Will do.\nOne more thing, shouldn't it be Pro tips and not Protips ?\nOn Jan 15, 2015 1:48 AM, \"Berker Peksag\" notifications@github.com wrote:\n\nIn docs/tutorial.rst\nhttps://github.com/hylang/hy/pull/751#discussion-diff-22966650:\n\n@@ -413,7 +413,7 @@ Are you familiar with passing in *args and **kwargs in Python?::\n\n\n\nargs = [1 2]\nkwargs = {\"keyword2\": 3\n   ...           \"keyword1\": 4}\n-  >>> optional_arg(_args, _kwargs)\n-  >>> optional-arg(_args, _kwargs)\n\n\n\n\nYes, please revert it and squash your commits. Otherwise LGTM.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/pull/751/files#r22966650.\n. Allright, thanks :)\n. \n",
    "larme": "I think \n(if (coll? routes)\n      (setv g!b [routes])\n      (setv g!b routes))\nshould be\n(if (coll? routes)\n      (setv g!b routes)\n      (setv g!b [routes]))\n. Documents added.\n. We can, but it will create some circular imports because then hy/models/__init__.py need to import hy/models/complex.py etc.. I'm not sure which way is better.\n. This error message doesn't clearly state what's wrong. Maybe we should change it to something like\n\n\"Can't wrap a  object to a HyObject\"\n. \n",
    "nicolas-p": "Maybe we could have cond, switch and case which all use square brakets to delimit each condition-expression pair, and cond', switch' and case' in which there are no square brakets and the arguments are implicitely grouped two-by-two.\nSquare brakets are not necessary in simple examples but when the conditions or expressions take several lines, it is good to have them so you can identify when the pairs start and end.\nI think both versions are useful.\n. I recently wrote some code for which I needed first and last. I had to import last from Toolz. So I think it would be a useful addition to Hy.\n. Interesting... but you're right, it's quite hard to understand :\nhy\n(->> filename \n    (<- (loadmat :squeeze_me true))\n    (keyfilter (fn [k] (not (in \"__\" k))))\n    (valfilter (fn [v] (> (len v) 0)))\n    DataFrame))\n. Actually, I think it would be better to name the macro ap-pipe and to have ap-compose as well :\nhy\n(defn load [filename]\n  (ap-pipe filename \n           (loadmat it :squeeze_me true) \n           (keyfilter (fn [key] (not (in \"__\" key))) it)\n           (valfilter (fn [values] (> (len values) 0)) it)\n           DataFrame)))\nhy\n(def load\n  (ap-compose (loadmat it :squeeze_me true) \n              (keyfilter (fn [key] (not (in \"__\" key))) it)\n              (valfilter (fn [values] (> (len values) 0)) it)\n              DataFrame)))\n. The second one is for function composition. It takes only functions as arguments.\n. Thanks. This is now officially my first contribution to open source software.\n. ",
    "rhaps0dy": "Sure, give me a sec :)\n. ",
    "sonelliot": "My workaround in the mean-time is to put these regex functions into python script instead.\n. Apologies. I'm new to python, didn't realize you need to put a r\"text\" on the front!\n. ",
    "yawnt": "looks like the print call isn't python's standard print .. or that it's forcing unicode support which isn't available in RPy (afaik).. any way to disable that and get back to good ol' print ?\n. I talked to @paultag on Twitter and, to his knowledge, the RPy backend was still working.. as long as Hy doesn't do particular translation magic, it should just fine.. \nedit: you're right in saying regular python won't run on RPy, but I plan on writing RPython, just with Hy syntax ;D\n. here it is, might it be that I have python3 installed so it defaults to print() instead of print? How can I choose the python backend version?\n```\n\u250c(yawnt@ehecatl) (iojs 1.2.0)\n\u2570\u2500(~/Code/hy/test/rpython)> hy2py test.hy\ndef fib(n):\n    return (n if (n <= 2L) else (fib((n - 1L)) + fib((n - 2L))))\ndef main(argv):\n    for x in [1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]:\n        print(fib(x))\n    return 0L\n```\nI've currently fixed it with a workaround, anyway\nhy\n(defn main [argv]\n  (for [x [1 2 3 4 5 6 7 8]]\n    (.pp target (fib x)))\n  0)\nin target.py\npython\n...\ndef pp(what):\n    print what\n...\n. yes, I'm playing a bit with it .. map doesn't seem to be working (i blame itertools), although for compiles fine.. I wonder if it would make sense to write a contrib.rpyhon package with alternative implementations of core fns\nit's a shame tho, it could really be something to be able to write RPy in Hy.. just think from a VM/Compiler perspective ;P\n. ",
    "acron0": "Proposed alternative: https://www.refheap.com/98654\nTested with:\n=> (last (take 5 (itertools.count 10)))\n14L\nI will admit that I don't fully grok the purposes of that tee though. Would (list coll) be enough in this situation? --> https://www.refheap.com/98655\nEDIT: Oops, didn't mean to close, sorry!\n. Changes are committed. It's obscenely simple now :P\n. Changes are committed. It's obscenely simple now :P\n. Thank you folks! Great to see such a positive, engaging team.\n. algernon> (ap-map-when (fn [x] (= x foo)) (* it 2) [1 2 3 4])\nMind the doors.\n. ",
    "jaredly": "The original example works fine as\n(->> \n     (loadmat filename :squeeze_me true)\n     (keyfilter (fn [k] (not (in \"__\" k))))\n     (valfilter (fn [v] (> (len v) 0)))\n     DataFrame))\nBut, if this anaphoric macro is going forward, it might be clearer if some sigil were used instead of the variable-looking it. Something like @\n(edit) I see that it is already used in other anaphoric macros. nevermind\n. Right, I know this is wrong syntax. The error message is confusing though. Why an UnboundLocalError?\n. but why not have it be a language feature? Python already has function argument destructuring built-in\n. @kirbyfan64 that was fast! :+1: \n. Would it take better advantage of the python runtime to just convert it into the ast generated by this?\ndef foo((a,b)):\n  print a+b\nFor reference, here is the ast for the function's args in python 2.7\njson\n\"args\": {\n  \"_type\": \"<class '_ast.arguments'>\", \n  \"args\": [\n    {\n      \"elts\": [\n        {\n          \"_type\": \"<class '_ast.Name'>\", \n          \"ctx\": {\n            \"_type\": \"<class '_ast.Store'>\"\n          }, \n          \"id\": \"a\", \n          \"col_offset\": 7, \n          \"lineno\": 2\n        }, \n        {\n          \"_type\": \"<class '_ast.Name'>\", \n          \"ctx\": {\n            \"_type\": \"<class '_ast.Store'>\"\n          }, \n          \"id\": \"b\", \n          \"col_offset\": 9, \n          \"lineno\": 2\n        }\n      ], \n      \"_type\": \"<class '_ast.Tuple'>\", \n      \"ctx\": {\n        \"_type\": \"<class '_ast.Store'>\"\n      }, \n      \"lineno\": 2, \n      \"col_offset\": 7\n    }\n  ], \n  \"kwarg\": null, \n  \"defaults\": [], \n  \"vararg\": null\n},\n. ",
    "acekingke": "thank you very much ,the macro can work well\n. I have got the problem , when I use pip install ,It just  generate directory astor-0.5.dist-info, do not have astor-0.5-py2.7.egg , Now download the source code and run setup.py ,It can work\n. Thank you very much\uff0c It\u2018s my fault\n. Thank you very much\n. Thank you very much\n. Thank you, yes,  I mean the (1 2 3)  like lisp\n. Thank you very much\n. @agentultra  They should make like this:\n=> (setv a (.extend [1 2] [3 4]))\n=> a\n=> (setv a [1 2])\n=> (.extend a [3 4])\n=> a\n[1L, 2L, 3L, 4L]\nand the way algernon afford can work well:\n=> (+ '(3 3) '(4 4))\n(3L 3L 4L 4L)\n. Thank you very much\n. Thank you very much\n. match_string cause the error\n. Sorry\uff0c I make error.\n. http://docs.hylang.org/en/stable/language/api.html#cut\n```\n=> (setv collection (range 10))\n=> (cut collection)\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n=> (cut collection 5)\n[5, 6, 7, 8, 9]\n=> (cut collection 2 8)\n[2, 3, 4, 5, 6, 7]\n=> (cut collection 2 8 2)\n[2, 4, 6]\n=> (cut collection -4 -2)\n[6, 7]\n```. ",
    "Marrin": "Just tripped over this. I agree with the interpretation of else as continuation of the try block in case no exception occurred and that the result of else should be the result of the try then.. ",
    "kitsu": "You could maybe implement getitem and setitem in this case and get the built-in assoc working, but protocols are a more general solution. Protocols are about open extension, adding features to someone else's objects without modifying its code or monkey patching.\nHere is a gist where I've sketched part of a protocol implementation: https://gist.github.com/kitsu/83d0120b5ef3ba783940\nIt still needs a lot of machinery for grouping functions in actual protocols and extending those sets over existing types. Then all that machinery can be hidden on the Hy side with some nice macros.\n. It seems the author of PEP0443 and the python devs that included it in Python 3.4 disagree with you. Also, I'm proposing adding this to Hy, not Python. Just because you are not enamored of an idea in an imperitive/OOP setting doesn't mean it has no use.\n. ",
    "wuxianliang": "it works.\nhy\n(import [numba [jit]])\n(with-decorator jit (defn sum [x y] (+ x y)))\nShould we make a new keyword \"defn-jit\" for defining functions with numba ( JIT )  as default? @berkerpeksag \nhy\n(defn-jit sum [x y] (+ x y))\nor \"defnj\" for short\nhy\n(defnj sum [x y] (+ x y))\nor \"defn!\" if I may\nhy\n(defn! sum [x y] (+ x y))\n. @berkerpeksag @kirbyfan64 Thank you all! This is my first day with Hy! Macros! \n. I pip install --upgrade readline in root and virtualenv a new env, then hy works well.\n. ",
    "bollwyvl": "Thanks for the response.\nSeems like this makes it hard to write things in hy which normal py users could use... from the whole JS/Coffee/Typescript debacle, it's at least usually the case that one can use the output of a transpiler in the upstream language.\nI've taken the approach out of defensive laziness, I suppose. By handing over generated python code, I can reuse everything in the upstream IPythonKernel. History, magics, widgets, tracebacks, documentation, autocomplete, etc. Some of them are lies, as they are text-based and therefore based on python and not hy, but I'm handling them as I figure out sane ways to wrap them,\nOf course, deep down, IPython's shell is generating and executing AST nodes, just from python source, but only after (potentially) doing quite a bit of other hackery to it.\nI explored monkeypatching the Kernel's shell, (and m of its n super/sub classes, and users along the way), but haven't figured out how to preserve the text-based features... and even if I was able to achieve feature parity, I would be able to keep up with the upstream in terms of re-implementing features... the very features a user would be using Jupyter for in the first place. As it is, I have to give up a good number of features as some are line-and-whitespace sensitive.\n. With respect to publishing, I was referring to the example just given where a potentially useful thing would not be importable through standard means due to the developer's choice of naming:\n``` py\nsome.py\nfrom some_hy import foo!\n```\nI suppose it might be possible to use importlib with the module.\nThe star joke was a pun: if you're trying to import multiplication, you call it *: if you want to implement everything you call it... *. So \"expected\" depends on how you see the world.\nI am certainly not arguing anything about the value of AST vs. source, I just was fishing for an The Decision. If the stance is, \"generating valid python utf-8 source is never going to be a concern,\" that's great and fine, and my caveat that hy_kernel for the time being can't do some hy stuff will stand, and I'll keep looking for some way to keep the text-based features of IPython, while exposing successively more of the Truth of Hy!\n. ",
    "ewaldgrusk": "Sorry, my mistake. I've updated the commit accordingly.\n. I assume you mean something like this:\nhy\n((fn [x] x) :x) ;; Make sure this raises a HyTypeError\nIf so, which file would be the best place for this test?\n. Aah! Now I remember why my first attempt didn't show the bad keyword in the error message anymore. I'm open to suggestions.\n. I have applied the fix suggested by @algernon (see #821 and #822) to the working directory of my local repository. The tests pass, but here\u2019s the catch:\n``` hy\n;; Python 2.7.3 on Linux\n((fn [\ud83d\udca9] \ud83d\udca9) 1)\n;; 1L\n((fn [\ud83d\udca9] \ud83d\udca9) :\ud83d\udca9)\n;; UnicodeEncodeError: 'ascii' codec can't encode character u'\\U0001f4a9' \u2026\n((fn [\ud83d\udca9] \ud83d\udca9) :\ud83d\udca9 1)\n;; UnicodeEncodeError: 'ascii' codec can't encode character u'\\U0001f4a9' \u2026\n```\nNeedless to say that Python 3 is not affected by this.\n. I have looked into this:\nhy\n(macroexpand '(bar)) ;; macroexpand(HyExpression(([] + [HySymbol(u'bar')])))\n(eval '(bar)) ;; hy_eval(HyExpression(([] + [HySymbol(u'bar')])), \u2026)\nSo, macroexpand passes its argument unchanged to HyMacroExpansionError(\u2026) (hy/macros.py#L204), whereas hy_eval adds the expected attributes (start_line, etc.) before macro expansion (see this little gem: hy/importer.py#L105).\nThus:\n```\n$ cat bar.hy\n(defmacro bar [x] '())\n(eval '(bar))\n$ hy bar.hy \n  File \"bar.hy\", line 0, column 0\nHyMacroExpansionError: expanding `bar': TypeError(\"_hy_anon_fn_1() missing 1 required positional argument: 'x'\",)\n```\n. :+1: I ran into the same problem (see #815).\n. My fault, I haven\u2019t read the part of the documentation that states that \u00bbthere is generally no reason to use it directly\u00ab.\n. ",
    "pmaupin": "If you can make astor codegen fail, please add a test, and then we'll add a fix.  See https://github.com/berkerpeksag/astor/pull/46\nThanks,\nPat\nP.S. I just double-checked, and the code to print 'elif' was in the code from Armin Ronacher that I started with back in late 2012...\n. How can you print an elif if you have those additional lines?\n(e.g. _hy_anon_var_3 = _hy_anon_var_2 in the second example?)\n. ",
    "noxecane": "This issue seems to be reccuring in version 0.11.1 for Cython 3.5.2. Sorry I meant CPython. I keep confusing both. so how do I use import  macros?. thanks....by the way how can I help with docs. ok. whoah!!!!\nI thought using a problem to describe it would be better but anyways....\nI am trying to request a feature. The latest version of Hy has multi-arity functions i.e. functions that dispatch based on their arity and I am asking for the same thing with macros, which is exactly as it is in clojure. Since macros are basically functions that take code as inputs.\n```hy\n(defmacro if-let [[form test] then &kwargs kwargs]\n    (;;do something useful\n     (if (in \"else\" kwargs))\n        (print \"deal with else\"))\n     (if (in \"others\" kwrags)\n         (print \"deal with else\"))))\n;; compared to\n(defmacro if-let\n    ([[form test] then]\n        (print \"then\"))\n    ([[form test] then else]\n        (print \"then else\"))\n    ([[form test] then else others]\n        (print \"then else others\")))\n```\nbetter?. whoah!!!!\nI thought using a problem to describe it would be better but anyways....\nI am trying to request a feature. The latest version of Hy has multi-arity functions i.e. functions that dispatch based on their arity and I am asking for the same thing with macros, which is exactly as it is in clojure. Since macros are basically functions that take code as inputs.\n```hy\n(defmacro if-let [[form test] then &kwargs kwargs]\n    (;;do something useful\n     (if (in \"else\" kwargs))\n        (print \"deal with else\"))\n     (if (in \"others\" kwrags)\n         (print \"deal with else\"))))\n;; compared to\n(defmacro if-let\n    ([[form test] then]\n        (print \"then\"))\n    ([[form test] then else]\n        (print \"then else\"))\n    ([[form test] then else others]\n        (print \"then else others\")))\n```\nbetter?. makes sense. ",
    "mknecht": "Two questions about keywords not being available in macros. (Seems to be part of this issue here, sorry, if wrong.)\nKeywords as (invalid) strings are kind of weird. They're awkward in macros.\n\nWhy is that?\nAlso, the merged PR above does not provide keywords in macros, right?. ",
    "Ealhad": "I\u2019ll do it. Where should it go ? In Hy (the language) ?\nI am glad strings seem not to be broken anymore.. Seems anaphoric enough to me.. > What if I want to eval (exec?) a string containing Hy code? Is there a way to do that from Python? Or can you only import?\nI don\u2019t know if we can do this. If there is such a feature, it will be my pleasure to document it.. I like earmuffs.\nThere is however a problem: symbols with earmuffs are transformed in their upper-cased version, whereas upper-cased symbols from Python code stay the same when imported to Hy.\n(setv *test* 42) gives TEST = 42\nAnd if I import a Python module containing TEST = 42, the translated Hy symbol is still TEST.\nI think this is inconsistent.. Oh, my bad.\nI didn\u2019t realise that we could in fact access Python\u2018s SYMBOL as either SYMBOL or *symbol*, since well, it isn\u2019t really documented yet ;)\nAnd the same goes for underscore and dashes. Oh. Well, that\u2019s nice, and I am going to write it down.\nThanks !. First PR indeed, not scared away \ud83d\ude2c \n\nMore generally, I think that fulfilling #1061 calls for adding discussion of lots of gory details. Your additions here don't suffice.\n\nIn that case, maybe this should be completely moved away from the tutorial, which would still contain general interop instructions without the \u201cgory details\u201d.\nWhat I have understood so far is that if anywhere in the code, the name of a Hy builtin is found, it is imported.\nFor example :\n(def second 42)\ntriggers \nfrom hy.core.language import second. Thank you for those words! (tssst, I wanted to put a space before my exclamation mark. It\u2019s hard being French when writing in English)\nI\u2019ll make the corrections quickly.\nI'd suggest documenting mangling in a separate PR.\n\nShouldn\u2019t mangling still be mentioned in this section? Maybe a link would suffice.\n. https://www.python.org/download/releases/2.6.9/\n\nWith the 2.6.9 release, and five years after its first release, the Python 2.6 series is now officially retired. All official maintenance for Python 2.6, including security patches, has ended. For ongoing maintenance releases, please see the Python 2.7 series. The NEWS file lists every change in each alpha, beta, release candidate, and final release of Python 2.6.\n\nI guess it's alright.. ",
    "woodrush": "I'm currently working on this now at https://github.com/woodrush/py2hy. The main idea is to make the Python AST into S-expression form, then treat Python AST keywords as Hy macros, and let Hy recursively macroexpand the raw Python AST S-expression. There is some sample output I've generated which seems fairly promising right now.\nI wrote a parser for the Python AST specs that creates a template code to be filled in to create py2hy. The project is still work in progress but I believe it could be implemented this way. Current potentially large issues I've noticed is how to work around return, which would at the time need lots of AST workarounds. Otherwise, I believe it is fairly straightforward to implement it this way.\nOnce I get this finished, I plan to try to write HyHy, a Hy analogue of PyPy in Hy, and see how far it could go. I think it would serve as a clean definition of how Hy transforms its AST to Python AST and vice versa.. I did some work on py2hy, and it's mostly done now.\nThe current state is like this:\n\nIt is capable of rewriting the Hy core to Hy, to create a running version of \"HyHy\".\nThe return statement is implemented via a workaround similar to Tritlo's comment.\nI've started writing a pytest for Python>=3.3. It runs on tox but doesn't have a full pytest yet.\nThe code it outputs is still ugly as mentioned by @gilch in another issue, mainly because of the return workaround, and it doesn't do some nice optimizations yet.\n\nUpon integrating this to the Hy core, I was thinking we would benefit more if we made it a separate repository in the hylang toolset like hylang/hydiomatic. Some reasons why are,\n\nWhile hy2py leverages on the Hy core (the core is by definition a Hy to Python converter), py2hy runs on an entirely separate main function from the Hy core. This makes the development of hy2py and py2hy a different task, and therefore creates an extra burden when updating the Hy core.\nThe codebase is large. The current py2hy is over 1000 lines, and has several helper modules (the pretty printer and the AST specs parser). Since the test would highly likely be as large as itself, that would make the estimated final size to be around 2000 lines.\nThe tests aren't finished yet, and it would take another load of time to finish writing it, so it needs some more effort to be a mature portion of the Hy core. Yet, it successfully runs HyHy and all of its pytests, so it would be practically useful for debugging Hy itself, as @gilch mentioned in the first comment. py2hy could be debugged concurrently with Hy, and as said earlier, that would make more sense if done as a separate task from the Hy core.\n\nWhat are your thoughts?\n. Thanks! I plan to continue working on it, so yes, it sounds be better to keep it in the current repo for a while.\nWhile that's going on, would it be OK for me to push this on PyPI? I haven't pushed to PyPI before but I was wondering if it wouldn't cause unwanted conflicts with Hy.\n\nNote that I recently implemented return, although it's not merged yet (#1380).\n\nYes I saw it! Many thanks for the PR. I'll put that in py2hy once it's merged. It would make everything very clean and simple.. Awesome! Thank you very much! I'll post again when I get that done.\n\nso you don't want the user to install the code in a place where only the superuser can write without the corresponding bytecode.\n\nIndeed! I finally got why Hy uses the Install class in setup.py. Thanks for the advice. I'll make sure I do that in py2hy as well.. Oh snap, this was open with no PRs when I started working on it last night. I'll just close my PR.. #1349 fixes this. The current unquote-splice receives the value of the form inside and passes it to Python's list. When the form inside ~ evaluates to None, it produces list(None), but since None is not iterable, it results an error. Instead of passing the form to list, #1349 passes the form to a function that returns [] when it receives None, allowing None to be spliceable. . Thanks. No problem, I'll remember about it next time. :). Note that this code assures that the form is evaluated only once using setv, and uses self.get_anon_var() to assure that unwanted captures of variables don't occur.. An alternative way would be to change https://github.com/woodrush/hy/blob/f90cb39a61359c54089b2251324a11cb353b3b96/hy/compiler.py#L703 so that it appends nothing when it receives None. This would mean that we change\nclojure\n(+ [] contents)\nto\nclojure\n(do\n  (setv ret [])\n  (for [form contents]\n    (setv var form)\n    (if (None? var) (continue) (ret.append var)))\n  ret)\nNow, both of these solutions don't change the fact that the None-ness of the form is evaluated after the form is compiled to Hy AST. Therefore, in both solutions we must construct this code using HySymbol and HyExpression constructs, so the alternative way of changing L703 would be almost the same as this PR. Also, the contents that is received here is what is created at https://github.com/woodrush/hy/blob/f90cb39a61359c54089b2251324a11cb353b3b96/hy/compiler.py#L711 , where I've changed in this PR (it is added at https://github.com/woodrush/hy/blob/f90cb39a61359c54089b2251324a11cb353b3b96/hy/compiler.py#L721). Changing L703 would also be a slight overhead for expressions that are not unquote-spliceed since it would add redundant checks of quotedform?. . Thanks! I ran tests with tox for all the versions in tox.ini. Oh, but I forgot to add tests that splice None, I'll work on that.\n\nAlso, change your commit message and PR title to be more descriptive.\n\nI see. Got that.. Thanks for the comments. I added some tests for splicing None, squashed and rewrote the commit messages. I also reformatted the code where it was more than 80 characters long.\nI'm writing another test which tests for (unquote None).. Hmm... I think I've hit an issue-ish thing but I'm not that sure.\nI'm trying to write a test that compares (quasiquote (unquote None)) with (quote None),\nclojure\n; Test 1\n(setv qq (quasiquote (a b c (unquote (+ 1 3))\n                      (unquote None)\n                      (unquote (when False 1)))))\n(assert (= (len qq) 6))\n(assert (= qq (quote (a b c 4 None None))))\nbut this fails since (quasiquote (unquote None)) becomes <class 'NoneType'> while (quote None) becomes <class 'hy.models.HySymbol'>. The same thing happens with the original master branch as well.\nSo I tried casting None,\nclojure\n; Test 2\n(setv qq (quasiquote (a b c (unquote (+ 1 3))\n                      (hy.models.HySymbol (unquote None))\n                      (hy.models.HySymbol (unquote (when False 1))))))\n(assert (= (len qq) 6))\n(assert (= qq (quote (a b c 4 None None))))\nbut this fails since HySymbol needs to be fed with a str. Same for the original master branch.\nI wondered why the original test works with the integers, so I looked inside the definitions of HyInteger, and searched the codebase for\noverrides of __eq__, but it seems that there's no overloading of = going on. I'm not sure why (= (quote 1) 1) is True\nalthough (type (quote 1)) is <class 'hy.models.HyInteger'> and (type 1) is <class 'int'>.\nI'm not sure how, and also a little unsure if I should write this test for unquote somehow right now... any suggestions?. Hmm, I tried that but that doesn't work. Although \nclojure\n`[1 2 ~@0] ;-> `[1 2],\n`[1 2 ~@None] ;-> Becomes an error.\nThis worked:\npython\n                    to_add = HyExpression([\n                        HySymbol(\"list\"),\n                        HyExpression([HySymbol(\"or\"), f_contents, HyList()])]). > These aren't supposed to be the same though. `~x is just x, not 'x.\nI see. Well then I guess I'll just leave the test since it doesn't make that much sense as a practical expression.\n\nIt's a little bit strange at first to think that 0 (or any custom falsy type via bool) is now also allowed in a splice as an empty list.\n\nSince we have lif, I think we could create lor and put that in the core macros, where stuff like defn and if are. It would serve as part of a basis of what Hy considers as nil-ish.. Speaking of core macros, when I use the bootstrap macros that are in bootstrap.hy in where I wrote to_add, tests in pypy fail. I tried using if at first but failed, but if* didn't. defn also passed all versions except pypy but failed with it. I think pypy is failing to properly load these macros at compile-time.\nedit: added last line. > What is the tests/a_test_bin.py file for? It seems like a duplicate of tests/test_bin.py.\nSorry, that was an artifact for me renaming it to avoid tox to run test_bin. I dropped it out.. Thanks! The test now uses \\` and ~@. I also added the docs on unquote-splice, any feedback would be appreciated.. Awesome!. @gilch, thanks for the review. All the changes are included now, including the Python 2 -> Python 3 notation for the section I edited.. Thanks for the feedback. I see. The code (the py2hyed Hy, and the py2hy | hy2pyed Python) is not beautiful right now, and I could wait for self-hosting when both the Hy and Python code in this PR becomes readable enough. I also see that we could wait until when reach version 1.0, regarding the complications it would bring. Until then, I'll see if I could make the code more readable and more simple.\nI tried the pip and HEAD version of Hydiomatic a little, but it seemed to need some workarounds to make it work with the current version of Hy. I'll look into it to see if I could use it to simplify the code.. I agree. Changed to that.. I see, that sounds better.. ",
    "jkitchin": "See https://github.com/jkitchin/hy/blob/hydoc/hy/core/hylp.hy#L154 For one approach to getting the doc string.\n=> (. (get hy.macros._hy_macros nil \"with\") doc)\nu'shorthand for nested with* loops:\\n  (with [x foo y bar] baz) ->\\n  (with* [x foo]\\n    (with* [y bar]\\n      baz))'\n=> \n. The point of this is to be able to get help from within hy on what the compiler functions do.  See http://kitchingroup.cheme.cmu.edu/blog/2016/04/03/Getting-hylp-in-hy/ for example. None of the functions defined in compiler.py have any docstrings attached to them, so they are not introspectable in an editor to find out what they do, e.g. http://kitchingroup.cheme.cmu.edu/blog/2016/04/06/Another-step-towards-HyDE/.\nThis also makes it possible to auto-generate documentation, rather than update it in one place that isn't the code, or two places.\n. All of these are used by users I think, but not in an obvious way to\nusers. For example:\n(cut col 0 1 2)\nuses compile_cut_expression. A user would not directly call this, but by\nputting a docstring on it, you can access what cut is supposed to do.\ne.g.\n+BEGIN_SRC hy\n(import hy)\n(for x  (hy.compiler._compile_table.items))\n    (print (. x [1] doc))))\n+END_SRC\n+RESULTS:\n+begin_example\ncut can be used to take a subset of a list and create a new list from it.\n```\n    The form takes at least one parameter specifying the list to cut. Two\n    optional parameters can be used to give the start and end position of\n    the subset. If they are not supplied, the default value of None will\n    be used instead. The third optional parameter is used to control step\n    between the elements.\ncut follows the same rules as its Python counterpart. Negative indices\nare counted starting from the end of the list.\n\n```\n+end_example\nMatthew Egan Odendahl writes:\n\nMaybe we should mark some of these as implementation detail subject to change without notice, rather than part of the public API. A simple docstring like \"implementation detail: do not use\" would suffice.\n\nYou are receiving this because you authored the thread.\nReply to this email directly or view it on GitHub:\nhttps://github.com/hylang/hy/pull/1040#issuecomment-208468852\n\n\nProfessor John Kitchin\nDoherty Hall A207F\nDepartment of Chemical Engineering\nCarnegie Mellon University\nPittsburgh, PA 15213\n412-268-7803\n@johnkitchin\nhttp://kitchingroup.cheme.cmu.edu\n. It isn't that far off though. In this post\nhttp://kitchingroup.cheme.cmu.edu/blog/2016/04/03/Getting-hylp-in-hy/ I\ngenerated documentation for everything I could find at the time (even a\nlist of the compiler functions, just no documentation for them).\nSelf explanatory is in the eye of the beholder ;) For people brand-new\nto this, they might disagree. At some point I think having examples that\nare doctestable would make it worth having even trivial ones.\nRyan Gonzalez writes:\n\nI guess that makes sense...but it would first require the ability to even auto-generate the docs (which isn't possible ATM).\nBut I still think some of the docstrings, like compile_complex, are a little overkill, since the function names are rather self-explanatory.\n\nYou are receiving this because you authored the thread.\nReply to this email directly or view it on GitHub:\nhttps://github.com/hylang/hy/pull/1040#issuecomment-208449607\n\n\nProfessor John Kitchin\nDoherty Hall A207F\nDepartment of Chemical Engineering\nCarnegie Mellon University\nPittsburgh, PA 15213\n412-268-7803\n@johnkitchin\nhttp://kitchingroup.cheme.cmu.edu\n. For example,\nThese examples didn't work for me today:\nhttp://docs.hylang.org/en/latest/language/api.html#unquote\nI gathered that name is a function, and def doesn't redefine it.\n=> (def name \"Cuddles\")\n=> (quasiquote (= name (unquote name)))\n(u'=' u'name' )\nThe docs advertise:\n(def name \"Cuddles\")\n(quasiquote (= name (unquote name)))\n;=> (u'=' u'name' u'Cuddles')\nRyan Gonzalez writes:\n\n@jkitchin Good point about doctest; that would be really useful, since the documentation examples frequently go out of date.\n\nYou are receiving this because you were mentioned.\nReply to this email directly or view it on GitHub:\nhttps://github.com/hylang/hy/pull/1040#issuecomment-208488746\n\n\nProfessor John Kitchin\nDoherty Hall A207F\nDepartment of Chemical Engineering\nCarnegie Mellon University\nPittsburgh, PA 15213\n412-268-7803\n@johnkitchin\nhttp://kitchingroup.cheme.cmu.edu\n. That is more or less what I was aiming at in this code:\nhttps://github.com/jkitchin/hy/blob/hydoc/hy/core/hylp.hy\nThat code does the language, shadowed functions, keywords and macros.\nI didn't get to deferring to built-in Python help yet, but I would like to\nget there!\nJohn\n\nProfessor John Kitchin\nDoherty Hall A207F\nDepartment of Chemical Engineering\nCarnegie Mellon University\nPittsburgh, PA 15213\n412-268-7803\n@johnkitchin\nhttp://kitchingroup.cheme.cmu.edu\nOn Mon, Apr 11, 2016 at 3:50 PM, Matthew Egan Odendahl \nnotifications@github.com wrote:\n\nWe could override Python's help function with a macro that checks if the\nsymbol is a macro or built-in hy special form, and if so fetches the\nappropriate docstring. If not it can defer to the built-in Python help.\nThis would help with #356 https://github.com/hylang/hy/issues/356 and\n892 https://github.com/hylang/hy/issues/892.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/pull/1040#issuecomment-208527145\n. Here goes a hydoc macro that covers functions in hy, including macros, and Python functions. I think this should resolve #892 and #356.\n\n``\n(defmacro hydoc [sym]\n  \"Return docstring for SYM.\n  Look for hy functions first, then defer to Python.\"\n  (let [code(do\n               (import hy)\n               (import pydoc))]\n    (.append code\n       (cond\n        ;; language functions\n        [(in sym (. hy core language exports))\n         `(pydoc.getdoc (. hy core language ~(HySymbol sym)))]\n    ;; shadowed functions\n    [(in sym (. hy core shadow *exports*))\n     `(pydoc.getdoc (. hy core shadow  ~(HySymbol sym)))]\n\n    ;; Macros\n    [(in sym (.keys (get hy.macros._hy_macros nil)))\n     `(pydoc.getdoc (get hy.macros._hy_macros nil ~sym))]\n\n    ;; Functions in compiler\n    [(in sym (list-comp (get x 0) [x (hy.compiler._compile_table.items)]\n                        (string? (get x 0))))\n     `(pydoc.getdoc (get hy.compiler._compile_table ~sym))]\n\n    ;; Fallback to Python\n    [true\n     `(try\n       (pydoc.getdoc ~(HySymbol sym))\n       (except [e NameError] (.format \"{} Not found.\" ~sym)))]))\ncode))\n\n```\n. That is pretty nice, I haven't used the threading macros before. Pretty\nconcise. I think this might be a bit more robust, it also gets comments\nif there is no doc attribute\n```(defn hydoc* sym\n  (import pydoc)\n  (pydoc.getdoc (or (->> false\n            (.get hy.compiler._compile_table sym)\n            (.get (get hy.macros._hy_macros nil) sym)\n            (.get hy.core.shadow.dict sym)\n            (.get hy.core.language.dict sym))\n         (eval sym))))\n``````\nJust curious is the hydoc* an indication it is a function (the * at the\nend) to differentiate it from the macro by the similar name?\nMatthew Egan Odendahl writes:\n\nMaybe more like this?\n```Hy\n(defn hydoc* [sym]\n  (import hy)\n  (. (or (->> false\n            (.get hy.compiler._compile_table sym)\n            (.get (get hy.macros._hy_macros nil) sym)\n            (.get hy.core.shadow.dict sym)\n            (.get hy.core.language.dict sym))\n         (eval sym))\n     doc))\n(defmacro hydoc [sym]\n  `(hydoc* '~sym))\n```\n\nYou are receiving this because you were mentioned.\nReply to this email directly or view it on GitHub:\nhttps://github.com/hylang/hy/pull/1040#issuecomment-208675587\n\n--\nProfessor John Kitchin\nDoherty Hall A207F\nDepartment of Chemical Engineering\nCarnegie Mellon University\nPittsburgh, PA 15213\n412-268-7803\n@johnkitchin\nhttp://kitchingroup.cheme.cmu.edu\n``````\n. I am not sure you can get the autodoc feature of Sphinx to work with hy the way it does with Python. There is a lot of redirection between hy functions/macros and where the doc strings are. For example, here https://github.com/jkitchin/hyve/blob/master/hylp.hy#L103 I expanded some code you posted earlier to get the Python object for a given hy symbol, so that I can use the python tools for accessing docstrings, source files and linenumbers. I am pretty sure Sphinx would see things from the Python side in using the autodoc features.\nOn the other hand it is not that difficult to write code that would generate html docs from these docstrings. pydoc already has a lot of this framework. So there probably could be some code in the Sphinx docs that generates documentation for the hy functions and macros.\nThe benefit of this approach would be getting things the way you want them, e.g. sorted, or separated by categories, etc... The downside is more than one line of .. autodoc: ...\n. The extra line seems to get put in here: https://github.com/hylang/hy/blob/master/hy/compiler.py#L2122\n. In the SO example it causes a bug. And it doesn't happen for non dotted names. Why isn't there a 5 after a=5?\n. ",
    "arrdem": "IMO T/F is pretty awful and common/traditional lispy. Beyond that legacy, I see no attraction in in using it since the modern algol derivative ecosystems all use true and false variously capitalized.\nPersonally, I'm missing true and false from Clojure a lot as I'm writing bare python at work these days. But Hy is supposed to first and foremost fit in with python, and it doesn't really make sense to keep true and false around when True and False have to be reserved words so on that basis I'd argue that True and False are the best choice here. Users can always create aliases to lower-case true and false.\n. Having hacked on and used Clojure a bunch I'm comfortable saying that (for [] ...) executing exactly once makes no sense. for is not doseq or a looping construct, it is a macro for generating list comprehensions with conditional control flow. Clojure itself will reject (for [] ...), as it requires at least one binding thus resolving this ambiguity, but if you will allow zero bindings, any execution whatever flies in the face of the design goal which is list comprehension.\n. This is a PR which may be closed and succeeded. Please discuss the matter on the tracking ticket #908.\n. ",
    "fragrans": "Hi farhaven,\nI really need to use this feature; \nThe situation is this:\nI read a string of lisp/code from stream; and I want to run/eval it right away;\nIf Hy could only import from file module? how should I do?\nThanks,\nfragrans\n. hi farhaven,\nSorry, I forgot to mention, sample code with following error:\nC:\\Users\\LL L>c:\\Python27\\python.exe\n```\nPython 2.7.11 (v2.7.11:6d1b6a68f775, Dec  5 2015, 20:32:19) [MSC v.1500 32 bit (Intel)] on win32\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n\n\n\nimport hy\nx = hy.lex.tokenize(\"(defn foo [] (print 'fnord))\")\nhy.importer.hy_eval(x, globals(), \"main\")\nTraceback (most recent call last):\n  File \"\", line 1, in \n  File \"c:\\Python27\\lib\\site-packages\\hy\\importer.py\", line 110, in hy_eval\n    hytree.replace(foo)\nAttributeError: 'list' object has no attribute 'replace'\n```\n. hi pualtag,\nThanks for your comment, but I need to import/eval hy code in python.\n\n\n\nLL L\n. It's from PyPI: pip install hy\n```\n\n\n\nhelp(hy)\nHelp on package hy:\n\n\n\nNAME\n    hy\nFILE\n    c:\\python27\\lib\\site-packages\\hy__init__.py\nDESCRIPTION\n    # Copyright (c) 2013 Paul Tagliamonte paultag@debian.org\n    #\n    # Permission is hereby granted, free of charge, to any person obtaining a\n    # copy of this software and associated documentation files (the \"Software\"),\n    # to deal in the Software without restriction, including without limitation\n    # the rights to use, copy, modify, merge, publish, distribute, sublicense,\n    # and/or sell copies of the Software, and to permit persons to whom the\n    # Software is furnished to do so, subject to the following conditions:\n    #\n    # The above copyright notice and this permission notice shall be included in\n    # all copies or substantial portions of the Software.\n    #\n    # THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n    # THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n    # FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n    # DEALINGS IN THE SOFTWARE.\nPACKAGE CONTENTS\n    main\n    _compat\n    cmdline\n    compiler\n    completer\n    contrib (package)\n    core (package)\n    errors\n    importer\n    lex (package)\n    macros\n    models (package)\n    version\nDATA\n    appname = 'hy'\n    version = '0.11.1'\nVERSION\n    0.11.1\n```\n. ",
    "MelomanCool": "A bit late to the party, but I too would like to see this feature in the standard library.\n\nHy's (get) works on everything that supports the python subscript stuff, be that arrays, dicts, and whatnot.\n\nSo you're implying that if a user expects (get) to work with \"whatnot\", then they will also expect get-with-default to work with it also?\n\nTrying to subscript a key or index that doesn't exist, raise different exceptions.\n\nIf we rely on exceptions, then yes, we have a problem with \"whatnot\", since we don't know what could it raise.\n\nSo to make (get) truly generic, I'd have to catch all exceptions.\n\nWell, there are other options.\nInstead of relying on exceptions, we could check keys of a dict or length of a list. There's still a problem with \"whatever\", but at least we won't need to catch all exceptions.\nInstead of making a truly generic get-with-default, maybe it will be enough to only support dict- and list-like collections? Then, if a container raises another exception, we will not catch it. Or catch it and raise another exception, stating that container is not supported. Or, if we don't rely on exceptions, but can't check the length or the keys of a container, also raise an \"unsupported\" exception.\nInstead of putting this feature inside the (get), maybe it will better to create something separate like (get-default)? That will not break the existing API and the user will be aware that this function may behave differently.. I would also like to point out that Clojure's get, which OP mentioned, doesn't rely on exceptions, but checks map's keys and length of an array or a string. And for unsupported/null collections it simply returns the default value.",
    "tmbdev": "In the toplevel, it kind of makes sense, though. However, in Hy, it seems to me that \"test.+\" should be definable.\n. ",
    "cmwt": "@gilch \nHi, can you elaborate on possible/potential use cases for such a feature?\nI am not aware of any libraries that take python code as an argument. If you have a situation where you need to pass in python code directly could you just create a python program, call your hy program, and then just return to python when needed?\n. ",
    "ketsuban": "For some reason I expected this to be harder or I'd have taken a look at doing it myself. I guess I forgot setup.py is still Python source so you can play tricks like that.\nLooks good to me, I think. You might consider also adding variants which use both the major and minor components of the version_info tuple (e.g. hy-2.7) since easy_install and pip do that, but it's probably overkill.\n. python2 and python3 are created by distro packaging, sure, but their existence is due to distros obeying the relevant PEP. In any case, I didn't install Hy with a distro package\u2014I installed it with pip.\n. ",
    "paultopia": "Newbie here poking around looking for ways to get involved.  \nRe mobile, there is a python implementation for iOS, actually a few, but the most popular is a closed-source paid implementation called pythonista.  It's a little restricted due to apple sandboxing---only supports 2.7, currently no way I know of to get many modules in (anything that depends on C for example) unless the guy who writes it packages it in the core \"app\" in an update (for example, I haven't been able to get sci-kit learn in). But there are a variety of hacks to get modules written in pure Python in.  It's all very samizdat, lots of scripts to download other scripts off github and the like, because Apple has Feelings about sideloading code.  \nI may try and muck around a bit to see if I can get hy to install in a few days, will report back.\n. Ok, I've done a little experimenting.  I can get hy installed via the latest (2.0) version of pythonista on ios, but only after a bit of rigmarole.  I can also get a repl.  But I haven't managed yet to get it to execute anything else, I suspect simply because the way I've hacked it together it needs manual imports of basically everything.  \nSteps so far:\n1.  Manually install stash (a commandline clone): https://github.com/ywangd/stash\n2.  From stash command line, manually install dependencies in the following order via pip: 1) appdirs, 2) the listed dependencies in setup.py (astor, clint, rply)\n3.  Close stash command line (trying the below without doing this first led to a crash, I suspect because of memory)\n4.  Switch to pythonista console (repl).  Then, in console:\n```\n\n\n\nimport hy\nimport hy.cmdline\nhy.cmdline.hy_main()\nhy 0.11.1 using CPython(default) 2.7.5 on Darwin\n=> \n```\n\n\n\nAnd we have a hy repl!  Unfortunately, trying to use it blows up ugly.  Viz.: (sorry for lousy formatting, I'm pasting this in straight from ipad)\nMaybe I'll try importing everything individually...\n=> (print \"hello hy!\")\n    Traceback (most recent call last):\n      File \"/private/var/mobile/Containers/Shared/AppGroup/3CA811DC-91BC-4964-9CFE-81FFABD1596F/Documents/site-packages/hy/hy/compiler.py\", line 2304, in hy_compile\n        compiler = HyASTCompiler(module_name)\n      File \"/private/var/mobile/Containers/Shared/AppGroup/3CA811DC-91BC-4964-9CFE-81FFABD1596F/Documents/site-packages/hy/hy/compiler.py\", line 378, in init\n        load_stdlib()\n      File \"/private/var/mobile/Containers/Shared/AppGroup/3CA811DC-91BC-4964-9CFE-81FFABD1596F/Documents/site-packages/hy/hy/compiler.py\", line 73, in load_stdlib\n        mod = importlib.import_module(module)\n      File \"/var/mobile/Containers/Bundle/Application/575025AB-2EF8-4348-BA3E-A7FBA91E5011/Pythonista.app/Frameworks/PythonistaKit.framework/pylib/importlib/init.py\", line 38, in import_module\n        import(name)\n      File \"/private/var/mobile/Containers/Shared/AppGroup/3CA811DC-91BC-4964-9CFE-81FFABD1596F/Documents/site-packages/hy/hy/importer.py\", line 180, in load_module\n    self.path)\n  File \"/private/var/mobile/Containers/Shared/AppGroup/3CA811DC-91BC-4964-9CFE-81FFABD1596F/Documents/site-packages/hy/hy/importer.py\", line 75, in import_file_to_module\n    _ast = import_file_to_ast(fpath, module_name)\n  File \"/private/var/mobile/Containers/Shared/AppGroup/3CA811DC-91BC-4964-9CFE-81FFABD1596F/Documents/site-packages/hy/hy/importer.py\", line 67, in import_file_to_ast\n    return hy_compile(import_file_to_hst(fpath), module_name)\n  File \"/private/var/mobile/Containers/Shared/AppGroup/3CA811DC-91BC-4964-9CFE-81FFABD1596F/Documents/site-packages/hy/compiler.py\", line 2305, in hy_compile\n    result = compiler.compile(tree)\n  File \"/private/var/mobile/Containers/Shared/AppGroup/3CA811DC-91BC-4964-9CFE-81FFABD1596F/Documents/site-packages/hy/compiler.py\", line 428, in compile\n    ret = self.compile_atom(_type, tree)\n  File \"/private/var/mobile/Containers/Shared/AppGroup/3CA811DC-91BC-4964-9CFE-81FFABD1596F/Documents/site-packages/hy/compiler.py\", line 420, in compile_atom\n    ret = _compile_tableatom_type\n  File \"/private/var/mobile/Containers/Shared/AppGroup/3CA811DC-91BC-4964-9CFE-81FFABD1596F/Documents/site-packages/hy/compiler.py\", line 596, in compile_raw_list\n    ret = self._compile_branch(entries)\n  File \"/private/var/mobile/Containers/Shared/AppGroup/3CA811DC-91BC-4964-9CFE-81FFABD1596F/Documents/site-packages/hy/compiler.py\", line 483, in _compile_branch\n    return _branch(self.compile(expr) for expr in exprs)\n  File \"/private/var/mobile/Containers/Shared/AppGroup/3CA811DC-91BC-4964-9CFE-81FFABD1596F/Documents/site-packages/hy/compiler.py\", line 313, in _branch\n    results = list(results)\n  File \"/private/var/mobile/Containers/Shared/AppGroup/3CA811DC-91BC-4964-9CFE-81FFABD1596F/Documents/site-packages/hy/compiler.py\", line 483, in \n    return _branch(self.compile(expr) for expr in exprs)\n  File \"/private/var/mobile/Containers/Shared/AppGroup/3CA811DC-91BC-4964-9CFE-81FFABD1596F/Documents/site-packages/hy/compiler.py\", line 442, in compile\n    raise HyCompileError(Exception(\"Unknown type: %s'\" % _type))\nHyCompileError: Internal Compiler Bug \ud83d\ude31\n\u2937 Exception: Unknown type:'\nCompilation traceback:\nNo traceback available. \ud83d\ude1f\n=> \n. ",
    "remexre": "I'm on version 0.11.0, the latest from sudo pip install hy.\n. I'm on version 0.11.0, the latest from sudo pip install hy.\n. Oh, sorry, I'm more used to a stable-master unstable-develop branch, rather than unstable-master stable-stable branch. My bad.\n. Oh, sorry, I'm more used to a stable-master unstable-develop branch, rather than unstable-master stable-stable branch. My bad.\n. ",
    "kevinjqiu": "@gilch Thanks!\n. ",
    "koji-kojiro": "I propose that use foo = getattr(bar, \"foo\") instead of  from bar import foo. \nThe second case, (reduce + [1 2]) becomes:\n```python\nimport hy.core.shadow\n+ = getattr(hy.core.shadow, \"+\") \nequivalent to from hy.core.shadow import +\nreduce(+, [1L, 2L])\nwe can replace '+' with any valid identifier\n. That might be solved as follows:python\nglobals().update({'+': 123})\n+ = globals().get('+')\nequivalent to + = 123\n``. What @woodrush mentioned is not a problem of onlyhy2py`.\n```shell-session\n$ hy -c \"(import [future [print_function]]) (def name 10)\"\nTraceback (most recent call last):\n  File \"/usr/local/bin/hy\", line 9, in \n    load_entry_point('hy==0.12.1+101.g5bf9ecf', 'console_scripts', 'hy')()\n  File \"/usr/local/lib/python3.5/dist-packages/hy/cmdline.py\", line 344, in hy_main\n    sys.exit(cmdline_handler(\"hy\", sys.argv))\n  File \"/usr/local/lib/python3.5/dist-packages/hy/cmdline.py\", line 313, in cmdline_handler\n    return run_command(options.command)\n  File \"/usr/local/lib/python3.5/dist-packages/hy/cmdline.py\", line 193, in run_command\n    pretty_error(import_buffer_to_module, \"main\", source)\n  File \"/usr/local/lib/python3.5/dist-packages/hy/cmdline.py\", line 184, in pretty_error\n    return func(args, *kw)\n  File \"/usr/local/lib/python3.5/dist-packages/hy/importer.py\", line 135, in import_buffer_to_module\n    eval(ast_compile(_ast, \"\", \"exec\"), mod.dict)\n  File \"/usr/local/lib/python3.5/dist-packages/hy/importer.py\", line 29, in ast_compile\n    return compile(ast, filename, mode, flags)\n  File \"\", line 1\nSyntaxError: from future imports must occur at the beginning of the file\n```\n. ",
    "martinakcsilla": "Which part of the tutorial needs updating? A quick skim through it doesn't reveal anything obvious, except maybe two examples:\n- The (defclass) example where --init-- has an explicit None at the end, which could be omitted.\n- An apply example in the \"Hy <-> Python interop\" section, where the named arguments could use keywords instead of strings.\nIs there anything else? The rest of the syntax changes appear to be reflected in the tutorial too.\n. Updated. Didn't notice they rendered badly, sorry.\n. ",
    "Scorpil": "BTW, is there any reason to prefix keywords with \\uFDD0? Couldn't find any place where it is actually useful.\n. Comment would be useful, since I'm still not following :)\n\\uFDD0 is not character '. According to this link it's actually unassigned. My terminal certainly can't print it...\n. Ah, got it. Thanks.\n. @berkerpeksag i've checked it - you're right. self.message there is correct unicode value on our side, so clint supposed to handle it correctly, but because of the bug it doesn't. I've sent PR https://github.com/kennethreitz/clint/pull/153 but it can take a while.\nIn the meantime, I've updated my fix to work around this bug by sending encoded string instead of unicode (as you suggested).\n. Done. Glad to help.\n. ",
    "felixonmars": "py34 is also missing from tox, though. I'll add both then :)\n. classifiers updated. I think TOX_ENV is good, and I can update this PR if decided :)\n. Updated.\npython: 3.5 was added due to a Travis issue: https://github.com/travis-ci/travis-ci/issues/4794#issuecomment-143758799\npassenv = TERM was added to workaround a pypy failure under tox, according to https://botbot.me/freenode/pypy/2015-06-06/?msg=41126051&page=2\n. Updated to make Travis display better table :)\n. A friendly ping :)\n. ",
    "aqui18": "oh that makes sense.\nThanks\n. Actually, just tried it with the string as the key word.\nStill the same issue:\nGreetings, Sir Foo\nGreetings, Darth Foo\nTraceback (most recent call last):\n  File \"/usr/local/bin/hy\", line 11, in <module>\n    sys.exit(hy_main())\n  File \"/usr/local/lib/python3.5/site-packages/hy/cmdline.py\", line 347, in hy_main\n    sys.exit(cmdline_handler(\"hy\", sys.argv))\n  File \"/usr/local/lib/python3.5/site-packages/hy/cmdline.py\", line 335, in cmdline_handler\n    return run_file(options.args[0])\n  File \"/usr/local/lib/python3.5/site-packages/hy/cmdline.py\", line 210, in run_file\n    import_file_to_module(\"__main__\", filename)\n  File \"/usr/local/lib/python3.5/site-packages/hy/importer.py\", line 78, in import_file_to_module\n    eval(ast_compile(_ast, fpath, \"exec\"), mod.__dict__)\n  File \"./package.hy\", line 24, in <module>\n    (apply (. greetings greet) [\"Foo\"] {\"title\" \"Lord\"})\nTypeError: greet() missing 1 required positional argument: 'name'\n. Seems to be working on the latest release when I build from source - so I guess I'll close this.\n. ",
    "digitalvectorz": "We had an issue with using the up and down arrows to recall previous\ncommands...the tab complete was a consequence of fixing that\nJohnathon Mlady\n[GoogleVoice] 440.782.1dvz (1389)\nOn Dec 12, 2015 12:47 PM, notifications@github.com wrote:\n\n@digitalvectorz https://github.com/digitalvectorz don't we already have\ntab complete? (\nhttps://github.com/hylang/hy/blob/master/hy/completer.py#L50-L53)\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/pull/993#issuecomment-164171227.\n. Ubuntu 12.04  python 3.5 virtual env...fresh install.\n\nJohnathon Mlady\n[GoogleVoice] 440.782.1dvz (1389)\nOn Dec 12, 2015 12:52 PM, notifications@github.com wrote:\n\n(We import readline over in\nhttps://github.com/hylang/hy/blob/master/hy/completer.py#L40-L48 too)\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/pull/993#issuecomment-164171527.\n. When I get to the computer I will...\n\nLaunching with just hy from command line\nJohnathon Mlady\n[GoogleVoice] 440.782.1dvz (1389)\nOn Dec 12, 2015 12:58 PM, notifications@github.com wrote:\n\n@digitalvectorz https://github.com/digitalvectorz I can't reproduce -\nand on and older version --\nhttp://asciinema.org/a/89notjhpgljyt390qe6tpx9f7\nHow are you launching hy? Can you send me a screengrab?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/hylang/hy/pull/993#issuecomment-164171946.\n. \n",
    "jwilk": "Sort of. :)\n. Yeah, I don't think scheme-relative URLs should be used for links to external sites.\nAlso, they wouldn't even work in offline documentation: the browser would interpret //foo.example.com/ as file://foo.example.com/, which makes no sense.\n. I doubt any real users would ever see this, but in theory, yes, it's user-visible.\nI've added a test.. ",
    "rduplain": "The doctest module parses and runs examples, so it'd take re-implementing that.\n\nThe main reason you put tests in docstrings is to show examples of intended use.\n\n+1\n\nIf the examples are in a different language it kind of defeats the purpose.\n\nNot if you are calling your code from Python, not hy. It's still relevant to show Python-based examples.\n. ",
    "ttkk1024": "@tuturto thank you very much\n. The hylang team should change hylang documention.. ",
    "krysros": "@rwtolbert \nThanks for your reply. After updating pyreadline:\n```\n(testhy) C:\\Users\\Kros\\Desktop>pip install pyreadline==2.1\nCollecting pyreadline==2.1\n  Using cached pyreadline-2.1.zip\nInstalling collected packages: pyreadline\n  Found existing installation: pyreadline 2.0\n    Uninstalling pyreadline-2.0:\n      Successfully uninstalled pyreadline-2.0\n  Running setup.py install for pyreadline ... done\nSuccessfully installed pyreadline-2.1\n(testhy) C:\\Users\\Kros\\Desktop>hy\nTraceback (most recent call last):\n  File \"c:\\users\\kros\\desktop\\testhy\\lib\\site-packages\\pkg_resources__init__.py\", line 651, in _build_master\n    ws.require(requires)\n  File \"c:\\users\\kros\\desktop\\testhy\\lib\\site-packages\\pkg_resources__init__.py\", line 952, in require\n    needed = self.resolve(parse_requirements(requirements))\n  File \"c:\\users\\kros\\desktop\\testhy\\lib\\site-packages\\pkg_resources__init__.py\", line 844, in resolve\n    raise VersionConflict(dist, req).with_context(dependent_req)\npkg_resources.ContextualVersionConflict: (pyreadline 2.1 (c:\\users\\kros\\desktop\\testhy\\lib\\site-packages), Requirement.parse('pyreadline==2.0'), {'hy'})\nDuring handling of the above exception, another exception occurred:\nTraceback (most recent call last):\n  File \"C:\\Users\\Kros\\Desktop\\testhy\\Scripts\\hy-script.py\", line 5, in \n    from pkg_resources import load_entry_point\n  File \"c:\\users\\kros\\desktop\\testhy\\lib\\site-packages\\pkg_resources__init__.py\", line 3084, in \n    @_call_aside\n  File \"c:\\users\\kros\\desktop\\testhy\\lib\\site-packages\\pkg_resources__init__.py\", line 3070, in _call_aside\n    f(args, *kwargs)\n  File \"c:\\users\\kros\\desktop\\testhy\\lib\\site-packages\\pkg_resources__init__.py\", line 3097, in _initialize_master_working_set\n    working_set = WorkingSet._build_master()\n  File \"c:\\users\\kros\\desktop\\testhy\\lib\\site-packages\\pkg_resources__init__.py\", line 653, in _build_master\n    return cls._build_from_requirements(requires)\n  File \"c:\\users\\kros\\desktop\\testhy\\lib\\site-packages\\pkg_resources__init__.py\", line 666, in _build_from_requirements\n    dists = ws.resolve(reqs, Environment())\n  File \"c:\\users\\kros\\desktop\\testhy\\lib\\site-packages\\pkg_resources__init__.py\", line 839, in resolve\n    raise DistributionNotFound(req, requirers)\npkg_resources.DistributionNotFound: The 'pyreadline==2.0' distribution was not found and is required by hy\n```\n. ",
    "poltak": "Fixed up that little grammar issue and also found another little inconsistency between code snippets in python and hy.\nThree commits containing changes in total, which I've tried to squash into one in d858107263ece7e43a28e33de3a79402676437b0\n. ",
    "leiserfg": "Mmm, it hapend with the version installed from pypi, not with the code that are on master, update the package please.\n. Ha ha ha. I was using the latest doc with the stable version of the code, sorry :D\n. ",
    "madanh": "Thanks, for the expl., commented on #1198. The problem stems from the fact that this repo uses a single branch but readthedocs assumes a \"master-develop\" branching model. Other CI tools might have this assumption by default, so it might be worthy to consider adopting it.. ",
    "Perif": "Adding a link to the gitready squashing guide would make sense but since GitHub helps to do that when merging, is this issue still current ?\n. You are welcome ! :+1: \n. ",
    "levthedev": "Yes, it is! I'll get on that now :)\n. ",
    "sentientcucumber": "Seems like this a duplicate (or very closely related) of #249?\nIt seems like the behavior may have changed since this was originally opened. When I run the above\n``` hy\n=> (print (setv x 7 y 42))\n  File \"\", line 1, column 8\n(print (setv x 7 y 42))\n         ^-------------^\nHyTypeError: `setv' needs 2 arguments, got 4\n=> (print (setv x 42))\n42\n=> (print (setv x 7 x 42))\n  File \"\", line 1, column 8\n(print (setv x 7 x 42))\n         ^-------------^\nHyTypeError: `setv' needs 2 arguments, got 4\n```\nFrom the other issue\nhy\n=> (print (setv (, a b) [1 2]))                 \n(1, 2)\n. ",
    "brandonblock": "Thanks for the excellently informative answer!\n. ",
    "Digenis": "This is not specific to django; lot of software uses pkgutil.iter_modules.\n. @berkerpeksag, where did you find documentation besides the 2-3 relevant peps?\nDo you know any model implementation for a path hook?\n. Very excited to see this finally happening.\nGreat work @elfsternberg\n. ",
    "elfsternberg": "True.  Closing until I find a better fix.\n. @berkerpeksag You're probably right; I'll look into that and consider a better implementation after I finish the work I get paid for.  Sigh  Hacking this stuff is so much more fun.\n@digenis Unfortunately, no, I don't.  I spent several days deep inside the source code of importlib and pkgutil, hand-tracing various steps through the process in order to discern what it was really doing with respect to the code, before I managed to come up with this solution.  I'm going to get a pretty good blog post out of it sometime soon, I imagine.  The importlib/pkgutil relationship is excessively complicated.\nThe big lesson here is that having multiple alternative language syntaxes that produce Python ASTs, and having that code present in the same source tree (as both Hy and Py files), is something Python was never, ever meant to support, and coercing it to support such requires a degree of Python black magic most of us never actually want to get into!\n. @berkerpeksag I'm afraid that pkgutils, at least under Python 3.4, uses the singledispatch() decorator in order to direct iter_importer_modules to the correct iterator.  Moving iter_modules into HyFileFinder didn't work.  \"Monkeypatch\" is perhaps the wrong word to describe that particular action; I'm just registering a Hy module recognizer with iter_modules.\nI most certainly am monkeypatching FileFinder and FileLoader to call the right compiler when it's .py or .hy.\n. Gahh.  Importlib isn't a very stable piece of code.\n. I'm withdrawing this pull request until I get a better handle on the internals through Py 2.7.\n. @kirbyfan64 I agree those are bizarre, but... I have to wonder.  \nIn ordinary Python2, ((1 / 2) == 0.5) == False, as this expression uses integer division.\nIn Hy (= (= 0.5 (/ 1 2)) True) because it's using the truedivision operator.  So now the question is, WHY didn't that get picked up here?  What did I miss?\nThe loader is supposed to privilege python syntax imports first.  This is a fascinating edge case.  Let me look into it.\n[Edit] Gads, I'm an idiot.  I forgot to add the flags properly.  Fixed!\n. ",
    "IndieRobert": "Get the following python code:\nimport hy\nfrom hy import HyExpression, HyList, HySymbol\nf = False\nt = True\nkey = Key()\nmouse = Mouse()\nESC = KEY_ESCAPE\n@hy.macros.macro(u'awhen')\ndef _hy_anon_fn_1(x, *body):\n    return HyExpression(((([] + [HySymbol(u'let')]) + [HyList((([] + [HySymbol(u'it')]) + [x]))]) + [HyExpression(((([] + [HySymbol(u'when')]) + [HySym\nbol(u'it')]) + list(body)))]))\n@hy.macros.macro(u'when1')\ndef _hy_anon_fn_2(x, *body):\n    return HyExpression((((([] + [HySymbol(u'awhen')]) + [x]) + list(body)) + [HySymbol(u'it')]))\n@hy.macros.macro(u'until')\ndef _hy_anon_fn_3(c, *body):\n    return HyExpression(((([] + [HySymbol(u'while')]) + [HyExpression((([] + [HySymbol(u'not')]) + [c]))]) + list(body)))\n@hy.macros.macro(u'is_key')\ndef _hy_anon_fn_4(k, *body):\n    return HyExpression(((([] + [HySymbol(u'when1')]) + [HyExpression((([] + [HySymbol(u'console_is_key_pressed')]) + [k]))]) + list(body)))\nis_win_closed = console_is_window_closed\ndef inputs():\n    return sys_check_for_event(EVENT_ANY, key, mouse)\ndef _hy_anon_fn_6():\n    it = None\n    console_is_key_pressed = ESC\n    return (it if it else None)\nwhile (not (is_win_closed() or _hy_anon_fn_6())):\n    inputs()\n    console_flush()\nNotice that _hy_anon_fn_6 is completely weird\n. It works with the latest. Sorry for that.\n. ",
    "Jiehong": "Let me try to understand that clearly.\nAway from hy, in another lisp, I'd expect the following:\nlisp\n(set a 1)\n; This is read as a list\n; Evaluated with 'set' as a function, fail if doesn't exist\n; Then 'a' is evaluated, and this would fail as 'a' is unassigned yet (void variable)\n(set (quote a) 1)\n; Same as before, but the 'quote' macro would evaluate to the symbol 'a'\n; Then the set would finish correctly and 'a' would be equal to 1 after this line\n(set 'a 1)\n; Ok, same, but the read pass will convert this to the previous form, so it's identical.\nTrying to look in the code of hy, setv seems to be defined in compiler.py, and is thus a 'native' construct of the language, dropping the need for quoting for the variable.\nWhat was the intend behind this when setv was conceived? I'm just being curious.\nCorrect me if I'm wrong though.\n. I simply wanted to reformulate on my own here :)\nThanks for this nonetheless!\n. ",
    "ttsiodras": "Damn, I missed an extra dash. Sorry for the noise!\n=> (list (->> (src) (filter (fn [x] (.startswith x \"a\")))))\n['a']\n. ",
    "lthibault": "Could you profile the code?  I suppose the bottleneck could be rewritten with Cython in principle, but it would be up to the maintainers to decide whether the added complexity is worthwhile.\n. ",
    "alton-campbell": "Never mind, this is a duplicate of #1022.\n. ",
    "viksit": "Ah I meant - if one were to write something in Python and the same thing in hy - how much of a perf hit could you expect?\n\nOn Aug 30, 2016, at 16:10, Ryan Gonzalez notifications@github.com wrote:\nHy performs no optimizationss over Python, FYI.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Well I'd like to use macros and other lispy features of course rather than emulate the procedural style. Did you mean that doing that will have an impact here?\n\nThanks for the pointer on let!\n\nOn Aug 30, 2016, at 16:28, Ryan Gonzalez notifications@github.com wrote:\nAh, ok.\nIf you write your code exactly like Python, then it should be minimal performance impact, pretty much all from implicit results that Hy generates.\nIf you go more Lisp-y, before of statements in short-circuiting expressions (e.g. (and (setv a 1) 2) and, in particular:\nBEWARE OF let. It's not fast.\nOther than that, I don't recall anything else of interest.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. \n",
    "ntrifunovic": "@algernon: This works:\n`` hy\n(defmacro fun1 [method name](defn ~(HySymbol (+ method \"_\" name))  [] print \"hello\"))\n(fun1 new fun)\n(new-fun)\n```\nI still needed to convert - to _ to make it work.\n. ",
    "EMayej": "Thanks. It's OK now.\n. ",
    "h2non": "Cool, Thanks! Any estimated release date for 0.12.0?. ",
    "abhi18av": "I'm on Ubuntu 16.04 which comes with python3 by default - you reckon that might be the issue?\npip 8.1.1 from /usr/lib/python3/dist-packages (python 3.5) is what pip -version prints out.\nBut for the first question, I don't really know how to uninstall a module installed via python setup.py install.. Hey, @Kodiologist  I did update the pip and now it works fine. Whoops :)\nThank you for your time, I appreciate it \ud83d\udc4d . Ah, I see. Well, I was unaware of that. Feel free to close the request :)\nRegarding, doc, here I try it with\n- apply\n- reduce\n- eval\n```clojure\n\u279c  ~ hy\nhy 0.13.0 using CPython(default) 3.5.1+ on Linux\n=> (doc apply)\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.5/dist-packages/hy/cmdline.py\", line 102, in runsource\n    ast_callback)\n  File \"/usr/local/lib/python3.5/dist-packages/hy/importer.py\", line 176, in hy_eval\n    return eval(ast_compile(expr, \"\", \"eval\"), namespace)\n  File \"\", line 1, in \nNameError: name 'doc' is not defined\n=> (doc reduce)\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.5/dist-packages/hy/cmdline.py\", line 102, in runsource\n    ast_callback)\n  File \"/usr/local/lib/python3.5/dist-packages/hy/importer.py\", line 176, in hy_eval\n    return eval(ast_compile(expr, \"\", \"eval\"), namespace)\n  File \"\", line 1, in \nNameError: name 'doc' is not defined\n=> (doc eval)\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.5/dist-packages/hy/cmdline.py\", line 102, in runsource\n    ast_callback)\n  File \"/usr/local/lib/python3.5/dist-packages/hy/importer.py\", line 176, in hy_eval\n    return eval(ast_compile(expr, \"\", \"eval\"), namespace)\n  File \"\", line 1, in \nNameError: name 'doc' is not defined\n=> \n```\nNeither does it show up in the code-completions\n```clojure\n=> do\ndo    doto\n=> do\n``. @kirbyfan64 , I saw morehylibs in your profile and I've started this project [awesome-hy`](https://github.com/abhi18av/awesome-hy). \nPlease do fork and add to them!. ",
    "mr-karan": "Sorry, I messed up this branch in my local git and wasn't able to rebase properly. i have opened a new PR and made the changes request. https://github.com/hylang/hy/pull/1164 \nApologies again !. ",
    "adamfeuer": "@Kodiologist @Tritlo I'm interested in doing the work to get this merged. What needs to be done? Should I submit a new PR, referencing this one?. @Kodiologist @Tritlo I think I'd rather work on my own fork - will that be ok? \nI cloned from hy/master into my account adamfeuer/hy and then merged tritlo/master into it. Then I fixed the merge conflicts.\nI'm working on getting all the tests running.. @Tritlo Yes, your commit is there - thanks for your work on it. I'm just more comfortable using my own fork in case I screw things up. Also I'm willing to merge the changes from my branch back into yours when everything works if you want.\n. @Kodiologist @Tritlo ok, got all the tests to pass on Python 3.6 on my branch. How do I get the tests to run in travis? By doing PR, or updating this PR by merging my changes into @Tritlo's branch?. @Kodiologist @Tritlo Ok, I got travis running the tests on my branch. We'll see how it goes.... @Kodiologist @Tritlo All the tests pass on all platforms:\nhttps://travis-ci.org/adamfeuer/hy\nHere's the branch:\nhttps://github.com/hylang/hy/compare/master...adamfeuer:feature/tail-call-optimization\nAnything else to be done? If not, I can merge back to @Tritlo's branch for continuity so the merging can be done here in this PR.. @Kodiologist I haven't checked that bug, will work with @Tritlo on it offline, and report back here.. ",
    "profitware": "It seems that highlight.js is not the proper repository for the code as I would like the project in future to cover not only highlight.js library but also Rouge and may be some other libraries for syntax highlighting that doesn't support Hy yet.\nI would appreciate if someone who has permissions creates a new repo in HyLang org for Hyghlight project then. The PR should be closed afterwards.\nThanks.. That sounds fine for me. Thank you.. @Kodiologist may you create a new repo named \"hyghlight\" in hylang organization then?. @Kodiologist could you also make an initial commit containing Hy's .gitignore and LICENSE in the repo? Github doesn't provide a possibility to fork an empty repo and create PRs there. Thank you.. remote: Permission to hylang/hyghlight.git denied to profitware.\nfatal: unable to access 'https://github.com/hylang/hyghlight/': The requested URL returned error: 403. Thank you, @Kodiologist . ",
    "dangom": "Thx for the quick reply. \nThe expansion of `(= \".\" ~(get (name numpy) 0)) seems correct. I'd expect it to eval just fine...\nExpanding the macro won't work when errors are thrown.. Wow, that must be it.\nCasting the str to a HyString solves the issue.\n=> (eval `(= \".\" ~(HyString (get (name numpy) 0))))\nFalse\nWouldn't know how to fix it though. Should str be cast to HyString internally?. ",
    "edouardklein": "I'm just commenting to say that I'm affected by this too.\nI'll use the explicit cast to HyString as a workaround for now.. Yep, I'm just away from the office, I only have a cell phone. If that's\nallright I'll do it next week.\nI'll try sometime in the next few days, but I can't promise I'll be\nconfortable enough with github's web tools on mobile to be successful.\nLe sam. 2 f\u00e9vr. 2019 \u00e0 15:17, Kodi Arfer notifications@github.com a\n\u00e9crit :\n\nSo, do you want to change it per my comment?\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/hylang/hy/pull/1736#issuecomment-459968559, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AApF7cB891SR4ggGxJ6e4SJP0OkTw8xuks5vJZ3jgaJpZM4aRTGV\n.\n. Of course! It was just a small catch after I updated hy and my earmuffs did\nnot interop with Python anymore. I searched the docs and saw that it should\nstill work, and then came to the issues and saw the discussion about\nmangling. Please do what is the easiest for you, or instruct me to do what\nis easiest for everyone and I'll be happy to do it next week.\n\nLe dim. 3 f\u00e9vr. 2019 \u00e0 02:04, Kodi Arfer notifications@github.com a\n\u00e9crit :\n\nI can just rebase it for you if you agree to the change.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/hylang/hy/pull/1736#issuecomment-460013438, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AApF7aOpBlUfchzyNaILhIJsMuP3_Yclks5vJjW5gaJpZM4aRTGV\n.\n. \n",
    "pyx": "Thank you @tuturto, the complement function is the same as Clojure's, except we don't need to write it as multi-motheds :)\n@gilch is right, those functions will be convenient to use with HOFs while in other cases, threading macros are probably more suitable. \nPlease note that the constant function in Hymn generates a customized docstring on the fly from the value, but we usually do not want that happen in more general cases (e.g in stdlib), as there is no guarantee that .__str__ / .__repr__ / .__unicode__ of the value will be pure functions.\nLast but not least, let me take this opportunity to say thank you to all of you.  Hy is great, and I still remember the jaw-dropping moments when on that lightning talk, Paul showed us importing hy modules in python and stepping through hy in gdb...\nEDIT: s/lighting/lightning/. FYI, I found out the anaphoric macro version is called ap-compose.. On second thought, flip in languages without auto currying (as in Haskell and ML family languages) might be of little use, as in, to partially apply the flipped function (the most general use cases of flip), we need explicit function call (functools.partial) or lambda expression anyway, there is no saving compare to a plain old lambda in the first place.. Agree with gilch and Kodiologist, ((comp f  g) x) means (f (g x)).\nRegarding tests, compose does obey three laws, provided function f, g and h are pure functions, id is identity function and .(dot) is compose function:\n1. left identity\n(id . f) x = f x\n2. right identity\n(f . id) x = f x\n3. associative\n((f . g) . h) x = (f . (g . h)) x\nThis is how I test compose in hymn, even though it looks like overkill for such a simple function. :). @tuturto, sure, my pleasure, if you find that useful, please do whatever you want, including re-licensing, I didn't put a no-evil clause on it. :D . @tuturto \nIn case you were talking about not only the tests but also the function itself, please notice that there is a design decision I made that might not be suitable for standard library: I did not catch the no-argument case, since the function was meant to be used only internally, an exception from reduce is enough for me.\nI think there are two sensible options:\n1. comp can be called with any number of arguments, return identity function when no argument provided.\nEDIT: one if test for no-arugment case is enough, reduce can handle sequence with only one element.\n\ncomp should be called with at least one argument, something like\nhy\n(defn compose [f &rest fs]\n  \"function composition\"\n  (defn compose-2 [f g]\n    \"compose 2 functions\"\n    (fn [&rest args &kwargs kwargs]\n      (f (apply g args kwargs))))\n  (reduce compose-2 fs f))\nshould do. May I suggest a minor improvement,\nsince we have if taking out the empty case, and reduce can handle sequence with a single element by returning that sole element, which is what we expect in this case. (comp f) == f\nhy\n(reduce compose-2 (list (rest fs)) (first fs))\ncan be\nhy\n(reduce compose-2 fs)\n. @gilch \nIMHO, I do not understand the nested for loop, it works because in Hy, reversed, like in python3, returns a generator, so the first iteration on the outer loop fetch the first function, then all the work done inside inner loop, then the generator is exhausted, yielding the expected result (each function been called once and only once).\n\nBut, then this composed function can only be called once, because the function list (fs) is defined in outer scope of the function, try:\nhy\nhy 0.11.0+353.gca6fd66 using CPython(default) 3.5.2 on Linux\n=> (defn comp [&rest fs]\n...   (if (not fs) identity\n...       (= 1 (len fs)) (first fs)\n...       (do (setv fs (reversed fs))\n...           (fn [&rest args &kwargs kwargs]\n...             (for* [f fs] (setv res (apply f args kwargs))\n...               (for* [f fs] (setv res (f res)))) res))))\n=> (def inc4 (comp inc inc inc inc))\n=> (inc4 1)\n5\n=> (inc4 1)\nTraceback (most recent call last):\n  File \"<input>\", line 1, in <module>\n  File \"<input>\", line 263, in _hy_anon_fn_1\nUnboundLocalError: local variable 'res' referenced before assignment\n=>\nHere is my take:\nhy\n(defn comp [&rest fs]\n  (if (not fs) identity\n      (= 1 (len fs)) (first fs)\n      (do (setv rfs (reversed fs)\n                first-f (next rfs)\n                fs (tuple rfs))\n          (fn [&rest args &kwargs kwargs]\n            (setv res (apply first-f args kwargs))\n            (for* [f fs]\n              (setv res (f res)))\n            res))))\nNotice:\n1. I used next instead of first, to make explicit the intent that we want to advance the generator once.\n2. I used tuple call to make the rest of sequence re-usable, I guess tuple should have small footprint and better performance.\n3. I named the first function first-f, a little bit ugly, but we need a different name or we will have the (in)famous UnboundLocalError exception, no nonlocal here, because we still support python2. Oh, lovely python scoping ... :). @Kodiologist \nGenerating reversed list each time on-the-fly (inside the inner function) is fine, as we usually do not feed too much into comp, so the performance lost should be acceptable, but this version will call the last (of the argument list) function twice:\nhy\nhy 0.11.0+353.gca6fd66 using CPython(default) 3.5.2 on Linux\n=> (defn comp [&rest fs]\n...   (if (not fs) identity\n...       (= 1 (len fs)) (first fs)\n...       (fn [&rest args &kwargs kwargs]\n...         (setv res (apply (get fs -1) args kwargs))\n...         (for [f (reversed fs)]\n...           (setv res (f res)))\n...         res)))\n=> (def inc4 (comp inc inc inc (fn [n] (print \"hit!\") (inc n))))\n=> (inc4 1)\nhit!\nhit!\n6\nEdit: spelling mistake. I think the most common case of compose, might be that the composed fuction will be re-used a lot, think map, so on a second thought, we might better prepare the function list before entering into the scope of inner (composed) function.\nAnd I wrote a naive time-it macro as mentioned by @gilch, I will open a new issue.. Now that we have a proper (I hope so) timeit macro https://github.com/hylang/hy/issues/1181\nAnd we have three implementations:\n```hy\n(defn comp-f [&rest fs]\n   \"function composition\"\n   (defn compose-2 [f g]\n     \"compose 2 functions\"\n     (fn [&rest args &kwargs kwargs]\n       (f (apply g args kwargs))))\n   (if fs\n     (reduce compose-2 fs)\n     identity))\n(defn comp-i1 [&rest fs]\n  (if (not fs) identity\n      (= 1 (len fs)) (first fs)\n      (fn [&rest args &kwargs kwargs]\n        (setv res (apply (get fs -1) args kwargs))\n        (for [f (cut fs -2 None -1)]\n          (setv res (f res)))\n        res)))\n(defn comp-i2 [&rest fs]\n  (if (not fs) identity\n      (= 1 (len fs)) (first fs)\n      (do (setv rfs (reversed fs)\n                first-f (next rfs)\n                fs (tuple rfs))\n          (fn [&rest args &kwargs kwargs]\n            (setv res (apply first-f args kwargs))\n            (for* [f fs]\n              (setv res (f res)))\n            res))))\nIt's time to let the data speak:hy\n=> (defn comp-f [&rest fs]\n...    \"function composition\"\n...    (defn compose-2 [f g]\n...      \"compose 2 functions\"\n...      (fn [&rest args &kwargs kwargs]\n...        (f (apply g args kwargs))))\n...    (if fs\n...      (reduce compose-2 fs)\n...      identity))\n=> (defn comp-i1 [&rest fs]\n...   (if (not fs) identity\n...       (= 1 (len fs)) (first fs)\n...       (fn [&rest args &kwargs kwargs]\n...         (setv res (apply (get fs -1) args kwargs))\n...         (for [f (cut fs -2 None -1)]\n...           (setv res (f res)))\n...         res)))\n=> (defn comp-i2 [&rest fs]\n...   (if (not fs) identity\n...       (= 1 (len fs)) (first fs)\n...       (do (setv rfs (reversed fs)\n...                 first-f (next rfs)\n...                 fs (tuple rfs))\n...           (fn [&rest args &kwargs kwargs]\n...             (setv res (apply first-f args kwargs))\n...             (for* [f fs]\n...               (setv res (f res)))\n...             res))))\n=> (print ((comp-f inc inc inc inc) 1))\n5\n=> (print ((comp-i1 inc inc inc inc) 1))\n5\n=> (print ((comp-i2 inc inc inc inc) 1))\n5\n=> (time-it ((comp-f inc inc inc inc) 1))\n11.021359261001635\n=> (time-it ((comp-i1 inc inc inc inc) 1))\n8.513512686997274\n=> (time-it ((comp-i2 inc inc inc inc) 1))\n12.34987382899999\n=> (time-it (inc4 1) (setv inc4 (comp-f inc inc inc inc)))\n4.459002538002096\n=> (time-it (inc4 1) (setv inc4 (comp-i1 inc inc inc inc)))\n4.978545720001421\n=> (time-it (inc4 1) (setv inc4 (comp-i2 inc inc inc inc)))\n3.3503086150012678\n```\nCalling cut is actually slower than recurring 4 times. If we try 10 (on my machine), then it starts to gain:\nhy\n=> (time-it (inc10 1) (setv inc10 (comp-f inc inc inc inc inc inc inc inc inc inc)))\n11.87790252600098\n=> (time-it (inc10 1) (setv inc10 (comp-i1 inc inc inc inc inc inc inc inc inc inc)))\n7.043803205000586\n=> (time-it (inc10 1) (setv inc10 (comp-i2 inc inc inc inc inc inc inc inc inc inc)))\n5.294795802998124. Now that I think flip might not be a good idea, but may I propose other two handy functions?\npipe - the counterpart of comp\nhy\n(defn pipe [&rest fs]\n  \"docstring goes here\"\n  (apply comp (reversed fs)))\nin use\nhy\n=> (def inc-str (pipe int inc str))\n=> (inc-str \"41\")\n'42'\njuxt - I saw this one when I read about the \"see also\" part on clojure-docs, did not read the implementation though\nhy\n(defn juxt [f &rest fs]\n  \"docstring goes here\"\n  (setv fs (cons f fs))\n  (fn [&rest args &kwargs kwargs]\n    (setv res [])\n    (for* [f fs]\n      (.append res (apply f args kwargs)))\n    res))\nI can imagine juxt will be super handy in data processing\n```hy\n=> ((juxt min max sum) (range 1 101))\n[1, 100, 5050]\n=> (setv [total difference product quotient] ((juxt + - * /) 24 3))\n[27, 21, 72, 8.0]\n=> (import [operator [itemgetter]])\n=> ((juxt (itemgetter 'name) (itemgetter 'age)) {'name 'Joe 'age 42 'height 182})\n['Joe', 42]\n. @Kodiologist, fair enough, but usuallypipeis defined in terms ofcompto avoid duplicate code, so that PR will be depending on this one, in this case, it might be less management effort to go withcomp```.\njuxt, I can draft a separate PR.. @gilch Since I am new here, sometimes I don't know which way should I go, e.g, I am not sure if creating a new issue regarding yet-to-be merged PR is a proper way of giving feedback.\nThat's why I did not draft a PR myself in the first place, I know it should come with proper documentation and test cases, to which the requirements I am not quite sure about.  I will try, for juxt, anyway.\nAbout cut vs reversed when precomputing, I think the invocation of comp is a onetime event in most cases (data processing/analysis, web app(?), etc.), the difference is acceptable, to say the least, so whichever with better readability should win, and I vote reversed for being straightforward, cut, IMHO, is not like [::-1], which is a well known pythonic idiom.. I have juxt implemented with documentation and test, should I create a PR now, or wait until this PR get merged first then rebase, cause it will create merge conflict[1] right now, both PRs touch the *exports* part.\n[1] That's why I proposed pipe and juxt into this PR instead of a separate one.. @Kodiologist , okay, I will add pipe into the mix (just juxt right now) and send a PR later. Thanks.. @gilch this is my thought on pipe\nWhen composing with, let's say, more than a handful functions, pipe is easier to work with, case study:\nAssuming we are building a file processing pipeline, and have these functions:\nread-file write-file parse-file rename transform-phase-1 transform-phase-2 transform-phase-3 , etc.\nThey are all of type \nhaskell\nfile -> file\nWe can build the pipeline like this:\nhy\n(def process\n  (pipe\n    read-file\n    parse-file\n    transform-phase-1\n    transform-phase-2\n    transform-phase-3\n    rename\n    write-file))\nIt's just more natural to read in this case than comp.\nIf I am forced to have only one, I will go with pipe.  But, there is only compose predefined (have a name) in maths, so many functional programming languages only define compose in their standard libraries, it's not because pipe is less useful, to reduce the surprise factor, so compose should stay...\nIf we can have both comp and pipe, I totally agree that define pipe imperatively, then define comp in terms of pipe looks better, especially in (I suppose) common scenarios like above, pipe gets used more.  I might actually go as far as define both imperatively, cause these two functions' behaviours are so well known, and the logic is so trivial, that we do not expect them to be changed in the future, that means almost no maintenance burden.  . @kirbyfan64  @gilch , I totally agree technically (compliment f) is just (comp not f), and in other static compiled languages, the compiler may even inline the function, but iirc, in Hy, not is not a normal function (pun not intended) but a special form, so, cannot be composed:\nhy\nhy 0.11.0+357.g29b3702 using CPython(default) 3.5.2 on Linux\n=> (def my-even? (comp not odd?))\nTraceback (most recent call last):\n  File \"<input>\", line 1, in <module>\nNameError: name 'not' is not defined\n=> not\nTraceback (most recent call last):\n  File \"<input>\", line 1, in <module>\nNameError: name 'not' is not defined\n=> (not True)\nFalse\nIf I remember correctly, you have an issue or milestone regarding this and in, etc.  But it does not work as of today.\nBTW, happy holidays, everyone.. PS. my juxt branch is here https://github.com/hylang/hy/compare/master...pyx:juxt , just waiting for this PR, then rebase, also, if you all agree to add pipe, I can add that too.. Revise, remove excessive do\nhy\n(defmacro/g! time-it [expr &optional setup round]\n  `((fn []\n      (import [timeit [timeit :as ~g!timeit]])\n      ~(when setup setup)\n      (defn testee [] ~expr)\n      (setv kwargs {})\n      ~(when round `(assoc kwargs \"number\" ~round))\n      (apply ~g!timeit [testee] kwargs))))\nIn the beginning, I did not wrap everything inside a function, thus the do form, when I switched to function (to have local scope), I forgot to remove the do. @gilch \nAh, that's a nice idea, a helper function will do, indeed. Thanks.\nI will come back to this when I have time, I need some fresh air now.. Okay, this is what I have so far\nhy\n(defmacro/g! time-it [expr &rest options]\n  (if\n    (not (keyword? (first options)))\n      (setv setup (first options) args (rest options))\n    (in :setup options)\n      (do\n        (setv index (.index options (keyword \"setup\")))\n        (when (= index (dec (len options)))\n          (macro-error None \"Keyword argument :setup needs a value.\"))\n        (setv skipped (, index (inc index))\n              setup (get options (inc index))\n              args (list-comp exp\n                              [(, i exp) (enumerate options)]\n                              (not-in i skipped))))\n    (setv setup None args options))\n  `((fn []\n      (import [timeit [timeit :as ~g!timeit]])\n      ~(when setup setup)\n      (~g!timeit (fn [] ~expr) \"pass\" ~@args))))\nTest drive:\n``hy\nhy 0.11.0+353.gca6fd66 using CPython(default) 3.5.2 on Linux\n=> (defmacro/g! time-it [expr &rest options]\n...   (if\n...     (not (keyword? (first options)))\n...       (setv setup (first options) args (rest options))\n...     (in :setup options)\n...       (do\n...         (setv index (.index options (keyword \"setup\")))\n...         (when (= index (dec (len options)))\n...           (macro-error None \"Keyword argument :setup needs a value.\"))\n...         (setv skipped (, index (inc index))\n...               setup (get options (inc index))\n...               args (list-comp exp\n...                               [(, i exp) (enumerate options)]\n...                               (not-in i skipped))))\n...     (setv setup None args options))\n...((fn []\n...       (import [timeit [timeit :as ~g!timeit]])\n...       ~(when setup setup)\n...       (~g!timeit (fn [] ~expr) \"pass\" ~@args))))\n=> (time-it (inc 1))\n0.6054470939998282\n=> (time-it (inc answer))\nTraceback (most recent call last):\n  File \"\", line 1, in \n  File \"\", line 1, in _hy_anon_fn_2\n  File \"/usr/lib64/python3.5/timeit.py\", line 213, in timeit\n    return Timer(stmt, setup, timer, globals).timeit(number)\n  File \"/usr/lib64/python3.5/timeit.py\", line 178, in timeit\n    timing = self.inner(it, self.timer)\n  File \"\", line 6, in inner\n  File \"\", line 1, in _hy_anon_fn_1\nNameError: name 'answer' is not defined\n=> (time-it (inc answer) (setv answer 42))\n0.6117291800001112\n=> answer\nTraceback (most recent call last):\n  File \"\", line 1, in \nNameError: name 'answer' is not defined\n=> (time-it (print 'Hit) :number 3)\nHit\nHit\nHit\n0.00010172399925068021\n=> (time-it (print 'Hit) () :number 3)\nHit\nHit\nHit\n9.308399967267178e-05\n=> (time-it (print 'Hit) :number 3 :setup (print 'Setup...))\nSetup...\nHit\nHit\nHit\n7.982400347827934e-05\n=> (time-it (print 'Hit) :setup (print 'Setup...) :number 3)\nSetup...\nHit\nHit\nHit\n8.413199975620955e-05\n=> (time-it (inc 1) :setup (print 'Setup...))\nSetup...\n0.5945940750025329\n=> (time-it (inc 1) :setup)\n  File \"\", line 1, column 1\n(time-it (inc 1) :setup)\n  ^----------------------^\nHyMacroExpansionError: b'Keyword argument :setup needs a value.'\n=> (time-it (inc 1) :i-dont-know-what-i-am-doing 42)\nTraceback (most recent call last):\n  File \"\", line 1, in \n  File \"\", line 1, in _hy_anon_fn_2\nTypeError: timeit() got an unexpected keyword argument 'i_dont_know_what_i_am_doing'\n. Thank you.. Oh, I am sorry, I made a mistake when I tried to reproduce the bug I encountered with this testing repository, I should used(require p.m)instead of(require m)```.\nI will close this now, sorry about that.\nPS. I still have no clue about that import halted bug, I got the qualified names correct in that case.. @Kodiologist \nA real world scenario:\nI have a script with repetitive patterns, think argparse setup code, I want to reduce boilerplate code. A locally defined/used one-off macro is a logical choice, acting like C-style macro.\nFYI, I did my hy-0.12 port with macros factored out into a macro-only module, it is a good practice anyway in my use case, but still.. @Kodiologist Without further investigation on how it should work, I am just feeling counter-intuitive that locally defined macros are not in the local scope (should I call it, macro namespace).. @Kodiologist Yes, your wording is accurate, what I mean is, after the first macro expansion, the generated code is somehow not in the scope that have local macros, that's the reason we need another require form. And that macros not in that scope is what I call counter-intuitive.  Macro expansion supposed to be all turtles down :). > the generated code ends up in the same scope as if you wrote it in that spot (where you called the macro, not where you defined it).\nIf I understand what you mean correctly, that's also how I believe the way macro work.\nIn my example at the beginning of this thread, after the expansion of (foo 42), what I got should be (do (require m) (m.bar 42))), then the complier goes on to execute the do form, and require form inside, and then expand that bar macro, and on, and on.\nUp until now, that's how I think lisp macro should work, but, what I mean is, the fact that we need (require m), here, it is because at that point, macro bar (lexically defined before the call site, in the same file) is undefined, that is what I call counter-intuitive.. To put it more clearly,\n(bar 42) works,\nwhile\n(defmacro foo [e] `(bar ~e)) (foo 42) which expends to (bar 42) at the same location does not work (undefined bar).. @Kodiologist oh, I am sorry, my bad, you are right, it works.\nIn the case that macro expansion happens in another file, it makes perfect sense that other macros are not in scope without require.  I forgot the reason that I added require inside macro, was I called those macros in different file, not because they are not in the scope of that same file. Thank you.. @Kodiologist thanks, so the cause should be there is no 'compiled bytecode for macro' (whatever that means) in .pyc files.  Do not generate byte code file for any .hy source with macro definition, maybe?\nIMHO, This is a showstopper.. @Kodiologist it depends, for example, to have easier to remember interface, a package with many public macros, can have all those macros being aggregated into a module, namely 'some_package.macros'.  (I encountered this situation in https://github.com/pyx/hymn ).\nThis issue prevents that.. @Kodiologist \n\nWhat's the point of ap-compose in the first place? The value of the typical composition operator is that given some existing named functions f and g, you can write (compose f g) instead of (fn [x] (f (g (x))). But an anaphoric composition operator only lets you write something like (ap-compose (+ it 1) (* it 3)), which you could just as easily write (fn [it] (+ (+ it 3) 1)). You can't do point-free programming with an anaphoric function.[emphasis mine]\n\nI am actually 100% with you in this regard, especially the last sentence. (Proof: if you remember what sides I was taking when I added comp into stdlib).  I did not follow the development of Hy lately, thus have no idea about when and why regarding this ap-compose, it might even existed before comp.\nBut that's not the point of this issue, I should make it clear that since ap-compose is already there, we should at least make it consistent.. Re-read @Kodiologist's make me believe removing ap-compose might be a better idea, it can be done with (fn [x] (ap-pipe x (+ it 1) (* it 3))) if so desire. (I confess, I wouldn't do that :yum:) . Yes. Like I said here (#1179), pipe as a function is more useful.\nQuoting myself\n\nAssuming we are building a file processing pipeline, and have these functions:\nread-file write-file parse-file rename transform-phase-1 transform-phase-2 transform-phase-3 , etc.\nThey are all of type\nfile -> file\nWe can build the pipeline like this:\nclojure\n(setv process\n  (pipe\n    read-file\n    parse-file\n    transform-phase-1\n    transform-phase-2\n    transform-phase-3\n    rename\n    write-file))\nIt's just more natural to read in this case than comp.. I have a real use case, cause I wrote a static site generator in Hy that's powering a few websites, in the top level of the program, it's similar to the process function above, assembling each phase into a pipeline, except that I am using monadic functions, so the code is a chain of bind instead, some think like:\n\n```clojure\n(setv compile\n  (>=>\n    parse-rst\n    parse-md\n    remove-private\n    add-tag-pages\n    add-category-pages\n    add-archives\n    add-index))\n(setv generate (>=> render add-extra-assets))\n(setv build (>> source (ignore hidden?) compile generate output))\n```\nEach step, parse-rst, compile, generate, output, etc, is a monadic function.\nIf I am chaining normal (not monadic) functions here, pipe (in place of >=>[1]) is the perfect fit.\n[1]: >=> is the operator of the left-to-right Kleisli composition of monads, alias of k-pipe in hymn.. No problem.. Done.. How can I do that in github?  I know how to squash commits in command line, but... Thanks, I am actually using mercurial as git client, I will try.. I tried, it is in fact more complicated, since the sha1 hashing scheme is different, I combine the changes and HG's git bridge loses track of hashes.\nNo worries, I will clone with git and do the squash.. Done, my git-fu is rusty.... Excuse me if I go off-topic a bit..\n@kirbyfan64 I use Mercurial exclusively, that's how I keep my opensource projects in sync. on both github and bitbucket (hg repos.), it's been doing well.\nI had to resort to do this commit with git due to the way Hg-Git (the extension) works,  it keeps an internal mapping of hashes between the two, once the ancestral path changed, they are not in sync anymore since both git and mercurial calculate the hash all the way up to root from current commit with different algorithm.\nWhat you observed was true, cloning git repositories with hg is time consuming, for one, it has to recalculate all the hashes at least once. Also IIRC, cloning via http/https protocol (back then, the only way to clone a git repos with mercurial besides ssh/scp) was inefficient in git (even with git itself), something about extra round-trip, it is greatly improved now. And it's true that Mercurial is losing market share big time, at least in OOS circle, a huge factor is github.com, not because of something inferior.\nI am a strong believer of \"diversity is beneficial\". I even wrote a blog post about why I keep using Mercurial, pointing out the advantages[1] against git.\nGit could use a better interface, many commands do more than one thing, take rebase for example, it does rebasing, merging, history editing, commit squashing, etc. depends on the situation and how you invoke it.\nI am not saying Mercurial is better than git, or the other way around, they are just different beneath the UI/terminology similarities[2].\nI will try using Mercurial until I cannot. :smile: \n[1]: Mercurial comes with two powerful functional (yes, as in functional programming) query languages (revset and fileset) to search history, phase, changeset evolution, etc.\n[2]: as further as even how they record everthing, e.g. git is snapshot based, mercurial is changeset delta based. Thanks.. > Hmmm, what if we did a hy-language-server?\n@vodik that's a good idea, except that the syntax of Hy is constantly changing now (a norm before 1.0), that will need someone close enough to the core team involve. I can help if I have the understanding of Hy's code base (which I didn't find time to do so). Maybe that's a good excuse to start reading the source.\nBTW,\nSince I opened this issue, I read a bit of vim-hy's source, I found:\n\ndue to the design of vim script, the language, it's hard to read.\nthe indentation support is writing in hy, which sounds great, but in fact, this makes hy a hard requirement, and this does not work with virtual environments. This is a showstopper.\nmany part of the code could use automation (eg. code generation).\n\nThus, I am planning a rewrite.... Fair enough, so the problem remaining is better error message.. Playing with it a bit, I think there is a discrepancy here.\nHow can we translate this Python code into Hy code?\n```python\nimport functools\ndef the_answer(f):\n    @functools.wraps(f)\n    def decorated():\n        return 42\n    return decorated\n@the_answer\ndef tell_me():\n    return 0\ntell_me()  # -> 42\n```\nLiteral translation (sans the return, which is not lispy) does not work here:\n```clojure\n(import functools)\n(defn the-answer [f]\n  (with-decorator (functools.wraps f)\n    (defn decorated []\n      42)))\n(with-decorator the-answer\n  (defn tell-me [] 0))\n(tell-me)  ;; raises \"TypeError: 'NoneType' object is not callable\"\n```\nI know sometime ago, defn had been re-designed as returning None, combining this fact with the current behaviour of with-decorator, it breaks the \"Hy <-> Python interop\" to certain extent.\nMaybe the true literal translation with (return decorated) is what's preferred? . docmebro, maybe? Cause the proposed way is not lispy (for my own definition of lispy, that is :smile:).\nI know with-decorator support more than one decorators, but returning None makes nesting with-decorator impossible (not that I think that is a good idea).. My fault. I mistakenly thought that because with-decorator evaluated to None, nesting does not work.  Didn't know that it is a special form on AST level until I just checked hy.compiler.py, I thought it was either on macro's level or run-time level.\nThanks for your clarification.. lisp-comp, set-comp, genexpr, dict-comp will be replaced by lfor, sfor, gfor, dfor in the future, is it correct? If so, will they be in next release?\nIMHO, for/l, for/s, for/g, for/d look better (we do have for/a already), for/list, for/set, for/generator, for/dict, for/async are even better. Just my 2 cents. . Thanks. By \"they\", I meant the new forms (lfor, etc.)\nAny idea about when? I am going to release a new version of my library, might as well wait for the new form.\n. Great, I'll wait then. Thanks.\nBTW, what are your thoughts on for/l, for/d, etc?. Fair enough.\nI was thinking since we already have for/a, wait/a, defmacro/g ... but to each their own. Yes, I saw you on that topic before, this might be related to that and might be fixed with new import form syntax.\nI also re-read the document recently and learned the mangle function got improved, I did not know this is related though.\nclojure\n=> (mangle '/)\n'hyx_XsolidusX'\n=> (mangle '.)\n'hyx_Xfull_stopX'\n=> (mangle '*)\n'hyx_XasteriskX'\n=> (mangle '/.*)\n'hyx_XsolidusXXfull_stopXXasteriskX' \nFYI,\n```python\n$ python\nPython 3.6.5 (default, Apr 26 2018, 17:48:52) \n[GCC 7.3.0] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n\n\n\nimport hy\nfrom test import hyx_XsolidusXXfull_stopXXasteriskX\nTraceback (most recent call last):\n  File \"\", line 1, in \n  File \"/home/pyx/projects/hy/hy/importer.py\", line 251, in load_module\n    return import_file_to_module(fullname, self.path, self)\n  File \"/home/pyx/projects/hy/hy/importer.py\", line 96, in import_file_to_module\n    load_module(module_name))\n  File \"/home/pyx/projects/ena/test.hy\", line 1, in \n    (setv /.* \"Hidden Files\")\nImportError: cannot import name '/'\n```. Thanks. I am fine with disallowing . (dot) in symbols in import form except expressing relative import path, I am just thinking, maybe better documentation and/or error message can reduce the surprise factor.. Yes, that will help.\n\n\n\nWhile we're at it, it might help to also address (require [.macros [some-macro]]), we should mention that in documentation somewhere, the current behaviour, ModuleNotFoundError: No module named HySymbol('.macros'), is surprising.. And the stack traceback of trying absolute import (not shown above)\nTraceback (most recent call last):\n  File \"/home/pyx/.virtualenvs/ri/bin/hy\", line 11, in <module>\n    load_entry_point('hy', 'console_scripts', 'hy')()\n  File \"/home/pyx/projects/hy/hy/cmdline.py\", line 363, in hy_main\n    sys.exit(cmdline_handler(\"hy\", sys.argv))\n  File \"/home/pyx/projects/hy/hy/cmdline.py\", line 351, in cmdline_handler\n    return run_file(options.args[0])\n  File \"/home/pyx/projects/hy/hy/cmdline.py\", line 224, in run_file\n    pretty_error(import_file_to_module, \"__main__\", filename)\n  File \"/home/pyx/projects/hy/hy/cmdline.py\", line 197, in pretty_error\n    return func(*args, **kw)\n  File \"/home/pyx/projects/hy/hy/importer.py\", line 116, in import_file_to_module\n    eval(code, module.__dict__)\n  File \"test.hy\", line 4, in <module>\n    (import [ai_hy [func]])\n  File \"/home/pyx/projects/hy/hy/importer.py\", line 244, in load_module\n    return import_file_to_module(fullname, self.path, self)\n  File \"/home/pyx/projects/hy/hy/importer.py\", line 96, in import_file_to_module\n    load_module(module_name))\n  File \"/home/pyx/projects/ri/ai_hy/__init__.hy\", line 1, in <module>\n    (import [ai_hy.mod [func]])\nModuleNotFoundError: No module named 'ai_hy.mod'; 'ai_hy' is not a package\nmake: *** [Makefile:4: all] Error 1. @Kodiologist \nI added a new test case to the repos.\nIn this test, test_2.hy, no content in __init__.hy and no self/circular importing, just one of the module imports from the other via relative import. Do you think that's related?. @Kodiologist never mind. I misread the error message, it worked. Sorry about that.. The way used in #1625 to circumvent this is teaching py.test what to look for in setup.cfg:\nini\n[tool:pytest]\npython_functions=test_* is_test_* hyx_test_* hyx_is_test_*\nIn addition to hyx_ prefix, something like (defn test-maybe? []) will cause problem (also addressed above), too.  The is_ prefix is way more harder to avoid, since that's by-design.  So, users are on their own. I believe a section dedicated to testing in documentation is the way to go. It should show:\n\nas a warning, that this problem exists, users should either avoid special characters in test functions, or do what mentioned above in setup.cfg\nways to setup auto test discovery for unit testing frameworks (py.test, node2, etc.) , for example, py.test by default, does not check inside .hy files, to find hy source code, put this in conftest.py\n  ```python\n  from pytest import Module\n\ndef pytest_collect_file(path, parent):\n      if path.ext == \".hy\" and path.basename.startswith('test_'):\n          return Module(path, parent)\n  ``. Edit: I was unaware of this section http://docs.hylang.org/en/stable/language/api.html#discard-prefix , it is documented already. I am sorry.. I sort of understand the reason_` being chosen in the first place, originated from a way to signify the value is of no importance, which in term, borrowed from ML languages.\nIn both python and strict MLs (OCaml for example), the expression being bound to _ is evaluated, then the result is discarded, while #_ as it is now, the next expression is discarded right away, not even being turned into AST, so I believe, in this regard, #; is actually telling what really happened behind the scenes.. So this is an official \"no\", am I right?\nIf so, I will close this.. Thanks for the clarification. I might use #tr or #trs for gettext then, and #i18n for extra fun :). I will close this at the moment.  In case someone else bring this up again, I will still be voting for #;. Ha ha, my sense of humor wasn't online. Do you want me to revert this part?. Done. Please review. Thanks.. ",
    "eblume": "I can confirm that something is broken with my readline, so I'll be closing this. I wonder though if the import check should be restructured so as to not swallow an ImportError, which is the current case.. In case anyone finds this in the future - in OS X, if you use pyenv to install python, you must first install GNU Readline for pyenv to build python with readline enabled. I accomplished this with a simple brew install readline followed by uninstalling and re-installing my preferred version of Python in pyenv. (In truth I had to jump through a few small hoops to get readline installed correctly - I did something naughty at some point, not sure what.). ",
    "cpdean": "Where can I read about how to get hy working on macos 10.12.1?  I'm not familiar enough with how the dependencies are breaking and I feel like I may be maintaining my venv in the wrong way.  How does everyone else do it?. ",
    "swhalen": "Thank you for the input. I've submitted a (trivial) PR  #1194 making the shadow operator behavior more consistent with normal operator behavior.\nI would point out that unlike Python's and, the usage of and in that PR is not short-circuiting. To fix this would, I guess, require either lazy evaluation of the chained comparisons or some macrology. Multiple comparisons are also short-circuiting in Guile, but I have not checked any other Lisps/Schemes. However, the existing code in hy.core.shadow is not short-circuiting so I have not attempted to make this change. I am happy to update this if desired.. ",
    "handicraftsman": "/me tries to summon somebody... @gilch. @kirbyfan64, thanks - it works. BTW your nickname sounds familiar.. @kirbyfan64, i am about first part of nickname - kirby. Isn't it nintendo game?. @kirbyfan64, lol.. @Kodiologist, worked. Thanks.. ",
    "hrehfeld": "I have this case:\n(defn get-sym [] 'foo)\n\n(defmacro setnq [var]\n  ;;(assert (even? (len vars)))\n  `(setv ~(eval var) True))\n\nResulting in:\nhy 0.12.1+70.gad94343 using CPython(default) 3.6.0 on Linux\n=> (get-sym)\n'foo'\n=> (setnq 'foo)\n=> foo\nTrue\n=> (setnq (get-sym))\n  File \"<input>\", line 1, column 1\n\n  (setnq (get-sym))\n  ^---------------^\nHyMacroExpansionError: b'expanding `setnq\\': NameError(\"name \\'get_sym\\' is not defined\",)'\n\n\n=> (macroexpand-1 '(setnq (get-sym)))\nTraceback (most recent call last):\n  File \"/usr/lib/python3.6/site-packages/hy/macros.py\", line 215, in macroexpand_1\n    obj = wrap_value(m(*ntree[1:], **opts))\n  File \"<eval>\", line 1, in <lambda>\n  File \"/usr/lib/python3.6/site-packages/hy/importer.py\", line 198, in hy_eval\n    return eval(ast_compile(expr, \"<eval>\", \"eval\"), namespace)\n  File \"<eval>\", line 1, in <module>\nNameError: name 'get_sym' is not defined\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/lib/python3.6/site-packages/hy/cmdline.py\", line 125, in runsource\n    ast_callback)\n  File \"/usr/lib/python3.6/site-packages/hy/importer.py\", line 198, in hy_eval\n    return eval(ast_compile(expr, \"<eval>\", \"eval\"), namespace)\n  File \"<eval>\", line 1, in <module>\n  File \"/tmp/pkgbuild-1000/hy-git/src/hy/hy/core/language.hy\", line 327, in macroexpand_1\n  File \"/usr/lib/python3.6/site-packages/hy/macros.py\", line 222, in macroexpand_1\n    raise HyMacroExpansionError(tree, msg)\nhy.errors.HyMacroExpansionError: <exception str() failed>\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/usr/bin/hy\", line 11, in <module>\n    load_entry_point('hy==0.12.1+70.gad94343', 'console_scripts', 'hy')()\n  File \"/usr/lib/python3.6/site-packages/hy/cmdline.py\", line 367, in hy_main\n    sys.exit(cmdline_handler(\"hy\", sys.argv))\n  File \"/usr/lib/python3.6/site-packages/hy/cmdline.py\", line 362, in cmdline_handler\n    return run_repl(spy=options.spy, output_fn=options.repl_output_fn)\n  File \"/usr/lib/python3.6/site-packages/hy/cmdline.py\", line 257, in run_repl\n    os=platform.system()\n  File \"/usr/lib/python3.6/code.py\", line 233, in interact\n    more = self.push(line)\n  File \"/usr/lib/python3.6/code.py\", line 259, in push\n    more = self.runsource(source, self.filename)\n  File \"/usr/lib/python3.6/site-packages/hy/cmdline.py\", line 131, in runsource\n    print(e, file=sys.stderr)\n  File \"/usr/lib/python3.6/site-packages/hy/errors.py\", line 64, in __str__\n    line = self.expression.start_line\nAttributeError: 'HyExpression' object has no attribute 'start_line'\n\nProcess inferior-lisp exited abnormally with code 1\n. Should I continue to report instances of stuff like this? I don't want to spam the issues, but it might be worth it for the debugging info?. Ah, sorry!.\n",
    "madhat2r": "I guess you are correct @Kodiologist . I was just reading the docs and it says:\nxor is used in logical expressions to perform exclusive or. It takes two parameters. It returns True if only of the parameters is True. In all other cases False is returned.\nSo I took that to mean that it letteraly retunred false in all other cases. But I can agree, it probabbly won't matter much. ;). Thanks @Kodiologist for your reply.\nI have done some more testing, and it appears this only happens when importing another module in the same directory. I have captured the error thrown from cron:\nTraceback (most recent call last):\n  File \"/usr/bin/hy\", line 11, in <module>\n    load_entry_point('hy==0.13.0', 'console_scripts', 'hy')()\n  File \"/usr/lib/python3.6/site-packages/hy/cmdline.py\", line 344, in hy_main\n    sys.exit(cmdline_handler(\"hy\", sys.argv))\n  File \"/usr/lib/python3.6/site-packages/hy/cmdline.py\", line 332, in cmdline_handler\n    return run_file(options.args[0])\n  File \"/usr/lib/python3.6/site-packages/hy/cmdline.py\", line 211, in run_file\n    pretty_error(import_file_to_module, \"__main__\", filename)\n  File \"/usr/lib/python3.6/site-packages/hy/cmdline.py\", line 184, in pretty_error\n    return func(*args, **kw)\n  File \"/usr/lib/python3.6/site-packages/hy/importer.py\", line 87, in import_file_to_module\n    load_module(module_name))\n  File \"<frozen importlib._bootstrap_external>\", line 399, in _check_name_wrapper\n  File \"<frozen importlib._bootstrap_external>\", line 823, in load_module\n  File \"<frozen importlib._bootstrap_external>\", line 682, in load_module\n  File \"<frozen importlib._bootstrap>\", line 248, in _load_module_shim\n  File \"<frozen importlib._bootstrap>\", line 608, in _exec\n  File \"<frozen importlib._bootstrap_external>\", line 678, in exec_module\n  File \"<frozen importlib._bootstrap>\", line 205, in _call_with_frames_removed\n  File \"/tmp/test_hy/test.hy\", line 3, in <module>\n    (import\nModuleNotFoundError: No module named 'logger'\nkeep in mind, this works when calling in the shell. \ntest_hy.zip\n. Why would they need to be equivalent.\nHy is breaking on importing logger.. Remember this only breaks when called from a cron job. If you unzip to /tmp then you can use this in your crontab (crontab -e) which will run it and you can see the errors.\n# */1 * * * * /tmp/test_hy/test.hy >> /tmp/test_hy/test.hy.log 2>&1\n. I have rewritten it in python and it works as expected.. @kirbyfan64 what do you mean from my cron job? Do you mean in my hy file? or use it as a shell command from cronntab?. test_hy_with_py.zip\n\nOkay, good, so this should indeed be a Hy bug. Can you provide the Python version?\n\ntest.py: add it to the test_hy folder and change the cron job to execute this to test.\n```python\n! /usr/bin/env python\nimport logging\nimport click\nfrom logger import Logger\n@click.command()\n@click.option(\"--debug\", is_flag=True, default=False, help=\"Run in debug mode\")\ndef main(debug):\n    log_format = \"%(asctime)-15s %(levelname)-8s %(filename)-15s:%(lineno)-3s %(message)s\"\n    logging.basicConfig(\n        filename=\"crontest.log\", level=logging.DEBUG, format=log_format)\n    l = logging.getLogger()\n    l.info(\"running\")\nif name == 'main':\n    main()\n```. Just posting this for someone who may need to solve similar problem.\nAs a work-around, I found that I could create a python file that just stubs out the CLI entry functions and that imports hy and then the hy module.\nexample\n```python\ntest.py\nimport hy\nfrom test_hy import run\ndef main():\n    run()\nif name = 'main':\n    main()\nclojure\n;; test_hy.hy\n(defn run[]\n  (print \"I work from cron, when called from py\"))\n```. ",
    "ddkn": "I am in favor of keeping support until 2020. I just ported hy to the FreeBSD ports tree, and python3 is not default. I think keeping in tune with support of Python 2 is reasonable and makes sense, as @glich mentions keeping compatibility ensures more exposure, which increases the chances of more users.\nIn my case, rebuilding all of the python packages from ports to version 3+ would take a while just for Hy. Leaving python 2 support in allows me to make use of all of the scientific packages pre-compiled.. @gilch I would be interested in popping through some bugs. However, at the moment I have been busy with the end of a MSc. \nCurrently was going to port over to OpenBSD in the next week or two, as this is my daily driver now -- and they conveniently have flavours built in to ports, which mean packages for both v2.7+, and v3+. Might get some more interest that way.\nI cannot promise to commit anything any time soon until I finish what I am currently doing, but I will try. My end date is August, and should see more activity after that point.. ",
    "Rogof": "In my case, I'm working on a Standalone QGIS application. QGIS only supports Python 2 for now and while the next mayor version will support Python 3, it seems it won't be ready any time soon.\nSo I really would like for python 2 to be supported for a while.. ",
    "Zabolekar": "My Hy version is 0.12.1+24.g45b7a4a\nI am reasonably sure that it is the same version of Python in both cases. If I add\n(import sys)\n(print sys.__version__)\n\nat the beginning of the test file, it prints 3.6.0 (v3.6.0:41df79263a11, Dec 23 2016, 08:06:12) [MSC v.1900 64 bit (AMD64)] in both cases.. ",
    "egregius313": "In the case of map could we consider adding something like Clojure's mapv and have that essentially be (compose list map)?. mapv returns a vector instead of a seq. So in Hylang, mapv would return a list. It would be equivalent to Python 2's map.. ",
    "john-patterson": "Hey! I think this is your first commit here, so per CONTRIBUTING.rst you'll be asked by the maintainer to submit a separate commit adding yourself to the AUTHORS file as part of this pull request.\nCheers!. ",
    "pothos": "Yes, I read it too late, sorry! Thanks for merging.. ",
    "massmy": "Well, did set the hy.exe as standard executable for the file extension over the normal windows dialog.. @kirbyfan64 It worked kind of.\nthe assoc command did not work as expected.\nI had to manually set the registry key from \"hy_auto_file\" to \"Hy\" under HKEY_CLASSES_ROOT.hy\n. ",
    "jdanford": "I'd like to implement this. Does the following seem like the best way to expose it in Python?\npython\nimport hy\nhy.eval_str(\"(+ 1 1)\"). Alright, would you rather the reading function be called read or parse?. Oh gotcha, your original example used hy.lex.tokenize so I thought I had to wrap that! So this is just a matter of exporting read, read_str, and hy_eval?. All three functions have docstrings, but tests would be good, so I'll add some as soon as I get a chance.. Of course, not sure why I misunderstood! Should I add a new section under Using Hy from Python?. Whoops, just noticed I did this on master instead of a branch! New PR is #1369. All fixes have been made!. Forgot to do a git add, fixed now!. ",
    "brandonwillard": "I have a mostly work implementation of something like this here: https://github.com/brandonwillard/hy/blob/macro-changes/hy/compiler.py#L1197\nI'll put in a PR when I get all the tests passing again (only a few to go, though).. Where are we with this; is it a desired feature?\nI think it's well worth having, so, if I put in a PR  that does it, how will it go over?. I don't think this functionality necessitates incremental compilation, but it would make it easy to implement (or automatically available) by allowing macros to behave like the basic Python functions with which they're implemented (e.g. https://github.com/hylang/hy/issues/1689).\nIn a sense, incremental compilation could be similar to an always-on eval-and-compile, and, currently, eval-and-compile doesn't appear to break any of the functionality you described.  \nAlso, I don't see how incremental evaluation would change, or require changes to, the generated AST and resulting bytecode.  The AST is evaluated, via Python, incrementally (I've been using the term \"incrementally\" to also mean \"evaluated as Python would\"), so, if anything, it would bring the compile and run-time behavior closer together.  As a result, there would be fewer surprises and debugging would be drastically better.\nPerhaps I'm missing something, though.\n. Of course that wouldn't work; the code is evaluated too many times (and in different modules/namespaces) during the course of compilation and the superfluous eval of the resulting AST!\nThe analogy with eval-and-compile (of top-level forms) is only useful for demonstrating how evaluation at compile-time can be done and doesn't break functionality in any fundamental way; however, the incremental compiler we're talking about isn't as simple as that.. No specific changes have been proposed, yet; I'm only discussing broad functionality and its implications.\nOtherwise, relative to the subject of this issue, any changes would necessarily allow the macro in sandwich.hy to resolve x.\nAlso, I assume the expected output\u2014in all cases\u2014would be:\nTop\n[1 2]\n[1 2]\nBottom. Yes, currently, the compiler produces AST for (print (m)) reflecting (print [1 2]) and not something like (print (do (.append x 2) x)).  \nI don't see why we couldn't make it produce the latter, if desired, but I also don't see the issue with the current result (relative to this topic).  How would it affect our ability to resolve x during macro expansion, or vice versa?. > That's why it's undesirable: the program needs to do the work of expanding macros (represented in this case by the sleep time) every time you run the program.\nIt seems like you're assuming that result is also necessary for this functionality, and I don't believe it is.\n\nIf m can see x, it can modify it. If m can modify x, later expressions, like (print x), can be affected by whether m was expanded during the current run. \n\nYes, this is true of all function calls with side effects\u2014macros included.  Is there something about accessing module-scoped variables in macros with side effects that's particularly problematic? . > The subsequent sentence states the two problematic possibilities: \"either (print x) can print different things on the first run and the second run, or m needs to be re-expanded on every run\".\nI don't think it's reasonable to burden Hy with a responsibility to save people from the potential confusions resulting from side effects (in macros or otherwise), but we could make it possible to produce the same results.  \nFor instance, a decorator and/or macro that directs the compiler to not produce AST of the expanded results.  It could be made to only affect the AST generation for that one macro or location and still use the expanded results of any macros it calls.\nTo illustrate, let's call such a macro eval-always.  It would behave as follows:\n```clojure\n;; Regular macro\n(defmacro a [x]\n  (+ 1 1 x))\n;; Tell the compiler that this macro shouldn't fully expand its AST results\n(eval-always\n  (defmacro m []\n    (a 1)))\n;; Generates AST like (print 3)\n(print (a 1))\n;; Generates AST like (print (+ 1 1 1))\n(print (m))\n;; Generates AST like (print (+ 1 1 1))\n(eval-always\n  (print (a 1))\n```. I've only ever said that we have options, among which is the ability to produce the same results pre and post-bytecode.  The approach above does that without entirely throwing out byte-compilation of macro expanded results.  In that sense, no, it's not actually one of the \"problematic possibilities\" you described.\nThere are other approaches, but the ones I can think of are potentially more complicated than that one.. Yes, it's effectively inlining, but I'm not sure if it's exactly like the inline in other Lisps (e.g. Elisp), though.  Could be.. Also, in macroexpand, we could attempt to determine when a macro's corresponding Python function accesses variables within its module's namespace (e.g. via f_locals, f_globals, co_names, whatever) and produce that eval-always/inline-like AST.. This should probably be closed by #1672, no?. @vodik, I just copied this branch and made some updates for those conflicting files: https://github.com/brandonwillard/hy/tree/new-importer. I really do want to see this go through, so I'll do that.. This should be closed by #1672 (and/or after #1683 for Python 2.7).. That sounds very much along the same lines as my initial hunch.  Thanks for providing the details!. Ah, makes sense; I'll delete it.. The idea of require-ing a module's requires sounds helpful (in this situation), but perhaps not scalable \u2014 among other things.\nMy first response to this situation involved things like macroexpand, and @gilch provided some potential shortcomings in this comment.\nGiven that Hy seems partly inspired by Clojure, how does it handle these things?  (Unfortunately, I'm not familiar enough with Clojure to readily find that answer in its source.). @Kodiologist, sure, but for no reason other than generic pessimism.  Well, I would also include \"complexity\" (of code changes, comprehensibility, maintenance, etc.) into that scaling.  Regardless, if there's negligible performance and/or complexity hits, then I'm all for it!\nI'm walking through the require process in the debugger right now, so hopefully I'll have a better sense of what's going on (both in general and as it pertains to this issue).. As a person recently introduced to Hy (but familiar with Lisps), I found it surprising/confusing.. I didn't think about it in terms of broader variable scoping and/or binding, but I suppose that could be part of it.  \nHowever, does that still apply in a situation like the following?\n```clojure\n\n(let [some-dict {\"some-key\" None}\n...     (get some-dict \"some-key\") 1]\n... (print some-dict))\n  File \"\", line 2, column 6\n\n   (get some-dict \"some-key\") 1]\n   ^------------------------^\n\nHyMacroExpansionError: bind targets must be symbols\n```\nAnother way to state the functionality I'm describing: alter let to allow any valid assignment target as a target in its bindings.. @gilch, on a somewhat related note, I came across this thread (and this one, too) a while back when searching for letf in CL.. Ha, yeah, I forgot about those docstring edits; I'll just retract them.. Also, I wasn't sure whether or not it was desirable to have a require expand to None.  It doesn't seem to hurt anything, but does produces a rather redundant expression (e.g. an unnecessary (do None ...)).  \nWe could easily filter-out those Nones, but that would introduce topics like expression simplification/normalization, canonical forms, etc., and none of that was going on in the module already.. Also, before I forget, that require in walk isn't side effect-free, in that it adds the required macros to the calling module, which seems less than ideal.\nI considered creating a temporary shallow copy of the calling module (or at least the hy.macros._hy_macros dicts) for a side-effect free version, but didn't because it appeared to relate to @gilch's comments on namespace enhancements and possibly other fundamental changes that would facilitate such an implementation.. Thanks; I look forward to helping everyone get Hy!  (My apologies, in advance). Agh, yeah; well, I'm in the process of reducing the import machinery to the bare essentials in 3.x, so, once I've figured out exactly what that should look like, I'll re-add 2.7 support.. In the search for minimal integration with Python >= 3.4 importlib, I found this small monkey-patch sufficient for at least the basics (e.g. regular imports of .hy files) and even direct use of standard py_compile:\n```python\nimport importlib\nfrom hy.compiler import hy_compile\nfrom hy.lex import tokenize\nfrom hy.models import HyObject, HyExpression, HySymbol\nimportlib.machinery.SOURCE_SUFFIXES += ['.hy']\nKeep a copy of the original method\n_source_to_code = importlib.machinery.SourceFileLoader.source_to_code\ndef hy_parse(source):\n    source = re.sub(r'\\A#!.*', '', source)\n    return HyExpression([HySymbol(\"do\")] + tokenize(source + \"\\n\"))\nNew, patched method that considers .hy files\ndef _hy_source_to_code(self, data, path, *, _optimize=-1):\n    if os.path.isfile(path) and path.rpartition('.')[-1] == 'hy':\n            data = hy_compile(hy_parse(data.decode(\"utf-8\")), self.name)\nreturn _source_to_code(self, data, path, _optimize=_optimize)\n\nPatch the standard file loader\nimportlib.machinery.SourceFileLoader.source_to_code = _hy_source_to_code\n```\nIf this approach works across the board, we could remove the custom copy of py_compile and almost all existing importlib code in this branch.  Patches like this aren't usually ideal, but at least it's patching a method specified in the importlib API/spec without blatantly compromising that spec.   As well. the addition to SOURCE_SUFFIXES doesn't seem too out of place, since importlib itself updates it \"dynamically\".\nThe current approach is a non-trivial work-around for FileFinder's inflexibilities (see here) that effectively supplants the standard import mechanisms, so it's probably worth seriously considering an extremely terse patch that provides the same functionality and more.. Some issues fixed, targeted, and/or possible/easier to fix via this PR:\n- [x] https://github.com/hylang/hy/issues/712\n- [x] https://github.com/hylang/hy/issues/1523\n- [ ] https://github.com/hylang/hy/issues/1514 \n  - This issue is basically the mission statement of this PR, plus references to other issues.\n- [x] https://github.com/hylang/hy/issues/1466\n- [x] https://github.com/hylang/hy/issues/1457\n- [ ] https://github.com/hylang/hy/issues/1144\n  - These issues appear to be at the transpilation-level, not the actual importer.\n- [x] https://github.com/hylang/hy/issues/1134\n- [ ] https://github.com/hylang/hy/issues/659\n  - This works out-of-the-box for .py[c] files under the new importer, because it should find the default zipimporter in the process of searching sys.path_hooks.  In that sense, it's at least non-breaking (for existing Python functionality).  Support for .hy files in a zip will require more unrelated and (this) feature-specific work (for Python 2.7, at the very least).\n- [x] https://github.com/hylang/hy/issues/459\nNot fixes, but some things that might be more do-able due to these changes:\n- [ ] https://github.com/hylang/hy/issues/1268\n- [ ] https://github.com/hylang/hy/issues/1324\n- [ ] https://github.com/hylang/hy/issues/1540\n- [ ] https://github.com/hylang/hy/issues/1407\nI'm in the process of going through these to devise tests, check that they're fixed, etc.\nOtherwise, PEP compliance should be a high priority regardless, no?. Ah, yeah, I'll amend that last commit with a keyword to the corresponding issue.\nWhen I consider PEP compliance in this scenario, the concern is based in the reproduction of expected behavior and use of standard APIs for the purpose of automatic/seemless support of existing and new functionality, portability across Python implemenations, etc.  Unfortunately, not even CPython makes consistent use of these (e.g. runpy and py_compile do not completely use the existing loaders and are a lot less applicable as a result), so not all those benefits are actually present; however, they might be in later versions.. True; fortunately compliance was mostly just a matter of reorganizing existing import and compilation code, and even that was exclusively for Python 2.7.  \nOtherwise, this approach plugs into Python 3.x's existing importer pipeline in only a dozen lines of code!  The rest is interface changes (e.g. __import__ to importlib.import_module).. @Kodiologist, any other issues related to the import system that I might've missed?\nRegardless, what do we need, from me, in order to move forward?. The require issues are why I chose to do this first; there could be some overlap.. @Kodiologist, thanks for the feedback; I'll try to clean up the Git history today.\nI should've clarified the whole .py vs. .hy import choices; they currently differ between Python 3.x and Python 2.7 and Python 2.7 should be the situation detailed in the description.  This is simply due to an oversight.\nSince the Python 3.x implementation is piggybacking off of the existing import machinery, it will choose .py before .hy (in all same-name, different-suffix cases).  Changing the order of suffixes in importlib.machinery.SOURCE_SUFFIXES will alter the import order, though.  To make it throw an ImportError in Python 3.x, which I also think is a good response to the situation, another patch is probably needed.\nThe easiest solution (minimal changes) is to have the importer silently prefer .hy files in all Python versions and cases, ignoring any same-name .py files.  In other words, Hy prefers Hy.. @Kodiologist, all right, cleaned-up those commits.  \nAlso, I set the import preference to .hy files in all cases and versions; that seems like the most consistent approach that doesn't introduce more patches or violate existing tests/expectations.. Regarding the speed-up (or lack thereof), that's probably due to the use of runpy[.run_path] (in cmdline.py), which neither caches nor uses bytecode.\nAlso, python *.py doesn't appear to cache or use bytecode in either Python 2.7 or 3.6 (per the verbose output messages); however, if you run python -m * in Python 3.6, bytecode is cached and read, while in 2.7 it isn't.\nNot sure how we want to handle these cases in Hy, but perhaps some of the latency issues you observed were due to that.. No problem, it can be easily made to use the cache.. All right, those changes are in.  Also, I added the hy {fpath} tests back to test_bin_hy_byte_compile.. It looks like we can get rid of some boilerplate code in HyLoader (e.g. get_source, get_filename, _reopen at ~43 lines) if we adopt the existing imp.PY_SOURCE module type instead of using our own HY_SOURCE.\nThis change only affects Python 2.7, and it somewhat more closely reflects the patched loader for Python 3.x, since \u2014 in the latter case \u2014 .hy is added as an importlib.machinery.SOURCE_SUFFIXES.  \nThe naming alone (i.e. PY_SOURCE) is a little less welcoming of this change (Hy source is definitely not Py source), but, with the rest of the custom loader overrides, it really is just naming and nothing more.. Ah, yes, all the Hy-specific loader logic from #1672 is based on file extensions and falls back to Python builtins otherwise.  In other words, it only enforces a choice between files recognized as Hy and Python.\nDo we want to assume that extension-less files and/or unrecognized extensions are Hy?  Should we raise an exception (from the cmdline tool) when we don't find/recognize an extension?  Should we fail silently in those cases? \nWe can make some fairly straightforward changes to produce most of those conditions, but we probably want to be more laissez-faire than not.  Python's choice to interpret every file as Python source seems sorta reasonable if only because it handles the entire import process \u2014 in which we are simply injecting Hy parsing capabilities.  If we attempt to take over default behaviours, we might need to do a lot more just to preserve expected functionality elsewhere (e.g. make sure we don't block other importlib finders and loaders).. @kirbyfan64, that's the approach I was initially leaning toward, and it would require us to either stop using runpy in cmdline.py or force the runpy patch to use our loader.  Both of those approaches avoid changing the importer/finder we put on sys.path_hooks and negatively affecting the basic import process (e.g. making it greedy or blocking downstream importers/finders); however, they also effectively impose their own greedy import process just for the cmdline and/or runpy.\n@Kodiologist, handling a shebang is much more in-line with the approach I'm currently leaning toward, which attempts to determine whether or not a file is Hy source through extension and (simple) non-extension means.  Such a change could be introduced in the way described above, or more generally through changes to the importer/finder.  Since we implement the Python 2.7 importer/finder, it's clear where/how we should do this, but, with our minimally-invasive Python 3.x patch, we might need to do some research if a simple change to this line in _hy_source_to_code isn't enough.\nAlso, it's quite possible I'm over-thinking this, and that simply changing the extension conditions in the 2.7 loader, importer/finder and 3.x loader patch will work just fine.  Still, I think it's safer to define a clear and constrained \u2014 albeit potentially non-standard (e.g. exclusively extension, shebang, and perhaps light syntax inference) \u2014 means of determining when a file is Hy source.\n. Even so, we don't want to break valid Hy code that triggers imports or runpy invocations of other file types.  That's my main concern.. All right, I'll start a PR for changes to that effect.. @Kodiologist, the one failure on Travis \u2014 for pypy3 \u2014 is really weird; do you mind retrying that check manually?  \nI've seen spurious errors for other projects with pypy3 on Travis recently, and I can never reproduce them locally.  Perhaps it's because I have pypy at Python 3.5.3[pypy-6.0.0-final] on my machine, but, still, the errors make no sense whatsoever (relative to the changes, or otherwise).. In this case, the Hy error, just as if we only assumed the file was Hy.  Otherwise, do you think Python should never even be tried for unknown filetypes?\nFor Travis, I've been able to retry with this before.. @Kodiologist, this new approach should do just that.  I chose to copy the runpy module to produce a runhy that works exactly like runpy except that it prefers Hy for unknown file types.  It uses the same patching as before, but with a different, more inclusive condition for Hy files.\nWith this approach, we preserve the functionality of runpy for the Hy-centric cmdline case and the standard runpy (still patched for limited Hy parsing) without wastefully reproducing its logic.. It is possible, but wouldn't that only be testing the shell's ability to correctly run a script?. I think this bug was introduced by the use of importlib.import_module (via #1672), so should it be in the same NEWS that reports the addition of #1672?\nAlso, I was thinking of putting in a PR that rewrites the doc macro so that it simply works with everything (i.e. tags, macros, functions).  It's much less confusing to get documentation in Hy that way, so, if anyone else is interested, we could entirely obviate this PR with that one.. It should print the documentation of both or allow one to specify/choose.. I was looking over #1416 yesterday; it's next on my list.  I've been doing all this recent work in preparation for larger macro-oriented changes, so I'll need your input on that later, as well as #1407 and #277.\nUsing help would be nice, too, if only for leveraging its already established role.  On a side note, I think the focus of this topic should probably be on broader pydoc functionality/inter-op.  That said, the doc we're talking about is probably more related to pydoc.doc/pydoc.render_doc than help.\nOtherwise, the discussion in #1415 does not make a clear case for why a type-narrowing option \u2014 or something similar \u2014 is objectively \"bad\".  It looks like a matter of preference, especially since the current implementation only separates the cases based on a syntax mnemonic (instead of, for instance, a naming scheme like doc-macro, doc-tag and possibly a doc-defn).\nI don't really have a preference either way, but I do think there's value in having the ability to obtain all the information in one place.. After adding tests, this should at least close\n- [x] https://github.com/hylang/hy/issues/142\n- [x] https://github.com/hylang/hy/issues/1395 (I think this was already closed by #1672)\nWith a little extra (and perhaps tangential REPL) work, we could get #1397 in place, as well.  Also, after some upcoming macro/require rehauls, some of the ideas in #741 might be do-able.. PyPy raises exceptions during calls to inspect.getsource:\nclojure\nhy 0.15.0+32.g4af87dc.dirty using PyPy(fdd60ed87e941677e8ea11acf9f1819466521bf2) 3.5.3 on Linux\n=> (import inspect [tests.resources.bin.pdb [*]])\n=> (inspect.findsource func2)\n(['(defn func1 [x]\\n', '  (print \"func1\")\\n', '  (+ 1 x))\\n', '(defn func2 [x]\\n', '  (print \"func2\")\\n', '  (func1 x))\\n'], -1)\n=> (inspect.getsource func2)\nTraceback (most recent call last):\n  File \"/home/bwillard/projects/code/python/hy/hy/importer.py\", line 140, in hy_eval\n    return eval(ast_compile(expr, \"<eval>\", \"eval\"), namespace)\n  File \"<eval>\", line 1, in <module>\n  File \"/home/bwillard/apps/anaconda3/envs/hy-dev-pypy35/lib-python/3/inspect.py\", line 947, in getsource\n    lines, lnum = getsourcelines(object)\n  File \"/home/bwillard/apps/anaconda3/envs/hy-dev-pypy35/lib-python/3/inspect.py\", line 939, in getsourcelines\n    return getblock(lines[lnum:]), lnum + 1\n  File \"/home/bwillard/apps/anaconda3/envs/hy-dev-pypy35/lib-python/3/inspect.py\", line 919, in getblock\n    for _token in tokens:\n  File \"/home/bwillard/apps/anaconda3/envs/hy-dev-pypy35/lib-python/3/tokenize.py\", line 597, in _tokenize\n    raise TokenError(\"EOF in multi-line statement\", (lnum, 0))\ntokenize.TokenError: ('EOF in multi-line statement', (2, 0))\nwhile CPython raises no exception (notice, however, that the result it gives is incomplete):\nclojure\nhy 0.15.0+32.g4af87dc.dirty using CPython(default) 2.7.15 on Linux\n=> (import inspect [tests.resources.bin.pdb [*]])\n=> (inspect.findsource func2)\n(['(defn func1 [x]\\n', '  (print \"func1\")\\n', '  (+ 1 x))\\n', '(defn func2 [x]\\n', '  (print \"func2\")\\n', '  (func1 x))\\n'], 0)\n=> (inspect.getsource func2)\n'(defn func1 [x]\\n'\nThis appears to be what's causing the current test failures in Travis, and it's because the debugger triggers a call to inspect during code listing, then a -1 start-of-line is returned by PyPy's inspect.findsource, which causes inspect.getsourcelines to send inspect.getblock only the last line and, ultimately, the Python tokenizer to barf.  These problems can be fixed by patching inspect, and I image that entire module should probably be patched/made compatible with Hy for other reasons, as well.\nIn the course of researching and testing said patches, I noticed that defn forms do not completely preserve/map source line-number information (at least not in PyPy).  It's possible to work around this \u2014 to some extent \u2014 via special inspect logic, but a true solution leads right back to fundamental macro questions and, most likely, changes.\nComment on Patching for Hy\nOn a somewhat related note, all this patching has me rethinking how we could accomplish the same compatibility and core Python code re-use with much less effort.  In quite a few instances, the necessary patches simply wrap the use of eval, exec and compile so that they handle Hy code.  While patching those bulit-ins directly is possible (well, for exec, in Python 3.x, at least), simply replacing the regular Python handling with Hy is not sufficient; however, there might be other work-arounds available that allow those functions to handle Hy source strings as a special case.\nFor instance, if Hy source strings were created by the Hy interpreter and loader as a special, identifiable type (e.g. class HySource(UserString)), then eval, exec and compile could be patched with only a simple condition handling those.\nOverall, patching every piece of relevant code that calls eval, exec and/or compile sounds like an uphill battle, so it's better to address this now.. Doing just that \u2014 plus further necessary additions.  I'm working somewhat incrementally on this one, so you folks can see/be involved in the process.. The changes introduced here might also help address the following issues:\n- [ ] https://github.com/hylang/hy/issues/1414\n- [ ] https://github.com/hylang/hy/issues/1324\n- [ ] https://github.com/hylang/hy/issues/277\n  - The macro-only \"namespacing\" for symbols implemented in this PR is a light-weight, behind-the-scenes version of this; however, full namespacing should probably be introduced (e.g. as part of the Hy syntax) and used instead.\n(Moved from initial comment). When test-macro-module is macroexpanded (in, say, __main__), we get its definition namespace (i.e. module tests.resources.macro_with_require) from the macro function object, then we assign the definition namespace to the HyExpression resulting from the macro's expansion via the new HyObject.module field.  (Currently, this is only done for HyExpressions objects resulting from a macro expansion.)\nWhen that HyExpression is macroexpanded, we first check the compiler namespace's __macros__ dictionary (e.g. __main__), then, if that fails, the definition namespace's via HyExpression.module.  So the test example should use a let defined in the calling file (or module __main__) ahead of the let defined in the macro's definition namespace (i.e. tests.resources.macro_with_require).\nThis form of namespace/module resolution is intentionally restrictive; for instance, it doesn't propagate into sub-expressions or apply to anything else other than macro expansion.  This can easily be changed; however, I wanted to start by implementing just enough to make non-trivial macro work a little more tolerable.. That's a simple change to make, so I'll do it now before it causes confusion down the line.. Macro expansion now checks the macro's module's namespace first, then the \"local\" namespace.\nAlso, requireing all will only add the macros and tags defined in the module being required (and not its required dependencies).\nFinally, I rewrote the tests so that they use test.resources macros and modules exclusively.  There's also a simple test in there confirming that required macros (even requirements of required macros) can reference variables in their module namespaces and that their expansions only bind to symbols in the namespace they're expanded (e.g. locally). (Just to be safe.). Not yet; just noticed that the tag macros don't resolve in the correct order (didn't update the code in that place), so I need to fix that and add another test.\nOtherwise, I have some AST/source line numbering fixes to make.  For example, hy_eval strips line numbering and doesn't compile with the correct filename, so anywhere that's used \u2014 like eval-and-compile and whatever uses it (e.g. the defmacro macro) \u2014 the resulting bytecode produces unreadable source in the debugger and trace output.  \nOn a related note, hy_eval and hy_parse and ast_compile should all probably be in compiler.py; currently, there's a weird back and forth between those modules that simply isn't necessary.  Also, it seems like we shouldn't have to create a whole new HyAstCompiler during compilation of eval-and-compile, which is what's currently happening through our use of hy_eval, so I would like to refactor that, too.\nI think the two aforementioned changes could/should have their own PRs, though, so I'll end this one here (unless something more related to macros comes up).\n. All right, updated the last commit with the correct macro resolution order (for tags) and corresponding tests.. Those are pre-existing issues.. The example in #1268 should work, and it does in Python 2.7, but not Python 3.x.  I'm looking at it now.. Ah, yeah, I wasn't sure about include_require either (both its name and purpose).  It's effectively being used to designate when the compiler should be run \"interactively\" (i.e. compiling code to be evaluated in the same \"session\") or \"non-interactively\" code for use by Python package/module Loaders (e.g. the generation of bytecode).\nIf anything, it only tries to avoid an unnecessary require in the first/\"interactive\" case, because, when the resulting Python AST is compiled to bytecode and immediately run, an AST-generated require is likely redundant.\nThere might not be issues if the AST is always included in the output, but, since a second require currently doesn't occur in Hy, I played it safe and had it skip AST generation when the intention is to immediately evaluate the resulting code object.\nNow, I just came across a situation that could change all that.  I'm currently making the example in #1211 work, and I think the answer involves an AST-generated require for the \"interactive\" case.  Commit coming soon.... ~~The most recent commit produces require AST in all cases and does not raise an exception when a module contains no macros/tags.  I think the latter should be changed, since it will surely confuse people, but something needs to be done about the situation demonstrated by the new test.~~\n~~In that test, the macro foo is expanded at any time when AST and/or a Python code object is desired (e.g. a simple import or use of runpy).  During that expansion the require in foo is evaluated, and\u2014in this test\u2014for the first time, so the module circular_macro_require exists in sys.modules but does not have any defined macros (i.e. in __macros__).  Even though we've already compiled the forms defining the macros, since the resulting AST hasn't been evaluated yet, they effectively do not exist, and the aforementioned require should fail.~~\n~~The current solution is hackish, because it simply removes the error (that should actually be there), allowing the require to silently fail, and then leaves the rest for run-time.  The assumption is that we're fine pushing this potential error to run-time, and\u2014in this particular case\u2014it isn't an issue, so no worries.~~\n~~Under that assumption, we might as well have every macro expansion-processed require fail silently.  That would would push macro issues downstream (e.g. during an expansion that uses a missing macro) and allow us to re-introduce the removed exception, but it seems like poor design.~~\n~~It would be better if we could collect macros as we compiled them.  For the case in which a module uses/requires its own macros, that would avoid a self import, which\u2014during run-time\u2014produces double output (e.g. the tests prints 42 twice: once for the require and its import and again from the command line run).  However, collecting macros during compilation would appear to require sequential compile-and-eval (or defmacro special forms handled by the compiler).~~\n~~Actually, it might really help to have awareness of the compilation context in order to avoid a compile-time require caused by a macro expansion.  We currently can't tell which is which (i.e. top-level require vs. macro-expanded require), since the compiler provides no direct state/level processing information.  If we could tell, then the answer to all this is much more simple and elegant: only perform top-level requires during compile-time and defer all others (e.g. those resulting from macro expansion) to run-time\u2014via the newly generated AST for require.~~\n~~Perhaps we could add something to the tree/Result being expanded, or create a subclass of Result (e.g. ExpansionResult) for this purpose?  I'll experiment with the latter idea in the meantime.~~. > The reason I would expect (require foo) to work when foo has no macros is because (import foo) works even when foo is empty. \nYeah, that's why it's more reasonable to not err for (require foo), but from foo import bar will fail in Python and probably should when handling the analogous (require [foo [bar]]).  I'm changing this logic now.. > The behavior of the new circular_macro_require.hy is definitely weird. You say that \"Even though we've already compiled the forms defining the macros, since the resulting AST hasn't been evaluated yet, they effectively do not exist\u2026\", but\nI just recently noticed that the eval-and-compile isn't putting those macros in the right module's __macros__.  This is because runpy is actually compiling code in the __main__ module (instead of circular_macro_require.hy).  I'm still trying to get a clear picture on this, so stay tuned.... Just put in a better solution to this specific run[p|h]y issue: we now check\u2014in a module-name independent way\u2014whether or not we're importing the same module we're compiling, and, if we are, we can safely skip that require and let downstream macroexpands find the macros (introduced by defmacro's eval-and-compile) in the module being compiled.. I'm debating whether or not the AST require should be generated when requireing the compiled module.  Something like that should fix the double output, though.. All right, just pushed a fix that correctly avoids duplicate output due to self-requires.. Did you remove the absolute_import?  If that solves the problem, then why are those commits needed?\nI'm not 100% on-board with adding recursions when more-or-less static AST can be generated on the spot.  Besides being technically more efficient (and avoiding the require name clash), its output/result is also exceedingly more transparent.  Additionally, the import AST is generated on the spot (and was before this PR); why deviate for require?\nIs there an important forward-looking aspect to using Hy trees that I'm missing?\nAlso, which commits were undoing other commits?. > You mean faster? It's hard for me to imagine a situation in which this change would make a noticeable speed difference (and if so, that would probably point to deeper speed problems regarding starting and stopping the compiler).\nAlso in terms of memory and debugging.  Having to wade through more function calls and stack traces to find out how and where AST was generated is already a difficulty worth mitigating.  Plus, unnecessarily sending the interpreter through other parts of the compiler only increases the chances that it will err somewhere unrelated to the actual problem.\n\nTrue, in the sense that you don't need to look elsewhere in the compiler, but I'd rather have the logic for compiling a function call in only one place, even though this means you need to scroll down to @builds(HyExpression) to see how it works.\n\nIf AST generation occurred exclusively within compile_expression, then sure, but it doesn't.  Furthermore, what's happening in compile_expression isn't trivial and involves other non-trivial, yet irrelevant, aspects of the compiler (e.g. the entries in _special_form_compilers, the loops in _compile_collect and macroexpand).  Speaking of macroexpand, will a user-defined requiref interfere with compilation of requires? \nI can understand the desire to handle all ast.Call-generating statements in one place, but\u2014at some point\u2014this approach starts to negatively conflate two distinct operations: the general act of generating Python AST (as ultimately emitted by the compiler), and the generation of AST for Hy trees (which involves language-specific logic affecting Python AST generation).\nThe two overlap (well, one simply depends on the other) but they also account for different things and incur different costs.  In trying to make one function account for more than one operation, it necessarily ends up sharing some of the costs between all of them.\nFor instance, such an approach requires special logic to avoid \"collisions\" (e.g. a user-defined function, macro or built-in special form should not interfere with the compiler's internal AST generation).  Similarly, performance costs are shared unless efforts are made to distinguish between the two cases (in a sense un-doing the whole approach).\nIn other words, when the compiler simply needs to generate Python AST for itself, why should it have to take exclusively Hy language-related steps?\nInstead of having the compiler generate and immediately compile a Hy tree for a require, why not turn require into a built-in/core macro?  This approach would re-use the same compiler logic and keep the compiler complexity from unnecessarily growing.\nAnyway, these changes don't appear to be directly related to the functionality addressed by this PR.  Are they addressing a requirement of some sort, or simply design choices/preferences?\n. > I think so. In your implementation, this would happen for functions named require instead of requiref. \nI do not see how that could happen in the original implementation, and, having just tried it, it doesn't: \nclojure\nhy 0.15.0+43.g31a630d using CPython(default) 3.6.6 on Linux\n=> (.keys __macros__)\ndict_keys(['koan', 'ideas', 'defmacro', 'hyx_if', 'deftag', 'macro_error', 'defn', 'hyx_defnXsolidusXa', 'if_python2', 'hyx_as_XgreaterHthan_signX', 'assoc', 'hyx_with', 'hyx_withXsolidusXa', 'cond', '_hyx_Xgreat\nerHthan_signX', 'doto', '_hyx_XgreaterHthan_signXXgreaterHthan_signX', 'if_not', 'lif', 'lif_not', 'when', 'unless', 'with_gensyms', 'hyx_defmacroXsolidusXgXexclamation_markX', 'hyx_defmacroXexclamation_markX', '\ndefmain', 'comment', 'doc'])\n=> (defn require [x] (print \"wrong require!\"))                                                                                                                                                                      \n=> (require [hy.contrib.walk [let]])\n=> (let [x 1] (print x))\n1\n=> (.keys __macros__)\ndict_keys(['koan', 'ideas', 'defmacro', 'hyx_if', 'deftag', 'macro_error', 'defn', 'hyx_defnXsolidusXa', 'if_python2', 'hyx_as_XgreaterHthan_signX', 'assoc', 'hyx_with', 'hyx_withXsolidusXa', 'cond', '_hyx_Xgreat\nerHthan_signX', 'doto', '_hyx_XgreaterHthan_signXXgreaterHthan_signX', 'if_not', 'lif', 'lif_not', 'when', 'unless', 'with_gensyms', 'hyx_defmacroXsolidusXgXexclamation_markX', 'hyx_defmacroXexclamation_markX', '\ndefmain', 'comment', 'doc', 'let'])\n=> require\n<function require at 0x7fec8e6ce048>\n=>\nA user-defined macro named require will interfere with the built-in require in both cases, though:\nclojure\nhy 0.15.0+43.g31a630d using CPython(default) 3.6.6 on Linux\n=> (defmacro require [x] (print \"wrong require!\"))\n<function <lambda> at 0x7f1455014598>\n=> (require [hy.contrib.walk [let]])\nwrong require!\n=> \nThis seems like a pretty bad thing, especially since removing a macro isn't so straight-forward!\n\nIf by \"these changes\" you mean my use of `ret += self.compile(HyExpression([HySymbol('requiref')...\n\nNo, I mean the inspect and requiref-related changes.  I don't understand what they're specifically addressing that wasn't already addressed by the original commits in this PR.\nI still haven't gone through all the changes within the rebased original commits, but I am seeing quite a few confusing things.  So far, there are a lot of apparently stylistic changes to edits surrounding necessary changes.  I can understand reversions of stylistic\u2014or language convention\u2014changes that do not surround necessary edits, but that's not the case here.\nFor instance:\n```diff\nmodified   hy/extra/reserved.hy\n@@ -12,12 +12,15 @@\nThe result of the first call is cached.\"\n   (global _cache)\n-  (if (is _cache None) (do\n-    (setv _cache (frozenset (map unmangle (+\n-      hy.core.language.EXPORTS\n-      hy.core.shadow.EXPORTS\n-      (list (.keys hy.core.macros.macros))\n-      keyword.kwlist\n-      (list (.keys hy.compiler._special_form_compilers))\n-      (list hy.compiler._bad_roots)))))))\n+  (if (is _cache None)\n+      (do\n+        (setv _cache\n+          (frozenset\n+            (map unmangle\n+              (+ hy.core.language.EXPORTS\n+                hy.core.shadow.EXPORTS\n+                (list (.keys hy.core.macros.macros))\n+                keyword.kwlist\n+                (list (.keys hy.compiler._special_form_compilers))\n+                (list hy.compiler._bad_roots)))))))\n   _cache)\n``\nThere are necessary changes in there (e.g. due to the addition ofmacros`), so fixing the indentation is definitely warranted and not a superfluous style change.\nSame with these \"intermediate variable\" revisions:\n```diff\n@@ -1546,10 +1577,9 @@ class HyASTCompiler(object):\n @special(\"dispatch-tag-macro\", [STR, FORM])\n def compile_dispatch_tag_macro(self, expr, root, tag, arg):\n\n\nreturn self.compile(tag_macroexpand(\nHyString(mangle(tag)).replace(tag),\narg,\nself.module))\nres = tag_macroexpand(HyString(mangle(tag)).replace(tag), arg,\nself.module)\n\nreturn self.compile(res)\n@special([\"eval-and-compile\", \"eval-when-compile\"], [many(FORM)])\n def compile_eval_and_compile(self, expr, root, body):\n``\nIn almost every one of these cases, a module parameter was added and/or a module object was acquired (e.g. usingimportlib.import_module`), so they're not style-only changes.  In contrast, unnecessarily long, compound one-liners provide nothing noticeable, yet easily hinder readability and debuggability.  \n\n\nAs far as performance is concerned, I'm extremely surprised that the preference for an unnecessary, recursive HyASTCompiler.compile call for require AST is admissible in light of comments that sweepingly discourage \"intermediate variables\"!  It's not hard to see that HyASTCompiler.compile will generate a considerable amount of temporary variables for no material gain (performance or otherwise).\nThen there's this reversion that puts _stdlib back into module scope, where it serves no clear purpose and adds a dangerous and unnecessary coupling between this dictionary and HyASTCompiler instances (e.g. makes asynchronous use of this code problematic).\n```diff\n@@ -281,9 +282,6 @@ def is_unpack(kind, x):\n             and x[0] == \"unpack-\" + kind)\n-_stdlib = {}\n-\n class HyASTCompiler(object):\n     \"\"\"A Hy-to-Python AST compiler\"\"\"\n@@ -313,7 +311,8 @@ class HyASTCompiler(object):\n     # Everything in core needs to be explicit (except for\n     # the core macros, which are built with the core functions).\n\n\nif self.can_use_stdlib and not _stdlib:\nself._stdlib = {}\nif self.can_use_stdlib and not self._stdlib:\n             # Populate _stdlib.\n             import hy.core\n             for stdlib_module in hy.core.STDLIB:\n@@ -323,7 +322,7 @@ class HyASTCompiler(object):\n                         # Don't bother putting a name in _stdlib if it\n                         # points to a builtin with the same name. This\n                         # prevents pointless imports.\n_stdlib[e] = stdlib_module\n\nself._stdlib[e] = stdlib_module\ndef get_anon_var(self):\n     self.anon_var_count += 1\n``\nIf anything,_stdlibcould be a completely global, read-only dictionary, but, given that it was originally being populated inHyASTCompiler`, it's easier to make it compiler-local.  Regardless, unless there's some related functionality I'm overlooking, reverting this is a step backward in terms of code quality.\n\n\nWhat's the reason for these test changes?\n``diff\n-def test_bin_hy_circular_macro_require():\n-    \"\"\"Confirm that macros can require themselves during expansion and when\n-    run from the command line.\"\"\"\n+def test_bin_hy_macro_require():\n+    \"\"\"Confirm that arequirewill load macros into the non-module namespace\n+    (i.e.exec(code, locals)) used byrunpy.run_path.\n+    In other words, this confirms that the AST generated for arequire` will\n+    load macros into the unnamed namespace its run in.\"\"\"\n # First, with no bytecode\n\n\ntest_file = \"tests/resources/bin/circular_macro_require.hy\"\ntest_file = \"tests/resources/bin/require_and_eval.hy\"\n     rm(cache_from_source(test_file))\n     assert not os.path.exists(cache_from_source(test_file))\n     output, _ = run_cmd(\"hy {}\".format(test_file))\nassert \"42\" == output.strip()\n\nassert \"abc\" == output.strip()\n# Now, with bytecode\n assert os.path.exists(cache_from_source(test_file))\n output, _ = run_cmd(\"hy {}\".format(test_file))\n-    assert \"42\" == output.strip()\n+    assert \"abc\" == output.strip()\n```\nI could understand the missing grammar fix, but these changes simply remove a more informative explanation and swap the positions of the last two tests.. > Using the REPL makes the automatic import happen later, so the issue doesn't appear in your example. \n\n\nI just made an update that uses the fully qualified name for the require function\u2014among other simplifications\u2014and now it doesn't seem to be affected by your example.\nThere's still the matter involving macro shadowing.  I don't know of a simple work-around in the current state, but I imagine we could add a separate require function to core/language.hy (or change the existing one) so that it too can be called \"interactively\" via its fully qualified name\u2014or simply re-imported.\nThis brings up a bigger question: why do we have import and require logic in the compiler?  It looks like compile_import_or_require could be removed and replaced by a couple Hy \"builtins\" that parse the list and keyword arguments, no?\nSince both problems (i.e. (defn require ...) and (defmacro require ...)) were not introduced by this PR, I don't think we need to fix them both here (although the former appears to be fixed by this).  I'll put in another PR after this one, though.. > import, at least, needs to generate AST nodes that no other special forms generate, so it needs to be a special form (or implemented in terms of a special form that creates those AST nodes).\nYou're right; it's the shared parsing logic that I was thinking of, but the AST node absolutely sets it apart.\n\nrequire seems more readily doable as a macro, but its unique compiler logic at this point is very simple, anyway; it calls macro.require and produces a function call that's compiled instead. Its other logic is parsing, which it shares with import.\n\nI suppose it's that shared logic that would be factored-out, and compile_import_or_require converted to a simple compile_import that handles just that AST node.. > I would suggest my old name for the commit \"Integrate hy.inspect into hy._compat\" rather than \"Remove hy.inspect\" because the new name suggests all the code was actually deleted, instead of part of it being moved and part of it being deleted.\nThe content of hy.inspect was only being used in hy.macros, so I turned the relevant code into helper functions specific to hy.macros and kept the removal of hy.inspect.  Are there external API expectations (e.g. Hy-dependent packages) that should drive us to more granularly track these changes and/or keep them in hy._compat?. > One idea I've thought about a little but not explored is making a system so that Hy macros can produce AST nodes instead of just more Hy code, and using this to replace a lot of the compiler with macros. But a lot of the special forms provide very basic features, like setv, that you'd need to write those macros, so this would lead down the rabbit hole to self-hosting, which I suspect is way more trouble than it's worth.\nThere has to be a minimal sufficiency spec for a related Lisp we can borrow (e.g. Clojure?).  \nIdeally, the compiler would be super simple and highly efficient; otherwise, if it's going to do anything fancy, it should probably handle higher-level\u2014and perhaps more Lisp-oriented\u2014compiler optimizations (e.g. tail-call optimization).\nSpeaking of tail-call optimization, why does it currently exist as an optional feature and not a more general compiler optimization?. @Kodiologist, anything else needed for this one?. Turning require into a macro would be cool, but I would rather get these fixes through first.  I have a few other things in the pipeline that would benefit greatly from the way macros and require work in this PR.. An explanation for those changes is given here.  Otherwise, get_arity doesn't warrant any special distinction (it isn't even used) and the changes are easily summarized by only a single commit.\nMore importantly, why would we want to be so granular?  Is there something special about get_arity that I'm not seeing?  Is there a more general convention behind this: e.g. we want separate commits for each addition and removal of a function?. > Because the two things being accomplished in the combined commit are independent.\nget_arity's removal occurs as a direct result of hy.inspect's removal (i.e. the focus of the commit), so those two are not independent.  Likewise, removal of hy.inspect necessitates the relocation of its functions used within hy.macros (to hy.macros), so those are also not independent.\nAs a result, all the actions comprising the commit are clearly centered around the removal of hy.inspect and perfectly suited for one commit on that topic.. > I don't see this. You could as easily delete get_arity in a separate PR, which could be merged before or after any PR in which the other functions are moved, and all the individual changes would still make sense. That seems like independence par excellence.\nBecause you could delete get_arity independent of hy.inspect (e.g. in a separate PR) does not negate the fact that deleting hy.inspect necessarily deletes get_arity.  Whether or not the changes can be made independently is not relevant, since, for that matter, every character change could justify its own commit on such \"independence\".\n\nThe only reason that I deleted get_arity here, in the same PR as I was moving those functions, is that I noticed get_arity was never actually used while I was moving the functions.\n\nI don't see how its irrelevance is a reason for an unnecessary commit.  The opposite seems much more appropriate: because the function isn't used, there's no reason to emphasise its removal in the Git commit history!\nAlso, decoupling get_arity's removal from the rest of the changes serves no apparent functional purpose.  If, for instance, one wanted to revert the change and re-introduce get_arity in isolation, a separate commit that first removes or relocates it from hy.inspect wouldn't be helpful, since the former would require the reversion of hy.inspect's removal\u2014and further justify their coupling\u2014and the latter would require another superfluous commit that subsequently deletes get_arity after relocating it.\nIf the purpose of the separate commit is simply logging, and nothing particularly functional, then it's best to mention the removal explicitly in the commit message.  Still, I don't see why get_arity deserves this much attention.. Just to be clear, you're arguing for situation A over B, no?\nFor a repository with the following file in its index:\n```clojure\n;; some_file.hy\n(defn func-1 [] \n  (print 1))\n(defn func-2 [] \n  (print 2))\n(defn func-3 [] \n  (print 3))\n```\nSituation A\nCommit 1\n```diff\n--- a/some_file.hy\n+++ b/some_file.hy\n@@ -1,8 +1,5 @@\n ;; some_file.hy\n-(defn func-1 [] \n-  (print 1))\n-\n```\nCommit 2\n```diff\n--- a/some_file.hy\n+++ b/some_file.hy\n@@ -1,7 +1,4 @@\n ;; some_file.hy\n-(defn func-2 [] \n-  (print 2))\n-\n```\nCommit 3\ndiff\ndeleted file mode 100644\nindex c2ff364..0000000\n--- a/some_file.hy\n+++ /dev/null\n@@ -1,4 +0,0 @@\n-;; some_file.hy\n-\n-(defn func-3 [] \n-  (print 3))\nSituation B\nCommit 1\ndiff\ndeleted file mode 100644\nindex 14ce434..0000000\n--- a/some_file.hy\n+++ /dev/null\n@@ -1,10 +0,0 @@\n-;; some_file.hy\n-\n-(defn func-1 [] \n-  (print 1))\n-\n-(defn func-2 [] \n-  (print 2))\n-\n-(defn func-3 [] \n-  (print 3)). All right, I may not understand it, but I've recreated that squashed commit and added it back.. What's the inclusion criteria for hy.core.macros?. Looks like it's pointing at the end of the file, where the paren isn't closed, but the indenting in the print-out stops after a.. Just pushed a fix that should take care of that print-out.\n```bash\n\nhy test.hy\nTraceback (most recent call last):\n  File \"/home/bwillard/apps/anaconda3/envs/hy-dev/bin/hy\", line 11, in \n    load_entry_point('hy', 'console_scripts', 'hy')()\n  File \"/home/bwillard/apps/anaconda3/envs/hy-dev/lib/python3.6/runpy.py\", line 261, in run_path\n    code, fname = _get_code_from_file(run_name, path_name)\n  File \"\", line 781, in get_code\n  File \"/tmp/test.hy\", line 27\n    (\n    ^\nhy.lex.exceptions.PrematureEndOfInput: Premature end of input\n``. All right, I further separated those commits by their functionality.  Unfortunately, the first one is necessarily large-ish, due to how much code it affects; however, most of the changes are simple (e.g. adding new arguments for source and filename).. All right, added some helpers for the relevant errors.. No, the helper functions are the additional class methods inHySyntaxErrorandLexException`.\n\nSure, a method in the compiler could be added, too.. Added a HyASTCompiler._syntax_error method.. Any updates needed?  I find myself using this branch for everyday Hy\u2014specifically, for the new error messages and REPL source tracking\u2014and I would like to build-out a few new updates from it (e.g. better spy output for hy-mode highlighting, inspect patches, finishing the pdb integrations, etc.), so it would be great to get it officially out there.. Agh, yeah, I'm on it.. Conflicts resolved.. All right, rebased those into the first commit.. > Why's this one a HyTypeError instead of a HySyntaxError? I'm not sure I understand the difference.\n\npython\nif level == 0 and op in (\"unquote\", \"unquote-splice\"):\n     if len(form) != 2:\n         raise HyTypeError(\"`%s' needs 1 argument, got %s\" % op, len(form) - 1,\n                           self.filename, form, self.source)\n     return set(), form[1], op == \"unquote-splice\"\n\nMost, if not all, of the HyTypeErrors that were changed to HySyntaxErrors had some sort of correlate in Python (that would raise SyntaxError).  In this case, TypeErrors are\u2014usually\u2014raised in Python when a required argument is missing.. > ```python\n\n_source = re.sub(r'\\A#!.*', '', source)\nOffset for removed shebang (if removed).\nlineno_offset = 1 if _source != source else 0\n```\nThe re.sub will only blank the first line, not remove its trailing newline, so shouldn't lineno_offset stay at 0 in any case?\n\nIf we're not removing leading newlines later on, then, yes, I think so.  \nThat reminds me; I wanted to remove it entirely.  This is the kind of stuff that should be handled by the lexer.. > Kind of a shame that we have to add a state parameter to every single parser when we rarely need it, but I guess that's an rply limitation.\nYeah, it would be much better if the production functions accepted the state object as an optional keyword argument.. All right, removed.. Breaking out that _syntax_error in compiler.py into the first commit isn't helpful; at that point it's not even simplifying the the code it's replacing.. You'll have to be more specific about which tests you're talking about, because some are specifically for the exception messages.. Those changes aren't about whitespace though.. The goal is to make sure that the source information is retained, and properly used (for the descriptive print-out) throughout the course of raising and processing that exception (per the described changes) in the context of a call to tokenize.  \nHow exactly is this confusing?  That test is directly related to the PR-added and commit-described functionality (e.g. that message couldn't be produced if we weren't tracking the source string, line information, etc.)  The changes only elaborate on its original purpose, which is\u2014in part\u2014to make sure that a LexException is thrown, by including the requirement that the LexException show the location of the error in the source string.. No problem; I try to respond with a message after force-pushes, since I also don't recall ever getting such notifications.\nI believe I've addressed the matters in your last comment, except for the REPL return value.  Is it by design that it doesn't display None?  \nThe Python REPL doesn't either, but, if I recall, Clojure and some other Lisps do.  The only immediate advantage\u2014 that I can think of right now\u2014involves code that reads from the REPL output (e.g. comint in Emacs); it's often easier to handle situations in which output is guaranteed/consistent.\nRegardless, it's easy to change.. All right, now it doesn't print None expression values in the console. Yes. I'm fine with one reasonably sized set of final reviewer changes\u2014which is what I thought the last one was\u2014but a review process consisting of rebases is too confusing and time consuming.\nPlease describe the changes you think are necessary to merge this PR.. Finally had a chance to look at your branch; give it a push.. Out of curiosity, I made some minor edits that expose the macro functions at module level.\nWith those changes, one can do the following:\nclojure\nhy 0.15.0+43.g31a630d using CPython(default) 3.6.6 on Linux\n=> (defmacro test [] (print \"macro\"))\n=> (test)\nmacro\n=> test\n<function _hy_anon_var_1 at 0x7f0be5b2cea0>\n=> (defn test [] (print \"function\"))\n=> (test)\nfunction\n=> test\n<function test at 0x7f0be5b2c950>\n=> (del test)\n=> test\nTraceback (most recent call last):\n  File \"/home/bwillard/projects/code/python/hy/hy/importer.py\", line 173, in hy_eval\n    return eval(ast_compile(expr, \"<eval>\", \"eval\"), globals, locals)\n  File \"<eval>\", line 1, in <module>\nNameError: name 'test' is not defined\n=> (test)\nTraceback (most recent call last):\n  File \"/home/bwillard/projects/code/python/hy/hy/importer.py\", line 173, in hy_eval\n    return eval(ast_compile(expr, \"<eval>\", \"eval\"), globals, locals)\n  File \"<eval>\", line 1, in <module>\nNameError: name 'test' is not defined\n=>\nThe changes are in an experimental macros-in-module-namespaces branch that starts from #1682.\nSome interesting things have already come up, and I'll describe them here when I get a minute.. Exactly!. Maybe put these changes together with https://github.com/hylang/hy/issues/1695 in a reorganizing PR?. While we're on the topic of organization, what do you think about forcing test_bin.py tests to run last and adding a prefix to the .hy test files (e.g. test_*.hy)?\nThose test_bin.py tests usually run first and indirectly expose errors more clearly demonstrated by the smaller unit tests that follow.  The Hy file renaming should also help with pytest's initial search/collection process, and otherwise avoid issues resulting from temporary files created by editors.. Yet another \"decoupling\" point: the compiler automatically loads/imports modules for the standard libraries (macros included); it would be nice if the compiler's could run without these.  Once again, development can be particularly difficult because of these dependencies.\nIn other words, would we like to have a lightweight compiler that exclusively translates Hy AST to Python AST and implicitly relies on the current state of its target module for macro and function dependencies?  This is possible now that we're using module objects more consistently.. Also, before I forget: HyREPL calls hy_compile on every processed command.  When that happens, a HyASTCompiler is constructed and all the stdlib imports are triggered again and again.\nWe should probably create and reuse a single HyASTCompiler instance for the lifetime of HyREPL, no?. No problem.. In order for a compiler instance to simply [re]use itself when calling hy_eval (e.g. during eval-and-compile), we need to make the compiler \"stateless\".  Members like imports and temp_if attach state to a compiler instance that don't allow its immediate reuse.\nTo replace imports, my plan of attack involves more consistent tracking/use of Result objects and the imports in those.  Basically, we can\u2014and should\u2014keep all \"state\" within Result objects.  This looks like it will involve an interface-like change to the compiler, though; namely, that all HyASTCompiler.compile_* methods must return and take Result objects.  While that's often the case (well, the former at least), it's not always true, and this inconsistency isn't good for the compiler's design.\nFor instance, HyASTCompiler.compile_symbol doesn't return a Result object, but it can be made to do so, and\u2014with that change\u2014it can assign stdlib auto-imports to the current state of compilation (via Result.imports) instead of the actual compiler instance.  Likewise, with that in place, we can make HyASTCompiler.imports_as_stmts produce AST for a Results's imports and return those in another Result object\u2014bringing it more in-line with its adjacent compile_* methods.  Additionally, the logic currently in hy_compile could then be moved to HyASTCompiler.imports_as_stmts and disentangle essential compilation logic from hy_compile.\nAt the very least, these changes would get us closer to a compiler that better isolates its functionality and is significantly easier to extend and debug.  \nRegarding HyASTCompiler.temp_if, I'm having a hard time understanding exactly what its functional \"intentions\" are and the exact scope/constraints of its role.  I can see that it's attempting to avoid the unnecessary use/creation of temporary variables in an if*, but how it's using the compiler state to do this isn't very clear or well contained.  I can't tell whether or not the addition of a temp_if field to Result would work, or if there's something much simpler that would avoid such an undesirable addition.\nSomewhat related issues: #1542, #1482.  Also, this comment in #1697.. @Kodiologist, good call; will do.. Yeah, one minute.. OK, that should do it.. Didn't notice that; I'll update it.\nOtherwise, it seems like we should really get started on https://github.com/hylang/hy/issues/1044.. I think the root of this problem might be more closely aligned with the idea of macros returning function objects.  If a macro could return a function object, then the macro designer could simply create a function in whatever namespace they wanted.\nCurrently, function objects can't be wrapped by a Hy object.  Any ideas on how a function object could be represented in the Hy language model?. The first multiprocessing example seems to work interactively:\n```clojure\nhy 0.15.0+39.gd2319dc using CPython(default) 3.6.6 on Linux\n=> import multiprocessing as mp\nNone\n=> ... def f(x):\n    return x * x\nNone\n=> None\n=> ... _hy_anon_var_1 = None\nwith mp.Pool(5) as p:\n    _hy_anon_var_1 = p.map(f, range(3))\n_hy_anon_var_1\n[0, 1, 4]\n=> None\n```\nOtherwise, from the command line (e.g. hy test.hy), the defmain macro fails with empty arguments (e.g. (defmain [x] ...) appears to work).. Likewise, the following works fine after adding an unused x to the defmain arguments:\n```clojure\n;; test.hy\n(import [multiprocessing :as mp])\n(defn f [x]\n  (print x))\n(setv p (mp.Pool 5))\n(defmain [x]\n  (p.map f (range 5 20)))\n```\n```bash\n\nhy test.hy\n5\n6\n8\n7\n10\n11\n12\n9\n13\n14\n15\n16\n17\n18\n19\n``. @cynseok, if you're still seeing errors, try deleting the corresponding.pycfiles (e.g../pycache/test.cpython-36.pycin my examples). That just avoids cryptic error messages.  We can remove it, though.. There are none, so we're actually talking about adding some.  Even so, the cryptic results have more to do with the likely unexpected default firstsys.argv` value and the error messages caused by it.  \n\nFurthermore, a user specifying their own arguments, e.g. (defmain [a b] (print a)), might not expect the first argument to always be the executable/script name instead of the first cmdline argument.  Perhaps it would be better to make that value accessible in some other way and let the user-specified arguments correspond directly to the cmdline arguments.\nAt the very least, the docs string should state that the first macro argument will always be the binary/script name.\n. Will do.\nNo, didn't work when I first tried.\nOn Tue, Nov 27, 2018, 7:27 AM Kodi Arfer <notifications@github.com wrote:\n\nI would bind the &rest to a gensym, or else you'll override the shadow\nsubtraction operator.\nI would use pytest.raises for the tests instead of try. Or does that not\nwork with SystemExit?\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/hylang/hy/pull/1708#issuecomment-442057431, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AA7TUZJrEgBy7_7dtu1jTBlJ7x_HkvHGks5uzT2sgaJpZM4Yzqd7\n.\n. This issue isn't a rehash of #1576; removing cons as a built-in Hy object and syntax support for the dot notation is perfectly fine.  We're talking about adding a cons pair and cons, car and cdr functions as an optional feature to support code written with their semantics.\n\n@Kodiologist, your statements\u2014and parts of #1576\u2014are actually asking about the meaning and/or purpose of cons, car and cdr.\nExplanations/answers for those are largely context dependent and already well covered elsewhere, but one obvious stumbling block here appears to be the misconception that cons, car and cdr only server to (immediately) produce and/or manipulate a list.  The fundamental idea of \"partially constructed sequences\" and the process of constructing sequences with cons has been overlooked (or outright dismissed), and, in #1576, point 2. iv. very clearly demonstrates this.\nFor example, in adderall and hydiomatic, the cons pair construct is used to represent such a partially constructed sequence.  The cdr can be a \"variable\" object\u2014or a structure containing such objects\u2014that might later be replaced by an actual list, and, when that occurs, the same operators are used to succinctly produce a \"completed\" list.  Basically, the same cons function handles both cases; plus, the \"incomplete\" list (i.e. a cons pair) serves to identify it as such and exactly how/where one can \"complete\" it.\nWithout the semantics and constructs of cons, car and cdr, the logic underlying this process is considerably less succinct or ultimately reinvented in a way that speaks to much fewer people.\nIn other words, recommendations to use ~@, +, extend, #*, etc., completely miss the point.\nRegardless, the semantics and usage of cons, car and cdr do not have a one-to-one mapping via any combination of builtin Python or Hy data structures and functions (that I'm aware of, at least), so there is a need for an implementation when the semantics are used.\nFinally, if Hy is intended to serve as a Lisp, these basic Lisp constructs and semantics shouldn't be dismissed simply because some people don't use or understand them.  . > It's clear to me what cons cells and the cons, car, and cdr functions are good for in Emacs Lisp and Common Lisp. It's not clear to me what they would be good for in Hy.\nEmacs and Common Lisp both have list construction and manipulations functions nearly equivalent to Python's/Hy's, so what exactly are they \"good for\" in those languages?\nMore importantly, by what measure are you judging Lisp conventions to be \"good for Hy\"?\n\nCan you provide an example that's concrete? ...\n\nadderall and hydiomatic are excellent concrete examples; please, do not be so unproductively dismissive.\n\nYou say that \"recommendations to use ~@, +, extend, #*, etc., completely miss the point\", but the one concrete example I've seen has a one-to-one reimplentation with ~@.\n\nWhat example are you referring to?\nIf it's the one in #1576 recommending that (~?fn ~?name ~?params . ~?body) be replaced with (~fn ~?name ~?params ~@?body), then there's definitely no one-to-one reimplementation.\nAs I said,\n\nFor example, in adderall andhydiomatic, the cons pair construct is used to represent such a partially constructed sequence.\n\nThe point of the expression (~?fn ~?name ~?params . ~?body) is that it results in a partially constructed sequence (and later a proper sequence).  hydiomatic and adderall operate on such objects and produce iterations of viable completions.  This use of cons is an abstraction similar to delayed evaluation and macros in Lisp.\nSuch approaches are fundamental to symbolic computation (and even historically, Lisp itself), where cons, car and cdr are used to succinctly represent relevant algebras, structures built from them, and their properties.\n. > Probably the clearest example is that in those Lisps, expressions are made up of cons cells. So, you need to deal with cons cells in order to do much metaprogramming at all. In Hy, by contrast, expressions are implemented as Python lists.\nThey might be made from cons cells, but when/if you're only ever manipulating or producing proper lists, there's effectively no need to use or deal with cons cells directly.  Still, you've been implying that this cons stuff isn't necessary or necessarily advantageous, but now you're implying that they sometimes are\u2014even in the presence of Python-equivalent list construction and manipulation functions?\nAnd what exactly is the \"metaprogramming\" you're referring to?  Is it something that can just as easily be done using Python lists?  Is it related to the improper list/cons pair use-cases I've been talking about?  If it is, then you're starting to answer your own questions.\nOtherwise, if you can clearly identify those instances in which they are needed\u2014outside of the construction of those aforementioned Python-equivalent list functions\u2014you might also find some other reasons for using cons pairs.  By the way, even if some of those reasons are convention/language-based, we are ultimately talking about a Lisp-like programming language (i.e. Hy), so we can't simply dismiss them.\nAs I said, there are quite a few existing resources demonstrating the non-list relevance for the combined use of cons pairs, cons, car and cdr.  Here's a fairly apt set of examples.  You can even look to the non-list examples in nearly any classic Lisp-based book or paper (e.g. SICP).  \n\nThose are entire libraries. Can't you be more specific?\n\nSure, start by try to rewrite this function without some form of cons pairs and car, cdr abstractions.  It can definitely be done, but it's not likely to be more concise or as easily relatable to people working with these concepts and structures.\nFurthermore, it's not apparent to me that all, more, or even some current hy.contrib offerings surpass the demands for justification and relevance leveled against these cons elements.  Also, by removing cons functionality, two projects that very clearly demonstrate the power of Hy\u2014hydiomatic and adderall\u2014through their ability to bring non-trivial Lisp abstractions directly into the Python world, were completely disabled and made considerably more difficult to repair.  \nOut of respect for those projects alone, limited cons functionality could've simply been moved to hy.contrib.  That approach also seems much more in-line with the deprecation process of most other mature software projects.  However, if one assumes that the problems involved with not removing all aspects of cons clearly outweighed the value of those two projects, then, sure, but #1576 did not make that particular case.. Version numbers aren't what make a project meaningfully mature, nor are they justification for enforcing the preferences of individual project members, and especially not at an unnecessary cost to the development community.  They exist as a service to those communities, and only sometimes as a means of justifying destructive changes when they serve an agreeable purpose\u2014usually one that's equal to or greater than the things they destroy.\nCommunity-based projects tend to become mature by actively respecting people's efforts and continually adopting and improving fair, transparent, easy-to-follow standards and practices, so that discussions like these become less and less frequent and necessary.\nWhen that happens, it's easier for others to get\u2014and stay\u2014involved, or for existing contributors to confidently work toward larger improvements.  That's how version numbers meaningfully increase.\nAlternatively, without those elements of maturity, projects end up being driven by random individuals. \n Unless those individuals are consistently driving all the version-defining, large-scale improvements, contributions will mostly likely consist of minor improvements, and those version numbers won't reasonably increase.. I think the points in that blog post make some very good cases for why.. This patch seems to work:\ndiff\ndiff --git a/docs/conf.py b/docs/conf.py\nindex d537b60..27793ac 100644\n--- a/docs/conf.py\n+++ b/docs/conf.py\n@@ -54,3 +54,18 @@ html_context = dict(\n intersphinx_mapping = dict(\n     py2 = ('https://docs.python.org/2/', None),\n     py  = ('https://docs.python.org/3/', None))\n+\n+def setup(app):\n+\n+    from sphinx.writers.texinfo import TexinfoTranslator\n+\n+    def _escape_id(self, s):\n+        # type: (unicode) -> unicode\n+        \"\"\"Return an escaped string suitable for node names and anchors.\"\"\"\n+        bad_chars = ',:()'\n+        for bc in bad_chars:\n+            s = s.replace(bc, ' ')\n+        s = ' '.join(s.split()).strip()\n+        return self.escape(s)\n+\n+    TexinfoTranslator.escape_id = _escape_id\nI'm not sure about texinfo formatting (e.g. there might be a \"correct\" way to escape/format a .), but this looks like a means of addressing the problem directly.. I put in a PR https://github.com/sphinx-doc/sphinx/pull/5872, so keep an eye out for that.\n(Just so happens that I recently hacked up an autodoc documenter for extracting docstrings from macros, so this Sphinx stuff was fresh in my mind.). Not an immediately usable answer, but I recently wrote something about Hy <-> Python AST (i.e. round-trip) compilation: Readable Strings and Relational Programming in Hy.. > @brandonwillard did you mean \"equivalent and not exactly equal\"? rather than:\n\nmight only be equal and not exactly equivalent\n\nYeah, looks like it.. On master I get this:\n```clojure\nhy 0.15.0+64.ga42e17a using CPython(default) 3.6.6 on Linux\n=> (setv foo {:a 1 :b 2})\n=> (. foo contain #* [:c])\n  File \"\", line 1, column 20\n(. foo contain #* [:c])\n                     ^-----^\nHyTypeError: parse error for special form '.': should have reached end of form: HyExpression([\n  HySymbol('unpack-iterable'),\n  HyList([\n    HyKeyword('c')])])\n```\nDoesn't look as bad as the OP.  @Wagk, which version of Hy are you running?. I don't know if being a statistician is necessarily good; you seen R?. Joking aside, I might like it more than Python, but it's definitely no Lisp.. By the way, the best language is Haskell.... Python libraries?  Not exactly.  It's something between Python's accessibility and the breadth and interests of its community (e.g. general scripting, machine learning, data-related things, etc.). Maybe a bytecode version thing?  If you turn on debug, does it say it's recompiling?. I was thinking of -d.. What about this:\nclojure\n(defn factory [upper]\n  (eval `(fn [] ~upper)))\nIt yields\n```clojure\n=> ((factory 9))\n9\n```\nThe original formulation has the lambda's upper as a generic symbol object, and I'm not sure why it would/should bind with the function argument upper.\n. It appears directly related to #1041.  One might be able to get the desired effect in the original factory formulation, and some of the examples in #1041, by setting the locals and/or module differently.. @xuqinghan, try the following instead:\nclojure\n(defn make2 [str_fn_body]\n    (fn [env]\n        (eval `(fn [uid] ((.get ~env \"a?\") uid)))\n    )\n). OK, I know what's happening.  The expression (factory 9) is using the local function namespace to evaluate (eval '(fn [] upper)), and that namespace includes upper, as expected.  Unfortunately, the presence of a binding for upper doesn't matter in that situation, because it's only creating the function/closure object that is (fn [] upper).  What's desired/assumed is for the resulting function/closure object to adopt the evaluation namespace.\nAlso, if this is the Python equivalent, it also doesn't work:\npython\ndef factory(upper):\n    return eval('lambda: upper')\n```python\n\n\n\nfactory(9)()\nTraceback (most recent call last):\n  File \"\", line 1, in \n  File \"\", line 1, in \nNameError: name 'upper' is not defined\n```\n\n\n\nHowever, setting the globals namespace to the local one does add the desired binding to the resulting closure:\npython\ndef factory(upper):\n    return eval('lambda: upper', locals())\n```python\n\n\n\nfactory(9)()\n9\n```\n\n\n\nCurrently, the same can be demonstrated in Hy as follows:\n```clojure\n(import types)\n(defn factory [upper]\n  (setv local-mod (types.ModuleType \"local-mod\"))\n  (setv test-mod.upper upper)\n  (eval '(fn [] upper) :module local-mod))\nclojure\n=> ((factory 9))\n9\n```\nWe could make it easier/possible to specify globals explicitly, or even make some better default choices for that value (it's currently the module namespace).  The latter sounds more in-line with #1041.. I suppose it should throw something other than a HyCompileError (e.g. a HyMacroExpansionError).. Unrelated question: is there a reason we aren't using six for most of those compatibility functions and constants?. Replace it with a link to Hy Society members?. Ohh, now I kind of like the idea of it being a secret (Hy) society.. This was a fix for errors observed in Travis caused by seemingly incompatible versions of py and pytest.. It was this one.  I think I was able to replicate it locally, but it must've been caused by something in the old PR, because I can't now.. Not so sure about removing this override; the default ImpLoader._reopen simply does open(self.filename, 'rU'), which won't necessarily use the unicode codec (I think).. It is, but most likely not in a situation where ImpLoader._reopen is called.. Just re-added a custom _reopen that guarantees unicode decoding.. Yeah, probably.  This started from an elaborate scheme to check ast.ImportFrom and multi-import ast.Imports, then I realized only from __future__ import ... statements needed to be handled and cut out parts from there.. You fine leaving that test in there, though?  I like its \"directness\".. Looks like the tests in test_ast.py are using can_compile instead; I'll make the other tests here use that as well.\nOtherwise, I can replace this one with an assertion to test_hy2py that checks m.__doc__.. All these patched functions are direct copies from the [bp]db source (a couple have slight cross-version modifications, though), but, yeah, they could be cleaned up a bit.. Good point; will update.. Yeah, that's why it's currently an expected fail, but I'm open to making it work \u2014 e.g. with the incremental compile-and-eval approach.  If there aren't any objections to that design change, I can put it higher up in my priorities.\nBy the way, an incremental approach would drastically simplify debugging!. Removed them. That's not just a style change; a new parameter was added to macroexpand.. Ha, yeah, I was debating that in my head, and ultimately sided with \"transpiler\".  Still, that comment was actually a personal note that shouldn't have ended up in there!. Perhaps it's reasonable to silently allow a (require module) when module has no macros or tags, but I'm on the fence about that.  Regardless, that check short-circuits the steps that follow and provides a much more precise error when assignments are not just ALL.. These change requests from the ... if ... else ... syntax to ... and/or ... are rather frequent; is there a Python convention/style guide I've missed, or should we establish one?\nI like the latter more, but, for some reason, I find the former more conventional (maybe even \"Pythonic\").. Yeah, I have have something like that in a correction I'm about to push.. Heh, good question: sometimes one of those, sometimes a couple, sometimes all!\nThis one is for editors, though.. In the case of these import/package-based utility functions (including inspect.getfile and others), where their output is optional (i.e. we don't require filename and/or source) and should not stop the code that follows, catching Exception is fine.\nRegardless, I believe that inspect.getfile should only raise a TypeError, so those cases might be easily reducible, and pkgutil.get_loader is supposed to return a loader or None, so perhaps that as well.  I'm not sure about get_filename and get_source, though, and I don't want those to screw things up.. There were cross-Python-version reasons, but they might be irrelevant under coming changes.. Yeah, I wasn't sure where/if that was ever used, so I didn't update it and only commented it out.. Any relevant errors showing up here would necessarily appear in more appropriate places soon after (i.e. when one of the modules is actually imported), or\u2014best case scenario\u2014we would completely avoidable irrelevant errors in the core functionality that follows.\nI don't mind being more precise, though, so I'll make that change.. Great example of my point: the current pytest failures are due to an exception in this exact place (and the exact circumstances I described).\npytest hijacks the loader mechanisms in order to do its assertion rewriting, and the loader object it returns from pkgutil.get_loader does not fulfill the Python API, so the get_filename and get_source calls will fail.  Had this exception been caught, the function would've gone forward unaffected and the tests would've done their job (and passed).  \nNow, since it's not reasonable to write special conditions for an exception caused exclusively by pytest, we have to work around this problem indirectly and in less sure-fire ways.  Furthermore, the code is still open to issues of this nature.. The TypeError is for the other situation that uses inspect.getfile.\nWorse yet, after fixing the pytest issue, I hit this independent pkgutil.get_loader issue in Python 3.4.0.  Thankfully, upgrading to Python 3.4.4 fixes it.. Yeah, but I think I'm gonna put in another refactoring PR that will take care of that point, so I'll remove it from here.. Sorry, I think I've just been confused about your request: you want it there in its original form, and not removed?. Ohh, looks like they just added this \"insert a suggestion\" feature (literally just popped up as I wrote the previous comment).  If it shows up for you, let's try it!. These two functions are part of the class spec and called implicitly elsewhere, so I can't get rid of them, but they can be simplified.. This change appears to produce the following rendered HTML:\nhtml\n<p>_.\n-</p>\nThat result is far from the expected output/formatting.  Is there a better hack that doesn't break the output?  Perhaps a unicode alternative?. takes should be take.. a vector defining a possible super classes should probably be a list defining the super classes.. ",
    "caustin-usgs": "@Kodiologist thanks for the clarification, makes sense. will open a new PR for the switch to python 3 syntax. @freezas sorry, no i haven't. ",
    "freezas": "@caustin-usgs Have you already made a branch to Python 3 syntax? I'm willing to help a hand or start a new branch if you haven't got the chance to work on this.\nedit: nvm, I don't see more commits in your fork, so I'll do a pull request. No problem ;-). D'oh! I've replaced the raw-input in the Hy examples as well now.\nI tried to rebase it, but it looks like the forked branch is still made of multiple commits... Or is this okay now?\nI actually wanted to work on a seperate branch and merge it back to the fork's master, but I forgot to do that correctly. Would that be better next time?\nedit: rebased it with another method after some googling.. I've removed the trailing L's and added a remark about using Python 3.\nI've ran most of the examples. Some of the examples don't work. The things I think need to be fixed are:\n\nan install of Django and import of 'models' in order to run the examples about class variables\na 'require' in order to use the 'loop' expression in the example of Protips!\n\nI wasn't sure if you want these in the same pull request. Should I try to fix those examples anyway?\nThere are also more issues I wanted to discuss first before changing more of the tutorial, but maybe it's better to discuss that on the mailing list. Or is there already a plan to work on improving the tutorial?. I've add my name to the AUTHORS file.\nI'll take another look at Hy and the tutorial another time again.. Thanks! . ",
    "jacktasia": "\nDid you try installing in a clean virtualenv?\n\nNope. Although, I just did and it worked fine from master. That said, my use case, which is probably rare is using a fresh python install from an AWS AMI and installing on the system python. So what's interesting is if I take a fresh instance it won't work, but it will work if I copy what's in your travis/tox config:\ngit clone https://github.com/hylang/hy.git\ncd hy/\npip install --allow-all-external -e .\nAnyway, it's probably on my end so I'll just close this and let google index just in case someone runs into a similar problem they can see some options.. ",
    "yuvallanger": "@Kodiologist Switched to master base.. ",
    "neil-lindquist": "I described the single argument version of cond and did a macro expansion example, like was there.. ",
    "munk": "@Kodiologist It's no more niche than a lisp running on python ;) \nDesign by contract is a very powerful feature. I think it's one of the greatest ideas in software engineering for demonstrating correctness.\nI could certainly write my own macro to do this, but for non-toy programs, I'd be using that over defn most of the time. Because of that, I'd prefer if it was native to the language.\nThis has precidence in Clojure here and it seems like it would be straightforward to implement.\nI'm happy to take a shot at implementing it if you're open to the idea.. ",
    "spiderbit": "ok thanks for clearification. the hy master thing makes sense, the other suggestion I don't get. So basicly that problem is fixed in hy master and there is a workaround for older versions.\nI thought *words transforms it to a tuple, and I thought I created a tuple with (, \"hello\" \"world) in fact type gave me even type tuple.\nSo * dont is a shortcut for (tuple ...)\nSorry for wasting your time then :D. I wonder if that problem is no reason to fork? It would be hard to change the muscle-memory from (let (...) foo) to (with [x 5] foo) or something like that. But I think not even that would work.\nWhat is the goal of hy, it should be a as much as possible lisp with a ptyhon backend? \nI thought it's just not possible that python has no block scope so you can't implement a lisp like (let) construct, but I just learned aboutd the del() function.\nSo you could compile:\nlisp\n(let (foo 5) (bar))\ninto:\npython\nfoo = 5\nbar()\ndel (foo)\nI just wonder, because without let I can't take a lisp like language serious. I don't want to programm python code with a bit different parens syntax.. that's good to hear, why do I not see it then in the documentation homepage?\nneither there:\nhttp://docs.hylang.org/en/stable/language/api.html#built-ins\nnor there:\nhttp://docs.hylang.org/en/stable/tutorial.html#hy-is-a-lisp-flavored-python\nwhere is it hidden? :D. ",
    "waigx": "PSA: I will grab this one, please let me know if you have any concern.. Thinking to pick up this one if possible.\nIt seems that we need to override this function (I might be wrong): https://github.com/python/cpython/blob/master/Lib/pdb.py#L1194\nSorry for being unfamiliar with the code base and probably easier asking you guys: have we done similar thing (override a method in Python library) before?\n. Okay, probably should go hy/hy/contrib/ folder. Ah, thanks for the heads-up. I honestly just started looking into it, and not familiar with it at all.\nI think it's better to leave this for a more experienced developer, and implement it in a correct way. BTW if this enhancement significantly enlarges the scope of that PR, you might want to focus on that PR and back to this issue with a separate PR.\nI would like to see how do we map lines between .hy and .py \ud83d\ude01. Thanks for all these details - I thought this a problem of the way pdb.do_list read source files but I was wrong.\nThanks again for your time!. This sounds a good idea. I am going to grab -E supporting.. I am honestly not familiar with PYTHONCASEOK... How does this effect the project? and why is icky related?. @kirbyfan64 haha gotcha. @Kodiologist - just tried and seemed still doesn't work\n```\nhy 0.14.0 using CPython(default) 3.6.4 on Darwin\n=> (. imag 1j)\n  File \"\", line 1, column 9\n(. imag 1j)\n          ^-^\nHyTypeError: The attribute access DSL only accepts HySymbols and one-item lists, got HyComplex instead\n``. @Kodiologist -- sorry my bad. I should have use(. x imag). Hi @vodik - Thanks for the solution. I am still new tohy` and trying to take advantage the elegance syntax in python.\nHi @Kodiologist @gilch - Sorry for spamming the issue list. ~Do you have a irc channel by any chance?~ \nnvm, Just saw it in the README. @Kodiologist - Yeah, I tried to fix mangle function yesterday but didn't figured out a working solution. Unicode on python 2 seems really tricky.\nI think it is fine as long as unmangle converts the emoji back. The internal representations shouldn't really matter.. That sounds reasonable. But since mangle a frequently called function, I just little bit concern about the performance trade off on fixing that.. Ah, right. This only affects Python 2. The performance difference depends on the solution we come up with.\nIf 'hyx_XU1f602X' is correct on all systems, essentially we want a \"literal\" unicode or coverting UTF-16s to UTF-32. Not sure if some internal methods could do that.. OK, talked with @gilch in the IRC and sounds like there won't be a performance problem.\nJust updated the mangle function for UCS-2 case. Please take another look when you have a chance. Thanks.. @Kodiologist - Thanks for suggestion, the code has been updated accordingly:\n  - pulled the function out and renamed convert_to_ucs4_list --> unicode_to_ucs4iter;\n  - styling and comments had been updated;\n  - checked the NEWS, I feel \"Mangling rules have been overhauled, such that mangled names are always legal Python identifiers\" is already good. Since the Mangling change hasn't been release yet, this commit will be part of it.\n  - PR is squashed and rebased\n  - thanks for the reminder, I will do :D\n  . Hey @vodik - The code has been updated, please take another look.. Testing failure on the first environment is expected:\nhttps://travis-ci.org/hylang/hy/jobs/359655542\n--- Update ---\nIt passes after have usc2 fix in\nhttps://travis-ci.org/hylang/hy/jobs/360290082. True. Also after Python 2 gets obsolete, this infrastructure will be useless.\nI added this env just because we might want to refactor mangling/unmangling at some point. Or, probably when non english speaking users start using Hy for real productions(who uses python2 for new productions \u2753 ).. Thank all for reviewing and suggestions.\n@Kodiologist - Yes, that is a valid concern.\nThis is all about how git manages these pointers. Internally git have all pointer inside .git/refs folder, inside of it, has sub-folders. git provides extensive tools to manipulate these folders/refs. In my case, my .git/refs file system structure will looks like:\n- refs/\n  - remotes/\n     ...\n  - heads/\n     - fix/\n        - ucs2/\n        - problem1/\n     - feat/\n        - travis/\n        - interesting/\nBack to your example, if git got confused, say feat/travis, it will warn you and always checkout the local branch. git also could be confused if you have same tag and branch name.\nI used to organize my code with / durning past 2 years. typically I have fix, feat, chore, doc prefixes in my working git. And have my remote names as upstream, origin, upstream-gitlab etc. I feel the / notation is pretty \"nature\" for me and integrate well with file system.\nThat been said, I am totally open to suggestions of organizing my git. Also I am willing to follow the existing conventions of projects I am working on if any.. Travis jobs run in parallel, typically pypy3 is the last one to pass even with this change in.\nBut I do agree that all this is meant to test a Python2 only pitfall, and makes .travis.yml unclear. Hope other developers could give some advices.. @Kodiologist - I honestly not really sure either... but seems their document say so.\nStages group jobs that run in parallel, while their stages run sequentially. [reference]\nEither way I agree this increase the demand on QA boxes resources. (wait I think that's the point of QA: reduce potential bugs with preallocated resources \ud83d\ude3a). Hi @vodik, Thanks for point that out, I just cleaned up the commit history. Please take a another look.. @Kodiologist - Ahhh, I totally forgot to update NEWS \u2014 my bad. Thanks for adding that.\nReally? I got my masters in SBU two years ago (and had an amazing time there). Small world indeed! Go Seawolves! \ud83d\udc3e. D\u2019oh, seems it only works on python 2. Will update it once I got back to home. Also the NEWs ... . Hi @gilch , the *e has been added (I saw that that but didn't add it - not meant to close that issue). Please take a looks see if that looks good to you. Thanks.. @Kodiologist - Thanks for the reminder, I just added the unit tests.. @Kodiologist - Thanks for the reminder!. ~I could be wrong, but this seems breaks Hy:~\nhy 0.14.0+89.g28f661c using CPython(default) 3.6.5 on Darwin\n=> (+ 1 2)\nTraceback (most recent call last):\n  File \"hy/hy/importer.py\", line 185, in hy_eval\n    _ast, expr = hy_compile(hytree, module_name, get_expr=True)\n  File \"hy/hy/compiler.py\", line 2226, in hy_compile\n    compiler = HyASTCompiler(module_name)\n  File \"hy/hy/compiler.py\", line 381, in __init__\n    load_stdlib()\n  File \"hy/hy/compiler.py\", line 55, in load_stdlib\n    if getattr(mod, e) is not getattr(builtins, e, ''):\nAttributeError: module 'hy.core.language' has no attribute 'hyx_XasteriskXmap'. Sorry, I was wrong, I need to clean my local .pyc (make clean) before running. :(. Nice, we probably want to add the badge into the README.md file if any. @Kodiologist - Thanks, good to know that. I just just updated the initial comment.. @Kodiologist - Thanks, just added the NEWS (shamefully forgot that again... ) and re-worded the title. Please take another look.. Just updated a little bit: quickstart.rst\nNot sure if it worths another pull request.. Thanks for the suggestions - opened a small PR for above concerns. If c is a two 16-bit int unicode, ord(c) throws in a UCS2 python system:\n```\n\n\n\nord(u'\\U0001f5b1')\nTraceback (most recent call last):\n  File \"\", line 1, in \nTypeError: ord() expected a character, but string of length 2 found\n```\n\n\n\nBut I have to say my solution is really ugly - just a patch I can think of without refactor the function.. @vodik - Actually I guess del operation is quite expensive - I wrote like that for pythonic and simplicity.\nBut I can change this part if we'd prefer something like this (from my understanding):\nPython\ni, ucs4lst = 0, []\nwhile i < len(ustr):\n  usc4lst.append(usrt[i])\n  if LOW < ustr[i] <HIGH:\n    usc4lst[-1] += ustr[i]\n    i += 1\n  i += 1\n  . Agreed, we probably want to polish related code a little bit after ditching Python 2. Thanks for suggestion, code has been updated\n(I actually used list before but for simplicity changed it to something like this, now changing it back :D). Got it. I definitely need to switch to Python 3 too. Just because the system came with Python 2 as default and I am too lazy to type an extra 3 (python3).. I was thinking about this, after checking the behavior of python. It seems that _ will be undefined if no result from previous lines: Accessing _ throws error.\nI didn't check iPython but assume it might be the same. I guess we would like keep such behavior for *x, what do you think?. @Kodiologist - What the default value then? It might be a little weird If we use None as the default value, as we don't allow None appears in *x.\nThe implementation could be much simpler if we don't want this behavior, just initialize and shift (I don't even think the queue size need to be configurable):\n. I didn't check iPython but assume it might be the same.\nhahaha \ud83d\ude04 . alright, you guys win \ud83d\ude24. What the initial values then - apparently iPython is using ''. no problem at all - I just used None as default since that makes more sense to me. The code has been updated (literally copied you suggestion above). Please take another look.. Thanks, I didn't know that could be a concern....\nJust updated the code and make the default value to False. I think it is good to use the key value whenever calling error_handler, so the code is easier to reason. Made it default to False to avoid verbose.. Thanks! Again, I honest didn't know the run_cmd could be used that way. This looks nicer ... but unfortunately I guess Hy treat the tuple as 4 individual code pieces. So the *1 ... is None if we wrote that way.\nI updated to ''' -- hope it looks better.. Ah, sorry I was just copying and pasting other part of this file...\nReally should have a good read of PEP8, and maybe find some PEP8 plugin for vim.... D'OH. ",
    "alphapapa": "@tuturto Thanks, those look like the kind of posts I'm looking for!  I added the feed for that to GWENE at gwene.com.wordpress.engineersjourn.category.hy. Thanks for your thoughts.  Is there any kind of timeline that the developers are aiming for with regard to a stable 1.0? I only ask because Hy is already several years old, and with as much potential as it has, I'd hate to see it go several more years without stabilizing.. Maybe what we need is a hy.cl library.  It'd be nice to be able to use letf, flet, labels, etc.. What extant problem in the Hy project is imposing the \"Collective Code Construction Contract\" intended to solve?  And why is a non-contributor trying to impose a policy on a project he's not even a contributor to?. > Pull requests will be merged in time when maintainers have no time to review details of pull requests.\nWhat is \"in time\"?\nThis is a language, not an app or even a library.  PRs shouldn't be merged until they have been thoroughly reviewed by the project maintainers.\n\nC4 can help reduce workload for maintainers.\n\nIt can also increase workload when the maintainers have to revert patches that shouldn't have been merged in the first place.\nWhat are you trying to optimize for here?  Stability?  Longevity?  Features?  PR average-time-to-merge?  Maintainer workload?  You can't optimize for all of them at the same time, because some of them negatively affect others.\nI will ask again, since you didn't answer it: What extant problem in the Hy project is imposing the \"Collective Code Construction Contract\" intended to solve? \nIn general, projects should be wary of \"drive-by\" non-contributors who attempt to impose (or strongly suggest) overarching policies.. > Notice that you have a strong opinion about this project, too. \nNo, only about attempts at \"drive-by\" policy impositions, which seem all too common on GitHub.\n\nAnd, you think you are not imposing your opinion on Hy. \n\nUnlike you, I am not trying to convince Hy to adopt a lengthy, formal policy which would govern the maintainers' own actions.\n\nI also noticed that I couldn't find your commits in Hy project.\n\nIndeed, I am not a Hy contributor, merely an interested bystander.  Maybe I can save the Hy maintainers a little time by raising some objections before they wander by.. > Reading just my comments is not sufficient to understand the lessons of the past.\nPerhaps it would help if you compared and contrasted ZeroMQ with Hy, explaining why you think that what's best for ZeroMQ is also what's best for Hy.. Lessons of the past?  Let's look at a few examples of the \"problems\" caused by non-C4 processes:\n\nIt tells new contributors, \"guilty until proven innocent,\" which is a negative message that creates negative emotions.  ... contributor retreats, fixes patch, comes back somewhat humiliated.\n\nThat's just silly.  If a contributor is humiliated by being asked to make a few changes, after having their code reviewed by experts for free out of the goodness of their heart, that contributor needs an attitude adjustment.\n\nIt gives maintainers power over new contributors, which many maintainers abuse. This abuse can be subconscious. Yet it is widespread. Maintainers inherently strive to remain important in their project. If they can keep out potential competitors by delaying and blocking their patches, they will.\n\nAlso silly.  If a maintainer is being so abusive, fork the project.  We're talking about FOSS.\n\nIt opens the door to discrimination. One can argue, a project belongs to its maintainers, so they can choose who they want to work with. My response is: projects that are not aggressively inclusive will die, and deserve to die.\n\nSee previous.  If you don't like how the project is run, fork it.  Let the better project win.\n\nIt slows down the learning cycle. Innovation demands rapid experiment-failure-success cycles. Someone identifies a problem or inefficiency in a product. Someone proposes a fix. The fix is tested and works or fails. We have learned something new. The faster this cycle happens, the faster and more accurately the project can move.\n\nIndeed an \"optimistic\" perspective.  In reality it would more likely happen this way: new contributor gets code merged without review.  Busy maintainers, whose time is much more valuable than new contributors' time, spend their time cleaning up the mess made by someone who has yet to participate in the \"learning cycle.\"  This is the antithesis of, \"To behave like a hacker, you have to believe that the thinking time of other hackers is precious \u2014 so much so that it's almost a moral duty for you to share information, solve problems and then give the solutions away just so other hackers can solve new problems instead of having to perpetually re-address old ones.\" (Talk about understanding lessons of the past.)\n\nIt gives outsiders the chance to troll the project. It is a simple as raising an objection to a new patch. \"I don't like this code.\" Discussions over details can use up much more effort than writing code. It is far cheaper to attack a patch than to make one. These economics favor the trolls and punish the honest contributors.\n\nAlso preposterous.  Actual trolls should be ignored or banned.  As well, a completely false dichotomy.\n\nIt puts the burden of work on individual contributors, which is ironic and sad for open source. We want to work together yet we're told to fix our work alone.\n\n???  Nonsense.\nNothing there justifies \"C4.\"\n\nThose articles explain better than I can. \n\nIf you cannot or will not explain why you think your proposed policies apply to this project, then you're essentially trolling.. By modifying Sphinx's texinfo.py and causing it to fill empty nodes, I was able to make it finish outputting, and then texinfo revealed the location of the problem.  #1718 fixes the problem, although I don't know if that's how you want to handle it.\nPlease do support the info doc target, as having an info page is very helpful for, e.g. viewing and searching in Emacs, especially with helm-info.  Otherwise one has to view the docs as HTML in a browser, which is much slower to access and search.. @brandonwillard Thanks for digging into it!  That looks like a better solution.. @Kodiologist Given Brandon's PR to Sphinx, do you still want me to submit his patch to conf.py here?. Hm, well, in the interest of laziness (and not adding eventually useless code), I think I'll wait.  I was able to build the info pages for my own use, and I'm guessing no one else is using them anyway.\nI'll go ahead and close this issue, because I surely won't remember to clean it up after Sphinx merges that.\nThanks to both of you for your work!. ",
    "gwerbin": "@Kodiologist not with Homebrew on a Mac! To be fair it's acceptable in this kind of setup to chown -R $(whoami) /usr/local/. Which I did, and it installed fine.\nStill, why should this install something directly to /usr/local and not, say /tmp? Is get_version.py required for Hy to run? Can I configure this somehow, e.g. with an environment variable?. @kirbyfan64 this actually does look like an upstream bug. Try this minimal Python \"package\":\nsetup.py\n```python\nimport os, sys\nfrom setuptools import setup\nos.chdir(os.path.split(os.path.abspath(file))[0])\nwith open('hello.txt', 'w') as f:\n    f.write('hello')\nsetup(\n    name='tmp_pkg',\n    version='0.0.1',\n    data_files=[ ('hello', ['hello.txt']) ]\n)\n```\nI get the same problem:\nrunning install_data\n    creating /usr/local/hello\n    error: could not create '/usr/local/hello': Permission denied\nSetuptools' setup.py install_data is trying to install directly to /usr/local, which seems incorrect according to this comment: https://github.com/pypa/setuptools/issues/130#issuecomment-202911425. @Kodiologist Yep, IPython is written in Python and it provides an interface for writing your own magics. I'll see about hacking a PoC together.. @gilch Based on the docs it looks like you can swap register_line_magic with register_line_cell_magic:\n```python\n@register_line_cell_magic\ndef hy(line, cell=None):\n    import hy\n    if cell is None:\n        return hy.eval(hy.read_str(line), globals())\n    else:\n        # read and eval multiple lines here\ndelete the function to avoid namespace conflicts, as per the docs\ndel hy\n```. @gilch this appears to work. Not sure about edge cases.\n```python\nfrom IPython.core.magic import register_line_cell_magic\n@register_line_cell_magic\ndef hy(line, cell=None):\n    import hy\ndef hy_eval(line):\n    return hy.eval(hy.read_str(line), globals())\n\nif cell is None:\n    return hy_eval(line)\nelse:\n    lines = list(filter(bool, map(str.strip, cell.strip().split('\\n'))))\n    for line in lines[:-1]:\n        hy_eval(line)\n    return hy_eval(lines[-1])\n\ndel hy\n```\nCell 1:\n```scheme\n%%hy\n(setv x 1)\n(print x)\n```\nCell 2:\npython\nprint(x). More complete implementation including %load_ext hy.ipython functionality\nhy/ipython.py\n```python\nimport hy\nimport hy.lex\nfrom IPython.core.magic import Magics, magics_class, line_cell_magic\n@magics_class\nclass HyMagics(Magics):\n    \"\"\" Implement %hy and %%hy \"\"\"\n    def eval_line(self, line):\n        \"\"\" Evaluate a line of Hy code, as a string in the global environment \"\"\"\n        return hy.eval(hy.read_str(line), globals())\ndef eval_cell(self, cell):\n    \"\"\" Evaluate multiple lines of Hy code in the global environment \"\"\"\n    # Only want to return the last result\n    return hy.eval(hy.lex.tokenize(cell), globals())[-1]\n    lines = list(filter(bool, map(str.strip, cell.strip().split('\\n'))))\n\n    for line in lines[:-1]:\n        self.eval_line(line)\n    return self.eval_line(lines[-1])\n\n@line_cell_magic\ndef hy(self, line, cell=None):\n    \"\"\" Dispatch %hy and %%hy magics to be evaluated\"\"\"\n    return self.eval_line(line) if cell is None else self.eval_cell(cell)\n\ndef load_ipython_extension(ipython):\n    \"\"\" Enable %load_ext hy.ipython, which makes the magic available \"\"\"\n    ipython.register_magics(HyMagics)\n```\nIt looks like Scheme syntax highlighting is possible using the code here, using x-scheme instead of x-mssql as in the example.\nEDIT: this doesn't work because my crude string parsing fails on lines that aren't complete Hy forms. Is there a way to parse an entire file with Hy API?\nEDIT 2: fixed. I got that code mostly working here.\nThe one problem is that it always prints a list of outputs, one for each Hy form in the input, rather than just the last one:\nIn [52]: %hy (setv x 1)\nOut[52]: [None]\nI've been messing around with different combinations of arguments and I'm starting to wonder if Hy itself is doing something unusual. I'm not really sure how to proceed; thoughts?. ",
    "ChefAndy": "Sorry about not following protocol. In my haste, I inadvertently created the fork in my work development organization, so I deleted it when the changes were approved. Since it's a very minor change, I'm just going to make a new pull request.. Replaced by PR #1373. Oy, of course. Such a small commit that I got ahead oh myself. Really batting .1000 with this change. \ud83d\ude01\ud83d\ude2c\ud83d\ude33. ",
    "deejoe": "@cwebber @paultag and @olasd are the admins for #hy, as best I can tell from the brief conversation I had with Freenode's ChanServ just now, e.g.:\n/msg chanserv access #hy list\n. As for using whatever IM-du-jour beyond IRC, I think setting up a bridge between any given service and the IRC channel is the most inclusive approach, whose maintenance might be made scalable by advocates of that service taking on the responsibility for making whatever arrangements need to be made.\nMy preferred protocol in this regard is Matrix, and conveniently enough for me as its advocate, Freenode and Matrix.org already have arranged the bridge, which /names shows me several people are already using (the default nick for an IRC user coming across a Matrix bridge has an [m] postfix, making them easy to spot. This can be customized but rarely is.)\nAnyway, the Matrix side of the bridge is accessible through the web manifestation of the riot.im client through this link:\nhttps://riot.im/app/#/room/#freenode_#hy:matrix.org\nbut a great deal of its utility comes from its fairly reasonable experience (eg, one can get a local copy of continuous channel history despite intermittent network connectivity) using the mobile apps.\n. On Fri, Sep 15, 2017 at 06:41:57AM +0000, Jay Kamat wrote:\n\nThe traditional way of dealing with this is MemoServ, or something in your\nbrowser. Freenode supports MemoServ already.\n/msg MemoServ help\n\nMemoServ is a one-to-one push system: If an intended recipient is offline,\none can give memoserv a message to hold until the recipient re-connects to\nthe channel.\nSo, yes, this does provide some ability to communicate via IRC despite\nintermittent connectivity.\nWhat MemoServ does not supply is continuity of access to ongoing discussion\nnot funnelled through MemoServ to third-parties: Alice and Bob discuss a bug\nin the channel.  Charlie's client was disconnected during that discussion,\nand so not only does he miss the content of the conversation, he may not\neven know it has taken place.\nSome individuals address this by following the channel using bouncers or by\nmaintaining long-running clients on well-connected machines (eg,\nssh+[tmux|screen]+[irssi|weechat]) and accessing discussion using backscroll\nor other more explicit logging features of their clients.\nSome channels address this via making logs of the channel public so that\nsomeone without a client connected at the time of the conversation can go\nback to read it later.\nMemoServ has its uses, and perhaps should be more widely known and used, but\nit does not offer the same experience that we're talking about here.\n. On Fri, Sep 22, 2017 at 03:15:42AM +0000, Ryan Gonzalez wrote:\n\nTBH is there a particular reason we're using IRC, over something like Gitter\n(which has great GitHub integration and is used by a ton of projects) or\nDiscord (which is user by RPCS3)?\n\nThere are several.\nFor me IRC remains, at the very least, first among equals.  It has very low\noverhead and is very easy to start using.  It has a wide range of access\nmodalities from web-hosted clients (IRCCloud, Mibbit, etc) to console to\nmobile clients, including bouncers, etc.\nEvery other approach has its adherents, but tbh every other approach is a\nbaby compared to IRC.  Nearly all other approaches suffer from not being\nfederated and standardized, not being end-to-end free, or relying on a\nsingle company's continued support and infrastructure (making that company\na single point of failure) (eg, the Google Reader problem). \nXMPP is the one thing that avoids most of these problems, but of course not\nhaving a single company promoting it in their attempt rapidly to gain\nnetwork-effect dominance, it doesn't have the mindshare of all these other\nthings. It is more powerful than IRC in many respects but that comes at a\ncost in complexity.\nEvery other option shares IRC's marked disadvantage of not being somebody\nelse's favorite thing that a ton of projects use.\n. ",
    "jgkamat": "The traditional way of dealing with this is MemoServ, or some integration in your irc bouncer to send messages answering questions when a user comes back. Freenode supports MemoServ already.\n/msg MemoServ help\n. The traditional way of dealing with this is MemoServ, or some integration in your irc bouncer to send messages answering questions when a user comes back. Freenode supports MemoServ already.\n/msg MemoServ help\n. On my computer (debian 9), I don't see this issue. The \u0394 is saved properly in history, even after opening the hy repl up multiple times.\nI'm using hy3 though, maybe this is only an issue on hy2 (since python string encoding was improved in python3). ",
    "schaefed": "Ahh, you are right, that was the whole point of the exception... I updated the PR.. Alright, done!. Added a small test. Not sure why travis-ci is failing, on my local machine make d with Python 3.6 terminates without errors.... I just reverted the changes and travis passes, so my stuff is wrong. I noticed that pytest collected 397 items in travis while this number is 534 on my machine. Any idea where this discrepancy comes from and how I could reproduce the travis checks locally?. No, I am on Linux (Arch Linux, up to date). I had a look into the travis logs again and it seems, that the tests already fail during the collection phase of pytest. None of the test did actually run, as pytest gave up after two Errors during the search. That should be the reason why the numbers of collected items deviate.\nI now also managed to reproduce the errors locally, within a fresh python2 based virtualenv (still passing all 533 expected tests on python3 though). Not sure if I am able to fix them, at least the first import related error seems to originate deep within the internals of the compiler. And this thing is basically a black box for me...\nI think I can give it a few more tries within the next a couple of days... . With #1377 in place this now works as intended.. Points 2 and 3, sure.\n\nPut the new test in test_ast.py, rather than putting it in a different file and importing can_compile from test_ast.py\n\nWell, I consider the problem to be a compiler, rather than an ast issue, that's why I placed the test into test_compiler. If you just dislike the import from another test file (which I certainly do), maybe the cleanest solution would be to put can_compile into a separate test helper module (maybe something like that already exists?). However, your game your rules, so, if you tell me to move the test, I do.... Thanks for the clarification.. Done. > [...] or just meld the commits together?\nIs there some git magic making this possible?. Okay, did that. I guess I am causing you a lot of extra work, considering all the stuff I am not doing correctly.... Okay, that was maybe to simplistic... \nAfter digging further, I guess I found the root of the problem. HyComplex only takes one positional argument, but when calling copy or deepcopy on an HyComplex object the real and imag parts a passed to the constructor as seperate arguments. The latter always ends up within *args which is not passed to the superclass. \nThe proposed implementation handles that in a way, that there is no need to overwrite __copy__ and __deepcopy__ anymore.. I know, but I prefer it that way... if you don't, I can change it.... You are right, sorry! Changed.. ",
    "ackerleytng": "Got it, thanks!. ",
    "trylks": "Hi, first: great job here with Hy. I'm looking forward for version 1.0.\nAbout this issue, why not creating a local function?\nx=3\ndef _hy_anon_def_1():\n  print('hi')\n  return x\nwhile _hy_anon_def_1():\n  print(x)\n  x -= 1\nDoes that mess up with the AST too much?. ",
    "longquan7": "@tianon @kirbyfan64 What I want is to push it to the authorities,if can be support arm64,thanks. @kirbyfan64 If this image support arm64 I want to add it to  https://hub.docker.com/u/arm64v8/. @kirbyfan64 ok,thanks. ",
    "rkday": "I've created #1419 to cover that (as a separate PR, in case there is some reason).. Thanks! I've made those changes.. Like so?. OK, done.. Yep - I had 'str' in a check but 2.7 wanted 'unicode'. Should be fixed now by using hy._compat.. Done. (I didn't know about none?, and I agree it's nicer, so I've used that - thanks.). Whoops, fixed.. Sorry for the delay in getting back round to this - I've now made that docs change and rebased. (I'm happy to squash the docs commit into the original one if that's better.). $ mkdir bar\n$ cd bar\n$ mkdir -p /tmp/foo\n$ echo \"import sys; print(sys.path)\" > /tmp/foo/testpy.py\n$ python /tmp/foo/testpy.py\n['/private/tmp/foo', '/Users/rkd/bar', '/Users/rkd/Envs/hy/lib/python36.zip', '/Users/rkd/Envs/hy/lib/python3.6', '/Users/rkd/Envs/hy/lib/python3.6/lib-dynload', '/usr/local/Cellar/python3/3.6.2/Frameworks/Python.framework/Versions/3.6/lib/python3.6', '/Users/rkd/Envs/hy/lib/python3.6/site-packages']\n$ echo \"(import sys) (print sys.path)\" > /tmp/foo/testhy.hy\n$ hy /tmp/foo/testhy.hy\n['', '/Users/rkd/Envs/hy/bin', '/Users/rkd/bar', '/Users/rkd/Envs/hy/lib/python36.zip', '/Users/rkd/Envs/hy/lib/python3.6', '/Users/rkd/Envs/hy/lib/python3.6/lib-dynload', '/usr/local/Cellar/python3/3.6.2/Frameworks/Python.framework/Versions/3.6/lib/python3.6', '/Users/rkd/Envs/hy/lib/python3.6/site-packages']\nSo in the Python case the path includes the directory that testpy.py is in, and in the Hy case it includes the current directory and the directory that hy is in (presumably because to the Python interpreter, hy is in the same position that testpy.py is otherwise). The rest of the path is the same.\nAdding sys.path = [os.path.dirname(filename)] + sys.path at https://github.com/hylang/hy/blob/master/hy/cmdline.py#L212 fixes it, but that feels a bit hacky - any better thoughts?. Do we need this? https://softwareengineering.stackexchange.com/questions/130478/what-copyright-date-for-an-update-to-an-open-source-project-from-last-year suggests year of first publication is all that's required.. \ud83d\udc4d . I'm keen on two weeks - it's nice to be faster-moving (and having fewer open pull requests gives new contributors a better impression of the project - I'm much less inclined to contribute to projects where it looks like PRs just become stale).\n\"We could add an experimental branch that takes only one approval. Merging that in to master would be more difficult, but less frequent.\"\nMaybe some variation on this idea? For example, PRs can be merged after two weeks with only one core member's approval, but every PR needs to get two approvals before a Hy release (which may be a more efficient \"if this was going to break anything, it would have by now, so +1\"). That keeps the master branch faster-moving, but doesn't reduce the quality of actual releases.. Only because https://github.com/hylang/hy/blob/51fb807cc9eb5b005b79b4dbe819d8e11889de78/tests/native_tests/language.hy#L260 does - I'll remove.. Although the ... syntax is only supported on Python3, the Ellipsis object exists in 2.x (https://docs.python.org/2.4/lib/bltin-ellipsis-object.html). Couldn't we do:\nif PY3:\n    return asty.Ellipsis(symbol)\nelse:\n    symbol = \"Ellipsis\". ",
    "0atman": "hy 0.13.0 using CPython(default) 3.5.2 on Linux. I agree I could just use get here, but still I'd like to know why the anonymous function is being returned unapplied, rather than being called with the dictionary.. double parens - got it. thanks!. ",
    "dannyfreeman": "Thanks for the answer!. ",
    "sleepyfox": "Is there a workaround to this, other than precompiling every .hy file to .py and calling python -m unittest test_file?. i.e. I'd like to be able to just work with hy files and do something like hy -m unittest my_hy_test_file (except that the previous doesn't work).. And I can do this without having to compile everything to .py files first?. ",
    "h8hawk": "I've installed with pip. hy version is 0.13.0 . astor.version is 0.6. I'v edited \"/usr/local/lib/python3.6/dist-packages/hy/cmdline.py\" , changed \"import astor.codegen\" to \"from astor import codegen\" . It runs well. However there are bug's in running wrong codes in Hylang shell. such:\n\"\"\"\n=> (pr fka)\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.6/dist-packages/hy/cmdline.py\", line 102, in runsource\n    ast_callback)\n  File \"/usr/local/lib/python3.6/dist-packages/hy/importer.py\", line 176, in hy_eval\n    return eval(ast_compile(expr, \"\", \"eval\"), namespace)\n  File \"\", line 1, in \nNameError: name 'pr' is not defined\n\"\"\"\". ",
    "krosenmann": "@rkday No, it doesn't.\n```\n$ echo \"import sys; print(sys.path)\" > testpy.py\n$ python testpy.py \n['/home/roman/sources/hyjango', '/home/roman/sources/hyjango/.venv/lib/python36.zip', '/home/roman/sources/hyjango/.venv/lib/python3.6', '/home/roman/sources/hyjango/.venv/lib/python3.6/lib-dynload', '/usr/lib/python3.6', '/home/roman/sources/hyjango/.venv/lib/python3.6/site-packages']\n$ echo \"(import sys) (print sys.path)\" > testhy.hy\n$ hy testhy.hy \n['', '', '/home/roman/sources/hyjango/.venv/bin', '/home/roman/sources/hyjango/.venv/lib/python36.zip', '/home/roman/sources/hyjango/.venv/lib/python3.6', '/home/roman/sources/hyjango/.venv/lib/python3.6/lib-dynload', '/usr/lib/python3.6', '/home/roman/sources/hyjango/.venv/lib/python3.6/site-packages']\nAnd this is a reason:\nipdb> p os.path.dirname(filename)\n''\nipdb> l\n    207 \n    208 \n    209 def run_file(filename):\n    210     from hy.importer import import_file_to_module\n    211     from IPython.core.debugger import Tracer; Tracer()()\n--> 212     sys.path = [os.path.dirname(filename)] + sys.path\n    213     pretty_error(import_file_to_module, \"main\", filename)\n    214     return 0\n    215 \n    216 \n    217 def run_repl(hr=None, **kwargs):\nipdb> \n```. ",
    "POMXARK": "I do not know, I'm trying to start a text gen\nerator https://github.com/philiparvidsson/LSTM-Text-Generation. why? where can I ask then? tell me?. ",
    "MonsieurV": "Can't be more reactive! Thanks\nJust beginning to use Hy. The doc is clear, it is easy to progressively introduce it in a project: that's great!. ",
    "Alex-Keyes": "@Kodiologist what would you recommend as the best place to start?. Okay awesome I'll check it out! Thanks!\nOn Wed, Mar 28, 2018, 08:44 Kodi Arfer notifications@github.com wrote:\n\n@Alex-Keyes https://github.com/Alex-Keyes How about fixing this error\nmessage? #1486 (comment)\nhttps://github.com/hylang/hy/issues/1486#issuecomment-356675221\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/hylang/hy/issues/1490#issuecomment-376912625, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/ALKQFrMmW5PJ9ZTJcbcrsCZj2134azZ_ks5ti6G9gaJpZM4Rcy5d\n.\n. \n",
    "thautwarm": "@vodik The reason why slice performs worse in your code is that global variable slice is loaded in each cycle.\nIn fact, slice could be slightly faster than literally getitem syntax.\n```python\nclass Demo:\n    def getitem(self, item):\n        return  item\ndemo = Demo()\ns = slice(1, 2)\n%timeit demo[1:2]\n137 ns \u00b1 0.564 ns per loop (mean \u00b1 std. dev. of 7 runs, 10000000 loops each)\n%timeit demo[s]\n130 ns \u00b1 0.7 ns per loop (mean \u00b1 std. dev. of 7 runs, 10000000 loops each)\ndef test():\n    s = slice(1, 2)\n    demo = Demo()\n    def test1():\n        demo[1:2]\n    def test2():\n        demo[s]\n    return test1, test2\ntest1, test2 = test()\n%timeit test1()\n203 ns \u00b1 4.77 ns per loop (mean \u00b1 std. dev. of 7 runs, 1000000 loops each)\n%timeit test2()\n190 ns \u00b1 4.65 ns per loop (mean \u00b1 std. dev. of 7 runs, 1000000 loops each)\n```. More to fetch at serhiy-storchaka's PR.. ",
    "v217": "OK any combination works fine!\nWhether provided by apt or pip3\nI had the problem only with the build script of sublimetext. Sorry for the false bug report.. ",
    "asmodehn": "Hi @vodik, I was actually working on implementing a working importer for hy in palimport when I found out this PR.\nI m not yet familiar with hylang, but it looks like you reimplemented an importlib... It might be necessary or not, not sure how much you want to deviate from python import semantics (namespaces packages, bytecode location and all that...) But I though you might want to know about filefinder2, which I maintain, as I need custom imports (py2/py3) for other projects. The goal is to eventually phase it out when py3 takes over, but it currently is a good base to start when writing a custom importer.\nReusing filefinder2 might help you implement importlib by relying on python3, without too much code for py2 compatibility. Anyway, Let me know if I might be of some help here.. FYI, I got a simple importer to work on a simple usecase there : https://github.com/asmodehn/palimport/pull/6/files. > I might have done stuff wrong, but the loader should respect Python 2 conventions, like how submodules as supposed to be loaded recursively,\nI would be more careful about respecting python3 conventions... because the end is near.\nWhat do you mean submodules are loaded recursively ? They should be loaded if and only if the __init__.py import them, no ? Maybe something I am not aware of (or already forgot about) regarding python2.\n\nBytecode generation and related stuff is there because, as far as I can tell, its not exposed in Python 2. Only in 3.\n\nYes, and it is good to have it (if you need it). I didn't implement that in filefinder2 because I had no usecase for it. Meaning, filefinder2 will use the one in python interpreter (2 or 3, the one that is available), I had no need to modify it yet, so no need to reimplement it there. Also I don't care much about having bytecode or not in python2. Talking about it now, I wonder if I even have test cases for it...\nIf hylang needs bytecode, it would be great if you can find some time to integrate that in filefinder2( with test cases !). That package is specifically for python 2/3 compatibility, and deviation from py3 will need to be implemented outside of filefinder2 (inheriting from filefinder2 where suitable). Implementing that might be quite an adventure however...\n\nI only deviate with namespace packages.\nMaybe you can help me here, but as far as I can tell, I have to break namespace modules.\n\nI don't think so (or I don't get the problem yet...)\nThe code you refer to is in the Loader. Deciding for a namespace package or not, is at the PathFinder level.\nBecause python is happy with a __init__.hy to be a normal package and load it, we should just add this logic into the PathFinder.find_spec method. I've put more details in https://gist.github.com/vodik/efe2310b8d0e5c065a1a38e582d4e580, so let's keep discussing about it there.\n\nSo long as you do a good job of matching Python 2's expected behaviour (instead of backporting 3), \n\nI do backport python3, to match its behavior by default, but another goal is for anyone to be able to modify (by inheritance) the behavior where needed, to : \n- minimize the cost of porting custom importer systems to (latest) python3.\n- make it simple to implement a custom importer with proper behaviors when no deviation is explicitely required\n- make it obvious where a custom importer deviates from python3 import logic\n- make it obvious in the code where importers are enabled or not (using context managers)\n\nI'm game for trying to merge what I've learned here back. And if there's interest in using it besides me, I don't see a problem with it then.\n\nOh yes, please do.\nI think it is beneficial in general to push all the python2 backward compatibility code to external packages (2to3 or six), I just didn't find one that was allowing to also do custom imports.\nDoing that will really reduce the code complexity in hylang.\nAlso there are tests there to validate many usecases in all (supported) python versions, and that can help a lot not to break someone's python because of a small import statement on a python version that wasn't tested.\nAlso the more use cases we have for filefinder2, the cleaner it will be, and python3 import upgrades will be less messy, when we will have to finally let python2 die.. > Yes, I realize the end is near. If it where up to me, we'd drop Python 2 tomorrow. But in the meanwhile, I have to support it. And, in my humble opinion, the best way to do it is to match Python 2's loader's behaviour (not backport Python 3's behaviour), and do it in such a way that a simple patch will drop code, rather than requiring rewrites.\nHehe, that can be a very long debate. In my case I would think that having the user explicitly import in his package __init__ is a good thing anyway. But if you want to recursively import everything recursively, I would think implementing a Py2RecursivePathFinder for this specific behaviour would be simple enough.\nBy the way, I have no problem if you want to send a PR to filefinder2 for this, as a Py2RecursivePathFinder that the user can chose (or not) to use...\n\nYeah, you're right. Its been a while since I last digged into it - its not there. Its here: https://github.com/python/cpython/blob/master/Lib/importlib/_bootstrap_external.py#L1388\nIts not in the PathFinder, its in the FileFinder. The FileFinder looks for \"init\" + suffix and gives up if its a directory. So you can't really chain FileFinders (either within the same PathFinder or across PathFinders) without them all sharing the same the same concept of a module (denoted by init.py as decided by the first FileFinder). The idea that a namespace module is blankly returned here prevents the rest of the file finders from getting a chance to see if they know how to provide a loader.\nNamespace module should be designated last, after all loaders give up.\n\nAh I get your point. I also had a problem with this, and I agree with you in the sense that it took me by surprise at first. I wasn't expecting this design at all. But I guess I come at it from a slightly different angle. My problem is that I want to add (and potentially remove) a CustomFileFinder : \n- Inserting it in the sys.path_hook list after Python's FileFinder is not working ( Python's FileFinder decides it's a namespace path before it gets to my CustomFileFinder).\n- Inserting it in the sys.path_hook list before Python's FileFinder means I need to first find the filefinder hook in the list (which feels like a horrible hack).\nSo I had to go with option2 : when I implement a custom importer, I manage the \"hierarchy/subfolder\" logic in CustomPathFinder (if it is any different that Python3's one), and I manage the file logic in the CustomFileFinder, but I have to insert it before Python's FileFinder (like so : https://github.com/asmodehn/palimport/pull/6/files#diff-98dc28c5586b3a1c1d9b76f9aa62f134R22).\nI also override find_spec in the CustomFileFinder, but do not deal with namespace package (assuming they will be managed by Python's FileFinder, when it gets to that path_hook, since I usually want the python3 behaviour). See https://github.com/asmodehn/palimport/pull/6/files#diff-6a4fa10e912a1a2253de026b1e3ba7cbR54 for an example.\nNote in this simple hylang importer implementation I did not handle the (namespace or not) package case, as I wasn't sure of the desired behaviour. It might be that the inconvenient implementation (for my usecase) of python importlib right now is a major hurdle for your usecase...But I did change before the namespace package semantic for an importer (rosimport), as it was really necessary. But it turned out to be so unexpected and tricky to follow, that I vowed to never do it again, if I can help it ;-). I find that Python3 has a sensible subdirectory import semantic, when it comes to modular scripting language anyway.\nLooking deeper into the code I found out this point also :\n- the PathFinder find_spec implementation defer to the FileFinder to make it a namespace package.\n- the PathFinder find_module implementation directly instantiate a NamespaceLoader.\nI would (naively - can't remember if I ever tested it) assume that : \n- if you want a python2-like behaviour for modules, you should use the python2 API (PEP302), that is find_module.\n- if you want a the python3.4+-like behaviour (meaning PEP451) then you use find_spec.\n\nFinding the time to write test cases and documentation is actually what's I haven't found time to dig into at the moment.\n\nFeel free to take or reuse all the tests in filefinder2. You will also need to box (pytest-forked) your tests, so the state of your interpreter doesn't get polluted by previous tests. One of the problem here is that the volume of files and folder grows quickly, which is another reason why I decided to have that in a separate package.\n\nHaving a high quality, well documented library would be a boon.\n\nOh yes. sadly, documentation is not really my forte either...\nI will now have a detail look at the code you sent here, and run it in a few different way. I ll soon post some kind of report on the gist comments.. ",
    "etanol": "The root cause of this is somehow also related to the root cause of #1134.  However, the fix is different.. I think efforts should go into completing #1518.  Hy's importer is not even compliant with PEP-0302, therefore it's a matter of implementing it right in order to match the expectations of the average Python user.. Definitely.. > This is cool, but seems likely to conflict with #1518.\nHow far from completion is that?\n\nDoes this help with #712?\n\nNot really.\n\nIs there any reason the test uses f.close instead of a with block?\n\nNo reason, I just forgot about it.  I'll change that.\n. Dropping in favor of #1518 . Thanks for that, much appreciated :-). ",
    "saketh": "It seems like the issue is with atoms in the body of defclass expressions, and has nothing to do with triple quotes as I had initially thought, as @vodik insightfully noted.\nFor example, if I just skip the macroexpand as in the attached patch (which probably breaks the compiler logic, so isn't a fix!), then the atoms don't choke the defclass expansion.\nThe offending defclasses with atoms in their bodies, like (defclass Foo [] \"doc\" 42),  then compile just fine.\nI just started looking at Hy today, so I don't yet have an intuition for what might be breaking \u2014 perhaps the iterated macroexpand_1?. ",
    "vlasovskikh": "@Kodiologist What are the changes to funcparserlib that you're proposing? I haven't been developing funcparserlib for a few years, but I still maintain it and I'd like to see improvements in the library by the community in the form of pull requests.. @Kodiologist I like the general idea of being able to list expected terminals or non-terminals. However it's a bit unclear to me how you propose to fix it. We can continue this discussion at https://github.com/vlasovskikh/funcparserlib. Could you file an issue with a simple example grammar, an example file to parse and the desired output on parse errors? Or maybe even a pull request with an implementation of your idea for finding expected tokens? :). ",
    "furiel": "Thanks @Kodiologist, works like charm.\n``\n(defmacro =defn [basename args &rest body]\n  (setv funcname (+ \"=\" basename))(defn ~(HySymbol funcname) ~args (do ~@body)))\n(=defn test [a] (print a))\n(=test \"something\")\n```\nprints \"something\" as expected.. I suggest use semicolon for this line. Not a big deal, but I ran into this as I accidentally copied this line too.. Small typo: def -> defn.. ",
    "dsevero": "Still got the same error :/. @Kodiologist yeah, I'm gonna remove one of them. I'll try to investigate it further.. Looks like the bytecode generation wasn't the problem. For some reason, after generating python code with hy2py, this import statement is the problem:\npython\nfrom hy.core.language import complement, distinct, drop_while, first, inc, iterate, last, reduce, take_while\nMaybe something in the importer is trying to write data somewhere.. I was unable to get any more logging information from aws lambda. \nAlthough, strangely enough, ti looks like it breaks BEFORE the actual import statement.\npython\nprint(\"before everything\")\nfrom hy.core.language import complement, distinct, drop_while, first, inc, iterate, last, reduce, take_while\nmodule initialization error\n[Errno 30] Read-only file system: '/home/sbx_user1073'\nbefore everything\n. Sort of. It enabled me to deploy my code to aws lambda as long as I don't use anything from the shadow library. For some reason it acusses that the module isn't available.\nSince I use toolz most of the time, this wasn't such a big issue.. ",
    "mathvdh": "We can write to /tmp on AWS lambda ... We could have a way to configure where is the cache located (independently of the fact that it should write on read-only fs ..). ",
    "srfoster": "Yep! Thanks!. ",
    "riatzukiza": "I used the discord.py library\nlisp\n(import discord)\n(import asyncio)\n(with-decorator client.event\n  (defn/a on_ready []\n    (print \"Logged in as\")\n    (print client.user.name)\n    (print client.user.id)))\nto produce the above, in an emacs terminal. no, this behavior also occurs if I run it from the commandline and enter it all in line by line\n```lisp\n(import discord)\n(import asyncio)\n(setv client (.Client discord))\n(with-decorator client.event\n  (defn/a on_ready []\n    (print \"Logged in as\")\n    (print client.user.name)\n    (print client.user.id)))\n(.run client \"discord-key\")\n```. I enter it, then after the logs, I can enter no further input.\nI must ctrl +c the terminal\n. It does not... same behavior.... ",
    "oskarkv": "@Kodiologist I was using a slightly old version of hy, hy-0.14.0+92.g4d98cde, and when I updated to hy-0.14.0+169.g79bd4b0 rply-0.7.6 today, I got the same error as you. Seems to me that something is broken, since now I can't do\n=> (defn testf [[a b] c] [a b c])\n  File \"<input>\", line 1, column 13\n\n  (defn testf [[a b] c] [a b c])\n              ^-------^\nHyTypeError: parse error for special form 'fn*': should have reached end of form: HyList([\n  HySymbol('a'),\n  HySymbol('b')]): HyList([\n  HyList([\n    HySymbol('a'),\n    HySymbol('b')]),\n  HySymbol('c')])\n\nwhich I could before, and I expected it to work (the [a b] list, of course, means destructuring).\nAbout my example: I don't know which part you don't understand, so let me explain everything. No doubt I will explain something that you already know.\nMy if-let should work like Clojure's if-let, meaning (if-let [sym expr] then else) should evaluate expr, and if it is truthy, do the then expression, else the else expression. But when evaluating the then expression, sym should be bound to the result of expr. An example would be\n(if-let [element (first some-seq)] (print element) (print \"empty seq\"))\n\nIn\n(defmacro! if-let [[sym o!expr] then else]\n  `(if ~g!expr (let [~sym ~g!expr] ~then) ~else))\n\n[[sym o!expr] then else] intends to destructure the given list, so sym would be element and o!expr would be (first some-seq) in the example above. then and else would of course be (print element) and (print \"empty seq\").\nI use defmacro! and o!expr because of course the expression should only be evaluated once. The implementation from Clojure, for example, is (after removing some assertions and irrelevant stuff):\n(defmacro if-let\n  \"bindings => binding-form test\n  If test is true, evaluates then with binding-form bound to the value of \n  test, if not, yields else\"\n  ([bindings then else]\n   (let [form (bindings 0) tst (bindings 1)]\n     `(let [temp# ~tst]\n        (if temp#\n          (let [~form temp#]\n            ~then)\n          ~else)))))\n\nwhich is quite a bit longer that my version with defmacro!.\nAdditionally, without my change, I noticed that not only can one not have o!-syms in destructuring lists in the macro arguments, one can't have destructuring lists at all, since defmacro! tries (.startswith s \"o!\") on all arguments.\n. I tried to look at all the issues related to removing tuple unpacking in lambda lists, but I didn't really get what the alternative is supposed to be. Is there currently an alternative or is this a work in progress?. I guess my dream of having o!-parameters in unpacking lists will have to wait.\nBut since defmacro! currently can't even use regular optional arguments (because it tries to call .startswith on all arguments), maybe adding support for o!-parameters in optional arguments is still good. Admittedly it's hard to come up with an example using optional arguments for macros. Of course, one could fix the regular optional arguments without adding o!-parameter support, but why not add it?\nSo anyway, what do you think of this?\n(defmacro defmacro! [name args &rest body]\n  \"Like `defmacro/g!`, with automatic once-only evaluation for 'o!' params.\n\nSuch 'o!' params are available within `body` as the equivalent 'g!' symbol.\"\n  (defn extract-o [arg]\n    (cond [(and (symbol? arg) (.startswith arg \"o!\"))\n           arg]\n          [(and (instance? list arg) (.startswith (first arg) \"o!\"))\n           (first arg)]))\n  (setv os (list (filter identity (map extract-o args)))\n        gs (list-comp (HySymbol (+ \"g!\" (cut s 2))) [s os]))\n  `(defmacro/g! ~name ~args\n     `(do (setv ~@(interleave ~gs ~os))\n          ~@~body)))\n\n. I might have discovered a problem with the tests.\nI was trying to add a test in test-defmacro! in tests/native_tests/native_macros.hy. I was confused because some tests that should be failing was passing. But if I added a bad macro it would complain when trying to expand it, so something was working. At last, I just added (assert (= 1 0)) in test-defmacro! without anything else new, and the tests still passed. At this point I was really confused. I thought that maybe the function didn't run, and the bad macros were failing at compile time. Then I counted the number of test functions (19), but pytest said \"17 passed\". Two function names had ! at the end. I renamed test-defmacro! to test-defmacrobang, and then pytest started saying 1 failed, 17 passed.\nSo, it is just for me that the functions ending with ! don't run? I don't think so, because one of the old asserts fail, namely (assert (in \"_;res|\" s1)).. Ah, OK! I added some tests.. @gilch Oh, missed your comment there.\nWhen you say I can work around it, do you mean privately, or do you suggest I submit an updated version of defmacro! that supports unpacking? I figured I could wait until you guys finish the more general destructuring macros. It seems a little strange that defmacro! should support unpacking but not defn or defmacro. But I guess it makes more sense in defmacro!, since not having unpacking requires more extra lines than in defn, for example I think this is the shortest way to write if-let without it, which is two extra lines compared to having unpacking:\n(defmacro! if-let [bindings then else]\n  (setv [sym expr] bindings)\n  `(do (setv ~g!t ~expr)\n       (if ~g!t (let [~sym ~g!t] ~then) ~else))).\n",
    "dluciv": "Oops. Missed it. hy.contrib.walk, right?. Yeah, nice, thank you! =)\nIt might however be useful to create reference from core lenguage documentation to contributed walk module about this because I guess many of readers expect having let in some form.... And one more comment.\nIt looks working ok, but it can not produce valid Python code, e.g. it creates dictionary named _;let|1235. Replacing ;let| with _let_ everywhere works, but no idea why not generate valid Python from beginnging here. Why so?. Yeah, really works from master.\nActually Python code produced by those macros looks creepy a bit.\nFor such an example\n(let [a 1 b 2]\n  (do\n    (print a b)\n    (let [b 3 c 4]\n      (print a b c))\n    (print a b)))\nit generates\n_hyx_XsemicolonXletXvertical_lineX1235 = {}\n_hyx_XsemicolonXletXvertical_lineX1235['a'] = 1\n_hyx_XsemicolonXletXvertical_lineX1235['b'] = 2\nprint(_hyx_XsemicolonXletXvertical_lineX1235['a'],\n    _hyx_XsemicolonXletXvertical_lineX1235['b'])\n_hyx_XsemicolonXletXvertical_lineX1236 = {}\n_hyx_XsemicolonXletXvertical_lineX1236['b'] = 3\n_hyx_XsemicolonXletXvertical_lineX1236['c'] = 4\nprint(_hyx_XsemicolonXletXvertical_lineX1235['a'],\n    _hyx_XsemicolonXletXvertical_lineX1236['b'],\n    _hyx_XsemicolonXletXvertical_lineX1236['c'])\nprint(_hyx_XsemicolonXletXvertical_lineX1235['a'],\n    _hyx_XsemicolonXletXvertical_lineX1235['b'])\nNot sure it is faster or slower, but with above lei macro resulting code looks much prettier\n```\ndef _hy_anon_var_1(a, b):\n    print(a, b)\n    (lambda b, c: print(a, b, c))(3, 4)\n    return print(a, b)\n_hy_anon_var_1(1, 2)\n```. ",
    "notagoodidea": "\nIt's even possible to write Hy programs this way that don't have Hy itself as a dependency.\n\nEven using Hy Core or similar namespaces (as stated in the documentation with the exemple of name) in the Hy program ? That can be great!. ",
    "mmiszczyk": "@kirbyfan64  as I mentioned in the OP, removing the splice does not help:\n``hy\n(defmacro my-switch-case [var cases](cond\n    ~(list-comp [`(= ~var ~(first x)) (second x)] [x cases])))\n(my-switch-case x\n  ([1 (print \"first condition\")]\n   [2 (print \"second condition\")]))\nbash\nhy test.hy\nFile \"test.hy\", line 5, column 1\n(my-switch-case x\n  ^----------------\n    ([1 (print \"first condition\")]\n\n [2 (print \"second condition\")]))\n\n----------------------------------^\nHyMacroExpansionError: cond branches need to be a list\n```. no need to import, HyList seems to be accessible by default. but it doesn't help:\n``hy\n(defmacro my-switch-case [var cases](cond\n    (HyList ~(list-comp [`(= ~var ~(first x)) (second x)] [x cases]))))\n(my-switch-case x\n  ([1 (print \"first condition\")]\n   [2 (print \"second condition\")]))\n```\n```bash\nhy test.hy\nFile \"test.hy\", line 5, column 1\n(my-switch-case x\n  ^----------------\n    ([1 (print \"first condition\")]\n\n [2 (print \"second condition\")]))\n\n----------------------------------^\nHyMacroExpansionError: cond branches need to be a list\n. I did a quick and dirty test by replacing(macro-error branch \"cond branches need to be a list\"))with (macro-error branch (-> (type branch) str)))``` to find out the cause. Here's the results:\n```hy\n(import [hy.models [HyList HySymbol]])\n(defmacro cond [&rest branches]\n  \"Build a nested if clause with each branch a [cond result] bracket pair.\nThe result in the bracket may be omitted, in which case the condition is also\nused as the result.\"\n  (if (empty? branches)\n    None\n    (do\n     (setv branches (iter branches))\n     (setv branch (next branches))\n     (defn check-branch [branch]\n       \"check cond branch for validity, return the corresponding if expr\"\n       (if (not (= (type branch) HyList))\n         (macro-error branch (-> (type branch) str)))\n       (if (< (len branch) 2)\n         (do\n           (setv g (gensym))\n           (if (do (setv ~g ~(first branch)) ~g) ~g))(if ~(first branch) (do ~@(cut branch 1)))))\n (setv root (check-branch branch))\n (setv latest-branch root)\n\n (for [branch branches]\n   (setv cur-branch (check-branch branch))\n   (.append latest-branch cur-branch)\n   (setv latest-branch cur-branch))\n\nroot)))\n(defmacro my-switch-case [var cases]\n  (cond\n      ~(list-comp [(= ~var ~(first x)) (second x)] [x cases])))\n(my-switch-case x\n  ([1 (print \"first condition\")]\n   [2 (print \"second condition\")]))\n;;;; HyMacroExpansionError:  ;;;;\n(defmacro my-switch-case [var cases]\n  (cond\n      (HyList ~(list-comp [(= ~var ~(first x)) (second x)] [x cases]))))\n(my-switch-case x\n  ([1 (print \"first condition\")]\n   [2 (print \"second condition\")]))\n;;;; HyMacroExpansionError:  ;;;;\n```. With more testing, I determined that explicit casting to HyList does work, but only if it happens inside the cond macro. After that change, it more or less works the same as the Common Lisp example (that is, I need to splice the result of list-comp):\n```hy\n(import [hy.models [HyList HySymbol]])\n(defmacro cond [&rest branches]\n  \"Build a nested if clause with each branch a [cond result] bracket pair.\nThe result in the bracket may be omitted, in which case the condition is also\nused as the result.\"\n  (if (empty? branches)\n    None\n    (do\n     (setv branches (iter branches))\n     (setv branch (next branches))\n     (defn check-branch [branch]\n       \"check cond branch for validity, return the corresponding if expr\"\n       (when (= (type branch) list) (setv branch (HyList branch)))\n       (if (not (= (type branch) HyList))\n         (macro-error branch (-> (type branch) str)))\n       (if (< (len branch) 2)\n         (do\n           (setv g (gensym))\n           (if (do (setv ~g ~(first branch)) ~g) ~g))(if ~(first branch) (do ~@(cut branch 1)))))\n (setv root (check-branch branch))\n (setv latest-branch root)\n\n (for [branch branches]\n   (setv cur-branch (check-branch branch))\n   (.append latest-branch cur-branch)\n   (setv latest-branch cur-branch))\n\nroot)))\n(defmacro my-switch-case [var cases]\n  (cond\n      ~@(list-comp [(= ~var ~(first x)) (second x)] [x cases])))\n(setv x 1)\n(my-switch-case x\n  ([1 (print \"first condition\")]\n   [2 (print \"second condition\")]))\n; first condition\n(setv x 2)\n(my-switch-case x\n  ([1 (print \"first condition\")]\n   [2 (print \"second condition\")]))\n; second condition\n```\nI'm not sure if you consider this solution good enough to be commited to mainline though. It does seem a bit hacky.. You're right, it works on master with the lfor form and without redefining the cond macro.. ",
    "xuqinghan": "Thanks. I found the problem is list VS HyList.\nthe difference between python list and HyList is subtle.\n\nwhen change the setv line by add ` or ':\nfrom\n```\n(defn flatten_list [list_in_list]\n  (setv res [])\n  ...\n\nto\n(defn flatten_list [list_in_list]\n  (setv res `[])\n  ...\n```\nthe result is just I wanted\ninput  '['(identity) ['(/ 2) '(np.ceil)]]\noutput '['(identity) '(/ 2) '(np.ceil)]\ninput  '[(identity) [(/ 2) (np.ceil)]]\noutput '[(identity) (/ 2) (np.ceil)]\n\nbecause  the ['(identity) ['(/ 2) '(np.ceil)]] is other defn is return value. I dont know how to \" parse str to HySymbol \" in hy and without ' outside. as:\n\n\n(\"ceil\")  ->  (np.ceil) \n (/ 2)      ->  (/ 2)\n\nthen  use -> call them.\nnow I format string f\"(np.{f_name})\"  in py , and call hy.read_str()  return the exor to hy.\n(defn parse_simple_effect [expr]\n;\"ceil\"->np.ceil (/ 2)->(/ 2)\n  (setv symbol_effect (first expr))\n  (if-not (symbol? symbol_effect)\n      (util_py.create_expr_math_str symbol_effect)\n      expr\n  ))\nbut both (/ 2) and (\"ceil\") 's  return has the '.  but the eval is OK.\n...\n  (setv cmd `(-> ~x ~@list_effect_flattened))\n  (eval cmd (globals))\nIs there a elegent way  do (\"ceil\")  ->  (np.ceil)?\n. @brandonwillard   thanks a lot,  it works!\nI rewrite my scene:\n```\n(import types)\n(defn create_fn_of_env [expr_fn]\n    (fn [env]\n        (setv local-mod (types.ModuleType \"local-mod\"))\n        (setv local-mod.env env)\n        (eval expr_fn :module local-mod)\n    )\n)\n(do\n    ;-------create a dict as env----------\n    (setv my_env {\"a?\" (fn [x] (+ x 9))})\n;------create my_fn by 3 steps----------------------\n;1 assemble expr of a fn's body and head\n(setv expr_fn_body '((.get env \"a?\") uid))\n(setv expr_fn `(fn [uid] ~expr_fn_body))\n\n;2 create factory_fn via expr_fn\n(setv factory_fn (create_fn_of_env expr_fn))\n;3 create fn via env\n(setv my_fn (factory_fn my_env))\n\n; -----create a fn as ground truth--------\n(defn factory_gt [env]\n    (fn [uid] ((.get env \"a?\") uid))\n)\n(setv fn_gt (factory_gt my_env))\n\n;-----call fn---------------------\n(print (my_fn 1))\n(assert (= (my_fn 1) (fn_gt 1)))\n\n)\n```. ",
    "celaleddin": "Looks like this issue is resolved.\nIf I remember correctly, GitHub wasn't highlighting Hy three days ago. It was all black. But today, it is highlighted!. ",
    "Risto-Stevcev": "@Kodiologist Apologies, I didn't phrase this well -- this is an actionable item: Adding documentation for how to package Hy packages. ",
    "mbarkhau": "Ahh, I see. So this badge is actually referring to a build that is a few months old?\nhttps://secure.travis-ci.org/hylang/hy.png?branch=master. Maybe this is helpful? https://stackoverflow.com/questions/31882306/how-to-configure-travis-ci-to-build-pull-requests-merges-to-master-w-o-redunda?rq=1\nIf it were me, and if it's possible, I'd just let it do another build after the merge to master of any pull request.. ",
    "vshesh": "Mac OS 10.13.2 (high sierra)\nI don't have access to another mac to test it on... . how is that shebang line made? /usr/local/opt/python3/bin/python3.7 exists, and there's no python3.5 anywhere on my machine, so I'm not sure where the pip install picked that up from.\n. ",
    "david-morris": "Is there a new way to define default arguments? . Thanks!  I didn't see it in tutorial.rst before.. ",
    "cynseok": "@gilch \nThat example produces same error.\nI am running the following version of anaconda and hy on Windows\nanaconda                  5.2.0                    py36_3\nhy                                 0.15.0\n. Running hy2py then running with python test.py works. What is Hy master? Is it different from the one I installed with pip install hy ?. Well, I tried the master version, it would not load any .hy codes, after tinkering for couple of hours I decided to stay on stable release. \nWhat would be the reason multiprocessing support would be on the master version but not available on the stable version?. ",
    "crocket": "@kirbyfan64 If you read https://github.com/zeromq/libzmq/pulls, you would realize that pull requests that abide by a few rules get merged quickly. The ones that aren't merged yet explicitly state \"Work In Progress\", \"Discussion\", or \"Don't merge\". On the contrary, https://github.com/hylang/hy/pulls tells a different story. hy is slow to merge pull requests.\nThe faster you merge pull requests, the bigger a community grows by attracting contributors. Contributors are more likely to come back to a project that merges pull requests quickly.\nThe purpose of C4 is to grow community by merging pull requests quickly without breaking public API.. C4 accommodates Pieter Hintjen's experiences after writing that blog article.\nHe realized that there needs to be rules for merging in order to avoid arguments and avoid breaking public API and ensure stability while merging as quickly as possible. So, he made a tradeoff. The result is still optimistic merging.\nhttp://hintjens.com/blog:117#toc40 explains the updated story.. http://hintjens.com/blog:106 says\n\nPM: we get a flamewar which troll wins by sheer force of argument. Community explodes in fight-or-flee emotions. Bad patches get pushed through. OM: existing contributor immediately reverts the patch. There is no discussion. Troll may try again, and eventually may be banned. Toxic patches remain in git history forever.\n\nC4 states\n\nAdministrators SHOULD block or ban \"bad actors\" who cause stress and pain to others in the project. This should be done after public discussion, with a chance for all parties to speak. A bad actor is someone who repeatedly ignores the rules and culture of the project, who is needlessly argumentative or hostile, or who is offensive, and who is unable to self-correct their behavior when asked to do so by others.\n\nOn http://hintjens.com/blog:106, Pieter Hintjens wrote in one of his comments\n\nI've contributed often to Wikipedia, as a newbie, and sometimes experienced this yet not always. It depends on the page. Some pages are hostile, like some open source projects.\nIf a project is hostile, it makes no difference what rules you offer: those in power will be aggressive and offensive. The solution then is to fork the project and be a better owner. This is hard on Wikipedia because you can only have one page for a topic. For open source it's trivial.\nI think the rules we develop (like C4, the umbrella contract we use) are more to help the majority of decent people work together than to educate abusive people into behaving.\nSo in practice what you describe happens, yes, yet not because of OM. A precondition for successful OM is decent owners who want their projects to grow.\nWhich is what we see in practice: many ZeroMQ projects practice this, and it works nicely, delivers stable growth and happiness. (And we do not see patch wars.)\n\nI think there's a small chance that a patch war can potentially happen in a huge project like chromium web browser. If a patch war happens, someone will be banned. Or, someone will lose interest, correct one's own behaviors, or leave in anger. You should read Reverts aren't friendly on http://hintjens.com/blog:106\nI asked zeromq developers. They said they hadn't experienced patch wars.\nC4 is not a panacea. It hasn't been tested on huge projects, yet. A better contribution process will emerge in the future.. If there are two disagreeing decent people, they can compromise. I make compromises with coworkers at work, too. C4 doesn't state anything about leaving stuff unchanged.\nI think you can get more contributors from C4 than you lose them due to C4. You shouldn't be afraid of missing out when choosing things. You're always going to miss out on many other things when you choose to focus on something.\nAlso, zeromq developers haven't seen patch wars, yet.\nI'm not saying you should adopt C4. But, I wanted to inform you of other strategies. There's a big difference between not knowing about other options and knowing about them in the long run.. I can't impose C4 on Hy. I have no power over anyone in this project. I'm not a code contributor. But, I can contribute in other ways, for example, by suggesting a contribution process.\nI think people will get more satisfaction from C4 or something similar to it. I proposed C4 because I think it will help Hy survive for longer. I am interested in using Hy, and I want it to survive for longer.\nPull requests will be merged in time when maintainers have no time to review details of pull requests.\nC4 can help reduce workload for maintainers.. I see that pull requests are held up for months. When people learn that their contributions are delayed for months and years, they will leave. It doesn't help with maintaining community size. It helps with growing community and keeping it alive.\n@alphapapa Notice that you have a strong opinion about this project, too. And, you think you are not imposing your opinion on Hy. I also noticed that I couldn't find your commits in this repository.\nI can't make choices for maintainers. I simply wanted to inform maintainers that there are other options they didn't know but can think about. Even if C4 is not adopted, at least the maintainers had time to think about their long-term strategies. Thinking about long-term strategy is important.. @kirbyfan64 C4 is not needed. But, I think it helps. The purpose of this issue was to help the maintainers think about improvements by suggesting C4 to them. I'm not here to be ideological about C4 or anything. There's a lot to learn from someone who dedicated many years to community building.\nYour concerns are addressed on\n\nhttp://hintjens.com/blog:106\nhttp://hintjens.com/blog:117#toc40\n\nReading just my comments is not sufficient to understand the lessons of the past.. Those articles explain better than I can. The best way to understand the lessons of the past is to read those articles, read C4, and take a few minutes to observe the contents of https://github.com/zeromq/libzmq/pulls. Whether or not you adopt C4, it is educational.. I already explained briefly several times.\nAlso, if you already decided that it is a bad idea, nobody is going to change your mind.\nRead the silly articles. Read the stupid contract. Watch it in action. Decide then for yourself. You either like it or hate it.. ",
    "kuettler": "Thanks. I should have seen that.. ",
    "johanatan": "@brandonwillard did you mean \"equivalent and not exactly equal\"? rather than:\nmight only be equal and not exactly equivalent\n. And, very interesting article btw. \nSince this doesn't quite seem possible in practice currently, does anyone have advice for mixing Hy in to an existing Python team? Assuming that co-workers want to continue to use Python syntax and I want to use Hy syntax, what is the best way at this point in time to facilitate it?\nI was thinking that I could \"own\" any modules I write in Hy, be responsible for any feature or modification requests to them and if at some point in time others take a keen enough interest in it, do a one-way translation to Python and let them \"takeover\". Would that work? . ",
    "Quelklef": "Makes sense.\nTo provide a little more insight, I'll say that my understanding after reading the docs was as follows:\n\nAll optional arguments must be marked individually\nIf an optional argument defaults to None, use &optional.\nIf an optional argument has a default provided, simply use a pair [arg default] without &optional.\n\nAn example case like the following:\n(defn long-fun [arg1 arg2 &optional arg3 [arg4 with-default] arg5 arg6 [with-default]]\n    body)\nWould help greatly.. On the thread of more concise arguments, thoughts on not having &kwonly and just having all keyword-only arguments be written as a keyword with :?. So e.g.\nhylang\n(defn print [&rest values &kwonly end] ...)\nis written instead as\nhylang\n(defn print [&rest values :end] ...)\nI would be against this in Common Lisp, because \"keywords\" are symbols, by Hy treats keywords differently anyway.. Didn't know about multiple clauses, awesome!\nTo answer your question, of the two, I'd prefer the former, because it's consistent. Another option would be to change for to drop the braces to match lfor, dfor, and gfor:\n(for x xs y ys foo)\n(lfor x xs y ys foo)\n(By the way, I'm aware that I'm opening a lot of issues and giving a lot of feedback while being someone very new to Hy. If I'm overreaching, please let me know.). Seconded. I like that solution.. I recognize this is a bit of a one-off usage, but it will make it much nicer to stick a debug print into a loop:\nhylang\n(lfor [n some-iterable]\n    (print n)  ; <-- just put it in there with no worries\n    (some-function n))\nthough I am mostly in favor for the sake of consistency.. Eh, incf and decf are fairly ugly names, IMO. I personally would like inc! and dec! but as far as I can tell, Hy doesn't use that convention.\nAnother option would be to not have mutative increment/decrement functions. (+= x 1) and (-= x 1) are not that bad to write, and while succ and pred are likely to be passed around a lot in functional code, saving many keystrokes over (fn [x] (+- x 1)), I imagine that mutative increment/decrement functions will only be used as statements, not saving that much at all.. I'm betting that setv was only called what it was because Python has the built-in set function (@Kodiologist confirm?) so I'm not sure making -v a motif would be great. . Personally I think it would be cool to do this as follows:\ndoto transforms mutative forms into non-mutative forms. What if there was a counterpart, called, say, #!?\n```Hylang\n(setv x 1)\n! (succ x)  ; expands to (setv x (succ x))\n(setv l [5 4 3 2 1])\n! (sorted l)  ; expands to (setv l (sorted l))\n```\nThis would be a more general solution, bridging the mutative<->non-mutative gap in the other direction, which would be awesome. However, it's a little weird/hard to read. Also, the examples I gave are very simple and it's not clear how it should generalize to multiple values or multiple forms (if desired).. A solution would be to make it not a tag, so you'd have:\n```Hylang\n(mut a (succ))\n(mut b (sorted))\n(mut c (filter even?))\n; Multiple forms?\n(mut d (map succ) (filter even?))\n```\nwhere the supplied argument is the last argument.. Yeah. But I've been pondering this kind of macro for a while and I think it may be useful enough to warrant its own thing.. I suppose it doesn't make sense to call (-!> x succ) a \"solution\" to this discussion since it's more verbose than (+= x 1) and really the power of mutative inc/dec is concision. Written-out increment and decrement functions are off the board as well.\nMy personal vote goes for:\n\nThere are no functions named inc/dec.\nMutative increment/decrement is done with += and -=.\nNon-mutative increment/decrement is called succ/pred.\n\nThis would also fit better with Python's \"one way to do it\" mantra.. I get that Hy follows Clojure, but I would opine that Clojure's naming is a mistake. I presume that inc and dec stand for increment and decrement. To \"increment\" and to \"decrement\" are both fundamentally mutative operations, and having them pure seems misleading.\nAnd by status quo more general than just Clojure, inc and dec should be succ and pred.. (m #* 1) would be (m (unpack-mapping 1)) which only satisfies the a argument. That's how I expected it to work, anyway, so (print (id #** {})) would be the same as (print #** {}).. I expected this because AFAICT #** x always desugars to the special form (unpack-mapping x). All other special forms I've seen seem to act this way with macros--which is to say not at all--so I expected this one to as well.. (m #* l) would do nothing because #* l satisfies the a argument but b and c are left unspecified.. > which is illegal at the top level\nExcuse me if this is dumb, but isn't it not at top-level because it's nested in the print call?. Would it not be possible to have arguments be compiled not in sequential order but macro-first?. I think I meant something that doesn't make sense.\nAfter squinting at the code for a bit, it seems that it would be sufficient to expand only one level extra--just arguments to functions, if those arguments are macro calls--rather than all the way.\nRelated, am I correct in saying that Hy does \"no\" evaluation? Hy expressions are compiled to the Python AST which is then evaluated? So it wouldn't make sense to have the checks for unpack- at invocation time.. Alright, I'll try to rewrite the current &optional docs. The other & symbols seemed OK.\nAs for constantly, I included that note because I hit a situation where I wanted to use constantly, but only if it had delayed evaluation. I figure it's worth mentioning for others who were wondering like I was. But I understand your position; should I remove it?. Same PR? New PR?. New constantly documentation should go under Built-Ins, right? What's the difference between Hy Core/Core Functions and Built-Ins?. Or Hy Core/ anything and Built-Ins, for that matter... Well, it's now two commits, but I rewrote history. Still a git novice; was there a nicer way of squashing the PR?. The \"real\" (read: historical) reason I made this change is that I was writing code in which I wanted to use constantly as a macro, but I wasn't sure if it was a macro or a function. It wasn't (explicitely) mentioned in the docs one way or the other, so I made a PR adding a line of documentation. @Kodiologist noted that constantly would probably be more useful as a macro and said I could make a PR with that if I wanted.\nAs for why making constantly be a macro is useful\n\nWe don't lose functionality for pure arguments, however\nWe switch impure arguments from single-time evaluation to evaluation every time the function is called. IMO, this is less surprising; take a look at, say:\n\nhylang\n(setv f (constantly (print \"hello\")))\n(f)\n(f)\nIt seems more natural to me that hello should be printed both times.\nThat being said, I think this boils down to opinion. I can see sticking to Clojure, so perhaps a function constantly and a macro constantly/m would be a good compromise?. > confuses the usual call-by-value semantics of Python.\nI mean, as with all macros.\nBut I see your point about const. Another option besides do-constantly would be continually. It nicely implies an effectful argument and is a shorter name.. ",
    "yuhan0": "How about requiring brackets around the bindings in lfor, gfor and allowing multiple body forms, for consistency with the for signature?  \nEssentially allowing this:  \nclojure\n(lfor [x xs  y ys]\n  (body1)\n  (body2)\n  (result))\nWhich would be equivalent to the current syntax:  \nclojure\n(lfor x xs  y ys\n      (do (body1)\n          (body2)\n          (result)))\nIt seems more \"lisp-like\" to treat the first argument specially (the binding vector) rather than having 2N + 1 arguments and treating the last differently.. For constructing intermediate values, especially since there isn't a built-in let form in Hy.\neg.\n(lfor\n  n (range 5)\n  (do (setv sq (* n n))\n      (.format \"{} squared is {}\" n sq)))\n;; => ['0 squared is 0', '1 squared is 1', '2 squared is 4', '3 squared is 9', '4 squared is 16']. Sorry for the noise - I did read the documentation some time ago, but forgot that these special clauses existed. In a way it seems that the lfor family is much more similar to the CL loop macro than an actual Python list comprehension. \nPersonally I would prefer a natural way of writing these things, i.e just being able to use the standard(setv ... ) form, instead of using a specialized DSL with :setv , :do etc. clauses that don't exist elsewhere in the language.\nBut it's true that the :if clause exists in Python too, and I haven't thought entirely about how that would fit into my proposed syntax. Thanks for your patience though :). Thanks for the explanation, it's always interesting to hear the rationale behind these syntax decisions :)  \nI guess you had also considered Clojure's syntax for its for loop, from what I understand these are equivalent:  \n```clojure\n;; ===== Clojure =====\n(for [x xs\n      :when (condition x)\n      :let [p (f1 x)\n            q (f2 p)]\n      y ys\n      :let [r (f3 y)]]\n  (body1)\n  (body2)\n  (g x y))\n;; ===== Hy =====\n(gfor x xs\n      :if (condition x)\n      :setv p (f1 x)\n      :setv q (f2 p)\n      y ys\n      :setv r (f3 y)\n      :do (body1)\n      :do (body2)\n      (g x y))\n``\nIt's strange how aggressively Hy tends to \"flatten\" its syntax, considering Clojure already does that to some extent \u2013 I find the first one more readable but guess it's a matter of getting used to..\n. +1 to not changing the existing meaning ofinc/dec` to be mutative. (as someone coming from Clojure and also very new to Hy)  \nUsing incf from Common Lisp doesn't make much sense because there's no equivalent concept in Hy of a \"generalized place variable\"...\nMaybe incv / decv in relation to setv ?  \n``clojure\n(defmacro incv [x](+= ~x 1))\n(setv xs [1 2 3])\n(incv (get xs 2))\n(print xs)\n;; => [1, 2, 4]\n``. Personally I actually like the-vprefix as a sort of reminder that it follows Python's scoping rules, as opposed to thesetq` in other Lisps.\n@Quelklef wouldn't that just be a specialized form of threading macro?\n``clojure\n(defmacro ->! [lval &rest forms](setv ~lval\n         (-> ~lval ~@forms)))\n;; eg.\n(setv x 1)\n(->! x\n  (str)\n  (repeat 5)\n  (zip (range 10))\n  (list))\n(print x)\n;; => [('1', 0), ('1', 1), ('1', 2), ('1', 3), ('1', 4)]\n```. I don't think this is a good idea either - to me \"constantly\" strongly implies that the argument is a constant, pure value being returned instead of a side-effectful procedure. \nUsing a macro incurs the cost of an additional function call every time it is called, and confuses the usual call-by-value semantics of Python. \n```clojure\n(defn expensive-computation []\n  (time.sleep 10)\n  42)\n(setv xs [1 2 3 4 5])\n(map (constantly 42) xs)\n;; => [42, 42, 42, 42, 42]\n;; The interpreter has no way of knowing if this is a pure function and caching its results --\n;; would the user expect it to complete in 10 or 50 seconds?\n(map (constantly (expensive-computation)) xs)\n;; => [42, 42, 42, 42, 42]\n```\nconst is used quite regularly in functional programming and hurting its performance in return for (questionable) side-effectful use does not seem like a good tradeoff.. \nPerhaps do-constantly for the macro version under a different name?. I think a better comparison would be with Coconut or Dogelang - both also being \"compile-to-Python\" languages with nice landing pages. \nHaving side-by-side syntax examples up front showcasing some of the killer features would be great. \n(Threading macros? Multiline lambdas? Keyworded dictionaries without need for commas?)\nEven better a live interpreter like on the Coconut page, showing the direct transpilation between Hy -> Python. The current one on https://try-hy.appspot.com is awesome but not very functional :P \nHere's one for Clojurescript -> Javascript: http://app.klipse.tech/ \n. Yeah, it depends who the target audience is - for anyone who's not already familiar with Lisps the advantages of \"homoiconicity\" are notoriously hard to explain.\nThe ones I listed are more like immediate syntactical conveniences off the top of my head that someone coming from Python would be able to understand immediately? . ",
    "Wagk": "Similarly, is byte literal syntax supported?. Appears to be a duplicate of #1239. I wrote it in an attempt to implement (in :c foo)\n(Not very well I might add since I'm still trying to get the hang of it)\nIt should be mentioned that in isn't documented.. Closing because the root cause looks like inexperience more than anything. ",
    "chuckwondo": "I disagree, although it is confusing. The reason every? ends with a question mark is because that is the naming pattern for predicates in hy, and every? is indeed a predicate. However, some is not a predicate, which perhaps leads to confusion.\nThe some function returns the first \"truthy\" value (not necessarily True) returned by the specified predicate for an element of the specified collection, or None (not False) if there is no such value. If it were to instead return True if the specified predicate returned a \"truthy\" value, or False otherwise, then it would make sense to name it some?. However, some? may be implemented by using some:\n(defn some? [pred coll]\n  (not (none? (some pred coll))))\nI can't imagine why some was implemented as it is, but that's why it's not named some?.. ",
    "Immortalin": "A pretty landing page and website is important for adoption. Closing issues aggressively is not. Unless that is Hylang's plan is to forever remain an obscure niche language used by a few.. Languages need to be marketed to gain momentum.. Just leaving everything to \"the community\" won't be enough.. Yes but a docs page isn't quite the same caliber as e.g. Nim or Rust's landing pages. Being flashy may be gimmicky but it helps conversion rates.. Even Clojure has a dedicated landing page.. The relative path import could be better documented though.. Especially since . is dual-use. ",
    "Chaformbintrano": "hmm, you're right. ",
    "digikar99": "\nI think you forgot a trailing backtick. Did you try rendering the file?\n\nYup, I had forgotten. I copied it from a few lines below, and didn't take note of the closing back-tick. Thanks for pointing that out.\nNo, I had not tried rendering. I will keep \"build should be successful\" in mind for the future pull requests.\n\nLooks good, but the backtick fix should be in the first commit, and the underline fix should be in its own commit (if you want it in this PR). Try\ngit reset HEAD~\ngit commit --amend --patch\ngit commit -a\n\nI'll also keep \"commit separately for each task, no matter how small that task is\". Thanks for pointing out!\n\nI know you didn't introduce these mistakes, but, while you're changing those lines, this would be a great opportunity to fix them!\n\nSure, I have incorporated the suggested changes now. I have also added another attr-value example. \nAnother good-first-issue I can think of is: fixing the missing syntax-highlighting (or more generally, fixing the warnings in Sphinx build process) for some of the documentation. Example sections include as->. Should I create such an issue? . ",
    "TristanCacqueray": "I meant slices indeed, and actually didn't knew about cut either as I am still discovering hy. It's a really awesome project btw, thanks :-). Indeed. The new patch also added an assoc example.. Oh wow, I didn't realized you could set the value of a get expression like so :-)\nOk, let's keep this addition about get and cut since that is what i was looking for in the first place.. ",
    "superbobry": "Hello, I read about this PR in the dustycloud blogpost. \nThe idea of using macros to emulate yield from sounds wonderful. However, the implementation doesn't handle some edge cases described in the Formal Semantics section of PEP-380. Was this deliberate or is it just a proof-of-concept at the moment?\n. ",
    "charness": "(Docstring typo: missing the g in argument.)\n. "
}